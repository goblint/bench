/* Generated by Frama-C */
#line 106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compiler_types.h"
typedef signed char __s8;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef __s8 s8;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __u8 u8;
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __s16 s16;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __u16 u16;
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __s32 s32;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __u32 u32;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __s64 s64;
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __u64 u64;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/uapi/asm/posix_types_64.h"
typedef long __kernel_long_t;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 51  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_time64_t;
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 93  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 94  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef __u16 __le16;
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u16 __be16;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u32 __le32;
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u32 __be32;
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u64 __le64;
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u64 __be64;
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef unsigned int __poll_t;
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef u32 __kernel_dev_t;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned short umode_t;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef _Bool bool;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef s32 int32_t;
#line 109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u32 uint32_t;
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u64 sector_t;
#line 131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u64 blkcnt_t;
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u64 dma_addr_t;
#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned int gfp_t;
#line 154  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned int slab_flags_t;
#line 155  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned int fmode_t;
#line 156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u64 phys_addr_t;
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 170  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 170  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   s64 counter ;
};
#line 174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 181  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 185 
struct hlist_node;
#line 185  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 219  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
} __attribute__((__aligned__(8)));
#line 14  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ptp.i.aux"
struct task_struct;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/export.h"
struct module;
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/export.h"
struct kernel_symbol {
   int value_offset ;
   int name_offset ;
   int namespace_offset ;
};
#line 136  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 139 
struct file_system_type;
#line 83  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/printk.h"
struct ctl_table;
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
struct jump_entry;
#line 87 
struct static_key_mod;
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
union __anonunion_8 {
   unsigned long type ;
   struct jump_entry *entries ;
   struct static_key_mod *next ;
};
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
struct static_key {
   atomic_t enabled ;
   union __anonunion_8 __anonCompField_static_key_4 ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
struct jump_entry {
   s32 code ;
   s32 target ;
   long key ;
};
#line 346  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
struct static_key_true {
   struct static_key key ;
};
#line 350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
struct static_key_false {
   struct static_key key ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_debug.h"
union __anonunion_key_9 {
   struct static_key_true dd_key_true ;
   struct static_key_false dd_key_false ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_debug.h"
struct _ddebug {
   char *modname ;
   char *function ;
   char *filename ;
   char *format ;
   unsigned int lineno : 18 ;
   unsigned int flags : 8 ;
   union __anonunion_key_9 key ;
} __attribute__((__aligned__(8)));
#line 59 
struct device;
#line 65 
struct net_device;
#line 476  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/printk.h"
struct file_operations;
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/div64.h"
struct completion;
#line 88 
struct pt_regs;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bug.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/math64.h"
typedef __s64 time64_t;
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/time_types.h"
struct __kernel_timespec {
   __kernel_time64_t tv_sec ;
   long long tv_nsec ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/time64.h"
struct timespec64 {
   time64_t tv_sec ;
   long tv_nsec ;
};
#line 165 
struct old_timespec32;
#line 166 
struct pollfd;
#line 167 
enum timespec_type {
    TT_NONE = 0,
    TT_NATIVE = 1,
    TT_COMPAT = 2
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
struct __anonstruct_futex_27 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
union __anonunion_29 {
   struct __kernel_timespec *rmtp ;
   struct old_timespec32 *compat_rmtp ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
struct __anonstruct_nanosleep_28 {
   clockid_t clockid ;
   enum timespec_type type ;
   union __anonunion_29 __anonCompField___anonstruct_nanosleep_28_5 ;
   u64 expires ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
struct __anonstruct_poll_30 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
union __anonunion_26 {
   struct __anonstruct_futex_27 futex ;
   struct __anonstruct_nanosleep_28 nanosleep ;
   struct __anonstruct_poll_30 poll ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_26 __anonCompField_restart_block_6 ;
};
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/page_64.h"
struct page;
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/getorder.h"
struct mm_struct;
#line 49 
struct io_bitmap;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/ptrace.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/desc_defs.h"
struct desc_struct {
   u16 limit0 ;
   u16 base0 ;
   u16 base1 : 8 ;
   u16 type : 4 ;
   u16 s : 1 ;
   u16 dpl : 2 ;
   u16 p : 1 ;
   u16 limit1 : 4 ;
   u16 avl : 1 ;
   u16 l : 1 ;
   u16 d : 1 ;
   u16 g : 1 ;
   u16 base2 : 8 ;
} __attribute__((__packed__));
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/desc_defs.h"
typedef unsigned long pteval_t;
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pmdval_t;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pudval_t;
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_53 {
   pteval_t pte ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_53 pte_t;
#line 265  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 267  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_54 {
   pgdval_t pgd ;
};
#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_54 pgd_t;
#line 319  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pud_t_56 {
   pudval_t pud ;
};
#line 319  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pud_t_56 pud_t;
#line 345  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pmd_t_57 {
   pmdval_t pmd ;
};
#line 345  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pmd_t_57 pmd_t;
#line 505  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 519 
struct file;
#line 530 
struct seq_file;
#line 360  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/nospec-branch.h"
struct thread_struct;
#line 362 
struct cpumask;
#line 365 
struct vm_area_struct;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
struct __anonstruct_59 {
   u8 locked ;
   u8 pending ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
struct __anonstruct_60 {
   u16 locked_pending ;
   u16 tail ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
union __anonunion_58 {
   atomic_t val ;
   struct __anonstruct_59 __anonCompField___anonunion_58_7 ;
   struct __anonstruct_60 __anonCompField___anonunion_58_8 ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
struct qspinlock {
   union __anonunion_58 __anonCompField_qspinlock_9 ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qrwlock_types.h"
struct __anonstruct_62 {
   u8 wlocked ;
   u8 __lstate[3U] ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qrwlock_types.h"
union __anonunion_61 {
   atomic_t cnts ;
   struct __anonstruct_62 __anonCompField___anonunion_61_10 ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qrwlock_types.h"
struct qrwlock {
   union __anonunion_61 __anonCompField_qrwlock_11 ;
   arch_spinlock_t wait_lock ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/math_emu.h"
struct math_emu_info {
   long ___orig_eip ;
   struct pt_regs *regs ;
};
#line 2288  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/atomic-fallback.h"
typedef atomic64_t atomic_long_t;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/tracepoint-defs.h"
struct tracepoint_func {
   void *func ;
   void *data ;
   int prio ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/tracepoint-defs.h"
struct tracepoint {
   char *name ;
   struct static_key key ;
   int (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/tracepoint-defs.h"
typedef int tracepoint_ptr_t;
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/tracepoint-defs.h"
struct bpf_raw_event_map {
   struct tracepoint *tp ;
   void *bpf_func ;
   u32 num_args ;
   u32 writable_size ;
} __attribute__((__aligned__(32)));
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_90 {
   u64 rip ;
   u64 rdp ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_91 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
union __anonunion_89 {
   struct __anonstruct_90 __anonCompField___anonunion_89_17 ;
   struct __anonstruct_91 __anonCompField___anonunion_89_18 ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
union __anonunion_92 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_89 __anonCompField_fxregs_state_19 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_92 __anonCompField_fxregs_state_20 ;
} __attribute__((__aligned__(16)));
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
} __attribute__((__packed__));
#line 253  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 extended_state_area[0U] ;
} __attribute__((__packed__, __aligned__(64)));
#line 268  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};
#line 281  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned long avx512_timestamp ;
   union fpregs_state state ;
};
#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/orc_types.h"
struct orc_entry {
   s16 sp_offset ;
   s16 bp_offset ;
   unsigned int sp_reg : 4 ;
   unsigned int bp_reg : 4 ;
   unsigned int type : 2 ;
   unsigned int end : 1 ;
} __attribute__((__packed__));
#line 180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 479  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_95 {
   unsigned long seg ;
};
#line 479  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_95 mm_segment_t;
#line 485  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fsbase ;
   unsigned long gsbase ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct io_bitmap *io_bitmap ;
   unsigned long iopl_emul ;
   mm_segment_t addr_limit ;
   unsigned int sig_on_uaccess_err : 1 ;
   unsigned int uaccess_err : 1 ;
   struct fpu fpu ;
};
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/thread_info.h"
struct thread_info {
   unsigned long flags ;
   u32 status ;
};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bottom_half.h"
struct lockdep_map;
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__));
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
union __anonunion_96 {
   struct hlist_node hash_entry ;
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct lock_class_key {
   union __anonunion_96 __anonCompField_lock_class_key_23 ;
};
#line 68 
struct lock_trace;
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct lock_class {
   struct hlist_node hash_entry ;
   struct list_head lock_entry ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct lock_trace *usage_traces[9U] ;
   int name_version ;
   char *name ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char *name ;
   int cpu ;
   unsigned long ip ;
};
#line 226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int class_idx : 13 ;
   unsigned int irq_context : 2 ;
   unsigned int trylock : 1 ;
   unsigned int read : 2 ;
   unsigned int check : 1 ;
   unsigned int hardirqs_off : 1 ;
   unsigned int references : 12 ;
   unsigned int pin_count ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
struct __anonstruct_98 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
union __anonunion_97 {
   struct raw_spinlock rlock ;
   struct __anonstruct_98 __anonCompField___anonunion_97_24 ;
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_97 __anonCompField_spinlock_25 ;
};
#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
struct __anonstruct_rwlock_t_99 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
typedef struct __anonstruct_rwlock_t_99 rwlock_t;
#line 57  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
struct mutex;
#line 27  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
struct kmem_cache;
#line 48  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/thread.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 403  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_112 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 403  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_112 seqlock_t;
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timex.h"
typedef s32 old_time32_t;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/time32.h"
struct old_timespec32 {
   old_time32_t tv_sec ;
   s32 tv_nsec ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/wait.h"
struct wait_queue_head {
   spinlock_t lock ;
   struct list_head head ;
};
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/wait.h"
typedef struct wait_queue_head wait_queue_head_t;
#line 1133  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/wait.h"
struct __anonstruct_nodemask_t_113 {
   unsigned long bits[16U] ;
};
#line 1133  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/wait.h"
typedef struct __anonstruct_nodemask_t_113 nodemask_t;
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/tlbbatch.h"
struct arch_tlbflush_unmap_batch {
   struct cpumask cpumask ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct vmacache {
   u64 seqnum ;
   struct vm_area_struct *vmas[4U] ;
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct task_rss_stat {
   int events ;
   int count[4U] ;
};
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct mm_rss_stat {
   atomic_long_t count[4U] ;
};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct tlbflush_unmap_batch {
   struct arch_tlbflush_unmap_batch arch ;
   bool flush_required ;
   bool writable ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rbtree.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(8)));
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 125  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rbtree.h"
struct rb_root_cached {
   struct rb_root rb_root ;
   struct rb_node *rb_leftmost ;
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rwsem.h"
struct rw_semaphore {
   atomic_long_t count ;
   atomic_long_t owner ;
   struct optimistic_spin_queue osq ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/completion.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 120 
struct inode;
#line 121 
struct notifier_block;
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct ww_acquire_ctx;
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mutex.h"
struct mutex {
   atomic_long_t owner ;
   spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct list_head wait_list ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   struct ww_acquire_ctx *ww_ctx ;
   void *magic ;
};
#line 461  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jiffies.h"
typedef s64 ktime_t;
#line 249  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timekeeping.h"
struct system_device_crosststamp {
   ktime_t device ;
   ktime_t sys_realtime ;
   ktime_t sys_monoraw ;
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(struct timer_list *) ;
   u32 flags ;
   struct lockdep_map lockdep_map ;
};
#line 196 
struct hrtimer;
#line 197 
enum hrtimer_restart;
#line 221 
struct workqueue_struct;
#line 222 
struct work_struct;
#line 102  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 124  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/workqueue.h"
struct rcu_work {
   struct work_struct work ;
   struct callback_head rcu ;
   struct workqueue_struct *wq ;
};
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcu_segcblist.h"
struct rcu_segcblist {
   struct callback_head *head ;
   struct callback_head **tails[4U] ;
   unsigned long gp_seq[4U] ;
   atomic_long_t len ;
   long len_lazy ;
   u8 enabled ;
   u8 offloaded ;
};
#line 80 
struct srcu_struct;
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/srcu.h"
struct srcu_node;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/srcutree.h"
struct srcu_data {
   unsigned long srcu_lock_count[2U] ;
   unsigned long srcu_unlock_count[2U] ;
   spinlock_t lock ;
   struct rcu_segcblist srcu_cblist ;
   unsigned long srcu_gp_seq_needed ;
   unsigned long srcu_gp_seq_needed_exp ;
   bool srcu_cblist_invoking ;
   struct timer_list delay_work ;
   struct work_struct work ;
   struct callback_head srcu_barrier_head ;
   struct srcu_node *mynode ;
   unsigned long grpmask ;
   int cpu ;
   struct srcu_struct *ssp ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/srcutree.h"
struct srcu_node {
   spinlock_t lock ;
   unsigned long srcu_have_cbs[4U] ;
   unsigned long srcu_data_have_cbs[4U] ;
   unsigned long srcu_gp_seq_needed_exp ;
   struct srcu_node *srcu_parent ;
   int grplo ;
   int grphi ;
};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/srcutree.h"
struct srcu_struct {
   struct srcu_node node[521U] ;
   struct srcu_node *level[4U] ;
   struct mutex srcu_cb_mutex ;
   spinlock_t lock ;
   struct mutex srcu_gp_mutex ;
   unsigned int srcu_idx ;
   unsigned long srcu_gp_seq ;
   unsigned long srcu_gp_seq_needed ;
   unsigned long srcu_gp_seq_needed_exp ;
   unsigned long srcu_last_gp_end ;
   struct srcu_data *sda ;
   unsigned long srcu_barrier_seq ;
   struct mutex srcu_barrier_mutex ;
   struct completion srcu_barrier_completion ;
   atomic_t srcu_barrier_cpu_cnt ;
   struct delayed_work work ;
   struct lockdep_map dep_map ;
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};
#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/notifier.h"
struct raw_notifier_head {
   struct notifier_block *head ;
};
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 57 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct __anonstruct_126 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct __anonstruct_127 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
union __anonunion_125 {
   struct __anonstruct_126 __anonCompField___anonunion_125_28 ;
   struct __anonstruct_127 __anonCompField___anonunion_125_29 ;
};
#line 61 
struct uprobe;
#line 61 
struct return_instance;
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_125 __anonCompField_uprobe_task_30 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 83  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct return_instance {
   struct uprobe *uprobe ;
   unsigned long func ;
   unsigned long stack ;
   unsigned long orig_ret_vaddr ;
   bool chained ;
   struct return_instance *next ;
};
#line 98 
struct xol_area;
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 140 
struct ldt_struct;
#line 140 
struct vdso_image;
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct __anonstruct_mm_context_t_128 {
   u64 ctx_id ;
   atomic64_t tlb_gen ;
   struct rw_semaphore ldt_usr_sem ;
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   struct vdso_image *vdso_image ;
   atomic_t perf_rdpmc_allowed ;
   u16 pkey_allocation_map ;
   s16 execute_only_pkey ;
   void *bd_addr ;
};
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
typedef struct __anonstruct_mm_context_t_128 mm_context_t;
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct address_space;
#line 67 
struct mem_cgroup;
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_130 {
   struct list_head lru ;
   struct address_space *mapping ;
   unsigned long index ;
   unsigned long private ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_131 {
   dma_addr_t dma_addr ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_134 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_133 {
   struct list_head slab_list ;
   struct __anonstruct_134 __anonCompField___anonunion_133_33 ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_136 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_135 {
   void *s_mem ;
   unsigned long counters ;
   struct __anonstruct_136 __anonCompField___anonunion_135_35 ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_132 {
   union __anonunion_133 __anonCompField___anonstruct_132_34 ;
   struct kmem_cache *slab_cache ;
   void *freelist ;
   union __anonunion_135 __anonCompField___anonstruct_132_36 ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_137 {
   unsigned long compound_head ;
   unsigned char compound_dtor ;
   unsigned char compound_order ;
   atomic_t compound_mapcount ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_138 {
   unsigned long _compound_pad_1 ;
   unsigned long _compound_pad_2 ;
   struct list_head deferred_list ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_140 {
   struct mm_struct *pt_mm ;
   atomic_t pt_frag_refcount ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_139 {
   unsigned long _pt_pad_1 ;
   pgtable_t pmd_huge_pte ;
   unsigned long _pt_pad_2 ;
   union __anonunion_140 __anonCompField___anonstruct_139_40 ;
   spinlock_t *ptl ;
};
#line 68 
struct dev_pagemap;
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_141 {
   struct dev_pagemap *pgmap ;
   void *zone_device_data ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_129 {
   struct __anonstruct_130 __anonCompField___anonunion_129_31 ;
   struct __anonstruct_131 __anonCompField___anonunion_129_32 ;
   struct __anonstruct_132 __anonCompField___anonunion_129_37 ;
   struct __anonstruct_137 __anonCompField___anonunion_129_38 ;
   struct __anonstruct_138 __anonCompField___anonunion_129_39 ;
   struct __anonstruct_139 __anonCompField___anonunion_129_41 ;
   struct __anonstruct_141 __anonCompField___anonunion_129_42 ;
   struct callback_head callback_head ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_142 {
   atomic_t _mapcount ;
   unsigned int page_type ;
   unsigned int active ;
   int units ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct page {
   unsigned long flags ;
   union __anonunion_129 __anonCompField_page_43 ;
   union __anonunion_142 __anonCompField_page_44 ;
   atomic_t _refcount ;
   struct mem_cgroup *mem_cgroup ;
} __attribute__((__aligned__(16)));
#line 278  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct userfaultfd_ctx;
#line 278  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct vm_userfaultfd_ctx {
   struct userfaultfd_ctx *ctx ;
};
#line 292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct __anonstruct_shared_143 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 292 
struct anon_vma;
#line 292 
struct vm_operations_struct;
#line 292 
struct mempolicy;
#line 292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_143 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   atomic_long_t swap_readahead_info ;
   struct mempolicy *vm_policy ;
   struct vm_userfaultfd_ctx vm_userfaultfd_ctx ;
} __attribute__((__designated_init__));
#line 358  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 363  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 368 
struct kioctx_table;
#line 370 
struct linux_binfmt;
#line 370 
struct user_namespace;
#line 370 
struct mmu_notifier_mm;
#line 370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct __anonstruct_144 {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u64 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long mmap_compat_base ;
   unsigned long mmap_compat_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t membarrier_state ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t pgtables_bytes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   atomic64_t pinned_vm ;
   unsigned long data_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   spinlock_t arg_lock ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct user_namespace *user_ns ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   atomic_t tlb_flush_pending ;
   bool tlb_flush_batched ;
   struct uprobes_state uprobes_state ;
   atomic_long_t hugetlb_usage ;
   struct work_struct async_put_work ;
} __attribute__((__designated_init__));
#line 370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct mm_struct {
   struct __anonstruct_144 __anonCompField_mm_struct_45 ;
   unsigned long cpu_bitmap[] ;
};
#line 642 
struct vm_fault;
#line 643  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
typedef unsigned int vm_fault_t;
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct free_area {
   struct list_head free_list[6U] ;
   unsigned long nr_free ;
};
#line 158 
struct pglist_data;
#line 168  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct zone_padding {
   char x[0U] ;
} __attribute__((__aligned__(4096)));
#line 285  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct zone_reclaim_stat {
   unsigned long recent_rotated[2U] ;
   unsigned long recent_scanned[2U] ;
};
#line 304  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct lruvec {
   struct list_head lists[5U] ;
   struct zone_reclaim_stat reclaim_stat ;
   atomic_long_t inactive_age ;
   unsigned long refaults ;
   unsigned long flags ;
   struct pglist_data *pgdat ;
};
#line 316  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
typedef unsigned int isolate_mode_t;
#line 340  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct per_cpu_pages {
   int count ;
   int high ;
   int batch ;
   struct list_head lists[3U] ;
};
#line 349  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct per_cpu_pageset {
   struct per_cpu_pages pcp ;
   s8 expire ;
   u16 vm_numa_stat_diff[6U] ;
   s8 stat_threshold ;
   s8 vm_stat_diff[13U] ;
};
#line 361  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct per_cpu_nodestat {
   s8 stat_threshold ;
   s8 vm_node_stat_diff[32U] ;
};
#line 365 
enum zone_type {
    ZONE_DMA = 0,
    ZONE_DMA32 = 1,
    ZONE_NORMAL = 2,
    ZONE_MOVABLE = 3,
    ZONE_DEVICE = 4,
    __MAX_NR_ZONES = 5
};
#line 432  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct zone {
   unsigned long _watermark[3U] ;
   unsigned long watermark_boost ;
   unsigned long nr_reserved_highatomic ;
   long lowmem_reserve[5U] ;
   int node ;
   struct pglist_data *zone_pgdat ;
   struct per_cpu_pageset *pageset ;
   unsigned long zone_start_pfn ;
   atomic_long_t managed_pages ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   char *name ;
   unsigned long nr_isolate_pageblock ;
   seqlock_t span_seqlock ;
   int initialized ;
   struct zone_padding _pad1_ ;
   struct free_area free_area[11U] ;
   unsigned long flags ;
   spinlock_t lock ;
   struct zone_padding _pad2_ ;
   unsigned long percpu_drift_mark ;
   unsigned long compact_cached_free_pfn ;
   unsigned long compact_cached_migrate_pfn[2U] ;
   unsigned long compact_init_migrate_pfn ;
   unsigned long compact_init_free_pfn ;
   unsigned int compact_considered ;
   unsigned int compact_defer_shift ;
   int compact_order_failed ;
   bool compact_blockskip_flush ;
   bool contiguous ;
   struct zone_padding _pad3_ ;
   atomic_long_t vm_stat[13U] ;
   atomic_long_t vm_numa_stat[6U] ;
} __attribute__((__aligned__(4096)));
#line 665  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct zoneref {
   struct zone *zone ;
   int zone_idx ;
};
#line 684  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct zonelist {
   struct zoneref _zonerefs[5121U] ;
};
#line 694  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct deferred_split {
   spinlock_t split_queue_lock ;
   struct list_head split_queue ;
   unsigned long split_queue_len ;
};
#line 710  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
struct pglist_data {
   struct zone node_zones[5U] ;
   struct zonelist node_zonelists[2U] ;
   int nr_zones ;
   spinlock_t node_size_lock ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   wait_queue_head_t kswapd_wait ;
   wait_queue_head_t pfmemalloc_wait ;
   struct task_struct *kswapd ;
   int kswapd_order ;
   enum zone_type kswapd_classzone_idx ;
   int kswapd_failures ;
   int kcompactd_max_order ;
   enum zone_type kcompactd_classzone_idx ;
   wait_queue_head_t kcompactd_wait ;
   struct task_struct *kcompactd ;
   unsigned long totalreserve_pages ;
   unsigned long min_unmapped_pages ;
   unsigned long min_slab_pages ;
   struct zone_padding _pad1_ ;
   spinlock_t lru_lock ;
   unsigned long first_deferred_pfn ;
   struct deferred_split deferred_split_queue ;
   struct lruvec __lruvec ;
   unsigned long flags ;
   struct zone_padding _pad2_ ;
   struct per_cpu_nodestat *per_cpu_nodestats ;
   atomic_long_t vm_stat[32U] ;
};
#line 824 
struct resource;
#line 825 
struct vmem_altmap;
#line 282  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 440  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/io.h"
struct fwnode_operations;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fwnode.h"
struct fwnode_handle {
   struct fwnode_handle *secondary ;
   struct fwnode_operations *ops ;
   struct device *dev ;
};
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fwnode.h"
struct fwnode_endpoint {
   unsigned int port ;
   unsigned int id ;
   struct fwnode_handle *local_fwnode ;
};
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fwnode.h"
struct fwnode_reference_args {
   struct fwnode_handle *fwnode ;
   unsigned int nargs ;
   u64 args[8U] ;
};
#line 110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fwnode.h"
struct fwnode_operations {
   struct fwnode_handle *(*get)(struct fwnode_handle *) ;
   void (*put)(struct fwnode_handle *) ;
   bool (*device_is_available)(struct fwnode_handle *) ;
   void *(*device_get_match_data)(struct fwnode_handle *, struct device *) ;
   bool (*property_present)(struct fwnode_handle *, char *) ;
   int (*property_read_int_array)(struct fwnode_handle *, char *, unsigned int , void *, size_t ) ;
   int (*property_read_string_array)(struct fwnode_handle *, char *, char **, size_t ) ;
   char *(*get_name)(struct fwnode_handle *) ;
   char *(*get_name_prefix)(struct fwnode_handle *) ;
   struct fwnode_handle *(*get_parent)(struct fwnode_handle *) ;
   struct fwnode_handle *(*get_next_child_node)(struct fwnode_handle *, struct fwnode_handle *) ;
   struct fwnode_handle *(*get_named_child_node)(struct fwnode_handle *, char *) ;
   int (*get_reference_args)(struct fwnode_handle *, char *, char *, unsigned int , unsigned int , struct fwnode_reference_args *) ;
   struct fwnode_handle *(*graph_get_next_endpoint)(struct fwnode_handle *, struct fwnode_handle *) ;
   struct fwnode_handle *(*graph_get_remote_endpoint)(struct fwnode_handle *) ;
   struct fwnode_handle *(*graph_get_port_parent)(struct fwnode_handle *) ;
   int (*graph_parse_endpoint)(struct fwnode_handle *, struct fwnode_endpoint *) ;
   int (*add_links)(struct fwnode_handle *, struct device *) ;
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/llist.h"
struct llist_node;
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/vmalloc.h"
struct vm_struct {
   struct vm_struct *next ;
   void *addr ;
   unsigned long size ;
   unsigned long flags ;
   struct page **pages ;
   unsigned int nr_pages ;
   phys_addr_t phys_addr ;
   void *caller ;
};
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/smp.h"
struct __call_single_data {
   struct llist_node llist ;
   void (*func)(void *) ;
   void *info ;
   unsigned int flags ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/arch_topology.h"
struct device_node;
#line 623  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/gfp.h"
struct percpu_ref;
#line 624  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/gfp.h"
typedef void percpu_ref_func_t(struct percpu_ref *);
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic : 1 ;
   bool allow_reinit : 1 ;
   struct callback_head rcu ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/shrinker.h"
struct shrink_control {
   gfp_t gfp_mask ;
   int nid ;
   unsigned long nr_to_scan ;
   unsigned long nr_scanned ;
   struct mem_cgroup *memcg ;
};
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   long batch ;
   int seeks ;
   unsigned int flags ;
   struct list_head list ;
   int id ;
   atomic_long_t *nr_deferred ;
};
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ioport.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char *name ;
   unsigned long flags ;
   unsigned long desc ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memremap.h"
struct vmem_altmap {
   unsigned long base_pfn ;
   unsigned long end_pfn ;
   unsigned long reserve ;
   unsigned long free ;
   unsigned long align ;
   unsigned long alloc ;
};
#line 26 
enum memory_type {
    MEMORY_DEVICE_PRIVATE = 1,
    MEMORY_DEVICE_FS_DAX = 2,
    MEMORY_DEVICE_DEVDAX = 3,
    MEMORY_DEVICE_PCI_P2PDMA = 4
};
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memremap.h"
struct dev_pagemap_ops {
   void (*page_free)(struct page *) ;
   void (*kill)(struct dev_pagemap *) ;
   void (*cleanup)(struct dev_pagemap *) ;
   vm_fault_t (*migrate_to_ram)(struct vm_fault *) ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memremap.h"
struct dev_pagemap {
   struct vmem_altmap altmap ;
   struct resource res ;
   struct percpu_ref *ref ;
   struct percpu_ref internal_ref ;
   struct completion done ;
   enum memory_type type ;
   unsigned int flags ;
   struct dev_pagemap_ops *ops ;
};
#line 176 
struct file_ra_state;
#line 177 
struct user_struct;
#line 178 
struct writeback_control;
#line 179 
struct bdi_writeback;
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/refcount.h"
struct refcount_struct {
   atomic_t refs ;
};
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/refcount.h"
typedef struct refcount_struct refcount_t;
#line 305 
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_TGID = 1,
    PIDTYPE_PGID = 2,
    PIDTYPE_SID = 3,
    PIDTYPE_MAX = 4
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pid.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pid.h"
struct pid {
   refcount_t count ;
   unsigned int level ;
   struct hlist_head tasks[4U] ;
   wait_queue_head_t wait_pidfd ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
struct __anonstruct_kuid_t_272 {
   uid_t val ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_272 kuid_t;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
struct __anonstruct_kgid_t_273 {
   gid_t val ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_273 kgid_t;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rhashtable-types.h"
struct rhash_head {
   struct rhash_head *next ;
};
#line 25 
struct bucket_table;
#line 33 
struct rhashtable;
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rhashtable-types.h"
struct rhashtable_compare_arg {
   struct rhashtable *ht ;
   void *key ;
};
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rhashtable-types.h"
struct rhashtable_params {
   u16 nelem_hint ;
   u16 key_len ;
   u16 key_offset ;
   u16 head_offset ;
   unsigned int max_size ;
   u16 min_size ;
   bool automatic_shrinking ;
   u32 (*hashfn)(void *, u32 , u32 ) ;
   u32 (*obj_hashfn)(void *, u32 , u32 ) ;
   int (*obj_cmpfn)(struct rhashtable_compare_arg *, void *) ;
};
#line 81  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rhashtable-types.h"
struct rhashtable {
   struct bucket_table *tbl ;
   unsigned int key_len ;
   unsigned int max_elems ;
   struct rhashtable_params p ;
   bool rhlist ;
   struct work_struct run_work ;
   struct mutex mutex ;
   spinlock_t lock ;
   atomic_t nelems ;
};
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/sem.h"
struct sem_undo_list;
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 83  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timerqueue.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root_cached rb_root ;
};
#line 60 
struct hrtimer_clock_base;
#line 61 
struct hrtimer_cpu_base;
#line 80 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};
#line 117  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hrtimer.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   u8 state ;
   u8 is_rel ;
   u8 is_soft ;
   u8 is_hard ;
};
#line 158  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   unsigned int index ;
   clockid_t clockid ;
   seqcount_t seq ;
   struct hrtimer *running ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
} __attribute__((__aligned__(64)));
#line 213  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   unsigned int hres_active : 1 ;
   unsigned int in_hrtirq : 1 ;
   unsigned int hang_detected : 1 ;
   unsigned int softirq_activated : 1 ;
   unsigned int nr_events ;
   unsigned short nr_retries ;
   unsigned short nr_hangs ;
   unsigned int max_hang_time ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   ktime_t softirq_expires_next ;
   struct hrtimer *softirq_next_timer ;
   struct hrtimer_clock_base clock_base[8U] ;
} __attribute__((__aligned__(64)));
#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/seccomp.h"
struct seccomp_filter;
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/latencytop.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/types.h"
struct task_cputime {
   u64 stime ;
   u64 utime ;
   unsigned long long sum_exec_runtime ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_276 {
   unsigned long sig[1U] ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_276 sigset_t;
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/signal.h"
typedef void __signalfn_t(int );
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_277 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_278 {
   __kernel_timer_t _tid ;
   int _overrun ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_279 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_280 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_283 {
   char _dummy_bnd[8U] ;
   void *_lower ;
   void *_upper ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_pkey_284 {
   char _dummy_pkey[8U] ;
   __u32 _pkey ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
union __anonunion_282 {
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_283 _addr_bnd ;
   struct __anonstruct__addr_pkey_284 _addr_pkey ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_281 {
   void *_addr ;
   union __anonunion_282 __anonCompField___anonstruct__sigfault_281_47 ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_285 {
   long _band ;
   int _fd ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_286 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
union __sifields {
   struct __anonstruct__kill_277 _kill ;
   struct __anonstruct__timer_278 _timer ;
   struct __anonstruct__rt_279 _rt ;
   struct __anonstruct__sigchld_280 _sigchld ;
   struct __anonstruct__sigfault_281 _sigfault ;
   struct __anonstruct__sigpoll_285 _sigpoll ;
   struct __anonstruct__sigsys_286 _sigsys ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct __anonstruct_291 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __sifields _sifields ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct kernel_siginfo {
   struct __anonstruct_291 __anonCompField_kernel_siginfo_50 ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
typedef struct kernel_siginfo kernel_siginfo_t;
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/task_io_accounting.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/posix-timers.h"
struct posix_cputimer_base {
   u64 nextevt ;
   struct timerqueue_head tqhead ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/posix-timers.h"
struct posix_cputimers {
   struct posix_cputimer_base bases[3U] ;
   unsigned int timers_active ;
   unsigned int expiry_active ;
};
#line 193 
struct signal_struct;
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/rseq.h"
union __anonunion_rseq_cs_296 {
   __u64 ptr64 ;
   __u64 ptr ;
};
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/rseq.h"
struct rseq {
   __u32 cpu_id_start ;
   __u32 cpu_id ;
   union __anonunion_rseq_cs_296 rseq_cs ;
   __u32 flags ;
} __attribute__((__aligned__(32)));
#line 146 
struct audit_context;
#line 147 
struct backing_dev_info;
#line 148 
struct bio_list;
#line 149 
struct blk_plug;
#line 150 
struct capture_control;
#line 151 
struct cfs_rq;
#line 152 
struct fs_struct;
#line 153 
struct futex_pi_state;
#line 154 
struct io_context;
#line 155 
struct nameidata;
#line 156 
struct nsproxy;
#line 158 
struct pipe_inode_info;
#line 160 
struct reclaim_state;
#line 161 
struct robust_list_head;
#line 166 
struct sighand_struct;
#line 167 
struct task_delay_info;
#line 168 
struct task_group;
#line 242  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct prev_cputime {
   u64 utime ;
   u64 stime ;
   raw_spinlock_t lock ;
};
#line 290  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 352  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct util_est {
   unsigned int enqueued ;
   unsigned int ewma ;
} __attribute__((__aligned__(8)));
#line 401  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_avg {
   u64 last_update_time ;
   u64 load_sum ;
   u64 runnable_load_sum ;
   u32 util_sum ;
   u32 period_contrib ;
   unsigned long load_avg ;
   unsigned long runnable_load_avg ;
   unsigned long util_avg ;
   struct util_est util_est ;
} __attribute__((__aligned__(64)));
#line 413  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 449  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   unsigned long runnable_weight ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 486 
struct rt_rq;
#line 486  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   unsigned short on_rq ;
   unsigned short on_list ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
} __attribute__((__designated_init__));
#line 504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   u64 dl_density ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   unsigned int dl_throttled : 1 ;
   unsigned int dl_boosted : 1 ;
   unsigned int dl_yielded : 1 ;
   unsigned int dl_non_contending : 1 ;
   unsigned int dl_overrun : 1 ;
   struct hrtimer dl_timer ;
   struct hrtimer inactive_timer ;
};
#line 600  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct uclamp_se {
   unsigned int value : 11 ;
   unsigned int bucket_id : 3 ;
   unsigned int active : 1 ;
   unsigned int user_defined : 1 ;
};
#line 625  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 629 
struct sched_class;
#line 629 
struct cred;
#line 629 
struct key;
#line 629 
struct files_struct;
#line 629 
struct rt_mutex_waiter;
#line 629 
struct css_set;
#line 629 
struct compat_robust_list_head;
#line 629 
struct numa_group;
#line 629  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
union __anonunion_298 {
   refcount_t rcu_users ;
   struct callback_head rcu ;
};
#line 629 
struct kcov;
#line 629 
struct request_queue;
#line 629  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct task_struct {
   struct thread_info thread_info ;
   long state ;
   void *stack ;
   refcount_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   unsigned int cpu ;
   unsigned int wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   struct task_struct *last_wakee ;
   int recent_used_cpu ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct uclamp_se uclamp_req[2U] ;
   struct uclamp_se uclamp[2U] ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t *cpus_ptr ;
   cpumask_t cpus_mask ;
   unsigned long rcu_tasks_nvcsw ;
   u8 rcu_tasks_holdout ;
   u8 rcu_tasks_idx ;
   int rcu_tasks_idle_cpu ;
   struct list_head rcu_tasks_holdout_list ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct vmacache vmacache ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int sched_reset_on_fork : 1 ;
   unsigned int sched_contributes_to_load : 1 ;
   unsigned int sched_migrated : 1 ;
   unsigned int sched_remote_wakeup : 1 ;
   unsigned int sched_psi_wake_requeue : 1 ;
   unsigned int  ;
   unsigned int in_execve : 1 ;
   unsigned int in_iowait : 1 ;
   unsigned int restore_sigmask : 1 ;
   unsigned int in_user_fault : 1 ;
   unsigned int brk_randomized : 1 ;
   unsigned int no_cgroup_migration : 1 ;
   unsigned int frozen : 1 ;
   unsigned int use_memdelay : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid *thread_pid ;
   struct hlist_node pid_links[4U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   u64 utime ;
   u64 stime ;
   u64 gtime ;
   struct prev_cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 start_boottime ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct posix_cputimers posix_cputimers ;
   struct cred *ptracer_cred ;
   struct cred *real_cred ;
   struct cred *cred ;
   struct key *cached_requested_key ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   unsigned long last_switch_time ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   unsigned int sas_ss_flags ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root_cached pi_waiters ;
   struct task_struct *pi_top_task ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   int non_block_count ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   unsigned int in_ubsan ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   struct capture_control *capture_control ;
   unsigned long ptrace_message ;
   kernel_siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   unsigned int psi_flags ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   u64 acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   u32 closid ;
   u32 rmid ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct mutex futex_exit_mutex ;
   unsigned int futex_state ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_prev ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct rseq *rseq ;
   u32 rseq_sig ;
   unsigned long rseq_event_mask ;
   struct tlbflush_unmap_batch tlb_ubc ;
   union __anonunion_298 __anonCompField_task_struct_52 ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   unsigned int fail_nth ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   u64 timer_slack_ns ;
   u64 default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   int curr_ret_depth ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   unsigned int kcov_mode ;
   unsigned int kcov_size ;
   void *kcov_area ;
   struct kcov *kcov ;
   u64 kcov_handle ;
   int kcov_sequence ;
   struct mem_cgroup *memcg_in_oom ;
   gfp_t memcg_oom_gfp_mask ;
   int memcg_oom_order ;
   unsigned int memcg_nr_pages_over_high ;
   struct mem_cgroup *active_memcg ;
   struct request_queue *throttle_queue ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct task_struct *oom_reaper_list ;
   struct vm_struct *stack_vm_area ;
   refcount_t stack_refcount ;
   int patch_state ;
   void *security ;
   struct thread_struct thread ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/extable.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
   int handler ;
};
#line 417  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
struct vm_fault {
   struct vm_area_struct *vma ;
   unsigned int flags ;
   gfp_t gfp_mask ;
   unsigned long pgoff ;
   unsigned long address ;
   pmd_t *pmd ;
   pud_t *pud ;
   pte_t orig_pte ;
   struct page *cow_page ;
   struct mem_cgroup *memcg ;
   struct page *page ;
   pte_t *pte ;
   spinlock_t *ptl ;
   pgtable_t prealloc_pte ;
};
#line 448 
enum page_entry_size {
    PE_SIZE_PTE = 0,
    PE_SIZE_PMD = 1,
    PE_SIZE_PUD = 2
};
#line 467  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*split)(struct vm_area_struct *, unsigned long ) ;
   int (*mremap)(struct vm_area_struct *) ;
   vm_fault_t (*fault)(struct vm_fault *) ;
   vm_fault_t (*huge_fault)(struct vm_fault *, enum page_entry_size ) ;
   void (*map_pages)(struct vm_fault *, unsigned long , unsigned long ) ;
   unsigned long (*pagesize)(struct vm_area_struct *) ;
   vm_fault_t (*page_mkwrite)(struct vm_fault *) ;
   vm_fault_t (*pfn_mkwrite)(struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_bl.h"
struct hlist_bl_node;
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_bl.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockref.h"
struct __anonstruct_387 {
   spinlock_t lock ;
   int count ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockref.h"
union __anonunion_386 {
   struct __anonstruct_387 __anonCompField___anonunion_386_53 ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockref.h"
struct lockref {
   union __anonunion_386 __anonCompField_lockref_54 ;
};
#line 78  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/stringhash.h"
struct path;
#line 79 
struct vfsmount;
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
struct __anonstruct_389 {
   u32 hash ;
   u32 len ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
union __anonunion_388 {
   struct __anonstruct_389 __anonCompField___anonunion_388_55 ;
   u64 hash_len ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
struct qstr {
   union __anonunion_388 __anonCompField_qstr_56 ;
   unsigned char *name ;
};
#line 89 
struct dentry_operations;
#line 89 
struct super_block;
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
union __anonunion_390 {
   struct list_head d_lru ;
   wait_queue_head_t *d_wait ;
};
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
union __anonunion_d_u_391 {
   struct hlist_node d_alias ;
   struct hlist_bl_node d_in_lookup_hash ;
   struct callback_head d_rcu ;
};
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   union __anonunion_390 __anonCompField_dentry_57 ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_391 d_u ;
} __attribute__((__designated_init__));
#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry *, struct qstr *) ;
   int (*d_compare)(struct dentry *, unsigned int , char *, struct qstr *) ;
   int (*d_delete)(struct dentry *) ;
   int (*d_init)(struct dentry *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct path *, bool ) ;
   struct dentry *(*d_real)(struct dentry *, struct inode *) ;
} __attribute__((__aligned__(64)));
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/path.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
} __attribute__((__designated_init__));
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/stat.h"
struct kstat {
   u32 result_mask ;
   umode_t mode ;
   unsigned int nlink ;
   uint32_t blksize ;
   u64 attributes ;
   u64 attributes_mask ;
   u64 ino ;
   dev_t dev ;
   dev_t rdev ;
   kuid_t uid ;
   kgid_t gid ;
   loff_t size ;
   struct timespec64 atime ;
   struct timespec64 mtime ;
   struct timespec64 ctime ;
   struct timespec64 btime ;
   u64 blocks ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_lru.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_lru.h"
struct list_lru_memcg {
   struct callback_head rcu ;
   struct list_lru_one *lru[0U] ;
};
#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
   long nr_items ;
} __attribute__((__aligned__(64)));
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
   int shrinker_id ;
   bool memcg_aware ;
};
#line 292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/xarray.h"
struct xarray {
   spinlock_t xa_lock ;
   gfp_t xa_flags ;
   void *xa_head ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fiemap.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 39 
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2,
    MIGRATE_SYNC_NO_COPY = 3
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcuwait.h"
struct rcuwait {
   struct task_struct *task ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcu_sync.h"
struct rcu_sync {
   int gp_state ;
   int gp_count ;
   wait_queue_head_t gp_wait ;
   struct callback_head cb_head ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/percpu-rwsem.h"
struct percpu_rw_semaphore {
   struct rcu_sync rss ;
   unsigned int *read_count ;
   struct rw_semaphore rw_sem ;
   struct rcuwait writer ;
   int readers_block ;
};
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/delayed_call.h"
struct delayed_call {
   void (*fn)(void *) ;
   void *arg ;
};
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/uuid.h"
struct __anonstruct_uuid_t_409 {
   __u8 b[16U] ;
};
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/uuid.h"
typedef struct __anonstruct_uuid_t_409 uuid_t;
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uuid.h"
typedef u32 errseq_t;
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iocontext.h"
union __anonunion_410 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iocontext.h"
union __anonunion_411 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iocontext.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion_410 __anonCompField_io_cq_60 ;
   union __anonunion_411 __anonCompField_io_cq_61 ;
   unsigned int flags ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct xarray icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 286  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fs.h"
struct bio;
#line 287 
struct export_operations;
#line 288 
struct hd_geometry;
#line 289 
struct iovec;
#line 290 
struct kiocb;
#line 291 
struct kobject;
#line 292 
struct poll_table_struct;
#line 293 
struct kstatfs;
#line 294 
struct swap_info_struct;
#line 295 
struct iov_iter;
#line 296 
struct fscrypt_info;
#line 297 
struct fscrypt_operations;
#line 298 
struct fsverity_info;
#line 299 
struct fsverity_operations;
#line 300 
struct fs_context;
#line 301 
struct fs_parameter_description;
#line 224  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec64 ia_atime ;
   struct timespec64 ia_mtime ;
   struct timespec64 ia_ctime ;
   struct file *ia_file ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/percpu_counter.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 214  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 215 
struct kqid;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/projid.h"
struct __anonstruct_kprojid_t_412 {
   projid_t val ;
};
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_412 kprojid_t;
#line 180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
typedef long long qsize_t;
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
union __anonunion_413 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct kqid {
   union __anonunion_413 __anonCompField_kqid_62 ;
   enum quota_type type ;
};
#line 205  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time64_t dqb_btime ;
   time64_t dqb_itime ;
};
#line 216 
struct quota_format_type;
#line 222  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 294  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   spinlock_t dq_dqb_lock ;
   atomic_t dq_count ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 310  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
   int (*get_next_id)(struct super_block *, struct kqid *) ;
};
#line 322  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
   int (*get_inode_usage)(struct inode *, qsize_t *) ;
   int (*get_next_id)(struct super_block *, struct kqid *) ;
};
#line 343  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 395  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 409  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 415  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 428  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};
#line 443  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 518  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct rw_semaphore dqio_sem ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops *ops[3U] ;
};
#line 538 
enum rw_hint {
    WRITE_LIFE_NOT_SET = 0,
    WRITE_LIFE_NONE = 1,
    WRITE_LIFE_SHORT = 2,
    WRITE_LIFE_MEDIUM = 3,
    WRITE_LIFE_LONG = 4,
    WRITE_LIFE_EXTREME = 5
};
#line 318  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
   u16 ki_hint ;
   u16 ki_ioprio ;
   unsigned int ki_cookie ;
};
#line 339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_arg_415 {
   char *buf ;
   void *data ;
};
#line 339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_414 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_415 arg ;
   int error ;
};
#line 339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_414 read_descriptor_t;
#line 362  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   bool (*isolate_page)(struct page *, isolate_mode_t ) ;
   void (*putback_page)(struct page *) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};
#line 445  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct xarray i_pages ;
   gfp_t gfp_mask ;
   atomic_t i_mmap_writable ;
   atomic_t nr_thps ;
   struct rb_root_cached i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrexceptional ;
   unsigned long writeback_index ;
   struct address_space_operations *a_ops ;
   unsigned long flags ;
   errseq_t wb_err ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
} __attribute__((__designated_init__, __aligned__(8)));
#line 473 
struct hd_struct;
#line 473 
struct gendisk;
#line 473  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   u8 bd_partno ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct backing_dev_info *bd_bdi ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
} __attribute__((__designated_init__));
#line 587 
struct posix_acl;
#line 614 
struct fsnotify_mark_connector;
#line 628 
struct inode_operations;
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_418 {
   unsigned int i_nlink ;
   unsigned int __i_nlink ;
};
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_419 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_420 {
   struct file_operations *i_fop ;
   void (*free_inode)(struct inode *) ;
};
#line 628 
struct file_lock_context;
#line 628 
struct cdev;
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_421 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
   unsigned int i_dir_seq ;
};
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_418 __anonCompField_inode_63 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec64 i_atime ;
   struct timespec64 i_mtime ;
   struct timespec64 i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   u8 i_blkbits ;
   u8 i_write_hint ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct rw_semaphore i_rwsem ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_io_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   struct list_head i_wb_list ;
   union __anonunion_419 __anonCompField_inode_64 ;
   atomic64_t i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   union __anonunion_420 __anonCompField_inode_65 ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_421 __anonCompField_inode_66 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct fsnotify_mark_connector *i_fsnotify_marks ;
   struct fscrypt_info *i_crypt_info ;
   struct fsverity_info *i_verity_info ;
   void *i_private ;
} __attribute__((__designated_init__));
#line 904  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 915  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 935  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_f_u_422 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 935  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file {
   union __anonunion_f_u_422 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations *f_op ;
   spinlock_t f_lock ;
   enum rw_hint f_write_hint ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   errseq_t f_wb_err ;
} __attribute__((__designated_init__, __aligned__(4)));
#line 988  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
typedef void *fl_owner_t;
#line 1026 
struct file_lock;
#line 1029  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};
#line 1034  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct lock_manager_operations {
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};
#line 1052 
struct net;
#line 1058 
struct nlm_lockowner;
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nfs_fs_i.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 15 
struct nfs4_lock_state;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 1079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct fasync_struct;
#line 1079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct __anonstruct_afs_424 {
   struct list_head link ;
   int state ;
   unsigned int debug_id ;
};
#line 1079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_fl_u_423 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_424 afs ;
};
#line 1079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_lock {
   struct file_lock *fl_blocker ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_blocked_requests ;
   struct list_head fl_blocked_member ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_423 fl_u ;
} __attribute__((__designated_init__));
#line 1117  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1331  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct fasync_struct {
   rwlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1418  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct sb_writers {
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct percpu_rw_semaphore rw_sem[3U] ;
};
#line 1424 
struct super_operations;
#line 1424 
struct xattr_handler;
#line 1424 
struct mtd_info;
#line 1424  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct fscrypt_operations *s_cop ;
   struct key *s_master_keys ;
   struct fsverity_operations *s_vop ;
   struct hlist_bl_head s_roots ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   void *s_fs_info ;
   u32 s_time_gran ;
   time64_t s_time_min ;
   time64_t s_time_max ;
   __u32 s_fsnotify_mask ;
   struct fsnotify_mark_connector *s_fsnotify_marks ;
   char s_id[32U] ;
   uuid_t s_uuid ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   struct dentry_operations *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   atomic_long_t s_fsnotify_inode_refs ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct user_namespace *s_user_ns ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   struct work_struct destroy_work ;
   struct mutex s_sync_lock ;
   int s_stack_depth ;
   spinlock_t s_inode_list_lock ;
   struct list_head s_inodes ;
   spinlock_t s_inode_wblist_lock ;
   struct list_head s_inodes_wb ;
} __attribute__((__designated_init__));
#line 1746  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1756 
struct dir_context;
#line 1767  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};
#line 1771 
struct block_device_operations;
#line 1821  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iopoll)(struct kiocb *, bool ) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   int (*iterate_shared)(struct file *, struct dir_context *) ;
   __poll_t (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   unsigned long mmap_supported_flags ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
   ssize_t (*copy_file_range)(struct file *, loff_t , struct file *, loff_t , size_t , unsigned int ) ;
   loff_t (*remap_file_range)(struct file *, loff_t , struct file *, loff_t , loff_t , unsigned int ) ;
   int (*fadvise)(struct file *, loff_t , loff_t , int ) ;
} __attribute__((__designated_init__));
#line 1863  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char *(*get_link)(struct dentry *, struct inode *, struct delayed_call *) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct path *, struct kstat *, u32 , unsigned int ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec64 *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t ) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
} __attribute__((__aligned__(64)));
#line 1942  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*free_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};
#line 2217  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_system_type {
   char *name ;
   int fs_flags ;
   int (*init_fs_context)(struct fs_context *) ;
   struct fs_parameter_description *parameters ;
   struct dentry *(*mount)(struct file_system_type *, int , char *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 3599 
struct sock;
#line 1565  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
struct kvec;
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bvec.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bvec.h"
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned int bi_idx ;
   unsigned int bi_bvec_done ;
};
#line 686  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
struct scatterlist;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/uio.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
union __anonunion_438 {
   struct iovec *iov ;
   struct kvec *kvec ;
   struct bio_vec *bvec ;
   struct pipe_inode_info *pipe ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
struct __anonstruct_440 {
   unsigned int head ;
   unsigned int start_head ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
union __anonunion_439 {
   unsigned long nr_segs ;
   struct __anonstruct_440 __anonCompField___anonunion_439_68 ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
struct iov_iter {
   unsigned int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_438 __anonCompField_iov_iter_67 ;
   union __anonunion_439 __anonCompField_iov_iter_69 ;
};
#line 285  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
typedef unsigned short __kernel_sa_family_t;
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/socket.h"
struct socket;
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};
#line 422 
struct ns_common;
#line 201  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/random.h"
enum ldv_8871 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};
#line 209  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/random.h"
typedef enum ldv_8871 socket_state;
#line 94  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   unsigned long flags ;
   struct callback_head rcu ;
} __attribute__((__aligned__(64)));
#line 112 
struct proto_ops;
#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops *ops ;
   struct socket_wq wq ;
};
#line 125 
struct sk_buff;
#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *) ;
   int (*bind)(struct socket *, struct sockaddr *, int ) ;
   int (*connect)(struct socket *, struct sockaddr *, int , int ) ;
   int (*socketpair)(struct socket *, struct socket *) ;
   int (*accept)(struct socket *, struct socket *, int , bool ) ;
   int (*getname)(struct socket *, struct sockaddr *, int ) ;
   __poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *) ;
   int (*ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*gettstamp)(struct socket *, void *, bool , bool ) ;
   int (*listen)(struct socket *, int ) ;
   int (*shutdown)(struct socket *, int ) ;
   int (*setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*sendmsg)(struct socket *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct socket *, struct msghdr *, size_t , int ) ;
   int (*mmap)(struct file *, struct socket *, struct vm_area_struct *) ;
   ssize_t (*sendpage)(struct socket *, struct page *, int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock *, int ) ;
   int (*peek_len)(struct socket *) ;
   int (*read_sock)(struct sock *, read_descriptor_t *, int (*)(read_descriptor_t *, struct sk_buff *, unsigned int , size_t )) ;
   int (*sendpage_locked)(struct sock *, struct page *, int , size_t , int ) ;
   int (*sendmsg_locked)(struct sock *, struct msghdr *, size_t ) ;
   int (*set_rcvlowat)(struct sock *, int ) ;
};
#line 162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/idr.h"
struct idr {
   struct xarray idr_rt ;
   unsigned int idr_base ;
   unsigned int idr_next ;
};
#line 323 
struct kernfs_open_node;
#line 324 
struct kernfs_iattrs;
#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_root;
#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 96 
struct kernfs_node;
#line 96  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 100 
struct kernfs_ops;
#line 100  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
union __anonunion_463 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char *name ;
   struct rb_node rb ;
   void *ns ;
   unsigned int hash ;
   union __anonunion_463 __anonCompField_kernfs_node_72 ;
   void *priv ;
   u64 id ;
   unsigned short flags ;
   umode_t mode ;
   struct kernfs_iattrs *iattr ;
};
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char *) ;
   int (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *) ;
};
#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct idr ino_idr ;
   u32 last_id_lowbits ;
   u32 id_highbits ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   struct seq_file *seq_file ;
   void *priv ;
   struct mutex mutex ;
   struct mutex prealloc_mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped : 1 ;
   bool released : 1 ;
   struct vm_operations_struct *vm_ops ;
};
#line 210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_ops {
   int (*open)(struct kernfs_open_file *) ;
   void (*release)(struct kernfs_open_file *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   __poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};
#line 595 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject_ns.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void *(*netlink_ns)(struct sock *) ;
   void *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};
#line 58 
struct bin_attribute;
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysfs.h"
struct attribute {
   char *name ;
   umode_t mode ;
   bool ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysfs.h"
struct attribute_group {
   char *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   umode_t (*is_bin_visible)(struct kobject *, struct bin_attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};
#line 223  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char *, size_t ) ;
};
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kref.h"
struct kref {
   refcount_t refcount ;
};
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kset;
#line 65 
struct kobj_type;
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kobject {
   char *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
   struct attribute_group **default_groups ;
   struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *) ;
   void *(*namespace)(struct kobject *) ;
   void (*get_ownership)(struct kobject *, kuid_t *, kgid_t *) ;
};
#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kset_uevent_ops {
   int (*filter)(struct kset *, struct kobject *) ;
   char *(*name)(struct kset *, struct kobject *) ;
   int (*uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};
#line 193  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
} __attribute__((__designated_init__));
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 278  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};
#line 303 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};
#line 310 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};
#line 318 
struct wakeup_source;
#line 319 
struct wake_irq;
#line 320 
struct pm_domain_data;
#line 530  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
   struct pm_domain_data *domain_data ;
};
#line 573 
struct dev_pm_qos;
#line 573  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int async_suspend : 1 ;
   bool in_dpm_list : 1 ;
   bool is_prepared : 1 ;
   bool is_suspended : 1 ;
   bool is_noirq_suspended : 1 ;
   bool is_late_suspended : 1 ;
   bool no_pm : 1 ;
   bool early_init : 1 ;
   bool direct_complete : 1 ;
   u32 driver_flags ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path : 1 ;
   bool syscore : 1 ;
   bool no_pm_callbacks : 1 ;
   unsigned int must_resume : 1 ;
   unsigned int may_skip_resume : 1 ;
   struct hrtimer suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int disable_depth : 3 ;
   unsigned int idle_notification : 1 ;
   unsigned int request_pending : 1 ;
   unsigned int deferred_resume : 1 ;
   unsigned int runtime_auto : 1 ;
   bool ignore_children : 1 ;
   unsigned int no_callbacks : 1 ;
   unsigned int irq_safe : 1 ;
   unsigned int use_autosuspend : 1 ;
   unsigned int timer_autosuspends : 1 ;
   unsigned int memalloc_noio : 1 ;
   unsigned int links_count ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   u64 last_busy ;
   u64 active_time ;
   u64 suspended_time ;
   u64 accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};
#line 650  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   int (*start)(struct device *) ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ratelimit.h"
struct ratelimit_state {
   raw_spinlock_t lock ;
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
   unsigned long flags ;
};
#line 5  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/device.h"
struct dev_archdata {
   void *iommu ;
};
#line 12 
struct dma_map_ops;
#line 23 
struct device_driver;
#line 24 
struct driver_private;
#line 25 
struct class;
#line 26 
struct subsys_private;
#line 27 
struct bus_type;
#line 28 
struct iommu_ops;
#line 29 
struct iommu_group;
#line 30 
struct iommu_fwspec;
#line 31 
struct dev_pin_info;
#line 32 
struct iommu_param;
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct bus_type {
   char *name ;
   char *dev_name ;
   struct device *dev_root ;
   struct attribute_group **bus_groups ;
   struct attribute_group **dev_groups ;
   struct attribute_group **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   void (*sync_state)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   int (*num_vf)(struct device *) ;
   int (*dma_configure)(struct device *) ;
   struct dev_pm_ops *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
   bool need_parent_lock ;
};
#line 164 
struct device_type;
#line 309 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};
#line 383 
struct of_device_id;
#line 383 
struct acpi_device_id;
#line 383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct device_driver {
   char *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id *of_match_table ;
   struct acpi_device_id *acpi_match_table ;
   int (*probe)(struct device *) ;
   void (*sync_state)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group **groups ;
   struct attribute_group **dev_groups ;
   struct dev_pm_ops *pm ;
   void (*coredump)(struct device *) ;
   struct driver_private *p ;
};
#line 589  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct class {
   char *name ;
   struct module *owner ;
   struct attribute_group **class_groups ;
   struct attribute_group **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*shutdown_pre)(struct device *) ;
   struct kobj_ns_type_operations *ns_type ;
   void *(*namespace)(struct device *) ;
   void (*get_ownership)(struct device *, kuid_t *, kgid_t *) ;
   struct dev_pm_ops *pm ;
   struct subsys_private *p ;
};
#line 809  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct device_type {
   char *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops *pm ;
};
#line 1008  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 1139 
enum dl_dev_state {
    DL_DEV_NO_DRIVER = 0,
    DL_DEV_PROBING = 1,
    DL_DEV_DRIVER_BOUND = 2,
    DL_DEV_UNBINDING = 3
};
#line 1164  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct dev_links_info {
   struct list_head suppliers ;
   struct list_head consumers ;
   struct list_head needs_suppliers ;
   struct list_head defer_sync ;
   bool need_for_probe ;
   enum dl_dev_state status ;
};
#line 1259 
struct dma_coherent_mem;
#line 1259 
struct cma;
#line 1259  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct device {
   struct kobject kobj ;
   struct device *parent ;
   struct device_private *p ;
   char *init_name ;
   struct device_type *type ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct mutex lockdep_mutex ;
   struct mutex mutex ;
   struct dev_links_info links ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct irq_domain *msi_domain ;
   struct dev_pin_info *pins ;
   struct list_head msi_list ;
   struct dma_map_ops *dma_ops ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   u64 bus_dma_limit ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   int numa_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct class *class ;
   struct attribute_group **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   struct iommu_fwspec *iommu_fwspec ;
   struct iommu_param *iommu_param ;
   bool offline_disabled : 1 ;
   bool offline : 1 ;
   bool of_node_reused : 1 ;
   bool state_synced : 1 ;
};
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm_wakeup.h"
struct wakeup_source {
   char *name ;
   int id ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   struct device *dev ;
   bool active : 1 ;
   bool autosleep_enabled : 1 ;
};
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-debug.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/scatterlist.h"
struct scatterlist {
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , unsigned long ) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , unsigned long ) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , unsigned long ) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , unsigned long ) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , unsigned long ) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , unsigned long ) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , unsigned long ) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , unsigned long ) ;
   dma_addr_t (*map_resource)(struct device *, phys_addr_t , size_t , enum dma_data_direction , unsigned long ) ;
   void (*unmap_resource)(struct device *, dma_addr_t , size_t , enum dma_data_direction , unsigned long ) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*cache_sync)(struct device *, void *, size_t , enum dma_data_direction ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   u64 (*get_required_mask)(struct device *) ;
   size_t (*max_mapping_size)(struct device *) ;
   unsigned long (*get_merge_boundary)(struct device *) ;
};
#line 803  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
typedef u64 netdev_features_t;
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/in6.h"
union __anonunion_in6_u_466 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/in6.h"
struct in6_addr {
   union __anonunion_in6_u_466 in6_u ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/in6.h"
struct __anonstruct_siphash_key_t_467 {
   u64 key[2U] ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/in6.h"
typedef struct __anonstruct_siphash_key_t_467 siphash_key_t;
#line 163  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_ether.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
} __attribute__((__packed__));
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pipe_fs_i.h"
struct pipe_buf_operations;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pipe_fs_i.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int head ;
   unsigned int tail ;
   unsigned int max_usage ;
   unsigned int ring_size ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
   struct user_struct *user ;
};
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   bool (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct flowi_tunnel {
   __be64 tun_id ;
};
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct flowi_common {
   int flowic_oif ;
   int flowic_iif ;
   __u32 flowic_mark ;
   __u8 flowic_tos ;
   __u8 flowic_scope ;
   __u8 flowic_proto ;
   __u8 flowic_flags ;
   __u32 flowic_secid ;
   kuid_t flowic_uid ;
   struct flowi_tunnel flowic_tun_key ;
   __u32 flowic_multipath_hash ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct __anonstruct_ports_478 {
   __be16 dport ;
   __be16 sport ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct __anonstruct_icmpt_479 {
   __u8 type ;
   __u8 code ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct __anonstruct_dnports_480 {
   __le16 dport ;
   __le16 sport ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct __anonstruct_mht_481 {
   __u8 type ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
union flowi_uli {
   struct __anonstruct_ports_478 ports ;
   struct __anonstruct_icmpt_479 icmpt ;
   struct __anonstruct_dnports_480 dnports ;
   __be32 spi ;
   __be32 gre_key ;
   struct __anonstruct_mht_481 mht ;
};
#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct flowi4 {
   struct flowi_common __fl_common ;
   __be32 saddr ;
   __be32 daddr ;
   union flowi_uli uli ;
} __attribute__((__aligned__(8)));
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct flowi6 {
   struct flowi_common __fl_common ;
   struct in6_addr daddr ;
   struct in6_addr saddr ;
   __be32 flowlabel ;
   union flowi_uli uli ;
   __u32 mp_hash ;
} __attribute__((__aligned__(8)));
#line 158  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct flowidn {
   struct flowi_common __fl_common ;
   __le16 daddr ;
   __le16 saddr ;
   union flowi_uli uli ;
} __attribute__((__aligned__(8)));
#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
union __anonunion_u_482 {
   struct flowi_common __fl_common ;
   struct flowi4 ip4 ;
   struct flowi6 ip6 ;
   struct flowidn dn ;
};
#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow.h"
struct flowi {
   union __anonunion_u_482 u ;
} __attribute__((__aligned__(8)));
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netfilter/nf_conntrack_common.h"
struct ip_conntrack_stat {
   unsigned int found ;
   unsigned int invalid ;
   unsigned int ignore ;
   unsigned int insert ;
   unsigned int insert_failed ;
   unsigned int drop ;
   unsigned int early_drop ;
   unsigned int error ;
   unsigned int expect_new ;
   unsigned int expect_create ;
   unsigned int expect_delete ;
   unsigned int search_restart ;
};
#line 41 
struct napi_struct;
#line 42 
struct bpf_prog;
#line 43 
union bpf_attr;
#line 44 
struct skb_ext;
#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 313  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
typedef struct bio_vec skb_frag_t;
#line 416  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
};
#line 510  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct skb_shared_info {
   __u8 __unused ;
   __u8 meta_len ;
   __u8 nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   unsigned int gso_type ;
   u32 tskey ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};
#line 562  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_489 {
   struct net_device *dev ;
   unsigned long dev_scratch ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct __anonstruct_488 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_489 __anonCompField___anonstruct_488_85 ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_487 {
   struct __anonstruct_488 __anonCompField___anonunion_487_86 ;
   struct rb_node rbnode ;
   struct list_head list ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_490 {
   struct sock *sk ;
   int ip_defrag_offset ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_491 {
   ktime_t tstamp ;
   u64 skb_mstamp_ns ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct __anonstruct_493 {
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_492 {
   struct __anonstruct_493 __anonCompField___anonunion_492_90 ;
   struct list_head tcp_tsorted_anchor ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct __anonstruct_495 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_494 {
   __wsum csum ;
   struct __anonstruct_495 __anonCompField___anonunion_494_92 ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_496 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_497 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_498 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_487 __anonCompField_sk_buff_87 ;
   union __anonunion_490 __anonCompField_sk_buff_88 ;
   union __anonunion_491 __anonCompField_sk_buff_89 ;
   char cb[48U] ;
   union __anonunion_492 __anonCompField_sk_buff_91 ;
   unsigned long _nfct ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __cloned_offset[0U] ;
   __u8 cloned : 1 ;
   __u8 nohdr : 1 ;
   __u8 fclone : 2 ;
   __u8 peeked : 1 ;
   __u8 head_frag : 1 ;
   __u8 pfmemalloc : 1 ;
   __u8 active_extensions ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 pkt_type : 3 ;
   __u8 ignore_df : 1 ;
   __u8 nf_trace : 1 ;
   __u8 ip_summed : 2 ;
   __u8 ooo_okay : 1 ;
   __u8 l4_hash : 1 ;
   __u8 sw_hash : 1 ;
   __u8 wifi_acked_valid : 1 ;
   __u8 wifi_acked : 1 ;
   __u8 no_fcs : 1 ;
   __u8 encapsulation : 1 ;
   __u8 encap_hdr_csum : 1 ;
   __u8 csum_valid : 1 ;
   __u8 __pkt_vlan_present_offset[0U] ;
   __u8 vlan_present : 1 ;
   __u8 csum_complete_sw : 1 ;
   __u8 csum_level : 2 ;
   __u8 csum_not_inet : 1 ;
   __u8 dst_pending_confirm : 1 ;
   __u8 ndisc_nodetype : 2 ;
   __u8 ipvs_property : 1 ;
   __u8 inner_protocol_type : 1 ;
   __u8 remcsum_offload : 1 ;
   __u8 offload_fwd_mark : 1 ;
   __u8 offload_l3_fwd_mark : 1 ;
   __u8 tc_skip_classify : 1 ;
   __u8 tc_at_ingress : 1 ;
   __u8 tc_redirected : 1 ;
   __u8 tc_from_ingress : 1 ;
   __u8 decrypted : 1 ;
   __u16 tc_index ;
   union __anonunion_494 __anonCompField_sk_buff_93 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_496 __anonCompField_sk_buff_94 ;
   __u32 secmark ;
   union __anonunion_497 __anonCompField_sk_buff_95 ;
   union __anonunion_498 __anonCompField_sk_buff_96 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   refcount_t users ;
   struct skb_ext *extensions ;
};
#line 920 
struct dst_entry;
#line 4108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct skb_ext {
   refcount_t refcnt ;
   u8 offset[3U] ;
   u8 chunks ;
   char data[0U] ;
};
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_nulls.h"
struct hlist_nulls_node;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_nulls.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
struct __anonstruct_sync_serial_settings_532 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
typedef struct __anonstruct_sync_serial_settings_532 sync_serial_settings;
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_533 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_533 te1_settings;
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_534 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_534 raw_hdlc_proto;
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_535 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_535 fr_proto;
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_536 {
   unsigned int dlci ;
};
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_536 fr_proto_pvc;
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_537 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_537 fr_proto_pvc_info;
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_538 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_538 cisco_proto;
#line 195  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_539 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_539 ifs_ifsu ;
};
#line 232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_540 {
   char ifrn_name[16U] ;
};
#line 232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_541 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_540 ifr_ifrn ;
   union __anonunion_ifr_ifru_541 ifr_ifru ;
};
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/compat.h"
typedef s32 compat_long_t;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/compat.h"
typedef u32 compat_uptr_t;
#line 367  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 371  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 177  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 310  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 360  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 382  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 462  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 513  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 541  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 575  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 702  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 758  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 775  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 793  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 812  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_tcpip6_spec {
   __be32 ip6src[4U] ;
   __be32 ip6dst[4U] ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tclass ;
};
#line 829  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip6_spec {
   __be32 ip6src[4U] ;
   __be32 ip6dst[4U] ;
   __be32 spi ;
   __u8 tclass ;
};
#line 844  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_usrip6_spec {
   __be32 ip6src[4U] ;
   __be32 ip6dst[4U] ;
   __be32 l4_4_bytes ;
   __u8 tclass ;
   __u8 l4_proto ;
};
#line 852  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethtool_tcpip6_spec tcp_ip6_spec ;
   struct ethtool_tcpip6_spec udp_ip6_spec ;
   struct ethtool_tcpip6_spec sctp_ip6_spec ;
   struct ethtool_ah_espip6_spec ah_ip6_spec ;
   struct ethtool_ah_espip6_spec esp_ip6_spec ;
   struct ethtool_usrip6_spec usr_ip6_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 880  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 905  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 1001  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
union __anonunion_560 {
   __u32 rule_cnt ;
   __u32 rss_context ;
};
#line 1001  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   union __anonunion_560 __anonCompField_ethtool_rxnfc_99 ;
   __u32 rule_locs[0U] ;
};
#line 1130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 1150  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1230  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 1302  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_fecparam {
   __u32 cmd ;
   __u32 active_fec ;
   __u32 fec ;
   __u32 reserved ;
};
#line 1876  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_link_settings {
   __u32 cmd ;
   __u32 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __s8 link_mode_masks_nwords ;
   __u8 transceiver ;
   __u8 reserved1[3U] ;
   __u32 reserved[7U] ;
   __u32 link_mode_masks[0U] ;
};
#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};
#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
struct __anonstruct_link_modes_563 {
   unsigned long supported[2U] ;
   unsigned long advertising[2U] ;
   unsigned long lp_advertising[2U] ;
};
#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
struct ethtool_link_ksettings {
   struct ethtool_link_settings base ;
   struct __anonstruct_link_modes_563 link_modes ;
};
#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
struct ethtool_ops {
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 *, u8 *, u8 ) ;
   int (*get_rxfh_context)(struct net_device *, u32 *, u8 *, u8 *, u32 ) ;
   int (*set_rxfh_context)(struct net_device *, u32 *, u8 *, u8 , u32 *, bool ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable *, void *) ;
   int (*get_per_queue_coalesce)(struct net_device *, u32 , struct ethtool_coalesce *) ;
   int (*set_per_queue_coalesce)(struct net_device *, u32 , struct ethtool_coalesce *) ;
   int (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *) ;
   int (*set_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *) ;
   int (*get_fecparam)(struct net_device *, struct ethtool_fecparam *) ;
   int (*set_fecparam)(struct net_device *, struct ethtool_fecparam *) ;
   void (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
};
#line 822  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/sysctl.h"
struct ctl_table_root;
#line 823 
struct ctl_table_header;
#line 824 
struct ctl_dir;
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);
#line 105  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table {
   char *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
} __attribute__((__designated_init__));
#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct __anonstruct_565 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
union __anonunion_564 {
   struct __anonstruct_565 __anonCompField___anonunion_564_100 ;
   struct callback_head rcu ;
};
#line 142 
struct ctl_table_set;
#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_564 __anonCompField_ctl_table_header_101 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
   struct hlist_head inodes ;
};
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 167  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *) ;
   void (*set_ownership)(struct ctl_table_header *, struct ctl_table *, kuid_t *, kgid_t *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};
#line 242 
struct prot_inuse;
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/core.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   int *sock_inuse ;
   struct prot_inuse *prot_inuse ;
};
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct u64_stats_sync {
   };
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct __anonstruct_local_t_566 {
   atomic_long_t a ;
};
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
typedef struct __anonstruct_local_t_566 local_t;
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/local.h"
struct __anonstruct_local64_t_567 {
   local_t a ;
};
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/local.h"
typedef struct __anonstruct_local64_t_567 local64_t;
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/local64.h"
struct __anonstruct_u64_stats_t_568 {
   local64_t v ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/local64.h"
typedef struct __anonstruct_u64_stats_t_568 u64_stats_t;
#line 51  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct ipstats_mib {
   u64 mibs[37U] ;
   struct u64_stats_sync syncp ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};
#line 81  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[120U] ;
};
#line 110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct linux_tls_mib {
   unsigned long mibs[11U] ;
};
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/mib.h"
struct proc_dir_entry;
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/mib.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
   struct linux_tls_mib *tls_statistics ;
};
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/unix.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/packet.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct inet_frags;
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct fqdir {
   long high_thresh ;
   long low_thresh ;
   int timeout ;
   int max_dist ;
   struct inet_frags *f ;
   struct net *net ;
   bool dead ;
   struct rhashtable rhashtable ;
   atomic_long_t mem ;
   struct work_struct destroy_work ;
};
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct frag_v4_compare_key {
   __be32 saddr ;
   __be32 daddr ;
   u32 user ;
   u32 vif ;
   __be16 id ;
   u16 protocol ;
};
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct frag_v6_compare_key {
   struct in6_addr saddr ;
   struct in6_addr daddr ;
   u32 user ;
   __be32 id ;
   u32 iif ;
};
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
union __anonunion_key_569 {
   struct frag_v4_compare_key v4 ;
   struct frag_v6_compare_key v6 ;
};
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct inet_frag_queue {
   struct rhash_head node ;
   union __anonunion_key_569 key ;
   struct timer_list timer ;
   spinlock_t lock ;
   refcount_t refcnt ;
   struct rb_root rb_fragments ;
   struct sk_buff *fragments_tail ;
   struct sk_buff *last_run_head ;
   ktime_t stamp ;
   int len ;
   int meat ;
   __u8 flags ;
   u16 max_size ;
   struct fqdir *fqdir ;
   struct callback_head rcu ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct inet_frags {
   unsigned int qsize ;
   void (*constructor)(struct inet_frag_queue *, void *) ;
   void (*destructor)(struct inet_frag_queue *) ;
   void (*frag_expire)(struct timer_list *) ;
   struct kmem_cache *frags_cachep ;
   char *frags_cache_name ;
   struct rhashtable_params rhash_params ;
   refcount_t refcnt ;
   struct completion completion ;
};
#line 177 
struct ipv4_devconf;
#line 178 
struct fib_rules_ops;
#line 179 
struct fib_table;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv4.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 31 
struct inet_hashinfo;
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv4.h"
struct inet_timewait_death_row {
   atomic_t tw_count ;
   struct inet_hashinfo *hashinfo ;
   int sysctl_max_tw_buckets ;
};
#line 40 
struct tcp_fastopen_context;
#line 43 
struct ip_ra_chain;
#line 43 
struct inet_peer_base;
#line 43 
struct xt_table;
#line 43 
struct tcp_congestion_ops;
#line 43 
struct fib_notifier_ops;
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct ip_ra_chain *ra_chain ;
   struct mutex ra_mutex ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   unsigned int fib_rules_require_fldissect ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   bool fib_has_custom_local_routes ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct fqdir *fqdir ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_default_ttl ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_fwd_update_priority ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_ip_dynaddr ;
   int sysctl_ip_early_demux ;
   int sysctl_raw_l3mdev_accept ;
   int sysctl_tcp_early_demux ;
   int sysctl_udp_early_demux ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_l3mdev_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_mtu_probe_floor ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_min_snd_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   int sysctl_tcp_keepalive_time ;
   int sysctl_tcp_keepalive_probes ;
   int sysctl_tcp_keepalive_intvl ;
   int sysctl_tcp_syn_retries ;
   int sysctl_tcp_synack_retries ;
   int sysctl_tcp_syncookies ;
   int sysctl_tcp_reordering ;
   int sysctl_tcp_retries1 ;
   int sysctl_tcp_retries2 ;
   int sysctl_tcp_orphan_retries ;
   int sysctl_tcp_fin_timeout ;
   unsigned int sysctl_tcp_notsent_lowat ;
   int sysctl_tcp_tw_reuse ;
   int sysctl_tcp_sack ;
   int sysctl_tcp_window_scaling ;
   int sysctl_tcp_timestamps ;
   int sysctl_tcp_early_retrans ;
   int sysctl_tcp_recovery ;
   int sysctl_tcp_thin_linear_timeouts ;
   int sysctl_tcp_slow_start_after_idle ;
   int sysctl_tcp_retrans_collapse ;
   int sysctl_tcp_stdurg ;
   int sysctl_tcp_rfc1337 ;
   int sysctl_tcp_abort_on_overflow ;
   int sysctl_tcp_fack ;
   int sysctl_tcp_max_reordering ;
   int sysctl_tcp_dsack ;
   int sysctl_tcp_app_win ;
   int sysctl_tcp_adv_win_scale ;
   int sysctl_tcp_frto ;
   int sysctl_tcp_nometrics_save ;
   int sysctl_tcp_moderate_rcvbuf ;
   int sysctl_tcp_tso_win_divisor ;
   int sysctl_tcp_workaround_signed_windows ;
   int sysctl_tcp_limit_output_bytes ;
   int sysctl_tcp_challenge_ack_limit ;
   int sysctl_tcp_min_tso_segs ;
   int sysctl_tcp_min_rtt_wlen ;
   int sysctl_tcp_autocorking ;
   int sysctl_tcp_invalid_ratelimit ;
   int sysctl_tcp_pacing_ss_ratio ;
   int sysctl_tcp_pacing_ca_ratio ;
   int sysctl_tcp_wmem[3U] ;
   int sysctl_tcp_rmem[3U] ;
   int sysctl_tcp_comp_sack_nr ;
   unsigned long sysctl_tcp_comp_sack_delay_ns ;
   struct inet_timewait_death_row tcp_death_row ;
   int sysctl_max_syn_backlog ;
   int sysctl_tcp_fastopen ;
   struct tcp_congestion_ops *tcp_congestion_control ;
   struct tcp_fastopen_context *tcp_fastopen_ctx ;
   spinlock_t tcp_fastopen_ctx_lock ;
   unsigned int sysctl_tcp_fastopen_blackhole_timeout ;
   atomic_t tfo_active_disable_times ;
   unsigned long tfo_active_disable_stamp ;
   int sysctl_udp_wmem_min ;
   int sysctl_udp_rmem_min ;
   int sysctl_udp_l3mdev_accept ;
   int sysctl_igmp_max_memberships ;
   int sysctl_igmp_max_msf ;
   int sysctl_igmp_llm_reports ;
   int sysctl_igmp_qrv ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   int sysctl_ip_prot_sock ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   int sysctl_fib_multipath_use_neigh ;
   int sysctl_fib_multipath_hash_policy ;
   struct fib_notifier_ops *notifier_ops ;
   unsigned int fib_seq ;
   struct fib_notifier_ops *ipmr_notifier_ops ;
   unsigned int ipmr_seq ;
   atomic_t rt_genid ;
   siphash_key_t ip_id_key ;
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dst_ops.h"
struct neighbour;
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dst_ops.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry *) ;
   unsigned int (*mtu)(struct dst_entry *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 , bool ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct net *, struct sock *, struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry *, struct sk_buff *, void *) ;
   void (*confirm_neigh)(struct dst_entry *, void *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv6.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int multipath_hash_policy ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int icmpv6_echo_ignore_all ;
   int icmpv6_echo_ignore_multicast ;
   int icmpv6_echo_ignore_anycast ;
   unsigned long icmpv6_ratemask[4U] ;
   unsigned long *icmpv6_ratemask_ptr ;
   int anycast_src_echo_reply ;
   int ip_nonlocal_bind ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
   int flowlabel_reflect ;
   int max_dst_opts_cnt ;
   int max_hbh_opts_cnt ;
   int max_dst_opts_len ;
   int max_hbh_opts_len ;
   int seg6_flowlabel ;
   bool skip_notify_on_dev_down ;
};
#line 56 
struct ipv6_devconf;
#line 56 
struct seg6_pernet_data;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv6.h"
struct __anonstruct_ip6addrlbl_table_571 {
   struct hlist_head head ;
   spinlock_t lock ;
   u32 seq ;
};
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct fqdir *fqdir ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct fib6_info *fib6_null_entry ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct list_head fib6_walkers ;
   struct dst_ops ip6_dst_ops ;
   rwlock_t fib6_walker_lock ;
   spinlock_t fib6_gc_lock ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   unsigned int fib6_rules_require_fldissect ;
   bool fib6_has_custom_rules ;
   unsigned int fib6_routes_require_src ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
   struct seg6_pernet_data *seg6_data ;
   struct fib_notifier_ops *notifier_ops ;
   struct fib_notifier_ops *ip6mr_notifier_ops ;
   unsigned int ipmr_seq ;
   struct __anonstruct_ip6addrlbl_table_571 ip6addrlbl_table ;
};
#line 121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct fqdir *fqdir ;
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/nexthop.h"
struct netns_nexthop {
   struct rb_root rb_root ;
   struct hlist_head *devhash ;
   unsigned int seq ;
   u32 last_id_allocated ;
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ieee802154_6lowpan.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct fqdir *fqdir ;
};
#line 21 
struct sctp_mib;
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/sctp.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int ps_retrans ;
   int pf_enable ;
   int pf_expose ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int reconf_enable ;
   int auth_enable ;
   int intl_enable ;
   int ecn_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/dccp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/netfilter.h"
struct nf_logger;
#line 76 
struct nf_queue_handler;
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/netfilter.h"
struct nf_hook_entries;
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_queue_handler *queue_handler ;
   struct nf_logger *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
   struct nf_hook_entries *hooks_ipv4[5U] ;
   struct nf_hook_entries *hooks_ipv6[5U] ;
   struct nf_hook_entries *hooks_arp[3U] ;
   struct nf_hook_entries *hooks_bridge[5U] ;
   struct nf_hook_entries *hooks_decnet[7U] ;
   bool defrag_ipv4 ;
   bool defrag_ipv6 ;
};
#line 37 
struct ebt_table;
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/x_tables.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_generic_net {
   unsigned int timeout ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_tcp_net {
   unsigned int timeouts[14U] ;
   int tcp_loose ;
   int tcp_be_liberal ;
   int tcp_max_retrans ;
};
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_udp_net {
   unsigned int timeouts[2U] ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_icmp_net {
   unsigned int timeout ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_dccp_net {
   int dccp_loose ;
   unsigned int dccp_timeout[10U] ;
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_sctp_net {
   unsigned int timeouts[10U] ;
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_gre_net {
   struct list_head keymap_list ;
   unsigned int timeouts[2U] ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct nf_dccp_net dccp ;
   struct nf_sctp_net sctp ;
   struct nf_gre_net gre ;
};
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};
#line 95 
struct nf_ct_event_notifier;
#line 95 
struct nf_exp_event_notifier;
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   bool auto_assign_helper_warned ;
   struct ctl_table_header *sysctl_header ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
};
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/nftables.h"
struct netns_nftables {
   struct list_head tables ;
   struct list_head commit_list ;
   struct list_head module_list ;
   struct mutex commit_mutex ;
   unsigned int base_seq ;
   u8 gencursor ;
   u8 validate_state ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/xfrm.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct list_head inexact_bins ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   spinlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
};
#line 79 
struct mpls_route;
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/mpls.h"
struct netns_mpls {
   int ip_ttl_propagate ;
   int default_ttl ;
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
#line 20 
struct can_dev_rcv_lists;
#line 21 
struct can_pkg_stats;
#line 22 
struct can_rcv_lists_stats;
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/can.h"
struct netns_can {
   struct proc_dir_entry *proc_dir ;
   struct proc_dir_entry *pde_version ;
   struct proc_dir_entry *pde_stats ;
   struct proc_dir_entry *pde_reset_stats ;
   struct proc_dir_entry *pde_rcvlist_all ;
   struct proc_dir_entry *pde_rcvlist_fil ;
   struct proc_dir_entry *pde_rcvlist_inv ;
   struct proc_dir_entry *pde_rcvlist_sff ;
   struct proc_dir_entry *pde_rcvlist_eff ;
   struct proc_dir_entry *pde_rcvlist_err ;
   struct proc_dir_entry *bcmproc_dir ;
   struct can_dev_rcv_lists *rx_alldev_list ;
   spinlock_t rcvlists_lock ;
   struct timer_list stattimer ;
   struct can_pkg_stats *pkg_stats ;
   struct can_rcv_lists_stats *rcv_lists_stats ;
   struct hlist_head cgw_list ;
};
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/xdp.h"
struct netns_xdp {
   struct mutex lock ;
   struct hlist_head list ;
};
#line 12 
struct proc_ns_operations;
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ns_common.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations *ops ;
   unsigned int inum ;
};
#line 12 
struct net_generic;
#line 13 
struct uevent_sock;
#line 14 
struct netns_ipvs;
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/net_namespace.h"
struct key_tag;
#line 55 
struct ucounts;
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/net_namespace.h"
struct net {
   refcount_t passive ;
   refcount_t count ;
   spinlock_t rules_mod_lock ;
   unsigned int dev_unreg_count ;
   unsigned int dev_base_seq ;
   int ifindex ;
   spinlock_t nsid_lock ;
   atomic_t fnhe_genid ;
   struct list_head list ;
   struct list_head exit_list ;
   struct llist_node cleanup_list ;
   struct key_tag *key_domain ;
   struct user_namespace *user_ns ;
   struct ucounts *ucounts ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct list_head dev_base_head ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct uevent_sock *uevent_sock ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   struct raw_notifier_head netdev_chain ;
   u32 hash_mix ;
   struct net_device *loopback_dev ;
   struct list_head rules_ops ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_nexthop nexthop ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct ctl_table_header *nf_frag_frags_hdr ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct list_head nfnl_acct_list ;
   struct list_head nfct_timeout_list ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct bpf_prog *flow_dissector_prog ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct netns_can can ;
   struct netns_xdp xdp ;
   struct sock *crypto_nlsk ;
   struct sock *diag_nlsk ;
} __attribute__((__designated_init__));
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/assoc_array.h"
struct assoc_array_ptr;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/assoc_array.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 83  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/assoc_array.h"
typedef int32_t key_serial_t;
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 32 
struct key_type;
#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct key_tag {
   struct callback_head rcu ;
   refcount_t usage ;
   bool removed ;
};
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct __anonstruct_580 {
   u16 desc_len ;
   char desc[6U] ;
};
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_579 {
   struct __anonstruct_580 __anonCompField___anonunion_579_102 ;
   unsigned long x ;
};
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct keyring_index_key {
   unsigned long hash ;
   union __anonunion_579 __anonCompField_keyring_index_key_103 ;
   struct key_type *type ;
   struct key_tag *domain_tag ;
   char *description ;
};
#line 111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union key_payload {
   void *rcu_data0 ;
   void *data[4U] ;
};
#line 153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct key_restriction {
   int (*check)(struct key *, struct key_type *, union key_payload *, struct key *) ;
   struct key *key ;
   struct key_type *keytype ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_581 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 172 
struct key_user;
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_582 {
   time64_t expiry ;
   time64_t revoked_at ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct __anonstruct_584 {
   unsigned long hash ;
   unsigned long len_desc ;
   struct key_type *type ;
   struct key_tag *domain_tag ;
   char *description ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_583 {
   struct keyring_index_key index_key ;
   struct __anonstruct_584 __anonCompField___anonunion_583_106 ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct __anonstruct_586 {
   struct list_head name_link ;
   struct assoc_array keys ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_585 {
   union key_payload payload ;
   struct __anonstruct_586 __anonCompField___anonunion_585_108 ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct key {
   refcount_t usage ;
   key_serial_t serial ;
   union __anonunion_581 __anonCompField_key_104 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_582 __anonCompField_key_105 ;
   time64_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   short state ;
   unsigned long flags ;
   union __anonunion_583 __anonCompField_key_107 ;
   union __anonunion_585 __anonCompField_key_109 ;
   struct key_restriction *restrict_link ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/user.h"
struct user_struct {
   refcount_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   unsigned long unix_inflight ;
   atomic_long_t pipe_bufs ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
   struct ratelimit_state ratelimit ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cred.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   kgid_t gid[0U] ;
} __attribute__((__designated_init__));
#line 111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cred.h"
union __anonunion_589 {
   int non_rcu ;
   struct callback_head rcu ;
};
#line 111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   kernel_cap_t cap_ambient ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   union __anonunion_589 __anonCompField_cred_110 ;
} __attribute__((__designated_init__));
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seq_file.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations *op ;
   int poll_event ;
   struct file *file ;
   void *private ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};
#line 275  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_590 {
   struct net *net ;
};
#line 275  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_590 possible_net_t;
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 78  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
#line 141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 168  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct dcbnl_buffer {
   __u8 prio2buffer[8U] ;
   __u32 buffer_size[8U] ;
   __u32 total_size ;
};
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 207  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 259  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
   int (*dcbnl_getbuffer)(struct net_device *, struct dcbnl_buffer *) ;
   int (*dcbnl_setbuffer)(struct net_device *, struct dcbnl_buffer *) ;
};
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/taskstats.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
   __u64 thrashing_count ;
   __u64 thrashing_delay_total ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/cgroupstats.h"
struct mnt_namespace;
#line 60 
struct uts_namespace;
#line 61 
struct ipc_namespace;
#line 62 
struct cgroup_namespace;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nsproxy.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
   struct cgroup_namespace *cgroup_ns ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct uid_gid_extent {
   u32 first ;
   u32 lower_first ;
   u32 count ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct __anonstruct_592 {
   struct uid_gid_extent *forward ;
   struct uid_gid_extent *reverse ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
union __anonunion_591 {
   struct uid_gid_extent extent[5U] ;
   struct __anonstruct_592 __anonCompField___anonunion_591_111 ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct uid_gid_map {
   u32 nr_extents ;
   union __anonunion_591 __anonCompField_uid_gid_map_112 ;
};
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct user_namespace {
   struct uid_gid_map uid_map ;
   struct uid_gid_map gid_map ;
   struct uid_gid_map projid_map ;
   atomic_t count ;
   struct user_namespace *parent ;
   int level ;
   kuid_t owner ;
   kgid_t group ;
   struct ns_common ns ;
   unsigned long flags ;
   struct list_head keyring_name_list ;
   struct key *user_keyring_register ;
   struct rw_semaphore keyring_sem ;
   struct key *persistent_keyring_register ;
   struct work_struct work ;
   struct ctl_table_set set ;
   struct ctl_table_header *sysctls ;
   struct ucounts *ucounts ;
   int ucount_max[9U] ;
} __attribute__((__designated_init__));
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct ucounts {
   struct hlist_node node ;
   struct user_namespace *ns ;
   kuid_t uid ;
   int count ;
   atomic_t ucount[9U] ;
};
#line 139 
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
};
#line 145  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
typedef enum irqreturn irqreturn_t;
#line 268  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/interrupt.h"
struct irq_affinity_notify {
   unsigned int irq ;
   struct kref kref ;
   struct work_struct work ;
   void (*notify)(struct irq_affinity_notify *, cpumask_t *) ;
   void (*release)(struct kref *) ;
};
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct bpf_insn {
   __u8 code ;
   __u8 dst_reg : 4 ;
   __u8 src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct bpf_cgroup_storage_key {
   __u64 cgroup_inode_id ;
   __u32 attach_type ;
};
#line 110 
enum bpf_map_type {
    BPF_MAP_TYPE_UNSPEC = 0,
    BPF_MAP_TYPE_HASH = 1,
    BPF_MAP_TYPE_ARRAY = 2,
    BPF_MAP_TYPE_PROG_ARRAY = 3,
    BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
    BPF_MAP_TYPE_PERCPU_HASH = 5,
    BPF_MAP_TYPE_PERCPU_ARRAY = 6,
    BPF_MAP_TYPE_STACK_TRACE = 7,
    BPF_MAP_TYPE_CGROUP_ARRAY = 8,
    BPF_MAP_TYPE_LRU_HASH = 9,
    BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
    BPF_MAP_TYPE_LPM_TRIE = 11,
    BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
    BPF_MAP_TYPE_HASH_OF_MAPS = 13,
    BPF_MAP_TYPE_DEVMAP = 14,
    BPF_MAP_TYPE_SOCKMAP = 15,
    BPF_MAP_TYPE_CPUMAP = 16,
    BPF_MAP_TYPE_XSKMAP = 17,
    BPF_MAP_TYPE_SOCKHASH = 18,
    BPF_MAP_TYPE_CGROUP_STORAGE = 19,
    BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,
    BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
    BPF_MAP_TYPE_QUEUE = 22,
    BPF_MAP_TYPE_STACK = 23,
    BPF_MAP_TYPE_SK_STORAGE = 24,
    BPF_MAP_TYPE_DEVMAP_HASH = 25
};
#line 139 
enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4,
    BPF_PROG_TYPE_TRACEPOINT = 5,
    BPF_PROG_TYPE_XDP = 6,
    BPF_PROG_TYPE_PERF_EVENT = 7,
    BPF_PROG_TYPE_CGROUP_SKB = 8,
    BPF_PROG_TYPE_CGROUP_SOCK = 9,
    BPF_PROG_TYPE_LWT_IN = 10,
    BPF_PROG_TYPE_LWT_OUT = 11,
    BPF_PROG_TYPE_LWT_XMIT = 12,
    BPF_PROG_TYPE_SOCK_OPS = 13,
    BPF_PROG_TYPE_SK_SKB = 14,
    BPF_PROG_TYPE_CGROUP_DEVICE = 15,
    BPF_PROG_TYPE_SK_MSG = 16,
    BPF_PROG_TYPE_RAW_TRACEPOINT = 17,
    BPF_PROG_TYPE_CGROUP_SOCK_ADDR = 18,
    BPF_PROG_TYPE_LWT_SEG6LOCAL = 19,
    BPF_PROG_TYPE_LIRC_MODE2 = 20,
    BPF_PROG_TYPE_SK_REUSEPORT = 21,
    BPF_PROG_TYPE_FLOW_DISSECTOR = 22,
    BPF_PROG_TYPE_CGROUP_SYSCTL = 23,
    BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 24,
    BPF_PROG_TYPE_CGROUP_SOCKOPT = 25,
    BPF_PROG_TYPE_TRACING = 26
};
#line 169 
enum bpf_attach_type {
    BPF_CGROUP_INET_INGRESS = 0,
    BPF_CGROUP_INET_EGRESS = 1,
    BPF_CGROUP_INET_SOCK_CREATE = 2,
    BPF_CGROUP_SOCK_OPS = 3,
    BPF_SK_SKB_STREAM_PARSER = 4,
    BPF_SK_SKB_STREAM_VERDICT = 5,
    BPF_CGROUP_DEVICE = 6,
    BPF_SK_MSG_VERDICT = 7,
    BPF_CGROUP_INET4_BIND = 8,
    BPF_CGROUP_INET6_BIND = 9,
    BPF_CGROUP_INET4_CONNECT = 10,
    BPF_CGROUP_INET6_CONNECT = 11,
    BPF_CGROUP_INET4_POST_BIND = 12,
    BPF_CGROUP_INET6_POST_BIND = 13,
    BPF_CGROUP_UDP4_SENDMSG = 14,
    BPF_CGROUP_UDP6_SENDMSG = 15,
    BPF_LIRC_MODE2 = 16,
    BPF_FLOW_DISSECTOR = 17,
    BPF_CGROUP_SYSCTL = 18,
    BPF_CGROUP_UDP4_RECVMSG = 19,
    BPF_CGROUP_UDP6_RECVMSG = 20,
    BPF_CGROUP_GETSOCKOPT = 21,
    BPF_CGROUP_SETSOCKOPT = 22,
    BPF_TRACE_RAW_TP = 23,
    BPF_TRACE_FENTRY = 24,
    BPF_TRACE_FEXIT = 25,
    __MAX_BPF_ATTACH_TYPE = 26
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_594 {
   __u32 map_type ;
   __u32 key_size ;
   __u32 value_size ;
   __u32 max_entries ;
   __u32 map_flags ;
   __u32 inner_map_fd ;
   __u32 numa_node ;
   char map_name[16U] ;
   __u32 map_ifindex ;
   __u32 btf_fd ;
   __u32 btf_key_type_id ;
   __u32 btf_value_type_id ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
union __anonunion_596 {
   __u64 value ;
   __u64 next_key ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_595 {
   __u32 map_fd ;
   __u64 key ;
   union __anonunion_596 __anonCompField___anonstruct_595_115 ;
   __u64 flags ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_597 {
   __u32 prog_type ;
   __u32 insn_cnt ;
   __u64 insns ;
   __u64 license ;
   __u32 log_level ;
   __u32 log_size ;
   __u64 log_buf ;
   __u32 kern_version ;
   __u32 prog_flags ;
   char prog_name[16U] ;
   __u32 prog_ifindex ;
   __u32 expected_attach_type ;
   __u32 prog_btf_fd ;
   __u32 func_info_rec_size ;
   __u64 func_info ;
   __u32 func_info_cnt ;
   __u32 line_info_rec_size ;
   __u64 line_info ;
   __u32 line_info_cnt ;
   __u32 attach_btf_id ;
   __u32 attach_prog_fd ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_598 {
   __u64 pathname ;
   __u32 bpf_fd ;
   __u32 file_flags ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_599 {
   __u32 target_fd ;
   __u32 attach_bpf_fd ;
   __u32 attach_type ;
   __u32 attach_flags ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_test_600 {
   __u32 prog_fd ;
   __u32 retval ;
   __u32 data_size_in ;
   __u32 data_size_out ;
   __u64 data_in ;
   __u64 data_out ;
   __u32 repeat ;
   __u32 duration ;
   __u32 ctx_size_in ;
   __u32 ctx_size_out ;
   __u64 ctx_in ;
   __u64 ctx_out ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
union __anonunion_602 {
   __u32 start_id ;
   __u32 prog_id ;
   __u32 map_id ;
   __u32 btf_id ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_601 {
   union __anonunion_602 __anonCompField___anonstruct_601_120 ;
   __u32 next_id ;
   __u32 open_flags ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_info_603 {
   __u32 bpf_fd ;
   __u32 info_len ;
   __u64 info ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_query_604 {
   __u32 target_fd ;
   __u32 attach_type ;
   __u32 query_flags ;
   __u32 attach_flags ;
   __u64 prog_ids ;
   __u32 prog_cnt ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_raw_tracepoint_605 {
   __u64 name ;
   __u32 prog_fd ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_606 {
   __u64 btf ;
   __u64 btf_log_buf ;
   __u32 btf_size ;
   __u32 btf_log_size ;
   __u32 btf_log_level ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_task_fd_query_607 {
   __u32 pid ;
   __u32 fd ;
   __u32 flags ;
   __u32 buf_len ;
   __u64 buf ;
   __u32 prog_id ;
   __u32 fd_type ;
   __u64 probe_offset ;
   __u64 probe_addr ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
union bpf_attr {
   struct __anonstruct_594 __anonCompField_bpf_attr_114 ;
   struct __anonstruct_595 __anonCompField_bpf_attr_116 ;
   struct __anonstruct_597 __anonCompField_bpf_attr_117 ;
   struct __anonstruct_598 __anonCompField_bpf_attr_118 ;
   struct __anonstruct_599 __anonCompField_bpf_attr_119 ;
   struct __anonstruct_test_600 test ;
   struct __anonstruct_601 __anonCompField_bpf_attr_121 ;
   struct __anonstruct_info_603 info ;
   struct __anonstruct_query_604 query ;
   struct __anonstruct_raw_tracepoint_605 raw_tracepoint ;
   struct __anonstruct_606 __anonCompField_bpf_attr_122 ;
   struct __anonstruct_task_fd_query_607 task_fd_query ;
} __attribute__((__aligned__(8)));
#line 3653  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct bpf_func_info {
   __u32 insn_off ;
   __u32 type_id ;
};
#line 3661  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct bpf_line_info {
   __u32 insn_off ;
   __u32 file_name_off ;
   __u32 line_off ;
   __u32 line_col ;
};
#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rbtree_latch.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 215 
struct bpf_prog_aux;
#line 216 
struct bpf_map;
#line 217 
struct btf;
#line 218 
struct btf_type;
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_map_ops {
   int (*map_alloc_check)(union bpf_attr *) ;
   struct bpf_map *(*map_alloc)(union bpf_attr *) ;
   void (*map_release)(struct bpf_map *, struct file *) ;
   void (*map_free)(struct bpf_map *) ;
   int (*map_get_next_key)(struct bpf_map *, void *, void *) ;
   void (*map_release_uref)(struct bpf_map *) ;
   void *(*map_lookup_elem_sys_only)(struct bpf_map *, void *) ;
   void *(*map_lookup_elem)(struct bpf_map *, void *) ;
   int (*map_update_elem)(struct bpf_map *, void *, void *, u64 ) ;
   int (*map_delete_elem)(struct bpf_map *, void *) ;
   int (*map_push_elem)(struct bpf_map *, void *, u64 ) ;
   int (*map_pop_elem)(struct bpf_map *, void *) ;
   int (*map_peek_elem)(struct bpf_map *, void *) ;
   void *(*map_fd_get_ptr)(struct bpf_map *, struct file *, int ) ;
   void (*map_fd_put_ptr)(void *) ;
   u32 (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *) ;
   u32 (*map_fd_sys_lookup_elem)(void *) ;
   void (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *) ;
   int (*map_check_btf)(struct bpf_map *, struct btf *, struct btf_type *, struct btf_type *) ;
   int (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *) ;
   void (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *) ;
   void (*map_poke_run)(struct bpf_map *, u32 , struct bpf_prog *, struct bpf_prog *) ;
   int (*map_direct_value_addr)(struct bpf_map *, u64 *, u32 ) ;
   int (*map_direct_value_meta)(struct bpf_map *, u64 , u32 *) ;
   int (*map_mmap)(struct bpf_map *, struct vm_area_struct *) ;
};
#line 82  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_map_memory {
   u32 pages ;
   struct user_struct *user ;
};
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_map {
   struct bpf_map_ops *ops ;
   struct bpf_map *inner_map_meta ;
   void *security ;
   enum bpf_map_type map_type ;
   u32 key_size ;
   u32 value_size ;
   u32 max_entries ;
   u32 map_flags ;
   int spin_lock_off ;
   u32 id ;
   int numa_node ;
   u32 btf_key_type_id ;
   u32 btf_value_type_id ;
   struct btf *btf ;
   struct bpf_map_memory memory ;
   char name[16U] ;
   bool unpriv_array ;
   bool frozen ;
   atomic64_t refcnt ;
   atomic64_t usercnt ;
   struct work_struct work ;
   struct mutex freeze_mutex ;
   u64 writecnt ;
};
#line 151 
struct bpf_offload_dev;
#line 152 
struct bpf_offloaded_map;
#line 156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_map_dev_ops {
   int (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *) ;
   int (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *) ;
   int (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64 ) ;
   int (*map_delete_elem)(struct bpf_offloaded_map *, void *) ;
};
#line 166  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_offloaded_map {
   struct bpf_map map ;
   struct net_device *netdev ;
   struct bpf_map_dev_ops *dev_ops ;
   void *dev_priv ;
   struct list_head offloads ;
};
#line 327  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_ops {
   int (*test_run)(struct bpf_prog *, union bpf_attr *, union bpf_attr *) ;
};
#line 369  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_offload {
   struct bpf_prog *prog ;
   struct net_device *netdev ;
   struct bpf_offload_dev *offdev ;
   void *dev_priv ;
   struct list_head offloads ;
   bool dev_state ;
   bool opt_failed ;
   void *jited_image ;
   u32 jited_len ;
};
#line 394  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_stats {
   u64 cnt ;
   u64 nsecs ;
   struct u64_stats_sync syncp ;
} __attribute__((__aligned__(16)));
#line 400  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct btf_func_model {
   u8 ret_size ;
   u8 nr_args ;
   u8 arg_size[12U] ;
};
#line 447 
enum bpf_tramp_prog_type {
    BPF_TRAMP_FENTRY = 0,
    BPF_TRAMP_FEXIT = 1,
    BPF_TRAMP_MAX = 2
};
#line 454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct __anonstruct_func_640 {
   struct btf_func_model model ;
   void *addr ;
   bool ftrace_managed ;
};
#line 454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_trampoline {
   struct hlist_node hlist ;
   struct mutex mutex ;
   refcount_t refcnt ;
   u64 key ;
   struct __anonstruct_func_640 func ;
   struct hlist_head progs_hlist[2U] ;
   int progs_cnt[2U] ;
   void *image ;
   u64 selector ;
};
#line 495  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_func_info_aux {
   bool unreliable ;
};
#line 504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct __anonstruct_tail_call_642 {
   struct bpf_map *map ;
   u32 key ;
};
#line 504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
union __anonunion_641 {
   struct __anonstruct_tail_call_642 tail_call ;
};
#line 504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_jit_poke_descriptor {
   void *ip ;
   union __anonunion_641 __anonCompField_bpf_jit_poke_descriptor_147 ;
   bool ip_stable ;
   u8 adj_off ;
   u16 reason ;
};
#line 517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
union __anonunion_643 {
   struct work_struct work ;
   struct callback_head rcu ;
};
#line 517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_aux {
   atomic64_t refcnt ;
   u32 used_map_cnt ;
   u32 max_ctx_offset ;
   u32 max_pkt_offset ;
   u32 max_tp_access ;
   u32 stack_depth ;
   u32 id ;
   u32 func_cnt ;
   u32 func_idx ;
   u32 attach_btf_id ;
   struct bpf_prog *linked_prog ;
   bool verifier_zext ;
   bool offload_requested ;
   bool attach_btf_trace ;
   bool func_proto_unreliable ;
   enum bpf_tramp_prog_type trampoline_prog_type ;
   struct bpf_trampoline *trampoline ;
   struct hlist_node tramp_hlist ;
   struct btf_type *attach_func_proto ;
   char *attach_func_name ;
   struct bpf_prog **func ;
   void *jit_data ;
   struct bpf_jit_poke_descriptor *poke_tab ;
   u32 size_poke_tab ;
   struct latch_tree_node ksym_tnode ;
   struct list_head ksym_lnode ;
   struct bpf_prog_ops *ops ;
   struct bpf_map **used_maps ;
   struct bpf_prog *prog ;
   struct user_struct *user ;
   u64 load_time ;
   struct bpf_map *cgroup_storage[2U] ;
   char name[16U] ;
   void *security ;
   struct bpf_prog_offload *offload ;
   struct btf *btf ;
   struct bpf_func_info *func_info ;
   struct bpf_func_info_aux *func_info_aux ;
   struct bpf_line_info *linfo ;
   void **jited_linfo ;
   u32 func_info_cnt ;
   u32 nr_linfo ;
   u32 linfo_idx ;
   u32 num_exentries ;
   struct exception_table_entry *extable ;
   struct bpf_prog_stats *stats ;
   union __anonunion_643 __anonCompField_bpf_prog_aux_148 ;
};
#line 686 
struct bpf_cgroup_storage;
#line 686  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_array_item {
   struct bpf_prog *prog ;
   struct bpf_cgroup_storage *cgroup_storage[2U] ;
};
#line 691  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_array {
   struct callback_head rcu ;
   struct bpf_prog_array_item items[0U] ;
};
#line 1335 
struct cgroup;
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
struct bpf_cgroup_storage_map;
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
struct bpf_storage_buffer {
   struct callback_head rcu ;
   char data[0U] ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
union __anonunion_645 {
   struct bpf_storage_buffer *buf ;
   void *percpu_buf ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
struct bpf_cgroup_storage {
   union __anonunion_645 __anonCompField_bpf_cgroup_storage_150 ;
   struct bpf_cgroup_storage_map *map ;
   struct bpf_cgroup_storage_key key ;
   struct list_head list ;
   struct rb_node node ;
   struct callback_head rcu ;
};
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
struct cgroup_bpf {
   struct bpf_prog_array *effective[26U] ;
   struct list_head progs[26U] ;
   u32 flags[26U] ;
   struct bpf_prog_array *inactive ;
   struct percpu_ref refcnt ;
   struct work_struct release_work ;
};
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kthread.h"
struct kthread_work;
#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kthread.h"
struct kthread_worker {
   unsigned int flags ;
   raw_spinlock_t lock ;
   struct list_head work_list ;
   struct list_head delayed_work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
   int canceling ;
};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kthread.h"
struct kthread_delayed_work {
   struct kthread_work work ;
   struct timer_list timer ;
};
#line 199 
struct cgroup_subsys_state;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/psi_types.h"
struct psi_group_cpu {
   seqcount_t seq ;
   unsigned int tasks[3U] ;
   u32 state_mask ;
   u32 times[6U] ;
   u64 state_start ;
   u32 times_prev[2U][6U] ;
};
#line 96 
struct psi_group;
#line 128  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/psi_types.h"
struct psi_group {
   struct mutex avgs_lock ;
   struct psi_group_cpu *pcpu ;
   u64 avg_total[5U] ;
   u64 avg_last_update ;
   u64 avg_next_update ;
   struct delayed_work avgs_work ;
   u64 total[2U][5U] ;
   unsigned long avg[5U][3U] ;
   atomic_t poll_scheduled ;
   struct kthread_worker *poll_kworker ;
   struct kthread_delayed_work poll_work ;
   struct mutex trigger_lock ;
   struct list_head triggers ;
   u32 nr_triggers[5U] ;
   u32 poll_states ;
   u64 poll_min_period ;
   u64 polling_total[5U] ;
   u64 polling_next_update ;
   u64 polling_until ;
};
#line 166 
struct cgroup_root;
#line 167 
struct cgroup_subsys;
#line 168 
struct cgroup_taskset;
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_file {
   struct kernfs_node *kn ;
   unsigned long notified_at ;
   struct timer_list notify_timer ;
};
#line 133  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct list_head sibling ;
   struct list_head children ;
   struct list_head rstat_css_node ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   atomic_t online_cnt ;
   struct work_struct destroy_work ;
   struct rcu_work destroy_rwork ;
   struct cgroup_subsys_state *parent ;
};
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct css_set {
   struct cgroup_subsys_state *subsys[14U] ;
   refcount_t refcount ;
   struct css_set *dom_cset ;
   struct cgroup *dfl_cgrp ;
   int nr_tasks ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head dying_tasks ;
   struct list_head task_iters ;
   struct list_head e_cset_node[14U] ;
   struct list_head threaded_csets ;
   struct list_head threaded_csets_node ;
   struct hlist_node hlist ;
   struct list_head cgrp_links ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct cgroup *mg_dst_cgrp ;
   struct css_set *mg_dst_cset ;
   bool dead ;
   struct callback_head callback_head ;
};
#line 279  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_base_stat {
   struct task_cputime cputime ;
};
#line 303  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_rstat_cpu {
   struct u64_stats_sync bsync ;
   struct cgroup_base_stat bstat ;
   struct cgroup_base_stat last_bstat ;
   struct cgroup *updated_children ;
   struct cgroup *updated_next ;
};
#line 332  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_freezer_state {
   bool freeze ;
   int e_freeze ;
   int nr_frozen_descendants ;
   int nr_frozen_tasks ;
};
#line 351  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int level ;
   int max_depth ;
   int nr_descendants ;
   int nr_dying_descendants ;
   int max_descendants ;
   int nr_populated_csets ;
   int nr_populated_domain_children ;
   int nr_populated_threaded_children ;
   int nr_threaded_children ;
   struct kernfs_node *kn ;
   struct cgroup_file procs_file ;
   struct cgroup_file events_file ;
   u16 subtree_control ;
   u16 subtree_ss_mask ;
   u16 old_subtree_control ;
   u16 old_subtree_ss_mask ;
   struct cgroup_subsys_state *subsys[14U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[14U] ;
   struct cgroup *dom_cgrp ;
   struct cgroup *old_dom_cgrp ;
   struct cgroup_rstat_cpu *rstat_cpu ;
   struct list_head rstat_css_list ;
   struct cgroup_base_stat last_bstat ;
   struct cgroup_base_stat bstat ;
   struct prev_cputime prev_cputime ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
   struct psi_group psi ;
   struct cgroup_bpf bpf ;
   atomic_t congestion_count ;
   struct cgroup_freezer_state freezer ;
   u64 ancestor_ids[] ;
};
#line 489  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   u64 cgrp_ancestor_id_storage ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 527  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   unsigned long private ;
   size_t max_write_len ;
   unsigned int flags ;
   unsigned int file_offset ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   int (*open)(struct kernfs_open_file *) ;
   void (*release)(struct kernfs_open_file *) ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   __poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *) ;
   struct lock_class_key lockdep_key ;
};
#line 616  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_rstat_flush)(struct cgroup_subsys_state *, int ) ;
   int (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_taskset *) ;
   void (*post_attach)(void) ;
   int (*can_fork)(struct task_struct *) ;
   void (*cancel_fork)(struct task_struct *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct task_struct *) ;
   void (*release)(struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   bool early_init : 1 ;
   bool implicit_on_dfl : 1 ;
   bool threaded : 1 ;
   bool broken_hierarchy : 1 ;
   bool warned_broken_hierarchy : 1 ;
   int id ;
   char *name ;
   char *legacy_name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 783  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct __anonstruct_647 {
   u8 is_data ;
   u8 padding ;
   u16 prioidx ;
   u32 classid ;
} __attribute__((__packed__));
#line 783  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
union __anonunion_646 {
   struct __anonstruct_647 __anonCompField___anonunion_646_151 ;
   u64 val ;
};
#line 783  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct sock_cgroup_data {
   union __anonunion_646 __anonCompField_sock_cgroup_data_152 ;
};
#line 848  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup.h"
struct cgroup_namespace {
   refcount_t count ;
   struct ns_common ns ;
   struct user_namespace *user_ns ;
   struct ucounts *ucounts ;
   struct css_set *root_cset ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netprio_cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
struct xdp_mem_info {
   u32 type ;
   u32 id ;
};
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
struct zero_copy_allocator {
   void (*free)(struct zero_copy_allocator *, unsigned long ) ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
struct xdp_rxq_info {
   struct net_device *dev ;
   u32 queue_index ;
   u32 reg_state ;
   struct xdp_mem_info mem ;
} __attribute__((__aligned__(64)));
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
struct xdp_frame {
   void *data ;
   u16 len ;
   u16 headroom ;
   u16 metasize ;
   struct xdp_mem_info mem ;
   struct net_device *dev_rx ;
};
#line 175 
struct netdev_bpf;
#line 160  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/security.h"
struct xfrm_policy;
#line 161 
struct xfrm_state;
#line 178 
struct request_sock;
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct sighand_struct {
   spinlock_t siglock ;
   refcount_t count ;
   wait_queue_head_t signalfd_wqh ;
   struct k_sigaction action[64U] ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   u64 ac_utime ;
   u64 ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct cpu_itimer {
   u64 expires ;
   u64 incr ;
};
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
};
#line 80 
struct tty_struct;
#line 80 
struct autogroup;
#line 80 
struct tty_audit_buf;
#line 80  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct signal_struct {
   refcount_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   struct hlist_head multiprocess ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int is_child_subreaper : 1 ;
   unsigned int has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct posix_cputimers posix_cputimers ;
   struct pid *pids[4U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   u64 utime ;
   u64 stime ;
   u64 cutime ;
   u64 cstime ;
   u64 gtime ;
   u64 cgtime ;
   struct prev_cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   bool oom_flag_origin ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mm_struct *oom_mm ;
   struct mutex cred_guard_mutex ;
} __attribute__((__designated_init__));
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 211  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netlink.h"
struct netlink_ext_ack {
   char *_msg ;
   struct nlattr *bad_attr ;
   u8 cookie[20U] ;
   u8 cookie_len ;
};
#line 180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netlink.h"
union __anonunion_670 {
   u8 ctx[48U] ;
   long args[6U] ;
};
#line 180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   struct netlink_ext_ack *extack ;
   u16 family ;
   u16 min_dump_alloc ;
   bool strict_check ;
   u16 answer_flags ;
   unsigned int prev_seq ;
   unsigned int seq ;
   union __anonunion_670 __anonCompField_netlink_callback_153 ;
};
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/neighbour.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
   __u64 rx_nohandler ;
};
#line 753  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_link.h"
struct ifla_vf_guid {
   __u32 vf ;
   __u64 guid ;
};
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
   __u32 trusted ;
   __be16 vlan_proto ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/pkt_sched.h"
struct tc_stats {
   __u64 bytes ;
   __u32 packets ;
   __u32 drops ;
   __u32 overlimits ;
   __u32 bps ;
   __u32 pps ;
   __u32 qlen ;
   __u32 backlog ;
};
#line 102  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/pkt_sched.h"
struct tc_sizespec {
   unsigned char cell_log ;
   unsigned char size_log ;
   short cell_align ;
   int overhead ;
   unsigned int linklayer ;
   unsigned int mpu ;
   unsigned int mtu ;
   unsigned int tsize ;
};
#line 702  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/pkt_sched.h"
struct tc_mqprio_qopt {
   __u8 num_tc ;
   __u8 prio_tc_map[16U] ;
   __u8 hw ;
   __u16 count[16U] ;
   __u16 offset[16U] ;
};
#line 118  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hashtable.h"
struct netpoll_info;
#line 120 
struct dsa_port;
#line 121 
struct sfp_bus;
#line 122 
struct wireless_dev;
#line 123 
struct wpan_dev;
#line 124 
struct mpls_dev;
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 195 
struct neigh_parms;
#line 217  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 237  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct hh_cache {
   unsigned int hh_len ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 263  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void *, void *, unsigned int ) ;
   int (*parse)(struct sk_buff *, unsigned char *) ;
   int (*cache)(struct neighbour *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device *, unsigned char *) ;
   bool (*validate)(char *, unsigned int ) ;
   __be16 (*parse_protocol)(struct sk_buff *) ;
};
#line 302  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct gro_list {
   struct list_head list ;
   int count ;
};
#line 316  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned long gro_bitmask ;
   int (*poll)(struct napi_struct *, int ) ;
   int poll_owner ;
   struct net_device *dev ;
   struct gro_list gro_hash[8U] ;
   struct sk_buff *skb ;
   struct list_head rx_list ;
   int rx_count ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 372 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};
#line 379  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 421  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);
#line 589 
struct Qdisc;
#line 589 
struct xdp_umem;
#line 589  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   unsigned long tx_maxrate ;
   unsigned long trans_timeout ;
   struct net_device *sb_dev ;
   struct xdp_umem *umem ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long state ;
   struct dql dql ;
} __attribute__((__aligned__(64)));
#line 662  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 674  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 684  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 736  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
   struct xdp_rxq_info xdp_rxq ;
   struct xdp_umem *umem ;
} __attribute__((__aligned__(64)));
#line 764  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 777  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *attr_map[0U] ;
};
#line 793  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 803  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 820  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 833 
enum tc_setup_type {
    TC_SETUP_QDISC_MQPRIO = 0,
    TC_SETUP_CLSU32 = 1,
    TC_SETUP_CLSFLOWER = 2,
    TC_SETUP_CLSMATCHALL = 3,
    TC_SETUP_CLSBPF = 4,
    TC_SETUP_BLOCK = 5,
    TC_SETUP_QDISC_CBS = 6,
    TC_SETUP_QDISC_RED = 7,
    TC_SETUP_QDISC_PRIO = 8,
    TC_SETUP_QDISC_MQ = 9,
    TC_SETUP_QDISC_ETF = 10,
    TC_SETUP_ROOT_QDISC = 11,
    TC_SETUP_QDISC_GRED = 12,
    TC_SETUP_QDISC_TAPRIO = 13,
    TC_SETUP_FT = 14
};
#line 851 
enum bpf_netdev_command {
    XDP_SETUP_PROG = 0,
    XDP_SETUP_PROG_HW = 1,
    XDP_QUERY_PROG = 2,
    XDP_QUERY_PROG_HW = 3,
    BPF_OFFLOAD_MAP_ALLOC = 4,
    BPF_OFFLOAD_MAP_FREE = 5,
    XDP_SETUP_XSK_UMEM = 6
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_675 {
   u32 flags ;
   struct bpf_prog *prog ;
   struct netlink_ext_ack *extack ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_676 {
   u32 prog_id ;
   u32 prog_flags ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_677 {
   struct bpf_offloaded_map *offmap ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_xsk_678 {
   struct xdp_umem *umem ;
   u16 queue_id ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
union __anonunion_674 {
   struct __anonstruct_675 __anonCompField___anonunion_674_155 ;
   struct __anonstruct_676 __anonCompField___anonunion_674_156 ;
   struct __anonstruct_677 __anonCompField___anonunion_674_157 ;
   struct __anonstruct_xsk_678 xsk ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_bpf {
   enum bpf_netdev_command command ;
   union __anonunion_674 __anonCompField_netdev_bpf_158 ;
};
#line 911  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct xfrmdev_ops {
   int (*xdo_dev_state_add)(struct xfrm_state *) ;
   void (*xdo_dev_state_delete)(struct xfrm_state *) ;
   void (*xdo_dev_state_free)(struct xfrm_state *) ;
   bool (*xdo_dev_offload_ok)(struct sk_buff *, struct xfrm_state *) ;
   void (*xdo_dev_state_advance_esn)(struct xfrm_state *) ;
};
#line 921  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct dev_ifalias {
   struct callback_head rcuhead ;
   char ifalias[] ;
};
#line 926 
struct tlsdev_ops;
#line 929  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_name_node {
   struct hlist_node hlist ;
   struct list_head list ;
   struct net_device *dev ;
   char *name ;
};
#line 1257 
struct devlink_port;
#line 1257  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   void (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   bool (*ndo_has_offload_stats)(struct net_device *, int ) ;
   int (*ndo_get_offload_stats)(int , struct net_device *, void *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 , __be16 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_set_vf_trust)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_get_vf_guid)(struct net_device *, int , struct ifla_vf_guid *, struct ifla_vf_guid *) ;
   int (*ndo_set_vf_guid)(struct net_device *, int , u64 , int ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, enum tc_setup_type , void *) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct net_device *, struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct net_device *, struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char *, u16 , u16 , struct netlink_ext_ack *) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *) ;
   int (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, unsigned char *, u16 , u32 , u32 , struct netlink_ext_ack *) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 , struct netlink_ext_ack *) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_udp_tunnel_add)(struct net_device *, struct udp_tunnel_info *) ;
   void (*ndo_udp_tunnel_del)(struct net_device *, struct udp_tunnel_info *) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device *) ;
   int (*ndo_change_proto_down)(struct net_device *, bool ) ;
   int (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *) ;
   void (*ndo_set_rx_headroom)(struct net_device *, int ) ;
   int (*ndo_bpf)(struct net_device *, struct netdev_bpf *) ;
   int (*ndo_xdp_xmit)(struct net_device *, int , struct xdp_frame **, u32 ) ;
   int (*ndo_xsk_wakeup)(struct net_device *, u32 , u32 ) ;
   struct devlink_port *(*ndo_get_devlink_port)(struct net_device *) ;
};
#line 1492 
enum ldv_14518 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
};
#line 1501 
enum ldv_14519 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
};
#line 1795  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_adj_list_679 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1795 
struct iw_handler_def;
#line 1795 
struct iw_public_data;
#line 1795 
struct l3mdev_ops;
#line 1795 
struct ndisc_ops;
#line 1795 
struct vlan_info;
#line 1795 
struct tipc_bearer;
#line 1795 
struct in_device;
#line 1795 
struct dn_dev;
#line 1795 
struct inet6_dev;
#line 1795 
struct mini_Qdisc;
#line 1795 
struct cpu_rmap;
#line 1795 
struct pcpu_lstats;
#line 1795 
struct pcpu_sw_netstats;
#line 1795 
struct pcpu_dstats;
#line 1795  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
union __anonunion_680 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
};
#line 1795 
struct garp_port;
#line 1795 
struct mrp_port;
#line 1795 
struct rtnl_link_ops;
#line 1795  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct netdev_name_node *name_node ;
   struct dev_ifalias *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_679 adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   netdev_features_t gso_partial_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   atomic_long_t rx_nohandler ;
   atomic_t carrier_up_count ;
   atomic_t carrier_down_count ;
   struct iw_handler_def *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops *netdev_ops ;
   struct ethtool_ops *ethtool_ops ;
   struct l3mdev_ops *l3mdev_ops ;
   struct ndisc_ops *ndisc_ops ;
   struct xfrmdev_ops *xfrmdev_ops ;
   struct tlsdev_ops *tlsdev_ops ;
   struct header_ops *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned int min_mtu ;
   unsigned int max_mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned char min_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned char upper_level ;
   unsigned char lower_level ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_port *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   struct bpf_prog *xdp_prog ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct mini_Qdisc *miniq_ingress ;
   struct netdev_queue *ingress_queue ;
   struct nf_hook_entries *nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   struct hlist_head qdisc_hash[16U] ;
   unsigned int tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_cpus_map ;
   struct xps_dev_maps *xps_rxqs_map ;
   struct mini_Qdisc *miniq_egress ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   enum ldv_14518 reg_state : 8 ;
   bool dismantle ;
   enum ldv_14519 rtnl_link_state : 16 ;
   bool needs_free_netdev ;
   void (*priv_destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_680 __anonCompField_net_device_159 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group *sysfs_groups[4U] ;
   struct attribute_group *sysfs_rx_queue_group ;
   struct rtnl_link_ops *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   struct dcbnl_rtnl_ops *dcbnl_ops ;
   s16 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct sfp_bus *sfp_bus ;
   struct lock_class_key qdisc_tx_busylock_key ;
   struct lock_class_key qdisc_running_key ;
   struct lock_class_key qdisc_xmit_lock_key ;
   struct lock_class_key addr_list_lock_key ;
   bool proto_down ;
   unsigned int wol_enabled : 1 ;
};
#line 2400  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
} __attribute__((__aligned__(32)));
#line 2408  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct pcpu_lstats {
   u64_stats_t packets ;
   u64_stats_t bytes ;
   struct u64_stats_sync syncp ;
} __attribute__((__aligned__(16)));
#line 3610 
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
};
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/page_counter.h"
struct page_counter {
   atomic_long_t usage ;
   unsigned long min ;
   unsigned long low ;
   unsigned long max ;
   struct page_counter *parent ;
   unsigned long emin ;
   atomic_long_t min_usage ;
   atomic_long_t children_min_usage ;
   unsigned long elow ;
   atomic_long_t low_usage ;
   atomic_long_t children_low_usage ;
   unsigned long watermark ;
   unsigned long failcnt ;
};
#line 66 
struct eventfd_ctx;
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/vmpressure.h"
struct vmpressure {
   unsigned long scanned ;
   unsigned long reclaimed ;
   unsigned long tree_scanned ;
   unsigned long tree_reclaimed ;
   spinlock_t sr_lock ;
   struct list_head events ;
   struct mutex events_lock ;
   struct work_struct work ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/flex_proportions.h"
struct fprop_global {
   struct percpu_counter events ;
   unsigned int period ;
   seqcount_t sequence ;
};
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/flex_proportions.h"
typedef int congested_fn(void *, int );
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backing-dev-defs.h"
enum wb_reason {
    WB_REASON_BACKGROUND = 0,
    WB_REASON_VMSCAN = 1,
    WB_REASON_SYNC = 2,
    WB_REASON_PERIODIC = 3,
    WB_REASON_LAPTOP_TIMER = 4,
    WB_REASON_FREE_MORE_MEM = 5,
    WB_REASON_FS_FREE_SPACE = 6,
    WB_REASON_FORKER_THREAD = 7,
    WB_REASON_FOREIGN_FLUSH = 8,
    WB_REASON_MAX = 9
};
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backing-dev-defs.h"
struct wb_completion {
   atomic_t cnt ;
   wait_queue_head_t *waitq ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backing-dev-defs.h"
struct bdi_writeback_congested {
   unsigned long state ;
   refcount_t refcnt ;
   struct backing_dev_info *__bdi ;
   int blkcg_id ;
   struct rb_node rb_node ;
};
#line 130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backing-dev-defs.h"
union __anonunion_687 {
   struct work_struct release_work ;
   struct callback_head rcu ;
};
#line 130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backing-dev-defs.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned long state ;
   unsigned long last_old_flush ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   struct list_head b_dirty_time ;
   spinlock_t list_lock ;
   struct percpu_counter stat[4U] ;
   struct bdi_writeback_congested *congested ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   enum wb_reason start_all_reason ;
   spinlock_t work_lock ;
   struct list_head work_list ;
   struct delayed_work dwork ;
   unsigned long dirty_sleep ;
   struct list_head bdi_node ;
   struct percpu_ref refcnt ;
   struct fprop_local_percpu memcg_completions ;
   struct cgroup_subsys_state *memcg_css ;
   struct cgroup_subsys_state *blkcg_css ;
   struct list_head memcg_node ;
   struct list_head blkcg_node ;
   union __anonunion_687 __anonCompField_bdi_writeback_160 ;
};
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backing-dev-defs.h"
struct backing_dev_info {
   u64 id ;
   struct rb_node rb_node ;
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned long io_pages ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   struct kref refcnt ;
   unsigned int capabilities ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   atomic_long_t tot_write_bandwidth ;
   struct bdi_writeback wb ;
   struct list_head wb_list ;
   struct xarray cgwb_tree ;
   struct rb_root cgwb_congested_tree ;
   struct mutex cgwb_release_mutex ;
   struct rw_semaphore wb_switch_rwsem ;
   wait_queue_head_t wb_waitq ;
   struct device *dev ;
   struct device *owner ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
};
#line 306 
struct bio_set;
#line 307 
struct bio_integrity_payload;
#line 308  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backing-dev-defs.h"
typedef void bio_end_io_t(struct bio *);
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk_types.h"
typedef u8 blk_status_t;
#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk_types.h"
struct bio_issue {
   u64 value ;
};
#line 144 
struct blkcg_gq;
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk_types.h"
union __anonunion_688 {
   struct bio_integrity_payload *bi_integrity ;
};
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk_types.h"
struct bio {
   struct bio *bi_next ;
   struct gendisk *bi_disk ;
   unsigned int bi_opf ;
   unsigned short bi_flags ;
   unsigned short bi_ioprio ;
   unsigned short bi_write_hint ;
   blk_status_t bi_status ;
   u8 bi_partno ;
   atomic_t __bi_remaining ;
   struct bvec_iter bi_iter ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct blkcg_gq *bi_blkg ;
   struct bio_issue bi_issue ;
   u64 bi_iocost_cost ;
   union __anonunion_688 __anonCompField_bio_161 ;
   unsigned short bi_vcnt ;
   unsigned short bi_max_vecs ;
   atomic_t __bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 452  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk_types.h"
typedef unsigned int blk_qc_t;
#line 479  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk_types.h"
struct blk_rq_stat {
   u64 mean ;
   u64 min ;
   u64 max ;
   u32 nr_samples ;
   u64 batch ;
};
#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/genhd.h"
struct disk_stats {
   u64 nsecs[4U] ;
   unsigned long sectors[4U] ;
   unsigned long ios[4U] ;
   unsigned long merges[4U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
   local_t in_flight[2U] ;
};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   struct disk_stats *dkstats ;
   struct percpu_ref ref ;
   struct rcu_work rcu_work ;
};
#line 160  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 166 
struct disk_events;
#line 167 
struct badblocks;
#line 172 
struct blk_integrity_profile;
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/genhd.h"
struct blk_integrity {
   struct blk_integrity_profile *profile ;
   unsigned char flags ;
   unsigned char tuple_size ;
   unsigned char interval_exp ;
   unsigned char tag_size ;
};
#line 182 
struct timer_rand_state;
#line 182  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk *, umode_t *) ;
   unsigned short events ;
   unsigned short event_flags ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct rw_semaphore lookup_sem ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct kobject integrity_kobj ;
   int node_id ;
   struct badblocks *bb ;
   struct lockdep_map lockdep_map ;
};
#line 637  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pagemap.h"
typedef void *mempool_alloc_t(gfp_t , void *);
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mempool.h"
typedef void mempool_free_t(void *, void *);
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 307  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   struct bvec_iter bip_iter ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_max_vcnt ;
   unsigned short bip_flags ;
   struct bvec_iter bio_iter ;
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};
#line 575  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 703  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t bio_pool ;
   mempool_t bvec_pool ;
   mempool_t bio_integrity_pool ;
   mempool_t bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bsg.h"
struct sg_io_v4 {
   __s32 guard ;
   __u32 protocol ;
   __u32 subprotocol ;
   __u32 request_len ;
   __u64 request ;
   __u64 request_tag ;
   __u32 request_attr ;
   __u32 request_priority ;
   __u32 request_extra ;
   __u32 max_response_len ;
   __u64 response ;
   __u32 dout_iovec_count ;
   __u32 dout_xfer_len ;
   __u32 din_iovec_count ;
   __u32 din_xfer_len ;
   __u64 dout_xferp ;
   __u64 din_xferp ;
   __u32 timeout ;
   __u32 flags ;
   __u64 usr_ptr ;
   __u32 spare_in ;
   __u32 driver_status ;
   __u32 transport_status ;
   __u32 device_status ;
   __u32 retry_delay ;
   __u32 info ;
   __u32 duration ;
   __u32 response_len ;
   __s32 din_resid ;
   __s32 dout_resid ;
   __u64 generated_tag ;
   __u32 spare_out ;
   __u32 padding ;
};
#line 65 
struct request;
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bsg.h"
struct bsg_ops {
   int (*check_proto)(struct sg_io_v4 *) ;
   int (*fill_hdr)(struct request *, struct sg_io_v4 *, fmode_t ) ;
   int (*complete_rq)(struct request *, struct sg_io_v4 *) ;
   void (*free_rq)(struct request *) ;
};
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   int minor ;
   struct request_queue *queue ;
   struct bsg_ops *ops ;
};
#line 94  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/blkzoned.h"
struct blk_zone {
   __u64 start ;
   __u64 len ;
   __u64 wp ;
   __u8 type ;
   __u8 cond ;
   __u8 non_seq ;
   __u8 reset ;
   __u8 reserved[36U] ;
};
#line 134 
struct elevator_queue;
#line 135 
struct blk_trace;
#line 138 
struct blk_flush_queue;
#line 139 
struct pr_ops;
#line 140 
struct rq_qos;
#line 141 
struct blk_queue_stats;
#line 142 
struct blk_stat_callback;
#line 143  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/blkzoned.h"
typedef void rq_end_io_fn(struct request *, blk_status_t );
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
typedef __u32 req_flags_t;
#line 67 
enum mq_rq_state {
    MQ_RQ_IDLE = 0,
    MQ_RQ_IN_FLIGHT = 1,
    MQ_RQ_COMPLETE = 2
};
#line 132 
struct blk_mq_ctx;
#line 132 
struct blk_mq_hw_ctx;
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
union __anonunion_691 {
   struct hlist_node hash ;
   struct list_head ipi_list ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
union __anonunion_692 {
   struct rb_node rb_node ;
   struct bio_vec special_vec ;
   void *completion_data ;
   int error_count ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct __anonstruct_elv_694 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct __anonstruct_flush_695 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
union __anonunion_693 {
   struct __anonstruct_elv_694 elv ;
   struct __anonstruct_flush_695 flush ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
union __anonunion_696 {
   struct __call_single_data csd ;
   u64 fifo_time ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct request {
   struct request_queue *q ;
   struct blk_mq_ctx *mq_ctx ;
   struct blk_mq_hw_ctx *mq_hctx ;
   unsigned int cmd_flags ;
   req_flags_t rq_flags ;
   int tag ;
   int internal_tag ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   struct list_head queuelist ;
   union __anonunion_691 __anonCompField_request_162 ;
   union __anonunion_692 __anonCompField_request_163 ;
   union __anonunion_693 __anonCompField_request_164 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   u64 alloc_time_ns ;
   u64 start_time_ns ;
   u64 io_start_time_ns ;
   unsigned short wbt_flags ;
   unsigned short stats_sectors ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short write_hint ;
   unsigned short ioprio ;
   unsigned int extra_len ;
   enum mq_rq_state state ;
   refcount_t ref ;
   unsigned int timeout ;
   unsigned long deadline ;
   union __anonunion_696 __anonCompField_request_165 ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
};
#line 285 
struct elevator_type;
#line 286 
struct blk_mq_debugfs_attr;
#line 287 
enum elv_merge {
    ELEVATOR_NO_MERGE = 0,
    ELEVATOR_FRONT_MERGE = 1,
    ELEVATOR_BACK_MERGE = 2,
    ELEVATOR_DISCARD_MERGE = 3
};
#line 294 
struct blk_mq_alloc_data;
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/elevator.h"
struct elevator_mq_ops {
   int (*init_sched)(struct request_queue *, struct elevator_type *) ;
   void (*exit_sched)(struct elevator_queue *) ;
   int (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int ) ;
   void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int ) ;
   void (*depth_updated)(struct blk_mq_hw_ctx *) ;
   bool (*allow_merge)(struct request_queue *, struct request *, struct bio *) ;
   bool (*bio_merge)(struct blk_mq_hw_ctx *, struct bio *, unsigned int ) ;
   int (*request_merge)(struct request_queue *, struct request **, struct bio *) ;
   void (*request_merged)(struct request_queue *, struct request *, enum elv_merge ) ;
   void (*requests_merged)(struct request_queue *, struct request *, struct request *) ;
   void (*limit_depth)(unsigned int , struct blk_mq_alloc_data *) ;
   void (*prepare_request)(struct request *, struct bio *) ;
   void (*finish_request)(struct request *) ;
   void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, bool ) ;
   struct request *(*dispatch_request)(struct blk_mq_hw_ctx *) ;
   bool (*has_work)(struct blk_mq_hw_ctx *) ;
   void (*completed_request)(struct request *, u64 ) ;
   void (*requeue_request)(struct request *) ;
   struct request *(*former_request)(struct request_queue *, struct request *) ;
   struct request *(*next_request)(struct request_queue *, struct request *) ;
   void (*init_icq)(struct io_cq *) ;
   void (*exit_icq)(struct io_cq *) ;
};
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue *, char *) ;
   ssize_t (*store)(struct elevator_queue *, char *, size_t ) ;
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_mq_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char *elevator_name ;
   char *elevator_alias ;
   unsigned int elevator_features ;
   struct module *elevator_owner ;
   struct blk_mq_debugfs_attr *queue_debugfs_attrs ;
   struct blk_mq_debugfs_attr *hctx_debugfs_attrs ;
   char icq_cache_name[22U] ;
   struct list_head list ;
};
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned int registered : 1 ;
   struct hlist_head hash[64U] ;
};
#line 153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/elevator.h"
typedef blk_qc_t make_request_fn(struct request_queue *, struct bio *);
#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request *);
#line 304 
enum blk_zoned_model {
    BLK_ZONED_NONE = 0,
    BLK_ZONED_HA = 1,
    BLK_ZONED_HM = 2
};
#line 320  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned long virt_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int max_dev_sectors ;
   unsigned int chunk_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int logical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_hw_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int max_write_zeroes_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned short max_discard_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char raid_partial_stripes_expensive ;
   enum blk_zoned_model zoned ;
};
#line 394 
struct blk_mq_ops;
#line 394 
struct throtl_data;
#line 394 
struct blk_mq_tag_set;
#line 394  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct request_queue {
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   struct blk_queue_stats *stats ;
   struct rq_qos *rq_qos ;
   make_request_fn *make_request_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   struct blk_mq_ops *mq_ops ;
   struct blk_mq_ctx *queue_ctx ;
   unsigned int queue_depth ;
   struct blk_mq_hw_ctx **queue_hw_ctx ;
   unsigned int nr_hw_queues ;
   struct backing_dev_info *backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   atomic_t pm_only ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t queue_lock ;
   struct kobject kobj ;
   struct kobject *mq_kobj ;
   struct blk_integrity integrity ;
   struct device *dev ;
   int rpm_status ;
   unsigned int nr_pending ;
   unsigned long nr_requests ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   unsigned int rq_timeout ;
   int poll_nsec ;
   struct blk_stat_callback *poll_cb ;
   struct blk_rq_stat poll_stat[16U] ;
   struct timer_list timeout ;
   struct work_struct timeout_work ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int required_elevator_features ;
   unsigned int nr_zones ;
   unsigned long *conv_zones_bitmap ;
   unsigned long *seq_zones_wlock ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   struct blk_trace *blk_trace ;
   struct mutex blk_trace_mutex ;
   struct blk_flush_queue *fq ;
   struct list_head requeue_list ;
   spinlock_t requeue_lock ;
   struct delayed_work requeue_work ;
   struct mutex sysfs_lock ;
   struct mutex sysfs_dir_lock ;
   struct list_head unused_hctx_list ;
   spinlock_t unused_hctx_lock ;
   int mq_freeze_depth ;
   struct bsg_class_device bsg_dev ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
   wait_queue_head_t mq_freeze_wq ;
   struct mutex mq_freeze_lock ;
   struct percpu_ref q_usage_counter ;
   struct blk_mq_tag_set *tag_set ;
   struct list_head tag_set_list ;
   struct bio_set bio_split ;
   struct dentry *debugfs_dir ;
   struct dentry *sched_debugfs_dir ;
   struct dentry *rqos_debugfs_dir ;
   bool mq_sysfs_init_done ;
   size_t cmd_size ;
   struct work_struct release_work ;
   u64 write_hints[5U] ;
};
#line 1160  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct blk_plug {
   struct list_head mq_list ;
   struct list_head cb_list ;
   unsigned short rq_count ;
   bool multiple_queues ;
};
#line 1514  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct blk_integrity_iter {
   void *prot_buf ;
   void *data_buf ;
   sector_t seed ;
   unsigned int data_size ;
   unsigned short interval ;
   char *disk_name ;
};
#line 1522  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
typedef blk_status_t integrity_processing_fn(struct blk_integrity_iter *);
#line 1524  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
typedef void integrity_prepare_fn(struct request *);
#line 1525  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
typedef void integrity_complete_fn(struct request *, unsigned int );
#line 1527  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct blk_integrity_profile {
   integrity_processing_fn *generate_fn ;
   integrity_processing_fn *verify_fn ;
   integrity_prepare_fn *prepare_fn ;
   integrity_complete_fn *complete_fn ;
   char *name ;
};
#line 1693  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device *, fmode_t ) ;
   void (*release)(struct gendisk *, fmode_t ) ;
   int (*rw_page)(struct block_device *, sector_t , struct page *, unsigned int ) ;
   int (*ioctl)(struct block_device *, fmode_t , unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct block_device *, fmode_t , unsigned int , unsigned long ) ;
   unsigned int (*check_events)(struct gendisk *, unsigned int ) ;
   int (*media_changed)(struct gendisk *) ;
   void (*unlock_native_capacity)(struct gendisk *) ;
   int (*revalidate_disk)(struct gendisk *) ;
   int (*getgeo)(struct block_device *, struct hd_geometry *) ;
   void (*swap_slot_free_notify)(struct block_device *, unsigned long ) ;
   int (*report_zones)(struct gendisk *, sector_t , unsigned int , int (*)(struct blk_zone *, unsigned int , void *), void *) ;
   struct module *owner ;
   struct pr_ops *pr_ops ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-cgroup.h"
struct blkcg_policy_data;
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-cgroup.h"
struct blkcg {
   struct cgroup_subsys_state css ;
   spinlock_t lock ;
   struct xarray blkg_tree ;
   struct blkcg_gq *blkg_hint ;
   struct hlist_head blkg_list ;
   struct blkcg_policy_data *cpd[5U] ;
   struct list_head all_blkcgs_node ;
   struct list_head cgwb_list ;
   refcount_t cgwb_refcnt ;
};
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-cgroup.h"
struct blkg_iostat {
   u64 bytes[3U] ;
   u64 ios[3U] ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-cgroup.h"
struct blkg_iostat_set {
   struct u64_stats_sync sync ;
   struct blkg_iostat cur ;
   struct blkg_iostat last ;
};
#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-cgroup.h"
struct blkg_policy_data {
   struct blkcg_gq *blkg ;
   int plid ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-cgroup.h"
struct blkcg_policy_data {
   struct blkcg *blkcg ;
   int plid ;
};
#line 105  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/blk-cgroup.h"
struct blkcg_gq {
   struct request_queue *q ;
   struct list_head q_node ;
   struct hlist_node blkcg_node ;
   struct blkcg *blkcg ;
   struct bdi_writeback_congested *wb_congested ;
   struct blkcg_gq *parent ;
   struct percpu_ref refcnt ;
   bool online ;
   struct blkg_iostat_set *iostat_cpu ;
   struct blkg_iostat_set iostat ;
   struct blkg_policy_data *pd[5U] ;
   spinlock_t async_bio_lock ;
   struct bio_list async_bios ;
   struct work_struct async_bio_work ;
   atomic_t use_delay ;
   atomic64_t delay_nsec ;
   atomic64_t delay_start ;
   u64 last_delay ;
   int last_use ;
   struct callback_head callback_head ;
};
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/writeback.h"
enum writeback_sync_modes {
    WB_SYNC_NONE = 0,
    WB_SYNC_ALL = 1
};
#line 51  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/writeback.h"
struct writeback_control {
   long nr_to_write ;
   long pages_skipped ;
   loff_t range_start ;
   loff_t range_end ;
   enum writeback_sync_modes sync_mode ;
   unsigned int for_kupdate : 1 ;
   unsigned int for_background : 1 ;
   unsigned int tagged_writepages : 1 ;
   unsigned int for_reclaim : 1 ;
   unsigned int range_cyclic : 1 ;
   unsigned int for_sync : 1 ;
   unsigned int no_cgroup_owner : 1 ;
   unsigned int punt_to_cgroup : 1 ;
   struct bdi_writeback *wb ;
   struct inode *inode ;
   int wb_id ;
   int wb_lcand_id ;
   int wb_tcand_id ;
   size_t wb_bytes ;
   size_t wb_lcand_bytes ;
   size_t wb_tcand_bytes ;
};
#line 129  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/writeback.h"
struct wb_domain {
   spinlock_t lock ;
   struct fprop_global completions ;
   struct timer_list period_timer ;
   unsigned long period_time ;
   unsigned long dirty_limit_tstamp ;
   unsigned long dirty_limit ;
};
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct mem_cgroup_id {
   int id ;
   refcount_t ref ;
};
#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct memcg_vmstats_percpu {
   long stat[38U] ;
   unsigned long events[91U] ;
   unsigned long nr_page_events ;
   unsigned long targets[2U] ;
};
#line 93  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct mem_cgroup_reclaim_iter {
   struct mem_cgroup *position ;
   unsigned int generation ;
};
#line 99  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct lruvec_stat {
   long count[32U] ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct memcg_shrinker_map {
   struct callback_head rcu ;
   unsigned long map[0U] ;
};
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct mem_cgroup_per_node {
   struct lruvec lruvec ;
   struct lruvec_stat *lruvec_stat_local ;
   struct lruvec_stat *lruvec_stat_cpu ;
   atomic_long_t lruvec_stat[32U] ;
   unsigned long lru_zone_size[5U][5U] ;
   struct mem_cgroup_reclaim_iter iter ;
   struct memcg_shrinker_map *shrinker_map ;
   struct rb_node tree_node ;
   unsigned long usage_in_excess ;
   bool on_tree ;
   struct mem_cgroup *memcg ;
};
#line 139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct mem_cgroup_threshold {
   struct eventfd_ctx *eventfd ;
   unsigned long threshold ;
};
#line 145  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct mem_cgroup_threshold_ary {
   int current_threshold ;
   unsigned int size ;
   struct mem_cgroup_threshold entries[0U] ;
};
#line 154  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct mem_cgroup_thresholds {
   struct mem_cgroup_threshold_ary *primary ;
   struct mem_cgroup_threshold_ary *spare ;
};
#line 164 
enum memcg_kmem_state {
    KMEM_NONE = 0,
    KMEM_ALLOCATED = 1,
    KMEM_ONLINE = 2
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct memcg_padding {
   char x[0U] ;
} __attribute__((__aligned__(4096)));
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct memcg_cgwb_frn {
   u64 bdi_id ;
   int memcg_id ;
   u64 at ;
   struct wb_completion done ;
};
#line 203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memcontrol.h"
struct mem_cgroup {
   struct cgroup_subsys_state css ;
   struct mem_cgroup_id id ;
   struct page_counter memory ;
   struct page_counter swap ;
   struct page_counter memsw ;
   struct page_counter kmem ;
   struct page_counter tcpmem ;
   unsigned long high ;
   struct work_struct high_work ;
   unsigned long soft_limit ;
   struct vmpressure vmpressure ;
   bool use_hierarchy ;
   bool oom_group ;
   bool oom_lock ;
   int under_oom ;
   int swappiness ;
   int oom_kill_disable ;
   struct cgroup_file events_file ;
   struct cgroup_file events_local_file ;
   struct cgroup_file swap_events_file ;
   struct mutex thresholds_lock ;
   struct mem_cgroup_thresholds thresholds ;
   struct mem_cgroup_thresholds memsw_thresholds ;
   struct list_head oom_notify ;
   unsigned long move_charge_at_immigrate ;
   spinlock_t move_lock ;
   unsigned long move_lock_flags ;
   struct memcg_padding _pad1_ ;
   atomic_t moving_account ;
   struct task_struct *move_lock_task ;
   struct memcg_vmstats_percpu *vmstats_local ;
   struct memcg_vmstats_percpu *vmstats_percpu ;
   struct memcg_padding _pad2_ ;
   atomic_long_t vmstats[38U] ;
   atomic_long_t vmevents[91U] ;
   atomic_long_t memory_events[7U] ;
   atomic_long_t memory_events_local[7U] ;
   unsigned long socket_pressure ;
   bool tcpmem_active ;
   int tcpmem_pressure ;
   int kmemcg_id ;
   enum memcg_kmem_state kmem_state ;
   struct list_head kmem_caches ;
   struct list_head cgwb_list ;
   struct wb_domain cgwb_domain ;
   struct memcg_cgwb_frn cgwb_frn[4U] ;
   struct list_head event_list ;
   spinlock_t event_list_lock ;
   struct deferred_split deferred_split_queue ;
   struct mem_cgroup_per_node *nodeinfo[0U] ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/vdso.h"
struct vdso_image {
   void *data ;
   unsigned long size ;
   unsigned long alt ;
   unsigned long alt_len ;
   long sym_vvar_start ;
   long sym_vvar_page ;
   long sym_pvclock_page ;
   long sym_hvclock_page ;
   long sym_VDSO32_NOTE_MASK ;
   long sym___kernel_sigreturn ;
   long sym___kernel_rt_sigreturn ;
   long sym___kernel_vsyscall ;
   long sym_int80_landing_pad ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u64 Elf64_Off;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 192  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 200  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 221  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
struct elf64_hdr {
   unsigned char e_ident[16U] ;
   Elf64_Half e_type ;
   Elf64_Half e_machine ;
   Elf64_Word e_version ;
   Elf64_Addr e_entry ;
   Elf64_Off e_phoff ;
   Elf64_Off e_shoff ;
   Elf64_Word e_flags ;
   Elf64_Half e_ehsize ;
   Elf64_Half e_phentsize ;
   Elf64_Half e_phnum ;
   Elf64_Half e_shentsize ;
   Elf64_Half e_shnum ;
   Elf64_Half e_shstrndx ;
};
#line 237  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef struct elf64_hdr Elf64_Ehdr;
#line 316  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
struct elf64_shdr {
   Elf64_Word sh_name ;
   Elf64_Word sh_type ;
   Elf64_Xword sh_flags ;
   Elf64_Addr sh_addr ;
   Elf64_Off sh_offset ;
   Elf64_Xword sh_size ;
   Elf64_Word sh_link ;
   Elf64_Word sh_info ;
   Elf64_Xword sh_addralign ;
   Elf64_Xword sh_entsize ;
};
#line 328  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef struct elf64_shdr Elf64_Shdr;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/elf.h"
struct kernel_param;
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char *, struct kernel_param *) ;
   int (*get)(char *, struct kernel_param *) ;
   void (*free)(void *) ;
};
#line 69 
struct kparam_string;
#line 69 
struct kparam_array;
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
union __anonunion_715 {
   void *arg ;
   struct kparam_string *str ;
   struct kparam_array *arr ;
};
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
struct kernel_param {
   char *name ;
   struct module *mod ;
   struct kernel_param_ops *ops ;
   u16 perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_715 __anonCompField_kernel_param_166 ;
};
#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops *ops ;
   void *elem ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/error-injection.h"
struct error_injection_entry {
   unsigned long addr ;
   int etype ;
};
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/module.h"
struct mod_arch_specific {
   unsigned int num_orcs ;
   int *orc_unwind_ip ;
   struct orc_entry *orc_unwind ;
};
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct module_param_attrs;
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
} __attribute__((__designated_init__));
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char *, size_t ) ;
   void (*setup)(struct module *, char *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};
#line 297 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};
#line 305  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 310  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct module_layout {
   void *base ;
   unsigned int size ;
   unsigned int text_size ;
   unsigned int ro_size ;
   unsigned int ro_after_init_size ;
   struct mod_tree_node mtn ;
};
#line 334  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct mod_kallsyms {
   Elf64_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   char *typetab ;
};
#line 342  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct klp_modinfo {
   Elf64_Ehdr hdr ;
   Elf64_Shdr *sechdrs ;
   char *secstrings ;
   unsigned int symndx ;
};
#line 350 
struct module_sect_attrs;
#line 350 
struct module_notes_attrs;
#line 350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char *version ;
   char *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol *syms ;
   s32 *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol *gpl_syms ;
   s32 *gpl_crcs ;
   struct kernel_symbol *unused_syms ;
   s32 *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol *unused_gpl_syms ;
   s32 *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol *gpl_future_syms ;
   s32 *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   struct module_layout core_layout ;
   struct module_layout init_layout ;
   struct mod_arch_specific arch ;
   unsigned long taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   struct mod_kallsyms *kallsyms ;
   struct mod_kallsyms core_kallsyms ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   tracepoint_ptr_t *tracepoints_ptrs ;
   unsigned int num_srcu_structs ;
   struct srcu_struct **srcu_struct_ptrs ;
   unsigned int num_bpf_raw_events ;
   struct bpf_raw_event_map *bpf_raw_events ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_eval_map **trace_evals ;
   unsigned int num_trace_evals ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp ;
   bool klp_alive ;
   struct klp_modinfo *klp_info ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t *ctors ;
   unsigned int num_ctors ;
   struct error_injection_entry *ei_funcs ;
   unsigned int num_ei_funcs ;
} __attribute__((__designated_init__, __aligned__(64)));
#line 567  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/rtnetlink.h"
struct tcmsg {
   unsigned char tcm_family ;
   unsigned char tcm__pad1 ;
   unsigned short tcm__pad2 ;
   int tcm_ifindex ;
   __u32 tcm_handle ;
   __u32 tcm_parent ;
   __u32 tcm_info ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/gen_stats.h"
struct gnet_stats_queue {
   __u32 qlen ;
   __u32 backlog ;
   __u32 drops ;
   __u32 requeues ;
   __u32 overlimits ;
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/gen_stats.h"
struct gnet_stats_basic_packed {
   __u64 bytes ;
   __u64 packets ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/gen_stats.h"
struct gnet_stats_basic_cpu {
   struct gnet_stats_basic_packed bstats ;
   struct u64_stats_sync syncp ;
} __attribute__((__aligned__(16)));
#line 20 
struct net_rate_estimator;
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/gen_stats.h"
struct gnet_dump {
   spinlock_t *lock ;
   struct sk_buff *skb ;
   struct nlattr *tail ;
   int compat_tc_stats ;
   int compat_xstats ;
   int padattr ;
   void *xstats ;
   int xstats_len ;
   struct tc_stats tc_stats ;
};
#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
struct __anonstruct_727 {
   s16 min ;
   s16 max ;
};
#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
union __anonunion_726 {
   void *validation_data ;
   struct __anonstruct_727 __anonCompField___anonunion_726_167 ;
   int (*validate)(struct nlattr *, struct netlink_ext_ack *) ;
   u16 strict_start_type ;
};
#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
struct nla_policy {
   u8 type ;
   u8 validation_type ;
   u16 len ;
   union __anonunion_726 __anonCompField_nla_policy_168 ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device *) ;
   unsigned int maxtype ;
   struct nla_policy *policy ;
   int (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *) ;
   int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *) ;
   int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *) ;
   void (*dellink)(struct net_device *, struct list_head *) ;
   size_t (*get_size)(struct net_device *) ;
   int (*fill_info)(struct sk_buff *, struct net_device *) ;
   size_t (*get_xstats_size)(struct net_device *) ;
   int (*fill_xstats)(struct sk_buff *, struct net_device *) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   unsigned int slave_maxtype ;
   struct nla_policy *slave_policy ;
   int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *) ;
   size_t (*get_slave_size)(struct net_device *, struct net_device *) ;
   int (*fill_slave_info)(struct sk_buff *, struct net_device *, struct net_device *) ;
   struct net *(*get_link_net)(struct net_device *) ;
   size_t (*get_linkxstats_size)(struct net_device *, int ) ;
   int (*fill_linkxstats)(struct sk_buff *, struct net_device *, int *, int ) ;
};
#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jhash.h"
struct rhash_lock_head {
   };
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rhashtable.h"
struct bucket_table {
   unsigned int size ;
   unsigned int nest ;
   u32 hash_rnd ;
   struct list_head walkers ;
   struct callback_head rcu ;
   struct bucket_table *future_tbl ;
   struct lockdep_map dep_map ;
   struct rhash_lock_head *buckets[] ;
};
#line 281  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_block {
   struct list_head cb_list ;
};
#line 298  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
typedef int flow_setup_cb_t(enum tc_setup_type , void *, void *);
#line 412 
struct Qdisc_ops;
#line 413 
struct qdisc_walker;
#line 414 
struct tcf_walker;
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct qdisc_size_table {
   struct callback_head rcu ;
   struct list_head list ;
   struct tc_sizespec szopts ;
   int refcnt ;
   u16 data[] ;
};
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct qdisc_skb_head {
   struct sk_buff *head ;
   struct sk_buff *tail ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct Qdisc {
   int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **) ;
   struct sk_buff *(*dequeue)(struct Qdisc *) ;
   unsigned int flags ;
   u32 limit ;
   struct Qdisc_ops *ops ;
   struct qdisc_size_table *stab ;
   struct hlist_node hash ;
   u32 handle ;
   u32 parent ;
   struct netdev_queue *dev_queue ;
   struct net_rate_estimator *rate_est ;
   struct gnet_stats_basic_cpu *cpu_bstats ;
   struct gnet_stats_queue *cpu_qstats ;
   int padded ;
   refcount_t refcnt ;
   struct sk_buff_head gso_skb ;
   struct qdisc_skb_head q ;
   struct gnet_stats_basic_packed bstats ;
   seqcount_t running ;
   struct gnet_stats_queue qstats ;
   unsigned long state ;
   struct Qdisc *next_sched ;
   struct sk_buff_head skb_bad_txq ;
   spinlock_t busylock ;
   spinlock_t seqlock ;
   bool empty ;
   struct callback_head rcu ;
};
#line 195 
struct tcf_block;
#line 195  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct Qdisc_class_ops {
   unsigned int flags ;
   struct netdev_queue *(*select_queue)(struct Qdisc *, struct tcmsg *) ;
   int (*graft)(struct Qdisc *, unsigned long , struct Qdisc *, struct Qdisc **, struct netlink_ext_ack *) ;
   struct Qdisc *(*leaf)(struct Qdisc *, unsigned long ) ;
   void (*qlen_notify)(struct Qdisc *, unsigned long ) ;
   unsigned long (*find)(struct Qdisc *, u32 ) ;
   int (*change)(struct Qdisc *, u32 , u32 , struct nlattr **, unsigned long *, struct netlink_ext_ack *) ;
   int (*delete)(struct Qdisc *, unsigned long ) ;
   void (*walk)(struct Qdisc *, struct qdisc_walker *) ;
   struct tcf_block *(*tcf_block)(struct Qdisc *, unsigned long , struct netlink_ext_ack *) ;
   unsigned long (*bind_tcf)(struct Qdisc *, unsigned long , u32 ) ;
   void (*unbind_tcf)(struct Qdisc *, unsigned long ) ;
   int (*dump)(struct Qdisc *, unsigned long , struct sk_buff *, struct tcmsg *) ;
   int (*dump_stats)(struct Qdisc *, unsigned long , struct gnet_dump *) ;
};
#line 235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct Qdisc_ops {
   struct Qdisc_ops *next ;
   struct Qdisc_class_ops *cl_ops ;
   char id[16U] ;
   int priv_size ;
   unsigned int static_flags ;
   int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **) ;
   struct sk_buff *(*dequeue)(struct Qdisc *) ;
   struct sk_buff *(*peek)(struct Qdisc *) ;
   int (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *) ;
   void (*reset)(struct Qdisc *) ;
   void (*destroy)(struct Qdisc *) ;
   int (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *) ;
   void (*attach)(struct Qdisc *) ;
   int (*change_tx_queue_len)(struct Qdisc *, unsigned int ) ;
   int (*dump)(struct Qdisc *, struct sk_buff *) ;
   int (*dump_stats)(struct Qdisc *, struct gnet_dump *) ;
   void (*ingress_block_set)(struct Qdisc *, u32 ) ;
   void (*egress_block_set)(struct Qdisc *, u32 ) ;
   u32 (*ingress_block_get)(struct Qdisc *) ;
   u32 (*egress_block_get)(struct Qdisc *) ;
   struct module *owner ;
};
#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct __anonstruct_801 {
   unsigned long class ;
   u32 classid ;
};
#line 272 
struct tcf_proto;
#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct __anonstruct_802 {
   bool ingress ;
   struct gnet_stats_queue *qstats ;
};
#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
union __anonunion_800 {
   struct __anonstruct_801 __anonCompField___anonunion_800_170 ;
   struct tcf_proto *goto_tp ;
   struct __anonstruct_802 __anonCompField___anonunion_800_171 ;
};
#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct tcf_result {
   union __anonunion_800 __anonCompField_tcf_result_172 ;
};
#line 287 
struct tcf_chain;
#line 290  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct tcf_proto_ops {
   struct list_head head ;
   char kind[16U] ;
   int (*classify)(struct sk_buff *, struct tcf_proto *, struct tcf_result *) ;
   int (*init)(struct tcf_proto *) ;
   void (*destroy)(struct tcf_proto *, bool , struct netlink_ext_ack *) ;
   void *(*get)(struct tcf_proto *, u32 ) ;
   void (*put)(struct tcf_proto *, void *) ;
   int (*change)(struct net *, struct sk_buff *, struct tcf_proto *, unsigned long , u32 , struct nlattr **, void **, bool , bool , struct netlink_ext_ack *) ;
   int (*delete)(struct tcf_proto *, void *, bool *, bool , struct netlink_ext_ack *) ;
   bool (*delete_empty)(struct tcf_proto *) ;
   void (*walk)(struct tcf_proto *, struct tcf_walker *, bool ) ;
   int (*reoffload)(struct tcf_proto *, bool , flow_setup_cb_t *, void *, struct netlink_ext_ack *) ;
   void (*hw_add)(struct tcf_proto *, void *) ;
   void (*hw_del)(struct tcf_proto *, void *) ;
   void (*bind_class)(void *, u32 , unsigned long ) ;
   void *(*tmplt_create)(struct net *, struct tcf_chain *, struct nlattr **, struct netlink_ext_ack *) ;
   void (*tmplt_destroy)(void *) ;
   int (*dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool ) ;
   int (*tmplt_dump)(struct sk_buff *, struct net *, void *) ;
   struct module *owner ;
   int flags ;
};
#line 348  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct tcf_proto {
   struct tcf_proto *next ;
   void *root ;
   int (*classify)(struct sk_buff *, struct tcf_proto *, struct tcf_result *) ;
   __be16 protocol ;
   u32 prio ;
   void *data ;
   struct tcf_proto_ops *ops ;
   struct tcf_chain *chain ;
   spinlock_t lock ;
   bool deleting ;
   refcount_t refcnt ;
   struct callback_head rcu ;
   struct hlist_node destroy_ht_node ;
};
#line 386  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct tcf_chain {
   struct mutex filter_chain_lock ;
   struct tcf_proto *filter_chain ;
   struct list_head list ;
   struct tcf_block *block ;
   u32 index ;
   unsigned int refcnt ;
   unsigned int action_refcnt ;
   bool explicitly_created ;
   bool flushing ;
   struct tcf_proto_ops *tmplt_ops ;
   void *tmplt_priv ;
   struct callback_head rcu ;
};
#line 402  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct __anonstruct_chain0_804 {
   struct tcf_chain *chain ;
   struct list_head filter_chain_list ;
};
#line 402  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct tcf_block {
   struct mutex lock ;
   struct list_head chain_list ;
   u32 index ;
   refcount_t refcnt ;
   struct net *net ;
   struct Qdisc *q ;
   struct rw_semaphore cb_lock ;
   struct flow_block flow_block ;
   struct list_head owner_list ;
   bool keep_dst ;
   atomic_t offloadcnt ;
   unsigned int nooffloaddevcnt ;
   unsigned int lockeddevcnt ;
   struct __anonstruct_chain0_804 chain0 ;
   struct callback_head rcu ;
   struct hlist_head proto_destroy_ht[128U] ;
   struct mutex proto_destroy_lock ;
};
#line 1269  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
struct mini_Qdisc {
   struct tcf_proto *filter_list ;
   struct gnet_stats_basic_cpu *cpu_bstats ;
   struct gnet_stats_queue *cpu_qstats ;
   struct callback_head rcu ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/filter.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};
#line 35 
struct sock_reuseport;
#line 513  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/filter.h"
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};
#line 526  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/filter.h"
union __anonunion_817 {
   struct sock_filter insns[0U] ;
   struct bpf_insn insnsi[0U] ;
};
#line 526  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/filter.h"
struct bpf_prog {
   u16 pages ;
   u16 jited : 1 ;
   u16 jit_requested : 1 ;
   u16 gpl_compatible : 1 ;
   u16 cb_access : 1 ;
   u16 dst_needed : 1 ;
   u16 blinded : 1 ;
   u16 is_func : 1 ;
   u16 kprobe_override : 1 ;
   u16 has_callchain_buf : 1 ;
   u16 enforce_expected_attach_type : 1 ;
   enum bpf_prog_type type ;
   enum bpf_attach_type expected_attach_type ;
   u32 len ;
   u32 jited_len ;
   u8 tag[8U] ;
   struct bpf_prog_aux *aux ;
   struct sock_fprog_kern *orig_prog ;
   unsigned int (*bpf_func)(void *, struct bpf_insn *) ;
   union __anonunion_817 __anonCompField_bpf_prog_174 ;
};
#line 554  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/filter.h"
struct sk_filter {
   refcount_t refcnt ;
   struct callback_head rcu ;
   struct bpf_prog *prog ;
};
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file *, wait_queue_head_t *, struct poll_table_struct *) ;
   __poll_t _key ;
};
#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct neigh_table;
#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct neigh_parms {
   possible_net_t net ;
   struct net_device *dev ;
   struct list_head list ;
   int (*neigh_setup)(struct neighbour *) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   refcount_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[13U] ;
   unsigned long data_state[1U] ;
};
#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
   unsigned long table_fulls ;
};
#line 134 
struct neigh_ops;
#line 134  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   refcount_t refcnt ;
   unsigned int arp_queue_len_bytes ;
   struct sk_buff_head arp_queue ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   u8 protocol ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   struct neigh_ops *ops ;
   struct list_head gc_list ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
} __attribute__((__designated_init__));
#line 163  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour *, struct sk_buff *) ;
   void (*error_report)(struct neighbour *, struct sk_buff *) ;
   int (*output)(struct neighbour *, struct sk_buff *) ;
   int (*connected_output)(struct neighbour *, struct sk_buff *) ;
};
#line 171  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   possible_net_t net ;
   struct net_device *dev ;
   u8 flags ;
   u8 protocol ;
   u8 key[0U] ;
};
#line 186  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};
#line 194  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/neighbour.h"
struct neigh_table {
   int family ;
   unsigned int entry_size ;
   unsigned int key_len ;
   __be16 protocol ;
   __u32 (*hash)(void *, struct net_device *, __u32 *) ;
   bool (*key_eq)(struct neighbour *, void *) ;
   int (*constructor)(struct neighbour *) ;
   int (*pconstructor)(struct pneigh_entry *) ;
   void (*pdestructor)(struct pneigh_entry *) ;
   void (*proxy_redo)(struct sk_buff *) ;
   bool (*allow_add)(struct net_device *, struct netlink_ext_ack *) ;
   char *id ;
   struct neigh_parms parms ;
   struct list_head parms_list ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   atomic_t gc_entries ;
   struct list_head gc_list ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dst.h"
struct dst_entry {
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff *) ;
   int (*output)(struct net *, struct sock *, struct sk_buff *) ;
   unsigned short flags ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   struct lwtunnel_state *lwtstate ;
   struct callback_head callback_head ;
   short error ;
   short __pad ;
   __u32 tclassid ;
};
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/net_tstamp.h"
struct hwtstamp_config {
   int flags ;
   int tx_type ;
   int rx_filter ;
};
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fib_rules.h"
struct fib_rule_hdr {
   __u8 family ;
   __u8 dst_len ;
   __u8 src_len ;
   __u8 tos ;
   __u8 table ;
   __u8 res1 ;
   __u8 res2 ;
   __u8 action ;
   __u32 flags ;
};
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fib_rules.h"
struct fib_rule_port_range {
   __u16 start ;
   __u16 end ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/fib_notifier.h"
struct fib_notifier_ops {
   int family ;
   struct list_head list ;
   unsigned int (*fib_seq_read)(struct net *) ;
   int (*fib_dump)(struct net *, struct notifier_block *, struct netlink_ext_ack *) ;
   struct module *owner ;
   struct callback_head rcu ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/fib_rules.h"
struct fib_kuid_range {
   kuid_t start ;
   kuid_t end ;
};
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/fib_rules.h"
struct fib_rule {
   struct list_head list ;
   int iifindex ;
   int oifindex ;
   u32 mark ;
   u32 mark_mask ;
   u32 flags ;
   u32 table ;
   u8 action ;
   u8 l3mdev ;
   u8 proto ;
   u8 ip_proto ;
   u32 target ;
   __be64 tun_id ;
   struct fib_rule *ctarget ;
   struct net *fr_net ;
   refcount_t refcnt ;
   u32 pref ;
   int suppress_ifgroup ;
   int suppress_prefixlen ;
   char iifname[16U] ;
   char oifname[16U] ;
   struct fib_kuid_range uid_range ;
   struct fib_rule_port_range sport_range ;
   struct fib_rule_port_range dport_range ;
   struct callback_head rcu ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/fib_rules.h"
struct fib_lookup_arg {
   void *lookup_ptr ;
   void *lookup_data ;
   void *result ;
   struct fib_rule *rule ;
   u32 table ;
   int flags ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/fib_rules.h"
struct fib_rules_ops {
   int family ;
   struct list_head list ;
   int rule_size ;
   int addr_size ;
   int unresolved_rules ;
   int nr_goto_rules ;
   unsigned int fib_rules_seq ;
   int (*action)(struct fib_rule *, struct flowi *, int , struct fib_lookup_arg *) ;
   bool (*suppress)(struct fib_rule *, struct fib_lookup_arg *) ;
   int (*match)(struct fib_rule *, struct flowi *, int ) ;
   int (*configure)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *, struct nlattr **, struct netlink_ext_ack *) ;
   int (*delete)(struct fib_rule *) ;
   int (*compare)(struct fib_rule *, struct fib_rule_hdr *, struct nlattr **) ;
   int (*fill)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *) ;
   size_t (*nlmsg_payload)(struct fib_rule *) ;
   void (*flush_cache)(struct fib_rules_ops *) ;
   int nlgroup ;
   struct nla_policy *policy ;
   struct list_head rules_list ;
   struct module *owner ;
   struct net *fro_net ;
   struct callback_head rcu ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/l3mdev.h"
struct l3mdev_ops {
   u32 (*l3mdev_fib_table)(struct net_device *) ;
   struct sk_buff *(*l3mdev_l3_rcv)(struct net_device *, struct sk_buff *, u16 ) ;
   struct sk_buff *(*l3mdev_l3_out)(struct net_device *, struct sock *, struct sk_buff *, u16 ) ;
   struct dst_entry *(*l3mdev_link_scope_lookup)(struct net_device *, struct flowi6 *) ;
};
#line 202  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/l3mdev.h"
struct __anonstruct_socket_lock_t_839 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};
#line 202  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/l3mdev.h"
typedef struct __anonstruct_socket_lock_t_839 socket_lock_t;
#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
struct proto;
#line 109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
typedef __u32 __portpair;
#line 114  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
typedef __u64 __addrpair;
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
struct __anonstruct_841 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_840 {
   __addrpair skc_addrpair ;
   struct __anonstruct_841 __anonCompField___anonunion_840_176 ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_842 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
struct __anonstruct_844 {
   __be16 skc_dport ;
   __u16 skc_num ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_843 {
   __portpair skc_portpair ;
   struct __anonstruct_844 __anonCompField___anonunion_843_179 ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_845 {
   struct hlist_node skc_bind_node ;
   struct hlist_node skc_portaddr_node ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_846 {
   unsigned long skc_flags ;
   struct sock *skc_listener ;
   struct inet_timewait_death_row *skc_tw_dr ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_847 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_848 {
   int skc_incoming_cpu ;
   u32 skc_rcv_wnd ;
   u32 skc_tw_rcv_nxt ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_849 {
   u32 skc_rxhash ;
   u32 skc_window_clamp ;
   u32 skc_tw_snd_nxt ;
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
struct sock_common {
   union __anonunion_840 __anonCompField_sock_common_177 ;
   union __anonunion_842 __anonCompField_sock_common_178 ;
   union __anonunion_843 __anonCompField_sock_common_180 ;
   unsigned short skc_family ;
   unsigned char skc_state ;
   unsigned char skc_reuse : 4 ;
   unsigned char skc_reuseport : 1 ;
   unsigned char skc_ipv6only : 1 ;
   unsigned char skc_net_refcnt : 1 ;
   int skc_bound_dev_if ;
   union __anonunion_845 __anonCompField_sock_common_181 ;
   struct proto *skc_prot ;
   possible_net_t skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   atomic64_t skc_cookie ;
   union __anonunion_846 __anonCompField_sock_common_182 ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion_847 __anonCompField_sock_common_183 ;
   unsigned short skc_tx_queue_mapping ;
   unsigned short skc_rx_queue_mapping ;
   union __anonunion_848 __anonCompField_sock_common_184 ;
   refcount_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
   union __anonunion_849 __anonCompField_sock_common_185 ;
};
#line 231 
struct bpf_sk_storage;
#line 323  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
struct __anonstruct_sk_backlog_850 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
#line 323  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_851 {
   struct socket_wq *sk_wq ;
   struct socket_wq *sk_wq_raw ;
};
#line 323  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_852 {
   struct sk_buff *sk_send_head ;
   struct rb_root tcp_rtx_queue ;
};
#line 323  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   atomic_t sk_drops ;
   int sk_rcvlowat ;
   struct sk_buff_head sk_error_queue ;
   struct sk_buff *sk_rx_skb_cache ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_850 sk_backlog ;
   int sk_forward_alloc ;
   unsigned int sk_ll_usec ;
   unsigned int sk_napi_id ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   union __anonunion_851 __anonCompField_sock_186 ;
   struct xfrm_policy *sk_policy[2U] ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   int sk_wmem_queued ;
   refcount_t sk_wmem_alloc ;
   unsigned long sk_tsq_flags ;
   union __anonunion_852 __anonCompField_sock_187 ;
   struct sk_buff *sk_tx_skb_cache ;
   struct sk_buff_head sk_write_queue ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   __u32 sk_dst_pending_confirm ;
   u32 sk_pacing_status ;
   long sk_sndtimeo ;
   struct timer_list sk_timer ;
   __u32 sk_priority ;
   __u32 sk_mark ;
   unsigned long sk_pacing_rate ;
   unsigned long sk_max_pacing_rate ;
   struct page_frag sk_frag ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   netdev_features_t sk_route_forced_caps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   gfp_t sk_allocation ;
   __u32 sk_txhash ;
   unsigned int __sk_flags_offset[0U] ;
   unsigned int sk_padding : 1 ;
   unsigned int sk_kern_sock : 1 ;
   unsigned int sk_no_check_tx : 1 ;
   unsigned int sk_no_check_rx : 1 ;
   unsigned int sk_userlocks : 4 ;
   unsigned int sk_protocol : 8 ;
   unsigned int sk_type : 16 ;
   u16 sk_gso_max_segs ;
   u8 sk_pacing_shift ;
   unsigned long sk_lingertime ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   u32 sk_ack_backlog ;
   u32 sk_max_ack_backlog ;
   kuid_t sk_uid ;
   struct pid *sk_peer_pid ;
   struct cred *sk_peer_cred ;
   long sk_rcvtimeo ;
   ktime_t sk_stamp ;
   u16 sk_tsflags ;
   u8 sk_shutdown ;
   u32 sk_tskey ;
   atomic_t sk_zckey ;
   u8 sk_clockid ;
   u8 sk_txtime_deadline_mode : 1 ;
   u8 sk_txtime_report_errors : 1 ;
   u8 sk_txtime_unused : 6 ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   void *sk_security ;
   struct sock_cgroup_data sk_cgrp_data ;
   struct mem_cgroup *sk_memcg ;
   void (*sk_state_change)(struct sock *) ;
   void (*sk_data_ready)(struct sock *) ;
   void (*sk_write_space)(struct sock *) ;
   void (*sk_error_report)(struct sock *) ;
   int (*sk_backlog_rcv)(struct sock *, struct sk_buff *) ;
   struct sk_buff *(*sk_validate_xmit_skb)(struct sock *, struct net_device *, struct sk_buff *) ;
   void (*sk_destruct)(struct sock *) ;
   struct sock_reuseport *sk_reuseport_cb ;
   struct bpf_sk_storage *sk_bpf_storage ;
   struct callback_head sk_rcu ;
};
#line 1048 
struct request_sock_ops;
#line 1049 
struct timewait_sock_ops;
#line 1050 
struct raw_hashinfo;
#line 1051 
struct smc_hashinfo;
#line 1071 
struct udp_table;
#line 1071  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
union __anonunion_h_887 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
   struct smc_hashinfo *smc_hash ;
};
#line 1071  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock.h"
struct proto {
   void (*close)(struct sock *, long ) ;
   int (*pre_connect)(struct sock *, struct sockaddr *, int ) ;
   int (*connect)(struct sock *, struct sockaddr *, int ) ;
   int (*disconnect)(struct sock *, int ) ;
   struct sock *(*accept)(struct sock *, int , int *, bool ) ;
   int (*ioctl)(struct sock *, int , unsigned long ) ;
   int (*init)(struct sock *) ;
   void (*destroy)(struct sock *) ;
   void (*shutdown)(struct sock *, int ) ;
   int (*setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct sock *, int , int , char *, int *) ;
   void (*keepalive)(struct sock *, int ) ;
   int (*compat_setsockopt)(struct sock *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct sock *, int , int , char *, int *) ;
   int (*compat_ioctl)(struct sock *, unsigned int , unsigned long ) ;
   int (*sendmsg)(struct sock *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct sock *, struct msghdr *, size_t , int , int , int *) ;
   int (*sendpage)(struct sock *, struct page *, int , size_t , int ) ;
   int (*bind)(struct sock *, struct sockaddr *, int ) ;
   int (*backlog_rcv)(struct sock *, struct sk_buff *) ;
   void (*release_cb)(struct sock *) ;
   int (*hash)(struct sock *) ;
   void (*unhash)(struct sock *) ;
   void (*rehash)(struct sock *) ;
   int (*get_port)(struct sock *, unsigned short ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock *, int ) ;
   bool (*stream_memory_read)(struct sock *) ;
   void (*enter_memory_pressure)(struct sock *) ;
   void (*leave_memory_pressure)(struct sock *) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   unsigned long *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   u32 sysctl_wmem_offset ;
   u32 sysctl_rmem_offset ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   slab_flags_t slab_flags ;
   unsigned int useroffset ;
   unsigned int usersize ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_887 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*diag_destroy)(struct sock *, int ) ;
} __attribute__((__designated_init__));
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/request_sock.h"
struct request_sock_ops {
   int family ;
   unsigned int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock *, struct request_sock *) ;
   void (*send_ack)(struct sock *, struct sk_buff *, struct request_sock *) ;
   void (*send_reset)(struct sock *, struct sk_buff *) ;
   void (*destructor)(struct request_sock *) ;
   void (*syn_ack_timeout)(struct request_sock *) ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   u16 mss ;
   u8 num_retrans ;
   u8 cookie_ts : 1 ;
   u8 num_timeout : 7 ;
   u32 ts_recent ;
   struct timer_list rsk_timer ;
   struct request_sock_ops *rsk_ops ;
   struct sock *sk ;
   u32 *saved_syn ;
   u32 secid ;
   u32 peer_secid ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/timewait_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock *, struct sock *, void *) ;
   void (*twsk_destructor)(struct sock *) ;
};
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ipv6.h"
struct ipv6_stable_secret {
   bool initialized ;
   struct in6_addr secret ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_max_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_min_hop_limit ;
   __s32 accept_ra_pinfo ;
   __s32 ignore_routes_with_linkdown ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_min_plen ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 accept_ra_from_local ;
   __s32 optimistic_dad ;
   __s32 use_optimistic ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 drop_unicast_in_l2_multicast ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   __s32 accept_ra_mtu ;
   __s32 drop_unsolicited_na ;
   struct ipv6_stable_secret stable_secret ;
   __s32 use_oif_addrs_only ;
   __s32 keep_addr_on_down ;
   __s32 seg6_enabled ;
   __s32 seg6_require_hmac ;
   __u32 enhanced_dad ;
   __u32 addr_gen_mode ;
   __s32 disable_policy ;
   __s32 ndisc_tclass ;
   struct ctl_table_header *sysctl_header ;
};
#line 99  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};
#line 114  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   refcount_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct fib6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   struct hlist_node aca_addr_lst ;
   int aca_users ;
   refcount_t aca_refcnt ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
   struct callback_head rcu ;
};
#line 156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6 ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};
#line 163  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   refcount_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u32 desync_factor ;
   u8 rndid[8U] ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __s32 rs_interval ;
   __u8 rs_probes ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ndisc.h"
struct nd_opt_hdr {
   __u8 nd_opt_type ;
   __u8 nd_opt_len ;
} __attribute__((__packed__));
#line 110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ndisc.h"
struct ndisc_options {
   struct nd_opt_hdr *nd_opt_array[15U] ;
   struct nd_opt_hdr *nd_opts_ri ;
   struct nd_opt_hdr *nd_opts_ri_end ;
   struct nd_opt_hdr *nd_useropts ;
   struct nd_opt_hdr *nd_useropts_end ;
   struct nd_opt_hdr *nd_802154_opt_array[3U] ;
};
#line 201  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ndisc.h"
struct ndisc_ops {
   int (*is_useropt)(u8 ) ;
   int (*parse_options)(struct net_device *, struct nd_opt_hdr *, struct ndisc_options *) ;
   void (*update)(struct net_device *, struct neighbour *, u32 , u8 , struct ndisc_options *) ;
   int (*opt_addr_space)(struct net_device *, u8 , struct neighbour *, u8 *, u8 **) ;
   void (*fill_addr_option)(struct net_device *, struct sk_buff *, u8 , u8 *) ;
   void (*prefix_rcv_add_addr)(struct net *, struct net_device *, struct prefix_info *, struct inet6_dev *, struct in6_addr *, int , u32 , bool , bool , __u32 , u32 , bool ) ;
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inetpeer.h"
struct inet_peer_base {
   struct rb_root rb_root ;
   seqlock_t lock ;
   int total ;
};
#line 235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
struct fib_table {
   struct hlist_node tb_hlist ;
   u32 tb_id ;
   int tb_num_default ;
   struct callback_head rcu ;
   unsigned long *tb_data ;
   unsigned long __data[0U] ;
};
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_hashtables.h"
struct inet_ehash_bucket {
   struct hlist_nulls_head chain ;
};
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_hashtables.h"
struct inet_bind_hashbucket {
   spinlock_t lock ;
   struct hlist_head chain ;
};
#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_hashtables.h"
union __anonunion_984 {
   struct hlist_head head ;
   struct hlist_nulls_head nulls_head ;
};
#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_hashtables.h"
struct inet_listen_hashbucket {
   spinlock_t lock ;
   unsigned int count ;
   union __anonunion_984 __anonCompField_inet_listen_hashbucket_195 ;
};
#line 124  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_hashtables.h"
struct inet_hashinfo {
   struct inet_ehash_bucket *ehash ;
   spinlock_t *ehash_locks ;
   unsigned int ehash_mask ;
   unsigned int ehash_locks_mask ;
   struct kmem_cache *bind_bucket_cachep ;
   struct inet_bind_hashbucket *bhash ;
   unsigned int bhash_size ;
   unsigned int lhash2_mask ;
   struct inet_listen_hashbucket *lhash2 ;
   struct inet_listen_hashbucket listening_hash[32U] ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sock_reuseport.h"
struct sock_reuseport {
   struct callback_head rcu ;
   u16 max_socks ;
   u16 num_socks ;
   unsigned int synq_overflow_ts ;
   unsigned int reuseport_id ;
   unsigned int bind_inany : 1 ;
   unsigned int has_conns : 1 ;
   struct bpf_prog *prog ;
   struct sock *socks[0U] ;
};
#line 121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip.h"
union __anonunion_987 {
   void (*destructor)(struct sock *) ;
   struct sock *saved_sk ;
};
#line 121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip.h"
struct ip_ra_chain {
   struct ip_ra_chain *next ;
   struct sock *sk ;
   union __anonunion_987 __anonCompField_ip_ra_chain_196 ;
   struct callback_head rcu ;
};
#line 979  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/tcp.h"
enum tcp_ca_event {
    CA_EVENT_TX_START = 0,
    CA_EVENT_CWND_RESTART = 1,
    CA_EVENT_COMPLETE_CWR = 2,
    CA_EVENT_LOSS = 3,
    CA_EVENT_ECN_NO_CE = 4,
    CA_EVENT_ECN_IS_CE = 5
};
#line 994 
union tcp_cc_info;
#line 1013  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/tcp.h"
struct ack_sample {
   u32 pkts_acked ;
   s32 rtt_us ;
   u32 in_flight ;
};
#line 1027  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/tcp.h"
struct rate_sample {
   u64 prior_mstamp ;
   u32 prior_delivered ;
   s32 delivered ;
   long interval_us ;
   u32 snd_interval_us ;
   u32 rcv_interval_us ;
   long rtt_us ;
   int losses ;
   u32 acked_sacked ;
   u32 prior_in_flight ;
   bool is_app_limited ;
   bool is_retrans ;
   bool is_ack_delayed ;
};
#line 1043  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/tcp.h"
struct tcp_congestion_ops {
   struct list_head list ;
   u32 key ;
   u32 flags ;
   void (*init)(struct sock *) ;
   void (*release)(struct sock *) ;
   u32 (*ssthresh)(struct sock *) ;
   void (*cong_avoid)(struct sock *, u32 , u32 ) ;
   void (*set_state)(struct sock *, u8 ) ;
   void (*cwnd_event)(struct sock *, enum tcp_ca_event ) ;
   void (*in_ack_event)(struct sock *, u32 ) ;
   u32 (*undo_cwnd)(struct sock *) ;
   void (*pkts_acked)(struct sock *, struct ack_sample *) ;
   u32 (*min_tso_segs)(struct sock *) ;
   u32 (*sndbuf_expand)(struct sock *) ;
   void (*cong_control)(struct sock *, struct rate_sample *) ;
   size_t (*get_info)(struct sock *, u32 , int *, union tcp_cc_info *) ;
   char name[16U] ;
   struct module *owner ;
};
#line 1661  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/tcp.h"
struct tcp_fastopen_context {
   siphash_key_t key[2U] ;
   int num ;
   struct callback_head rcu ;
};
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/udp.h"
struct udp_hslot {
   struct hlist_head head ;
   int count ;
   spinlock_t lock ;
} __attribute__((__aligned__(16)));
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/udp.h"
struct udp_table {
   struct udp_hslot *hash ;
   struct udp_hslot *hash2 ;
   unsigned int mask ;
   unsigned int log ;
};
#line 495  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/udp.h"
typedef unsigned long kernel_ulong_t;
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};
#line 260  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void *data ;
};
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct hotplug_slot;
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 99  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef int pci_power_t;
#line 153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 162 
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
};
#line 181  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 207  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 282 
struct pcie_link_state;
#line 283 
struct pci_vpd;
#line 284 
struct pci_sriov;
#line 285 
struct pci_p2pdma;
#line 290 
struct aer_stats;
#line 290 
struct pci_driver;
#line 290  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
union __anonunion_1042 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 290  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u16 aer_cap ;
   struct aer_stats *aer_stats ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   unsigned long *dma_alias_mask ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   unsigned int imm_ready : 1 ;
   u8 pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int pme_poll : 1 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   unsigned int no_d3cold : 1 ;
   unsigned int bridge_d3 : 1 ;
   unsigned int d3cold_allowed : 1 ;
   unsigned int mmio_always_on : 1 ;
   unsigned int wakeup_prepared : 1 ;
   unsigned int runtime_d3cold : 1 ;
   unsigned int skip_bus_pm : 1 ;
   unsigned int ignore_hotplug : 1 ;
   unsigned int hotplug_user_indicators : 1 ;
   unsigned int clear_retrain_link : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   unsigned int ltr_path : 1 ;
   unsigned int eetlp_prefix_path : 1 ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int transparent : 1 ;
   unsigned int io_window : 1 ;
   unsigned int pref_window : 1 ;
   unsigned int pref_64_window : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int no_64bit_msi : 1 ;
   unsigned int block_cfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int ats_enabled : 1 ;
   unsigned int pasid_enabled : 1 ;
   unsigned int pri_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int needs_freset : 1 ;
   unsigned int state_saved : 1 ;
   unsigned int is_physfn : 1 ;
   unsigned int is_virtfn : 1 ;
   unsigned int reset_fn : 1 ;
   unsigned int is_hotplug_bridge : 1 ;
   unsigned int shpc_managed : 1 ;
   unsigned int is_thunderbolt : 1 ;
   unsigned int untrusted : 1 ;
   unsigned int __aer_firmware_first_valid : 1 ;
   unsigned int __aer_firmware_first : 1 ;
   unsigned int broken_intx_masking : 1 ;
   unsigned int io_window_1k : 1 ;
   unsigned int irq_managed : 1 ;
   unsigned int non_compliant_bars : 1 ;
   unsigned int is_probed : 1 ;
   unsigned int link_active_reporting : 1 ;
   unsigned int no_vf_scan : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   unsigned int broken_cmd_compl : 1 ;
   unsigned int ptm_root : 1 ;
   unsigned int ptm_enabled : 1 ;
   u8 ptm_granularity ;
   struct attribute_group **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_1042 __anonCompField_pci_dev_200 ;
   u16 ats_cap ;
   u8 ats_stu ;
   u16 pri_cap ;
   u32 pri_reqs_alloc ;
   unsigned int pasid_required : 1 ;
   u16 pasid_cap ;
   u16 pasid_features ;
   struct pci_p2pdma *p2pdma ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
   unsigned long priv_flags ;
};
#line 493 
struct pci_ops;
#line 493 
struct msi_controller;
#line 571  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
#line 697  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_ops {
   int (*add_bus)(struct pci_bus *) ;
   void (*remove_bus)(struct pci_bus *) ;
   void *(*map_bus)(struct pci_bus *, unsigned int , int ) ;
   int (*read)(struct pci_bus *, unsigned int , int , int , u32 *) ;
   int (*write)(struct pci_bus *, unsigned int , int , int , u32 ) ;
};
#line 725  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 729  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 761  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *, enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *) ;
   void (*reset_prepare)(struct pci_dev *) ;
   void (*reset_done)(struct pci_dev *) ;
   void (*resume)(struct pci_dev *) ;
};
#line 824  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char *name ;
   struct pci_device_id *id_table ;
   int (*probe)(struct pci_dev *, struct pci_device_id *) ;
   void (*remove)(struct pci_dev *) ;
   int (*suspend)(struct pci_dev *, pm_message_t ) ;
   int (*resume)(struct pci_dev *) ;
   void (*shutdown)(struct pci_dev *) ;
   int (*sriov_configure)(struct pci_dev *, int ) ;
   struct pci_error_handlers *err_handler ;
   struct attribute_group **groups ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 1424  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 439  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/property.h"
typedef u32 phandle;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   struct bin_attribute attr ;
};
#line 51  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/of.h"
struct device_node {
   char *name ;
   phandle phandle ;
   char *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/of.h"
struct of_phandle_args {
   struct device_node *np ;
   int args_count ;
   uint32_t args[16U] ;
};
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/iommu.h"
struct iommu_fault_unrecoverable {
   __u32 reason ;
   __u32 flags ;
   __u32 pasid ;
   __u32 perm ;
   __u64 addr ;
   __u64 fetch_addr ;
};
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/iommu.h"
struct iommu_fault_page_request {
   __u32 flags ;
   __u32 pasid ;
   __u32 grpid ;
   __u32 perm ;
   __u64 addr ;
   __u64 private_data[2U] ;
};
#line 111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/iommu.h"
union __anonunion_1045 {
   struct iommu_fault_unrecoverable event ;
   struct iommu_fault_page_request prm ;
   __u8 padding2[56U] ;
};
#line 111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/iommu.h"
struct iommu_fault {
   __u32 type ;
   __u32 padding ;
   union __anonunion_1045 __anonCompField_iommu_fault_202 ;
};
#line 145  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/iommu.h"
struct iommu_page_response {
   __u32 version ;
   __u32 flags ;
   __u32 pasid ;
   __u32 grpid ;
   __u32 code ;
};
#line 183  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/iommu.h"
struct iommu_inv_addr_info {
   __u32 flags ;
   __u32 archid ;
   __u64 pasid ;
   __u64 addr ;
   __u64 granule_size ;
   __u64 nb_granules ;
};
#line 210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/iommu.h"
struct iommu_inv_pasid_info {
   __u32 flags ;
   __u32 archid ;
   __u64 pasid ;
};
#line 248  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/iommu.h"
union __anonunion_1046 {
   struct iommu_inv_pasid_info pasid_info ;
   struct iommu_inv_addr_info addr_info ;
};
#line 248  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/iommu.h"
struct iommu_cache_invalidate_info {
   __u32 version ;
   __u8 cache ;
   __u8 granularity ;
   __u8 padding[2U] ;
   union __anonunion_1046 __anonCompField_iommu_cache_invalidate_info_203 ;
};
#line 276  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/iommu.h"
struct iommu_gpasid_bind_data_vtd {
   __u64 flags ;
   __u32 pat ;
   __u32 emt ;
};
#line 306  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/iommu.h"
union __anonunion_1047 {
   struct iommu_gpasid_bind_data_vtd vtd ;
};
#line 306  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/iommu.h"
struct iommu_gpasid_bind_data {
   __u32 version ;
   __u32 format ;
   __u64 flags ;
   __u64 gpgd ;
   __u64 hpasid ;
   __u64 gpasid ;
   __u32 addr_width ;
   __u8 padding[12U] ;
   union __anonunion_1047 __anonCompField_iommu_gpasid_bind_data_204 ;
};
#line 323 
struct iommu_domain;
#line 324 
struct iommu_sva;
#line 325 
struct iommu_fault_event;
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iommu.h"
struct iommu_domain_geometry {
   dma_addr_t aperture_start ;
   dma_addr_t aperture_end ;
   bool force_aperture ;
};
#line 90  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iommu.h"
struct iommu_domain {
   unsigned int type ;
   struct iommu_ops *ops ;
   unsigned long pgsize_bitmap ;
   int (*handler)(struct iommu_domain *, struct device *, unsigned long , int , void *) ;
   void *handler_token ;
   struct iommu_domain_geometry geometry ;
   void *iova_cookie ;
};
#line 99 
enum iommu_cap {
    IOMMU_CAP_CACHE_COHERENCY = 0,
    IOMMU_CAP_INTR_REMAP = 1,
    IOMMU_CAP_NOEXEC = 2
};
#line 105 
enum iommu_attr {
    DOMAIN_ATTR_GEOMETRY = 0,
    DOMAIN_ATTR_PAGING = 1,
    DOMAIN_ATTR_WINDOWS = 2,
    DOMAIN_ATTR_FSL_PAMU_STASH = 3,
    DOMAIN_ATTR_FSL_PAMU_ENABLE = 4,
    DOMAIN_ATTR_FSL_PAMUV1 = 5,
    DOMAIN_ATTR_NESTING = 6,
    DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE = 7,
    DOMAIN_ATTR_MAX = 8
};
#line 117 
enum iommu_resv_type {
    IOMMU_RESV_DIRECT = 0,
    IOMMU_RESV_DIRECT_RELAXABLE = 1,
    IOMMU_RESV_RESERVED = 2,
    IOMMU_RESV_MSI = 3,
    IOMMU_RESV_SW_MSI = 4
};
#line 158  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iommu.h"
struct iommu_resv_region {
   struct list_head list ;
   phys_addr_t start ;
   size_t length ;
   int prot ;
   enum iommu_resv_type type ;
};
#line 165 
enum iommu_dev_features {
    IOMMU_DEV_FEAT_AUX = 0,
    IOMMU_DEV_FEAT_SVA = 1
};
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iommu.h"
struct iommu_sva_ops {
   int (*mm_exit)(struct device *, struct iommu_sva *, void *) ;
};
#line 206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iommu.h"
struct iommu_iotlb_gather {
   unsigned long start ;
   unsigned long end ;
   size_t pgsize ;
};
#line 253  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iommu.h"
struct iommu_ops {
   bool (*capable)(enum iommu_cap ) ;
   struct iommu_domain *(*domain_alloc)(unsigned int ) ;
   void (*domain_free)(struct iommu_domain *) ;
   int (*attach_dev)(struct iommu_domain *, struct device *) ;
   void (*detach_dev)(struct iommu_domain *, struct device *) ;
   int (*map)(struct iommu_domain *, unsigned long , phys_addr_t , size_t , int , gfp_t ) ;
   size_t (*unmap)(struct iommu_domain *, unsigned long , size_t , struct iommu_iotlb_gather *) ;
   void (*flush_iotlb_all)(struct iommu_domain *) ;
   void (*iotlb_sync_map)(struct iommu_domain *) ;
   void (*iotlb_sync)(struct iommu_domain *, struct iommu_iotlb_gather *) ;
   phys_addr_t (*iova_to_phys)(struct iommu_domain *, dma_addr_t ) ;
   int (*add_device)(struct device *) ;
   void (*remove_device)(struct device *) ;
   struct iommu_group *(*device_group)(struct device *) ;
   int (*domain_get_attr)(struct iommu_domain *, enum iommu_attr , void *) ;
   int (*domain_set_attr)(struct iommu_domain *, enum iommu_attr , void *) ;
   void (*get_resv_regions)(struct device *, struct list_head *) ;
   void (*put_resv_regions)(struct device *, struct list_head *) ;
   void (*apply_resv_region)(struct device *, struct iommu_domain *, struct iommu_resv_region *) ;
   int (*domain_window_enable)(struct iommu_domain *, u32 , phys_addr_t , u64 , int ) ;
   void (*domain_window_disable)(struct iommu_domain *, u32 ) ;
   int (*of_xlate)(struct device *, struct of_phandle_args *) ;
   bool (*is_attach_deferred)(struct iommu_domain *, struct device *) ;
   bool (*dev_has_feat)(struct device *, enum iommu_dev_features ) ;
   bool (*dev_feat_enabled)(struct device *, enum iommu_dev_features ) ;
   int (*dev_enable_feat)(struct device *, enum iommu_dev_features ) ;
   int (*dev_disable_feat)(struct device *, enum iommu_dev_features ) ;
   int (*aux_attach_dev)(struct iommu_domain *, struct device *) ;
   void (*aux_detach_dev)(struct iommu_domain *, struct device *) ;
   int (*aux_get_pasid)(struct iommu_domain *, struct device *) ;
   struct iommu_sva *(*sva_bind)(struct device *, struct mm_struct *, void *) ;
   void (*sva_unbind)(struct iommu_sva *) ;
   int (*sva_get_pasid)(struct iommu_sva *) ;
   int (*page_response)(struct device *, struct iommu_fault_event *, struct iommu_page_response *) ;
   int (*cache_invalidate)(struct iommu_domain *, struct device *, struct iommu_cache_invalidate_info *) ;
   int (*sva_bind_gpasid)(struct iommu_domain *, struct device *, struct iommu_gpasid_bind_data *) ;
   int (*sva_unbind_gpasid)(struct device *, int ) ;
   unsigned long pgsize_bitmap ;
};
#line 346  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iommu.h"
struct iommu_fault_event {
   struct iommu_fault fault ;
   struct list_head list ;
};
#line 358  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iommu.h"
struct iommu_fault_param {
   int (*handler)(struct iommu_fault *, void *) ;
   void *data ;
   struct list_head faults ;
   struct mutex lock ;
};
#line 374  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iommu.h"
struct iommu_param {
   struct mutex lock ;
   struct iommu_fault_param *fault_param ;
};
#line 576  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iommu.h"
struct iommu_fwspec {
   struct iommu_ops *ops ;
   struct fwnode_handle *iommu_fwnode ;
   void *iommu_priv ;
   u32 flags ;
   unsigned int num_ids ;
   u32 ids[1U] ;
};
#line 591  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iommu.h"
struct iommu_sva {
   struct device *dev ;
   struct iommu_sva_ops *ops ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cdev.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
} __attribute__((__designated_init__));
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ptp_clock.h"
struct ptp_clock_time {
   __s64 sec ;
   __u32 nsec ;
   __u32 reserved ;
};
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ptp_clock.h"
struct ptp_extts_request {
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[2U] ;
};
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ptp_clock.h"
struct ptp_perout_request {
   struct ptp_clock_time start ;
   struct ptp_clock_time period ;
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[4U] ;
};
#line 138 
enum ptp_pin_function {
    PTP_PF_NONE = 0,
    PTP_PF_EXTTS = 1,
    PTP_PF_PEROUT = 2,
    PTP_PF_PHYSYNC = 3
};
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ptp_clock.h"
struct ptp_pin_desc {
   char name[64U] ;
   unsigned int index ;
   unsigned int func ;
   unsigned int chan ;
   unsigned int rsv[5U] ;
};
#line 205 
enum ldv_21232 {
    PTP_CLK_REQ_EXTTS = 0,
    PTP_CLK_REQ_PEROUT = 1,
    PTP_CLK_REQ_PPS = 2
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
union __anonunion_1056 {
   struct ptp_extts_request extts ;
   struct ptp_perout_request perout ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
struct ptp_clock_request {
   enum ldv_21232 type ;
   union __anonunion_1056 __anonCompField_ptp_clock_request_206 ;
};
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
struct ptp_system_timestamp {
   struct timespec64 pre_ts ;
   struct timespec64 post_ts ;
};
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
struct ptp_clock_info {
   struct module *owner ;
   char name[16U] ;
   s32 max_adj ;
   int n_alarm ;
   int n_ext_ts ;
   int n_per_out ;
   int n_pins ;
   int pps ;
   struct ptp_pin_desc *pin_config ;
   int (*adjfine)(struct ptp_clock_info *, long ) ;
   int (*adjfreq)(struct ptp_clock_info *, s32 ) ;
   int (*adjtime)(struct ptp_clock_info *, s64 ) ;
   int (*gettime64)(struct ptp_clock_info *, struct timespec64 *) ;
   int (*gettimex64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *) ;
   int (*getcrosststamp)(struct ptp_clock_info *, struct system_device_crosststamp *) ;
   int (*settime64)(struct ptp_clock_info *, struct timespec64 *) ;
   int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int ) ;
   int (*verify)(struct ptp_clock_info *, unsigned int , enum ptp_pin_function , unsigned int ) ;
   long (*do_aux_work)(struct ptp_clock_info *) ;
};
#line 144 
struct ptp_clock;
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_sched.h"
struct qdisc_walker {
   int stop ;
   int skip ;
   int count ;
   int (*fn)(struct Qdisc *, unsigned long , struct qdisc_walker *) ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/generic.h"
struct __anonstruct_s_1059 {
   unsigned int len ;
   struct callback_head rcu ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/generic.h"
union __anonunion_1058 {
   struct __anonstruct_s_1059 s ;
   void *ptr[0U] ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/generic.h"
struct net_generic {
   union __anonunion_1058 __anonCompField_net_generic_208 ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
struct tcf_walker {
   int stop ;
   int skip ;
   int count ;
   bool nonempty ;
   unsigned long cookie ;
   int (*fn)(struct tcf_proto *, void *, struct tcf_walker *) ;
};
#line 665  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
struct tc_mqprio_qopt_offload {
   struct tc_mqprio_qopt qopt ;
   u16 mode ;
   u16 shaper ;
   u32 flags ;
   u64 min_rate[16U] ;
   u64 max_rate[16U] ;
};
#line 105  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_xdp.h"
struct xsk_queue;
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
struct xdp_umem_page {
   void *addr ;
   dma_addr_t dma ;
};
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
struct xdp_umem_fq_reuse {
   u32 nentries ;
   u32 length ;
   u64 handles[] ;
};
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
struct xdp_umem {
   struct xsk_queue *fq ;
   struct xsk_queue *cq ;
   struct xdp_umem_page *pages ;
   u64 chunk_mask ;
   u64 size ;
   u32 headroom ;
   u32 chunk_size_nohr ;
   struct user_struct *user ;
   unsigned long address ;
   refcount_t users ;
   struct work_struct work ;
   struct page **pgs ;
   u32 npgs ;
   u16 queue_id ;
   u8 need_wakeup ;
   u8 flags ;
   int id ;
   struct net_device *dev ;
   struct xdp_umem_fq_reuse *fq_reuse ;
   bool zc ;
   spinlock_t xsk_list_lock ;
   struct list_head xsk_list ;
};
#line 242 
enum i40e_status_code {
    I40E_SUCCESS = 0,
    I40E_ERR_NVM = -1,
    I40E_ERR_NVM_CHECKSUM = -2,
    I40E_ERR_PHY = -3,
    I40E_ERR_CONFIG = -4,
    I40E_ERR_PARAM = -5,
    I40E_ERR_MAC_TYPE = -6,
    I40E_ERR_UNKNOWN_PHY = -7,
    I40E_ERR_LINK_SETUP = -8,
    I40E_ERR_ADAPTER_STOPPED = -9,
    I40E_ERR_INVALID_MAC_ADDR = -10,
    I40E_ERR_DEVICE_NOT_SUPPORTED = -11,
    I40E_ERR_MASTER_REQUESTS_PENDING = -12,
    I40E_ERR_INVALID_LINK_SETTINGS = -13,
    I40E_ERR_AUTONEG_NOT_COMPLETE = -14,
    I40E_ERR_RESET_FAILED = -15,
    I40E_ERR_SWFW_SYNC = -16,
    I40E_ERR_NO_AVAILABLE_VSI = -17,
    I40E_ERR_NO_MEMORY = -18,
    I40E_ERR_BAD_PTR = -19,
    I40E_ERR_RING_FULL = -20,
    I40E_ERR_INVALID_PD_ID = -21,
    I40E_ERR_INVALID_QP_ID = -22,
    I40E_ERR_INVALID_CQ_ID = -23,
    I40E_ERR_INVALID_CEQ_ID = -24,
    I40E_ERR_INVALID_AEQ_ID = -25,
    I40E_ERR_INVALID_SIZE = -26,
    I40E_ERR_INVALID_ARP_INDEX = -27,
    I40E_ERR_INVALID_FPM_FUNC_ID = -28,
    I40E_ERR_QP_INVALID_MSG_SIZE = -29,
    I40E_ERR_QP_TOOMANY_WRS_POSTED = -30,
    I40E_ERR_INVALID_FRAG_COUNT = -31,
    I40E_ERR_QUEUE_EMPTY = -32,
    I40E_ERR_INVALID_ALIGNMENT = -33,
    I40E_ERR_FLUSHED_QUEUE = -34,
    I40E_ERR_INVALID_PUSH_PAGE_INDEX = -35,
    I40E_ERR_INVALID_IMM_DATA_SIZE = -36,
    I40E_ERR_TIMEOUT = -37,
    I40E_ERR_OPCODE_MISMATCH = -38,
    I40E_ERR_CQP_COMPL_ERROR = -39,
    I40E_ERR_INVALID_VF_ID = -40,
    I40E_ERR_INVALID_HMCFN_ID = -41,
    I40E_ERR_BACKING_PAGE_ERROR = -42,
    I40E_ERR_NO_PBLCHUNKS_AVAILABLE = -43,
    I40E_ERR_INVALID_PBLE_INDEX = -44,
    I40E_ERR_INVALID_SD_INDEX = -45,
    I40E_ERR_INVALID_PAGE_DESC_INDEX = -46,
    I40E_ERR_INVALID_SD_TYPE = -47,
    I40E_ERR_MEMCPY_FAILED = -48,
    I40E_ERR_INVALID_HMC_OBJ_INDEX = -49,
    I40E_ERR_INVALID_HMC_OBJ_COUNT = -50,
    I40E_ERR_INVALID_SRQ_ARM_LIMIT = -51,
    I40E_ERR_SRQ_ENABLED = -52,
    I40E_ERR_ADMIN_QUEUE_ERROR = -53,
    I40E_ERR_ADMIN_QUEUE_TIMEOUT = -54,
    I40E_ERR_BUF_TOO_SHORT = -55,
    I40E_ERR_ADMIN_QUEUE_FULL = -56,
    I40E_ERR_ADMIN_QUEUE_NO_WORK = -57,
    I40E_ERR_BAD_IWARP_CQE = -58,
    I40E_ERR_NVM_BLANK_MODE = -59,
    I40E_ERR_NOT_IMPLEMENTED = -60,
    I40E_ERR_PE_DOORBELL_NOT_ENABLED = -61,
    I40E_ERR_DIAG_TEST_FAILED = -62,
    I40E_ERR_NOT_READY = -63,
    I40E_NOT_SUPPORTED = -64,
    I40E_ERR_FIRMWARE_API_VERSION = -65,
    I40E_ERR_ADMIN_QUEUE_CRITICAL_ERROR = -66
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_osdep.h"
struct i40e_dma_mem {
   void *va ;
   dma_addr_t pa ;
   u32 size ;
};
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_osdep.h"
struct i40e_virt_mem {
   void *va ;
   u32 size ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_osdep.h"
typedef enum i40e_status_code i40e_status;
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct __anonstruct_internal_1072 {
   __le32 param0 ;
   __le32 param1 ;
   __le32 param2 ;
   __le32 param3 ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct __anonstruct_external_1073 {
   __le32 param0 ;
   __le32 param1 ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
union __anonunion_params_1071 {
   struct __anonstruct_internal_1072 internal ;
   struct __anonstruct_external_1073 external ;
   u8 raw[16U] ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aq_desc {
   __le16 flags ;
   __le16 opcode ;
   __le16 datalen ;
   __le16 retval ;
   __le32 cookie_high ;
   __le32 cookie_low ;
   union __anonunion_params_1071 params ;
};
#line 51 
enum i40e_admin_queue_err {
    I40E_AQ_RC_OK = 0,
    I40E_AQ_RC_EPERM = 1,
    I40E_AQ_RC_ENOENT = 2,
    I40E_AQ_RC_ESRCH = 3,
    I40E_AQ_RC_EINTR = 4,
    I40E_AQ_RC_EIO = 5,
    I40E_AQ_RC_ENXIO = 6,
    I40E_AQ_RC_E2BIG = 7,
    I40E_AQ_RC_EAGAIN = 8,
    I40E_AQ_RC_ENOMEM = 9,
    I40E_AQ_RC_EACCES = 10,
    I40E_AQ_RC_EFAULT = 11,
    I40E_AQ_RC_EBUSY = 12,
    I40E_AQ_RC_EEXIST = 13,
    I40E_AQ_RC_EINVAL = 14,
    I40E_AQ_RC_ENOTTY = 15,
    I40E_AQ_RC_ENOSPC = 16,
    I40E_AQ_RC_ENOSYS = 17,
    I40E_AQ_RC_ERANGE = 18,
    I40E_AQ_RC_EFLUSHED = 19,
    I40E_AQ_RC_BAD_ADDR = 20,
    I40E_AQ_RC_EMODE = 21,
    I40E_AQ_RC_EFBIG = 22
};
#line 867  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_vsi_properties_data {
   __le16 valid_sections ;
   __le16 switch_id ;
   u8 sw_reserved[2U] ;
   u8 sec_flags ;
   u8 sec_reserved ;
   __le16 pvid ;
   __le16 fcoe_pvid ;
   u8 port_vlan_flags ;
   u8 pvlan_reserved[3U] ;
   __le32 ingress_table ;
   __le32 egress_table ;
   __le16 cas_pv_tag ;
   u8 cas_pv_flags ;
   u8 cas_pv_reserved ;
   __le16 mapping_flags ;
   __le16 queue_mapping[16U] ;
   __le16 tc_mapping[8U] ;
   u8 queueing_opt_flags ;
   u8 queueing_opt_reserved[3U] ;
   u8 up_enable_bits ;
   u8 sched_reserved ;
   __le32 outer_up_table ;
   u8 cmd_reserved[8U] ;
   __le16 qs_handle[8U] ;
   __le16 stat_counter_idx ;
   __le16 sched_id ;
   u8 resp_reserved[12U] ;
};
#line 1853 
enum i40e_aq_phy_type {
    I40E_PHY_TYPE_SGMII = 0,
    I40E_PHY_TYPE_1000BASE_KX = 1,
    I40E_PHY_TYPE_10GBASE_KX4 = 2,
    I40E_PHY_TYPE_10GBASE_KR = 3,
    I40E_PHY_TYPE_40GBASE_KR4 = 4,
    I40E_PHY_TYPE_XAUI = 5,
    I40E_PHY_TYPE_XFI = 6,
    I40E_PHY_TYPE_SFI = 7,
    I40E_PHY_TYPE_XLAUI = 8,
    I40E_PHY_TYPE_XLPPI = 9,
    I40E_PHY_TYPE_40GBASE_CR4_CU = 10,
    I40E_PHY_TYPE_10GBASE_CR1_CU = 11,
    I40E_PHY_TYPE_10GBASE_AOC = 12,
    I40E_PHY_TYPE_40GBASE_AOC = 13,
    I40E_PHY_TYPE_UNRECOGNIZED = 14,
    I40E_PHY_TYPE_UNSUPPORTED = 15,
    I40E_PHY_TYPE_100BASE_TX = 17,
    I40E_PHY_TYPE_1000BASE_T = 18,
    I40E_PHY_TYPE_10GBASE_T = 19,
    I40E_PHY_TYPE_10GBASE_SR = 20,
    I40E_PHY_TYPE_10GBASE_LR = 21,
    I40E_PHY_TYPE_10GBASE_SFPP_CU = 22,
    I40E_PHY_TYPE_10GBASE_CR1 = 23,
    I40E_PHY_TYPE_40GBASE_CR4 = 24,
    I40E_PHY_TYPE_40GBASE_SR4 = 25,
    I40E_PHY_TYPE_40GBASE_LR4 = 26,
    I40E_PHY_TYPE_1000BASE_SX = 27,
    I40E_PHY_TYPE_1000BASE_LX = 28,
    I40E_PHY_TYPE_1000BASE_T_OPTICAL = 29,
    I40E_PHY_TYPE_20GBASE_KR2 = 30,
    I40E_PHY_TYPE_25GBASE_KR = 31,
    I40E_PHY_TYPE_25GBASE_CR = 32,
    I40E_PHY_TYPE_25GBASE_SR = 33,
    I40E_PHY_TYPE_25GBASE_LR = 34,
    I40E_PHY_TYPE_25GBASE_AOC = 35,
    I40E_PHY_TYPE_25GBASE_ACC = 36,
    I40E_PHY_TYPE_2_5GBASE_T = 48,
    I40E_PHY_TYPE_5GBASE_T = 49,
    I40E_PHY_TYPE_MAX = 50,
    I40E_PHY_TYPE_NOT_SUPPORTED_HIGH_TEMP = 253,
    I40E_PHY_TYPE_EMPTY = 254,
    I40E_PHY_TYPE_DEFAULT = 255
};
#line 1898 
enum i40e_aq_link_speed {
    I40E_LINK_SPEED_UNKNOWN = 0,
    I40E_LINK_SPEED_100MB = 2,
    I40E_LINK_SPEED_1GB = 4,
    I40E_LINK_SPEED_2_5GB = 1,
    I40E_LINK_SPEED_5GB = 128,
    I40E_LINK_SPEED_10GB = 8,
    I40E_LINK_SPEED_40GB = 16,
    I40E_LINK_SPEED_20GB = 32,
    I40E_LINK_SPEED_25GB = 64
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.h"
union __anonunion_r_1081 {
   struct i40e_dma_mem *asq_bi ;
   struct i40e_dma_mem *arq_bi ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.h"
struct i40e_adminq_ring {
   struct i40e_virt_mem dma_head ;
   struct i40e_dma_mem desc_buf ;
   struct i40e_virt_mem cmd_buf ;
   union __anonunion_r_1081 r ;
   u16 count ;
   u16 rx_buf_len ;
   u16 next_to_use ;
   u16 next_to_clean ;
   u32 head ;
   u32 tail ;
   u32 len ;
   u32 bah ;
   u32 bal ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.h"
struct i40e_asq_cmd_details {
   void *callback ;
   u64 cookie ;
   u16 flags_ena ;
   u16 flags_dis ;
   bool async ;
   bool postpone ;
   struct i40e_aq_desc *wb_desc ;
};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.h"
struct i40e_adminq_info {
   struct i40e_adminq_ring arq ;
   struct i40e_adminq_ring asq ;
   u32 asq_cmd_timeout ;
   u16 num_arq_entries ;
   u16 num_asq_entries ;
   u16 arq_buf_size ;
   u16 asq_buf_size ;
   u16 fw_maj_ver ;
   u16 fw_min_ver ;
   u32 fw_build ;
   u16 api_maj_ver ;
   u16 api_min_ver ;
   struct mutex asq_mutex ;
   struct mutex arq_mutex ;
   enum i40e_admin_queue_err asq_last_status ;
   enum i40e_admin_queue_err arq_last_status ;
};
#line 134 
struct i40e_hw;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
struct i40e_hmc_obj_info {
   u64 base ;
   u32 max_cnt ;
   u32 cnt ;
   u64 size ;
};
#line 25 
enum i40e_sd_entry_type {
    I40E_SD_TYPE_INVALID = 0,
    I40E_SD_TYPE_PAGED = 1,
    I40E_SD_TYPE_DIRECT = 2
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
struct i40e_hmc_bp {
   enum i40e_sd_entry_type entry_type ;
   struct i40e_dma_mem addr ;
   u32 sd_pd_index ;
   u32 ref_cnt ;
};
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
struct i40e_hmc_pd_entry {
   struct i40e_hmc_bp bp ;
   u32 sd_index ;
   bool rsrc_pg ;
   bool valid ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
struct i40e_hmc_pd_table {
   struct i40e_dma_mem pd_page_addr ;
   struct i40e_hmc_pd_entry *pd_entry ;
   struct i40e_virt_mem pd_entry_virt_mem ;
   u32 ref_cnt ;
   u32 sd_index ;
};
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
union __anonunion_u_1082 {
   struct i40e_hmc_pd_table pd_table ;
   struct i40e_hmc_bp bp ;
};
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
struct i40e_hmc_sd_entry {
   enum i40e_sd_entry_type entry_type ;
   bool valid ;
   union __anonunion_u_1082 u ;
};
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
struct i40e_hmc_sd_table {
   struct i40e_virt_mem addr ;
   u32 sd_cnt ;
   u32 ref_cnt ;
   struct i40e_hmc_sd_entry *sd_entry ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
struct i40e_hmc_info {
   u32 signature ;
   u8 hmc_fn_id ;
   u16 first_sd_index ;
   struct i40e_hmc_obj_info *hmc_obj ;
   struct i40e_virt_mem hmc_obj_virt_mem ;
   struct i40e_hmc_sd_table sd_table ;
};
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
enum i40e_mac_type {
    I40E_MAC_UNKNOWN = 0,
    I40E_MAC_XL710 = 1,
    I40E_MAC_VF = 2,
    I40E_MAC_X722 = 3,
    I40E_MAC_X722_VF = 4,
    I40E_MAC_GENERIC = 5
};
#line 67 
enum i40e_media_type {
    I40E_MEDIA_TYPE_UNKNOWN = 0,
    I40E_MEDIA_TYPE_FIBER = 1,
    I40E_MEDIA_TYPE_BASET = 2,
    I40E_MEDIA_TYPE_BACKPLANE = 3,
    I40E_MEDIA_TYPE_CX4 = 4,
    I40E_MEDIA_TYPE_DA = 5,
    I40E_MEDIA_TYPE_VIRTUAL = 6
};
#line 77 
enum i40e_fc_mode {
    I40E_FC_NONE = 0,
    I40E_FC_RX_PAUSE = 1,
    I40E_FC_TX_PAUSE = 2,
    I40E_FC_FULL = 3,
    I40E_FC_PFC = 4,
    I40E_FC_DEFAULT = 5
};
#line 94 
enum i40e_vsi_type {
    I40E_VSI_MAIN = 0,
    I40E_VSI_VMDQ1 = 1,
    I40E_VSI_VMDQ2 = 2,
    I40E_VSI_CTRL = 3,
    I40E_VSI_FCOE = 4,
    I40E_VSI_MIRROR = 5,
    I40E_VSI_SRIOV = 6,
    I40E_VSI_FDIR = 7,
    I40E_VSI_IWARP = 8,
    I40E_VSI_TYPE_UNKNOWN = 9
};
#line 163  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_link_status {
   enum i40e_aq_phy_type phy_type ;
   enum i40e_aq_link_speed link_speed ;
   u8 link_info ;
   u8 an_info ;
   u8 req_fec_info ;
   u8 fec_info ;
   u8 ext_info ;
   u8 loopback ;
   bool lse_enable ;
   u16 max_frame_size ;
   bool crc_enable ;
   u8 pacing ;
   u8 requested_speeds ;
   u8 module_type[3U] ;
};
#line 198  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_phy_info {
   struct i40e_link_status link_info ;
   struct i40e_link_status link_info_old ;
   bool get_link_info ;
   enum i40e_media_type media_type ;
   u64 phy_types ;
};
#line 263  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_hw_capabilities {
   u32 switch_mode ;
   u32 management_mode ;
   u32 mng_protocols_over_mctp ;
   u32 npar_enable ;
   u32 os2bmc ;
   u32 valid_functions ;
   bool sr_iov_1_1 ;
   bool vmdq ;
   bool evb_802_1_qbg ;
   bool evb_802_1_qbh ;
   bool dcb ;
   bool fcoe ;
   bool iscsi ;
   bool flex10_enable ;
   bool flex10_capable ;
   u32 flex10_mode ;
   u32 flex10_status ;
   bool sec_rev_disabled ;
   bool update_disabled ;
   bool mgmt_cem ;
   bool ieee_1588 ;
   bool iwarp ;
   bool fd ;
   u32 fd_filters_guaranteed ;
   u32 fd_filters_best_effort ;
   bool rss ;
   u32 rss_table_size ;
   u32 rss_table_entry_width ;
   bool led[30U] ;
   bool sdp[30U] ;
   u32 nvm_image_type ;
   u32 num_flow_director_filters ;
   u32 num_vfs ;
   u32 vf_base_id ;
   u32 num_vsis ;
   u32 num_rx_qp ;
   u32 num_tx_qp ;
   u32 base_queue ;
   u32 num_msix_vectors ;
   u32 num_msix_vectors_vf ;
   u32 led_pin_num ;
   u32 sdp_pin_num ;
   u32 mdio_port_num ;
   u32 mdio_port_mode ;
   u8 rx_buf_chain_len ;
   u32 enabled_tcmap ;
   u32 maxtc ;
   u64 wr_csr_prot ;
};
#line 341  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_mac_info {
   enum i40e_mac_type type ;
   u8 addr[6U] ;
   u8 perm_addr[6U] ;
   u8 san_addr[6U] ;
   u8 port_addr[6U] ;
   u16 max_fcoeq ;
};
#line 359  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_nvm_info {
   u64 hw_semaphore_timeout ;
   u32 timeout ;
   u16 sr_size ;
   bool blank_nvm_mode ;
   u16 version ;
   u32 eetrack ;
   u32 oem_ver ;
};
#line 388 
enum i40e_nvmupd_state {
    I40E_NVMUPD_STATE_INIT = 0,
    I40E_NVMUPD_STATE_READING = 1,
    I40E_NVMUPD_STATE_WRITING = 2,
    I40E_NVMUPD_STATE_INIT_WAIT = 3,
    I40E_NVMUPD_STATE_WRITE_WAIT = 4,
    I40E_NVMUPD_STATE_ERROR = 5
};
#line 437 
enum i40e_bus_type {
    i40e_bus_type_unknown = 0,
    i40e_bus_type_pci = 1,
    i40e_bus_type_pcix = 2,
    i40e_bus_type_pci_express = 3,
    i40e_bus_type_reserved = 4
};
#line 445 
enum i40e_bus_speed {
    i40e_bus_speed_unknown = 0,
    i40e_bus_speed_33 = 33,
    i40e_bus_speed_66 = 66,
    i40e_bus_speed_100 = 100,
    i40e_bus_speed_120 = 120,
    i40e_bus_speed_133 = 133,
    i40e_bus_speed_2500 = 2500,
    i40e_bus_speed_5000 = 5000,
    i40e_bus_speed_8000 = 8000,
    i40e_bus_speed_reserved = 8001
};
#line 458 
enum i40e_bus_width {
    i40e_bus_width_unknown = 0,
    i40e_bus_width_pcie_x1 = 1,
    i40e_bus_width_pcie_x2 = 2,
    i40e_bus_width_pcie_x4 = 4,
    i40e_bus_width_pcie_x8 = 8,
    i40e_bus_width_32 = 32,
    i40e_bus_width_64 = 64,
    i40e_bus_width_reserved = 65
};
#line 487  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_bus_info {
   enum i40e_bus_speed speed ;
   enum i40e_bus_width width ;
   enum i40e_bus_type type ;
   u16 func ;
   u16 device ;
   u16 lan_id ;
   u16 bus_id ;
};
#line 499  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_fc_info {
   enum i40e_fc_mode current_mode ;
   enum i40e_fc_mode requested_mode ;
};
#line 521  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_dcb_ets_config {
   u8 willing ;
   u8 cbs ;
   u8 maxtcs ;
   u8 prioritytable[8U] ;
   u8 tcbwtable[8U] ;
   u8 tsatable[8U] ;
};
#line 531  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_dcb_pfc_config {
   u8 willing ;
   u8 mbc ;
   u8 pfccap ;
   u8 pfcenable ;
};
#line 539  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_dcb_app_priority_table {
   u8 priority ;
   u8 selector ;
   u16 protocolid ;
};
#line 545  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_dcbx_config {
   u8 dcbx_mode ;
   u8 app_mode ;
   u32 numapps ;
   u32 tlv_status ;
   struct i40e_dcb_ets_config etscfg ;
   struct i40e_dcb_ets_config etsrec ;
   struct i40e_dcb_pfc_config pfc ;
   struct i40e_dcb_app_priority_table app[32U] ;
};
#line 560  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_hw {
   u8 *hw_addr ;
   void *back ;
   struct i40e_phy_info phy ;
   struct i40e_mac_info mac ;
   struct i40e_bus_info bus ;
   struct i40e_nvm_info nvm ;
   struct i40e_fc_info fc ;
   u16 device_id ;
   u16 vendor_id ;
   u16 subsystem_device_id ;
   u16 subsystem_vendor_id ;
   u8 revision_id ;
   u8 port ;
   bool adapter_stopped ;
   struct i40e_hw_capabilities dev_caps ;
   struct i40e_hw_capabilities func_caps ;
   u16 fdir_shared_filter_count ;
   u8 pf_id ;
   u16 main_vsi_seid ;
   u16 partition_id ;
   u16 num_partitions ;
   u16 num_ports ;
   u16 numa_node ;
   struct i40e_adminq_info aq ;
   enum i40e_nvmupd_state nvmupd_state ;
   struct i40e_aq_desc nvm_wb_desc ;
   struct i40e_aq_desc nvm_aq_event_desc ;
   struct i40e_virt_mem nvm_buff ;
   bool nvm_release_on_done ;
   u16 nvm_wait_opcode ;
   struct i40e_hmc_info hmc ;
   u16 dcbx_status ;
   struct i40e_dcbx_config local_dcbx_config ;
   struct i40e_dcbx_config remote_dcbx_config ;
   struct i40e_dcbx_config desired_dcbx_config ;
   u64 flags ;
   u16 switch_tag ;
   u16 first_tag ;
   u16 second_tag ;
   u32 debug_mask ;
   char err_str[16U] ;
};
#line 958  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_tx_desc {
   __le64 buffer_addr ;
   __le64 cmd_type_offset_bsz ;
};
#line 1228  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_eth_stats {
   u64 rx_bytes ;
   u64 rx_unicast ;
   u64 rx_multicast ;
   u64 rx_broadcast ;
   u64 rx_discards ;
   u64 rx_unknown_protocol ;
   u64 tx_bytes ;
   u64 tx_unicast ;
   u64 tx_multicast ;
   u64 tx_broadcast ;
   u64 tx_discards ;
   u64 tx_errors ;
};
#line 1244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_veb_tc_stats {
   u64 tc_rx_packets[8U] ;
   u64 tc_rx_bytes[8U] ;
   u64 tc_tx_packets[8U] ;
   u64 tc_tx_bytes[8U] ;
};
#line 1252  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_hw_port_stats {
   struct i40e_eth_stats eth ;
   u64 tx_dropped_link_down ;
   u64 crc_errors ;
   u64 illegal_bytes ;
   u64 error_bytes ;
   u64 mac_local_faults ;
   u64 mac_remote_faults ;
   u64 rx_length_errors ;
   u64 link_xon_rx ;
   u64 link_xoff_rx ;
   u64 priority_xon_rx[8U] ;
   u64 priority_xoff_rx[8U] ;
   u64 link_xon_tx ;
   u64 link_xoff_tx ;
   u64 priority_xon_tx[8U] ;
   u64 priority_xoff_tx[8U] ;
   u64 priority_xon_2_xoff[8U] ;
   u64 rx_size_64 ;
   u64 rx_size_127 ;
   u64 rx_size_255 ;
   u64 rx_size_511 ;
   u64 rx_size_1023 ;
   u64 rx_size_1522 ;
   u64 rx_size_big ;
   u64 rx_undersize ;
   u64 rx_fragments ;
   u64 rx_oversize ;
   u64 rx_jabber ;
   u64 tx_size_64 ;
   u64 tx_size_127 ;
   u64 tx_size_255 ;
   u64 tx_size_511 ;
   u64 tx_size_1023 ;
   u64 tx_size_1522 ;
   u64 tx_size_big ;
   u64 mac_short_packet_dropped ;
   u64 checksum_error ;
   u64 fd_atr_match ;
   u64 fd_sb_match ;
   u64 fd_atr_tunnel_match ;
   u32 fd_atr_status ;
   u32 fd_sb_status ;
   u32 tx_lpi_status ;
   u32 rx_lpi_status ;
   u64 tx_lpi_count ;
   u64 rx_lpi_count ;
};
#line 1305 
enum i40e_switch_element_types {
    I40E_SWITCH_ELEMENT_TYPE_MAC = 1,
    I40E_SWITCH_ELEMENT_TYPE_PF = 2,
    I40E_SWITCH_ELEMENT_TYPE_VF = 3,
    I40E_SWITCH_ELEMENT_TYPE_EMP = 4,
    I40E_SWITCH_ELEMENT_TYPE_BMC = 6,
    I40E_SWITCH_ELEMENT_TYPE_PE = 16,
    I40E_SWITCH_ELEMENT_TYPE_VEB = 17,
    I40E_SWITCH_ELEMENT_TYPE_PA = 18,
    I40E_SWITCH_ELEMENT_TYPE_VSI = 19
};
#line 1332 
enum i40e_hash_filter_size {
    I40E_HASH_FILTER_SIZE_1K = 0,
    I40E_HASH_FILTER_SIZE_2K = 1,
    I40E_HASH_FILTER_SIZE_4K = 2,
    I40E_HASH_FILTER_SIZE_8K = 3,
    I40E_HASH_FILTER_SIZE_16K = 4,
    I40E_HASH_FILTER_SIZE_32K = 5,
    I40E_HASH_FILTER_SIZE_64K = 6,
    I40E_HASH_FILTER_SIZE_128K = 7,
    I40E_HASH_FILTER_SIZE_256K = 8,
    I40E_HASH_FILTER_SIZE_512K = 9,
    I40E_HASH_FILTER_SIZE_1M = 10
};
#line 1346 
enum i40e_dma_cntx_size {
    I40E_DMA_CNTX_SIZE_512 = 0,
    I40E_DMA_CNTX_SIZE_1K = 1,
    I40E_DMA_CNTX_SIZE_2K = 2,
    I40E_DMA_CNTX_SIZE_4K = 3,
    I40E_DMA_CNTX_SIZE_8K = 4,
    I40E_DMA_CNTX_SIZE_16K = 5,
    I40E_DMA_CNTX_SIZE_32K = 6,
    I40E_DMA_CNTX_SIZE_64K = 7,
    I40E_DMA_CNTX_SIZE_128K = 8,
    I40E_DMA_CNTX_SIZE_256K = 9
};
#line 1359 
enum i40e_hash_lut_size {
    I40E_HASH_LUT_SIZE_128 = 0,
    I40E_HASH_LUT_SIZE_512 = 1
};
#line 1413  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_filter_control_settings {
   enum i40e_hash_filter_size pe_filt_num ;
   enum i40e_dma_cntx_size pe_cntx_num ;
   enum i40e_hash_filter_size fcoe_filt_num ;
   enum i40e_dma_cntx_size fcoe_cntx_num ;
   enum i40e_hash_lut_size hash_lut_size ;
   bool enable_fdir ;
   bool enable_ethtype ;
   bool enable_macvlan ;
};
#line 182  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_version_info {
   u32 major ;
   u32 minor ;
};
#line 406  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_ether_addr {
   u8 addr[6U] ;
   u8 pad[2U] ;
};
#line 633  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_iwarp_qv_info {
   u32 v_idx ;
   u16 ceq_idx ;
   u16 aeq_idx ;
   u8 itr_idx ;
};
#line 642  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_iwarp_qvlist_info {
   u32 num_vectors ;
   struct virtchnl_iwarp_qv_info qv_info[1U] ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.h"
struct i40e_client_version {
   u8 major ;
   u8 minor ;
   u8 build ;
   u8 rsvd ;
};
#line 36 
struct i40e_ops;
#line 37 
struct i40e_client;
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.h"
struct i40e_qv_info {
   u32 v_idx ;
   u16 ceq_idx ;
   u16 aeq_idx ;
   u8 itr_idx ;
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.h"
struct i40e_qvlist_info {
   u32 num_vectors ;
   struct i40e_qv_info qv_info[1U] ;
};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.h"
struct i40e_prio_qos_params {
   u16 qs_handle ;
   u8 tc ;
   u8 reserved ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.h"
struct i40e_qos_params {
   struct i40e_prio_qos_params prio_qos[8U] ;
};
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.h"
struct i40e_params {
   struct i40e_qos_params qos ;
   u16 mtu ;
};
#line 82  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.h"
struct i40e_info {
   struct i40e_client_version version ;
   u8 lanmac[6U] ;
   struct net_device *netdev ;
   struct pci_dev *pcidev ;
   u8 *hw_addr ;
   u8 fid ;
   u8 ftype ;
   void *pf ;
   struct i40e_qvlist_info *qvlist_info ;
   struct i40e_params params ;
   struct i40e_ops *ops ;
   u16 msix_count ;
   struct msix_entry *msix_entries ;
   u16 itr_index ;
   u16 fw_maj_ver ;
   u16 fw_min_ver ;
   u32 fw_build ;
};
#line 114  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.h"
struct i40e_ops {
   int (*setup_qvlist)(struct i40e_info *, struct i40e_client *, struct i40e_qvlist_info *) ;
   int (*virtchnl_send)(struct i40e_info *, struct i40e_client *, u32 , u8 *, u16 ) ;
   void (*request_reset)(struct i40e_info *, struct i40e_client *, u32 ) ;
   int (*update_vsi_ctxt)(struct i40e_info *, struct i40e_client *, bool , u32 , u32 , u32 ) ;
};
#line 137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.h"
struct i40e_client_ops {
   int (*open)(struct i40e_info *, struct i40e_client *) ;
   void (*close)(struct i40e_info *, struct i40e_client *, bool ) ;
   void (*l2_param_change)(struct i40e_info *, struct i40e_client *, struct i40e_params *) ;
   int (*virtchnl_receive)(struct i40e_info *, struct i40e_client *, u32 , u8 *, u16 ) ;
   void (*vf_reset)(struct i40e_info *, struct i40e_client *, u32 ) ;
   void (*vf_enable)(struct i40e_info *, struct i40e_client *, u32 ) ;
   int (*vf_capable)(struct i40e_info *, struct i40e_client *, u32 ) ;
};
#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.h"
struct i40e_client_instance {
   struct list_head list ;
   struct i40e_info lan_info ;
   struct i40e_client *client ;
   unsigned long state ;
};
#line 180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.h"
struct i40e_client {
   struct list_head list ;
   char name[10U] ;
   struct i40e_client_version version ;
   unsigned long state ;
   atomic_t ref_cnt ;
   u32 flags ;
   u8 type ;
   struct i40e_client_ops *ops ;
};
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
struct i40evf_channel {
   u16 vsi_idx ;
   u16 vsi_id ;
   u16 num_qps ;
   u64 max_tx_rate ;
};
#line 65 
struct i40e_pf;
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
struct i40e_vf {
   struct i40e_pf *pf ;
   s16 vf_id ;
   enum i40e_switch_element_types parent_type ;
   struct virtchnl_version_info vf_ver ;
   u32 driver_caps ;
   u16 stag ;
   struct virtchnl_ether_addr default_lan_addr ;
   u16 port_vlan_id ;
   bool pf_set_mac ;
   bool trusted ;
   u16 lan_vsi_idx ;
   u16 lan_vsi_id ;
   u8 num_queue_pairs ;
   u8 num_req_queues ;
   u64 num_mdd_events ;
   u64 num_invalid_msgs ;
   u64 num_valid_msgs ;
   unsigned long vf_caps ;
   unsigned long vf_states ;
   unsigned int tx_rate ;
   bool link_forced ;
   bool link_up ;
   bool queues_enabled ;
   bool spoofchk ;
   u16 num_vlan ;
   bool adq_enabled ;
   u8 num_tc ;
   struct i40evf_channel ch[4U] ;
   struct hlist_head cloud_filter_list ;
   u16 num_cloud_filters ;
   struct virtchnl_iwarp_qvlist_info *qvlist_info ;
};
#line 282  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
union __anonunion_1105 {
   struct xdp_frame *xdpf ;
   struct sk_buff *skb ;
   void *raw_buf ;
};
#line 282  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct i40e_tx_buffer {
   struct i40e_tx_desc *next_to_watch ;
   union __anonunion_1105 __anonCompField_i40e_tx_buffer_217 ;
   unsigned int bytecount ;
   unsigned short gso_segs ;
   dma_addr_t dma ;
   __u32 len ;
   u32 tx_flags ;
};
#line 297  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct __anonstruct_1107 {
   struct page *page ;
   __u32 page_offset ;
   __u16 pagecnt_bias ;
};
#line 297  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct __anonstruct_1108 {
   void *addr ;
   u64 handle ;
};
#line 297  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
union __anonunion_1106 {
   struct __anonstruct_1107 __anonCompField___anonunion_1106_218 ;
   struct __anonstruct_1108 __anonCompField___anonunion_1106_219 ;
};
#line 297  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct i40e_rx_buffer {
   dma_addr_t dma ;
   union __anonunion_1106 __anonCompField_i40e_rx_buffer_220 ;
};
#line 312  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct i40e_queue_stats {
   u64 packets ;
   u64 bytes ;
};
#line 317  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct i40e_tx_queue_stats {
   u64 restart_queue ;
   u64 tx_busy ;
   u64 tx_done_old ;
   u64 tx_linearize ;
   u64 tx_force_wb ;
   int prev_pkt_ctr ;
};
#line 326  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct i40e_rx_queue_stats {
   u64 non_eop_descs ;
   u64 alloc_page_failed ;
   u64 alloc_buff_failed ;
   u64 page_reuse_count ;
   u64 realloc_count ;
};
#line 352  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
union __anonunion_1109 {
   struct i40e_tx_buffer *tx_bi ;
   struct i40e_rx_buffer *rx_bi ;
};
#line 352  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
union __anonunion_1110 {
   struct i40e_tx_queue_stats tx_stats ;
   struct i40e_rx_queue_stats rx_stats ;
};
#line 352 
struct i40e_vsi;
#line 352 
struct i40e_q_vector;
#line 352 
struct i40e_channel;
#line 352  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct i40e_ring {
   struct i40e_ring *next ;
   void *desc ;
   struct device *dev ;
   struct net_device *netdev ;
   struct bpf_prog *xdp_prog ;
   union __anonunion_1109 __anonCompField_i40e_ring_221 ;
   unsigned long state[1U] ;
   u16 queue_index ;
   u8 dcb_tc ;
   u8 *tail ;
   u16 itr_setting ;
   u16 count ;
   u16 reg_idx ;
   u16 rx_buf_len ;
   u16 next_to_use ;
   u16 next_to_clean ;
   u8 atr_sample_rate ;
   u8 atr_count ;
   bool ring_active ;
   bool arm_wb ;
   u8 packet_stride ;
   u16 flags ;
   struct i40e_queue_stats stats ;
   struct u64_stats_sync syncp ;
   union __anonunion_1110 __anonCompField_i40e_ring_222 ;
   unsigned int size ;
   dma_addr_t dma ;
   struct i40e_vsi *vsi ;
   struct i40e_q_vector *q_vector ;
   struct callback_head rcu ;
   u16 next_to_alloc ;
   struct sk_buff *skb ;
   struct i40e_channel *ch ;
   struct xdp_rxq_info xdp_rxq ;
   struct xdp_umem *xsk_umem ;
   struct zero_copy_allocator zca ;
} __attribute__((__aligned__(4096)));
#line 457  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
struct i40e_ring_container {
   struct i40e_ring *ring ;
   unsigned long next_update ;
   unsigned int total_bytes ;
   unsigned int total_packets ;
   u16 count ;
   u16 target_itr ;
   u16 current_itr ;
};
#line 182  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.h"
enum i40e_interrupt_policy {
    I40E_INTERRUPT_BEST_CASE = 0,
    I40E_INTERRUPT_MEDIUM = 1,
    I40E_INTERRUPT_LOWEST = 2
};
#line 177  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_lump_tracking {
   u16 num_entries ;
   u16 search_hint ;
   u16 list[0U] ;
};
#line 302  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_tc_info {
   u16 qoffset ;
   u16 qcount ;
   u8 netdev_tc ;
};
#line 309  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_tc_configuration {
   u8 numtc ;
   u8 enabled_tc ;
   struct i40e_tc_info tc_info[8U] ;
};
#line 316  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_udp_port_config {
   u16 port ;
   u8 type ;
   u8 filter_index ;
};
#line 415  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_fwd_adapter {
   struct net_device *netdev ;
   int bit_no ;
};
#line 420  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_channel {
   struct list_head list ;
   bool initialized ;
   u8 type ;
   u16 vsi_number ;
   u16 stat_counter_idx ;
   u16 base_queue ;
   u16 num_queue_pairs ;
   u16 seid ;
   u8 enabled_tc ;
   struct i40e_aqc_vsi_properties_data info ;
   u64 max_tx_rate ;
   struct i40e_fwd_adapter *fwd ;
   struct i40e_vsi *parent_vsi ;
};
#line 454 
struct i40e_veb;
#line 454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_pf {
   struct pci_dev *pdev ;
   struct i40e_hw hw ;
   unsigned long state[1U] ;
   struct msix_entry *msix_entries ;
   bool fc_autoneg_status ;
   u16 eeprom_version ;
   u16 num_vmdq_vsis ;
   u16 num_vmdq_qps ;
   u16 num_vmdq_msix ;
   u16 num_req_vfs ;
   u16 num_vf_qps ;
   u16 num_lan_qps ;
   u16 num_lan_msix ;
   u16 num_fdsb_msix ;
   u16 num_iwarp_msix ;
   int iwarp_base_vector ;
   int queues_left ;
   u16 alloc_rss_size ;
   u16 rss_size_max ;
   u16 fdir_pf_filter_count ;
   u16 num_alloc_vsi ;
   u8 atr_sample_rate ;
   bool wol_en ;
   struct hlist_head fdir_filter_list ;
   u16 fdir_pf_active_filters ;
   unsigned long fd_flush_timestamp ;
   u32 fd_flush_cnt ;
   u32 fd_add_err ;
   u32 fd_atr_cnt ;
   u16 fd_tcp4_filter_cnt ;
   u16 fd_udp4_filter_cnt ;
   u16 fd_sctp4_filter_cnt ;
   u16 fd_ip4_filter_cnt ;
   struct list_head l3_flex_pit_list ;
   struct list_head l4_flex_pit_list ;
   struct i40e_udp_port_config udp_ports[16U] ;
   u16 pending_udp_bitmap ;
   struct hlist_head cloud_filter_list ;
   u16 num_cloud_filters ;
   enum i40e_interrupt_policy int_policy ;
   u16 rx_itr_default ;
   u16 tx_itr_default ;
   u32 msg_enable ;
   char int_name[32U] ;
   u16 adminq_work_limit ;
   unsigned long service_timer_period ;
   unsigned long service_timer_previous ;
   struct timer_list service_timer ;
   struct work_struct service_task ;
   u32 hw_features ;
   u32 flags ;
   struct i40e_client_instance *cinst ;
   bool stat_offsets_loaded ;
   struct i40e_hw_port_stats stats ;
   struct i40e_hw_port_stats stats_offsets ;
   u32 tx_timeout_count ;
   u32 tx_timeout_recovery_level ;
   unsigned long tx_timeout_last_recovery ;
   u32 tx_sluggish_count ;
   u32 hw_csum_rx_error ;
   u32 led_status ;
   u16 corer_count ;
   u16 globr_count ;
   u16 empr_count ;
   u16 pfr_count ;
   u16 sw_int_count ;
   struct mutex switch_mutex ;
   u16 lan_vsi ;
   u16 lan_veb ;
   u16 next_vsi ;
   struct i40e_vsi **vsi ;
   struct i40e_veb *veb[16U] ;
   struct i40e_lump_tracking *qp_pile ;
   struct i40e_lump_tracking *irq_pile ;
   u16 pf_seid ;
   u16 main_vsi_seid ;
   u16 mac_seid ;
   struct kobject *switch_kobj ;
   struct dentry *i40e_dbg_pf ;
   bool cur_promisc ;
   u16 instance ;
   struct i40e_vf *vf ;
   int num_alloc_vfs ;
   u32 vf_aq_requests ;
   u32 arq_overflows ;
   u16 dcbx_cap ;
   struct i40e_filter_control_settings filter_settings ;
   struct ptp_clock *ptp_clock ;
   struct ptp_clock_info ptp_caps ;
   struct sk_buff *ptp_tx_skb ;
   unsigned long ptp_tx_start ;
   struct hwtstamp_config tstamp_config ;
   struct timespec64 ptp_prev_hw_time ;
   ktime_t ptp_reset_start ;
   struct mutex tmreg_lock ;
   u32 ptp_adj_mult ;
   u32 tx_hwtstamp_timeouts ;
   u32 tx_hwtstamp_skipped ;
   u32 rx_hwtstamp_cleared ;
   u32 latch_event_flags ;
   spinlock_t ptp_rx_lock ;
   unsigned long latch_events[4U] ;
   bool ptp_tx ;
   bool ptp_rx ;
   u16 rss_table_size ;
   u32 max_bw ;
   u32 min_bw ;
   u32 ioremap_len ;
   u32 fd_inv ;
   u16 phy_led_val ;
   u16 override_q_count ;
   u16 last_sw_conf_flags ;
   u16 last_sw_conf_valid_flags ;
   struct list_head ddp_old_prof ;
};
#line 706  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_veb {
   struct i40e_pf *pf ;
   u16 idx ;
   u16 veb_idx ;
   u16 seid ;
   u16 uplink_seid ;
   u16 stats_idx ;
   u8 enabled_tc ;
   u16 bridge_mode ;
   u16 flags ;
   u16 bw_limit ;
   u8 bw_max_quanta ;
   bool is_abs_credits ;
   u8 bw_tc_share_credits[8U] ;
   u16 bw_tc_limit_credits[8U] ;
   u8 bw_tc_max_quanta[8U] ;
   struct kobject *kobj ;
   bool stat_offsets_loaded ;
   struct i40e_eth_stats stats ;
   struct i40e_eth_stats stats_offsets ;
   struct i40e_veb_tc_stats tc_stats ;
   struct i40e_veb_tc_stats tc_stats_offsets ;
};
#line 731  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_vsi {
   struct net_device *netdev ;
   unsigned long active_vlans[64U] ;
   bool netdev_registered ;
   bool stat_offsets_loaded ;
   u32 current_netdev_flags ;
   unsigned long state[1U] ;
   unsigned long flags ;
   spinlock_t mac_filter_hash_lock ;
   struct hlist_head mac_filter_hash[256U] ;
   bool has_vlan_filter ;
   struct rtnl_link_stats64 net_stats ;
   struct rtnl_link_stats64 net_stats_offsets ;
   struct i40e_eth_stats eth_stats ;
   struct i40e_eth_stats eth_stats_offsets ;
   u32 tx_restart ;
   u32 tx_busy ;
   u64 tx_linearize ;
   u64 tx_force_wb ;
   u32 rx_buf_failed ;
   u32 rx_page_failed ;
   struct i40e_ring **rx_rings ;
   struct i40e_ring **tx_rings ;
   struct i40e_ring **xdp_rings ;
   u32 active_filters ;
   u32 promisc_threshold ;
   u16 work_limit ;
   u16 int_rate_limit ;
   u16 rss_table_size ;
   u16 rss_size ;
   u8 *rss_hkey_user ;
   u8 *rss_lut_user ;
   u16 max_frame ;
   u16 rx_buf_len ;
   struct bpf_prog *xdp_prog ;
   struct i40e_q_vector **q_vectors ;
   int num_q_vectors ;
   int base_vector ;
   bool irqs_ready ;
   u16 seid ;
   u16 id ;
   u16 uplink_seid ;
   u16 base_queue ;
   u16 alloc_queue_pairs ;
   u16 req_queue_pairs ;
   u16 num_queue_pairs ;
   u16 num_tx_desc ;
   u16 num_rx_desc ;
   enum i40e_vsi_type type ;
   s16 vf_id ;
   struct tc_mqprio_qopt_offload mqprio_qopt ;
   struct i40e_tc_configuration tc_config ;
   struct i40e_aqc_vsi_properties_data info ;
   u16 bw_limit ;
   u8 bw_max_quanta ;
   u8 bw_ets_share_credits[8U] ;
   u16 bw_ets_limit_credits[8U] ;
   u8 bw_ets_max_quanta[8U] ;
   struct i40e_pf *back ;
   u16 idx ;
   u16 veb_idx ;
   struct kobject *kobj ;
   bool current_isup ;
   enum i40e_aq_link_speed current_speed ;
   u16 cnt_q_avail ;
   u16 orig_rss_size ;
   u16 current_rss_size ;
   bool reconfig_rss ;
   u16 next_base_queue ;
   struct list_head ch_list ;
   u16 tc_seid_map[8U] ;
   unsigned long fwd_bitmask[2U] ;
   struct list_head macvlan_list ;
   int macvlan_cnt ;
   void *priv ;
   irqreturn_t (*irq_handler)(int , void *) ;
   unsigned long *af_xdp_zc_qps ;
} __attribute__((__aligned__(4096)));
#line 855  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_q_vector {
   struct i40e_vsi *vsi ;
   u16 v_idx ;
   u16 reg_idx ;
   struct napi_struct napi ;
   struct i40e_ring_container rx ;
   struct i40e_ring_container tx ;
   u8 itr_countdown ;
   u8 num_ringpairs ;
   cpumask_t affinity_mask ;
   struct irq_affinity_notify affinity_notify ;
   struct callback_head rcu ;
   char name[32U] ;
   bool arm_wb_state ;
} __attribute__((__aligned__(4096)));
#line 130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
union __anonunion___u_1117 {
   u32 __val ;
   char __c[1U] ;
};
#line 503  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
union __anonunion___u_1119 {
   u32 __val ;
   char __c[1U] ;
};
#line 762  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_1140 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 788  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_1142 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/in.h"
struct in_addr {
   __be32 s_addr ;
};
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
struct i40e_hmc_obj_rxq {
   u16 head ;
   u16 cpuid ;
   u64 base ;
   u16 qlen ;
   u16 dbuff ;
   u16 hbuff ;
   u8 dtype ;
   u8 dsize ;
   u8 crcstrip ;
   u8 fc_ena ;
   u8 l2tsel ;
   u8 hsplit_0 ;
   u8 hsplit_1 ;
   u8 showiv ;
   u32 rxmax ;
   u8 tphrdesc_ena ;
   u8 tphwdesc_ena ;
   u8 tphdata_ena ;
   u8 tphhead_ena ;
   u16 lrxqthresh ;
   u8 prefena ;
};
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
struct i40e_hmc_obj_txq {
   u16 head ;
   u8 new_context ;
   u64 base ;
   u8 fc_ena ;
   u8 timesync_ena ;
   u8 fd_ena ;
   u8 alt_vlan_ena ;
   u16 thead_wb ;
   u8 cpuid ;
   u8 head_wb_ena ;
   u16 qlen ;
   u8 tphrdesc_ena ;
   u8 tphrpacket_ena ;
   u8 tphwdesc_ena ;
   u64 head_wb_addr ;
   u32 crc ;
   u16 rdylist ;
   u8 rdylist_act ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
enum i40e_queue_type {
    I40E_QUEUE_TYPE_RX = 0,
    I40E_QUEUE_TYPE_TX = 1,
    I40E_QUEUE_TYPE_PE_CEQ = 2,
    I40E_QUEUE_TYPE_UNKNOWN = 3
};
#line 1204  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_vsi_context {
   u16 seid ;
   u16 uplink_seid ;
   u16 vsi_number ;
   u16 vsis_allocated ;
   u16 vsis_unallocated ;
   u16 flags ;
   u8 pf_num ;
   u8 vf_num ;
   u8 connection_type ;
   struct i40e_aqc_vsi_properties_data info ;
};
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_alloc.h"
enum virtchnl_link_speed {
    VIRTCHNL_LINK_SPEED_UNKNOWN = 0,
    VIRTCHNL_LINK_SPEED_100MB = 2,
    VIRTCHNL_LINK_SPEED_1GB = 4,
    VIRTCHNL_LINK_SPEED_10GB = 8,
    VIRTCHNL_LINK_SPEED_40GB = 16,
    VIRTCHNL_LINK_SPEED_20GB = 32,
    VIRTCHNL_LINK_SPEED_25GB = 64,
    VIRTCHNL_LINK_SPEED_2_5GB = 1,
    VIRTCHNL_LINK_SPEED_5GB = 128
};
#line 56 
enum virtchnl_rx_hsplit {
    VIRTCHNL_RX_HSPLIT_NO_SPLIT = 0,
    VIRTCHNL_RX_HSPLIT_SPLIT_L2 = 1,
    VIRTCHNL_RX_HSPLIT_SPLIT_IP = 2,
    VIRTCHNL_RX_HSPLIT_SPLIT_TCP_UDP = 4,
    VIRTCHNL_RX_HSPLIT_SPLIT_SCTP = 8
};
#line 64 
enum virtchnl_ops {
    VIRTCHNL_OP_UNKNOWN = 0,
    VIRTCHNL_OP_VERSION = 1,
    VIRTCHNL_OP_RESET_VF = 2,
    VIRTCHNL_OP_GET_VF_RESOURCES = 3,
    VIRTCHNL_OP_CONFIG_TX_QUEUE = 4,
    VIRTCHNL_OP_CONFIG_RX_QUEUE = 5,
    VIRTCHNL_OP_CONFIG_VSI_QUEUES = 6,
    VIRTCHNL_OP_CONFIG_IRQ_MAP = 7,
    VIRTCHNL_OP_ENABLE_QUEUES = 8,
    VIRTCHNL_OP_DISABLE_QUEUES = 9,
    VIRTCHNL_OP_ADD_ETH_ADDR = 10,
    VIRTCHNL_OP_DEL_ETH_ADDR = 11,
    VIRTCHNL_OP_ADD_VLAN = 12,
    VIRTCHNL_OP_DEL_VLAN = 13,
    VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE = 14,
    VIRTCHNL_OP_GET_STATS = 15,
    VIRTCHNL_OP_RSVD = 16,
    VIRTCHNL_OP_EVENT = 17,
    VIRTCHNL_OP_IWARP = 20,
    VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP = 21,
    VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP = 22,
    VIRTCHNL_OP_CONFIG_RSS_KEY = 23,
    VIRTCHNL_OP_CONFIG_RSS_LUT = 24,
    VIRTCHNL_OP_GET_RSS_HENA_CAPS = 25,
    VIRTCHNL_OP_SET_RSS_HENA = 26,
    VIRTCHNL_OP_ENABLE_VLAN_STRIPPING = 27,
    VIRTCHNL_OP_DISABLE_VLAN_STRIPPING = 28,
    VIRTCHNL_OP_REQUEST_QUEUES = 29,
    VIRTCHNL_OP_ENABLE_CHANNELS = 30,
    VIRTCHNL_OP_DISABLE_CHANNELS = 31,
    VIRTCHNL_OP_ADD_CLOUD_FILTER = 32,
    VIRTCHNL_OP_DEL_CLOUD_FILTER = 33
};
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
enum virtchnl_vsi_type {
    VIRTCHNL_VSI_TYPE_INVALID = 0,
    VIRTCHNL_VSI_SRIOV = 6
};
#line 221  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_vsi_resource {
   u16 vsi_id ;
   u16 num_queue_pairs ;
   enum virtchnl_vsi_type vsi_type ;
   u16 qset_handle ;
   u8 default_mac_addr[6U] ;
};
#line 257  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_vf_resource {
   u16 num_vsis ;
   u16 num_queue_pairs ;
   u16 max_vectors ;
   u16 max_mtu ;
   u32 vf_cap_flags ;
   u32 rss_key_size ;
   u32 rss_lut_size ;
   struct virtchnl_vsi_resource vsi_res[1U] ;
};
#line 279  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_txq_info {
   u16 vsi_id ;
   u16 queue_id ;
   u16 ring_len ;
   u16 headwb_enabled ;
   u64 dma_ring_addr ;
   u64 dma_headwb_addr ;
};
#line 297  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_rxq_info {
   u16 vsi_id ;
   u16 queue_id ;
   u32 ring_len ;
   u16 hdr_size ;
   u16 splithdr_enabled ;
   u32 databuffer_size ;
   u32 max_pkt_size ;
   u32 pad1 ;
   u64 dma_ring_addr ;
   enum virtchnl_rx_hsplit rx_split_pos ;
   u32 pad2 ;
};
#line 320  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_queue_pair_info {
   struct virtchnl_txq_info txq ;
   struct virtchnl_rxq_info rxq ;
};
#line 328  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_vsi_queue_config_info {
   u16 vsi_id ;
   u16 num_queue_pairs ;
   u32 pad ;
   struct virtchnl_queue_pair_info qpair[1U] ;
};
#line 348  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_vf_res_request {
   u16 num_queue_pairs ;
};
#line 359  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_vector_map {
   u16 vsi_id ;
   u16 vector_id ;
   u16 rxq_map ;
   u16 txq_map ;
   u16 rxitr_idx ;
   u16 txitr_idx ;
};
#line 370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_irq_map_info {
   u16 num_vectors ;
   struct virtchnl_vector_map vecmap[1U] ;
};
#line 385  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_queue_select {
   u16 vsi_id ;
   u16 pad ;
   u32 rx_queues ;
   u32 tx_queues ;
};
#line 413  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_ether_addr_list {
   u16 vsi_id ;
   u16 num_elements ;
   struct virtchnl_ether_addr list[1U] ;
};
#line 435  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_vlan_filter_list {
   u16 vsi_id ;
   u16 num_elements ;
   u16 vlan_id[1U] ;
};
#line 448  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_promisc_info {
   u16 vsi_id ;
   u16 flags ;
};
#line 475  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_rss_key {
   u16 vsi_id ;
   u16 key_len ;
   u8 key[1U] ;
};
#line 483  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_rss_lut {
   u16 vsi_id ;
   u16 lut_entries ;
   u8 lut[1U] ;
};
#line 498  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_rss_hena {
   u64 hena ;
};
#line 511  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_channel_info {
   u16 count ;
   u16 offset ;
   u32 pad ;
   u64 max_tx_rate ;
};
#line 520  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_tc_info {
   u32 num_tc ;
   u32 pad ;
   struct virtchnl_channel_info list[1U] ;
};
#line 536  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_l4_spec {
   u8 src_mac[6U] ;
   u8 dst_mac[6U] ;
   __be16 vlan_id ;
   __be16 pad ;
   __be32 src_ip[4U] ;
   __be32 dst_ip[4U] ;
   __be16 src_port ;
   __be16 dst_port ;
};
#line 549  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
union virtchnl_flow_spec {
   struct virtchnl_l4_spec tcp_spec ;
   u8 buffer[128U] ;
};
#line 557 
enum virtchnl_action {
    VIRTCHNL_ACTION_DROP = 0,
    VIRTCHNL_ACTION_TC_REDIRECT = 1
};
#line 562 
enum virtchnl_flow_type {
    VIRTCHNL_TCP_V4_FLOW = 0,
    VIRTCHNL_TCP_V6_FLOW = 1
};
#line 568  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_filter {
   union virtchnl_flow_spec data ;
   union virtchnl_flow_spec mask ;
   enum virtchnl_flow_type flow_type ;
   enum virtchnl_action action ;
   u32 action_meta ;
   u8 field_flags ;
};
#line 580 
enum virtchnl_event_codes {
    VIRTCHNL_EVENT_UNKNOWN = 0,
    VIRTCHNL_EVENT_LINK_CHANGE = 1,
    VIRTCHNL_EVENT_RESET_IMPENDING = 2,
    VIRTCHNL_EVENT_PF_DRIVER_CLOSE = 3
};
#line 594  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct __anonstruct_link_event_2222 {
   enum virtchnl_link_speed link_speed ;
   bool link_status ;
};
#line 594  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct __anonstruct_link_event_adv_2223 {
   u32 link_speed ;
   u8 link_status ;
};
#line 594  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
union __anonunion_event_data_2221 {
   struct __anonstruct_link_event_2222 link_event ;
   struct __anonstruct_link_event_adv_2223 link_event_adv ;
};
#line 594  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
struct virtchnl_pf_event {
   enum virtchnl_event_codes event ;
   union __anonunion_event_data_2221 event_data ;
   int severity ;
};
#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct __anonstruct_v4_2231 {
   struct in_addr dst_ip ;
   struct in_addr src_ip ;
};
#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct __anonstruct_v6_2232 {
   struct in6_addr dst_ip6 ;
   struct in6_addr src_ip6 ;
};
#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
union __anonunion_ip_2230 {
   struct __anonstruct_v4_2231 v4 ;
   struct __anonstruct_v6_2232 v6 ;
};
#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_cloud_filter {
   struct hlist_node cloud_node ;
   unsigned long cookie ;
   u8 dst_mac[6U] ;
   u8 src_mac[6U] ;
   __be16 vlan_id ;
   u16 seid ;
   __be16 dst_port ;
   __be16 src_port ;
   u32 tenant_id ;
   union __anonunion_ip_2230 ip ;
   u16 n_proto ;
   u8 ip_proto ;
   u8 flags ;
   u8 tunnel_type ;
};
#line 673 
enum i40e_filter_state {
    I40E_FILTER_INVALID = 0,
    I40E_FILTER_NEW = 1,
    I40E_FILTER_ACTIVE = 2,
    I40E_FILTER_FAILED = 3,
    I40E_FILTER_REMOVE = 4
};
#line 682  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_mac_filter {
   struct hlist_node hlist ;
   u8 macaddr[6U] ;
   s16 vlan ;
   enum i40e_filter_state state ;
};
#line 850  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_netdev_priv {
   struct i40e_vsi *vsi ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
enum i40e_admin_queue_opc {
    i40e_aqc_opc_get_version = 1,
    i40e_aqc_opc_driver_version = 2,
    i40e_aqc_opc_queue_shutdown = 3,
    i40e_aqc_opc_set_pf_context = 4,
    i40e_aqc_opc_request_resource = 8,
    i40e_aqc_opc_release_resource = 9,
    i40e_aqc_opc_list_func_capabilities = 10,
    i40e_aqc_opc_list_dev_capabilities = 11,
    i40e_aqc_opc_set_proxy_config = 260,
    i40e_aqc_opc_set_ns_proxy_table_entry = 261,
    i40e_aqc_opc_mac_address_read = 263,
    i40e_aqc_opc_mac_address_write = 264,
    i40e_aqc_opc_clear_pxe_mode = 272,
    i40e_aqc_opc_set_wol_filter = 288,
    i40e_aqc_opc_get_wake_reason = 289,
    i40e_aqc_opc_get_switch_config = 512,
    i40e_aqc_opc_add_statistics = 513,
    i40e_aqc_opc_remove_statistics = 514,
    i40e_aqc_opc_set_port_parameters = 515,
    i40e_aqc_opc_get_switch_resource_alloc = 516,
    i40e_aqc_opc_set_switch_config = 517,
    i40e_aqc_opc_rx_ctl_reg_read = 518,
    i40e_aqc_opc_rx_ctl_reg_write = 519,
    i40e_aqc_opc_add_vsi = 528,
    i40e_aqc_opc_update_vsi_parameters = 529,
    i40e_aqc_opc_get_vsi_parameters = 530,
    i40e_aqc_opc_add_pv = 544,
    i40e_aqc_opc_update_pv_parameters = 545,
    i40e_aqc_opc_get_pv_parameters = 546,
    i40e_aqc_opc_add_veb = 560,
    i40e_aqc_opc_update_veb_parameters = 561,
    i40e_aqc_opc_get_veb_parameters = 562,
    i40e_aqc_opc_delete_element = 579,
    i40e_aqc_opc_add_macvlan = 592,
    i40e_aqc_opc_remove_macvlan = 593,
    i40e_aqc_opc_add_vlan = 594,
    i40e_aqc_opc_remove_vlan = 595,
    i40e_aqc_opc_set_vsi_promiscuous_modes = 596,
    i40e_aqc_opc_add_tag = 597,
    i40e_aqc_opc_remove_tag = 598,
    i40e_aqc_opc_add_multicast_etag = 599,
    i40e_aqc_opc_remove_multicast_etag = 600,
    i40e_aqc_opc_update_tag = 601,
    i40e_aqc_opc_add_control_packet_filter = 602,
    i40e_aqc_opc_remove_control_packet_filter = 603,
    i40e_aqc_opc_add_cloud_filters = 604,
    i40e_aqc_opc_remove_cloud_filters = 605,
    i40e_aqc_opc_clear_wol_switch_filters = 606,
    i40e_aqc_opc_add_mirror_rule = 608,
    i40e_aqc_opc_delete_mirror_rule = 609,
    i40e_aqc_opc_write_personalization_profile = 624,
    i40e_aqc_opc_get_personalization_profile_list = 625,
    i40e_aqc_opc_dcb_ignore_pfc = 769,
    i40e_aqc_opc_dcb_updated = 770,
    i40e_aqc_opc_set_dcb_parameters = 771,
    i40e_aqc_opc_configure_vsi_bw_limit = 1024,
    i40e_aqc_opc_configure_vsi_ets_sla_bw_limit = 1030,
    i40e_aqc_opc_configure_vsi_tc_bw = 1031,
    i40e_aqc_opc_query_vsi_bw_config = 1032,
    i40e_aqc_opc_query_vsi_ets_sla_config = 1034,
    i40e_aqc_opc_configure_switching_comp_bw_limit = 1040,
    i40e_aqc_opc_enable_switching_comp_ets = 1043,
    i40e_aqc_opc_modify_switching_comp_ets = 1044,
    i40e_aqc_opc_disable_switching_comp_ets = 1045,
    i40e_aqc_opc_configure_switching_comp_ets_bw_limit = 1046,
    i40e_aqc_opc_configure_switching_comp_bw_config = 1047,
    i40e_aqc_opc_query_switching_comp_ets_config = 1048,
    i40e_aqc_opc_query_port_ets_config = 1049,
    i40e_aqc_opc_query_switching_comp_bw_config = 1050,
    i40e_aqc_opc_suspend_port_tx = 1051,
    i40e_aqc_opc_resume_port_tx = 1052,
    i40e_aqc_opc_configure_partition_bw = 1053,
    i40e_aqc_opc_query_hmc_resource_profile = 1280,
    i40e_aqc_opc_set_hmc_resource_profile = 1281,
    i40e_aqc_opc_get_phy_abilities = 1536,
    i40e_aqc_opc_set_phy_config = 1537,
    i40e_aqc_opc_set_mac_config = 1539,
    i40e_aqc_opc_set_link_restart_an = 1541,
    i40e_aqc_opc_get_link_status = 1543,
    i40e_aqc_opc_set_phy_int_mask = 1555,
    i40e_aqc_opc_get_local_advt_reg = 1556,
    i40e_aqc_opc_set_local_advt_reg = 1557,
    i40e_aqc_opc_get_partner_advt = 1558,
    i40e_aqc_opc_set_lb_modes = 1560,
    i40e_aqc_opc_get_phy_wol_caps = 1569,
    i40e_aqc_opc_set_phy_debug = 1570,
    i40e_aqc_opc_upload_ext_phy_fm = 1573,
    i40e_aqc_opc_run_phy_activity = 1574,
    i40e_aqc_opc_set_phy_register = 1576,
    i40e_aqc_opc_get_phy_register = 1577,
    i40e_aqc_opc_nvm_read = 1793,
    i40e_aqc_opc_nvm_erase = 1794,
    i40e_aqc_opc_nvm_update = 1795,
    i40e_aqc_opc_nvm_config_read = 1796,
    i40e_aqc_opc_nvm_config_write = 1797,
    i40e_aqc_opc_oem_post_update = 1824,
    i40e_aqc_opc_thermal_sensor = 1825,
    i40e_aqc_opc_send_msg_to_pf = 2049,
    i40e_aqc_opc_send_msg_to_vf = 2050,
    i40e_aqc_opc_send_msg_to_peer = 2051,
    i40e_aqc_opc_alternate_write = 2304,
    i40e_aqc_opc_alternate_write_indirect = 2305,
    i40e_aqc_opc_alternate_read = 2306,
    i40e_aqc_opc_alternate_read_indirect = 2307,
    i40e_aqc_opc_alternate_write_done = 2308,
    i40e_aqc_opc_alternate_set_mode = 2309,
    i40e_aqc_opc_alternate_clear_port = 2310,
    i40e_aqc_opc_lldp_get_mib = 2560,
    i40e_aqc_opc_lldp_update_mib = 2561,
    i40e_aqc_opc_lldp_add_tlv = 2562,
    i40e_aqc_opc_lldp_update_tlv = 2563,
    i40e_aqc_opc_lldp_delete_tlv = 2564,
    i40e_aqc_opc_lldp_stop = 2565,
    i40e_aqc_opc_lldp_start = 2566,
    i40e_aqc_opc_get_cee_dcb_cfg = 2567,
    i40e_aqc_opc_lldp_set_local_mib = 2568,
    i40e_aqc_opc_lldp_stop_start_spec_agent = 2569,
    i40e_aqc_opc_lldp_restore = 2570,
    i40e_aqc_opc_add_udp_tunnel = 2816,
    i40e_aqc_opc_del_udp_tunnel = 2817,
    i40e_aqc_opc_set_rss_key = 2818,
    i40e_aqc_opc_set_rss_lut = 2819,
    i40e_aqc_opc_get_rss_key = 2820,
    i40e_aqc_opc_get_rss_lut = 2821,
    i40e_aqc_opc_event_lan_overflow = 4097,
    i40e_aqc_opc_oem_parameter_change = 65024,
    i40e_aqc_opc_oem_device_status_change = 65025,
    i40e_aqc_opc_oem_ocsd_initialize = 65026,
    i40e_aqc_opc_oem_ocbb_initialize = 65027,
    i40e_aqc_opc_debug_read_reg = 65283,
    i40e_aqc_opc_debug_write_reg = 65284,
    i40e_aqc_opc_debug_modify_reg = 65287,
    i40e_aqc_opc_debug_dump_internals = 65288
};
#line 321  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_version {
   __le32 rom_ver ;
   __le32 fw_build ;
   __le16 fw_major ;
   __le16 fw_minor ;
   __le16 api_major ;
   __le16 api_minor ;
};
#line 333  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_driver_version {
   u8 driver_major_ver ;
   u8 driver_minor_ver ;
   u8 driver_build_ver ;
   u8 driver_subbuild_ver ;
   u8 reserved[4U] ;
   __le32 address_high ;
   __le32 address_low ;
};
#line 346  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_queue_shutdown {
   __le32 driver_unloading ;
   u8 reserved[12U] ;
};
#line 372  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_request_resource {
   __le16 resource_id ;
   __le16 access_type ;
   __le32 timeout ;
   __le32 resource_number ;
   u8 reserved[4U] ;
};
#line 385  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_list_capabilites {
   u8 command_flags ;
   u8 pf_index ;
   u8 reserved[2U] ;
   __le32 count ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 397  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_list_capabilities_element_resp {
   __le16 id ;
   u8 major_rev ;
   u8 minor_rev ;
   __le32 number ;
   __le32 logical_id ;
   __le32 phys_id ;
   u8 reserved[16U] ;
};
#line 520  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_mac_address_read {
   __le16 command_flags ;
   u8 reserved[6U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 535  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_mac_address_read_data {
   u8 pf_lan_mac[6U] ;
   u8 pf_san_mac[6U] ;
   u8 port_mac[6U] ;
   u8 pf_wol_mac[6U] ;
};
#line 545  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_mac_address_write {
   __le16 command_flags ;
   __le16 mac_sah ;
   __le32 mac_sal ;
   u8 reserved[8U] ;
};
#line 565  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_clear_pxe {
   u8 rx_cnt ;
   u8 reserved[15U] ;
};
#line 627  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_switch_seid {
   __le16 seid ;
   u8 reserved[6U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 639  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_switch_config_header_resp {
   __le16 num_reported ;
   __le16 num_total ;
   u8 reserved[12U] ;
};
#line 647  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_switch_config_element_resp {
   u8 element_type ;
   u8 revision ;
   __le16 seid ;
   __le16 uplink_seid ;
   __le16 downlink_seid ;
   u8 reserved[3U] ;
   u8 connection_type ;
   __le16 scheduler_id ;
   __le16 element_info ;
};
#line 678  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_switch_config_resp {
   struct i40e_aqc_get_switch_config_header_resp header ;
   struct i40e_aqc_switch_config_element_resp element[1U] ;
};
#line 755  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_set_switch_config {
   __le16 flags ;
   __le16 valid_flags ;
   __le16 switch_tag ;
   __le16 first_tag ;
   __le16 second_tag ;
   u8 mode ;
   u8 rsvd5[5U] ;
};
#line 814  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_rx_ctl_reg_read_write {
   __le32 reserved1 ;
   __le32 address ;
   __le32 reserved2 ;
   __le32 value ;
};
#line 833  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_get_update_vsi {
   __le16 uplink_seid ;
   u8 connection_type ;
   u8 reserved1 ;
   u8 vf_id ;
   u8 reserved2 ;
   __le16 vsi_flags ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 856  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_get_update_vsi_completion {
   __le16 seid ;
   __le16 vsi_number ;
   __le16 vsi_used ;
   __le16 vsi_free ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 1039  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_veb {
   __le16 uplink_seid ;
   __le16 downlink_seid ;
   __le16 veb_flags ;
   u8 enable_tcs ;
   u8 reserved[9U] ;
};
#line 1057  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_veb_completion {
   u8 reserved[6U] ;
   __le16 switch_seid ;
   __le16 veb_seid ;
   __le16 statistic_index ;
   __le16 vebs_used ;
   __le16 vebs_free ;
};
#line 1076  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_veb_parameters_completion {
   __le16 seid ;
   __le16 switch_id ;
   __le16 veb_flags ;
   __le16 statistic_index ;
   __le16 vebs_used ;
   __le16 vebs_free ;
   u8 reserved[4U] ;
};
#line 1095  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_macvlan {
   __le16 num_addresses ;
   __le16 seid[3U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 1109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_macvlan_element_data {
   u8 mac_addr[6U] ;
   __le16 vlan_tag ;
   __le16 flags ;
   __le16 queue_number ;
   u8 match_method ;
   u8 reserved1[3U] ;
};
#line 1146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_remove_macvlan_element_data {
   u8 mac_addr[6U] ;
   __le16 vlan_tag ;
   u8 flags ;
   u8 reserved[3U] ;
   u8 error_code ;
   u8 reply_reserved[3U] ;
};
#line 1205  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_set_vsi_promiscuous_modes {
   __le16 promiscuous_flags ;
   __le16 valid_flags ;
   __le16 seid ;
   __le16 vlan_tag ;
   u8 reserved[8U] ;
};
#line 1316  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_remove_control_packet_filter {
   u8 mac[6U] ;
   __le16 etype ;
   __le16 flags ;
   __le16 seid ;
   __le16 queue ;
   u8 reserved[2U] ;
};
#line 1335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_remove_control_packet_filter_completion {
   __le16 mac_etype_used ;
   __le16 etype_used ;
   __le16 mac_etype_free ;
   __le16 etype_free ;
   u8 reserved[8U] ;
};
#line 1350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_remove_cloud_filters {
   u8 num_filters ;
   u8 reserved ;
   __le16 seid ;
   u8 big_buffer_flag ;
   u8 reserved2[3U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 1366  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct __anonstruct_v4_3322 {
   u8 reserved[12U] ;
   u8 data[4U] ;
};
#line 1366  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct __anonstruct_v6_3323 {
   u8 data[16U] ;
};
#line 1366  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct __anonstruct_raw_v6_3324 {
   __le16 data[8U] ;
};
#line 1366  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
union __anonunion_ipaddr_3321 {
   struct __anonstruct_v4_3322 v4 ;
   struct __anonstruct_v6_3323 v6 ;
   struct __anonstruct_raw_v6_3324 raw_v6 ;
};
#line 1366  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_cloud_filters_element_data {
   u8 outer_mac[6U] ;
   u8 inner_mac[6U] ;
   __le16 inner_vlan ;
   union __anonunion_ipaddr_3321 ipaddr ;
   __le16 flags ;
   __le32 tenant_id ;
   u8 reserved[4U] ;
   __le16 queue_number ;
   u8 reserved2[14U] ;
   u8 allocation_result ;
   u8 response_reserved[7U] ;
};
#line 1445  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_cloud_filters_element_bb {
   struct i40e_aqc_cloud_filters_element_data element ;
   u16 general_fields[32U] ;
};
#line 1553  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_delete_mirror_rule {
   __le16 seid ;
   __le16 rule_type ;
   __le16 num_entries ;
   __le16 destination ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 1572  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_delete_mirror_rule_completion {
   u8 reserved[2U] ;
   __le16 rule_id ;
   __le16 mirror_rules_used ;
   __le16 mirror_rules_free ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 1584  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_write_personalization_profile {
   u8 flags ;
   u8 reserved[3U] ;
   __le32 profile_track_id ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 1594  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_write_ddp_resp {
   __le32 error_offset ;
   __le32 error_info ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 1601  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_applied_profiles {
   u8 flags ;
   u8 rsv[3U] ;
   __le32 reserved ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 1637  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_tx_sched_ind {
   __le16 vsi_seid ;
   u8 reserved[6U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 1652  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_configure_vsi_bw_limit {
   __le16 vsi_seid ;
   u8 reserved[2U] ;
   __le16 credit ;
   u8 reserved1[2U] ;
   u8 max_credit ;
   u8 reserved2[7U] ;
};
#line 1681  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_configure_vsi_tc_bw_data {
   u8 tc_valid_bits ;
   u8 reserved[3U] ;
   u8 tc_bw_credits[8U] ;
   u8 reserved1[4U] ;
   __le16 qs_handles[8U] ;
};
#line 1692  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_query_vsi_bw_config_resp {
   u8 tc_valid_bits ;
   u8 tc_suspended_bits ;
   u8 reserved[14U] ;
   __le16 qs_handles[8U] ;
   u8 reserved1[4U] ;
   __le16 port_bw_limit ;
   u8 reserved2[2U] ;
   u8 max_bw ;
   u8 reserved3[23U] ;
};
#line 1707  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_query_vsi_ets_sla_config_resp {
   u8 tc_valid_bits ;
   u8 reserved[3U] ;
   u8 share_credits[8U] ;
   __le16 credits[8U] ;
   __le16 tc_bw_max[2U] ;
};
#line 1735  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_configure_switching_comp_ets_data {
   u8 reserved[4U] ;
   u8 tc_valid_bits ;
   u8 seepage ;
   u8 tc_strict_priority_flags ;
   u8 reserved1[17U] ;
   u8 tc_bw_share_credits[8U] ;
   u8 reserved2[96U] ;
};
#line 1765  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_configure_switching_comp_bw_config_data {
   u8 tc_valid_bits ;
   u8 reserved[2U] ;
   u8 absolute_credits ;
   u8 tc_bw_share_credits[8U] ;
   u8 reserved1[20U] ;
};
#line 1776  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_query_switching_comp_ets_config_resp {
   u8 tc_valid_bits ;
   u8 reserved[35U] ;
   __le16 port_bw_limit ;
   u8 reserved1[2U] ;
   u8 tc_bw_max ;
   u8 reserved2[23U] ;
};
#line 1788  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_query_port_ets_config_resp {
   u8 reserved[4U] ;
   u8 tc_valid_bits ;
   u8 reserved1 ;
   u8 tc_strict_priority_bits ;
   u8 reserved2 ;
   u8 tc_bw_share_credits[8U] ;
   __le16 tc_bw_limits[8U] ;
   __le16 tc_bw_max[2U] ;
   u8 reserved3[32U] ;
};
#line 1807  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_query_switching_comp_bw_config_resp {
   u8 tc_valid_bits ;
   u8 reserved[2U] ;
   u8 absolute_credits_enable ;
   u8 tc_bw_share_credits[8U] ;
   __le16 tc_bw_limits[8U] ;
   __le16 tc_bw_max[2U] ;
};
#line 1827  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_configure_partition_bw_data {
   __le16 pf_valid_bits ;
   u8 min_bw[16U] ;
   u8 max_bw[16U] ;
};
#line 1964  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_module_desc {
   u8 oui[3U] ;
   u8 reserved1 ;
   u8 part_number[16U] ;
   u8 revision[4U] ;
   u8 reserved2[8U] ;
};
#line 1974  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aq_get_phy_abilities_resp {
   __le32 phy_type ;
   u8 link_speed ;
   u8 abilities ;
   __le16 eee_capability ;
   __le32 eeer_val ;
   u8 d3_lpan ;
   u8 phy_type_ext ;
   u8 fec_cfg_curr_mod_ext_info ;
   u8 ext_comp_code ;
   u8 phy_id[4U] ;
   u8 module_type[3U] ;
   u8 qualified_module_count ;
   struct i40e_aqc_module_desc qualified_module[16U] ;
};
#line 2026  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aq_set_phy_config {
   __le32 phy_type ;
   u8 link_speed ;
   u8 abilities ;
   __le16 eee_capability ;
   __le32 eeer ;
   u8 low_power_ctrl ;
   u8 phy_type_ext ;
   u8 fec_config ;
   u8 reserved ;
};
#line 2083  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_set_link_restart_an {
   u8 command ;
   u8 reserved[15U] ;
};
#line 2093  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct __anonstruct_3326 {
   u8 power_desc ;
   u8 reserved[4U] ;
};
#line 2093  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct __anonstruct_3327 {
   u8 link_type[4U] ;
   u8 link_type_ext ;
};
#line 2093  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
union __anonunion_3325 {
   struct __anonstruct_3326 __anonCompField___anonunion_3325_214 ;
   struct __anonstruct_3327 __anonCompField___anonunion_3325_215 ;
};
#line 2093  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_link_status {
   __le16 command_flags ;
   u8 phy_type ;
   u8 link_speed ;
   u8 link_info ;
   u8 an_info ;
   u8 ext_info ;
   u8 loopback ;
   __le16 max_frame_size ;
   u8 config ;
   union __anonunion_3325 __anonCompField_i40e_aqc_get_link_status_216 ;
};
#line 2169  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_set_phy_int_mask {
   u8 reserved[8U] ;
   __le16 event_mask ;
   u8 reserved1[6U] ;
};
#line 2210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_set_phy_debug {
   u8 command_flags ;
   u8 reserved[15U] ;
};
#line 2248  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_phy_register_access {
   u8 phy_interface ;
   u8 dev_address ;
   u8 cmd_flags ;
   u8 reserved1 ;
   __le32 reg_address ;
   __le32 reg_value ;
   u8 reserved2[4U] ;
};
#line 2272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_nvm_update {
   u8 command_flags ;
   u8 module_pointer ;
   __le16 length ;
   __le32 offset ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 2383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_pf_vf_message {
   __le32 id ;
   u8 reserved[4U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 2397  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_alternate_write {
   __le32 address0 ;
   __le32 data0 ;
   __le32 address1 ;
   __le32 data1 ;
};
#line 2457  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_lldp_get_mib {
   u8 type ;
   u8 reserved1 ;
   __le16 local_len ;
   __le16 remote_len ;
   u8 reserved2[2U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 2483  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_lldp_update_mib {
   u8 command ;
   u8 reserved[7U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 2522  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_lldp_stop {
   u8 command ;
   u8 reserved[15U] ;
};
#line 2533  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_lldp_start {
   u8 command ;
   u8 reserved[15U] ;
};
#line 2543  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_set_dcb_parameters {
   u8 command ;
   u8 valid_flags ;
   u8 reserved[14U] ;
};
#line 2661  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_lldp_restore {
   u8 command ;
   u8 reserved[15U] ;
};
#line 2671  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_add_udp_tunnel {
   __le16 udp_port ;
   u8 reserved0[3U] ;
   u8 protocol_type ;
   u8 reserved1[10U] ;
};
#line 2697  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_remove_udp_tunnel {
   u8 reserved[2U] ;
   u8 index ;
   u8 reserved2[13U] ;
};
#line 2705  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_del_udp_tunnel_completion {
   __le16 udp_port ;
   u8 index ;
   u8 multiple_pfs ;
   u8 total_filters_used ;
   u8 reserved1[11U] ;
};
#line 2715  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_set_rss_key {
   __le16 vsi_id ;
   u8 reserved[6U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 2728  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_set_rss_key_data {
   u8 standard_rss_key[40U] ;
   u8 extended_hash_key[12U] ;
};
#line 2735  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_set_rss_lut {
   __le16 vsi_id ;
   __le16 flags ;
   u8 reserved[4U] ;
   __le32 addr_high ;
   __le32 addr_low ;
};
#line 2847  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_debug_reg_read_write {
   __le32 reserved ;
   __le32 address ;
   __le32 value_high ;
   __le32 value_low ;
};
#line 2891  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_debug_dump_internals {
   u8 cluster_id ;
   u8 table_id ;
   __le16 data_size ;
   __le32 idx ;
   __le32 address_high ;
   __le32 address_low ;
};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
enum i40e_debug_mask {
    I40E_DEBUG_INIT = 1,
    I40E_DEBUG_RELEASE = 2,
    I40E_DEBUG_LINK = 16,
    I40E_DEBUG_PHY = 32,
    I40E_DEBUG_HMC = 64,
    I40E_DEBUG_NVM = 128,
    I40E_DEBUG_LAN = 256,
    I40E_DEBUG_FLOW = 512,
    I40E_DEBUG_DCB = 1024,
    I40E_DEBUG_DIAG = 2048,
    I40E_DEBUG_FD = 4096,
    I40E_DEBUG_PACKAGE = 8192,
    I40E_DEBUG_IWARP = 15728640,
    I40E_DEBUG_AQ_MESSAGE = 16777216,
    I40E_DEBUG_AQ_DESCRIPTOR = 33554432,
    I40E_DEBUG_AQ_DESC_BUFFER = 67108864,
    I40E_DEBUG_AQ_COMMAND = 100663296,
    I40E_DEBUG_AQ = 251658240,
    I40E_DEBUG_USER = 4026531840,
    I40E_DEBUG_ALL = 4294967295
};
#line 349 
enum i40e_aq_resources_ids {
    I40E_NVM_RESOURCE_ID = 1
};
#line 353 
enum i40e_aq_resource_access_type {
    I40E_RESOURCE_READ = 1,
    I40E_RESOURCE_WRITE = 2
};
#line 647  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_driver_version {
   u8 major_version ;
   u8 minor_version ;
   u8 build_version ;
   u8 subbuild_version ;
   u8 driver_string[32U] ;
};
#line 832  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_rx_ptype_decoded {
   u32 ptype : 8 ;
   u32 known : 1 ;
   u32 outer_ip : 1 ;
   u32 outer_ip_ver : 1 ;
   u32 outer_frag : 1 ;
   u32 tunnel_type : 3 ;
   u32 tunnel_end_prot : 2 ;
   u32 tunnel_end_frag : 1 ;
   u32 inner_prot : 4 ;
   u32 payload_layer : 3 ;
};
#line 1433  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_control_filter_stats {
   u16 mac_etype_used ;
   u16 etype_used ;
   u16 mac_etype_free ;
   u16 etype_free ;
};
#line 1510  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_ddp_version {
   u8 major ;
   u8 minor ;
   u8 update ;
   u8 draft ;
};
#line 1520  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_package_header {
   struct i40e_ddp_version version ;
   u32 segment_count ;
   u32 segment_offset[1U] ;
};
#line 1527  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_generic_seg_header {
   u32 type ;
   struct i40e_ddp_version version ;
   u32 size ;
   char name[32U] ;
};
#line 1547  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_device_id_entry {
   u32 vendor_dev_id ;
   u32 sub_vendor_dev_id ;
};
#line 1552  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_profile_segment {
   struct i40e_generic_seg_header header ;
   struct i40e_ddp_version version ;
   char name[32U] ;
   u32 device_table_count ;
   struct i40e_device_id_entry device_table[1U] ;
};
#line 1560  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_section_table {
   u32 section_count ;
   u32 section_offset[1U] ;
};
#line 1565  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_section_3348 {
   u32 type ;
   u32 offset ;
   u32 size ;
};
#line 1565  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_profile_section_header {
   u16 tbl_size ;
   u16 data_end ;
   struct __anonstruct_section_3348 section ;
};
#line 1593  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_profile_aq_section {
   u16 opcode ;
   u16 flags ;
   u8 param[16U] ;
   u16 datalen ;
   u8 data[1U] ;
};
#line 1601  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_profile_info {
   u32 track_id ;
   struct i40e_ddp_version version ;
   u8 op ;
   u8 reserved[7U] ;
   u8 name[32U] ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_diag.h"
struct i40e_diag_reg_test_info {
   u32 offset ;
   u32 mask ;
   u32 elements ;
   u32 stride ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 1610  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
enum i40e_memory_type {
    i40e_mem_arq_buf = 0,
    i40e_mem_asq_buf = 1,
    i40e_mem_atq_buf = 2,
    i40e_mem_arq_ring = 3,
    i40e_mem_atq_ring = 4,
    i40e_mem_pd = 5,
    i40e_mem_bp = 6,
    i40e_mem_bp_jumbo = 7,
    i40e_mem_reserved = 8
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 100  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
enum i40e_hmc_lan_rsrc_type {
    I40E_HMC_LAN_FULL = 0,
    I40E_HMC_LAN_TX = 1,
    I40E_HMC_LAN_RX = 2,
    I40E_HMC_FCOE_CTX = 3,
    I40E_HMC_FCOE_FILT = 4,
    I40E_HMC_LAN_MAX = 5
};
#line 109 
enum i40e_hmc_model {
    I40E_HMC_MODEL_DIRECT_PREFERRED = 0,
    I40E_HMC_MODEL_DIRECT_ONLY = 1,
    I40E_HMC_MODEL_PAGED_ONLY = 2,
    I40E_HMC_MODEL_UNKNOWN = 3
};
#line 124  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
struct i40e_hmc_lan_create_obj_info {
   struct i40e_hmc_info *hmc_info ;
   u32 rsrc_type ;
   u32 start_idx ;
   u32 count ;
   enum i40e_sd_entry_type entry_type ;
   u64 direct_mode_sz ;
};
#line 133  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
struct i40e_hmc_lan_delete_obj_info {
   struct i40e_hmc_info *hmc_info ;
   u32 rsrc_type ;
   u32 start_idx ;
   u32 count ;
};
#line 664  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
struct i40e_context_ele {
   u16 offset ;
   u16 size_of ;
   u16 width ;
   u16 lsb ;
};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u16 __sum16;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
union __anonunion___u_6652 {
   int __val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nodemask.h"
enum node_states {
    N_POSSIBLE = 0,
    N_ONLINE = 1,
    N_NORMAL_MEMORY = 2,
    N_HIGH_MEMORY = 2,
    N_MEMORY = 3,
    N_CPU = 4,
    NR_NODE_STATES = 5
};
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
union __anonunion___u_6834 {
   unsigned int __val ;
   char __c[1U] ;
};
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
union __anonunion___u_6836 {
   unsigned int __val ;
   char __c[1U] ;
};
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/refcount.h"
enum refcount_saturation_type {
    REFCOUNT_ADD_NOT_ZERO_OVF = 0,
    REFCOUNT_ADD_OVF = 1,
    REFCOUNT_ADD_UAF = 2,
    REFCOUNT_SUB_UAF = 3,
    REFCOUNT_DEC_LEAK = 4
};
#line 174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/page-flags.h"
union __anonunion___u_6840 {
   unsigned long __val ;
   char __c[1U] ;
};
#line 1165  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
enum pkt_hash_types {
    PKT_HASH_TYPE_NONE = 0,
    PKT_HASH_TYPE_L2 = 1,
    PKT_HASH_TYPE_L3 = 2,
    PKT_HASH_TYPE_L4 = 3
};
#line 893  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct xdp_buff;
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
struct xdp_buff {
   void *data ;
   void *data_end ;
   void *data_meta ;
   void *data_hard_start ;
   unsigned long handle ;
   struct xdp_rxq_info *rxq ;
};
#line 362  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4,
    GRO_CONSUMED = 5
};
#line 371  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
typedef enum gro_result gro_result_t;
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_vlan.h"
struct vlan_hdr {
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_vlan.h"
struct vlan_ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_vlan_proto ;
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/tracepoint.h"
struct trace_eval_map {
   char *system ;
   char *eval_string ;
   unsigned long eval_value ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/trace/events/xdp.h"
union __anonunion___u_7380 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/trace/events/xdp.h"
union __anonunion___u_7382 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/tcp.h"
struct tcphdr {
   __be16 source ;
   __be16 dest ;
   __be32 seq ;
   __be32 ack_seq ;
   __u16 res1 : 4 ;
   __u16 doff : 4 ;
   __u16 fin : 1 ;
   __u16 syn : 1 ;
   __u16 rst : 1 ;
   __u16 psh : 1 ;
   __u16 ack : 1 ;
   __u16 urg : 1 ;
   __u16 ece : 1 ;
   __u16 cwr : 1 ;
   __be16 window ;
   __sum16 check ;
   __be16 urg_ptr ;
};
#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ip.h"
struct iphdr {
   __u8 ihl : 4 ;
   __u8 version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ipv6.h"
struct ipv6hdr {
   __u8 priority : 4 ;
   __u8 version : 4 ;
   __u8 flow_lbl[3U] ;
   __be16 payload_len ;
   __u8 nexthdr ;
   __u8 hop_limit ;
   struct in6_addr saddr ;
   struct in6_addr daddr ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/udp.h"
struct udphdr {
   __be16 source ;
   __be16 dest ;
   __be16 len ;
   __sum16 check ;
};
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sctp.h"
struct sctphdr {
   __be16 source ;
   __be16 dest ;
   __be32 vtag ;
   __le32 checksum ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_read_7724 {
   __le64 pkt_addr ;
   __le64 hdr_addr ;
   __le64 rsvd1 ;
   __le64 rsvd2 ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
union __anonunion_mirr_fcoe_7728 {
   __le16 mirroring_status ;
   __le16 fcoe_ctx_id ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_lo_dword_7727 {
   union __anonunion_mirr_fcoe_7728 mirr_fcoe ;
   __le16 l2tag1 ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
union __anonunion_hi_dword_7729 {
   __le32 rss ;
   __le32 fcoe_param ;
   __le32 fd_id ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_qword0_7726 {
   struct __anonstruct_lo_dword_7727 lo_dword ;
   union __anonunion_hi_dword_7729 hi_dword ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_qword1_7730 {
   __le64 status_error_len ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_qword2_7731 {
   __le16 ext_status ;
   __le16 rsvd ;
   __le16 l2tag2_1 ;
   __le16 l2tag2_2 ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
union __anonunion_lo_dword_7733 {
   __le32 flex_bytes_lo ;
   __le32 pe_status ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
union __anonunion_hi_dword_7734 {
   __le32 flex_bytes_hi ;
   __le32 fd_id ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_qword3_7732 {
   union __anonunion_lo_dword_7733 lo_dword ;
   union __anonunion_hi_dword_7734 hi_dword ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct __anonstruct_wb_7725 {
   struct __anonstruct_qword0_7726 qword0 ;
   struct __anonstruct_qword1_7730 qword1 ;
   struct __anonstruct_qword2_7731 qword2 ;
   struct __anonstruct_qword3_7732 qword3 ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
union i40e_32byte_rx_desc {
   struct __anonstruct_read_7724 read ;
   struct __anonstruct_wb_7725 wb ;
};
#line 1022  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_tx_context_desc {
   __le32 tunneling_params ;
   __le16 l2tag2 ;
   __le16 rsvd ;
   __le64 type_cmd_tso_mss ;
};
#line 1095  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_filter_program_desc {
   __le32 qindex_flex_ptype_vsi ;
   __le32 rsvd ;
   __le32 dtype_cmd_cntindex ;
   __le32 fd_id ;
};
#line 218  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_fdir_filter {
   struct hlist_node fdir_node ;
   u8 flow_type ;
   u8 ip4_proto ;
   __be32 dst_ip ;
   __be32 src_ip ;
   __be16 src_port ;
   __be16 dst_port ;
   __be32 sctp_v_tag ;
   __be16 flex_word ;
   u16 flex_offset ;
   bool flex_filter ;
   u16 q_index ;
   u8 flex_off ;
   u8 pctype ;
   u16 dest_vsi ;
   u8 dest_ctl ;
   u8 fd_status ;
   u16 cnt_index ;
   u32 fd_id ;
};
#line 1155  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
union __anonunion___u_7749 {
   struct bpf_prog *__val ;
   char __c[1U] ;
};
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
union __anonunion___u_7751 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
union __anonunion___u_7753 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
union __anonunion___u_7755 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
union __anonunion___u_7757 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
union __anonunion___u_7759 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
union __anonunion___u_7761 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 148  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
union __anonunion___u_7763 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 148  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
union __anonunion___u_7765 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 182  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
union __anonunion___u_7767 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 182  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
union __anonunion___u_7769 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
union __anonunion___u_7771 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
union __anonunion___u_7773 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 2205  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
union __anonunion___u_7775 {
   struct bpf_prog *__val ;
   char __c[1U] ;
};
#line 2672  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
union __anonunion_hdr_7777 {
   unsigned char *network ;
   struct iphdr *ipv4 ;
   struct ipv6hdr *ipv6 ;
};
#line 2891  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
union __anonunion_ip_7780 {
   struct iphdr *v4 ;
   struct ipv6hdr *v6 ;
   unsigned char *hdr ;
};
#line 2896  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
union __anonunion_l4_7781 {
   struct tcphdr *tcp ;
   struct udphdr *udp ;
   unsigned char *hdr ;
};
#line 3050  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
union __anonunion_ip_7784 {
   struct iphdr *v4 ;
   struct ipv6hdr *v6 ;
   unsigned char *hdr ;
};
#line 3055  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
union __anonunion_l4_7785 {
   struct tcphdr *tcp ;
   struct udphdr *udp ;
   unsigned char *hdr ;
};
#line 557  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernel.h"
enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_SCHEDULING = 1,
    SYSTEM_RUNNING = 2,
    SYSTEM_HALT = 3,
    SYSTEM_POWER_OFF = 4,
    SYSTEM_RESTART = 5,
    SYSTEM_SUSPEND = 6
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_7798 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_7800 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 268  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_7802 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 754  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_7804 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 762  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_7806 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 788  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_7808 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
union __anonunion___u_7852 {
   int __val ;
   char __c[1U] ;
};
#line 690  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 196  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_dissector.h"
struct flow_dissector_key_control {
   u16 thoff ;
   u16 addr_type ;
   u32 flags ;
};
#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_dissector.h"
struct flow_dissector_key_basic {
   __be16 n_proto ;
   u8 ip_proto ;
   u8 padding ;
};
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_dissector.h"
struct __anonstruct_8255 {
   u16 vlan_id : 12 ;
   u16 vlan_dei : 1 ;
   u16 vlan_priority : 3 ;
};
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_dissector.h"
union __anonunion_8254 {
   struct __anonstruct_8255 __anonCompField___anonunion_8254_73 ;
   __be16 vlan_tci ;
};
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_dissector.h"
struct flow_dissector_key_vlan {
   union __anonunion_8254 __anonCompField_flow_dissector_key_vlan_74 ;
   __be16 vlan_tpid ;
};
#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_dissector.h"
struct flow_dissector_key_keyid {
   __be32 keyid ;
};
#line 93  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_dissector.h"
struct flow_dissector_key_ipv4_addrs {
   __be32 src ;
   __be32 dst ;
};
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_dissector.h"
struct flow_dissector_key_ipv6_addrs {
   struct in6_addr src ;
   struct in6_addr dst ;
};
#line 155  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_dissector.h"
struct __anonstruct_8258 {
   __be16 src ;
   __be16 dst ;
};
#line 155  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_dissector.h"
union __anonunion_8257 {
   __be32 ports ;
   struct __anonstruct_8258 __anonCompField___anonunion_8257_76 ;
};
#line 155  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_dissector.h"
struct flow_dissector_key_ports {
   union __anonunion_8257 __anonCompField_flow_dissector_key_ports_77 ;
};
#line 184  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_dissector.h"
struct flow_dissector_key_eth_addrs {
   unsigned char dst[6U] ;
   unsigned char src[6U] ;
};
#line 231 
enum flow_dissector_key_id {
    FLOW_DISSECTOR_KEY_CONTROL = 0,
    FLOW_DISSECTOR_KEY_BASIC = 1,
    FLOW_DISSECTOR_KEY_IPV4_ADDRS = 2,
    FLOW_DISSECTOR_KEY_IPV6_ADDRS = 3,
    FLOW_DISSECTOR_KEY_PORTS = 4,
    FLOW_DISSECTOR_KEY_PORTS_RANGE = 5,
    FLOW_DISSECTOR_KEY_ICMP = 6,
    FLOW_DISSECTOR_KEY_ETH_ADDRS = 7,
    FLOW_DISSECTOR_KEY_TIPC = 8,
    FLOW_DISSECTOR_KEY_ARP = 9,
    FLOW_DISSECTOR_KEY_VLAN = 10,
    FLOW_DISSECTOR_KEY_FLOW_LABEL = 11,
    FLOW_DISSECTOR_KEY_GRE_KEYID = 12,
    FLOW_DISSECTOR_KEY_MPLS_ENTROPY = 13,
    FLOW_DISSECTOR_KEY_ENC_KEYID = 14,
    FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS = 15,
    FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS = 16,
    FLOW_DISSECTOR_KEY_ENC_CONTROL = 17,
    FLOW_DISSECTOR_KEY_ENC_PORTS = 18,
    FLOW_DISSECTOR_KEY_MPLS = 19,
    FLOW_DISSECTOR_KEY_TCP = 20,
    FLOW_DISSECTOR_KEY_IP = 21,
    FLOW_DISSECTOR_KEY_CVLAN = 22,
    FLOW_DISSECTOR_KEY_ENC_IP = 23,
    FLOW_DISSECTOR_KEY_ENC_OPTS = 24,
    FLOW_DISSECTOR_KEY_META = 25,
    FLOW_DISSECTOR_KEY_CT = 26,
    FLOW_DISSECTOR_KEY_MAX = 27
};
#line 274  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_dissector.h"
struct flow_dissector {
   unsigned int used_keys ;
   unsigned short offset[27U] ;
};
#line 973  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct rtable;
#line 409  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
struct flow_rule;
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netprio_cgroup.h"
enum xdp_mem_type {
    MEM_TYPE_PAGE_SHARED = 0,
    MEM_TYPE_PAGE_ORDER0 = 1,
    MEM_TYPE_PAGE_POOL = 2,
    MEM_TYPE_ZERO_COPY = 3,
    MEM_TYPE_MAX = 4
};
#line 1865  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/security.h"
struct perf_event_attr;
#line 410  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_link.h"
enum macvlan_mode {
    MACVLAN_MODE_PRIVATE = 1,
    MACVLAN_MODE_VEPA = 2,
    MACVLAN_MODE_BRIDGE = 4,
    MACVLAN_MODE_PASSTHRU = 8,
    MACVLAN_MODE_SOURCE = 16
};
#line 823  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mod_devicetable.h"
struct gpio_desc;
#line 824 
struct mii_bus;
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mdio.h"
struct reset_control;
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mdio.h"
struct mdio_device {
   struct device dev ;
   struct mii_bus *bus ;
   char modalias[32U] ;
   int (*bus_match)(struct device *, struct device_driver *) ;
   void (*device_free)(struct mdio_device *) ;
   void (*device_remove)(struct mdio_device *) ;
   int addr ;
   int flags ;
   struct gpio_desc *reset_gpio ;
   struct reset_control *reset_ctrl ;
   unsigned int reset_assert_delay ;
   unsigned int reset_deassert_delay ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mdio.h"
struct mdio_driver_common {
   struct device_driver driver ;
   int flags ;
};
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
enum ldv_15393 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_INTERNAL = 1,
    PHY_INTERFACE_MODE_MII = 2,
    PHY_INTERFACE_MODE_GMII = 3,
    PHY_INTERFACE_MODE_SGMII = 4,
    PHY_INTERFACE_MODE_TBI = 5,
    PHY_INTERFACE_MODE_REVMII = 6,
    PHY_INTERFACE_MODE_RMII = 7,
    PHY_INTERFACE_MODE_RGMII = 8,
    PHY_INTERFACE_MODE_RGMII_ID = 9,
    PHY_INTERFACE_MODE_RGMII_RXID = 10,
    PHY_INTERFACE_MODE_RGMII_TXID = 11,
    PHY_INTERFACE_MODE_RTBI = 12,
    PHY_INTERFACE_MODE_SMII = 13,
    PHY_INTERFACE_MODE_XGMII = 14,
    PHY_INTERFACE_MODE_MOCA = 15,
    PHY_INTERFACE_MODE_QSGMII = 16,
    PHY_INTERFACE_MODE_TRGMII = 17,
    PHY_INTERFACE_MODE_1000BASEX = 18,
    PHY_INTERFACE_MODE_2500BASEX = 19,
    PHY_INTERFACE_MODE_RXAUI = 20,
    PHY_INTERFACE_MODE_XAUI = 21,
    PHY_INTERFACE_MODE_10GKR = 22,
    PHY_INTERFACE_MODE_USXGMII = 23,
    PHY_INTERFACE_MODE_MAX = 24
};
#line 93  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
typedef enum ldv_15393 phy_interface_t;
#line 186 
struct phylink;
#line 188 
enum ldv_15408 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
};
#line 214  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
struct mii_bus {
   struct module *owner ;
   char *name ;
   char id[61U] ;
   void *priv ;
   int (*read)(struct mii_bus *, int , int ) ;
   int (*write)(struct mii_bus *, int , int , u16 ) ;
   int (*reset)(struct mii_bus *) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_15408 state ;
   struct device dev ;
   struct mdio_device *mdio_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int irq[32U] ;
   int reset_delay_us ;
   struct gpio_desc *reset_gpiod ;
};
#line 278 
enum phy_state {
    PHY_DOWN = 0,
    PHY_READY = 1,
    PHY_HALTED = 2,
    PHY_UP = 3,
    PHY_RUNNING = 4,
    PHY_NOLINK = 5
};
#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 363 
struct phy_driver;
#line 363 
struct phy_led_trigger;
#line 363  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
struct phy_device {
   struct mdio_device mdio ;
   struct phy_driver *drv ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   unsigned int is_c45 : 1 ;
   unsigned int is_internal : 1 ;
   unsigned int is_pseudo_fixed_link : 1 ;
   unsigned int is_gigabit_capable : 1 ;
   unsigned int has_fixups : 1 ;
   unsigned int suspended : 1 ;
   unsigned int sysfs_links : 1 ;
   unsigned int loopback_enabled : 1 ;
   unsigned int autoneg : 1 ;
   unsigned int link : 1 ;
   unsigned int autoneg_complete : 1 ;
   unsigned int interrupts : 1 ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   unsigned long supported[2U] ;
   unsigned long advertising[2U] ;
   unsigned long lp_advertising[2U] ;
   unsigned long adv_old[2U] ;
   u32 eee_broken_modes ;
   struct phy_led_trigger *phy_led_triggers ;
   unsigned int phy_num_led_triggers ;
   struct phy_led_trigger *last_triggered ;
   struct phy_led_trigger *led_link_trigger ;
   int irq ;
   void *priv ;
   struct delayed_work state_queue ;
   struct mutex lock ;
   bool sfp_bus_attached ;
   struct sfp_bus *sfp_bus ;
   struct phylink *phylink ;
   struct net_device *attached_dev ;
   u8 mdix ;
   u8 mdix_ctrl ;
   void (*phy_link_change)(struct phy_device *, bool , bool ) ;
   void (*adjust_link)(struct net_device *) ;
};
#line 475  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/phy.h"
struct phy_driver {
   struct mdio_driver_common mdiodrv ;
   u32 phy_id ;
   char *name ;
   u32 phy_id_mask ;
   unsigned long *features ;
   u32 flags ;
   void *driver_data ;
   int (*soft_reset)(struct phy_device *) ;
   int (*config_init)(struct phy_device *) ;
   int (*probe)(struct phy_device *) ;
   int (*get_features)(struct phy_device *) ;
   int (*suspend)(struct phy_device *) ;
   int (*resume)(struct phy_device *) ;
   int (*config_aneg)(struct phy_device *) ;
   int (*aneg_done)(struct phy_device *) ;
   int (*read_status)(struct phy_device *) ;
   int (*ack_interrupt)(struct phy_device *) ;
   int (*config_intr)(struct phy_device *) ;
   int (*did_interrupt)(struct phy_device *) ;
   int (*handle_interrupt)(struct phy_device *) ;
   void (*remove)(struct phy_device *) ;
   int (*match_phy_device)(struct phy_device *) ;
   int (*ts_info)(struct phy_device *, struct ethtool_ts_info *) ;
   int (*hwtstamp)(struct phy_device *, struct ifreq *) ;
   bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   void (*txtstamp)(struct phy_device *, struct sk_buff *, int ) ;
   int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *) ;
   void (*link_change_notify)(struct phy_device *) ;
   int (*read_mmd)(struct phy_device *, int , u16 ) ;
   int (*write_mmd)(struct phy_device *, int , u16 , u16 ) ;
   int (*read_page)(struct phy_device *) ;
   int (*write_page)(struct phy_device *, int ) ;
   int (*module_info)(struct phy_device *, struct ethtool_modinfo *) ;
   int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_sset_count)(struct phy_device *) ;
   void (*get_strings)(struct phy_device *, u8 *) ;
   void (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *) ;
   int (*get_tunable)(struct phy_device *, struct ethtool_tunable *, void *) ;
   int (*set_tunable)(struct phy_device *, struct ethtool_tunable *, void *) ;
   int (*set_loopback)(struct phy_device *, bool ) ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_vlan.h"
struct vlan_pcpu_stats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 rx_multicast ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
   u32 rx_errors ;
   u32 tx_dropped ;
};
#line 149 
struct netpoll;
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_match {
   struct flow_dissector *dissector ;
   void *mask ;
   void *key ;
};
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_match_basic {
   struct flow_dissector_key_basic *key ;
   struct flow_dissector_key_basic *mask ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_match_control {
   struct flow_dissector_key_control *key ;
   struct flow_dissector_key_control *mask ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_match_eth_addrs {
   struct flow_dissector_key_eth_addrs *key ;
   struct flow_dissector_key_eth_addrs *mask ;
};
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_match_vlan {
   struct flow_dissector_key_vlan *key ;
   struct flow_dissector_key_vlan *mask ;
};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_match_ipv4_addrs {
   struct flow_dissector_key_ipv4_addrs *key ;
   struct flow_dissector_key_ipv4_addrs *mask ;
};
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_match_ipv6_addrs {
   struct flow_dissector_key_ipv6_addrs *key ;
   struct flow_dissector_key_ipv6_addrs *mask ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_match_ports {
   struct flow_dissector_key_ports *key ;
   struct flow_dissector_key_ports *mask ;
};
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_match_enc_keyid {
   struct flow_dissector_key_keyid *key ;
   struct flow_dissector_key_keyid *mask ;
};
#line 112 
enum flow_action_id {
    FLOW_ACTION_ACCEPT = 0,
    FLOW_ACTION_DROP = 1,
    FLOW_ACTION_TRAP = 2,
    FLOW_ACTION_GOTO = 3,
    FLOW_ACTION_REDIRECT = 4,
    FLOW_ACTION_MIRRED = 5,
    FLOW_ACTION_REDIRECT_INGRESS = 6,
    FLOW_ACTION_MIRRED_INGRESS = 7,
    FLOW_ACTION_VLAN_PUSH = 8,
    FLOW_ACTION_VLAN_POP = 9,
    FLOW_ACTION_VLAN_MANGLE = 10,
    FLOW_ACTION_TUNNEL_ENCAP = 11,
    FLOW_ACTION_TUNNEL_DECAP = 12,
    FLOW_ACTION_MANGLE = 13,
    FLOW_ACTION_ADD = 14,
    FLOW_ACTION_CSUM = 15,
    FLOW_ACTION_MARK = 16,
    FLOW_ACTION_PTYPE = 17,
    FLOW_ACTION_WAKE = 18,
    FLOW_ACTION_QUEUE = 19,
    FLOW_ACTION_SAMPLE = 20,
    FLOW_ACTION_POLICE = 21,
    FLOW_ACTION_CT = 22,
    FLOW_ACTION_MPLS_PUSH = 23,
    FLOW_ACTION_MPLS_POP = 24,
    FLOW_ACTION_MPLS_MANGLE = 25,
    NUM_FLOW_ACTIONS = 26
};
#line 142 
enum flow_action_mangle_base {
    FLOW_ACT_MANGLE_UNSPEC = 0,
    FLOW_ACT_MANGLE_HDR_TYPE_ETH = 1,
    FLOW_ACT_MANGLE_HDR_TYPE_IP4 = 2,
    FLOW_ACT_MANGLE_HDR_TYPE_IP6 = 3,
    FLOW_ACT_MANGLE_HDR_TYPE_TCP = 4,
    FLOW_ACT_MANGLE_HDR_TYPE_UDP = 5
};
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct __anonstruct_vlan_8574 {
   u16 vid ;
   __be16 proto ;
   u8 prio ;
};
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct __anonstruct_mangle_8575 {
   enum flow_action_mangle_base htype ;
   u32 offset ;
   u32 mask ;
   u32 val ;
};
#line 159 
struct ip_tunnel_info;
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct __anonstruct_queue_8576 {
   u32 ctx ;
   u32 index ;
   u8 vf ;
};
#line 159 
struct psample_group;
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct __anonstruct_sample_8577 {
   struct psample_group *psample_group ;
   u32 rate ;
   u32 trunc_size ;
   bool truncate ;
};
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct __anonstruct_police_8578 {
   s64 burst ;
   u64 rate_bytes_ps ;
};
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct __anonstruct_ct_8579 {
   int action ;
   u16 zone ;
};
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct __anonstruct_mpls_push_8580 {
   u32 label ;
   __be16 proto ;
   u8 tc ;
   u8 bos ;
   u8 ttl ;
};
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct __anonstruct_mpls_pop_8581 {
   __be16 proto ;
};
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct __anonstruct_mpls_mangle_8582 {
   u32 label ;
   u8 tc ;
   u8 bos ;
   u8 ttl ;
};
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
union __anonunion_8573 {
   u32 chain_index ;
   struct net_device *dev ;
   struct __anonstruct_vlan_8574 vlan ;
   struct __anonstruct_mangle_8575 mangle ;
   struct ip_tunnel_info *tunnel ;
   u32 csum_flags ;
   u32 mark ;
   u16 ptype ;
   struct __anonstruct_queue_8576 queue ;
   struct __anonstruct_sample_8577 sample ;
   struct __anonstruct_police_8578 police ;
   struct __anonstruct_ct_8579 ct ;
   struct __anonstruct_mpls_push_8580 mpls_push ;
   struct __anonstruct_mpls_pop_8581 mpls_pop ;
   struct __anonstruct_mpls_mangle_8582 mpls_mangle ;
};
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_action_entry {
   enum flow_action_id id ;
   void (*destructor)(void *) ;
   void *destructor_priv ;
   union __anonunion_8573 __anonCompField_flow_action_entry_171 ;
};
#line 219  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_action {
   unsigned int num_entries ;
   struct flow_action_entry entries[0U] ;
};
#line 243  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_rule {
   struct flow_match match ;
   struct flow_action action ;
};
#line 256  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_stats {
   u64 pkts ;
   u64 bytes ;
   u64 lastused ;
};
#line 270 
enum flow_block_command {
    FLOW_BLOCK_BIND = 0,
    FLOW_BLOCK_UNBIND = 1
};
#line 275 
enum flow_block_binder_type {
    FLOW_BLOCK_BINDER_TYPE_UNSPEC = 0,
    FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS = 1,
    FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS = 2
};
#line 287  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_block_offload {
   enum flow_block_command command ;
   enum flow_block_binder_type binder_type ;
   bool block_shared ;
   bool unlocked_driver_cb ;
   struct net *net ;
   struct flow_block *block ;
   struct list_head cb_list ;
   struct list_head *driver_block_list ;
   struct netlink_ext_ack *extack ;
};
#line 341 
enum flow_cls_command {
    FLOW_CLS_REPLACE = 0,
    FLOW_CLS_DESTROY = 1,
    FLOW_CLS_STATS = 2,
    FLOW_CLS_TMPLT_CREATE = 3,
    FLOW_CLS_TMPLT_DESTROY = 4
};
#line 353  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_cls_common_offload {
   u32 chain_index ;
   __be16 protocol ;
   u32 prio ;
   struct netlink_ext_ack *extack ;
};
#line 360  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
struct flow_cls_offload {
   struct flow_cls_common_offload common ;
   enum flow_cls_command command ;
   unsigned long cookie ;
   struct flow_rule *rule ;
   struct flow_stats stats ;
   u32 classid ;
};
#line 82  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dst.h"
struct dst_metrics {
   u32 metrics[17U] ;
   refcount_t refcnt ;
} __attribute__((__aligned__(4)));
#line 261  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/if_inet6.h"
struct fib6_nh;
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
struct fib_info;
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
struct fib_nh_exception {
   struct fib_nh_exception *fnhe_next ;
   int fnhe_genid ;
   __be32 fnhe_daddr ;
   u32 fnhe_pmtu ;
   bool fnhe_mtu_locked ;
   __be32 fnhe_gw ;
   unsigned long fnhe_expires ;
   struct rtable *fnhe_rth_input ;
   struct rtable *fnhe_rth_output ;
   unsigned long fnhe_stamp ;
   struct callback_head rcu ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
struct fnhe_hash_bucket {
   struct fib_nh_exception *chain ;
};
#line 80  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
union __anonunion_nhc_gw_8763 {
   __be32 ipv4 ;
   struct in6_addr ipv6 ;
};
#line 80  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
struct fib_nh_common {
   struct net_device *nhc_dev ;
   int nhc_oif ;
   unsigned char nhc_scope ;
   u8 nhc_family ;
   u8 nhc_gw_family ;
   unsigned char nhc_flags ;
   struct lwtunnel_state *nhc_lwtstate ;
   union __anonunion_nhc_gw_8763 nhc_gw ;
   int nhc_weight ;
   atomic_t nhc_upper_bound ;
   struct rtable **nhc_pcpu_rth_output ;
   struct rtable *nhc_rth_input ;
   struct fnhe_hash_bucket *nhc_exceptions ;
};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
struct fib_nh {
   struct fib_nh_common nh_common ;
   struct hlist_node nh_hash ;
   struct fib_info *nh_parent ;
   __u32 nh_tclassid ;
   __be32 nh_saddr ;
   int nh_saddr_genid ;
};
#line 113 
struct nexthop;
#line 131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_fib.h"
struct fib_info {
   struct hlist_node fib_hash ;
   struct hlist_node fib_lhash ;
   struct list_head nh_list ;
   struct net *fib_net ;
   int fib_treeref ;
   refcount_t fib_clntref ;
   unsigned int fib_flags ;
   unsigned char fib_dead ;
   unsigned char fib_protocol ;
   unsigned char fib_scope ;
   unsigned char fib_type ;
   __be32 fib_prefsrc ;
   u32 fib_tb_id ;
   u32 fib_priority ;
   struct dst_metrics *fib_metrics ;
   int fib_nhs ;
   bool fib_nh_is_v6 ;
   bool nh_updated ;
   struct nexthop *nh ;
   struct callback_head rcu ;
   struct fib_nh fib_nh[0U] ;
};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/route.h"
struct uncached_list;
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/route.h"
union __anonunion_8772 {
   __be32 rt_gw4 ;
   struct in6_addr rt_gw6 ;
};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   u8 rt_gw_family ;
   union __anonunion_8772 __anonCompField_rtable_196 ;
   u32 rt_mtu_locked : 1 ;
   u32 rt_pmtu : 31 ;
   struct list_head rt_uncached ;
   struct uncached_list *rt_uncached_list ;
};
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_checksum.h"
struct macvlan_port;
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_macvlan.h"
struct macvlan_dev {
   struct net_device *dev ;
   struct list_head list ;
   struct hlist_node hlist ;
   struct macvlan_port *port ;
   struct net_device *lowerdev ;
   void *accel_priv ;
   struct vlan_pcpu_stats *pcpu_stats ;
   unsigned long mc_filter[4U] ;
   netdev_features_t set_features ;
   enum macvlan_mode mode ;
   u16 flags ;
   unsigned int macaddr_count ;
   struct netpoll *netpoll ;
};
#line 2448  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_lan_overflow {
   __le32 prtdcb_rupto ;
   __le32 otx_ctl ;
   u8 reserved[8U] ;
};
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.h"
struct i40e_arq_event_info {
   struct i40e_aq_desc desc ;
   u16 msg_len ;
   u16 buf_len ;
   u8 *msg_buf ;
};
#line 409  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_flex_pit {
   struct list_head list ;
   u16 src_offset ;
   u8 pit_index ;
};
#line 698  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_new_mac_filter {
   struct hlist_node hlist ;
   struct i40e_mac_filter *f ;
   enum i40e_filter_state state ;
};
#line 1155  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
union __anonunion___u_8900 {
   struct bpf_prog *__val ;
   char __c[1U] ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/lwtunnel.h"
struct lwtunnel_state {
   __u16 type ;
   __u16 flags ;
   __u16 headroom ;
   atomic_t refcnt ;
   int (*orig_output)(struct net *, struct sock *, struct sk_buff *) ;
   int (*orig_input)(struct sk_buff *) ;
   struct callback_head rcu ;
   __u8 data[0U] ;
};
#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct fib6_node {
   struct fib6_node *parent ;
   struct fib6_node *left ;
   struct fib6_node *right ;
   struct fib6_node *subtree ;
   struct fib6_info *leaf ;
   __u16 fn_bit ;
   __u16 fn_flags ;
   int fn_sernum ;
   struct fib6_info *rr_ptr ;
   struct callback_head rcu ;
};
#line 127  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct rt6key {
   struct in6_addr addr ;
   int plen ;
};
#line 134  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct rt6_exception_bucket {
   struct hlist_head chain ;
   int depth ;
};
#line 150  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct fib6_nh {
   struct fib_nh_common nh_common ;
   unsigned long last_probe ;
   struct rt6_info **rt6i_pcpu ;
   struct rt6_exception_bucket *rt6i_exception_bucket ;
};
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
union __anonunion_8901 {
   struct list_head fib6_siblings ;
   struct list_head nh_list ;
};
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct fib6_info {
   struct fib6_table *fib6_table ;
   struct fib6_info *fib6_next ;
   struct fib6_node *fib6_node ;
   union __anonunion_8901 __anonCompField_fib6_info_223 ;
   unsigned int fib6_nsiblings ;
   refcount_t fib6_ref ;
   unsigned long expires ;
   struct dst_metrics *fib6_metrics ;
   struct rt6key fib6_dst ;
   u32 fib6_flags ;
   struct rt6key fib6_src ;
   struct rt6key fib6_prefsrc ;
   u32 fib6_metric ;
   u8 fib6_protocol ;
   u8 fib6_type ;
   u8 should_flush : 1 ;
   u8 dst_nocount : 1 ;
   u8 dst_nopolicy : 1 ;
   u8 dst_host : 1 ;
   u8 fib6_destroying : 1 ;
   u8 unused : 3 ;
   struct callback_head rcu ;
   struct nexthop *nh ;
   struct fib6_nh fib6_nh[0U] ;
};
#line 202  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct rt6_info {
   struct dst_entry dst ;
   struct fib6_info *from ;
   struct rt6key rt6i_dst ;
   struct rt6key rt6i_src ;
   struct in6_addr rt6i_gateway ;
   struct inet6_dev *rt6i_idev ;
   u32 rt6i_flags ;
   struct list_head rt6i_uncached ;
   struct uncached_list *rt6i_uncached_list ;
   unsigned short rt6i_nfheader_len ;
};
#line 354  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct rt6_statistics {
   __u32 fib_nodes ;
   __u32 fib_route_nodes ;
   __u32 fib_rt_entries ;
   __u32 fib_rt_cache ;
   __u32 fib_discarded_routes ;
   atomic_t fib_rt_alloc ;
   atomic_t fib_rt_uncache ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip6_fib.h"
struct fib6_table {
   struct hlist_node tb6_hlist ;
   u32 tb6_id ;
   spinlock_t tb6_lock ;
   struct fib6_node tb6_root ;
   struct inet_peer_base tb6_peers ;
   unsigned int flags ;
   unsigned int fib_seq ;
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dst_cache.h"
struct dst_cache_pcpu;
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dst_cache.h"
struct dst_cache {
   struct dst_cache_pcpu *cache ;
   unsigned long reset_ts ;
};
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/addrconf.h"
struct prefix_info {
   __u8 type ;
   __u8 length ;
   __u8 prefix_len ;
   __u8 reserved : 6 ;
   __u8 autoconf : 1 ;
   __u8 onlink : 1 ;
   __be32 valid ;
   __be32 prefered ;
   __be32 reserved2 ;
   struct in6_addr prefix ;
};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/nexthop.h"
union __anonunion_8915 {
   struct fib_nh_common fib_nhc ;
   struct fib_nh fib_nh ;
   struct fib6_nh fib6_nh ;
};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/nexthop.h"
struct nh_info {
   struct hlist_node dev_hash ;
   struct nexthop *nh_parent ;
   u8 family ;
   bool reject_nh ;
   union __anonunion_8915 __anonCompField_nh_info_224 ;
};
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/nexthop.h"
struct nh_grp_entry {
   struct nexthop *nh ;
   u8 weight ;
   atomic_t upper_bound ;
   struct list_head nh_list ;
   struct nexthop *nh_parent ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/nexthop.h"
struct nh_group {
   u16 num_nh ;
   bool mpath ;
   bool has_v4 ;
   struct nh_grp_entry nh_entries[0U] ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/nexthop.h"
union __anonunion_8916 {
   struct nh_info *nh_info ;
   struct nh_group *nh_grp ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/nexthop.h"
struct nexthop {
   struct rb_node rb_node ;
   struct list_head fi_list ;
   struct list_head f6i_list ;
   struct list_head grp_list ;
   struct net *net ;
   u32 id ;
   u8 protocol ;
   u8 nh_flags ;
   bool is_group ;
   refcount_t refcnt ;
   struct callback_head rcu ;
   union __anonunion_8916 __anonCompField_nexthop_225 ;
};
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_tunnels.h"
struct __anonstruct_ipv4_8936 {
   __be32 src ;
   __be32 dst ;
};
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_tunnels.h"
struct __anonstruct_ipv6_8937 {
   struct in6_addr src ;
   struct in6_addr dst ;
};
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_tunnels.h"
union __anonunion_u_8935 {
   struct __anonstruct_ipv4_8936 ipv4 ;
   struct __anonstruct_ipv6_8937 ipv6 ;
};
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_tunnels.h"
struct ip_tunnel_key {
   __be64 tun_id ;
   union __anonunion_u_8935 u ;
   __be16 tun_flags ;
   u8 tos ;
   u8 ttl ;
   __be32 label ;
   __be16 tp_src ;
   __be16 tp_dst ;
};
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ip_tunnels.h"
struct ip_tunnel_info {
   struct ip_tunnel_key key ;
   struct dst_cache dst_cache ;
   u8 options_len ;
   u8 mode ;
};
#line 114  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/udp_tunnel.h"
struct udp_tunnel_info {
   unsigned short type ;
   sa_family_t sa_family ;
   __be16 port ;
};
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
struct ring_buffer;
#line 191 
struct ring_buffer_iter;
#line 196  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ring_buffer.h"
struct trace_seq;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seq_buf.h"
struct seq_buf {
   char *buffer ;
   size_t size ;
   size_t len ;
   loff_t readpos ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/trace_seq.h"
struct trace_seq {
   unsigned char buffer[4096U] ;
   struct seq_buf seq ;
   int full ;
};
#line 312  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/perf_event.h"
union __anonunion_8968 {
   __u64 sample_period ;
   __u64 sample_freq ;
};
#line 312  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/perf_event.h"
union __anonunion_8969 {
   __u32 wakeup_events ;
   __u32 wakeup_watermark ;
};
#line 312  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/perf_event.h"
union __anonunion_8970 {
   __u64 bp_addr ;
   __u64 kprobe_func ;
   __u64 uprobe_path ;
   __u64 config1 ;
};
#line 312  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/perf_event.h"
union __anonunion_8971 {
   __u64 bp_len ;
   __u64 kprobe_addr ;
   __u64 probe_offset ;
   __u64 config2 ;
};
#line 312  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/perf_event.h"
struct perf_event_attr {
   __u32 type ;
   __u32 size ;
   __u64 config ;
   union __anonunion_8968 __anonCompField_perf_event_attr_228 ;
   __u64 sample_type ;
   __u64 read_format ;
   __u64 disabled : 1 ;
   __u64 inherit : 1 ;
   __u64 pinned : 1 ;
   __u64 exclusive : 1 ;
   __u64 exclude_user : 1 ;
   __u64 exclude_kernel : 1 ;
   __u64 exclude_hv : 1 ;
   __u64 exclude_idle : 1 ;
   __u64 mmap : 1 ;
   __u64 comm : 1 ;
   __u64 freq : 1 ;
   __u64 inherit_stat : 1 ;
   __u64 enable_on_exec : 1 ;
   __u64 task : 1 ;
   __u64 watermark : 1 ;
   __u64 precise_ip : 2 ;
   __u64 mmap_data : 1 ;
   __u64 sample_id_all : 1 ;
   __u64 exclude_host : 1 ;
   __u64 exclude_guest : 1 ;
   __u64 exclude_callchain_kernel : 1 ;
   __u64 exclude_callchain_user : 1 ;
   __u64 mmap2 : 1 ;
   __u64 comm_exec : 1 ;
   __u64 use_clockid : 1 ;
   __u64 context_switch : 1 ;
   __u64 write_backward : 1 ;
   __u64 namespaces : 1 ;
   __u64 ksymbol : 1 ;
   __u64 bpf_event : 1 ;
   __u64 aux_output : 1 ;
   __u64 __reserved_1 : 32 ;
   union __anonunion_8969 __anonCompField_perf_event_attr_229 ;
   __u32 bp_type ;
   union __anonunion_8970 __anonCompField_perf_event_attr_230 ;
   union __anonunion_8971 __anonCompField_perf_event_attr_231 ;
   __u64 branch_sample_type ;
   __u64 sample_regs_user ;
   __u32 sample_stack_user ;
   __s32 clockid ;
   __u64 sample_regs_intr ;
   __u32 aux_watermark ;
   __u16 sample_max_stack ;
   __u16 __reserved_2 ;
   __u32 aux_sample_size ;
   __u32 __reserved_3 ;
};
#line 1056  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/perf_event.h"
struct __anonstruct_8974 {
   __u64 mem_op : 5 ;
   __u64 mem_lvl : 14 ;
   __u64 mem_snoop : 5 ;
   __u64 mem_lock : 2 ;
   __u64 mem_dtlb : 7 ;
   __u64 mem_lvl_num : 4 ;
   __u64 mem_remote : 1 ;
   __u64 mem_snoopx : 2 ;
   __u64 mem_rsvd : 24 ;
};
#line 1056  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/perf_event.h"
union perf_mem_data_src {
   __u64 val ;
   struct __anonstruct_8974 __anonCompField_perf_mem_data_src_234 ;
};
#line 1176  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/perf_event.h"
struct perf_branch_entry {
   __u64 from ;
   __u64 to ;
   __u64 mispred : 1 ;
   __u64 predicted : 1 ;
   __u64 in_tx : 1 ;
   __u64 abort : 1 ;
   __u64 cycles : 16 ;
   __u64 type : 4 ;
   __u64 reserved : 40 ;
};
#line 1187 
struct fs_pin;
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pid_namespace.h"
struct pid_namespace {
   struct kref kref ;
   struct idr idr ;
   struct callback_head rcu ;
   unsigned int pid_allocated ;
   struct task_struct *child_reaper ;
   struct kmem_cache *pid_cachep ;
   unsigned int level ;
   struct pid_namespace *parent ;
   struct vfsmount *proc_mnt ;
   struct dentry *proc_self ;
   struct dentry *proc_thread_self ;
   struct fs_pin *bacct ;
   struct user_namespace *user_ns ;
   struct ucounts *ucounts ;
   struct work_struct proc_work ;
   kgid_t pid_gid ;
   int hide_pid ;
   int reboot ;
   struct ns_common ns ;
} __attribute__((__designated_init__));
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/hw_breakpoint.h"
struct arch_hw_breakpoint {
   unsigned long address ;
   unsigned long mask ;
   u8 len ;
   u8 type ;
};
#line 51 
struct pmu;
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ftrace.h"
struct ftrace_hash;
#line 85 
struct ftrace_ops;
#line 174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ftrace.h"
struct ftrace_ops_hash {
   struct ftrace_hash *notrace_hash ;
   struct ftrace_hash *filter_hash ;
   struct mutex regex_lock ;
};
#line 198  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ftrace.h"
struct ftrace_ops {
   void (*func)(unsigned long , unsigned long , struct ftrace_ops *, struct pt_regs *) ;
   struct ftrace_ops *next ;
   unsigned long flags ;
   void *private ;
   void (*saved_func)(unsigned long , unsigned long , struct ftrace_ops *, struct pt_regs *) ;
   struct ftrace_ops_hash local_hash ;
   struct ftrace_ops_hash *func_hash ;
   struct ftrace_ops_hash old_hash ;
   unsigned long trampoline ;
   unsigned long trampoline_size ;
};
#line 869  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ftrace.h"
struct ftrace_ret_stack {
   unsigned long ret ;
   unsigned long func ;
   unsigned long long calltime ;
   unsigned long long subtime ;
   unsigned long *retp ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/irq_work.h"
struct irq_work {
   atomic_t flags ;
   struct llist_node llnode ;
   void (*func)(struct irq_work *) ;
};
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_regs.h"
struct perf_regs {
   __u64 abi ;
   struct pt_regs *regs ;
};
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct perf_callchain_entry {
   __u64 nr ;
   __u64 ip[0U] ;
};
#line 78  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
union __anonunion_8994 {
   struct perf_raw_frag *next ;
   unsigned long pad ;
};
#line 78  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct perf_raw_frag {
   union __anonunion_8994 __anonCompField_perf_raw_frag_236 ;
   unsigned long (*copy)(void *, void *, unsigned long , unsigned long ) ;
   void *data ;
   u32 size ;
} __attribute__((__packed__));
#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct perf_raw_record {
   struct perf_raw_frag frag ;
   u32 size ;
};
#line 102  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct perf_branch_stack {
   __u64 nr ;
   struct perf_branch_entry entries[0U] ;
};
#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct hw_perf_event_extra {
   u64 config ;
   unsigned int reg ;
   int alloc ;
   int idx ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct __anonstruct_8996 {
   u64 config ;
   u64 last_tag ;
   unsigned long config_base ;
   unsigned long event_base ;
   int event_base_rdpmc ;
   int idx ;
   int last_cpu ;
   int flags ;
   struct hw_perf_event_extra extra_reg ;
   struct hw_perf_event_extra branch_reg ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct __anonstruct_8997 {
   struct hrtimer hrtimer ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct __anonstruct_8998 {
   struct list_head tp_list ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct __anonstruct_8999 {
   u64 pwr_acc ;
   u64 ptsc ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct __anonstruct_9000 {
   struct arch_hw_breakpoint info ;
   struct list_head bp_list ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct __anonstruct_9001 {
   u8 iommu_bank ;
   u8 iommu_cntr ;
   u16 padding ;
   u64 conf ;
   u64 conf1 ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
union __anonunion_8995 {
   struct __anonstruct_8996 __anonCompField___anonunion_8995_237 ;
   struct __anonstruct_8997 __anonCompField___anonunion_8995_238 ;
   struct __anonstruct_8998 __anonCompField___anonunion_8995_239 ;
   struct __anonstruct_8999 __anonCompField___anonunion_8995_240 ;
   struct __anonstruct_9000 __anonCompField___anonunion_8995_241 ;
   struct __anonstruct_9001 __anonCompField___anonunion_8995_242 ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct hw_perf_event {
   union __anonunion_8995 __anonCompField_hw_perf_event_243 ;
   struct task_struct *target ;
   void *addr_filters ;
   unsigned long addr_filters_gen ;
   int state ;
   local64_t prev_count ;
   u64 sample_period ;
   u64 last_period ;
   local64_t period_left ;
   u64 interrupts_seq ;
   u64 interrupts ;
   u64 freq_time_stamp ;
   u64 freq_count_stamp ;
};
#line 229 
struct perf_output_handle;
#line 257 
struct perf_cpu_context;
#line 257  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct pmu {
   struct list_head entry ;
   struct module *module ;
   struct device *dev ;
   struct attribute_group **attr_groups ;
   struct attribute_group **attr_update ;
   char *name ;
   int type ;
   int capabilities ;
   int *pmu_disable_count ;
   struct perf_cpu_context *pmu_cpu_context ;
   atomic_t exclusive_cnt ;
   int task_ctx_nr ;
   int hrtimer_interval_ms ;
   unsigned int nr_addr_filters ;
   void (*pmu_enable)(struct pmu *) ;
   void (*pmu_disable)(struct pmu *) ;
   int (*event_init)(struct perf_event *) ;
   void (*event_mapped)(struct perf_event *, struct mm_struct *) ;
   void (*event_unmapped)(struct perf_event *, struct mm_struct *) ;
   int (*add)(struct perf_event *, int ) ;
   void (*del)(struct perf_event *, int ) ;
   void (*start)(struct perf_event *, int ) ;
   void (*stop)(struct perf_event *, int ) ;
   void (*read)(struct perf_event *) ;
   void (*start_txn)(struct pmu *, unsigned int ) ;
   int (*commit_txn)(struct pmu *) ;
   void (*cancel_txn)(struct pmu *) ;
   int (*event_idx)(struct perf_event *) ;
   void (*sched_task)(struct perf_event_context *, bool ) ;
   size_t task_ctx_size ;
   void (*swap_task_ctx)(struct perf_event_context *, struct perf_event_context *) ;
   void *(*setup_aux)(struct perf_event *, void **, int , bool ) ;
   void (*free_aux)(void *) ;
   long (*snapshot_aux)(struct perf_event *, struct perf_output_handle *, unsigned long ) ;
   int (*addr_filters_validate)(struct list_head *) ;
   void (*addr_filters_sync)(struct perf_event *) ;
   int (*aux_output_match)(struct perf_event *) ;
   int (*filter_match)(struct perf_event *) ;
   int (*check_period)(struct perf_event *, u64 ) ;
};
#line 530  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct perf_addr_filters_head {
   struct list_head list ;
   raw_spinlock_t lock ;
   unsigned int nr_file_filters ;
};
#line 536  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct perf_addr_filter_range {
   unsigned long start ;
   unsigned long size ;
};
#line 540 
enum perf_event_state {
    PERF_EVENT_STATE_DEAD = -4,
    PERF_EVENT_STATE_EXIT = -3,
    PERF_EVENT_STATE_ERROR = -2,
    PERF_EVENT_STATE_OFF = -1,
    PERF_EVENT_STATE_INACTIVE = 0,
    PERF_EVENT_STATE_ACTIVE = 1
};
#line 549 
struct perf_sample_data;
#line 577 
struct perf_cgroup;
#line 599 
struct event_filter;
#line 599  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct perf_event {
   struct list_head event_entry ;
   struct list_head sibling_list ;
   struct list_head active_list ;
   struct rb_node group_node ;
   u64 group_index ;
   struct list_head migrate_entry ;
   struct hlist_node hlist_entry ;
   struct list_head active_entry ;
   int nr_siblings ;
   int event_caps ;
   int group_caps ;
   struct perf_event *group_leader ;
   struct pmu *pmu ;
   void *pmu_private ;
   enum perf_event_state state ;
   unsigned int attach_state ;
   local64_t count ;
   atomic64_t child_count ;
   u64 total_time_enabled ;
   u64 total_time_running ;
   u64 tstamp ;
   u64 shadow_ctx_time ;
   struct perf_event_attr attr ;
   u16 header_size ;
   u16 id_header_size ;
   u16 read_size ;
   struct hw_perf_event hw ;
   struct perf_event_context *ctx ;
   atomic_long_t refcount ;
   atomic64_t child_total_time_enabled ;
   atomic64_t child_total_time_running ;
   struct mutex child_mutex ;
   struct list_head child_list ;
   struct perf_event *parent ;
   int oncpu ;
   int cpu ;
   struct list_head owner_entry ;
   struct task_struct *owner ;
   struct mutex mmap_mutex ;
   atomic_t mmap_count ;
   struct ring_buffer *rb ;
   struct list_head rb_entry ;
   unsigned long rcu_batches ;
   int rcu_pending ;
   wait_queue_head_t waitq ;
   struct fasync_struct *fasync ;
   int pending_wakeup ;
   int pending_kill ;
   int pending_disable ;
   struct irq_work pending ;
   atomic_t event_limit ;
   struct perf_addr_filters_head addr_filters ;
   struct perf_addr_filter_range *addr_filter_ranges ;
   unsigned long addr_filters_gen ;
   struct perf_event *aux_event ;
   void (*destroy)(struct perf_event *) ;
   struct callback_head callback_head ;
   struct pid_namespace *ns ;
   u64 id ;
   u64 (*clock)(void) ;
   void (*overflow_handler)(struct perf_event *, struct perf_sample_data *, struct pt_regs *) ;
   void *overflow_handler_context ;
   void (*orig_overflow_handler)(struct perf_event *, struct perf_sample_data *, struct pt_regs *) ;
   struct bpf_prog *prog ;
   struct trace_event_call *tp_event ;
   struct event_filter *filter ;
   struct ftrace_ops ftrace_ops ;
   struct perf_cgroup *cgrp ;
   void *security ;
   struct list_head sb_list ;
};
#line 757  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct perf_event_groups {
   struct rb_root tree ;
   u64 index ;
};
#line 767  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct perf_event_context {
   struct pmu *pmu ;
   raw_spinlock_t lock ;
   struct mutex mutex ;
   struct list_head active_ctx_list ;
   struct perf_event_groups pinned_groups ;
   struct perf_event_groups flexible_groups ;
   struct list_head event_list ;
   struct list_head pinned_active ;
   struct list_head flexible_active ;
   int nr_events ;
   int nr_active ;
   int is_active ;
   int nr_stat ;
   int nr_freq ;
   int rotate_disable ;
   int rotate_necessary ;
   refcount_t refcount ;
   struct task_struct *task ;
   u64 time ;
   u64 timestamp ;
   struct perf_event_context *parent_ctx ;
   u64 parent_gen ;
   u64 generation ;
   int pin_count ;
   int nr_cgroups ;
   void *task_ctx_data ;
   struct callback_head callback_head ;
};
#line 833  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct perf_cpu_context {
   struct perf_event_context ctx ;
   struct perf_event_context *task_ctx ;
   int active_oncpu ;
   int exclusive ;
   raw_spinlock_t hrtimer_lock ;
   struct hrtimer hrtimer ;
   ktime_t hrtimer_interval ;
   unsigned int hrtimer_active ;
   struct perf_cgroup *cgrp ;
   struct list_head cgrp_cpuctx_entry ;
   struct list_head sched_cb_entry ;
   int sched_cb_usage ;
   int online ;
};
#line 855  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
union __anonunion_9002 {
   void *addr ;
   unsigned long head ;
};
#line 855  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct perf_output_handle {
   struct perf_event *event ;
   struct ring_buffer *rb ;
   unsigned long wakeup ;
   unsigned long size ;
   u64 aux_flags ;
   union __anonunion_9002 __anonCompField_perf_output_handle_244 ;
   int page ;
};
#line 880  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct perf_cgroup_info {
   u64 time ;
   u64 timestamp ;
};
#line 885  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct perf_cgroup {
   struct cgroup_subsys_state css ;
   struct perf_cgroup_info *info ;
};
#line 960  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct __anonstruct_tid_entry_9005 {
   u32 pid ;
   u32 tid ;
};
#line 960  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct __anonstruct_cpu_entry_9006 {
   u32 cpu ;
   u32 reserved ;
};
#line 960  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/perf_event.h"
struct perf_sample_data {
   u64 addr ;
   struct perf_raw_record *raw ;
   struct perf_branch_stack *br_stack ;
   u64 period ;
   u64 weight ;
   u64 txn ;
   union perf_mem_data_src data_src ;
   u64 type ;
   u64 ip ;
   struct __anonstruct_tid_entry_9005 tid_entry ;
   u64 time ;
   u64 id ;
   u64 stream_id ;
   struct __anonstruct_cpu_entry_9006 cpu_entry ;
   struct perf_callchain_entry *callchain ;
   u64 aux_size ;
   struct perf_regs regs_user ;
   struct pt_regs regs_user_copy ;
   struct perf_regs regs_intr ;
   u64 stack_user_size ;
   u64 phys_addr ;
} __attribute__((__aligned__(64)));
#line 1542 
struct trace_array;
#line 1543 
struct trace_buffer;
#line 1544 
struct tracer;
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/trace_events.h"
struct trace_iterator;
#line 51 
struct trace_event;
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/trace_events.h"
struct trace_entry {
   unsigned short type ;
   unsigned char flags ;
   unsigned char preempt_count ;
   int pid ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/trace_events.h"
struct trace_iterator {
   struct trace_array *tr ;
   struct tracer *trace ;
   struct trace_buffer *trace_buffer ;
   void *private ;
   int cpu_file ;
   struct mutex mutex ;
   struct ring_buffer_iter **buffer_iter ;
   unsigned long iter_flags ;
   struct trace_seq tmp_seq ;
   cpumask_var_t started ;
   bool snapshot ;
   struct trace_seq seq ;
   struct trace_entry *ent ;
   unsigned long lost_events ;
   int leftover ;
   int ent_size ;
   int cpu ;
   u64 ts ;
   loff_t pos ;
   long idx ;
};
#line 115 
enum print_line_t;
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/trace_events.h"
struct trace_event_functions {
   enum print_line_t (*trace)(struct trace_iterator *, int , struct trace_event *) ;
   enum print_line_t (*raw)(struct trace_iterator *, int , struct trace_event *) ;
   enum print_line_t (*hex)(struct trace_iterator *, int , struct trace_event *) ;
   enum print_line_t (*binary)(struct trace_iterator *, int , struct trace_event *) ;
};
#line 129  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/trace_events.h"
struct trace_event {
   struct hlist_node node ;
   struct list_head list ;
   int type ;
   struct trace_event_functions *funcs ;
};
#line 138 
enum print_line_t {
    TRACE_TYPE_PARTIAL_LINE = 0,
    TRACE_TYPE_HANDLED = 1,
    TRACE_TYPE_UNHANDLED = 2,
    TRACE_TYPE_NO_CONSUME = 3
};
#line 172 
enum trace_reg {
    TRACE_REG_REGISTER = 0,
    TRACE_REG_UNREGISTER = 1,
    TRACE_REG_PERF_REGISTER = 2,
    TRACE_REG_PERF_UNREGISTER = 3,
    TRACE_REG_PERF_OPEN = 4,
    TRACE_REG_PERF_CLOSE = 5,
    TRACE_REG_PERF_ADD = 6,
    TRACE_REG_PERF_DEL = 7
};
#line 195  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/trace_events.h"
struct trace_event_class {
   char *system ;
   void *probe ;
   void *perf_probe ;
   int (*reg)(struct trace_event_call *, enum trace_reg , void *) ;
   int (*define_fields)(struct trace_event_call *) ;
   struct list_head *(*get_fields)(struct trace_event_call *) ;
   struct list_head fields ;
   int (*raw_init)(struct trace_event_call *) ;
};
#line 259  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/trace_events.h"
union __anonunion_9007 {
   char *name ;
   struct tracepoint *tp ;
};
#line 259  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/trace_events.h"
struct trace_event_call {
   struct list_head list ;
   struct trace_event_class *class ;
   union __anonunion_9007 __anonCompField_trace_event_call_245 ;
   struct trace_event event ;
   char *print_fmt ;
   struct event_filter *filter ;
   void *mod ;
   void *data ;
   int flags ;
   int perf_refcount ;
   struct hlist_head *perf_events ;
   struct bpf_prog_array *prog_array ;
   int (*perf_perm)(struct trace_event_call *, struct perf_event *) ;
};
#line 455  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
union __anonunion___u_9011 {
   struct i40e_ring *__val ;
   char __c[1U] ;
};
#line 808  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
union __anonunion___u_9013 {
   struct i40e_ring *__val ;
   char __c[1U] ;
};
#line 10422  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
union __anonunion___u_9842 {
   u16 __val ;
   char __c[1U] ;
};
#line 10423  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
union __anonunion___u_9844 {
   u8 __val ;
   char __c[1U] ;
};
#line 10424  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
union __anonunion___u_9846 {
   u8 __val ;
   char __c[1U] ;
};
#line 12557  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
union __anonunion___u_9849 {
   struct bpf_prog *__val ;
   char __c[1U] ;
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_9864 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_9866 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 268  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_9868 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 31  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/device.h"
struct firmware;
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 1538  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_metadata_segment {
   struct i40e_generic_seg_header header ;
   struct i40e_ddp_version version ;
   u32 track_id ;
   char name[32U] ;
};
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_ddp_profile_list {
   u32 p_count ;
   struct i40e_profile_info p_info[0U] ;
};
#line 340  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_ddp_old_profile_list {
   struct list_head list ;
   size_t old_ddp_size ;
   u8 old_ddp_buf[0U] ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/firmware.h"
struct firmware {
   size_t size ;
   u8 *data ;
   struct page **pages ;
   void *priv ;
};
#line 368  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
enum i40e_nvmupd_cmd {
    I40E_NVMUPD_INVALID = 0,
    I40E_NVMUPD_READ_CON = 1,
    I40E_NVMUPD_READ_SNT = 2,
    I40E_NVMUPD_READ_LCB = 3,
    I40E_NVMUPD_READ_SA = 4,
    I40E_NVMUPD_WRITE_ERA = 5,
    I40E_NVMUPD_WRITE_CON = 6,
    I40E_NVMUPD_WRITE_SNT = 7,
    I40E_NVMUPD_WRITE_LCB = 8,
    I40E_NVMUPD_WRITE_SA = 9,
    I40E_NVMUPD_CSUM_CON = 10,
    I40E_NVMUPD_CSUM_SA = 11,
    I40E_NVMUPD_CSUM_LCB = 12,
    I40E_NVMUPD_STATUS = 13,
    I40E_NVMUPD_EXEC_AQ = 14,
    I40E_NVMUPD_GET_AQ_RESULT = 15,
    I40E_NVMUPD_GET_AQ_EVENT = 16
};
#line 430  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_nvm_access {
   u32 command ;
   u32 config ;
   u32 offset ;
   u32 data_size ;
   u8 data[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 242  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
union __anonunion___u_13076 {
   struct i40e_ring *__val ;
   char __c[1U] ;
};
#line 285  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
union __anonunion___u_13078 {
   struct i40e_ring *__val ;
   char __c[1U] ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_osdep.h"
enum i40e_status_code;
#line 2586  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_cee_dcb_cfg_v1_resp {
   u8 reserved1 ;
   u8 oper_num_tc ;
   u8 oper_prio_tc[4U] ;
   u8 reserved2 ;
   u8 oper_tc_bw[8U] ;
   u8 oper_pfc_en ;
   u8 reserved3[2U] ;
   __le16 oper_app_prio ;
   u8 reserved4[2U] ;
   __le16 tlv_status ;
};
#line 2601  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h"
struct i40e_aqc_get_cee_dcb_cfg_resp {
   u8 oper_num_tc ;
   u8 oper_prio_tc[4U] ;
   u8 oper_tc_bw[8U] ;
   u8 oper_pfc_en ;
   __le16 oper_app_prio ;
   __le32 tlv_status ;
   u8 reserved[12U] ;
};
#line 1450  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
struct i40e_lldp_variables {
   u16 length ;
   u16 adminstatus ;
   u16 msgfasttx ;
   u16 msgtxinterval ;
   u16 txparams ;
   u16 timers ;
   u16 crc8 ;
};
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.h"
struct i40e_lldp_org_tlv {
   __be16 typelength ;
   __be32 ouisubtype ;
   u8 tlvinfo[1U] ;
};
#line 93  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.h"
struct i40e_cee_tlv_hdr {
   __be16 typelen ;
   u8 operver ;
   u8 maxver ;
};
#line 105  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.h"
struct i40e_cee_feat_tlv {
   struct i40e_cee_tlv_hdr hdr ;
   u8 en_will_err ;
   u8 subtype ;
   u8 tlvinfo[1U] ;
};
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.h"
struct i40e_cee_app_prio {
   __be16 protocol ;
   u8 upper_oui_sel ;
   __be16 lower_oui ;
   u8 prio_map ;
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_15075 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_15077 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 201  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};
#line 878  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_device {
   struct list_head list ;
   struct i40e_pf *pf ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 550  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
union __anonunion___u_16851 {
   unsigned long __val ;
   char __c[1U] ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/trace/events/xdp.h"
union __anonunion___u_16973 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/trace/events/xdp.h"
union __anonunion___u_16975 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 100  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_xdp.h"
struct xdp_desc {
   __u64 addr ;
   __u32 len ;
   __u32 options ;
};
#line 1155  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
union __anonunion___u_17342 {
   struct bpf_prog *__val ;
   char __c[1U] ;
};
#line 204  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
union __anonunion___u_17344 {
   struct bpf_prog *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/export.h"
typedef __builtin_va_list __gnuc_va_list;
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/usr/lib/gcc/x86_64-linux-gnu/6/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_18472 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_18474 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 268  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_18476 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 762  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_18480 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 788  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_18482 {
   struct hlist_node *__val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 212  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
struct i40e_rx_flow_userdef {
   bool flex_filter ;
   u16 flex_word ;
   u16 flex_offset ;
};
#line 1155  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
union __anonunion___u_19574 {
   struct bpf_prog *__val ;
   char __c[1U] ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
struct i40e_stats {
   char stat_string[32U] ;
   int sizeof_stat ;
   int stat_offset ;
};
#line 361  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
struct i40e_pfc_stats {
   u64 priority_xon_rx ;
   u64 priority_xoff_rx ;
   u64 priority_xon_tx ;
   u64 priority_xoff_tx ;
   u64 priority_xon_2_xoff ;
};
#line 416  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
struct i40e_priv_flags {
   char flag_string[32U] ;
   u64 flag ;
   bool read_only ;
};
#line 1382  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
union __anonunion___u_19577 {
   u32 __val ;
   char __c[1U] ;
};
#line 2274  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
union __anonunion___u_19597 {
   struct i40e_ring *__val ;
   char __c[1U] ;
};
#line 2275  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
union __anonunion___u_19599 {
   struct i40e_ring *__val ;
   char __c[1U] ;
};
#line 4881  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
union __anonunion___u_19616 {
   u32 __val ;
   char __c[1U] ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 197 
enum hrtimer_restart;
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
struct device_private {
   void *driver_data ;
};
#line 164  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned long irq_hw_number_t;
#line 303  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ioport.h"
struct irq_data;
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/idr.h"
struct ida {
   struct xarray xa ;
};
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/irqdomain.h"
struct irq_fwspec {
   struct fwnode_handle *fwnode ;
   int param_count ;
   u32 param[16U] ;
};
#line 68 
enum irq_domain_bus_token {
    DOMAIN_BUS_ANY = 0,
    DOMAIN_BUS_WIRED = 1,
    DOMAIN_BUS_GENERIC_MSI = 2,
    DOMAIN_BUS_PCI_MSI = 3,
    DOMAIN_BUS_PLATFORM_MSI = 4,
    DOMAIN_BUS_NEXUS = 5,
    DOMAIN_BUS_IPI = 6,
    DOMAIN_BUS_FSL_MC_MSI = 7,
    DOMAIN_BUS_TI_SCI_INTA_MSI = 8,
    DOMAIN_BUS_WAKEUP = 9
};
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/irqdomain.h"
struct irq_domain_ops {
   int (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token ) ;
   int (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token ) ;
   int (*map)(struct irq_domain *, unsigned int , irq_hw_number_t ) ;
   void (*unmap)(struct irq_domain *, unsigned int ) ;
   int (*xlate)(struct irq_domain *, struct device_node *, u32 *, unsigned int , unsigned long *, unsigned int *) ;
   int (*alloc)(struct irq_domain *, unsigned int , unsigned int , void *) ;
   void (*free)(struct irq_domain *, unsigned int , unsigned int ) ;
   int (*activate)(struct irq_domain *, struct irq_data *, bool ) ;
   void (*deactivate)(struct irq_domain *, struct irq_data *) ;
   int (*translate)(struct irq_domain *, struct irq_fwspec *, unsigned long *, unsigned int *) ;
   void (*debug_show)(struct seq_file *, struct irq_domain *, struct irq_data *, int ) ;
};
#line 132 
struct irq_domain_chip_generic;
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/irqdomain.h"
struct irq_domain {
   struct list_head link ;
   char *name ;
   struct irq_domain_ops *ops ;
   void *host_data ;
   unsigned int flags ;
   unsigned int mapcount ;
   struct fwnode_handle *fwnode ;
   enum irq_domain_bus_token bus_token ;
   struct irq_domain_chip_generic *gc ;
   struct irq_domain *parent ;
   struct dentry *debugfs_file ;
   irq_hw_number_t hwirq_max ;
   unsigned int revmap_direct_max_irq ;
   unsigned int revmap_size ;
   struct xarray revmap_tree ;
   struct mutex revmap_tree_mutex ;
   unsigned int linear_revmap[] ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rtmutex.h"
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct rb_root_cached waiters ;
   struct task_struct *owner ;
   int save_state ;
   char *name ;
   char *file ;
   int line ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/i2c.h"
struct i2c_msg {
   __u16 addr ;
   __u16 flags ;
   __u16 len ;
   __u8 *buf ;
};
#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/i2c.h"
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34U] ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_algorithm;
#line 28 
struct i2c_adapter;
#line 29 
struct i2c_client;
#line 33 
enum i2c_slave_event;
#line 33 
enum i2c_slave_event;
#line 314  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_client {
   unsigned short flags ;
   unsigned short addr ;
   char name[20U] ;
   struct i2c_adapter *adapter ;
   struct device dev ;
   int init_irq ;
   int irq ;
   struct list_head detected ;
   int (*slave_cb)(struct i2c_client *, enum i2c_slave_event , u8 *) ;
};
#line 360 
enum i2c_slave_event {
    I2C_SLAVE_READ_REQUESTED = 0,
    I2C_SLAVE_WRITE_REQUESTED = 1,
    I2C_SLAVE_READ_PROCESSED = 2,
    I2C_SLAVE_WRITE_RECEIVED = 3,
    I2C_SLAVE_STOP = 4
};
#line 527  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_algorithm {
   int (*master_xfer)(struct i2c_adapter *, struct i2c_msg *, int ) ;
   int (*master_xfer_atomic)(struct i2c_adapter *, struct i2c_msg *, int ) ;
   int (*smbus_xfer)(struct i2c_adapter *, u16 , unsigned short , char , u8 , int , union i2c_smbus_data *) ;
   int (*smbus_xfer_atomic)(struct i2c_adapter *, u16 , unsigned short , char , u8 , int , union i2c_smbus_data *) ;
   u32 (*functionality)(struct i2c_adapter *) ;
   int (*reg_slave)(struct i2c_client *) ;
   int (*unreg_slave)(struct i2c_client *) ;
};
#line 565  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_lock_operations {
   void (*lock_bus)(struct i2c_adapter *, unsigned int ) ;
   int (*trylock_bus)(struct i2c_adapter *, unsigned int ) ;
   void (*unlock_bus)(struct i2c_adapter *, unsigned int ) ;
};
#line 618  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_bus_recovery_info {
   int (*recover_bus)(struct i2c_adapter *) ;
   int (*get_scl)(struct i2c_adapter *) ;
   void (*set_scl)(struct i2c_adapter *, int ) ;
   int (*get_sda)(struct i2c_adapter *) ;
   void (*set_sda)(struct i2c_adapter *, int ) ;
   int (*get_bus_free)(struct i2c_adapter *) ;
   void (*prepare_recovery)(struct i2c_adapter *) ;
   void (*unprepare_recovery)(struct i2c_adapter *) ;
   struct gpio_desc *scl_gpiod ;
   struct gpio_desc *sda_gpiod ;
};
#line 661  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_adapter_quirks {
   u64 flags ;
   int max_num_msgs ;
   u16 max_write_len ;
   u16 max_read_len ;
   u16 max_comb_1st_msg_len ;
   u16 max_comb_2nd_msg_len ;
};
#line 692  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_adapter {
   struct module *owner ;
   unsigned int class ;
   struct i2c_algorithm *algo ;
   void *algo_data ;
   struct i2c_lock_operations *lock_ops ;
   struct rt_mutex bus_lock ;
   struct rt_mutex mux_lock ;
   int timeout ;
   int retries ;
   struct device dev ;
   unsigned long locked_flags ;
   int nr ;
   char name[48U] ;
   struct completion dev_released ;
   struct mutex userspace_clients_lock ;
   struct list_head userspace_clients ;
   struct i2c_bus_recovery_info *bus_recovery_info ;
   struct i2c_adapter_quirks *quirks ;
   struct irq_domain *host_notify_domain ;
};
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-common.h"
struct v4l2_edid {
   __u32 pad ;
   __u32 start_block ;
   __u32 blocks ;
   __u32 reserved[5U] ;
   __u8 *edid ;
};
#line 754 
enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
    V4L2_PRIORITY_DEFAULT = 2
};
#line 413  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_rect {
   __s32 left ;
   __s32 top ;
   __u32 width ;
   __u32 height ;
};
#line 420  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_fract {
   __u32 numerator ;
   __u32 denominator ;
};
#line 1212  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
typedef __u64 v4l2_std_id;
#line 1394  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_bt_timings {
   __u32 width ;
   __u32 height ;
   __u32 interlaced ;
   __u32 polarities ;
   __u64 pixelclock ;
   __u32 hfrontporch ;
   __u32 hsync ;
   __u32 hbackporch ;
   __u32 vfrontporch ;
   __u32 vsync ;
   __u32 vbackporch ;
   __u32 il_vfrontporch ;
   __u32 il_vsync ;
   __u32 il_vbackporch ;
   __u32 standards ;
   __u32 flags ;
   struct v4l2_fract picture_aspect ;
   __u8 cea861_vic ;
   __u8 hdmi_vic ;
   __u8 reserved[46U] ;
} __attribute__((__packed__));
#line 1517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
union __anonunion_21395 {
   struct v4l2_bt_timings bt ;
   __u32 reserved[32U] ;
};
#line 1517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_dv_timings {
   __u32 type ;
   union __anonunion_21395 __anonCompField_v4l2_dv_timings_77 ;
} __attribute__((__packed__));
#line 1536  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_enum_dv_timings {
   __u32 index ;
   __u32 pad ;
   __u32 reserved[2U] ;
   struct v4l2_dv_timings timings ;
};
#line 1554  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_bt_timings_cap {
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u64 min_pixelclock ;
   __u64 max_pixelclock ;
   __u32 standards ;
   __u32 capabilities ;
   __u32 reserved[16U] ;
} __attribute__((__packed__));
#line 1581  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
union __anonunion_21396 {
   struct v4l2_bt_timings_cap bt ;
   __u32 raw_data[32U] ;
};
#line 1581  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_dv_timings_cap {
   __u32 type ;
   __u32 pad ;
   __u32 reserved[2U] ;
   union __anonunion_21396 __anonCompField_v4l2_dv_timings_cap_78 ;
};
#line 1803  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_tuner {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 rxsubchans ;
   __u32 audmode ;
   __s32 signal ;
   __s32 afc ;
   __u32 reserved[4U] ;
};
#line 1817  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_modulator {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 txsubchans ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 1860  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_frequency {
   __u32 tuner ;
   __u32 type ;
   __u32 frequency ;
   __u32 reserved[8U] ;
};
#line 1871  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_frequency_band {
   __u32 tuner ;
   __u32 type ;
   __u32 index ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 modulation ;
   __u32 reserved[9U] ;
};
#line 2043  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_vbi_format {
   __u32 sampling_rate ;
   __u32 offset ;
   __u32 samples_per_line ;
   __u32 sample_format ;
   __s32 start[2U] ;
   __u32 count[2U] ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 2071  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_format {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 io_size ;
   __u32 reserved[2U] ;
};
#line 2095  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_cap {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 2106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_data {
   __u32 id ;
   __u32 field ;
   __u32 line ;
   __u32 reserved ;
   __u8 data[48U] ;
};
#line 2350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_event_subscription {
   __u32 type ;
   __u32 id ;
   __u32 flags ;
   __u32 reserved[5U] ;
};
#line 2375  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
union __anonunion_21412 {
   __u32 addr ;
   char name[32U] ;
};
#line 2375  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_dbg_match {
   __u32 type ;
   union __anonunion_21412 __anonCompField_v4l2_dbg_match_87 ;
} __attribute__((__packed__));
#line 2383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_dbg_register {
   struct v4l2_dbg_match match ;
   __u32 size ;
   __u64 reg ;
   __u64 val ;
} __attribute__((__packed__));
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_device;
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_gobj {
   struct media_device *mdev ;
   u32 id ;
   struct list_head list ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_entity_enum {
   unsigned long *bmap ;
   int idx_max ;
};
#line 88 
struct media_entity;
#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct __anonstruct_stack_21416 {
   struct media_entity *entity ;
   struct list_head *link ;
};
#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_graph {
   struct __anonstruct_stack_21416 stack[16U] ;
   struct media_entity_enum ent_enum ;
   int top ;
};
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_pipeline {
   int streaming_count ;
   struct media_graph graph ;
};
#line 132 
struct media_pad;
#line 132 
struct media_interface;
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
union __anonunion_21417 {
   struct media_gobj *gobj0 ;
   struct media_pad *source ;
   struct media_interface *intf ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
union __anonunion_21418 {
   struct media_gobj *gobj1 ;
   struct media_pad *sink ;
   struct media_entity *entity ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_link {
   struct media_gobj graph_obj ;
   struct list_head list ;
   union __anonunion_21417 __anonCompField_media_link_90 ;
   union __anonunion_21418 __anonCompField_media_link_91 ;
   struct media_link *reverse ;
   unsigned long flags ;
   bool is_backlink ;
};
#line 149 
enum media_pad_signal_type {
    PAD_SIGNAL_DEFAULT = 0,
    PAD_SIGNAL_ANALOG = 1,
    PAD_SIGNAL_DV = 2,
    PAD_SIGNAL_AUDIO = 3
};
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_pad {
   struct media_gobj graph_obj ;
   struct media_entity *entity ;
   u16 index ;
   enum media_pad_signal_type sig_type ;
   unsigned long flags ;
};
#line 214  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_entity_operations {
   int (*get_fwnode_pad)(struct fwnode_endpoint *) ;
   int (*link_setup)(struct media_entity *, struct media_pad *, struct media_pad *, u32 ) ;
   int (*link_validate)(struct media_link *) ;
};
#line 221 
enum media_entity_type {
    MEDIA_ENTITY_TYPE_BASE = 0,
    MEDIA_ENTITY_TYPE_VIDEO_DEVICE = 1,
    MEDIA_ENTITY_TYPE_V4L2_SUBDEV = 2
};
#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct __anonstruct_dev_21420 {
   u32 major ;
   u32 minor ;
};
#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
union __anonunion_info_21419 {
   struct __anonstruct_dev_21420 dev ;
};
#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_entity {
   struct media_gobj graph_obj ;
   char *name ;
   enum media_entity_type obj_type ;
   u32 function ;
   unsigned long flags ;
   u16 num_pads ;
   u16 num_links ;
   u16 num_backlinks ;
   int internal_idx ;
   struct media_pad *pads ;
   struct list_head links ;
   struct media_entity_operations *ops ;
   int stream_count ;
   int use_count ;
   struct media_pipeline *pipe ;
   union __anonunion_info_21419 info ;
};
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_interface {
   struct media_gobj graph_obj ;
   struct list_head links ;
   u32 type ;
   u32 flags ;
};
#line 349  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_intf_devnode {
   struct media_interface intf ;
   u32 major ;
   u32 minor ;
};
#line 1087 
enum vfl_devnode_type {
    VFL_TYPE_GRABBER = 0,
    VFL_TYPE_VBI = 1,
    VFL_TYPE_RADIO = 2,
    VFL_TYPE_SUBDEV = 3,
    VFL_TYPE_SDR = 4,
    VFL_TYPE_TOUCH = 5,
    VFL_TYPE_MAX = 6
};
#line 1097 
enum vfl_devnode_direction {
    VFL_DIR_RX = 0,
    VFL_DIR_TX = 1,
    VFL_DIR_M2M = 2
};
#line 1104 
struct video_device;
#line 1105 
struct v4l2_device;
#line 1106 
struct v4l2_ctrl_handler;
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-dev.h"
struct v4l2_prio_state {
   atomic_t prios[4U] ;
};
#line 193  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-dev.h"
struct v4l2_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char *, size_t , loff_t *) ;
   __poll_t (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl32)(struct file *, unsigned int , unsigned long ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct file *) ;
   int (*release)(struct file *) ;
};
#line 256 
struct vb2_queue;
#line 256 
struct v4l2_ioctl_ops;
#line 256  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-dev.h"
struct video_device {
   struct media_entity entity ;
   struct media_intf_devnode *intf_devnode ;
   struct media_pipeline pipe ;
   struct v4l2_file_operations *fops ;
   u32 device_caps ;
   struct device dev ;
   struct cdev *cdev ;
   struct v4l2_device *v4l2_dev ;
   struct device *dev_parent ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct vb2_queue *queue ;
   struct v4l2_prio_state *prio ;
   char name[32U] ;
   enum vfl_devnode_type vfl_type ;
   enum vfl_devnode_direction vfl_dir ;
   int minor ;
   u16 num ;
   unsigned long flags ;
   int index ;
   spinlock_t fh_lock ;
   struct list_head fh_list ;
   int dev_debug ;
   v4l2_std_id tvnorms ;
   void (*release)(struct video_device *) ;
   struct v4l2_ioctl_ops *ioctl_ops ;
   unsigned long valid_ioctls[3U] ;
   struct mutex *lock ;
};
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-common.h"
struct v4l2_subdev;
#line 96 
struct v4l2_subdev_ops;
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-common.h"
struct v4l2_priv_tun_config {
   int tuner ;
   void *priv ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-devnode.h"
struct media_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char *, size_t , loff_t *) ;
   __poll_t (*poll)(struct file *, struct poll_table_struct *) ;
   long (*ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*open)(struct file *) ;
   int (*release)(struct file *) ;
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-devnode.h"
struct media_devnode {
   struct media_device *media_dev ;
   struct media_file_operations *fops ;
   struct device dev ;
   struct cdev cdev ;
   struct device *parent ;
   int minor ;
   unsigned long flags ;
   void (*release)(struct media_devnode *) ;
};
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-device.h"
struct media_request;
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-device.h"
struct media_device_ops {
   int (*link_notify)(struct media_link *, u32 , unsigned int ) ;
   struct media_request *(*req_alloc)(struct media_device *) ;
   void (*req_free)(struct media_request *) ;
   int (*req_validate)(struct media_request *) ;
   void (*req_queue)(struct media_request *) ;
};
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-device.h"
struct media_device {
   struct device *dev ;
   struct media_devnode *devnode ;
   char model[32U] ;
   char driver_name[32U] ;
   char serial[40U] ;
   char bus_info[32U] ;
   u32 hw_revision ;
   u64 topology_version ;
   u32 id ;
   struct ida entity_internal_idx ;
   int entity_internal_idx_max ;
   struct list_head entities ;
   struct list_head interfaces ;
   struct list_head pads ;
   struct list_head links ;
   struct list_head entity_notify ;
   struct mutex graph_mutex ;
   struct media_graph pm_count_walk ;
   void *source_priv ;
   int (*enable_source)(struct media_entity *, struct media_pipeline *) ;
   void (*disable_source)(struct media_entity *) ;
   struct media_device_ops *ops ;
   struct mutex req_queue_mutex ;
   atomic_t request_id ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-mediabus.h"
struct v4l2_mbus_framefmt {
   __u32 width ;
   __u32 height ;
   __u32 code ;
   __u32 field ;
   __u32 colorspace ;
   __u16 ycbcr_enc ;
   __u16 quantization ;
   __u16 xfer_func ;
   __u16 reserved[11U] ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_format {
   __u32 which ;
   __u32 pad ;
   struct v4l2_mbus_framefmt format ;
   __u32 reserved[8U] ;
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_mbus_code_enum {
   __u32 pad ;
   __u32 index ;
   __u32 code ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 90  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_size_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval {
   __u32 pad ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 width ;
   __u32 height ;
   struct v4l2_fract interval ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_selection {
   __u32 which ;
   __u32 pad ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[8U] ;
};
#line 157 
struct v4l2_async_notifier;
#line 158 
enum v4l2_async_match_type {
    V4L2_ASYNC_MATCH_CUSTOM = 0,
    V4L2_ASYNC_MATCH_DEVNAME = 1,
    V4L2_ASYNC_MATCH_I2C = 2,
    V4L2_ASYNC_MATCH_FWNODE = 3
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct __anonstruct_i2c_21434 {
   int adapter_id ;
   unsigned short address ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct __anonstruct_custom_21435 {
   bool (*match)(struct device *, struct v4l2_async_subdev *) ;
   void *priv ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
union __anonunion_match_21433 {
   struct fwnode_handle *fwnode ;
   char *device_name ;
   struct __anonstruct_i2c_21434 i2c ;
   struct __anonstruct_custom_21435 custom ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct v4l2_async_subdev {
   enum v4l2_async_match_type match_type ;
   union __anonunion_match_21433 match ;
   struct list_head list ;
   struct list_head asd_list ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct v4l2_async_notifier_operations {
   int (*bound)(struct v4l2_async_notifier *, struct v4l2_subdev *, struct v4l2_async_subdev *) ;
   int (*complete)(struct v4l2_async_notifier *) ;
   void (*unbind)(struct v4l2_async_notifier *, struct v4l2_subdev *, struct v4l2_async_subdev *) ;
};
#line 129  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct v4l2_async_notifier {
   struct v4l2_async_notifier_operations *ops ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev *sd ;
   struct v4l2_async_notifier *parent ;
   struct list_head asd_list ;
   struct list_head waiting ;
   struct list_head done ;
   struct list_head list ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-fh.h"
struct v4l2_m2m_ctx;
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-fh.h"
struct v4l2_fh {
   struct list_head list ;
   struct video_device *vdev ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   enum v4l2_priority prio ;
   wait_queue_head_t wait ;
   struct mutex subscribe_lock ;
   struct list_head subscribed ;
   struct list_head available ;
   unsigned int navailable ;
   u32 sequence ;
   struct v4l2_m2m_ctx *m2m_ctx ;
};
#line 162 
enum v4l2_mbus_type {
    V4L2_MBUS_UNKNOWN = 0,
    V4L2_MBUS_PARALLEL = 1,
    V4L2_MBUS_BT656 = 2,
    V4L2_MBUS_CSI1 = 3,
    V4L2_MBUS_CCP2 = 4,
    V4L2_MBUS_CSI2_DPHY = 5,
    V4L2_MBUS_CSI2_CPHY = 6
};
#line 97  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-mediabus.h"
struct v4l2_mbus_config {
   enum v4l2_mbus_type type ;
   unsigned int flags ;
};
#line 184 
struct v4l2_subdev_fh;
#line 185 
struct tuner_setup;
#line 186 
struct v4l2_mbus_frame_desc;
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_decode_vbi_line {
   u32 is_second_field ;
   u8 *p ;
   u32 line ;
   u32 type ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_io_pin_config {
   u32 flags ;
   u8 pin ;
   u8 function ;
   u8 value ;
   u8 strength ;
};
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_core_ops {
   int (*log_status)(struct v4l2_subdev *) ;
   int (*s_io_pin_config)(struct v4l2_subdev *, size_t , struct v4l2_subdev_io_pin_config *) ;
   int (*init)(struct v4l2_subdev *, u32 ) ;
   int (*load_fw)(struct v4l2_subdev *) ;
   int (*reset)(struct v4l2_subdev *, u32 ) ;
   int (*s_gpio)(struct v4l2_subdev *, u32 ) ;
   long (*ioctl)(struct v4l2_subdev *, unsigned int , void *) ;
   long (*compat_ioctl32)(struct v4l2_subdev *, unsigned int , unsigned long ) ;
   int (*g_register)(struct v4l2_subdev *, struct v4l2_dbg_register *) ;
   int (*s_register)(struct v4l2_subdev *, struct v4l2_dbg_register *) ;
   int (*s_power)(struct v4l2_subdev *, int ) ;
   int (*interrupt_service_routine)(struct v4l2_subdev *, u32 , bool *) ;
   int (*subscribe_event)(struct v4l2_subdev *, struct v4l2_fh *, struct v4l2_event_subscription *) ;
   int (*unsubscribe_event)(struct v4l2_subdev *, struct v4l2_fh *, struct v4l2_event_subscription *) ;
};
#line 264  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_tuner_ops {
   int (*standby)(struct v4l2_subdev *) ;
   int (*s_radio)(struct v4l2_subdev *) ;
   int (*s_frequency)(struct v4l2_subdev *, struct v4l2_frequency *) ;
   int (*g_frequency)(struct v4l2_subdev *, struct v4l2_frequency *) ;
   int (*enum_freq_bands)(struct v4l2_subdev *, struct v4l2_frequency_band *) ;
   int (*g_tuner)(struct v4l2_subdev *, struct v4l2_tuner *) ;
   int (*s_tuner)(struct v4l2_subdev *, struct v4l2_tuner *) ;
   int (*g_modulator)(struct v4l2_subdev *, struct v4l2_modulator *) ;
   int (*s_modulator)(struct v4l2_subdev *, struct v4l2_modulator *) ;
   int (*s_type_addr)(struct v4l2_subdev *, struct tuner_setup *) ;
   int (*s_config)(struct v4l2_subdev *, struct v4l2_priv_tun_config *) ;
};
#line 304  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_audio_ops {
   int (*s_clock_freq)(struct v4l2_subdev *, u32 ) ;
   int (*s_i2s_clock_freq)(struct v4l2_subdev *, u32 ) ;
   int (*s_routing)(struct v4l2_subdev *, u32 , u32 , u32 ) ;
   int (*s_stream)(struct v4l2_subdev *, int ) ;
};
#line 310 
enum v4l2_mbus_frame_desc_flags {
    V4L2_MBUS_FRAME_DESC_FL_LEN_MAX = 1,
    V4L2_MBUS_FRAME_DESC_FL_BLOB = 2
};
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc_entry {
   enum v4l2_mbus_frame_desc_flags flags ;
   u32 pixelcode ;
   u32 length ;
};
#line 348  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc {
   struct v4l2_mbus_frame_desc_entry entry[4U] ;
   unsigned short num_entries ;
};
#line 415  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_video_ops {
   int (*s_routing)(struct v4l2_subdev *, u32 , u32 , u32 ) ;
   int (*s_crystal_freq)(struct v4l2_subdev *, u32 , u32 ) ;
   int (*g_std)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*s_std)(struct v4l2_subdev *, v4l2_std_id ) ;
   int (*s_std_output)(struct v4l2_subdev *, v4l2_std_id ) ;
   int (*g_std_output)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*querystd)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*g_tvnorms)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*g_tvnorms_output)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*g_input_status)(struct v4l2_subdev *, u32 *) ;
   int (*s_stream)(struct v4l2_subdev *, int ) ;
   int (*g_pixelaspect)(struct v4l2_subdev *, struct v4l2_fract *) ;
   int (*g_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_frame_interval *) ;
   int (*s_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_frame_interval *) ;
   int (*s_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *) ;
   int (*g_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *) ;
   int (*query_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *) ;
   int (*g_mbus_config)(struct v4l2_subdev *, struct v4l2_mbus_config *) ;
   int (*s_mbus_config)(struct v4l2_subdev *, struct v4l2_mbus_config *) ;
   int (*s_rx_buffer)(struct v4l2_subdev *, void *, unsigned int *) ;
};
#line 481  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_vbi_ops {
   int (*decode_vbi_line)(struct v4l2_subdev *, struct v4l2_decode_vbi_line *) ;
   int (*s_vbi_data)(struct v4l2_subdev *, struct v4l2_sliced_vbi_data *) ;
   int (*g_vbi_data)(struct v4l2_subdev *, struct v4l2_sliced_vbi_data *) ;
   int (*g_sliced_vbi_cap)(struct v4l2_subdev *, struct v4l2_sliced_vbi_cap *) ;
   int (*s_raw_fmt)(struct v4l2_subdev *, struct v4l2_vbi_format *) ;
   int (*g_sliced_fmt)(struct v4l2_subdev *, struct v4l2_sliced_vbi_format *) ;
   int (*s_sliced_fmt)(struct v4l2_subdev *, struct v4l2_sliced_vbi_format *) ;
};
#line 501  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_sensor_ops {
   int (*g_skip_top_lines)(struct v4l2_subdev *, u32 *) ;
   int (*g_skip_frames)(struct v4l2_subdev *, u32 *) ;
};
#line 505 
enum v4l2_subdev_ir_mode {
    V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0
};
#line 540  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_parameters {
   unsigned int bytes_per_data_element ;
   enum v4l2_subdev_ir_mode mode ;
   bool enable ;
   bool interrupt_enable ;
   bool shutdown ;
   bool modulation ;
   u32 max_pulse_width ;
   unsigned int carrier_freq ;
   unsigned int duty_cycle ;
   bool invert_level ;
   bool invert_carrier_sense ;
   u32 noise_filter_min_width ;
   unsigned int carrier_range_lower ;
   unsigned int carrier_range_upper ;
   u32 resolution ;
};
#line 599  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_ops {
   int (*rx_read)(struct v4l2_subdev *, u8 *, size_t , ssize_t *) ;
   int (*rx_g_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *) ;
   int (*rx_s_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *) ;
   int (*tx_write)(struct v4l2_subdev *, u8 *, size_t , ssize_t *) ;
   int (*tx_g_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *) ;
   int (*tx_s_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *) ;
};
#line 630  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_config {
   struct v4l2_mbus_framefmt try_fmt ;
   struct v4l2_rect try_crop ;
   struct v4l2_rect try_compose ;
};
#line 674  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_ops {
   int (*init_cfg)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *) ;
   int (*enum_mbus_code)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_mbus_code_enum *) ;
   int (*enum_frame_size)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_frame_size_enum *) ;
   int (*enum_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_frame_interval_enum *) ;
   int (*get_fmt)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_format *) ;
   int (*set_fmt)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_format *) ;
   int (*get_selection)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_selection *) ;
   int (*set_selection)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_selection *) ;
   int (*get_edid)(struct v4l2_subdev *, struct v4l2_edid *) ;
   int (*set_edid)(struct v4l2_subdev *, struct v4l2_edid *) ;
   int (*dv_timings_cap)(struct v4l2_subdev *, struct v4l2_dv_timings_cap *) ;
   int (*enum_dv_timings)(struct v4l2_subdev *, struct v4l2_enum_dv_timings *) ;
   int (*link_validate)(struct v4l2_subdev *, struct media_link *, struct v4l2_subdev_format *, struct v4l2_subdev_format *) ;
   int (*get_frame_desc)(struct v4l2_subdev *, unsigned int , struct v4l2_mbus_frame_desc *) ;
   int (*set_frame_desc)(struct v4l2_subdev *, unsigned int , struct v4l2_mbus_frame_desc *) ;
};
#line 727  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_ops {
   struct v4l2_subdev_core_ops *core ;
   struct v4l2_subdev_tuner_ops *tuner ;
   struct v4l2_subdev_audio_ops *audio ;
   struct v4l2_subdev_video_ops *video ;
   struct v4l2_subdev_vbi_ops *vbi ;
   struct v4l2_subdev_ir_ops *ir ;
   struct v4l2_subdev_sensor_ops *sensor ;
   struct v4l2_subdev_pad_ops *pad ;
};
#line 765  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_internal_ops {
   int (*registered)(struct v4l2_subdev *) ;
   void (*unregistered)(struct v4l2_subdev *) ;
   int (*open)(struct v4l2_subdev *, struct v4l2_subdev_fh *) ;
   int (*close)(struct v4l2_subdev *, struct v4l2_subdev_fh *) ;
   void (*release)(struct v4l2_subdev *) ;
};
#line 772 
struct regulator_bulk_data;
#line 797  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_platform_data {
   struct regulator_bulk_data *regulators ;
   int num_regulators ;
   void *host_priv ;
};
#line 848  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev {
   struct media_entity entity ;
   struct list_head list ;
   struct module *owner ;
   bool owner_v4l2_dev ;
   u32 flags ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev_ops *ops ;
   struct v4l2_subdev_internal_ops *internal_ops ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   char name[32U] ;
   u32 grp_id ;
   void *dev_priv ;
   void *host_priv ;
   struct video_device *devnode ;
   struct device *dev ;
   struct fwnode_handle *fwnode ;
   struct list_head async_list ;
   struct v4l2_async_subdev *asd ;
   struct v4l2_async_notifier *notifier ;
   struct v4l2_async_notifier *subdev_notifier ;
   struct v4l2_subdev_platform_data *pdata ;
};
#line 906  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_fh {
   struct v4l2_fh vfh ;
   struct module *owner ;
   struct v4l2_subdev_pad_config *pad ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-device.h"
struct v4l2_device {
   struct device *dev ;
   struct media_device *mdev ;
   struct list_head subdevs ;
   spinlock_t lock ;
   char name[36U] ;
   void (*notify)(struct v4l2_subdev *, unsigned int , void *) ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct v4l2_prio_state prio ;
   struct kref ref ;
   void (*release)(struct v4l2_device *) ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 277  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
struct dma_chan;
#line 279 
struct spi_controller;
#line 280 
struct spi_transfer;
#line 281 
struct spi_controller_mem_ops;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_statistics {
   spinlock_t lock ;
   unsigned long messages ;
   unsigned long transfers ;
   unsigned long errors ;
   unsigned long timedout ;
   unsigned long spi_sync ;
   unsigned long spi_sync_immediate ;
   unsigned long spi_async ;
   unsigned long long bytes ;
   unsigned long long bytes_rx ;
   unsigned long long bytes_tx ;
   unsigned long transfer_bytes_histo[17U] ;
   unsigned long transfers_split_maxsize ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_delay {
   u16 value ;
   u8 unit ;
};
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_controller *controller ;
   struct spi_controller *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   bool rt ;
   u32 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   char *driver_override ;
   int cs_gpio ;
   struct gpio_desc *cs_gpiod ;
   struct spi_delay word_delay ;
   struct spi_statistics statistics ;
};
#line 247 
struct spi_message;
#line 452  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_controller {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u32 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   bool slave ;
   size_t (*max_transfer_size)(struct spi_device *) ;
   size_t (*max_message_size)(struct spi_device *) ;
   struct mutex io_mutex ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*set_cs_timing)(struct spi_device *, struct spi_delay *, struct spi_delay *, struct spi_delay *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_controller *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_controller *) ;
   int (*transfer_one_message)(struct spi_controller *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_controller *) ;
   int (*prepare_message)(struct spi_controller *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_controller *, struct spi_message *) ;
   int (*slave_abort)(struct spi_controller *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_controller *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_controller *, struct spi_message *) ;
   struct spi_controller_mem_ops *mem_ops ;
   struct spi_delay cs_setup ;
   struct spi_delay cs_hold ;
   struct spi_delay cs_inactive ;
   int *cs_gpios ;
   struct gpio_desc **cs_gpiods ;
   bool use_gpio_descriptors ;
   struct spi_statistics statistics ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
   int (*fw_translate_cs)(struct spi_controller *, unsigned int ) ;
   bool ptp_sts_supported ;
   unsigned long irq_flags ;
};
#line 890  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_transfer {
   void *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int cs_change : 1 ;
   unsigned int tx_nbits : 3 ;
   unsigned int rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   struct spi_delay delay ;
   struct spi_delay cs_change_delay ;
   struct spi_delay word_delay ;
   u32 speed_hz ;
   u32 effective_speed_hz ;
   unsigned int ptp_sts_word_pre ;
   unsigned int ptp_sts_word_post ;
   struct ptp_system_timestamp *ptp_sts ;
   bool timestamped_pre ;
   bool timestamped_post ;
   struct list_head transfer_list ;
};
#line 961  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
   struct list_head resources ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_fix_screeninfo {
   char id[16U] ;
   unsigned long smem_start ;
   __u32 smem_len ;
   __u32 type ;
   __u32 type_aux ;
   __u32 visual ;
   __u16 xpanstep ;
   __u16 ypanstep ;
   __u16 ywrapstep ;
   __u32 line_length ;
   unsigned long mmio_start ;
   __u32 mmio_len ;
   __u32 accel ;
   __u16 capabilities ;
   __u16 reserved[2U] ;
};
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_bitfield {
   __u32 offset ;
   __u32 length ;
   __u32 msb_right ;
};
#line 241  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_var_screeninfo {
   __u32 xres ;
   __u32 yres ;
   __u32 xres_virtual ;
   __u32 yres_virtual ;
   __u32 xoffset ;
   __u32 yoffset ;
   __u32 bits_per_pixel ;
   __u32 grayscale ;
   struct fb_bitfield red ;
   struct fb_bitfield green ;
   struct fb_bitfield blue ;
   struct fb_bitfield transp ;
   __u32 nonstd ;
   __u32 activate ;
   __u32 height ;
   __u32 width ;
   __u32 accel_flags ;
   __u32 pixclock ;
   __u32 left_margin ;
   __u32 right_margin ;
   __u32 upper_margin ;
   __u32 lower_margin ;
   __u32 hsync_len ;
   __u32 vsync_len ;
   __u32 sync ;
   __u32 vmode ;
   __u32 rotate ;
   __u32 colorspace ;
   __u32 reserved[4U] ;
};
#line 281  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_cmap {
   __u32 start ;
   __u32 len ;
   __u16 *red ;
   __u16 *green ;
   __u16 *blue ;
   __u16 *transp ;
};
#line 341  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_copyarea {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 sx ;
   __u32 sy ;
};
#line 350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_fillrect {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 color ;
   __u32 rop ;
};
#line 359  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_image {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 fg_color ;
   __u32 bg_color ;
   __u8 depth ;
   char *data ;
   struct fb_cmap cmap ;
};
#line 383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fbcurpos {
   __u16 x ;
   __u16 y ;
};
#line 387  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_cursor {
   __u16 set ;
   __u16 enable ;
   __u16 rop ;
   char *mask ;
   struct fbcurpos hot ;
   struct fb_image image ;
};
#line 400 
enum backlight_type {
    BACKLIGHT_RAW = 1,
    BACKLIGHT_PLATFORM = 2,
    BACKLIGHT_FIRMWARE = 3,
    BACKLIGHT_TYPE_MAX = 4
};
#line 412 
enum backlight_scale {
    BACKLIGHT_SCALE_UNKNOWN = 0,
    BACKLIGHT_SCALE_LINEAR = 1,
    BACKLIGHT_SCALE_NON_LINEAR = 2
};
#line 418 
struct backlight_device;
#line 419 
struct fb_info;
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backlight.h"
struct backlight_ops {
   unsigned int options ;
   int (*update_status)(struct backlight_device *) ;
   int (*get_brightness)(struct backlight_device *) ;
   int (*check_fb)(struct backlight_device *, struct fb_info *) ;
};
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backlight.h"
struct backlight_properties {
   int brightness ;
   int max_brightness ;
   int power ;
   int fb_blank ;
   enum backlight_type type ;
   unsigned int state ;
   enum backlight_scale scale ;
};
#line 97  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backlight.h"
struct backlight_device {
   struct backlight_properties props ;
   struct mutex update_lock ;
   struct mutex ops_lock ;
   struct backlight_ops *ops ;
   struct notifier_block fb_notif ;
   struct list_head entry ;
   struct device dev ;
   bool fb_bl_on[32U] ;
   int use_count ;
};
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_chroma {
   __u32 redx ;
   __u32 greenx ;
   __u32 bluex ;
   __u32 whitex ;
   __u32 redy ;
   __u32 greeny ;
   __u32 bluey ;
   __u32 whitey ;
};
#line 63 
struct fb_videomode;
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_monspecs {
   struct fb_chroma chroma ;
   struct fb_videomode *modedb ;
   __u8 manufacturer[4U] ;
   __u8 monitor[14U] ;
   __u8 serial_no[14U] ;
   __u8 ascii[14U] ;
   __u32 modedb_len ;
   __u32 model ;
   __u32 serial ;
   __u32 year ;
   __u32 week ;
   __u32 hfmin ;
   __u32 hfmax ;
   __u32 dclkmin ;
   __u32 dclkmax ;
   __u16 input ;
   __u16 dpms ;
   __u16 signal ;
   __u16 vfmin ;
   __u16 vfmax ;
   __u16 gamma ;
   __u16 gtf : 1 ;
   __u16 misc ;
   __u8 version ;
   __u8 revision ;
   __u8 max_x ;
   __u8 max_y ;
};
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_blit_caps {
   u32 x ;
   u32 y ;
   u32 len ;
   u32 flags ;
};
#line 185  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_pixmap {
   u8 *addr ;
   u32 size ;
   u32 offset ;
   u32 buf_align ;
   u32 scan_align ;
   u32 access_align ;
   u32 flags ;
   u32 blit_x ;
   u32 blit_y ;
   void (*writeio)(struct fb_info *, void *, void *, unsigned int ) ;
   void (*readio)(struct fb_info *, void *, void *, unsigned int ) ;
};
#line 203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_deferred_io {
   unsigned long delay ;
   struct mutex lock ;
   struct list_head pagelist ;
   void (*first_io)(struct fb_info *) ;
   void (*deferred_io)(struct fb_info *, struct list_head *) ;
};
#line 228  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_ops {
   struct module *owner ;
   int (*fb_open)(struct fb_info *, int ) ;
   int (*fb_release)(struct fb_info *, int ) ;
   ssize_t (*fb_read)(struct fb_info *, char *, size_t , loff_t *) ;
   ssize_t (*fb_write)(struct fb_info *, char *, size_t , loff_t *) ;
   int (*fb_check_var)(struct fb_var_screeninfo *, struct fb_info *) ;
   int (*fb_set_par)(struct fb_info *) ;
   int (*fb_setcolreg)(unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , struct fb_info *) ;
   int (*fb_setcmap)(struct fb_cmap *, struct fb_info *) ;
   int (*fb_blank)(int , struct fb_info *) ;
   int (*fb_pan_display)(struct fb_var_screeninfo *, struct fb_info *) ;
   void (*fb_fillrect)(struct fb_info *, struct fb_fillrect *) ;
   void (*fb_copyarea)(struct fb_info *, struct fb_copyarea *) ;
   void (*fb_imageblit)(struct fb_info *, struct fb_image *) ;
   int (*fb_cursor)(struct fb_info *, struct fb_cursor *) ;
   int (*fb_sync)(struct fb_info *) ;
   int (*fb_ioctl)(struct fb_info *, unsigned int , unsigned long ) ;
   int (*fb_compat_ioctl)(struct fb_info *, unsigned int , unsigned long ) ;
   int (*fb_mmap)(struct fb_info *, struct vm_area_struct *) ;
   void (*fb_get_caps)(struct fb_info *, struct fb_blit_caps *, struct fb_var_screeninfo *) ;
   void (*fb_destroy)(struct fb_info *) ;
   int (*fb_debug_enter)(struct fb_info *) ;
   int (*fb_debug_leave)(struct fb_info *) ;
};
#line 306  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tilemap {
   __u32 width ;
   __u32 height ;
   __u32 depth ;
   __u32 length ;
   __u8 *data ;
};
#line 315  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tilerect {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 index ;
   __u32 fg ;
   __u32 bg ;
   __u32 rop ;
};
#line 326  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tilearea {
   __u32 sx ;
   __u32 sy ;
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
};
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tileblit {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 fg ;
   __u32 bg ;
   __u32 length ;
   __u32 *indices ;
};
#line 346  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tilecursor {
   __u32 sx ;
   __u32 sy ;
   __u32 mode ;
   __u32 shape ;
   __u32 fg ;
   __u32 bg ;
};
#line 355  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tile_ops {
   void (*fb_settile)(struct fb_info *, struct fb_tilemap *) ;
   void (*fb_tilecopy)(struct fb_info *, struct fb_tilearea *) ;
   void (*fb_tilefill)(struct fb_info *, struct fb_tilerect *) ;
   void (*fb_tileblit)(struct fb_info *, struct fb_tileblit *) ;
   void (*fb_tilecursor)(struct fb_info *, struct fb_tilecursor *) ;
   int (*fb_get_tilemax)(struct fb_info *) ;
};
#line 499  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct aperture {
   resource_size_t base ;
   resource_size_t size ;
};
#line 497  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct apertures_struct {
   unsigned int count ;
   struct aperture ranges[0U] ;
};
#line 439  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
union __anonunion_22336 {
   char *screen_base ;
   char *screen_buffer ;
};
#line 439  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_info {
   atomic_t count ;
   int node ;
   int flags ;
   int fbcon_rotate_hint ;
   struct mutex lock ;
   struct mutex mm_lock ;
   struct fb_var_screeninfo var ;
   struct fb_fix_screeninfo fix ;
   struct fb_monspecs monspecs ;
   struct work_struct queue ;
   struct fb_pixmap pixmap ;
   struct fb_pixmap sprite ;
   struct fb_cmap cmap ;
   struct list_head modelist ;
   struct fb_videomode *mode ;
   struct backlight_device *bl_dev ;
   struct mutex bl_curve_mutex ;
   u8 bl_curve[128U] ;
   struct delayed_work deferred_work ;
   struct fb_deferred_io *fbdefio ;
   struct fb_ops *fbops ;
   struct device *device ;
   struct device *dev ;
   int class_flag ;
   struct fb_tile_ops *tileops ;
   union __anonunion_22336 __anonCompField_fb_info_73 ;
   unsigned long screen_size ;
   void *pseudo_palette ;
   u32 state ;
   void *fbcon_par ;
   void *par ;
   struct apertures_struct *apertures ;
   bool skip_vt_switch ;
};
#line 767  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_videomode {
   char *name ;
   u32 refresh ;
   u32 xres ;
   u32 yres ;
   u32 pixclock ;
   u32 left_margin ;
   u32 right_margin ;
   u32 upper_margin ;
   u32 lower_margin ;
   u32 hsync_len ;
   u32 vsync_len ;
   u32 sync ;
   u32 vmode ;
   u32 flag ;
};
#line 63  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
struct ldv_kmem_cache {
   char *name ;
   unsigned int size ;
};
#line 88  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
typedef unsigned long pthread_t;
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};
#line 30  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 20  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_free_irq_7 {
   int arg0 ;
   int signal_pending ;
};
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_interrupt_scenario_i40e_intr_17 {
   int arg0 ;
   enum irqreturn (*arg1)(int , void *) ;
   enum irqreturn (*arg2)(int , void *) ;
   void *arg3 ;
   int signal_pending ;
};
#line 33  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_character_driver_scenario_i40e_dbg_command_fops_15 {
   struct file_operations *arg0 ;
   int signal_pending ;
};
#line 38  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_random_allocationless_scenario_i40e_ddp_flash_18 {
   struct net_device *arg0 ;
   int signal_pending ;
};
#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_pci_scenario_i40e_driver_19 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};
#line 48  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_timer_scenario_6_21 {
   struct timer_list *arg0 ;
   int signal_pending ;
};
/* compiler builtin: 
   void *__builtin_memcpy(void *, void const *, unsigned long);   */
/* compiler builtin: 
   unsigned long __builtin_object_size(void *, int);   */
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/common/inline_asm.h"
#line 22 
void ldv_inline_asm(void);
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/export.h"
#line 16 
extern struct module __this_module;
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compiler.h"
__inline static void __read_once_size(void *p, void *res, int size)
{
  #line 199 
  switch (size) {
    #line 199 
    case 1: 
            #line 199 
    ;
    #line 199 
    *((__u8 *)res) = *((__u8 *)p);
    #line 199 
    break;
    #line 199 
    case 2: 
            #line 199 
    ;
    #line 199 
    *((__u16 *)res) = *((__u16 *)p);
    #line 199 
    break;
    #line 199 
    case 4: 
            #line 199 
    ;
    #line 199 
    *((__u32 *)res) = *((__u32 *)p);
    #line 199 
    break;
    #line 199 
    case 8: 
            #line 199 
    ;
    #line 199 
    *((__u64 *)res) = *((__u64 *)p);
    #line 199 
    break;
    #line 199 
    default: 
             #line 199 
    ;
    #line 200 
    ldv_inline_asm();
    #line 199 
    __builtin_memcpy(res,(void const *)p,(unsigned long)size);
    #line 200 
    ldv_inline_asm();
  }
  #line 203 
  return;
}

#line 220  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compiler.h"
__inline static void __write_once_size(void *p, void *res, int size)
{
  #line 222 
  switch (size) {
    #line 223 
    case 1: 
            #line 223 
    ;
    #line 223 
    *((__u8 *)p) = *((__u8 *)res);
    #line 223 
    break;
    #line 224 
    case 2: 
            #line 224 
    ;
    #line 224 
    *((__u16 *)p) = *((__u16 *)res);
    #line 224 
    break;
    #line 225 
    case 4: 
            #line 225 
    ;
    #line 225 
    *((__u32 *)p) = *((__u32 *)res);
    #line 225 
    break;
    #line 226 
    case 8: 
            #line 226 
    ;
    #line 226 
    *((__u64 *)p) = *((__u64 *)res);
    #line 226 
    break;
    #line 227 
    default: 
             #line 227 
    ;
    #line 228 
    ldv_inline_asm();
    #line 229 
    __builtin_memcpy(p,(void const *)res,(unsigned long)size);
    #line 230 
    ldv_inline_asm();
  }
  #line 232 
  return;
}

#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kasan-checks.h"
__inline static bool kasan_check_read(void *p, unsigned int size)
{
  #line 36 
  return (_Bool)1;
}

#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static void arch_clear_bit(long nr, unsigned long *addr)
{
  #line 74 
  if (0 != 0) 
              #line 76 
              ldv_inline_asm(); else 
                                     #line 79 
                                     ldv_inline_asm();
  #line 80 
  return;
}

#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static void arch_clear_bit_unlock(long nr, unsigned long *addr)
{
  #line 87 
  ldv_inline_asm();
  #line 88 
  arch_clear_bit(nr,addr);
  #line 89 
  return;
}

#line 204  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static bool constant_test_bit(long nr, unsigned long *addr)
{
  #line 207 
  return (_Bool)(((*(addr + (unsigned long)(nr >> 6)) >> (nr & 63L)) & 1UL) != 0UL);
}

#line 210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static bool variable_test_bit(long nr, unsigned long *addr)
{
  #line 212 
  bool oldbit;
  #line 213 
  ldv_inline_asm();
  #line 219 
  return oldbit;
}

#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-non-atomic.h"
__inline static bool test_bit(long nr, unsigned long *addr)
{
  #line 111 
  int tmp_1;
  #line 110 
  kasan_check_read((void *)(addr + (unsigned long)(nr / 64L)),8U);
  #line 111 
  if (0 != 0) {
    #line 111 
    tmp_1 = (int)constant_test_bit(nr,addr) != 0;
  }
  else {
    #line 111 
    tmp_1 = (int)variable_test_bit(nr,addr) != 0;
  }
  #line 111 
  return (_Bool)(tmp_1 != 0);
}

#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-lock.h"
__inline static void clear_bit_unlock(long nr, unsigned long *addr)
{
  #line 25 
  kasan_check_read((void *)(addr + (unsigned long)(nr / 64L)),8U);
  #line 26 
  arch_clear_bit_unlock(nr,addr);
  #line 27 
  return;
}

#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/jump_label.h"
__inline static bool arch_static_branch(struct static_key *key, bool branch)
{
  #line 27 
  ldv_inline_asm();
  #line 28 
  ldv_inline_asm();
  #line 34 
  return (_Bool)0;
  #line 35 
  l_yes: 
         #line 35 
  ;
  #line 36 
  return (_Bool)1;
}

#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_debug.h"
#line 64 
void __dynamic_dev_dbg(struct _ddebug *, struct device *, char * , ...);
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bug.h"
#line 89 
void __warn_printk(char * , ...);
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/math64.h"
__inline static u64 div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)
{
  #line 26 
  *remainder = (unsigned int)(dividend % (unsigned long long)divisor);
  #line 27 
  return dividend / (unsigned long long)divisor;
}

#line 123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/math64.h"
__inline static u64 div_u64(u64 dividend, u32 divisor)
{
  #line 125 
  u32 remainder;
  #line 126 
  return div_u64_rem(dividend,divisor,& remainder);
}

#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/math64.h"
__inline static u32 __iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder)
{
  #line 148 
  u32 ret = 0U;
  #line 150 
  while ((unsigned long long)divisor <= dividend) {
    #line 152 
    ldv_inline_asm();
    #line 155 
    dividend -= (unsigned long long)divisor;
    #line 156 
    ret ++;
  }
  #line 159 
  *remainder = dividend;
  #line 161 
  return ret;
}

#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/time64.h"
#line 69 
void set_normalized_timespec64(struct timespec64 *, time64_t, s64);
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/time64.h"
__inline static struct timespec64 timespec64_add(struct timespec64 lhs, struct timespec64 rhs)
{
  #line 74 
  struct timespec64 ts_delta;
  #line 75 
  set_normalized_timespec64(& ts_delta,lhs.tv_sec + rhs.tv_sec,(long long)(lhs.tv_nsec + rhs.tv_nsec));
  #line 77 
  return ts_delta;
}

#line 133  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/time64.h"
__inline static s64 timespec64_to_ns(struct timespec64 *ts)
{
  #line 135 
  return ts->tv_sec * 1000000000LL + (long long)ts->tv_nsec;
}

#line 144 
#line 144 
struct timespec64 ns_to_timespec64(s64);
#line 154  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/time64.h"
__inline static void timespec64_add_ns(struct timespec64 *a, u64 ns)
{
  #line 156 
  a->tv_sec += (long long)__iter_div_u64_rem((unsigned long long)a->tv_nsec + ns,1000000000U,
                         & ns);
  #line 157 
  a->tv_nsec = (long)ns;
  #line 158 
  return;
}

#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/string_64.h"
#line 18 
void *memset(void *, int, size_t);
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/string.h"
#line 29 
size_t strlcpy(char *, char *, size_t);
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 211  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ptp.i.aux"
static long PTR_ERR(void *ptr);
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 218  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ptp.i.aux"
static bool IS_ERR(void *ptr);
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 225  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ptp.i.aux"
static bool IS_ERR_OR_NULL(void *ptr);
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/irqflags.h"
#line 20 
unsigned long native_save_fl(void);
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/irqflags.h"
unsigned long native_save_fl(void)
{
  #line 22 
  unsigned long flags;
  #line 23 
  ldv_inline_asm();
  #line 35 
  return flags;
}

#line 38 
#line 39 
void native_restore_fl(unsigned long flags);
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/irqflags.h"
void native_restore_fl(unsigned long flags)
{
  #line 41 
  ldv_inline_asm();
  #line 42 
  return;
}

#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/thread_info.h"
#line 112 
void __check_object_size(void *, unsigned long, bool);
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/thread_info.h"
__inline static void check_object_size(void *ptr, unsigned long n, bool to_user)
{
  #line 118 
  if (0 == 0) 
              #line 119 
              __check_object_size(ptr,n,(_Bool)((bool)((int)to_user) != 0));
  #line 120 
  return;
}

#line 128 
#line 128 
void __bad_copy_from(void);
#line 130 
#line 130 
void __bad_copy_to(void);
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/thread_info.h"
__inline static void copy_overflow(int size, unsigned long count)
{
  #line 134 
  int __ret_warn_on = 1;
  #line 134 
  if ((long)(__ret_warn_on != 0) != 0L) {
    #line 134 
    __warn_printk((char *)"Buffer overflow detected (%d < %lu)!\n",size,count);
    #line 135 
    ldv_inline_asm();
    #line 136 
    ldv_inline_asm();
  }
  #line 134 
  long tmp = (long)(__ret_warn_on != 0);
  #line 136 
  return;
}

#line 138  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/thread_info.h"
__inline static bool check_copy_size(void *addr, size_t bytes, bool is_source)
{
  #line 150 
  int __ret_warn_on;
  #line 140 
  int sz = (int)__builtin_object_size(addr,0);
  #line 141 
  if ((long)(sz >= 0) != 0L && (long)((unsigned long)sz < bytes) != 0L) {
    #line 142 
    if (0 == 0) 
                #line 143 
                copy_overflow(sz,bytes);
    else 
      #line 144 
      if ((int)is_source != 0) 
                               #line 145 
                               __bad_copy_from(); else 
                                                       #line 147 
                                                       __bad_copy_to();
    #line 148 
    return (_Bool)0;
  }
  #line 150 
  __ret_warn_on = bytes > 2147483647UL;
  #line 150 
  if ((long)(__ret_warn_on != 0) != 0L) {
    #line 151 
    ldv_inline_asm();
    #line 152 
    ldv_inline_asm();
  }
  #line 150 
  if ((long)((long)(__ret_warn_on != 0)) != 0L) 
                                                #line 151 
                                                return (_Bool)0;
  #line 152 
  check_object_size(addr,bytes,(_Bool)((bool)((int)is_source) != 0));
  #line 153 
  return (_Bool)1;
}

#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
#line 95 
void __raw_spin_lock_init(raw_spinlock_t *, char *, struct lock_class_key *);
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_api_smp.h"
#line 28 
void _raw_spin_lock_bh(raw_spinlock_t *);
#line 40 
#line 40 
void _raw_spin_unlock_bh(raw_spinlock_t *);
#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
  #line 327 
  return & lock->__anonCompField_spinlock_25.rlock;
}

#line 341  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_lock_bh(spinlock_t *lock)
{
  #line 343 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_25.rlock);
  #line 344 
  return;
}

#line 345 
#line 845  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ptp.i.aux"
static void cif_spin_lock_bh_ptp_rx_lock_of_i40e_pf(spinlock_t *lock);
#line 381  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_unlock_bh(spinlock_t *lock)
{
  #line 383 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_25.rlock);
  #line 384 
  return;
}

#line 385 
#line 854  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ptp.i.aux"
static void cif_spin_unlock_bh_ptp_rx_lock_of_i40e_pf(spinlock_t *lock);
#line 26 
#line 831 
static void cif_mutex_lock_tmreg_lock_of_i40e_pf(struct mutex *lock);
#line 29 
#line 29 
void ldv_mutex_model_lock(struct mutex *, char *);
#line 31 
#line 31 
void ldv_mutex_model_unlock(struct mutex *, char *);
#line 40 
#line 40 
void ldv_spin_model_lock(char *);
#line 41 
#line 41 
void ldv_spin_model_unlock(char *);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/err.h"
#line 23 
bool ldv_is_err(void *ptr);
#line 24 
#line 24 
bool ldv_is_err_or_null(void *ptr);
#line 26 
#line 26 
long ldv_ptr_err(void *ptr);
#line 128  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mutex.h"
#line 128 
void __mutex_init(struct mutex *, char *, struct lock_class_key *);
#line 185 
#line 838  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ptp.i.aux"
static void cif_mutex_unlock_tmreg_lock_of_i40e_pf(struct mutex *lock);
#line 81  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jiffies.h"
#line 81 
extern unsigned long jiffies;
#line 97  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ktime.h"
__inline static s64 ktime_to_ns(ktime_t kt)
{
  #line 99 
  return kt;
}

#line 265  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ktime.h"
__inline static ktime_t ns_to_ktime(u64 ns)
{
  #line 267 
  return (long long)ns;
}

#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timekeeping.h"
#line 43 
void ktime_get_real_ts64(struct timespec64 *);
#line 67 
#line 67 
ktime_t ktime_get(void);
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void *addr)
{
  #line 59 
  unsigned int ret;
  #line 60 
  ldv_inline_asm();
  #line 59 
  return ret;
}

#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val, void *addr)
{
  #line 69 
  ldv_inline_asm();
  #line 70 
  return;
}

#line 121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uaccess.h"
#line 121 
unsigned long _copy_from_user(void *, void *, unsigned long);
#line 137 
#line 137 
unsigned long _copy_to_user(void *, void *, unsigned long);
#line 141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uaccess.h"
__inline static unsigned long copy_from_user(void *to, void *from, unsigned long n)
{
  #line 143 
  if ((long)((int)check_copy_size(to,n,(_Bool)0) != 0) != 0L) 
                                                              #line 144 
                                                              n = _copy_from_user(to,from,n);
  #line 145 
  return n;
}

#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uaccess.h"
__inline static unsigned long copy_to_user(void *to, void *from, unsigned long n)
{
  #line 151 
  if ((long)((int)check_copy_size(from,n,(_Bool)1) != 0) != 0L) 
                                                                #line 152 
                                                                n = _copy_to_user(to,from,n);
  #line 153 
  return n;
}

#line 1712  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
#line 1712 
void _dev_err(struct device *, char * , ...);
#line 1714 
#line 1714 
void _dev_warn(struct device *, char * , ...);
#line 1718 
#line 1718 
void _dev_info(struct device *, char * , ...);
#line 1381  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff *skb)
{
  #line 1383 
  return skb->head + (unsigned long)skb->end;
}

#line 1405  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb)
{
  #line 1407 
  return & ((struct skb_shared_info *)skb_end_pointer(skb))->hwtstamps;
}

#line 3813 
#line 3813 
void skb_tstamp_tx(struct sk_buff *, struct skb_shared_hwtstamps *);
#line 3617  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
#line 3617 
void __dev_kfree_skb_any(struct sk_buff *, enum skb_free_reason);
#line 3648  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb)
{
  #line 3650 
  __dev_kfree_skb_any(skb,(enum skb_free_reason)SKB_REASON_DROPPED);
  #line 3651 
  return;
}

#line 186  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
#line 186 
struct ptp_clock *ptp_clock_register(struct ptp_clock_info *, struct device *);
#line 195 
#line 195 
int ptp_clock_unregister(struct ptp_clock *);
#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
__inline static void ptp_read_system_prets(struct ptp_system_timestamp *sts)
{
  #line 268 
  if (sts != (struct ptp_system_timestamp *)0) 
                                               #line 269 
                                               ktime_get_real_ts64(& sts->pre_ts);
  #line 270 
  return;
}

#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
__inline static void ptp_read_system_postts(struct ptp_system_timestamp *sts)
{
  #line 274 
  if (sts != (struct ptp_system_timestamp *)0) 
                                               #line 275 
                                               ktime_get_real_ts64(& sts->post_ts);
  #line 276 
  return;
}

#line 96  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 96 
i40e_status i40e_aq_get_link_info(struct i40e_hw *hw, bool enable_lse, struct i40e_link_status *link, struct i40e_asq_cmd_details *cmd_details);
#line 994  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
char i40e_driver_name[5U];
#line 1134  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 269  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_rx_hang(struct i40e_pf *pf);
#line 1135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 328  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_tx_hang(struct i40e_pf *pf);
#line 1136  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 362  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_tx_hwtstamp(struct i40e_pf *pf);
#line 1137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 408  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_rx_hwtstamp(struct i40e_pf *pf, struct sk_buff *skb, u8 index);
#line 1138  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_set_increment(struct i40e_pf *pf);
#line 1139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 665  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
int i40e_ptp_set_ts_config(struct i40e_pf *pf, struct ifreq *ifr);
#line 1140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 516  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
int i40e_ptp_get_ts_config(struct i40e_pf *pf, struct ifreq *ifr);
#line 1141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 743  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_save_hw_time(struct i40e_pf *pf);
#line 1142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 766  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_restore_hw_time(struct i40e_pf *pf);
#line 1143  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 790  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_init(struct i40e_pf *pf);
#line 1144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 852  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_stop(struct i40e_pf *pf);
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static void i40e_ptp_read(struct i40e_pf *pf, struct timespec64 *ts, struct ptp_system_timestamp *sts)
{
  #line 41 
  u32 hi;
  #line 41 
  u32 lo;
  #line 42 
  u64 ns;
  #line 40 
  struct i40e_hw *hw = & pf->hw;
  #line 45 
  ptp_read_system_prets(sts);
  #line 46 
  lo = readl((void *)(hw->hw_addr + 1982720U));
  #line 47 
  ptp_read_system_postts(sts);
  #line 48 
  hi = readl((void *)(hw->hw_addr + 1982752U));
  #line 50 
  ns = ((unsigned long long)hi << 32) | (unsigned long long)lo;
  #line 52 
  *ts = ns_to_timespec64((long long)ns);
  #line 53 
  return;
}

#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static void i40e_ptp_write(struct i40e_pf *pf, struct timespec64 *ts)
{
  #line 66 
  struct i40e_hw *hw = & pf->hw;
  #line 67 
  u64 ns = (unsigned long long)timespec64_to_ns(ts);
  #line 72 
  writel((unsigned int)ns,(void *)(hw->hw_addr + 1982720U));
  #line 73 
  writel((unsigned int)(ns >> 32),(void *)(hw->hw_addr + 1982752U));
  #line 74 
  return;
}

#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static void i40e_ptp_convert_to_hwtstamp(struct skb_shared_hwtstamps *hwtstamps, u64 timestamp)
{
  #line 88 
  memset((void *)hwtstamps,0,8UL);
  #line 90 
  hwtstamps->hwtstamp = ns_to_ktime(timestamp);
  #line 91 
  return;
}

#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static int i40e_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
{
  #line 131 
  union __anonunion___u_1117 __u;
  #line 103 
  void *__mptr;
  #line 105 
  u64 adj;
  #line 105 
  u64 freq;
  #line 105 
  u64 diff;
  #line 103 
  __mptr = (void *)ptp;
  #line 103 
  struct i40e_pf *pf = ((struct i40e_pf *)(__mptr + 18446744073709547256U));
  #line 104 
  struct i40e_hw *hw = & pf->hw;
  #line 106 
  int neg_adj = 0;
  #line 108 
  if (ppb < 0) {
    #line 109 
    neg_adj = 1;
    #line 110 
    ppb = - ppb;
  }
  #line 113 
  freq = 6871947673ULL;
  #line 114 
  freq = (unsigned long long)ppb * freq;
  #line 115 
  diff = div_u64(freq,1000000000U);
  #line 117 
  if (neg_adj != 0) 
                    #line 118 
                    adj = 6871947673ULL - diff; else 
                                                     #line 120 
                                                     adj = diff + 6871947673ULL;
  #line 121 
  ldv_inline_asm();
  #line 130 
  __read_once_size((void *)(& pf->ptp_adj_mult),(void *)(& __u.__c),4);
  #line 130 
  adj = (unsigned long long)(__u.__val) * adj;
  #line 132 
  writel((unsigned int)adj,(void *)(hw->hw_addr + 1982528U));
  #line 133 
  writel((unsigned int)(adj >> 32),(void *)(hw->hw_addr + 1982560U));
  #line 135 
  return 0;
}

#line 145  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static int i40e_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
{
  #line 147 
  void *__mptr;
  #line 148 
  struct timespec64 now;
  #line 148 
  struct timespec64 then;
  #line 147 
  __mptr = (void *)ptp;
  #line 147 
  struct i40e_pf *pf = ((struct i40e_pf *)(__mptr + 18446744073709547256U));
  #line 150 
  then = ns_to_timespec64(delta);
  #line 151 
  cif_mutex_lock_tmreg_lock_of_i40e_pf(& pf->tmreg_lock);
  #line 153 
  i40e_ptp_read(pf,& now,(struct ptp_system_timestamp *)0);
  #line 154 
  now = timespec64_add(now,then);
  #line 155 
  i40e_ptp_write(pf,& now);
  #line 157 
  cif_mutex_unlock_tmreg_lock_of_i40e_pf(& pf->tmreg_lock);
  #line 159 
  return 0;
}

#line 171  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static int i40e_ptp_gettimex(struct ptp_clock_info *ptp, struct timespec64 *ts, struct ptp_system_timestamp *sts)
{
  #line 174 
  void *__mptr;
  #line 174 
  __mptr = (void *)ptp;
  #line 174 
  struct i40e_pf *pf = ((struct i40e_pf *)(__mptr + 18446744073709547256U));
  #line 176 
  cif_mutex_lock_tmreg_lock_of_i40e_pf(& pf->tmreg_lock);
  #line 177 
  i40e_ptp_read(pf,ts,sts);
  #line 178 
  cif_mutex_unlock_tmreg_lock_of_i40e_pf(& pf->tmreg_lock);
  #line 180 
  return 0;
}

#line 191  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static int i40e_ptp_settime(struct ptp_clock_info *ptp, struct timespec64 *ts)
{
  #line 194 
  void *__mptr;
  #line 194 
  __mptr = (void *)ptp;
  #line 194 
  struct i40e_pf *pf = ((struct i40e_pf *)(__mptr + 18446744073709547256U));
  #line 196 
  cif_mutex_lock_tmreg_lock_of_i40e_pf(& pf->tmreg_lock);
  #line 197 
  i40e_ptp_write(pf,ts);
  #line 198 
  cif_mutex_unlock_tmreg_lock_of_i40e_pf(& pf->tmreg_lock);
  #line 200 
  return 0;
}

#line 212  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static int i40e_ptp_feature_enable(struct ptp_clock_info *ptp, struct ptp_clock_request *rq, int on)
{
  #line 215 
  return -95;
}

#line 230  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static u32 i40e_ptp_get_rx_events(struct i40e_pf *pf)
{
  #line 233 
  u32 prttsyn_stat;
  #line 233 
  u32 new_latch_events;
  #line 234 
  int i;
  #line 232 
  struct i40e_hw *hw = & pf->hw;
  #line 236 
  prttsyn_stat = readl((void *)(hw->hw_addr + 545088U));
  #line 237 
  new_latch_events = ~ pf->latch_event_flags & prttsyn_stat;
  #line 248 
  i = 0;
  #line 248 
  while (i <= 3) {
    #line 249 
    if ((((unsigned long)new_latch_events >> i) & 1UL) != 0UL) 
                                                               #line 250 
                                                               pf->latch_events[i] = jiffies;
    #line 248 
    i ++;
  }
  #line 254 
  pf->latch_event_flags = prttsyn_stat;
  #line 256 
  return prttsyn_stat;
}

#line 269  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_rx_hang(struct i40e_pf *pf)
{
  #line 272 
  unsigned int i;
  #line 271 
  struct i40e_hw *hw = & pf->hw;
  #line 272 
  unsigned int cleared = 0U;
  #line 279 
  if (((unsigned long)pf->flags & 131072UL) == 0UL || ! pf->ptp_rx) 
                                                                    #line 280 
                                                                    return;
  #line 282 
  cif_spin_lock_bh_ptp_rx_lock_of_i40e_pf(& pf->ptp_rx_lock);
  #line 285 
  i40e_ptp_get_rx_events(pf);
  #line 293 
  i = 0U;
  #line 293 
  while (i <= 3U) {
    {
      #line 295 
      unsigned long __dummy;
      #line 295 
      unsigned long __dummy2;
      }
    #line 294 
    if (1 != 0) {
      {
        #line 295 
        unsigned long __dummy_0;
        #line 295 
        unsigned long __dummy2_0;
        }
      #line 295 
      if (1 != 0) 
        #line 295 
        if ((long)((pf->latch_events[i] - jiffies) + 250UL) < 0L) 
          #line 294 
          if ((((unsigned long)pf->latch_event_flags >> i) & 1UL) != 0UL) {
            #line 296 
            readl((void *)(hw->hw_addr + (unsigned long)((i + 17026U) * 32U)));
            #line 297 
            pf->latch_event_flags &= ~ ((unsigned int)(1UL << i));
            #line 298 
            cleared ++;
          }
    }
    #line 293 
    i ++;
  }
  #line 302 
  cif_spin_unlock_bh_ptp_rx_lock_of_i40e_pf(& pf->ptp_rx_lock);
  #line 310 
  if (cleared > 2U) {
    #line 311 
    bool branch;
    #line 311 
    struct _ddebug __UNIQUE_ID_ddebug558 = {.modname = (char *)"i40e", .function = (char *)"i40e_ptp_rx_hang", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c", .format = (char *)"Dropped %d missed RXTIME timestamp events\n", .lineno = (unsigned int)311U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 311 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug558.key.dd_key_false.key,(_Bool)0);
    #line 311 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 311 
                                                __dynamic_dev_dbg(& __UNIQUE_ID_ddebug558,& (pf->pdev)->dev,(char *)"Dropped %d missed RXTIME timestamp events\n",cleared);
  }
  #line 316 
  pf->rx_hwtstamp_cleared += cleared;
  #line 317 
  return;
}

#line 328  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_tx_hang(struct i40e_pf *pf)
{
  #line 330 
  struct sk_buff *skb;
  #line 332 
  if (((unsigned long)pf->flags & 131072UL) == 0UL || ! pf->ptp_tx) 
                                                                    #line 333 
                                                                    return;
  #line 336 
  if (! test_bit(18L,(unsigned long *)(& pf->state))) 
                                                      #line 337 
                                                      return;
  {
    #line 343 
    unsigned long __dummy;
    #line 343 
    unsigned long __dummy2;
    }
  #line 343 
  if (1 != 0) {
    {
      #line 343 
      unsigned long __dummy_0;
      #line 343 
      unsigned long __dummy2_0;
      }
    #line 343 
    if (1 != 0) 
      #line 343 
      if ((long)((pf->ptp_tx_start - jiffies) + 250UL) < 0L) {
        #line 344 
        skb = pf->ptp_tx_skb;
        #line 345 
        pf->ptp_tx_skb = (struct sk_buff *)0;
        #line 346 
        clear_bit_unlock(18L,(unsigned long *)(& pf->state));
        #line 349 
        dev_kfree_skb_any(skb);
        #line 350 
        (pf->tx_hwtstamp_timeouts) ++;
      }
  }
  #line 352 
  return;
}

#line 362  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_tx_hwtstamp(struct i40e_pf *pf)
{
  #line 364 
  struct skb_shared_hwtstamps shhwtstamps;
  #line 367 
  u32 hi;
  #line 367 
  u32 lo;
  #line 368 
  u64 ns;
  #line 365 
  struct sk_buff *skb = pf->ptp_tx_skb;
  #line 366 
  struct i40e_hw *hw = & pf->hw;
  #line 370 
  if (((unsigned long)pf->flags & 131072UL) == 0UL || ! pf->ptp_tx) 
                                                                    #line 371 
                                                                    return;
  #line 374 
  if (pf->ptp_tx_skb == (struct sk_buff *)0) 
                                             #line 375 
                                             return;
  #line 377 
  lo = readl((void *)(hw->hw_addr + 1982912U));
  #line 378 
  hi = readl((void *)(hw->hw_addr + 1982944U));
  #line 380 
  ns = ((unsigned long long)hi << 32) | (unsigned long long)lo;
  #line 381 
  i40e_ptp_convert_to_hwtstamp(& shhwtstamps,ns);
  #line 388 
  pf->ptp_tx_skb = (struct sk_buff *)0;
  #line 389 
  clear_bit_unlock(18L,(unsigned long *)(& pf->state));
  #line 392 
  skb_tstamp_tx(skb,& shhwtstamps);
  #line 393 
  dev_kfree_skb_any(skb);
  #line 394 
  return;
}

#line 408  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_rx_hwtstamp(struct i40e_pf *pf, struct sk_buff *skb, u8 index)
{
  #line 410 
  u32 prttsyn_stat;
  #line 410 
  u32 hi;
  #line 410 
  u32 lo;
  #line 411 
  struct i40e_hw *hw;
  #line 412 
  u64 ns;
  #line 417 
  if (((unsigned long)pf->flags & 131072UL) == 0UL || ! pf->ptp_rx) 
                                                                    #line 418 
                                                                    return;
  #line 420 
  hw = & pf->hw;
  #line 422 
  cif_spin_lock_bh_ptp_rx_lock_of_i40e_pf(& pf->ptp_rx_lock);
  #line 425 
  prttsyn_stat = i40e_ptp_get_rx_events(pf);
  #line 428 
  if ((((unsigned long)prttsyn_stat >> (int)index) & 1UL) == 0UL) {
    #line 429 
    cif_spin_unlock_bh_ptp_rx_lock_of_i40e_pf(& pf->ptp_rx_lock);
    #line 430 
    return;
  }
  #line 434 
  pf->latch_event_flags &= ~ ((unsigned int)(1UL << (int)index));
  #line 436 
  lo = readl((void *)(hw->hw_addr + (unsigned long)(((int)index + 17030) * 32)));
  #line 437 
  hi = readl((void *)(hw->hw_addr + (unsigned long)(((int)index + 17026) * 32)));
  #line 439 
  cif_spin_unlock_bh_ptp_rx_lock_of_i40e_pf(& pf->ptp_rx_lock);
  #line 441 
  ns = ((unsigned long long)hi << 32) | (unsigned long long)lo;
  #line 443 
  ;
  #line 443 
  i40e_ptp_convert_to_hwtstamp(skb_hwtstamps(skb),ns);
  #line 444 
  return;
}

#line 454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_set_increment(struct i40e_pf *pf)
{
  #line 456 
  struct i40e_link_status *hw_link_info;
  #line 458 
  u64 incval;
  #line 459 
  u32 mult;
  #line 457 
  struct i40e_hw *hw = & pf->hw;
  #line 461 
  hw_link_info = & hw->phy.link_info;
  #line 463 
  i40e_aq_get_link_info(& pf->hw,(_Bool)1,(struct i40e_link_status *)0,(struct i40e_asq_cmd_details *)0);
  #line 465 
  switch ((unsigned int)hw_link_info->link_speed) {
    #line 466 
    case (unsigned int)8: 
                          #line 466 
    ;
    #line 467 
    mult = 2U;
    #line 468 
    break;
    #line 469 
    case (unsigned int)4: 
                          #line 469 
    ;
    #line 470 
    mult = 20U;
    #line 471 
    break;
    #line 472 
    case (unsigned int)2: 
                          #line 472 
    ;
    {
      #line 474 
      int warn_once;
      #line 476 
      if (warn_once == 0) {
        #line 477 
        _dev_warn(& (pf->pdev)->dev,(char *)"1588 functionality is not supported at 100 Mbps. Stopping the PHC.\n");
        #line 479 
        warn_once ++;
      }
      #line 481 
      mult = 0U;
      #line 482 
      break;
    }
    #line 484 
    case (unsigned int)16: 
                           #line 484 
    ;
    #line 485 
    default: 
             #line 485 
    ;
    #line 486 
    mult = 1U;
    #line 487 
    break;
  }
  #line 493 
  incval = (unsigned long long)mult * 6871947673ULL;
  #line 499 
  writel((unsigned int)incval,(void *)(hw->hw_addr + 1982528U));
  #line 500 
  writel((unsigned int)(incval >> 32),(void *)(hw->hw_addr + 1982560U));
  {
    #line 504 
    union __anonunion___u_1119 __u = {.__val = mult};
    #line 503 
    __write_once_size((void *)(& pf->ptp_adj_mult),(void *)(& __u.__c),4);
    #line 503 
    u32 tmp = __u.__val;
  }
  #line 505 
  ldv_inline_asm();
  #line 506 
  return;
}

#line 516  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
int i40e_ptp_get_ts_config(struct i40e_pf *pf, struct ifreq *ifr)
{
  #line 524 
  int tmp_0;
  #line 518 
  struct hwtstamp_config *config = & pf->tstamp_config;
  #line 520 
  if (((unsigned long)pf->flags & 131072UL) == 0UL) 
                                                    #line 521 
                                                    return -95;
  #line 524 
  if (copy_to_user(ifr->ifr_ifru.ifru_data,(void *)config,12UL) != 0UL) 
    #line 524 
    tmp_0 = -14; else 
                      #line 524 
                      tmp_0 = 0;
  #line 524 
  return tmp_0;
}

#line 539  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static int i40e_ptp_set_timestamp_mode(struct i40e_pf *pf, struct hwtstamp_config *config)
{
  #line 543 
  u32 tsyntype;
  #line 543 
  u32 regval;
  #line 542 
  struct i40e_hw *hw = & pf->hw;
  #line 546 
  if (config->flags != 0) 
                          #line 547 
                          return -22;
  #line 549 
  switch (config->tx_type) {
    #line 550 
    case 0: 
            #line 550 
    ;
    #line 551 
    pf->ptp_tx = (_Bool)0;
    #line 552 
    break;
    #line 553 
    case 1: 
            #line 553 
    ;
    #line 554 
    pf->ptp_tx = (_Bool)1;
    #line 555 
    break;
    #line 556 
    default: 
             #line 556 
    ;
    #line 557 
    return -34;
  }
  #line 560 
  switch (config->rx_filter) {
    #line 561 
    case 0: 
            #line 561 
    ;
    #line 562 
    pf->ptp_rx = (_Bool)0;
    #line 568 
    tsyntype = 16777216U;
    #line 569 
    break;
    #line 570 
    case 4: 
            #line 570 
    ;
    #line 571 
    case 5: 
            #line 571 
    ;
    #line 572 
    case 3: 
            #line 572 
    ;
    #line 573 
    if (((unsigned long)pf->hw_features & 1024UL) == 0UL) 
                                                          #line 574 
                                                          return -34;
    #line 575 
    pf->ptp_rx = (_Bool)1;
    #line 576 
    tsyntype = 218104063U;
    #line 579 
    config->rx_filter = 3;
    #line 580 
    break;
    #line 581 
    case 12: 
             #line 581 
    ;
    #line 582 
    case 6: 
            #line 582 
    ;
    #line 583 
    case 13: 
             #line 583 
    ;
    #line 584 
    case 7: 
            #line 584 
    ;
    #line 585 
    case 14: 
             #line 585 
    ;
    #line 586 
    case 8: 
            #line 586 
    ;
    #line 587 
    if (((unsigned long)pf->hw_features & 1024UL) == 0UL) 
                                                          #line 588 
                                                          return -34;
    #line 590 
    case 9: 
            #line 590 
    ;
    #line 591 
    case 10: 
             #line 591 
    ;
    #line 592 
    case 11: 
             #line 592 
    ;
    #line 593 
    pf->ptp_rx = (_Bool)1;
    #line 594 
    tsyntype = 34537472U;
    #line 596 
    if (((unsigned long)pf->hw_features & 1024UL) != 0UL) {
      #line 597 
      tsyntype |= 201326592U;
      #line 598 
      config->rx_filter = 12;
    }
    else 
         #line 600 
         config->rx_filter = 9;
    #line 602 
    break;
    #line 603 
    case 15: 
             #line 603 
    ;
    #line 604 
    case 1: 
            #line 604 
    ;
    #line 605 
    default: 
             #line 605 
    ;
    #line 606 
    return -34;
  }
  #line 610 
  cif_spin_lock_bh_ptp_rx_lock_of_i40e_pf(& pf->ptp_rx_lock);
  #line 611 
  readl((void *)(hw->hw_addr + 1983008U));
  #line 612 
  readl((void *)(hw->hw_addr + 1982944U));
  #line 613 
  readl((void *)(hw->hw_addr + 544832U));
  #line 614 
  readl((void *)(hw->hw_addr + 544864U));
  #line 615 
  readl((void *)(hw->hw_addr + 544896U));
  #line 616 
  readl((void *)(hw->hw_addr + 544928U));
  #line 617 
  pf->latch_event_flags = 0U;
  #line 618 
  cif_spin_unlock_bh_ptp_rx_lock_of_i40e_pf(& pf->ptp_rx_lock);
  #line 621 
  regval = readl((void *)(hw->hw_addr + 1982976U));
  #line 622 
  if ((int)pf->ptp_tx != 0) 
                            #line 623 
                            regval |= 2U; else 
                                               #line 625 
                                               regval &= 4294967293U;
  #line 626 
  writel(regval,(void *)(hw->hw_addr + 1982976U));
  #line 628 
  regval = readl((void *)(hw->hw_addr + 231424U));
  #line 629 
  if ((int)pf->ptp_tx != 0) 
                            #line 630 
                            regval |= 8388608U; else 
                                                     #line 632 
                                                     regval &= 4286578687U;
  #line 633 
  writel(regval,(void *)(hw->hw_addr + 231424U));
  #line 641 
  regval = readl((void *)(hw->hw_addr + 544800U));
  #line 643 
  regval &= 2147483648U;
  #line 645 
  regval |= tsyntype;
  #line 646 
  writel(regval,(void *)(hw->hw_addr + 544800U));
  #line 648 
  return 0;
}

#line 665  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
int i40e_ptp_set_ts_config(struct i40e_pf *pf, struct ifreq *ifr)
{
  #line 667 
  struct hwtstamp_config config;
  #line 668 
  int err;
  #line 684 
  int tmp_1;
  #line 670 
  if (((unsigned long)pf->flags & 131072UL) == 0UL) 
                                                    #line 671 
                                                    return -95;
  #line 673 
  if (copy_from_user((void *)(& config),ifr->ifr_ifru.ifru_data,12UL) != 0UL) 
    #line 674 
    return -14;
  #line 676 
  err = i40e_ptp_set_timestamp_mode(pf,& config);
  #line 677 
  if (err != 0) 
                #line 678 
                return err;
  #line 681 
  pf->tstamp_config = config;
  #line 684 
  if (copy_to_user(ifr->ifr_ifru.ifru_data,(void *)(& config),12UL) != 0UL) 
    #line 684 
    tmp_1 = -14; else 
                      #line 684 
                      tmp_1 = 0;
  #line 684 
  return tmp_1;
}

#line 697  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
static long i40e_ptp_create_clock(struct i40e_pf *pf)
{
  #line 700 
  if (! IS_ERR_OR_NULL((void *)pf->ptp_clock)) 
                                               #line 701 
                                               return 0L;
  #line 703 
  strlcpy((char *)(& pf->ptp_caps.name),(char *)(& i40e_driver_name),15UL);
  #line 705 
  pf->ptp_caps.owner = & __this_module;
  #line 706 
  pf->ptp_caps.max_adj = 999999999;
  #line 707 
  pf->ptp_caps.n_ext_ts = 0;
  #line 708 
  pf->ptp_caps.pps = 0;
  #line 709 
  pf->ptp_caps.adjfreq = & i40e_ptp_adjfreq;
  #line 710 
  pf->ptp_caps.adjtime = & i40e_ptp_adjtime;
  #line 711 
  pf->ptp_caps.gettimex64 = & i40e_ptp_gettimex;
  #line 712 
  pf->ptp_caps.settime64 = & i40e_ptp_settime;
  #line 713 
  pf->ptp_caps.enable = & i40e_ptp_feature_enable;
  #line 716 
  pf->ptp_clock = ptp_clock_register(& pf->ptp_caps,& (pf->pdev)->dev);
  #line 717 
  if ((int)IS_ERR((void *)pf->ptp_clock) != 0) {
    #line 718 
    return PTR_ERR((void *)pf->ptp_clock);
  }
  #line 724 
  pf->tstamp_config.rx_filter = 0;
  #line 725 
  pf->tstamp_config.tx_type = 0;
  #line 728 
  ktime_get_real_ts64(& pf->ptp_prev_hw_time);
  #line 729 
  pf->ptp_reset_start = ktime_get();
  #line 731 
  return 0L;
}

#line 743  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_save_hw_time(struct i40e_pf *pf)
{
  #line 746 
  if (((unsigned long)pf->flags & 131072UL) == 0UL) 
                                                    #line 747 
                                                    return;
  #line 749 
  i40e_ptp_gettimex(& pf->ptp_caps,& pf->ptp_prev_hw_time,(struct ptp_system_timestamp *)0);
  #line 751 
  pf->ptp_reset_start = ktime_get();
  #line 752 
  return;
}

#line 766  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_restore_hw_time(struct i40e_pf *pf)
{
  #line 768 
  ktime_t delta = ktime_get() - pf->ptp_reset_start;
  #line 771 
  ;
  #line 771 
  timespec64_add_ns(& pf->ptp_prev_hw_time,(unsigned long long)ktime_to_ns(delta));
  #line 774 
  i40e_ptp_settime(& pf->ptp_caps,& pf->ptp_prev_hw_time);
  #line 775 
  return;
}

#line 790  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_init(struct i40e_pf *pf)
{
  #line 794 
  u32 pf_id;
  #line 795 
  long err;
  #line 792 
  struct net_device *netdev = (*(pf->vsi + (unsigned long)pf->lan_vsi))->netdev;
  #line 793 
  struct i40e_hw *hw = & pf->hw;
  #line 800 
  pf_id = (readl((void *)(hw->hw_addr + 1982976U)) >> 8) & 15U;
  #line 802 
  if ((unsigned int)hw->pf_id != pf_id) {
    #line 803 
    pf->flags &= 4294836223U;
    #line 804 
    _dev_info(& (pf->pdev)->dev,(char *)"%s: PTP not supported on %s\n",(char *)"i40e_ptp_init",(char *)(& netdev->name));
    #line 807 
    return;
  }
  {
    #line 810 
    struct lock_class_key __key;
    #line 810 
    __mutex_init(& pf->tmreg_lock,(char *)"&pf->tmreg_lock",& __key);
  }
  #line 811 
  spinlock_check(& pf->ptp_rx_lock);
  {
    #line 811 
    struct lock_class_key __key_0;
    #line 811 
    __raw_spin_lock_init(& pf->ptp_rx_lock.__anonCompField_spinlock_25.rlock,(char *)"&(&pf->ptp_rx_lock)->rlock",& __key_0);
  }
  #line 814 
  err = i40e_ptp_create_clock(pf);
  #line 815 
  if (err != 0L) {
    #line 816 
    pf->ptp_clock = (struct ptp_clock *)0;
    #line 817 
    _dev_err(& (pf->pdev)->dev,(char *)"%s: ptp_clock_register failed\n",(char *)"i40e_ptp_init");
  }
  else 
    #line 819 
    if (pf->ptp_clock != (struct ptp_clock *)0) {
      #line 820 
      u32 regval;
      #line 822 
      if ((pf->hw.debug_mask & 256U) != 0U) 
                                            #line 823 
                                            _dev_info(& (pf->pdev)->dev,(char *)"PHC enabled\n");
      #line 824 
      pf->flags |= 131072U;
      #line 827 
      regval = readl((void *)(hw->hw_addr + 1982976U));
      #line 828 
      regval |= 2147483648U;
      #line 829 
      writel(regval,(void *)(hw->hw_addr + 1982976U));
      #line 830 
      regval = readl((void *)(hw->hw_addr + 544800U));
      #line 831 
      regval |= 2147483648U;
      #line 832 
      writel(regval,(void *)(hw->hw_addr + 544800U));
      #line 835 
      i40e_ptp_set_increment(pf);
      #line 838 
      i40e_ptp_set_timestamp_mode(pf,& pf->tstamp_config);
      #line 841 
      i40e_ptp_restore_hw_time(pf);
    }
  #line 843 
  return;
}

#line 852  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ptp.c"
void i40e_ptp_stop(struct i40e_pf *pf)
{
  #line 854 
  pf->flags &= 4294836223U;
  #line 855 
  pf->ptp_tx = (_Bool)0;
  #line 856 
  pf->ptp_rx = (_Bool)0;
  #line 858 
  if (pf->ptp_tx_skb != (struct sk_buff *)0) {
    #line 859 
    struct sk_buff *skb = pf->ptp_tx_skb;
    #line 861 
    pf->ptp_tx_skb = (struct sk_buff *)0;
    #line 862 
    clear_bit_unlock(18L,(unsigned long *)(& pf->state));
    #line 863 
    dev_kfree_skb_any(skb);
  }
  #line 866 
  if (pf->ptp_clock != (struct ptp_clock *)0) {
    #line 867 
    ptp_clock_unregister(pf->ptp_clock);
    #line 868 
    pf->ptp_clock = (struct ptp_clock *)0;
    #line 869 
    _dev_info(& (pf->pdev)->dev,(char *)"%s: removed PHC on %s\n",(char *)"i40e_ptp_stop",(char *)(& ((*(pf->vsi + (unsigned long)pf->lan_vsi))->netdev)->name));
  }
  #line 871 
  return;
}

#line 211  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ptp.i.aux"
static long PTR_ERR(void *ptr)
{
  #line 214 
  return ldv_ptr_err(ptr);
}

#line 218  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ptp.i.aux"
static bool IS_ERR(void *ptr)
{
  #line 221 
  return ldv_is_err(ptr);
}

#line 225  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ptp.i.aux"
static bool IS_ERR_OR_NULL(void *ptr)
{
  #line 228 
  return ldv_is_err_or_null(ptr);
}

#line 831  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ptp.i.aux"
static void cif_mutex_lock_tmreg_lock_of_i40e_pf(struct mutex *lock)
{
  #line 834 
  ldv_mutex_model_lock(lock,(char *)"tmreg_lock_of_i40e_pf");
  #line 835 
  return;
}

#line 838  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ptp.i.aux"
static void cif_mutex_unlock_tmreg_lock_of_i40e_pf(struct mutex *lock)
{
  #line 841 
  ldv_mutex_model_unlock(lock,(char *)"tmreg_lock_of_i40e_pf");
  #line 842 
  return;
}

#line 845  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ptp.i.aux"
static void cif_spin_lock_bh_ptp_rx_lock_of_i40e_pf(spinlock_t *lock)
{
  #line 848 
  ldv_spin_model_lock((char *)"ptp_rx_lock_of_i40e_pf");
  #line 850 
  spin_lock_bh(lock);
  #line 851 
  return;
}

#line 854  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ptp.i.aux"
static void cif_spin_unlock_bh_ptp_rx_lock_of_i40e_pf(spinlock_t *lock)
{
  #line 857 
  ldv_spin_model_unlock((char *)"ptp_rx_lock_of_i40e_pf");
  #line 859 
  spin_unlock_bh(lock);
  #line 860 
  return;
}

/* compiler builtin: 
   unsigned short __builtin_bswap16(unsigned short);   */
#line 136  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static bool arch_test_and_set_bit(long nr, unsigned long *addr)
{
  #line 138 
  bool c;
  #line 139 
  ldv_inline_asm();
  #line 138 
  return c;
}

#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/find.h"
#line 113  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static unsigned long cif_find_next_bit(unsigned long *addr, unsigned long size, unsigned long offset);
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/find.h"
#line 155  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static unsigned long cif_find_first_bit(unsigned long *addr, unsigned long size);
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 120  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static void cif_set_bit(long nr, unsigned long *addr);
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 127  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static void cif_clear_bit(long nr, unsigned long *addr);
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
__inline static bool test_and_set_bit(long nr, unsigned long *addr)
{
  #line 70 
  kasan_check_read((void *)(addr + (unsigned long)(nr / 64L)),8U);
  #line 71 
  return arch_test_and_set_bit(nr,addr);
}

#line 741  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void INIT_HLIST_NODE(struct hlist_node *h)
{
  #line 743 
  h->next = (struct hlist_node *)0;
  #line 744 
  h->pprev = (struct hlist_node **)0;
  #line 745 
  return;
}

#line 757  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __hlist_del(struct hlist_node *n)
{
  #line 759 
  struct hlist_node *next = n->next;
  #line 760 
  struct hlist_node **pprev = n->pprev;
  {
    #line 763 
    union __anonunion___u_1140 __u = {.__val = next};
    #line 762 
    __write_once_size((void *)pprev,(void *)(& __u.__c),8);
    #line 762 
    struct hlist_node *tmp = __u.__val;
  }
  #line 763 
  if (next != (struct hlist_node *)0) 
                                      #line 764 
                                      next->pprev = pprev;
  #line 765 
  return;
}

#line 767  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void hlist_del(struct hlist_node *n)
{
  #line 769 
  __hlist_del(n);
  #line 770 
  n->next = (struct hlist_node *)(-2401263026318606080);
  #line 771 
  n->pprev = (struct hlist_node **)(-2401263026318606046);
  #line 772 
  return;
}

#line 782  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
{
  #line 784 
  struct hlist_node *first = h->first;
  #line 785 
  n->next = first;
  #line 786 
  if (first != (struct hlist_node *)0) 
                                       #line 787 
                                       first->pprev = & n->next;
  {
    #line 789 
    union __anonunion___u_1142 __u = {.__val = n};
    #line 788 
    __write_once_size((void *)(& h->first),(void *)(& __u.__c),8);
    #line 788 
    struct hlist_node *tmp = __u.__val;
  }
  #line 789 
  n->pprev = & h->first;
  #line 790 
  return;
}

#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/string_64.h"
#line 14 
void *memcpy(void *, void *, size_t);
#line 61 
#line 61 
int memcmp(void *, void *, size_t);
#line 341  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_lock_bh_0(spinlock_t *lock)
{
  #line 343 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_25.rlock);
  #line 344 
  return;
}

#line 345 
#line 831  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static void cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi(spinlock_t *lock);
#line 381  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_unlock_bh_0(spinlock_t *lock)
{
  #line 383 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_25.rlock);
  #line 384 
  return;
}

#line 385 
#line 840  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static void cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi(spinlock_t *lock);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/bitmap.h"
#line 21 
void ldv_set_bit(long nr, unsigned long *addr);
#line 22 
#line 22 
void ldv_clear_bit(long nr, unsigned long *addr);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/find_bit.h"
#line 21 
unsigned long ldv_find_first_bit(unsigned long *addr, unsigned long size);
#line 22 
#line 22 
unsigned long ldv_find_next_bit(unsigned long *addr, unsigned long size, unsigned long offset);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 23 
void *ldv_kzalloc(size_t size, gfp_t flags);
#line 25 
#line 25 
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);
#line 257  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/overflow.h"
#line 257 
extern int ( /* missing proto */ __builtin_mul_overflow)(unsigned long x_0, unsigned long x_1, size_t *x_2);
#line 297 
#line 297 
extern int ( /* missing proto */ __builtin_add_overflow)(unsigned long x_0, unsigned long x_1, size_t *x_2);
#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/overflow.h"
__inline static size_t __ab_c_size(size_t a, size_t b, size_t c)
{
  #line 297 
  size_t *__d_0;
  #line 295 
  size_t __a;
  #line 295 
  size_t __b;
  #line 295 
  size_t *__d;
  #line 297 
  size_t __a_0;
  #line 297 
  size_t __b_0;
  #line 293 
  size_t bytes;
  {
    #line 295 
    __a = a;
    #line 295 
    __b = b;
    #line 295 
    __d = & bytes;
    #line 295 
    int tmp = & __a == __d;
    }
  #line 295 
  if (__builtin_mul_overflow(__a,__b,__d) != 0) 
                                                #line 296 
                                                return 18446744073709551615UL;
  {
    #line 297 
    __a_0 = bytes;
    #line 297 
    __b_0 = c;
    #line 297 
    __d_0 = & bytes;
    #line 297 
    int tmp_3 = & __a_0 == __d_0;
    }
  #line 297 
  if (__builtin_add_overflow(__a_0,__b_0,__d_0) != 0) 
                                                      #line 298 
                                                      return 18446744073709551615UL;
  #line 300 
  return bytes;
}

#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 189 
void kfree(void *);
#line 607 
#line 407  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static void *kcalloc(size_t n, size_t size, gfp_t flags);
#line 668  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 428  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static void *kzalloc(size_t size, gfp_t flags);
#line 1417  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device *dev)
{
  #line 1419 
  return dev->driver_data;
}

#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/delay.h"
#line 11 
void __const_udelay(unsigned long);
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/delay.h"
#line 59 
void msleep(unsigned int);
#line 61 
#line 61 
void usleep_range(unsigned long, unsigned long);
#line 2203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device *dev)
{
  #line 2205 
  return (void *)((char *)dev + 3328UL);
}

#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 *addr)
{
  #line 101 
  return (_Bool)((*((u32 *)addr) | (unsigned int)*((u16 *)(addr + 4U))) == 0U);
}

#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 *addr)
{
  #line 119 
  u32 a = *((u32 *)addr);
  #line 126 
  return (_Bool)((a & 1U) != 0U);
}

#line 162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool is_broadcast_ether_addr(u8 *addr)
{
  #line 166 
  return (_Bool)((unsigned int)(((int)*((u16 *)addr) & (int)*((u16 *)(addr + 2U))) & (int)*((u16 *)(addr + 4U))) == 65535U);
}

#line 191  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 *addr)
{
  #line 195 
  int tmp_1;
  #line 195 
  if (is_multicast_ether_addr(addr)) 
                                     #line 195 
                                     tmp_1 = 0;
  else {
    #line 195 
    if (is_zero_ether_addr(addr)) 
                                  #line 195 
                                  tmp_1 = 0; else 
                                                  #line 195 
                                                  tmp_1 = 1;
  }
  #line 195 
  return (_Bool)(tmp_1 != 0);
}

#line 238  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static void eth_broadcast_addr(u8 *addr)
{
  #line 240 
  memset((void *)addr,255,6UL);
  #line 241 
  return;
}

#line 276  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static void ether_addr_copy(u8 *dst, u8 *src)
{
  #line 279 
  *((u32 *)dst) = *((u32 *)src);
  #line 280 
  *((u16 *)(dst + 4U)) = *((u16 *)(src + 4U));
  #line 281 
  return;
}

#line 315  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 *addr1, u8 *addr2)
{
  #line 318 
  u32 fold = (*((u32 *)addr1) ^ *((u32 *)addr2)) | (unsigned int)((int)*((u16 *)(addr1 + 4U)) ^ (int)*((u16 *)(addr2 + 4U)));
  #line 321 
  return (_Bool)(fold == 0U);
}

#line 1833  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev)
{
  #line 1835 
  return dev_get_drvdata(& pdev->dev);
}

#line 2029 
#line 2029 
int pci_enable_sriov(struct pci_dev *, int);
#line 2030 
#line 2030 
void pci_disable_sriov(struct pci_dev *);
#line 2033 
#line 2033 
int pci_num_vf(struct pci_dev *);
#line 2034 
#line 2034 
int pci_vfs_assigned(struct pci_dev *);
#line 147  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
#line 147 
i40e_status i40e_clear_lan_tx_queue_context(struct i40e_hw *hw, u16 queue);
#line 149 
#line 149 
i40e_status i40e_set_lan_tx_queue_context(struct i40e_hw *hw, u16 queue, struct i40e_hmc_obj_txq *s);
#line 152 
#line 152 
i40e_status i40e_clear_lan_rx_queue_context(struct i40e_hw *hw, u16 queue);
#line 154 
#line 154 
i40e_status i40e_set_lan_rx_queue_context(struct i40e_hw *hw, u16 queue, struct i40e_hmc_obj_rxq *s);
#line 676  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/avf/virtchnl.h"
__inline static int virtchnl_vc_validate_vf_msg(struct virtchnl_version_info *ver, u32 v_opcode, u8 *msg, u16 msglen)
{
  #line 679 
  bool err_msg_format = (_Bool)0;
  #line 680 
  int valid_len = 0;
  #line 683 
  switch (v_opcode) {
    #line 684 
    case (u32)1: 
                 #line 684 
    ;
    #line 685 
    valid_len = 8;
    #line 686 
    break;
    #line 687 
    case (u32)2: 
                 #line 687 
    ;
    #line 688 
    break;
    #line 689 
    case (u32)3: 
                 #line 689 
    ;
    #line 690 
    if (ver->major == 1U && ver->minor == 1U) 
                                              #line 691 
                                              valid_len = 4;
    #line 692 
    break;
    #line 693 
    case (u32)4: 
                 #line 693 
    ;
    #line 694 
    valid_len = 24;
    #line 695 
    break;
    #line 696 
    case (u32)5: 
                 #line 696 
    ;
    #line 697 
    valid_len = 40;
    #line 698 
    break;
    #line 699 
    case (u32)6: 
                 #line 699 
    ;
    #line 700 
    valid_len = 72;
    #line 701 
    if ((int)msglen >= valid_len) {
      #line 702 
      struct virtchnl_vsi_queue_config_info *vqc = (struct virtchnl_vsi_queue_config_info *)msg;
      #line 704 
      valid_len = (int)((unsigned int)vqc->num_queue_pairs * 64U + (unsigned int)valid_len);
      #line 707 
      if ((unsigned int)vqc->num_queue_pairs == 0U) 
                                                    #line 708 
                                                    err_msg_format = (_Bool)1;
    }
    #line 710 
    break;
    #line 711 
    case (u32)7: 
                 #line 711 
    ;
    #line 712 
    valid_len = 14;
    #line 713 
    if ((int)msglen >= valid_len) {
      #line 714 
      struct virtchnl_irq_map_info *vimi = (struct virtchnl_irq_map_info *)msg;
      #line 716 
      valid_len = (int)((unsigned int)vimi->num_vectors * 12U + (unsigned int)valid_len);
      #line 718 
      if ((unsigned int)vimi->num_vectors == 0U) 
                                                 #line 719 
                                                 err_msg_format = (_Bool)1;
    }
    #line 721 
    break;
    #line 722 
    case (u32)8: 
                 #line 722 
    ;
    #line 723 
    case (u32)9: 
                 #line 723 
    ;
    #line 724 
    valid_len = 12;
    #line 725 
    break;
    #line 726 
    case (u32)10: 
                  #line 726 
    ;
    #line 727 
    case (u32)11: 
                  #line 727 
    ;
    #line 728 
    valid_len = 12;
    #line 729 
    if ((int)msglen >= valid_len) {
      #line 730 
      struct virtchnl_ether_addr_list *veal = (struct virtchnl_ether_addr_list *)msg;
      #line 732 
      valid_len = (int)((unsigned int)veal->num_elements * 8U + (unsigned int)valid_len);
      #line 734 
      if ((unsigned int)veal->num_elements == 0U) 
                                                  #line 735 
                                                  err_msg_format = (_Bool)1;
    }
    #line 737 
    break;
    #line 738 
    case (u32)12: 
                  #line 738 
    ;
    #line 739 
    case (u32)13: 
                  #line 739 
    ;
    #line 740 
    valid_len = 6;
    #line 741 
    if ((int)msglen >= valid_len) {
      #line 742 
      struct virtchnl_vlan_filter_list *vfl = (struct virtchnl_vlan_filter_list *)msg;
      #line 744 
      valid_len = (int)((unsigned int)vfl->num_elements * 2U + (unsigned int)valid_len);
      #line 745 
      if ((unsigned int)vfl->num_elements == 0U) 
                                                 #line 746 
                                                 err_msg_format = (_Bool)1;
    }
    #line 748 
    break;
    #line 749 
    case (u32)14: 
                  #line 749 
    ;
    #line 750 
    valid_len = 4;
    #line 751 
    break;
    #line 752 
    case (u32)15: 
                  #line 752 
    ;
    #line 753 
    valid_len = 12;
    #line 754 
    break;
    #line 755 
    case (u32)20: 
                  #line 755 
    ;
    #line 760 
    if ((unsigned int)msglen != 0U) 
                                    #line 761 
                                    valid_len = (int)msglen; else 
                                                                  #line 763 
                                                                  err_msg_format = (_Bool)1;
    #line 764 
    break;
    #line 765 
    case (u32)22: 
                  #line 765 
    ;
    #line 766 
    break;
    #line 767 
    case (u32)21: 
                  #line 767 
    ;
    #line 768 
    valid_len = 16;
    #line 769 
    if ((int)msglen >= valid_len) {
      #line 770 
      struct virtchnl_iwarp_qvlist_info *qv = (struct virtchnl_iwarp_qvlist_info *)msg;
      #line 772 
      if (qv->num_vectors == 0U) {
        #line 773 
        err_msg_format = (_Bool)1;
        #line 774 
        break;
      }
      #line 776 
      valid_len = (int)((qv->num_vectors * 12U + (u32)valid_len) + 4294967284U);
    }
    #line 779 
    break;
    #line 780 
    case (u32)23: 
                  #line 780 
    ;
    #line 781 
    valid_len = 6;
    #line 782 
    if ((int)msglen >= valid_len) {
      #line 783 
      struct virtchnl_rss_key *vrk = (struct virtchnl_rss_key *)msg;
      #line 785 
      valid_len = ((int)vrk->key_len + -1) + valid_len;
    }
    #line 787 
    break;
    #line 788 
    case (u32)24: 
                  #line 788 
    ;
    #line 789 
    valid_len = 6;
    #line 790 
    if ((int)msglen >= valid_len) {
      #line 791 
      struct virtchnl_rss_lut *vrl = (struct virtchnl_rss_lut *)msg;
      #line 793 
      valid_len = ((int)vrl->lut_entries + -1) + valid_len;
    }
    #line 795 
    break;
    #line 796 
    case (u32)25: 
                  #line 796 
    ;
    #line 797 
    break;
    #line 798 
    case (u32)26: 
                  #line 798 
    ;
    #line 799 
    valid_len = 8;
    #line 800 
    break;
    #line 801 
    case (u32)27: 
                  #line 801 
    ;
    #line 802 
    case (u32)28: 
                  #line 802 
    ;
    #line 803 
    break;
    #line 804 
    case (u32)29: 
                  #line 804 
    ;
    #line 805 
    valid_len = 2;
    #line 806 
    break;
    #line 807 
    case (u32)30: 
                  #line 807 
    ;
    #line 808 
    valid_len = 24;
    #line 809 
    if ((int)msglen >= valid_len) {
      #line 810 
      struct virtchnl_tc_info *vti = (struct virtchnl_tc_info *)msg;
      #line 812 
      valid_len = (int)((vti->num_tc + 4294967295U) * 16U + (u32)valid_len);
      #line 814 
      if (vti->num_tc == 0U) 
                             #line 815 
                             err_msg_format = (_Bool)1;
    }
    #line 817 
    break;
    #line 818 
    case (u32)31: 
                  #line 818 
    ;
    #line 819 
    break;
    #line 820 
    case (u32)32: 
                  #line 820 
    ;
    #line 821 
    valid_len = 272;
    #line 822 
    break;
    #line 823 
    case (u32)33: 
                  #line 823 
    ;
    #line 824 
    valid_len = 272;
    #line 825 
    break;
    #line 827 
    case (u32)17: 
                  #line 827 
    ;
    #line 828 
    case (u32)0: 
                 #line 828 
    ;
    #line 829 
    default: 
             #line 829 
    ;
    #line 830 
    return -5;
  }
  #line 833 
  if ((int)err_msg_format != 0 || (int)msglen != valid_len) 
                                                            #line 834 
                                                            return -38;
  #line 836 
  return 0;
}

#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 38 
char *i40e_aq_str(struct i40e_hw *hw, enum i40e_admin_queue_err aq_err);
#line 39 
#line 39 
char *i40e_stat_str(struct i40e_hw *hw, i40e_status stat_err);
#line 111 
#line 111 
i40e_status i40e_aq_set_vsi_unicast_promiscuous(struct i40e_hw *hw, u16 seid, bool set, struct i40e_asq_cmd_details *cmd_details, bool rx_only_promisc);
#line 114 
#line 114 
i40e_status i40e_aq_set_vsi_multicast_promiscuous(struct i40e_hw *hw, u16 seid, bool set, struct i40e_asq_cmd_details *cmd_details);
#line 116 
#line 116 
enum i40e_status_code i40e_aq_set_vsi_mc_promisc_on_vlan(struct i40e_hw *hw, u16 seid, bool enable, u16 vid, struct i40e_asq_cmd_details *cmd_details);
#line 120 
#line 120 
enum i40e_status_code i40e_aq_set_vsi_uc_promisc_on_vlan(struct i40e_hw *hw, u16 seid, bool enable, u16 vid, struct i40e_asq_cmd_details *cmd_details);
#line 133 
#line 133 
i40e_status i40e_aq_update_vsi_params(struct i40e_hw *hw, struct i40e_vsi_context *vsi_ctx, struct i40e_asq_cmd_details *cmd_details);
#line 161 
#line 161 
i40e_status i40e_aq_send_msg_to_vf(struct i40e_hw *hw, u16 vfid, u32 v_opcode, u32 v_retval, u8 *msg, u16 msglen, struct i40e_asq_cmd_details *cmd_details);
#line 232 
#line 232 
i40e_status i40e_aq_config_vsi_bw_limit(struct i40e_hw *hw, u16 seid, u16 credit, u8 max_credit, struct i40e_asq_cmd_details *cmd_details);
#line 356  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
__inline static enum virtchnl_link_speed i40e_virtchnl_link_speed(enum i40e_aq_link_speed link_speed)
{
  #line 358 
  switch ((unsigned int)link_speed) {
    #line 359 
    case (unsigned int)2: 
                          #line 359 
    ;
    #line 360 
    return VIRTCHNL_LINK_SPEED_100MB;
    #line 361 
    case (unsigned int)4: 
                          #line 361 
    ;
    #line 362 
    return VIRTCHNL_LINK_SPEED_1GB;
    #line 363 
    case (unsigned int)1: 
                          #line 363 
    ;
    #line 364 
    return VIRTCHNL_LINK_SPEED_2_5GB;
    #line 365 
    case (unsigned int)128: 
                            #line 365 
    ;
    #line 366 
    return VIRTCHNL_LINK_SPEED_5GB;
    #line 367 
    case (unsigned int)8: 
                          #line 367 
    ;
    #line 368 
    return VIRTCHNL_LINK_SPEED_10GB;
    #line 369 
    case (unsigned int)16: 
                           #line 369 
    ;
    #line 370 
    return VIRTCHNL_LINK_SPEED_40GB;
    #line 371 
    case (unsigned int)32: 
                           #line 371 
    ;
    #line 372 
    return VIRTCHNL_LINK_SPEED_20GB;
    #line 373 
    case (unsigned int)64: 
                           #line 373 
    ;
    #line 374 
    return VIRTCHNL_LINK_SPEED_25GB;
    #line 375 
    case (unsigned int)0: 
                          #line 375 
    ;
    #line 376 
    default: 
             #line 376 
    ;
    #line 377 
    return VIRTCHNL_LINK_SPEED_UNKNOWN;
  }
}

#line 413 
#line 413 
void i40e_write_rx_ctl(struct i40e_hw *hw, u32 reg_addr, u32 reg_val);
#line 117  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 1502  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
void i40e_free_vfs(struct i40e_pf *pf);
#line 118  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 1689  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_pci_sriov_configure(struct pci_dev *pdev, int num_vfs);
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 1577  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_alloc_vfs(struct i40e_pf *pf, u16 num_alloc_vfs);
#line 120  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 3741  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_vc_process_vf_msg(struct i40e_pf *pf, s16 vf_id, u32 v_opcode, u32 v_retval, u8 *msg, u16 msglen);
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 3877  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_vc_process_vflr_event(struct i40e_pf *pf);
#line 123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 1339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
bool i40e_reset_vf(struct i40e_vf *vf, bool flr);
#line 124  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 1404  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
bool i40e_reset_all_vfs(struct i40e_pf *pf, bool flr);
#line 125  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 114  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
void i40e_vc_notify_vf_reset(struct i40e_vf *vf);
#line 128  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 3949  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_mac(struct net_device *netdev, int vf_id, u8 *mac);
#line 129  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 4085  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_port_vlan(struct net_device *netdev, int vf_id, u16 vlan_id, u8 qos, __be16 vlan_proto);
#line 131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 4251  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_bw(struct net_device *netdev, int vf_id, int min_tx_rate, int max_tx_rate);
#line 133  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 4493  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_trust(struct net_device *netdev, int vf_id, bool setting);
#line 134  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 4304  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_get_vf_config(struct net_device *netdev, int vf_id, struct ifla_vf_info *ivi);
#line 136  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 4363  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_link_state(struct net_device *netdev, int vf_id, int link);
#line 137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 4433  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_spoofchk(struct net_device *netdev, int vf_id, bool enable);
#line 139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
void i40e_vc_notify_link_state(struct i40e_pf *pf);
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
void i40e_vc_notify_reset(struct i40e_pf *pf);
#line 141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h"
#line 4548  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_get_vf_stats(struct net_device *netdev, int vf_id, struct ifla_vf_stats *vf_stats);
#line 996  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 996 
void i40e_do_reset_safe(struct i40e_pf *pf, u32 reset_flags);
#line 998 
#line 998 
int i40e_config_rss(struct i40e_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
#line 1002 
#line 1002 
struct i40e_vsi *i40e_find_vsi_from_id(struct i40e_pf *pf, u16 id);
#line 1024 
#line 1024 
void i40e_update_eth_stats(struct i40e_vsi *vsi);
#line 1040 
#line 1040 
void __i40e_del_filter(struct i40e_vsi *vsi, struct i40e_mac_filter *f);
#line 1042 
#line 1042 
int i40e_sync_vsi_filters(struct i40e_vsi *vsi);
#line 1043 
#line 1043 
struct i40e_vsi *i40e_vsi_setup(struct i40e_pf *pf, u8 type, u16 uplink_seid, u32 param1);
#line 1045 
#line 1045 
int i40e_vsi_release(struct i40e_vsi *vsi);
#line 1046 
#line 1046 
void i40e_service_event_schedule(struct i40e_pf *pf);
#line 1047 
#line 1047 
void i40e_notify_client_of_vf_msg(struct i40e_vsi *vsi, u32 vf_id, u8 *msg, u16 len);
#line 1050 
#line 1050 
int i40e_control_wait_tx_q(int seid, struct i40e_pf *pf, int pf_q, bool is_xdp, bool enable);
#line 1052 
#line 1052 
int i40e_control_wait_rx_q(struct i40e_pf *pf, int pf_q, bool enable);
#line 1053 
#line 1053 
int i40e_vsi_start_rings(struct i40e_vsi *vsi);
#line 1054 
#line 1054 
void i40e_vsi_stop_rings(struct i40e_vsi *vsi);
#line 1055 
#line 1055 
void i40e_vsi_stop_rings_no_wait(struct i40e_vsi *vsi);
#line 1056 
#line 1056 
int i40e_vsi_wait_queues_disabled(struct i40e_vsi *vsi);
#line 1063 
#line 1063 
int i40e_vsi_add_pvid(struct i40e_vsi *vsi, u16 vid);
#line 1064 
#line 1064 
void i40e_vsi_remove_pvid(struct i40e_vsi *vsi);
#line 1084 
#line 1084 
void i40e_notify_client_of_vf_enable(struct i40e_pf *pf, u32 num_vfs);
#line 1085 
#line 1085 
void i40e_notify_client_of_vf_reset(struct i40e_pf *pf, u32 vf_id);
#line 1087 
#line 1087 
int i40e_vf_client_capable(struct i40e_pf *pf, u32 vf_id);
#line 1106 
#line 1106 
void i40e_irq_dynamic_disable_icr0(struct i40e_pf *pf);
#line 1107 
#line 1107 
void i40e_irq_dynamic_enable_icr0(struct i40e_pf *pf);
#line 1112 
#line 1112 
void i40e_vlan_stripping_disable(struct i40e_vsi *vsi);
#line 1113 
#line 1113 
int i40e_add_vlan_all_mac(struct i40e_vsi *vsi, s16 vid);
#line 1114 
#line 1114 
int i40e_vsi_add_vlan(struct i40e_vsi *vsi, u16 vid);
#line 1115 
#line 1115 
void i40e_rm_vlan_all_mac(struct i40e_vsi *vsi, s16 vid);
#line 1116 
#line 1116 
void i40e_vsi_kill_vlan(struct i40e_vsi *vsi, u16 vid);
#line 1117 
#line 1117 
struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi, u8 *macaddr);
#line 1119 
#line 1119 
int i40e_del_mac_filter(struct i40e_vsi *vsi, u8 *macaddr);
#line 1120 
#line 1120 
bool i40e_is_vsi_in_vlan(struct i40e_vsi *vsi);
#line 1121 
#line 1121 
int i40e_count_filters(struct i40e_vsi *vsi);
#line 1122 
#line 1122 
struct i40e_mac_filter *i40e_find_mac(struct i40e_vsi *vsi, u8 *macaddr);
#line 1123 
#line 1123 
void i40e_vlan_stripping_enable(struct i40e_vsi *vsi);
#line 1159 
#line 1159 
int i40e_set_bw_limit(struct i40e_vsi *vsi, u16 seid, u64 max_tx_rate);
#line 1160 
#line 1160 
int i40e_add_del_cloud_filter(struct i40e_vsi *vsi, struct i40e_cloud_filter *filter, bool add);
#line 1163 
#line 1163 
int i40e_add_del_cloud_filter_big_buf(struct i40e_vsi *vsi, struct i40e_cloud_filter *filter, bool add);
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_vc_vf_broadcast(struct i40e_pf *pf, enum virtchnl_ops v_opcode, i40e_status v_retval, u8 *msg, u16 msglen)
{
  #line 25 
  int i;
  #line 23 
  struct i40e_hw *hw = & pf->hw;
  #line 24 
  struct i40e_vf *vf = pf->vf;
  #line 27 
  i = 0;
  #line 27 
  while (pf->num_alloc_vfs > i) {
    {
      #line 28 
      int abs_vf_id = (int)vf->vf_id + (int)hw->func_caps.vf_base_id;
      #line 30 
      if (! test_bit(0L,& vf->vf_states)) {
        #line 31 
        if (! test_bit(1L,& vf->vf_states)) 
                                            #line 32 
                                            goto __Cont;
      }
      #line 37 
      i40e_aq_send_msg_to_vf(hw,(unsigned short)((int)((unsigned short)abs_vf_id)),(unsigned int)v_opcode,(unsigned int)v_retval,msg,(unsigned short)((int)msglen),(struct i40e_asq_cmd_details *)0);
    }
    #line 27 
    __Cont: 
            #line 27 
    i ++;
    #line 27 
    vf ++;
  }
  #line 39 
  return;
}

#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_vc_notify_vf_link_state(struct i40e_vf *vf)
{
  #line 50 
  struct virtchnl_pf_event pfe;
  #line 51 
  struct i40e_pf *pf = vf->pf;
  #line 52 
  struct i40e_hw *hw = & pf->hw;
  #line 53 
  struct i40e_link_status *ls = & pf->hw.phy.link_info;
  #line 54 
  int abs_vf_id = (int)vf->vf_id + (int)hw->func_caps.vf_base_id;
  #line 56 
  pfe.event = VIRTCHNL_EVENT_LINK_CHANGE;
  #line 57 
  pfe.severity = 0;
  #line 60 
  if (! vf->queues_enabled) {
    #line 61 
    pfe.event_data.link_event.link_status = (_Bool)0;
    #line 62 
    pfe.event_data.link_event.link_speed = VIRTCHNL_LINK_SPEED_UNKNOWN;
  }
  else 
    #line 63 
    if ((int)vf->link_forced != 0) {
      #line 64 
      pfe.event_data.link_event.link_status = vf->link_up;
      #line 65 
      if ((int)vf->link_up != 0) 
                                 #line 65 
                                 pfe.event_data.link_event.link_speed = VIRTCHNL_LINK_SPEED_40GB; else 
                                                                    #line 65 
                                                                    pfe.event_data.link_event.link_speed = VIRTCHNL_LINK_SPEED_UNKNOWN;
    }
    else {
      #line 68 
      pfe.event_data.link_event.link_status = (_Bool)(((int)ls->link_info & 1) != 0);
      #line 70 
      pfe.event_data.link_event.link_speed = i40e_virtchnl_link_speed(ls->link_speed);
    }
  #line 74 
  i40e_aq_send_msg_to_vf(hw,(unsigned short)((int)((unsigned short)abs_vf_id)),17U,0U,(u8 *)(& pfe),(unsigned short)16,(struct i40e_asq_cmd_details *)0);
  #line 76 
  return;
}

#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
void i40e_vc_notify_link_state(struct i40e_pf *pf)
{
  #line 86 
  int i;
  #line 88 
  i = 0;
  #line 88 
  while (pf->num_alloc_vfs > i) {
    #line 89 
    i40e_vc_notify_vf_link_state(pf->vf + (unsigned long)i);
    #line 88 
    i ++;
  }
  #line 90 
  return;
}

#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
void i40e_vc_notify_reset(struct i40e_pf *pf)
{
  #line 100 
  struct virtchnl_pf_event pfe;
  #line 102 
  pfe.event = VIRTCHNL_EVENT_RESET_IMPENDING;
  #line 103 
  pfe.severity = 255;
  #line 104 
  i40e_vc_vf_broadcast(pf,(enum virtchnl_ops)VIRTCHNL_OP_EVENT,(enum i40e_status_code)I40E_SUCCESS,(u8 *)(& pfe),(unsigned short)16);
  #line 106 
  return;
}

#line 114  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
void i40e_vc_notify_vf_reset(struct i40e_vf *vf)
{
  #line 116 
  struct virtchnl_pf_event pfe;
  #line 117 
  int abs_vf_id;
  #line 120 
  if (vf == (struct i40e_vf *)0 || (int)vf->vf_id >= (vf->pf)->num_alloc_vfs) 
    #line 121 
    return;
  #line 124 
  if (! test_bit(0L,& vf->vf_states)) {
    #line 125 
    if (! test_bit(1L,& vf->vf_states)) 
                                        #line 126 
                                        return;
  }
  #line 128 
  abs_vf_id = (int)vf->vf_id + (int)(vf->pf)->hw.func_caps.vf_base_id;
  #line 130 
  pfe.event = VIRTCHNL_EVENT_RESET_IMPENDING;
  #line 131 
  pfe.severity = 255;
  #line 132 
  i40e_aq_send_msg_to_vf(& (vf->pf)->hw,(unsigned short)((int)((unsigned short)abs_vf_id)),17U,0U,(u8 *)(& pfe),(unsigned short)16,(struct i40e_asq_cmd_details *)0);
  #line 134 
  return;
}

#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
__inline static void i40e_vc_disable_vf(struct i40e_vf *vf)
{
  #line 146 
  int i;
  #line 148 
  i40e_vc_notify_vf_reset(vf);
  #line 155 
  i = 0;
  #line 155 
  while (i <= 19) {
    {
      #line 156 
      if ((int)i40e_reset_vf(vf,(_Bool)0) != 0) 
                                                #line 157 
                                                return;
      #line 158 
      usleep_range(10000UL,20000UL);
    }
    #line 155 
    i ++;
  }
  #line 161 
  _dev_warn(& ((vf->pf)->pdev)->dev,(char *)"Failed to initiate reset for VF %d after 200 milliseconds\n",(int)vf->vf_id);
  #line 162 
  return;
}

#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
__inline static bool i40e_vc_isvalid_vsi_id(struct i40e_vf *vf, u16 vsi_id)
{
  #line 175 
  struct i40e_pf *pf = vf->pf;
  #line 176 
  struct i40e_vsi *vsi = i40e_find_vsi_from_id(pf,(unsigned short)((int)vsi_id));
  #line 178 
  return (_Bool)((vsi != (struct i40e_vsi *)0 && (int)vsi->vf_id == (int)vf->vf_id) != 0);
}

#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
__inline static bool i40e_vc_isvalid_queue_id(struct i40e_vf *vf, u16 vsi_id, u16 qid)
{
  #line 192 
  struct i40e_pf *pf = vf->pf;
  #line 193 
  struct i40e_vsi *vsi = i40e_find_vsi_from_id(pf,(unsigned short)((int)vsi_id));
  #line 195 
  return (_Bool)((vsi != (struct i40e_vsi *)0 && (int)vsi->alloc_queue_pairs > (int)qid) != 0);
}

#line 205  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
__inline static bool i40e_vc_isvalid_vector_id(struct i40e_vf *vf, u32 vector_id)
{
  #line 207 
  struct i40e_pf *pf = vf->pf;
  #line 209 
  return (_Bool)(pf->hw.func_caps.num_msix_vectors_vf > vector_id);
}

#line 222  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static u16 i40e_vc_get_pf_queue_id(struct i40e_vf *vf, u16 vsi_id, u8 vsi_queue_id)
{
  #line 225 
  struct i40e_pf *pf = vf->pf;
  #line 226 
  struct i40e_vsi *vsi = i40e_find_vsi_from_id(pf,(unsigned short)((int)vsi_id));
  #line 227 
  u16 pf_queue_id = (unsigned short)2047U;
  #line 229 
  if (vsi == (struct i40e_vsi *)0) 
                                   #line 230 
                                   return pf_queue_id;
  #line 232 
  if (((int)vsi->info.mapping_flags & 1) != 0) 
                                               #line 234 
                                               pf_queue_id = vsi->info.queue_mapping[(int)vsi_queue_id]; else 
                                                                    #line 237 
                                                                    pf_queue_id = (unsigned short)((int)vsi->info.queue_mapping[0] + (int)((unsigned short)vsi_queue_id));
  #line 240 
  return pf_queue_id;
}

#line 251  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static u16 i40e_get_real_pf_qid(struct i40e_vf *vf, u16 vsi_id, u16 queue_id)
{
  #line 253 
  int i;
  #line 255 
  if ((int)vf->adq_enabled != 0) {
    #line 260 
    i = 0;
    #line 260 
    while ((int)vf->num_tc > i) {
      #line 261 
      if ((int)vf->ch[i].num_qps > (int)queue_id) {
        #line 262 
        vsi_id = vf->ch[i].vsi_id;
        #line 263 
        break;
      }
      #line 268 
      queue_id = (unsigned short)((int)queue_id - (int)vf->ch[i].num_qps);
      #line 260 
      i ++;
    }
  }
  #line 272 
  return i40e_vc_get_pf_queue_id(vf,(unsigned short)((int)vsi_id),
                              (unsigned char)((int)((unsigned char)queue_id)));
}

#line 283  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_config_irq_link_list(struct i40e_vf *vf, u16 vsi_id, struct virtchnl_vector_map *vecmap)
{
  #line 286 
  unsigned long tempmap;
  #line 289 
  u16 vsi_queue_id;
  #line 289 
  u16 pf_queue_id;
  #line 290 
  enum i40e_queue_type qtype;
  #line 291 
  u16 next_q;
  #line 291 
  u16 vector_id;
  #line 291 
  u16 size;
  #line 292 
  u32 reg;
  #line 292 
  u32 reg_idx;
  #line 286 
  unsigned long linklistmap = 0UL;
  #line 287 
  struct i40e_pf *pf = vf->pf;
  #line 288 
  struct i40e_hw *hw = & pf->hw;
  #line 293 
  u16 itr_idx = (unsigned short)0U;
  #line 295 
  vector_id = vecmap->vector_id;
  #line 297 
  if ((unsigned int)vector_id == 0U) 
                                     #line 298 
                                     reg_idx = (unsigned int)(((int)vf->vf_id + 43520) * 4); else 
                                                                    #line 300 
                                                                    reg_idx = (((pf->hw.func_caps.num_msix_vectors_vf + 4294967295U) * (unsigned int)vf->vf_id + (unsigned int)vector_id) + 37887U) * 4U;
  #line 304 
  if ((unsigned int)vecmap->rxq_map == 0U && (unsigned int)vecmap->txq_map == 0U) {
    #line 306 
    writel(2047U,(void *)(hw->hw_addr + (unsigned long)reg_idx));
    #line 307 
    goto irq_list_done;
  }
  #line 309 
  tempmap = (unsigned long)vecmap->rxq_map;
  #line 310 
  vsi_queue_id = (unsigned short)cif_find_first_bit(& tempmap,16UL);
  #line 310 
  while ((unsigned int)vsi_queue_id <= 15U) {
    #line 311 
    linklistmap = (1UL << (int)vsi_queue_id * 2) | linklistmap;
    #line 310 
    vsi_queue_id = (unsigned short)cif_find_next_bit(& tempmap,16UL,
                          (unsigned long)((int)vsi_queue_id + 1));
  }
  #line 315 
  tempmap = (unsigned long)vecmap->txq_map;
  #line 316 
  vsi_queue_id = (unsigned short)cif_find_first_bit(& tempmap,16UL);
  #line 316 
  while ((unsigned int)vsi_queue_id <= 15U) {
    #line 317 
    linklistmap = (1UL << ((int)vsi_queue_id * 2 + 1)) | linklistmap;
    #line 316 
    vsi_queue_id = (unsigned short)cif_find_next_bit(& tempmap,16UL,
                          (unsigned long)((int)vsi_queue_id + 1));
  }
  #line 321 
  size = (unsigned short)32U;
  #line 322 
  next_q = (unsigned short)cif_find_first_bit(& linklistmap,(unsigned long)size);
  #line 323 
  if ((long)((int)next_q == (int)size) != 0L) 
                                              #line 324 
                                              goto irq_list_done;
  #line 326 
  vsi_queue_id = (unsigned short)((unsigned int)next_q / 2U);
  #line 327 
  qtype = (enum i40e_queue_type)((int)next_q & 1);
  #line 328 
  pf_queue_id = i40e_get_real_pf_qid(vf,(unsigned short)((int)vsi_id),(unsigned short)((int)vsi_queue_id));
  #line 329 
  reg = ((unsigned int)qtype << 11) | (unsigned int)pf_queue_id;
  #line 331 
  writel(reg,(void *)(hw->hw_addr + (unsigned long)reg_idx));
  #line 333 
  while ((int)next_q < (int)size) {
    #line 334 
    switch ((unsigned int)qtype) {
      #line 335 
      case (unsigned int)0: 
                            #line 335 
      ;
      #line 336 
      reg_idx = (unsigned int)(((int)pf_queue_id + 59392) * 4);
      #line 337 
      itr_idx = vecmap->rxitr_idx;
      #line 338 
      break;
      #line 339 
      case (unsigned int)1: 
                            #line 339 
      ;
      #line 340 
      reg_idx = (unsigned int)(((int)pf_queue_id + 61440) * 4);
      #line 341 
      itr_idx = vecmap->txitr_idx;
      #line 342 
      break;
      #line 343 
      default: 
               #line 343 
      ;
      #line 344 
      break;
    }
    #line 347 
    next_q = (unsigned short)cif_find_next_bit(& linklistmap,(unsigned long)size,
                          (unsigned long)((int)next_q + 1));
    #line 348 
    if ((int)next_q < (int)size) {
      #line 349 
      vsi_queue_id = (unsigned short)((unsigned int)next_q / 2U);
      #line 350 
      qtype = (enum i40e_queue_type)((int)next_q & 1);
      #line 351 
      pf_queue_id = i40e_get_real_pf_qid(vf,(unsigned short)((int)vsi_id),(unsigned short)((int)vsi_queue_id));
    }
    else {
      #line 355 
      pf_queue_id = (unsigned short)2047U;
      #line 356 
      qtype = I40E_QUEUE_TYPE_RX;
    }
    #line 360 
    reg = ((((unsigned int)vector_id | ((unsigned int)qtype << 27)) | (unsigned int)((int)pf_queue_id << 16)) | (unsigned int)((int)itr_idx << 11)) | 1073741824U;
    #line 365 
    writel(reg,(void *)(hw->hw_addr + (unsigned long)reg_idx));
  }
  #line 371 
  if ((vf->driver_caps & 131072U) != 0U && (unsigned int)vector_id == 0U) {
    #line 373 
    reg = readl((void *)(hw->hw_addr + 260096U));
    #line 374 
    if ((reg & 2U) == 0U) {
      #line 375 
      reg |= 2U;
      #line 376 
      writel(reg,(void *)(hw->hw_addr + 260096U));
    }
  }
  #line 380 
  irq_list_done: 
                 #line 380 
  ;
  #line 381 
  readl((void *)(hw->hw_addr + 745772U));
  #line 382 
  return;
}

#line 389  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_release_iwarp_qvlist(struct i40e_vf *vf)
{
  #line 393 
  u32 msix_vf;
  #line 394 
  u32 i;
  #line 391 
  struct i40e_pf *pf = vf->pf;
  #line 392 
  struct virtchnl_iwarp_qvlist_info *qvlist_info = vf->qvlist_info;
  #line 396 
  if (vf->qvlist_info == (struct virtchnl_iwarp_qvlist_info *)0) 
                                                                 #line 397 
                                                                 return;
  #line 399 
  msix_vf = pf->hw.func_caps.num_msix_vectors_vf;
  #line 400 
  i = 0U;
  #line 400 
  while (qvlist_info->num_vectors > i) {
    {
      #line 401 
      struct virtchnl_iwarp_qv_info *qv_info;
      #line 402 
      u32 next_q_index;
      #line 402 
      u32 next_q_type;
      #line 404 
      u32 v_idx;
      #line 404 
      u32 reg_idx;
      #line 404 
      u32 reg;
      #line 403 
      struct i40e_hw *hw = & pf->hw;
      #line 406 
      qv_info = & qvlist_info->qv_info[i];
      #line 407 
      if (qv_info == (struct virtchnl_iwarp_qv_info *)0) 
                                                         #line 408 
                                                         goto __Cont;
      #line 409 
      v_idx = qv_info->v_idx;
      #line 410 
      if ((unsigned int)qv_info->ceq_idx != 65535U) {
        #line 414 
        reg_idx = (msix_vf + 4294967295U) * (unsigned int)vf->vf_id + (unsigned int)qv_info->ceq_idx;
        #line 415 
        reg = readl((void *)(hw->hw_addr + (unsigned long)((reg_idx + 39424U) * 4U)));
        #line 416 
        next_q_index = (reg >> 16) & 2047U;
        #line 418 
        next_q_type = (reg >> 27) & 3U;
        #line 421 
        reg_idx = ((msix_vf + 4294967295U) * (unsigned int)vf->vf_id + v_idx) + 4294967295U;
        #line 422 
        reg = (next_q_index & 2047U) | (next_q_type << 11);
        #line 427 
        writel(reg,(void *)(hw->hw_addr + (unsigned long)((reg_idx + 37888U) * 4U)));
      }
    }
    #line 400 
    __Cont: 
            #line 400 
    i ++;
  }
  #line 430 
  kfree((void *)vf->qvlist_info);
  #line 431 
  vf->qvlist_info = (struct virtchnl_iwarp_qvlist_info *)0;
  #line 432 
  return;
}

#line 441  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_config_iwarp_qvlist(struct i40e_vf *vf, struct virtchnl_iwarp_qvlist_info *qvlist_info)
{
  #line 446 
  struct virtchnl_iwarp_qv_info *qv_info;
  #line 447 
  u32 v_idx;
  #line 447 
  u32 i;
  #line 447 
  u32 reg_idx;
  #line 447 
  u32 reg;
  #line 448 
  u32 next_q_idx;
  #line 448 
  u32 next_q_type;
  #line 449 
  u32 msix_vf;
  #line 444 
  struct i40e_pf *pf = vf->pf;
  #line 445 
  struct i40e_hw *hw = & pf->hw;
  #line 450 
  int ret = 0;
  #line 452 
  msix_vf = pf->hw.func_caps.num_msix_vectors_vf;
  #line 454 
  if (qvlist_info->num_vectors > msix_vf) {
    #line 455 
    _dev_warn(& (pf->pdev)->dev,(char *)"Incorrect number of iwarp vectors %u. Maximum %u allowed.\n",qvlist_info->num_vectors,msix_vf);
    #line 459 
    ret = -22;
    #line 460 
    goto err_out;
  }
  #line 463 
  kfree((void *)vf->qvlist_info);
  #line 464 
  vf->qvlist_info = (struct virtchnl_iwarp_qvlist_info *)kzalloc(__ab_c_size((unsigned long)(qvlist_info->num_vectors + 4294967295U),
                  12UL,16UL),
                3264U);
  #line 467 
  if (vf->qvlist_info == (struct virtchnl_iwarp_qvlist_info *)0) {
    #line 468 
    ret = -12;
    #line 469 
    goto err_out;
  }
  #line 471 
  (vf->qvlist_info)->num_vectors = qvlist_info->num_vectors;
  #line 473 
  msix_vf = pf->hw.func_caps.num_msix_vectors_vf;
  #line 474 
  i = 0U;
  #line 474 
  while (qvlist_info->num_vectors > i) {
    {
      #line 475 
      qv_info = & qvlist_info->qv_info[i];
      #line 476 
      if (qv_info == (struct virtchnl_iwarp_qv_info *)0) 
                                                         #line 477 
                                                         goto __Cont;
      #line 480 
      if (! i40e_vc_isvalid_vector_id(vf,qv_info->v_idx)) {
        #line 481 
        ret = -22;
        #line 482 
        goto err_free;
      }
      #line 485 
      v_idx = qv_info->v_idx;
      #line 487 
      (vf->qvlist_info)->qv_info[i] = *qv_info;
      #line 489 
      reg_idx = ((msix_vf + 4294967295U) * (unsigned int)vf->vf_id + v_idx) + 4294967295U;
      #line 494 
      reg = readl((void *)(hw->hw_addr + (unsigned long)((reg_idx + 37888U) * 4U)));
      #line 495 
      next_q_idx = reg & 2047U;
      #line 497 
      next_q_type = (reg >> 11) & 3U;
      #line 500 
      if ((unsigned int)qv_info->ceq_idx != 65535U) {
        #line 501 
        reg_idx = (msix_vf + 4294967295U) * (unsigned int)vf->vf_id + (unsigned int)qv_info->ceq_idx;
        #line 502 
        reg = ((((unsigned int)((int)qv_info->itr_idx << 11) | v_idx) | (next_q_type << 27)) | (next_q_idx << 16)) | 1073741824U;
        #line 507 
        writel(reg,(void *)(hw->hw_addr + (unsigned long)((reg_idx + 39424U) * 4U)));
        #line 509 
        reg_idx = ((msix_vf + 4294967295U) * (unsigned int)vf->vf_id + v_idx) + 4294967295U;
        #line 510 
        reg = ((unsigned int)qv_info->ceq_idx & 2047U) | 4096U;
        #line 514 
        writel(reg,(void *)(hw->hw_addr + (unsigned long)((reg_idx + 37888U) * 4U)));
      }
      #line 517 
      if ((unsigned int)qv_info->aeq_idx != 65535U) {
        #line 518 
        reg = ((unsigned int)((int)qv_info->itr_idx << 11) | v_idx) | 1073741824U;
        #line 522 
        writel(reg,(void *)(hw->hw_addr + (unsigned long)(((int)vf->vf_id + 44544) * 4)));
      }
    }
    #line 474 
    __Cont: 
            #line 474 
    i ++;
  }
  #line 526 
  return 0;
  #line 527 
  err_free: 
            #line 527 
  ;
  #line 528 
  kfree((void *)vf->qvlist_info);
  #line 529 
  vf->qvlist_info = (struct virtchnl_iwarp_qvlist_info *)0;
  #line 530 
  err_out: 
           #line 530 
  ;
  #line 531 
  return ret;
}

#line 543  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_config_vsi_tx_queue(struct i40e_vf *vf, u16 vsi_id, u16 vsi_queue_id, struct virtchnl_txq_info *info)
{
  #line 549 
  struct i40e_hmc_obj_txq tx_ctx;
  #line 550 
  struct i40e_vsi *vsi;
  #line 551 
  u16 pf_queue_id;
  #line 552 
  u32 qtx_ctl;
  #line 547 
  struct i40e_pf *pf = vf->pf;
  #line 548 
  struct i40e_hw *hw = & pf->hw;
  #line 553 
  int ret = 0;
  #line 555 
  if (! i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)info->vsi_id))) {
    #line 556 
    ret = -2;
    #line 557 
    goto error_context;
  }
  #line 559 
  pf_queue_id = i40e_vc_get_pf_queue_id(vf,(unsigned short)((int)vsi_id),(unsigned char)((int)((unsigned char)vsi_queue_id)));
  #line 560 
  vsi = i40e_find_vsi_from_id(pf,(unsigned short)((int)vsi_id));
  #line 561 
  if (vsi == (struct i40e_vsi *)0) {
    #line 562 
    ret = -2;
    #line 563 
    goto error_context;
  }
  #line 567 
  memset((void *)(& tx_ctx),0,48UL);
  #line 570 
  tx_ctx.base = info->dma_ring_addr / 128ULL;
  #line 571 
  tx_ctx.qlen = info->ring_len;
  #line 572 
  tx_ctx.rdylist = vsi->info.qs_handle[0];
  #line 573 
  tx_ctx.rdylist_act = (unsigned char)0U;
  #line 574 
  tx_ctx.head_wb_ena = (unsigned char)info->headwb_enabled;
  #line 575 
  tx_ctx.head_wb_addr = info->dma_headwb_addr;
  #line 578 
  ret = (int)i40e_clear_lan_tx_queue_context(hw,
                                        (unsigned short)((int)pf_queue_id));
  #line 579 
  if (ret != 0) {
    #line 580 
    _dev_err(& (pf->pdev)->dev,(char *)"Failed to clear VF LAN Tx queue context %d, error: %d\n",(int)pf_queue_id,ret);
    #line 583 
    ret = -2;
    #line 584 
    goto error_context;
  }
  #line 588 
  ret = (int)i40e_set_lan_tx_queue_context(hw,(unsigned short)((int)pf_queue_id),
                                      & tx_ctx);
  #line 589 
  if (ret != 0) {
    #line 590 
    _dev_err(& (pf->pdev)->dev,(char *)"Failed to set VF LAN Tx queue context %d error: %d\n",(int)pf_queue_id,ret);
    #line 593 
    ret = -2;
    #line 594 
    goto error_context;
  }
  #line 598 
  qtx_ctl = 0U;
  #line 599 
  qtx_ctl = ((unsigned int)((int)hw->pf_id << 2) & 60U) | qtx_ctl;
  #line 601 
  qtx_ctl = ((((unsigned int)vf->vf_id + hw->func_caps.vf_base_id) << 7) & 65535U) | qtx_ctl;
  #line 604 
  writel(qtx_ctl,(void *)(hw->hw_addr + (unsigned long)(((int)pf_queue_id + 266240) * 4)));
  #line 605 
  readl((void *)(hw->hw_addr + 745772U));
  #line 607 
  error_context: 
                 #line 607 
  ;
  #line 608 
  return ret;
}

#line 620  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_config_vsi_rx_queue(struct i40e_vf *vf, u16 vsi_id, u16 vsi_queue_id, struct virtchnl_rxq_info *info)
{
  #line 626 
  struct i40e_hmc_obj_rxq rx_ctx;
  #line 627 
  u16 pf_queue_id;
  #line 624 
  struct i40e_pf *pf = vf->pf;
  #line 625 
  struct i40e_hw *hw = & pf->hw;
  #line 628 
  int ret = 0;
  #line 630 
  pf_queue_id = i40e_vc_get_pf_queue_id(vf,(unsigned short)((int)vsi_id),(unsigned char)((int)((unsigned char)vsi_queue_id)));
  #line 633 
  memset((void *)(& rx_ctx),0,48UL);
  #line 636 
  rx_ctx.base = info->dma_ring_addr / 128ULL;
  #line 637 
  rx_ctx.qlen = (unsigned short)info->ring_len;
  #line 639 
  if ((unsigned int)info->splithdr_enabled != 0U) {
    #line 640 
    rx_ctx.hsplit_0 = (unsigned char)15U;
    #line 645 
    if ((unsigned int)info->hdr_size > 1984U) {
      #line 646 
      ret = -22;
      #line 647 
      goto error_param;
    }
    #line 649 
    rx_ctx.hbuff = (unsigned short)((int)info->hdr_size >> 6);
    #line 652 
    rx_ctx.dtype = (unsigned char)1U;
  }
  #line 656 
  if (info->databuffer_size > 16256U) {
    #line 657 
    ret = -22;
    #line 658 
    goto error_param;
  }
  #line 660 
  rx_ctx.dbuff = (unsigned short)(info->databuffer_size >> 7);
  #line 663 
  if (info->max_pkt_size + 4294967232U > 16319U) {
    #line 664 
    ret = -22;
    #line 665 
    goto error_param;
  }
  #line 667 
  rx_ctx.rxmax = info->max_pkt_size;
  #line 670 
  rx_ctx.dsize = (unsigned char)1U;
  #line 673 
  rx_ctx.lrxqthresh = (unsigned short)1U;
  #line 674 
  rx_ctx.crcstrip = (unsigned char)1U;
  #line 675 
  rx_ctx.prefena = (unsigned char)1U;
  #line 676 
  rx_ctx.l2tsel = (unsigned char)1U;
  #line 679 
  ret = (int)i40e_clear_lan_rx_queue_context(hw,(unsigned short)((int)pf_queue_id));
  #line 680 
  if (ret != 0) {
    #line 681 
    _dev_err(& (pf->pdev)->dev,(char *)"Failed to clear VF LAN Rx queue context %d, error: %d\n",(int)pf_queue_id,ret);
    #line 684 
    ret = -2;
    #line 685 
    goto error_param;
  }
  #line 689 
  ret = (int)i40e_set_lan_rx_queue_context(hw,(unsigned short)((int)pf_queue_id),
                                      & rx_ctx);
  #line 690 
  if (ret != 0) {
    #line 691 
    _dev_err(& (pf->pdev)->dev,(char *)"Failed to set VF LAN Rx queue context %d error: %d\n",(int)pf_queue_id,ret);
    #line 694 
    ret = -2;
    #line 695 
    goto error_param;
  }
  #line 698 
  error_param: 
               #line 698 
  ;
  #line 699 
  return ret;
}

#line 709  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_alloc_vsi_res(struct i40e_vf *vf, u8 idx)
{
  #line 713 
  struct i40e_vsi *vsi;
  #line 711 
  struct i40e_mac_filter *f = (struct i40e_mac_filter *)0;
  #line 712 
  struct i40e_pf *pf = vf->pf;
  #line 714 
  u64 max_tx_rate = 0ULL;
  #line 715 
  int ret = 0;
  #line 717 
  vsi = i40e_vsi_setup(pf,(unsigned char)6,(unsigned short)((int)(*(pf->vsi + (unsigned long)pf->lan_vsi))->seid),(unsigned int)vf->vf_id);
  #line 720 
  if (vsi == (struct i40e_vsi *)0) {
    #line 721 
    _dev_err(& (pf->pdev)->dev,(char *)"add vsi failed for VF %d, aq_err %d\n",(int)vf->vf_id,(unsigned int)pf->hw.aq.asq_last_status);
    #line 724 
    ret = -2;
    #line 725 
    goto error_alloc_vsi_res;
  }
  #line 728 
  if ((unsigned int)idx == 0U) {
    #line 729 
    unsigned long long tmp;
    #line 730 
    u8 broadcast[6U];
    #line 729 
    if (((unsigned long)pf->hw_features & 16UL) != 0UL) 
                                                        #line 729 
                                                        tmp = 9223512361489399808ULL; else 
                                                                    #line 729 
                                                                    tmp = 9223506308269867008ULL;
    #line 729 
    u64 hena = tmp;
    #line 732 
    vf->lan_vsi_idx = vsi->idx;
    #line 733 
    vf->lan_vsi_id = vsi->id;
    #line 740 
    if ((unsigned int)vf->port_vlan_id != 0U) 
                                              #line 741 
                                              i40e_vsi_add_pvid(vsi,(unsigned short)((int)vf->port_vlan_id));
    #line 743 
    cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
    #line 744 
    if ((int)is_valid_ether_addr((u8 *)(& vf->default_lan_addr.addr)) != 0) {
      #line 745 
      f = i40e_add_mac_filter(vsi,(u8 *)(& vf->default_lan_addr.addr));
      #line 747 
      if (f == (struct i40e_mac_filter *)0) 
                                            #line 748 
                                            _dev_info(& (pf->pdev)->dev,(char *)"Could not add MAC filter %pM for VF %d\n",(u8 *)(& vf->default_lan_addr.addr),(int)vf->vf_id);
    }
    #line 752 
    eth_broadcast_addr((u8 *)(& broadcast));
    #line 753 
    f = i40e_add_mac_filter(vsi,(u8 *)(& broadcast));
    #line 754 
    if (f == (struct i40e_mac_filter *)0) 
                                          #line 755 
                                          _dev_info(& (pf->pdev)->dev,(char *)"Could not allocate VF broadcast filter\n");
    #line 757 
    cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
    #line 758 
    writel((unsigned int)hena,(void *)(pf->hw.hw_addr + (unsigned long)(((int)vf->vf_id + 573952) * 4)));
    #line 759 
    writel((unsigned int)(hena >> 32),(void *)(pf->hw.hw_addr + (unsigned long)(((int)vf->vf_id + 574208) * 4)));
    #line 761 
    ret = i40e_sync_vsi_filters(vsi);
    #line 762 
    if (ret != 0) 
                  #line 763 
                  _dev_err(& (pf->pdev)->dev,(char *)"Unable to program ucast filters\n");
  }
  #line 767 
  if ((int)vf->adq_enabled != 0) {
    #line 768 
    vf->ch[(int)idx].vsi_idx = vsi->idx;
    #line 769 
    vf->ch[(int)idx].vsi_id = vsi->id;
  }
  #line 773 
  if (vf->tx_rate != 0U) 
                         #line 774 
                         max_tx_rate = (unsigned long long)vf->tx_rate;
  else 
    #line 775 
    if (vf->ch[(int)idx].max_tx_rate != 0ULL) 
                                              #line 776 
                                              max_tx_rate = vf->ch[(int)idx].max_tx_rate;
  #line 779 
  if (max_tx_rate != 0ULL) {
    #line 780 
    max_tx_rate = div_u64(max_tx_rate,50U);
    #line 781 
    ret = (int)i40e_aq_config_vsi_bw_limit(& pf->hw,
                                    (unsigned short)((int)vsi->seid),
                                    (unsigned short)((int)((unsigned short)max_tx_rate)),
                                    (unsigned char)0,
                                    (struct i40e_asq_cmd_details *)0);
    #line 783 
    if (ret != 0) 
                  #line 784 
                  _dev_err(& (pf->pdev)->dev,(char *)"Unable to set tx rate, VF %d, error code %d.\n",(int)vf->vf_id,ret);
  }
  #line 788 
  error_alloc_vsi_res: 
                       #line 788 
  ;
  #line 789 
  return ret;
}

#line 799  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_map_pf_queues_to_vsi(struct i40e_vf *vf)
{
  #line 803 
  u32 reg;
  #line 804 
  u16 vsi_id;
  #line 804 
  u16 qps;
  #line 805 
  int i;
  #line 805 
  int j;
  #line 801 
  struct i40e_pf *pf = vf->pf;
  #line 802 
  struct i40e_hw *hw = & pf->hw;
  #line 803 
  u32 num_tc = 1U;
  #line 807 
  if ((int)vf->adq_enabled != 0) 
                                 #line 808 
                                 num_tc = (unsigned int)vf->num_tc;
  #line 810 
  i = 0;
  #line 810 
  while ((unsigned int)i < num_tc) {
    #line 811 
    if ((int)vf->adq_enabled != 0) {
      #line 812 
      qps = vf->ch[i].num_qps;
      #line 813 
      vsi_id = vf->ch[i].vsi_id;
    }
    else {
      #line 815 
      qps = (*(pf->vsi + (unsigned long)vf->lan_vsi_idx))->alloc_queue_pairs;
      #line 816 
      vsi_id = vf->lan_vsi_id;
    }
    #line 819 
    j = 0;
    #line 819 
    while (j <= 6) {
      #line 820 
      if (j * 2 >= (int)qps) 
                             #line 822 
                             reg = 134154239U;
      else {
        #line 824 
        u16 qid = i40e_vc_get_pf_queue_id(vf,(unsigned short)((int)vsi_id),(unsigned char)((int)((unsigned int)((unsigned char)j) * 2U)));
        #line 827 
        reg = (unsigned int)qid;
        #line 828 
        qid = i40e_vc_get_pf_queue_id(vf,(unsigned short)((int)vsi_id),(unsigned char)((int)((unsigned int)((unsigned char)j) * 2U + 1U)));
        #line 830 
        reg = (unsigned int)((int)qid << 16) | reg;
      }
      #line 832 
      i40e_write_rx_ctl(hw,(unsigned int)(((j * 512 + (int)vsi_id) + 524288) * 4),reg);
      #line 819 
      j ++;
    }
    #line 810 
    i ++;
  }
  #line 836 
  return;
}

#line 846  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_map_pf_to_vf_queues(struct i40e_vf *vf)
{
  #line 850 
  u32 reg;
  #line 851 
  u32 qps;
  #line 852 
  u16 vsi_id;
  #line 852 
  u16 qid;
  #line 853 
  int i;
  #line 853 
  int j;
  #line 848 
  struct i40e_pf *pf = vf->pf;
  #line 849 
  struct i40e_hw *hw = & pf->hw;
  #line 850 
  u32 total_qps = 0U;
  #line 851 
  u32 num_tc = 1U;
  #line 855 
  if ((int)vf->adq_enabled != 0) 
                                 #line 856 
                                 num_tc = (unsigned int)vf->num_tc;
  #line 858 
  i = 0;
  #line 858 
  while ((unsigned int)i < num_tc) {
    #line 859 
    if ((int)vf->adq_enabled != 0) {
      #line 860 
      qps = (unsigned int)vf->ch[i].num_qps;
      #line 861 
      vsi_id = vf->ch[i].vsi_id;
    }
    else {
      #line 863 
      qps = (unsigned int)(*(pf->vsi + (unsigned long)vf->lan_vsi_idx))->alloc_queue_pairs;
      #line 864 
      vsi_id = vf->lan_vsi_id;
    }
    #line 867 
    j = 0;
    #line 867 
    while ((unsigned int)j < qps) {
      #line 868 
      qid = i40e_vc_get_pf_queue_id(vf,(unsigned short)((int)vsi_id),(unsigned char)((int)((unsigned char)j)));
      #line 870 
      reg = (unsigned int)qid & 2047U;
      #line 871 
      writel(reg,(void *)(hw->hw_addr + (unsigned long)((total_qps * 1024U + (unsigned int)((int)vf->vf_id * 4)) + 458752U)));
      #line 873 
      total_qps ++;
      #line 867 
      j ++;
    }
    #line 858 
    i ++;
  }
  #line 876 
  return;
}

#line 884  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_enable_vf_mappings(struct i40e_vf *vf)
{
  #line 888 
  u32 reg;
  #line 886 
  struct i40e_pf *pf = vf->pf;
  #line 887 
  struct i40e_hw *hw = & pf->hw;
  #line 894 
  i40e_write_rx_ctl(hw,(unsigned int)(((int)vf->lan_vsi_id + 537088) * 4),2048U);
  #line 898 
  reg = 1U;
  #line 899 
  writel(reg,(void *)(hw->hw_addr + (unsigned long)(((int)vf->vf_id + 118784) * 4)));
  #line 901 
  i40e_map_pf_to_vf_queues(vf);
  #line 902 
  i40e_map_pf_queues_to_vsi(vf);
  #line 904 
  readl((void *)(hw->hw_addr + 745772U));
  #line 905 
  return;
}

#line 913  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_disable_vf_mappings(struct i40e_vf *vf)
{
  #line 917 
  int i;
  #line 915 
  struct i40e_pf *pf = vf->pf;
  #line 916 
  struct i40e_hw *hw = & pf->hw;
  #line 920 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)(((int)vf->vf_id + 118784) * 4)));
  #line 921 
  i = 0;
  #line 921 
  while (i <= 15) {
    #line 922 
    writel(2047U,(void *)(hw->hw_addr + (unsigned long)(((i * 256 + (int)vf->vf_id) + 114688) * 4)));
    #line 921 
    i ++;
  }
  #line 924 
  readl((void *)(hw->hw_addr + 745772U));
  #line 925 
  return;
}

#line 933  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_free_vf_res(struct i40e_vf *vf)
{
  #line 937 
  u32 reg_idx;
  #line 937 
  u32 reg;
  #line 938 
  int i;
  #line 938 
  int j;
  #line 938 
  int msix_vf;
  #line 935 
  struct i40e_pf *pf = vf->pf;
  #line 936 
  struct i40e_hw *hw = & pf->hw;
  #line 943 
  cif_clear_bit(0L,& vf->vf_states);
  #line 948 
  if ((unsigned int)vf->num_queue_pairs > 4U) 
                                              #line 949 
                                              pf->queues_left += (int)vf->num_queue_pairs + -4;
  #line 954 
  if ((unsigned int)vf->lan_vsi_idx != 0U) {
    #line 955 
    i40e_vsi_release(*(pf->vsi + (unsigned long)vf->lan_vsi_idx));
    #line 956 
    vf->lan_vsi_idx = (unsigned short)0U;
    #line 957 
    vf->lan_vsi_id = (unsigned short)0U;
  }
  #line 961 
  if ((int)vf->adq_enabled != 0 && (unsigned int)vf->ch[0].vsi_idx != 0U) {
    #line 962 
    j = 0;
    #line 962 
    while ((int)vf->num_tc > j) {
      #line 967 
      if (j != 0) 
                  #line 968 
                  i40e_vsi_release(*(pf->vsi + (unsigned long)vf->ch[j].vsi_idx));
      #line 969 
      vf->ch[j].vsi_idx = (unsigned short)0U;
      #line 970 
      vf->ch[j].vsi_id = (unsigned short)0U;
      #line 962 
      j ++;
    }
  }
  #line 973 
  msix_vf = (int)pf->hw.func_caps.num_msix_vectors_vf;
  #line 976 
  i = 0;
  #line 976 
  while (i < msix_vf) {
    #line 978 
    if (i == 0) 
                #line 979 
                reg_idx = (unsigned int)(((int)vf->vf_id + 43264) * 4); else 
                                                                    #line 981 
                                                                    reg_idx = (unsigned int)((((msix_vf + -1) * (int)vf->vf_id + (i + -1)) + 37376) * 4);
    #line 984 
    writel(2U,(void *)(hw->hw_addr + (unsigned long)reg_idx));
    #line 985 
    readl((void *)(hw->hw_addr + 745772U));
    #line 976 
    i ++;
  }
  #line 989 
  i = 0;
  #line 989 
  while (i < msix_vf) {
    #line 991 
    if (i == 0) 
                #line 992 
                reg_idx = (unsigned int)(((int)vf->vf_id + 43520) * 4); else 
                                                                    #line 994 
                                                                    reg_idx = (unsigned int)((((msix_vf + -1) * (int)vf->vf_id + (i + -1)) + 37888) * 4);
    #line 997 
    reg = 8191U;
    #line 999 
    writel(reg,(void *)(hw->hw_addr + (unsigned long)reg_idx));
    #line 1000 
    readl((void *)(hw->hw_addr + 745772U));
    #line 989 
    i ++;
  }
  #line 1003 
  vf->num_queue_pairs = (unsigned char)0U;
  #line 1004 
  cif_clear_bit(4L,& vf->vf_states);
  #line 1005 
  cif_clear_bit(5L,& vf->vf_states);
  #line 1006 
  return;
}

#line 1014  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_alloc_vf_res(struct i40e_vf *vf)
{
  #line 1018 
  int ret;
  #line 1018 
  int idx;
  #line 1016 
  struct i40e_pf *pf = vf->pf;
  #line 1017 
  int total_queue_pairs = 0;
  #line 1020 
  if ((unsigned int)vf->num_req_queues != 0U && (int)vf->num_req_queues <= pf->queues_left + 4) 
    #line 1022 
    pf->num_vf_qps = (unsigned short)vf->num_req_queues; else 
                                                              #line 1024 
                                                              pf->num_vf_qps = (unsigned short)4U;
  #line 1027 
  ret = i40e_alloc_vsi_res(vf,(unsigned char)0);
  #line 1028 
  if (ret != 0) 
                #line 1029 
                goto error_alloc;
  #line 1030 
  total_queue_pairs = (int)(*(pf->vsi + (unsigned long)vf->lan_vsi_idx))->alloc_queue_pairs + total_queue_pairs;
  #line 1033 
  if ((int)vf->adq_enabled != 0) 
    #line 1034 
    if (pf->queues_left > 11) {
      #line 1037 
      idx = 1;
      #line 1037 
      while ((int)vf->num_tc > idx) {
        #line 1038 
        ret = i40e_alloc_vsi_res(vf,(unsigned char)((int)((unsigned char)idx)));
        #line 1039 
        if (ret != 0) 
                      #line 1040 
                      goto error_alloc;
        #line 1037 
        idx ++;
      }
      #line 1043 
      total_queue_pairs = 16;
    }
    else {
      #line 1045 
      _dev_info(& (pf->pdev)->dev,(char *)"VF %d: Not enough queues to allocate, disabling ADq\n",(int)vf->vf_id);
      #line 1047 
      vf->adq_enabled = (_Bool)0;
    }
  #line 1056 
  if (total_queue_pairs > 4) 
                             #line 1057 
                             pf->queues_left -= total_queue_pairs + -4;
  #line 1060 
  if ((int)vf->trusted != 0) 
                             #line 1061 
                             cif_set_bit(0L,& vf->vf_caps); else 
                                                                 #line 1063 
                                                                 cif_clear_bit(0L,& vf->vf_caps);
  #line 1068 
  vf->num_queue_pairs = (unsigned char)total_queue_pairs;
  #line 1071 
  cif_set_bit(0L,& vf->vf_states);
  #line 1073 
  error_alloc: 
               #line 1073 
  ;
  #line 1074 
  if (ret != 0) 
                #line 1075 
                i40e_free_vf_res(vf);
  #line 1077 
  return ret;
}

#line 1089  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_quiesce_vf_pci(struct i40e_vf *vf)
{
  #line 1093 
  int vf_abs_id;
  #line 1093 
  int i;
  #line 1094 
  u32 reg;
  #line 1091 
  struct i40e_pf *pf = vf->pf;
  #line 1092 
  struct i40e_hw *hw = & pf->hw;
  #line 1096 
  vf_abs_id = (int)((unsigned int)vf->vf_id + hw->func_caps.vf_base_id);
  #line 1098 
  writel((unsigned int)((vf_abs_id << 12) | 170),(void *)(hw->hw_addr + 639104U));
  #line 1100 
  i = 0;
  #line 1100 
  while (i <= 99) {
    #line 1101 
    reg = readl((void *)(hw->hw_addr + 639232U));
    #line 1102 
    if ((reg & 32U) == 0U) 
                           #line 1103 
                           return 0;
    #line 1104 
    __const_udelay(4295UL);
    #line 1100 
    i ++;
  }
  #line 1106 
  return -5;
}

#line 1109 
#line 1981 
static int i40e_getnum_vf_vsi_vlan_filters(struct i40e_vsi *vsi);
#line 1121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static i40e_status i40e_config_vf_promiscuous_mode(struct i40e_vf *vf, u16 vsi_id, bool allmulti, bool alluni)
{
  #line 1128 
  struct i40e_mac_filter *f;
  #line 1130 
  struct i40e_vsi *vsi;
  #line 1131 
  int bkt;
  #line 1126 
  struct i40e_pf *pf = vf->pf;
  #line 1127 
  struct i40e_hw *hw = & pf->hw;
  #line 1129 
  i40e_status aq_ret = 0;
  #line 1133 
  vsi = i40e_find_vsi_from_id(pf,(unsigned short)((int)vsi_id));
  #line 1134 
  if (i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vsi_id))) {
    #line 1134 
    if (vsi == (struct i40e_vsi *)0) 
                                     #line 1135 
                                     return I40E_ERR_PARAM;
  }
  else 
       #line 1135 
       return I40E_ERR_PARAM;
  #line 1137 
  if ((unsigned int)vf->port_vlan_id != 0U) {
    #line 1138 
    aq_ret = i40e_aq_set_vsi_mc_promisc_on_vlan(hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)allmulti) != 0),(unsigned short)((int)vf->port_vlan_id),(struct i40e_asq_cmd_details *)0);
    #line 1142 
    if (aq_ret != I40E_SUCCESS) {
      #line 1143 
      int aq_err = (int)pf->hw.aq.asq_last_status;
      #line 1145 
      ;
      #line 1145 
      ;
      #line 1145 
      _dev_err(& (pf->pdev)->dev,(char *)"VF %d failed to set multicast promiscuous mode err %s aq_err %s\n",(int)vf->vf_id,i40e_stat_str(& pf->hw,aq_ret),i40e_aq_str(& pf->hw,(enum i40e_admin_queue_err)aq_err));
      #line 1150 
      return aq_ret;
    }
    #line 1153 
    aq_ret = i40e_aq_set_vsi_uc_promisc_on_vlan(hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)alluni) != 0),(unsigned short)((int)vf->port_vlan_id),(struct i40e_asq_cmd_details *)0);
    #line 1157 
    if (aq_ret != I40E_SUCCESS) {
      #line 1158 
      int aq_err_0 = (int)pf->hw.aq.asq_last_status;
      #line 1160 
      ;
      #line 1160 
      ;
      #line 1160 
      _dev_err(& (pf->pdev)->dev,(char *)"VF %d failed to set unicast promiscuous mode err %s aq_err %s\n",(int)vf->vf_id,i40e_stat_str(& pf->hw,aq_ret),i40e_aq_str(& pf->hw,(enum i40e_admin_queue_err)aq_err_0));
    }
    #line 1166 
    return aq_ret;
  }
  else {
    #line 1167 
    if (i40e_getnum_vf_vsi_vlan_filters(vsi) != 0) {
      #line 1168 
      bkt = 0;
      #line 1168 
      f = (struct i40e_mac_filter *)0;
      #line 1168 
      while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
        {
          #line 1168 
          void *__mptr;
          #line 1168 
          struct i40e_mac_filter *tmp_5;
          {
            #line 1168 
            struct hlist_node *____ptr = vsi->mac_filter_hash[bkt].first;
            #line 1168 
            if (____ptr != (struct hlist_node *)0) {
              #line 1168 
              __mptr = (void *)____ptr;
              #line 1168 
              tmp_5 = ((struct i40e_mac_filter *)__mptr);
            }
            else 
                 #line 1168 
                 tmp_5 = (struct i40e_mac_filter *)0;
            }
          #line 1168 
          f = tmp_5;
          #line 1168 
          while (f != (struct i40e_mac_filter *)0) {
            #line 1168 
            struct i40e_mac_filter *tmp_8;
            #line 1168 
            void *__mptr_0;
            #line 1169 
            if ((unsigned int)f->vlan > 4095U) 
                                               #line 1170 
                                               goto __Cont;
            #line 1171 
            aq_ret = i40e_aq_set_vsi_mc_promisc_on_vlan(hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)allmulti) != 0),(unsigned short)((int)((unsigned short)f->vlan)),(struct i40e_asq_cmd_details *)0);
            #line 1176 
            if (aq_ret != I40E_SUCCESS) {
              #line 1177 
              int aq_err_1 = (int)pf->hw.aq.asq_last_status;
              #line 1179 
              ;
              #line 1179 
              ;
              #line 1179 
              _dev_err(& (pf->pdev)->dev,(char *)"Could not add VLAN %d to multicast promiscuous domain err %s aq_err %s\n",(int)f->vlan,i40e_stat_str(& pf->hw,aq_ret),i40e_aq_str(& pf->hw,(enum i40e_admin_queue_err)aq_err_1));
            }
            #line 1186 
            aq_ret = i40e_aq_set_vsi_uc_promisc_on_vlan(hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)alluni) != 0),(unsigned short)((int)((unsigned short)f->vlan)),(struct i40e_asq_cmd_details *)0);
            #line 1191 
            if (aq_ret != I40E_SUCCESS) {
              #line 1192 
              int aq_err_2 = (int)pf->hw.aq.asq_last_status;
              #line 1194 
              ;
              #line 1194 
              ;
              #line 1194 
              _dev_err(& (pf->pdev)->dev,(char *)"Could not add VLAN %d to Unicast promiscuous domain err %s aq_err %s\n",(int)f->vlan,i40e_stat_str(& pf->hw,aq_ret),i40e_aq_str(& pf->hw,(enum i40e_admin_queue_err)aq_err_2));
            }
            #line 1168 
            __Cont: { /* sequence */
                      {
                        #line 1168 
                        struct hlist_node *____ptr_0 = f->hlist.next;
                        #line 1168 
                        if (____ptr_0 != (struct hlist_node *)0) {
                          #line 1168 
                          __mptr_0 = (void *)____ptr_0;
                          #line 1168 
                          tmp_8 = ((struct i40e_mac_filter *)__mptr_0);
                        }
                        else 
                             #line 1168 
                             tmp_8 = (struct i40e_mac_filter *)0;
                        }
                      #line 1168 
                      f = tmp_8;
                    }
          }
        }
        #line 1168 
        bkt ++;
      }
      #line 1201 
      return aq_ret;
    }
  }
  #line 1203 
  aq_ret = i40e_aq_set_vsi_multicast_promiscuous(hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)allmulti) != 0),(struct i40e_asq_cmd_details *)0);
  #line 1205 
  if (aq_ret != I40E_SUCCESS) {
    #line 1206 
    int aq_err_3 = (int)pf->hw.aq.asq_last_status;
    #line 1208 
    ;
    #line 1208 
    ;
    #line 1208 
    _dev_err(& (pf->pdev)->dev,(char *)"VF %d failed to set multicast promiscuous mode err %s aq_err %s\n",(int)vf->vf_id,i40e_stat_str(& pf->hw,aq_ret),i40e_aq_str(& pf->hw,(enum i40e_admin_queue_err)aq_err_3));
    #line 1213 
    return aq_ret;
  }
  #line 1216 
  aq_ret = i40e_aq_set_vsi_unicast_promiscuous(hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)alluni) != 0),(struct i40e_asq_cmd_details *)0,(_Bool)1);
  #line 1218 
  if (aq_ret != I40E_SUCCESS) {
    #line 1219 
    int aq_err_4 = (int)pf->hw.aq.asq_last_status;
    #line 1221 
    ;
    #line 1221 
    ;
    #line 1221 
    _dev_err(& (pf->pdev)->dev,(char *)"VF %d failed to set unicast promiscuous mode err %s aq_err %s\n",(int)vf->vf_id,i40e_stat_str(& pf->hw,aq_ret),i40e_aq_str(& pf->hw,(enum i40e_admin_queue_err)aq_err_4));
  }
  #line 1228 
  return aq_ret;
}

#line 1240  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_trigger_vf_reset(struct i40e_vf *vf, bool flr)
{
  #line 1244 
  u32 reg;
  #line 1244 
  u32 reg_idx;
  #line 1244 
  u32 bit_idx;
  #line 1242 
  struct i40e_pf *pf = vf->pf;
  #line 1243 
  struct i40e_hw *hw = & pf->hw;
  #line 1247 
  cif_clear_bit(1L,& vf->vf_states);
  #line 1255 
  cif_clear_bit(0L,& vf->vf_states);
  #line 1260 
  if (! flr) {
    #line 1262 
    reg = readl((void *)(hw->hw_addr + (unsigned long)(((int)vf->vf_id + 148992) * 4)));
    #line 1263 
    reg |= 1U;
    #line 1264 
    writel(reg,(void *)(hw->hw_addr + (unsigned long)(((int)vf->vf_id + 148992) * 4)));
    #line 1265 
    readl((void *)(hw->hw_addr + 745772U));
  }
  #line 1268 
  reg_idx = (hw->func_caps.vf_base_id + (unsigned int)vf->vf_id) / 32U;
  #line 1269 
  bit_idx = (hw->func_caps.vf_base_id + (unsigned int)vf->vf_id) & 31U;
  #line 1270 
  writel((unsigned int)(1UL << bit_idx),(void *)(hw->hw_addr + (unsigned long)((reg_idx + 149888U) * 4U)));
  #line 1271 
  readl((void *)(hw->hw_addr + 745772U));
  #line 1273 
  if (i40e_quiesce_vf_pci(vf) != 0) 
                                    #line 1274 
                                    _dev_err(& (pf->pdev)->dev,(char *)"VF %d PCI transactions stuck\n",(int)vf->vf_id);
  #line 1275 
  return;
}

#line 1286  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_cleanup_reset_vf(struct i40e_vf *vf)
{
  #line 1290 
  u32 reg;
  #line 1288 
  struct i40e_pf *pf = vf->pf;
  #line 1289 
  struct i40e_hw *hw = & pf->hw;
  #line 1293 
  i40e_config_vf_promiscuous_mode(vf,(unsigned short)((int)vf->lan_vsi_id),(_Bool)0,(_Bool)0);
  #line 1296 
  i40e_free_vf_res(vf);
  #line 1308 
  reg = readl((void *)(hw->hw_addr + (unsigned long)(((int)vf->vf_id + 148992) * 4)));
  #line 1309 
  reg &= 4294967294U;
  #line 1310 
  writel(reg,(void *)(hw->hw_addr + (unsigned long)(((int)vf->vf_id + 148992) * 4)));
  #line 1313 
  if (i40e_alloc_vf_res(vf) == 0) {
    #line 1314 
    int abs_vf_id = (int)((unsigned int)vf->vf_id + hw->func_caps.vf_base_id);
    #line 1315 
    i40e_enable_vf_mappings(vf);
    #line 1316 
    cif_set_bit(1L,& vf->vf_states);
    #line 1317 
    cif_clear_bit(3L,& vf->vf_states);
    #line 1319 
    if (! test_and_set_bit(6L,& vf->vf_states)) 
                                                #line 1321 
                                                i40e_notify_client_of_vf_reset(pf,(unsigned int)abs_vf_id);
    #line 1322 
    vf->num_vlan = (unsigned short)0U;
  }
  #line 1329 
  writel(2U,(void *)(hw->hw_addr + (unsigned long)(((int)vf->vf_id + 119040) * 4)));
  #line 1330 
  return;
}

#line 1339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
bool i40e_reset_vf(struct i40e_vf *vf, bool flr)
{
  #line 1344 
  u32 reg;
  #line 1345 
  int i;
  #line 1341 
  struct i40e_pf *pf = vf->pf;
  #line 1342 
  struct i40e_hw *hw = & pf->hw;
  #line 1343 
  bool rsd = (_Bool)0;
  #line 1350 
  if ((int)test_and_set_bit(26L,(unsigned long *)(& pf->state)) != 0) 
    #line 1351 
    return (_Bool)0;
  #line 1353 
  i40e_trigger_vf_reset(vf,(_Bool)((bool)((int)flr) != 0));
  #line 1358 
  i = 0;
  #line 1358 
  while (i <= 9) {
    #line 1364 
    usleep_range(10000UL,20000UL);
    #line 1365 
    reg = readl((void *)(hw->hw_addr + (unsigned long)(((int)vf->vf_id + 149248) * 4)));
    #line 1366 
    if ((reg & 1U) != 0U) {
      #line 1367 
      rsd = (_Bool)1;
      #line 1368 
      break;
    }
    #line 1358 
    i ++;
  }
  #line 1372 
  if ((int)flr != 0) 
                     #line 1373 
                     usleep_range(10000UL,20000UL);
  #line 1375 
  if (! rsd) 
             #line 1376 
             _dev_err(& (pf->pdev)->dev,(char *)"VF reset check timeout on VF %d\n",(int)vf->vf_id);
  #line 1378 
  usleep_range(10000UL,20000UL);
  #line 1381 
  if ((unsigned int)vf->lan_vsi_idx != 0U) 
                                           #line 1382 
                                           i40e_vsi_stop_rings(*(pf->vsi + (unsigned long)vf->lan_vsi_idx));
  #line 1384 
  i40e_cleanup_reset_vf(vf);
  #line 1386 
  readl((void *)(hw->hw_addr + 745772U));
  #line 1387 
  cif_clear_bit(26L,(unsigned long *)(& pf->state));
  #line 1389 
  return (_Bool)1;
}

#line 1404  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
bool i40e_reset_all_vfs(struct i40e_pf *pf, bool flr)
{
  #line 1407 
  struct i40e_vf *vf;
  #line 1408 
  int i;
  #line 1408 
  int v;
  #line 1409 
  u32 reg;
  #line 1406 
  struct i40e_hw *hw = & pf->hw;
  #line 1412 
  if (pf->num_alloc_vfs == 0) 
                              #line 1413 
                              return (_Bool)0;
  #line 1416 
  if ((int)test_and_set_bit(26L,(unsigned long *)(& pf->state)) != 0) 
    #line 1417 
    return (_Bool)0;
  #line 1420 
  v = 0;
  #line 1420 
  while (pf->num_alloc_vfs > v) {
    #line 1421 
    i40e_trigger_vf_reset(pf->vf + (unsigned long)v,(_Bool)((bool)((int)flr) != 0));
    #line 1420 
    v ++;
  }
  #line 1429 
  i = 0;
  #line 1429 
  v = 0;
  #line 1429 
  while (i <= 9 && pf->num_alloc_vfs > v) {
    #line 1430 
    usleep_range(10000UL,20000UL);
    #line 1435 
    while (pf->num_alloc_vfs > v) {
      #line 1436 
      vf = pf->vf + (unsigned long)v;
      #line 1437 
      reg = readl((void *)(hw->hw_addr + (unsigned long)(((int)vf->vf_id + 149248) * 4)));
      #line 1438 
      if ((reg & 1U) == 0U) 
                            #line 1439 
                            break;
      #line 1444 
      v ++;
    }
    #line 1429 
    i ++;
  }
  #line 1448 
  if ((int)flr != 0) 
                     #line 1449 
                     usleep_range(10000UL,20000UL);
  #line 1454 
  if (pf->num_alloc_vfs > v) 
                             #line 1455 
                             _dev_err(& (pf->pdev)->dev,(char *)"VF reset check timeout on VF %d\n",(int)(pf->vf + (unsigned long)v)->vf_id);
  #line 1457 
  usleep_range(10000UL,20000UL);
  #line 1462 
  v = 0;
  #line 1462 
  while (pf->num_alloc_vfs > v) {
    #line 1464 
    if ((unsigned int)(pf->vf + (unsigned long)v)->lan_vsi_idx == 0U) 
      #line 1465 
      goto __Cont;
    #line 1467 
    i40e_vsi_stop_rings_no_wait(*(pf->vsi + (unsigned long)(pf->vf + (unsigned long)v)->lan_vsi_idx));
    #line 1462 
    __Cont: 
            #line 1462 
    v ++;
  }
  #line 1473 
  v = 0;
  #line 1473 
  while (pf->num_alloc_vfs > v) {
    #line 1475 
    if ((unsigned int)(pf->vf + (unsigned long)v)->lan_vsi_idx == 0U) 
      #line 1476 
      goto __Cont_0;
    #line 1478 
    i40e_vsi_wait_queues_disabled(*(pf->vsi + (unsigned long)(pf->vf + (unsigned long)v)->lan_vsi_idx));
    #line 1473 
    __Cont_0: 
              #line 1473 
    v ++;
  }
  {
    #line 1484 
    unsigned long __ms = 50UL;
    #line 1484 
    while (1) {
      #line 1484 
      unsigned long tmp_0;
      #line 1484 
      tmp_0 = __ms;
      #line 1484 
      __ms --;
      #line 1484 
      ;
      #line 1484 
      if (! (tmp_0 != 0UL)) 
                            #line 1484 
                            break;
      #line 1484 
      __const_udelay(4295000UL);
    }
  }
  #line 1487 
  v = 0;
  #line 1487 
  while (pf->num_alloc_vfs > v) {
    #line 1488 
    i40e_cleanup_reset_vf(pf->vf + (unsigned long)v);
    #line 1487 
    v ++;
  }
  #line 1490 
  readl((void *)(hw->hw_addr + 745772U));
  #line 1491 
  cif_clear_bit(26L,(unsigned long *)(& pf->state));
  #line 1493 
  return (_Bool)1;
}

#line 1502  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
void i40e_free_vfs(struct i40e_pf *pf)
{
  #line 1505 
  u32 reg_idx;
  #line 1505 
  u32 bit_idx;
  #line 1506 
  int i;
  #line 1506 
  int tmp;
  #line 1506 
  int vf_id;
  #line 1504 
  struct i40e_hw *hw = & pf->hw;
  #line 1508 
  if (pf->vf == (struct i40e_vf *)0) 
                                     #line 1509 
                                     return;
  #line 1510 
  while (1) {
    #line 1510 
    if (! ((int)test_and_set_bit(26L,(unsigned long *)(& pf->state)) != 0)) 
      #line 1510 
      break;
    #line 1511 
    usleep_range(1000UL,2000UL);
  }
  #line 1513 
  i40e_notify_client_of_vf_enable(pf,0U);
  #line 1516 
  i = 0;
  #line 1516 
  while (pf->num_alloc_vfs > i) {
    {
      #line 1517 
      if ((int)test_bit(0L,& (pf->vf + (unsigned long)i)->vf_states) != 0) 
        #line 1518 
        goto __Cont;
      #line 1520 
      i40e_vsi_stop_rings_no_wait(*(pf->vsi + (unsigned long)(pf->vf + (unsigned long)i)->lan_vsi_idx));
    }
    #line 1516 
    __Cont: 
            #line 1516 
    i ++;
  }
  #line 1523 
  i = 0;
  #line 1523 
  while (pf->num_alloc_vfs > i) {
    {
      #line 1524 
      if ((int)test_bit(0L,& (pf->vf + (unsigned long)i)->vf_states) != 0) 
        #line 1525 
        goto __Cont_0;
      #line 1527 
      i40e_vsi_wait_queues_disabled(*(pf->vsi + (unsigned long)(pf->vf + (unsigned long)i)->lan_vsi_idx));
    }
    #line 1523 
    __Cont_0: 
              #line 1523 
    i ++;
  }
  #line 1534 
  if (pci_vfs_assigned(pf->pdev) == 0) 
                                       #line 1535 
                                       pci_disable_sriov(pf->pdev); else 
                                                                    #line 1537 
                                                                    _dev_warn(& (pf->pdev)->dev,(char *)"VFs are assigned - not disabling SR-IOV\n");
  #line 1540 
  tmp = pf->num_alloc_vfs;
  #line 1541 
  pf->num_alloc_vfs = 0;
  #line 1542 
  i = 0;
  #line 1542 
  while (i < tmp) {
    {
      #line 1543 
      if ((int)test_bit(0L,& (pf->vf + (unsigned long)i)->vf_states) != 0) 
        #line 1544 
        i40e_free_vf_res(pf->vf + (unsigned long)i);
      #line 1546 
      i40e_disable_vf_mappings(pf->vf + (unsigned long)i);
    }
    #line 1542 
    i ++;
  }
  #line 1549 
  kfree((void *)pf->vf);
  #line 1550 
  pf->vf = (struct i40e_vf *)0;
  #line 1556 
  if (pci_vfs_assigned(pf->pdev) == 0) {
    #line 1560 
    vf_id = 0;
    #line 1560 
    while (vf_id < tmp) {
      #line 1561 
      reg_idx = (hw->func_caps.vf_base_id + (unsigned int)vf_id) / 32U;
      #line 1562 
      bit_idx = (hw->func_caps.vf_base_id + (unsigned int)vf_id) & 31U;
      #line 1563 
      writel((unsigned int)(1UL << bit_idx),(void *)(hw->hw_addr + (unsigned long)((reg_idx + 149888U) * 4U)));
      #line 1560 
      vf_id ++;
    }
  }
  #line 1566 
  cif_clear_bit(26L,(unsigned long *)(& pf->state));
  #line 1567 
  return;
}

#line 1577  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_alloc_vfs(struct i40e_pf *pf, u16 num_alloc_vfs)
{
  #line 1579 
  struct i40e_vf *vfs;
  #line 1580 
  int i;
  #line 1580 
  int ret = 0;
  #line 1583 
  i40e_irq_dynamic_disable_icr0(pf);
  #line 1586 
  ;
  #line 1586 
  if (pci_num_vf(pf->pdev) != (int)num_alloc_vfs) {
    #line 1587 
    ret = pci_enable_sriov(pf->pdev,(int)num_alloc_vfs);
    #line 1588 
    if (ret != 0) {
      #line 1589 
      pf->flags &= 4294963199U;
      #line 1590 
      pf->num_alloc_vfs = 0;
      #line 1591 
      goto err_iov;
    }
  }
  #line 1595 
  vfs = (struct i40e_vf *)kcalloc((unsigned long)num_alloc_vfs,192UL,3264U);
  #line 1596 
  if (vfs == (struct i40e_vf *)0) {
    #line 1597 
    ret = -12;
    #line 1598 
    goto err_alloc;
  }
  #line 1600 
  pf->vf = vfs;
  #line 1603 
  i = 0;
  #line 1603 
  while ((int)num_alloc_vfs > i) {
    #line 1604 
    (vfs + (unsigned long)i)->pf = pf;
    #line 1605 
    (vfs + (unsigned long)i)->parent_type = I40E_SWITCH_ELEMENT_TYPE_VEB;
    #line 1606 
    (vfs + (unsigned long)i)->vf_id = (short)i;
    #line 1609 
    cif_set_bit(1L,& (vfs + (unsigned long)i)->vf_caps);
    #line 1610 
    (vfs + (unsigned long)i)->spoofchk = (_Bool)1;
    #line 1612 
    cif_set_bit(6L,& (vfs + (unsigned long)i)->vf_states);
    #line 1603 
    i ++;
  }
  #line 1615 
  pf->num_alloc_vfs = (int)num_alloc_vfs;
  #line 1618 
  i40e_reset_all_vfs(pf,(_Bool)0);
  #line 1620 
  i40e_notify_client_of_vf_enable(pf,(unsigned int)num_alloc_vfs);
  #line 1622 
  err_alloc: 
             #line 1622 
  ;
  #line 1623 
  if (ret != 0) 
                #line 1624 
                i40e_free_vfs(pf);
  #line 1625 
  err_iov: 
           #line 1625 
  ;
  #line 1627 
  i40e_irq_dynamic_enable_icr0(pf);
  #line 1628 
  return ret;
}

#line 1639  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_pci_sriov_enable(struct pci_dev *pdev, int num_vfs)
{
  #line 1642 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  #line 1643 
  int pre_existing_vfs = pci_num_vf(pdev);
  #line 1644 
  int err = 0;
  #line 1646 
  if ((int)test_bit(0L,(unsigned long *)(& pf->state)) != 0) {
    #line 1647 
    _dev_warn(& pdev->dev,(char *)"Cannot enable SR-IOV virtual functions while the device is undergoing diagnostic testing\n");
    #line 1649 
    err = -1;
    #line 1650 
    goto err_out;
  }
  #line 1653 
  if (pre_existing_vfs != 0 && pre_existing_vfs != num_vfs) 
                                                            #line 1654 
                                                            i40e_free_vfs(pf);
  else 
    #line 1655 
    if (pre_existing_vfs != 0 && pre_existing_vfs == num_vfs) 
                                                              #line 1656 
                                                              goto out;
  #line 1658 
  if ((int)pf->num_req_vfs < num_vfs) {
    #line 1659 
    _dev_warn(& pdev->dev,(char *)"Unable to enable %d VFs. Limited to %d VFs due to device resource constraints.\n",num_vfs,(int)pf->num_req_vfs);
    #line 1661 
    err = -1;
    #line 1662 
    goto err_out;
  }
  #line 1665 
  _dev_info(& pdev->dev,(char *)"Allocating %d VFs.\n",num_vfs);
  #line 1666 
  err = i40e_alloc_vfs(pf,(unsigned short)((int)((unsigned short)num_vfs)));
  #line 1667 
  if (err != 0) {
    #line 1668 
    _dev_warn(& pdev->dev,(char *)"Failed to enable SR-IOV: %d\n",err);
    #line 1669 
    goto err_out;
  }
  #line 1672 
  out: 
       #line 1672 
  ;
  #line 1673 
  return num_vfs;
  #line 1675 
  err_out: 
           #line 1675 
  ;
  #line 1676 
  return err;
  #line 1678 
  return 0;
}

#line 1689  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_pci_sriov_configure(struct pci_dev *pdev, int num_vfs)
{
  #line 1691 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  #line 1692 
  int ret = 0;
  #line 1694 
  if ((int)test_and_set_bit(33L,(unsigned long *)(& pf->state)) != 0) {
    #line 1695 
    _dev_warn(& pdev->dev,(char *)"Unable to configure VFs, other operation is pending.\n");
    #line 1696 
    return -11;
  }
  #line 1699 
  if (num_vfs != 0) {
    #line 1700 
    if (((unsigned long)pf->flags & 4096UL) == 0UL) {
      #line 1701 
      pf->flags |= 4096U;
      #line 1702 
      i40e_do_reset_safe(pf,8192U);
    }
    #line 1704 
    ret = i40e_pci_sriov_enable(pdev,num_vfs);
    #line 1705 
    goto sriov_configure_out;
  }
  #line 1708 
  if (pci_vfs_assigned(pf->pdev) == 0) {
    #line 1709 
    i40e_free_vfs(pf);
    #line 1710 
    pf->flags &= 4294963199U;
    #line 1711 
    i40e_do_reset_safe(pf,8192U);
  }
  else {
    #line 1713 
    _dev_warn(& pdev->dev,(char *)"Unable to free VFs because some are assigned to VMs.\n");
    #line 1714 
    ret = -22;
    #line 1715 
    goto sriov_configure_out;
  }
  #line 1717 
  sriov_configure_out: 
                       #line 1717 
  ;
  #line 1718 
  cif_clear_bit(33L,(unsigned long *)(& pf->state));
  #line 1719 
  return ret;
}

#line 1734  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_send_msg_to_vf(struct i40e_vf *vf, u32 v_opcode, u32 v_retval, u8 *msg, u16 msglen)
{
  #line 1737 
  struct i40e_pf *pf;
  #line 1738 
  struct i40e_hw *hw;
  #line 1739 
  int abs_vf_id;
  #line 1740 
  i40e_status aq_ret;
  #line 1743 
  if (vf == (struct i40e_vf *)0 || (int)vf->vf_id >= (vf->pf)->num_alloc_vfs) 
    #line 1744 
    return -22;
  #line 1746 
  pf = vf->pf;
  #line 1747 
  hw = & pf->hw;
  #line 1748 
  abs_vf_id = (int)((unsigned int)vf->vf_id + hw->func_caps.vf_base_id);
  #line 1751 
  if (v_retval != 0U) {
    #line 1752 
    (vf->num_invalid_msgs) ++;
    #line 1753 
    _dev_info(& (pf->pdev)->dev,(char *)"VF %d failed opcode %d, retval: %d\n",(int)vf->vf_id,v_opcode,v_retval);
    #line 1755 
    if (vf->num_invalid_msgs > 10ULL) {
      #line 1757 
      _dev_err(& (pf->pdev)->dev,(char *)"Number of invalid messages exceeded for VF %d\n",(int)vf->vf_id);
      #line 1760 
      _dev_err(& (pf->pdev)->dev,(char *)"Use PF Control I/F to enable the VF\n");
      #line 1761 
      cif_set_bit(3L,& vf->vf_states);
    }
  }
  else {
    #line 1764 
    (vf->num_valid_msgs) ++;
    #line 1766 
    vf->num_invalid_msgs = 0ULL;
  }
  #line 1769 
  aq_ret = i40e_aq_send_msg_to_vf(hw,(unsigned short)((int)((unsigned short)abs_vf_id)),v_opcode,v_retval,msg,(unsigned short)((int)msglen),(struct i40e_asq_cmd_details *)0);
  #line 1771 
  if (aq_ret != I40E_SUCCESS) {
    #line 1772 
    _dev_info(& (pf->pdev)->dev,(char *)"Unable to send the message to VF %d aq_err %d\n",(int)vf->vf_id,(unsigned int)pf->hw.aq.asq_last_status);
    #line 1775 
    return -5;
  }
  #line 1778 
  return 0;
}

#line 1789  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_send_resp_to_vf(struct i40e_vf *vf, enum virtchnl_ops opcode, i40e_status retval)
{
  #line 1793 
  return i40e_vc_send_msg_to_vf(vf,(unsigned int)opcode,(unsigned int)retval,
                             (u8 *)0U,(unsigned short)0);
}

#line 1803  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_get_version_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 1805 
  struct virtchnl_version_info info = {.major = 1U, .minor = 1U};
  #line 1809 
  vf->vf_ver = *((struct virtchnl_version_info *)msg);
  #line 1811 
  if (vf->vf_ver.major == 1U && vf->vf_ver.minor == 0U) 
                                                        #line 1812 
                                                        info.minor = 0U;
  #line 1813 
  return i40e_vc_send_msg_to_vf(vf,1U,0U,(u8 *)(& info),(unsigned short)8);
}

#line 1822  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_del_qch(struct i40e_vf *vf)
{
  #line 1825 
  int i;
  #line 1824 
  struct i40e_pf *pf = vf->pf;
  #line 1830 
  i = 1;
  #line 1830 
  while ((int)vf->num_tc > i) {
    #line 1831 
    if ((unsigned int)vf->ch[i].vsi_idx != 0U) {
      #line 1832 
      i40e_vsi_release(*(pf->vsi + (unsigned long)vf->ch[i].vsi_idx));
      #line 1833 
      vf->ch[i].vsi_idx = (unsigned short)0U;
      #line 1834 
      vf->ch[i].vsi_id = (unsigned short)0U;
    }
    #line 1830 
    i ++;
  }
  #line 1836 
  return;
}

#line 1846  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_get_vf_resources_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 1851 
  struct i40e_vsi *vsi;
  #line 1854 
  int ret;
  #line 1848 
  struct virtchnl_vf_resource *vfres = (struct virtchnl_vf_resource *)0;
  #line 1849 
  struct i40e_pf *pf = vf->pf;
  #line 1850 
  i40e_status aq_ret = 0;
  #line 1852 
  int num_vsis = 1;
  #line 1853 
  size_t len = 0UL;
  #line 1856 
  if (! test_bit(0L,& vf->vf_states)) {
    #line 1857 
    aq_ret = I40E_ERR_PARAM;
    #line 1858 
    goto err;
  }
  #line 1861 
  len = __ab_c_size((unsigned long)num_vsis,16UL,36UL);
  #line 1862 
  vfres = (struct virtchnl_vf_resource *)kzalloc(len,3264U);
  #line 1863 
  if (vfres == (struct virtchnl_vf_resource *)0) {
    #line 1864 
    aq_ret = I40E_ERR_NO_MEMORY;
    #line 1865 
    len = 0UL;
    #line 1866 
    goto err;
  }
  #line 1868 
  if (vf->vf_ver.major == 1U && vf->vf_ver.minor == 1U) 
                                                        #line 1869 
                                                        vf->driver_caps = *((u32 *)msg); else 
                                                                    #line 1871 
                                                                    vf->driver_caps = 65553U;
  #line 1875 
  vfres->vf_cap_flags = 1U;
  #line 1876 
  vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 1877 
  if ((unsigned int)vsi->info.pvid == 0U) 
                                          #line 1878 
                                          vfres->vf_cap_flags |= 65536U;
  #line 1880 
  if (i40e_vf_client_capable(pf,(unsigned int)vf->vf_id) != 0) 
    #line 1880 
    if ((vf->driver_caps & 2U) != 0U) {
      #line 1882 
      vfres->vf_cap_flags |= 2U;
      #line 1883 
      cif_set_bit(2L,& vf->vf_states);
    }
    else 
         #line 1885 
         cif_clear_bit(2L,& vf->vf_states);
  else 
       #line 1885 
       cif_clear_bit(2L,& vf->vf_states);
  #line 1888 
  if ((vf->driver_caps & 524288U) != 0U) 
                                         #line 1889 
                                         vfres->vf_cap_flags |= 524288U;
  else 
    #line 1891 
    if (((unsigned long)pf->hw_features & 1UL) != 0UL && (vf->driver_caps & 8U) != 0U) 
      #line 1893 
      vfres->vf_cap_flags |= 8U; else 
                                      #line 1895 
                                      vfres->vf_cap_flags |= 16U;
  #line 1898 
  if (((unsigned long)pf->hw_features & 16UL) != 0UL) 
    #line 1899 
    if ((vf->driver_caps & 262144U) != 0U) 
                                           #line 1900 
                                           vfres->vf_cap_flags |= 262144U;
  #line 1904 
  if ((vf->driver_caps & 1048576U) != 0U) 
                                          #line 1905 
                                          vfres->vf_cap_flags |= 1048576U;
  #line 1907 
  if (((unsigned long)pf->hw_features & 16384UL) != 0UL && (vf->driver_caps & 2097152U) != 0U) 
    #line 1909 
    vfres->vf_cap_flags |= 2097152U;
  #line 1911 
  if ((vf->driver_caps & 131072U) != 0U) {
    #line 1912 
    if (((unsigned long)pf->flags & 1024UL) != 0UL) {
      #line 1913 
      _dev_err(& (pf->pdev)->dev,(char *)"VF %d requested polling mode: this feature is supported only when the device is running in single function per port (SFP) mode\n",(int)vf->vf_id);
      #line 1916 
      aq_ret = I40E_ERR_PARAM;
      #line 1917 
      goto err;
    }
    #line 1919 
    vfres->vf_cap_flags |= 131072U;
  }
  #line 1922 
  if (((unsigned long)pf->hw_features & 8UL) != 0UL) 
    #line 1923 
    if ((vf->driver_caps & 32U) != 0U) 
                                       #line 1924 
                                       vfres->vf_cap_flags |= 32U;
  #line 1928 
  if ((vf->driver_caps & 64U) != 0U) 
                                     #line 1929 
                                     vfres->vf_cap_flags |= 64U;
  #line 1931 
  if ((vf->driver_caps & 8388608U) != 0U) 
                                          #line 1932 
                                          vfres->vf_cap_flags |= 8388608U;
  #line 1934 
  vfres->num_vsis = (unsigned short)num_vsis;
  #line 1935 
  vfres->num_queue_pairs = (unsigned short)vf->num_queue_pairs;
  #line 1936 
  vfres->max_vectors = (unsigned short)pf->hw.func_caps.num_msix_vectors_vf;
  #line 1937 
  vfres->rss_key_size = 52U;
  #line 1938 
  vfres->rss_lut_size = 64U;
  #line 1940 
  if ((unsigned int)vf->lan_vsi_idx != 0U) {
    #line 1941 
    vfres->vsi_res[0].vsi_id = vf->lan_vsi_id;
    #line 1942 
    vfres->vsi_res[0].vsi_type = VIRTCHNL_VSI_SRIOV;
    #line 1943 
    vfres->vsi_res[0].num_queue_pairs = vsi->alloc_queue_pairs;
    #line 1946 
    vfres->vsi_res[0].qset_handle = vsi->info.qs_handle[0];
    #line 1947 
    ether_addr_copy((u8 *)(& vfres->vsi_res[0].default_mac_addr),(u8 *)(& vf->default_lan_addr.addr));
  }
  #line 1950 
  cif_set_bit(1L,& vf->vf_states);
  #line 1952 
  err: 
       #line 1952 
  ;
  #line 1954 
  ret = i40e_vc_send_msg_to_vf(vf,3U,(unsigned int)aq_ret,(u8 *)vfres,(unsigned short)((int)((unsigned short)len)));
  #line 1957 
  kfree((void *)vfres);
  #line 1958 
  return ret;
}

#line 1969  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_vc_reset_vf_msg(struct i40e_vf *vf)
{
  #line 1971 
  if ((int)test_bit(1L,& vf->vf_states) != 0) 
                                              #line 1972 
                                              i40e_reset_vf(vf,(_Bool)0);
  #line 1973 
  return;
}

#line 1981  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_getnum_vf_vsi_vlan_filters(struct i40e_vsi *vsi)
{
  #line 1983 
  struct i40e_mac_filter *f;
  #line 1984 
  int bkt;
  #line 1984 
  int num_vlans = 0;
  #line 1986 
  bkt = 0;
  #line 1986 
  f = (struct i40e_mac_filter *)0;
  #line 1986 
  while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
    {
      #line 1986 
      void *__mptr;
      #line 1986 
      struct i40e_mac_filter *tmp_0;
      {
        #line 1986 
        struct hlist_node *____ptr = vsi->mac_filter_hash[bkt].first;
        #line 1986 
        if (____ptr != (struct hlist_node *)0) {
          #line 1986 
          __mptr = (void *)____ptr;
          #line 1986 
          tmp_0 = ((struct i40e_mac_filter *)__mptr);
        }
        else 
             #line 1986 
             tmp_0 = (struct i40e_mac_filter *)0;
        }
      #line 1986 
      f = tmp_0;
      #line 1986 
      while (f != (struct i40e_mac_filter *)0) {
        #line 1986 
        void *__mptr_0;
        #line 1986 
        struct i40e_mac_filter *tmp_3;
        #line 1987 
        if ((unsigned int)f->vlan <= 4095U) 
                                            #line 1988 
                                            num_vlans ++;
        {
          #line 1986 
          struct hlist_node *____ptr_0 = f->hlist.next;
          #line 1986 
          if (____ptr_0 != (struct hlist_node *)0) {
            #line 1986 
            __mptr_0 = (void *)____ptr_0;
            #line 1986 
            tmp_3 = ((struct i40e_mac_filter *)__mptr_0);
          }
          else 
               #line 1986 
               tmp_3 = (struct i40e_mac_filter *)0;
          }
        #line 1986 
        f = tmp_3;
      }
    }
    #line 1986 
    bkt ++;
  }
  #line 1991 
  return num_vlans;
}

#line 2002  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_config_promiscuous_mode_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 2004 
  struct virtchnl_promisc_info *info = (struct virtchnl_promisc_info *)msg;
  #line 2006 
  struct i40e_pf *pf = vf->pf;
  #line 2007 
  i40e_status aq_ret = 0;
  #line 2008 
  bool allmulti = (_Bool)0;
  #line 2009 
  bool alluni = (_Bool)0;
  #line 2011 
  if (! test_bit(1L,& vf->vf_states)) {
    #line 2012 
    aq_ret = I40E_ERR_PARAM;
    #line 2013 
    goto err_out;
  }
  #line 2015 
  if (! test_bit(0L,& vf->vf_caps)) {
    #line 2016 
    _dev_err(& (pf->pdev)->dev,(char *)"Unprivileged VF %d is attempting to configure promiscuous mode\n",(int)vf->vf_id);
    #line 2023 
    aq_ret = I40E_SUCCESS;
    #line 2024 
    goto err_out;
  }
  #line 2027 
  if ((unsigned int)info->flags > 3U) {
    #line 2028 
    aq_ret = I40E_ERR_PARAM;
    #line 2029 
    goto err_out;
  }
  #line 2032 
  if (! i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)info->vsi_id))) {
    #line 2033 
    aq_ret = I40E_ERR_PARAM;
    #line 2034 
    goto err_out;
  }
  #line 2038 
  if (((int)info->flags & 2) != 0) 
                                   #line 2039 
                                   allmulti = (_Bool)1;
  #line 2041 
  if (((int)info->flags & 1) != 0) 
                                   #line 2042 
                                   alluni = (_Bool)1;
  #line 2043 
  aq_ret = i40e_config_vf_promiscuous_mode(vf,(unsigned short)((int)info->vsi_id),(_Bool)((bool)((int)allmulti) != 0),(_Bool)((bool)((int)alluni) != 0));
  #line 2045 
  if (aq_ret != I40E_SUCCESS) 
                              #line 2046 
                              goto err_out;
  #line 2048 
  if ((int)allmulti != 0) {
    #line 2049 
    if (! test_and_set_bit(4L,& vf->vf_states)) 
                                                #line 2051 
                                                _dev_info(& (pf->pdev)->dev,(char *)"VF %d successfully set multicast promiscuous mode\n",(int)vf->vf_id);
  }
  else {
    #line 2054 
    if ((int)test_and_set_bit(4L,& vf->vf_states) != 0) 
                                                        #line 2056 
                                                        _dev_info(& (pf->pdev)->dev,(char *)"VF %d successfully unset multicast promiscuous mode\n",(int)vf->vf_id);
  }
  #line 2060 
  if ((int)alluni != 0) {
    #line 2061 
    if (! test_and_set_bit(5L,& vf->vf_states)) 
                                                #line 2063 
                                                _dev_info(& (pf->pdev)->dev,(char *)"VF %d successfully set unicast promiscuous mode\n",(int)vf->vf_id);
  }
  else {
    #line 2066 
    if ((int)test_and_set_bit(5L,& vf->vf_states) != 0) 
                                                        #line 2068 
                                                        _dev_info(& (pf->pdev)->dev,(char *)"VF %d successfully unset unicast promiscuous mode\n",(int)vf->vf_id);
  }
  #line 2072 
  err_out: 
           #line 2072 
  ;
  #line 2074 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE,
                                aq_ret);
}

#line 2087  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_config_queues_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 2091 
  struct virtchnl_queue_pair_info *qpi;
  #line 2093 
  u16 vsi_id;
  #line 2096 
  int i;
  #line 2089 
  struct virtchnl_vsi_queue_config_info *qci = (struct virtchnl_vsi_queue_config_info *)msg;
  #line 2092 
  struct i40e_pf *pf = vf->pf;
  #line 2093 
  u16 vsi_queue_id = (unsigned short)0U;
  #line 2094 
  u16 num_qps_all = (unsigned short)0U;
  #line 2095 
  i40e_status aq_ret = 0;
  #line 2096 
  int j = 0;
  #line 2096 
  int idx = 0;
  #line 2098 
  if (! test_bit(1L,& vf->vf_states)) {
    #line 2099 
    aq_ret = I40E_ERR_PARAM;
    #line 2100 
    goto error_param;
  }
  #line 2103 
  if (! i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)qci->vsi_id))) {
    #line 2104 
    aq_ret = I40E_ERR_PARAM;
    #line 2105 
    goto error_param;
  }
  #line 2108 
  if ((unsigned int)qci->num_queue_pairs > 16U) {
    #line 2109 
    aq_ret = I40E_ERR_PARAM;
    #line 2110 
    goto error_param;
  }
  #line 2113 
  if ((int)vf->adq_enabled != 0) {
    #line 2114 
    i = 0;
    #line 2114 
    while (i <= 3) {
      #line 2115 
      num_qps_all = (unsigned short)((int)vf->ch[i].num_qps + (int)num_qps_all);
      #line 2114 
      i ++;
    }
    #line 2116 
    if ((int)qci->num_queue_pairs != (int)num_qps_all) {
      #line 2117 
      aq_ret = I40E_ERR_PARAM;
      #line 2118 
      goto error_param;
    }
  }
  #line 2122 
  vsi_id = qci->vsi_id;
  #line 2124 
  i = 0;
  #line 2124 
  while ((int)qci->num_queue_pairs > i) {
    {
      #line 2125 
      qpi = & qci->qpair[i];
      #line 2127 
      if (! vf->adq_enabled) {
        #line 2128 
        if (! i40e_vc_isvalid_queue_id(vf,(unsigned short)((int)vsi_id),
                                 (unsigned short)((int)qpi->txq.queue_id))) {
          #line 2130 
          aq_ret = I40E_ERR_PARAM;
          #line 2131 
          goto error_param;
        }
        #line 2134 
        vsi_queue_id = qpi->txq.queue_id;
        #line 2136 
        if (((int)qpi->txq.vsi_id != (int)qci->vsi_id || (int)qpi->rxq.vsi_id != (int)qci->vsi_id) || (int)qpi->rxq.queue_id != (int)vsi_queue_id) {
          #line 2139 
          aq_ret = I40E_ERR_PARAM;
          #line 2140 
          goto error_param;
        }
      }
      #line 2144 
      if ((int)vf->adq_enabled != 0) {
        #line 2145 
        if ((unsigned int)idx > 3U) {
          #line 2146 
          aq_ret = I40E_ERR_NO_AVAILABLE_VSI;
          #line 2147 
          goto error_param;
        }
        #line 2149 
        vsi_id = vf->ch[idx].vsi_id;
      }
      #line 2152 
      if (i40e_config_vsi_rx_queue(vf,(unsigned short)((int)vsi_id),
                                 (unsigned short)((int)vsi_queue_id),
                                 & qpi->rxq) != 0) 
        #line 2152 
        goto _LOR;
      else {
        #line 2153 
        if (i40e_config_vsi_tx_queue(vf,(unsigned short)((int)vsi_id),
                                 (unsigned short)((int)vsi_queue_id),
                                 & qpi->txq) != 0) {
          #line 2152 
          _LOR: {
                  #line 2156 
                  aq_ret = I40E_ERR_PARAM;
                  #line 2157 
                  goto error_param;
                }
        }
      }
      #line 2165 
      if ((int)vf->adq_enabled != 0) {
        #line 2166 
        if ((unsigned int)idx > 3U) {
          #line 2167 
          aq_ret = I40E_ERR_NO_AVAILABLE_VSI;
          #line 2168 
          goto error_param;
        }
        #line 2170 
        if ((int)vf->ch[idx].num_qps + -1 == j) {
          #line 2171 
          idx ++;
          #line 2172 
          j = 0;
          #line 2173 
          vsi_queue_id = (unsigned short)0U;
        }
        else {
          #line 2175 
          j ++;
          #line 2176 
          vsi_queue_id = (u16)((int)vsi_queue_id + 1);
        }
      }
    }
    #line 2124 
    i ++;
  }
  #line 2181 
  if (! vf->adq_enabled) 
                         #line 2182 
                         (*(pf->vsi + (unsigned long)vf->lan_vsi_idx))->num_queue_pairs = qci->num_queue_pairs;
  else {
    #line 2185 
    i = 0;
    #line 2185 
    while ((int)vf->num_tc > i) {
      #line 2186 
      (*(pf->vsi + (unsigned long)vf->ch[i].vsi_idx))->num_queue_pairs = vf->ch[i].num_qps;
      #line 2185 
      i ++;
    }
  }
  #line 2190 
  error_param: 
               #line 2190 
  ;
  #line 2192 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_CONFIG_VSI_QUEUES,
                                aq_ret);
}

#line 2203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_validate_queue_map(struct i40e_vf *vf, u16 vsi_id, unsigned long queuemap)
{
  #line 2206 
  u16 vsi_queue_id;
  #line 2206 
  u16 queue_id;
  #line 2208 
  vsi_queue_id = (unsigned short)cif_find_first_bit(& queuemap,16UL);
  #line 2208 
  while ((unsigned int)vsi_queue_id <= 15U) {
    {
      #line 2209 
      if ((int)vf->adq_enabled != 0) {
        #line 2210 
        vsi_id = vf->ch[(int)((unsigned int)vsi_queue_id / 4U)].vsi_id;
        #line 2211 
        queue_id = (unsigned short)((unsigned int)vsi_queue_id & 3U);
      }
      else 
           #line 2213 
           queue_id = vsi_queue_id;
      #line 2216 
      if (! i40e_vc_isvalid_queue_id(vf,(unsigned short)((int)vsi_id),
                                 (unsigned short)((int)queue_id))) 
        #line 2217 
        return -22;
    }
    #line 2208 
    vsi_queue_id = (unsigned short)cif_find_next_bit(& queuemap,16UL,
                          (unsigned long)((int)vsi_queue_id + 1));
  }
  #line 2220 
  return 0;
}

#line 2231  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_config_irq_map_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 2235 
  struct virtchnl_vector_map *map;
  #line 2236 
  u16 vsi_id;
  #line 2238 
  int i;
  #line 2233 
  struct virtchnl_irq_map_info *irqmap_info = (struct virtchnl_irq_map_info *)msg;
  #line 2237 
  i40e_status aq_ret = 0;
  #line 2240 
  if (! test_bit(1L,& vf->vf_states)) {
    #line 2241 
    aq_ret = I40E_ERR_PARAM;
    #line 2242 
    goto error_param;
  }
  #line 2245 
  if ((unsigned int)irqmap_info->num_vectors > (vf->pf)->hw.func_caps.num_msix_vectors_vf) {
    #line 2247 
    aq_ret = I40E_ERR_PARAM;
    #line 2248 
    goto error_param;
  }
  #line 2251 
  i = 0;
  #line 2251 
  while ((int)irqmap_info->num_vectors > i) {
    {
      #line 2252 
      map = & irqmap_info->vecmap[i];
      #line 2254 
      if (i40e_vc_isvalid_vector_id(vf,(unsigned int)map->vector_id)) {
        #line 2255 
        if (! i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)map->vsi_id))) {
          #line 2254 
          _LOR: {
                  #line 2256 
                  aq_ret = I40E_ERR_PARAM;
                  #line 2257 
                  goto error_param;
                }
        }
      }
      else 
           #line 2254 
           goto _LOR;
      #line 2259 
      vsi_id = map->vsi_id;
      #line 2261 
      if (i40e_validate_queue_map(vf,(unsigned short)((int)vsi_id),
                                (unsigned long)map->rxq_map) != 0) {
        #line 2262 
        aq_ret = I40E_ERR_PARAM;
        #line 2263 
        goto error_param;
      }
      #line 2266 
      if (i40e_validate_queue_map(vf,(unsigned short)((int)vsi_id),
                                (unsigned long)map->txq_map) != 0) {
        #line 2267 
        aq_ret = I40E_ERR_PARAM;
        #line 2268 
        goto error_param;
      }
      #line 2271 
      i40e_config_irq_link_list(vf,(unsigned short)((int)vsi_id),map);
    }
    #line 2251 
    i ++;
  }
  #line 2273 
  error_param: 
               #line 2273 
  ;
  #line 2275 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_CONFIG_IRQ_MAP,
                                aq_ret);
}

#line 2285  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_ctrl_vf_tx_rings(struct i40e_vsi *vsi, unsigned long q_map, bool enable)
{
  #line 2290 
  u16 q_id;
  #line 2288 
  struct i40e_pf *pf = vsi->back;
  #line 2289 
  int ret = 0;
  #line 2292 
  q_id = (unsigned short)cif_find_first_bit(& q_map,16UL);
  #line 2292 
  while ((unsigned int)q_id <= 15U) {
    #line 2293 
    ret = i40e_control_wait_tx_q((int)vsi->seid,pf,(int)vsi->base_queue + (int)q_id,(_Bool)0,(_Bool)((bool)((int)enable) != 0));
    #line 2296 
    if (ret != 0) 
                  #line 2297 
                  break;
    #line 2292 
    q_id = (unsigned short)cif_find_next_bit(& q_map,16UL,(unsigned long)((int)q_id + 1));
  }
  #line 2299 
  return ret;
}

#line 2308  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_ctrl_vf_rx_rings(struct i40e_vsi *vsi, unsigned long q_map, bool enable)
{
  #line 2313 
  u16 q_id;
  #line 2311 
  struct i40e_pf *pf = vsi->back;
  #line 2312 
  int ret = 0;
  #line 2315 
  q_id = (unsigned short)cif_find_first_bit(& q_map,16UL);
  #line 2315 
  while ((unsigned int)q_id <= 15U) {
    #line 2316 
    ret = i40e_control_wait_rx_q(pf,(int)vsi->base_queue + (int)q_id,(_Bool)((bool)((int)enable) != 0));
    #line 2318 
    if (ret != 0) 
                  #line 2319 
                  break;
    #line 2315 
    q_id = (unsigned short)cif_find_next_bit(& q_map,16UL,(unsigned long)((int)q_id + 1));
  }
  #line 2321 
  return ret;
}

#line 2330  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static bool i40e_vc_validate_vqs_bitmaps(struct virtchnl_queue_select *vqs)
{
  #line 2332 
  if ((vqs->rx_queues == 0U && vqs->tx_queues == 0U || vqs->rx_queues > 65535U) || vqs->tx_queues > 65535U) 
    #line 2335 
    return (_Bool)0;
  #line 2337 
  return (_Bool)1;
}

#line 2347  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_enable_queues_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 2353 
  int i;
  #line 2349 
  struct virtchnl_queue_select *vqs = (struct virtchnl_queue_select *)msg;
  #line 2351 
  struct i40e_pf *pf = vf->pf;
  #line 2352 
  i40e_status aq_ret = 0;
  #line 2355 
  if (! test_bit(1L,& vf->vf_states)) {
    #line 2356 
    aq_ret = I40E_ERR_PARAM;
    #line 2357 
    goto error_param;
  }
  #line 2360 
  if (! i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vqs->vsi_id))) {
    #line 2361 
    aq_ret = I40E_ERR_PARAM;
    #line 2362 
    goto error_param;
  }
  #line 2365 
  if ((int)i40e_vc_validate_vqs_bitmaps(vqs) != 0) {
    #line 2366 
    aq_ret = I40E_ERR_PARAM;
    #line 2367 
    goto error_param;
  }
  #line 2371 
  if (i40e_ctrl_vf_rx_rings(*(pf->vsi + (unsigned long)vf->lan_vsi_idx),
                              (unsigned long)vqs->rx_queues,(_Bool)1) != 0) {
    #line 2373 
    aq_ret = I40E_ERR_TIMEOUT;
    #line 2374 
    goto error_param;
  }
  #line 2376 
  if (i40e_ctrl_vf_tx_rings(*(pf->vsi + (unsigned long)vf->lan_vsi_idx),
                              (unsigned long)vqs->tx_queues,(_Bool)1) != 0) {
    #line 2378 
    aq_ret = I40E_ERR_TIMEOUT;
    #line 2379 
    goto error_param;
  }
  #line 2383 
  if ((int)vf->adq_enabled != 0) {
    #line 2385 
    i = 1;
    #line 2385 
    while ((int)vf->num_tc > i) {
      #line 2386 
      if (i40e_vsi_start_rings(*(pf->vsi + (unsigned long)vf->ch[i].vsi_idx)) != 0) 
        #line 2387 
        aq_ret = I40E_ERR_TIMEOUT;
      #line 2385 
      i ++;
    }
  }
  #line 2391 
  vf->queues_enabled = (_Bool)1;
  #line 2393 
  error_param: 
               #line 2393 
  ;
  #line 2395 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_ENABLE_QUEUES,
                                aq_ret);
}

#line 2407  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_disable_queues_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 2409 
  struct virtchnl_queue_select *vqs = (struct virtchnl_queue_select *)msg;
  #line 2411 
  struct i40e_pf *pf = vf->pf;
  #line 2412 
  i40e_status aq_ret = 0;
  #line 2415 
  vf->queues_enabled = (_Bool)0;
  #line 2417 
  if (! test_bit(1L,& vf->vf_states)) {
    #line 2418 
    aq_ret = I40E_ERR_PARAM;
    #line 2419 
    goto error_param;
  }
  #line 2422 
  if (! i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vqs->vsi_id))) {
    #line 2423 
    aq_ret = I40E_ERR_PARAM;
    #line 2424 
    goto error_param;
  }
  #line 2427 
  if ((int)i40e_vc_validate_vqs_bitmaps(vqs) != 0) {
    #line 2428 
    aq_ret = I40E_ERR_PARAM;
    #line 2429 
    goto error_param;
  }
  #line 2433 
  if (i40e_ctrl_vf_tx_rings(*(pf->vsi + (unsigned long)vf->lan_vsi_idx),
                              (unsigned long)vqs->tx_queues,(_Bool)0) != 0) {
    #line 2435 
    aq_ret = I40E_ERR_TIMEOUT;
    #line 2436 
    goto error_param;
  }
  #line 2438 
  if (i40e_ctrl_vf_rx_rings(*(pf->vsi + (unsigned long)vf->lan_vsi_idx),
                              (unsigned long)vqs->rx_queues,(_Bool)0) != 0) {
    #line 2440 
    aq_ret = I40E_ERR_TIMEOUT;
    #line 2441 
    goto error_param;
  }
  #line 2443 
  error_param: 
               #line 2443 
  ;
  #line 2445 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_DISABLE_QUEUES,
                                aq_ret);
}

#line 2459  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_request_queues_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 2461 
  struct virtchnl_vf_res_request *vfres = (struct virtchnl_vf_res_request *)msg;
  #line 2463 
  u16 req_pairs = vfres->num_queue_pairs;
  #line 2464 
  u8 cur_pairs = vf->num_queue_pairs;
  #line 2465 
  struct i40e_pf *pf = vf->pf;
  #line 2467 
  if (! test_bit(1L,& vf->vf_states)) 
                                      #line 2468 
                                      return -22;
  #line 2470 
  if ((unsigned int)req_pairs > 16U) {
    #line 2471 
    _dev_err(& (pf->pdev)->dev,(char *)"VF %d tried to request more than %d queues.\n",(int)vf->vf_id,16);
    #line 2475 
    vfres->num_queue_pairs = (unsigned short)16U;
  }
  else 
    #line 2476 
    if ((int)req_pairs - (int)cur_pairs > pf->queues_left) {
      #line 2477 
      _dev_warn(& (pf->pdev)->dev,(char *)"VF %d requested %d more queues, but only %d left.\n",(int)vf->vf_id,(int)req_pairs - (int)cur_pairs,pf->queues_left);
      #line 2482 
      vfres->num_queue_pairs = (unsigned short)((int)((unsigned short)pf->queues_left) + (int)((unsigned short)cur_pairs));
    }
    else {
      #line 2485 
      vf->num_req_queues = (unsigned char)req_pairs;
      #line 2486 
      i40e_vc_notify_vf_reset(vf);
      #line 2487 
      i40e_reset_vf(vf,(_Bool)0);
      #line 2488 
      return 0;
    }
  #line 2491 
  return i40e_vc_send_msg_to_vf(vf,29U,0U,(u8 *)vfres,(unsigned short)2);
}

#line 2502  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_get_stats_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 2507 
  struct i40e_eth_stats stats;
  #line 2509 
  struct i40e_vsi *vsi;
  #line 2504 
  struct virtchnl_queue_select *vqs = (struct virtchnl_queue_select *)msg;
  #line 2506 
  struct i40e_pf *pf = vf->pf;
  #line 2508 
  i40e_status aq_ret = 0;
  #line 2511 
  memset((void *)(& stats),0,96UL);
  #line 2513 
  if (! test_bit(1L,& vf->vf_states)) {
    #line 2514 
    aq_ret = I40E_ERR_PARAM;
    #line 2515 
    goto error_param;
  }
  #line 2518 
  if (! i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vqs->vsi_id))) {
    #line 2519 
    aq_ret = I40E_ERR_PARAM;
    #line 2520 
    goto error_param;
  }
  #line 2523 
  vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 2524 
  if (vsi == (struct i40e_vsi *)0) {
    #line 2525 
    aq_ret = I40E_ERR_PARAM;
    #line 2526 
    goto error_param;
  }
  #line 2528 
  i40e_update_eth_stats(vsi);
  #line 2529 
  stats = vsi->eth_stats;
  #line 2531 
  error_param: 
               #line 2531 
  ;
  #line 2533 
  return i40e_vc_send_msg_to_vf(vf,15U,(unsigned int)aq_ret,(u8 *)(& stats),
                               (unsigned short)96);
}

#line 2560  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
__inline static int i40e_check_vf_permission(struct i40e_vf *vf, struct virtchnl_ether_addr_list *al)
{
  #line 2566 
  int i;
  #line 2563 
  struct i40e_pf *pf = vf->pf;
  #line 2564 
  struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 2565 
  int mac2add_cnt = 0;
  #line 2568 
  i = 0;
  #line 2568 
  while ((int)al->num_elements > i) {
    {
      #line 2569 
      struct i40e_mac_filter *f;
      #line 2570 
      u8 *addr = (u8 *)(& al->list[i].addr);
      #line 2572 
      if ((int)is_broadcast_ether_addr(addr) != 0) 
                                                   #line 2572 
                                                   goto _LOR;
      else {
        #line 2572 
        if ((int)is_zero_ether_addr(addr) != 0) {
          #line 2572 
          _LOR: {
                  #line 2574 
                  _dev_err(& (pf->pdev)->dev,(char *)"invalid VF MAC addr %pM\n",addr);
                  #line 2576 
                  return -10;
                }
        }
      }
      #line 2586 
      if (! test_bit(0L,& vf->vf_caps)) {
        #line 2587 
        if (! is_multicast_ether_addr(addr)) 
          #line 2587 
          if ((int)vf->pf_set_mac != 0) {
            #line 2588 
            if (! ether_addr_equal(addr,(u8 *)(& vf->default_lan_addr.addr))) {
              #line 2589 
              _dev_err(& (pf->pdev)->dev,(char *)"VF attempting to override administratively set MAC address, bring down and up the VF interface to resume normal operation\n");
              #line 2591 
              return -1;
            }
          }
      }
      #line 2595 
      f = i40e_find_mac(vsi,addr);
      #line 2596 
      if (f == (struct i40e_mac_filter *)0) 
                                            #line 2597 
                                            mac2add_cnt ++;
    }
    #line 2568 
    i ++;
  }
  #line 2604 
  if (! test_bit(0L,& vf->vf_caps)) {
    #line 2604 
    ;
    #line 2604 
    if (i40e_count_filters(vsi) + mac2add_cnt > 18) {
      #line 2607 
      _dev_err(& (pf->pdev)->dev,(char *)"Cannot add more MAC addresses, VF is not trusted, switch the VF to trusted to add more functionality\n");
      #line 2609 
      return -1;
    }
  }
  #line 2611 
  return 0;
}

#line 2621  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_add_mac_addr_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 2628 
  int i;
  #line 2623 
  struct virtchnl_ether_addr_list *al = (struct virtchnl_ether_addr_list *)msg;
  #line 2625 
  struct i40e_pf *pf = vf->pf;
  #line 2626 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  #line 2627 
  i40e_status ret = 0;
  #line 2630 
  if (test_bit(1L,& vf->vf_states)) {
    #line 2631 
    if (! i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)al->vsi_id))) {
      #line 2630 
      _LOR: {
              #line 2632 
              ret = I40E_ERR_PARAM;
              #line 2633 
              goto error_param;
            }
    }
  }
  else 
       #line 2630 
       goto _LOR;
  #line 2636 
  vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 2641 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
  #line 2643 
  ret = (enum i40e_status_code)i40e_check_vf_permission(vf,al);
  #line 2644 
  if (ret != I40E_SUCCESS) {
    #line 2645 
    cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
    #line 2646 
    goto error_param;
  }
  #line 2650 
  i = 0;
  #line 2650 
  while ((int)al->num_elements > i) {
    {
      #line 2651 
      struct i40e_mac_filter *f;
      #line 2653 
      f = i40e_find_mac(vsi,(u8 *)(& al->list[i].addr));
      #line 2654 
      if (f == (struct i40e_mac_filter *)0) {
        #line 2655 
        f = i40e_add_mac_filter(vsi,(u8 *)(& al->list[i].addr));
        #line 2657 
        if (f == (struct i40e_mac_filter *)0) {
          #line 2658 
          _dev_err(& (pf->pdev)->dev,(char *)"Unable to add MAC filter %pM for VF %d\n",(u8 *)(& al->list[i].addr),(int)vf->vf_id);
          #line 2661 
          ret = I40E_ERR_PARAM;
          #line 2662 
          cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
          #line 2663 
          goto error_param;
        }
      }
    }
    #line 2650 
    i ++;
  }
  #line 2667 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
  #line 2670 
  ret = (enum i40e_status_code)i40e_sync_vsi_filters(vsi);
  #line 2671 
  if (ret != I40E_SUCCESS) 
                           #line 2672 
                           _dev_err(& (pf->pdev)->dev,(char *)"Unable to program VF %d MAC filters, error %d\n",(int)vf->vf_id,(int)ret);
  #line 2675 
  error_param: 
               #line 2675 
  ;
  #line 2677 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_ADD_ETH_ADDR,
                                ret);
}

#line 2688  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_del_mac_addr_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 2695 
  int i;
  #line 2690 
  struct virtchnl_ether_addr_list *al = (struct virtchnl_ether_addr_list *)msg;
  #line 2692 
  struct i40e_pf *pf = vf->pf;
  #line 2693 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  #line 2694 
  i40e_status ret = 0;
  #line 2697 
  if (test_bit(1L,& vf->vf_states)) {
    #line 2698 
    if (! i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)al->vsi_id))) {
      #line 2697 
      _LOR: {
              #line 2699 
              ret = I40E_ERR_PARAM;
              #line 2700 
              goto error_param;
            }
    }
  }
  else 
       #line 2697 
       goto _LOR;
  #line 2703 
  i = 0;
  #line 2703 
  while ((int)al->num_elements > i) {
    #line 2704 
    if ((int)is_broadcast_ether_addr((u8 *)(& al->list[i].addr)) != 0) 
      #line 2704 
      goto _LOR_0;
    else {
      #line 2704 
      if ((int)is_zero_ether_addr((u8 *)(& al->list[i].addr)) != 0) {
        #line 2704 
        _LOR_0: {
                  #line 2706 
                  _dev_err(& (pf->pdev)->dev,(char *)"Invalid MAC addr %pM for VF %d\n",(u8 *)(& al->list[i].addr),(int)vf->vf_id);
                  #line 2708 
                  ret = I40E_ERR_INVALID_MAC_ADDR;
                  #line 2709 
                  goto error_param;
                }
      }
    }
    #line 2703 
    i ++;
  }
  #line 2712 
  vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 2714 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
  #line 2716 
  i = 0;
  #line 2716 
  while ((int)al->num_elements > i) {
    #line 2717 
    if (i40e_del_mac_filter(vsi,(u8 *)(& al->list[i].addr)) != 0) {
      #line 2718 
      ret = I40E_ERR_INVALID_MAC_ADDR;
      #line 2719 
      cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
      #line 2720 
      goto error_param;
    }
    #line 2716 
    i ++;
  }
  #line 2723 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
  #line 2726 
  ret = (enum i40e_status_code)i40e_sync_vsi_filters(vsi);
  #line 2727 
  if (ret != I40E_SUCCESS) 
                           #line 2728 
                           _dev_err(& (pf->pdev)->dev,(char *)"Unable to program VF %d MAC filters, error %d\n",(int)vf->vf_id,(int)ret);
  #line 2731 
  error_param: 
               #line 2731 
  ;
  #line 2733 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_DEL_ETH_ADDR,
                                ret);
}

#line 2744  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_add_vlan_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 2751 
  int i;
  #line 2746 
  struct virtchnl_vlan_filter_list *vfl = (struct virtchnl_vlan_filter_list *)msg;
  #line 2748 
  struct i40e_pf *pf = vf->pf;
  #line 2749 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  #line 2750 
  i40e_status aq_ret = 0;
  #line 2753 
  if ((unsigned int)vf->num_vlan > 15U) {
    #line 2754 
    if (! test_bit(0L,& vf->vf_caps)) {
      #line 2755 
      _dev_err(& (pf->pdev)->dev,(char *)"VF is not trusted, switch the VF to trusted to add more VLAN addresses\n");
      #line 2757 
      goto error_param;
    }
  }
  #line 2759 
  if (test_bit(1L,& vf->vf_states)) {
    #line 2760 
    if (! i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vfl->vsi_id))) {
      #line 2759 
      _LOR: {
              #line 2761 
              aq_ret = I40E_ERR_PARAM;
              #line 2762 
              goto error_param;
            }
    }
  }
  else 
       #line 2759 
       goto _LOR;
  #line 2765 
  i = 0;
  #line 2765 
  while ((int)vfl->num_elements > i) {
    #line 2766 
    if ((unsigned int)vfl->vlan_id[i] > 4095U) {
      #line 2767 
      aq_ret = I40E_ERR_PARAM;
      #line 2768 
      _dev_err(& (pf->pdev)->dev,(char *)"invalid VF VLAN id %d\n",(int)vfl->vlan_id[i]);
      #line 2770 
      goto error_param;
    }
    #line 2765 
    i ++;
  }
  #line 2773 
  vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 2774 
  if ((unsigned int)vsi->info.pvid != 0U) {
    #line 2775 
    aq_ret = I40E_ERR_PARAM;
    #line 2776 
    goto error_param;
  }
  #line 2779 
  i40e_vlan_stripping_enable(vsi);
  #line 2780 
  i = 0;
  #line 2780 
  while ((int)vfl->num_elements > i) {
    {
      #line 2782 
      int ret = i40e_vsi_add_vlan(vsi,(unsigned short)((int)vfl->vlan_id[i]));
      #line 2783 
      if (ret == 0) 
                    #line 2784 
                    vf->num_vlan = (u16)((int)vf->num_vlan + 1);
      #line 2786 
      if ((int)test_bit(5L,& vf->vf_states) != 0) 
                                                  #line 2787 
                                                  i40e_aq_set_vsi_uc_promisc_on_vlan(& pf->hw,(unsigned short)((int)vsi->seid),(_Bool)1,(unsigned short)((int)vfl->vlan_id[i]),(struct i40e_asq_cmd_details *)0);
      #line 2791 
      if ((int)test_bit(4L,& vf->vf_states) != 0) 
                                                  #line 2792 
                                                  i40e_aq_set_vsi_mc_promisc_on_vlan(& pf->hw,(unsigned short)((int)vsi->seid),(_Bool)1,(unsigned short)((int)vfl->vlan_id[i]),(struct i40e_asq_cmd_details *)0);
      #line 2797 
      if (ret != 0) 
                    #line 2798 
                    _dev_err(& (pf->pdev)->dev,(char *)"Unable to add VLAN filter %d for VF %d, error %d\n",(int)vfl->vlan_id[i],(int)vf->vf_id,ret);
    }
    #line 2780 
    i ++;
  }
  #line 2803 
  error_param: 
               #line 2803 
  ;
  #line 2805 
  return i40e_vc_send_resp_to_vf(vf,(enum virtchnl_ops)VIRTCHNL_OP_ADD_VLAN,
                                aq_ret);
}

#line 2815  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_remove_vlan_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 2822 
  int i;
  #line 2817 
  struct virtchnl_vlan_filter_list *vfl = (struct virtchnl_vlan_filter_list *)msg;
  #line 2819 
  struct i40e_pf *pf = vf->pf;
  #line 2820 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  #line 2821 
  i40e_status aq_ret = 0;
  #line 2824 
  if (test_bit(1L,& vf->vf_states)) {
    #line 2825 
    if (! i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vfl->vsi_id))) {
      #line 2824 
      _LOR: {
              #line 2826 
              aq_ret = I40E_ERR_PARAM;
              #line 2827 
              goto error_param;
            }
    }
  }
  else 
       #line 2824 
       goto _LOR;
  #line 2830 
  i = 0;
  #line 2830 
  while ((int)vfl->num_elements > i) {
    #line 2831 
    if ((unsigned int)vfl->vlan_id[i] > 4095U) {
      #line 2832 
      aq_ret = I40E_ERR_PARAM;
      #line 2833 
      goto error_param;
    }
    #line 2830 
    i ++;
  }
  #line 2837 
  vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 2838 
  if ((unsigned int)vsi->info.pvid != 0U) {
    #line 2839 
    if ((unsigned int)vfl->num_elements > 1U || (unsigned int)vfl->vlan_id[0] != 0U) 
      #line 2840 
      aq_ret = I40E_ERR_PARAM;
    #line 2841 
    goto error_param;
  }
  #line 2844 
  i = 0;
  #line 2844 
  while ((int)vfl->num_elements > i) {
    {
      #line 2845 
      i40e_vsi_kill_vlan(vsi,(unsigned short)((int)vfl->vlan_id[i]));
      #line 2846 
      vf->num_vlan = (u16)((int)vf->num_vlan - 1);
      #line 2848 
      if ((int)test_bit(5L,& vf->vf_states) != 0) 
                                                  #line 2849 
                                                  i40e_aq_set_vsi_uc_promisc_on_vlan(& pf->hw,(unsigned short)((int)vsi->seid),(_Bool)0,(unsigned short)((int)vfl->vlan_id[i]),(struct i40e_asq_cmd_details *)0);
      #line 2853 
      if ((int)test_bit(4L,& vf->vf_states) != 0) 
                                                  #line 2854 
                                                  i40e_aq_set_vsi_mc_promisc_on_vlan(& pf->hw,(unsigned short)((int)vsi->seid),(_Bool)0,(unsigned short)((int)vfl->vlan_id[i]),(struct i40e_asq_cmd_details *)0);
    }
    #line 2844 
    i ++;
  }
  #line 2860 
  error_param: 
               #line 2860 
  ;
  #line 2862 
  return i40e_vc_send_resp_to_vf(vf,(enum virtchnl_ops)VIRTCHNL_OP_DEL_VLAN,
                                aq_ret);
}

#line 2873  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_iwarp_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
{
  #line 2875 
  struct i40e_pf *pf = vf->pf;
  #line 2876 
  int abs_vf_id = (int)((unsigned int)vf->vf_id + pf->hw.func_caps.vf_base_id);
  #line 2877 
  i40e_status aq_ret = 0;
  #line 2879 
  if (test_bit(1L,& vf->vf_states)) {
    #line 2880 
    if (! test_bit(2L,& vf->vf_states)) {
      #line 2879 
      _LOR: {
              #line 2881 
              aq_ret = I40E_ERR_PARAM;
              #line 2882 
              goto error_param;
            }
    }
  }
  else 
       #line 2879 
       goto _LOR;
  #line 2885 
  i40e_notify_client_of_vf_msg(*(pf->vsi + (unsigned long)pf->lan_vsi),(unsigned int)abs_vf_id,msg,(unsigned short)((int)msglen));
  #line 2888 
  error_param: 
               #line 2888 
  ;
  #line 2890 
  return i40e_vc_send_resp_to_vf(vf,(enum virtchnl_ops)VIRTCHNL_OP_IWARP,
                                aq_ret);
}

#line 2902  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_iwarp_qvmap_msg(struct i40e_vf *vf, u8 *msg, bool config)
{
  #line 2923 
  int tmp_2;
  #line 2904 
  struct virtchnl_iwarp_qvlist_info *qvlist_info = (struct virtchnl_iwarp_qvlist_info *)msg;
  #line 2906 
  i40e_status aq_ret = 0;
  #line 2908 
  if (test_bit(1L,& vf->vf_states)) {
    #line 2909 
    if (! test_bit(2L,& vf->vf_states)) {
      #line 2908 
      _LOR: {
              #line 2910 
              aq_ret = I40E_ERR_PARAM;
              #line 2911 
              goto error_param;
            }
    }
  }
  else 
       #line 2908 
       goto _LOR;
  #line 2914 
  if ((int)config != 0) {
    #line 2915 
    if (i40e_config_iwarp_qvlist(vf,qvlist_info) != 0) 
                                                       #line 2916 
                                                       aq_ret = I40E_ERR_PARAM;
  }
  else 
       #line 2918 
       i40e_release_iwarp_qvlist(vf);
  #line 2921 
  error_param: 
               #line 2921 
  ;
  #line 2923 
  ;
  #line 2923 
  if ((int)config != 0) 
                        #line 2923 
                        tmp_2 = VIRTCHNL_OP_CONFIG_IWARP_IRQ_MAP; else 
                                                                    #line 2923 
                                                                    tmp_2 = VIRTCHNL_OP_RELEASE_IWARP_IRQ_MAP;
  #line 2923 
  ;
  #line 2923 
  return i40e_vc_send_resp_to_vf(vf,(enum virtchnl_ops)tmp_2,aq_ret);
}

#line 2936  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_config_rss_key(struct i40e_vf *vf, u8 *msg)
{
  #line 2938 
  struct virtchnl_rss_key *vrk = (struct virtchnl_rss_key *)msg;
  #line 2940 
  struct i40e_pf *pf = vf->pf;
  #line 2941 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  #line 2942 
  i40e_status aq_ret = 0;
  #line 2944 
  if (test_bit(1L,& vf->vf_states)) {
    #line 2945 
    if (i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vrk->vsi_id))) {
      #line 2945 
      if ((unsigned int)vrk->key_len != 52U) {
        #line 2944 
        _LOR: {
                #line 2947 
                aq_ret = I40E_ERR_PARAM;
                #line 2948 
                goto err;
              }
      }
    }
    else 
         #line 2944 
         goto _LOR;
  }
  else 
       #line 2944 
       goto _LOR;
  #line 2951 
  vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 2952 
  aq_ret = (enum i40e_status_code)i40e_config_rss(vsi,(u8 *)(& vrk->key),(u8 *)0U,(unsigned short)0);
  #line 2953 
  err: 
       #line 2953 
  ;
  #line 2955 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_CONFIG_RSS_KEY,
                                aq_ret);
}

#line 2966  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_config_rss_lut(struct i40e_vf *vf, u8 *msg)
{
  #line 2973 
  u16 i;
  #line 2968 
  struct virtchnl_rss_lut *vrl = (struct virtchnl_rss_lut *)msg;
  #line 2970 
  struct i40e_pf *pf = vf->pf;
  #line 2971 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  #line 2972 
  i40e_status aq_ret = 0;
  #line 2975 
  if (test_bit(1L,& vf->vf_states)) {
    #line 2976 
    if (i40e_vc_isvalid_vsi_id(vf,(unsigned short)((int)vrl->vsi_id))) {
      #line 2976 
      if ((unsigned int)vrl->lut_entries != 64U) {
        #line 2975 
        _LOR: {
                #line 2978 
                aq_ret = I40E_ERR_PARAM;
                #line 2979 
                goto err;
              }
      }
    }
    else 
         #line 2975 
         goto _LOR;
  }
  else 
       #line 2975 
       goto _LOR;
  #line 2982 
  i = (unsigned short)0U;
  #line 2982 
  while ((int)vrl->lut_entries > (int)i) {
    #line 2983 
    if ((int)vrl->lut[(int)i] >= (int)vf->num_queue_pairs) {
      #line 2984 
      aq_ret = I40E_ERR_PARAM;
      #line 2985 
      goto err;
    }
    #line 2982 
    i = (u16)((int)i + 1);
  }
  #line 2988 
  vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 2989 
  aq_ret = (enum i40e_status_code)i40e_config_rss(vsi,(u8 *)0U,(u8 *)(& vrl->lut),(unsigned short)64);
  #line 2991 
  err: 
       #line 2991 
  ;
  #line 2992 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_CONFIG_RSS_LUT,
                                aq_ret);
}

#line 3003  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_get_rss_hena(struct i40e_vf *vf, u8 *msg)
{
  #line 3005 
  struct virtchnl_rss_hena *vrh = (struct virtchnl_rss_hena *)0;
  #line 3006 
  struct i40e_pf *pf = vf->pf;
  #line 3007 
  i40e_status aq_ret = 0;
  #line 3008 
  int len = 0;
  #line 3010 
  if (! test_bit(1L,& vf->vf_states)) {
    #line 3011 
    aq_ret = I40E_ERR_PARAM;
    #line 3012 
    goto err;
  }
  #line 3014 
  len = 8;
  #line 3016 
  vrh = (struct virtchnl_rss_hena *)kzalloc((unsigned long)len,3264U);
  #line 3017 
  if (vrh == (struct virtchnl_rss_hena *)0) {
    #line 3018 
    aq_ret = I40E_ERR_NO_MEMORY;
    #line 3019 
    len = 0;
    #line 3020 
    goto err;
  }
  #line 3022 
  if (((unsigned long)pf->hw_features & 16UL) != 0UL) 
                                                      #line 3022 
                                                      vrh->hena = 9223512361489399808ULL; else 
                                                                    #line 3022 
                                                                    vrh->hena = 9223506308269867008ULL;
  #line 3023 
  err: 
       #line 3023 
  ;
  #line 3025 
  aq_ret = (enum i40e_status_code)i40e_vc_send_msg_to_vf(vf,25U,(unsigned int)aq_ret,(u8 *)vrh,
                               (unsigned short)((int)((unsigned short)len)));
  #line 3027 
  kfree((void *)vrh);
  #line 3028 
  return (int)aq_ret;
}

#line 3038  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_set_rss_hena(struct i40e_vf *vf, u8 *msg)
{
  #line 3040 
  struct virtchnl_rss_hena *vrh = (struct virtchnl_rss_hena *)msg;
  #line 3042 
  struct i40e_pf *pf = vf->pf;
  #line 3043 
  struct i40e_hw *hw = & pf->hw;
  #line 3044 
  i40e_status aq_ret = 0;
  #line 3046 
  if (! test_bit(1L,& vf->vf_states)) {
    #line 3047 
    aq_ret = I40E_ERR_PARAM;
    #line 3048 
    goto err;
  }
  #line 3050 
  i40e_write_rx_ctl(hw,(unsigned int)(((int)vf->vf_id + 573952) * 4),(unsigned int)vrh->hena);
  #line 3051 
  i40e_write_rx_ctl(hw,(unsigned int)(((int)vf->vf_id + 574208) * 4),(unsigned int)(vrh->hena >> 32));
  #line 3055 
  err: 
       #line 3055 
  ;
  #line 3056 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_SET_RSS_HENA,
                                aq_ret);
}

#line 3066  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_enable_vlan_stripping(struct i40e_vf *vf, u8 *msg)
{
  #line 3069 
  struct i40e_vsi *vsi;
  #line 3068 
  i40e_status aq_ret = 0;
  #line 3071 
  if (! test_bit(1L,& vf->vf_states)) {
    #line 3072 
    aq_ret = I40E_ERR_PARAM;
    #line 3073 
    goto err;
  }
  #line 3076 
  vsi = *((vf->pf)->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 3077 
  i40e_vlan_stripping_enable(vsi);
  #line 3080 
  err: 
       #line 3080 
  ;
  #line 3081 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_ENABLE_VLAN_STRIPPING,
                                aq_ret);
}

#line 3092  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_disable_vlan_stripping(struct i40e_vf *vf, u8 *msg)
{
  #line 3095 
  struct i40e_vsi *vsi;
  #line 3094 
  i40e_status aq_ret = 0;
  #line 3097 
  if (! test_bit(1L,& vf->vf_states)) {
    #line 3098 
    aq_ret = I40E_ERR_PARAM;
    #line 3099 
    goto err;
  }
  #line 3102 
  vsi = *((vf->pf)->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 3103 
  i40e_vlan_stripping_disable(vsi);
  #line 3106 
  err: 
       #line 3106 
  ;
  #line 3107 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_DISABLE_VLAN_STRIPPING,
                                aq_ret);
}

#line 3118  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_validate_cloud_filter(struct i40e_vf *vf, struct virtchnl_filter *tc_filter)
{
  #line 3125 
  struct i40e_mac_filter *f;
  #line 3126 
  struct hlist_node *h;
  #line 3128 
  int bkt;
  #line 3121 
  struct virtchnl_l4_spec mask = tc_filter->mask.tcp_spec;
  #line 3122 
  struct virtchnl_l4_spec data = tc_filter->data.tcp_spec;
  #line 3123 
  struct i40e_pf *pf = vf->pf;
  #line 3124 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  #line 3127 
  bool found = (_Bool)0;
  #line 3130 
  if (tc_filter->action == (unsigned int)VIRTCHNL_ACTION_DROP) {
    #line 3131 
    _dev_info(& (pf->pdev)->dev,(char *)"VF %d: Currently ADq doesn\'t support Drop Action\n",(int)vf->vf_id);
    #line 3134 
    goto err;
  }
  #line 3138 
  if (tc_filter->action_meta + 4294967295U > 3U) {
    #line 3140 
    _dev_info(& (pf->pdev)->dev,(char *)"VF %d: Invalid TC number %u\n",(int)vf->vf_id,tc_filter->action_meta);
    #line 3142 
    goto err;
  }
  #line 3154 
  if ((unsigned int)mask.dst_mac[0] != 0U && mask.dst_ip[0] == 0U) {
    #line 3155 
    vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
    #line 3156 
    f = i40e_find_mac(vsi,(u8 *)(& data.dst_mac));
    #line 3158 
    if (f == (struct i40e_mac_filter *)0) {
      #line 3159 
      _dev_info(& (pf->pdev)->dev,(char *)"Destination MAC %pM doesn\'t belong to VF %d\n",(u8 *)(& data.dst_mac),(int)vf->vf_id);
      #line 3162 
      goto err;
    }
    #line 3165 
    if ((unsigned int)mask.vlan_id != 0U) {
      #line 3166 
      bkt = 0;
      #line 3166 
      f = (struct i40e_mac_filter *)0;
      #line 3166 
      while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
        {
          #line 3166 
          void *__mptr;
          #line 3166 
          struct i40e_mac_filter *tmp_0;
          {
            #line 3166 
            struct hlist_node *____ptr = vsi->mac_filter_hash[bkt].first;
            #line 3166 
            if (____ptr != (struct hlist_node *)0) {
              #line 3166 
              __mptr = (void *)____ptr;
              #line 3166 
              tmp_0 = ((struct i40e_mac_filter *)__mptr);
            }
            else 
                 #line 3166 
                 tmp_0 = (struct i40e_mac_filter *)0;
            }
          #line 3166 
          f = tmp_0;
          #line 3166 
          while (1) {
            #line 3166 
            void *__mptr_0;
            #line 3166 
            struct i40e_mac_filter *tmp_3;
            #line 3166 
            if (f != (struct i40e_mac_filter *)0) {
              #line 3166 
              h = f->hlist.next;
              #line 3166 
              if (! (1 != 0)) 
                              #line 3166 
                              break;
            }
            else 
                 #line 3166 
                 break;
            #line 3168 
            ;
            #line 3168 
            if ((int)f->vlan == (int)__builtin_bswap16((unsigned short)((int)data.vlan_id))) {
              #line 3169 
              found = (_Bool)1;
              #line 3170 
              break;
            }
            {
              #line 3166 
              struct hlist_node *____ptr_0 = h;
              #line 3166 
              if (____ptr_0 != (struct hlist_node *)0) {
                #line 3166 
                __mptr_0 = (void *)____ptr_0;
                #line 3166 
                tmp_3 = ((struct i40e_mac_filter *)__mptr_0);
              }
              else 
                   #line 3166 
                   tmp_3 = (struct i40e_mac_filter *)0;
              }
            #line 3166 
            f = tmp_3;
          }
        }
        #line 3166 
        bkt ++;
      }
      #line 3173 
      if (! found) {
        #line 3174 
        ;
        #line 3174 
        ;
        #line 3174 
        _dev_info(& (pf->pdev)->dev,(char *)"VF %d doesn\'t have any VLAN id %u\n",(int)vf->vf_id,(int)__builtin_bswap16((unsigned short)((int)data.vlan_id)));
        #line 3177 
        goto err;
      }
    }
  }
  else {
    #line 3182 
    if (! test_bit(0L,& vf->vf_caps)) {
      #line 3183 
      _dev_err(& (pf->pdev)->dev,(char *)"VF %d not trusted, make VF trusted to add advanced mode ADq cloud filters\n",(int)vf->vf_id);
      #line 3186 
      return -4;
    }
  }
  #line 3190 
  if ((unsigned int)((int)mask.dst_mac[0] & (int)data.dst_mac[0]) != 0U) {
    #line 3191 
    if ((int)is_broadcast_ether_addr((u8 *)(& data.dst_mac)) != 0) 
                                                                   #line 3191 
                                                                   goto _LOR;
    else {
      #line 3191 
      if ((int)is_zero_ether_addr((u8 *)(& data.dst_mac)) != 0) {
        #line 3191 
        _LOR: {
                #line 3193 
                _dev_info(& (pf->pdev)->dev,(char *)"VF %d: Invalid Dest MAC addr %pM\n",(int)vf->vf_id,(u8 *)(& data.dst_mac));
                #line 3195 
                goto err;
              }
      }
    }
  }
  #line 3199 
  if ((unsigned int)((int)mask.src_mac[0] & (int)data.src_mac[0]) != 0U) {
    #line 3200 
    if ((int)is_broadcast_ether_addr((u8 *)(& data.src_mac)) != 0) 
                                                                   #line 3200 
                                                                   goto _LOR_0;
    else {
      #line 3200 
      if ((int)is_zero_ether_addr((u8 *)(& data.src_mac)) != 0) {
        #line 3200 
        _LOR_0: {
                  #line 3202 
                  _dev_info(& (pf->pdev)->dev,(char *)"VF %d: Invalid Source MAC addr %pM\n",(int)vf->vf_id,(u8 *)(& data.src_mac));
                  #line 3204 
                  goto err;
                }
      }
    }
  }
  #line 3208 
  if ((unsigned int)((int)mask.dst_port & (int)data.dst_port) != 0U) 
    #line 3209 
    if ((unsigned int)data.dst_port == 0U) {
      #line 3210 
      _dev_info(& (pf->pdev)->dev,(char *)"VF %d: Invalid Dest port\n",(int)vf->vf_id);
      #line 3212 
      goto err;
    }
  #line 3216 
  if ((unsigned int)((int)mask.src_port & (int)data.src_port) != 0U) 
    #line 3217 
    if ((unsigned int)data.src_port == 0U) {
      #line 3218 
      _dev_info(& (pf->pdev)->dev,(char *)"VF %d: Invalid Source port\n",(int)vf->vf_id);
      #line 3220 
      goto err;
    }
  #line 3224 
  if (tc_filter->flow_type > (unsigned int)VIRTCHNL_TCP_V6_FLOW) {
    #line 3226 
    _dev_info(& (pf->pdev)->dev,(char *)"VF %d: Invalid Flow type\n",(int)vf->vf_id);
    #line 3228 
    goto err;
  }
  #line 3231 
  if ((unsigned int)((int)mask.vlan_id & (int)data.vlan_id) != 0U) {
    #line 3232 
    if ((unsigned int)__builtin_bswap16((unsigned short)((int)data.vlan_id)) > 4095U) {
      #line 3233 
      _dev_info(& (pf->pdev)->dev,(char *)"VF %d: invalid VLAN ID\n",(int)vf->vf_id);
      #line 3235 
      goto err;
    }
  }
  #line 3239 
  return 0;
  #line 3240 
  err: 
       #line 3240 
  ;
  #line 3241 
  return -4;
}

#line 3249  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static struct i40e_vsi *i40e_find_vsi_from_seid(struct i40e_vf *vf, u16 seid)
{
  #line 3253 
  int i;
  #line 3251 
  struct i40e_pf *pf = vf->pf;
  #line 3252 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  #line 3255 
  i = 0;
  #line 3255 
  while ((int)vf->num_tc > i) {
    #line 3256 
    vsi = i40e_find_vsi_from_id(pf,(unsigned short)((int)vf->ch[i].vsi_id));
    #line 3257 
    if (vsi != (struct i40e_vsi *)0 && (int)vsi->seid == (int)seid) 
                                                                    #line 3258 
                                                                    return vsi;
    #line 3255 
    i ++;
  }
  #line 3260 
  return (struct i40e_vsi *)0;
}

#line 3269  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static void i40e_del_all_cloud_filters(struct i40e_vf *vf)
{
  #line 3277 
  void *__mptr;
  #line 3277 
  struct i40e_cloud_filter *tmp_0;
  #line 3274 
  struct hlist_node *node;
  #line 3275 
  int ret;
  #line 3271 
  struct i40e_cloud_filter *cfilter = (struct i40e_cloud_filter *)0;
  #line 3272 
  struct i40e_pf *pf = vf->pf;
  #line 3273 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  {
    #line 3277 
    struct hlist_node *____ptr = vf->cloud_filter_list.first;
    #line 3277 
    if (____ptr != (struct hlist_node *)0) {
      #line 3277 
      __mptr = (void *)____ptr;
      #line 3277 
      tmp_0 = ((struct i40e_cloud_filter *)__mptr);
    }
    else 
         #line 3277 
         tmp_0 = (struct i40e_cloud_filter *)0;
    }
  #line 3277 
  cfilter = tmp_0;
  #line 3277 
  while (1) {
    #line 3277 
    void *__mptr_0;
    #line 3277 
    struct i40e_cloud_filter *tmp_3;
    #line 3277 
    if (cfilter != (struct i40e_cloud_filter *)0) {
      #line 3277 
      node = cfilter->cloud_node.next;
      #line 3277 
      if (! (1 != 0)) 
                      #line 3277 
                      break;
    }
    else 
         #line 3277 
         break;
    #line 3279 
    vsi = i40e_find_vsi_from_seid(vf,(unsigned short)((int)cfilter->seid));
    #line 3281 
    if (vsi == (struct i40e_vsi *)0) {
      #line 3282 
      _dev_err(& (pf->pdev)->dev,(char *)"VF %d: no VSI found for matching %u seid, can\'t delete cloud filter\n",(int)vf->vf_id,(int)cfilter->seid);
      #line 3284 
      goto __Cont;
    }
    #line 3287 
    if ((unsigned int)cfilter->dst_port != 0U) 
                                               #line 3288 
                                               ret = i40e_add_del_cloud_filter_big_buf(vsi,cfilter,(_Bool)0); else 
                                                                    #line 3291 
                                                                    ret = i40e_add_del_cloud_filter(vsi,cfilter,(_Bool)0);
    #line 3292 
    if (ret != 0) {
      #line 3293 
      ;
      #line 3293 
      ;
      #line 3293 
      _dev_err(& (pf->pdev)->dev,(char *)"VF %d: Failed to delete cloud filter, err %s aq_err %s\n",(int)vf->vf_id,i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    }
    #line 3299 
    hlist_del(& cfilter->cloud_node);
    #line 3300 
    kfree((void *)cfilter);
    #line 3301 
    vf->num_cloud_filters = (u16)((int)vf->num_cloud_filters - 1);
    #line 3277 
    __Cont: { /* sequence */
              {
                #line 3277 
                struct hlist_node *____ptr_0 = node;
                #line 3277 
                if (____ptr_0 != (struct hlist_node *)0) {
                  #line 3277 
                  __mptr_0 = (void *)____ptr_0;
                  #line 3277 
                  tmp_3 = ((struct i40e_cloud_filter *)__mptr_0);
                }
                else 
                     #line 3277 
                     tmp_3 = (struct i40e_cloud_filter *)0;
                }
              #line 3277 
              cfilter = tmp_3;
            }
  }
  #line 3303 
  return;
}

#line 3312  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_del_cloud_filter(struct i40e_vf *vf, u8 *msg)
{
  #line 3403 
  void *__mptr;
  #line 3403 
  struct i40e_cloud_filter *tmp_4;
  #line 3317 
  struct i40e_cloud_filter cfilter;
  #line 3320 
  struct hlist_node *node;
  #line 3322 
  int i;
  #line 3322 
  int ret;
  #line 3314 
  struct virtchnl_filter *vcf = (struct virtchnl_filter *)msg;
  #line 3315 
  struct virtchnl_l4_spec mask = vcf->mask.tcp_spec;
  #line 3316 
  struct virtchnl_l4_spec tcf = vcf->data.tcp_spec;
  #line 3317 
  struct i40e_cloud_filter *cf = (struct i40e_cloud_filter *)0;
  #line 3318 
  struct i40e_pf *pf = vf->pf;
  #line 3319 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  #line 3321 
  i40e_status aq_ret = 0;
  #line 3324 
  if (! test_bit(1L,& vf->vf_states)) {
    #line 3325 
    aq_ret = I40E_ERR_PARAM;
    #line 3326 
    goto err;
  }
  #line 3329 
  if (! vf->adq_enabled) {
    #line 3330 
    _dev_info(& (pf->pdev)->dev,(char *)"VF %d: ADq not enabled, can\'t apply cloud filter\n",(int)vf->vf_id);
    #line 3333 
    aq_ret = I40E_ERR_PARAM;
    #line 3334 
    goto err;
  }
  #line 3337 
  if (i40e_validate_cloud_filter(vf,vcf) != 0) {
    #line 3338 
    _dev_info(& (pf->pdev)->dev,(char *)"VF %d: Invalid input, can\'t apply cloud filter\n",(int)vf->vf_id);
    #line 3341 
    aq_ret = I40E_ERR_PARAM;
    #line 3342 
    goto err;
  }
  #line 3345 
  memset((void *)(& cfilter),0,88UL);
  #line 3347 
  i = 0;
  #line 3347 
  while (i <= 5) {
    #line 3348 
    cfilter.dst_mac[i] = (unsigned char)((int)mask.dst_mac[i] & (int)tcf.dst_mac[i]);
    #line 3347 
    i ++;
  }
  #line 3351 
  i = 0;
  #line 3351 
  while (i <= 5) {
    #line 3352 
    cfilter.src_mac[i] = (unsigned char)((int)mask.src_mac[i] & (int)tcf.src_mac[i]);
    #line 3351 
    i ++;
  }
  #line 3354 
  cfilter.vlan_id = (unsigned short)((int)mask.vlan_id & (int)tcf.vlan_id);
  #line 3355 
  cfilter.dst_port = (unsigned short)((int)mask.dst_port & (int)tcf.dst_port);
  #line 3356 
  cfilter.src_port = (unsigned short)((int)mask.src_port & (int)tcf.src_port);
  #line 3358 
  switch ((unsigned int)vcf->flow_type) {
    #line 3359 
    case (unsigned int)0: 
                          #line 3359 
    ;
    #line 3360 
    cfilter.n_proto = (unsigned short)2048U;
    #line 3361 
    if ((mask.dst_ip[0] & tcf.dst_ip[0]) != 0U) 
                                                #line 3362 
                                                memcpy((void *)(& cfilter.ip.v4.dst_ip),(void *)(& tcf.dst_ip),4UL);
    else 
      #line 3364 
      if ((mask.src_ip[0] & tcf.dst_ip[0]) != 0U) 
                                                  #line 3365 
                                                  memcpy((void *)(& cfilter.ip.v4.src_ip),(void *)(& tcf.src_ip),4UL);
    #line 3367 
    break;
    #line 3368 
    case (unsigned int)1: 
                          #line 3368 
    ;
    #line 3369 
    cfilter.n_proto = (unsigned short)34525U;
    #line 3370 
    if ((mask.dst_ip[3] & tcf.dst_ip[3]) != 0U) 
                                                #line 3371 
                                                memcpy((void *)(& cfilter.ip.v6.dst_ip6),(void *)(& tcf.dst_ip),16UL);
    #line 3373 
    if ((mask.src_ip[3] & tcf.src_ip[3]) != 0U) 
                                                #line 3374 
                                                memcpy((void *)(& cfilter.ip.v6.src_ip6),(void *)(& tcf.src_ip),16UL);
    #line 3376 
    break;
    #line 3377 
    default: 
             #line 3377 
    ;
    #line 3381 
    _dev_info(& (pf->pdev)->dev,(char *)"VF %d: Flow type not configured\n",(int)vf->vf_id);
  }
  #line 3386 
  vsi = *(pf->vsi + (unsigned long)vf->ch[vcf->action_meta].vsi_idx);
  #line 3387 
  cfilter.seid = vsi->seid;
  #line 3388 
  cfilter.flags = vcf->field_flags;
  #line 3391 
  if ((unsigned int)tcf.dst_port != 0U) 
                                        #line 3392 
                                        ret = i40e_add_del_cloud_filter_big_buf(vsi,& cfilter,(_Bool)0); else 
                                                                    #line 3394 
                                                                    ret = i40e_add_del_cloud_filter(vsi,& cfilter,(_Bool)0);
  #line 3395 
  if (ret != 0) {
    #line 3396 
    ;
    #line 3396 
    ;
    #line 3396 
    _dev_err(& (pf->pdev)->dev,(char *)"VF %d: Failed to delete cloud filter, err %s aq_err %s\n",(int)vf->vf_id,i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 3400 
    goto err;
  }
  {
    #line 3403 
    struct hlist_node *____ptr = vf->cloud_filter_list.first;
    #line 3403 
    if (____ptr != (struct hlist_node *)0) {
      #line 3403 
      __mptr = (void *)____ptr;
      #line 3403 
      tmp_4 = ((struct i40e_cloud_filter *)__mptr);
    }
    else 
         #line 3403 
         tmp_4 = (struct i40e_cloud_filter *)0;
    }
  #line 3403 
  cf = tmp_4;
  #line 3403 
  while (1) {
    #line 3403 
    struct i40e_cloud_filter *tmp_7;
    #line 3403 
    void *__mptr_0;
    #line 3403 
    if (cf != (struct i40e_cloud_filter *)0) {
      #line 3403 
      node = cf->cloud_node.next;
      #line 3403 
      if (! (1 != 0)) 
                      #line 3403 
                      break;
    }
    else 
         #line 3403 
         break;
    #line 3405 
    if ((int)cf->seid != (int)cfilter.seid) 
                                            #line 3406 
                                            goto __Cont;
    #line 3407 
    if ((unsigned int)mask.dst_port != 0U) 
      #line 3408 
      if ((int)cfilter.dst_port != (int)cf->dst_port) 
                                                      #line 3409 
                                                      goto __Cont;
    #line 3410 
    if ((unsigned int)mask.dst_mac[0] != 0U) {
      #line 3411 
      if (! ether_addr_equal((u8 *)(& cf->src_mac),(u8 *)(& cfilter.src_mac))) 
        #line 3412 
        goto __Cont;
    }
    #line 3414 
    if ((unsigned int)cfilter.n_proto == 2048U && mask.dst_ip[0] != 0U) {
      #line 3415 
      if (memcmp((void *)(& cfilter.ip.v4.dst_ip),
                (void *)(& cf->ip.v4.dst_ip),4UL) != 0) 
        #line 3417 
        goto __Cont;
    }
    #line 3419 
    if ((unsigned int)cfilter.n_proto == 34525U && mask.dst_ip[3] != 0U) {
      #line 3420 
      if (memcmp((void *)(& cfilter.ip.v6.dst_ip6),
                (void *)(& cf->ip.v6.dst_ip6),16UL) != 0) 
        #line 3422 
        goto __Cont;
    }
    #line 3423 
    if ((unsigned int)mask.vlan_id != 0U) 
      #line 3424 
      if ((int)cfilter.vlan_id != (int)cf->vlan_id) 
                                                    #line 3425 
                                                    goto __Cont;
    #line 3427 
    hlist_del(& cf->cloud_node);
    #line 3428 
    kfree((void *)cf);
    #line 3429 
    vf->num_cloud_filters = (u16)((int)vf->num_cloud_filters - 1);
    #line 3403 
    __Cont: { /* sequence */
              {
                #line 3403 
                struct hlist_node *____ptr_0 = node;
                #line 3403 
                if (____ptr_0 != (struct hlist_node *)0) {
                  #line 3403 
                  __mptr_0 = (void *)____ptr_0;
                  #line 3403 
                  tmp_7 = ((struct i40e_cloud_filter *)__mptr_0);
                }
                else 
                     #line 3403 
                     tmp_7 = (struct i40e_cloud_filter *)0;
                }
              #line 3403 
              cf = tmp_7;
            }
  }
  #line 3432 
  err: 
       #line 3432 
  ;
  #line 3433 
  return i40e_vc_send_resp_to_vf(vf,
                                 (enum virtchnl_ops)VIRTCHNL_OP_DEL_CLOUD_FILTER,
                                 aq_ret);
}

#line 3444  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_add_cloud_filter(struct i40e_vf *vf, u8 *msg)
{
  #line 3453 
  int i;
  #line 3453 
  int ret;
  #line 3446 
  struct virtchnl_filter *vcf = (struct virtchnl_filter *)msg;
  #line 3447 
  struct virtchnl_l4_spec mask = vcf->mask.tcp_spec;
  #line 3448 
  struct virtchnl_l4_spec tcf = vcf->data.tcp_spec;
  #line 3449 
  struct i40e_cloud_filter *cfilter = (struct i40e_cloud_filter *)0;
  #line 3450 
  struct i40e_pf *pf = vf->pf;
  #line 3451 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  #line 3452 
  i40e_status aq_ret = 0;
  #line 3455 
  if (! test_bit(1L,& vf->vf_states)) {
    #line 3456 
    aq_ret = I40E_ERR_PARAM;
    #line 3457 
    goto err_out;
  }
  #line 3460 
  if (! vf->adq_enabled) {
    #line 3461 
    _dev_info(& (pf->pdev)->dev,(char *)"VF %d: ADq is not enabled, can\'t apply cloud filter\n",(int)vf->vf_id);
    #line 3464 
    aq_ret = I40E_ERR_PARAM;
    #line 3465 
    goto err_out;
  }
  #line 3468 
  if (i40e_validate_cloud_filter(vf,vcf) != 0) {
    #line 3469 
    _dev_info(& (pf->pdev)->dev,(char *)"VF %d: Invalid input/s, can\'t apply cloud filter\n",(int)vf->vf_id);
    #line 3472 
    aq_ret = I40E_ERR_PARAM;
    #line 3473 
    goto err_out;
  }
  #line 3476 
  cfilter = (struct i40e_cloud_filter *)kzalloc(88UL,3264U);
  #line 3477 
  if (cfilter == (struct i40e_cloud_filter *)0) 
                                                #line 3478 
                                                return -12;
  #line 3481 
  i = 0;
  #line 3481 
  while (i <= 5) {
    #line 3482 
    cfilter->dst_mac[i] = (unsigned char)((int)mask.dst_mac[i] & (int)tcf.dst_mac[i]);
    #line 3481 
    i ++;
  }
  #line 3485 
  i = 0;
  #line 3485 
  while (i <= 5) {
    #line 3486 
    cfilter->src_mac[i] = (unsigned char)((int)mask.src_mac[i] & (int)tcf.src_mac[i]);
    #line 3485 
    i ++;
  }
  #line 3488 
  cfilter->vlan_id = (unsigned short)((int)mask.vlan_id & (int)tcf.vlan_id);
  #line 3489 
  cfilter->dst_port = (unsigned short)((int)mask.dst_port & (int)tcf.dst_port);
  #line 3490 
  cfilter->src_port = (unsigned short)((int)mask.src_port & (int)tcf.src_port);
  #line 3492 
  switch ((unsigned int)vcf->flow_type) {
    #line 3493 
    case (unsigned int)0: 
                          #line 3493 
    ;
    #line 3494 
    cfilter->n_proto = (unsigned short)2048U;
    #line 3495 
    if ((mask.dst_ip[0] & tcf.dst_ip[0]) != 0U) 
                                                #line 3496 
                                                memcpy((void *)(& cfilter->ip.v4.dst_ip),(void *)(& tcf.dst_ip),4UL);
    else 
      #line 3498 
      if ((mask.src_ip[0] & tcf.dst_ip[0]) != 0U) 
                                                  #line 3499 
                                                  memcpy((void *)(& cfilter->ip.v4.src_ip),(void *)(& tcf.src_ip),4UL);
    #line 3501 
    break;
    #line 3502 
    case (unsigned int)1: 
                          #line 3502 
    ;
    #line 3503 
    cfilter->n_proto = (unsigned short)34525U;
    #line 3504 
    if ((mask.dst_ip[3] & tcf.dst_ip[3]) != 0U) 
                                                #line 3505 
                                                memcpy((void *)(& cfilter->ip.v6.dst_ip6),(void *)(& tcf.dst_ip),16UL);
    #line 3507 
    if ((mask.src_ip[3] & tcf.src_ip[3]) != 0U) 
                                                #line 3508 
                                                memcpy((void *)(& cfilter->ip.v6.src_ip6),(void *)(& tcf.src_ip),16UL);
    #line 3510 
    break;
    #line 3511 
    default: 
             #line 3511 
    ;
    #line 3515 
    _dev_info(& (pf->pdev)->dev,(char *)"VF %d: Flow type not configured\n",(int)vf->vf_id);
  }
  #line 3520 
  vsi = *(pf->vsi + (unsigned long)vf->ch[vcf->action_meta].vsi_idx);
  #line 3521 
  cfilter->seid = vsi->seid;
  #line 3522 
  cfilter->flags = vcf->field_flags;
  #line 3525 
  if ((unsigned int)tcf.dst_port != 0U) 
                                        #line 3526 
                                        ret = i40e_add_del_cloud_filter_big_buf(vsi,cfilter,(_Bool)1); else 
                                                                    #line 3528 
                                                                    ret = i40e_add_del_cloud_filter(vsi,cfilter,(_Bool)1);
  #line 3529 
  if (ret != 0) {
    #line 3530 
    ;
    #line 3530 
    ;
    #line 3530 
    _dev_err(& (pf->pdev)->dev,(char *)"VF %d: Failed to add cloud filter, err %s aq_err %s\n",(int)vf->vf_id,i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 3534 
    goto err_free;
  }
  #line 3537 
  INIT_HLIST_NODE(& cfilter->cloud_node);
  #line 3538 
  hlist_add_head(& cfilter->cloud_node,& vf->cloud_filter_list);
  #line 3540 
  cfilter = (struct i40e_cloud_filter *)0;
  #line 3541 
  vf->num_cloud_filters = (u16)((int)vf->num_cloud_filters + 1);
  #line 3542 
  err_free: 
            #line 3542 
  ;
  #line 3543 
  kfree((void *)cfilter);
  #line 3544 
  err_out: 
           #line 3544 
  ;
  #line 3545 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_ADD_CLOUD_FILTER,
                                aq_ret);
}

#line 3554  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_add_qch_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 3560 
  int i;
  #line 3556 
  struct virtchnl_tc_info *tci = (struct virtchnl_tc_info *)msg;
  #line 3558 
  struct i40e_pf *pf = vf->pf;
  #line 3559 
  struct i40e_link_status *ls = & pf->hw.phy.link_info;
  #line 3560 
  int adq_request_qps = 0;
  #line 3561 
  i40e_status aq_ret = 0;
  #line 3562 
  u64 speed = 0ULL;
  #line 3564 
  if (! test_bit(1L,& vf->vf_states)) {
    #line 3565 
    aq_ret = I40E_ERR_PARAM;
    #line 3566 
    goto err;
  }
  #line 3570 
  if ((int)vf->spoofchk != 0) {
    #line 3571 
    _dev_err(& (pf->pdev)->dev,(char *)"Spoof check is ON, turn it OFF to enable ADq\n");
    #line 3573 
    aq_ret = I40E_ERR_PARAM;
    #line 3574 
    goto err;
  }
  #line 3577 
  if ((vf->driver_caps & 8388608U) == 0U) {
    #line 3578 
    _dev_err(& (pf->pdev)->dev,(char *)"VF %d attempting to enable ADq, but hasn\'t properly negotiated that capability\n",(int)vf->vf_id);
    #line 3581 
    aq_ret = I40E_ERR_PARAM;
    #line 3582 
    goto err;
  }
  #line 3586 
  if (tci->num_tc + 4294967295U > 3U) {
    #line 3587 
    _dev_err(& (pf->pdev)->dev,(char *)"VF %d trying to set %u TCs, valid range 1-%u TCs per VF\n",(int)vf->vf_id,tci->num_tc,4);
    #line 3590 
    aq_ret = I40E_ERR_PARAM;
    #line 3591 
    goto err;
  }
  #line 3595 
  i = 0;
  #line 3595 
  while (tci->num_tc > (unsigned int)i) {
    #line 3596 
    if ((unsigned int)tci->list[i].count + 65535U > 3U) {
      #line 3598 
      _dev_err(& (pf->pdev)->dev,(char *)"VF %d: TC %d trying to set %u queues, valid range 1-%u queues per TC\n",(int)vf->vf_id,i,(int)tci->list[i].count,4);
      #line 3602 
      aq_ret = I40E_ERR_PARAM;
      #line 3603 
      goto err;
    }
    #line 3595 
    i ++;
  }
  #line 3607 
  adq_request_qps = 12;
  #line 3609 
  if (pf->queues_left < adq_request_qps) {
    #line 3610 
    _dev_err(& (pf->pdev)->dev,(char *)"No queues left to allocate to VF %d\n",(int)vf->vf_id);
    #line 3613 
    aq_ret = I40E_ERR_PARAM;
    #line 3614 
    goto err;
  }
  else 
       #line 3620 
       vf->num_queue_pairs = (unsigned char)16U;
  #line 3624 
  switch ((unsigned int)ls->link_speed) {
    #line 3625 
    case (unsigned int)2: 
                          #line 3625 
    ;
    #line 3626 
    speed = 100ULL;
    #line 3627 
    break;
    #line 3628 
    case (unsigned int)4: 
                          #line 3628 
    ;
    #line 3629 
    speed = 1000ULL;
    #line 3630 
    break;
    #line 3631 
    case (unsigned int)8: 
                          #line 3631 
    ;
    #line 3632 
    speed = 10000ULL;
    #line 3633 
    break;
    #line 3634 
    case (unsigned int)32: 
                           #line 3634 
    ;
    #line 3635 
    speed = 20000ULL;
    #line 3636 
    break;
    #line 3637 
    case (unsigned int)64: 
                           #line 3637 
    ;
    #line 3638 
    speed = 25000ULL;
    #line 3639 
    break;
    #line 3640 
    case (unsigned int)16: 
                           #line 3640 
    ;
    #line 3641 
    speed = 40000ULL;
    #line 3642 
    break;
    #line 3643 
    default: 
             #line 3643 
    ;
    #line 3644 
    _dev_err(& (pf->pdev)->dev,(char *)"Cannot detect link speed\n");
    #line 3646 
    aq_ret = I40E_ERR_PARAM;
    #line 3647 
    goto err;
  }
  #line 3651 
  vf->num_tc = (unsigned char)tci->num_tc;
  #line 3652 
  i = 0;
  #line 3652 
  while ((int)vf->num_tc > i) {
    #line 3653 
    if (tci->list[i].max_tx_rate != 0ULL) 
      #line 3654 
      if (tci->list[i].max_tx_rate > speed) {
        #line 3655 
        _dev_err(& (pf->pdev)->dev,(char *)"Invalid max tx rate %llu specified for VF %d.",tci->list[i].max_tx_rate,(int)vf->vf_id);
        #line 3659 
        aq_ret = I40E_ERR_PARAM;
        #line 3660 
        goto err;
      }
      else 
           #line 3662 
           vf->ch[i].max_tx_rate = tci->list[i].max_tx_rate;
    #line 3666 
    vf->ch[i].num_qps = tci->list[i].count;
    #line 3652 
    i ++;
  }
  #line 3670 
  vf->adq_enabled = (_Bool)1;
  #line 3675 
  vf->num_req_queues = (unsigned char)0U;
  #line 3678 
  i40e_vc_notify_vf_reset(vf);
  #line 3679 
  i40e_reset_vf(vf,(_Bool)0);
  #line 3681 
  return 0;
  #line 3684 
  err: 
       #line 3684 
  ;
  #line 3685 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_ENABLE_CHANNELS,
                                aq_ret);
}

#line 3694  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_vc_del_qch_msg(struct i40e_vf *vf, u8 *msg)
{
  #line 3696 
  struct i40e_pf *pf = vf->pf;
  #line 3697 
  i40e_status aq_ret = 0;
  #line 3699 
  if (! test_bit(1L,& vf->vf_states)) {
    #line 3700 
    aq_ret = I40E_ERR_PARAM;
    #line 3701 
    goto err;
  }
  #line 3704 
  if ((int)vf->adq_enabled != 0) {
    #line 3705 
    i40e_del_all_cloud_filters(vf);
    #line 3706 
    i40e_del_qch(vf);
    #line 3707 
    vf->adq_enabled = (_Bool)0;
    #line 3708 
    vf->num_tc = (unsigned char)0U;
    #line 3709 
    _dev_info(& (pf->pdev)->dev,(char *)"Deleting Queue Channels and cloud filters for ADq on VF %d\n",(int)vf->vf_id);
  }
  else {
    #line 3713 
    _dev_info(& (pf->pdev)->dev,(char *)"VF %d trying to delete queue channels but ADq isn\'t enabled\n",(int)vf->vf_id);
    #line 3715 
    aq_ret = I40E_ERR_PARAM;
  }
  #line 3719 
  i40e_vc_notify_vf_reset(vf);
  #line 3720 
  i40e_reset_vf(vf,(_Bool)0);
  #line 3722 
  return 0;
  #line 3724 
  err: 
       #line 3724 
  ;
  #line 3725 
  return i40e_vc_send_resp_to_vf(vf,
                                (enum virtchnl_ops)VIRTCHNL_OP_DISABLE_CHANNELS,
                                aq_ret);
}

#line 3741  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_vc_process_vf_msg(struct i40e_pf *pf, s16 vf_id, u32 v_opcode, u32 v_retval, u8 *msg, u16 msglen)
{
  #line 3746 
  struct i40e_vf *vf;
  #line 3747 
  int ret;
  #line 3744 
  struct i40e_hw *hw = & pf->hw;
  #line 3745 
  int local_vf_id = (int)vf_id - (int)((short)hw->func_caps.vf_base_id);
  #line 3749 
  (pf->vf_aq_requests) ++;
  #line 3750 
  if (local_vf_id < 0 || pf->num_alloc_vfs <= local_vf_id) 
                                                           #line 3751 
                                                           return -22;
  #line 3752 
  vf = pf->vf + (unsigned long)local_vf_id;
  #line 3755 
  if ((int)test_bit(3L,& vf->vf_states) != 0) 
                                              #line 3756 
                                              return -5;
  #line 3759 
  ret = virtchnl_vc_validate_vf_msg(& vf->vf_ver,v_opcode,msg,(unsigned short)((int)msglen));
  #line 3761 
  if (ret != 0) {
    #line 3762 
    i40e_vc_send_resp_to_vf(vf,(enum virtchnl_ops)v_opcode,(enum i40e_status_code)I40E_ERR_PARAM);
    #line 3763 
    _dev_err(& (pf->pdev)->dev,(char *)"Invalid message from VF %d, opcode %d, len %d\n",local_vf_id,v_opcode,(int)msglen);
    #line 3765 
    switch (ret) {
      #line 3766 
      case -5: 
               #line 3766 
      ;
      #line 3767 
      return -1;
      #line 3768 
      default: 
               #line 3768 
      ;
      #line 3769 
      return -22;
    }
  }
  #line 3773 
  switch (v_opcode) {
    #line 3774 
    case (u32)1: 
                 #line 3774 
    ;
    #line 3775 
    ret = i40e_vc_get_version_msg(vf,msg);
    #line 3776 
    break;
    #line 3777 
    case (u32)3: 
                 #line 3777 
    ;
    #line 3778 
    ret = i40e_vc_get_vf_resources_msg(vf,msg);
    #line 3779 
    i40e_vc_notify_vf_link_state(vf);
    #line 3780 
    break;
    #line 3781 
    case (u32)2: 
                 #line 3781 
    ;
    #line 3782 
    i40e_vc_reset_vf_msg(vf);
    #line 3783 
    ret = 0;
    #line 3784 
    break;
    #line 3785 
    case (u32)14: 
                  #line 3785 
    ;
    #line 3786 
    ret = i40e_vc_config_promiscuous_mode_msg(vf,msg);
    #line 3787 
    break;
    #line 3788 
    case (u32)6: 
                 #line 3788 
    ;
    #line 3789 
    ret = i40e_vc_config_queues_msg(vf,msg);
    #line 3790 
    break;
    #line 3791 
    case (u32)7: 
                 #line 3791 
    ;
    #line 3792 
    ret = i40e_vc_config_irq_map_msg(vf,msg);
    #line 3793 
    break;
    #line 3794 
    case (u32)8: 
                 #line 3794 
    ;
    #line 3795 
    ret = i40e_vc_enable_queues_msg(vf,msg);
    #line 3796 
    i40e_vc_notify_vf_link_state(vf);
    #line 3797 
    break;
    #line 3798 
    case (u32)9: 
                 #line 3798 
    ;
    #line 3799 
    ret = i40e_vc_disable_queues_msg(vf,msg);
    #line 3800 
    break;
    #line 3801 
    case (u32)10: 
                  #line 3801 
    ;
    #line 3802 
    ret = i40e_vc_add_mac_addr_msg(vf,msg);
    #line 3803 
    break;
    #line 3804 
    case (u32)11: 
                  #line 3804 
    ;
    #line 3805 
    ret = i40e_vc_del_mac_addr_msg(vf,msg);
    #line 3806 
    break;
    #line 3807 
    case (u32)12: 
                  #line 3807 
    ;
    #line 3808 
    ret = i40e_vc_add_vlan_msg(vf,msg);
    #line 3809 
    break;
    #line 3810 
    case (u32)13: 
                  #line 3810 
    ;
    #line 3811 
    ret = i40e_vc_remove_vlan_msg(vf,msg);
    #line 3812 
    break;
    #line 3813 
    case (u32)15: 
                  #line 3813 
    ;
    #line 3814 
    ret = i40e_vc_get_stats_msg(vf,msg);
    #line 3815 
    break;
    #line 3816 
    case (u32)20: 
                  #line 3816 
    ;
    #line 3817 
    ret = i40e_vc_iwarp_msg(vf,msg,(unsigned short)((int)msglen));
    #line 3818 
    break;
    #line 3819 
    case (u32)21: 
                  #line 3819 
    ;
    #line 3820 
    ret = i40e_vc_iwarp_qvmap_msg(vf,msg,(_Bool)1);
    #line 3821 
    break;
    #line 3822 
    case (u32)22: 
                  #line 3822 
    ;
    #line 3823 
    ret = i40e_vc_iwarp_qvmap_msg(vf,msg,(_Bool)0);
    #line 3824 
    break;
    #line 3825 
    case (u32)23: 
                  #line 3825 
    ;
    #line 3826 
    ret = i40e_vc_config_rss_key(vf,msg);
    #line 3827 
    break;
    #line 3828 
    case (u32)24: 
                  #line 3828 
    ;
    #line 3829 
    ret = i40e_vc_config_rss_lut(vf,msg);
    #line 3830 
    break;
    #line 3831 
    case (u32)25: 
                  #line 3831 
    ;
    #line 3832 
    ret = i40e_vc_get_rss_hena(vf,msg);
    #line 3833 
    break;
    #line 3834 
    case (u32)26: 
                  #line 3834 
    ;
    #line 3835 
    ret = i40e_vc_set_rss_hena(vf,msg);
    #line 3836 
    break;
    #line 3837 
    case (u32)27: 
                  #line 3837 
    ;
    #line 3838 
    ret = i40e_vc_enable_vlan_stripping(vf,msg);
    #line 3839 
    break;
    #line 3840 
    case (u32)28: 
                  #line 3840 
    ;
    #line 3841 
    ret = i40e_vc_disable_vlan_stripping(vf,msg);
    #line 3842 
    break;
    #line 3843 
    case (u32)29: 
                  #line 3843 
    ;
    #line 3844 
    ret = i40e_vc_request_queues_msg(vf,msg);
    #line 3845 
    break;
    #line 3846 
    case (u32)30: 
                  #line 3846 
    ;
    #line 3847 
    ret = i40e_vc_add_qch_msg(vf,msg);
    #line 3848 
    break;
    #line 3849 
    case (u32)31: 
                  #line 3849 
    ;
    #line 3850 
    ret = i40e_vc_del_qch_msg(vf,msg);
    #line 3851 
    break;
    #line 3852 
    case (u32)32: 
                  #line 3852 
    ;
    #line 3853 
    ret = i40e_vc_add_cloud_filter(vf,msg);
    #line 3854 
    break;
    #line 3855 
    case (u32)33: 
                  #line 3855 
    ;
    #line 3856 
    ret = i40e_vc_del_cloud_filter(vf,msg);
    #line 3857 
    break;
    #line 3858 
    case (u32)0: 
                 #line 3858 
    ;
    #line 3859 
    default: 
             #line 3859 
    ;
    #line 3860 
    _dev_err(& (pf->pdev)->dev,(char *)"Unsupported opcode %d from VF %d\n",v_opcode,local_vf_id);
    #line 3862 
    ret = i40e_vc_send_resp_to_vf(vf,(enum virtchnl_ops)v_opcode,(enum i40e_status_code)I40E_ERR_NOT_IMPLEMENTED);
    #line 3864 
    break;
  }
  #line 3867 
  return ret;
}

#line 3877  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_vc_process_vflr_event(struct i40e_pf *pf)
{
  #line 3880 
  u32 reg;
  #line 3880 
  u32 reg_idx;
  #line 3880 
  u32 bit_idx;
  #line 3881 
  struct i40e_vf *vf;
  #line 3882 
  int vf_id;
  #line 3879 
  struct i40e_hw *hw = & pf->hw;
  #line 3884 
  if (! test_bit(7L,(unsigned long *)(& pf->state))) 
                                                     #line 3885 
                                                     return 0;
  #line 3892 
  reg = readl((void *)(hw->hw_addr + 231424U));
  #line 3893 
  reg |= 536870912U;
  #line 3894 
  writel(reg,(void *)(hw->hw_addr + 231424U));
  #line 3895 
  readl((void *)(hw->hw_addr + 745772U));
  #line 3897 
  cif_clear_bit(7L,(unsigned long *)(& pf->state));
  #line 3898 
  vf_id = 0;
  #line 3898 
  while (pf->num_alloc_vfs > vf_id) {
    #line 3899 
    reg_idx = (hw->func_caps.vf_base_id + (unsigned int)vf_id) / 32U;
    #line 3900 
    bit_idx = (hw->func_caps.vf_base_id + (unsigned int)vf_id) & 31U;
    #line 3902 
    vf = pf->vf + (unsigned long)vf_id;
    #line 3903 
    reg = readl((void *)(hw->hw_addr + (unsigned long)((reg_idx + 149888U) * 4U)));
    #line 3904 
    if ((((unsigned long)reg >> bit_idx) & 1UL) != 0UL) 
                                                        #line 3906 
                                                        i40e_reset_vf(vf,(_Bool)1);
    #line 3898 
    vf_id ++;
  }
  #line 3909 
  return 0;
}

#line 3921  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static int i40e_validate_vf(struct i40e_pf *pf, int vf_id)
{
  #line 3923 
  struct i40e_vsi *vsi;
  #line 3924 
  struct i40e_vf *vf;
  #line 3925 
  int ret = 0;
  #line 3927 
  if (pf->num_alloc_vfs <= vf_id) {
    #line 3928 
    _dev_err(& (pf->pdev)->dev,(char *)"Invalid VF Identifier %d\n",vf_id);
    #line 3930 
    ret = -22;
    #line 3931 
    goto err_out;
  }
  #line 3933 
  vf = pf->vf + (unsigned long)vf_id;
  #line 3934 
  vsi = i40e_find_vsi_from_id(pf,(unsigned short)((int)vf->lan_vsi_id));
  #line 3935 
  if (vsi == (struct i40e_vsi *)0) 
                                   #line 3936 
                                   ret = -22;
  #line 3937 
  err_out: 
           #line 3937 
  ;
  #line 3938 
  return ret;
}

#line 3949  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_mac(struct net_device *netdev, int vf_id, u8 *mac)
{
  #line 3954 
  struct i40e_mac_filter *f;
  #line 3955 
  struct i40e_vf *vf;
  #line 3957 
  struct hlist_node *h;
  #line 3958 
  int bkt;
  #line 3959 
  u8 i;
  #line 3951 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 3952 
  struct i40e_vsi *vsi = np->vsi;
  #line 3953 
  struct i40e_pf *pf = vsi->back;
  #line 3956 
  int ret = 0;
  #line 3961 
  if ((int)test_and_set_bit(33L,(unsigned long *)(& pf->state)) != 0) {
    #line 3962 
    _dev_warn(& (pf->pdev)->dev,(char *)"Unable to configure VFs, other operation is pending.\n");
    #line 3963 
    return -11;
  }
  #line 3967 
  ret = i40e_validate_vf(pf,vf_id);
  #line 3968 
  if (ret != 0) 
                #line 3969 
                goto error_param;
  #line 3971 
  vf = pf->vf + (unsigned long)vf_id;
  #line 3972 
  vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 3980 
  i = (unsigned char)0U;
  #line 3980 
  while ((unsigned int)i <= 14U) {
    {
      #line 3981 
      if ((int)test_bit(0L,& vf->vf_states) != 0) {
        #line 3982 
        if ((unsigned int)i != 0U) 
                                   #line 3983 
                                   vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
        #line 3984 
        break;
      }
      #line 3986 
      msleep(20U);
    }
    #line 3980 
    i = (u8)((int)i + 1);
  }
  #line 3988 
  if (! test_bit(0L,& vf->vf_states)) {
    #line 3989 
    _dev_err(& (pf->pdev)->dev,(char *)"VF %d still in reset. Try again.\n",vf_id);
    #line 3991 
    ret = -11;
    #line 3992 
    goto error_param;
  }
  #line 3995 
  if ((int)is_multicast_ether_addr(mac) != 0) {
    #line 3996 
    _dev_err(& (pf->pdev)->dev,(char *)"Invalid Ethernet address %pM for VF %d\n",mac,vf_id);
    #line 3998 
    ret = -22;
    #line 3999 
    goto error_param;
  }
  #line 4005 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
  #line 4008 
  if (! is_zero_ether_addr((u8 *)(& vf->default_lan_addr.addr))) 
                                                                 #line 4009 
                                                                 i40e_del_mac_filter(vsi,(u8 *)(& vf->default_lan_addr.addr));
  #line 4014 
  bkt = 0;
  #line 4014 
  f = (struct i40e_mac_filter *)0;
  #line 4014 
  while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
    {
      #line 4014 
      void *__mptr;
      #line 4014 
      struct i40e_mac_filter *tmp_6;
      {
        #line 4014 
        struct hlist_node *____ptr = vsi->mac_filter_hash[bkt].first;
        #line 4014 
        if (____ptr != (struct hlist_node *)0) {
          #line 4014 
          __mptr = (void *)____ptr;
          #line 4014 
          tmp_6 = ((struct i40e_mac_filter *)__mptr);
        }
        else 
             #line 4014 
             tmp_6 = (struct i40e_mac_filter *)0;
        }
      #line 4014 
      f = tmp_6;
      #line 4014 
      while (1) {
        #line 4014 
        struct i40e_mac_filter *tmp_9;
        #line 4014 
        void *__mptr_0;
        #line 4014 
        if (f != (struct i40e_mac_filter *)0) {
          #line 4014 
          h = f->hlist.next;
          #line 4014 
          if (! (1 != 0)) 
                          #line 4014 
                          break;
        }
        else 
             #line 4014 
             break;
        #line 4015 
        __i40e_del_filter(vsi,f);
        {
          #line 4014 
          struct hlist_node *____ptr_0 = h;
          #line 4014 
          if (____ptr_0 != (struct hlist_node *)0) {
            #line 4014 
            __mptr_0 = (void *)____ptr_0;
            #line 4014 
            tmp_9 = ((struct i40e_mac_filter *)__mptr_0);
          }
          else 
               #line 4014 
               tmp_9 = (struct i40e_mac_filter *)0;
          }
        #line 4014 
        f = tmp_9;
      }
    }
    #line 4014 
    bkt ++;
  }
  #line 4017 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
  #line 4020 
  if (i40e_sync_vsi_filters(vsi) != 0) {
    #line 4021 
    _dev_err(& (pf->pdev)->dev,(char *)"Unable to program ucast filters\n");
    #line 4022 
    ret = -5;
    #line 4023 
    goto error_param;
  }
  #line 4025 
  ether_addr_copy((u8 *)(& vf->default_lan_addr.addr),mac);
  #line 4027 
  if ((int)is_zero_ether_addr(mac) != 0) {
    #line 4028 
    vf->pf_set_mac = (_Bool)0;
    #line 4029 
    _dev_info(& (pf->pdev)->dev,(char *)"Removing MAC on VF %d\n",vf_id);
  }
  else {
    #line 4031 
    vf->pf_set_mac = (_Bool)1;
    #line 4032 
    _dev_info(& (pf->pdev)->dev,(char *)"Setting MAC %pM on VF %d\n",mac,vf_id);
  }
  #line 4039 
  i40e_vc_disable_vf(vf);
  #line 4040 
  _dev_info(& (pf->pdev)->dev,(char *)"Bring down and up the VF interface to make this change effective.\n");
  #line 4042 
  error_param: 
               #line 4042 
  ;
  #line 4043 
  cif_clear_bit(33L,(unsigned long *)(& pf->state));
  #line 4044 
  return ret;
}

#line 4055  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
static bool i40e_vsi_has_vlans(struct i40e_vsi *vsi)
{
  #line 4057 
  bool have_vlans;
  #line 4062 
  if ((unsigned int)vsi->info.pvid != 0U) 
                                          #line 4063 
                                          return (_Bool)0;
  #line 4068 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
  #line 4069 
  have_vlans = i40e_is_vsi_in_vlan(vsi);
  #line 4070 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
  #line 4072 
  return have_vlans;
}

#line 4085  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_port_vlan(struct net_device *netdev, int vf_id, u16 vlan_id, u8 qos, __be16 vlan_proto)
{
  #line 4092 
  struct i40e_vsi *vsi;
  #line 4093 
  struct i40e_vf *vf;
  #line 4088 
  u16 vlanprio = (unsigned short)(((int)qos << 13) | (int)vlan_id);
  #line 4089 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 4090 
  bool allmulti = (_Bool)0;
  #line 4090 
  bool alluni = (_Bool)0;
  #line 4091 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 4094 
  int ret = 0;
  #line 4096 
  if ((int)test_and_set_bit(33L,(unsigned long *)(& pf->state)) != 0) {
    #line 4097 
    _dev_warn(& (pf->pdev)->dev,(char *)"Unable to configure VFs, other operation is pending.\n");
    #line 4098 
    return -11;
  }
  #line 4102 
  ret = i40e_validate_vf(pf,vf_id);
  #line 4103 
  if (ret != 0) 
                #line 4104 
                goto error_pvid;
  #line 4106 
  if ((unsigned int)vlan_id > 4095U || (unsigned int)qos > 7U) {
    #line 4107 
    _dev_err(& (pf->pdev)->dev,(char *)"Invalid VF Parameters\n");
    #line 4108 
    ret = -22;
    #line 4109 
    goto error_pvid;
  }
  #line 4112 
  if ((unsigned int)vlan_proto != 129U) {
    #line 4113 
    _dev_err(& (pf->pdev)->dev,(char *)"VF VLAN protocol is not supported\n");
    #line 4114 
    ret = -93;
    #line 4115 
    goto error_pvid;
  }
  #line 4118 
  vf = pf->vf + (unsigned long)vf_id;
  #line 4119 
  vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 4120 
  if (! test_bit(0L,& vf->vf_states)) {
    #line 4121 
    _dev_err(& (pf->pdev)->dev,(char *)"VF %d still in reset. Try again.\n",vf_id);
    #line 4123 
    ret = -11;
    #line 4124 
    goto error_pvid;
  }
  #line 4127 
  if ((int)vsi->info.pvid == (int)vlanprio) 
                                            #line 4129 
                                            goto error_pvid;
  #line 4131 
  if ((int)i40e_vsi_has_vlans(vsi) != 0) {
    #line 4132 
    _dev_err(& (pf->pdev)->dev,(char *)"VF %d has already configured VLAN filters and the administrator is requesting a port VLAN override.\nPlease unload and reload the VF driver for this change to take effect.\n",vf_id);
    #line 4139 
    i40e_vc_disable_vf(vf);
    #line 4141 
    vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  }
  #line 4145 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
  #line 4155 
  if (((unsigned int)vlan_id == 0U && (unsigned int)qos == 0U || (int)vsi->info.pvid != (int)vlanprio) && (unsigned int)vsi->info.pvid != 0U) {
    #line 4158 
    ret = i40e_add_vlan_all_mac(vsi,(short)(-1));
    #line 4159 
    if (ret != 0) {
      #line 4160 
      _dev_info(& ((vsi->back)->pdev)->dev,(char *)"add VF VLAN failed, ret=%d aq_err=%d\n",ret,(unsigned int)(vsi->back)->hw.aq.asq_last_status);
      #line 4163 
      cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
      #line 4164 
      goto error_pvid;
    }
  }
  #line 4168 
  if ((unsigned int)vsi->info.pvid != 0U) 
                                          #line 4170 
                                          i40e_rm_vlan_all_mac(vsi,(short)((int)((short)vsi->info.pvid) & 4095));
  #line 4174 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
  #line 4177 
  ret = (int)i40e_config_vf_promiscuous_mode(vf,
                                        (unsigned short)((int)vf->lan_vsi_id),
                                        (_Bool)((bool)((int)allmulti) != 0),
                                        (_Bool)((bool)((int)alluni) != 0));
  #line 4179 
  if (ret != 0) {
    #line 4180 
    _dev_err(& (pf->pdev)->dev,(char *)"Unable to config VF promiscuous mode\n");
    #line 4181 
    goto error_pvid;
  }
  #line 4184 
  if ((unsigned int)vlan_id != 0U || (unsigned int)qos != 0U) 
                                                              #line 4185 
                                                              ret = i40e_vsi_add_pvid(vsi,(unsigned short)((int)vlanprio)); else 
                                                                    #line 4187 
                                                                    i40e_vsi_remove_pvid(vsi);
  #line 4188 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
  #line 4190 
  if ((unsigned int)vlan_id != 0U) {
    #line 4191 
    _dev_info(& (pf->pdev)->dev,(char *)"Setting VLAN %d, QOS 0x%x on VF %d\n",(int)vlan_id,(int)qos,vf_id);
    #line 4195 
    ret = i40e_add_vlan_all_mac(vsi,(short)((int)((short)vlan_id)));
    #line 4196 
    if (ret != 0) {
      #line 4197 
      _dev_info(& ((vsi->back)->pdev)->dev,(char *)"add VF VLAN failed, ret=%d aq_err=%d\n",ret,(unsigned int)(vsi->back)->hw.aq.asq_last_status);
      #line 4200 
      cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
      #line 4201 
      goto error_pvid;
    }
    #line 4205 
    i40e_rm_vlan_all_mac(vsi,(short)(-1));
  }
  #line 4208 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi(& vsi->mac_filter_hash_lock);
  #line 4210 
  if ((int)test_bit(5L,& vf->vf_states) != 0) 
                                              #line 4211 
                                              alluni = (_Bool)1;
  #line 4213 
  if ((int)test_bit(4L,& vf->vf_states) != 0) 
                                              #line 4214 
                                              allmulti = (_Bool)1;
  #line 4217 
  i40e_service_event_schedule(vsi->back);
  #line 4219 
  if (ret != 0) {
    #line 4220 
    _dev_err(& (pf->pdev)->dev,(char *)"Unable to update VF vsi context\n");
    #line 4221 
    goto error_pvid;
  }
  #line 4227 
  vf->port_vlan_id = vsi->info.pvid;
  #line 4229 
  ret = (int)i40e_config_vf_promiscuous_mode(vf,(unsigned short)((int)vsi->id),
                                        (_Bool)((bool)((int)allmulti) != 0),
                                        (_Bool)((bool)((int)alluni) != 0));
  #line 4230 
  if (ret != 0) {
    #line 4231 
    _dev_err(& (pf->pdev)->dev,(char *)"Unable to config vf promiscuous mode\n");
    #line 4232 
    goto error_pvid;
  }
  #line 4235 
  ret = 0;
  #line 4237 
  error_pvid: 
              #line 4237 
  ;
  #line 4238 
  cif_clear_bit(33L,(unsigned long *)(& pf->state));
  #line 4239 
  return ret;
}

#line 4251  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_bw(struct net_device *netdev, int vf_id, int min_tx_rate, int max_tx_rate)
{
  #line 4256 
  struct i40e_vsi *vsi;
  #line 4257 
  struct i40e_vf *vf;
  #line 4254 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 4255 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 4258 
  int ret = 0;
  #line 4260 
  if ((int)test_and_set_bit(33L,(unsigned long *)(& pf->state)) != 0) {
    #line 4261 
    _dev_warn(& (pf->pdev)->dev,(char *)"Unable to configure VFs, other operation is pending.\n");
    #line 4262 
    return -11;
  }
  #line 4266 
  ret = i40e_validate_vf(pf,vf_id);
  #line 4267 
  if (ret != 0) 
                #line 4268 
                goto error;
  #line 4270 
  if (min_tx_rate != 0) {
    #line 4271 
    _dev_err(& (pf->pdev)->dev,(char *)"Invalid min tx rate (%d) (greater than 0) specified for VF %d.\n",min_tx_rate,vf_id);
    #line 4273 
    ret = -22;
    #line 4274 
    goto error;
  }
  #line 4277 
  vf = pf->vf + (unsigned long)vf_id;
  #line 4278 
  vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 4279 
  if (! test_bit(0L,& vf->vf_states)) {
    #line 4280 
    _dev_err(& (pf->pdev)->dev,(char *)"VF %d still in reset. Try again.\n",vf_id);
    #line 4282 
    ret = -11;
    #line 4283 
    goto error;
  }
  #line 4286 
  ret = i40e_set_bw_limit(vsi,(unsigned short)((int)vsi->seid),(unsigned long long)max_tx_rate);
  #line 4287 
  if (ret != 0) 
                #line 4288 
                goto error;
  #line 4290 
  vf->tx_rate = (unsigned int)max_tx_rate;
  #line 4291 
  error: 
         #line 4291 
  ;
  #line 4292 
  cif_clear_bit(33L,(unsigned long *)(& pf->state));
  #line 4293 
  return ret;
}

#line 4304  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_get_vf_config(struct net_device *netdev, int vf_id, struct ifla_vf_info *ivi)
{
  #line 4310 
  struct i40e_vf *vf;
  #line 4307 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 4308 
  struct i40e_vsi *vsi = np->vsi;
  #line 4309 
  struct i40e_pf *pf = vsi->back;
  #line 4311 
  int ret = 0;
  #line 4313 
  if ((int)test_and_set_bit(33L,(unsigned long *)(& pf->state)) != 0) {
    #line 4314 
    _dev_warn(& (pf->pdev)->dev,(char *)"Unable to configure VFs, other operation is pending.\n");
    #line 4315 
    return -11;
  }
  #line 4319 
  ret = i40e_validate_vf(pf,vf_id);
  #line 4320 
  if (ret != 0) 
                #line 4321 
                goto error_param;
  #line 4323 
  vf = pf->vf + (unsigned long)vf_id;
  #line 4325 
  vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 4326 
  if (vsi == (struct i40e_vsi *)0) {
    #line 4327 
    ret = -2;
    #line 4328 
    goto error_param;
  }
  #line 4331 
  ivi->vf = (unsigned int)vf_id;
  #line 4333 
  ether_addr_copy((u8 *)(& ivi->mac),(u8 *)(& vf->default_lan_addr.addr));
  #line 4335 
  ivi->max_tx_rate = vf->tx_rate;
  #line 4336 
  ivi->min_tx_rate = 0U;
  #line 4337 
  ivi->vlan = (unsigned int)vsi->info.pvid & 4095U;
  #line 4338 
  ivi->qos = (unsigned int)((int)vsi->info.pvid >> 13);
  #line 4340 
  if (! vf->link_forced) 
                         #line 4341 
                         ivi->linkstate = 0U;
  else 
    #line 4342 
    if ((int)vf->link_up == 1) 
                               #line 4343 
                               ivi->linkstate = 1U; else 
                                                         #line 4345 
                                                         ivi->linkstate = 2U;
  #line 4346 
  ivi->spoofchk = (unsigned int)vf->spoofchk;
  #line 4347 
  ivi->trusted = (unsigned int)vf->trusted;
  #line 4348 
  ret = 0;
  #line 4350 
  error_param: 
               #line 4350 
  ;
  #line 4351 
  cif_clear_bit(33L,(unsigned long *)(& pf->state));
  #line 4352 
  return ret;
}

#line 4363  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_link_state(struct net_device *netdev, int vf_id, int link)
{
  #line 4367 
  struct virtchnl_pf_event pfe;
  #line 4369 
  struct i40e_vf *vf;
  #line 4370 
  int abs_vf_id;
  #line 4365 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 4366 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 4368 
  struct i40e_hw *hw = & pf->hw;
  #line 4371 
  int ret = 0;
  #line 4373 
  if ((int)test_and_set_bit(33L,(unsigned long *)(& pf->state)) != 0) {
    #line 4374 
    _dev_warn(& (pf->pdev)->dev,(char *)"Unable to configure VFs, other operation is pending.\n");
    #line 4375 
    return -11;
  }
  #line 4379 
  if (pf->num_alloc_vfs <= vf_id) {
    #line 4380 
    _dev_err(& (pf->pdev)->dev,(char *)"Invalid VF Identifier %d\n",vf_id);
    #line 4381 
    ret = -22;
    #line 4382 
    goto error_out;
  }
  #line 4385 
  vf = pf->vf + (unsigned long)vf_id;
  #line 4386 
  abs_vf_id = (int)((unsigned int)vf->vf_id + hw->func_caps.vf_base_id);
  #line 4388 
  pfe.event = VIRTCHNL_EVENT_LINK_CHANGE;
  #line 4389 
  pfe.severity = 0;
  #line 4391 
  switch (link) {
    #line 4392 
    case 0: 
            #line 4392 
    ;
    #line 4393 
    vf->link_forced = (_Bool)0;
    #line 4394 
    pfe.event_data.link_event.link_status = (_Bool)(((int)pf->hw.phy.link_info.link_info & 1) != 0);
    #line 4396 
    pfe.event_data.link_event.link_speed = (enum virtchnl_link_speed)pf->hw.phy.link_info.link_speed;
    #line 4399 
    break;
    #line 4400 
    case 1: 
            #line 4400 
    ;
    #line 4401 
    vf->link_forced = (_Bool)1;
    #line 4402 
    vf->link_up = (_Bool)1;
    #line 4403 
    pfe.event_data.link_event.link_status = (_Bool)1;
    #line 4404 
    pfe.event_data.link_event.link_speed = VIRTCHNL_LINK_SPEED_40GB;
    #line 4405 
    break;
    #line 4406 
    case 2: 
            #line 4406 
    ;
    #line 4407 
    vf->link_forced = (_Bool)1;
    #line 4408 
    vf->link_up = (_Bool)0;
    #line 4409 
    pfe.event_data.link_event.link_status = (_Bool)0;
    #line 4410 
    pfe.event_data.link_event.link_speed = VIRTCHNL_LINK_SPEED_UNKNOWN;
    #line 4411 
    break;
    #line 4412 
    default: 
             #line 4412 
    ;
    #line 4413 
    ret = -22;
    #line 4414 
    goto error_out;
  }
  #line 4417 
  i40e_aq_send_msg_to_vf(hw,(unsigned short)((int)((unsigned short)abs_vf_id)),17U,0U,(u8 *)(& pfe),(unsigned short)16,(struct i40e_asq_cmd_details *)0);
  #line 4420 
  error_out: 
             #line 4420 
  ;
  #line 4421 
  cif_clear_bit(33L,(unsigned long *)(& pf->state));
  #line 4422 
  return ret;
}

#line 4433  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_spoofchk(struct net_device *netdev, int vf_id, bool enable)
{
  #line 4438 
  struct i40e_vsi_context ctxt;
  #line 4440 
  struct i40e_vf *vf;
  #line 4435 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 4436 
  struct i40e_vsi *vsi = np->vsi;
  #line 4437 
  struct i40e_pf *pf = vsi->back;
  #line 4439 
  struct i40e_hw *hw = & pf->hw;
  #line 4441 
  int ret = 0;
  #line 4443 
  if ((int)test_and_set_bit(33L,(unsigned long *)(& pf->state)) != 0) {
    #line 4444 
    _dev_warn(& (pf->pdev)->dev,(char *)"Unable to configure VFs, other operation is pending.\n");
    #line 4445 
    return -11;
  }
  #line 4449 
  if (pf->num_alloc_vfs <= vf_id) {
    #line 4450 
    _dev_err(& (pf->pdev)->dev,(char *)"Invalid VF Identifier %d\n",vf_id);
    #line 4451 
    ret = -22;
    #line 4452 
    goto out;
  }
  #line 4455 
  vf = pf->vf + (unsigned long)vf_id;
  #line 4456 
  if (! test_bit(0L,& vf->vf_states)) {
    #line 4457 
    _dev_err(& (pf->pdev)->dev,(char *)"VF %d still in reset. Try again.\n",vf_id);
    #line 4459 
    ret = -11;
    #line 4460 
    goto out;
  }
  #line 4463 
  if ((int)vf->spoofchk == (int)enable) 
                                        #line 4464 
                                        goto out;
  #line 4466 
  vf->spoofchk = enable;
  #line 4467 
  memset((void *)(& ctxt),0,144UL);
  #line 4468 
  ctxt.seid = (*(pf->vsi + (unsigned long)vf->lan_vsi_idx))->seid;
  #line 4469 
  ctxt.pf_num = pf->hw.pf_id;
  #line 4470 
  ctxt.info.valid_sections = (unsigned short)2U;
  #line 4471 
  if ((int)enable != 0) 
                        #line 4472 
                        ctxt.info.sec_flags = (unsigned char)((unsigned int)ctxt.info.sec_flags | 6U);
  #line 4474 
  ret = (int)i40e_aq_update_vsi_params(hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  #line 4475 
  if (ret != 0) {
    #line 4476 
    _dev_err(& (pf->pdev)->dev,(char *)"Error %d updating VSI parameters\n",ret);
    #line 4478 
    ret = -5;
  }
  #line 4480 
  out: 
       #line 4480 
  ;
  #line 4481 
  cif_clear_bit(33L,(unsigned long *)(& pf->state));
  #line 4482 
  return ret;
}

#line 4493  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_ndo_set_vf_trust(struct net_device *netdev, int vf_id, bool setting)
{
  #line 4497 
  struct i40e_vf *vf;
  #line 4525 
  char *tmp_1;
  #line 4495 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 4496 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 4498 
  int ret = 0;
  #line 4500 
  if ((int)test_and_set_bit(33L,(unsigned long *)(& pf->state)) != 0) {
    #line 4501 
    _dev_warn(& (pf->pdev)->dev,(char *)"Unable to configure VFs, other operation is pending.\n");
    #line 4502 
    return -11;
  }
  #line 4506 
  if (pf->num_alloc_vfs <= vf_id) {
    #line 4507 
    _dev_err(& (pf->pdev)->dev,(char *)"Invalid VF Identifier %d\n",vf_id);
    #line 4508 
    ret = -22;
    #line 4509 
    goto out;
  }
  #line 4512 
  if (((unsigned long)pf->flags & 1024UL) != 0UL) {
    #line 4513 
    _dev_err(& (pf->pdev)->dev,(char *)"Trusted VF not supported in MFP mode.\n");
    #line 4514 
    ret = -22;
    #line 4515 
    goto out;
  }
  #line 4518 
  vf = pf->vf + (unsigned long)vf_id;
  #line 4520 
  if ((int)vf->trusted == (int)setting) 
                                        #line 4521 
                                        goto out;
  #line 4523 
  vf->trusted = setting;
  #line 4524 
  i40e_vc_disable_vf(vf);
  #line 4525 
  if ((int)setting != 0) 
                         #line 4525 
                         tmp_1 = (char *)""; else 
                                                  #line 4525 
                                                  tmp_1 = (char *)"un";
  #line 4525 
  ;
  #line 4525 
  ;
  #line 4525 
  _dev_info(& (pf->pdev)->dev,(char *)"VF %u is now %strusted\n",vf_id,tmp_1);
  #line 4528 
  if ((int)vf->adq_enabled != 0) 
    #line 4529 
    if (! vf->trusted) {
      #line 4530 
      _dev_info(& (pf->pdev)->dev,(char *)"VF %u no longer Trusted, deleting all cloud filters\n",vf_id);
      #line 4533 
      i40e_del_all_cloud_filters(vf);
    }
  #line 4537 
  out: 
       #line 4537 
  ;
  #line 4538 
  cif_clear_bit(33L,(unsigned long *)(& pf->state));
  #line 4539 
  return ret;
}

#line 4548  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c"
int i40e_get_vf_stats(struct net_device *netdev, int vf_id, struct ifla_vf_stats *vf_stats)
{
  #line 4553 
  struct i40e_eth_stats *stats;
  #line 4554 
  struct i40e_vsi *vsi;
  #line 4555 
  struct i40e_vf *vf;
  #line 4551 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 4552 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 4558 
  if (i40e_validate_vf(pf,vf_id) != 0) 
                                       #line 4559 
                                       return -22;
  #line 4561 
  vf = pf->vf + (unsigned long)vf_id;
  #line 4562 
  if (! test_bit(0L,& vf->vf_states)) {
    #line 4563 
    _dev_err(& (pf->pdev)->dev,(char *)"VF %d in reset. Try again.\n",vf_id);
    #line 4564 
    return -16;
  }
  #line 4567 
  vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
  #line 4568 
  if (vsi == (struct i40e_vsi *)0) 
                                   #line 4569 
                                   return -22;
  #line 4571 
  i40e_update_eth_stats(vsi);
  #line 4572 
  stats = & vsi->eth_stats;
  #line 4574 
  memset((void *)vf_stats,0,64UL);
  #line 4576 
  vf_stats->rx_packets = (stats->rx_unicast + stats->rx_broadcast) + stats->rx_multicast;
  #line 4578 
  vf_stats->tx_packets = (stats->tx_unicast + stats->tx_broadcast) + stats->tx_multicast;
  #line 4580 
  vf_stats->rx_bytes = stats->rx_bytes;
  #line 4581 
  vf_stats->tx_bytes = stats->tx_bytes;
  #line 4582 
  vf_stats->broadcast = stats->rx_broadcast;
  #line 4583 
  vf_stats->multicast = stats->rx_multicast;
  #line 4584 
  vf_stats->rx_dropped = stats->rx_discards;
  #line 4585 
  vf_stats->tx_dropped = stats->tx_discards;
  #line 4587 
  return 0;
}

#line 113  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static unsigned long cif_find_next_bit(unsigned long *addr, unsigned long size, unsigned long offset)
{
  #line 116 
  return ldv_find_next_bit(addr,size,offset);
}

#line 120  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static void cif_set_bit(long nr, unsigned long *addr)
{
  #line 123 
  ldv_set_bit(nr,addr);
  #line 124 
  return;
}

#line 127  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static void cif_clear_bit(long nr, unsigned long *addr)
{
  #line 130 
  ldv_clear_bit(nr,addr);
  #line 131 
  return;
}

#line 155  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static unsigned long cif_find_first_bit(unsigned long *addr, unsigned long size)
{
  #line 158 
  return ldv_find_first_bit(addr,size);
}

#line 407  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static void *kcalloc(size_t n, size_t size, gfp_t flags)
{
  #line 410 
  return ldv_kcalloc(n,size,flags);
}

#line 428  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static void *kzalloc(size_t size, gfp_t flags)
{
  #line 431 
  return ldv_kzalloc(size,flags);
}

#line 831  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static void cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi(spinlock_t *lock)
{
  #line 834 
  ldv_spin_model_lock((char *)"mac_filter_hash_lock_of_i40e_vsi");
  #line 836 
  spin_lock_bh_0(lock);
  #line 837 
  return;
}

#line 840  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_virtchnl_pf.i.aux"
static void cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi(spinlock_t *lock)
{
  #line 843 
  ldv_spin_model_unlock((char *)"mac_filter_hash_lock_of_i40e_vsi");
  #line 845 
  spin_unlock_bh_0(lock);
  #line 846 
  return;
}

#line 171  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/printk.h"
#line 171 
int printk(char * , ...);
#line 487 
#line 487 
void print_hex_dump(char *, char *, int, int, int, void *, size_t, bool);
#line 472  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernel.h"
#line 472 
int snprintf(char *, size_t, char * , ...);
#line 133  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.h"
#line 133 
void i40e_fill_default_direct_cmd_desc(struct i40e_aq_desc *desc, u16 opcode);
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 25 
i40e_status i40e_asq_send_command(struct i40e_hw *hw, struct i40e_aq_desc *desc, void *buff, u16 buff_size, struct i40e_asq_cmd_details *cmd_details);
#line 32 
#line 282  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_debug_aq(struct i40e_hw *hw, enum i40e_debug_mask mask, void *desc, void *buffer, u16 buf_len);
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 338  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
bool i40e_check_asq_alive(struct i40e_hw *hw);
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 355  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_queue_shutdown(struct i40e_hw *hw, bool unloading);
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 437  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_rss_lut(struct i40e_hw *hw, u16 vsi_id, bool pf_lut, u8 *lut, u16 lut_size);
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_rss_lut(struct i40e_hw *hw, u16 vsi_id, bool pf_lut, u8 *lut, u16 lut_size);
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 509  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_rss_key(struct i40e_hw *hw, u16 vsi_id, struct i40e_aqc_get_set_rss_key_data *key);
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 524  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_rss_key(struct i40e_hw *hw, u16 vsi_id, struct i40e_aqc_get_set_rss_key_data *key);
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1480  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
u32 i40e_led_get(struct i40e_hw *hw);
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1511  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_led_set(struct i40e_hw *hw, u32 mode, bool blink);
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5186  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_led_set_phy(struct i40e_hw *hw, bool on, u16 led_addr, u32 mode);
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_led_get_phy(struct i40e_hw *hw, u16 *led_addr, u16 *val);
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4990  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_blink_phy_link_led(struct i40e_hw *hw, u32 time, u32 interval);
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2474  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_firmware_version(struct i40e_hw *hw, u16 *fw_major_version, u16 *fw_minor_version, u32 *fw_build, u16 *api_major_version, u16 *api_minor_version, struct i40e_asq_cmd_details *cmd_details);
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3028  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_debug_write_register(struct i40e_hw *hw, u32 reg_addr, u64 reg_val, struct i40e_asq_cmd_details *cmd_details);
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2993  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_debug_read_register(struct i40e_hw *hw, u32 reg_addr, u64 *reg_val, struct i40e_asq_cmd_details *cmd_details);
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1954  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_phy_debug(struct i40e_hw *hw, u8 cmd_flags, struct i40e_asq_cmd_details *cmd_details);
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2023  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_default_vsi(struct i40e_hw *hw, u16 seid, struct i40e_asq_cmd_details *cmd_details);
#line 78  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2051  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_clear_default_vsi(struct i40e_hw *hw, u16 seid, struct i40e_asq_cmd_details *cmd_details);
#line 80  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1569  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_get_phy_capabilities(struct i40e_hw *hw, bool qualified_modules, bool report_init, struct i40e_aq_get_phy_abilities_resp *abilities, struct i40e_asq_cmd_details *cmd_details);
#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1648  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_set_phy_config(struct i40e_hw *hw, struct i40e_aq_set_phy_config *config, struct i40e_asq_cmd_details *cmd_details);
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1728  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_set_fc(struct i40e_hw *hw, u8 *aq_failures, bool atomic_restart);
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1927  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_phy_int_mask(struct i40e_hw *hw, u16 mask, struct i40e_asq_cmd_details *cmd_details);
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1771  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_clear_pxe_mode(struct i40e_hw *hw, struct i40e_asq_cmd_details *cmd_details);
#line 93  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1799  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_link_restart_an(struct i40e_hw *hw, bool enable_link, struct i40e_asq_cmd_details *cmd_details);
#line 102  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2513  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_send_driver_version(struct i40e_hw *hw, struct i40e_driver_version *dv, struct i40e_asq_cmd_details *cmd_details);
#line 105  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1980  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_vsi(struct i40e_hw *hw, struct i40e_vsi_context *vsi_ctx, struct i40e_asq_cmd_details *cmd_details);
#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2261  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_vsi_broadcast(struct i40e_hw *hw, u16 seid, bool set_filter, struct i40e_asq_cmd_details *cmd_details);
#line 124  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_vsi_bc_promisc_on_vlan(struct i40e_hw *hw, u16 seid, bool enable, u16 vid, struct i40e_asq_cmd_details *cmd_details);
#line 127  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2294  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_vsi_vlan_promisc(struct i40e_hw *hw, u16 seid, bool enable, struct i40e_asq_cmd_details *cmd_details);
#line 130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2324  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_vsi_params(struct i40e_hw *hw, struct i40e_vsi_context *vsi_ctx, struct i40e_asq_cmd_details *cmd_details);
#line 136  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2626  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_veb(struct i40e_hw *hw, u16 uplink_seid, u16 downlink_seid, u8 enabled_tc, bool default_port, u16 *veb_seid, bool enable_stats, struct i40e_asq_cmd_details *cmd_details);
#line 141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2684  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_veb_parameters(struct i40e_hw *hw, u16 veb_seid, u16 *switch_id, bool *floating, u16 *statistic_index, u16 *vebs_used, u16 *vebs_free, struct i40e_asq_cmd_details *cmd_details);
#line 146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2738  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_macvlan(struct i40e_hw *hw, u16 seid, struct i40e_aqc_add_macvlan_element_data *mv_list, u16 count, struct i40e_asq_cmd_details *cmd_details);
#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2786  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_remove_macvlan(struct i40e_hw *hw, u16 seid, struct i40e_aqc_remove_macvlan_element_data *mv_list, u16 count, struct i40e_asq_cmd_details *cmd_details);
#line 152  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2895  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_mirrorrule(struct i40e_hw *hw, u16 sw_seid, u16 rule_type, u16 dest_vsi, u16 count, __le16 *mr_list, struct i40e_asq_cmd_details *cmd_details, u16 *rule_id, u16 *rules_used, u16 *rules_free);
#line 156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2926  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_delete_mirrorrule(struct i40e_hw *hw, u16 sw_seid, u16 rule_type, u16 rule_id, u16 count, __le16 *mr_list, struct i40e_asq_cmd_details *cmd_details, u16 *rules_used, u16 *rules_free);
#line 164  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2403  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_switch_config(struct i40e_hw *hw, struct i40e_aqc_get_switch_config_resp *buf, u16 buf_size, u16 *start_seid, struct i40e_asq_cmd_details *cmd_details);
#line 168  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2437  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_set_switch_config(struct i40e_hw *hw, u16 flags, u16 valid_flags, u8 mode, struct i40e_asq_cmd_details *cmd_details);
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3059  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_request_resource(struct i40e_hw *hw, enum i40e_aq_resources_ids resource, enum i40e_aq_resource_access_type access, u8 sdp_number, u64 *timeout, struct i40e_asq_cmd_details *cmd_details);
#line 177  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3098  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_release_resource(struct i40e_hw *hw, enum i40e_aq_resources_ids resource, u8 sdp_number, struct i40e_asq_cmd_details *cmd_details);
#line 181  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_read_nvm(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 length, void *data, bool last_command, struct i40e_asq_cmd_details *cmd_details);
#line 185  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3176  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_erase_nvm(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 length, bool last_command, struct i40e_asq_cmd_details *cmd_details);
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3466  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_discover_capabilities(struct i40e_hw *hw, void *buff, u16 buff_size, u16 *data_size, enum i40e_admin_queue_opc list_type_opc, struct i40e_asq_cmd_details *cmd_details);
#line 192  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3515  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_update_nvm(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 length, void *data, bool last_command, u8 preservation_flags, struct i40e_asq_cmd_details *cmd_details);
#line 196  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3568  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_rearrange_nvm(struct i40e_hw *hw, u8 rearrange_nvm, struct i40e_asq_cmd_details *cmd_details);
#line 199  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3608  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_lldp_mib(struct i40e_hw *hw, u8 bridge_type, u8 mib_type, void *buff, u16 buff_size, u16 *local_len, u16 *remote_len, struct i40e_asq_cmd_details *cmd_details);
#line 203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3657  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_cfg_lldp_mib_change_event(struct i40e_hw *hw, bool enable_update, struct i40e_asq_cmd_details *cmd_details);
#line 207  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3687  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_restore_lldp(struct i40e_hw *hw, u8 *setting, bool restore, struct i40e_asq_cmd_details *cmd_details);
#line 209  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3723  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_stop_lldp(struct i40e_hw *hw, bool shutdown_agent, bool persist, struct i40e_asq_cmd_details *cmd_details);
#line 212  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3793  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_dcb_parameters(struct i40e_hw *hw, bool dcb_enable, struct i40e_asq_cmd_details *cmd_details);
#line 216  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3760  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_start_lldp(struct i40e_hw *hw, bool persist, struct i40e_asq_cmd_details *cmd_details);
#line 218  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3825  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_cee_dcb_config(struct i40e_hw *hw, void *buff, u16 buff_size, struct i40e_asq_cmd_details *cmd_details);
#line 221  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3856  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_udp_tunnel(struct i40e_hw *hw, u16 udp_port, u8 protocol_index, u8 *filter_index, struct i40e_asq_cmd_details *cmd_details);
#line 225  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3887  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_del_udp_tunnel(struct i40e_hw *hw, u8 index, struct i40e_asq_cmd_details *cmd_details);
#line 227  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3912  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_delete_element(struct i40e_hw *hw, u16 seid, struct i40e_asq_cmd_details *cmd_details);
#line 229  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 975  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_mac_address_write(struct i40e_hw *hw, u16 flags, u8 *mac_addr, struct i40e_asq_cmd_details *cmd_details);
#line 235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 3941  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_dcb_updated(struct i40e_hw *hw, struct i40e_asq_cmd_details *cmd_details);
#line 240  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4051  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_config_vsi_tc_bw(struct i40e_hw *hw, u16 seid, struct i40e_aqc_configure_vsi_tc_bw_data *bw_data, struct i40e_asq_cmd_details *cmd_details);
#line 243  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4069  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_config_switch_comp_ets(struct i40e_hw *hw, u16 seid, struct i40e_aqc_configure_switching_comp_ets_data *ets_data, enum i40e_admin_queue_opc opcode, struct i40e_asq_cmd_details *cmd_details);
#line 248  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4086  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_config_switch_comp_bw_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_configure_switching_comp_bw_config_data *bw_data, struct i40e_asq_cmd_details *cmd_details);
#line 252  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_vsi_bw_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_vsi_bw_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details);
#line 256  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4120  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_vsi_ets_sla_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_vsi_ets_sla_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details);
#line 260  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_switch_comp_ets_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_switching_comp_ets_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details);
#line 264  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4154  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_port_ets_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_port_ets_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details);
#line 268  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4171  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_switch_comp_bw_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_switching_comp_bw_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details);
#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4475  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_resume_port_tx(struct i40e_hw *hw, struct i40e_asq_cmd_details *cmd_details);
#line 275  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5932  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_add_cloud_filters_bb(struct i40e_hw *hw, u16 seid, struct i40e_aqc_cloud_filters_element_bb *filters, u8 filter_count);
#line 279  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5895  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_add_cloud_filters(struct i40e_hw *hw, u16 seid, struct i40e_aqc_cloud_filters_element_data *filters, u8 filter_count);
#line 283  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5989  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_rem_cloud_filters(struct i40e_hw *hw, u16 seid, struct i40e_aqc_cloud_filters_element_data *filters, u8 filter_count);
#line 287  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 6026  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_rem_cloud_filters_bb(struct i40e_hw *hw, u16 seid, struct i40e_aqc_cloud_filters_element_bb *filters, u8 filter_count);
#line 293  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 908  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_init_shared_code(struct i40e_hw *hw);
#line 294  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_pf_reset(struct i40e_hw *hw);
#line 295  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1319  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_clear_hw(struct i40e_hw *hw);
#line 296  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1411  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_clear_pxe_mode(struct i40e_hw *hw);
#line 297  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2555  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_get_link_status(struct i40e_hw *hw, bool *link_up);
#line 298  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 2576  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_update_link_info(struct i40e_hw *hw);
#line 299  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1005  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_get_mac_addr(struct i40e_hw *hw, u8 *mac_addr);
#line 300  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4601  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_read_bw_from_alt_ram(struct i40e_hw *hw, u32 *max_bw, u32 *min_bw, bool *min_valid, bool *max_valid);
#line 303  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4641  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_configure_partition_bw(struct i40e_hw *hw, struct i40e_aqc_configure_partition_bw_data *bw_data, struct i40e_asq_cmd_details *cmd_details);
#line 306  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1026  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_get_port_mac_addr(struct i40e_hw *hw, u8 *mac_addr);
#line 307  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1084  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_read_pba_string(struct i40e_hw *hw, u8 *pba_num, u32 pba_num_size);
#line 310  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1053  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_pre_tx_queue_cfg(struct i40e_hw *hw, u32 queue, bool enable);
#line 312  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 312 
i40e_status i40e_init_nvm(struct i40e_hw *hw);
#line 313 
#line 313 
i40e_status i40e_acquire_nvm(struct i40e_hw *hw, enum i40e_aq_resource_access_type access);
#line 315 
#line 315 
void i40e_release_nvm(struct i40e_hw *hw);
#line 316 
#line 316 
i40e_status i40e_read_nvm_word(struct i40e_hw *hw, u16 offset, u16 *data);
#line 335 
#line 4495  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_set_pci_config_data(struct i40e_hw *hw, u16 link_status);
#line 337  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_set_mac_type(struct i40e_hw *hw);
#line 339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 576  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
struct i40e_rx_ptype_decoded i40e_ptype_lookup[256U];
#line 392  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4285  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_set_filter_control(struct i40e_hw *hw, struct i40e_filter_control_settings *settings);
#line 394  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4359  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_rem_control_packet_filter(struct i40e_hw *hw, u8 *mac_addr, u16 ethtype, u16 flags, u16 vsi_seid, u16 queue, bool is_add, struct i40e_control_filter_stats *stats, struct i40e_asq_cmd_details *cmd_details);
#line 399  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4549  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_debug_dump(struct i40e_hw *hw, u8 cluster_id, u8 table_id, u32 start_index, u16 buff_size, void *buff, u16 *ret_buff_size, u8 *ret_next_table, u32 *ret_next_index, struct i40e_asq_cmd_details *cmd_details);
#line 404  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4410  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_add_filter_to_drop_tx_flow_control_frames(struct i40e_hw *hw, u16 seid);
#line 406  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_rx_ctl_read_register(struct i40e_hw *hw, u32 reg_addr, u32 *reg_val, struct i40e_asq_cmd_details *cmd_details);
#line 409  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5264  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
u32 i40e_read_rx_ctl(struct i40e_hw *hw, u32 reg_addr);
#line 410  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5301  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_rx_ctl_write_register(struct i40e_hw *hw, u32 reg_addr, u32 reg_val, struct i40e_asq_cmd_details *cmd_details);
#line 415  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5390  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_set_phy_register_ext(struct i40e_hw *hw, u8 phy_select, u8 dev_addr, bool page_change, bool set_mdio, u8 mdio_num, u32 reg_addr, u32 reg_val, struct i40e_asq_cmd_details *cmd_details);
#line 421  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5434  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_get_phy_register_ext(struct i40e_hw *hw, u8 phy_select, u8 dev_addr, bool page_change, bool set_mdio, u8 mdio_num, u32 reg_addr, u32 *reg_val, struct i40e_asq_cmd_details *cmd_details);
#line 433  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4676  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_read_phy_register_clause22(struct i40e_hw *hw, u16 reg, u8 phy_addr, u16 *value);
#line 435  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4721  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_write_phy_register_clause22(struct i40e_hw *hw, u16 reg, u8 phy_addr, u16 value);
#line 437  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4762  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_read_phy_register_clause45(struct i40e_hw *hw, u8 page, u16 reg, u8 phy_addr, u16 *value);
#line 439  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4836  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_write_phy_register_clause45(struct i40e_hw *hw, u8 page, u16 reg, u8 phy_addr, u16 value);
#line 441  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4940  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_read_phy_register(struct i40e_hw *hw, u8 page, u16 reg, u8 phy_addr, u16 *value);
#line 443  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4903  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_write_phy_register(struct i40e_hw *hw, u8 page, u16 reg, u8 phy_addr, u16 value);
#line 445  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 4974  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
u8 i40e_get_phy_address(struct i40e_hw *hw, u8 dev_num);
#line 448  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5475  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_write_ddp(struct i40e_hw *hw, void *buff, u16 buff_size, u32 track_id, u32 *error_offset, u32 *error_info, struct i40e_asq_cmd_details *cmd_details);
#line 453  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5519  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_ddp_list(struct i40e_hw *hw, void *buff, u16 buff_size, u8 flags, struct i40e_asq_cmd_details *cmd_details);
#line 458  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5553  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
struct i40e_generic_seg_header *i40e_find_segment_in_package(u32 segment_type, struct i40e_package_header *pkg_hdr);
#line 461  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5597  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
struct i40e_profile_section_header *i40e_find_section_in_profile(u32 section_type, struct i40e_profile_segment *profile);
#line 464  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5738  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_write_profile(struct i40e_hw *hw, struct i40e_profile_segment *profile, u32 track_id);
#line 467  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5801  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_rollback_profile(struct i40e_hw *hw, struct i40e_profile_segment *profile, u32 track_id);
#line 470  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 5853  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_add_pinfo_to_list(struct i40e_hw *hw, struct i40e_profile_segment *profile, u8 *profile_info_sec, u32 track_id);
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_set_mac_type(struct i40e_hw *hw)
{
  #line 19 
  i40e_status status = 0;
  #line 21 
  if ((unsigned int)hw->vendor_id == 32902U) 
    #line 22 
    switch ((int)hw->device_id) {
      #line 23 
      case 5490: 
                 #line 23 
      ;
      #line 24 
      case 5492: 
                 #line 24 
      ;
      #line 25 
      case 5504: 
                 #line 25 
      ;
      #line 26 
      case 5505: 
                 #line 26 
      ;
      #line 27 
      case 5507: 
                 #line 27 
      ;
      #line 28 
      case 5508: 
                 #line 28 
      ;
      #line 29 
      case 5509: 
                 #line 29 
      ;
      #line 30 
      case 5510: 
                 #line 30 
      ;
      #line 31 
      case 5513: 
                 #line 31 
      ;
      #line 32 
      case 5631: 
                 #line 32 
      ;
      #line 33 
      case 4175: 
                 #line 33 
      ;
      #line 34 
      case 4174: 
                 #line 34 
      ;
      #line 35 
      case 5511: 
                 #line 35 
      ;
      #line 36 
      case 5512: 
                 #line 36 
      ;
      #line 37 
      case 5514: 
                 #line 37 
      ;
      #line 38 
      case 5515: 
                 #line 38 
      ;
      #line 39 
      case 3320: 
                 #line 39 
      ;
      #line 40 
      case 3416: 
                 #line 40 
      ;
      #line 41 
      hw->mac.type = I40E_MAC_XL710;
      #line 42 
      break;
      #line 43 
      case 14286: 
                  #line 43 
      ;
      #line 44 
      case 14287: 
                  #line 44 
      ;
      #line 45 
      case 14288: 
                  #line 45 
      ;
      #line 46 
      case 14289: 
                  #line 46 
      ;
      #line 47 
      case 14290: 
                  #line 47 
      ;
      #line 48 
      case 14291: 
                  #line 48 
      ;
      #line 49 
      hw->mac.type = I40E_MAC_X722;
      #line 50 
      break;
      #line 51 
      default: 
               #line 51 
      ;
      #line 52 
      hw->mac.type = I40E_MAC_GENERIC;
      #line 53 
      break;
    }
  else 
       #line 56 
       status = I40E_ERR_DEVICE_NOT_SUPPORTED;
  {
    #line 59 
    bool branch;
    #line 59 
    struct _ddebug __UNIQUE_ID_ddebug558 = {.modname = (char *)"i40e", .function = (char *)"i40e_set_mac_type", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"i40e_set_mac_type found mac: %d, returns: %d\n", .lineno = (unsigned int)59U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 59 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug558.key.dd_key_false.key,(_Bool)0);
    #line 59 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 59 
                                                __dynamic_dev_dbg(& __UNIQUE_ID_ddebug558,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_set_mac_type found mac: %d, returns: %d\n",(unsigned int)hw->mac.type,(int)status);
  }
  #line 61 
  return status;
}

#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
char *i40e_aq_str(struct i40e_hw *hw, enum i40e_admin_queue_err aq_err)
{
  #line 71 
  switch ((unsigned int)aq_err) {
    #line 72 
    case (unsigned int)0: 
                          #line 72 
    ;
    #line 73 
    return (char *)"OK";
    #line 74 
    case (unsigned int)1: 
                          #line 74 
    ;
    #line 75 
    return (char *)"I40E_AQ_RC_EPERM";
    #line 76 
    case (unsigned int)2: 
                          #line 76 
    ;
    #line 77 
    return (char *)"I40E_AQ_RC_ENOENT";
    #line 78 
    case (unsigned int)3: 
                          #line 78 
    ;
    #line 79 
    return (char *)"I40E_AQ_RC_ESRCH";
    #line 80 
    case (unsigned int)4: 
                          #line 80 
    ;
    #line 81 
    return (char *)"I40E_AQ_RC_EINTR";
    #line 82 
    case (unsigned int)5: 
                          #line 82 
    ;
    #line 83 
    return (char *)"I40E_AQ_RC_EIO";
    #line 84 
    case (unsigned int)6: 
                          #line 84 
    ;
    #line 85 
    return (char *)"I40E_AQ_RC_ENXIO";
    #line 86 
    case (unsigned int)7: 
                          #line 86 
    ;
    #line 87 
    return (char *)"I40E_AQ_RC_E2BIG";
    #line 88 
    case (unsigned int)8: 
                          #line 88 
    ;
    #line 89 
    return (char *)"I40E_AQ_RC_EAGAIN";
    #line 90 
    case (unsigned int)9: 
                          #line 90 
    ;
    #line 91 
    return (char *)"I40E_AQ_RC_ENOMEM";
    #line 92 
    case (unsigned int)10: 
                           #line 92 
    ;
    #line 93 
    return (char *)"I40E_AQ_RC_EACCES";
    #line 94 
    case (unsigned int)11: 
                           #line 94 
    ;
    #line 95 
    return (char *)"I40E_AQ_RC_EFAULT";
    #line 96 
    case (unsigned int)12: 
                           #line 96 
    ;
    #line 97 
    return (char *)"I40E_AQ_RC_EBUSY";
    #line 98 
    case (unsigned int)13: 
                           #line 98 
    ;
    #line 99 
    return (char *)"I40E_AQ_RC_EEXIST";
    #line 100 
    case (unsigned int)14: 
                           #line 100 
    ;
    #line 101 
    return (char *)"I40E_AQ_RC_EINVAL";
    #line 102 
    case (unsigned int)15: 
                           #line 102 
    ;
    #line 103 
    return (char *)"I40E_AQ_RC_ENOTTY";
    #line 104 
    case (unsigned int)16: 
                           #line 104 
    ;
    #line 105 
    return (char *)"I40E_AQ_RC_ENOSPC";
    #line 106 
    case (unsigned int)17: 
                           #line 106 
    ;
    #line 107 
    return (char *)"I40E_AQ_RC_ENOSYS";
    #line 108 
    case (unsigned int)18: 
                           #line 108 
    ;
    #line 109 
    return (char *)"I40E_AQ_RC_ERANGE";
    #line 110 
    case (unsigned int)19: 
                           #line 110 
    ;
    #line 111 
    return (char *)"I40E_AQ_RC_EFLUSHED";
    #line 112 
    case (unsigned int)20: 
                           #line 112 
    ;
    #line 113 
    return (char *)"I40E_AQ_RC_BAD_ADDR";
    #line 114 
    case (unsigned int)21: 
                           #line 114 
    ;
    #line 115 
    return (char *)"I40E_AQ_RC_EMODE";
    #line 116 
    case (unsigned int)22: 
                           #line 116 
    ;
    #line 117 
    return (char *)"I40E_AQ_RC_EFBIG";
  }
  #line 120 
  snprintf((char *)(& hw->err_str),16UL,(char *)"%d",(unsigned int)aq_err);
  #line 121 
  return (char *)(& hw->err_str);
}

#line 129  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
char *i40e_stat_str(struct i40e_hw *hw, i40e_status stat_err)
{
  #line 131 
  switch ((int)stat_err) {
    #line 132 
    case 0: 
            #line 132 
    ;
    #line 133 
    return (char *)"OK";
    #line 134 
    case -1: 
             #line 134 
    ;
    #line 135 
    return (char *)"I40E_ERR_NVM";
    #line 136 
    case -2: 
             #line 136 
    ;
    #line 137 
    return (char *)"I40E_ERR_NVM_CHECKSUM";
    #line 138 
    case -3: 
             #line 138 
    ;
    #line 139 
    return (char *)"I40E_ERR_PHY";
    #line 140 
    case -4: 
             #line 140 
    ;
    #line 141 
    return (char *)"I40E_ERR_CONFIG";
    #line 142 
    case -5: 
             #line 142 
    ;
    #line 143 
    return (char *)"I40E_ERR_PARAM";
    #line 144 
    case -6: 
             #line 144 
    ;
    #line 145 
    return (char *)"I40E_ERR_MAC_TYPE";
    #line 146 
    case -7: 
             #line 146 
    ;
    #line 147 
    return (char *)"I40E_ERR_UNKNOWN_PHY";
    #line 148 
    case -8: 
             #line 148 
    ;
    #line 149 
    return (char *)"I40E_ERR_LINK_SETUP";
    #line 150 
    case -9: 
             #line 150 
    ;
    #line 151 
    return (char *)"I40E_ERR_ADAPTER_STOPPED";
    #line 152 
    case -10: 
              #line 152 
    ;
    #line 153 
    return (char *)"I40E_ERR_INVALID_MAC_ADDR";
    #line 154 
    case -11: 
              #line 154 
    ;
    #line 155 
    return (char *)"I40E_ERR_DEVICE_NOT_SUPPORTED";
    #line 156 
    case -12: 
              #line 156 
    ;
    #line 157 
    return (char *)"I40E_ERR_MASTER_REQUESTS_PENDING";
    #line 158 
    case -13: 
              #line 158 
    ;
    #line 159 
    return (char *)"I40E_ERR_INVALID_LINK_SETTINGS";
    #line 160 
    case -14: 
              #line 160 
    ;
    #line 161 
    return (char *)"I40E_ERR_AUTONEG_NOT_COMPLETE";
    #line 162 
    case -15: 
              #line 162 
    ;
    #line 163 
    return (char *)"I40E_ERR_RESET_FAILED";
    #line 164 
    case -16: 
              #line 164 
    ;
    #line 165 
    return (char *)"I40E_ERR_SWFW_SYNC";
    #line 166 
    case -17: 
              #line 166 
    ;
    #line 167 
    return (char *)"I40E_ERR_NO_AVAILABLE_VSI";
    #line 168 
    case -18: 
              #line 168 
    ;
    #line 169 
    return (char *)"I40E_ERR_NO_MEMORY";
    #line 170 
    case -19: 
              #line 170 
    ;
    #line 171 
    return (char *)"I40E_ERR_BAD_PTR";
    #line 172 
    case -20: 
              #line 172 
    ;
    #line 173 
    return (char *)"I40E_ERR_RING_FULL";
    #line 174 
    case -21: 
              #line 174 
    ;
    #line 175 
    return (char *)"I40E_ERR_INVALID_PD_ID";
    #line 176 
    case -22: 
              #line 176 
    ;
    #line 177 
    return (char *)"I40E_ERR_INVALID_QP_ID";
    #line 178 
    case -23: 
              #line 178 
    ;
    #line 179 
    return (char *)"I40E_ERR_INVALID_CQ_ID";
    #line 180 
    case -24: 
              #line 180 
    ;
    #line 181 
    return (char *)"I40E_ERR_INVALID_CEQ_ID";
    #line 182 
    case -25: 
              #line 182 
    ;
    #line 183 
    return (char *)"I40E_ERR_INVALID_AEQ_ID";
    #line 184 
    case -26: 
              #line 184 
    ;
    #line 185 
    return (char *)"I40E_ERR_INVALID_SIZE";
    #line 186 
    case -27: 
              #line 186 
    ;
    #line 187 
    return (char *)"I40E_ERR_INVALID_ARP_INDEX";
    #line 188 
    case -28: 
              #line 188 
    ;
    #line 189 
    return (char *)"I40E_ERR_INVALID_FPM_FUNC_ID";
    #line 190 
    case -29: 
              #line 190 
    ;
    #line 191 
    return (char *)"I40E_ERR_QP_INVALID_MSG_SIZE";
    #line 192 
    case -30: 
              #line 192 
    ;
    #line 193 
    return (char *)"I40E_ERR_QP_TOOMANY_WRS_POSTED";
    #line 194 
    case -31: 
              #line 194 
    ;
    #line 195 
    return (char *)"I40E_ERR_INVALID_FRAG_COUNT";
    #line 196 
    case -32: 
              #line 196 
    ;
    #line 197 
    return (char *)"I40E_ERR_QUEUE_EMPTY";
    #line 198 
    case -33: 
              #line 198 
    ;
    #line 199 
    return (char *)"I40E_ERR_INVALID_ALIGNMENT";
    #line 200 
    case -34: 
              #line 200 
    ;
    #line 201 
    return (char *)"I40E_ERR_FLUSHED_QUEUE";
    #line 202 
    case -35: 
              #line 202 
    ;
    #line 203 
    return (char *)"I40E_ERR_INVALID_PUSH_PAGE_INDEX";
    #line 204 
    case -36: 
              #line 204 
    ;
    #line 205 
    return (char *)"I40E_ERR_INVALID_IMM_DATA_SIZE";
    #line 206 
    case -37: 
              #line 206 
    ;
    #line 207 
    return (char *)"I40E_ERR_TIMEOUT";
    #line 208 
    case -38: 
              #line 208 
    ;
    #line 209 
    return (char *)"I40E_ERR_OPCODE_MISMATCH";
    #line 210 
    case -39: 
              #line 210 
    ;
    #line 211 
    return (char *)"I40E_ERR_CQP_COMPL_ERROR";
    #line 212 
    case -40: 
              #line 212 
    ;
    #line 213 
    return (char *)"I40E_ERR_INVALID_VF_ID";
    #line 214 
    case -41: 
              #line 214 
    ;
    #line 215 
    return (char *)"I40E_ERR_INVALID_HMCFN_ID";
    #line 216 
    case -42: 
              #line 216 
    ;
    #line 217 
    return (char *)"I40E_ERR_BACKING_PAGE_ERROR";
    #line 218 
    case -43: 
              #line 218 
    ;
    #line 219 
    return (char *)"I40E_ERR_NO_PBLCHUNKS_AVAILABLE";
    #line 220 
    case -44: 
              #line 220 
    ;
    #line 221 
    return (char *)"I40E_ERR_INVALID_PBLE_INDEX";
    #line 222 
    case -45: 
              #line 222 
    ;
    #line 223 
    return (char *)"I40E_ERR_INVALID_SD_INDEX";
    #line 224 
    case -46: 
              #line 224 
    ;
    #line 225 
    return (char *)"I40E_ERR_INVALID_PAGE_DESC_INDEX";
    #line 226 
    case -47: 
              #line 226 
    ;
    #line 227 
    return (char *)"I40E_ERR_INVALID_SD_TYPE";
    #line 228 
    case -48: 
              #line 228 
    ;
    #line 229 
    return (char *)"I40E_ERR_MEMCPY_FAILED";
    #line 230 
    case -49: 
              #line 230 
    ;
    #line 231 
    return (char *)"I40E_ERR_INVALID_HMC_OBJ_INDEX";
    #line 232 
    case -50: 
              #line 232 
    ;
    #line 233 
    return (char *)"I40E_ERR_INVALID_HMC_OBJ_COUNT";
    #line 234 
    case -51: 
              #line 234 
    ;
    #line 235 
    return (char *)"I40E_ERR_INVALID_SRQ_ARM_LIMIT";
    #line 236 
    case -52: 
              #line 236 
    ;
    #line 237 
    return (char *)"I40E_ERR_SRQ_ENABLED";
    #line 238 
    case -53: 
              #line 238 
    ;
    #line 239 
    return (char *)"I40E_ERR_ADMIN_QUEUE_ERROR";
    #line 240 
    case -54: 
              #line 240 
    ;
    #line 241 
    return (char *)"I40E_ERR_ADMIN_QUEUE_TIMEOUT";
    #line 242 
    case -55: 
              #line 242 
    ;
    #line 243 
    return (char *)"I40E_ERR_BUF_TOO_SHORT";
    #line 244 
    case -56: 
              #line 244 
    ;
    #line 245 
    return (char *)"I40E_ERR_ADMIN_QUEUE_FULL";
    #line 246 
    case -57: 
              #line 246 
    ;
    #line 247 
    return (char *)"I40E_ERR_ADMIN_QUEUE_NO_WORK";
    #line 248 
    case -58: 
              #line 248 
    ;
    #line 249 
    return (char *)"I40E_ERR_BAD_IWARP_CQE";
    #line 250 
    case -59: 
              #line 250 
    ;
    #line 251 
    return (char *)"I40E_ERR_NVM_BLANK_MODE";
    #line 252 
    case -60: 
              #line 252 
    ;
    #line 253 
    return (char *)"I40E_ERR_NOT_IMPLEMENTED";
    #line 254 
    case -61: 
              #line 254 
    ;
    #line 255 
    return (char *)"I40E_ERR_PE_DOORBELL_NOT_ENABLED";
    #line 256 
    case -62: 
              #line 256 
    ;
    #line 257 
    return (char *)"I40E_ERR_DIAG_TEST_FAILED";
    #line 258 
    case -63: 
              #line 258 
    ;
    #line 259 
    return (char *)"I40E_ERR_NOT_READY";
    #line 260 
    case -64: 
              #line 260 
    ;
    #line 261 
    return (char *)"I40E_NOT_SUPPORTED";
    #line 262 
    case -65: 
              #line 262 
    ;
    #line 263 
    return (char *)"I40E_ERR_FIRMWARE_API_VERSION";
    #line 264 
    case -66: 
              #line 264 
    ;
    #line 265 
    return (char *)"I40E_ERR_ADMIN_QUEUE_CRITICAL_ERROR";
  }
  #line 268 
  snprintf((char *)(& hw->err_str),16UL,(char *)"%d",(int)stat_err);
  #line 269 
  return (char *)(& hw->err_str);
}

#line 282  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_debug_aq(struct i40e_hw *hw, enum i40e_debug_mask mask, void *desc, void *buffer, u16 buf_len)
{
  #line 287 
  char prefix[27U];
  #line 288 
  u16 len;
  #line 285 
  struct i40e_aq_desc *aq_desc = (struct i40e_aq_desc *)desc;
  #line 286 
  u32 effective_mask = hw->debug_mask & (unsigned int)mask;
  #line 289 
  u8 *buf = (u8 *)buffer;
  #line 291 
  if (effective_mask == 0U || desc == (void *)0) 
                                                 #line 292 
                                                 return;
  #line 294 
  len = aq_desc->datalen;
  #line 296 
  if (((hw->debug_mask & (unsigned int)mask) & 33554432U) != 0U) 
                                                                 #line 296 
                                                                 printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)aq_desc->opcode,(int)aq_desc->flags,(int)aq_desc->datalen,(int)aq_desc->retval);
  #line 302 
  if (((hw->debug_mask & (unsigned int)mask) & 33554432U) != 0U) 
                                                                 #line 302 
                                                                 printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,aq_desc->cookie_high,aq_desc->cookie_low);
  #line 306 
  if (((hw->debug_mask & (unsigned int)mask) & 33554432U) != 0U) 
                                                                 #line 306 
                                                                 printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,aq_desc->params.internal.param0,aq_desc->params.internal.param1);
  #line 310 
  if (((hw->debug_mask & (unsigned int)mask) & 33554432U) != 0U) 
                                                                 #line 310 
                                                                 printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,aq_desc->params.external.addr_high,aq_desc->params.external.addr_low);
  #line 315 
  if (((buffer != (void *)0 && (unsigned int)buf_len != 0U) && (unsigned int)len != 0U) && (effective_mask & 67108864U) != 0U) {
    #line 317 
    if ((hw->debug_mask & (unsigned int)mask) != 0U) 
                                                     #line 317 
                                                     printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
    #line 318 
    if ((int)buf_len < (int)len) 
                                 #line 319 
                                 len = buf_len;
    #line 321 
    snprintf((char *)(& prefix),27UL,(char *)"i40e %02x:%02x.%x: \t0x",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
    #line 327 
    print_hex_dump((char *)"\001",(char *)(& prefix),2,16,1,(void *)buf,(unsigned long)len,(_Bool)0);
  }
  #line 329 
  return;
}

#line 338  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
bool i40e_check_asq_alive(struct i40e_hw *hw)
{
  #line 340 
  if (hw->aq.asq.len != 0U) {
    #line 341 
    return (_Bool)((readl((void *)(hw->hw_addr + (unsigned long)hw->aq.asq.len)) & 2147483648U) != 0U);
  }
  else 
       #line 344 
       return (_Bool)0;
}

#line 355  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_queue_shutdown(struct i40e_hw *hw, bool unloading)
{
  #line 358 
  struct i40e_aq_desc desc;
  #line 361 
  i40e_status status;
  #line 359 
  struct i40e_aqc_queue_shutdown *cmd = (struct i40e_aqc_queue_shutdown *)(& desc.params.raw);
  #line 363 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)3);
  #line 366 
  if ((int)unloading != 0) 
                           #line 367 
                           cmd->driver_unloading = 1U;
  #line 368 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,(struct i40e_asq_cmd_details *)0);
  #line 370 
  return status;
}

#line 384  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static i40e_status i40e_aq_get_set_rss_lut(struct i40e_hw *hw, u16 vsi_id, bool pf_lut, u8 *lut, u16 lut_size, bool set)
{
  #line 389 
  i40e_status status;
  #line 390 
  struct i40e_aq_desc desc;
  #line 391 
  struct i40e_aqc_get_set_rss_lut *cmd_resp = (struct i40e_aqc_get_set_rss_lut *)(& desc.params.raw);
  #line 394 
  if ((int)set != 0) 
                     #line 395 
                     i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2819); else 
                                                                    #line 398 
                                                                    i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2821);
  #line 402 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  #line 403 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 1024U);
  #line 405 
  cmd_resp->vsi_id = (unsigned short)((unsigned int)vsi_id & 1023U);
  #line 409 
  cmd_resp->vsi_id = (unsigned short)((unsigned int)cmd_resp->vsi_id | 32768U);
  #line 411 
  if ((int)pf_lut != 0) 
                        #line 412 
                        cmd_resp->flags = (unsigned short)((unsigned int)cmd_resp->flags | 1U); else 
                                                                    #line 417 
                                                                    cmd_resp->flags = cmd_resp->flags;
  #line 422 
  status = i40e_asq_send_command(hw,& desc,(void *)lut,(unsigned short)((int)lut_size),(struct i40e_asq_cmd_details *)0);
  #line 424 
  return status;
}

#line 437  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_rss_lut(struct i40e_hw *hw, u16 vsi_id, bool pf_lut, u8 *lut, u16 lut_size)
{
  #line 440 
  return i40e_aq_get_set_rss_lut(hw,(unsigned short)((int)vsi_id),
                              (_Bool)((bool)((int)pf_lut) != 0),lut,
                              (unsigned short)((int)lut_size),(_Bool)0);
}

#line 454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_rss_lut(struct i40e_hw *hw, u16 vsi_id, bool pf_lut, u8 *lut, u16 lut_size)
{
  #line 457 
  return i40e_aq_get_set_rss_lut(hw,(unsigned short)((int)vsi_id),
                              (_Bool)((bool)((int)pf_lut) != 0),lut,
                              (unsigned short)((int)lut_size),(_Bool)1);
}

#line 469  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static i40e_status i40e_aq_get_set_rss_key(struct i40e_hw *hw, u16 vsi_id, struct i40e_aqc_get_set_rss_key_data *key, bool set)
{
  #line 474 
  i40e_status status;
  #line 475 
  struct i40e_aq_desc desc;
  #line 476 
  struct i40e_aqc_get_set_rss_key *cmd_resp = (struct i40e_aqc_get_set_rss_key *)(& desc.params.raw);
  #line 478 
  u16 key_size = (unsigned short)52U;
  #line 480 
  if ((int)set != 0) 
                     #line 481 
                     i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2818); else 
                                                                    #line 484 
                                                                    i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2820);
  #line 488 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  #line 489 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 1024U);
  #line 491 
  cmd_resp->vsi_id = (unsigned short)((unsigned int)vsi_id & 1023U);
  #line 495 
  cmd_resp->vsi_id = (unsigned short)((unsigned int)cmd_resp->vsi_id | 32768U);
  #line 497 
  status = i40e_asq_send_command(hw,& desc,(void *)key,(unsigned short)((int)key_size),(struct i40e_asq_cmd_details *)0);
  #line 499 
  return status;
}

#line 509  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_rss_key(struct i40e_hw *hw, u16 vsi_id, struct i40e_aqc_get_set_rss_key_data *key)
{
  #line 513 
  return i40e_aq_get_set_rss_key(hw,(unsigned short)((int)vsi_id),key,(_Bool)0);
}

#line 524  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_rss_key(struct i40e_hw *hw, u16 vsi_id, struct i40e_aqc_get_set_rss_key_data *key)
{
  #line 528 
  return i40e_aq_get_set_rss_key(hw,(unsigned short)((int)vsi_id),key,(_Bool)1);
}

#line 576  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
struct i40e_rx_ptype_decoded i40e_ptype_lookup[256U] = {[1] = {.ptype = (unsigned int)1U, .known = (unsigned int)1U, .payload_layer = (unsigned int)1U}, {.ptype = (unsigned int)2U, .known = (unsigned int)1U, .inner_prot = (unsigned int)5U, .payload_layer = (unsigned int)1U}, {.ptype = (unsigned int)3U, .known = (unsigned int)1U, .payload_layer = (unsigned int)1U}, {.ptype = (unsigned int)4U}, {.ptype = (unsigned int)5U}, {.ptype = (unsigned int)6U, .known = (unsigned int)1U, .payload_layer = (unsigned int)1U}, {.ptype = (unsigned int)7U, .known = (unsigned int)1U, .payload_layer = (unsigned int)1U}, {.ptype = (unsigned int)8U}, {.ptype = (unsigned int)9U}, {.ptype = (unsigned int)10U, .known = (unsigned int)1U, .payload_layer = (unsigned int)1U}, {.ptype = (unsigned int)11U, .known = (unsigned int)1U}, {.ptype = (unsigned int)12U, .known = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)13U, .known = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)14U, .known = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)15U, .known = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)16U, .known = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)17U, .known = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)18U, .known = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)19U, .known = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)20U, .known = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)21U, .known = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)22U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)23U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)24U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)25U}, {.ptype = (unsigned int)26U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)27U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)28U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)29U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)1U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)30U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)31U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)32U}, {.ptype = (unsigned int)33U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)34U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)35U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)36U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)2U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)37U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)2U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)38U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)39U}, {.ptype = (unsigned int)40U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)41U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)42U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)43U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)44U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)1U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)45U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)46U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)47U}, {.ptype = (unsigned int)48U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)49U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)50U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)51U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)2U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)52U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)2U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)53U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)54U}, {.ptype = (unsigned int)55U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)56U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)57U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)58U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)59U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)1U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)60U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)61U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)62U}, {.ptype = (unsigned int)63U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)64U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)65U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)66U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)2U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)67U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)2U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)68U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)69U}, {.ptype = (unsigned int)70U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)71U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)72U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)73U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)74U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)1U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)75U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)76U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)77U}, {.ptype = (unsigned int)78U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)79U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)80U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)81U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)2U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)82U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)2U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)83U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)84U}, {.ptype = (unsigned int)85U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)86U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)87U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)88U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .outer_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)89U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)90U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)91U}, {.ptype = (unsigned int)92U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)93U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)94U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)95U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)1U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)96U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)97U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)98U}, {.ptype = (unsigned int)99U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)100U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)101U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)102U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)2U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)103U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)2U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)104U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)105U}, {.ptype = (unsigned int)106U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)107U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)108U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)1U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)109U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)110U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)1U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)111U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)112U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)113U}, {.ptype = (unsigned int)114U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)115U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)116U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)117U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)2U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)118U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)2U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)119U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)120U}, {.ptype = (unsigned int)121U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)122U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)123U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)2U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)124U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)125U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)1U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)126U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)127U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)128U}, {.ptype = (unsigned int)129U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)130U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)131U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)132U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)2U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)133U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)2U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)134U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)135U}, {.ptype = (unsigned int)136U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)137U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)138U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)3U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)139U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)140U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)1U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)141U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)142U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)143U}, {.ptype = (unsigned int)144U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)145U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)146U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)1U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)147U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)2U, .tunnel_end_frag = (unsigned int)1U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)148U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)2U, .payload_layer = (unsigned int)2U}, {.ptype = (unsigned int)149U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)1U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)150U}, {.ptype = (unsigned int)151U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)2U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)152U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)3U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)153U, .known = (unsigned int)1U, .outer_ip = (unsigned int)1U, .outer_ip_ver = (unsigned int)1U, .tunnel_type = (unsigned int)4U, .tunnel_end_prot = (unsigned int)2U, .inner_prot = (unsigned int)4U, .payload_layer = (unsigned int)3U}, {.ptype = (unsigned int)154U}, {.ptype = (unsigned int)155U}, {.ptype = (unsigned int)156U}, {.ptype = (unsigned int)157U}, {.ptype = (unsigned int)158U}, {.ptype = (unsigned int)159U}, {.ptype = (unsigned int)160U}, {.ptype = (unsigned int)161U}, {.ptype = (unsigned int)162U}, {.ptype = (unsigned int)163U}, {.ptype = (unsigned int)164U}, {.ptype = (unsigned int)165U}, {.ptype = (unsigned int)166U}, {.ptype = (unsigned int)167U}, {.ptype = (unsigned int)168U}, {.ptype = (unsigned int)169U}, {.ptype = (unsigned int)170U}, {.ptype = (unsigned int)171U}, {.ptype = (unsigned int)172U}, {.ptype = (unsigned int)173U}, {.ptype = (unsigned int)174U}, {.ptype = (unsigned int)175U}, {.ptype = (unsigned int)176U}, {.ptype = (unsigned int)177U}, {.ptype = (unsigned int)178U}, {.ptype = (unsigned int)179U}, {.ptype = (unsigned int)180U}, {.ptype = (unsigned int)181U}, {.ptype = (unsigned int)182U}, {.ptype = (unsigned int)183U}, {.ptype = (unsigned int)184U}, {.ptype = (unsigned int)185U}, {.ptype = (unsigned int)186U}, {.ptype = (unsigned int)187U}, {.ptype = (unsigned int)188U}, {.ptype = (unsigned int)189U}, {.ptype = (unsigned int)190U}, {.ptype = (unsigned int)191U}, {.ptype = (unsigned int)192U}, {.ptype = (unsigned int)193U}, {.ptype = (unsigned int)194U}, {.ptype = (unsigned int)195U}, {.ptype = (unsigned int)196U}, {.ptype = (unsigned int)197U}, {.ptype = (unsigned int)198U}, {.ptype = (unsigned int)199U}, {.ptype = (unsigned int)200U}, {.ptype = (unsigned int)201U}, {.ptype = (unsigned int)202U}, {.ptype = (unsigned int)203U}, {.ptype = (unsigned int)204U}, {.ptype = (unsigned int)205U}, {.ptype = (unsigned int)206U}, {.ptype = (unsigned int)207U}, {.ptype = (unsigned int)208U}, {.ptype = (unsigned int)209U}, {.ptype = (unsigned int)210U}, {.ptype = (unsigned int)211U}, {.ptype = (unsigned int)212U}, {.ptype = (unsigned int)213U}, {.ptype = (unsigned int)214U}, {.ptype = (unsigned int)215U}, {.ptype = (unsigned int)216U}, {.ptype = (unsigned int)217U}, {.ptype = (unsigned int)218U}, {.ptype = (unsigned int)219U}, {.ptype = (unsigned int)220U}, {.ptype = (unsigned int)221U}, {.ptype = (unsigned int)222U}, {.ptype = (unsigned int)223U}, {.ptype = (unsigned int)224U}, {.ptype = (unsigned int)225U}, {.ptype = (unsigned int)226U}, {.ptype = (unsigned int)227U}, {.ptype = (unsigned int)228U}, {.ptype = (unsigned int)229U}, {.ptype = (unsigned int)230U}, {.ptype = (unsigned int)231U}, {.ptype = (unsigned int)232U}, {.ptype = (unsigned int)233U}, {.ptype = (unsigned int)234U}, {.ptype = (unsigned int)235U}, {.ptype = (unsigned int)236U}, {.ptype = (unsigned int)237U}, {.ptype = (unsigned int)238U}, {.ptype = (unsigned int)239U}, {.ptype = (unsigned int)240U}, {.ptype = (unsigned int)241U}, {.ptype = (unsigned int)242U}, {.ptype = (unsigned int)243U}, {.ptype = (unsigned int)244U}, {.ptype = (unsigned int)245U}, {.ptype = (unsigned int)246U}, {.ptype = (unsigned int)247U}, {.ptype = (unsigned int)248U}, {.ptype = (unsigned int)249U}, {.ptype = (unsigned int)250U}, {.ptype = (unsigned int)251U}, {.ptype = (unsigned int)252U}, {.ptype = (unsigned int)253U}, {.ptype = (unsigned int)254U}, {.ptype = (unsigned int)255U}};
#line 908  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_init_shared_code(struct i40e_hw *hw)
{
  #line 911 
  u32 port;
  #line 911 
  u32 ari;
  #line 911 
  u32 func_rid;
  #line 910 
  i40e_status status = 0;
  #line 913 
  i40e_set_mac_type(hw);
  #line 915 
  switch ((unsigned int)hw->mac.type) {
    #line 916 
    case (unsigned int)1: 
                          #line 916 
    ;
    #line 917 
    case (unsigned int)3: 
                          #line 917 
    ;
    #line 918 
    break;
    #line 919 
    default: 
             #line 919 
    ;
    #line 920 
    return I40E_ERR_DEVICE_NOT_SUPPORTED;
  }
  #line 923 
  hw->phy.get_link_info = (_Bool)1;
  #line 926 
  port = readl((void *)(hw->hw_addr + 1836160U)) & 3U;
  #line 928 
  hw->port = (unsigned char)port;
  #line 929 
  ari = (readl((void *)(hw->hw_addr + 779432U)) >> 4) & 1U;
  #line 931 
  func_rid = readl((void *)(hw->hw_addr + 638976U));
  #line 932 
  if (ari != 0U) 
                 #line 933 
                 hw->pf_id = (unsigned char)func_rid; else 
                                                           #line 935 
                                                           hw->pf_id = (unsigned char)((unsigned int)((unsigned char)func_rid) & 7U);
  #line 937 
  status = i40e_init_nvm(hw);
  #line 938 
  return status;
}

#line 948  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static i40e_status i40e_aq_mac_address_read(struct i40e_hw *hw, u16 *flags, struct i40e_aqc_mac_address_read_data *addrs, struct i40e_asq_cmd_details *cmd_details)
{
  #line 953 
  struct i40e_aq_desc desc;
  #line 956 
  i40e_status status;
  #line 954 
  struct i40e_aqc_mac_address_read *cmd_data = (struct i40e_aqc_mac_address_read *)(& desc.params.raw);
  #line 958 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)263);
  #line 959 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  #line 961 
  status = i40e_asq_send_command(hw,& desc,(void *)addrs,(unsigned short)24,cmd_details);
  #line 963 
  *flags = cmd_data->command_flags;
  #line 965 
  return status;
}

#line 975  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_mac_address_write(struct i40e_hw *hw, u16 flags, u8 *mac_addr, struct i40e_asq_cmd_details *cmd_details)
{
  #line 979 
  struct i40e_aq_desc desc;
  #line 982 
  i40e_status status;
  #line 980 
  struct i40e_aqc_mac_address_write *cmd_data = (struct i40e_aqc_mac_address_write *)(& desc.params.raw);
  #line 984 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)264);
  #line 986 
  cmd_data->command_flags = flags;
  #line 987 
  cmd_data->mac_sah = (unsigned short)(((int)*mac_addr << 8) | (int)*(mac_addr + 1U));
  #line 988 
  cmd_data->mac_sal = ((((unsigned int)*(mac_addr + 2U) << 24) | ((unsigned int)*(mac_addr + 3U) << 16)) | ((unsigned int)*(mac_addr + 4U) << 8)) | (unsigned int)*(mac_addr + 5U);
  #line 993 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 995 
  return status;
}

#line 1005  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_get_mac_addr(struct i40e_hw *hw, u8 *mac_addr)
{
  #line 1007 
  struct i40e_aqc_mac_address_read_data addrs;
  #line 1008 
  i40e_status status;
  #line 1009 
  u16 flags = (unsigned short)0U;
  #line 1011 
  status = i40e_aq_mac_address_read(hw,& flags,& addrs,(struct i40e_asq_cmd_details *)0);
  #line 1013 
  if (((int)flags & 16) != 0) 
                              #line 1014 
                              ether_addr_copy(mac_addr,(u8 *)(& addrs.pf_lan_mac));
  #line 1016 
  return status;
}

#line 1026  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_get_port_mac_addr(struct i40e_hw *hw, u8 *mac_addr)
{
  #line 1028 
  struct i40e_aqc_mac_address_read_data addrs;
  #line 1029 
  i40e_status status;
  #line 1030 
  u16 flags = (unsigned short)0U;
  #line 1032 
  status = i40e_aq_mac_address_read(hw,& flags,& addrs,(struct i40e_asq_cmd_details *)0);
  #line 1033 
  if (status != I40E_SUCCESS) 
                              #line 1034 
                              return status;
  #line 1036 
  if (((int)flags & 64) != 0) 
                              #line 1037 
                              ether_addr_copy(mac_addr,(u8 *)(& addrs.port_mac)); else 
                                                                    #line 1039 
                                                                    status = I40E_ERR_INVALID_MAC_ADDR;
  #line 1041 
  return status;
}

#line 1053  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_pre_tx_queue_cfg(struct i40e_hw *hw, u32 queue, bool enable)
{
  #line 1057 
  u32 reg_val;
  #line 1055 
  u32 abs_queue_idx = hw->func_caps.base_queue + queue;
  #line 1056 
  u32 reg_block = 0U;
  #line 1059 
  if (abs_queue_idx > 127U) {
    #line 1060 
    reg_block = abs_queue_idx / 128U;
    #line 1061 
    abs_queue_idx &= 127U;
  }
  #line 1064 
  reg_val = readl((void *)(hw->hw_addr + (unsigned long)((reg_block + 235840U) * 4U)));
  #line 1065 
  reg_val &= 4294965248U;
  #line 1066 
  reg_val |= abs_queue_idx;
  #line 1068 
  if ((int)enable != 0) 
                        #line 1069 
                        reg_val |= 2147483648U; else 
                                                     #line 1071 
                                                     reg_val |= 1073741824U;
  #line 1073 
  writel(reg_val,(void *)(hw->hw_addr + (unsigned long)((reg_block + 235840U) * 4U)));
  #line 1074 
  return;
}

#line 1084  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_read_pba_string(struct i40e_hw *hw, u8 *pba_num, u32 pba_num_size)
{
  #line 1087 
  i40e_status status = 0;
  #line 1088 
  u16 pba_word = (unsigned short)0U;
  #line 1089 
  u16 pba_size = (unsigned short)0U;
  #line 1090 
  u16 pba_ptr = (unsigned short)0U;
  #line 1091 
  u16 i = (unsigned short)0U;
  #line 1093 
  status = i40e_read_nvm_word(hw,(unsigned short)21,& pba_word);
  #line 1094 
  if (status != I40E_SUCCESS || (unsigned int)pba_word != 64250U) {
    {
      #line 1095 
      bool branch;
      #line 1095 
      struct _ddebug __UNIQUE_ID_ddebug559 = {.modname = (char *)"i40e", .function = (char *)"i40e_read_pba_string", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"Failed to read PBA flags or flag is invalid.\n", .lineno = (unsigned int)1095U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1095 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug559.key.dd_key_false.key,(_Bool)0);
      #line 1095 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1095 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug559,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"Failed to read PBA flags or flag is invalid.\n");
    }
    #line 1096 
    return status;
  }
  #line 1099 
  status = i40e_read_nvm_word(hw,(unsigned short)22,& pba_ptr);
  #line 1100 
  if (status != I40E_SUCCESS) {
    {
      #line 1101 
      bool branch_0;
      #line 1101 
      struct _ddebug __UNIQUE_ID_ddebug560 = {.modname = (char *)"i40e", .function = (char *)"i40e_read_pba_string", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"Failed to read PBA Block pointer.\n", .lineno = (unsigned int)1101U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1101 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug560.key.dd_key_false.key,(_Bool)0);
      #line 1101 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 1101 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug560,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"Failed to read PBA Block pointer.\n");
    }
    #line 1102 
    return status;
  }
  #line 1105 
  status = i40e_read_nvm_word(hw,(unsigned short)((int)pba_ptr),& pba_size);
  #line 1106 
  if (status != I40E_SUCCESS) {
    {
      #line 1107 
      bool branch_1;
      #line 1107 
      struct _ddebug __UNIQUE_ID_ddebug561 = {.modname = (char *)"i40e", .function = (char *)"i40e_read_pba_string", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"Failed to read PBA Block size.\n", .lineno = (unsigned int)1107U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1107 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug561.key.dd_key_false.key,(_Bool)0);
      #line 1107 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 1107 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug561,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"Failed to read PBA Block size.\n");
    }
    #line 1108 
    return status;
  }
  #line 1114 
  pba_size = (u16)((int)pba_size - 1);
  #line 1115 
  if ((unsigned int)pba_size * 2U + 1U > pba_num_size) {
    {
      #line 1116 
      bool branch_2;
      #line 1116 
      struct _ddebug __UNIQUE_ID_ddebug562 = {.modname = (char *)"i40e", .function = (char *)"i40e_read_pba_string", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"Buffer too small for PBA data.\n", .lineno = (unsigned int)1116U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1116 
      branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug562.key.dd_key_false.key,(_Bool)0);
      #line 1116 
      if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                    #line 1116 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug562,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"Buffer too small for PBA data.\n");
    }
    #line 1117 
    return I40E_ERR_PARAM;
  }
  #line 1120 
  i = (unsigned short)0U;
  #line 1120 
  while ((int)i < (int)pba_size) {
    #line 1121 
    status = i40e_read_nvm_word(hw,(unsigned short)((int)((unsigned int)((int)pba_ptr + (int)i) + 1U)),& pba_word);
    #line 1122 
    if (status != I40E_SUCCESS) {
      {
        #line 1123 
        bool branch_3;
        #line 1123 
        struct _ddebug __UNIQUE_ID_ddebug563 = {.modname = (char *)"i40e", .function = (char *)"i40e_read_pba_string", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"Failed to read PBA Block word %d.\n", .lineno = (unsigned int)1123U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1123 
        branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug563.key.dd_key_false.key,(_Bool)0);
        #line 1123 
        if ((long)((long)((int)branch_3 != 0)) != 0L) 
                                                      #line 1123 
                                                      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug563,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"Failed to read PBA Block word %d.\n",(int)i);
      }
      #line 1124 
      return status;
    }
    #line 1127 
    *(pba_num + (unsigned long)((int)i * 2)) = (unsigned char)((int)pba_word >> 8);
    #line 1128 
    *(pba_num + ((unsigned long)((int)i * 2) + (unsigned long)1U)) = (unsigned char)pba_word;
    #line 1120 
    i = (u16)((int)i + 1);
  }
  #line 1130 
  *(pba_num + (unsigned long)((int)pba_size * 2)) = (unsigned char)0U;
  #line 1132 
  return status;
}

#line 1139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static enum i40e_media_type i40e_get_media_type(struct i40e_hw *hw)
{
  #line 1141 
  enum i40e_media_type media;
  #line 1143 
  switch ((unsigned int)hw->phy.link_info.phy_type) {
    #line 1144 
    case (unsigned int)20: 
                           #line 1144 
    ;
    #line 1145 
    case (unsigned int)21: 
                           #line 1145 
    ;
    #line 1146 
    case (unsigned int)27: 
                           #line 1146 
    ;
    #line 1147 
    case (unsigned int)28: 
                           #line 1147 
    ;
    #line 1148 
    case (unsigned int)25: 
                           #line 1148 
    ;
    #line 1149 
    case (unsigned int)26: 
                           #line 1149 
    ;
    #line 1150 
    case (unsigned int)34: 
                           #line 1150 
    ;
    #line 1151 
    case (unsigned int)33: 
                           #line 1151 
    ;
    #line 1152 
    media = I40E_MEDIA_TYPE_FIBER;
    #line 1153 
    break;
    #line 1154 
    case (unsigned int)17: 
                           #line 1154 
    ;
    #line 1155 
    case (unsigned int)18: 
                           #line 1155 
    ;
    #line 1156 
    case (unsigned int)48: 
                           #line 1156 
    ;
    #line 1157 
    case (unsigned int)49: 
                           #line 1157 
    ;
    #line 1158 
    case (unsigned int)19: 
                           #line 1158 
    ;
    #line 1159 
    media = I40E_MEDIA_TYPE_BASET;
    #line 1160 
    break;
    #line 1161 
    case (unsigned int)11: 
                           #line 1161 
    ;
    #line 1162 
    case (unsigned int)10: 
                           #line 1162 
    ;
    #line 1163 
    case (unsigned int)23: 
                           #line 1163 
    ;
    #line 1164 
    case (unsigned int)24: 
                           #line 1164 
    ;
    #line 1165 
    case (unsigned int)22: 
                           #line 1165 
    ;
    #line 1166 
    case (unsigned int)13: 
                           #line 1166 
    ;
    #line 1167 
    case (unsigned int)12: 
                           #line 1167 
    ;
    #line 1168 
    case (unsigned int)32: 
                           #line 1168 
    ;
    #line 1169 
    case (unsigned int)35: 
                           #line 1169 
    ;
    #line 1170 
    case (unsigned int)36: 
                           #line 1170 
    ;
    #line 1171 
    media = I40E_MEDIA_TYPE_DA;
    #line 1172 
    break;
    #line 1173 
    case (unsigned int)1: 
                          #line 1173 
    ;
    #line 1174 
    case (unsigned int)2: 
                          #line 1174 
    ;
    #line 1175 
    case (unsigned int)3: 
                          #line 1175 
    ;
    #line 1176 
    case (unsigned int)4: 
                          #line 1176 
    ;
    #line 1177 
    case (unsigned int)30: 
                           #line 1177 
    ;
    #line 1178 
    case (unsigned int)31: 
                           #line 1178 
    ;
    #line 1179 
    media = I40E_MEDIA_TYPE_BACKPLANE;
    #line 1180 
    break;
    #line 1181 
    case (unsigned int)0: 
                          #line 1181 
    ;
    #line 1182 
    case (unsigned int)5: 
                          #line 1182 
    ;
    #line 1183 
    case (unsigned int)6: 
                          #line 1183 
    ;
    #line 1184 
    case (unsigned int)8: 
                          #line 1184 
    ;
    #line 1185 
    case (unsigned int)9: 
                          #line 1185 
    ;
    #line 1186 
    default: 
             #line 1186 
    ;
    #line 1187 
    media = I40E_MEDIA_TYPE_UNKNOWN;
    #line 1188 
    break;
  }
  #line 1191 
  return media;
}

#line 1199  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static i40e_status i40e_poll_globr(struct i40e_hw *hw, u32 retry_limit)
{
  #line 1202 
  u32 cnt;
  #line 1202 
  u32 reg = 0U;
  #line 1204 
  cnt = 0U;
  #line 1204 
  while (cnt < retry_limit) {
    #line 1205 
    reg = readl((void *)(hw->hw_addr + 754056U));
    #line 1206 
    if ((reg & 3U) == 0U) 
                          #line 1207 
                          return I40E_SUCCESS;
    #line 1208 
    msleep(100U);
    #line 1204 
    cnt ++;
  }
  {
    #line 1211 
    bool branch;
    #line 1211 
    struct _ddebug __UNIQUE_ID_ddebug564 = {.modname = (char *)"i40e", .function = (char *)"i40e_poll_globr", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"Global reset failed.\n", .lineno = (unsigned int)1211U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 1211 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug564.key.dd_key_false.key,(_Bool)0);
    #line 1211 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 1211 
                                                __dynamic_dev_dbg(& __UNIQUE_ID_ddebug564,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"Global reset failed.\n");
  }
  {
    #line 1212 
    bool branch_0;
    #line 1212 
    struct _ddebug __UNIQUE_ID_ddebug565 = {.modname = (char *)"i40e", .function = (char *)"i40e_poll_globr", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"I40E_GLGEN_RSTAT = 0x%x\n", .lineno = (unsigned int)1212U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 1212 
    branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug565.key.dd_key_false.key,(_Bool)0);
    #line 1212 
    if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                  #line 1212 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug565,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"I40E_GLGEN_RSTAT = 0x%x\n",reg);
  }
  #line 1214 
  return I40E_ERR_RESET_FAILED;
}

#line 1226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_pf_reset(struct i40e_hw *hw)
{
  #line 1231 
  u32 grst_del;
  #line 1228 
  u32 cnt = 0U;
  #line 1229 
  u32 cnt1 = 0U;
  #line 1230 
  u32 reg = 0U;
  #line 1237 
  grst_del = readl((void *)(hw->hw_addr + 754048U)) & 63U;
  #line 1244 
  grst_del *= 20U;
  #line 1246 
  cnt = 0U;
  #line 1246 
  while (cnt < grst_del) {
    #line 1247 
    reg = readl((void *)(hw->hw_addr + 754056U));
    #line 1248 
    if ((reg & 3U) == 0U) 
                          #line 1249 
                          break;
    #line 1250 
    msleep(100U);
    #line 1246 
    cnt ++;
  }
  #line 1252 
  if ((reg & 3U) != 0U) {
    {
      #line 1253 
      bool branch;
      #line 1253 
      struct _ddebug __UNIQUE_ID_ddebug566 = {.modname = (char *)"i40e", .function = (char *)"i40e_pf_reset", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"Global reset polling failed to complete.\n", .lineno = (unsigned int)1253U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1253 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug566.key.dd_key_false.key,(_Bool)0);
      #line 1253 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1253 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug566,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"Global reset polling failed to complete.\n");
    }
    #line 1254 
    return I40E_ERR_RESET_FAILED;
  }
  #line 1258 
  cnt1 = 0U;
  #line 1258 
  while (cnt1 <= 199U) {
    #line 1259 
    reg = readl((void *)(hw->hw_addr + 745480U));
    #line 1260 
    reg &= 24U;
    #line 1262 
    if (reg == 24U) {
      {
        #line 1264 
        bool branch_0;
        #line 1264 
        struct _ddebug __UNIQUE_ID_ddebug567 = {.modname = (char *)"i40e", .function = (char *)"i40e_pf_reset", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"Core and Global modules ready %d\n", .lineno = (unsigned int)1264U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 1264 
        branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug567.key.dd_key_false.key,(_Bool)0);
        #line 1264 
        if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                      #line 1264 
                                                      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug567,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"Core and Global modules ready %d\n",cnt1);
      }
      #line 1265 
      break;
    }
    #line 1267 
    usleep_range(10000UL,20000UL);
    #line 1258 
    cnt1 ++;
  }
  #line 1269 
  if ((reg & 24U) == 0U) {
    {
      #line 1271 
      bool branch_1;
      #line 1271 
      struct _ddebug __UNIQUE_ID_ddebug568 = {.modname = (char *)"i40e", .function = (char *)"i40e_pf_reset", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"wait for FW Reset complete timedout\n", .lineno = (unsigned int)1271U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1271 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug568.key.dd_key_false.key,(_Bool)0);
      #line 1271 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 1271 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug568,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"wait for FW Reset complete timedout\n");
    }
    {
      #line 1272 
      bool branch_2;
      #line 1272 
      struct _ddebug __UNIQUE_ID_ddebug569 = {.modname = (char *)"i40e", .function = (char *)"i40e_pf_reset", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"I40E_GLNVM_ULD = 0x%x\n", .lineno = (unsigned int)1272U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1272 
      branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug569.key.dd_key_false.key,(_Bool)0);
      #line 1272 
      if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                    #line 1272 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug569,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"I40E_GLNVM_ULD = 0x%x\n",reg);
    }
    #line 1273 
    return I40E_ERR_RESET_FAILED;
  }
  #line 1279 
  if (cnt == 0U) {
    #line 1280 
    u32 reg2 = 0U;
    #line 1281 
    if ((unsigned int)hw->revision_id == 0U) 
                                             #line 1282 
                                             cnt = 200U; else 
                                                              #line 1284 
                                                              cnt = 200U;
    #line 1285 
    reg = readl((void *)(hw->hw_addr + 599040U));
    #line 1286 
    writel(reg | 1U,(void *)(hw->hw_addr + 599040U));
    #line 1288 
    while (cnt != 0U) {
      #line 1289 
      reg = readl((void *)(hw->hw_addr + 599040U));
      #line 1290 
      if ((reg & 1U) == 0U) 
                            #line 1291 
                            break;
      #line 1292 
      reg2 = readl((void *)(hw->hw_addr + 754056U));
      #line 1293 
      if ((reg2 & 3U) != 0U) 
                             #line 1294 
                             break;
      #line 1295 
      usleep_range(1000UL,2000UL);
      #line 1288 
      cnt --;
    }
    #line 1297 
    if ((reg2 & 3U) != 0U) {
      #line 1298 
      if (i40e_poll_globr(hw,grst_del) != I40E_SUCCESS) 
                                                        #line 1299 
                                                        return I40E_ERR_RESET_FAILED;
    }
    else 
      #line 1300 
      if ((reg & 1U) != 0U) {
        {
          #line 1301 
          bool branch_3;
          #line 1301 
          struct _ddebug __UNIQUE_ID_ddebug570 = {.modname = (char *)"i40e", .function = (char *)"i40e_pf_reset", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"PF reset polling failed to complete.\n", .lineno = (unsigned int)1301U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 1301 
          branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug570.key.dd_key_false.key,(_Bool)0);
          #line 1301 
          if ((long)((long)((int)branch_3 != 0)) != 0L) 
                                                        #line 1301 
                                                        __dynamic_dev_dbg(& __UNIQUE_ID_ddebug570,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"PF reset polling failed to complete.\n");
        }
        #line 1302 
        return I40E_ERR_RESET_FAILED;
      }
  }
  #line 1306 
  i40e_clear_pxe_mode(hw);
  #line 1308 
  return I40E_SUCCESS;
}

#line 1319  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_clear_hw(struct i40e_hw *hw)
{
  #line 1321 
  u32 num_queues;
  #line 1321 
  u32 base_queue;
  #line 1322 
  u32 num_pf_int;
  #line 1323 
  u32 num_vf_int;
  #line 1324 
  u32 num_vfs;
  #line 1325 
  u32 i;
  #line 1325 
  u32 j;
  #line 1326 
  u32 val;
  #line 1327 
  u32 eol = 2047U;
  #line 1330 
  val = readl((void *)(hw->hw_addr + 779412U));
  #line 1331 
  num_pf_int = (val >> 2) & 2047U;
  #line 1333 
  num_vf_int = (val >> 13) & 2047U;
  #line 1336 
  val = readl((void *)(hw->hw_addr + 1836032U));
  #line 1337 
  base_queue = val & 2047U;
  #line 1339 
  j = (val >> 16) & 2047U;
  #line 1341 
  if ((val & 2147483648U) != 0U) 
                                 #line 1342 
                                 num_queues = (j - base_queue) + 1U; else 
                                                                    #line 1344 
                                                                    num_queues = 0U;
  #line 1346 
  val = readl((void *)(hw->hw_addr + 1836288U));
  #line 1347 
  i = val & 255U;
  #line 1349 
  j = (val >> 8) & 255U;
  #line 1351 
  if ((val & 2147483648U) != 0U) 
                                 #line 1352 
                                 num_vfs = (j - i) + 1U; else 
                                                              #line 1354 
                                                              num_vfs = 0U;
  #line 1357 
  writel(0U,(void *)(hw->hw_addr + 231424U));
  #line 1358 
  val = 24U;
  #line 1359 
  i = 0U;
  #line 1359 
  while (num_pf_int + 4294967294U > i) {
    #line 1360 
    writel(val,(void *)(hw->hw_addr + (unsigned long)((i + 53760U) * 4U)));
    #line 1359 
    i ++;
  }
  #line 1363 
  val = eol;
  #line 1364 
  writel(val,(void *)(hw->hw_addr + 230656U));
  #line 1365 
  i = 0U;
  #line 1365 
  while (num_pf_int + 4294967294U > i) {
    #line 1366 
    writel(val,(void *)(hw->hw_addr + (unsigned long)((i + 54272U) * 4U)));
    #line 1365 
    i ++;
  }
  #line 1367 
  val = eol;
  #line 1368 
  i = 0U;
  #line 1368 
  while (i < num_vfs) {
    #line 1369 
    writel(val,(void *)(hw->hw_addr + (unsigned long)((i + 43520U) * 4U)));
    #line 1368 
    i ++;
  }
  #line 1370 
  i = 0U;
  #line 1370 
  while (num_vf_int + 4294967294U > i) {
    #line 1371 
    writel(val,(void *)(hw->hw_addr + (unsigned long)((i + 37888U) * 4U)));
    #line 1370 
    i ++;
  }
  #line 1374 
  i = 0U;
  #line 1374 
  while (i < num_queues) {
    {
      #line 1375 
      u32 abs_queue_idx = base_queue + i;
      #line 1376 
      u32 reg_block = 0U;
      #line 1378 
      if (abs_queue_idx > 127U) {
        #line 1379 
        reg_block = abs_queue_idx / 128U;
        #line 1380 
        abs_queue_idx &= 127U;
      }
      #line 1383 
      val = readl((void *)(hw->hw_addr + (unsigned long)((reg_block + 235840U) * 4U)));
      #line 1384 
      val &= 4294965248U;
      #line 1385 
      val |= abs_queue_idx;
      #line 1386 
      val |= 1073741824U;
      #line 1388 
      writel(val,(void *)(hw->hw_addr + (unsigned long)((reg_block + 235840U) * 4U)));
    }
    #line 1374 
    i ++;
  }
  #line 1390 
  __const_udelay(1718000UL);
  #line 1393 
  i = 0U;
  #line 1393 
  while (i < num_queues) {
    #line 1394 
    writel(0U,(void *)(hw->hw_addr + (unsigned long)((i + 61440U) * 4U)));
    #line 1395 
    writel(0U,(void *)(hw->hw_addr + (unsigned long)((i + 262144U) * 4U)));
    #line 1396 
    writel(0U,(void *)(hw->hw_addr + (unsigned long)((i + 59392U) * 4U)));
    #line 1397 
    writel(0U,(void *)(hw->hw_addr + (unsigned long)((i + 294912U) * 4U)));
    #line 1393 
    i ++;
  }
  #line 1401 
  __const_udelay(214750UL);
  #line 1403 
  return;
}

#line 1411  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_clear_pxe_mode(struct i40e_hw *hw)
{
  #line 1413 
  u32 reg;
  #line 1415 
  if ((int)i40e_check_asq_alive(hw) != 0) 
                                          #line 1416 
                                          i40e_aq_clear_pxe_mode(hw,(struct i40e_asq_cmd_details *)0);
  #line 1419 
  reg = readl((void *)(hw->hw_addr + 1221888U));
  #line 1421 
  if ((unsigned int)hw->revision_id == 0U) 
                                           #line 1423 
                                           writel(reg & 4294967294U,(void *)(hw->hw_addr + 1221888U)); else 
                                                                    #line 1425 
                                                                    writel(reg | 1U,(void *)(hw->hw_addr + 1221888U));
  #line 1426 
  return;
}

#line 1436  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static u32 i40e_led_is_mine(struct i40e_hw *hw, int idx)
{
  #line 1439 
  u32 port;
  #line 1438 
  u32 gpio_val = 0U;
  #line 1441 
  if ((unsigned int)hw->device_id != 5631U && ! hw->func_caps.led[idx]) 
    #line 1443 
    return 0U;
  #line 1444 
  gpio_val = readl((void *)(hw->hw_addr + (unsigned long)((idx + 139328) * 4)));
  #line 1445 
  port = gpio_val & 3U;
  #line 1451 
  if ((gpio_val & 8U) != 0U || (unsigned int)hw->port != port) 
                                                               #line 1453 
                                                               return 0U;
  #line 1455 
  return gpio_val;
}

#line 1480  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
u32 i40e_led_get(struct i40e_hw *hw)
{
  #line 1483 
  int i;
  #line 1482 
  u32 mode = 0U;
  #line 1488 
  i = 22;
  #line 1488 
  while (i <= 29) {
    {
      #line 1489 
      u32 gpio_val = i40e_led_is_mine(hw,i);
      #line 1491 
      if (gpio_val == 0U) 
                          #line 1492 
                          goto __Cont;
      #line 1494 
      mode = (gpio_val >> 12) & 31U;
      #line 1496 
      break;
    }
    #line 1488 
    __Cont: 
            #line 1488 
    i ++;
  }
  #line 1499 
  return mode;
}

#line 1511  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_led_set(struct i40e_hw *hw, u32 mode, bool blink)
{
  #line 1513 
  int i;
  #line 1515 
  if ((mode & 4294967264U) != 0U) {
    {
      #line 1516 
      bool branch;
      #line 1516 
      struct _ddebug __UNIQUE_ID_ddebug571 = {.modname = (char *)"i40e", .function = (char *)"i40e_led_set", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"invalid mode passed in %X\n", .lineno = (unsigned int)1516U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1516 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug571.key.dd_key_false.key,(_Bool)0);
      #line 1516 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 1516 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug571,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"invalid mode passed in %X\n",mode);
    }
    #line 1517 
    return;
  }
  #line 1523 
  i = 22;
  #line 1523 
  while (i <= 29) {
    {
      #line 1524 
      u32 gpio_val = i40e_led_is_mine(hw,i);
      #line 1526 
      if (gpio_val == 0U) 
                          #line 1527 
                          goto __Cont;
      #line 1529 
      if ((unsigned int)hw->device_id == 5631U) {
        #line 1530 
        u32 pin_func = 0U;
        #line 1532 
        if (((unsigned long)mode & 16UL) != 0UL) 
                                                 #line 1533 
                                                 pin_func = 0U; else 
                                                                  #line 1535 
                                                                  pin_func = 1U;
        #line 1537 
        gpio_val &= 4294966399U;
        #line 1538 
        gpio_val = ((pin_func << 7) & 896U) | gpio_val;
      }
      #line 1542 
      gpio_val &= 4294840319U;
      #line 1544 
      gpio_val = ((mode << 12) & 126976U) | gpio_val;
      #line 1547 
      if ((int)blink != 0) 
                           #line 1548 
                           gpio_val |= 2048U; else 
                                                   #line 1550 
                                                   gpio_val &= 4294965247U;
      #line 1552 
      writel(gpio_val,(void *)(hw->hw_addr + (unsigned long)((i + 139328) * 4)));
      #line 1553 
      break;
    }
    #line 1523 
    __Cont: 
            #line 1523 
    i ++;
  }
  #line 1555 
  return;
}

#line 1569  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_get_phy_capabilities(struct i40e_hw *hw, bool qualified_modules, bool report_init, struct i40e_aq_get_phy_abilities_resp *abilities, struct i40e_asq_cmd_details *cmd_details)
{
  #line 1574 
  struct i40e_aq_desc desc;
  #line 1575 
  i40e_status status;
  #line 1576 
  u16 abilities_size = (unsigned short)536U;
  #line 1577 
  u16 max_delay = (unsigned short)500U;
  #line 1577 
  u16 total_delay = (unsigned short)0U;
  #line 1579 
  if (abilities == (struct i40e_aq_get_phy_abilities_resp *)0) 
                                                               #line 1580 
                                                               return I40E_ERR_PARAM;
  #line 1582 
  while (1) {
    #line 1583 
    i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1536);
    #line 1586 
    desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
    #line 1587 
    if ((unsigned int)abilities_size > 512U) 
                                             #line 1588 
                                             desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
    #line 1590 
    if ((int)qualified_modules != 0) 
                                     #line 1591 
                                     desc.params.external.param0 |= 1U;
    #line 1594 
    if ((int)report_init != 0) 
                               #line 1595 
                               desc.params.external.param0 |= 2U;
    #line 1598 
    status = i40e_asq_send_command(hw,& desc,(void *)abilities,(unsigned short)((int)abilities_size),cmd_details);
    #line 1601 
    switch ((unsigned int)hw->aq.asq_last_status) {
      #line 1602 
      case (unsigned int)5: 
                            #line 1602 
      ;
      #line 1603 
      status = I40E_ERR_UNKNOWN_PHY;
      #line 1604 
      break;
      #line 1605 
      case (unsigned int)8: 
                            #line 1605 
      ;
      #line 1606 
      usleep_range(1000UL,2000UL);
      #line 1607 
      total_delay = (u16)((int)total_delay + 1);
      #line 1608 
      status = I40E_ERR_TIMEOUT;
      #line 1609 
      break;
      #line 1611 
      default: 
               #line 1611 
      ;
      #line 1612 
      break;
    }
    #line 1614 
    if (! (hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_EAGAIN && (int)total_delay < (int)max_delay)) 
      #line 1582 
      break;
  }
  #line 1618 
  if (status != I40E_SUCCESS) 
                              #line 1619 
                              return status;
  #line 1621 
  if ((int)report_init != 0) 
    #line 1622 
    if ((hw->mac.type == (unsigned int)I40E_MAC_XL710 && (unsigned int)hw->aq.api_maj_ver == 1U) && (unsigned int)hw->aq.api_min_ver > 6U) 
      #line 1625 
      status = i40e_aq_get_link_info(hw,(_Bool)1,(struct i40e_link_status *)0,(struct i40e_asq_cmd_details *)0);
    else {
      #line 1627 
      hw->phy.phy_types = (unsigned long long)abilities->phy_type;
      #line 1628 
      hw->phy.phy_types |= (unsigned long long)abilities->phy_type_ext << 32;
    }
  #line 1633 
  return status;
}

#line 1648  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_set_phy_config(struct i40e_hw *hw, struct i40e_aq_set_phy_config *config, struct i40e_asq_cmd_details *cmd_details)
{
  #line 1652 
  struct i40e_aq_desc desc;
  #line 1655 
  enum i40e_status_code status;
  #line 1653 
  struct i40e_aq_set_phy_config *cmd = (struct i40e_aq_set_phy_config *)(& desc.params.raw);
  #line 1657 
  if (config == (struct i40e_aq_set_phy_config *)0) 
                                                    #line 1658 
                                                    return I40E_ERR_PARAM;
  #line 1660 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1537);
  #line 1663 
  *cmd = *config;
  #line 1665 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 1667 
  return status;
}

#line 1671  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static enum i40e_status_code i40e_set_fc_status(struct i40e_hw *hw, struct i40e_aq_get_phy_abilities_resp *abilities, bool atomic_restart)
{
  #line 1675 
  struct i40e_aq_set_phy_config config;
  #line 1676 
  enum i40e_fc_mode fc_mode = hw->fc.requested_mode;
  #line 1677 
  u8 pause_mask = (unsigned char)0U;
  #line 1679 
  switch ((unsigned int)fc_mode) {
    #line 1680 
    case (unsigned int)3: 
                          #line 1680 
    ;
    #line 1681 
    pause_mask = (unsigned char)((unsigned int)pause_mask | 1U);
    #line 1682 
    pause_mask = (unsigned char)((unsigned int)pause_mask | 2U);
    #line 1683 
    break;
    #line 1684 
    case (unsigned int)1: 
                          #line 1684 
    ;
    #line 1685 
    pause_mask = (unsigned char)((unsigned int)pause_mask | 2U);
    #line 1686 
    break;
    #line 1687 
    case (unsigned int)2: 
                          #line 1687 
    ;
    #line 1688 
    pause_mask = (unsigned char)((unsigned int)pause_mask | 1U);
    #line 1689 
    break;
    #line 1690 
    default: 
             #line 1690 
    ;
    #line 1691 
    break;
  }
  #line 1694 
  memset((void *)(& config),0,16UL);
  #line 1696 
  config.abilities = (unsigned char)((unsigned int)abilities->abilities & 252U);
  #line 1699 
  config.abilities = (unsigned char)((int)config.abilities | (int)pause_mask);
  #line 1701 
  if ((int)config.abilities == (int)abilities->abilities) 
                                                          #line 1702 
                                                          return I40E_SUCCESS;
  #line 1705 
  if ((int)atomic_restart != 0) 
                                #line 1706 
                                config.abilities = (unsigned char)((unsigned int)config.abilities | 32U);
  #line 1708 
  config.phy_type = abilities->phy_type;
  #line 1709 
  config.phy_type_ext = abilities->phy_type_ext;
  #line 1710 
  config.link_speed = abilities->link_speed;
  #line 1711 
  config.eee_capability = abilities->eee_capability;
  #line 1712 
  config.eeer = abilities->eeer_val;
  #line 1713 
  config.low_power_ctrl = abilities->d3_lpan;
  #line 1714 
  config.fec_config = (unsigned char)((unsigned int)abilities->fec_cfg_curr_mod_ext_info & 31U);
  #line 1717 
  return i40e_aq_set_phy_config(hw,& config,(struct i40e_asq_cmd_details *)0);
}

#line 1728  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_set_fc(struct i40e_hw *hw, u8 *aq_failures, bool atomic_restart)
{
  #line 1731 
  struct i40e_aq_get_phy_abilities_resp abilities;
  #line 1732 
  enum i40e_status_code status;
  #line 1734 
  *aq_failures = (unsigned char)0U;
  #line 1737 
  status = i40e_aq_get_phy_capabilities(hw,(_Bool)0,(_Bool)0,& abilities,(struct i40e_asq_cmd_details *)0);
  #line 1739 
  if (status != I40E_SUCCESS) {
    #line 1740 
    *aq_failures = (unsigned char)((unsigned int)*aq_failures | 1U);
    #line 1741 
    return status;
  }
  #line 1744 
  status = i40e_set_fc_status(hw,& abilities,(_Bool)((bool)((int)atomic_restart) != 0));
  #line 1745 
  if (status != I40E_SUCCESS) 
                              #line 1746 
                              *aq_failures = (unsigned char)((unsigned int)*aq_failures | 2U);
  #line 1749 
  status = i40e_update_link_info(hw);
  #line 1750 
  if (status != I40E_SUCCESS) {
    #line 1755 
    msleep(1000U);
    #line 1756 
    status = i40e_update_link_info(hw);
  }
  #line 1758 
  if (status != I40E_SUCCESS) 
                              #line 1759 
                              *aq_failures = (unsigned char)((unsigned int)*aq_failures | 4U);
  #line 1761 
  return status;
}

#line 1771  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_clear_pxe_mode(struct i40e_hw *hw, struct i40e_asq_cmd_details *cmd_details)
{
  #line 1774 
  i40e_status status;
  #line 1775 
  struct i40e_aq_desc desc;
  #line 1776 
  struct i40e_aqc_clear_pxe *cmd = (struct i40e_aqc_clear_pxe *)(& desc.params.raw);
  #line 1779 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)272);
  #line 1782 
  cmd->rx_cnt = (unsigned char)2U;
  #line 1784 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 1786 
  writel(1U,(void *)(hw->hw_addr + 1221888U));
  #line 1788 
  return status;
}

#line 1799  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_link_restart_an(struct i40e_hw *hw, bool enable_link, struct i40e_asq_cmd_details *cmd_details)
{
  #line 1803 
  struct i40e_aq_desc desc;
  #line 1806 
  i40e_status status;
  #line 1804 
  struct i40e_aqc_set_link_restart_an *cmd = (struct i40e_aqc_set_link_restart_an *)(& desc.params.raw);
  #line 1808 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1541);
  #line 1811 
  cmd->command = (unsigned char)2U;
  #line 1812 
  if ((int)enable_link != 0) 
                             #line 1813 
                             cmd->command = (unsigned char)((unsigned int)cmd->command | 4U); else 
                                                                    #line 1815 
                                                                    cmd->command = (unsigned char)((unsigned int)cmd->command & 251U);
  #line 1817 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 1819 
  return status;
}

#line 1831  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_link_info(struct i40e_hw *hw, bool enable_lse, struct i40e_link_status *link, struct i40e_asq_cmd_details *cmd_details)
{
  #line 1835 
  struct i40e_aq_desc desc;
  #line 1839 
  i40e_status status;
  #line 1840 
  bool tx_pause;
  #line 1840 
  bool rx_pause;
  #line 1841 
  u16 command_flags;
  #line 1836 
  struct i40e_aqc_get_link_status *resp = (struct i40e_aqc_get_link_status *)(& desc.params.raw);
  #line 1838 
  struct i40e_link_status *hw_link_info = & hw->phy.link_info;
  #line 1843 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1543);
  #line 1845 
  if ((int)enable_lse != 0) 
                            #line 1846 
                            command_flags = (unsigned short)3U; else 
                                                                  #line 1848 
                                                                  command_flags = (unsigned short)2U;
  #line 1849 
  resp->command_flags = command_flags;
  #line 1851 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 1853 
  if (status != I40E_SUCCESS) 
                              #line 1854 
                              goto aq_get_link_info_exit;
  #line 1857 
  hw->phy.link_info_old = *hw_link_info;
  #line 1860 
  hw_link_info->phy_type = (enum i40e_aq_phy_type)resp->phy_type;
  #line 1861 
  hw->phy.media_type = i40e_get_media_type(hw);
  #line 1862 
  hw_link_info->link_speed = (enum i40e_aq_link_speed)resp->link_speed;
  #line 1863 
  hw_link_info->link_info = resp->link_info;
  #line 1864 
  hw_link_info->an_info = resp->an_info;
  #line 1865 
  hw_link_info->fec_info = (unsigned char)((unsigned int)resp->config & 3U);
  #line 1867 
  hw_link_info->ext_info = resp->ext_info;
  #line 1868 
  hw_link_info->loopback = (unsigned char)((unsigned int)resp->loopback & 7U);
  #line 1869 
  hw_link_info->max_frame_size = resp->max_frame_size;
  #line 1870 
  hw_link_info->pacing = (unsigned char)((unsigned int)resp->config & 120U);
  #line 1873 
  tx_pause = (_Bool)(((int)resp->an_info & 32) != 0);
  #line 1874 
  rx_pause = (_Bool)(((int)resp->an_info & 64) != 0);
  #line 1875 
  if (((int)tx_pause & (int)rx_pause) != 0) 
                                            #line 1876 
                                            hw->fc.current_mode = I40E_FC_FULL;
  else 
    #line 1877 
    if ((int)tx_pause != 0) 
                            #line 1878 
                            hw->fc.current_mode = I40E_FC_TX_PAUSE;
    else 
      #line 1879 
      if ((int)rx_pause != 0) 
                              #line 1880 
                              hw->fc.current_mode = I40E_FC_RX_PAUSE; else 
                                                                    #line 1882 
                                                                    hw->fc.current_mode = I40E_FC_NONE;
  #line 1884 
  if (((int)resp->config & 4) != 0) 
                                    #line 1885 
                                    hw_link_info->crc_enable = (_Bool)1; else 
                                                                    #line 1887 
                                                                    hw_link_info->crc_enable = (_Bool)0;
  #line 1889 
  if (((int)resp->command_flags & 1) != 0) 
                                           #line 1890 
                                           hw_link_info->lse_enable = (_Bool)1; else 
                                                                    #line 1892 
                                                                    hw_link_info->lse_enable = (_Bool)0;
  #line 1894 
  if ((hw->mac.type == (unsigned int)I40E_MAC_XL710 && ((unsigned int)hw->aq.fw_maj_ver <= 3U || (unsigned int)hw->aq.fw_maj_ver == 4U && (unsigned int)hw->aq.fw_min_ver <= 39U)) && hw_link_info->phy_type == (unsigned int)I40E_PHY_TYPE_UNRECOGNIZED) 
    #line 1897 
    hw_link_info->phy_type = I40E_PHY_TYPE_10GBASE_SFPP_CU;
  #line 1899 
  if ((hw->flags & 4ULL) != 0ULL && hw->mac.type != (unsigned int)I40E_MAC_X722) {
    #line 1901 
    __le32 tmp;
    #line 1903 
    memcpy((void *)(& tmp),(void *)(& resp->__anonCompField_i40e_aqc_get_link_status_216.__anonCompField___anonunion_3325_215.link_type),4UL);
    #line 1904 
    hw->phy.phy_types = (unsigned long long)tmp;
    #line 1905 
    hw->phy.phy_types |= (unsigned long long)resp->__anonCompField_i40e_aqc_get_link_status_216.__anonCompField___anonunion_3325_215.link_type_ext << 32;
  }
  #line 1909 
  if (link != (struct i40e_link_status *)0) 
                                            #line 1910 
                                            *link = *hw_link_info;
  #line 1913 
  hw->phy.get_link_info = (_Bool)0;
  #line 1915 
  aq_get_link_info_exit: 
                         #line 1915 
  ;
  #line 1916 
  return status;
}

#line 1927  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_phy_int_mask(struct i40e_hw *hw, u16 mask, struct i40e_asq_cmd_details *cmd_details)
{
  #line 1931 
  struct i40e_aq_desc desc;
  #line 1934 
  i40e_status status;
  #line 1932 
  struct i40e_aqc_set_phy_int_mask *cmd = (struct i40e_aqc_set_phy_int_mask *)(& desc.params.raw);
  #line 1936 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1555);
  #line 1939 
  cmd->event_mask = mask;
  #line 1941 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 1943 
  return status;
}

#line 1954  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_phy_debug(struct i40e_hw *hw, u8 cmd_flags, struct i40e_asq_cmd_details *cmd_details)
{
  #line 1957 
  struct i40e_aq_desc desc;
  #line 1960 
  i40e_status status;
  #line 1958 
  struct i40e_aqc_set_phy_debug *cmd = (struct i40e_aqc_set_phy_debug *)(& desc.params.raw);
  #line 1962 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1570);
  #line 1965 
  cmd->command_flags = cmd_flags;
  #line 1967 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 1969 
  return status;
}

#line 1980  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_vsi(struct i40e_hw *hw, struct i40e_vsi_context *vsi_ctx, struct i40e_asq_cmd_details *cmd_details)
{
  #line 1984 
  struct i40e_aq_desc desc;
  #line 1990 
  i40e_status status;
  #line 1985 
  struct i40e_aqc_add_get_update_vsi *cmd = (struct i40e_aqc_add_get_update_vsi *)(& desc.params.raw);
  #line 1987 
  struct i40e_aqc_add_get_update_vsi_completion *resp = (struct i40e_aqc_add_get_update_vsi_completion *)(& desc.params.raw);
  #line 1992 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)528);
  #line 1995 
  cmd->uplink_seid = vsi_ctx->uplink_seid;
  #line 1996 
  cmd->connection_type = vsi_ctx->connection_type;
  #line 1997 
  cmd->vf_id = vsi_ctx->vf_num;
  #line 1998 
  cmd->vsi_flags = vsi_ctx->flags;
  #line 2000 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  #line 2002 
  status = i40e_asq_send_command(hw,& desc,(void *)(& vsi_ctx->info),(unsigned short)128,cmd_details);
  #line 2005 
  if (status != I40E_SUCCESS) 
                              #line 2006 
                              goto aq_add_vsi_exit;
  #line 2008 
  vsi_ctx->seid = resp->seid;
  #line 2009 
  vsi_ctx->vsi_number = resp->vsi_number;
  #line 2010 
  vsi_ctx->vsis_allocated = resp->vsi_used;
  #line 2011 
  vsi_ctx->vsis_unallocated = resp->vsi_free;
  #line 2013 
  aq_add_vsi_exit: 
                   #line 2013 
  ;
  #line 2014 
  return status;
}

#line 2023  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_default_vsi(struct i40e_hw *hw, u16 seid, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2027 
  struct i40e_aq_desc desc;
  #line 2031 
  i40e_status status;
  #line 2028 
  struct i40e_aqc_set_vsi_promiscuous_modes *cmd = (struct i40e_aqc_set_vsi_promiscuous_modes *)(& desc.params.raw);
  #line 2033 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)596);
  #line 2036 
  cmd->promiscuous_flags = (unsigned short)8U;
  #line 2037 
  cmd->valid_flags = (unsigned short)8U;
  #line 2038 
  cmd->seid = seid;
  #line 2040 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 2042 
  return status;
}

#line 2051  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_clear_default_vsi(struct i40e_hw *hw, u16 seid, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2055 
  struct i40e_aq_desc desc;
  #line 2059 
  i40e_status status;
  #line 2056 
  struct i40e_aqc_set_vsi_promiscuous_modes *cmd = (struct i40e_aqc_set_vsi_promiscuous_modes *)(& desc.params.raw);
  #line 2061 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)596);
  #line 2064 
  cmd->promiscuous_flags = (unsigned short)0U;
  #line 2065 
  cmd->valid_flags = (unsigned short)8U;
  #line 2066 
  cmd->seid = seid;
  #line 2068 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 2070 
  return status;
}

#line 2081  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_vsi_unicast_promiscuous(struct i40e_hw *hw, u16 seid, bool set, struct i40e_asq_cmd_details *cmd_details, bool rx_only_promisc)
{
  #line 2086 
  struct i40e_aq_desc desc;
  #line 2089 
  i40e_status status;
  #line 2087 
  struct i40e_aqc_set_vsi_promiscuous_modes *cmd = (struct i40e_aqc_set_vsi_promiscuous_modes *)(& desc.params.raw);
  #line 2090 
  u16 flags = (unsigned short)0U;
  #line 2092 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)596);
  #line 2095 
  if ((int)set != 0) {
    #line 2096 
    flags = (unsigned short)((unsigned int)flags | 1U);
    #line 2097 
    if ((int)rx_only_promisc != 0 && ((unsigned int)hw->aq.api_maj_ver == 1U && (unsigned int)hw->aq.api_min_ver > 4U || (unsigned int)hw->aq.api_maj_ver > 1U)) 
      #line 2100 
      flags = (unsigned short)((unsigned int)flags | 32768U);
  }
  #line 2103 
  cmd->promiscuous_flags = flags;
  #line 2105 
  cmd->valid_flags = (unsigned short)1U;
  #line 2106 
  if ((unsigned int)hw->aq.api_maj_ver != 0U && (unsigned int)hw->aq.api_min_ver > 4U || (unsigned int)hw->aq.api_maj_ver > 1U) 
    #line 2108 
    cmd->valid_flags = (unsigned short)((unsigned int)cmd->valid_flags | 32768U);
  #line 2110 
  cmd->seid = seid;
  #line 2111 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 2113 
  return status;
}

#line 2123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_vsi_multicast_promiscuous(struct i40e_hw *hw, u16 seid, bool set, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2126 
  struct i40e_aq_desc desc;
  #line 2129 
  i40e_status status;
  #line 2127 
  struct i40e_aqc_set_vsi_promiscuous_modes *cmd = (struct i40e_aqc_set_vsi_promiscuous_modes *)(& desc.params.raw);
  #line 2130 
  u16 flags = (unsigned short)0U;
  #line 2132 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)596);
  #line 2135 
  if ((int)set != 0) 
                     #line 2136 
                     flags = (unsigned short)((unsigned int)flags | 2U);
  #line 2138 
  cmd->promiscuous_flags = flags;
  #line 2140 
  cmd->valid_flags = (unsigned short)2U;
  #line 2142 
  cmd->seid = seid;
  #line 2143 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 2145 
  return status;
}

#line 2156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_set_vsi_mc_promisc_on_vlan(struct i40e_hw *hw, u16 seid, bool enable, u16 vid, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2161 
  struct i40e_aq_desc desc;
  #line 2164 
  enum i40e_status_code status;
  #line 2162 
  struct i40e_aqc_set_vsi_promiscuous_modes *cmd = (struct i40e_aqc_set_vsi_promiscuous_modes *)(& desc.params.raw);
  #line 2165 
  u16 flags = (unsigned short)0U;
  #line 2167 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)596);
  #line 2170 
  if ((int)enable != 0) 
                        #line 2171 
                        flags = (unsigned short)((unsigned int)flags | 2U);
  #line 2173 
  cmd->promiscuous_flags = flags;
  #line 2174 
  cmd->valid_flags = (unsigned short)2U;
  #line 2175 
  cmd->seid = seid;
  #line 2176 
  cmd->vlan_tag = (unsigned short)((unsigned int)vid | 32768U);
  #line 2178 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 2180 
  return status;
}

#line 2191  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_set_vsi_uc_promisc_on_vlan(struct i40e_hw *hw, u16 seid, bool enable, u16 vid, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2196 
  struct i40e_aq_desc desc;
  #line 2199 
  enum i40e_status_code status;
  #line 2197 
  struct i40e_aqc_set_vsi_promiscuous_modes *cmd = (struct i40e_aqc_set_vsi_promiscuous_modes *)(& desc.params.raw);
  #line 2200 
  u16 flags = (unsigned short)0U;
  #line 2202 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)596);
  #line 2205 
  if ((int)enable != 0) 
                        #line 2206 
                        flags = (unsigned short)((unsigned int)flags | 1U);
  #line 2208 
  cmd->promiscuous_flags = flags;
  #line 2209 
  cmd->valid_flags = (unsigned short)1U;
  #line 2210 
  cmd->seid = seid;
  #line 2211 
  cmd->vlan_tag = (unsigned short)((unsigned int)vid | 32768U);
  #line 2213 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 2215 
  return status;
}

#line 2226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_vsi_bc_promisc_on_vlan(struct i40e_hw *hw, u16 seid, bool enable, u16 vid, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2230 
  struct i40e_aq_desc desc;
  #line 2233 
  i40e_status status;
  #line 2231 
  struct i40e_aqc_set_vsi_promiscuous_modes *cmd = (struct i40e_aqc_set_vsi_promiscuous_modes *)(& desc.params.raw);
  #line 2234 
  u16 flags = (unsigned short)0U;
  #line 2236 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)596);
  #line 2239 
  if ((int)enable != 0) 
                        #line 2240 
                        flags = (unsigned short)((unsigned int)flags | 4U);
  #line 2242 
  cmd->promiscuous_flags = flags;
  #line 2243 
  cmd->valid_flags = (unsigned short)4U;
  #line 2244 
  cmd->seid = seid;
  #line 2245 
  cmd->vlan_tag = (unsigned short)((unsigned int)vid | 32768U);
  #line 2247 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 2249 
  return status;
}

#line 2261  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_vsi_broadcast(struct i40e_hw *hw, u16 seid, bool set_filter, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2265 
  struct i40e_aq_desc desc;
  #line 2268 
  i40e_status status;
  #line 2266 
  struct i40e_aqc_set_vsi_promiscuous_modes *cmd = (struct i40e_aqc_set_vsi_promiscuous_modes *)(& desc.params.raw);
  #line 2270 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)596);
  #line 2273 
  if ((int)set_filter != 0) 
                            #line 2275 
                            cmd->promiscuous_flags = (unsigned short)((unsigned int)cmd->promiscuous_flags | 4U); else 
                                                                    #line 2278 
                                                                    cmd->promiscuous_flags = (unsigned short)((unsigned int)cmd->promiscuous_flags & 65531U);
  #line 2280 
  cmd->valid_flags = (unsigned short)4U;
  #line 2281 
  cmd->seid = seid;
  #line 2282 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 2284 
  return status;
}

#line 2294  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_vsi_vlan_promisc(struct i40e_hw *hw, u16 seid, bool enable, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2298 
  struct i40e_aq_desc desc;
  #line 2301 
  i40e_status status;
  #line 2299 
  struct i40e_aqc_set_vsi_promiscuous_modes *cmd = (struct i40e_aqc_set_vsi_promiscuous_modes *)(& desc.params.raw);
  #line 2302 
  u16 flags = (unsigned short)0U;
  #line 2304 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)596);
  #line 2306 
  if ((int)enable != 0) 
                        #line 2307 
                        flags = (unsigned short)((unsigned int)flags | 16U);
  #line 2309 
  cmd->promiscuous_flags = flags;
  #line 2310 
  cmd->valid_flags = (unsigned short)16U;
  #line 2311 
  cmd->seid = seid;
  #line 2313 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 2315 
  return status;
}

#line 2324  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_vsi_params(struct i40e_hw *hw, struct i40e_vsi_context *vsi_ctx, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2328 
  struct i40e_aq_desc desc;
  #line 2334 
  i40e_status status;
  #line 2329 
  struct i40e_aqc_add_get_update_vsi *cmd = (struct i40e_aqc_add_get_update_vsi *)(& desc.params.raw);
  #line 2331 
  struct i40e_aqc_add_get_update_vsi_completion *resp = (struct i40e_aqc_add_get_update_vsi_completion *)(& desc.params.raw);
  #line 2336 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)530);
  #line 2339 
  cmd->uplink_seid = vsi_ctx->seid;
  #line 2341 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  #line 2343 
  status = i40e_asq_send_command(hw,& desc,(void *)(& vsi_ctx->info),(unsigned short)128,(struct i40e_asq_cmd_details *)0);
  #line 2346 
  if (status != I40E_SUCCESS) 
                              #line 2347 
                              goto aq_get_vsi_params_exit;
  #line 2349 
  vsi_ctx->seid = resp->seid;
  #line 2350 
  vsi_ctx->vsi_number = resp->vsi_number;
  #line 2351 
  vsi_ctx->vsis_allocated = resp->vsi_used;
  #line 2352 
  vsi_ctx->vsis_unallocated = resp->vsi_free;
  #line 2354 
  aq_get_vsi_params_exit: 
                          #line 2354 
  ;
  #line 2355 
  return status;
}

#line 2366  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_update_vsi_params(struct i40e_hw *hw, struct i40e_vsi_context *vsi_ctx, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2370 
  struct i40e_aq_desc desc;
  #line 2376 
  i40e_status status;
  #line 2371 
  struct i40e_aqc_add_get_update_vsi *cmd = (struct i40e_aqc_add_get_update_vsi *)(& desc.params.raw);
  #line 2373 
  struct i40e_aqc_add_get_update_vsi_completion *resp = (struct i40e_aqc_add_get_update_vsi_completion *)(& desc.params.raw);
  #line 2378 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)529);
  #line 2380 
  cmd->uplink_seid = vsi_ctx->seid;
  #line 2382 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  #line 2384 
  status = i40e_asq_send_command(hw,& desc,(void *)(& vsi_ctx->info),(unsigned short)128,cmd_details);
  #line 2387 
  vsi_ctx->vsis_allocated = resp->vsi_used;
  #line 2388 
  vsi_ctx->vsis_unallocated = resp->vsi_free;
  #line 2390 
  return status;
}

#line 2403  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_switch_config(struct i40e_hw *hw, struct i40e_aqc_get_switch_config_resp *buf, u16 buf_size, u16 *start_seid, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2408 
  struct i40e_aq_desc desc;
  #line 2411 
  i40e_status status;
  #line 2409 
  struct i40e_aqc_switch_seid *scfg = (struct i40e_aqc_switch_seid *)(& desc.params.raw);
  #line 2413 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)512);
  #line 2415 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  #line 2416 
  if ((unsigned int)buf_size > 512U) 
                                     #line 2417 
                                     desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
  #line 2418 
  scfg->seid = *start_seid;
  #line 2420 
  status = i40e_asq_send_command(hw,& desc,(void *)buf,(unsigned short)((int)buf_size),cmd_details);
  #line 2421 
  *start_seid = scfg->seid;
  #line 2423 
  return status;
}

#line 2437  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_set_switch_config(struct i40e_hw *hw, u16 flags, u16 valid_flags, u8 mode, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2442 
  struct i40e_aq_desc desc;
  #line 2445 
  enum i40e_status_code status;
  #line 2443 
  struct i40e_aqc_set_switch_config *scfg = (struct i40e_aqc_set_switch_config *)(& desc.params.raw);
  #line 2447 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)517);
  #line 2449 
  scfg->flags = flags;
  #line 2450 
  scfg->valid_flags = valid_flags;
  #line 2451 
  scfg->mode = mode;
  #line 2452 
  if ((hw->flags & 2ULL) != 0ULL) {
    #line 2453 
    scfg->switch_tag = hw->switch_tag;
    #line 2454 
    scfg->first_tag = hw->first_tag;
    #line 2455 
    scfg->second_tag = hw->second_tag;
  }
  #line 2457 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 2459 
  return status;
}

#line 2474  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_firmware_version(struct i40e_hw *hw, u16 *fw_major_version, u16 *fw_minor_version, u32 *fw_build, u16 *api_major_version, u16 *api_minor_version, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2480 
  struct i40e_aq_desc desc;
  #line 2483 
  i40e_status status;
  #line 2481 
  struct i40e_aqc_get_version *resp = (struct i40e_aqc_get_version *)(& desc.params.raw);
  #line 2485 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1);
  #line 2487 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 2489 
  if (status == I40E_SUCCESS) {
    #line 2490 
    if (fw_major_version != (u16 *)0U) 
                                       #line 2491 
                                       *fw_major_version = resp->fw_major;
    #line 2492 
    if (fw_minor_version != (u16 *)0U) 
                                       #line 2493 
                                       *fw_minor_version = resp->fw_minor;
    #line 2494 
    if (fw_build != (u32 *)0U) 
                               #line 2495 
                               *fw_build = resp->fw_build;
    #line 2496 
    if (api_major_version != (u16 *)0U) 
                                        #line 2497 
                                        *api_major_version = resp->api_major;
    #line 2498 
    if (api_minor_version != (u16 *)0U) 
                                        #line 2499 
                                        *api_minor_version = resp->api_minor;
  }
  #line 2502 
  return status;
}

#line 2513  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_send_driver_version(struct i40e_hw *hw, struct i40e_driver_version *dv, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2517 
  struct i40e_aq_desc desc;
  #line 2520 
  i40e_status status;
  #line 2521 
  u16 len;
  #line 2518 
  struct i40e_aqc_driver_version *cmd = (struct i40e_aqc_driver_version *)(& desc.params.raw);
  #line 2523 
  if (dv == (struct i40e_driver_version *)0) 
                                             #line 2524 
                                             return I40E_ERR_PARAM;
  #line 2526 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2);
  #line 2528 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  #line 2529 
  cmd->driver_major_ver = dv->major_version;
  #line 2530 
  cmd->driver_minor_ver = dv->minor_version;
  #line 2531 
  cmd->driver_build_ver = dv->build_version;
  #line 2532 
  cmd->driver_subbuild_ver = dv->subbuild_version;
  #line 2534 
  len = (unsigned short)0U;
  #line 2535 
  while (((unsigned int)len <= 31U && (int)dv->driver_string[(int)len] >= 0) && (unsigned int)dv->driver_string[(int)len] != 0U) 
    #line 2538 
    len = (u16)((int)len + 1);
  #line 2539 
  status = i40e_asq_send_command(hw,& desc,(void *)(& dv->driver_string),(unsigned short)((int)len),cmd_details);
  #line 2542 
  return status;
}

#line 2555  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_get_link_status(struct i40e_hw *hw, bool *link_up)
{
  #line 2557 
  i40e_status status = 0;
  #line 2559 
  if ((int)hw->phy.get_link_info != 0) {
    #line 2560 
    status = i40e_update_link_info(hw);
    #line 2562 
    if (status != I40E_SUCCESS) 
      #line 2563 
      if ((hw->debug_mask & 16U) != 0U) 
                                        #line 2563 
                                        printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)status);
  }
  #line 2567 
  *link_up = (_Bool)(((int)hw->phy.link_info.link_info & 1) != 0);
  #line 2569 
  return status;
}

#line 2576  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_update_link_info(struct i40e_hw *hw)
{
  #line 2578 
  struct i40e_aq_get_phy_abilities_resp abilities;
  #line 2579 
  i40e_status status = 0;
  #line 2581 
  status = i40e_aq_get_link_info(hw,(_Bool)1,(struct i40e_link_status *)0,(struct i40e_asq_cmd_details *)0);
  #line 2582 
  if (status != I40E_SUCCESS) 
                              #line 2583 
                              return status;
  #line 2586 
  if (((int)hw->phy.link_info.link_info & 64) != 0 && (((int)hw->phy.link_info.link_info & 1) != 0 || ((int)hw->phy.link_info_old.link_info & 1) == 0)) {
    #line 2589 
    status = i40e_aq_get_phy_capabilities(hw,(_Bool)0,(_Bool)0,& abilities,(struct i40e_asq_cmd_details *)0);
    #line 2591 
    if (status != I40E_SUCCESS) 
                                #line 2592 
                                return status;
    #line 2594 
    if (((int)abilities.fec_cfg_curr_mod_ext_info & 16) != 0) 
                                                              #line 2596 
                                                              hw->phy.link_info.req_fec_info = (unsigned char)12U; else 
                                                                    #line 2600 
                                                                    hw->phy.link_info.req_fec_info = (unsigned char)((unsigned int)abilities.fec_cfg_curr_mod_ext_info & 12U);
    #line 2605 
    memcpy((void *)(& hw->phy.link_info.module_type),(void *)(& abilities.module_type),3UL);
  }
  #line 2609 
  return status;
}

#line 2626  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_veb(struct i40e_hw *hw, u16 uplink_seid, u16 downlink_seid, u8 enabled_tc, bool default_port, u16 *veb_seid, bool enable_stats, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2632 
  struct i40e_aq_desc desc;
  #line 2637 
  i40e_status status;
  #line 2633 
  struct i40e_aqc_add_veb *cmd = (struct i40e_aqc_add_veb *)(& desc.params.raw);
  #line 2635 
  struct i40e_aqc_add_veb_completion *resp = (struct i40e_aqc_add_veb_completion *)(& desc.params.raw);
  #line 2638 
  u16 veb_flags = (unsigned short)0U;
  #line 2641 
  if (((unsigned int)uplink_seid != 0U) ^ ((unsigned int)downlink_seid != 0U)) 
    #line 2642 
    return I40E_ERR_PARAM;
  #line 2644 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)560);
  #line 2646 
  cmd->uplink_seid = uplink_seid;
  #line 2647 
  cmd->downlink_seid = downlink_seid;
  #line 2648 
  cmd->enable_tcs = enabled_tc;
  #line 2649 
  if ((unsigned int)uplink_seid == 0U) 
                                       #line 2650 
                                       veb_flags = (unsigned short)((unsigned int)veb_flags | 1U);
  #line 2651 
  if ((int)default_port != 0) 
                              #line 2652 
                              veb_flags = (unsigned short)((unsigned int)veb_flags | 2U); else 
                                                                    #line 2654 
                                                                    veb_flags = (unsigned short)((unsigned int)veb_flags | 4U);
  #line 2657 
  if (! enable_stats) 
                      #line 2658 
                      veb_flags = (unsigned short)((unsigned int)veb_flags | 16U);
  #line 2660 
  cmd->veb_flags = veb_flags;
  #line 2662 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 2664 
  if (status == I40E_SUCCESS && veb_seid != (u16 *)0U) 
                                                       #line 2665 
                                                       *veb_seid = resp->veb_seid;
  #line 2667 
  return status;
}

#line 2684  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_veb_parameters(struct i40e_hw *hw, u16 veb_seid, u16 *switch_id, bool *floating, u16 *statistic_index, u16 *vebs_used, u16 *vebs_free, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2690 
  struct i40e_aq_desc desc;
  #line 2694 
  i40e_status status;
  #line 2691 
  struct i40e_aqc_get_veb_parameters_completion *cmd_resp = (struct i40e_aqc_get_veb_parameters_completion *)(& desc.params.raw);
  #line 2696 
  if ((unsigned int)veb_seid == 0U) 
                                    #line 2697 
                                    return I40E_ERR_PARAM;
  #line 2699 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)562);
  #line 2701 
  cmd_resp->seid = veb_seid;
  #line 2703 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 2704 
  if (status != I40E_SUCCESS) 
                              #line 2705 
                              goto get_veb_exit;
  #line 2707 
  if (switch_id != (u16 *)0U) 
                              #line 2708 
                              *switch_id = cmd_resp->switch_id;
  #line 2709 
  if (statistic_index != (u16 *)0U) 
                                    #line 2710 
                                    *statistic_index = cmd_resp->statistic_index;
  #line 2711 
  if (vebs_used != (u16 *)0U) 
                              #line 2712 
                              *vebs_used = cmd_resp->vebs_used;
  #line 2713 
  if (vebs_free != (u16 *)0U) 
                              #line 2714 
                              *vebs_free = cmd_resp->vebs_free;
  #line 2715 
  if (floating != (bool *)0) {
    #line 2716 
    u16 flags = cmd_resp->veb_flags;
    #line 2718 
    if (((int)flags & 1) != 0) 
                               #line 2719 
                               *floating = (_Bool)1; else 
                                                          #line 2721 
                                                          *floating = (_Bool)0;
  }
  #line 2724 
  get_veb_exit: 
                #line 2724 
  ;
  #line 2725 
  return status;
}

#line 2738  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_macvlan(struct i40e_hw *hw, u16 seid, struct i40e_aqc_add_macvlan_element_data *mv_list, u16 count, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2742 
  struct i40e_aq_desc desc;
  #line 2745 
  i40e_status status;
  #line 2746 
  u16 buf_size;
  #line 2747 
  int i;
  #line 2743 
  struct i40e_aqc_macvlan *cmd = (struct i40e_aqc_macvlan *)(& desc.params.raw);
  #line 2749 
  if (((unsigned int)count == 0U || mv_list == (struct i40e_aqc_add_macvlan_element_data *)0) || hw == (struct i40e_hw *)0) 
    #line 2750 
    return I40E_ERR_PARAM;
  #line 2752 
  buf_size = (unsigned short)((unsigned int)count * 16U);
  #line 2755 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)592);
  #line 2756 
  cmd->num_addresses = count;
  #line 2757 
  cmd->seid[0] = (unsigned short)((unsigned int)seid | 32768U);
  #line 2758 
  cmd->seid[1] = (unsigned short)0U;
  #line 2759 
  cmd->seid[2] = (unsigned short)0U;
  #line 2761 
  i = 0;
  #line 2761 
  while ((int)count > i) {
    #line 2762 
    if ((int)is_multicast_ether_addr((u8 *)(& (mv_list + (unsigned long)i)->mac_addr)) != 0) 
      #line 2763 
      (mv_list + (unsigned long)i)->flags = (unsigned short)((unsigned int)(mv_list + (unsigned long)i)->flags | 16U);
    #line 2761 
    i ++;
  }
  #line 2766 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  #line 2767 
  if ((unsigned int)buf_size > 512U) 
                                     #line 2768 
                                     desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
  #line 2770 
  status = i40e_asq_send_command(hw,& desc,(void *)mv_list,(unsigned short)((int)buf_size),cmd_details);
  #line 2773 
  return status;
}

#line 2786  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_remove_macvlan(struct i40e_hw *hw, u16 seid, struct i40e_aqc_remove_macvlan_element_data *mv_list, u16 count, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2790 
  struct i40e_aq_desc desc;
  #line 2793 
  i40e_status status;
  #line 2794 
  u16 buf_size;
  #line 2791 
  struct i40e_aqc_macvlan *cmd = (struct i40e_aqc_macvlan *)(& desc.params.raw);
  #line 2796 
  if (((unsigned int)count == 0U || mv_list == (struct i40e_aqc_remove_macvlan_element_data *)0) || hw == (struct i40e_hw *)0) 
    #line 2797 
    return I40E_ERR_PARAM;
  #line 2799 
  buf_size = (unsigned short)((unsigned int)count * 16U);
  #line 2802 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)593);
  #line 2803 
  cmd->num_addresses = count;
  #line 2804 
  cmd->seid[0] = (unsigned short)((unsigned int)seid | 32768U);
  #line 2805 
  cmd->seid[1] = (unsigned short)0U;
  #line 2806 
  cmd->seid[2] = (unsigned short)0U;
  #line 2808 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  #line 2809 
  if ((unsigned int)buf_size > 512U) 
                                     #line 2810 
                                     desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
  #line 2812 
  status = i40e_asq_send_command(hw,& desc,(void *)mv_list,(unsigned short)((int)buf_size),cmd_details);
  #line 2815 
  return status;
}

#line 2835  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static i40e_status i40e_mirrorrule_op(struct i40e_hw *hw, u16 opcode, u16 sw_seid, u16 rule_type, u16 id, u16 count, __le16 *mr_list, struct i40e_asq_cmd_details *cmd_details, u16 *rule_id, u16 *rules_used, u16 *rules_free)
{
  #line 2841 
  struct i40e_aq_desc desc;
  #line 2846 
  i40e_status status;
  #line 2847 
  u16 buf_size;
  #line 2842 
  struct i40e_aqc_add_delete_mirror_rule *cmd = (struct i40e_aqc_add_delete_mirror_rule *)(& desc.params.raw);
  #line 2844 
  struct i40e_aqc_add_delete_mirror_rule_completion *resp = (struct i40e_aqc_add_delete_mirror_rule_completion *)(& desc.params.raw);
  #line 2849 
  buf_size = (unsigned short)((unsigned int)count * 2U);
  #line 2852 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)((int)opcode));
  #line 2853 
  cmd->seid = sw_seid;
  #line 2854 
  cmd->rule_type = (unsigned short)((unsigned int)rule_type & 7U);
  #line 2856 
  cmd->num_entries = count;
  #line 2858 
  cmd->destination = id;
  #line 2859 
  if (mr_list != (__le16 *)0U) {
    #line 2860 
    desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
    #line 2862 
    if ((unsigned int)buf_size > 512U) 
                                       #line 2863 
                                       desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
  }
  #line 2866 
  status = i40e_asq_send_command(hw,& desc,(void *)mr_list,(unsigned short)((int)buf_size),cmd_details);
  #line 2868 
  if (status == I40E_SUCCESS || hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_ENOSPC) {
    #line 2870 
    if (rule_id != (u16 *)0U) 
                              #line 2871 
                              *rule_id = resp->rule_id;
    #line 2872 
    if (rules_used != (u16 *)0U) 
                                 #line 2873 
                                 *rules_used = resp->mirror_rules_used;
    #line 2874 
    if (rules_free != (u16 *)0U) 
                                 #line 2875 
                                 *rules_free = resp->mirror_rules_free;
  }
  #line 2877 
  return status;
}

#line 2895  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_mirrorrule(struct i40e_hw *hw, u16 sw_seid, u16 rule_type, u16 dest_vsi, u16 count, __le16 *mr_list, struct i40e_asq_cmd_details *cmd_details, u16 *rule_id, u16 *rules_used, u16 *rules_free)
{
  #line 2900 
  if ((unsigned int)rule_type + 65532U > 1U) 
    #line 2902 
    if ((unsigned int)count == 0U || mr_list == (__le16 *)0U) 
                                                              #line 2903 
                                                              return I40E_ERR_PARAM;
  #line 2906 
  return i40e_mirrorrule_op(hw,(unsigned short)608,
                         (unsigned short)((int)sw_seid),
                         (unsigned short)((int)rule_type),
                         (unsigned short)((int)dest_vsi),
                         (unsigned short)((int)count),mr_list,cmd_details,
                         rule_id,rules_used,rules_free);
}

#line 2926  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_delete_mirrorrule(struct i40e_hw *hw, u16 sw_seid, u16 rule_type, u16 rule_id, u16 count, __le16 *mr_list, struct i40e_asq_cmd_details *cmd_details, u16 *rules_used, u16 *rules_free)
{
  #line 2932 
  if ((unsigned int)rule_type == 3U) 
    #line 2937 
    if ((unsigned int)count == 0U || mr_list == (__le16 *)0U) 
                                                              #line 2938 
                                                              return I40E_ERR_PARAM;
  #line 2941 
  return i40e_mirrorrule_op(hw,(unsigned short)609,
                         (unsigned short)((int)sw_seid),
                         (unsigned short)((int)rule_type),
                         (unsigned short)((int)rule_id),
                         (unsigned short)((int)count),mr_list,cmd_details,
                         (u16 *)0U,rules_used,rules_free);
}

#line 2958  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_send_msg_to_vf(struct i40e_hw *hw, u16 vfid, u32 v_opcode, u32 v_retval, u8 *msg, u16 msglen, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2962 
  struct i40e_aq_desc desc;
  #line 2965 
  i40e_status status;
  #line 2963 
  struct i40e_aqc_pf_vf_message *cmd = (struct i40e_aqc_pf_vf_message *)(& desc.params.raw);
  #line 2967 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2050);
  #line 2968 
  cmd->id = (unsigned int)vfid;
  #line 2969 
  desc.cookie_high = v_opcode;
  #line 2970 
  desc.cookie_low = v_retval;
  #line 2971 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 8192U);
  #line 2972 
  if ((unsigned int)msglen != 0U) {
    #line 2973 
    desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
    #line 2975 
    if ((unsigned int)msglen > 512U) 
                                     #line 2976 
                                     desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
    #line 2977 
    desc.datalen = msglen;
  }
  #line 2979 
  status = i40e_asq_send_command(hw,& desc,(void *)msg,(unsigned short)((int)msglen),cmd_details);
  #line 2981 
  return status;
}

#line 2993  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_debug_read_register(struct i40e_hw *hw, u32 reg_addr, u64 *reg_val, struct i40e_asq_cmd_details *cmd_details)
{
  #line 2997 
  struct i40e_aq_desc desc;
  #line 3000 
  i40e_status status;
  #line 2998 
  struct i40e_aqc_debug_reg_read_write *cmd_resp = (struct i40e_aqc_debug_reg_read_write *)(& desc.params.raw);
  #line 3002 
  if (reg_val == (u64 *)0ULL) 
                              #line 3003 
                              return I40E_ERR_PARAM;
  #line 3005 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)65283);
  #line 3007 
  cmd_resp->address = reg_addr;
  #line 3009 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3011 
  if (status == I40E_SUCCESS) 
                              #line 3012 
                              *reg_val = ((unsigned long long)cmd_resp->value_high << 32) | (unsigned long long)cmd_resp->value_low;
  #line 3016 
  return status;
}

#line 3028  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_debug_write_register(struct i40e_hw *hw, u32 reg_addr, u64 reg_val, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3032 
  struct i40e_aq_desc desc;
  #line 3035 
  i40e_status status;
  #line 3033 
  struct i40e_aqc_debug_reg_read_write *cmd = (struct i40e_aqc_debug_reg_read_write *)(& desc.params.raw);
  #line 3037 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)65284);
  #line 3039 
  cmd->address = reg_addr;
  #line 3040 
  cmd->value_high = (unsigned int)(reg_val >> 32);
  #line 3041 
  cmd->value_low = (unsigned int)reg_val;
  #line 3043 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3045 
  return status;
}

#line 3059  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_request_resource(struct i40e_hw *hw, enum i40e_aq_resources_ids resource, enum i40e_aq_resource_access_type access, u8 sdp_number, u64 *timeout, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3065 
  struct i40e_aq_desc desc;
  #line 3068 
  i40e_status status;
  #line 3066 
  struct i40e_aqc_request_resource *cmd_resp = (struct i40e_aqc_request_resource *)(& desc.params.raw);
  #line 3070 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)8);
  #line 3072 
  cmd_resp->resource_id = (unsigned short)resource;
  #line 3073 
  cmd_resp->access_type = (unsigned short)access;
  #line 3074 
  cmd_resp->resource_number = (unsigned int)sdp_number;
  #line 3076 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3083 
  if (status == I40E_SUCCESS || hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_EBUSY) 
    #line 3084 
    *timeout = (unsigned long long)cmd_resp->timeout;
  #line 3086 
  return status;
}

#line 3098  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_release_resource(struct i40e_hw *hw, enum i40e_aq_resources_ids resource, u8 sdp_number, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3103 
  struct i40e_aq_desc desc;
  #line 3106 
  i40e_status status;
  #line 3104 
  struct i40e_aqc_request_resource *cmd = (struct i40e_aqc_request_resource *)(& desc.params.raw);
  #line 3108 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)9);
  #line 3110 
  cmd->resource_id = (unsigned short)resource;
  #line 3111 
  cmd->resource_number = (unsigned int)sdp_number;
  #line 3113 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3115 
  return status;
}

#line 3130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_read_nvm(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 length, void *data, bool last_command, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3135 
  struct i40e_aq_desc desc;
  #line 3138 
  i40e_status status;
  #line 3136 
  struct i40e_aqc_nvm_update *cmd = (struct i40e_aqc_nvm_update *)(& desc.params.raw);
  #line 3141 
  if ((offset & 4278190080U) != 0U) {
    #line 3142 
    status = I40E_ERR_PARAM;
    #line 3143 
    goto i40e_aq_read_nvm_exit;
  }
  #line 3146 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1793);
  #line 3149 
  if ((int)last_command != 0) 
                              #line 3150 
                              cmd->command_flags = (unsigned char)((unsigned int)cmd->command_flags | 1U);
  #line 3151 
  cmd->module_pointer = module_pointer;
  #line 3152 
  cmd->offset = offset;
  #line 3153 
  cmd->length = length;
  #line 3155 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  #line 3156 
  if ((unsigned int)length > 512U) 
                                   #line 3157 
                                   desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
  #line 3159 
  status = i40e_asq_send_command(hw,& desc,data,(unsigned short)((int)length),cmd_details);
  #line 3161 
  i40e_aq_read_nvm_exit: 
                         #line 3161 
  ;
  #line 3162 
  return status;
}

#line 3176  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_erase_nvm(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 length, bool last_command, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3180 
  struct i40e_aq_desc desc;
  #line 3183 
  i40e_status status;
  #line 3181 
  struct i40e_aqc_nvm_update *cmd = (struct i40e_aqc_nvm_update *)(& desc.params.raw);
  #line 3186 
  if ((offset & 4278190080U) != 0U) {
    #line 3187 
    status = I40E_ERR_PARAM;
    #line 3188 
    goto i40e_aq_erase_nvm_exit;
  }
  #line 3191 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1794);
  #line 3194 
  if ((int)last_command != 0) 
                              #line 3195 
                              cmd->command_flags = (unsigned char)((unsigned int)cmd->command_flags | 1U);
  #line 3196 
  cmd->module_pointer = module_pointer;
  #line 3197 
  cmd->offset = offset;
  #line 3198 
  cmd->length = length;
  #line 3200 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3202 
  i40e_aq_erase_nvm_exit: 
                          #line 3202 
  ;
  #line 3203 
  return status;
}

#line 3215  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static void i40e_parse_discover_capabilities(struct i40e_hw *hw, void *buff, u32 cap_count, enum i40e_admin_queue_opc list_type_opc)
{
  #line 3219 
  struct i40e_aqc_list_capabilities_element_resp *cap;
  #line 3220 
  u32 valid_functions;
  #line 3220 
  u32 num_functions;
  #line 3221 
  u32 number;
  #line 3221 
  u32 logical_id;
  #line 3221 
  u32 phys_id;
  #line 3222 
  struct i40e_hw_capabilities *p;
  #line 3223 
  u16 id;
  #line 3223 
  u16 ocp_cfg_word0;
  #line 3224 
  i40e_status status;
  #line 3225 
  u8 major_rev;
  #line 3226 
  u32 i = 0U;
  #line 3228 
  cap = (struct i40e_aqc_list_capabilities_element_resp *)buff;
  #line 3230 
  if (list_type_opc == (unsigned int)i40e_aqc_opc_list_dev_capabilities) 
    #line 3231 
    p = & hw->dev_caps;
  else 
    #line 3232 
    if (list_type_opc == (unsigned int)i40e_aqc_opc_list_func_capabilities) 
      #line 3233 
      p = & hw->func_caps; else 
                                #line 3235 
                                return;
  #line 3237 
  i = 0U;
  #line 3237 
  while (i < cap_count) {
    #line 3238 
    id = cap->id;
    #line 3239 
    number = cap->number;
    #line 3240 
    logical_id = cap->logical_id;
    #line 3241 
    phys_id = cap->phys_id;
    #line 3242 
    major_rev = cap->major_rev;
    #line 3244 
    switch ((int)id) {
      #line 3245 
      case 1: 
              #line 3245 
      ;
      #line 3246 
      p->switch_mode = number;
      #line 3247 
      break;
      #line 3248 
      case 2: 
              #line 3248 
      ;
      #line 3249 
      p->management_mode = number;
      #line 3250 
      if ((unsigned int)major_rev > 1U) {
        #line 3251 
        p->mng_protocols_over_mctp = logical_id;
        #line 3252 
        if ((hw->debug_mask & 1U) != 0U) 
                                         #line 3252 
                                         printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,p->mng_protocols_over_mctp);
      }
      else 
           #line 3256 
           p->mng_protocols_over_mctp = 0U;
      #line 3258 
      break;
      #line 3259 
      case 3: 
              #line 3259 
      ;
      #line 3260 
      p->npar_enable = number;
      #line 3261 
      break;
      #line 3262 
      case 4: 
              #line 3262 
      ;
      #line 3263 
      p->os2bmc = number;
      #line 3264 
      break;
      #line 3265 
      case 5: 
              #line 3265 
      ;
      #line 3266 
      p->valid_functions = number;
      #line 3267 
      break;
      #line 3268 
      case 18: 
               #line 3268 
      ;
      #line 3269 
      if (number == 1U) 
                        #line 3270 
                        p->sr_iov_1_1 = (_Bool)1;
      #line 3271 
      break;
      #line 3272 
      case 19: 
               #line 3272 
      ;
      #line 3273 
      p->num_vfs = number;
      #line 3274 
      p->vf_base_id = logical_id;
      #line 3275 
      break;
      #line 3276 
      case 20: 
               #line 3276 
      ;
      #line 3277 
      if (number == 1U) 
                        #line 3278 
                        p->vmdq = (_Bool)1;
      #line 3279 
      break;
      #line 3280 
      case 21: 
               #line 3280 
      ;
      #line 3281 
      if (number == 1U) 
                        #line 3282 
                        p->evb_802_1_qbg = (_Bool)1;
      #line 3283 
      break;
      #line 3284 
      case 22: 
               #line 3284 
      ;
      #line 3285 
      if (number == 1U) 
                        #line 3286 
                        p->evb_802_1_qbh = (_Bool)1;
      #line 3287 
      break;
      #line 3288 
      case 23: 
               #line 3288 
      ;
      #line 3289 
      p->num_vsis = number;
      #line 3290 
      break;
      #line 3291 
      case 24: 
               #line 3291 
      ;
      #line 3292 
      if (number == 1U) {
        #line 3293 
        p->dcb = (_Bool)1;
        #line 3294 
        p->enabled_tcmap = logical_id;
        #line 3295 
        p->maxtc = phys_id;
      }
      #line 3297 
      break;
      #line 3298 
      case 33: 
               #line 3298 
      ;
      #line 3299 
      if (number == 1U) 
                        #line 3300 
                        p->fcoe = (_Bool)1;
      #line 3301 
      break;
      #line 3302 
      case 34: 
               #line 3302 
      ;
      #line 3303 
      if (number == 1U) 
                        #line 3304 
                        p->iscsi = (_Bool)1;
      #line 3305 
      break;
      #line 3306 
      case 64: 
               #line 3306 
      ;
      #line 3307 
      p->rss = (_Bool)1;
      #line 3308 
      p->rss_table_size = number;
      #line 3309 
      p->rss_table_entry_width = logical_id;
      #line 3310 
      break;
      #line 3311 
      case 65: 
               #line 3311 
      ;
      #line 3312 
      p->num_rx_qp = number;
      #line 3313 
      p->base_queue = phys_id;
      #line 3314 
      break;
      #line 3315 
      case 66: 
               #line 3315 
      ;
      #line 3316 
      p->num_tx_qp = number;
      #line 3317 
      p->base_queue = phys_id;
      #line 3318 
      break;
      #line 3319 
      case 67: 
               #line 3319 
      ;
      #line 3320 
      p->num_msix_vectors = number;
      #line 3321 
      if ((hw->debug_mask & 1U) != 0U) 
                                       #line 3321 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,p->num_msix_vectors);
      #line 3324 
      break;
      #line 3325 
      case 68: 
               #line 3325 
      ;
      #line 3326 
      p->num_msix_vectors_vf = number;
      #line 3327 
      break;
      #line 3328 
      case 241: 
                #line 3328 
      ;
      #line 3329 
      if ((unsigned int)major_rev == 1U) {
        #line 3330 
        if (number == 1U) {
          #line 3331 
          p->flex10_enable = (_Bool)1;
          #line 3332 
          p->flex10_capable = (_Bool)1;
        }
      }
      else {
        #line 3336 
        if ((number & 1U) != 0U) 
                                 #line 3337 
                                 p->flex10_enable = (_Bool)1;
        #line 3338 
        if ((number & 2U) != 0U) 
                                 #line 3339 
                                 p->flex10_capable = (_Bool)1;
      }
      #line 3341 
      p->flex10_mode = logical_id;
      #line 3342 
      p->flex10_status = phys_id;
      #line 3343 
      break;
      #line 3344 
      case 242: 
                #line 3344 
      ;
      #line 3345 
      if (number == 1U) 
                        #line 3346 
                        p->mgmt_cem = (_Bool)1;
      #line 3347 
      break;
      #line 3348 
      case 81: 
               #line 3348 
      ;
      #line 3349 
      if (number == 1U) 
                        #line 3350 
                        p->iwarp = (_Bool)1;
      #line 3351 
      break;
      #line 3352 
      case 97: 
               #line 3352 
      ;
      #line 3353 
      if (phys_id <= 29U) 
                          #line 3354 
                          p->led[phys_id] = (_Bool)1;
      #line 3355 
      break;
      #line 3356 
      case 98: 
               #line 3356 
      ;
      #line 3357 
      if (phys_id <= 29U) 
                          #line 3358 
                          p->sdp[phys_id] = (_Bool)1;
      #line 3359 
      break;
      #line 3360 
      case 99: 
               #line 3360 
      ;
      #line 3361 
      if (number == 1U) {
        #line 3362 
        p->mdio_port_num = phys_id;
        #line 3363 
        p->mdio_port_mode = logical_id;
      }
      #line 3365 
      break;
      #line 3366 
      case 70: 
               #line 3366 
      ;
      #line 3367 
      if (number == 1U) 
                        #line 3368 
                        p->ieee_1588 = (_Bool)1;
      #line 3369 
      break;
      #line 3370 
      case 69: 
               #line 3370 
      ;
      #line 3371 
      p->fd = (_Bool)1;
      #line 3372 
      p->fd_filters_guaranteed = number;
      #line 3373 
      p->fd_filters_best_effort = logical_id;
      #line 3374 
      break;
      #line 3375 
      case 100: 
                #line 3375 
      ;
      #line 3376 
      p->wr_csr_prot = (unsigned long long)number;
      #line 3377 
      p->wr_csr_prot |= (unsigned long long)logical_id << 32;
      #line 3378 
      break;
      #line 3379 
      case 128: 
                #line 3379 
      ;
      #line 3380 
      if ((number & 1U) != 0U) 
                               #line 3381 
                               p->sec_rev_disabled = (_Bool)1;
      #line 3382 
      if ((number & 2U) != 0U) 
                               #line 3383 
                               p->update_disabled = (_Bool)1;
      #line 3384 
      break;
      #line 3385 
      default: 
               #line 3385 
      ;
      #line 3386 
      break;
    }
    #line 3237 
    i ++;
    #line 3237 
    cap ++;
  }
  #line 3390 
  if ((int)p->fcoe != 0) 
    #line 3391 
    if (hw->debug_mask != 0U) 
                              #line 3391 
                              printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
  #line 3396 
  if (p->npar_enable != 0U || (int)p->flex10_enable != 0) 
                                                          #line 3397 
                                                          p->fcoe = (_Bool)0;
  #line 3400 
  hw->num_ports = (unsigned short)0U;
  #line 3401 
  i = 0U;
  #line 3401 
  while (i <= 3U) {
    {
      #line 3402 
      u32 port_cfg_reg = (i + 188488U) * 4U;
      #line 3403 
      u64 port_cfg = 0ULL;
      #line 3408 
      i40e_aq_debug_read_register(hw,port_cfg_reg,& port_cfg,(struct i40e_asq_cmd_details *)0);
      #line 3409 
      if ((port_cfg & 1ULL) == 0ULL) 
                                     #line 3410 
                                     hw->num_ports = (u16)((int)hw->num_ports + 1);
    }
    #line 3401 
    i ++;
  }
  #line 3420 
  if (hw->mac.type == (unsigned int)I40E_MAC_X722) {
    #line 3421 
    if (i40e_acquire_nvm(hw,
                       (enum i40e_aq_resource_access_type)I40E_RESOURCE_READ) == I40E_SUCCESS) {
      #line 3422 
      status = i40e_aq_read_nvm(hw,(unsigned char)72,86U,(unsigned short)2,(void *)(& ocp_cfg_word0),(_Bool)1,(struct i40e_asq_cmd_details *)0);
      #line 3426 
      if (status == I40E_SUCCESS && ((unsigned long)ocp_cfg_word0 & 32768UL) != 0UL) 
        #line 3428 
        hw->num_ports = (unsigned short)4U;
      #line 3429 
      i40e_release_nvm(hw);
    }
  }
  #line 3433 
  valid_functions = p->valid_functions;
  #line 3434 
  num_functions = 0U;
  #line 3435 
  while (valid_functions != 0U) {
    #line 3436 
    if ((valid_functions & 1U) != 0U) 
                                      #line 3437 
                                      num_functions ++;
    #line 3438 
    valid_functions >>= 1;
  }
  #line 3444 
  if ((unsigned int)hw->num_ports != 0U) {
    #line 3445 
    hw->partition_id = (unsigned short)((unsigned int)((unsigned short)((int)hw->pf_id / (int)hw->num_ports)) + 1U);
    #line 3446 
    hw->num_partitions = (unsigned short)(num_functions / (unsigned int)hw->num_ports);
  }
  #line 3452 
  p->rx_buf_chain_len = (unsigned char)5U;
  #line 3453 
  return;
}

#line 3466  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_discover_capabilities(struct i40e_hw *hw, void *buff, u16 buff_size, u16 *data_size, enum i40e_admin_queue_opc list_type_opc, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3471 
  struct i40e_aqc_list_capabilites *cmd;
  #line 3472 
  struct i40e_aq_desc desc;
  #line 3473 
  i40e_status status = 0;
  #line 3475 
  cmd = (struct i40e_aqc_list_capabilites *)(& desc.params.raw);
  #line 3477 
  if ((unsigned int)list_type_opc + 4294967286U > 1U) {
    #line 3479 
    status = I40E_ERR_PARAM;
    #line 3480 
    goto exit;
  }
  #line 3483 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)((int)((unsigned short)list_type_opc)));
  #line 3485 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  #line 3486 
  if ((unsigned int)buff_size > 512U) 
                                      #line 3487 
                                      desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
  #line 3489 
  status = i40e_asq_send_command(hw,& desc,buff,(unsigned short)((int)buff_size),cmd_details);
  #line 3490 
  *data_size = desc.datalen;
  #line 3492 
  if (status != I40E_SUCCESS) 
                              #line 3493 
                              goto exit;
  #line 3495 
  i40e_parse_discover_capabilities(hw,buff,cmd->count,list_type_opc);
  #line 3498 
  exit: 
        #line 3498 
  ;
  #line 3499 
  return status;
}

#line 3515  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_update_nvm(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 length, void *data, bool last_command, u8 preservation_flags, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3520 
  struct i40e_aq_desc desc;
  #line 3523 
  i40e_status status;
  #line 3521 
  struct i40e_aqc_nvm_update *cmd = (struct i40e_aqc_nvm_update *)(& desc.params.raw);
  #line 3526 
  if ((offset & 4278190080U) != 0U) {
    #line 3527 
    status = I40E_ERR_PARAM;
    #line 3528 
    goto i40e_aq_update_nvm_exit;
  }
  #line 3531 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1795);
  #line 3534 
  if ((int)last_command != 0) 
                              #line 3535 
                              cmd->command_flags = (unsigned char)((unsigned int)cmd->command_flags | 1U);
  #line 3536 
  if (hw->mac.type == (unsigned int)I40E_MAC_X722) 
    #line 3537 
    if ((unsigned int)preservation_flags == 1U) 
                                                #line 3538 
                                                cmd->command_flags = (unsigned char)((unsigned int)cmd->command_flags | 6U);
    else 
      #line 3541 
      if ((unsigned int)preservation_flags == 2U) 
                                                  #line 3542 
                                                  cmd->command_flags = (unsigned char)((unsigned int)cmd->command_flags | 2U);
  #line 3546 
  cmd->module_pointer = module_pointer;
  #line 3547 
  cmd->offset = offset;
  #line 3548 
  cmd->length = length;
  #line 3550 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  #line 3551 
  if ((unsigned int)length > 512U) 
                                   #line 3552 
                                   desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
  #line 3554 
  status = i40e_asq_send_command(hw,& desc,data,(unsigned short)((int)length),cmd_details);
  #line 3556 
  i40e_aq_update_nvm_exit: 
                           #line 3556 
  ;
  #line 3557 
  return status;
}

#line 3568  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_rearrange_nvm(struct i40e_hw *hw, u8 rearrange_nvm, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3572 
  struct i40e_aqc_nvm_update *cmd;
  #line 3573 
  i40e_status status;
  #line 3574 
  struct i40e_aq_desc desc;
  #line 3576 
  cmd = (struct i40e_aqc_nvm_update *)(& desc.params.raw);
  #line 3578 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1795);
  #line 3580 
  rearrange_nvm = (unsigned char)((unsigned int)rearrange_nvm & 96U);
  #line 3583 
  if ((unsigned int)rearrange_nvm == 0U) {
    #line 3584 
    status = I40E_ERR_PARAM;
    #line 3585 
    goto i40e_aq_rearrange_nvm_exit;
  }
  #line 3588 
  cmd->command_flags = (unsigned char)((int)cmd->command_flags | (int)rearrange_nvm);
  #line 3589 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3591 
  i40e_aq_rearrange_nvm_exit: 
                              #line 3591 
  ;
  #line 3592 
  return status;
}

#line 3608  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_lldp_mib(struct i40e_hw *hw, u8 bridge_type, u8 mib_type, void *buff, u16 buff_size, u16 *local_len, u16 *remote_len, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3613 
  struct i40e_aq_desc desc;
  #line 3618 
  i40e_status status;
  #line 3614 
  struct i40e_aqc_lldp_get_mib *cmd = (struct i40e_aqc_lldp_get_mib *)(& desc.params.raw);
  #line 3616 
  struct i40e_aqc_lldp_get_mib *resp = (struct i40e_aqc_lldp_get_mib *)(& desc.params.raw);
  #line 3620 
  if ((unsigned int)buff_size == 0U || buff == (void *)0) 
                                                          #line 3621 
                                                          return I40E_ERR_PARAM;
  #line 3623 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2560);
  #line 3625 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  #line 3627 
  cmd->type = (unsigned char)((unsigned int)mib_type & 3U);
  #line 3628 
  cmd->type = (unsigned char)((int)cmd->type | (((int)bridge_type << 2) & 12));
  #line 3631 
  desc.datalen = buff_size;
  #line 3633 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  #line 3634 
  if ((unsigned int)buff_size > 512U) 
                                      #line 3635 
                                      desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
  #line 3637 
  status = i40e_asq_send_command(hw,& desc,buff,(unsigned short)((int)buff_size),cmd_details);
  #line 3638 
  if (status == I40E_SUCCESS) {
    #line 3639 
    if (local_len != (u16 *)0U) 
                                #line 3640 
                                *local_len = resp->local_len;
    #line 3641 
    if (remote_len != (u16 *)0U) 
                                 #line 3642 
                                 *remote_len = resp->remote_len;
  }
  #line 3645 
  return status;
}

#line 3657  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_cfg_lldp_mib_change_event(struct i40e_hw *hw, bool enable_update, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3661 
  struct i40e_aq_desc desc;
  #line 3664 
  i40e_status status;
  #line 3662 
  struct i40e_aqc_lldp_update_mib *cmd = (struct i40e_aqc_lldp_update_mib *)(& desc.params.raw);
  #line 3666 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2561);
  #line 3668 
  if (! enable_update) 
                       #line 3669 
                       cmd->command = (unsigned char)((unsigned int)cmd->command | 1U);
  #line 3671 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3673 
  return status;
}

#line 3687  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_restore_lldp(struct i40e_hw *hw, u8 *setting, bool restore, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3690 
  struct i40e_aq_desc desc;
  #line 3693 
  i40e_status status;
  #line 3691 
  struct i40e_aqc_lldp_restore *cmd = (struct i40e_aqc_lldp_restore *)(& desc.params.raw);
  #line 3695 
  if ((hw->flags & 32ULL) == 0ULL) {
    #line 3696 
    if (hw->debug_mask != 0U) 
                              #line 3696 
                              printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
    #line 3698 
    return I40E_ERR_DEVICE_NOT_SUPPORTED;
  }
  #line 3701 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2570);
  #line 3703 
  if ((int)restore != 0) 
                         #line 3704 
                         cmd->command = (unsigned char)((unsigned int)cmd->command | 1U);
  #line 3706 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3708 
  if (setting != (u8 *)0U) 
                           #line 3709 
                           *setting = (unsigned char)((unsigned int)cmd->command & 1U);
  #line 3711 
  return status;
}

#line 3723  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_stop_lldp(struct i40e_hw *hw, bool shutdown_agent, bool persist, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3727 
  struct i40e_aq_desc desc;
  #line 3730 
  i40e_status status;
  #line 3728 
  struct i40e_aqc_lldp_stop *cmd = (struct i40e_aqc_lldp_stop *)(& desc.params.raw);
  #line 3732 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2565);
  #line 3734 
  if ((int)shutdown_agent != 0) 
                                #line 3735 
                                cmd->command = (unsigned char)((unsigned int)cmd->command | 1U);
  #line 3737 
  if ((int)persist != 0) 
    #line 3738 
    if ((hw->flags & 32ULL) != 0ULL) 
                                     #line 3739 
                                     cmd->command = (unsigned char)((unsigned int)cmd->command | 2U);
    else 
      #line 3741 
      if (hw->debug_mask != 0U) 
                                #line 3741 
                                printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
  #line 3745 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3747 
  return status;
}

#line 3760  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_start_lldp(struct i40e_hw *hw, bool persist, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3763 
  struct i40e_aq_desc desc;
  #line 3766 
  i40e_status status;
  #line 3764 
  struct i40e_aqc_lldp_start *cmd = (struct i40e_aqc_lldp_start *)(& desc.params.raw);
  #line 3768 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2566);
  #line 3770 
  cmd->command = (unsigned char)1U;
  #line 3772 
  if ((int)persist != 0) 
    #line 3773 
    if ((hw->flags & 32ULL) != 0ULL) 
                                     #line 3774 
                                     cmd->command = (unsigned char)((unsigned int)cmd->command | 2U);
    else 
      #line 3776 
      if (hw->debug_mask != 0U) 
                                #line 3776 
                                printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
  #line 3780 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3782 
  return status;
}

#line 3793  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_set_dcb_parameters(struct i40e_hw *hw, bool dcb_enable, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3796 
  struct i40e_aq_desc desc;
  #line 3799 
  i40e_status status;
  #line 3797 
  struct i40e_aqc_set_dcb_parameters *cmd = (struct i40e_aqc_set_dcb_parameters *)(& desc.params.raw);
  #line 3801 
  if ((hw->flags & 16ULL) == 0ULL) 
                                   #line 3802 
                                   return I40E_ERR_DEVICE_NOT_SUPPORTED;
  #line 3804 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)771);
  #line 3807 
  if ((int)dcb_enable != 0) {
    #line 3808 
    cmd->valid_flags = (unsigned char)1U;
    #line 3809 
    cmd->command = (unsigned char)1U;
  }
  #line 3811 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3813 
  return status;
}

#line 3825  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_cee_dcb_config(struct i40e_hw *hw, void *buff, u16 buff_size, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3829 
  struct i40e_aq_desc desc;
  #line 3830 
  i40e_status status;
  #line 3832 
  if ((unsigned int)buff_size == 0U || buff == (void *)0) 
                                                          #line 3833 
                                                          return I40E_ERR_PARAM;
  #line 3835 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2567);
  #line 3837 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  #line 3838 
  status = i40e_asq_send_command(hw,& desc,buff,(unsigned short)((int)buff_size),cmd_details);
  #line 3841 
  return status;
}

#line 3856  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_udp_tunnel(struct i40e_hw *hw, u16 udp_port, u8 protocol_index, u8 *filter_index, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3861 
  struct i40e_aq_desc desc;
  #line 3866 
  i40e_status status;
  #line 3862 
  struct i40e_aqc_add_udp_tunnel *cmd = (struct i40e_aqc_add_udp_tunnel *)(& desc.params.raw);
  #line 3864 
  struct i40e_aqc_del_udp_tunnel_completion *resp = (struct i40e_aqc_del_udp_tunnel_completion *)(& desc.params.raw);
  #line 3868 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2816);
  #line 3870 
  cmd->udp_port = udp_port;
  #line 3871 
  cmd->protocol_type = protocol_index;
  #line 3873 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3875 
  if (status == I40E_SUCCESS && filter_index != (u8 *)0U) 
                                                          #line 3876 
                                                          *filter_index = resp->index;
  #line 3878 
  return status;
}

#line 3887  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_del_udp_tunnel(struct i40e_hw *hw, u8 index, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3890 
  struct i40e_aq_desc desc;
  #line 3893 
  i40e_status status;
  #line 3891 
  struct i40e_aqc_remove_udp_tunnel *cmd = (struct i40e_aqc_remove_udp_tunnel *)(& desc.params.raw);
  #line 3895 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2817);
  #line 3897 
  cmd->index = index;
  #line 3899 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3901 
  return status;
}

#line 3912  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_delete_element(struct i40e_hw *hw, u16 seid, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3915 
  struct i40e_aq_desc desc;
  #line 3918 
  i40e_status status;
  #line 3916 
  struct i40e_aqc_switch_seid *cmd = (struct i40e_aqc_switch_seid *)(& desc.params.raw);
  #line 3920 
  if ((unsigned int)seid == 0U) 
                                #line 3921 
                                return I40E_ERR_PARAM;
  #line 3923 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)579);
  #line 3925 
  cmd->seid = seid;
  #line 3927 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3929 
  return status;
}

#line 3941  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_dcb_updated(struct i40e_hw *hw, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3944 
  struct i40e_aq_desc desc;
  #line 3945 
  i40e_status status;
  #line 3947 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)770);
  #line 3949 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 3951 
  return status;
}

#line 3965  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static i40e_status i40e_aq_tx_sched_cmd(struct i40e_hw *hw, u16 seid, void *buff, u16 buff_size, enum i40e_admin_queue_opc opcode, struct i40e_asq_cmd_details *cmd_details)
{
  #line 3970 
  struct i40e_aq_desc desc;
  #line 3973 
  i40e_status status;
  #line 3971 
  struct i40e_aqc_tx_sched_ind *cmd = (struct i40e_aqc_tx_sched_ind *)(& desc.params.raw);
  #line 3974 
  bool cmd_param_flag = (_Bool)0;
  #line 3976 
  switch ((unsigned int)opcode) {
    #line 3977 
    case (unsigned int)1030: 
                             #line 3977 
    ;
    #line 3978 
    case (unsigned int)1031: 
                             #line 3978 
    ;
    #line 3979 
    case (unsigned int)1043: 
                             #line 3979 
    ;
    #line 3980 
    case (unsigned int)1044: 
                             #line 3980 
    ;
    #line 3981 
    case (unsigned int)1045: 
                             #line 3981 
    ;
    #line 3982 
    case (unsigned int)1046: 
                             #line 3982 
    ;
    #line 3983 
    case (unsigned int)1047: 
                             #line 3983 
    ;
    #line 3984 
    cmd_param_flag = (_Bool)1;
    #line 3985 
    break;
    #line 3986 
    case (unsigned int)1032: 
                             #line 3986 
    ;
    #line 3987 
    case (unsigned int)1034: 
                             #line 3987 
    ;
    #line 3988 
    case (unsigned int)1048: 
                             #line 3988 
    ;
    #line 3989 
    case (unsigned int)1049: 
                             #line 3989 
    ;
    #line 3990 
    case (unsigned int)1050: 
                             #line 3990 
    ;
    #line 3991 
    cmd_param_flag = (_Bool)0;
    #line 3992 
    break;
    #line 3993 
    default: 
             #line 3993 
    ;
    #line 3994 
    return I40E_ERR_PARAM;
  }
  #line 3997 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)((int)((unsigned short)opcode)));
  #line 4000 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  #line 4001 
  if ((int)cmd_param_flag != 0) 
                                #line 4002 
                                desc.flags = (unsigned short)((unsigned int)desc.flags | 1024U);
  #line 4003 
  if ((unsigned int)buff_size > 512U) 
                                      #line 4004 
                                      desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
  #line 4006 
  desc.datalen = buff_size;
  #line 4008 
  cmd->vsi_seid = seid;
  #line 4010 
  status = i40e_asq_send_command(hw,& desc,buff,(unsigned short)((int)buff_size),cmd_details);
  #line 4012 
  return status;
}

#line 4023  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_config_vsi_bw_limit(struct i40e_hw *hw, u16 seid, u16 credit, u8 max_credit, struct i40e_asq_cmd_details *cmd_details)
{
  #line 4027 
  struct i40e_aq_desc desc;
  #line 4030 
  i40e_status status;
  #line 4028 
  struct i40e_aqc_configure_vsi_bw_limit *cmd = (struct i40e_aqc_configure_vsi_bw_limit *)(& desc.params.raw);
  #line 4032 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1024);
  #line 4035 
  cmd->vsi_seid = seid;
  #line 4036 
  cmd->credit = credit;
  #line 4037 
  cmd->max_credit = max_credit;
  #line 4039 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 4041 
  return status;
}

#line 4051  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_config_vsi_tc_bw(struct i40e_hw *hw, u16 seid, struct i40e_aqc_configure_vsi_tc_bw_data *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  #line 4056 
  return i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)bw_data,
                           (unsigned short)32,
                           (enum i40e_admin_queue_opc)i40e_aqc_opc_configure_vsi_tc_bw,
                           cmd_details);
}

#line 4069  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_config_switch_comp_ets(struct i40e_hw *hw, u16 seid, struct i40e_aqc_configure_switching_comp_ets_data *ets_data, enum i40e_admin_queue_opc opcode, struct i40e_asq_cmd_details *cmd_details)
{
  #line 4075 
  return i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)ets_data,
                           (unsigned short)128,opcode,cmd_details);
}

#line 4086  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_config_switch_comp_bw_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_configure_switching_comp_bw_config_data *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  #line 4091 
  return i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)bw_data,
                           (unsigned short)32,
                           (enum i40e_admin_queue_opc)i40e_aqc_opc_configure_switching_comp_bw_config,
                           cmd_details);
}

#line 4103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_vsi_bw_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_vsi_bw_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  #line 4108 
  return i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)bw_data,
                           (unsigned short)64,
                           (enum i40e_admin_queue_opc)i40e_aqc_opc_query_vsi_bw_config,
                           cmd_details);
}

#line 4120  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_vsi_ets_sla_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_vsi_ets_sla_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  #line 4125 
  return i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)bw_data,
                           (unsigned short)32,
                           (enum i40e_admin_queue_opc)i40e_aqc_opc_query_vsi_ets_sla_config,
                           cmd_details);
}

#line 4137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_switch_comp_ets_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_switching_comp_ets_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  #line 4142 
  return i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)bw_data,
                           (unsigned short)64,
                           (enum i40e_admin_queue_opc)i40e_aqc_opc_query_switching_comp_ets_config,
                           cmd_details);
}

#line 4154  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_port_ets_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_port_ets_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  #line 4159 
  return i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)bw_data,
                           (unsigned short)68,
                           (enum i40e_admin_queue_opc)i40e_aqc_opc_query_port_ets_config,
                           cmd_details);
}

#line 4171  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_query_switch_comp_bw_config(struct i40e_hw *hw, u16 seid, struct i40e_aqc_query_switching_comp_bw_config_resp *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  #line 4176 
  return i40e_aq_tx_sched_cmd(hw,(unsigned short)((int)seid),(void *)bw_data,
                           (unsigned short)32,
                           (enum i40e_admin_queue_opc)i40e_aqc_opc_query_switching_comp_bw_config,
                           cmd_details);
}

#line 4193  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static i40e_status i40e_validate_filter_settings(struct i40e_hw *hw, struct i40e_filter_control_settings *settings)
{
  #line 4196 
  u32 fcoe_cntx_size;
  #line 4196 
  u32 fcoe_filt_size;
  #line 4197 
  u32 pe_cntx_size;
  #line 4197 
  u32 pe_filt_size;
  #line 4198 
  u32 fcoe_fmax;
  #line 4199 
  u32 val;
  #line 4202 
  switch ((unsigned int)settings->fcoe_filt_num) {
    #line 4203 
    case (unsigned int)0: 
                          #line 4203 
    ;
    #line 4204 
    case (unsigned int)1: 
                          #line 4204 
    ;
    #line 4205 
    case (unsigned int)2: 
                          #line 4205 
    ;
    #line 4206 
    case (unsigned int)3: 
                          #line 4206 
    ;
    #line 4207 
    case (unsigned int)4: 
                          #line 4207 
    ;
    #line 4208 
    case (unsigned int)5: 
                          #line 4208 
    ;
    #line 4209 
    fcoe_filt_size = 1024U;
    #line 4210 
    fcoe_filt_size <<= (unsigned int)settings->fcoe_filt_num;
    #line 4211 
    break;
    #line 4212 
    default: 
             #line 4212 
    ;
    #line 4213 
    return I40E_ERR_PARAM;
  }
  #line 4216 
  switch ((unsigned int)settings->fcoe_cntx_num) {
    #line 4217 
    case (unsigned int)0: 
                          #line 4217 
    ;
    #line 4218 
    case (unsigned int)1: 
                          #line 4218 
    ;
    #line 4219 
    case (unsigned int)2: 
                          #line 4219 
    ;
    #line 4220 
    case (unsigned int)3: 
                          #line 4220 
    ;
    #line 4221 
    fcoe_cntx_size = 512U;
    #line 4222 
    fcoe_cntx_size <<= (unsigned int)settings->fcoe_cntx_num;
    #line 4223 
    break;
    #line 4224 
    default: 
             #line 4224 
    ;
    #line 4225 
    return I40E_ERR_PARAM;
  }
  #line 4229 
  switch ((unsigned int)settings->pe_filt_num) {
    #line 4230 
    case (unsigned int)0: 
                          #line 4230 
    ;
    #line 4231 
    case (unsigned int)1: 
                          #line 4231 
    ;
    #line 4232 
    case (unsigned int)2: 
                          #line 4232 
    ;
    #line 4233 
    case (unsigned int)3: 
                          #line 4233 
    ;
    #line 4234 
    case (unsigned int)4: 
                          #line 4234 
    ;
    #line 4235 
    case (unsigned int)5: 
                          #line 4235 
    ;
    #line 4236 
    case (unsigned int)6: 
                          #line 4236 
    ;
    #line 4237 
    case (unsigned int)7: 
                          #line 4237 
    ;
    #line 4238 
    case (unsigned int)8: 
                          #line 4238 
    ;
    #line 4239 
    case (unsigned int)9: 
                          #line 4239 
    ;
    #line 4240 
    case (unsigned int)10: 
                           #line 4240 
    ;
    #line 4241 
    pe_filt_size = 1024U;
    #line 4242 
    pe_filt_size <<= (unsigned int)settings->pe_filt_num;
    #line 4243 
    break;
    #line 4244 
    default: 
             #line 4244 
    ;
    #line 4245 
    return I40E_ERR_PARAM;
  }
  #line 4248 
  switch ((unsigned int)settings->pe_cntx_num) {
    #line 4249 
    case (unsigned int)0: 
                          #line 4249 
    ;
    #line 4250 
    case (unsigned int)1: 
                          #line 4250 
    ;
    #line 4251 
    case (unsigned int)2: 
                          #line 4251 
    ;
    #line 4252 
    case (unsigned int)3: 
                          #line 4252 
    ;
    #line 4253 
    case (unsigned int)4: 
                          #line 4253 
    ;
    #line 4254 
    case (unsigned int)5: 
                          #line 4254 
    ;
    #line 4255 
    case (unsigned int)6: 
                          #line 4255 
    ;
    #line 4256 
    case (unsigned int)7: 
                          #line 4256 
    ;
    #line 4257 
    case (unsigned int)8: 
                          #line 4257 
    ;
    #line 4258 
    case (unsigned int)9: 
                          #line 4258 
    ;
    #line 4259 
    pe_cntx_size = 512U;
    #line 4260 
    pe_cntx_size <<= (unsigned int)settings->pe_cntx_num;
    #line 4261 
    break;
    #line 4262 
    default: 
             #line 4262 
    ;
    #line 4263 
    return I40E_ERR_PARAM;
  }
  #line 4267 
  val = readl((void *)(hw->hw_addr + 794832U));
  #line 4268 
  fcoe_fmax = val & 65535U;
  #line 4270 
  if (fcoe_filt_size + fcoe_cntx_size > fcoe_fmax) 
                                                   #line 4271 
                                                   return I40E_ERR_INVALID_SIZE;
  #line 4273 
  return I40E_SUCCESS;
}

#line 4285  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_set_filter_control(struct i40e_hw *hw, struct i40e_filter_control_settings *settings)
{
  #line 4290 
  u32 val;
  #line 4288 
  i40e_status ret = 0;
  #line 4289 
  u32 hash_lut_size = 0U;
  #line 4292 
  if (settings == (struct i40e_filter_control_settings *)0) 
                                                            #line 4293 
                                                            return I40E_ERR_PARAM;
  #line 4296 
  ret = i40e_validate_filter_settings(hw,settings);
  #line 4297 
  if (ret != I40E_SUCCESS) 
                           #line 4298 
                           return ret;
  #line 4301 
  val = i40e_read_rx_ctl(hw,1837760U);
  #line 4304 
  val &= 4294967264U;
  #line 4305 
  val = ((unsigned int)settings->pe_filt_num & 31U) | val;
  #line 4308 
  val &= 4294966303U;
  #line 4309 
  val = (((unsigned int)settings->pe_cntx_num << 5) & 992U) | val;
  #line 4313 
  val &= 4294951935U;
  #line 4314 
  val = (((unsigned int)settings->fcoe_filt_num << 10) & 15360U) | val;
  #line 4318 
  val &= 4294918143U;
  #line 4319 
  val = (((unsigned int)settings->fcoe_cntx_num << 14) & 65535U) | val;
  #line 4324 
  val &= 4294901759U;
  #line 4325 
  if (settings->hash_lut_size == (unsigned int)I40E_HASH_LUT_SIZE_512) 
    #line 4326 
    hash_lut_size = 1U;
  #line 4327 
  val = ((hash_lut_size << 16) & 65536U) | val;
  #line 4331 
  if ((int)settings->enable_fdir != 0) 
                                       #line 4332 
                                       val |= 131072U;
  #line 4333 
  if ((int)settings->enable_ethtype != 0) 
                                          #line 4334 
                                          val |= 262144U;
  #line 4335 
  if ((int)settings->enable_macvlan != 0) 
                                          #line 4336 
                                          val |= 524288U;
  #line 4338 
  i40e_write_rx_ctl(hw,1837760U,val);
  #line 4340 
  return I40E_SUCCESS;
}

#line 4359  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_add_rem_control_packet_filter(struct i40e_hw *hw, u8 *mac_addr, u16 ethtype, u16 flags, u16 vsi_seid, u16 queue, bool is_add, struct i40e_control_filter_stats *stats, struct i40e_asq_cmd_details *cmd_details)
{
  #line 4365 
  struct i40e_aq_desc desc;
  #line 4372 
  i40e_status status;
  #line 4366 
  struct i40e_aqc_add_remove_control_packet_filter *cmd = (struct i40e_aqc_add_remove_control_packet_filter *)(& desc.params.raw);
  #line 4369 
  struct i40e_aqc_add_remove_control_packet_filter_completion *resp = (struct i40e_aqc_add_remove_control_packet_filter_completion *)(& desc.params.raw);
  #line 4374 
  if ((unsigned int)vsi_seid == 0U) 
                                    #line 4375 
                                    return I40E_ERR_PARAM;
  #line 4377 
  if ((int)is_add != 0) {
    #line 4378 
    i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)602);
    #line 4380 
    cmd->queue = queue;
  }
  else 
       #line 4382 
       i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)603);
  #line 4386 
  if (mac_addr != (u8 *)0U) 
                            #line 4387 
                            ether_addr_copy((u8 *)(& cmd->mac),mac_addr);
  #line 4389 
  cmd->etype = ethtype;
  #line 4390 
  cmd->flags = flags;
  #line 4391 
  cmd->seid = vsi_seid;
  #line 4393 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 4395 
  if (status == I40E_SUCCESS && stats != (struct i40e_control_filter_stats *)0) {
    #line 4396 
    stats->mac_etype_used = resp->mac_etype_used;
    #line 4397 
    stats->etype_used = resp->etype_used;
    #line 4398 
    stats->mac_etype_free = resp->mac_etype_free;
    #line 4399 
    stats->etype_free = resp->etype_free;
  }
  #line 4402 
  return status;
}

#line 4410  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_add_filter_to_drop_tx_flow_control_frames(struct i40e_hw *hw, u16 seid)
{
  #line 4418 
  i40e_status status;
  #line 4414 
  u16 flag = (unsigned short)11U;
  #line 4417 
  u16 ethtype = (unsigned short)34824U;
  #line 4420 
  status = i40e_aq_add_rem_control_packet_filter(hw,(u8 *)0U,(unsigned short)((int)ethtype),(unsigned short)((int)flag),(unsigned short)((int)seid),(unsigned short)0,(_Bool)1,(struct i40e_control_filter_stats *)0,(struct i40e_asq_cmd_details *)0);
  #line 4423 
  if (status != I40E_SUCCESS) {
    #line 4424 
    bool branch;
    #line 4424 
    struct _ddebug __UNIQUE_ID_ddebug572 = {.modname = (char *)"i40e", .function = (char *)"i40e_add_filter_to_drop_tx_flow_control_frames", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c", .format = (char *)"Ethtype Filter Add failed: Error pruning Tx flow control frames\n", .lineno = (unsigned int)4424U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 4424 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug572.key.dd_key_false.key,(_Bool)0);
    #line 4424 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 4424 
                                                __dynamic_dev_dbg(& __UNIQUE_ID_ddebug572,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"Ethtype Filter Add failed: Error pruning Tx flow control frames\n");
  }
  #line 4426 
  return;
}

#line 4440  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static i40e_status i40e_aq_alternate_read(struct i40e_hw *hw, u32 reg_addr0, u32 *reg_val0, u32 reg_addr1, u32 *reg_val1)
{
  #line 4444 
  struct i40e_aq_desc desc;
  #line 4447 
  i40e_status status;
  #line 4445 
  struct i40e_aqc_alternate_write *cmd_resp = (struct i40e_aqc_alternate_write *)(& desc.params.raw);
  #line 4449 
  if (reg_val0 == (u32 *)0U) 
                             #line 4450 
                             return I40E_ERR_PARAM;
  #line 4452 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)2306);
  #line 4453 
  cmd_resp->address0 = reg_addr0;
  #line 4454 
  cmd_resp->address1 = reg_addr1;
  #line 4456 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,(struct i40e_asq_cmd_details *)0);
  #line 4458 
  if (status == I40E_SUCCESS) {
    #line 4459 
    *reg_val0 = cmd_resp->data0;
    #line 4461 
    if (reg_val1 != (u32 *)0U) 
                               #line 4462 
                               *reg_val1 = cmd_resp->data1;
  }
  #line 4465 
  return status;
}

#line 4475  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_resume_port_tx(struct i40e_hw *hw, struct i40e_asq_cmd_details *cmd_details)
{
  #line 4478 
  struct i40e_aq_desc desc;
  #line 4479 
  i40e_status status;
  #line 4481 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1052);
  #line 4483 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 4485 
  return status;
}

#line 4495  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_set_pci_config_data(struct i40e_hw *hw, u16 link_status)
{
  #line 4497 
  hw->bus.type = i40e_bus_type_pci_express;
  #line 4499 
  switch ((int)link_status & 1008) {
    #line 4500 
    case 16: 
             #line 4500 
    ;
    #line 4501 
    hw->bus.width = i40e_bus_width_pcie_x1;
    #line 4502 
    break;
    #line 4503 
    case 32: 
             #line 4503 
    ;
    #line 4504 
    hw->bus.width = i40e_bus_width_pcie_x2;
    #line 4505 
    break;
    #line 4506 
    case 64: 
             #line 4506 
    ;
    #line 4507 
    hw->bus.width = i40e_bus_width_pcie_x4;
    #line 4508 
    break;
    #line 4509 
    case 128: 
              #line 4509 
    ;
    #line 4510 
    hw->bus.width = i40e_bus_width_pcie_x8;
    #line 4511 
    break;
    #line 4512 
    default: 
             #line 4512 
    ;
    #line 4513 
    hw->bus.width = i40e_bus_width_unknown;
    #line 4514 
    break;
  }
  #line 4517 
  switch ((int)link_status & 15) {
    #line 4518 
    case 1: 
            #line 4518 
    ;
    #line 4519 
    hw->bus.speed = i40e_bus_speed_2500;
    #line 4520 
    break;
    #line 4521 
    case 2: 
            #line 4521 
    ;
    #line 4522 
    hw->bus.speed = i40e_bus_speed_5000;
    #line 4523 
    break;
    #line 4524 
    case 3: 
            #line 4524 
    ;
    #line 4525 
    hw->bus.speed = i40e_bus_speed_8000;
    #line 4526 
    break;
    #line 4527 
    default: 
             #line 4527 
    ;
    #line 4528 
    hw->bus.speed = i40e_bus_speed_unknown;
    #line 4529 
    break;
  }
  #line 4531 
  return;
}

#line 4549  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_debug_dump(struct i40e_hw *hw, u8 cluster_id, u8 table_id, u32 start_index, u16 buff_size, void *buff, u16 *ret_buff_size, u8 *ret_next_table, u32 *ret_next_index, struct i40e_asq_cmd_details *cmd_details)
{
  #line 4555 
  struct i40e_aq_desc desc;
  #line 4560 
  i40e_status status;
  #line 4556 
  struct i40e_aqc_debug_dump_internals *cmd = (struct i40e_aqc_debug_dump_internals *)(& desc.params.raw);
  #line 4558 
  struct i40e_aqc_debug_dump_internals *resp = (struct i40e_aqc_debug_dump_internals *)(& desc.params.raw);
  #line 4562 
  if ((unsigned int)buff_size == 0U || buff == (void *)0) 
                                                          #line 4563 
                                                          return I40E_ERR_PARAM;
  #line 4565 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)65288);
  #line 4568 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  #line 4569 
  if ((unsigned int)buff_size > 512U) 
                                      #line 4570 
                                      desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
  #line 4572 
  cmd->cluster_id = cluster_id;
  #line 4573 
  cmd->table_id = table_id;
  #line 4574 
  cmd->idx = start_index;
  #line 4576 
  desc.datalen = buff_size;
  #line 4578 
  status = i40e_asq_send_command(hw,& desc,buff,(unsigned short)((int)buff_size),cmd_details);
  #line 4579 
  if (status == I40E_SUCCESS) {
    #line 4580 
    if (ret_buff_size != (u16 *)0U) 
                                    #line 4581 
                                    *ret_buff_size = desc.datalen;
    #line 4582 
    if (ret_next_table != (u8 *)0U) 
                                    #line 4583 
                                    *ret_next_table = resp->table_id;
    #line 4584 
    if (ret_next_index != (u32 *)0U) 
                                     #line 4585 
                                     *ret_next_index = resp->idx;
  }
  #line 4588 
  return status;
}

#line 4601  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_read_bw_from_alt_ram(struct i40e_hw *hw, u32 *max_bw, u32 *min_bw, bool *min_valid, bool *max_valid)
{
  #line 4605 
  i40e_status status;
  #line 4606 
  u32 max_bw_addr;
  #line 4606 
  u32 min_bw_addr;
  #line 4609 
  max_bw_addr = (unsigned int)((int)hw->pf_id * 64 + 15);
  #line 4612 
  min_bw_addr = (unsigned int)((int)hw->pf_id * 64 + 14);
  #line 4617 
  status = i40e_aq_alternate_read(hw,max_bw_addr,max_bw,min_bw_addr,min_bw);
  #line 4620 
  if ((*min_bw & 2147483648U) != 0U) 
                                     #line 4621 
                                     *min_valid = (_Bool)1; else 
                                                                 #line 4623 
                                                                 *min_valid = (_Bool)0;
  #line 4625 
  if ((*max_bw & 2147483648U) != 0U) 
                                     #line 4626 
                                     *max_valid = (_Bool)1; else 
                                                                 #line 4628 
                                                                 *max_valid = (_Bool)0;
  #line 4630 
  return status;
}

#line 4641  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_configure_partition_bw(struct i40e_hw *hw, struct i40e_aqc_configure_partition_bw_data *bw_data, struct i40e_asq_cmd_details *cmd_details)
{
  #line 4645 
  i40e_status status;
  #line 4646 
  struct i40e_aq_desc desc;
  #line 4647 
  u16 bwd_size = (unsigned short)34U;
  #line 4649 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1053);
  #line 4653 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  #line 4654 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 1024U);
  #line 4656 
  if ((unsigned int)bwd_size > 512U) 
                                     #line 4657 
                                     desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
  #line 4659 
  desc.datalen = bwd_size;
  #line 4661 
  status = i40e_asq_send_command(hw,& desc,(void *)bw_data,(unsigned short)((int)bwd_size),cmd_details);
  #line 4664 
  return status;
}

#line 4676  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_read_phy_register_clause22(struct i40e_hw *hw, u16 reg, u8 phy_addr, u16 *value)
{
  #line 4679 
  i40e_status status = -37;
  #line 4680 
  u8 port_num = (unsigned char)hw->func_caps.mdio_port_num;
  #line 4681 
  u32 command = 0U;
  #line 4682 
  u16 retry = (unsigned short)1000U;
  #line 4684 
  command = (unsigned int)(((int)reg << 16) | ((int)phy_addr << 21)) | 1476395008U;
  #line 4689 
  writel(command,(void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139363) * 4)));
  #line 4690 
  while (1) {
    #line 4691 
    command = readl((void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139363) * 4)));
    #line 4692 
    if ((command & 1073741824U) == 0U) {
      #line 4693 
      status = I40E_SUCCESS;
      #line 4694 
      break;
    }
    #line 4696 
    __const_udelay(42950UL);
    #line 4697 
    retry = (u16)((int)retry - 1);
    #line 4698 
    if (! ((unsigned int)retry != 0U)) 
                                       #line 4690 
                                       break;
  }
  #line 4700 
  if (status != I40E_SUCCESS) {
    #line 4701 
    if ((hw->debug_mask & 32U) != 0U) 
                                      #line 4701 
                                      printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
  }
  else {
    #line 4704 
    command = readl((void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139367) * 4)));
    #line 4705 
    *value = (unsigned short)(command >> 16);
  }
  #line 4709 
  return status;
}

#line 4721  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_write_phy_register_clause22(struct i40e_hw *hw, u16 reg, u8 phy_addr, u16 value)
{
  #line 4724 
  i40e_status status = -37;
  #line 4725 
  u8 port_num = (unsigned char)hw->func_caps.mdio_port_num;
  #line 4726 
  u32 command = 0U;
  #line 4727 
  u16 retry = (unsigned short)1000U;
  #line 4729 
  command = (unsigned int)value;
  #line 4730 
  writel(command,(void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139367) * 4)));
  #line 4732 
  command = (unsigned int)(((int)reg << 16) | ((int)phy_addr << 21)) | 1409286144U;
  #line 4738 
  writel(command,(void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139363) * 4)));
  #line 4739 
  while (1) {
    #line 4740 
    command = readl((void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139363) * 4)));
    #line 4741 
    if ((command & 1073741824U) == 0U) {
      #line 4742 
      status = I40E_SUCCESS;
      #line 4743 
      break;
    }
    #line 4745 
    __const_udelay(42950UL);
    #line 4746 
    retry = (u16)((int)retry - 1);
    #line 4747 
    if (! ((unsigned int)retry != 0U)) 
                                       #line 4739 
                                       break;
  }
  #line 4749 
  return status;
}

#line 4762  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_read_phy_register_clause45(struct i40e_hw *hw, u8 page, u16 reg, u8 phy_addr, u16 *value)
{
  #line 4765 
  i40e_status status = -37;
  #line 4766 
  u32 command = 0U;
  #line 4767 
  u16 retry = (unsigned short)1000U;
  #line 4768 
  u8 port_num = (unsigned char)hw->func_caps.mdio_port_num;
  #line 4770 
  command = (unsigned int)(((int)reg | ((int)page << 16)) | ((int)phy_addr << 21)) | 3221225472U;
  #line 4777 
  writel(command,(void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139363) * 4)));
  #line 4778 
  while (1) {
    #line 4779 
    command = readl((void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139363) * 4)));
    #line 4780 
    if ((command & 1073741824U) == 0U) {
      #line 4781 
      status = I40E_SUCCESS;
      #line 4782 
      break;
    }
    #line 4784 
    usleep_range(10UL,20UL);
    #line 4785 
    retry = (u16)((int)retry - 1);
    #line 4786 
    if (! ((unsigned int)retry != 0U)) 
                                       #line 4778 
                                       break;
  }
  #line 4788 
  if (status != I40E_SUCCESS) {
    #line 4789 
    if ((hw->debug_mask & 32U) != 0U) 
                                      #line 4789 
                                      printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
    #line 4791 
    goto phy_read_end;
  }
  #line 4794 
  command = (unsigned int)(((int)page << 16) | ((int)phy_addr << 21)) | 3422552064U;
  #line 4800 
  status = I40E_ERR_TIMEOUT;
  #line 4801 
  retry = (unsigned short)1000U;
  #line 4802 
  writel(command,(void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139363) * 4)));
  #line 4803 
  while (1) {
    #line 4804 
    command = readl((void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139363) * 4)));
    #line 4805 
    if ((command & 1073741824U) == 0U) {
      #line 4806 
      status = I40E_SUCCESS;
      #line 4807 
      break;
    }
    #line 4809 
    usleep_range(10UL,20UL);
    #line 4810 
    retry = (u16)((int)retry - 1);
    #line 4811 
    if (! ((unsigned int)retry != 0U)) 
                                       #line 4803 
                                       break;
  }
  #line 4813 
  if (status == I40E_SUCCESS) {
    #line 4814 
    command = readl((void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139367) * 4)));
    #line 4815 
    *value = (unsigned short)(command >> 16);
  }
  else 
    #line 4818 
    if ((hw->debug_mask & 32U) != 0U) 
                                      #line 4818 
                                      printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
  #line 4822 
  phy_read_end: 
                #line 4822 
  ;
  #line 4823 
  return status;
}

#line 4836  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_write_phy_register_clause45(struct i40e_hw *hw, u8 page, u16 reg, u8 phy_addr, u16 value)
{
  #line 4839 
  i40e_status status = -37;
  #line 4840 
  u32 command = 0U;
  #line 4841 
  u16 retry = (unsigned short)1000U;
  #line 4842 
  u8 port_num = (unsigned char)hw->func_caps.mdio_port_num;
  #line 4844 
  command = (unsigned int)(((int)reg | ((int)page << 16)) | ((int)phy_addr << 21)) | 3221225472U;
  #line 4851 
  writel(command,(void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139363) * 4)));
  #line 4852 
  while (1) {
    #line 4853 
    command = readl((void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139363) * 4)));
    #line 4854 
    if ((command & 1073741824U) == 0U) {
      #line 4855 
      status = I40E_SUCCESS;
      #line 4856 
      break;
    }
    #line 4858 
    usleep_range(10UL,20UL);
    #line 4859 
    retry = (u16)((int)retry - 1);
    #line 4860 
    if (! ((unsigned int)retry != 0U)) 
                                       #line 4852 
                                       break;
  }
  #line 4861 
  if (status != I40E_SUCCESS) {
    #line 4862 
    if ((hw->debug_mask & 32U) != 0U) 
                                      #line 4862 
                                      printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
    #line 4864 
    goto phy_write_end;
  }
  #line 4867 
  command = (unsigned int)value;
  #line 4868 
  writel(command,(void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139367) * 4)));
  #line 4870 
  command = (unsigned int)(((int)page << 16) | ((int)phy_addr << 21)) | 3288334336U;
  #line 4876 
  status = I40E_ERR_TIMEOUT;
  #line 4877 
  retry = (unsigned short)1000U;
  #line 4878 
  writel(command,(void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139363) * 4)));
  #line 4879 
  while (1) {
    #line 4880 
    command = readl((void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139363) * 4)));
    #line 4881 
    if ((command & 1073741824U) == 0U) {
      #line 4882 
      status = I40E_SUCCESS;
      #line 4883 
      break;
    }
    #line 4885 
    usleep_range(10UL,20UL);
    #line 4886 
    retry = (u16)((int)retry - 1);
    #line 4887 
    if (! ((unsigned int)retry != 0U)) 
                                       #line 4879 
                                       break;
  }
  #line 4889 
  phy_write_end: 
                 #line 4889 
  ;
  #line 4890 
  return status;
}

#line 4903  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_write_phy_register(struct i40e_hw *hw, u8 page, u16 reg, u8 phy_addr, u16 value)
{
  #line 4906 
  i40e_status status;
  #line 4908 
  switch ((int)hw->device_id) {
    #line 4909 
    case 14289: 
                #line 4909 
    ;
    #line 4910 
    status = i40e_write_phy_register_clause22(hw,(unsigned short)((int)reg),(unsigned char)((int)phy_addr),(unsigned short)((int)value));
    #line 4912 
    break;
    #line 4913 
    case 5510: 
               #line 4913 
    ;
    #line 4914 
    case 5513: 
               #line 4914 
    ;
    #line 4915 
    case 5631: 
               #line 4915 
    ;
    #line 4916 
    case 14290: 
                #line 4916 
    ;
    #line 4917 
    case 5514: 
               #line 4917 
    ;
    #line 4918 
    case 5515: 
               #line 4918 
    ;
    #line 4919 
    status = i40e_write_phy_register_clause45(hw,(unsigned char)((int)page),(unsigned short)((int)reg),(unsigned char)((int)phy_addr),(unsigned short)((int)value));
    #line 4921 
    break;
    #line 4922 
    default: 
             #line 4922 
    ;
    #line 4923 
    status = I40E_ERR_UNKNOWN_PHY;
    #line 4924 
    break;
  }
  #line 4927 
  return status;
}

#line 4940  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_read_phy_register(struct i40e_hw *hw, u8 page, u16 reg, u8 phy_addr, u16 *value)
{
  #line 4943 
  i40e_status status;
  #line 4945 
  switch ((int)hw->device_id) {
    #line 4946 
    case 14289: 
                #line 4946 
    ;
    #line 4947 
    status = i40e_read_phy_register_clause22(hw,(unsigned short)((int)reg),(unsigned char)((int)phy_addr),value);
    #line 4949 
    break;
    #line 4950 
    case 5510: 
               #line 4950 
    ;
    #line 4951 
    case 5513: 
               #line 4951 
    ;
    #line 4952 
    case 5631: 
               #line 4952 
    ;
    #line 4953 
    case 14290: 
                #line 4953 
    ;
    #line 4954 
    case 5514: 
               #line 4954 
    ;
    #line 4955 
    case 5515: 
               #line 4955 
    ;
    #line 4956 
    status = i40e_read_phy_register_clause45(hw,(unsigned char)((int)page),(unsigned short)((int)reg),(unsigned char)((int)phy_addr),value);
    #line 4958 
    break;
    #line 4959 
    default: 
             #line 4959 
    ;
    #line 4960 
    status = I40E_ERR_UNKNOWN_PHY;
    #line 4961 
    break;
  }
  #line 4964 
  return status;
}

#line 4974  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
u8 i40e_get_phy_address(struct i40e_hw *hw, u8 dev_num)
{
  #line 4976 
  u8 port_num = (unsigned char)hw->func_caps.mdio_port_num;
  #line 4977 
  u32 reg_val = readl((void *)(hw->hw_addr + (unsigned long)(((int)port_num + 139376) * 4)));
  #line 4979 
  return (unsigned char)((unsigned int)((unsigned char)(reg_val >> ((int)dev_num + 1) * 5)) & 31U);
}

#line 4990  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_blink_phy_link_led(struct i40e_hw *hw, u32 time, u32 interval)
{
  #line 4994 
  u32 i;
  #line 4995 
  u16 led_ctl;
  #line 4996 
  u16 gpio_led_port;
  #line 4997 
  u16 led_reg;
  #line 5000 
  u8 port_num;
  #line 4993 
  i40e_status status = 0;
  #line 4998 
  u16 led_addr = (unsigned short)50224U;
  #line 4999 
  u8 phy_addr = (unsigned char)0U;
  #line 5002 
  i = readl((void *)(hw->hw_addr + 1836160U));
  #line 5003 
  port_num = (unsigned char)((unsigned int)((unsigned char)i) & 3U);
  #line 5004 
  phy_addr = i40e_get_phy_address(hw,(unsigned char)((int)port_num));
  #line 5006 
  gpio_led_port = (unsigned short)0U;
  #line 5006 
  while ((unsigned int)gpio_led_port <= 2U) {
    #line 5008 
    status = i40e_read_phy_register_clause45(hw,(unsigned char)30,(unsigned short)((int)led_addr),(unsigned char)((int)phy_addr),& led_reg);
    #line 5012 
    if (status != I40E_SUCCESS) 
                                #line 5013 
                                goto phy_blinking_end;
    #line 5014 
    led_ctl = led_reg;
    #line 5015 
    if (((int)led_reg & 240) != 0) {
      #line 5016 
      led_reg = (unsigned short)0U;
      #line 5017 
      status = i40e_write_phy_register_clause45(hw,(unsigned char)30,(unsigned short)((int)led_addr),(unsigned char)((int)phy_addr),(unsigned short)((int)led_reg));
      #line 5021 
      if (status != I40E_SUCCESS) 
                                  #line 5022 
                                  goto phy_blinking_end;
      #line 5023 
      break;
    }
    #line 5006 
    gpio_led_port = (u16)((int)gpio_led_port + 1);
    #line 5006 
    led_addr = (u16)((int)led_addr + 1);
  }
  #line 5027 
  if (time != 0U && interval != 0U) {
    #line 5028 
    i = 0U;
    #line 5028 
    while (time * 1000U > i) {
      #line 5029 
      status = i40e_read_phy_register_clause45(hw,(unsigned char)30,(unsigned short)((int)led_addr),(unsigned char)((int)phy_addr),& led_reg);
      #line 5032 
      if (status != I40E_SUCCESS) 
                                  #line 5033 
                                  goto restore_config;
      #line 5034 
      if (((int)led_reg & 256) != 0) 
                                     #line 5035 
                                     led_reg = (unsigned short)0U; else 
                                                                    #line 5037 
                                                                    led_reg = (unsigned short)256U;
      #line 5038 
      status = i40e_write_phy_register_clause45(hw,(unsigned char)30,(unsigned short)((int)led_addr),(unsigned char)((int)phy_addr),(unsigned short)((int)led_reg));
      #line 5041 
      if (status != I40E_SUCCESS) 
                                  #line 5042 
                                  goto restore_config;
      #line 5043 
      msleep(interval);
      #line 5028 
      i += interval;
    }
  }
  #line 5047 
  restore_config: 
                  #line 5047 
  ;
  #line 5048 
  status = i40e_write_phy_register_clause45(hw,(unsigned char)30,(unsigned short)((int)led_addr),(unsigned char)((int)phy_addr),(unsigned short)((int)led_ctl));
  #line 5052 
  phy_blinking_end: 
                    #line 5052 
  ;
  #line 5053 
  return status;
}

#line 5062  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static enum i40e_status_code i40e_led_get_reg(struct i40e_hw *hw, u16 led_addr, u32 *reg_val)
{
  #line 5065 
  enum i40e_status_code status;
  #line 5067 
  u8 port_num;
  #line 5068 
  u32 i;
  #line 5066 
  u8 phy_addr = (unsigned char)0U;
  #line 5070 
  *reg_val = 0U;
  #line 5071 
  if ((hw->flags & 4ULL) != 0ULL) 
                                  #line 5072 
                                  status = i40e_aq_get_phy_register_ext(hw,(unsigned char)1,(unsigned char)30,(_Bool)1,(_Bool)0,(unsigned char)0,50224U,reg_val,(struct i40e_asq_cmd_details *)0);
  else {
    #line 5079 
    i = readl((void *)(hw->hw_addr + 1836160U));
    #line 5080 
    port_num = (unsigned char)((unsigned int)((unsigned char)i) & 3U);
    #line 5081 
    phy_addr = i40e_get_phy_address(hw,(unsigned char)((int)port_num));
    #line 5082 
    status = i40e_read_phy_register_clause45(hw,(unsigned char)30,(unsigned short)((int)led_addr),(unsigned char)((int)phy_addr),(u16 *)reg_val);
  }
  #line 5087 
  return status;
}

#line 5096  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static enum i40e_status_code i40e_led_set_reg(struct i40e_hw *hw, u16 led_addr, u32 reg_val)
{
  #line 5099 
  enum i40e_status_code status;
  #line 5101 
  u8 port_num;
  #line 5102 
  u32 i;
  #line 5100 
  u8 phy_addr = (unsigned char)0U;
  #line 5104 
  if ((hw->flags & 4ULL) != 0ULL) 
                                  #line 5105 
                                  status = i40e_aq_set_phy_register_ext(hw,(unsigned char)1,(unsigned char)30,(_Bool)1,(_Bool)0,(unsigned char)0,50224U,reg_val,(struct i40e_asq_cmd_details *)0);
  else {
    #line 5112 
    i = readl((void *)(hw->hw_addr + 1836160U));
    #line 5113 
    port_num = (unsigned char)((unsigned int)((unsigned char)i) & 3U);
    #line 5114 
    phy_addr = i40e_get_phy_address(hw,(unsigned char)((int)port_num));
    #line 5115 
    status = i40e_write_phy_register_clause45(hw,(unsigned char)30,(unsigned short)((int)led_addr),(unsigned char)((int)phy_addr),(unsigned short)((int)((unsigned short)reg_val)));
  }
  #line 5121 
  return status;
}

#line 5131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_led_get_phy(struct i40e_hw *hw, u16 *led_addr, u16 *val)
{
  #line 5135 
  u16 gpio_led_port;
  #line 5137 
  u16 reg_val;
  #line 5138 
  u16 temp_addr;
  #line 5139 
  u8 port_num;
  #line 5140 
  u32 i;
  #line 5141 
  u32 reg_val_aq;
  #line 5134 
  i40e_status status = 0;
  #line 5136 
  u8 phy_addr = (unsigned char)0U;
  #line 5143 
  if ((hw->flags & 4ULL) != 0ULL) {
    #line 5144 
    status = i40e_aq_get_phy_register_ext(hw,(unsigned char)1,(unsigned char)30,(_Bool)1,(_Bool)0,(unsigned char)0,50224U,& reg_val_aq,(struct i40e_asq_cmd_details *)0);
    #line 5150 
    if (status == I40E_SUCCESS) 
                                #line 5151 
                                *val = (unsigned short)reg_val_aq;
    #line 5152 
    return status;
  }
  #line 5154 
  temp_addr = (unsigned short)50224U;
  #line 5155 
  i = readl((void *)(hw->hw_addr + 1836160U));
  #line 5156 
  port_num = (unsigned char)((unsigned int)((unsigned char)i) & 3U);
  #line 5157 
  phy_addr = i40e_get_phy_address(hw,(unsigned char)((int)port_num));
  #line 5159 
  gpio_led_port = (unsigned short)0U;
  #line 5159 
  while ((unsigned int)gpio_led_port <= 2U) {
    #line 5161 
    status = i40e_read_phy_register_clause45(hw,(unsigned char)30,(unsigned short)((int)temp_addr),(unsigned char)((int)phy_addr),& reg_val);
    #line 5165 
    if (status != I40E_SUCCESS) 
                                #line 5166 
                                return status;
    #line 5167 
    *val = reg_val;
    #line 5168 
    if (((int)reg_val & 240) != 0) {
      #line 5169 
      *led_addr = temp_addr;
      #line 5170 
      break;
    }
    #line 5159 
    gpio_led_port = (u16)((int)gpio_led_port + 1);
    #line 5159 
    temp_addr = (u16)((int)temp_addr + 1);
  }
  #line 5173 
  return status;
}

#line 5186  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_led_set_phy(struct i40e_hw *hw, bool on, u16 led_addr, u32 mode)
{
  #line 5189 
  i40e_status status = 0;
  #line 5190 
  u32 led_ctl = 0U;
  #line 5191 
  u32 led_reg = 0U;
  #line 5193 
  status = i40e_led_get_reg(hw,(unsigned short)((int)led_addr),& led_reg);
  #line 5194 
  if (status != I40E_SUCCESS) 
                              #line 5195 
                              return status;
  #line 5196 
  led_ctl = led_reg;
  #line 5197 
  if ((led_reg & 240U) != 0U) {
    #line 5198 
    led_reg = 0U;
    #line 5199 
    status = i40e_led_set_reg(hw,(unsigned short)((int)led_addr),led_reg);
    #line 5200 
    if (status != I40E_SUCCESS) 
                                #line 5201 
                                return status;
  }
  #line 5203 
  status = i40e_led_get_reg(hw,(unsigned short)((int)led_addr),& led_reg);
  #line 5204 
  if (status != I40E_SUCCESS) 
                              #line 5205 
                              goto restore_config;
  #line 5206 
  if ((int)on != 0) 
                    #line 5207 
                    led_reg = 256U; else 
                                         #line 5209 
                                         led_reg = 0U;
  #line 5211 
  status = i40e_led_set_reg(hw,(unsigned short)((int)led_addr),led_reg);
  #line 5212 
  if (status != I40E_SUCCESS) 
                              #line 5213 
                              goto restore_config;
  #line 5214 
  if ((mode & 2147483648U) != 0U) {
    #line 5215 
    led_ctl = mode & 65535U;
    #line 5216 
    status = i40e_led_set_reg(hw,(unsigned short)((int)led_addr),led_ctl);
  }
  #line 5218 
  return status;
  #line 5220 
  restore_config: 
                  #line 5220 
  ;
  #line 5221 
  status = i40e_led_set_reg(hw,(unsigned short)((int)led_addr),led_ctl);
  #line 5222 
  return status;
}

#line 5235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_rx_ctl_read_register(struct i40e_hw *hw, u32 reg_addr, u32 *reg_val, struct i40e_asq_cmd_details *cmd_details)
{
  #line 5239 
  struct i40e_aq_desc desc;
  #line 5242 
  i40e_status status;
  #line 5240 
  struct i40e_aqc_rx_ctl_reg_read_write *cmd_resp = (struct i40e_aqc_rx_ctl_reg_read_write *)(& desc.params.raw);
  #line 5244 
  if (reg_val == (u32 *)0U) 
                            #line 5245 
                            return I40E_ERR_PARAM;
  #line 5247 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)518);
  #line 5249 
  cmd_resp->address = reg_addr;
  #line 5251 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 5253 
  if (status == I40E_SUCCESS) 
                              #line 5254 
                              *reg_val = cmd_resp->value;
  #line 5256 
  return status;
}

#line 5264  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
u32 i40e_read_rx_ctl(struct i40e_hw *hw, u32 reg_addr)
{
  #line 5267 
  bool use_register;
  #line 5266 
  i40e_status status = 0;
  #line 5268 
  int retry = 5;
  #line 5269 
  u32 val = 0U;
  #line 5271 
  use_register = (_Bool)(((unsigned int)hw->aq.api_maj_ver == 1U && (unsigned int)hw->aq.api_min_ver <= 4U || hw->mac.type == (unsigned int)I40E_MAC_X722) != 0);
  #line 5274 
  if (! use_register) {
    #line 5275 
    do_retry: 
              #line 5275 
    ;
    #line 5276 
    status = i40e_aq_rx_ctl_read_register(hw,reg_addr,& val,(struct i40e_asq_cmd_details *)0);
    #line 5277 
    if (hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_EAGAIN && retry != 0) {
      #line 5278 
      usleep_range(1000UL,2000UL);
      #line 5279 
      retry --;
      #line 5280 
      goto do_retry;
    }
  }
  #line 5285 
  if (status != I40E_SUCCESS || (int)use_register != 0) 
                                                        #line 5286 
                                                        val = readl((void *)(hw->hw_addr + (unsigned long)reg_addr));
  #line 5288 
  return val;
}

#line 5301  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_rx_ctl_write_register(struct i40e_hw *hw, u32 reg_addr, u32 reg_val, struct i40e_asq_cmd_details *cmd_details)
{
  #line 5305 
  struct i40e_aq_desc desc;
  #line 5308 
  i40e_status status;
  #line 5306 
  struct i40e_aqc_rx_ctl_reg_read_write *cmd = (struct i40e_aqc_rx_ctl_reg_read_write *)(& desc.params.raw);
  #line 5310 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)519);
  #line 5312 
  cmd->address = reg_addr;
  #line 5313 
  cmd->value = reg_val;
  #line 5315 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 5317 
  return status;
}

#line 5326  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
void i40e_write_rx_ctl(struct i40e_hw *hw, u32 reg_addr, u32 reg_val)
{
  #line 5329 
  bool use_register;
  #line 5328 
  i40e_status status = 0;
  #line 5330 
  int retry = 5;
  #line 5332 
  use_register = (_Bool)(((unsigned int)hw->aq.api_maj_ver == 1U && (unsigned int)hw->aq.api_min_ver <= 4U || hw->mac.type == (unsigned int)I40E_MAC_X722) != 0);
  #line 5335 
  if (! use_register) {
    #line 5336 
    do_retry: 
              #line 5336 
    ;
    #line 5337 
    status = i40e_aq_rx_ctl_write_register(hw,reg_addr,reg_val,(struct i40e_asq_cmd_details *)0);
    #line 5339 
    if (hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_EAGAIN && retry != 0) {
      #line 5340 
      usleep_range(1000UL,2000UL);
      #line 5341 
      retry --;
      #line 5342 
      goto do_retry;
    }
  }
  #line 5347 
  if (status != I40E_SUCCESS || (int)use_register != 0) 
                                                        #line 5348 
                                                        writel(reg_val,(void *)(hw->hw_addr + (unsigned long)reg_addr));
  #line 5349 
  return;
}

#line 5358  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static void i40e_mdio_if_number_selection(struct i40e_hw *hw, bool set_mdio, u8 mdio_num, struct i40e_aqc_phy_register_access *cmd)
{
  #line 5362 
  if ((int)set_mdio != 0 && (unsigned int)cmd->phy_interface == 1U) 
    #line 5363 
    if ((hw->flags & 64ULL) != 0ULL) 
                                     #line 5364 
                                     cmd->cmd_flags = (unsigned char)(((unsigned int)cmd->cmd_flags | ((unsigned int)((unsigned char)((int)mdio_num << 2)) & 12U)) | 2U);
    else 
      #line 5370 
      if ((hw->debug_mask & 32U) != 0U) 
                                        #line 5370 
                                        printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
  #line 5371 
  return;
}

#line 5390  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_set_phy_register_ext(struct i40e_hw *hw, u8 phy_select, u8 dev_addr, bool page_change, bool set_mdio, u8 mdio_num, u32 reg_addr, u32 reg_val, struct i40e_asq_cmd_details *cmd_details)
{
  #line 5396 
  struct i40e_aq_desc desc;
  #line 5399 
  i40e_status status;
  #line 5397 
  struct i40e_aqc_phy_register_access *cmd = (struct i40e_aqc_phy_register_access *)(& desc.params.raw);
  #line 5401 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1576);
  #line 5404 
  cmd->phy_interface = phy_select;
  #line 5405 
  cmd->dev_address = dev_addr;
  #line 5406 
  cmd->reg_address = reg_addr;
  #line 5407 
  cmd->reg_value = reg_val;
  #line 5409 
  i40e_mdio_if_number_selection(hw,(_Bool)((bool)((int)set_mdio) != 0),(unsigned char)((int)mdio_num),cmd);
  #line 5411 
  if (! page_change) 
                     #line 5412 
                     cmd->cmd_flags = (unsigned char)1U;
  #line 5414 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 5416 
  return status;
}

#line 5434  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_get_phy_register_ext(struct i40e_hw *hw, u8 phy_select, u8 dev_addr, bool page_change, bool set_mdio, u8 mdio_num, u32 reg_addr, u32 *reg_val, struct i40e_asq_cmd_details *cmd_details)
{
  #line 5440 
  struct i40e_aq_desc desc;
  #line 5443 
  i40e_status status;
  #line 5441 
  struct i40e_aqc_phy_register_access *cmd = (struct i40e_aqc_phy_register_access *)(& desc.params.raw);
  #line 5445 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)1577);
  #line 5448 
  cmd->phy_interface = phy_select;
  #line 5449 
  cmd->dev_address = dev_addr;
  #line 5450 
  cmd->reg_address = reg_addr;
  #line 5452 
  i40e_mdio_if_number_selection(hw,(_Bool)((bool)((int)set_mdio) != 0),(unsigned char)((int)mdio_num),cmd);
  #line 5454 
  if (! page_change) 
                     #line 5455 
                     cmd->cmd_flags = (unsigned char)1U;
  #line 5457 
  status = i40e_asq_send_command(hw,& desc,(void *)0,(unsigned short)0,cmd_details);
  #line 5458 
  if (status == I40E_SUCCESS) 
                              #line 5459 
                              *reg_val = cmd->reg_value;
  #line 5461 
  return status;
}

#line 5475  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_write_ddp(struct i40e_hw *hw, void *buff, u16 buff_size, u32 track_id, u32 *error_offset, u32 *error_info, struct i40e_asq_cmd_details *cmd_details)
{
  #line 5480 
  struct i40e_aq_desc desc;
  #line 5484 
  struct i40e_aqc_write_ddp_resp *resp;
  #line 5485 
  i40e_status status;
  #line 5481 
  struct i40e_aqc_write_personalization_profile *cmd = (struct i40e_aqc_write_personalization_profile *)(& desc.params.raw);
  #line 5487 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)624);
  #line 5490 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  #line 5491 
  if ((unsigned int)buff_size > 512U) 
                                      #line 5492 
                                      desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
  #line 5494 
  desc.datalen = buff_size;
  #line 5496 
  cmd->profile_track_id = track_id;
  #line 5498 
  status = i40e_asq_send_command(hw,& desc,buff,(unsigned short)((int)buff_size),cmd_details);
  #line 5499 
  if (status == I40E_SUCCESS) {
    #line 5500 
    resp = (struct i40e_aqc_write_ddp_resp *)(& desc.params.raw);
    #line 5501 
    if (error_offset != (u32 *)0U) 
                                   #line 5502 
                                   *error_offset = resp->error_offset;
    #line 5503 
    if (error_info != (u32 *)0U) 
                                 #line 5504 
                                 *error_info = resp->error_info;
  }
  #line 5507 
  return status;
}

#line 5519  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
i40e_status i40e_aq_get_ddp_list(struct i40e_hw *hw, void *buff, u16 buff_size, u8 flags, struct i40e_asq_cmd_details *cmd_details)
{
  #line 5523 
  struct i40e_aq_desc desc;
  #line 5526 
  i40e_status status;
  #line 5524 
  struct i40e_aqc_get_applied_profiles *cmd = (struct i40e_aqc_get_applied_profiles *)(& desc.params.raw);
  #line 5528 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)625);
  #line 5531 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 4096U);
  #line 5532 
  if ((unsigned int)buff_size > 512U) 
                                      #line 5533 
                                      desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
  #line 5534 
  desc.datalen = buff_size;
  #line 5536 
  cmd->flags = flags;
  #line 5538 
  status = i40e_asq_send_command(hw,& desc,buff,(unsigned short)((int)buff_size),cmd_details);
  #line 5540 
  return status;
}

#line 5553  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
struct i40e_generic_seg_header *i40e_find_segment_in_package(u32 segment_type, struct i40e_package_header *pkg_hdr)
{
  #line 5556 
  struct i40e_generic_seg_header *segment;
  #line 5557 
  u32 i;
  #line 5560 
  i = 0U;
  #line 5560 
  while (pkg_hdr->segment_count > i) {
    #line 5561 
    segment = (struct i40e_generic_seg_header *)((u8 *)pkg_hdr + (unsigned long)pkg_hdr->segment_offset[i]);
    #line 5565 
    if (segment->type == segment_type) 
                                       #line 5566 
                                       return segment;
    #line 5560 
    i ++;
  }
  #line 5569 
  return (struct i40e_generic_seg_header *)0;
}

#line 5597  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
struct i40e_profile_section_header *i40e_find_section_in_profile(u32 section_type, struct i40e_profile_segment *profile)
{
  #line 5600 
  struct i40e_profile_section_header *sec;
  #line 5601 
  struct i40e_section_table *sec_tbl;
  #line 5602 
  u32 sec_off;
  #line 5603 
  u32 i;
  #line 5605 
  if (profile->header.type != 17U) 
                                   #line 5606 
                                   return (struct i40e_profile_section_header *)0;
  {
    #line 5608 
    u32 count;
    #line 5608 
    u32 *nvm;
    #line 5608 
    struct i40e_profile_segment *p = profile;
    #line 5608 
    count = p->device_table_count;
    #line 5608 
    nvm = (u32 *)(& p->device_table[count]);
    #line 5608 
    sec_tbl = (struct i40e_section_table *)(nvm + (unsigned long)(*nvm + 1U));
  }
  #line 5610 
  i = 0U;
  #line 5610 
  while (sec_tbl->section_count > i) {
    #line 5611 
    sec_off = sec_tbl->section_offset[i];
    #line 5612 
    sec = (struct i40e_profile_section_header *)((u8 *)profile + (unsigned long)sec_off);
    #line 5613 
    if (sec->section.type == section_type) 
                                           #line 5614 
                                           return sec;
    #line 5610 
    i ++;
  }
  #line 5617 
  return (struct i40e_profile_section_header *)0;
}

#line 5626  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static enum i40e_status_code i40e_ddp_exec_aq_section(struct i40e_hw *hw, struct i40e_profile_aq_section *aq)
{
  #line 5629 
  i40e_status status;
  #line 5630 
  struct i40e_aq_desc desc;
  #line 5632 
  u16 msglen;
  #line 5631 
  u8 *msg = (u8 *)0U;
  #line 5634 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)((int)aq->opcode));
  #line 5635 
  desc.flags = (unsigned short)((int)desc.flags | (int)aq->flags);
  #line 5636 
  memcpy((void *)(& desc.params.raw),(void *)(& aq->param),16UL);
  #line 5638 
  msglen = aq->datalen;
  #line 5639 
  if ((unsigned int)msglen != 0U) {
    #line 5640 
    desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
    #line 5642 
    if ((unsigned int)msglen > 512U) 
                                     #line 5643 
                                     desc.flags = (unsigned short)((unsigned int)desc.flags | 512U);
    #line 5644 
    desc.datalen = msglen;
    #line 5645 
    msg = & aq->data[0];
  }
  #line 5648 
  status = i40e_asq_send_command(hw,& desc,(void *)msg,(unsigned short)((int)msglen),(struct i40e_asq_cmd_details *)0);
  #line 5650 
  if (status != I40E_SUCCESS) {
    #line 5651 
    if ((hw->debug_mask & 8192U) != 0U) 
                                        #line 5651 
                                        printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)aq->opcode,(int)status);
    #line 5654 
    return status;
  }
  #line 5658 
  memcpy((void *)(& aq->param),(void *)(& desc.params.raw),16UL);
  #line 5660 
  return I40E_SUCCESS;
}

#line 5673  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
static enum i40e_status_code i40e_validate_profile(struct i40e_hw *hw, struct i40e_profile_segment *profile, u32 track_id, bool rollback)
{
  #line 5678 
  struct i40e_section_table *sec_tbl;
  #line 5679 
  u32 vendor_dev_id;
  #line 5680 
  u32 dev_cnt;
  #line 5681 
  u32 sec_off;
  #line 5682 
  u32 i;
  #line 5676 
  struct i40e_profile_section_header *sec = (struct i40e_profile_section_header *)0;
  #line 5677 
  i40e_status status = 0;
  #line 5684 
  if (track_id == 4294967295U) {
    #line 5685 
    if ((hw->debug_mask & 8192U) != 0U) 
                                        #line 5685 
                                        printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
    #line 5686 
    return I40E_NOT_SUPPORTED;
  }
  #line 5689 
  dev_cnt = profile->device_table_count;
  #line 5690 
  i = 0U;
  #line 5690 
  while (i < dev_cnt) {
    #line 5691 
    vendor_dev_id = profile->device_table[i].vendor_dev_id;
    #line 5692 
    if (vendor_dev_id >> 16 == 32902U && (unsigned int)hw->device_id == (vendor_dev_id & 65535U)) 
      #line 5694 
      break;
    #line 5690 
    i ++;
  }
  #line 5696 
  if (dev_cnt != 0U && i == dev_cnt) {
    #line 5697 
    if ((hw->debug_mask & 8192U) != 0U) 
                                        #line 5697 
                                        printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
    #line 5699 
    return I40E_ERR_DEVICE_NOT_SUPPORTED;
  }
  {
    #line 5702 
    u32 count;
    #line 5702 
    u32 *nvm;
    #line 5702 
    struct i40e_profile_segment *p = profile;
    #line 5702 
    count = p->device_table_count;
    #line 5702 
    nvm = (u32 *)(& p->device_table[count]);
    #line 5702 
    sec_tbl = (struct i40e_section_table *)(nvm + (unsigned long)(*nvm + 1U));
  }
  #line 5705 
  i = 0U;
  #line 5705 
  while (sec_tbl->section_count > i) {
    #line 5706 
    sec_off = sec_tbl->section_offset[i];
    #line 5707 
    sec = (struct i40e_profile_section_header *)((u8 *)profile + (unsigned long)sec_off);
    #line 5708 
    if ((int)rollback != 0) {
      #line 5709 
      if (sec->section.type + 4294965248U <= 1U || sec->section.type == 6145U) {
        #line 5712 
        if ((hw->debug_mask & 8192U) != 0U) 
                                            #line 5712 
                                            printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
        #line 5714 
        return I40E_NOT_SUPPORTED;
      }
    }
    else 
      #line 5717 
      if (sec->section.type + 4294961152U <= 1U) {
        #line 5719 
        if ((hw->debug_mask & 8192U) != 0U) 
                                            #line 5719 
                                            printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
        #line 5721 
        return I40E_NOT_SUPPORTED;
      }
    #line 5705 
    i ++;
  }
  #line 5726 
  return status;
}

#line 5738  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_write_profile(struct i40e_hw *hw, struct i40e_profile_segment *profile, u32 track_id)
{
  #line 5742 
  struct i40e_section_table *sec_tbl;
  #line 5744 
  struct i40e_profile_aq_section *ddp_aq;
  #line 5747 
  u32 sec_off;
  #line 5748 
  u32 i;
  #line 5741 
  i40e_status status = 0;
  #line 5743 
  struct i40e_profile_section_header *sec = (struct i40e_profile_section_header *)0;
  #line 5745 
  u32 section_size = 0U;
  #line 5746 
  u32 offset = 0U;
  #line 5746 
  u32 info = 0U;
  #line 5750 
  status = i40e_validate_profile(hw,profile,track_id,(_Bool)0);
  #line 5751 
  if (status != I40E_SUCCESS) 
                              #line 5752 
                              return status;
  {
    #line 5754 
    u32 count;
    #line 5754 
    u32 *nvm;
    #line 5754 
    struct i40e_profile_segment *p = profile;
    #line 5754 
    count = p->device_table_count;
    #line 5754 
    nvm = (u32 *)(& p->device_table[count]);
    #line 5754 
    sec_tbl = (struct i40e_section_table *)(nvm + (unsigned long)(*nvm + 1U));
  }
  #line 5756 
  i = 0U;
  #line 5756 
  while (sec_tbl->section_count > i) {
    #line 5757 
    sec_off = sec_tbl->section_offset[i];
    #line 5758 
    sec = (struct i40e_profile_section_header *)((u8 *)profile + (unsigned long)sec_off);
    #line 5760 
    if (sec->section.type == 2049U) {
      #line 5761 
      ddp_aq = (struct i40e_profile_aq_section *)(sec + 1U);
      #line 5762 
      status = i40e_ddp_exec_aq_section(hw,ddp_aq);
      #line 5763 
      if (status != I40E_SUCCESS) {
        #line 5764 
        if ((hw->debug_mask & 8192U) != 0U) 
                                            #line 5764 
                                            printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,i,(int)ddp_aq->opcode);
        #line 5767 
        break;
      }
      #line 5769 
      sec->section.type = 6145U;
    }
    #line 5773 
    if (sec->section.type != 2048U) 
                                    #line 5774 
                                    goto __Cont;
    #line 5776 
    section_size = sec->section.size + 16U;
    #line 5780 
    status = i40e_aq_write_ddp(hw,(void *)sec,(unsigned short)((int)((unsigned short)section_size)),track_id,& offset,& info,(struct i40e_asq_cmd_details *)0);
    #line 5782 
    if (status != I40E_SUCCESS) {
      #line 5783 
      if ((hw->debug_mask & 8192U) != 0U) 
                                          #line 5783 
                                          printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,i,offset,info);
      #line 5786 
      break;
    }
    #line 5756 
    __Cont: 
            #line 5756 
    i ++;
  }
  #line 5789 
  return status;
}

#line 5801  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_rollback_profile(struct i40e_hw *hw, struct i40e_profile_segment *profile, u32 track_id)
{
  #line 5806 
  struct i40e_section_table *sec_tbl;
  #line 5809 
  u32 sec_off;
  #line 5810 
  int i;
  #line 5804 
  struct i40e_profile_section_header *sec = (struct i40e_profile_section_header *)0;
  #line 5805 
  i40e_status status = 0;
  #line 5807 
  u32 offset = 0U;
  #line 5807 
  u32 info = 0U;
  #line 5808 
  u32 section_size = 0U;
  #line 5812 
  status = i40e_validate_profile(hw,profile,track_id,(_Bool)1);
  #line 5813 
  if (status != I40E_SUCCESS) 
                              #line 5814 
                              return status;
  {
    #line 5816 
    u32 count;
    #line 5816 
    u32 *nvm;
    #line 5816 
    struct i40e_profile_segment *p = profile;
    #line 5816 
    count = p->device_table_count;
    #line 5816 
    nvm = (u32 *)(& p->device_table[count]);
    #line 5816 
    sec_tbl = (struct i40e_section_table *)(nvm + (unsigned long)(*nvm + 1U));
  }
  #line 5819 
  i = (int)(sec_tbl->section_count + 4294967295U);
  #line 5819 
  while (i >= 0) {
    #line 5820 
    sec_off = sec_tbl->section_offset[i];
    #line 5821 
    sec = (struct i40e_profile_section_header *)((u8 *)profile + (unsigned long)sec_off);
    #line 5824 
    if (sec->section.type != 6144U) 
                                    #line 5825 
                                    goto __Cont;
    #line 5827 
    section_size = sec->section.size + 16U;
    #line 5831 
    status = i40e_aq_write_ddp(hw,(void *)sec,(unsigned short)((int)((unsigned short)section_size)),track_id,& offset,& info,(struct i40e_asq_cmd_details *)0);
    #line 5833 
    if (status != I40E_SUCCESS) {
      #line 5834 
      if ((hw->debug_mask & 8192U) != 0U) 
                                          #line 5834 
                                          printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,i,offset,info);
      #line 5837 
      break;
    }
    #line 5819 
    __Cont: 
            #line 5819 
    i --;
  }
  #line 5840 
  return status;
}

#line 5853  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_add_pinfo_to_list(struct i40e_hw *hw, struct i40e_profile_segment *profile, u8 *profile_info_sec, u32 track_id)
{
  #line 5859 
  struct i40e_profile_info *pinfo;
  #line 5857 
  i40e_status status = 0;
  #line 5858 
  struct i40e_profile_section_header *sec = (struct i40e_profile_section_header *)0;
  #line 5860 
  u32 offset = 0U;
  #line 5860 
  u32 info = 0U;
  #line 5862 
  sec = (struct i40e_profile_section_header *)profile_info_sec;
  #line 5863 
  sec->tbl_size = (unsigned short)1U;
  #line 5864 
  sec->data_end = (unsigned short)64U;
  #line 5866 
  sec->section.type = 16U;
  #line 5867 
  sec->section.offset = 16U;
  #line 5868 
  sec->section.size = 48U;
  #line 5869 
  pinfo = (struct i40e_profile_info *)(profile_info_sec + (unsigned long)sec->section.offset);
  #line 5871 
  pinfo->track_id = track_id;
  #line 5872 
  pinfo->version = profile->version;
  #line 5873 
  pinfo->op = (unsigned char)1U;
  #line 5874 
  memcpy((void *)(& pinfo->name),(void *)(& profile->name),32UL);
  #line 5876 
  status = i40e_aq_write_ddp(hw,(void *)sec,(unsigned short)((int)sec->data_end),track_id,& offset,& info,(struct i40e_asq_cmd_details *)0);
  #line 5879 
  return status;
}

#line 5895  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_add_cloud_filters(struct i40e_hw *hw, u16 seid, struct i40e_aqc_cloud_filters_element_data *filters, u8 filter_count)
{
  #line 5899 
  struct i40e_aq_desc desc;
  #line 5902 
  enum i40e_status_code status;
  #line 5903 
  u16 buff_len;
  #line 5900 
  struct i40e_aqc_add_remove_cloud_filters *cmd = (struct i40e_aqc_add_remove_cloud_filters *)(& desc.params.raw);
  #line 5905 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)604);
  #line 5908 
  buff_len = (unsigned short)((unsigned int)((unsigned short)filter_count) * 64U);
  #line 5909 
  desc.datalen = buff_len;
  #line 5910 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  #line 5911 
  cmd->num_filters = filter_count;
  #line 5912 
  cmd->seid = seid;
  #line 5914 
  status = i40e_asq_send_command(hw,& desc,(void *)filters,(unsigned short)((int)buff_len),(struct i40e_asq_cmd_details *)0);
  #line 5916 
  return status;
}

#line 5932  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_add_cloud_filters_bb(struct i40e_hw *hw, u16 seid, struct i40e_aqc_cloud_filters_element_bb *filters, u8 filter_count)
{
  #line 5936 
  struct i40e_aq_desc desc;
  #line 5939 
  i40e_status status;
  #line 5940 
  u16 buff_len;
  #line 5941 
  int i;
  #line 5937 
  struct i40e_aqc_add_remove_cloud_filters *cmd = (struct i40e_aqc_add_remove_cloud_filters *)(& desc.params.raw);
  #line 5943 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)604);
  #line 5946 
  buff_len = (unsigned short)((unsigned int)((unsigned short)filter_count) * 128U);
  #line 5947 
  desc.datalen = buff_len;
  #line 5948 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  #line 5949 
  cmd->num_filters = filter_count;
  #line 5950 
  cmd->seid = seid;
  #line 5951 
  cmd->big_buffer_flag = (unsigned char)1U;
  #line 5953 
  i = 0;
  #line 5953 
  while ((int)filter_count > i) {
    {
      #line 5954 
      u16 tnl_type;
      #line 5955 
      u32 ti;
      #line 5957 
      tnl_type = (unsigned short)((unsigned int)((unsigned short)((int)(filters + (unsigned long)i)->element.flags >> 9)) & 15U);
      #line 5965 
      if ((unsigned int)tnl_type == 2U) {
        #line 5966 
        ti = (filters + (unsigned long)i)->element.tenant_id;
        #line 5967 
        (filters + (unsigned long)i)->element.tenant_id = ti << 8;
      }
    }
    #line 5953 
    i ++;
  }
  #line 5971 
  status = i40e_asq_send_command(hw,& desc,(void *)filters,(unsigned short)((int)buff_len),(struct i40e_asq_cmd_details *)0);
  #line 5973 
  return status;
}

#line 5989  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_rem_cloud_filters(struct i40e_hw *hw, u16 seid, struct i40e_aqc_cloud_filters_element_data *filters, u8 filter_count)
{
  #line 5993 
  struct i40e_aq_desc desc;
  #line 5996 
  enum i40e_status_code status;
  #line 5997 
  u16 buff_len;
  #line 5994 
  struct i40e_aqc_add_remove_cloud_filters *cmd = (struct i40e_aqc_add_remove_cloud_filters *)(& desc.params.raw);
  #line 5999 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)605);
  #line 6002 
  buff_len = (unsigned short)((unsigned int)((unsigned short)filter_count) * 64U);
  #line 6003 
  desc.datalen = buff_len;
  #line 6004 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  #line 6005 
  cmd->num_filters = filter_count;
  #line 6006 
  cmd->seid = seid;
  #line 6008 
  status = i40e_asq_send_command(hw,& desc,(void *)filters,(unsigned short)((int)buff_len),(struct i40e_asq_cmd_details *)0);
  #line 6010 
  return status;
}

#line 6026  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_common.c"
enum i40e_status_code i40e_aq_rem_cloud_filters_bb(struct i40e_hw *hw, u16 seid, struct i40e_aqc_cloud_filters_element_bb *filters, u8 filter_count)
{
  #line 6030 
  struct i40e_aq_desc desc;
  #line 6033 
  i40e_status status;
  #line 6034 
  u16 buff_len;
  #line 6035 
  int i;
  #line 6031 
  struct i40e_aqc_add_remove_cloud_filters *cmd = (struct i40e_aqc_add_remove_cloud_filters *)(& desc.params.raw);
  #line 6037 
  i40e_fill_default_direct_cmd_desc(& desc,(unsigned short)605);
  #line 6040 
  buff_len = (unsigned short)((unsigned int)((unsigned short)filter_count) * 128U);
  #line 6041 
  desc.datalen = buff_len;
  #line 6042 
  desc.flags = (unsigned short)((unsigned int)desc.flags | 5120U);
  #line 6043 
  cmd->num_filters = filter_count;
  #line 6044 
  cmd->seid = seid;
  #line 6045 
  cmd->big_buffer_flag = (unsigned char)1U;
  #line 6047 
  i = 0;
  #line 6047 
  while ((int)filter_count > i) {
    {
      #line 6048 
      u16 tnl_type;
      #line 6049 
      u32 ti;
      #line 6051 
      tnl_type = (unsigned short)((unsigned int)((unsigned short)((int)(filters + (unsigned long)i)->element.flags >> 9)) & 15U);
      #line 6059 
      if ((unsigned int)tnl_type == 2U) {
        #line 6060 
        ti = (filters + (unsigned long)i)->element.tenant_id;
        #line 6061 
        (filters + (unsigned long)i)->element.tenant_id = ti << 8;
      }
    }
    #line 6047 
    i ++;
  }
  #line 6065 
  status = i40e_asq_send_command(hw,& desc,(void *)filters,(unsigned short)((int)buff_len),(struct i40e_asq_cmd_details *)0);
  #line 6067 
  return status;
}

#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_diag.h"
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_diag.c"
struct i40e_diag_reg_test_info i40e_reg_list[12U];
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_diag.h"
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_diag.c"
i40e_status i40e_diag_reg_test(struct i40e_hw *hw);
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_diag.h"
#line 117  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_diag.c"
i40e_status i40e_diag_eeprom_test(struct i40e_hw *hw);
#line 327  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 327 
i40e_status i40e_validate_nvm_checksum(struct i40e_hw *hw, u16 *checksum);
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_diag.c"
static i40e_status i40e_diag_reg_pattern_test(struct i40e_hw *hw, u32 reg, u32 mask)
{
  #line 19 
  u32 pat;
  #line 19 
  u32 val;
  #line 19 
  u32 orig_val;
  #line 20 
  int i;
  #line 16 
  u32 patterns[4U] = {1515870810U, 2779096485U, 0U, 4294967295U};
  #line 22 
  orig_val = readl((void *)(hw->hw_addr + (unsigned long)reg));
  #line 23 
  i = 0;
  #line 23 
  while ((unsigned int)i <= 3U) {
    #line 24 
    pat = patterns[i];
    #line 25 
    writel(pat & mask,(void *)(hw->hw_addr + (unsigned long)reg));
    #line 26 
    val = readl((void *)(hw->hw_addr + (unsigned long)reg));
    #line 27 
    if (((val ^ pat) & mask) != 0U) {
      #line 28 
      if ((hw->debug_mask & 2048U) != 0U) 
                                          #line 28 
                                          printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(char *)"i40e_diag_reg_pattern_test",reg,pat,val);
      #line 31 
      return I40E_ERR_DIAG_TEST_FAILED;
    }
    #line 23 
    i ++;
  }
  #line 35 
  writel(orig_val,(void *)(hw->hw_addr + (unsigned long)reg));
  #line 36 
  val = readl((void *)(hw->hw_addr + (unsigned long)reg));
  #line 37 
  if (val != orig_val) {
    #line 38 
    if ((hw->debug_mask & 2048U) != 0U) 
                                        #line 38 
                                        printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(char *)"i40e_diag_reg_pattern_test",reg,orig_val,val);
    #line 41 
    return I40E_ERR_DIAG_TEST_FAILED;
  }
  #line 44 
  return I40E_SUCCESS;
}

#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_diag.c"
struct i40e_diag_reg_test_info i40e_reg_list[12U] = {{.offset = 1064960U, .mask = 65471U, .elements = 1U, .stride = 4U}, {.offset = 229376U, .mask = 4095U, .elements = 3U, .stride = 128U}, {.offset = 196608U, .mask = 4095U, .elements = 1U, .stride = 4U}, {.offset = 198656U, .mask = 4095U, .elements = 1U, .stride = 4U}, {.offset = 200704U, .mask = 4095U, .elements = 1U, .stride = 4U}, {.offset = 230400U, .mask = 12U, .elements = 1U}, {.offset = 230656U, .mask = 8191U, .elements = 1U}, {.offset = 217088U, .mask = 2047U, .elements = 1U, .stride = 4U}, {.offset = 245760U, .mask = 255U, .elements = 1U, .stride = 4U}, {.offset = 237568U, .mask = 255U, .elements = 1U, .stride = 4U}, {.offset = 231424U, .mask = 4159832064U, .elements = 1U}};
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_diag.c"
i40e_status i40e_diag_reg_test(struct i40e_hw *hw)
{
  #line 80 
  u32 reg;
  #line 80 
  u32 mask;
  #line 81 
  u32 i;
  #line 81 
  u32 j;
  #line 79 
  i40e_status ret_code = 0;
  #line 83 
  i = 0U;
  #line 83 
  while (i40e_reg_list[i].offset != 0U && ret_code == I40E_SUCCESS) {
    #line 87 
    if (i40e_reg_list[i].offset == 1064960U && hw->func_caps.num_tx_qp != 0U) 
      #line 89 
      i40e_reg_list[i].elements = hw->func_caps.num_tx_qp;
    #line 90 
    if (((((i40e_reg_list[i].offset == 196608U || i40e_reg_list[i].offset == 198656U) || i40e_reg_list[i].offset == 200704U) || i40e_reg_list[i].offset == 245760U) || i40e_reg_list[i].offset == 237568U) && hw->func_caps.num_msix_vectors != 0U) 
      #line 96 
      i40e_reg_list[i].elements = hw->func_caps.num_msix_vectors + 4294967295U;
    #line 100 
    mask = i40e_reg_list[i].mask;
    #line 101 
    j = 0U;
    #line 101 
    while (i40e_reg_list[i].elements > j && ret_code == I40E_SUCCESS) {
      #line 102 
      reg = i40e_reg_list[i].offset + i40e_reg_list[i].stride * j;
      #line 104 
      ret_code = i40e_diag_reg_pattern_test(hw,reg,mask);
      #line 101 
      j ++;
    }
    #line 84 
    i ++;
  }
  #line 108 
  return ret_code;
}

#line 117  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_diag.c"
i40e_status i40e_diag_eeprom_test(struct i40e_hw *hw)
{
  #line 119 
  i40e_status ret_code;
  #line 120 
  u16 reg_val;
  #line 123 
  ret_code = i40e_read_nvm_word(hw,(unsigned short)0,& reg_val);
  #line 124 
  if (ret_code == I40E_SUCCESS && ((unsigned int)reg_val & 192U) == 64U) {
    #line 127 
    return i40e_validate_nvm_checksum(hw,(u16 *)0U);
  }
  else 
       #line 129 
       return I40E_ERR_DIAG_TEST_FAILED;
}

#line 191  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_add_sd_table_entry(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 sd_index, enum i40e_sd_entry_type type, u64 direct_mode_sz);
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
#line 109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_add_pd_table_entry(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 pd_index, struct i40e_dma_mem *rsrc_pg);
#line 201  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_remove_pd_bp(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx);
#line 204  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
#line 244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_prep_remove_sd_bp(struct i40e_hmc_info *hmc_info, u32 idx);
#line 206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_remove_sd_bp_new(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx, bool is_pf);
#line 209  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
#line 293  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_prep_remove_pd_page(struct i40e_hmc_info *hmc_info, u32 idx);
#line 211  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.h"
#line 321  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_remove_pd_page_new(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx, bool is_pf);
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_alloc.h"
#line 23 
i40e_status i40e_allocate_dma_mem_d(struct i40e_hw *hw, struct i40e_dma_mem *mem, u64 size, u32 alignment);
#line 27 
#line 27 
i40e_status i40e_free_dma_mem_d(struct i40e_hw *hw, struct i40e_dma_mem *mem);
#line 29 
#line 29 
i40e_status i40e_allocate_virt_mem_d(struct i40e_hw *hw, struct i40e_virt_mem *mem, u32 size);
#line 32 
#line 32 
i40e_status i40e_free_virt_mem_d(struct i40e_hw *hw, struct i40e_virt_mem *mem);
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_add_sd_table_entry(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 sd_index, enum i40e_sd_entry_type type, u64 direct_mode_sz)
{
  #line 26 
  enum i40e_memory_type mem_type;
  #line 27 
  struct i40e_hmc_sd_entry *sd_entry;
  #line 29 
  struct i40e_dma_mem mem;
  #line 31 
  u64 alloc_len;
  #line 28 
  bool dma_mem_alloc_done = (_Bool)0;
  #line 30 
  i40e_status ret_code = 0;
  #line 33 
  if (hmc_info->sd_table.sd_entry == (struct i40e_hmc_sd_entry *)0) {
    #line 34 
    ret_code = I40E_ERR_BAD_PTR;
    {
      #line 35 
      bool branch;
      #line 35 
      struct _ddebug __UNIQUE_ID_ddebug558 = {.modname = (char *)"i40e", .function = (char *)"i40e_add_sd_table_entry", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c", .format = (char *)"i40e_add_sd_table_entry: bad sd_entry\n", .lineno = (unsigned int)35U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 35 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug558.key.dd_key_false.key,(_Bool)0);
      #line 35 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 35 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug558,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_add_sd_table_entry: bad sd_entry\n");
    }
    #line 36 
    goto exit;
  }
  #line 39 
  if (hmc_info->sd_table.sd_cnt <= sd_index) {
    #line 40 
    ret_code = I40E_ERR_INVALID_SD_INDEX;
    {
      #line 41 
      bool branch_0;
      #line 41 
      struct _ddebug __UNIQUE_ID_ddebug559 = {.modname = (char *)"i40e", .function = (char *)"i40e_add_sd_table_entry", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c", .format = (char *)"i40e_add_sd_table_entry: bad sd_index\n", .lineno = (unsigned int)41U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 41 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug559.key.dd_key_false.key,(_Bool)0);
      #line 41 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 41 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug559,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_add_sd_table_entry: bad sd_index\n");
    }
    #line 42 
    goto exit;
  }
  #line 45 
  sd_entry = hmc_info->sd_table.sd_entry + (unsigned long)sd_index;
  #line 46 
  if (! sd_entry->valid) {
    #line 47 
    if (type == (unsigned int)I40E_SD_TYPE_PAGED) {
      #line 48 
      mem_type = i40e_mem_pd;
      #line 49 
      alloc_len = 4096ULL;
    }
    else {
      #line 51 
      mem_type = i40e_mem_bp_jumbo;
      #line 52 
      alloc_len = direct_mode_sz;
    }
    #line 56 
    ret_code = i40e_allocate_dma_mem_d(hw,& mem,alloc_len,4096U);
    #line 58 
    if (ret_code != I40E_SUCCESS) 
                                  #line 59 
                                  goto exit;
    #line 60 
    dma_mem_alloc_done = (_Bool)1;
    #line 61 
    if (type == (unsigned int)I40E_SD_TYPE_PAGED) {
      #line 62 
      ret_code = i40e_allocate_virt_mem_d(hw,& sd_entry->u.pd_table.pd_entry_virt_mem,24576U);
      #line 65 
      if (ret_code != I40E_SUCCESS) 
                                    #line 66 
                                    goto exit;
      #line 67 
      sd_entry->u.pd_table.pd_entry = (struct i40e_hmc_pd_entry *)sd_entry->u.pd_table.pd_entry_virt_mem.va;
      #line 70 
      sd_entry->u.pd_table.pd_page_addr = mem;
    }
    else {
      #line 72 
      sd_entry->u.bp.addr = mem;
      #line 73 
      sd_entry->u.bp.sd_pd_index = sd_index;
    }
    #line 76 
    (hmc_info->sd_table.sd_entry + (unsigned long)sd_index)->entry_type = type;
    #line 79 
    (hmc_info->sd_table.ref_cnt) ++;
  }
  #line 82 
  if (sd_entry->entry_type == (unsigned int)I40E_SD_TYPE_DIRECT) 
                                                                 #line 83 
                                                                 (sd_entry->u.bp.ref_cnt) ++;
  #line 84 
  exit: 
        #line 84 
  ;
  #line 85 
  if (ret_code != I40E_SUCCESS) 
    #line 86 
    if ((int)dma_mem_alloc_done != 0) 
                                      #line 87 
                                      i40e_free_dma_mem_d(hw,& mem);
  #line 89 
  return ret_code;
}

#line 109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_add_pd_table_entry(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 pd_index, struct i40e_dma_mem *rsrc_pg)
{
  #line 115 
  struct i40e_hmc_pd_table *pd_table;
  #line 116 
  struct i40e_hmc_pd_entry *pd_entry;
  #line 117 
  struct i40e_dma_mem mem;
  #line 119 
  u32 sd_idx;
  #line 119 
  u32 rel_pd_idx;
  #line 120 
  u64 *pd_addr;
  #line 121 
  u64 page_desc;
  #line 114 
  i40e_status ret_code = 0;
  #line 118 
  struct i40e_dma_mem *page = & mem;
  #line 123 
  if (pd_index / 512U >= hmc_info->sd_table.sd_cnt) {
    #line 124 
    ret_code = I40E_ERR_INVALID_PAGE_DESC_INDEX;
    {
      #line 125 
      bool branch;
      #line 125 
      struct _ddebug __UNIQUE_ID_ddebug560 = {.modname = (char *)"i40e", .function = (char *)"i40e_add_pd_table_entry", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c", .format = (char *)"i40e_add_pd_table_entry: bad pd_index\n", .lineno = (unsigned int)125U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 125 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug560.key.dd_key_false.key,(_Bool)0);
      #line 125 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 125 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug560,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_add_pd_table_entry: bad pd_index\n");
    }
    #line 126 
    goto exit;
  }
  #line 130 
  sd_idx = pd_index / 512U;
  #line 131 
  if ((hmc_info->sd_table.sd_entry + (unsigned long)sd_idx)->entry_type != (unsigned int)I40E_SD_TYPE_PAGED) 
    #line 133 
    goto exit;
  #line 135 
  rel_pd_idx = pd_index & 511U;
  #line 136 
  pd_table = & (hmc_info->sd_table.sd_entry + (unsigned long)sd_idx)->u.pd_table;
  #line 137 
  pd_entry = pd_table->pd_entry + (unsigned long)rel_pd_idx;
  #line 138 
  if (! pd_entry->valid) {
    #line 139 
    if (rsrc_pg != (struct i40e_dma_mem *)0) {
      #line 140 
      pd_entry->rsrc_pg = (_Bool)1;
      #line 141 
      page = rsrc_pg;
    }
    else {
      #line 144 
      ret_code = i40e_allocate_dma_mem_d(hw,page,4096ULL,4096U);
      #line 147 
      if (ret_code != I40E_SUCCESS) 
                                    #line 148 
                                    goto exit;
      #line 149 
      pd_entry->rsrc_pg = (_Bool)0;
    }
    #line 152 
    pd_entry->bp.addr = *page;
    #line 153 
    pd_entry->bp.sd_pd_index = pd_index;
    #line 154 
    pd_entry->bp.entry_type = I40E_SD_TYPE_PAGED;
    #line 156 
    page_desc = page->pa | 1ULL;
    #line 158 
    pd_addr = (u64 *)pd_table->pd_page_addr.va;
    #line 159 
    pd_addr += (unsigned long)rel_pd_idx;
    #line 162 
    memcpy((void *)pd_addr,(void *)(& page_desc),8UL);
    #line 164 
    pd_entry->sd_index = sd_idx;
    #line 165 
    pd_entry->valid = (_Bool)1;
    #line 166 
    (pd_table->ref_cnt) ++;
  }
  #line 168 
  (pd_entry->bp.ref_cnt) ++;
  #line 169 
  exit: 
        #line 169 
  ;
  #line 170 
  return ret_code;
}

#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_remove_pd_bp(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx)
{
  #line 193 
  struct i40e_hmc_pd_entry *pd_entry;
  #line 194 
  struct i40e_hmc_pd_table *pd_table;
  #line 195 
  struct i40e_hmc_sd_entry *sd_entry;
  #line 196 
  u32 sd_idx;
  #line 196 
  u32 rel_pd_idx;
  #line 197 
  u64 *pd_addr;
  #line 192 
  i40e_status ret_code = 0;
  #line 200 
  sd_idx = idx / 512U;
  #line 201 
  rel_pd_idx = idx & 511U;
  #line 202 
  if (hmc_info->sd_table.sd_cnt <= sd_idx) {
    #line 203 
    ret_code = I40E_ERR_INVALID_PAGE_DESC_INDEX;
    {
      #line 204 
      bool branch;
      #line 204 
      struct _ddebug __UNIQUE_ID_ddebug561 = {.modname = (char *)"i40e", .function = (char *)"i40e_remove_pd_bp", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c", .format = (char *)"i40e_remove_pd_bp: bad idx\n", .lineno = (unsigned int)204U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 204 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug561.key.dd_key_false.key,(_Bool)0);
      #line 204 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 204 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug561,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_remove_pd_bp: bad idx\n");
    }
    #line 205 
    goto exit;
  }
  #line 207 
  sd_entry = hmc_info->sd_table.sd_entry + (unsigned long)sd_idx;
  #line 208 
  if (sd_entry->entry_type != (unsigned int)I40E_SD_TYPE_PAGED) {
    #line 209 
    ret_code = I40E_ERR_INVALID_SD_TYPE;
    {
      #line 210 
      bool branch_0;
      #line 210 
      struct _ddebug __UNIQUE_ID_ddebug562 = {.modname = (char *)"i40e", .function = (char *)"i40e_remove_pd_bp", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c", .format = (char *)"i40e_remove_pd_bp: wrong sd_entry type\n", .lineno = (unsigned int)210U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 210 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug562.key.dd_key_false.key,(_Bool)0);
      #line 210 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 210 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug562,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_remove_pd_bp: wrong sd_entry type\n");
    }
    #line 211 
    goto exit;
  }
  #line 214 
  pd_table = & (hmc_info->sd_table.sd_entry + (unsigned long)sd_idx)->u.pd_table;
  #line 215 
  pd_entry = pd_table->pd_entry + (unsigned long)rel_pd_idx;
  #line 216 
  (pd_entry->bp.ref_cnt) --;
  #line 217 
  if (pd_entry->bp.ref_cnt != 0U) 
                                  #line 218 
                                  goto exit;
  #line 221 
  pd_entry->valid = (_Bool)0;
  #line 222 
  (pd_table->ref_cnt) --;
  #line 223 
  pd_addr = (u64 *)pd_table->pd_page_addr.va;
  #line 224 
  pd_addr += (unsigned long)rel_pd_idx;
  #line 225 
  memset((void *)pd_addr,0,8UL);
  #line 226 
  writel((idx << 16) | sd_idx,(void *)(hw->hw_addr + 787200U));
  #line 229 
  if (! pd_entry->rsrc_pg) 
                           #line 230 
                           ret_code = i40e_free_dma_mem_d(hw,& pd_entry->bp.addr);
  #line 231 
  if (ret_code != I40E_SUCCESS) 
                                #line 232 
                                goto exit;
  #line 233 
  if (pd_table->ref_cnt == 0U) 
                               #line 234 
                               i40e_free_virt_mem_d(hw,& pd_table->pd_entry_virt_mem);
  #line 235 
  exit: 
        #line 235 
  ;
  #line 236 
  return ret_code;
}

#line 244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_prep_remove_sd_bp(struct i40e_hmc_info *hmc_info, u32 idx)
{
  #line 248 
  struct i40e_hmc_sd_entry *sd_entry;
  #line 247 
  i40e_status ret_code = 0;
  #line 251 
  sd_entry = hmc_info->sd_table.sd_entry + (unsigned long)idx;
  #line 252 
  (sd_entry->u.bp.ref_cnt) --;
  #line 253 
  if (sd_entry->u.bp.ref_cnt != 0U) {
    #line 254 
    ret_code = I40E_ERR_NOT_READY;
    #line 255 
    goto exit;
  }
  #line 257 
  (hmc_info->sd_table.ref_cnt) --;
  #line 260 
  sd_entry->valid = (_Bool)0;
  #line 261 
  exit: 
        #line 261 
  ;
  #line 262 
  return ret_code;
}

#line 272  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_remove_sd_bp_new(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx, bool is_pf)
{
  #line 276 
  struct i40e_hmc_sd_entry *sd_entry;
  #line 278 
  if (! is_pf) 
               #line 279 
               return I40E_NOT_SUPPORTED;
  #line 282 
  sd_entry = hmc_info->sd_table.sd_entry + (unsigned long)idx;
  {
    #line 283 
    u32 val2;
    #line 283 
    u32 val3;
    #line 283 
    val2 = 2050U;
    #line 283 
    val3 = idx | 2147483648U;
    #line 283 
    writel(0U,(void *)(hw->hw_addr + 786944U));
    #line 283 
    writel(val2,(void *)(hw->hw_addr + 786688U));
    #line 283 
    writel(val3,(void *)(hw->hw_addr + 786432U));
  }
  #line 285 
  return i40e_free_dma_mem_d(hw,& sd_entry->u.bp.addr);
}

#line 293  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_prep_remove_pd_page(struct i40e_hmc_info *hmc_info, u32 idx)
{
  #line 297 
  struct i40e_hmc_sd_entry *sd_entry;
  #line 296 
  i40e_status ret_code = 0;
  #line 299 
  sd_entry = hmc_info->sd_table.sd_entry + (unsigned long)idx;
  #line 301 
  if (sd_entry->u.pd_table.ref_cnt != 0U) {
    #line 302 
    ret_code = I40E_ERR_NOT_READY;
    #line 303 
    goto exit;
  }
  #line 307 
  sd_entry->valid = (_Bool)0;
  #line 309 
  (hmc_info->sd_table.ref_cnt) --;
  #line 310 
  exit: 
        #line 310 
  ;
  #line 311 
  return ret_code;
}

#line 321  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_hmc.c"
i40e_status i40e_remove_pd_page_new(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx, bool is_pf)
{
  #line 325 
  struct i40e_hmc_sd_entry *sd_entry;
  #line 327 
  if (! is_pf) 
               #line 328 
               return I40E_NOT_SUPPORTED;
  #line 330 
  sd_entry = hmc_info->sd_table.sd_entry + (unsigned long)idx;
  {
    #line 331 
    u32 val2;
    #line 331 
    u32 val3;
    #line 331 
    val2 = 2048U;
    #line 331 
    val3 = idx | 2147483648U;
    #line 331 
    writel(0U,(void *)(hw->hw_addr + 786944U));
    #line 331 
    writel(val2,(void *)(hw->hw_addr + 786688U));
    #line 331 
    writel(val3,(void *)(hw->hw_addr + 786432U));
  }
  #line 333 
  return i40e_free_dma_mem_d(hw,& sd_entry->u.pd_table.pd_page_addr);
}

#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_init_lan_hmc(struct i40e_hw *hw, u32 txq_num, u32 rxq_num, u32 fcoe_cntx_num, u32 fcoe_filt_num);
#line 143  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
#line 438  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_configure_lan_hmc(struct i40e_hw *hw, enum i40e_hmc_model model);
#line 145  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.h"
#line 635  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_shutdown_lan_hmc(struct i40e_hw *hw);
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static u64 i40e_align_l2obj_base(u64 offset)
{
  #line 22 
  u64 aligned_offset = offset;
  #line 24 
  if ((offset & 511ULL) != 0ULL) 
                                 #line 25 
                                 aligned_offset = (aligned_offset - (offset & 511ULL)) + 512ULL;
  #line 28 
  return aligned_offset;
}

#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static u64 i40e_calculate_l2fpm_size(u32 txq_num, u32 rxq_num, u32 fcoe_cntx_num, u32 fcoe_filt_num)
{
  #line 44 
  u64 fpm_size = 0ULL;
  #line 46 
  fpm_size = (unsigned long long)(txq_num * 128U);
  #line 47 
  fpm_size = i40e_align_l2obj_base(fpm_size);
  #line 49 
  fpm_size = (unsigned long long)(rxq_num * 32U) + fpm_size;
  #line 50 
  fpm_size = i40e_align_l2obj_base(fpm_size);
  #line 52 
  fpm_size = (unsigned long long)(fcoe_cntx_num * 64U) + fpm_size;
  #line 53 
  fpm_size = i40e_align_l2obj_base(fpm_size);
  #line 55 
  fpm_size = (unsigned long long)(fcoe_filt_num * 64U) + fpm_size;
  #line 56 
  fpm_size = i40e_align_l2obj_base(fpm_size);
  #line 58 
  return fpm_size;
}

#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_init_lan_hmc(struct i40e_hw *hw, u32 txq_num, u32 rxq_num, u32 fcoe_cntx_num, u32 fcoe_filt_num)
{
  #line 81 
  struct i40e_hmc_obj_info *obj;
  #line 81 
  struct i40e_hmc_obj_info *full_obj;
  #line 83 
  u64 l2fpm_size;
  #line 84 
  u32 size_exp;
  #line 82 
  i40e_status ret_code = 0;
  #line 86 
  hw->hmc.signature = 1213027143U;
  #line 87 
  hw->hmc.hmc_fn_id = hw->pf_id;
  #line 90 
  ret_code = i40e_allocate_virt_mem_d(hw,& hw->hmc.hmc_obj_virt_mem,120U);
  #line 92 
  if (ret_code != I40E_SUCCESS) 
                                #line 93 
                                goto init_lan_hmc_out;
  #line 94 
  hw->hmc.hmc_obj = (struct i40e_hmc_obj_info *)hw->hmc.hmc_obj_virt_mem.va;
  #line 98 
  full_obj = hw->hmc.hmc_obj;
  #line 99 
  full_obj->max_cnt = 0U;
  #line 100 
  full_obj->cnt = 0U;
  #line 101 
  full_obj->base = 0ULL;
  #line 102 
  full_obj->size = 0ULL;
  #line 105 
  obj = hw->hmc.hmc_obj + 1U;
  #line 106 
  obj->max_cnt = readl((void *)(hw->hw_addr + 794632U));
  #line 107 
  obj->cnt = txq_num;
  #line 108 
  obj->base = 0ULL;
  #line 109 
  size_exp = readl((void *)(hw->hw_addr + 794628U));
  #line 110 
  obj->size = 1ULL << size_exp;
  #line 113 
  if (obj->max_cnt < txq_num) {
    #line 114 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_COUNT;
    {
      #line 115 
      bool branch;
      #line 115 
      struct _ddebug __UNIQUE_ID_ddebug558 = {.modname = (char *)"i40e", .function = (char *)"i40e_init_lan_hmc", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_init_lan_hmc: Tx context: asks for 0x%x but max allowed is 0x%x, returns error %d\n", .lineno = (unsigned int)115U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 115 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug558.key.dd_key_false.key,(_Bool)0);
      #line 115 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 115 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug558,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_init_lan_hmc: Tx context: asks for 0x%x but max allowed is 0x%x, returns error %d\n",txq_num,obj->max_cnt,(int)ret_code);
    }
    #line 117 
    goto init_lan_hmc_out;
  }
  #line 121 
  full_obj->max_cnt += obj->max_cnt;
  #line 122 
  full_obj->cnt += obj->cnt;
  #line 125 
  obj = hw->hmc.hmc_obj + 2U;
  #line 126 
  obj->max_cnt = readl((void *)(hw->hw_addr + 794632U));
  #line 127 
  obj->cnt = rxq_num;
  #line 128 
  obj->base = (hw->hmc.hmc_obj + 1U)->base + (unsigned long long)(hw->hmc.hmc_obj + 1U)->cnt * (hw->hmc.hmc_obj + 1U)->size;
  #line 131 
  obj->base = i40e_align_l2obj_base(obj->base);
  #line 132 
  size_exp = readl((void *)(hw->hw_addr + 794636U));
  #line 133 
  obj->size = 1ULL << size_exp;
  #line 136 
  if (obj->max_cnt < rxq_num) {
    #line 137 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_COUNT;
    {
      #line 138 
      bool branch_0;
      #line 138 
      struct _ddebug __UNIQUE_ID_ddebug559 = {.modname = (char *)"i40e", .function = (char *)"i40e_init_lan_hmc", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_init_lan_hmc: Rx context: asks for 0x%x but max allowed is 0x%x, returns error %d\n", .lineno = (unsigned int)138U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 138 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug559.key.dd_key_false.key,(_Bool)0);
      #line 138 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 138 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug559,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_init_lan_hmc: Rx context: asks for 0x%x but max allowed is 0x%x, returns error %d\n",rxq_num,obj->max_cnt,(int)ret_code);
    }
    #line 140 
    goto init_lan_hmc_out;
  }
  #line 144 
  full_obj->max_cnt += obj->max_cnt;
  #line 145 
  full_obj->cnt += obj->cnt;
  #line 148 
  obj = hw->hmc.hmc_obj + 3U;
  #line 149 
  obj->max_cnt = readl((void *)(hw->hw_addr + 794644U));
  #line 150 
  obj->cnt = fcoe_cntx_num;
  #line 151 
  obj->base = (hw->hmc.hmc_obj + 2U)->base + (unsigned long long)(hw->hmc.hmc_obj + 2U)->cnt * (hw->hmc.hmc_obj + 2U)->size;
  #line 154 
  obj->base = i40e_align_l2obj_base(obj->base);
  #line 155 
  size_exp = readl((void *)(hw->hw_addr + 794640U));
  #line 156 
  obj->size = 1ULL << size_exp;
  #line 159 
  if (obj->max_cnt < fcoe_cntx_num) {
    #line 160 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_COUNT;
    {
      #line 161 
      bool branch_1;
      #line 161 
      struct _ddebug __UNIQUE_ID_ddebug560 = {.modname = (char *)"i40e", .function = (char *)"i40e_init_lan_hmc", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_init_lan_hmc: FCoE context: asks for 0x%x but max allowed is 0x%x, returns error %d\n", .lineno = (unsigned int)161U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 161 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug560.key.dd_key_false.key,(_Bool)0);
      #line 161 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 161 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug560,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_init_lan_hmc: FCoE context: asks for 0x%x but max allowed is 0x%x, returns error %d\n",fcoe_cntx_num,obj->max_cnt,(int)ret_code);
    }
    #line 163 
    goto init_lan_hmc_out;
  }
  #line 167 
  full_obj->max_cnt += obj->max_cnt;
  #line 168 
  full_obj->cnt += obj->cnt;
  #line 171 
  obj = hw->hmc.hmc_obj + 4U;
  #line 172 
  obj->max_cnt = readl((void *)(hw->hw_addr + 794832U));
  #line 173 
  obj->cnt = fcoe_filt_num;
  #line 174 
  obj->base = (hw->hmc.hmc_obj + 3U)->base + (unsigned long long)(hw->hmc.hmc_obj + 3U)->cnt * (hw->hmc.hmc_obj + 3U)->size;
  #line 177 
  obj->base = i40e_align_l2obj_base(obj->base);
  #line 178 
  size_exp = readl((void *)(hw->hw_addr + 794648U));
  #line 179 
  obj->size = 1ULL << size_exp;
  #line 182 
  if (obj->max_cnt < fcoe_filt_num) {
    #line 183 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_COUNT;
    {
      #line 184 
      bool branch_2;
      #line 184 
      struct _ddebug __UNIQUE_ID_ddebug561 = {.modname = (char *)"i40e", .function = (char *)"i40e_init_lan_hmc", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_init_lan_hmc: FCoE filter: asks for 0x%x but max allowed is 0x%x, returns error %d\n", .lineno = (unsigned int)184U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 184 
      branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug561.key.dd_key_false.key,(_Bool)0);
      #line 184 
      if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                    #line 184 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug561,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_init_lan_hmc: FCoE filter: asks for 0x%x but max allowed is 0x%x, returns error %d\n",fcoe_filt_num,obj->max_cnt,(int)ret_code);
    }
    #line 186 
    goto init_lan_hmc_out;
  }
  #line 190 
  full_obj->max_cnt += obj->max_cnt;
  #line 191 
  full_obj->cnt += obj->cnt;
  #line 193 
  hw->hmc.first_sd_index = (unsigned short)0U;
  #line 194 
  hw->hmc.sd_table.ref_cnt = 0U;
  #line 195 
  l2fpm_size = i40e_calculate_l2fpm_size(txq_num,rxq_num,fcoe_cntx_num,fcoe_filt_num);
  #line 197 
  if (hw->hmc.sd_table.sd_entry == (struct i40e_hmc_sd_entry *)0) {
    #line 198 
    hw->hmc.sd_table.sd_cnt = ((unsigned int)l2fpm_size + 2097151U) / 2097152U;
    #line 203 
    ret_code = i40e_allocate_virt_mem_d(hw,& hw->hmc.sd_table.addr,hw->hmc.sd_table.sd_cnt * 64U);
    #line 206 
    if (ret_code != I40E_SUCCESS) 
                                  #line 207 
                                  goto init_lan_hmc_out;
    #line 208 
    hw->hmc.sd_table.sd_entry = (struct i40e_hmc_sd_entry *)hw->hmc.sd_table.addr.va;
  }
  #line 212 
  full_obj->size = l2fpm_size;
  #line 214 
  init_lan_hmc_out: 
                    #line 214 
  ;
  #line 215 
  return ret_code;
}

#line 232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static i40e_status i40e_remove_pd_page(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx)
{
  #line 236 
  i40e_status ret_code = 0;
  #line 238 
  if (i40e_prep_remove_pd_page(hmc_info,idx) == I40E_SUCCESS) 
                                                              #line 239 
                                                              ret_code = i40e_remove_pd_page_new(hw,hmc_info,idx,(_Bool)1);
  #line 241 
  return ret_code;
}

#line 259  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static i40e_status i40e_remove_sd_bp(struct i40e_hw *hw, struct i40e_hmc_info *hmc_info, u32 idx)
{
  #line 263 
  i40e_status ret_code = 0;
  #line 265 
  if (i40e_prep_remove_sd_bp(hmc_info,idx) == I40E_SUCCESS) 
                                                            #line 266 
                                                            ret_code = i40e_remove_sd_bp_new(hw,hmc_info,idx,(_Bool)1);
  #line 268 
  return ret_code;
}

#line 279  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static i40e_status i40e_create_lan_hmc_object(struct i40e_hw *hw, struct i40e_hmc_lan_create_obj_info *info)
{
  #line 283 
  struct i40e_hmc_sd_entry *sd_entry;
  #line 287 
  u32 sd_idx;
  #line 287 
  u32 sd_lmt;
  #line 288 
  u64 sd_size;
  #line 289 
  u32 i;
  #line 289 
  u32 j;
  #line 282 
  i40e_status ret_code = 0;
  #line 284 
  u32 pd_idx1 = 0U;
  #line 284 
  u32 pd_lmt1 = 0U;
  #line 285 
  u32 pd_idx = 0U;
  #line 285 
  u32 pd_lmt = 0U;
  #line 286 
  bool pd_error = (_Bool)0;
  #line 291 
  if (info == (struct i40e_hmc_lan_create_obj_info *)0) {
    #line 292 
    ret_code = I40E_ERR_BAD_PTR;
    {
      #line 293 
      bool branch;
      #line 293 
      struct _ddebug __UNIQUE_ID_ddebug562 = {.modname = (char *)"i40e", .function = (char *)"i40e_create_lan_hmc_object", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_create_lan_hmc_object: bad info ptr\n", .lineno = (unsigned int)293U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 293 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug562.key.dd_key_false.key,(_Bool)0);
      #line 293 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 293 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug562,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_create_lan_hmc_object: bad info ptr\n");
    }
    #line 294 
    goto exit;
  }
  #line 296 
  if (info->hmc_info == (struct i40e_hmc_info *)0) {
    #line 297 
    ret_code = I40E_ERR_BAD_PTR;
    {
      #line 298 
      bool branch_0;
      #line 298 
      struct _ddebug __UNIQUE_ID_ddebug563 = {.modname = (char *)"i40e", .function = (char *)"i40e_create_lan_hmc_object", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_create_lan_hmc_object: bad hmc_info ptr\n", .lineno = (unsigned int)298U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 298 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug563.key.dd_key_false.key,(_Bool)0);
      #line 298 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 298 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug563,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_create_lan_hmc_object: bad hmc_info ptr\n");
    }
    #line 299 
    goto exit;
  }
  #line 301 
  if ((info->hmc_info)->signature != 1213027143U) {
    #line 302 
    ret_code = I40E_ERR_BAD_PTR;
    {
      #line 303 
      bool branch_1;
      #line 303 
      struct _ddebug __UNIQUE_ID_ddebug564 = {.modname = (char *)"i40e", .function = (char *)"i40e_create_lan_hmc_object", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_create_lan_hmc_object: bad signature\n", .lineno = (unsigned int)303U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 303 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug564.key.dd_key_false.key,(_Bool)0);
      #line 303 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 303 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug564,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_create_lan_hmc_object: bad signature\n");
    }
    #line 304 
    goto exit;
  }
  #line 307 
  if (info->start_idx >= ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->cnt) {
    #line 308 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_INDEX;
    {
      #line 309 
      bool branch_2;
      #line 309 
      struct _ddebug __UNIQUE_ID_ddebug565 = {.modname = (char *)"i40e", .function = (char *)"i40e_create_lan_hmc_object", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_create_lan_hmc_object: returns error %d\n", .lineno = (unsigned int)309U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 309 
      branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug565.key.dd_key_false.key,(_Bool)0);
      #line 309 
      if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                    #line 309 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug565,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_create_lan_hmc_object: returns error %d\n",(int)ret_code);
    }
    #line 311 
    goto exit;
  }
  #line 313 
  if (info->start_idx + info->count > ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->cnt) {
    #line 315 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_COUNT;
    {
      #line 316 
      bool branch_3;
      #line 316 
      struct _ddebug __UNIQUE_ID_ddebug566 = {.modname = (char *)"i40e", .function = (char *)"i40e_create_lan_hmc_object", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_create_lan_hmc_object: returns error %d\n", .lineno = (unsigned int)316U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 316 
      branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug566.key.dd_key_false.key,(_Bool)0);
      #line 316 
      if ((long)((long)((int)branch_3 != 0)) != 0L) 
                                                    #line 316 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug566,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_create_lan_hmc_object: returns error %d\n",(int)ret_code);
    }
    #line 318 
    goto exit;
  }
  {
    #line 322 
    u64 fpm_addr;
    #line 322 
    u64 fpm_limit;
    #line 322 
    fpm_addr = ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->base + ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->size * (unsigned long long)info->start_idx;
    #line 322 
    fpm_limit = ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->size * (unsigned long long)info->count + fpm_addr;
    #line 322 
    sd_idx = (unsigned int)(fpm_addr / 2097152ULL);
    #line 322 
    sd_lmt = (unsigned int)((fpm_limit + 18446744073709551615ULL) / 2097152ULL);
    #line 322 
    sd_lmt ++;
  }
  #line 325 
  if ((info->hmc_info)->sd_table.sd_cnt <= sd_idx || (info->hmc_info)->sd_table.sd_cnt < sd_lmt) {
    #line 327 
    ret_code = I40E_ERR_INVALID_SD_INDEX;
    #line 328 
    goto exit;
  }
  {
    #line 331 
    u64 fpm_adr;
    #line 331 
    u64 fpm_limit_0;
    #line 331 
    fpm_adr = ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->base + ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->size * (unsigned long long)info->start_idx;
    #line 331 
    fpm_limit_0 = ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->size * (unsigned long long)info->count + fpm_adr;
    #line 331 
    pd_idx = (unsigned int)(fpm_adr / 4096ULL);
    #line 331 
    pd_lmt = (unsigned int)((fpm_limit_0 + 18446744073709551615ULL) / 4096ULL);
    #line 331 
    pd_lmt ++;
  }
  #line 339 
  if (info->direct_mode_sz == 0ULL) 
                                    #line 340 
                                    sd_size = 2097152ULL; else 
                                                               #line 342 
                                                               sd_size = info->direct_mode_sz;
  #line 347 
  j = sd_idx;
  #line 347 
  while (j < sd_lmt) {
    #line 349 
    ret_code = i40e_add_sd_table_entry(hw,info->hmc_info,j,info->entry_type,sd_size);
    #line 352 
    if (ret_code != I40E_SUCCESS) 
                                  #line 353 
                                  goto exit_sd_error;
    #line 354 
    sd_entry = (info->hmc_info)->sd_table.sd_entry + (unsigned long)j;
    #line 355 
    if (sd_entry->entry_type == (unsigned int)I40E_SD_TYPE_PAGED) {
      #line 362 
      u32 tmp_6;
      #line 361 
      u32 __UNIQUE_ID___x567;
      #line 361 
      u32 tmp_4;
      #line 362 
      u32 __UNIQUE_ID___x569;
      {
        #line 361 
        __UNIQUE_ID___x567 = pd_idx;
        #line 361 
        u32 __UNIQUE_ID___y568 = j * 512U;
        #line 361 
        if (__UNIQUE_ID___x567 > __UNIQUE_ID___y568) 
                                                     #line 361 
                                                     tmp_4 = __UNIQUE_ID___x567; else 
                                                                    #line 361 
                                                                    tmp_4 = __UNIQUE_ID___y568;
        }
      #line 361 
      pd_idx1 = tmp_4;
      {
        #line 362 
        __UNIQUE_ID___x569 = pd_lmt;
        #line 362 
        u32 __UNIQUE_ID___y570 = (j + 1U) * 512U;
        #line 362 
        if (__UNIQUE_ID___x569 < __UNIQUE_ID___y570) 
                                                     #line 362 
                                                     tmp_6 = __UNIQUE_ID___x569; else 
                                                                    #line 362 
                                                                    tmp_6 = __UNIQUE_ID___y570;
        }
      #line 362 
      pd_lmt1 = tmp_6;
      #line 364 
      i = pd_idx1;
      #line 364 
      while (i < pd_lmt1) {
        #line 366 
        ret_code = i40e_add_pd_table_entry(hw,info->hmc_info,i,(struct i40e_dma_mem *)0);
        #line 369 
        if (ret_code != I40E_SUCCESS) {
          #line 370 
          pd_error = (_Bool)1;
          #line 371 
          break;
        }
        #line 364 
        i ++;
      }
      #line 374 
      if ((int)pd_error != 0) 
        #line 376 
        while (i != 0U && i > pd_idx1) {
          #line 377 
          i40e_remove_pd_bp(hw,info->hmc_info,i + 4294967295U);
          #line 379 
          i --;
        }
    }
    #line 383 
    if (! sd_entry->valid) {
      #line 384 
      sd_entry->valid = (_Bool)1;
      #line 385 
      switch ((unsigned int)sd_entry->entry_type) {
        #line 386 
        case (unsigned int)1: 
                              #line 386 
        ;
        {
          #line 387 
          u32 val1;
          #line 387 
          u32 val2;
          #line 387 
          u32 val3;
          #line 387 
          unsigned int tmp_8;
          #line 387 
          val1 = (unsigned int)(sd_entry->u.pd_table.pd_page_addr.pa >> 32);
          #line 387 
          if (sd_entry->entry_type != (unsigned int)I40E_SD_TYPE_PAGED) 
            #line 387 
            tmp_8 = 2U; else 
                             #line 387 
                             tmp_8 = 0U;
          #line 387 
          val2 = ((unsigned int)sd_entry->u.pd_table.pd_page_addr.pa | tmp_8) | 2049U;
          #line 387 
          val3 = j | 2147483648U;
          #line 387 
          writel(val1,(void *)(hw->hw_addr + 786944U));
          #line 387 
          writel(val2,(void *)(hw->hw_addr + 786688U));
          #line 387 
          writel(val3,(void *)(hw->hw_addr + 786432U));
        }
        #line 390 
        break;
        #line 391 
        case (unsigned int)2: 
                              #line 391 
        ;
        {
          #line 392 
          u32 val1_0;
          #line 392 
          u32 val2_0;
          #line 392 
          u32 val3_0;
          #line 392 
          unsigned int tmp_9;
          #line 392 
          val1_0 = (unsigned int)(sd_entry->u.bp.addr.pa >> 32);
          #line 392 
          if (sd_entry->entry_type != (unsigned int)I40E_SD_TYPE_PAGED) 
            #line 392 
            tmp_9 = 2U; else 
                             #line 392 
                             tmp_9 = 0U;
          #line 392 
          val2_0 = ((unsigned int)sd_entry->u.bp.addr.pa | tmp_9) | 2049U;
          #line 392 
          val3_0 = j | 2147483648U;
          #line 392 
          writel(val1_0,(void *)(hw->hw_addr + 786944U));
          #line 392 
          writel(val2_0,(void *)(hw->hw_addr + 786688U));
          #line 392 
          writel(val3_0,(void *)(hw->hw_addr + 786432U));
        }
        #line 394 
        break;
        #line 395 
        default: 
                 #line 395 
        ;
        #line 396 
        ret_code = I40E_ERR_INVALID_SD_TYPE;
        #line 397 
        goto exit;
      }
    }
    #line 347 
    j ++;
  }
  #line 401 
  goto exit;
  #line 403 
  exit_sd_error: 
                 #line 403 
  ;
  #line 405 
  while (j != 0U && j > sd_idx) {
    #line 406 
    sd_entry = (info->hmc_info)->sd_table.sd_entry + (unsigned long)(j + 4294967295U);
    #line 407 
    switch ((unsigned int)sd_entry->entry_type) {
      #line 411 
      u32 __UNIQUE_ID___x573;
      #line 411 
      u32 tmp_12;
      #line 409 
      u32 __UNIQUE_ID___x571;
      #line 409 
      u32 tmp_10;
      #line 408 
      case (unsigned int)1: 
                            #line 408 
      ;
      {
        #line 409 
        __UNIQUE_ID___x571 = pd_idx;
        #line 409 
        u32 __UNIQUE_ID___y572 = (j + 4294967295U) * 512U;
        #line 409 
        if (__UNIQUE_ID___x571 > __UNIQUE_ID___y572) 
                                                     #line 409 
                                                     tmp_10 = __UNIQUE_ID___x571; else 
                                                                    #line 409 
                                                                    tmp_10 = __UNIQUE_ID___y572;
        }
      #line 409 
      pd_idx1 = tmp_10;
      {
        #line 411 
        __UNIQUE_ID___x573 = pd_lmt;
        #line 411 
        u32 __UNIQUE_ID___y574 = j * 512U;
        #line 411 
        if (__UNIQUE_ID___x573 < __UNIQUE_ID___y574) 
                                                     #line 411 
                                                     tmp_12 = __UNIQUE_ID___x573; else 
                                                                    #line 411 
                                                                    tmp_12 = __UNIQUE_ID___y574;
        }
      #line 411 
      pd_lmt1 = tmp_12;
      #line 412 
      i = pd_idx1;
      #line 412 
      while (i < pd_lmt1) {
        #line 413 
        i40e_remove_pd_bp(hw,info->hmc_info,i);
        #line 412 
        i ++;
      }
      #line 414 
      i40e_remove_pd_page(hw,info->hmc_info,j + 4294967295U);
      #line 415 
      break;
      #line 416 
      case (unsigned int)2: 
                            #line 416 
      ;
      #line 417 
      i40e_remove_sd_bp(hw,info->hmc_info,j + 4294967295U);
      #line 418 
      break;
      #line 419 
      default: 
               #line 419 
      ;
      #line 420 
      ret_code = I40E_ERR_INVALID_SD_TYPE;
      #line 421 
      break;
    }
    #line 423 
    j --;
  }
  #line 425 
  exit: 
        #line 425 
  ;
  #line 426 
  return ret_code;
}

#line 438  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_configure_lan_hmc(struct i40e_hw *hw, enum i40e_hmc_model model)
{
  #line 441 
  struct i40e_hmc_lan_create_obj_info info;
  #line 444 
  struct i40e_hmc_obj_info *obj;
  #line 442 
  i40e_status ret_code = 0;
  #line 443 
  u8 hmc_fn_id = hw->hmc.hmc_fn_id;
  #line 447 
  info.hmc_info = & hw->hmc;
  #line 448 
  info.rsrc_type = 0U;
  #line 449 
  info.start_idx = 0U;
  #line 450 
  info.direct_mode_sz = (hw->hmc.hmc_obj)->size;
  #line 453 
  switch ((unsigned int)model) {
    #line 454 
    case (unsigned int)0: 
                          #line 454 
    ;
    #line 455 
    case (unsigned int)1: 
                          #line 455 
    ;
    #line 456 
    info.entry_type = I40E_SD_TYPE_DIRECT;
    #line 458 
    info.count = 1U;
    #line 459 
    ret_code = i40e_create_lan_hmc_object(hw,& info);
    #line 460 
    if (ret_code != I40E_SUCCESS && model == (unsigned int)I40E_HMC_MODEL_DIRECT_PREFERRED) 
      #line 461 
      goto try_type_paged;
    else 
      #line 462 
      if (ret_code != I40E_SUCCESS) 
                                    #line 463 
                                    goto configure_lan_hmc_out;
    #line 465 
    break;
    #line 466 
    case (unsigned int)2: 
                          #line 466 
    ;
    #line 467 
    try_type_paged: 
                    #line 467 
    ;
    #line 468 
    info.entry_type = I40E_SD_TYPE_PAGED;
    #line 470 
    info.count = 1U;
    #line 471 
    ret_code = i40e_create_lan_hmc_object(hw,& info);
    #line 472 
    if (ret_code != I40E_SUCCESS) 
                                  #line 473 
                                  goto configure_lan_hmc_out;
    #line 474 
    break;
    #line 475 
    default: 
             #line 475 
    ;
    #line 477 
    ret_code = I40E_ERR_INVALID_SD_TYPE;
    {
      #line 478 
      bool branch;
      #line 478 
      struct _ddebug __UNIQUE_ID_ddebug575 = {.modname = (char *)"i40e", .function = (char *)"i40e_configure_lan_hmc", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_configure_lan_hmc: Unknown SD type: %d\n", .lineno = (unsigned int)478U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 478 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug575.key.dd_key_false.key,(_Bool)0);
      #line 478 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 478 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug575,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_configure_lan_hmc: Unknown SD type: %d\n",(int)ret_code);
    }
    #line 480 
    goto configure_lan_hmc_out;
  }
  #line 486 
  obj = hw->hmc.hmc_obj + 1U;
  #line 487 
  writel((unsigned int)((obj->base & 16777215ULL) / 512ULL),(void *)(hw->hw_addr + (unsigned long)(((int)hmc_fn_id + 202880) * 4)));
  #line 489 
  writel(obj->cnt,(void *)(hw->hw_addr + (unsigned long)(((int)hmc_fn_id + 202944) * 4)));
  #line 492 
  obj = hw->hmc.hmc_obj + 2U;
  #line 493 
  writel((unsigned int)((obj->base & 16777215ULL) / 512ULL),(void *)(hw->hw_addr + (unsigned long)(((int)hmc_fn_id + 203008) * 4)));
  #line 495 
  writel(obj->cnt,(void *)(hw->hw_addr + (unsigned long)(((int)hmc_fn_id + 203072) * 4)));
  #line 498 
  obj = hw->hmc.hmc_obj + 3U;
  #line 499 
  writel((unsigned int)((obj->base & 16777215ULL) / 512ULL),(void *)(hw->hw_addr + (unsigned long)(((int)hmc_fn_id + 203136) * 4)));
  #line 501 
  writel(obj->cnt,(void *)(hw->hw_addr + (unsigned long)(((int)hmc_fn_id + 203200) * 4)));
  #line 504 
  obj = hw->hmc.hmc_obj + 4U;
  #line 505 
  writel((unsigned int)((obj->base & 16777215ULL) / 512ULL),(void *)(hw->hw_addr + (unsigned long)(((int)hmc_fn_id + 203264) * 4)));
  #line 507 
  writel(obj->cnt,(void *)(hw->hw_addr + (unsigned long)(((int)hmc_fn_id + 203328) * 4)));
  #line 509 
  configure_lan_hmc_out: 
                         #line 509 
  ;
  #line 510 
  return ret_code;
}

#line 523  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static i40e_status i40e_delete_lan_hmc_object(struct i40e_hw *hw, struct i40e_hmc_lan_delete_obj_info *info)
{
  #line 527 
  struct i40e_hmc_pd_table *pd_table;
  #line 528 
  u32 pd_idx;
  #line 528 
  u32 pd_lmt;
  #line 528 
  u32 rel_pd_idx;
  #line 529 
  u32 sd_idx;
  #line 529 
  u32 sd_lmt;
  #line 530 
  u32 i;
  #line 530 
  u32 j;
  #line 526 
  i40e_status ret_code = 0;
  #line 532 
  if (info == (struct i40e_hmc_lan_delete_obj_info *)0) {
    #line 533 
    ret_code = I40E_ERR_BAD_PTR;
    {
      #line 534 
      bool branch;
      #line 534 
      struct _ddebug __UNIQUE_ID_ddebug576 = {.modname = (char *)"i40e", .function = (char *)"i40e_delete_lan_hmc_object", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_delete_hmc_object: bad info ptr\n", .lineno = (unsigned int)534U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 534 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug576.key.dd_key_false.key,(_Bool)0);
      #line 534 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 534 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug576,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_delete_hmc_object: bad info ptr\n");
    }
    #line 535 
    goto exit;
  }
  #line 537 
  if (info->hmc_info == (struct i40e_hmc_info *)0) {
    #line 538 
    ret_code = I40E_ERR_BAD_PTR;
    {
      #line 539 
      bool branch_0;
      #line 539 
      struct _ddebug __UNIQUE_ID_ddebug577 = {.modname = (char *)"i40e", .function = (char *)"i40e_delete_lan_hmc_object", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_delete_hmc_object: bad info->hmc_info ptr\n", .lineno = (unsigned int)539U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 539 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug577.key.dd_key_false.key,(_Bool)0);
      #line 539 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 539 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug577,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_delete_hmc_object: bad info->hmc_info ptr\n");
    }
    #line 540 
    goto exit;
  }
  #line 542 
  if ((info->hmc_info)->signature != 1213027143U) {
    #line 543 
    ret_code = I40E_ERR_BAD_PTR;
    {
      #line 544 
      bool branch_1;
      #line 544 
      struct _ddebug __UNIQUE_ID_ddebug578 = {.modname = (char *)"i40e", .function = (char *)"i40e_delete_lan_hmc_object", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_delete_hmc_object: bad hmc_info->signature\n", .lineno = (unsigned int)544U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 544 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug578.key.dd_key_false.key,(_Bool)0);
      #line 544 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 544 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug578,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_delete_hmc_object: bad hmc_info->signature\n");
    }
    #line 545 
    goto exit;
  }
  #line 548 
  if ((info->hmc_info)->sd_table.sd_entry == (struct i40e_hmc_sd_entry *)0) {
    #line 549 
    ret_code = I40E_ERR_BAD_PTR;
    {
      #line 550 
      bool branch_2;
      #line 550 
      struct _ddebug __UNIQUE_ID_ddebug579 = {.modname = (char *)"i40e", .function = (char *)"i40e_delete_lan_hmc_object", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_delete_hmc_object: bad sd_entry\n", .lineno = (unsigned int)550U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 550 
      branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug579.key.dd_key_false.key,(_Bool)0);
      #line 550 
      if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                    #line 550 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug579,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_delete_hmc_object: bad sd_entry\n");
    }
    #line 551 
    goto exit;
  }
  #line 554 
  if ((info->hmc_info)->hmc_obj == (struct i40e_hmc_obj_info *)0) {
    #line 555 
    ret_code = I40E_ERR_BAD_PTR;
    {
      #line 556 
      bool branch_3;
      #line 556 
      struct _ddebug __UNIQUE_ID_ddebug580 = {.modname = (char *)"i40e", .function = (char *)"i40e_delete_lan_hmc_object", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_delete_hmc_object: bad hmc_info->hmc_obj\n", .lineno = (unsigned int)556U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 556 
      branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug580.key.dd_key_false.key,(_Bool)0);
      #line 556 
      if ((long)((long)((int)branch_3 != 0)) != 0L) 
                                                    #line 556 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug580,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_delete_hmc_object: bad hmc_info->hmc_obj\n");
    }
    #line 557 
    goto exit;
  }
  #line 559 
  if (info->start_idx >= ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->cnt) {
    #line 560 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_INDEX;
    {
      #line 561 
      bool branch_4;
      #line 561 
      struct _ddebug __UNIQUE_ID_ddebug581 = {.modname = (char *)"i40e", .function = (char *)"i40e_delete_lan_hmc_object", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_delete_hmc_object: returns error %d\n", .lineno = (unsigned int)561U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 561 
      branch_4 = arch_static_branch(& __UNIQUE_ID_ddebug581.key.dd_key_false.key,(_Bool)0);
      #line 561 
      if ((long)((long)((int)branch_4 != 0)) != 0L) 
                                                    #line 561 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug581,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_delete_hmc_object: returns error %d\n",(int)ret_code);
    }
    #line 563 
    goto exit;
  }
  #line 566 
  if (info->start_idx + info->count > ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->cnt) {
    #line 568 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_COUNT;
    {
      #line 569 
      bool branch_5;
      #line 569 
      struct _ddebug __UNIQUE_ID_ddebug582 = {.modname = (char *)"i40e", .function = (char *)"i40e_delete_lan_hmc_object", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_delete_hmc_object: returns error %d\n", .lineno = (unsigned int)569U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 569 
      branch_5 = arch_static_branch(& __UNIQUE_ID_ddebug582.key.dd_key_false.key,(_Bool)0);
      #line 569 
      if ((long)((long)((int)branch_5 != 0)) != 0L) 
                                                    #line 569 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug582,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_delete_hmc_object: returns error %d\n",(int)ret_code);
    }
    #line 571 
    goto exit;
  }
  {
    #line 574 
    u64 fpm_adr;
    #line 574 
    u64 fpm_limit;
    #line 574 
    fpm_adr = ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->base + ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->size * (unsigned long long)info->start_idx;
    #line 574 
    fpm_limit = ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->size * (unsigned long long)info->count + fpm_adr;
    #line 574 
    pd_idx = (unsigned int)(fpm_adr / 4096ULL);
    #line 574 
    pd_lmt = (unsigned int)((fpm_limit + 18446744073709551615ULL) / 4096ULL);
    #line 574 
    pd_lmt ++;
  }
  #line 578 
  j = pd_idx;
  #line 578 
  while (j < pd_lmt) {
    #line 579 
    sd_idx = j / 512U;
    #line 581 
    if (((info->hmc_info)->sd_table.sd_entry + (unsigned long)sd_idx)->entry_type != (unsigned int)I40E_SD_TYPE_PAGED) 
      #line 583 
      goto __Cont;
    #line 585 
    rel_pd_idx = j & 511U;
    #line 587 
    pd_table = & ((info->hmc_info)->sd_table.sd_entry + (unsigned long)sd_idx)->u.pd_table;
    #line 589 
    if ((int)(pd_table->pd_entry + (unsigned long)rel_pd_idx)->valid != 0) {
      #line 590 
      ret_code = i40e_remove_pd_bp(hw,info->hmc_info,j);
      #line 591 
      if (ret_code != I40E_SUCCESS) 
                                    #line 592 
                                    goto exit;
    }
    #line 578 
    __Cont: 
            #line 578 
    j ++;
  }
  {
    #line 597 
    u64 fpm_addr;
    #line 597 
    u64 fpm_limit_0;
    #line 597 
    fpm_addr = ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->base + ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->size * (unsigned long long)info->start_idx;
    #line 597 
    fpm_limit_0 = ((info->hmc_info)->hmc_obj + (unsigned long)info->rsrc_type)->size * (unsigned long long)info->count + fpm_addr;
    #line 597 
    sd_idx = (unsigned int)(fpm_addr / 2097152ULL);
    #line 597 
    sd_lmt = (unsigned int)((fpm_limit_0 + 18446744073709551615ULL) / 2097152ULL);
    #line 597 
    sd_lmt ++;
  }
  #line 600 
  if ((info->hmc_info)->sd_table.sd_cnt <= sd_idx || (info->hmc_info)->sd_table.sd_cnt < sd_lmt) {
    #line 602 
    ret_code = I40E_ERR_INVALID_SD_INDEX;
    #line 603 
    goto exit;
  }
  #line 606 
  i = sd_idx;
  #line 606 
  while (i < sd_lmt) {
    #line 607 
    if (! ((info->hmc_info)->sd_table.sd_entry + (unsigned long)i)->valid) 
      #line 608 
      goto __Cont_0;
    #line 609 
    switch ((unsigned int)((info->hmc_info)->sd_table.sd_entry + (unsigned long)i)->entry_type) {
      #line 610 
      case (unsigned int)2: 
                            #line 610 
      ;
      #line 611 
      ret_code = i40e_remove_sd_bp(hw,info->hmc_info,i);
      #line 612 
      if (ret_code != I40E_SUCCESS) 
                                    #line 613 
                                    goto exit;
      #line 614 
      break;
      #line 615 
      case (unsigned int)1: 
                            #line 615 
      ;
      #line 616 
      ret_code = i40e_remove_pd_page(hw,info->hmc_info,i);
      #line 617 
      if (ret_code != I40E_SUCCESS) 
                                    #line 618 
                                    goto exit;
      #line 619 
      break;
      #line 620 
      default: 
               #line 620 
      ;
      #line 621 
      break;
    }
    #line 606 
    __Cont_0: 
              #line 606 
    i ++;
  }
  #line 624 
  exit: 
        #line 624 
  ;
  #line 625 
  return ret_code;
}

#line 635  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_shutdown_lan_hmc(struct i40e_hw *hw)
{
  #line 637 
  struct i40e_hmc_lan_delete_obj_info info;
  #line 638 
  i40e_status ret_code;
  #line 640 
  info.hmc_info = & hw->hmc;
  #line 641 
  info.rsrc_type = 0U;
  #line 642 
  info.start_idx = 0U;
  #line 643 
  info.count = 1U;
  #line 646 
  ret_code = i40e_delete_lan_hmc_object(hw,& info);
  #line 649 
  i40e_free_virt_mem_d(hw,& hw->hmc.sd_table.addr);
  #line 650 
  hw->hmc.sd_table.sd_cnt = 0U;
  #line 651 
  hw->hmc.sd_table.sd_entry = (struct i40e_hmc_sd_entry *)0;
  #line 654 
  i40e_free_virt_mem_d(hw,& hw->hmc.hmc_obj_virt_mem);
  #line 655 
  hw->hmc.hmc_obj = (struct i40e_hmc_obj_info *)0;
  #line 657 
  return ret_code;
}

#line 672  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static struct i40e_context_ele i40e_hmc_txq_ce_info[19U] = {{.size_of = (unsigned short)2U, .width = (unsigned short)13U}, {.offset = (unsigned short)2U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)30U}, {.offset = (unsigned short)8U, .size_of = (unsigned short)8U, .width = (unsigned short)57U, .lsb = (unsigned short)32U}, {.offset = (unsigned short)16U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)89U}, {.offset = (unsigned short)17U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)90U}, {.offset = (unsigned short)18U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)91U}, {.offset = (unsigned short)19U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)92U}, {.offset = (unsigned short)22U, .size_of = (unsigned short)1U, .width = (unsigned short)8U, .lsb = (unsigned short)96U}, {.offset = (unsigned short)20U, .size_of = (unsigned short)2U, .width = (unsigned short)13U, .lsb = (unsigned short)128U}, {.offset = (unsigned short)23U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)160U}, {.offset = (unsigned short)24U, .size_of = (unsigned short)2U, .width = (unsigned short)13U, .lsb = (unsigned short)161U}, {.offset = (unsigned short)26U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)174U}, {.offset = (unsigned short)27U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)175U}, {.offset = (unsigned short)28U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)176U}, {.offset = (unsigned short)32U, .size_of = (unsigned short)8U, .width = (unsigned short)64U, .lsb = (unsigned short)192U}, {.offset = (unsigned short)40U, .size_of = (unsigned short)4U, .width = (unsigned short)32U, .lsb = (unsigned short)896U}, {.offset = (unsigned short)44U, .size_of = (unsigned short)2U, .width = (unsigned short)10U, .lsb = (unsigned short)980U}, {.offset = (unsigned short)46U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)990U}};
#line 698  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static struct i40e_context_ele i40e_hmc_rxq_ce_info[22U] = {{.size_of = (unsigned short)2U, .width = (unsigned short)13U}, {.offset = (unsigned short)2U, .size_of = (unsigned short)2U, .width = (unsigned short)8U, .lsb = (unsigned short)13U}, {.offset = (unsigned short)8U, .size_of = (unsigned short)8U, .width = (unsigned short)57U, .lsb = (unsigned short)32U}, {.offset = (unsigned short)16U, .size_of = (unsigned short)2U, .width = (unsigned short)13U, .lsb = (unsigned short)89U}, {.offset = (unsigned short)18U, .size_of = (unsigned short)2U, .width = (unsigned short)7U, .lsb = (unsigned short)102U}, {.offset = (unsigned short)20U, .size_of = (unsigned short)2U, .width = (unsigned short)5U, .lsb = (unsigned short)109U}, {.offset = (unsigned short)22U, .size_of = (unsigned short)1U, .width = (unsigned short)2U, .lsb = (unsigned short)114U}, {.offset = (unsigned short)23U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)116U}, {.offset = (unsigned short)24U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)117U}, {.offset = (unsigned short)25U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)118U}, {.offset = (unsigned short)26U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)119U}, {.offset = (unsigned short)27U, .size_of = (unsigned short)1U, .width = (unsigned short)4U, .lsb = (unsigned short)120U}, {.offset = (unsigned short)28U, .size_of = (unsigned short)1U, .width = (unsigned short)2U, .lsb = (unsigned short)124U}, {.offset = (unsigned short)29U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)127U}, {.offset = (unsigned short)32U, .size_of = (unsigned short)4U, .width = (unsigned short)14U, .lsb = (unsigned short)174U}, {.offset = (unsigned short)36U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)193U}, {.offset = (unsigned short)37U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)194U}, {.offset = (unsigned short)38U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)195U}, {.offset = (unsigned short)39U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)196U}, {.offset = (unsigned short)40U, .size_of = (unsigned short)2U, .width = (unsigned short)3U, .lsb = (unsigned short)198U}, {.offset = (unsigned short)42U, .size_of = (unsigned short)1U, .width = (unsigned short)1U, .lsb = (unsigned short)201U}};
#line 730  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static void i40e_write_byte(u8 *hmc_bits, struct i40e_context_ele *ce_info, u8 *src)
{
  #line 734 
  u8 src_byte;
  #line 734 
  u8 dest_byte;
  #line 734 
  u8 mask;
  #line 735 
  u8 *from;
  #line 735 
  u8 *dest;
  #line 736 
  u16 shift_width;
  #line 739 
  from = src + (unsigned long)ce_info->offset;
  #line 742 
  shift_width = (unsigned short)((unsigned int)ce_info->lsb & 7U);
  #line 743 
  mask = (unsigned char)((unsigned int)((unsigned char)(1UL << (int)ce_info->width)) + 255U);
  #line 745 
  src_byte = *from;
  #line 746 
  src_byte = (unsigned char)((int)src_byte & (int)mask);
  #line 749 
  mask = (unsigned char)((int)mask << (int)shift_width);
  #line 750 
  src_byte = (unsigned char)((int)src_byte << (int)shift_width);
  #line 753 
  dest = hmc_bits + (unsigned long)((unsigned int)ce_info->lsb / 8U);
  #line 755 
  memcpy((void *)(& dest_byte),(void *)dest,1UL);
  #line 757 
  dest_byte = (unsigned char)(~ ((int)mask) & (int)dest_byte);
  #line 758 
  dest_byte = (unsigned char)((int)dest_byte | (int)src_byte);
  #line 761 
  memcpy((void *)dest,(void *)(& dest_byte),1UL);
  #line 762 
  return;
}

#line 770  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static void i40e_write_word(u8 *hmc_bits, struct i40e_context_ele *ce_info, u8 *src)
{
  #line 774 
  u16 src_word;
  #line 774 
  u16 mask;
  #line 775 
  u8 *from;
  #line 775 
  u8 *dest;
  #line 776 
  u16 shift_width;
  #line 777 
  __le16 dest_word;
  #line 780 
  from = src + (unsigned long)ce_info->offset;
  #line 783 
  shift_width = (unsigned short)((unsigned int)ce_info->lsb & 7U);
  #line 784 
  mask = (unsigned short)((unsigned int)((unsigned short)(1UL << (int)ce_info->width)) + 65535U);
  #line 789 
  src_word = *((u16 *)from);
  #line 790 
  src_word = (unsigned short)((int)src_word & (int)mask);
  #line 793 
  mask = (unsigned short)((int)mask << (int)shift_width);
  #line 794 
  src_word = (unsigned short)((int)src_word << (int)shift_width);
  #line 797 
  dest = hmc_bits + (unsigned long)((unsigned int)ce_info->lsb / 8U);
  #line 799 
  memcpy((void *)(& dest_word),(void *)dest,2UL);
  #line 801 
  dest_word = (unsigned short)(~ ((int)mask) & (int)dest_word);
  #line 802 
  dest_word = (unsigned short)((int)dest_word | (int)src_word);
  #line 805 
  memcpy((void *)dest,(void *)(& dest_word),2UL);
  #line 806 
  return;
}

#line 814  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static void i40e_write_dword(u8 *hmc_bits, struct i40e_context_ele *ce_info, u8 *src)
{
  #line 818 
  u32 src_dword;
  #line 818 
  u32 mask;
  #line 819 
  u8 *from;
  #line 819 
  u8 *dest;
  #line 820 
  u16 shift_width;
  #line 821 
  __le32 dest_dword;
  #line 824 
  from = src + (unsigned long)ce_info->offset;
  #line 827 
  shift_width = (unsigned short)((unsigned int)ce_info->lsb & 7U);
  #line 833 
  if ((unsigned int)ce_info->width <= 31U) 
                                           #line 834 
                                           mask = (unsigned int)(1UL << (int)ce_info->width) + 4294967295U; else 
                                                                    #line 836 
                                                                    mask = 4294967295U;
  #line 841 
  src_dword = *((u32 *)from);
  #line 842 
  src_dword &= mask;
  #line 845 
  mask <<= (int)shift_width;
  #line 846 
  src_dword <<= (int)shift_width;
  #line 849 
  dest = hmc_bits + (unsigned long)((unsigned int)ce_info->lsb / 8U);
  #line 851 
  memcpy((void *)(& dest_dword),(void *)dest,4UL);
  #line 853 
  dest_dword = ~ mask & dest_dword;
  #line 854 
  dest_dword |= src_dword;
  #line 857 
  memcpy((void *)dest,(void *)(& dest_dword),4UL);
  #line 858 
  return;
}

#line 866  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static void i40e_write_qword(u8 *hmc_bits, struct i40e_context_ele *ce_info, u8 *src)
{
  #line 870 
  u64 src_qword;
  #line 870 
  u64 mask;
  #line 871 
  u8 *from;
  #line 871 
  u8 *dest;
  #line 872 
  u16 shift_width;
  #line 873 
  __le64 dest_qword;
  #line 876 
  from = src + (unsigned long)ce_info->offset;
  #line 879 
  shift_width = (unsigned short)((unsigned int)ce_info->lsb & 7U);
  #line 885 
  if ((unsigned int)ce_info->width <= 63U) 
                                           #line 886 
                                           mask = (1ULL << (int)ce_info->width) + 18446744073709551615ULL; else 
                                                                    #line 888 
                                                                    mask = 18446744073709551615ULL;
  #line 893 
  src_qword = *((u64 *)from);
  #line 894 
  src_qword &= mask;
  #line 897 
  mask <<= (int)shift_width;
  #line 898 
  src_qword <<= (int)shift_width;
  #line 901 
  dest = hmc_bits + (unsigned long)((unsigned int)ce_info->lsb / 8U);
  #line 903 
  memcpy((void *)(& dest_qword),(void *)dest,8UL);
  #line 905 
  dest_qword = ~ mask & dest_qword;
  #line 906 
  dest_qword |= src_qword;
  #line 909 
  memcpy((void *)dest,(void *)(& dest_qword),8UL);
  #line 910 
  return;
}

#line 918  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static i40e_status i40e_clear_hmc_context(struct i40e_hw *hw, u8 *context_bytes, enum i40e_hmc_lan_rsrc_type hmc_type)
{
  #line 923 
  memset((void *)context_bytes,0,(unsigned long)((unsigned int)(hw->hmc.hmc_obj + (unsigned long)hmc_type)->size));
  #line 925 
  return I40E_SUCCESS;
}

#line 934  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static i40e_status i40e_set_hmc_context(u8 *context_bytes, struct i40e_context_ele *ce_info, u8 *dest)
{
  #line 938 
  int f;
  #line 940 
  f = 0;
  #line 940 
  while ((unsigned int)(ce_info + (unsigned long)f)->width != 0U) {
    #line 946 
    switch ((int)(ce_info + (unsigned long)f)->size_of) {
      #line 947 
      case 1: 
              #line 947 
      ;
      #line 948 
      i40e_write_byte(context_bytes,ce_info + (unsigned long)f,dest);
      #line 949 
      break;
      #line 950 
      case 2: 
              #line 950 
      ;
      #line 951 
      i40e_write_word(context_bytes,ce_info + (unsigned long)f,dest);
      #line 952 
      break;
      #line 953 
      case 4: 
              #line 953 
      ;
      #line 954 
      i40e_write_dword(context_bytes,ce_info + (unsigned long)f,dest);
      #line 955 
      break;
      #line 956 
      case 8: 
              #line 956 
      ;
      #line 957 
      i40e_write_qword(context_bytes,ce_info + (unsigned long)f,dest);
      #line 958 
      break;
    }
    #line 940 
    f ++;
  }
  #line 962 
  return I40E_SUCCESS;
}

#line 976  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
static i40e_status i40e_hmc_get_object_va(struct i40e_hw *hw, u8 **object_base, enum i40e_hmc_lan_rsrc_type rsrc_type, u32 obj_idx)
{
  #line 981 
  u32 obj_offset_in_sd;
  #line 981 
  u32 obj_offset_in_pd;
  #line 982 
  struct i40e_hmc_sd_entry *sd_entry;
  #line 983 
  struct i40e_hmc_pd_entry *pd_entry;
  #line 984 
  u32 pd_idx;
  #line 984 
  u32 pd_lmt;
  #line 984 
  u32 rel_pd_idx;
  #line 986 
  u64 obj_offset_in_fpm;
  #line 987 
  u32 sd_idx;
  #line 987 
  u32 sd_lmt;
  #line 980 
  struct i40e_hmc_info *hmc_info = & hw->hmc;
  #line 985 
  i40e_status ret_code = 0;
  #line 989 
  if (hmc_info == (struct i40e_hmc_info *)0) {
    #line 990 
    ret_code = I40E_ERR_BAD_PTR;
    {
      #line 991 
      bool branch;
      #line 991 
      struct _ddebug __UNIQUE_ID_ddebug583 = {.modname = (char *)"i40e", .function = (char *)"i40e_hmc_get_object_va", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_hmc_get_object_va: bad hmc_info ptr\n", .lineno = (unsigned int)991U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 991 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug583.key.dd_key_false.key,(_Bool)0);
      #line 991 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 991 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug583,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_hmc_get_object_va: bad hmc_info ptr\n");
    }
    #line 992 
    goto exit;
  }
  #line 994 
  if (hmc_info->hmc_obj == (struct i40e_hmc_obj_info *)0) {
    #line 995 
    ret_code = I40E_ERR_BAD_PTR;
    {
      #line 996 
      bool branch_0;
      #line 996 
      struct _ddebug __UNIQUE_ID_ddebug584 = {.modname = (char *)"i40e", .function = (char *)"i40e_hmc_get_object_va", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_hmc_get_object_va: bad hmc_info->hmc_obj ptr\n", .lineno = (unsigned int)996U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 996 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug584.key.dd_key_false.key,(_Bool)0);
      #line 996 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 996 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug584,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_hmc_get_object_va: bad hmc_info->hmc_obj ptr\n");
    }
    #line 997 
    goto exit;
  }
  #line 999 
  if (object_base == (u8 **)0U) {
    #line 1000 
    ret_code = I40E_ERR_BAD_PTR;
    {
      #line 1001 
      bool branch_1;
      #line 1001 
      struct _ddebug __UNIQUE_ID_ddebug585 = {.modname = (char *)"i40e", .function = (char *)"i40e_hmc_get_object_va", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_hmc_get_object_va: bad object_base ptr\n", .lineno = (unsigned int)1001U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1001 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug585.key.dd_key_false.key,(_Bool)0);
      #line 1001 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 1001 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug585,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_hmc_get_object_va: bad object_base ptr\n");
    }
    #line 1002 
    goto exit;
  }
  #line 1004 
  if (hmc_info->signature != 1213027143U) {
    #line 1005 
    ret_code = I40E_ERR_BAD_PTR;
    {
      #line 1006 
      bool branch_2;
      #line 1006 
      struct _ddebug __UNIQUE_ID_ddebug586 = {.modname = (char *)"i40e", .function = (char *)"i40e_hmc_get_object_va", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_hmc_get_object_va: bad hmc_info->signature\n", .lineno = (unsigned int)1006U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1006 
      branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug586.key.dd_key_false.key,(_Bool)0);
      #line 1006 
      if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                    #line 1006 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug586,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_hmc_get_object_va: bad hmc_info->signature\n");
    }
    #line 1007 
    goto exit;
  }
  #line 1009 
  if ((hmc_info->hmc_obj + (unsigned long)rsrc_type)->cnt <= obj_idx) {
    {
      #line 1010 
      bool branch_3;
      #line 1010 
      struct _ddebug __UNIQUE_ID_ddebug587 = {.modname = (char *)"i40e", .function = (char *)"i40e_hmc_get_object_va", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c", .format = (char *)"i40e_hmc_get_object_va: returns error %d\n", .lineno = (unsigned int)1010U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1010 
      branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug587.key.dd_key_false.key,(_Bool)0);
      #line 1010 
      if ((long)((long)((int)branch_3 != 0)) != 0L) 
                                                    #line 1010 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug587,& (((struct i40e_pf *)hw->back)->pdev)->dev,(char *)"i40e_hmc_get_object_va: returns error %d\n",(int)ret_code);
    }
    #line 1012 
    ret_code = I40E_ERR_INVALID_HMC_OBJ_INDEX;
    #line 1013 
    goto exit;
  }
  {
    #line 1016 
    u64 fpm_addr;
    #line 1016 
    u64 fpm_limit;
    #line 1016 
    fpm_addr = (hmc_info->hmc_obj + (unsigned long)rsrc_type)->base + (hmc_info->hmc_obj + (unsigned long)rsrc_type)->size * (unsigned long long)obj_idx;
    #line 1016 
    fpm_limit = (hmc_info->hmc_obj + (unsigned long)rsrc_type)->size + fpm_addr;
    #line 1016 
    sd_idx = (unsigned int)(fpm_addr / 2097152ULL);
    #line 1016 
    sd_lmt = (unsigned int)((fpm_limit + 18446744073709551615ULL) / 2097152ULL);
    #line 1016 
    sd_lmt ++;
  }
  #line 1019 
  sd_entry = hmc_info->sd_table.sd_entry + (unsigned long)sd_idx;
  #line 1020 
  obj_offset_in_fpm = (hmc_info->hmc_obj + (unsigned long)rsrc_type)->base + (hmc_info->hmc_obj + (unsigned long)rsrc_type)->size * (unsigned long long)obj_idx;
  #line 1023 
  if (sd_entry->entry_type == (unsigned int)I40E_SD_TYPE_PAGED) {
    {
      #line 1024 
      u64 fpm_adr;
      #line 1024 
      u64 fpm_limit_0;
      #line 1024 
      fpm_adr = (hmc_info->hmc_obj + (unsigned long)rsrc_type)->base + (hmc_info->hmc_obj + (unsigned long)rsrc_type)->size * (unsigned long long)obj_idx;
      #line 1024 
      fpm_limit_0 = (hmc_info->hmc_obj + (unsigned long)rsrc_type)->size + fpm_adr;
      #line 1024 
      pd_idx = (unsigned int)(fpm_adr / 4096ULL);
      #line 1024 
      pd_lmt = (unsigned int)((fpm_limit_0 + 18446744073709551615ULL) / 4096ULL);
      #line 1024 
      pd_lmt ++;
    }
    #line 1026 
    rel_pd_idx = pd_idx & 511U;
    #line 1027 
    pd_entry = sd_entry->u.pd_table.pd_entry + (unsigned long)rel_pd_idx;
    #line 1028 
    obj_offset_in_pd = (unsigned int)obj_offset_in_fpm & 4095U;
    #line 1030 
    *object_base = (u8 *)pd_entry->bp.addr.va + (unsigned long)obj_offset_in_pd;
  }
  else {
    #line 1032 
    obj_offset_in_sd = (unsigned int)obj_offset_in_fpm & 2097151U;
    #line 1034 
    *object_base = (u8 *)sd_entry->u.bp.addr.va + (unsigned long)obj_offset_in_sd;
  }
  #line 1036 
  exit: 
        #line 1036 
  ;
  #line 1037 
  return ret_code;
}

#line 1045  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_clear_lan_tx_queue_context(struct i40e_hw *hw, u16 queue)
{
  #line 1048 
  i40e_status err;
  #line 1049 
  u8 *context_bytes;
  #line 1051 
  err = i40e_hmc_get_object_va(hw,& context_bytes,(enum i40e_hmc_lan_rsrc_type)I40E_HMC_LAN_TX,(unsigned int)queue);
  #line 1053 
  if (err < I40E_SUCCESS) 
                          #line 1054 
                          return err;
  #line 1056 
  return i40e_clear_hmc_context(hw,context_bytes,
                             (enum i40e_hmc_lan_rsrc_type)I40E_HMC_LAN_TX);
}

#line 1065  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_set_lan_tx_queue_context(struct i40e_hw *hw, u16 queue, struct i40e_hmc_obj_txq *s)
{
  #line 1069 
  i40e_status err;
  #line 1070 
  u8 *context_bytes;
  #line 1072 
  err = i40e_hmc_get_object_va(hw,& context_bytes,(enum i40e_hmc_lan_rsrc_type)I40E_HMC_LAN_TX,(unsigned int)queue);
  #line 1074 
  if (err < I40E_SUCCESS) 
                          #line 1075 
                          return err;
  #line 1077 
  return i40e_set_hmc_context(context_bytes,
                           (struct i40e_context_ele *)(& i40e_hmc_txq_ce_info),
                           (u8 *)s);
}

#line 1086  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_clear_lan_rx_queue_context(struct i40e_hw *hw, u16 queue)
{
  #line 1089 
  i40e_status err;
  #line 1090 
  u8 *context_bytes;
  #line 1092 
  err = i40e_hmc_get_object_va(hw,& context_bytes,(enum i40e_hmc_lan_rsrc_type)I40E_HMC_LAN_RX,(unsigned int)queue);
  #line 1094 
  if (err < I40E_SUCCESS) 
                          #line 1095 
                          return err;
  #line 1097 
  return i40e_clear_hmc_context(hw,context_bytes,
                             (enum i40e_hmc_lan_rsrc_type)I40E_HMC_LAN_RX);
}

#line 1106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c"
i40e_status i40e_set_lan_rx_queue_context(struct i40e_hw *hw, u16 queue, struct i40e_hmc_obj_rxq *s)
{
  #line 1110 
  i40e_status err;
  #line 1111 
  u8 *context_bytes;
  #line 1113 
  err = i40e_hmc_get_object_va(hw,& context_bytes,(enum i40e_hmc_lan_rsrc_type)I40E_HMC_LAN_RX,(unsigned int)queue);
  #line 1115 
  if (err < I40E_SUCCESS) 
                          #line 1116 
                          return err;
  #line 1118 
  return i40e_set_hmc_context(context_bytes,
                           (struct i40e_context_ele *)(& i40e_hmc_rxq_ce_info),
                           (u8 *)s);
}

/* compiler builtin: 
   unsigned int __builtin_bswap32(unsigned int);   */
/* compiler builtin: 
   void __builtin_prefetch(void const * , ...);   */
/* compiler builtin: 
   void __builtin_unreachable(void);   */
#line 4  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
#line 4 
void ldv_atomic_add(int i, atomic_t *v);
#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static bool arch_test_and_set_bit_lock(long nr, unsigned long *addr)
{
  #line 144 
  return arch_test_and_set_bit(nr,addr);
}

#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 120  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
static void cif_set_bit_0(long nr, unsigned long *addr);
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 127  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
static void cif_clear_bit_0(long nr, unsigned long *addr);
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-lock.h"
__inline static bool test_and_set_bit_lock(long nr, unsigned long *addr)
{
  #line 55 
  kasan_check_read((void *)(addr + (unsigned long)(nr / 64L)),8U);
  #line 56 
  return arch_test_and_set_bit_lock(nr,addr);
}

#line 198  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
__inline static bool static_key_false(struct static_key *key)
{
  #line 200 
  return arch_static_branch(key,(_Bool)0);
}

#line 205  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernel.h"
#line 205 
void __cant_sleep(char *, int, int);
#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/percpu.h"
#line 88 
void __bad_percpu_size(void);
#line 309  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/percpu-defs.h"
#line 309 
void __bad_size_call_parameter(void);
#line 314  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/percpu-defs.h"
__inline static void __this_cpu_preempt_check(char *op)
{
  #line 316 
  return;
}

#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/page_64.h"
#line 14 
extern unsigned long page_offset_base;
#line 15 
#line 15 
extern unsigned long vmalloc_base;
#line 16 
#line 16 
extern unsigned long vmemmap_base;
#line 29 
#line 29 
unsigned long __phys_addr(unsigned long);
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/cmpxchg.h"
#line 17 
void __xadd_wrong_size(void);
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/cmpxchg_64.h"
__inline static int arch_atomic_read(atomic_t *v)
{
  #line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
  union __anonunion___u_6652 __u;
  #line 31 
  __read_once_size((void *)(& v->counter),(void *)(& __u.__c),4);
  #line 31 
  return (__u.__val);
}

#line 182  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
__inline static int arch_atomic_fetch_add(int i, atomic_t *v)
{
  #line 184 
  int __ret;
  #line 184 
  __ret = i;
  #line 184 
  switch (4UL) {
    #line 184 
    case (unsigned long)1: 
                           #line 184 
    ;
    #line 185 
    ldv_inline_asm();
    #line 184 
    break;
    #line 184 
    case (unsigned long)2: 
                           #line 184 
    ;
    #line 185 
    ldv_inline_asm();
    #line 184 
    break;
    #line 184 
    case (unsigned long)4: 
                           #line 184 
    ;
    #line 185 
    ldv_inline_asm();
    #line 184 
    break;
    #line 184 
    case (unsigned long)8: 
                           #line 184 
    ;
    #line 185 
    ldv_inline_asm();
    #line 184 
    break;
    #line 184 
    default: 
             #line 184 
    ;
    #line 184 
    __xadd_wrong_size();
  }
  #line 184 
  return __ret;
}

#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/atomic-instrumented.h"
__inline static int atomic_read(atomic_t *v)
{
  #line 26 
  kasan_check_read((void *)v,4U);
  #line 27 
  return arch_atomic_read(v);
}

#line 60 
#line 162  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
static void atomic_add(int i, atomic_t *v);
#line 109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/atomic-instrumented.h"
__inline static int atomic_fetch_add(int i, atomic_t *v)
{
  #line 111 
  kasan_check_read((void *)v,4U);
  #line 112 
  return arch_atomic_fetch_add(i,v);
}

#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
#line 39 
extern unsigned int nr_cpu_ids;
#line 91 
#line 91 
extern struct cpumask __cpu_online_mask;
#line 134  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
__inline static void cpu_max_bits_warn(unsigned int cpu, unsigned int bits)
{
  #line 137 
  int __ret_warn_on = cpu >= bits;
  #line 137 
  if ((long)(__ret_warn_on != 0) != 0L) {
    #line 138 
    ldv_inline_asm();
    #line 139 
    ldv_inline_asm();
  }
  #line 137 
  long tmp = (long)(__ret_warn_on != 0);
  #line 139 
  return;
}

#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu)
{
  #line 144 
  cpu_max_bits_warn(cpu,nr_cpu_ids);
  #line 145 
  return cpu;
}

#line 358  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
__inline static int cpumask_test_cpu(int cpu, struct cpumask *cpumask)
{
  #line 360 
  ;
  #line 360 
  return (int)test_bit((long)cpumask_check((unsigned int)cpu),
                 (unsigned long *)(& cpumask->bits));
}

#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 204  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
static void *ERR_PTR(long error);
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 211  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
static long PTR_ERR_0(void *ptr);
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 218  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
static bool IS_ERR_0(void *ptr);
#line 834  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/processor.h"
__inline static void prefetchw(void *x)
{
  #line 836 
  ldv_inline_asm();
  #line 837 
  return;
}

#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/cpufeature.h"
__inline static bool _static_cpu_has(u16 bit)
{
  #line 177 
  ldv_inline_asm();
  #line 178 
  ldv_inline_asm();
  #line 211 
  t_yes: 
         #line 211 
  ;
  #line 212 
  return (_Bool)1;
  #line 213 
  t_no: 
        #line 213 
  ;
  #line 214 
  return (_Bool)0;
}

#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val)
{
  #line 79 
  int tmp;
  #line 79 
  if (0 != 0 && (val == 1 || val == -1)) 
                                         #line 79 
                                         tmp = val; else 
                                                         #line 79 
                                                         tmp = 0;
  #line 79 
  int pao_ID__ = tmp;
  #line 79 
  switch (4UL) {
    #line 79 
    case (unsigned long)1: 
                           #line 79 
    ;
    #line 79 
    if (pao_ID__ == 1) 
                       #line 81 
                       ldv_inline_asm();
    else 
      #line 79 
      if (pao_ID__ == -1) 
                          #line 81 
                          ldv_inline_asm(); else 
                                                 #line 84 
                                                 ldv_inline_asm();
    #line 79 
    break;
    #line 79 
    case (unsigned long)2: 
                           #line 79 
    ;
    #line 79 
    if (pao_ID__ == 1) 
                       #line 81 
                       ldv_inline_asm();
    else 
      #line 79 
      if (pao_ID__ == -1) 
                          #line 81 
                          ldv_inline_asm(); else 
                                                 #line 84 
                                                 ldv_inline_asm();
    #line 79 
    break;
    #line 79 
    case (unsigned long)4: 
                           #line 79 
    ;
    #line 79 
    if (pao_ID__ == 1) 
                       #line 81 
                       ldv_inline_asm();
    else 
      #line 79 
      if (pao_ID__ == -1) 
                          #line 81 
                          ldv_inline_asm(); else 
                                                 #line 84 
                                                 ldv_inline_asm();
    #line 79 
    break;
    #line 79 
    case (unsigned long)8: 
                           #line 79 
    ;
    #line 79 
    if (pao_ID__ == 1) 
                       #line 81 
                       ldv_inline_asm();
    else 
      #line 79 
      if (pao_ID__ == -1) 
                          #line 81 
                          ldv_inline_asm(); else 
                                                 #line 84 
                                                 ldv_inline_asm();
    #line 79 
    break;
    #line 79 
    default: 
             #line 79 
    ;
    #line 79 
    __bad_percpu_size();
  }
  #line 82 
  return;
}

#line 82  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val)
{
  #line 84 
  int tmp;
  #line 84 
  if (0 != 0 && (val == -1 || val == 1)) 
                                         #line 84 
                                         tmp = - val; else 
                                                           #line 84 
                                                           tmp = 0;
  #line 84 
  int pao_ID__ = tmp;
  #line 84 
  switch (4UL) {
    #line 84 
    case (unsigned long)1: 
                           #line 84 
    ;
    #line 84 
    if (pao_ID__ == 1) 
                       #line 86 
                       ldv_inline_asm();
    else 
      #line 84 
      if (pao_ID__ == -1) 
                          #line 86 
                          ldv_inline_asm(); else 
                                                 #line 89 
                                                 ldv_inline_asm();
    #line 84 
    break;
    #line 84 
    case (unsigned long)2: 
                           #line 84 
    ;
    #line 84 
    if (pao_ID__ == 1) 
                       #line 86 
                       ldv_inline_asm();
    else 
      #line 84 
      if (pao_ID__ == -1) 
                          #line 86 
                          ldv_inline_asm(); else 
                                                 #line 89 
                                                 ldv_inline_asm();
    #line 84 
    break;
    #line 84 
    case (unsigned long)4: 
                           #line 84 
    ;
    #line 84 
    if (pao_ID__ == 1) 
                       #line 86 
                       ldv_inline_asm();
    else 
      #line 84 
      if (pao_ID__ == -1) 
                          #line 86 
                          ldv_inline_asm(); else 
                                                 #line 89 
                                                 ldv_inline_asm();
    #line 84 
    break;
    #line 84 
    case (unsigned long)8: 
                           #line 84 
    ;
    #line 84 
    if (pao_ID__ == 1) 
                       #line 86 
                       ldv_inline_asm();
    else 
      #line 84 
      if (pao_ID__ == -1) 
                          #line 86 
                          ldv_inline_asm(); else 
                                                 #line 89 
                                                 ldv_inline_asm();
    #line 84 
    break;
    #line 84 
    default: 
             #line 84 
    ;
    #line 84 
    __bad_percpu_size();
  }
  #line 87 
  return;
}

#line 348  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
#line 348 
void lock_acquire(struct lockdep_map *, unsigned int, int, int, int, struct lockdep_map *, unsigned long);
#line 352 
#line 352 
void lock_release(struct lockdep_map *, unsigned long);
#line 658 
#line 658 
void lockdep_rcu_suspicious(char *, int, char *);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/err.h"
#line 25 
void *ldv_err_ptr(long error);
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/delay.h"
#line 60 
unsigned long msleep_interruptible(unsigned int);
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmdebug.h"
#line 12 
void dump_page(struct page *, char *);
#line 410  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nodemask.h"
#line 410 
extern nodemask_t node_states[5U];
#line 413  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nodemask.h"
__inline static int node_state(int node, enum node_states state)
{
  #line 415 
  return (int)test_bit((long)node,
               (unsigned long *)(& node_states[(unsigned int)state].bits));
}

#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
__inline static void __rcu_read_lock(void)
{
  #line 59 
  __preempt_count_add(1);
  #line 60 
  ldv_inline_asm();
  #line 62 
  return;
}

#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
__inline static void __rcu_read_unlock(void)
{
  #line 66 
  ldv_inline_asm();
  #line 64 
  __preempt_count_sub(1);
  #line 66 
  return;
}

#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcutree.h"
#line 56 
bool rcu_is_watching(void);
#line 206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
__inline static void rcu_lock_acquire(struct lockdep_map *map)
{
  #line 208 
  __here_0: 
            #line 208 
  ;
  #line 208 
  ;
  #line 208 
  lock_acquire(map,0U,0,2,0,(struct lockdep_map *)0,(unsigned long)((void *)0));
  #line 210 
  return;
}

#line 211  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
__inline static void rcu_lock_release(struct lockdep_map *map)
{
  #line 213 
  __here_0: 
            #line 213 
  ;
  #line 213 
  ;
  #line 213 
  lock_release(map,(unsigned long)((void *)0));
  #line 215 
  return;
}

#line 216 
#line 216 
extern struct lockdep_map rcu_lock_map;
#line 220 
#line 220 
int debug_lockdep_rcu_enabled(void);
#line 223 
#line 223 
int rcu_read_lock_sched_held(void);
#line 613  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
__inline static void rcu_read_lock(void)
{
  #line 615 
  __rcu_read_lock();
  #line 617 
  rcu_lock_acquire(& rcu_lock_map);
  {
    #line 618 
    bool __warned;
    #line 618 
    if (debug_lockdep_rcu_enabled() != 0) 
      #line 618 
      if (! __warned) {
        #line 618 
        if (! rcu_is_watching()) {
          #line 618 
          __warned = (_Bool)1;
          #line 618 
          lockdep_rcu_suspicious((char *)"./include/linux/rcupdate.h",618,(char *)"rcu_read_lock() used illegally while idle");
        }
      }
  }
  #line 621 
  return;
}

#line 665  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
__inline static void rcu_read_unlock(void)
{
  {
    #line 667 
    bool __warned;
    #line 667 
    if (debug_lockdep_rcu_enabled() != 0) 
      #line 667 
      if (! __warned) {
        #line 667 
        if (! rcu_is_watching()) {
          #line 667 
          __warned = (_Bool)1;
          #line 667 
          lockdep_rcu_suspicious((char *)"./include/linux/rcupdate.h",667,(char *)"rcu_read_unlock() used illegally while idle");
        }
      }
  }
  #line 670 
  __rcu_read_unlock();
  #line 671 
  rcu_lock_release(& rcu_lock_map);
  #line 672 
  return;
}

#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
__inline static void dql_queued(struct dql *dql, unsigned int count)
{
  #line 75 
  if ((long)(count > 268435455U) != 0L) {
    #line 76 
    ldv_inline_asm();
    #line 77 
    ldv_inline_asm();
    #line 78 
    ldv_inline_asm();
    #line 75 
    ;
  }
  #line 77 
  dql->last_obj_cnt = count;
  #line 78 
  ldv_inline_asm();
  #line 86 
  dql->num_queued += count;
  #line 87 
  return;
}

#line 90  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
__inline static int dql_avail(struct dql *dql)
{
  #line 93 
  union __anonunion___u_6834 __u;
  #line 93 
  union __anonunion___u_6836 __u_0;
  #line 92 
  unsigned int tmp;
  #line 92 
  __read_once_size((void *)(& dql->adj_limit),(void *)(& __u.__c),4);
  #line 92 
  tmp = __u.__val;
  #line 92 
  __read_once_size((void *)(& dql->num_queued),(void *)(& __u_0.__c),4);
  #line 92 
  return (int)(tmp - (__u_0.__val));
}

#line 96 
#line 96 
void dql_completed(struct dql *, unsigned int);
#line 99 
#line 99 
void dql_reset(struct dql *);
#line 114  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/refcount.h"
#line 114 
void refcount_warn_saturate(refcount_t *, enum refcount_saturation_type);
#line 186  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/refcount.h"
__inline static void refcount_add(int i, refcount_t *r)
{
  #line 188 
  int old = atomic_fetch_add(i,& r->refs);
  #line 190 
  if ((long)(old == 0) != 0L) 
                              #line 191 
                              refcount_warn_saturate(r,(enum refcount_saturation_type)REFCOUNT_ADD_UAF);
  else 
    #line 192 
    if ((long)(old < 0) != 0L || (long)(old + i < 0) != 0L) 
                                                            #line 193 
                                                            refcount_warn_saturate(r,(enum refcount_saturation_type)REFCOUNT_ADD_OVF);
  #line 194 
  return;
}

#line 226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/refcount.h"
__inline static void refcount_inc(refcount_t *r)
{
  #line 228 
  refcount_add(1,r);
  #line 229 
  return;
}

#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/page-flags.h"
__inline static struct page *compound_head(struct page *page)
{
  #line 175 
  union __anonunion___u_6840 __u;
  #line 174 
  __read_once_size((void *)(& page->__anonCompField_page_43.__anonCompField___anonunion_129_38.compound_head),(void *)(& __u.__c),8);
  #line 174 
  unsigned long head = (__u.__val);
  #line 176 
  if ((long)((head & 1UL) != 0UL) != 0L) 
                                         #line 177 
                                         return (struct page *)(head + 18446744073709551615UL);
  #line 178 
  return page;
}

#line 192  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/page-flags.h"
__inline static int PagePoisoned(struct page *page)
{
  #line 194 
  return page->flags == 18446744073709551615UL;
}

#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/topology.h"
__inline static int numa_node_id(void)
{
  #line 88 
  int pscr_ret__;
  {
    #line 88 
    void *__vpp_verify = (void *)0;
    #line 88 
    void *tmp = __vpp_verify;
  }
  #line 88 
  switch (4UL) {
    #line 88 
    int pfo_ret__;
    #line 88 
    int pfo_ret___0;
    #line 88 
    int pfo_ret___1;
    #line 88 
    int pfo_ret___2;
    #line 88 
    case (unsigned long)1: 
                           #line 88 
    ;
    #line 88 
    switch (4UL) {
      #line 88 
      case (unsigned long)1: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)2: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)4: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)8: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      default: 
               #line 88 
      ;
      #line 88 
      __bad_percpu_size();
    }
    #line 88 
    pscr_ret__ = pfo_ret__;
    #line 88 
    break;
    #line 88 
    case (unsigned long)2: 
                           #line 88 
    ;
    #line 88 
    switch (4UL) {
      #line 88 
      case (unsigned long)1: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)2: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)4: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)8: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      default: 
               #line 88 
      ;
      #line 88 
      __bad_percpu_size();
    }
    #line 88 
    pscr_ret__ = pfo_ret___0;
    #line 88 
    break;
    #line 88 
    case (unsigned long)4: 
                           #line 88 
    ;
    #line 88 
    switch (4UL) {
      #line 88 
      case (unsigned long)1: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)2: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)4: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)8: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      default: 
               #line 88 
      ;
      #line 88 
      __bad_percpu_size();
    }
    #line 88 
    pscr_ret__ = pfo_ret___1;
    #line 88 
    break;
    #line 88 
    case (unsigned long)8: 
                           #line 88 
    ;
    #line 88 
    switch (4UL) {
      #line 88 
      case (unsigned long)1: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)2: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)4: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      case (unsigned long)8: 
                             #line 88 
      ;
      #line 89 
      ldv_inline_asm();
      #line 88 
      break;
      #line 88 
      default: 
               #line 88 
      ;
      #line 88 
      __bad_percpu_size();
    }
    #line 88 
    pscr_ret__ = pfo_ret___2;
    #line 88 
    break;
    #line 88 
    default: 
             #line 88 
    ;
    #line 88 
    __bad_size_call_parameter();
    #line 88 
    break;
  }
  #line 88 
  return pscr_ret__;
}

#line 177  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/topology.h"
__inline static int numa_mem_id(void)
{
  #line 179 
  return numa_node_id();
}

#line 490  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/gfp.h"
#line 490 
struct page *__alloc_pages_nodemask(gfp_t, unsigned int, int, nodemask_t *);
#line 494  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/gfp.h"
__inline static struct page *__alloc_pages(gfp_t gfp_mask, unsigned int order, int preferred_nid)
{
  #line 496 
  return __alloc_pages_nodemask(gfp_mask,order,preferred_nid,(nodemask_t *)0);
}

#line 504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/gfp.h"
__inline static struct page *__alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)
{
  #line 506 
  if ((long)((unsigned int)nid > 1023U) != 0L) {
    #line 507 
    ldv_inline_asm();
    #line 508 
    ldv_inline_asm();
    #line 509 
    ldv_inline_asm();
    #line 506 
    ;
  }
  {
    #line 507 
    int tmp_0;
    #line 507 
    if ((gfp_mask & 2097152U) != 0U) {
      #line 507 
      if (node_state(nid,(enum node_states)N_ONLINE) == 0) 
                                                           #line 507 
                                                           tmp_0 = 1; else 
                                                                    #line 507 
                                                                    tmp_0 = 0;
    }
    else 
         #line 507 
         tmp_0 = 0;
    #line 507 
    int __ret_warn_on = tmp_0;
    #line 507 
    if ((long)(__ret_warn_on != 0) != 0L) {
      #line 508 
      ldv_inline_asm();
      #line 509 
      ldv_inline_asm();
    }
    #line 507 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  #line 509 
  return __alloc_pages(gfp_mask,order,nid);
}

#line 517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/gfp.h"
__inline static struct page *alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)
{
  #line 520 
  if (nid == -1) 
                 #line 521 
                 nid = numa_mem_id();
  #line 523 
  return __alloc_pages_node(nid,gfp_mask,order);
}

#line 566 
#line 566 
void __free_pages(struct page *, unsigned int);
#line 572 
#line 572 
void __page_frag_cache_drain(struct page *, unsigned int);
#line 668  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 365  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
static void *kzalloc_0(size_t size, gfp_t flags);
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/page_ref.h"
#line 11 
extern struct tracepoint __tracepoint_page_ref_mod;
#line 30 
#line 30 
void __page_ref_mod(struct page *, int);
#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/page_ref.h"
__inline static int page_count(struct page *page)
{
  #line 72 
  return atomic_read(& compound_head(page)->_refcount);
}

#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/page_ref.h"
__inline static void page_ref_add(struct page *page, int nr)
{
  #line 93 
  atomic_add(nr,& page->_refcount);
  #line 94 
  if ((int)static_key_false(& __tracepoint_page_ref_mod.key) != 0) 
                                                                   #line 95 
                                                                   __page_ref_mod(page,nr);
  #line 96 
  return;
}

#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
__inline static bool is_vmalloc_addr(void *x)
{
  #line 633 
  int tmp_1;
  #line 631 
  unsigned long addr = (unsigned long)x;
  #line 633 
  if (addr >= vmalloc_base) {
    #line 633 
    unsigned long tmp_0;
    #line 633 
    if ((int)_static_cpu_has((unsigned short)528) != 0) 
                                                        #line 633 
                                                        tmp_0 = 14073748835532800UL; else 
                                                                    #line 633 
                                                                    tmp_0 = 35184372088832UL;
    #line 633 
    ;
    #line 633 
    if ((tmp_0 + vmalloc_base) + 18446744073709551615UL > addr) 
                                                                #line 633 
                                                                tmp_1 = 1; else 
                                                                    #line 633 
                                                                    tmp_1 = 0;
  }
  else 
       #line 633 
       tmp_1 = 0;
  #line 633 
  return (_Bool)(tmp_1 != 0);
}

#line 1083  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
__inline static int page_to_nid(struct page *page)
{
  #line 1085 
  struct page *p = page;
  {
    #line 1087 
    if ((long)(PagePoisoned(p) != 0) != 0L) {
      #line 1087 
      dump_page(p,(char *)"VM_BUG_ON_PAGE(");
      #line 1088 
      ldv_inline_asm();
      #line 1089 
      ldv_inline_asm();
      #line 1090 
      ldv_inline_asm();
      #line 1087 
      ;
    }
  }
  #line 1087 
  ;
  #line 1087 
  return (int)(p->flags >> 54UL) & 1023;
}

#line 1299  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page *page)
{
  #line 1301 
  return (void *)((unsigned long)((unsigned long long)((page - (struct page *)vmemmap_base) / 64L) << 12) + page_offset_base);
}

#line 1369  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
__inline static bool page_is_pfmemalloc(struct page *page)
{
  #line 1375 
  return (_Bool)(page->__anonCompField_page_43.__anonCompField___anonunion_129_31.index == 18446744073709551615UL);
}

#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/checksum_64.h"
__inline static __sum16 csum_fold(__wsum sum)
{
  #line 25 
  ldv_inline_asm();
  #line 30 
  return (unsigned short)(~ sum >> 16);
}

#line 183  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/checksum_64.h"
__inline static unsigned int add32_with_carry(unsigned int a, unsigned int b)
{
  #line 185 
  ldv_inline_asm();
  #line 189 
  return a;
}

#line 193  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/checksum_64.h"
__inline static __wsum csum_add(__wsum csum, __wsum addend)
{
  #line 195 
  return add32_with_carry(csum,addend);
}

#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/checksum.h"
__inline static __wsum csum_unfold(__sum16 n)
{
  #line 109 
  return (unsigned int)n;
}

#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/checksum.h"
__inline static void csum_replace_by_diff(__sum16 *sum, __wsum diff)
{
  #line 121 
  ;
  #line 121 
  *sum = csum_fold(csum_add(diff,~ csum_unfold((unsigned short)((int)*sum))));
  #line 122 
  return;
}

#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
__inline static char *kobject_name(struct kobject *kobj)
{
  #line 91 
  return kobj->name;
}

#line 1370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
__inline static char *dev_name(struct device *dev)
{
  #line 1373 
  if (dev->init_name != (char *)0) 
                                   #line 1374 
                                   return dev->init_name;
  #line 1376 
  return kobject_name(& dev->kobj);
}

#line 1680 
#line 1680 
char *dev_driver_string(struct device *);
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-debug.h"
#line 21 
void debug_dma_map_single(struct device *, void *, unsigned long);
#line 24 
#line 24 
void debug_dma_map_page(struct device *, struct page *, size_t, size_t, int, dma_addr_t);
#line 28 
#line 28 
void debug_dma_mapping_error(struct device *, dma_addr_t);
#line 30 
#line 30 
void debug_dma_unmap_page(struct device *, dma_addr_t, size_t, int);
#line 52 
#line 52 
void debug_dma_sync_single_for_cpu(struct device *, dma_addr_t, size_t, int);
#line 56 
#line 56 
void debug_dma_sync_single_for_device(struct device *, dma_addr_t, size_t, int);
#line 143  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction)
{
  #line 146 
  return (unsigned int)dma_direction <= 2U;
}

#line 191  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static bool dma_is_direct(struct dma_map_ops *ops)
{
  #line 193 
  return (_Bool)((long)(ops == (struct dma_map_ops *)0) != 0L);
}

#line 200 
#line 200 
dma_addr_t dma_direct_map_page(struct device *, struct page *, unsigned long, size_t, enum dma_data_direction, unsigned long);
#line 210 
#line 210 
void dma_direct_sync_single_for_device(struct device *, dma_addr_t, size_t, enum dma_data_direction);
#line 228 
#line 228 
void dma_direct_unmap_page(struct device *, dma_addr_t, size_t, enum dma_data_direction, unsigned long);
#line 232 
#line 232 
void dma_direct_sync_single_for_cpu(struct device *, dma_addr_t, size_t, enum dma_data_direction);
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/dma-mapping.h"
#line 19 
extern struct dma_map_ops *dma_ops;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_arch_dma_ops(struct bus_type *bus)
{
  #line 23 
  return dma_ops;
}

#line 261  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev)
{
  #line 263 
  if (dev->dma_ops != (struct dma_map_ops *)0) 
                                               #line 264 
                                               return dev->dma_ops;
  #line 265 
  return get_arch_dma_ops(dev->bus);
}

#line 274  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static dma_addr_t dma_map_page_attrs(struct device *dev, struct page *page, size_t offset, size_t size, enum dma_data_direction dir, unsigned long attrs)
{
  #line 279 
  dma_addr_t addr;
  #line 278 
  struct dma_map_ops *ops = get_dma_ops(dev);
  #line 281 
  if ((long)(valid_dma_direction((int)dir) == 0) != 0L) {
    #line 282 
    ldv_inline_asm();
    #line 283 
    ldv_inline_asm();
    #line 284 
    ldv_inline_asm();
    #line 281 
    ;
  }
  #line 282 
  if ((int)dma_is_direct(ops) != 0) 
                                    #line 283 
                                    addr = dma_direct_map_page(dev,page,offset,size,dir,attrs); else 
                                                                    #line 285 
                                                                    addr = (*(ops->map_page))(dev,page,offset,size,dir,attrs);
  #line 286 
  debug_dma_map_page(dev,page,offset,size,(int)dir,addr);
  #line 288 
  return addr;
}

#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_unmap_page_attrs(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir, unsigned long attrs)
{
  #line 294 
  struct dma_map_ops *ops = get_dma_ops(dev);
  #line 296 
  if ((long)(valid_dma_direction((int)dir) == 0) != 0L) {
    #line 297 
    ldv_inline_asm();
    #line 298 
    ldv_inline_asm();
    #line 299 
    ldv_inline_asm();
    #line 296 
    ;
  }
  #line 297 
  if ((int)dma_is_direct(ops) != 0) 
                                    #line 298 
                                    dma_direct_unmap_page(dev,addr,size,dir,attrs);
  else 
    #line 299 
    if (ops->unmap_page != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction , unsigned long ))0) 
      #line 300 
      (*(ops->unmap_page))(dev,addr,size,dir,attrs);
  #line 301 
  debug_dma_unmap_page(dev,addr,size,(int)dir);
  #line 302 
  return;
}

#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  #line 380 
  struct dma_map_ops *ops = get_dma_ops(dev);
  #line 382 
  if ((long)(valid_dma_direction((int)dir) == 0) != 0L) {
    #line 383 
    ldv_inline_asm();
    #line 384 
    ldv_inline_asm();
    #line 385 
    ldv_inline_asm();
    #line 382 
    ;
  }
  #line 383 
  if ((int)dma_is_direct(ops) != 0) 
                                    #line 384 
                                    dma_direct_sync_single_for_cpu(dev,addr,size,dir);
  else 
    #line 385 
    if (ops->sync_single_for_cpu != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
      #line 386 
      (*(ops->sync_single_for_cpu))(dev,addr,size,dir);
  #line 387 
  debug_dma_sync_single_for_cpu(dev,addr,size,(int)dir);
  #line 388 
  return;
}

#line 390  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_sync_single_for_device(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
{
  #line 394 
  struct dma_map_ops *ops = get_dma_ops(dev);
  #line 396 
  if ((long)(valid_dma_direction((int)dir) == 0) != 0L) {
    #line 397 
    ldv_inline_asm();
    #line 398 
    ldv_inline_asm();
    #line 399 
    ldv_inline_asm();
    #line 396 
    ;
  }
  #line 397 
  if ((int)dma_is_direct(ops) != 0) 
                                    #line 398 
                                    dma_direct_sync_single_for_device(dev,addr,size,dir);
  else 
    #line 399 
    if (ops->sync_single_for_device != (void (*)(struct device *, dma_addr_t , size_t , enum dma_data_direction ))0) 
      #line 400 
      (*(ops->sync_single_for_device))(dev,addr,size,dir);
  #line 401 
  debug_dma_sync_single_for_device(dev,addr,size,(int)dir);
  #line 402 
  return;
}

#line 433  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
  #line 435 
  debug_dma_mapping_error(dev,dma_addr);
  #line 437 
  if (dma_addr == 18446744073709551615ULL) 
                                           #line 438 
                                           return -12;
  #line 439 
  return 0;
}

#line 442 
#line 442 
void *dma_alloc_attrs(struct device *, size_t, dma_addr_t *, gfp_t, unsigned long);
#line 444 
#line 444 
void dma_free_attrs(struct device *, size_t, void *, dma_addr_t, unsigned long);
#line 580  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr, size_t size, enum dma_data_direction dir, unsigned long attrs)
{
  #line 584 
  int __ret_warn_once;
  {
    #line 584 
    bool __warned;
    #line 584 
    __ret_warn_once = (int)is_vmalloc_addr(ptr) != 0;
    #line 584 
    if ((long)(__ret_warn_once != 0) != 0L && (long)(! __warned) != 0L) {
      #line 584 
      __warned = (_Bool)1;
      {
        #line 584 
        int __ret_warn_on = 1;
        #line 584 
        if ((long)(__ret_warn_on != 0) != 0L) {
          #line 584 
          __warn_printk((char *)"%s %s: ",dev_driver_string(dev),dev_name(dev));
          #line 585 
          ldv_inline_asm();
          #line 586 
          ldv_inline_asm();
        }
        #line 584 
        long tmp_2 = (long)(__ret_warn_on != 0);
      }
    }
    }
  #line 584 
  if ((long)((long)(__ret_warn_once != 0)) != 0L) 
                                                  #line 586 
                                                  return 18446744073709551615ULL;
  #line 587 
  debug_dma_map_single(dev,ptr,size);
  #line 588 
  ;
  #line 588 
  ;
  #line 588 
  ;
  #line 588 
  ;
  #line 588 
  ;
  #line 588 
  ;
  #line 588 
  return dma_map_page_attrs(dev,
                           (struct page *)((__phys_addr((unsigned long)ptr) >> 12) + vmemmap_base),
                           (unsigned long)ptr & 4095UL,size,dir,attrs);
}

#line 592  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir, unsigned long attrs)
{
  #line 595 
  dma_unmap_page_attrs(dev,addr,size,dir,attrs);
  #line 596 
  return;
}

#line 598  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_sync_single_range_for_cpu(struct device *dev, dma_addr_t addr, unsigned long offset, size_t size, enum dma_data_direction dir)
{
  #line 602 
  dma_sync_single_for_cpu(dev,addr + (unsigned long long)offset,size,dir);
  #line 603 
  return;
}

#line 605  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_sync_single_range_for_device(struct device *dev, dma_addr_t addr, unsigned long offset, size_t size, enum dma_data_direction dir)
{
  #line 609 
  dma_sync_single_for_device(dev,addr + (unsigned long long)offset,size,dir);
  #line 610 
  return;
}

#line 641  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void *dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t gfp)
{
  #line 645 
  return dma_alloc_attrs(dev,size,dma_handle,gfp,
                      (unsigned long)(gfp >> 5) & 256UL);
}

#line 649  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t dma_handle)
{
  #line 652 
  dma_free_attrs(dev,size,cpu_addr,dma_handle,0UL);
  #line 653 
  return;
}

#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/clock.h"
#line 15 
unsigned long long sched_clock(void);
#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t *frag)
{
  #line 327 
  return frag->bv_len;
}

#line 1023 
#line 1023 
void consume_skb(struct sk_buff *);
#line 1035 
#line 1035 
struct sk_buff *build_skb(void *, unsigned int);
#line 1116 
#line 1116 
int pskb_expand_head(struct sk_buff *, int, int, gfp_t);
#line 1126 
#line 1126 
int __skb_pad(struct sk_buff *, int, bool);
#line 1214  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void __skb_set_hash(struct sk_buff *skb, __u32 hash, bool is_sw, bool is_l4)
{
  #line 1216 
  skb->l4_hash = (unsigned char)is_l4;
  #line 1217 
  skb->sw_hash = (unsigned char)is_sw;
  #line 1218 
  skb->hash = hash;
  #line 1219 
  return;
}

#line 1222  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_set_hash(struct sk_buff *skb, __u32 hash, enum pkt_hash_types type)
{
  #line 1225 
  __skb_set_hash(skb,hash,(_Bool)0,(_Bool)(type == (unsigned int)PKT_HASH_TYPE_L4));
  #line 1226 
  return;
}

#line 1580  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct sk_buff *skb_get(struct sk_buff *skb)
{
  #line 1582 
  refcount_inc(& skb->users);
  #line 1583 
  return skb;
}

#line 1621  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int skb_header_cloned(struct sk_buff *skb)
{
  #line 1623 
  int dataref;
  #line 1625 
  if ((unsigned int)skb->cloned == 0U) 
                                       #line 1626 
                                       return 0;
  #line 1628 
  dataref = atomic_read(& ((struct skb_shared_info *)skb_end_pointer(skb))->dataref);
  #line 1629 
  dataref = (dataref & 65535) - (dataref >> 16);
  #line 1630 
  return dataref != 1;
}

#line 2065  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff *skb)
{
  #line 2067 
  return (_Bool)(skb->data_len != 0U);
}

#line 2070  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff *skb)
{
  #line 2072 
  return skb->len - skb->data_len;
}

#line 2142 
#line 2142 
void skb_add_rx_frag(struct sk_buff *, int, struct page *, int, int, unsigned int);
#line 2151  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned char *skb_tail_pointer(struct sk_buff *skb)
{
  #line 2153 
  return skb->head + (unsigned long)skb->tail;
}

#line 2190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void *__skb_put(struct sk_buff *skb, unsigned int len)
{
  #line 2192 
  void *tmp = skb_tail_pointer(skb);
  #line 2193 
  if ((long)((int)skb_is_nonlinear(skb) != 0) != 0L) {
    #line 2194 
    ldv_inline_asm();
    #line 2195 
    ldv_inline_asm();
    #line 2196 
    ldv_inline_asm();
    #line 2193 
    ;
  }
  #line 2194 
  skb->tail += len;
  #line 2195 
  skb->len += len;
  #line 2196 
  return tmp;
}

#line 2266 
#line 2266 
void *__pskb_pull_tail(struct sk_buff *, int);
#line 2282  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static bool pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
  #line 2284 
  ;
  #line 2284 
  if ((long)(skb_headlen(skb) >= len) != 0L) 
                                             #line 2285 
                                             return (_Bool)1;
  #line 2286 
  if ((long)(skb->len < len) != 0L) 
                                    #line 2287 
                                    return (_Bool)0;
  #line 2288 
  ;
  #line 2288 
  ;
  #line 2288 
  return (_Bool)(__pskb_pull_tail(skb,(int)(len - skb_headlen(skb))) != (void *)0);
}

#line 2299  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned int skb_headroom(struct sk_buff *skb)
{
  #line 2301 
  return (unsigned int)(skb->data - skb->head);
}

#line 2338  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_reserve(struct sk_buff *skb, int len)
{
  #line 2340 
  skb->data += (unsigned long)len;
  #line 2341 
  skb->tail += (unsigned int)len;
  #line 2342 
  return;
}

#line 2397  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned char *skb_inner_transport_header(struct sk_buff *skb)
{
  #line 2400 
  return skb->head + (unsigned long)skb->inner_transport_header;
}

#line 2420  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned char *skb_inner_network_header(struct sk_buff *skb)
{
  #line 2422 
  return skb->head + (unsigned long)skb->inner_network_header;
}

#line 2458  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned char *skb_transport_header(struct sk_buff *skb)
{
  #line 2460 
  return skb->head + (unsigned long)skb->transport_header;
}

#line 2475  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff *skb)
{
  #line 2477 
  return skb->head + (unsigned long)skb->network_header;
}

#line 2820 
#line 2820 
struct sk_buff *__napi_alloc_skb(struct napi_struct *, unsigned int, gfp_t);
#line 2827 
#line 2827 
void napi_consume_skb(struct sk_buff *, int);
#line 2841  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct page *__dev_alloc_pages(gfp_t gfp_mask, unsigned int order)
{
  #line 2852 
  gfp_mask |= 393216U;
  #line 2854 
  return alloc_pages_node(-1,gfp_mask,order);
}

#line 2857  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct page *dev_alloc_pages(unsigned int order)
{
  #line 2859 
  return __dev_alloc_pages(10784U,order);
}

#line 2896  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned int skb_frag_off(skb_frag_t *frag)
{
  #line 2898 
  return frag->bv_offset;
}

#line 2938  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t *frag)
{
  #line 2940 
  return frag->bv_page;
}

#line 3067  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static dma_addr_t skb_frag_dma_map(struct device *dev, skb_frag_t *frag, size_t offset, size_t size, enum dma_data_direction dir)
{
  #line 3072 
  ;
  #line 3072 
  ;
  #line 3072 
  ;
  #line 3072 
  ;
  #line 3072 
  return dma_map_page_attrs(dev,skb_frag_page(frag),
                           (unsigned long)skb_frag_off(frag) + offset,size,
                           dir,0UL);
}

#line 3111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int __skb_cow(struct sk_buff *skb, unsigned int headroom, int cloned)
{
  #line 3114 
  int delta = 0;
  #line 3116 
  ;
  #line 3116 
  if (skb_headroom(skb) < headroom) {
    #line 3117 
    delta = (int)(headroom - skb_headroom(skb));
  }
  #line 3119 
  if (delta != 0 || cloned != 0) {
    #line 3120 
    return pskb_expand_head(skb,(delta + 63) & -64,0,2592U);
  }
  #line 3122 
  return 0;
}

#line 3152  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int skb_cow_head(struct sk_buff *skb, unsigned int headroom)
{
  #line 3154 
  ;
  #line 3154 
  ;
  #line 3154 
  return __skb_cow(skb,headroom,skb_header_cloned(skb));
}

#line 3186  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int __skb_put_padto(struct sk_buff *skb, unsigned int len, bool free_on_error)
{
  #line 3189 
  unsigned int size = skb->len;
  #line 3191 
  if ((long)(size < len) != 0L) {
    #line 3192 
    len -= size;
    #line 3193 
    if (__skb_pad(skb,(int)len,(_Bool)((bool)((int)free_on_error) != 0)) != 0) 
      #line 3194 
      return -12;
    #line 3195 
    __skb_put(skb,len);
  }
  #line 3197 
  return 0;
}

#line 3210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int skb_put_padto(struct sk_buff *skb, unsigned int len)
{
  #line 3212 
  return __skb_put_padto(skb,len,(_Bool)1);
}

#line 3248  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int __skb_linearize(struct sk_buff *skb)
{
  #line 3250 
  int tmp_0;
  #line 3250 
  if (__pskb_pull_tail(skb,(int)skb->data_len) != (void *)0) 
                                                             #line 3250 
                                                             tmp_0 = 0; else 
                                                                    #line 3250 
                                                                    tmp_0 = -12;
  #line 3250 
  return tmp_0;
}

#line 3507 
#line 3507 
int skb_copy_bits(struct sk_buff *, int, void *, int);
#line 3563  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void *__skb_header_pointer(struct sk_buff *skb, int offset, int len, void *data, int hlen, void *buffer)
{
  #line 3566 
  if (hlen - offset >= len) 
                            #line 3567 
                            return data + (unsigned long)offset;
  #line 3569 
  if (skb == (struct sk_buff *)0) 
                                  #line 3571 
                                  return (void *)0;
  else {
    #line 3569 
    if (skb_copy_bits(skb,offset,buffer,len) < 0) 
                                                  #line 3571 
                                                  return (void *)0;
  }
  #line 3573 
  return buffer;
}

#line 3577  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void *skb_header_pointer(struct sk_buff *skb, int offset, int len, void *buffer)
{
  #line 3579 
  ;
  #line 3579 
  ;
  #line 3579 
  ;
  #line 3579 
  ;
  #line 3579 
  ;
  #line 3579 
  return __skb_header_pointer(skb,offset,len,(void *)skb->data,
                             (int)skb_headlen(skb),buffer);
}

#line 3753  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_metadata_set(struct sk_buff *skb, u8 meta_len)
{
  #line 3755 
  ((struct skb_shared_info *)skb_end_pointer(skb))->meta_len = meta_len;
  #line 3756 
  return;
}

#line 3767 
#line 3767 
void skb_clone_tx_timestamp(struct sk_buff *);
#line 3828  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_tx_timestamp(struct sk_buff *skb)
{
  #line 3830 
  skb_clone_tx_timestamp(skb);
  #line 3831 
  ;
  #line 3831 
  if (((int)((struct skb_shared_info *)skb_end_pointer(skb))->tx_flags & 2) != 0) 
    #line 3832 
    skb_tstamp_tx(skb,(struct skb_shared_hwtstamps *)0);
  #line 3833 
  return;
}

#line 4287  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_record_rx_queue(struct sk_buff *skb, u16 rx_queue)
{
  #line 4289 
  skb->queue_mapping = (unsigned short)((unsigned int)rx_queue + 1U);
  #line 4290 
  return;
}

#line 4390  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static bool skb_is_gso(struct sk_buff *skb)
{
  #line 4392 
  ;
  #line 4392 
  return (_Bool)((unsigned int)((struct skb_shared_info *)skb_end_pointer(skb))->gso_size != 0U);
}

#line 4467  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_checksum_none_assert(struct sk_buff *skb)
{
  #line 4469 
  return;
}

#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/u64_stats_sync.h"
__inline static void u64_stats_init(struct u64_stats_sync *syncp)
{
  #line 117 
  return;
}

#line 94  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
#line 94 
struct xdp_frame *xdp_convert_zc_to_xdp_frame(struct xdp_buff *);
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
__inline static struct xdp_frame *convert_to_xdp_frame(struct xdp_buff *xdp)
{
  #line 100 
  struct xdp_frame *xdp_frame;
  #line 101 
  int metasize;
  #line 102 
  int headroom;
  #line 104 
  if ((xdp->rxq)->mem.type == 3U) {
    #line 105 
    return xdp_convert_zc_to_xdp_frame(xdp);
  }
  #line 108 
  headroom = (int)(xdp->data - xdp->data_hard_start);
  #line 109 
  metasize = (int)(xdp->data - xdp->data_meta);
  #line 110 
  if (0 > metasize) 
                    #line 110 
                    metasize = 0; else 
                                       #line 110 
                                       metasize = metasize;
  #line 111 
  if ((long)((unsigned int)(headroom - metasize) <= 31U) != 0L) 
                                                                #line 112 
                                                                return (struct xdp_frame *)0;
  #line 115 
  xdp_frame = (struct xdp_frame *)xdp->data_hard_start;
  #line 117 
  xdp_frame->data = xdp->data;
  #line 118 
  xdp_frame->len = (unsigned short)(xdp->data_end - xdp->data);
  #line 119 
  xdp_frame->headroom = (unsigned short)((unsigned int)((unsigned short)headroom) + 65504U);
  #line 120 
  xdp_frame->metasize = (unsigned short)metasize;
  #line 123 
  xdp_frame->mem = (xdp->rxq)->mem;
  #line 125 
  return xdp_frame;
}

#line 128 
#line 128 
void xdp_return_frame(struct xdp_frame *);
#line 129 
#line 129 
void xdp_return_frame_rx_napi(struct xdp_frame *);
#line 147 
#line 147 
int xdp_rxq_info_reg(struct xdp_rxq_info *, struct net_device *, u32);
#line 149 
#line 149 
void xdp_rxq_info_unreg(struct xdp_rxq_info *);
#line 468  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
#line 468 
bool napi_complete_done(struct napi_struct *, int);
#line 477  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool napi_complete(struct napi_struct *n)
{
  #line 479 
  return napi_complete_done(n,0);
}

#line 2132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device *dev, unsigned int index)
{
  #line 2135 
  return dev->_tx + (unsigned long)index;
}

#line 3094 
#line 3094 
void netif_schedule_queue(struct netdev_queue *);
#line 3104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue)
{
  #line 3106 
  cif_clear_bit_0(0L,& dev_queue->state);
  #line 3107 
  return;
}

#line 3130 
#line 3130 
void netif_tx_wake_queue(struct netdev_queue *);
#line 3154  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue)
{
  #line 3156 
  cif_set_bit_0(0L,& dev_queue->state);
  #line 3157 
  return;
}

#line 3174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue *dev_queue)
{
  #line 3176 
  return test_bit(0L,& dev_queue->state);
}

#line 3190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netif_xmit_stopped(struct netdev_queue *dev_queue)
{
  #line 3192 
  return (_Bool)((dev_queue->state & 3UL) != 0UL);
}

#line 3235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netdev_tx_sent_queue(struct netdev_queue *dev_queue, unsigned int bytes)
{
  #line 3239 
  dql_queued(& dev_queue->dql,bytes);
  #line 3241 
  if ((long)(dql_avail(& dev_queue->dql) >= 0) != 0L) 
                                                      #line 3242 
                                                      return;
  #line 3244 
  cif_set_bit_0(1L,& dev_queue->state);
  #line 3245 
  ldv_inline_asm();
  #line 3254 
  if ((long)(dql_avail(& dev_queue->dql) >= 0) != 0L) 
                                                      #line 3255 
                                                      cif_clear_bit_0(1L,& dev_queue->state);
  #line 3256 
  return;
}

#line 3301  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netdev_tx_completed_queue(struct netdev_queue *dev_queue, unsigned int pkts, unsigned int bytes)
{
  #line 3305 
  if ((long)(bytes == 0U) != 0L) 
                                 #line 3306 
                                 return;
  #line 3308 
  dql_completed(& dev_queue->dql,bytes);
  #line 3309 
  ldv_inline_asm();
  #line 3317 
  if ((long)(dql_avail(& dev_queue->dql) < 0) != 0L) 
                                                     #line 3318 
                                                     return;
  #line 3320 
  if ((int)test_and_set_bit(1L,& dev_queue->state) != 0) 
                                                         #line 3321 
                                                         netif_schedule_queue(dev_queue);
  #line 3322 
  return;
}

#line 3341  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netdev_tx_reset_queue(struct netdev_queue *q)
{
  #line 3344 
  cif_clear_bit_0(1L,& q->state);
  #line 3345 
  dql_reset(& q->dql);
  #line 3346 
  return;
}

#line 3406  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_start_subqueue(struct net_device *dev, u16 queue_index)
{
  #line 3408 
  struct netdev_queue *txq = netdev_get_tx_queue(dev,(unsigned int)queue_index);
  #line 3410 
  netif_tx_start_queue(txq);
  #line 3411 
  return;
}

#line 3420  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_stop_subqueue(struct net_device *dev, u16 queue_index)
{
  #line 3422 
  struct netdev_queue *txq = netdev_get_tx_queue(dev,(unsigned int)queue_index);
  #line 3423 
  netif_tx_stop_queue(txq);
  #line 3424 
  return;
}

#line 3433  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool __netif_subqueue_stopped(struct net_device *dev, u16 queue_index)
{
  #line 3436 
  struct netdev_queue *txq = netdev_get_tx_queue(dev,(unsigned int)queue_index);
  #line 3438 
  return netif_tx_queue_stopped(txq);
}

#line 3454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_wake_subqueue(struct net_device *dev, u16 queue_index)
{
  #line 3456 
  struct netdev_queue *txq = netdev_get_tx_queue(dev,(unsigned int)queue_index);
  #line 3458 
  netif_tx_wake_queue(txq);
  #line 3459 
  return;
}

#line 3665 
#line 3665 
gro_result_t napi_gro_receive(struct napi_struct *, struct sk_buff *);
#line 3803  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device *dev)
{
  #line 3805 
  int tmp_0;
  #line 3805 
  if ((int)test_bit(2L,& dev->state) != 0) 
                                           #line 3805 
                                           tmp_0 = 0; else 
                                                           #line 3805 
                                                           tmp_0 = 1;
  #line 3805 
  return (_Bool)(tmp_0 != 0);
}

#line 4373 
#line 4373 
int skb_checksum_help(struct sk_buff *);
#line 4452  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netdev_xmit_more(void)
{
  #line 4454 
  u8 pscr_ret__;
  #line 4454 
  __this_cpu_preempt_check((char *)"read");
  {
    #line 4454 
    void *__vpp_verify = (void *)0;
    #line 4454 
    void *tmp = __vpp_verify;
  }
  #line 4454 
  switch (1UL) {
    #line 4454 
    u8 pfo_ret__;
    #line 4454 
    u8 pfo_ret___0;
    #line 4454 
    u8 pfo_ret___1;
    #line 4454 
    u8 pfo_ret___2;
    #line 4454 
    case (unsigned long)1: 
                           #line 4454 
    ;
    #line 4454 
    switch (1UL) {
      #line 4454 
      case (unsigned long)1: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)2: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)4: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)8: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      default: 
               #line 4454 
      ;
      #line 4454 
      __bad_percpu_size();
    }
    #line 4454 
    pscr_ret__ = pfo_ret__;
    #line 4454 
    break;
    #line 4454 
    case (unsigned long)2: 
                           #line 4454 
    ;
    #line 4454 
    switch (1UL) {
      #line 4454 
      case (unsigned long)1: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)2: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)4: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)8: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      default: 
               #line 4454 
      ;
      #line 4454 
      __bad_percpu_size();
    }
    #line 4454 
    pscr_ret__ = pfo_ret___0;
    #line 4454 
    break;
    #line 4454 
    case (unsigned long)4: 
                           #line 4454 
    ;
    #line 4454 
    switch (1UL) {
      #line 4454 
      case (unsigned long)1: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)2: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)4: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)8: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      default: 
               #line 4454 
      ;
      #line 4454 
      __bad_percpu_size();
    }
    #line 4454 
    pscr_ret__ = pfo_ret___1;
    #line 4454 
    break;
    #line 4454 
    case (unsigned long)8: 
                           #line 4454 
    ;
    #line 4454 
    switch (1UL) {
      #line 4454 
      case (unsigned long)1: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)2: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)4: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      case (unsigned long)8: 
                             #line 4454 
      ;
      #line 4455 
      ldv_inline_asm();
      #line 4454 
      break;
      #line 4454 
      default: 
               #line 4454 
      ;
      #line 4454 
      __bad_percpu_size();
    }
    #line 4454 
    pscr_ret__ = pfo_ret___2;
    #line 4454 
    break;
    #line 4454 
    default: 
             #line 4454 
    ;
    #line 4454 
    __bad_size_call_parameter();
    #line 4454 
    break;
  }
  #line 4454 
  return (_Bool)((unsigned int)pscr_ret__ != 0U);
}

#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
#line 31 
u32 eth_get_headlen(struct net_device *, void *, unsigned int);
#line 32 
#line 32 
__be16 eth_type_trans(struct sk_buff *, struct net_device *);
#line 530  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static int eth_skb_pad(struct sk_buff *skb)
{
  #line 532 
  return skb_put_padto(skb,60U);
}

#line 300  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_vlan.h"
__inline static bool eth_type_vlan(__be16 ethertype)
{
  #line 302 
  switch ((int)ethertype) {
    #line 303 
    case 129: 
              #line 303 
    ;
    #line 304 
    case 43144: 
                #line 304 
    ;
    #line 305 
    return (_Bool)1;
    #line 306 
    default: 
             #line 306 
    ;
    #line 307 
    return (_Bool)0;
  }
}

#line 510  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_vlan.h"
__inline static void __vlan_hwaccel_put_tag(struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci)
{
  #line 513 
  skb->vlan_proto = vlan_proto;
  #line 514 
  skb->vlan_tci = vlan_tci;
  #line 515 
  skb->vlan_present = (unsigned char)1U;
  #line 516 
  return;
}

#line 580  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_vlan.h"
__inline static __be16 __vlan_get_protocol(struct sk_buff *skb, __be16 type, int *depth)
{
  #line 583 
  unsigned int vlan_depth = (unsigned int)skb->mac_len;
  #line 589 
  if ((int)eth_type_vlan((unsigned short)((int)type)) != 0) {
    #line 590 
    if (vlan_depth != 0U) {
      #line 591 
      int __ret_warn_on;
      #line 591 
      __ret_warn_on = vlan_depth <= 3U;
      #line 591 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 592 
        ldv_inline_asm();
        #line 593 
        ldv_inline_asm();
      }
      #line 591 
      if ((long)((long)(__ret_warn_on != 0)) != 0L) 
                                                    #line 592 
                                                    return (unsigned short)0U;
      #line 593 
      vlan_depth += 4294967292U;
    }
    else 
         #line 595 
         vlan_depth = 14U;
    #line 597 
    while (1) {
      {
        #line 598 
        struct vlan_hdr *vh;
        #line 600 
        int tmp_1;
        #line 600 
        if (pskb_may_pull(skb,vlan_depth + 4U)) 
                                                #line 600 
                                                tmp_1 = 0; else 
                                                                #line 600 
                                                                tmp_1 = 1;
        #line 600 
        if ((long)tmp_1 != 0L) 
                               #line 602 
                               return (unsigned short)0U;
        #line 604 
        vh = (struct vlan_hdr *)(skb->data + (unsigned long)vlan_depth);
        #line 605 
        type = vh->h_vlan_encapsulated_proto;
        #line 606 
        vlan_depth += 4U;
      }
      #line 607 
      if (! ((int)eth_type_vlan((unsigned short)((int)type)) != 0)) 
                                                                    #line 597 
                                                                    break;
    }
  }
  #line 610 
  if (depth != (int *)0) 
                         #line 611 
                         *depth = (int)vlan_depth;
  #line 613 
  return type;
}

#line 623  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_vlan.h"
__inline static __be16 vlan_get_protocol(struct sk_buff *skb)
{
  #line 625 
  return __vlan_get_protocol(skb,(unsigned short)((int)skb->protocol),(int *)0);
}

#line 560  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/filter.h"
#line 560 
extern struct static_key_false bpf_stats_enabled_key;
#line 702  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/filter.h"
__inline static u32 bpf_prog_run_xdp(struct bpf_prog *prog, struct xdp_buff *xdp)
{
  #line 711 
  u32 ret;
  #line 711 
  __cant_sleep((char *)"./include/linux/filter.h",711,0);
  {
    #line 711 
    bool branch;
    #line 711 
    branch = arch_static_branch(& bpf_stats_enabled_key.key,(_Bool)0);
    #line 711 
    if ((long)((long)((int)branch != 0)) != 0L) {
      #line 711 
      unsigned long tcp_ptr__;
      #line 711 
      struct bpf_prog_stats *stats;
      #line 711 
      u64 start = sched_clock();
      #line 711 
      ret = (*(prog->bpf_func))((void *)xdp,(struct bpf_insn *)(& prog->__anonCompField_bpf_prog_174.insnsi));
      {
        #line 711 
        void *__vpp_verify = (void *)0;
        #line 711 
        void *tmp_2 = __vpp_verify;
      }
      #line 712 
      ldv_inline_asm();
      #line 711 
      stats = ((struct bpf_prog_stats *)tcp_ptr__);
      #line 711 
      u64_stats_init(& stats->syncp);
      #line 711 
      (stats->cnt) ++;
      #line 711 
      stats->nsecs += sched_clock() - start;
      #line 711 
      u64_stats_init(& stats->syncp);
    }
    else 
         #line 711 
         ret = (*(prog->bpf_func))((void *)xdp,(struct bpf_insn *)(& prog->__anonCompField_bpf_prog_174.insnsi));
  }
  #line 711 
  return ret;
}

#line 920 
#line 920 
int xdp_do_redirect(struct net_device *, struct xdp_buff *, struct bpf_prog *);
#line 923 
#line 923 
void xdp_do_flush_map(void);
#line 925 
#line 925 
void bpf_warn_invalid_xdp_action(u32);
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/trace/events/xdp.h"
#line 28 
extern struct tracepoint __tracepoint_xdp_exception;
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/trace/events/xdp.h"
__inline static void trace_xdp_exception(struct net_device *dev, struct bpf_prog *xdp, u32 act)
{
  #line 28 
  int pscr_ret___0;
  #line 28 
  if ((int)static_key_false(& __tracepoint_xdp_exception.key) != 0) {
    #line 28 
    int pscr_ret__;
    #line 28 
    struct tracepoint_func *________p1;
    #line 28 
    struct tracepoint_func *it_func_ptr;
    #line 28 
    void *it_func;
    #line 28 
    void *__data;
    #line 28 
    int __idx = 0;
    {
      #line 28 
      void *__vpp_verify = (void *)0;
      #line 28 
      void *tmp = __vpp_verify;
    }
    #line 28 
    switch (4UL) {
      #line 28 
      int pfo_ret___0;
      #line 28 
      int pfo_ret___1;
      #line 28 
      int pfo_ret___2;
      #line 28 
      int pfo_ret__;
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret__;
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret___0;
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret___1;
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret___2;
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_size_call_parameter();
      #line 28 
      break;
    }
    #line 28 
    if (cpumask_test_cpu(pscr_ret__,& __cpu_online_mask) == 0) 
                                                               #line 28 
                                                               return;
    {
      #line 28 
      int __ret_warn_on = 0;
      #line 28 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 29 
        ldv_inline_asm();
        #line 30 
        ldv_inline_asm();
      }
      #line 28 
      long tmp_5 = (long)(__ret_warn_on != 0);
    }
    #line 28 
    __preempt_count_add(1);
    #line 29 
    ldv_inline_asm();
    {
      #line 29 
      union __anonunion___u_7380 __u;
      #line 28 
      __read_once_size((void *)(& __tracepoint_xdp_exception.funcs),(void *)(& __u.__c),8);
      #line 28 
      ________p1 = (__u.__val);
      }
    #line 28 
    it_func_ptr = ________p1;
    #line 28 
    if (it_func_ptr != (struct tracepoint_func *)0) 
      #line 28 
      while (1) {
        #line 28 
        it_func = it_func_ptr->func;
        #line 28 
        __data = it_func_ptr->data;
        #line 28 
        (*((void (*)(void *, struct net_device *, struct bpf_prog *, u32 ))it_func))(__data,dev,xdp,act);
        #line 28 
        it_func_ptr ++;
        #line 29 
        ;
        #line 29 
        if (! (it_func_ptr->func != (void *)0)) 
                                                #line 28 
                                                break;
      }
    #line 30 
    ldv_inline_asm();
    #line 28 
    __preempt_count_sub(1);
  }
  {
    #line 28 
    void *__vpp_verify_0 = (void *)0;
    #line 28 
    void *tmp_13 = __vpp_verify_0;
  }
  #line 28 
  switch (4UL) {
    #line 28 
    int pfo_ret___6;
    #line 28 
    int pfo_ret___3;
    #line 28 
    int pfo_ret___4;
    #line 28 
    int pfo_ret___5;
    #line 28 
    case (unsigned long)1: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___3;
    #line 28 
    break;
    #line 28 
    case (unsigned long)2: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___4;
    #line 28 
    break;
    #line 28 
    case (unsigned long)4: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___5;
    #line 28 
    break;
    #line 28 
    case (unsigned long)8: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___6;
    #line 28 
    break;
    #line 28 
    default: 
             #line 28 
    ;
    #line 28 
    __bad_size_call_parameter();
    #line 28 
    break;
  }
  #line 28 
  if (cpumask_test_cpu(pscr_ret___0,& __cpu_online_mask) != 0) {
    #line 28 
    __rcu_read_lock();
    {
      #line 29 
      union __anonunion___u_7382 __u_0;
      #line 28 
      __read_once_size((void *)(& __tracepoint_xdp_exception.funcs),(void *)(& __u_0.__c),8);
      #line 28 
      struct tracepoint_func *________p1_0 = (__u_0.__val);
      {
        #line 28 
        bool __warned;
        #line 28 
        if (debug_lockdep_rcu_enabled() != 0) 
          #line 28 
          if (! __warned) {
            #line 28 
            if (rcu_read_lock_sched_held() == 0) {
              #line 28 
              __warned = (_Bool)1;
              #line 28 
              lockdep_rcu_suspicious((char *)"./include/trace/events/xdp.h",28,(char *)"suspicious rcu_dereference_check() usage");
            }
          }
      }
      #line 28 
      struct tracepoint_func *tmp_11 = ________p1_0;
    }
    #line 28 
    __rcu_read_unlock();
  }
  #line 30 
  return;
}

#line 1057  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ipv6.h"
#line 1057 
int ipv6_skip_exthdr(struct sk_buff *, int, u8 *, __be16 *);
#line 1069 
#line 1069 
int ipv6_find_hdr(struct sk_buff *, unsigned int *, int, unsigned short *, int *);
#line 341  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
__inline static struct i40e_rx_ptype_decoded decode_rx_desc_ptype(u8 ptype)
{
  #line 343 
  return i40e_ptype_lookup[(int)ptype];
}

#line 139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static int i40e_compute_pad(int rx_buf_len)
{
  #line 141 
  int page_size;
  #line 141 
  int pad_size;
  #line 143 
  page_size = (rx_buf_len + 2047) & -2048;
  #line 144 
  pad_size = (int)((unsigned int)(page_size - rx_buf_len) + 4294966976U);
  #line 146 
  return pad_size;
}

#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static int i40e_skb_pad(void)
{
  #line 151 
  int rx_buf_len;
  #line 163 
  rx_buf_len = 1536;
  #line 166 
  rx_buf_len = rx_buf_len;
  #line 168 
  return i40e_compute_pad(rx_buf_len);
}

#line 187  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static bool i40e_test_staterr(union i40e_32byte_rx_desc *rx_desc, u64 stat_err_bits)
{
  #line 190 
  return (_Bool)((rx_desc->wb.qword1.status_error_len & stat_err_bits) != 0ULL);
}

#line 258  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static unsigned int i40e_txd_use_count(unsigned int size)
{
  #line 260 
  return (size * 85U >> 20) + 1U;
}

#line 425  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static bool ring_uses_build_skb(struct i40e_ring *ring)
{
  #line 427 
  return (_Bool)(((unsigned long)ring->flags & 2UL) != 0UL);
}

#line 440  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static bool ring_is_xdp(struct i40e_ring *ring)
{
  #line 442 
  return (_Bool)(((unsigned long)ring->flags & 4UL) != 0UL);
}

#line 471  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static unsigned int i40e_rx_pg_order(struct i40e_ring *ring)
{
  #line 474 
  if ((unsigned int)ring->rx_buf_len > 2048U) 
                                              #line 475 
                                              return 1U;
  #line 477 
  return 0U;
}

#line 482 
#line 1568  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
bool i40e_alloc_rx_buffers(struct i40e_ring *rx_ring, u16 cleaned_count);
#line 483  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
#line 3682  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
netdev_tx_t i40e_lan_xmit_frame(struct sk_buff *skb, struct net_device *netdev);
#line 484  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
#line 633  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_clean_tx_ring(struct i40e_ring *tx_ring);
#line 485  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
#line 1343  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_clean_rx_ring(struct i40e_ring *rx_ring);
#line 486  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
#line 1296  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_setup_tx_descriptors(struct i40e_ring *tx_ring);
#line 487  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
#line 1430  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_setup_rx_descriptors(struct i40e_ring *rx_ring);
#line 488  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
#line 673  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_free_tx_resources(struct i40e_ring *tx_ring);
#line 489  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
#line 1408  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_free_rx_resources(struct i40e_ring *rx_ring);
#line 490  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
#line 2568  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_napi_poll(struct napi_struct *napi, int budget);
#line 491  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
#line 939  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_force_wb(struct i40e_vsi *vsi, struct i40e_q_vector *q_vector);
#line 492  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
#line 694  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
u32 i40e_get_tx_pending(struct i40e_ring *ring, bool in_sw);
#line 493  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
#line 720  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_detect_recover_hung(struct i40e_vsi *vsi);
#line 494  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
#line 3240  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int __i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size);
#line 495  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
#line 3269  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
bool __i40e_chk_linearize(struct sk_buff *skb);
#line 496  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
#line 3708  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **frames, u32 flags);
#line 506  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static u32 i40e_get_head(struct i40e_ring *tx_ring)
{
  #line 508 
  void *head = (void *)((struct i40e_tx_desc *)tx_ring->desc + (unsigned long)tx_ring->count);
  #line 510 
  return *((__le32 *)head);
}

#line 522  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static int i40e_xmit_descriptor_count(struct sk_buff *skb)
{
  #line 524 
  skb_frag_t *frag = & ((struct skb_shared_info *)skb_end_pointer(skb))->frags[0];
  #line 525 
  unsigned int nr_frags = (unsigned int)((struct skb_shared_info *)skb_end_pointer(skb))->nr_frags;
  #line 526 
  int count = 0;
  #line 526 
  int size = (int)skb_headlen(skb);
  #line 528 
  while (1) {
    #line 531 
    unsigned int tmp_3;
    #line 534 
    skb_frag_t *tmp_4;
    #line 529 
    count = (int)(i40e_txd_use_count((unsigned int)size) + (unsigned int)count);
    #line 531 
    tmp_3 = nr_frags;
    #line 531 
    nr_frags --;
    #line 531 
    ;
    #line 531 
    if (tmp_3 == 0U) 
                     #line 532 
                     break;
    #line 534 
    tmp_4 = frag;
    #line 534 
    frag ++;
    #line 534 
    ;
    #line 534 
    size = (int)skb_frag_size(tmp_4);
  }
  #line 537 
  return count;
}

#line 547  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static int i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size)
{
  #line 549 
  int tmp;
  #line 549 
  if ((int)tx_ring->next_to_clean <= (int)tx_ring->next_to_use) 
                                                                #line 549 
                                                                tmp = (int)tx_ring->count; else 
                                                                    #line 549 
                                                                    tmp = 0;
  #line 549 
  ;
  #line 549 
  if ((long)((tmp + (int)tx_ring->next_to_clean) - (int)tx_ring->next_to_use > size) != 0L) 
    #line 550 
    return 0;
  #line 551 
  return __i40e_maybe_stop_tx(tx_ring,size);
}

#line 563  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static bool i40e_chk_linearize(struct sk_buff *skb, int count)
{
  #line 566 
  if ((long)(count <= 7) != 0L) 
                                #line 567 
                                return (_Bool)0;
  #line 569 
  if ((int)skb_is_gso(skb) != 0) {
    #line 570 
    return __i40e_chk_linearize(skb);
  }
  #line 573 
  return (_Bool)(count != 8);
}

#line 580  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static struct netdev_queue *txring_txq(struct i40e_ring *ring)
{
  #line 582 
  return netdev_get_tx_queue(ring->netdev,(unsigned int)ring->queue_index);
}

#line 931  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static struct i40e_pf *i40e_netdev_to_pf(struct net_device *netdev)
{
  #line 933 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 934 
  struct i40e_vsi *vsi = np->vsi;
  #line 936 
  return vsi->back;
}

#line 1009  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static struct i40e_vsi *i40e_find_vsi_by_type(struct i40e_pf *pf, u16 type)
{
  #line 1011 
  int i;
  #line 1013 
  i = 0;
  #line 1013 
  while ((int)pf->num_alloc_vsi > i) {
    {
      #line 1014 
      struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)i);
      #line 1016 
      if (vsi != (struct i40e_vsi *)0 && vsi->type == (enum i40e_vsi_type)type) 
        #line 1017 
        return vsi;
    }
    #line 1013 
    i ++;
  }
  #line 1020 
  return (struct i40e_vsi *)0;
}

#line 1029 
#line 469  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_add_del_fdir(struct i40e_vsi *vsi, struct i40e_fdir_filter *input, bool add);
#line 1034  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 1034 
u32 i40e_get_current_atr_cnt(struct i40e_pf *pf);
#line 1035 
#line 1035 
u32 i40e_get_global_fd_count(struct i40e_pf *pf);
#line 1153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static bool i40e_enabled_xdp_vsi(struct i40e_vsi *vsi)
{
  #line 1156 
  union __anonunion___u_7749 __u;
  #line 1155 
  __read_once_size((void *)(& vsi->xdp_prog),(void *)(& __u.__c),8);
  #line 1155 
  return (_Bool)((__u.__val) != (struct bpf_prog *)0);
}

#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
#line 95 
struct tracepoint __tracepoint_i40e_clean_tx_irq;
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
__inline static void trace_i40e_clean_tx_irq(struct i40e_ring *ring, struct i40e_tx_desc *desc, struct i40e_tx_buffer *buf)
{
  #line 95 
  int pscr_ret___0;
  #line 95 
  if ((int)static_key_false(& __tracepoint_i40e_clean_tx_irq.key) != 0) {
    #line 95 
    int pscr_ret__;
    #line 95 
    struct tracepoint_func *________p1;
    #line 95 
    struct tracepoint_func *it_func_ptr;
    #line 95 
    void *it_func;
    #line 95 
    void *__data;
    #line 95 
    int __idx = 0;
    {
      #line 95 
      void *__vpp_verify = (void *)0;
      #line 95 
      void *tmp = __vpp_verify;
    }
    #line 95 
    switch (4UL) {
      #line 95 
      int pfo_ret___1;
      #line 95 
      int pfo_ret___2;
      #line 95 
      int pfo_ret__;
      #line 95 
      int pfo_ret___0;
      #line 95 
      case (unsigned long)1: 
                             #line 95 
      ;
      #line 95 
      switch (4UL) {
        #line 95 
        case (unsigned long)1: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        case (unsigned long)2: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        case (unsigned long)4: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        case (unsigned long)8: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        default: 
                 #line 95 
        ;
        #line 95 
        __bad_percpu_size();
      }
      #line 95 
      pscr_ret__ = pfo_ret__;
      #line 95 
      break;
      #line 95 
      case (unsigned long)2: 
                             #line 95 
      ;
      #line 95 
      switch (4UL) {
        #line 95 
        case (unsigned long)1: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        case (unsigned long)2: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        case (unsigned long)4: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        case (unsigned long)8: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        default: 
                 #line 95 
        ;
        #line 95 
        __bad_percpu_size();
      }
      #line 95 
      pscr_ret__ = pfo_ret___0;
      #line 95 
      break;
      #line 95 
      case (unsigned long)4: 
                             #line 95 
      ;
      #line 95 
      switch (4UL) {
        #line 95 
        case (unsigned long)1: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        case (unsigned long)2: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        case (unsigned long)4: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        case (unsigned long)8: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        default: 
                 #line 95 
        ;
        #line 95 
        __bad_percpu_size();
      }
      #line 95 
      pscr_ret__ = pfo_ret___1;
      #line 95 
      break;
      #line 95 
      case (unsigned long)8: 
                             #line 95 
      ;
      #line 95 
      switch (4UL) {
        #line 95 
        case (unsigned long)1: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        case (unsigned long)2: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        case (unsigned long)4: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        case (unsigned long)8: 
                               #line 95 
        ;
        #line 96 
        ldv_inline_asm();
        #line 95 
        break;
        #line 95 
        default: 
                 #line 95 
        ;
        #line 95 
        __bad_percpu_size();
      }
      #line 95 
      pscr_ret__ = pfo_ret___2;
      #line 95 
      break;
      #line 95 
      default: 
               #line 95 
      ;
      #line 95 
      __bad_size_call_parameter();
      #line 95 
      break;
    }
    #line 95 
    if (cpumask_test_cpu(pscr_ret__,& __cpu_online_mask) == 0) 
                                                               #line 95 
                                                               return;
    {
      #line 95 
      int __ret_warn_on = 0;
      #line 95 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 96 
        ldv_inline_asm();
        #line 97 
        ldv_inline_asm();
      }
      #line 95 
      long tmp_5 = (long)(__ret_warn_on != 0);
    }
    #line 95 
    __preempt_count_add(1);
    #line 96 
    ldv_inline_asm();
    {
      #line 96 
      union __anonunion___u_7751 __u;
      #line 95 
      __read_once_size((void *)(& __tracepoint_i40e_clean_tx_irq.funcs),(void *)(& __u.__c),8);
      #line 95 
      ________p1 = (__u.__val);
      }
    #line 95 
    it_func_ptr = ________p1;
    #line 95 
    if (it_func_ptr != (struct tracepoint_func *)0) 
      #line 95 
      while (1) {
        #line 95 
        it_func = it_func_ptr->func;
        #line 95 
        __data = it_func_ptr->data;
        #line 95 
        (*((void (*)(void *, struct i40e_ring *, struct i40e_tx_desc *, struct i40e_tx_buffer *))it_func))(__data,ring,desc,buf);
        #line 95 
        it_func_ptr ++;
        #line 96 
        ;
        #line 96 
        if (! (it_func_ptr->func != (void *)0)) 
                                                #line 95 
                                                break;
      }
    #line 97 
    ldv_inline_asm();
    #line 95 
    __preempt_count_sub(1);
  }
  {
    #line 95 
    void *__vpp_verify_0 = (void *)0;
    #line 95 
    void *tmp_13 = __vpp_verify_0;
  }
  #line 95 
  switch (4UL) {
    #line 95 
    int pfo_ret___6;
    #line 95 
    int pfo_ret___3;
    #line 95 
    int pfo_ret___4;
    #line 95 
    int pfo_ret___5;
    #line 95 
    case (unsigned long)1: 
                           #line 95 
    ;
    #line 95 
    switch (4UL) {
      #line 95 
      case (unsigned long)1: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      case (unsigned long)2: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      case (unsigned long)4: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      case (unsigned long)8: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      default: 
               #line 95 
      ;
      #line 95 
      __bad_percpu_size();
    }
    #line 95 
    pscr_ret___0 = pfo_ret___3;
    #line 95 
    break;
    #line 95 
    case (unsigned long)2: 
                           #line 95 
    ;
    #line 95 
    switch (4UL) {
      #line 95 
      case (unsigned long)1: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      case (unsigned long)2: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      case (unsigned long)4: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      case (unsigned long)8: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      default: 
               #line 95 
      ;
      #line 95 
      __bad_percpu_size();
    }
    #line 95 
    pscr_ret___0 = pfo_ret___4;
    #line 95 
    break;
    #line 95 
    case (unsigned long)4: 
                           #line 95 
    ;
    #line 95 
    switch (4UL) {
      #line 95 
      case (unsigned long)1: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      case (unsigned long)2: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      case (unsigned long)4: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      case (unsigned long)8: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      default: 
               #line 95 
      ;
      #line 95 
      __bad_percpu_size();
    }
    #line 95 
    pscr_ret___0 = pfo_ret___5;
    #line 95 
    break;
    #line 95 
    case (unsigned long)8: 
                           #line 95 
    ;
    #line 95 
    switch (4UL) {
      #line 95 
      case (unsigned long)1: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      case (unsigned long)2: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      case (unsigned long)4: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      case (unsigned long)8: 
                             #line 95 
      ;
      #line 96 
      ldv_inline_asm();
      #line 95 
      break;
      #line 95 
      default: 
               #line 95 
      ;
      #line 95 
      __bad_percpu_size();
    }
    #line 95 
    pscr_ret___0 = pfo_ret___6;
    #line 95 
    break;
    #line 95 
    default: 
             #line 95 
    ;
    #line 95 
    __bad_size_call_parameter();
    #line 95 
    break;
  }
  #line 95 
  if (cpumask_test_cpu(pscr_ret___0,& __cpu_online_mask) != 0) {
    #line 95 
    __rcu_read_lock();
    {
      #line 96 
      union __anonunion___u_7753 __u_0;
      #line 95 
      __read_once_size((void *)(& __tracepoint_i40e_clean_tx_irq.funcs),(void *)(& __u_0.__c),8);
      #line 95 
      struct tracepoint_func *________p1_0 = (__u_0.__val);
      {
        #line 95 
        bool __warned;
        #line 95 
        if (debug_lockdep_rcu_enabled() != 0) 
          #line 95 
          if (! __warned) {
            #line 95 
            if (rcu_read_lock_sched_held() == 0) {
              #line 95 
              __warned = (_Bool)1;
              #line 95 
              lockdep_rcu_suspicious((char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h",95,(char *)"suspicious rcu_dereference_check() usage");
            }
          }
      }
      #line 95 
      struct tracepoint_func *tmp_11 = ________p1_0;
    }
    #line 95 
    __rcu_read_unlock();
  }
  #line 97 
  return;
}

#line 103 
#line 103 
struct tracepoint __tracepoint_i40e_clean_tx_irq_unmap;
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
__inline static void trace_i40e_clean_tx_irq_unmap(struct i40e_ring *ring, struct i40e_tx_desc *desc, struct i40e_tx_buffer *buf)
{
  #line 103 
  int pscr_ret___0;
  #line 103 
  if ((int)static_key_false(& __tracepoint_i40e_clean_tx_irq_unmap.key) != 0) {
    #line 103 
    int pscr_ret__;
    #line 103 
    struct tracepoint_func *________p1;
    #line 103 
    struct tracepoint_func *it_func_ptr;
    #line 103 
    void *it_func;
    #line 103 
    void *__data;
    #line 103 
    int __idx = 0;
    {
      #line 103 
      void *__vpp_verify = (void *)0;
      #line 103 
      void *tmp = __vpp_verify;
    }
    #line 103 
    switch (4UL) {
      #line 103 
      int pfo_ret___0;
      #line 103 
      int pfo_ret___1;
      #line 103 
      int pfo_ret___2;
      #line 103 
      int pfo_ret__;
      #line 103 
      case (unsigned long)1: 
                             #line 103 
      ;
      #line 103 
      switch (4UL) {
        #line 103 
        case (unsigned long)1: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        case (unsigned long)2: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        case (unsigned long)4: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        case (unsigned long)8: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        default: 
                 #line 103 
        ;
        #line 103 
        __bad_percpu_size();
      }
      #line 103 
      pscr_ret__ = pfo_ret__;
      #line 103 
      break;
      #line 103 
      case (unsigned long)2: 
                             #line 103 
      ;
      #line 103 
      switch (4UL) {
        #line 103 
        case (unsigned long)1: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        case (unsigned long)2: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        case (unsigned long)4: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        case (unsigned long)8: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        default: 
                 #line 103 
        ;
        #line 103 
        __bad_percpu_size();
      }
      #line 103 
      pscr_ret__ = pfo_ret___0;
      #line 103 
      break;
      #line 103 
      case (unsigned long)4: 
                             #line 103 
      ;
      #line 103 
      switch (4UL) {
        #line 103 
        case (unsigned long)1: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        case (unsigned long)2: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        case (unsigned long)4: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        case (unsigned long)8: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        default: 
                 #line 103 
        ;
        #line 103 
        __bad_percpu_size();
      }
      #line 103 
      pscr_ret__ = pfo_ret___1;
      #line 103 
      break;
      #line 103 
      case (unsigned long)8: 
                             #line 103 
      ;
      #line 103 
      switch (4UL) {
        #line 103 
        case (unsigned long)1: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        case (unsigned long)2: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        case (unsigned long)4: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        case (unsigned long)8: 
                               #line 103 
        ;
        #line 104 
        ldv_inline_asm();
        #line 103 
        break;
        #line 103 
        default: 
                 #line 103 
        ;
        #line 103 
        __bad_percpu_size();
      }
      #line 103 
      pscr_ret__ = pfo_ret___2;
      #line 103 
      break;
      #line 103 
      default: 
               #line 103 
      ;
      #line 103 
      __bad_size_call_parameter();
      #line 103 
      break;
    }
    #line 103 
    if (cpumask_test_cpu(pscr_ret__,& __cpu_online_mask) == 0) 
                                                               #line 103 
                                                               return;
    {
      #line 103 
      int __ret_warn_on = 0;
      #line 103 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 104 
        ldv_inline_asm();
        #line 105 
        ldv_inline_asm();
      }
      #line 103 
      long tmp_5 = (long)(__ret_warn_on != 0);
    }
    #line 103 
    __preempt_count_add(1);
    #line 104 
    ldv_inline_asm();
    {
      #line 104 
      union __anonunion___u_7755 __u;
      #line 103 
      __read_once_size((void *)(& __tracepoint_i40e_clean_tx_irq_unmap.funcs),(void *)(& __u.__c),8);
      #line 103 
      ________p1 = (__u.__val);
      }
    #line 103 
    it_func_ptr = ________p1;
    #line 103 
    if (it_func_ptr != (struct tracepoint_func *)0) 
      #line 103 
      while (1) {
        #line 103 
        it_func = it_func_ptr->func;
        #line 103 
        __data = it_func_ptr->data;
        #line 103 
        (*((void (*)(void *, struct i40e_ring *, struct i40e_tx_desc *, struct i40e_tx_buffer *))it_func))(__data,ring,desc,buf);
        #line 103 
        it_func_ptr ++;
        #line 104 
        ;
        #line 104 
        if (! (it_func_ptr->func != (void *)0)) 
                                                #line 103 
                                                break;
      }
    #line 105 
    ldv_inline_asm();
    #line 103 
    __preempt_count_sub(1);
  }
  {
    #line 103 
    void *__vpp_verify_0 = (void *)0;
    #line 103 
    void *tmp_13 = __vpp_verify_0;
  }
  #line 103 
  switch (4UL) {
    #line 103 
    int pfo_ret___6;
    #line 103 
    int pfo_ret___3;
    #line 103 
    int pfo_ret___4;
    #line 103 
    int pfo_ret___5;
    #line 103 
    case (unsigned long)1: 
                           #line 103 
    ;
    #line 103 
    switch (4UL) {
      #line 103 
      case (unsigned long)1: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      case (unsigned long)2: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      case (unsigned long)4: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      case (unsigned long)8: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      default: 
               #line 103 
      ;
      #line 103 
      __bad_percpu_size();
    }
    #line 103 
    pscr_ret___0 = pfo_ret___3;
    #line 103 
    break;
    #line 103 
    case (unsigned long)2: 
                           #line 103 
    ;
    #line 103 
    switch (4UL) {
      #line 103 
      case (unsigned long)1: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      case (unsigned long)2: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      case (unsigned long)4: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      case (unsigned long)8: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      default: 
               #line 103 
      ;
      #line 103 
      __bad_percpu_size();
    }
    #line 103 
    pscr_ret___0 = pfo_ret___4;
    #line 103 
    break;
    #line 103 
    case (unsigned long)4: 
                           #line 103 
    ;
    #line 103 
    switch (4UL) {
      #line 103 
      case (unsigned long)1: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      case (unsigned long)2: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      case (unsigned long)4: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      case (unsigned long)8: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      default: 
               #line 103 
      ;
      #line 103 
      __bad_percpu_size();
    }
    #line 103 
    pscr_ret___0 = pfo_ret___5;
    #line 103 
    break;
    #line 103 
    case (unsigned long)8: 
                           #line 103 
    ;
    #line 103 
    switch (4UL) {
      #line 103 
      case (unsigned long)1: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      case (unsigned long)2: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      case (unsigned long)4: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      case (unsigned long)8: 
                             #line 103 
      ;
      #line 104 
      ldv_inline_asm();
      #line 103 
      break;
      #line 103 
      default: 
               #line 103 
      ;
      #line 103 
      __bad_percpu_size();
    }
    #line 103 
    pscr_ret___0 = pfo_ret___6;
    #line 103 
    break;
    #line 103 
    default: 
             #line 103 
    ;
    #line 103 
    __bad_size_call_parameter();
    #line 103 
    break;
  }
  #line 103 
  if (cpumask_test_cpu(pscr_ret___0,& __cpu_online_mask) != 0) {
    #line 103 
    __rcu_read_lock();
    {
      #line 104 
      union __anonunion___u_7757 __u_0;
      #line 103 
      __read_once_size((void *)(& __tracepoint_i40e_clean_tx_irq_unmap.funcs),(void *)(& __u_0.__c),8);
      #line 103 
      struct tracepoint_func *________p1_0 = (__u_0.__val);
      {
        #line 103 
        bool __warned;
        #line 103 
        if (debug_lockdep_rcu_enabled() != 0) 
          #line 103 
          if (! __warned) {
            #line 103 
            if (rcu_read_lock_sched_held() == 0) {
              #line 103 
              __warned = (_Bool)1;
              #line 103 
              lockdep_rcu_suspicious((char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h",103,(char *)"suspicious rcu_dereference_check() usage");
            }
          }
      }
      #line 103 
      struct tracepoint_func *tmp_11 = ________p1_0;
    }
    #line 103 
    __rcu_read_unlock();
  }
  #line 105 
  return;
}

#line 140 
#line 140 
struct tracepoint __tracepoint_i40e_clean_rx_irq;
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
__inline static void trace_i40e_clean_rx_irq(struct i40e_ring *ring, union i40e_32byte_rx_desc *desc, struct sk_buff *skb)
{
  #line 140 
  int pscr_ret___0;
  #line 140 
  if ((int)static_key_false(& __tracepoint_i40e_clean_rx_irq.key) != 0) {
    #line 140 
    int pscr_ret__;
    #line 140 
    struct tracepoint_func *________p1;
    #line 140 
    struct tracepoint_func *it_func_ptr;
    #line 140 
    void *it_func;
    #line 140 
    void *__data;
    #line 140 
    int __idx = 0;
    {
      #line 140 
      void *__vpp_verify = (void *)0;
      #line 140 
      void *tmp = __vpp_verify;
    }
    #line 140 
    switch (4UL) {
      #line 140 
      int pfo_ret___0;
      #line 140 
      int pfo_ret___1;
      #line 140 
      int pfo_ret___2;
      #line 140 
      int pfo_ret__;
      #line 140 
      case (unsigned long)1: 
                             #line 140 
      ;
      #line 140 
      switch (4UL) {
        #line 140 
        case (unsigned long)1: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        case (unsigned long)2: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        case (unsigned long)4: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        case (unsigned long)8: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        default: 
                 #line 140 
        ;
        #line 140 
        __bad_percpu_size();
      }
      #line 140 
      pscr_ret__ = pfo_ret__;
      #line 140 
      break;
      #line 140 
      case (unsigned long)2: 
                             #line 140 
      ;
      #line 140 
      switch (4UL) {
        #line 140 
        case (unsigned long)1: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        case (unsigned long)2: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        case (unsigned long)4: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        case (unsigned long)8: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        default: 
                 #line 140 
        ;
        #line 140 
        __bad_percpu_size();
      }
      #line 140 
      pscr_ret__ = pfo_ret___0;
      #line 140 
      break;
      #line 140 
      case (unsigned long)4: 
                             #line 140 
      ;
      #line 140 
      switch (4UL) {
        #line 140 
        case (unsigned long)1: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        case (unsigned long)2: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        case (unsigned long)4: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        case (unsigned long)8: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        default: 
                 #line 140 
        ;
        #line 140 
        __bad_percpu_size();
      }
      #line 140 
      pscr_ret__ = pfo_ret___1;
      #line 140 
      break;
      #line 140 
      case (unsigned long)8: 
                             #line 140 
      ;
      #line 140 
      switch (4UL) {
        #line 140 
        case (unsigned long)1: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        case (unsigned long)2: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        case (unsigned long)4: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        case (unsigned long)8: 
                               #line 140 
        ;
        #line 141 
        ldv_inline_asm();
        #line 140 
        break;
        #line 140 
        default: 
                 #line 140 
        ;
        #line 140 
        __bad_percpu_size();
      }
      #line 140 
      pscr_ret__ = pfo_ret___2;
      #line 140 
      break;
      #line 140 
      default: 
               #line 140 
      ;
      #line 140 
      __bad_size_call_parameter();
      #line 140 
      break;
    }
    #line 140 
    if (cpumask_test_cpu(pscr_ret__,& __cpu_online_mask) == 0) 
                                                               #line 140 
                                                               return;
    {
      #line 140 
      int __ret_warn_on = 0;
      #line 140 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 141 
        ldv_inline_asm();
        #line 142 
        ldv_inline_asm();
      }
      #line 140 
      long tmp_5 = (long)(__ret_warn_on != 0);
    }
    #line 140 
    __preempt_count_add(1);
    #line 141 
    ldv_inline_asm();
    {
      #line 141 
      union __anonunion___u_7759 __u;
      #line 140 
      __read_once_size((void *)(& __tracepoint_i40e_clean_rx_irq.funcs),(void *)(& __u.__c),8);
      #line 140 
      ________p1 = (__u.__val);
      }
    #line 140 
    it_func_ptr = ________p1;
    #line 140 
    if (it_func_ptr != (struct tracepoint_func *)0) 
      #line 140 
      while (1) {
        #line 140 
        it_func = it_func_ptr->func;
        #line 140 
        __data = it_func_ptr->data;
        #line 140 
        (*((void (*)(void *, struct i40e_ring *, union i40e_32byte_rx_desc *, struct sk_buff *))it_func))(__data,ring,desc,skb);
        #line 140 
        it_func_ptr ++;
        #line 141 
        ;
        #line 141 
        if (! (it_func_ptr->func != (void *)0)) 
                                                #line 140 
                                                break;
      }
    #line 142 
    ldv_inline_asm();
    #line 140 
    __preempt_count_sub(1);
  }
  {
    #line 140 
    void *__vpp_verify_0 = (void *)0;
    #line 140 
    void *tmp_13 = __vpp_verify_0;
  }
  #line 140 
  switch (4UL) {
    #line 140 
    int pfo_ret___6;
    #line 140 
    int pfo_ret___3;
    #line 140 
    int pfo_ret___4;
    #line 140 
    int pfo_ret___5;
    #line 140 
    case (unsigned long)1: 
                           #line 140 
    ;
    #line 140 
    switch (4UL) {
      #line 140 
      case (unsigned long)1: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      case (unsigned long)2: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      case (unsigned long)4: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      case (unsigned long)8: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      default: 
               #line 140 
      ;
      #line 140 
      __bad_percpu_size();
    }
    #line 140 
    pscr_ret___0 = pfo_ret___3;
    #line 140 
    break;
    #line 140 
    case (unsigned long)2: 
                           #line 140 
    ;
    #line 140 
    switch (4UL) {
      #line 140 
      case (unsigned long)1: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      case (unsigned long)2: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      case (unsigned long)4: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      case (unsigned long)8: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      default: 
               #line 140 
      ;
      #line 140 
      __bad_percpu_size();
    }
    #line 140 
    pscr_ret___0 = pfo_ret___4;
    #line 140 
    break;
    #line 140 
    case (unsigned long)4: 
                           #line 140 
    ;
    #line 140 
    switch (4UL) {
      #line 140 
      case (unsigned long)1: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      case (unsigned long)2: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      case (unsigned long)4: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      case (unsigned long)8: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      default: 
               #line 140 
      ;
      #line 140 
      __bad_percpu_size();
    }
    #line 140 
    pscr_ret___0 = pfo_ret___5;
    #line 140 
    break;
    #line 140 
    case (unsigned long)8: 
                           #line 140 
    ;
    #line 140 
    switch (4UL) {
      #line 140 
      case (unsigned long)1: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      case (unsigned long)2: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      case (unsigned long)4: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      case (unsigned long)8: 
                             #line 140 
      ;
      #line 141 
      ldv_inline_asm();
      #line 140 
      break;
      #line 140 
      default: 
               #line 140 
      ;
      #line 140 
      __bad_percpu_size();
    }
    #line 140 
    pscr_ret___0 = pfo_ret___6;
    #line 140 
    break;
    #line 140 
    default: 
             #line 140 
    ;
    #line 140 
    __bad_size_call_parameter();
    #line 140 
    break;
  }
  #line 140 
  if (cpumask_test_cpu(pscr_ret___0,& __cpu_online_mask) != 0) {
    #line 140 
    __rcu_read_lock();
    {
      #line 141 
      union __anonunion___u_7761 __u_0;
      #line 140 
      __read_once_size((void *)(& __tracepoint_i40e_clean_rx_irq.funcs),(void *)(& __u_0.__c),8);
      #line 140 
      struct tracepoint_func *________p1_0 = (__u_0.__val);
      {
        #line 140 
        bool __warned;
        #line 140 
        if (debug_lockdep_rcu_enabled() != 0) 
          #line 140 
          if (! __warned) {
            #line 140 
            if (rcu_read_lock_sched_held() == 0) {
              #line 140 
              __warned = (_Bool)1;
              #line 140 
              lockdep_rcu_suspicious((char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h",140,(char *)"suspicious rcu_dereference_check() usage");
            }
          }
      }
      #line 140 
      struct tracepoint_func *tmp_11 = ________p1_0;
    }
    #line 140 
    __rcu_read_unlock();
  }
  #line 142 
  return;
}

#line 148 
#line 148 
struct tracepoint __tracepoint_i40e_clean_rx_irq_rx;
#line 148  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
__inline static void trace_i40e_clean_rx_irq_rx(struct i40e_ring *ring, union i40e_32byte_rx_desc *desc, struct sk_buff *skb)
{
  #line 148 
  int pscr_ret___0;
  #line 148 
  if ((int)static_key_false(& __tracepoint_i40e_clean_rx_irq_rx.key) != 0) {
    #line 148 
    int pscr_ret__;
    #line 148 
    struct tracepoint_func *________p1;
    #line 148 
    struct tracepoint_func *it_func_ptr;
    #line 148 
    void *it_func;
    #line 148 
    void *__data;
    #line 148 
    int __idx = 0;
    {
      #line 148 
      void *__vpp_verify = (void *)0;
      #line 148 
      void *tmp = __vpp_verify;
    }
    #line 148 
    switch (4UL) {
      #line 148 
      int pfo_ret___0;
      #line 148 
      int pfo_ret___1;
      #line 148 
      int pfo_ret___2;
      #line 148 
      int pfo_ret__;
      #line 148 
      case (unsigned long)1: 
                             #line 148 
      ;
      #line 148 
      switch (4UL) {
        #line 148 
        case (unsigned long)1: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        case (unsigned long)2: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        case (unsigned long)4: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        case (unsigned long)8: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        default: 
                 #line 148 
        ;
        #line 148 
        __bad_percpu_size();
      }
      #line 148 
      pscr_ret__ = pfo_ret__;
      #line 148 
      break;
      #line 148 
      case (unsigned long)2: 
                             #line 148 
      ;
      #line 148 
      switch (4UL) {
        #line 148 
        case (unsigned long)1: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        case (unsigned long)2: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        case (unsigned long)4: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        case (unsigned long)8: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        default: 
                 #line 148 
        ;
        #line 148 
        __bad_percpu_size();
      }
      #line 148 
      pscr_ret__ = pfo_ret___0;
      #line 148 
      break;
      #line 148 
      case (unsigned long)4: 
                             #line 148 
      ;
      #line 148 
      switch (4UL) {
        #line 148 
        case (unsigned long)1: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        case (unsigned long)2: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        case (unsigned long)4: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        case (unsigned long)8: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        default: 
                 #line 148 
        ;
        #line 148 
        __bad_percpu_size();
      }
      #line 148 
      pscr_ret__ = pfo_ret___1;
      #line 148 
      break;
      #line 148 
      case (unsigned long)8: 
                             #line 148 
      ;
      #line 148 
      switch (4UL) {
        #line 148 
        case (unsigned long)1: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        case (unsigned long)2: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        case (unsigned long)4: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        case (unsigned long)8: 
                               #line 148 
        ;
        #line 149 
        ldv_inline_asm();
        #line 148 
        break;
        #line 148 
        default: 
                 #line 148 
        ;
        #line 148 
        __bad_percpu_size();
      }
      #line 148 
      pscr_ret__ = pfo_ret___2;
      #line 148 
      break;
      #line 148 
      default: 
               #line 148 
      ;
      #line 148 
      __bad_size_call_parameter();
      #line 148 
      break;
    }
    #line 148 
    if (cpumask_test_cpu(pscr_ret__,& __cpu_online_mask) == 0) 
                                                               #line 148 
                                                               return;
    {
      #line 148 
      int __ret_warn_on = 0;
      #line 148 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 149 
        ldv_inline_asm();
        #line 150 
        ldv_inline_asm();
      }
      #line 148 
      long tmp_5 = (long)(__ret_warn_on != 0);
    }
    #line 148 
    __preempt_count_add(1);
    #line 149 
    ldv_inline_asm();
    {
      #line 149 
      union __anonunion___u_7763 __u;
      #line 148 
      __read_once_size((void *)(& __tracepoint_i40e_clean_rx_irq_rx.funcs),(void *)(& __u.__c),8);
      #line 148 
      ________p1 = (__u.__val);
      }
    #line 148 
    it_func_ptr = ________p1;
    #line 148 
    if (it_func_ptr != (struct tracepoint_func *)0) 
      #line 148 
      while (1) {
        #line 148 
        it_func = it_func_ptr->func;
        #line 148 
        __data = it_func_ptr->data;
        #line 148 
        (*((void (*)(void *, struct i40e_ring *, union i40e_32byte_rx_desc *, struct sk_buff *))it_func))(__data,ring,desc,skb);
        #line 148 
        it_func_ptr ++;
        #line 149 
        ;
        #line 149 
        if (! (it_func_ptr->func != (void *)0)) 
                                                #line 148 
                                                break;
      }
    #line 150 
    ldv_inline_asm();
    #line 148 
    __preempt_count_sub(1);
  }
  {
    #line 148 
    void *__vpp_verify_0 = (void *)0;
    #line 148 
    void *tmp_13 = __vpp_verify_0;
  }
  #line 148 
  switch (4UL) {
    #line 148 
    int pfo_ret___5;
    #line 148 
    int pfo_ret___6;
    #line 148 
    int pfo_ret___3;
    #line 148 
    int pfo_ret___4;
    #line 148 
    case (unsigned long)1: 
                           #line 148 
    ;
    #line 148 
    switch (4UL) {
      #line 148 
      case (unsigned long)1: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      case (unsigned long)2: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      case (unsigned long)4: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      case (unsigned long)8: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      default: 
               #line 148 
      ;
      #line 148 
      __bad_percpu_size();
    }
    #line 148 
    pscr_ret___0 = pfo_ret___3;
    #line 148 
    break;
    #line 148 
    case (unsigned long)2: 
                           #line 148 
    ;
    #line 148 
    switch (4UL) {
      #line 148 
      case (unsigned long)1: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      case (unsigned long)2: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      case (unsigned long)4: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      case (unsigned long)8: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      default: 
               #line 148 
      ;
      #line 148 
      __bad_percpu_size();
    }
    #line 148 
    pscr_ret___0 = pfo_ret___4;
    #line 148 
    break;
    #line 148 
    case (unsigned long)4: 
                           #line 148 
    ;
    #line 148 
    switch (4UL) {
      #line 148 
      case (unsigned long)1: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      case (unsigned long)2: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      case (unsigned long)4: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      case (unsigned long)8: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      default: 
               #line 148 
      ;
      #line 148 
      __bad_percpu_size();
    }
    #line 148 
    pscr_ret___0 = pfo_ret___5;
    #line 148 
    break;
    #line 148 
    case (unsigned long)8: 
                           #line 148 
    ;
    #line 148 
    switch (4UL) {
      #line 148 
      case (unsigned long)1: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      case (unsigned long)2: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      case (unsigned long)4: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      case (unsigned long)8: 
                             #line 148 
      ;
      #line 149 
      ldv_inline_asm();
      #line 148 
      break;
      #line 148 
      default: 
               #line 148 
      ;
      #line 148 
      __bad_percpu_size();
    }
    #line 148 
    pscr_ret___0 = pfo_ret___6;
    #line 148 
    break;
    #line 148 
    default: 
             #line 148 
    ;
    #line 148 
    __bad_size_call_parameter();
    #line 148 
    break;
  }
  #line 148 
  if (cpumask_test_cpu(pscr_ret___0,& __cpu_online_mask) != 0) {
    #line 148 
    __rcu_read_lock();
    {
      #line 149 
      union __anonunion___u_7765 __u_0;
      #line 148 
      __read_once_size((void *)(& __tracepoint_i40e_clean_rx_irq_rx.funcs),(void *)(& __u_0.__c),8);
      #line 148 
      struct tracepoint_func *________p1_0 = (__u_0.__val);
      {
        #line 148 
        bool __warned;
        #line 148 
        if (debug_lockdep_rcu_enabled() != 0) 
          #line 148 
          if (! __warned) {
            #line 148 
            if (rcu_read_lock_sched_held() == 0) {
              #line 148 
              __warned = (_Bool)1;
              #line 148 
              lockdep_rcu_suspicious((char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h",148,(char *)"suspicious rcu_dereference_check() usage");
            }
          }
      }
      #line 148 
      struct tracepoint_func *tmp_11 = ________p1_0;
    }
    #line 148 
    __rcu_read_unlock();
  }
  #line 150 
  return;
}

#line 182 
#line 182 
struct tracepoint __tracepoint_i40e_xmit_frame_ring;
#line 182  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
__inline static void trace_i40e_xmit_frame_ring(struct sk_buff *skb, struct i40e_ring *ring)
{
  #line 182 
  int pscr_ret___0;
  #line 182 
  if ((int)static_key_false(& __tracepoint_i40e_xmit_frame_ring.key) != 0) {
    #line 182 
    int pscr_ret__;
    #line 182 
    struct tracepoint_func *________p1;
    #line 182 
    struct tracepoint_func *it_func_ptr;
    #line 182 
    void *it_func;
    #line 182 
    void *__data;
    #line 182 
    int __idx = 0;
    {
      #line 182 
      void *__vpp_verify = (void *)0;
      #line 182 
      void *tmp = __vpp_verify;
    }
    #line 182 
    switch (4UL) {
      #line 182 
      int pfo_ret___0;
      #line 182 
      int pfo_ret___1;
      #line 182 
      int pfo_ret___2;
      #line 182 
      int pfo_ret__;
      #line 182 
      case (unsigned long)1: 
                             #line 182 
      ;
      #line 182 
      switch (4UL) {
        #line 182 
        case (unsigned long)1: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        case (unsigned long)2: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        case (unsigned long)4: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        case (unsigned long)8: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        default: 
                 #line 182 
        ;
        #line 182 
        __bad_percpu_size();
      }
      #line 182 
      pscr_ret__ = pfo_ret__;
      #line 182 
      break;
      #line 182 
      case (unsigned long)2: 
                             #line 182 
      ;
      #line 182 
      switch (4UL) {
        #line 182 
        case (unsigned long)1: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        case (unsigned long)2: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        case (unsigned long)4: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        case (unsigned long)8: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        default: 
                 #line 182 
        ;
        #line 182 
        __bad_percpu_size();
      }
      #line 182 
      pscr_ret__ = pfo_ret___0;
      #line 182 
      break;
      #line 182 
      case (unsigned long)4: 
                             #line 182 
      ;
      #line 182 
      switch (4UL) {
        #line 182 
        case (unsigned long)1: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        case (unsigned long)2: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        case (unsigned long)4: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        case (unsigned long)8: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        default: 
                 #line 182 
        ;
        #line 182 
        __bad_percpu_size();
      }
      #line 182 
      pscr_ret__ = pfo_ret___1;
      #line 182 
      break;
      #line 182 
      case (unsigned long)8: 
                             #line 182 
      ;
      #line 182 
      switch (4UL) {
        #line 182 
        case (unsigned long)1: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        case (unsigned long)2: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        case (unsigned long)4: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        case (unsigned long)8: 
                               #line 182 
        ;
        #line 183 
        ldv_inline_asm();
        #line 182 
        break;
        #line 182 
        default: 
                 #line 182 
        ;
        #line 182 
        __bad_percpu_size();
      }
      #line 182 
      pscr_ret__ = pfo_ret___2;
      #line 182 
      break;
      #line 182 
      default: 
               #line 182 
      ;
      #line 182 
      __bad_size_call_parameter();
      #line 182 
      break;
    }
    #line 182 
    if (cpumask_test_cpu(pscr_ret__,& __cpu_online_mask) == 0) 
                                                               #line 182 
                                                               return;
    {
      #line 182 
      int __ret_warn_on = 0;
      #line 182 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 183 
        ldv_inline_asm();
        #line 184 
        ldv_inline_asm();
      }
      #line 182 
      long tmp_5 = (long)(__ret_warn_on != 0);
    }
    #line 182 
    __preempt_count_add(1);
    #line 183 
    ldv_inline_asm();
    {
      #line 183 
      union __anonunion___u_7767 __u;
      #line 182 
      __read_once_size((void *)(& __tracepoint_i40e_xmit_frame_ring.funcs),(void *)(& __u.__c),8);
      #line 182 
      ________p1 = (__u.__val);
      }
    #line 182 
    it_func_ptr = ________p1;
    #line 182 
    if (it_func_ptr != (struct tracepoint_func *)0) 
      #line 182 
      while (1) {
        #line 182 
        it_func = it_func_ptr->func;
        #line 182 
        __data = it_func_ptr->data;
        #line 182 
        (*((void (*)(void *, struct sk_buff *, struct i40e_ring *))it_func))(__data,skb,ring);
        #line 182 
        it_func_ptr ++;
        #line 183 
        ;
        #line 183 
        if (! (it_func_ptr->func != (void *)0)) 
                                                #line 182 
                                                break;
      }
    #line 184 
    ldv_inline_asm();
    #line 182 
    __preempt_count_sub(1);
  }
  {
    #line 182 
    void *__vpp_verify_0 = (void *)0;
    #line 182 
    void *tmp_13 = __vpp_verify_0;
  }
  #line 182 
  switch (4UL) {
    #line 182 
    int pfo_ret___6;
    #line 182 
    int pfo_ret___3;
    #line 182 
    int pfo_ret___4;
    #line 182 
    int pfo_ret___5;
    #line 182 
    case (unsigned long)1: 
                           #line 182 
    ;
    #line 182 
    switch (4UL) {
      #line 182 
      case (unsigned long)1: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      case (unsigned long)2: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      case (unsigned long)4: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      case (unsigned long)8: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      default: 
               #line 182 
      ;
      #line 182 
      __bad_percpu_size();
    }
    #line 182 
    pscr_ret___0 = pfo_ret___3;
    #line 182 
    break;
    #line 182 
    case (unsigned long)2: 
                           #line 182 
    ;
    #line 182 
    switch (4UL) {
      #line 182 
      case (unsigned long)1: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      case (unsigned long)2: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      case (unsigned long)4: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      case (unsigned long)8: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      default: 
               #line 182 
      ;
      #line 182 
      __bad_percpu_size();
    }
    #line 182 
    pscr_ret___0 = pfo_ret___4;
    #line 182 
    break;
    #line 182 
    case (unsigned long)4: 
                           #line 182 
    ;
    #line 182 
    switch (4UL) {
      #line 182 
      case (unsigned long)1: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      case (unsigned long)2: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      case (unsigned long)4: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      case (unsigned long)8: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      default: 
               #line 182 
      ;
      #line 182 
      __bad_percpu_size();
    }
    #line 182 
    pscr_ret___0 = pfo_ret___5;
    #line 182 
    break;
    #line 182 
    case (unsigned long)8: 
                           #line 182 
    ;
    #line 182 
    switch (4UL) {
      #line 182 
      case (unsigned long)1: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      case (unsigned long)2: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      case (unsigned long)4: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      case (unsigned long)8: 
                             #line 182 
      ;
      #line 183 
      ldv_inline_asm();
      #line 182 
      break;
      #line 182 
      default: 
               #line 182 
      ;
      #line 182 
      __bad_percpu_size();
    }
    #line 182 
    pscr_ret___0 = pfo_ret___6;
    #line 182 
    break;
    #line 182 
    default: 
             #line 182 
    ;
    #line 182 
    __bad_size_call_parameter();
    #line 182 
    break;
  }
  #line 182 
  if (cpumask_test_cpu(pscr_ret___0,& __cpu_online_mask) != 0) {
    #line 182 
    __rcu_read_lock();
    {
      #line 183 
      union __anonunion___u_7769 __u_0;
      #line 182 
      __read_once_size((void *)(& __tracepoint_i40e_xmit_frame_ring.funcs),(void *)(& __u_0.__c),8);
      #line 182 
      struct tracepoint_func *________p1_0 = (__u_0.__val);
      {
        #line 182 
        bool __warned;
        #line 182 
        if (debug_lockdep_rcu_enabled() != 0) 
          #line 182 
          if (! __warned) {
            #line 182 
            if (rcu_read_lock_sched_held() == 0) {
              #line 182 
              __warned = (_Bool)1;
              #line 182 
              lockdep_rcu_suspicious((char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h",182,(char *)"suspicious rcu_dereference_check() usage");
            }
          }
      }
      #line 182 
      struct tracepoint_func *tmp_11 = ________p1_0;
    }
    #line 182 
    __rcu_read_unlock();
  }
  #line 184 
  return;
}

#line 189 
#line 189 
struct tracepoint __tracepoint_i40e_xmit_frame_ring_drop;
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
__inline static void trace_i40e_xmit_frame_ring_drop(struct sk_buff *skb, struct i40e_ring *ring)
{
  #line 189 
  int pscr_ret___0;
  #line 189 
  if ((int)static_key_false(& __tracepoint_i40e_xmit_frame_ring_drop.key) != 0) {
    #line 189 
    int pscr_ret__;
    #line 189 
    struct tracepoint_func *________p1;
    #line 189 
    struct tracepoint_func *it_func_ptr;
    #line 189 
    void *it_func;
    #line 189 
    void *__data;
    #line 189 
    int __idx = 0;
    {
      #line 189 
      void *__vpp_verify = (void *)0;
      #line 189 
      void *tmp = __vpp_verify;
    }
    #line 189 
    switch (4UL) {
      #line 189 
      int pfo_ret___2;
      #line 189 
      int pfo_ret__;
      #line 189 
      int pfo_ret___0;
      #line 189 
      int pfo_ret___1;
      #line 189 
      case (unsigned long)1: 
                             #line 189 
      ;
      #line 189 
      switch (4UL) {
        #line 189 
        case (unsigned long)1: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        case (unsigned long)2: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        case (unsigned long)4: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        case (unsigned long)8: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        default: 
                 #line 189 
        ;
        #line 189 
        __bad_percpu_size();
      }
      #line 189 
      pscr_ret__ = pfo_ret__;
      #line 189 
      break;
      #line 189 
      case (unsigned long)2: 
                             #line 189 
      ;
      #line 189 
      switch (4UL) {
        #line 189 
        case (unsigned long)1: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        case (unsigned long)2: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        case (unsigned long)4: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        case (unsigned long)8: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        default: 
                 #line 189 
        ;
        #line 189 
        __bad_percpu_size();
      }
      #line 189 
      pscr_ret__ = pfo_ret___0;
      #line 189 
      break;
      #line 189 
      case (unsigned long)4: 
                             #line 189 
      ;
      #line 189 
      switch (4UL) {
        #line 189 
        case (unsigned long)1: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        case (unsigned long)2: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        case (unsigned long)4: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        case (unsigned long)8: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        default: 
                 #line 189 
        ;
        #line 189 
        __bad_percpu_size();
      }
      #line 189 
      pscr_ret__ = pfo_ret___1;
      #line 189 
      break;
      #line 189 
      case (unsigned long)8: 
                             #line 189 
      ;
      #line 189 
      switch (4UL) {
        #line 189 
        case (unsigned long)1: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        case (unsigned long)2: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        case (unsigned long)4: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        case (unsigned long)8: 
                               #line 189 
        ;
        #line 190 
        ldv_inline_asm();
        #line 189 
        break;
        #line 189 
        default: 
                 #line 189 
        ;
        #line 189 
        __bad_percpu_size();
      }
      #line 189 
      pscr_ret__ = pfo_ret___2;
      #line 189 
      break;
      #line 189 
      default: 
               #line 189 
      ;
      #line 189 
      __bad_size_call_parameter();
      #line 189 
      break;
    }
    #line 189 
    if (cpumask_test_cpu(pscr_ret__,& __cpu_online_mask) == 0) 
                                                               #line 189 
                                                               return;
    {
      #line 189 
      int __ret_warn_on = 0;
      #line 189 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 190 
        ldv_inline_asm();
        #line 191 
        ldv_inline_asm();
      }
      #line 189 
      long tmp_5 = (long)(__ret_warn_on != 0);
    }
    #line 189 
    __preempt_count_add(1);
    #line 190 
    ldv_inline_asm();
    {
      #line 190 
      union __anonunion___u_7771 __u;
      #line 189 
      __read_once_size((void *)(& __tracepoint_i40e_xmit_frame_ring_drop.funcs),(void *)(& __u.__c),8);
      #line 189 
      ________p1 = (__u.__val);
      }
    #line 189 
    it_func_ptr = ________p1;
    #line 189 
    if (it_func_ptr != (struct tracepoint_func *)0) 
      #line 189 
      while (1) {
        #line 189 
        it_func = it_func_ptr->func;
        #line 189 
        __data = it_func_ptr->data;
        #line 189 
        (*((void (*)(void *, struct sk_buff *, struct i40e_ring *))it_func))(__data,skb,ring);
        #line 189 
        it_func_ptr ++;
        #line 190 
        ;
        #line 190 
        if (! (it_func_ptr->func != (void *)0)) 
                                                #line 189 
                                                break;
      }
    #line 191 
    ldv_inline_asm();
    #line 189 
    __preempt_count_sub(1);
  }
  {
    #line 189 
    void *__vpp_verify_0 = (void *)0;
    #line 189 
    void *tmp_13 = __vpp_verify_0;
  }
  #line 189 
  switch (4UL) {
    #line 189 
    int pfo_ret___3;
    #line 189 
    int pfo_ret___4;
    #line 189 
    int pfo_ret___5;
    #line 189 
    int pfo_ret___6;
    #line 189 
    case (unsigned long)1: 
                           #line 189 
    ;
    #line 189 
    switch (4UL) {
      #line 189 
      case (unsigned long)1: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      case (unsigned long)2: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      case (unsigned long)4: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      case (unsigned long)8: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      default: 
               #line 189 
      ;
      #line 189 
      __bad_percpu_size();
    }
    #line 189 
    pscr_ret___0 = pfo_ret___3;
    #line 189 
    break;
    #line 189 
    case (unsigned long)2: 
                           #line 189 
    ;
    #line 189 
    switch (4UL) {
      #line 189 
      case (unsigned long)1: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      case (unsigned long)2: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      case (unsigned long)4: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      case (unsigned long)8: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      default: 
               #line 189 
      ;
      #line 189 
      __bad_percpu_size();
    }
    #line 189 
    pscr_ret___0 = pfo_ret___4;
    #line 189 
    break;
    #line 189 
    case (unsigned long)4: 
                           #line 189 
    ;
    #line 189 
    switch (4UL) {
      #line 189 
      case (unsigned long)1: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      case (unsigned long)2: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      case (unsigned long)4: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      case (unsigned long)8: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      default: 
               #line 189 
      ;
      #line 189 
      __bad_percpu_size();
    }
    #line 189 
    pscr_ret___0 = pfo_ret___5;
    #line 189 
    break;
    #line 189 
    case (unsigned long)8: 
                           #line 189 
    ;
    #line 189 
    switch (4UL) {
      #line 189 
      case (unsigned long)1: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      case (unsigned long)2: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      case (unsigned long)4: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      case (unsigned long)8: 
                             #line 189 
      ;
      #line 190 
      ldv_inline_asm();
      #line 189 
      break;
      #line 189 
      default: 
               #line 189 
      ;
      #line 189 
      __bad_percpu_size();
    }
    #line 189 
    pscr_ret___0 = pfo_ret___6;
    #line 189 
    break;
    #line 189 
    default: 
             #line 189 
    ;
    #line 189 
    __bad_size_call_parameter();
    #line 189 
    break;
  }
  #line 189 
  if (cpumask_test_cpu(pscr_ret___0,& __cpu_online_mask) != 0) {
    #line 189 
    __rcu_read_lock();
    {
      #line 190 
      union __anonunion___u_7773 __u_0;
      #line 189 
      __read_once_size((void *)(& __tracepoint_i40e_xmit_frame_ring_drop.funcs),(void *)(& __u_0.__c),8);
      #line 189 
      struct tracepoint_func *________p1_0 = (__u_0.__val);
      {
        #line 189 
        bool __warned;
        #line 189 
        if (debug_lockdep_rcu_enabled() != 0) 
          #line 189 
          if (! __warned) {
            #line 189 
            if (rcu_read_lock_sched_held() == 0) {
              #line 189 
              __warned = (_Bool)1;
              #line 189 
              lockdep_rcu_suspicious((char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h",189,(char *)"suspicious rcu_dereference_check() usage");
            }
          }
      }
      #line 189 
      struct tracepoint_func *tmp_11 = ________p1_0;
    }
    #line 189 
    __rcu_read_unlock();
  }
  #line 191 
  return;
}

#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx_common.h"
#line 530  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_fd_handle_status(struct i40e_ring *rx_ring, union i40e_32byte_rx_desc *rx_desc, u8 prog_id);
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx_common.h"
#line 2181  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_xmit_xdp_tx_ring(struct xdp_buff *xdp, struct i40e_ring *xdp_ring);
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx_common.h"
#line 1260  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
struct i40e_rx_buffer *i40e_clean_programming_status(struct i40e_ring *rx_ring, union i40e_32byte_rx_desc *rx_desc, u64 qw);
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx_common.h"
#line 1777  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_process_skb_fields(struct i40e_ring *rx_ring, union i40e_32byte_rx_desc *rx_desc, struct sk_buff *skb);
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx_common.h"
#line 2266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_xdp_ring_update_tail(struct i40e_ring *xdp_ring);
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx_common.h"
#line 2283  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_update_rx_stats(struct i40e_ring *rx_ring, unsigned int total_rx_bytes, unsigned int total_rx_packets);
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx_common.h"
#line 2304  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_finalize_xdp_rx(struct i40e_ring *rx_ring, unsigned int xdp_res);
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx_common.h"
#line 1483  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_release_rx_desc(struct i40e_ring *rx_ring, u32 val);
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx_common.h"
__inline static __le64 build_ctob(u32 td_cmd, u32 td_offset, unsigned int size, u32 td_tag)
{
  #line 34 
  return ((((unsigned long long)td_cmd << 4) | ((unsigned long long)td_offset << 16)) | ((unsigned long long)size << 34)) | ((unsigned long long)td_tag << 48);
}

#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx_common.h"
__inline static void i40e_update_tx_stats(struct i40e_ring *tx_ring, unsigned int total_packets, unsigned int total_bytes)
{
  #line 51 
  u64_stats_init(& tx_ring->syncp);
  #line 52 
  tx_ring->stats.bytes += (unsigned long long)total_bytes;
  #line 53 
  tx_ring->stats.packets += (unsigned long long)total_packets;
  #line 54 
  u64_stats_init(& tx_ring->syncp);
  #line 55 
  (tx_ring->q_vector)->tx.total_bytes += total_bytes;
  #line 56 
  (tx_ring->q_vector)->tx.total_packets += total_packets;
  #line 57 
  return;
}

#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx_common.h"
__inline static void i40e_arm_wb(struct i40e_ring *tx_ring, struct i40e_vsi *vsi, int budget)
{
  #line 71 
  if (((unsigned long)tx_ring->flags & 1UL) != 0UL) {
    #line 77 
    unsigned int j = i40e_get_tx_pending(tx_ring,(_Bool)0);
    #line 79 
    if ((budget != 0 && j <= 3U) && j != 0U) {
      #line 81 
      if (! test_bit(0L,(unsigned long *)(& vsi->state))) {
        #line 81 
        int tmp_1;
        #line 81 
        if ((int)tx_ring->next_to_clean <= (int)tx_ring->next_to_use) 
          #line 81 
          tmp_1 = (int)tx_ring->count; else 
                                            #line 81 
                                            tmp_1 = 0;
        #line 81 
        ;
        #line 81 
        if (((tmp_1 + (int)tx_ring->next_to_clean) - (int)tx_ring->next_to_use) + -1 != (int)tx_ring->count) 
          #line 83 
          tx_ring->arm_wb = (_Bool)1;
      }
    }
  }
  #line 85 
  return;
}

#line 87 
#line 87 
void i40e_xsk_clean_rx_ring(struct i40e_ring *rx_ring);
#line 88 
#line 88 
void i40e_xsk_clean_tx_ring(struct i40e_ring *tx_ring);
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.h"
#line 17 
int i40e_clean_rx_irq_zc(struct i40e_ring *rx_ring, int budget);
#line 19 
#line 19 
bool i40e_clean_xdp_tx_irq(struct i40e_vsi *vsi, struct i40e_ring *tx_ring, int napi_budget);
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_fdir(struct i40e_ring *tx_ring, struct i40e_fdir_filter *fdata, bool add)
{
  #line 24 
  struct i40e_filter_program_desc *fdir_desc;
  #line 26 
  u32 flex_ptype;
  #line 26 
  u32 dtype_cmd;
  #line 27 
  u16 i;
  #line 49 
  unsigned int tmp;
  #line 55 
  unsigned int tmp_0;
  #line 25 
  struct i40e_pf *pf = (tx_ring->vsi)->back;
  #line 30 
  i = tx_ring->next_to_use;
  #line 31 
  fdir_desc = (struct i40e_filter_program_desc *)tx_ring->desc + (unsigned long)i;
  #line 33 
  i = (u16)((int)i + 1);
  #line 34 
  if ((int)tx_ring->count > (int)i) 
                                    #line 34 
                                    tx_ring->next_to_use = i; else 
                                                                   #line 34 
                                                                   tx_ring->next_to_use = (unsigned short)0U;
  #line 36 
  flex_ptype = (unsigned int)fdata->q_index & 2047U;
  #line 39 
  flex_ptype = ((unsigned int)((int)fdata->flex_off << 11) & 14336U) | flex_ptype;
  #line 42 
  flex_ptype = ((unsigned int)((int)fdata->pctype << 17) & 8257536U) | flex_ptype;
  #line 45 
  flex_ptype = ((unsigned int)((int)fdata->flex_offset << 11) & 8257536U) | flex_ptype;
  #line 49 
  if ((int)fdata->dest_vsi != 0) 
                                 #line 49 
                                 tmp = (unsigned int)((int)fdata->dest_vsi) << 23; else 
                                                                    #line 49 
                                                                    tmp = (unsigned int)(*(pf->vsi + (unsigned long)pf->lan_vsi))->id << 23;
  #line 51 
  flex_ptype = (unsigned int)((unsigned long)tmp) | flex_ptype;
  #line 53 
  dtype_cmd = 8U;
  #line 55 
  if ((int)add != 0) 
                     #line 55 
                     tmp_0 = 16U; else 
                                       #line 55 
                                       tmp_0 = 32U;
  #line 55 
  dtype_cmd = tmp_0 | dtype_cmd;
  #line 61 
  dtype_cmd = ((unsigned int)((int)fdata->dest_ctl << 7ULL) & 384U) | dtype_cmd;
  #line 64 
  dtype_cmd = ((unsigned int)((int)fdata->fd_status << 13ULL) & 24576U) | dtype_cmd;
  #line 67 
  if ((unsigned int)fdata->cnt_index != 0U) {
    #line 68 
    dtype_cmd |= 2048U;
    #line 69 
    dtype_cmd = (((unsigned int)fdata->cnt_index << 20) & 535822336U) | dtype_cmd;
  }
  #line 74 
  fdir_desc->qindex_flex_ptype_vsi = flex_ptype;
  #line 75 
  fdir_desc->rsvd = 0U;
  #line 76 
  fdir_desc->dtype_cmd_cntindex = dtype_cmd;
  #line 77 
  fdir_desc->fd_id = fdata->fd_id;
  #line 78 
  return;
}

#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_program_fdir_filter(struct i40e_fdir_filter *fdir_data, u8 *raw_packet, struct i40e_pf *pf, bool add)
{
  #line 92 
  struct i40e_tx_buffer *tx_buf;
  #line 92 
  struct i40e_tx_buffer *first;
  #line 93 
  struct i40e_tx_desc *tx_desc;
  #line 94 
  struct i40e_ring *tx_ring;
  #line 95 
  struct i40e_vsi *vsi;
  #line 96 
  struct device *dev;
  #line 97 
  dma_addr_t dma;
  #line 99 
  u16 i;
  #line 98 
  u32 td_cmd = 0U;
  #line 102 
  vsi = i40e_find_vsi_by_type(pf,(unsigned short)7);
  #line 103 
  if (vsi == (struct i40e_vsi *)0) 
                                   #line 104 
                                   return -2;
  #line 106 
  tx_ring = *(vsi->tx_rings);
  #line 107 
  dev = tx_ring->dev;
  #line 110 
  i = (unsigned short)10U;
  #line 110 
  while (1) {
    #line 110 
    int tmp;
    #line 110 
    if ((int)tx_ring->next_to_clean <= (int)tx_ring->next_to_use) 
                                                                  #line 110 
                                                                  tmp = (int)tx_ring->count; else 
                                                                    #line 110 
                                                                    tmp = 0;
    #line 110 
    ;
    #line 110 
    if (! ((tmp + (int)tx_ring->next_to_clean) - (int)tx_ring->next_to_use <= 2)) 
      #line 110 
      break;
    #line 111 
    if ((unsigned int)i == 0U) 
                               #line 112 
                               return -11;
    #line 113 
    msleep_interruptible(1U);
    #line 110 
    i = (u16)((int)i - 1);
  }
  #line 116 
  dma = dma_map_single_attrs(dev,(void *)raw_packet,512UL,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
  #line 118 
  if (dma_mapping_error(dev,dma) != 0) 
                                       #line 119 
                                       goto dma_fail;
  #line 122 
  i = tx_ring->next_to_use;
  #line 123 
  first = tx_ring->__anonCompField_i40e_ring_221.tx_bi + (unsigned long)i;
  #line 124 
  i40e_fdir(tx_ring,fdir_data,(_Bool)((bool)((int)add) != 0));
  #line 127 
  i = tx_ring->next_to_use;
  #line 128 
  tx_desc = (struct i40e_tx_desc *)tx_ring->desc + (unsigned long)i;
  #line 129 
  tx_buf = tx_ring->__anonCompField_i40e_ring_221.tx_bi + (unsigned long)i;
  #line 131 
  if ((int)i + 1 < (int)tx_ring->count) 
                                        #line 131 
                                        tx_ring->next_to_use = (unsigned short)((unsigned int)i + 1U); else 
                                                                    #line 131 
                                                                    tx_ring->next_to_use = (unsigned short)0U;
  #line 133 
  memset((void *)tx_buf,0,40UL);
  #line 136 
  tx_buf->len = 512U;
  #line 137 
  tx_buf->dma = dma;
  #line 139 
  tx_desc->buffer_addr = dma;
  #line 140 
  td_cmd = 19U;
  #line 142 
  tx_buf->tx_flags = 512U;
  #line 143 
  tx_buf->__anonCompField_i40e_tx_buffer_217.raw_buf = (void *)raw_packet;
  #line 145 
  tx_desc->cmd_type_offset_bsz = build_ctob(td_cmd,0U,512U,0U);
  #line 147 
  ldv_inline_asm();
  #line 154 
  first->next_to_watch = tx_desc;
  #line 156 
  writel((unsigned int)tx_ring->next_to_use,(void *)tx_ring->tail);
  #line 157 
  return 0;
  #line 159 
  dma_fail: 
            #line 159 
  ;
  #line 160 
  return -1;
}

#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_add_del_fdir_udpv4(struct i40e_vsi *vsi, struct i40e_fdir_filter *fd_data, bool add)
{
  #line 178 
  struct udphdr *udp;
  #line 179 
  struct iphdr *ip;
  #line 180 
  u8 *raw_packet;
  #line 181 
  int ret;
  #line 177 
  struct i40e_pf *pf = vsi->back;
  #line 182 
  char packet[42U] = {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)8, (char)0, (char)69, (char)0, (char)0, (char)28, (char)0, (char)0, (char)64, (char)0, (char)64, (char)17, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0};
  #line 186 
  raw_packet = (u8 *)kzalloc_0(512UL,3264U);
  #line 187 
  if (raw_packet == (u8 *)0U) 
                              #line 188 
                              return -12;
  #line 189 
  memcpy((void *)raw_packet,(void *)(& packet),42UL);
  #line 191 
  ip = (struct iphdr *)(raw_packet + 14U);
  #line 192 
  udp = (struct udphdr *)(raw_packet + 34U);
  #line 195 
  ip->daddr = fd_data->dst_ip;
  #line 196 
  udp->dest = fd_data->dst_port;
  #line 197 
  ip->saddr = fd_data->src_ip;
  #line 198 
  udp->source = fd_data->src_port;
  #line 200 
  if ((int)fd_data->flex_filter != 0) {
    #line 201 
    u8 *payload = raw_packet + 42U;
    #line 202 
    __be16 pattern = fd_data->flex_word;
    #line 203 
    u16 off = fd_data->flex_offset;
    #line 205 
    *((__be16 *)(payload + (unsigned long)off)) = pattern;
  }
  #line 208 
  fd_data->pctype = (unsigned char)31U;
  #line 209 
  ret = i40e_program_fdir_filter(fd_data,raw_packet,pf,(_Bool)((bool)((int)add) != 0));
  #line 210 
  if (ret != 0) {
    #line 211 
    _dev_info(& (pf->pdev)->dev,(char *)"PCTYPE:%d, Filter command send failed for fd_id:%d (ret = %d)\n",(int)fd_data->pctype,fd_data->fd_id,ret);
    #line 215 
    kfree((void *)raw_packet);
    #line 216 
    return -95;
  }
  else 
    #line 217 
    if ((pf->hw.debug_mask & 4096U) != 0U) 
      #line 218 
      if ((int)add != 0) 
                         #line 219 
                         _dev_info(& (pf->pdev)->dev,(char *)"Filter OK for PCTYPE %d loc = %d\n",(int)fd_data->pctype,fd_data->fd_id); else 
                                                                    #line 223 
                                                                    _dev_info(& (pf->pdev)->dev,(char *)"Filter deleted for PCTYPE %d loc = %d\n",(int)fd_data->pctype,fd_data->fd_id);
  #line 228 
  if ((int)add != 0) 
                     #line 229 
                     pf->fd_udp4_filter_cnt = (u16)((int)pf->fd_udp4_filter_cnt + 1); else 
                                                                    #line 231 
                                                                    pf->fd_udp4_filter_cnt = (u16)((int)pf->fd_udp4_filter_cnt - 1);
  #line 233 
  return 0;
}

#line 245  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_add_del_fdir_tcpv4(struct i40e_vsi *vsi, struct i40e_fdir_filter *fd_data, bool add)
{
  #line 250 
  struct tcphdr *tcp;
  #line 251 
  struct iphdr *ip;
  #line 252 
  u8 *raw_packet;
  #line 253 
  int ret;
  #line 249 
  struct i40e_pf *pf = vsi->back;
  #line 255 
  char packet[54U] = {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)8, (char)0, (char)69, (char)0, (char)0, (char)40, (char)0, (char)0, (char)64, (char)0, (char)64, (char)6, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)(-128), (char)17, (char)0, (char)114, (char)0, (char)0, (char)0, (char)0};
  #line 260 
  raw_packet = (u8 *)kzalloc_0(512UL,3264U);
  #line 261 
  if (raw_packet == (u8 *)0U) 
                              #line 262 
                              return -12;
  #line 263 
  memcpy((void *)raw_packet,(void *)(& packet),54UL);
  #line 265 
  ip = (struct iphdr *)(raw_packet + 14U);
  #line 266 
  tcp = (struct tcphdr *)(raw_packet + 34U);
  #line 269 
  ip->daddr = fd_data->dst_ip;
  #line 270 
  tcp->dest = fd_data->dst_port;
  #line 271 
  ip->saddr = fd_data->src_ip;
  #line 272 
  tcp->source = fd_data->src_port;
  #line 274 
  if ((int)fd_data->flex_filter != 0) {
    #line 275 
    u8 *payload = raw_packet + 54U;
    #line 276 
    __be16 pattern = fd_data->flex_word;
    #line 277 
    u16 off = fd_data->flex_offset;
    #line 279 
    *((__be16 *)(payload + (unsigned long)off)) = pattern;
  }
  #line 282 
  fd_data->pctype = (unsigned char)33U;
  #line 283 
  ret = i40e_program_fdir_filter(fd_data,raw_packet,pf,(_Bool)((bool)((int)add) != 0));
  #line 284 
  if (ret != 0) {
    #line 285 
    _dev_info(& (pf->pdev)->dev,(char *)"PCTYPE:%d, Filter command send failed for fd_id:%d (ret = %d)\n",(int)fd_data->pctype,fd_data->fd_id,ret);
    #line 289 
    kfree((void *)raw_packet);
    #line 290 
    return -95;
  }
  else 
    #line 291 
    if ((pf->hw.debug_mask & 4096U) != 0U) 
      #line 292 
      if ((int)add != 0) 
                         #line 293 
                         _dev_info(& (pf->pdev)->dev,(char *)"Filter OK for PCTYPE %d loc = %d)\n",(int)fd_data->pctype,fd_data->fd_id); else 
                                                                    #line 296 
                                                                    _dev_info(& (pf->pdev)->dev,(char *)"Filter deleted for PCTYPE %d loc = %d\n",(int)fd_data->pctype,fd_data->fd_id);
  #line 301 
  if ((int)add != 0) {
    #line 302 
    pf->fd_tcp4_filter_cnt = (u16)((int)pf->fd_tcp4_filter_cnt + 1);
    #line 303 
    if (((unsigned long)pf->flags & 512UL) != 0UL && (pf->hw.debug_mask & 4096U) != 0U) 
      #line 305 
      _dev_info(& (pf->pdev)->dev,(char *)"Forcing ATR off, sideband rules for TCP/IPv4 flow being applied\n");
    #line 306 
    cif_set_bit_0(22L,(unsigned long *)(& pf->state));
  }
  else 
       #line 308 
       pf->fd_tcp4_filter_cnt = (u16)((int)pf->fd_tcp4_filter_cnt - 1);
  #line 311 
  return 0;
}

#line 324  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_add_del_fdir_sctpv4(struct i40e_vsi *vsi, struct i40e_fdir_filter *fd_data, bool add)
{
  #line 329 
  struct sctphdr *sctp;
  #line 330 
  struct iphdr *ip;
  #line 331 
  u8 *raw_packet;
  #line 332 
  int ret;
  #line 328 
  struct i40e_pf *pf = vsi->back;
  #line 334 
  char packet[46U] = {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)8, (char)0, (char)69, (char)0, (char)0, (char)32, (char)0, (char)0, (char)64, (char)0, (char)64, (char)(-124), (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0};
  #line 338 
  raw_packet = (u8 *)kzalloc_0(512UL,3264U);
  #line 339 
  if (raw_packet == (u8 *)0U) 
                              #line 340 
                              return -12;
  #line 341 
  memcpy((void *)raw_packet,(void *)(& packet),46UL);
  #line 343 
  ip = (struct iphdr *)(raw_packet + 14U);
  #line 344 
  sctp = (struct sctphdr *)(raw_packet + 34U);
  #line 347 
  ip->daddr = fd_data->dst_ip;
  #line 348 
  sctp->dest = fd_data->dst_port;
  #line 349 
  ip->saddr = fd_data->src_ip;
  #line 350 
  sctp->source = fd_data->src_port;
  #line 352 
  if ((int)fd_data->flex_filter != 0) {
    #line 353 
    u8 *payload = raw_packet + 46U;
    #line 354 
    __be16 pattern = fd_data->flex_word;
    #line 355 
    u16 off = fd_data->flex_offset;
    #line 357 
    *((__be16 *)(payload + (unsigned long)off)) = pattern;
  }
  #line 360 
  fd_data->pctype = (unsigned char)34U;
  #line 361 
  ret = i40e_program_fdir_filter(fd_data,raw_packet,pf,(_Bool)((bool)((int)add) != 0));
  #line 362 
  if (ret != 0) {
    #line 363 
    _dev_info(& (pf->pdev)->dev,(char *)"PCTYPE:%d, Filter command send failed for fd_id:%d (ret = %d)\n",(int)fd_data->pctype,fd_data->fd_id,ret);
    #line 367 
    kfree((void *)raw_packet);
    #line 368 
    return -95;
  }
  else 
    #line 369 
    if ((pf->hw.debug_mask & 4096U) != 0U) 
      #line 370 
      if ((int)add != 0) 
                         #line 371 
                         _dev_info(& (pf->pdev)->dev,(char *)"Filter OK for PCTYPE %d loc = %d\n",(int)fd_data->pctype,fd_data->fd_id); else 
                                                                    #line 375 
                                                                    _dev_info(& (pf->pdev)->dev,(char *)"Filter deleted for PCTYPE %d loc = %d\n",(int)fd_data->pctype,fd_data->fd_id);
  #line 380 
  if ((int)add != 0) 
                     #line 381 
                     pf->fd_sctp4_filter_cnt = (u16)((int)pf->fd_sctp4_filter_cnt + 1); else 
                                                                    #line 383 
                                                                    pf->fd_sctp4_filter_cnt = (u16)((int)pf->fd_sctp4_filter_cnt - 1);
  #line 385 
  return 0;
}

#line 398  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_add_del_fdir_ipv4(struct i40e_vsi *vsi, struct i40e_fdir_filter *fd_data, bool add)
{
  #line 403 
  struct iphdr *ip;
  #line 404 
  u8 *raw_packet;
  #line 405 
  int ret;
  #line 406 
  int i;
  #line 402 
  struct i40e_pf *pf = vsi->back;
  #line 407 
  char packet[34U] = {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)8, (char)0, (char)69, (char)0, (char)0, (char)20, (char)0, (char)0, (char)64, (char)0, (char)64, (char)16, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0};
  #line 411 
  i = 35;
  #line 411 
  while (i <= 36) {
    #line 413 
    raw_packet = (u8 *)kzalloc_0(512UL,3264U);
    #line 414 
    if (raw_packet == (u8 *)0U) 
                                #line 415 
                                return -12;
    #line 416 
    memcpy((void *)raw_packet,(void *)(& packet),34UL);
    #line 417 
    ip = (struct iphdr *)(raw_packet + 14U);
    #line 419 
    ip->saddr = fd_data->src_ip;
    #line 420 
    ip->daddr = fd_data->dst_ip;
    #line 421 
    ip->protocol = (unsigned char)0U;
    #line 423 
    if ((int)fd_data->flex_filter != 0) {
      #line 424 
      u8 *payload = raw_packet + 34U;
      #line 425 
      __be16 pattern = fd_data->flex_word;
      #line 426 
      u16 off = fd_data->flex_offset;
      #line 428 
      *((__be16 *)(payload + (unsigned long)off)) = pattern;
    }
    #line 431 
    fd_data->pctype = (unsigned char)i;
    #line 432 
    ret = i40e_program_fdir_filter(fd_data,raw_packet,pf,(_Bool)((bool)((int)add) != 0));
    #line 433 
    if (ret != 0) {
      #line 434 
      _dev_info(& (pf->pdev)->dev,(char *)"PCTYPE:%d, Filter command send failed for fd_id:%d (ret = %d)\n",(int)fd_data->pctype,fd_data->fd_id,ret);
      #line 440 
      kfree((void *)raw_packet);
      #line 441 
      return -95;
    }
    else 
      #line 442 
      if ((pf->hw.debug_mask & 4096U) != 0U) 
        #line 443 
        if ((int)add != 0) 
                           #line 444 
                           _dev_info(& (pf->pdev)->dev,(char *)"Filter OK for PCTYPE %d loc = %d\n",(int)fd_data->pctype,fd_data->fd_id); else 
                                                                    #line 448 
                                                                    _dev_info(& (pf->pdev)->dev,(char *)"Filter deleted for PCTYPE %d loc = %d\n",(int)fd_data->pctype,fd_data->fd_id);
    #line 412 
    i ++;
  }
  #line 454 
  if ((int)add != 0) 
                     #line 455 
                     pf->fd_ip4_filter_cnt = (u16)((int)pf->fd_ip4_filter_cnt + 1); else 
                                                                    #line 457 
                                                                    pf->fd_ip4_filter_cnt = (u16)((int)pf->fd_ip4_filter_cnt - 1);
  #line 459 
  return 0;
}

#line 469  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_add_del_fdir(struct i40e_vsi *vsi, struct i40e_fdir_filter *input, bool add)
{
  #line 473 
  int ret;
  #line 472 
  struct i40e_pf *pf = vsi->back;
  #line 475 
  switch ((unsigned int)input->flow_type) {
    #line 476 
    case (unsigned int)1: 
                          #line 476 
    ;
    #line 477 
    ret = i40e_add_del_fdir_tcpv4(vsi,input,(_Bool)((bool)((int)add) != 0));
    #line 478 
    break;
    #line 479 
    case (unsigned int)2: 
                          #line 479 
    ;
    #line 480 
    ret = i40e_add_del_fdir_udpv4(vsi,input,(_Bool)((bool)((int)add) != 0));
    #line 481 
    break;
    #line 482 
    case (unsigned int)3: 
                          #line 482 
    ;
    #line 483 
    ret = i40e_add_del_fdir_sctpv4(vsi,input,(_Bool)((bool)((int)add) != 0));
    #line 484 
    break;
    #line 485 
    case (unsigned int)13: 
                           #line 485 
    ;
    #line 486 
    switch ((int)input->ip4_proto) {
      #line 487 
      case 6: 
              #line 487 
      ;
      #line 488 
      ret = i40e_add_del_fdir_tcpv4(vsi,input,(_Bool)((bool)((int)add) != 0));
      #line 489 
      break;
      #line 490 
      case 17: 
               #line 490 
      ;
      #line 491 
      ret = i40e_add_del_fdir_udpv4(vsi,input,(_Bool)((bool)((int)add) != 0));
      #line 492 
      break;
      #line 493 
      case 132: 
                #line 493 
      ;
      #line 494 
      ret = i40e_add_del_fdir_sctpv4(vsi,input,(_Bool)((bool)((int)add) != 0));
      #line 495 
      break;
      #line 496 
      case 0: 
              #line 496 
      ;
      #line 497 
      ret = i40e_add_del_fdir_ipv4(vsi,input,(_Bool)((bool)((int)add) != 0));
      #line 498 
      break;
      #line 499 
      default: 
               #line 499 
      ;
      #line 501 
      _dev_info(& (pf->pdev)->dev,(char *)"Unsupported IPv4 protocol 0x%02x\n",(int)input->ip4_proto);
      #line 503 
      return -22;
    }
    #line 505 
    break;
    #line 506 
    default: 
             #line 506 
    ;
    #line 507 
    _dev_info(& (pf->pdev)->dev,(char *)"Unsupported flow type 0x%02x\n",(int)input->flow_type);
    #line 509 
    return -22;
  }
  #line 518 
  return ret;
}

#line 530  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_fd_handle_status(struct i40e_ring *rx_ring, union i40e_32byte_rx_desc *rx_desc, u8 prog_id)
{
  #line 535 
  u32 fcnt_prog;
  #line 535 
  u32 fcnt_avail;
  #line 536 
  u32 error;
  #line 537 
  u64 qw;
  #line 533 
  struct i40e_pf *pf = (rx_ring->vsi)->back;
  #line 534 
  struct pci_dev *pdev = pf->pdev;
  #line 539 
  qw = rx_desc->wb.qword1.status_error_len;
  #line 540 
  error = (unsigned int)(qw >> 19) & 63U;
  #line 543 
  if (error == 1U) {
    #line 544 
    pf->fd_inv = rx_desc->wb.qword0.hi_dword.fd_id;
    #line 545 
    if (rx_desc->wb.qword0.hi_dword.fd_id != 0U || (pf->hw.debug_mask & 4096U) != 0U) 
      #line 547 
      _dev_warn(& pdev->dev,(char *)"ntuple filter loc = %d, could not be added\n",pf->fd_inv);
    #line 556 
    if ((int)test_bit(21L,(unsigned long *)(& pf->state)) != 0) 
                                                                #line 557 
                                                                return;
    #line 559 
    (pf->fd_add_err) ++;
    #line 561 
    pf->fd_atr_cnt = i40e_get_current_atr_cnt(pf);
    #line 563 
    if (rx_desc->wb.qword0.hi_dword.fd_id == 0U) {
      #line 563 
      if ((int)test_bit(23L,(unsigned long *)(& pf->state)) != 0) {
        #line 571 
        cif_set_bit_0(22L,(unsigned long *)(& pf->state));
        #line 572 
        cif_set_bit_0(21L,(unsigned long *)(& pf->state));
      }
    }
    #line 576 
    fcnt_prog = i40e_get_global_fd_count(pf);
    #line 577 
    fcnt_avail = (unsigned int)pf->fdir_pf_filter_count;
    #line 582 
    if (fcnt_avail + 4294967286U <= fcnt_prog) 
      #line 583 
      if (((unsigned long)pf->flags & 256UL) != 0UL) {
        #line 584 
        if (! test_and_set_bit(23L,(unsigned long *)(& pf->state))) 
          #line 586 
          if ((pf->hw.debug_mask & 4096U) != 0U) 
                                                 #line 587 
                                                 _dev_warn(& pdev->dev,(char *)"FD filter space full, new ntuple rules will not be added\n");
      }
  }
  else 
    #line 589 
    if (error == 2U) 
      #line 590 
      if ((pf->hw.debug_mask & 4096U) != 0U) 
                                             #line 591 
                                             _dev_info(& pdev->dev,(char *)"ntuple filter fd_id = %d, could not be removed\n",rx_desc->wb.qword0.hi_dword.fd_id);
  #line 592 
  return;
}

#line 601  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_unmap_and_free_tx_resource(struct i40e_ring *ring, struct i40e_tx_buffer *tx_buffer)
{
  #line 604 
  if (tx_buffer->__anonCompField_i40e_tx_buffer_217.skb != (struct sk_buff *)0) {
    #line 605 
    if (((unsigned long)tx_buffer->tx_flags & 512UL) != 0UL) 
                                                             #line 606 
                                                             kfree(tx_buffer->__anonCompField_i40e_tx_buffer_217.raw_buf);
    else {
      #line 607 
      if ((int)ring_is_xdp(ring) != 0) 
                                       #line 608 
                                       xdp_return_frame(tx_buffer->__anonCompField_i40e_tx_buffer_217.xdpf); else 
                                                                    #line 610 
                                                                    dev_kfree_skb_any(tx_buffer->__anonCompField_i40e_tx_buffer_217.skb);
    }
    #line 611 
    if (tx_buffer->len != 0U) 
                              #line 612 
                              dma_unmap_single_attrs(ring->dev,tx_buffer->dma,(unsigned long)tx_buffer->len,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
  }
  else 
    #line 616 
    if (tx_buffer->len != 0U) 
                              #line 617 
                              dma_unmap_page_attrs(ring->dev,tx_buffer->dma,(unsigned long)tx_buffer->len,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
  #line 623 
  tx_buffer->next_to_watch = (struct i40e_tx_desc *)0;
  #line 624 
  tx_buffer->__anonCompField_i40e_tx_buffer_217.skb = (struct sk_buff *)0;
  #line 625 
  tx_buffer->len = 0U;
  #line 626 
  return;
}

#line 633  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_clean_tx_ring(struct i40e_ring *tx_ring)
{
  #line 635 
  unsigned long bi_size;
  #line 636 
  u16 i;
  #line 638 
  if ((int)ring_is_xdp(tx_ring) != 0) {
    #line 638 
    if (tx_ring->xsk_umem != (struct xdp_umem *)0) 
                                                   #line 639 
                                                   i40e_xsk_clean_tx_ring(tx_ring); else 
                                                                    #line 638 
                                                                    goto _LAND;
  }
  else {
    #line 638 
    _LAND: {
             #line 642 
             if (tx_ring->__anonCompField_i40e_ring_221.tx_bi == (struct i40e_tx_buffer *)0) 
               #line 643 
               return;
             #line 646 
             i = (unsigned short)0U;
             #line 646 
             while ((int)tx_ring->count > (int)i) {
               #line 647 
               i40e_unmap_and_free_tx_resource(tx_ring,tx_ring->__anonCompField_i40e_ring_221.tx_bi + (unsigned long)i);
               #line 646 
               i = (u16)((int)i + 1);
             }
           }
  }
  #line 651 
  bi_size = (unsigned long)tx_ring->count * 40UL;
  #line 652 
  memset((void *)tx_ring->__anonCompField_i40e_ring_221.tx_bi,0,bi_size);
  #line 655 
  memset(tx_ring->desc,0,(unsigned long)tx_ring->size);
  #line 657 
  tx_ring->next_to_use = (unsigned short)0U;
  #line 658 
  tx_ring->next_to_clean = (unsigned short)0U;
  #line 660 
  if (tx_ring->netdev == (struct net_device *)0) 
                                                 #line 661 
                                                 return;
  #line 664 
  netdev_tx_reset_queue(txring_txq(tx_ring));
  #line 665 
  return;
}

#line 673  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_free_tx_resources(struct i40e_ring *tx_ring)
{
  #line 675 
  i40e_clean_tx_ring(tx_ring);
  #line 676 
  kfree((void *)tx_ring->__anonCompField_i40e_ring_221.tx_bi);
  #line 677 
  tx_ring->__anonCompField_i40e_ring_221.tx_bi = (struct i40e_tx_buffer *)0;
  #line 679 
  if (tx_ring->desc != (void *)0) {
    #line 680 
    dma_free_coherent(tx_ring->dev,(unsigned long)tx_ring->size,tx_ring->desc,tx_ring->dma);
    #line 682 
    tx_ring->desc = (void *)0;
  }
  #line 684 
  return;
}

#line 694  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
u32 i40e_get_tx_pending(struct i40e_ring *ring, bool in_sw)
{
  #line 696 
  u32 head;
  #line 696 
  u32 tail;
  #line 698 
  if (! in_sw) {
    #line 699 
    head = i40e_get_head(ring);
    #line 700 
    tail = readl((void *)ring->tail);
  }
  else {
    #line 702 
    head = (unsigned int)ring->next_to_clean;
    #line 703 
    tail = (unsigned int)ring->next_to_use;
  }
  #line 706 
  if (head != tail) {
    #line 708 
    u32 tmp;
    #line 708 
    if (head < tail) 
                     #line 708 
                     tmp = tail - head; else 
                                             #line 708 
                                             tmp = ((unsigned int)ring->count + tail) - head;
    #line 708 
    return tmp;
  }
  #line 710 
  return 0U;
}

#line 720  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_detect_recover_hung(struct i40e_vsi *vsi)
{
  #line 723 
  struct net_device *netdev;
  #line 724 
  unsigned int i;
  #line 725 
  int packets;
  #line 722 
  struct i40e_ring *tx_ring = (struct i40e_ring *)0;
  #line 727 
  if (vsi == (struct i40e_vsi *)0) 
                                   #line 728 
                                   return;
  #line 730 
  if ((int)test_bit(0L,(unsigned long *)(& vsi->state)) != 0) 
                                                              #line 731 
                                                              return;
  #line 733 
  netdev = vsi->netdev;
  #line 734 
  if (netdev == (struct net_device *)0) 
                                        #line 735 
                                        return;
  #line 737 
  if (! netif_carrier_ok(netdev)) 
                                  #line 738 
                                  return;
  #line 740 
  i = 0U;
  #line 740 
  while ((unsigned int)vsi->num_queue_pairs > i) {
    #line 741 
    tx_ring = *(vsi->tx_rings + (unsigned long)i);
    #line 742 
    if (tx_ring != (struct i40e_ring *)0 && tx_ring->desc != (void *)0) {
      #line 750 
      packets = (int)tx_ring->stats.packets & 2147483647;
      #line 751 
      if (tx_ring->__anonCompField_i40e_ring_222.tx_stats.prev_pkt_ctr == packets) {
        #line 752 
        i40e_force_wb(vsi,tx_ring->q_vector);
        #line 753 
        goto __Cont;
      }
      #line 755 
      ldv_inline_asm();
      #line 760 
      if (i40e_get_tx_pending(tx_ring,(_Bool)1) != 0U) 
                                                       #line 760 
                                                       tx_ring->__anonCompField_i40e_ring_222.tx_stats.prev_pkt_ctr = packets; else 
                                                                    #line 760 
                                                                    tx_ring->__anonCompField_i40e_ring_222.tx_stats.prev_pkt_ctr = -1;
    }
    #line 740 
    __Cont: 
            #line 740 
    i ++;
  }
  #line 764 
  return;
}

#line 774  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static bool i40e_clean_tx_irq(struct i40e_vsi *vsi, struct i40e_ring *tx_ring, int napi_budget)
{
  #line 778 
  struct i40e_tx_buffer *tx_buf;
  #line 779 
  struct i40e_tx_desc *tx_head;
  #line 780 
  struct i40e_tx_desc *tx_desc;
  #line 881 
  int tmp_6;
  #line 777 
  int i = (int)tx_ring->next_to_clean;
  #line 781 
  unsigned int total_bytes = 0U;
  #line 781 
  unsigned int total_packets = 0U;
  #line 782 
  unsigned int budget = (unsigned int)vsi->work_limit;
  #line 784 
  tx_buf = tx_ring->__anonCompField_i40e_ring_221.tx_bi + (unsigned long)i;
  #line 785 
  tx_desc = (struct i40e_tx_desc *)tx_ring->desc + (unsigned long)i;
  #line 786 
  i -= (int)tx_ring->count;
  #line 788 
  tx_head = (struct i40e_tx_desc *)tx_ring->desc + (unsigned long)i40e_get_head(tx_ring);
  #line 790 
  while (1) {
    {
      #line 791 
      struct i40e_tx_desc *eop_desc = tx_buf->next_to_watch;
      #line 794 
      if (eop_desc == (struct i40e_tx_desc *)0) 
                                                #line 795 
                                                break;
      #line 796 
      ldv_inline_asm();
      #line 800 
      trace_i40e_clean_tx_irq(tx_ring,tx_desc,tx_buf);
      #line 802 
      if (tx_head == tx_desc) 
                              #line 803 
                              break;
      #line 806 
      tx_buf->next_to_watch = (struct i40e_tx_desc *)0;
      #line 809 
      total_bytes = tx_buf->bytecount + total_bytes;
      #line 810 
      total_packets = (unsigned int)tx_buf->gso_segs + total_packets;
      #line 813 
      if ((int)ring_is_xdp(tx_ring) != 0) 
                                          #line 814 
                                          xdp_return_frame(tx_buf->__anonCompField_i40e_tx_buffer_217.xdpf); else 
                                                                    #line 816 
                                                                    napi_consume_skb(tx_buf->__anonCompField_i40e_tx_buffer_217.skb,napi_budget);
      #line 819 
      dma_unmap_single_attrs(tx_ring->dev,tx_buf->dma,(unsigned long)tx_buf->len,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
      #line 825 
      tx_buf->__anonCompField_i40e_tx_buffer_217.skb = (struct sk_buff *)0;
      #line 826 
      tx_buf->len = 0U;
      #line 829 
      while (tx_desc != eop_desc) {
        #line 830 
        trace_i40e_clean_tx_irq_unmap(tx_ring,tx_desc,tx_buf);
        #line 833 
        tx_buf ++;
        #line 834 
        tx_desc ++;
        #line 835 
        i ++;
        #line 836 
        if ((long)(i == 0) != 0L) {
          #line 837 
          i -= (int)tx_ring->count;
          #line 838 
          tx_buf = tx_ring->__anonCompField_i40e_ring_221.tx_bi;
          #line 839 
          tx_desc = (struct i40e_tx_desc *)tx_ring->desc;
        }
        #line 843 
        if (tx_buf->len != 0U) {
          #line 844 
          dma_unmap_page_attrs(tx_ring->dev,tx_buf->dma,(unsigned long)tx_buf->len,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
          #line 848 
          tx_buf->len = 0U;
        }
      }
      #line 853 
      tx_buf ++;
      #line 854 
      tx_desc ++;
      #line 855 
      i ++;
      #line 856 
      if ((long)(i == 0) != 0L) {
        #line 857 
        i -= (int)tx_ring->count;
        #line 858 
        tx_buf = tx_ring->__anonCompField_i40e_ring_221.tx_bi;
        #line 859 
        tx_desc = (struct i40e_tx_desc *)tx_ring->desc;
      }
      #line 862 
      __builtin_prefetch((void const *)((void *)tx_desc));
      #line 865 
      budget --;
    }
    #line 866 
    if (! ((long)(budget != 0U) != 0L)) 
                                        #line 790 
                                        break;
  }
  #line 868 
  i = (int)tx_ring->count + i;
  #line 869 
  tx_ring->next_to_clean = (unsigned short)i;
  #line 870 
  i40e_update_tx_stats(tx_ring,total_packets,total_bytes);
  #line 871 
  i40e_arm_wb(tx_ring,vsi,(int)budget);
  #line 873 
  if ((int)ring_is_xdp(tx_ring) != 0) 
                                      #line 874 
                                      return (_Bool)(budget != 0U);
  #line 877 
  ;
  #line 877 
  ;
  #line 877 
  netdev_tx_completed_queue(txring_txq(tx_ring),total_packets,total_bytes);
  #line 881 
  if ((long)(total_packets != 0U) != 0L) {
    #line 881 
    if ((long)((int)netif_carrier_ok(tx_ring->netdev) != 0) != 0L) 
                                                                   #line 881 
                                                                   tmp_6 = 1; else 
                                                                    #line 881 
                                                                    tmp_6 = 0;
  }
  else 
       #line 881 
       tmp_6 = 0;
  #line 881 
  if (tmp_6 != 0) {
    #line 881 
    int tmp_7;
    #line 881 
    if ((int)tx_ring->next_to_clean <= (int)tx_ring->next_to_use) 
                                                                  #line 881 
                                                                  tmp_7 = (int)tx_ring->count; else 
                                                                    #line 881 
                                                                    tmp_7 = 0;
    #line 881 
    ;
    #line 881 
    if ((long)((tmp_7 + (int)tx_ring->next_to_clean) - (int)tx_ring->next_to_use > 46) != 0L) {
      #line 883 
      ldv_inline_asm();
      #line 887 
      if ((int)__netif_subqueue_stopped(tx_ring->netdev,
                                 (unsigned short)((int)tx_ring->queue_index)) != 0) {
        #line 889 
        if (! test_bit(0L,(unsigned long *)(& vsi->state))) {
          #line 890 
          netif_wake_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
          #line 892 
          (tx_ring->__anonCompField_i40e_ring_222.tx_stats.restart_queue) ++;
        }
      }
    }
  }
  #line 896 
  return (_Bool)(budget != 0U);
}

#line 905  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_enable_wb_on_itr(struct i40e_vsi *vsi, struct i40e_q_vector *q_vector)
{
  #line 909 
  u32 val;
  #line 908 
  u16 flags = (q_vector->tx.ring)->flags;
  #line 911 
  if (((unsigned long)flags & 1UL) == 0UL) 
                                           #line 912 
                                           return;
  #line 914 
  if ((int)q_vector->arm_wb_state != 0) 
                                        #line 915 
                                        return;
  #line 917 
  if (((unsigned long)(vsi->back)->flags & 4UL) != 0UL) {
    #line 918 
    val = 1073741848U;
    #line 921 
    writel(val,(void *)((vsi->back)->hw.hw_addr + (unsigned long)(((int)q_vector->reg_idx + 53760) * 4)));
  }
  else {
    #line 925 
    val = 1073741848U;
    #line 928 
    writel(val,(void *)((vsi->back)->hw.hw_addr + 230528U));
  }
  #line 930 
  q_vector->arm_wb_state = (_Bool)1;
  #line 931 
  return;
}

#line 939  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_force_wb(struct i40e_vsi *vsi, struct i40e_q_vector *q_vector)
{
  #line 941 
  if (((unsigned long)(vsi->back)->flags & 4UL) != 0UL) {
    #line 942 
    u32 val = 16777245U;
    #line 948 
    writel(val,(void *)((vsi->back)->hw.hw_addr + (unsigned long)(((int)q_vector->reg_idx + 53760) * 4)));
  }
  else {
    #line 951 
    u32 val_0 = 16777245U;
    #line 957 
    writel(val_0,(void *)((vsi->back)->hw.hw_addr + 230528U));
  }
  #line 959 
  return;
}

#line 961  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static bool i40e_container_is_rx(struct i40e_q_vector *q_vector, struct i40e_ring_container *rc)
{
  #line 964 
  return (_Bool)(& q_vector->rx == rc);
}

#line 967  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static unsigned int i40e_itr_divisor(struct i40e_q_vector *q_vector)
{
  #line 969 
  unsigned int divisor;
  #line 971 
  switch ((unsigned int)((q_vector->vsi)->back)->hw.phy.link_info.link_speed) {
    #line 972 
    case (unsigned int)16: 
                           #line 972 
    ;
    #line 973 
    divisor = 2048U;
    #line 974 
    break;
    #line 975 
    case (unsigned int)64: 
                           #line 975 
    ;
    #line 976 
    case (unsigned int)32: 
                           #line 976 
    ;
    #line 977 
    divisor = 1024U;
    #line 978 
    break;
    #line 979 
    default: 
             #line 979 
    ;
    #line 980 
    case (unsigned int)8: 
                          #line 980 
    ;
    #line 981 
    divisor = 512U;
    #line 982 
    break;
    #line 983 
    case (unsigned int)4: 
                          #line 983 
    ;
    #line 984 
    case (unsigned int)2: 
                          #line 984 
    ;
    #line 985 
    divisor = 64U;
    #line 986 
    break;
  }
  #line 989 
  return divisor;
}

#line 1005  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_update_itr(struct i40e_q_vector *q_vector, struct i40e_ring_container *rc)
{
  #line 1008 
  unsigned int avg_wire_size;
  #line 1008 
  unsigned int packets;
  #line 1008 
  unsigned int bytes;
  #line 1008 
  unsigned int itr;
  #line 1009 
  unsigned long next_update = jiffies;
  #line 1014 
  if (rc->ring == (struct i40e_ring *)0 || ((int)(rc->ring)->itr_setting & 32768) == 0) 
    #line 1015 
    return;
  #line 1020 
  if ((int)i40e_container_is_rx(q_vector,rc) != 0) 
                                                   #line 1020 
                                                   itr = 32770U; else 
                                                                   #line 1020 
                                                                   itr = 32894U;
  {
    #line 1029 
    unsigned long __dummy;
    #line 1029 
    unsigned long __dummy2;
    }
  #line 1029 
  if (1 != 0) {
    {
      #line 1029 
      unsigned long __dummy_0;
      #line 1029 
      unsigned long __dummy2_0;
      }
    #line 1029 
    if (1 != 0) 
      #line 1029 
      if ((long)(rc->next_update - next_update) < 0L) 
                                                      #line 1030 
                                                      goto clear_counts;
  }
  #line 1038 
  if ((unsigned int)q_vector->itr_countdown != 0U) {
    #line 1039 
    itr = (unsigned int)rc->target_itr;
    #line 1040 
    goto clear_counts;
  }
  #line 1043 
  packets = rc->total_packets;
  #line 1044 
  bytes = rc->total_bytes;
  #line 1046 
  if ((int)i40e_container_is_rx(q_vector,rc) != 0) {
    #line 1052 
    if ((packets + 4294967295U <= 2U && bytes <= 8999U) && ((int)q_vector->tx.target_itr & 32768) != 0) {
      #line 1054 
      itr = 32768U;
      #line 1055 
      goto adjust_by_size;
    }
  }
  else 
    #line 1057 
    if (packets <= 3U) {
      #line 1063 
      if ((unsigned int)rc->target_itr == 126U && ((int)q_vector->rx.target_itr & 8190) == 126) 
        #line 1066 
        goto clear_counts;
    }
    else 
      #line 1067 
      if (packets > 32U) 
                         #line 1071 
                         rc->target_itr = (unsigned short)((unsigned int)rc->target_itr & 32767U);
  #line 1082 
  if (packets <= 55U) {
    #line 1083 
    itr = (unsigned int)((int)rc->target_itr + 2);
    #line 1084 
    if ((itr & 8190U) > 126U) {
      #line 1085 
      itr &= 32768U;
      #line 1086 
      itr += 126U;
    }
    #line 1088 
    goto clear_counts;
  }
  #line 1091 
  if (packets <= 256U) {
    #line 1092 
    u16 __UNIQUE_ID___x576;
    #line 1092 
    int tmp_3;
    {
      #line 1092 
      __UNIQUE_ID___x576 = q_vector->tx.current_itr;
      #line 1092 
      u16 __UNIQUE_ID___y577 = q_vector->rx.current_itr;
      #line 1092 
      if ((int)__UNIQUE_ID___x576 < (int)__UNIQUE_ID___y577) 
                                                             #line 1092 
                                                             tmp_3 = (int)__UNIQUE_ID___x576; else 
                                                                    #line 1092 
                                                                    tmp_3 = (int)__UNIQUE_ID___y577;
      }
    #line 1092 
    itr = (unsigned int)tmp_3;
    #line 1093 
    itr &= 8190U;
    #line 1099 
    if (packets <= 112U) 
                         #line 1100 
                         goto clear_counts;
    #line 1107 
    itr /= 2U;
    #line 1108 
    itr &= 8190U;
    #line 1109 
    if (itr <= 1U) 
                   #line 1110 
                   itr = 2U;
    #line 1112 
    goto clear_counts;
  }
  #line 1121 
  itr = 0U;
  #line 1123 
  adjust_by_size: 
                  #line 1123 
  ;
  #line 1129 
  avg_wire_size = bytes / packets;
  #line 1146 
  if (avg_wire_size <= 60U) 
                            #line 1148 
                            avg_wire_size = 4096U;
  else 
    #line 1149 
    if (avg_wire_size <= 380U) {
      #line 1151 
      avg_wire_size *= 40U;
      #line 1152 
      avg_wire_size += 1696U;
    }
    else 
      #line 1153 
      if (avg_wire_size <= 1084U) {
        #line 1155 
        avg_wire_size *= 15U;
        #line 1156 
        avg_wire_size += 11452U;
      }
      else 
        #line 1157 
        if (avg_wire_size <= 1980U) {
          #line 1159 
          avg_wire_size *= 5U;
          #line 1160 
          avg_wire_size += 22420U;
        }
        else 
             #line 1163 
             avg_wire_size = 32256U;
  #line 1169 
  if ((itr & 32768U) != 0U) 
                            #line 1170 
                            avg_wire_size /= 2U;
  #line 1180 
  itr = (((i40e_itr_divisor(q_vector) + avg_wire_size) + 4294967295U) / i40e_itr_divisor(q_vector)) * 2U + itr;
  #line 1182 
  if ((itr & 8190U) > 126U) {
    #line 1183 
    itr &= 32768U;
    #line 1184 
    itr += 126U;
  }
  #line 1187 
  clear_counts: 
                #line 1187 
  ;
  #line 1189 
  rc->target_itr = (unsigned short)itr;
  #line 1192 
  rc->next_update = next_update + 1UL;
  #line 1194 
  rc->total_bytes = 0U;
  #line 1195 
  rc->total_packets = 0U;
  #line 1196 
  return;
}

#line 1205  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_reuse_rx_page(struct i40e_ring *rx_ring, struct i40e_rx_buffer *old_buff)
{
  #line 1208 
  struct i40e_rx_buffer *new_buff;
  #line 1209 
  u16 nta = rx_ring->next_to_alloc;
  #line 1211 
  new_buff = rx_ring->__anonCompField_i40e_ring_221.rx_bi + (unsigned long)nta;
  #line 1214 
  nta = (u16)((int)nta + 1);
  #line 1215 
  if ((int)rx_ring->count > (int)nta) 
                                      #line 1215 
                                      rx_ring->next_to_alloc = nta; else 
                                                                    #line 1215 
                                                                    rx_ring->next_to_alloc = (unsigned short)0U;
  #line 1218 
  new_buff->dma = old_buff->dma;
  #line 1219 
  new_buff->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page = old_buff->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page;
  #line 1220 
  new_buff->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset = old_buff->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset;
  #line 1221 
  new_buff->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias = old_buff->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias;
  #line 1223 
  (rx_ring->__anonCompField_i40e_ring_222.rx_stats.page_reuse_count) ++;
  #line 1226 
  old_buff->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page = (struct page *)0;
  #line 1227 
  return;
}

#line 1238  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static bool i40e_rx_is_programming_status(u64 qw)
{
  #line 1245 
  return (_Bool)((qw & 9223372036854775808ULL) != 0ULL);
}

#line 1260  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
struct i40e_rx_buffer *i40e_clean_programming_status(struct i40e_ring *rx_ring, union i40e_32byte_rx_desc *rx_desc, u64 qw)
{
  #line 1265 
  struct i40e_rx_buffer *rx_buffer;
  #line 1266 
  u32 ntc;
  #line 1267 
  u8 id;
  #line 1275 
  u32 tmp_0;
  #line 1269 
  if (! i40e_rx_is_programming_status(qw)) 
                                           #line 1270 
                                           return (struct i40e_rx_buffer *)0;
  #line 1272 
  ntc = (unsigned int)rx_ring->next_to_clean;
  #line 1275 
  tmp_0 = ntc;
  #line 1275 
  ntc ++;
  #line 1275 
  rx_buffer = rx_ring->__anonCompField_i40e_ring_221.rx_bi + (unsigned long)tmp_0;
  #line 1276 
  if ((unsigned int)rx_ring->count > ntc) 
                                          #line 1276 
                                          ntc = ntc; else 
                                                          #line 1276 
                                                          ntc = 0U;
  #line 1277 
  rx_ring->next_to_clean = (unsigned short)ntc;
  #line 1279 
  __builtin_prefetch((void const *)((void *)((union i40e_32byte_rx_desc *)rx_ring->desc + (unsigned long)ntc)));
  #line 1281 
  id = (unsigned char)((unsigned int)((unsigned char)(qw >> 2)) & 7U);
  #line 1284 
  if ((unsigned int)id == 1U) 
                              #line 1285 
                              i40e_fd_handle_status(rx_ring,rx_desc,(unsigned char)((int)id));
  #line 1287 
  return rx_buffer;
}

#line 1296  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_setup_tx_descriptors(struct i40e_ring *tx_ring)
{
  #line 1299 
  int bi_size;
  #line 1298 
  struct device *dev = tx_ring->dev;
  #line 1301 
  if (dev == (struct device *)0) 
                                 #line 1302 
                                 return -12;
  {
    #line 1305 
    int __ret_warn_on = tx_ring->__anonCompField_i40e_ring_221.tx_bi != (struct i40e_tx_buffer *)0;
    #line 1305 
    if ((long)(__ret_warn_on != 0) != 0L) {
      #line 1306 
      ldv_inline_asm();
      #line 1307 
      ldv_inline_asm();
    }
    #line 1305 
    long tmp = (long)(__ret_warn_on != 0);
  }
  #line 1306 
  bi_size = (int)((unsigned int)tx_ring->count * 40U);
  #line 1307 
  tx_ring->__anonCompField_i40e_ring_221.tx_bi = (struct i40e_tx_buffer *)kzalloc_0((unsigned long)bi_size,3264U);
  #line 1308 
  if (tx_ring->__anonCompField_i40e_ring_221.tx_bi == (struct i40e_tx_buffer *)0) 
    #line 1309 
    goto err;
  #line 1311 
  u64_stats_init(& tx_ring->syncp);
  #line 1314 
  tx_ring->size = (unsigned int)tx_ring->count * 16U;
  #line 1318 
  tx_ring->size += 4U;
  #line 1319 
  tx_ring->size = (tx_ring->size + 4095U) & 4294963200U;
  #line 1320 
  tx_ring->desc = dma_alloc_coherent(dev,(unsigned long)tx_ring->size,& tx_ring->dma,3264U);
  #line 1322 
  if (tx_ring->desc == (void *)0) {
    #line 1323 
    _dev_info(dev,(char *)"Unable to allocate memory for the Tx descriptor ring, size=%d\n",tx_ring->size);
    #line 1325 
    goto err;
  }
  #line 1328 
  tx_ring->next_to_use = (unsigned short)0U;
  #line 1329 
  tx_ring->next_to_clean = (unsigned short)0U;
  #line 1330 
  tx_ring->__anonCompField_i40e_ring_222.tx_stats.prev_pkt_ctr = -1;
  #line 1331 
  return 0;
  #line 1333 
  err: 
       #line 1333 
  ;
  #line 1334 
  kfree((void *)tx_ring->__anonCompField_i40e_ring_221.tx_bi);
  #line 1335 
  tx_ring->__anonCompField_i40e_ring_221.tx_bi = (struct i40e_tx_buffer *)0;
  #line 1336 
  return -12;
}

#line 1343  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_clean_rx_ring(struct i40e_ring *rx_ring)
{
  #line 1345 
  unsigned long bi_size;
  #line 1346 
  u16 i;
  #line 1349 
  if (rx_ring->__anonCompField_i40e_ring_221.rx_bi == (struct i40e_rx_buffer *)0) 
    #line 1350 
    return;
  #line 1352 
  if (rx_ring->skb != (struct sk_buff *)0) {
    #line 1353 
    consume_skb(rx_ring->skb);
    #line 1354 
    rx_ring->skb = (struct sk_buff *)0;
  }
  #line 1357 
  if (rx_ring->xsk_umem != (struct xdp_umem *)0) {
    #line 1358 
    i40e_xsk_clean_rx_ring(rx_ring);
    #line 1359 
    goto skip_free;
  }
  #line 1363 
  i = (unsigned short)0U;
  #line 1363 
  while ((int)rx_ring->count > (int)i) {
    {
      #line 1364 
      struct i40e_rx_buffer *rx_bi = rx_ring->__anonCompField_i40e_ring_221.rx_bi + (unsigned long)i;
      #line 1366 
      if (rx_bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page == (struct page *)0) 
        #line 1367 
        goto __Cont;
      #line 1372 
      dma_sync_single_range_for_cpu(rx_ring->dev,rx_bi->dma,(unsigned long)rx_bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset,(unsigned long)rx_ring->rx_buf_len,(enum dma_data_direction)DMA_FROM_DEVICE);
      #line 1379 
      ;
      #line 1379 
      ;
      #line 1379 
      dma_unmap_page_attrs(rx_ring->dev,rx_bi->dma,4096UL << i40e_rx_pg_order(rx_ring),(enum dma_data_direction)DMA_FROM_DEVICE,34UL);
      #line 1384 
      __page_frag_cache_drain(rx_bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page,(unsigned int)rx_bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias);
      #line 1386 
      rx_bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page = (struct page *)0;
      #line 1387 
      rx_bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset = 0U;
    }
    #line 1363 
    __Cont: 
            #line 1363 
    i = (u16)((int)i + 1);
  }
  #line 1390 
  skip_free: 
             #line 1390 
  ;
  #line 1391 
  bi_size = (unsigned long)rx_ring->count * 24UL;
  #line 1392 
  memset((void *)rx_ring->__anonCompField_i40e_ring_221.rx_bi,0,bi_size);
  #line 1395 
  memset(rx_ring->desc,0,(unsigned long)rx_ring->size);
  #line 1397 
  rx_ring->next_to_alloc = (unsigned short)0U;
  #line 1398 
  rx_ring->next_to_clean = (unsigned short)0U;
  #line 1399 
  rx_ring->next_to_use = (unsigned short)0U;
  #line 1400 
  return;
}

#line 1408  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_free_rx_resources(struct i40e_ring *rx_ring)
{
  #line 1410 
  i40e_clean_rx_ring(rx_ring);
  #line 1411 
  if ((rx_ring->vsi)->type == (unsigned int)I40E_VSI_MAIN) 
                                                           #line 1412 
                                                           xdp_rxq_info_unreg(& rx_ring->xdp_rxq);
  #line 1413 
  rx_ring->xdp_prog = (struct bpf_prog *)0;
  #line 1414 
  kfree((void *)rx_ring->__anonCompField_i40e_ring_221.rx_bi);
  #line 1415 
  rx_ring->__anonCompField_i40e_ring_221.rx_bi = (struct i40e_rx_buffer *)0;
  #line 1417 
  if (rx_ring->desc != (void *)0) {
    #line 1418 
    dma_free_coherent(rx_ring->dev,(unsigned long)rx_ring->size,rx_ring->desc,rx_ring->dma);
    #line 1420 
    rx_ring->desc = (void *)0;
  }
  #line 1422 
  return;
}

#line 1430  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_setup_rx_descriptors(struct i40e_ring *rx_ring)
{
  #line 1434 
  int bi_size;
  #line 1432 
  struct device *dev = rx_ring->dev;
  #line 1433 
  int err = -12;
  {
    #line 1437 
    int __ret_warn_on = rx_ring->__anonCompField_i40e_ring_221.rx_bi != (struct i40e_rx_buffer *)0;
    #line 1437 
    if ((long)(__ret_warn_on != 0) != 0L) {
      #line 1438 
      ldv_inline_asm();
      #line 1439 
      ldv_inline_asm();
    }
    #line 1437 
    long tmp = (long)(__ret_warn_on != 0);
  }
  #line 1438 
  bi_size = (int)((unsigned int)rx_ring->count * 24U);
  #line 1439 
  rx_ring->__anonCompField_i40e_ring_221.rx_bi = (struct i40e_rx_buffer *)kzalloc_0((unsigned long)bi_size,3264U);
  #line 1440 
  if (rx_ring->__anonCompField_i40e_ring_221.rx_bi == (struct i40e_rx_buffer *)0) 
    #line 1441 
    goto err;
  #line 1443 
  u64_stats_init(& rx_ring->syncp);
  #line 1446 
  rx_ring->size = (unsigned int)rx_ring->count * 32U;
  #line 1447 
  rx_ring->size = (rx_ring->size + 4095U) & 4294963200U;
  #line 1448 
  rx_ring->desc = dma_alloc_coherent(dev,(unsigned long)rx_ring->size,& rx_ring->dma,3264U);
  #line 1451 
  if (rx_ring->desc == (void *)0) {
    #line 1452 
    _dev_info(dev,(char *)"Unable to allocate memory for the Rx descriptor ring, size=%d\n",rx_ring->size);
    #line 1454 
    goto err;
  }
  #line 1457 
  rx_ring->next_to_alloc = (unsigned short)0U;
  #line 1458 
  rx_ring->next_to_clean = (unsigned short)0U;
  #line 1459 
  rx_ring->next_to_use = (unsigned short)0U;
  #line 1462 
  if ((rx_ring->vsi)->type == (unsigned int)I40E_VSI_MAIN) {
    #line 1463 
    err = xdp_rxq_info_reg(& rx_ring->xdp_rxq,rx_ring->netdev,(unsigned int)rx_ring->queue_index);
    #line 1465 
    if (err < 0) 
                 #line 1466 
                 goto err;
  }
  #line 1469 
  rx_ring->xdp_prog = (rx_ring->vsi)->xdp_prog;
  #line 1471 
  return 0;
  #line 1472 
  err: 
       #line 1472 
  ;
  #line 1473 
  kfree((void *)rx_ring->__anonCompField_i40e_ring_221.rx_bi);
  #line 1474 
  rx_ring->__anonCompField_i40e_ring_221.rx_bi = (struct i40e_rx_buffer *)0;
  #line 1475 
  return err;
}

#line 1483  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_release_rx_desc(struct i40e_ring *rx_ring, u32 val)
{
  #line 1485 
  rx_ring->next_to_use = (unsigned short)val;
  #line 1488 
  rx_ring->next_to_alloc = (unsigned short)val;
  #line 1489 
  ldv_inline_asm();
  #line 1496 
  writel(val,(void *)rx_ring->tail);
  #line 1497 
  return;
}

#line 1505  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static unsigned int i40e_rx_offset(struct i40e_ring *rx_ring)
{
  #line 1507 
  unsigned int tmp_1;
  #line 1507 
  if ((int)ring_uses_build_skb(rx_ring) != 0) {
    #line 1507 
    tmp_1 = (unsigned int)i40e_skb_pad();
  }
  else 
       #line 1507 
       tmp_1 = 0U;
  #line 1507 
  return tmp_1;
}

#line 1518  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static bool i40e_alloc_mapped_page(struct i40e_ring *rx_ring, struct i40e_rx_buffer *bi)
{
  #line 1522 
  dma_addr_t dma;
  #line 1521 
  struct page *page = bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page;
  #line 1525 
  if ((long)(page != (struct page *)0) != 0L) {
    #line 1526 
    (rx_ring->__anonCompField_i40e_ring_222.rx_stats.page_reuse_count) ++;
    #line 1527 
    return (_Bool)1;
  }
  #line 1531 
  page = dev_alloc_pages(i40e_rx_pg_order(rx_ring));
  #line 1532 
  if ((long)(page == (struct page *)0) != 0L) {
    #line 1533 
    (rx_ring->__anonCompField_i40e_ring_222.rx_stats.alloc_page_failed) ++;
    #line 1534 
    return (_Bool)0;
  }
  #line 1538 
  ;
  #line 1538 
  ;
  #line 1538 
  dma = dma_map_page_attrs(rx_ring->dev,page,0UL,4096UL << i40e_rx_pg_order(rx_ring),(enum dma_data_direction)DMA_FROM_DEVICE,34UL);
  #line 1546 
  if (dma_mapping_error(rx_ring->dev,dma) != 0) {
    #line 1547 
    ;
    #line 1547 
    __free_pages(page,i40e_rx_pg_order(rx_ring));
    #line 1548 
    (rx_ring->__anonCompField_i40e_ring_222.rx_stats.alloc_page_failed) ++;
    #line 1549 
    return (_Bool)0;
  }
  #line 1552 
  bi->dma = dma;
  #line 1553 
  bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page = page;
  #line 1554 
  bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset = i40e_rx_offset(rx_ring);
  #line 1555 
  page_ref_add(page,65534);
  #line 1556 
  bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias = (unsigned short)65535U;
  #line 1558 
  return (_Bool)1;
}

#line 1568  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
bool i40e_alloc_rx_buffers(struct i40e_ring *rx_ring, u16 cleaned_count)
{
  #line 1571 
  union i40e_32byte_rx_desc *rx_desc;
  #line 1572 
  struct i40e_rx_buffer *bi;
  #line 1570 
  u16 ntu = rx_ring->next_to_use;
  #line 1575 
  if (rx_ring->netdev == (struct net_device *)0 || (unsigned int)cleaned_count == 0U) 
    #line 1576 
    return (_Bool)0;
  #line 1578 
  rx_desc = (union i40e_32byte_rx_desc *)rx_ring->desc + (unsigned long)ntu;
  #line 1579 
  bi = rx_ring->__anonCompField_i40e_ring_221.rx_bi + (unsigned long)ntu;
  #line 1581 
  while (1) {
    {
      #line 1582 
      if (! i40e_alloc_mapped_page(rx_ring,bi)) 
                                                #line 1583 
                                                goto no_buffers;
      #line 1586 
      dma_sync_single_range_for_device(rx_ring->dev,bi->dma,(unsigned long)bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset,(unsigned long)rx_ring->rx_buf_len,(enum dma_data_direction)DMA_FROM_DEVICE);
      #line 1594 
      rx_desc->read.pkt_addr = bi->dma + (unsigned long long)bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset;
      #line 1596 
      rx_desc ++;
      #line 1597 
      bi ++;
      #line 1598 
      ntu = (u16)((int)ntu + 1);
      #line 1599 
      if ((long)((int)rx_ring->count == (int)ntu) != 0L) {
        #line 1600 
        rx_desc = (union i40e_32byte_rx_desc *)rx_ring->desc;
        #line 1601 
        bi = rx_ring->__anonCompField_i40e_ring_221.rx_bi;
        #line 1602 
        ntu = (unsigned short)0U;
      }
      #line 1606 
      rx_desc->wb.qword1.status_error_len = 0ULL;
      #line 1608 
      cleaned_count = (u16)((int)cleaned_count - 1);
    }
    #line 1609 
    if (! ((unsigned int)cleaned_count != 0U)) 
                                               #line 1581 
                                               break;
  }
  #line 1611 
  if ((int)rx_ring->next_to_use != (int)ntu) 
                                             #line 1612 
                                             i40e_release_rx_desc(rx_ring,(unsigned int)ntu);
  #line 1614 
  return (_Bool)0;
  #line 1616 
  no_buffers: 
              #line 1616 
  ;
  #line 1617 
  if ((int)rx_ring->next_to_use != (int)ntu) 
                                             #line 1618 
                                             i40e_release_rx_desc(rx_ring,(unsigned int)ntu);
  #line 1623 
  return (_Bool)1;
}

#line 1632  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static void i40e_rx_checksum(struct i40e_vsi *vsi, struct sk_buff *skb, union i40e_32byte_rx_desc *rx_desc)
{
  #line 1636 
  struct i40e_rx_ptype_decoded decoded;
  #line 1637 
  u32 rx_error;
  #line 1637 
  u32 rx_status;
  #line 1638 
  bool ipv4;
  #line 1638 
  bool ipv6;
  #line 1639 
  u8 ptype;
  #line 1640 
  u64 qword;
  #line 1642 
  qword = rx_desc->wb.qword1.status_error_len;
  #line 1643 
  ptype = (unsigned char)(qword >> 30);
  #line 1644 
  rx_error = (unsigned int)(qword >> 19) & 255U;
  #line 1646 
  rx_status = (unsigned int)qword & 524287U;
  #line 1648 
  decoded = decode_rx_desc_ptype((unsigned char)((int)ptype));
  #line 1650 
  skb->ip_summed = (unsigned char)0U;
  #line 1652 
  skb_checksum_none_assert(skb);
  #line 1655 
  if (((vsi->netdev)->features & 549755813888ULL) == 0ULL) 
                                                           #line 1656 
                                                           return;
  #line 1659 
  if (((unsigned long)rx_status & 8UL) == 0UL) 
                                               #line 1660 
                                               return;
  #line 1663 
  if ((unsigned int)decoded.known == 0U || (unsigned int)decoded.outer_ip == 0U) 
    #line 1664 
    return;
  #line 1666 
  ipv4 = (_Bool)(((unsigned int)decoded.outer_ip == 1U && (unsigned int)decoded.outer_ip_ver == 0U) != 0);
  #line 1668 
  ipv6 = (_Bool)(((unsigned int)decoded.outer_ip == 1U && (unsigned int)decoded.outer_ip_ver == 1U) != 0);
  #line 1671 
  if ((int)ipv4 != 0 && ((unsigned long)rx_error & 40UL) != 0UL) 
                                                                 #line 1674 
                                                                 goto checksum_fail;
  #line 1677 
  if ((int)ipv6 != 0 && ((unsigned long)rx_status & 32768UL) != 0UL) 
    #line 1680 
    return;
  #line 1683 
  if (((unsigned long)rx_error & 16UL) != 0UL) 
                                               #line 1684 
                                               goto checksum_fail;
  #line 1690 
  if (((unsigned long)rx_error & 128UL) != 0UL) 
                                                #line 1691 
                                                return;
  #line 1697 
  if ((unsigned int)decoded.tunnel_type > 1U) 
                                              #line 1698 
                                              skb->csum_level = (unsigned char)1U;
  #line 1701 
  switch ((int)decoded.inner_prot) {
    #line 1702 
    case 2: 
            #line 1702 
    ;
    #line 1703 
    case 1: 
            #line 1703 
    ;
    #line 1704 
    case 3: 
            #line 1704 
    ;
    #line 1705 
    skb->ip_summed = (unsigned char)1U;
    #line 1707 
    default: 
             #line 1707 
    ;
    #line 1708 
    break;
  }
  #line 1711 
  return;
  #line 1713 
  checksum_fail: 
                 #line 1713 
  ;
  #line 1714 
  ((vsi->back)->hw_csum_rx_error) ++;
  #line 1715 
  return;
}

#line 1723  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static int i40e_ptype_to_htype(u8 ptype)
{
  #line 1725 
  struct i40e_rx_ptype_decoded decoded = decode_rx_desc_ptype((unsigned char)((int)ptype));
  #line 1727 
  if ((unsigned int)decoded.known == 0U) 
                                         #line 1728 
                                         return 0;
  #line 1730 
  if ((unsigned int)decoded.outer_ip == 1U && (unsigned int)decoded.payload_layer == 3U) 
    #line 1732 
    return 3;
  else 
    #line 1733 
    if ((unsigned int)decoded.outer_ip == 1U && (unsigned int)decoded.payload_layer == 2U) 
      #line 1735 
      return 2; else 
                     #line 1737 
                     return 1;
}

#line 1747  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static void i40e_rx_hash(struct i40e_ring *ring, union i40e_32byte_rx_desc *rx_desc, struct sk_buff *skb, u8 rx_ptype)
{
  #line 1752 
  u32 hash;
  #line 1753 
  __le64 rss_mask = 12288ULL;
  #line 1757 
  if (((ring->netdev)->features & 274877906944ULL) == 0ULL) 
                                                            #line 1758 
                                                            return;
  #line 1760 
  if ((rx_desc->wb.qword1.status_error_len & 12288ULL) == 12288ULL) {
    #line 1761 
    hash = rx_desc->wb.qword0.hi_dword.rss;
    #line 1762 
    ;
    #line 1762 
    ;
    #line 1762 
    skb_set_hash(skb,hash,(enum pkt_hash_types)i40e_ptype_to_htype((unsigned char)((int)rx_ptype)));
  }
  #line 1764 
  return;
}

#line 1777  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_process_skb_fields(struct i40e_ring *rx_ring, union i40e_32byte_rx_desc *rx_desc, struct sk_buff *skb)
{
  #line 1780 
  u64 qword = rx_desc->wb.qword1.status_error_len;
  #line 1781 
  u32 rx_status = (unsigned int)qword & 524287U;
  #line 1783 
  u32 tsynvalid = rx_status & 128U;
  #line 1784 
  u32 tsyn = (unsigned int)((unsigned long)rx_status >> 5) & 3U;
  #line 1786 
  u8 rx_ptype = (unsigned char)(qword >> 30);
  #line 1789 
  if ((long)(tsynvalid != 0U) != 0L) 
                                     #line 1790 
                                     i40e_ptp_rx_hwtstamp((rx_ring->vsi)->back,skb,(unsigned char)((int)((unsigned char)tsyn)));
  #line 1792 
  i40e_rx_hash(rx_ring,rx_desc,skb,(unsigned char)((int)rx_ptype));
  #line 1794 
  i40e_rx_checksum(rx_ring->vsi,skb,rx_desc);
  #line 1796 
  skb_record_rx_queue(skb,(unsigned short)((int)rx_ring->queue_index));
  #line 1798 
  if ((qword & 4ULL) != 0ULL) {
    #line 1799 
    u16 vlan_tag = rx_desc->wb.qword0.lo_dword.l2tag1;
    #line 1801 
    __vlan_hwaccel_put_tag(skb,(unsigned short)129,(unsigned short)((int)vlan_tag));
  }
  #line 1806 
  skb->protocol = eth_type_trans(skb,rx_ring->netdev);
  #line 1807 
  return;
}

#line 1823  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static bool i40e_cleanup_headers(struct i40e_ring *rx_ring, struct sk_buff *skb, union i40e_32byte_rx_desc *rx_desc)
{
  #line 1828 
  if ((int)IS_ERR_0((void *)skb) != 0) 
                                       #line 1829 
                                       return (_Bool)1;
  #line 1836 
  if ((long)((int)i40e_test_staterr(rx_desc,524288ULL) != 0) != 0L) {
    #line 1838 
    dev_kfree_skb_any(skb);
    #line 1839 
    return (_Bool)1;
  }
  #line 1843 
  if (eth_skb_pad(skb) != 0) 
                             #line 1844 
                             return (_Bool)1;
  #line 1846 
  return (_Bool)0;
}

#line 1856  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static bool i40e_page_is_reusable(struct page *page)
{
  #line 1858 
  int tmp_2;
  #line 1858 
  if (page_to_nid(page) == numa_mem_id()) {
    #line 1859 
    if (page_is_pfmemalloc(page)) 
                                  #line 1858 
                                  tmp_2 = 0; else 
                                                  #line 1858 
                                                  tmp_2 = 1;
  }
  else 
       #line 1858 
       tmp_2 = 0;
  #line 1858 
  return (_Bool)(tmp_2 != 0);
}

#line 1889  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static bool i40e_can_reuse_rx_page(struct i40e_rx_buffer *rx_buffer)
{
  #line 1895 
  int tmp_0;
  #line 1891 
  unsigned int pagecnt_bias = (unsigned int)rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias;
  #line 1892 
  struct page *page = rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page;
  #line 1895 
  if (i40e_page_is_reusable(page)) 
                                   #line 1895 
                                   tmp_0 = 0; else 
                                                   #line 1895 
                                                   tmp_0 = 1;
  #line 1895 
  if ((long)tmp_0 != 0L) 
                         #line 1896 
                         return (_Bool)0;
  #line 1900 
  ;
  #line 1900 
  if ((long)((unsigned int)page_count(page) - pagecnt_bias > 1U) != 0L) 
    #line 1901 
    return (_Bool)0;
  #line 1913 
  if ((long)(pagecnt_bias == 1U) != 0L) {
    #line 1914 
    page_ref_add(page,65534);
    #line 1915 
    rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias = (unsigned short)65535U;
  }
  #line 1918 
  return (_Bool)1;
}

#line 1933  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_add_rx_frag(struct i40e_ring *rx_ring, struct i40e_rx_buffer *rx_buffer, struct sk_buff *skb, unsigned int size)
{
  #line 1939 
  unsigned int truesize = (unsigned int)((4096UL << i40e_rx_pg_order(rx_ring)) / 2UL);
  #line 1944 
  ;
  #line 1944 
  ;
  #line 1944 
  ;
  #line 1944 
  ;
  #line 1944 
  ;
  #line 1944 
  skb_add_rx_frag(skb,(int)((struct skb_shared_info *)skb_end_pointer(skb))->nr_frags,rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page,(int)rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset,(int)size,truesize);
  #line 1949 
  rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset ^= truesize;
  #line 1950 
  return;
}

#line 1963  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static struct i40e_rx_buffer *i40e_get_rx_buffer(struct i40e_ring *rx_ring, unsigned int size)
{
  #line 1966 
  struct i40e_rx_buffer *rx_buffer;
  #line 1968 
  rx_buffer = rx_ring->__anonCompField_i40e_ring_221.rx_bi + (unsigned long)rx_ring->next_to_clean;
  #line 1969 
  prefetchw((void *)rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page);
  #line 1972 
  dma_sync_single_range_for_cpu(rx_ring->dev,rx_buffer->dma,(unsigned long)rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset,(unsigned long)size,(enum dma_data_direction)DMA_FROM_DEVICE);
  #line 1979 
  rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias = (__u16)((int)rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias - 1);
  #line 1981 
  return rx_buffer;
}

#line 1994  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static struct sk_buff *i40e_construct_skb(struct i40e_ring *rx_ring, struct i40e_rx_buffer *rx_buffer, struct xdp_buff *xdp)
{
  #line 2004 
  unsigned int headlen;
  #line 2005 
  struct sk_buff *skb;
  #line 1998 
  unsigned int size = (unsigned int)(xdp->data_end - xdp->data);
  #line 2000 
  unsigned int truesize = (unsigned int)((4096UL << i40e_rx_pg_order(rx_ring)) / 2UL);
  #line 2008 
  __builtin_prefetch((void const *)xdp->data);
  #line 2010 
  __builtin_prefetch((void const *)(xdp->data + 64U));
  #line 2029 
  skb = __napi_alloc_skb(& (rx_ring->q_vector)->napi,256U,10784U);
  #line 2032 
  if ((long)(skb == (struct sk_buff *)0) != 0L) 
                                                #line 2033 
                                                return (struct sk_buff *)0;
  #line 2036 
  headlen = size;
  #line 2037 
  if (headlen > 256U) 
                      #line 2038 
                      headlen = eth_get_headlen(skb->__anonCompField_sk_buff_87.__anonCompField___anonunion_487_86.__anonCompField___anonstruct_488_85.dev,xdp->data,256U);
  #line 2042 
  ;
  #line 2042 
  ;
  #line 2042 
  memcpy(__skb_put(skb,headlen),xdp->data,(unsigned long)(headlen + 7U) & 4294967288UL);
  #line 2046 
  size -= headlen;
  #line 2047 
  if (size != 0U) {
    #line 2048 
    skb_add_rx_frag(skb,0,rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page,(int)(rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset + headlen),(int)size,truesize);
    #line 2054 
    rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset ^= truesize;
  }
  else 
       #line 2060 
       rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias = (__u16)((int)rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias + 1);
  #line 2063 
  return skb;
}

#line 2075  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static struct sk_buff *i40e_build_skb(struct i40e_ring *rx_ring, struct i40e_rx_buffer *rx_buffer, struct xdp_buff *xdp)
{
  #line 2087 
  struct sk_buff *skb;
  #line 2079 
  unsigned int metasize = (unsigned int)(xdp->data - xdp->data_meta);
  #line 2081 
  unsigned int truesize = (unsigned int)((4096UL << i40e_rx_pg_order(rx_ring)) / 2UL);
  #line 2094 
  __builtin_prefetch((void const *)xdp->data_meta);
  #line 2096 
  __builtin_prefetch((void const *)(xdp->data_meta + 64U));
  #line 2099 
  skb = build_skb(xdp->data_hard_start,truesize);
  #line 2100 
  if ((long)(skb == (struct sk_buff *)0) != 0L) 
                                                #line 2101 
                                                return (struct sk_buff *)0;
  #line 2104 
  skb_reserve(skb,(int)(xdp->data - xdp->data_hard_start));
  #line 2105 
  __skb_put(skb,(unsigned int)(xdp->data_end - xdp->data));
  #line 2106 
  if (metasize != 0U) 
                      #line 2107 
                      skb_metadata_set(skb,(unsigned char)((int)((unsigned char)metasize)));
  #line 2111 
  rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset ^= truesize;
  #line 2116 
  return skb;
}

#line 2127  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_put_rx_buffer(struct i40e_ring *rx_ring, struct i40e_rx_buffer *rx_buffer)
{
  #line 2130 
  if ((int)i40e_can_reuse_rx_page(rx_buffer) != 0) 
                                                   #line 2132 
                                                   i40e_reuse_rx_page(rx_ring,rx_buffer);
  else {
    #line 2135 
    ;
    #line 2135 
    ;
    #line 2135 
    dma_unmap_page_attrs(rx_ring->dev,rx_buffer->dma,4096UL << i40e_rx_pg_order(rx_ring),(enum dma_data_direction)DMA_FROM_DEVICE,34UL);
    #line 2138 
    __page_frag_cache_drain(rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page,(unsigned int)rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias);
    #line 2141 
    rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page = (struct page *)0;
  }
  #line 2143 
  return;
}

#line 2156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static bool i40e_is_non_eop(struct i40e_ring *rx_ring, union i40e_32byte_rx_desc *rx_desc, struct sk_buff *skb)
{
  #line 2160 
  u32 ntc = (unsigned int)((int)rx_ring->next_to_clean + 1);
  #line 2163 
  if ((unsigned int)rx_ring->count > ntc) 
                                          #line 2163 
                                          ntc = ntc; else 
                                                          #line 2163 
                                                          ntc = 0U;
  #line 2164 
  rx_ring->next_to_clean = (unsigned short)ntc;
  #line 2166 
  __builtin_prefetch((void const *)((void *)((union i40e_32byte_rx_desc *)rx_ring->desc + (unsigned long)ntc)));
  #line 2170 
  if ((long)((int)i40e_test_staterr(rx_desc,2ULL) != 0) != 0L) 
                                                               #line 2171 
                                                               return (_Bool)0;
  #line 2173 
  (rx_ring->__anonCompField_i40e_ring_222.rx_stats.non_eop_descs) ++;
  #line 2175 
  return (_Bool)1;
}

#line 2178 
#line 3509 
static int i40e_xmit_xdp_ring(struct xdp_frame *xdpf, struct i40e_ring *xdp_ring);
#line 2181  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_xmit_xdp_tx_ring(struct xdp_buff *xdp, struct i40e_ring *xdp_ring)
{
  #line 2183 
  struct xdp_frame *xdpf = convert_to_xdp_frame(xdp);
  #line 2185 
  if ((long)(xdpf == (struct xdp_frame *)0) != 0L) 
                                                   #line 2186 
                                                   return 1;
  #line 2188 
  return i40e_xmit_xdp_ring(xdpf,xdp_ring);
}

#line 2196  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static struct sk_buff *i40e_run_xdp(struct i40e_ring *rx_ring, struct xdp_buff *xdp)
{
  #line 2206 
  union __anonunion___u_7775 __u;
  #line 2199 
  int err;
  #line 2200 
  struct i40e_ring *xdp_ring;
  #line 2201 
  struct bpf_prog *xdp_prog;
  #line 2202 
  u32 act;
  #line 2199 
  int result = 0;
  #line 2204 
  rcu_read_lock();
  #line 2205 
  __read_once_size((void *)(& rx_ring->xdp_prog),(void *)(& __u.__c),8);
  #line 2205 
  xdp_prog = (__u.__val);
  #line 2207 
  if (xdp_prog == (struct bpf_prog *)0) 
                                        #line 2208 
                                        goto xdp_out;
  #line 2210 
  prefetchw(xdp->data_hard_start);
  #line 2212 
  act = bpf_prog_run_xdp(xdp_prog,xdp);
  #line 2213 
  switch (act) {
    #line 2214 
    case (u32)2: 
                 #line 2214 
    ;
    #line 2215 
    break;
    #line 2216 
    case (u32)3: 
                 #line 2216 
    ;
    #line 2217 
    xdp_ring = *((rx_ring->vsi)->xdp_rings + (unsigned long)rx_ring->queue_index);
    #line 2218 
    result = i40e_xmit_xdp_tx_ring(xdp,xdp_ring);
    #line 2219 
    break;
    #line 2220 
    case (u32)4: 
                 #line 2220 
    ;
    #line 2221 
    err = xdp_do_redirect(rx_ring->netdev,xdp,xdp_prog);
    #line 2222 
    if (err == 0) 
                  #line 2222 
                  result = 4; else 
                                   #line 2222 
                                   result = 1;
    #line 2223 
    break;
    #line 2224 
    default: 
             #line 2224 
    ;
    #line 2225 
    bpf_warn_invalid_xdp_action(act);
    #line 2227 
    case (u32)0: 
                 #line 2227 
    ;
    #line 2228 
    trace_xdp_exception(rx_ring->netdev,xdp_prog,act);
    #line 2230 
    case (u32)1: 
                 #line 2230 
    ;
    #line 2231 
    result = 1;
    #line 2232 
    break;
  }
  #line 2234 
  xdp_out: 
           #line 2234 
  ;
  #line 2235 
  rcu_read_unlock();
  #line 2236 
  return (struct sk_buff *)ERR_PTR((long)(- result));
}

#line 2245  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_rx_buffer_flip(struct i40e_ring *rx_ring, struct i40e_rx_buffer *rx_buffer, unsigned int size)
{
  #line 2250 
  unsigned int truesize = (unsigned int)((4096UL << i40e_rx_pg_order(rx_ring)) / 2UL);
  #line 2252 
  rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset ^= truesize;
  #line 2253 
  return;
}

#line 2266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_xdp_ring_update_tail(struct i40e_ring *xdp_ring)
{
  #line 2268 
  ldv_inline_asm();
  #line 2272 
  writel((unsigned int)xdp_ring->next_to_use,(void *)xdp_ring->tail);
  #line 2273 
  return;
}

#line 2283  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_update_rx_stats(struct i40e_ring *rx_ring, unsigned int total_rx_bytes, unsigned int total_rx_packets)
{
  #line 2287 
  u64_stats_init(& rx_ring->syncp);
  #line 2288 
  rx_ring->stats.packets += (unsigned long long)total_rx_packets;
  #line 2289 
  rx_ring->stats.bytes += (unsigned long long)total_rx_bytes;
  #line 2290 
  u64_stats_init(& rx_ring->syncp);
  #line 2291 
  (rx_ring->q_vector)->rx.total_packets += total_rx_packets;
  #line 2292 
  (rx_ring->q_vector)->rx.total_bytes += total_rx_bytes;
  #line 2293 
  return;
}

#line 2304  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
void i40e_finalize_xdp_rx(struct i40e_ring *rx_ring, unsigned int xdp_res)
{
  #line 2306 
  if (((unsigned long)xdp_res & 4UL) != 0UL) 
                                             #line 2307 
                                             xdp_do_flush_map();
  #line 2309 
  if (((unsigned long)xdp_res & 2UL) != 0UL) {
    #line 2310 
    struct i40e_ring *xdp_ring = *((rx_ring->vsi)->xdp_rings + (unsigned long)rx_ring->queue_index);
    #line 2313 
    i40e_xdp_ring_update_tail(xdp_ring);
  }
  #line 2315 
  return;
}

#line 2329  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_clean_rx_irq(struct i40e_ring *rx_ring, int budget)
{
  #line 2333 
  unsigned int tmp;
  #line 2336 
  struct xdp_buff xdp;
  #line 2453 
  int tmp_9;
  #line 2331 
  unsigned int total_rx_bytes = 0U;
  #line 2331 
  unsigned int total_rx_packets = 0U;
  #line 2332 
  struct sk_buff *skb = rx_ring->skb;
  #line 2333 
  if ((int)rx_ring->next_to_clean <= (int)rx_ring->next_to_use) 
                                                                #line 2333 
                                                                tmp = (unsigned int)rx_ring->count; else 
                                                                    #line 2333 
                                                                    tmp = 0U;
  #line 2333 
  u16 cleaned_count = (unsigned short)(((tmp + (unsigned int)rx_ring->next_to_clean) - (unsigned int)rx_ring->next_to_use) + 65535U);
  #line 2334 
  unsigned int xdp_xmit = 0U;
  #line 2335 
  bool failure = (_Bool)0;
  #line 2338 
  xdp.rxq = & rx_ring->xdp_rxq;
  #line 2340 
  while ((long)(total_rx_packets < (unsigned int)budget) != 0L) {
    #line 2341 
    struct i40e_rx_buffer *rx_buffer;
    #line 2342 
    union i40e_32byte_rx_desc *rx_desc;
    #line 2343 
    unsigned int size;
    #line 2344 
    u64 qword;
    #line 2347 
    if ((unsigned int)cleaned_count > 31U) {
      #line 2348 
      int tmp_1;
      #line 2348 
      if ((int)failure != 0) 
                             #line 2348 
                             tmp_1 = 1;
      else {
        #line 2348 
        if ((int)i40e_alloc_rx_buffers(rx_ring,(unsigned short)((int)cleaned_count)) != 0) 
          #line 2348 
          tmp_1 = 1; else 
                          #line 2348 
                          tmp_1 = 0;
      }
      #line 2348 
      failure = (_Bool)(tmp_1 != 0);
      #line 2350 
      cleaned_count = (unsigned short)0U;
    }
    #line 2353 
    rx_desc = (union i40e_32byte_rx_desc *)rx_ring->desc + (unsigned long)rx_ring->next_to_clean;
    #line 2360 
    qword = rx_desc->wb.qword1.status_error_len;
    #line 2361 
    ldv_inline_asm();
    #line 2368 
    rx_buffer = i40e_clean_programming_status(rx_ring,rx_desc,qword);
    #line 2370 
    if ((long)(rx_buffer != (struct i40e_rx_buffer *)0) != 0L) {
      #line 2371 
      i40e_reuse_rx_page(rx_ring,rx_buffer);
      #line 2372 
      cleaned_count = (u16)((int)cleaned_count + 1);
      #line 2373 
      continue;
    }
    #line 2376 
    size = (unsigned int)(qword >> 38) & 16383U;
    #line 2378 
    if (size == 0U) 
                    #line 2379 
                    break;
    #line 2381 
    trace_i40e_clean_rx_irq(rx_ring,rx_desc,skb);
    #line 2382 
    rx_buffer = i40e_get_rx_buffer(rx_ring,size);
    #line 2385 
    if (skb == (struct sk_buff *)0) {
      #line 2386 
      xdp.data = lowmem_page_address(rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page) + (unsigned long)rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.page_offset;
      #line 2388 
      xdp.data_meta = xdp.data;
      #line 2389 
      xdp.data_hard_start = xdp.data + - i40e_rx_offset(rx_ring);
      #line 2391 
      xdp.data_end = xdp.data + (unsigned long)size;
      #line 2393 
      skb = i40e_run_xdp(rx_ring,& xdp);
    }
    #line 2396 
    if ((int)IS_ERR_0((void *)skb) != 0) {
      #line 2397 
      unsigned int xdp_res = - ((unsigned int)PTR_ERR_0((void *)skb));
      #line 2399 
      if (((unsigned long)xdp_res & 6UL) != 0UL) {
        #line 2400 
        xdp_xmit |= xdp_res;
        #line 2401 
        i40e_rx_buffer_flip(rx_ring,rx_buffer,size);
      }
      else 
           #line 2403 
           rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias = (__u16)((int)rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias + 1);
      #line 2405 
      total_rx_bytes += size;
      #line 2406 
      total_rx_packets ++;
    }
    else 
      #line 2407 
      if (skb != (struct sk_buff *)0) 
                                      #line 2408 
                                      i40e_add_rx_frag(rx_ring,rx_buffer,skb,size);
      else {
        #line 2409 
        if ((int)ring_uses_build_skb(rx_ring) != 0) 
                                                    #line 2410 
                                                    skb = i40e_build_skb(rx_ring,rx_buffer,& xdp); else 
                                                                    #line 2412 
                                                                    skb = i40e_construct_skb(rx_ring,rx_buffer,& xdp);
      }
    #line 2416 
    if (skb == (struct sk_buff *)0) {
      #line 2417 
      (rx_ring->__anonCompField_i40e_ring_222.rx_stats.alloc_buff_failed) ++;
      #line 2418 
      rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias = (__u16)((int)rx_buffer->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_218.pagecnt_bias + 1);
      #line 2419 
      break;
    }
    #line 2422 
    i40e_put_rx_buffer(rx_ring,rx_buffer);
    #line 2423 
    cleaned_count = (u16)((int)cleaned_count + 1);
    #line 2425 
    if ((int)i40e_is_non_eop(rx_ring,rx_desc,skb) != 0) 
                                                        #line 2426 
                                                        continue;
    #line 2428 
    if ((int)i40e_cleanup_headers(rx_ring,skb,rx_desc) != 0) {
      #line 2429 
      skb = (struct sk_buff *)0;
      #line 2430 
      continue;
    }
    #line 2434 
    total_rx_bytes = skb->len + total_rx_bytes;
    #line 2437 
    i40e_process_skb_fields(rx_ring,rx_desc,skb);
    #line 2439 
    trace_i40e_clean_rx_irq_rx(rx_ring,rx_desc,skb);
    #line 2440 
    napi_gro_receive(& (rx_ring->q_vector)->napi,skb);
    #line 2441 
    skb = (struct sk_buff *)0;
    #line 2444 
    total_rx_packets ++;
  }
  #line 2447 
  i40e_finalize_xdp_rx(rx_ring,xdp_xmit);
  #line 2448 
  rx_ring->skb = skb;
  #line 2450 
  i40e_update_rx_stats(rx_ring,total_rx_bytes,total_rx_packets);
  #line 2453 
  if ((int)failure != 0) 
                         #line 2453 
                         tmp_9 = budget; else 
                                              #line 2453 
                                              tmp_9 = (int)total_rx_packets;
  #line 2453 
  return tmp_9;
}

#line 2456  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static u32 i40e_buildreg_itr(int type, u16 itr)
{
  #line 2458 
  u32 val;
  #line 2475 
  itr = (unsigned short)((unsigned int)itr & 8190U);
  #line 2477 
  val = ((unsigned int)(type << 3) | (unsigned int)((int)itr << 4)) | 1U;
  #line 2481 
  return val;
}

#line 2502  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static void i40e_update_enable_itr(struct i40e_vsi *vsi, struct i40e_q_vector *q_vector)
{
  #line 2506 
  u32 intval;
  #line 2505 
  struct i40e_hw *hw = & (vsi->back)->hw;
  #line 2509 
  if (((unsigned long)(vsi->back)->flags & 4UL) == 0UL) {
    #line 2510 
    i40e_irq_dynamic_enable_icr0(vsi->back);
    #line 2511 
    return;
  }
  #line 2515 
  i40e_update_itr(q_vector,& q_vector->tx);
  #line 2516 
  i40e_update_itr(q_vector,& q_vector->rx);
  #line 2526 
  if ((int)q_vector->rx.target_itr < (int)q_vector->rx.current_itr) {
    #line 2528 
    intval = i40e_buildreg_itr(0,(unsigned short)((int)q_vector->rx.target_itr));
    #line 2530 
    q_vector->rx.current_itr = q_vector->rx.target_itr;
    #line 2531 
    q_vector->itr_countdown = (unsigned char)3U;
  }
  else 
    #line 2532 
    if ((int)q_vector->tx.target_itr < (int)q_vector->tx.current_itr || (int)q_vector->rx.target_itr - (int)q_vector->rx.current_itr < (int)q_vector->tx.target_itr - (int)q_vector->tx.current_itr) {
      #line 2538 
      intval = i40e_buildreg_itr(1,(unsigned short)((int)q_vector->tx.target_itr));
      #line 2540 
      q_vector->tx.current_itr = q_vector->tx.target_itr;
      #line 2541 
      q_vector->itr_countdown = (unsigned char)3U;
    }
    else 
      #line 2542 
      if ((int)q_vector->rx.current_itr != (int)q_vector->rx.target_itr) {
        #line 2544 
        intval = i40e_buildreg_itr(0,(unsigned short)((int)q_vector->rx.target_itr));
        #line 2546 
        q_vector->rx.current_itr = q_vector->rx.target_itr;
        #line 2547 
        q_vector->itr_countdown = (unsigned char)3U;
      }
      else {
        #line 2550 
        intval = i40e_buildreg_itr(3,(unsigned short)0);
        #line 2551 
        if ((unsigned int)q_vector->itr_countdown != 0U) 
                                                         #line 2552 
                                                         q_vector->itr_countdown = (u8)((int)q_vector->itr_countdown - 1);
      }
  #line 2555 
  if (! test_bit(0L,(unsigned long *)(& vsi->state))) 
                                                      #line 2556 
                                                      writel(intval,(void *)(hw->hw_addr + (unsigned long)(((int)q_vector->reg_idx + 53760) * 4)));
  #line 2557 
  return;
}

#line 2568  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_napi_poll(struct napi_struct *napi, int budget)
{
  #line 2658 
  int __UNIQUE_ID___x582;
  #line 2658 
  int tmp_17;
  #line 2607 
  int __UNIQUE_ID___x580;
  #line 2571 
  void *__mptr;
  #line 2607 
  int tmp_4;
  #line 2573 
  struct i40e_ring *ring;
  #line 2576 
  int budget_per_ring;
  #line 2571 
  __mptr = (void *)napi;
  #line 2570 
  struct i40e_q_vector *q_vector = ((struct i40e_q_vector *)(__mptr + 18446744073709551600U));
  #line 2572 
  struct i40e_vsi *vsi = q_vector->vsi;
  #line 2574 
  bool clean_complete = (_Bool)1;
  #line 2575 
  bool arm_wb = (_Bool)0;
  #line 2577 
  int work_done = 0;
  #line 2579 
  if ((int)test_bit(0L,(unsigned long *)(& vsi->state)) != 0) {
    #line 2580 
    napi_complete(napi);
    #line 2581 
    return 0;
  }
  #line 2587 
  ring = q_vector->tx.ring;
  #line 2587 
  while (ring != (struct i40e_ring *)0) {
    {
      #line 2588 
      int tmp_3;
      #line 2588 
      if (ring->xsk_umem != (struct xdp_umem *)0) {
        #line 2588 
        tmp_3 = (int)i40e_clean_xdp_tx_irq(vsi,ring,budget) != 0;
      }
      else {
        #line 2588 
        tmp_3 = (int)i40e_clean_tx_irq(vsi,ring,budget) != 0;
      }
      #line 2588 
      bool wd = (_Bool)(tmp_3 != 0);
      #line 2592 
      if (! wd) {
        #line 2593 
        clean_complete = (_Bool)0;
        #line 2594 
        goto __Cont;
      }
      #line 2596 
      arm_wb = (_Bool)(((int)ring->arm_wb | (int)arm_wb) != 0);
      #line 2597 
      ring->arm_wb = (_Bool)0;
    }
    #line 2587 
    __Cont: 
            #line 2587 
    ring = ring->next;
  }
  #line 2601 
  if (budget <= 0) 
                   #line 2602 
                   goto tx_only;
  {
    #line 2607 
    __UNIQUE_ID___x580 = budget / (int)q_vector->num_ringpairs;
    #line 2607 
    int __UNIQUE_ID___y581 = 1;
    #line 2607 
    if (__UNIQUE_ID___x580 > __UNIQUE_ID___y581) 
                                                 #line 2607 
                                                 tmp_4 = __UNIQUE_ID___x580; else 
                                                                    #line 2607 
                                                                    tmp_4 = __UNIQUE_ID___y581;
    }
  #line 2607 
  budget_per_ring = tmp_4;
  #line 2609 
  ring = q_vector->rx.ring;
  #line 2609 
  while (ring != (struct i40e_ring *)0) {
    {
      #line 2610 
      int tmp_8;
      #line 2610 
      if (ring->xsk_umem != (struct xdp_umem *)0) 
                                                  #line 2610 
                                                  tmp_8 = i40e_clean_rx_irq_zc(ring,budget_per_ring); else 
                                                                    #line 2611 
                                                                    tmp_8 = i40e_clean_rx_irq(ring,budget_per_ring);
      #line 2610 
      int cleaned = tmp_8;
      #line 2614 
      work_done += cleaned;
      #line 2616 
      if (cleaned >= budget_per_ring) 
                                      #line 2617 
                                      clean_complete = (_Bool)0;
    }
    #line 2609 
    ring = ring->next;
  }
  #line 2621 
  if (! clean_complete) {
    #line 2622 
    int pscr_ret__;
    #line 2622 
    __this_cpu_preempt_check((char *)"read");
    {
      #line 2622 
      void *__vpp_verify = (void *)0;
      #line 2622 
      void *tmp_9 = __vpp_verify;
    }
    #line 2622 
    switch (4UL) {
      #line 2622 
      int pfo_ret___2;
      #line 2622 
      int pfo_ret__;
      #line 2622 
      int pfo_ret___0;
      #line 2622 
      int pfo_ret___1;
      #line 2622 
      case (unsigned long)1: 
                             #line 2622 
      ;
      #line 2622 
      switch (4UL) {
        #line 2622 
        case (unsigned long)1: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        case (unsigned long)2: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        case (unsigned long)4: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        case (unsigned long)8: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        default: 
                 #line 2622 
        ;
        #line 2622 
        __bad_percpu_size();
      }
      #line 2622 
      pscr_ret__ = pfo_ret__;
      #line 2622 
      break;
      #line 2622 
      case (unsigned long)2: 
                             #line 2622 
      ;
      #line 2622 
      switch (4UL) {
        #line 2622 
        case (unsigned long)1: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        case (unsigned long)2: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        case (unsigned long)4: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        case (unsigned long)8: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        default: 
                 #line 2622 
        ;
        #line 2622 
        __bad_percpu_size();
      }
      #line 2622 
      pscr_ret__ = pfo_ret___0;
      #line 2622 
      break;
      #line 2622 
      case (unsigned long)4: 
                             #line 2622 
      ;
      #line 2622 
      switch (4UL) {
        #line 2622 
        case (unsigned long)1: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        case (unsigned long)2: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        case (unsigned long)4: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        case (unsigned long)8: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        default: 
                 #line 2622 
        ;
        #line 2622 
        __bad_percpu_size();
      }
      #line 2622 
      pscr_ret__ = pfo_ret___1;
      #line 2622 
      break;
      #line 2622 
      case (unsigned long)8: 
                             #line 2622 
      ;
      #line 2622 
      switch (4UL) {
        #line 2622 
        case (unsigned long)1: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        case (unsigned long)2: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        case (unsigned long)4: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        case (unsigned long)8: 
                               #line 2622 
        ;
        #line 2623 
        ldv_inline_asm();
        #line 2622 
        break;
        #line 2622 
        default: 
                 #line 2622 
        ;
        #line 2622 
        __bad_percpu_size();
      }
      #line 2622 
      pscr_ret__ = pfo_ret___2;
      #line 2622 
      break;
      #line 2622 
      default: 
               #line 2622 
      ;
      #line 2622 
      __bad_size_call_parameter();
      #line 2622 
      break;
    }
    #line 2622 
    int cpu_id = pscr_ret__;
    #line 2631 
    if (cpumask_test_cpu(cpu_id,& q_vector->affinity_mask) == 0) {
      #line 2633 
      napi_complete_done(napi,work_done);
      #line 2636 
      i40e_force_wb(vsi,q_vector);
      #line 2639 
      return budget + -1;
    }
    #line 2641 
    tx_only: 
             #line 2641 
    ;
    #line 2642 
    if ((int)arm_wb != 0) {
      #line 2643 
      ((q_vector->tx.ring)->__anonCompField_i40e_ring_222.tx_stats.tx_force_wb) ++;
      #line 2644 
      i40e_enable_wb_on_itr(vsi,q_vector);
    }
    #line 2646 
    return budget;
  }
  #line 2649 
  if (((unsigned long)(vsi->back)->flags & 1UL) != 0UL) 
                                                        #line 2650 
                                                        q_vector->arm_wb_state = (_Bool)0;
  #line 2655 
  if ((long)((int)napi_complete_done(napi,work_done) != 0) != 0L) 
                                                                  #line 2656 
                                                                  i40e_update_enable_itr(vsi,q_vector);
  {
    #line 2658 
    __UNIQUE_ID___x582 = work_done;
    #line 2658 
    int __UNIQUE_ID___y583 = budget + -1;
    #line 2658 
    if (__UNIQUE_ID___x582 < __UNIQUE_ID___y583) 
                                                 #line 2658 
                                                 tmp_17 = __UNIQUE_ID___x582; else 
                                                                    #line 2658 
                                                                    tmp_17 = __UNIQUE_ID___y583;
    }
  #line 2658 
  return tmp_17;
}

#line 2667  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_atr(struct i40e_ring *tx_ring, struct sk_buff *skb, u32 tx_flags)
{
  #line 2670 
  struct i40e_filter_program_desc *fdir_desc;
  #line 2676 
  union __anonunion_hdr_7777 hdr;
  #line 2677 
  struct tcphdr *th;
  #line 2678 
  unsigned int hlen;
  #line 2679 
  u32 flex_ptype;
  #line 2679 
  u32 dtype_cmd;
  #line 2680 
  int l4_proto;
  #line 2681 
  u16 i;
  #line 2757 
  unsigned int tmp_3;
  #line 2767 
  unsigned int tmp_4;
  #line 2671 
  struct i40e_pf *pf = (tx_ring->vsi)->back;
  #line 2684 
  if (((unsigned long)pf->flags & 512UL) == 0UL) 
                                                 #line 2685 
                                                 return;
  #line 2687 
  if ((int)test_bit(22L,(unsigned long *)(& pf->state)) != 0) 
                                                              #line 2688 
                                                              return;
  #line 2691 
  if ((unsigned int)tx_ring->atr_sample_rate == 0U) 
                                                    #line 2692 
                                                    return;
  #line 2695 
  if (((unsigned long)tx_flags & 48UL) == 0UL) 
                                               #line 2696 
                                               return;
  #line 2699 
  if (((unsigned long)tx_flags & 1024UL) != 0UL) 
                                                 #line 2699 
                                                 hdr.network = skb_inner_network_header(skb); else 
                                                                    #line 2700 
                                                                    hdr.network = skb_network_header(skb);
  #line 2705 
  if (((unsigned long)tx_flags & 16UL) != 0UL) {
    #line 2707 
    hlen = (unsigned int)((int)*(hdr.network) << 2) & 60U;
    #line 2708 
    l4_proto = (int)(hdr.ipv4)->protocol;
  }
  else {
    #line 2711 
    unsigned int inner_hlen = (unsigned int)(hdr.network - skb->data);
    #line 2712 
    unsigned int h_offset = inner_hlen;
    #line 2715 
    l4_proto = ipv6_find_hdr(skb,& h_offset,6,(unsigned short *)0U,(int *)0);
    #line 2718 
    hlen = h_offset - inner_hlen;
  }
  #line 2721 
  if (l4_proto != 6) 
                     #line 2722 
                     return;
  #line 2724 
  th = (struct tcphdr *)(hdr.network + (unsigned long)hlen);
  #line 2727 
  if ((unsigned int)th->syn != 0U) {
    #line 2727 
    if ((int)test_bit(22L,(unsigned long *)(& pf->state)) != 0) 
                                                                #line 2728 
                                                                return;
  }
  #line 2729 
  if (((unsigned long)pf->flags & 2048UL) != 0UL) 
    #line 2733 
    if ((unsigned int)th->fin != 0U || (unsigned int)th->rst != 0U) 
                                                                    #line 2734 
                                                                    return;
  #line 2737 
  tx_ring->atr_count = (u8)((int)tx_ring->atr_count + 1);
  #line 2740 
  if ((((unsigned int)th->fin == 0U && (unsigned int)th->syn == 0U) && (unsigned int)th->rst == 0U) && (int)tx_ring->atr_count < (int)tx_ring->atr_sample_rate) 
    #line 2744 
    return;
  #line 2746 
  tx_ring->atr_count = (unsigned char)0U;
  #line 2749 
  i = tx_ring->next_to_use;
  #line 2750 
  fdir_desc = (struct i40e_filter_program_desc *)tx_ring->desc + (unsigned long)i;
  #line 2752 
  i = (u16)((int)i + 1);
  #line 2753 
  if ((int)tx_ring->count > (int)i) 
                                    #line 2753 
                                    tx_ring->next_to_use = i; else 
                                                                   #line 2753 
                                                                   tx_ring->next_to_use = (unsigned short)0U;
  #line 2755 
  flex_ptype = (unsigned int)tx_ring->queue_index & 2047U;
  #line 2757 
  if (((unsigned long)tx_flags & 16UL) != 0UL) 
                                               #line 2757 
                                               tmp_3 = 4325376U; else 
                                                                   #line 2757 
                                                                   tmp_3 = 5636096U;
  #line 2757 
  flex_ptype = tmp_3 | flex_ptype;
  #line 2763 
  flex_ptype = (unsigned int)((int)(tx_ring->vsi)->id << 23) | flex_ptype;
  #line 2765 
  dtype_cmd = 8U;
  #line 2767 
  if ((unsigned int)th->fin != 0U || (unsigned int)th->rst != 0U) 
                                                                  #line 2767 
                                                                  tmp_4 = 32U; else 
                                                                    #line 2767 
                                                                    tmp_4 = 16U;
  #line 2767 
  dtype_cmd = tmp_4 | dtype_cmd;
  #line 2773 
  dtype_cmd |= 128U;
  #line 2776 
  dtype_cmd |= 8192U;
  #line 2779 
  dtype_cmd |= 2048U;
  #line 2780 
  if (((unsigned long)tx_flags & 1024UL) == 0UL) 
                                                 #line 2781 
                                                 dtype_cmd = (((unsigned int)((int)pf->hw.pf_id * 3) << 20) & 535822336U) | dtype_cmd; else 
                                                                    #line 2786 
                                                                    dtype_cmd = (((unsigned int)((int)pf->hw.pf_id * 3 + 2) << 20) & 535822336U) | dtype_cmd;
  #line 2791 
  if (((unsigned long)pf->flags & 2048UL) != 0UL) 
                                                  #line 2792 
                                                  dtype_cmd |= 262144U;
  #line 2794 
  fdir_desc->qindex_flex_ptype_vsi = flex_ptype;
  #line 2795 
  fdir_desc->rsvd = 0U;
  #line 2796 
  fdir_desc->dtype_cmd_cntindex = dtype_cmd;
  #line 2797 
  fdir_desc->fd_id = 0U;
  #line 2798 
  return;
}

#line 2812  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static int i40e_tx_prepare_vlan_flags(struct sk_buff *skb, struct i40e_ring *tx_ring, u32 *flags)
{
  #line 2816 
  __be16 protocol = skb->protocol;
  #line 2817 
  u32 tx_flags = 0U;
  #line 2819 
  if ((unsigned int)protocol == 129U && ((tx_ring->netdev)->features & 128ULL) == 0ULL) {
    #line 2828 
    skb->protocol = vlan_get_protocol(skb);
    #line 2829 
    goto out;
  }
  #line 2833 
  if ((unsigned int)skb->vlan_present != 0U) {
    #line 2834 
    tx_flags = (unsigned int)((int)skb->vlan_tci << 16) | tx_flags;
    #line 2835 
    tx_flags |= 2U;
  }
  else 
    #line 2837 
    if ((unsigned int)protocol == 129U) {
      #line 2838 
      struct vlan_hdr *vhdr;
      #line 2838 
      struct vlan_hdr _vhdr;
      #line 2840 
      vhdr = (struct vlan_hdr *)skb_header_pointer(skb,14,4,(void *)(& _vhdr));
      #line 2841 
      if (vhdr == (struct vlan_hdr *)0) 
                                        #line 2842 
                                        return -22;
      #line 2844 
      protocol = vhdr->h_vlan_encapsulated_proto;
      #line 2845 
      tx_flags = (unsigned int)((int)__builtin_bswap16((unsigned short)((int)vhdr->h_vlan_TCI)) << 16) | tx_flags;
      #line 2846 
      tx_flags |= 4U;
    }
  #line 2849 
  if (((unsigned long)((tx_ring->vsi)->back)->flags & 128UL) == 0UL) 
    #line 2850 
    goto out;
  #line 2853 
  if (((unsigned long)tx_flags & 6UL) != 0UL || skb->priority != 7U) {
    #line 2855 
    tx_flags &= 536870911U;
    #line 2856 
    tx_flags = (skb->priority << 29) | tx_flags;
    #line 2858 
    if (((unsigned long)tx_flags & 4UL) != 0UL) {
      #line 2859 
      struct vlan_ethhdr *vhdr_0;
      #line 2860 
      int rc;
      #line 2862 
      rc = skb_cow_head(skb,0U);
      #line 2863 
      if (rc < 0) 
                  #line 2864 
                  return rc;
      #line 2865 
      vhdr_0 = (struct vlan_ethhdr *)skb->data;
      #line 2866 
      vhdr_0->h_vlan_TCI = __builtin_bswap16((unsigned short)((int)((unsigned short)(tx_flags >> 16))));
    }
    else 
         #line 2869 
         tx_flags |= 2U;
  }
  #line 2873 
  out: 
       #line 2873 
  ;
  #line 2874 
  *flags = tx_flags;
  #line 2875 
  return 0;
}

#line 2886  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_tso(struct i40e_tx_buffer *first, u8 *hdr_len, u64 *cd_type_cmd_tso_mss)
{
  #line 2890 
  u64 cd_cmd;
  #line 2890 
  u64 cd_tso_len;
  #line 2890 
  u64 cd_mss;
  #line 2895 
  union __anonunion_ip_7780 ip;
  #line 2900 
  union __anonunion_l4_7781 l4;
  #line 2901 
  u32 paylen;
  #line 2901 
  u32 l4_offset;
  #line 2902 
  u16 gso_segs;
  #line 2902 
  u16 gso_size;
  #line 2903 
  int err;
  #line 2889 
  struct sk_buff *skb = first->__anonCompField_i40e_tx_buffer_217.skb;
  #line 2905 
  if ((unsigned int)skb->ip_summed != 3U) 
                                          #line 2906 
                                          return 0;
  #line 2908 
  if (! skb_is_gso(skb)) 
                         #line 2909 
                         return 0;
  #line 2911 
  err = skb_cow_head(skb,0U);
  #line 2912 
  if (err < 0) 
               #line 2913 
               return err;
  #line 2915 
  ip.hdr = skb_network_header(skb);
  #line 2916 
  l4.hdr = skb_transport_header(skb);
  #line 2919 
  if ((unsigned int)(ip.v4)->version == 4U) {
    #line 2920 
    (ip.v4)->tot_len = (unsigned short)0U;
    #line 2921 
    (ip.v4)->check = (unsigned short)0U;
  }
  else 
       #line 2923 
       (ip.v6)->payload_len = (unsigned short)0U;
  #line 2926 
  ;
  #line 2926 
  if ((((struct skb_shared_info *)skb_end_pointer(skb))->gso_type & 4032U) != 0U) {
    #line 2932 
    ;
    #line 2932 
    if ((((struct skb_shared_info *)skb_end_pointer(skb))->gso_type & 4096U) == 0U) {
      #line 2932 
      ;
      #line 2932 
      if ((((struct skb_shared_info *)skb_end_pointer(skb))->gso_type & 2048U) != 0U) {
        #line 2934 
        (l4.udp)->len = (unsigned short)0U;
        #line 2937 
        l4_offset = (unsigned int)(l4.hdr - skb->data);
        #line 2940 
        paylen = skb->len - l4_offset;
        #line 2941 
        ;
        #line 2941 
        csum_replace_by_diff(& (l4.udp)->check,__builtin_bswap32(paylen));
      }
    }
    #line 2946 
    ip.hdr = skb_inner_network_header(skb);
    #line 2947 
    l4.hdr = skb_inner_transport_header(skb);
    #line 2950 
    if ((unsigned int)(ip.v4)->version == 4U) {
      #line 2951 
      (ip.v4)->tot_len = (unsigned short)0U;
      #line 2952 
      (ip.v4)->check = (unsigned short)0U;
    }
    else 
         #line 2954 
         (ip.v6)->payload_len = (unsigned short)0U;
  }
  #line 2959 
  l4_offset = (unsigned int)(l4.hdr - skb->data);
  #line 2962 
  paylen = skb->len - l4_offset;
  #line 2964 
  ;
  #line 2964 
  if ((((struct skb_shared_info *)skb_end_pointer(skb))->gso_type & 131072U) != 0U) {
    #line 2965 
    ;
    #line 2965 
    csum_replace_by_diff(& (l4.udp)->check,__builtin_bswap32(paylen));
    #line 2967 
    *hdr_len = (unsigned char)((unsigned int)((unsigned char)l4_offset) + 8U);
  }
  else {
    #line 2969 
    ;
    #line 2969 
    csum_replace_by_diff(& (l4.tcp)->check,__builtin_bswap32(paylen));
    #line 2971 
    *hdr_len = (unsigned char)((unsigned int)((unsigned char)(l4.tcp)->doff) * 4U + (unsigned int)((unsigned char)l4_offset));
  }
  #line 2975 
  gso_size = ((struct skb_shared_info *)skb_end_pointer(skb))->gso_size;
  #line 2976 
  gso_segs = ((struct skb_shared_info *)skb_end_pointer(skb))->gso_segs;
  #line 2979 
  first->gso_segs = gso_segs;
  #line 2980 
  first->bytecount += (unsigned int)(((int)first->gso_segs + -1) * (int)*hdr_len);
  #line 2983 
  cd_cmd = 1ULL;
  #line 2984 
  cd_tso_len = (unsigned long long)(skb->len - (unsigned int)*hdr_len);
  #line 2985 
  cd_mss = (unsigned long long)gso_size;
  #line 2986 
  *cd_type_cmd_tso_mss |= ((cd_cmd << 4) | (cd_tso_len << 30)) | (cd_mss << 50);
  #line 2989 
  return 1;
}

#line 3001  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_tsyn(struct i40e_ring *tx_ring, struct sk_buff *skb, u32 tx_flags, u64 *cd_type_cmd_tso_mss)
{
  #line 3004 
  struct i40e_pf *pf;
  #line 3006 
  ;
  #line 3006 
  if ((long)(((int)((struct skb_shared_info *)skb_end_pointer(skb))->tx_flags & 1) == 0) != 0L) 
    #line 3007 
    return 0;
  #line 3010 
  if (((unsigned long)tx_flags & 8UL) != 0UL) 
                                              #line 3011 
                                              return 0;
  #line 3016 
  pf = i40e_netdev_to_pf(tx_ring->netdev);
  #line 3017 
  if (((unsigned long)pf->flags & 131072UL) == 0UL) 
                                                    #line 3018 
                                                    return 0;
  #line 3020 
  if ((int)pf->ptp_tx != 0) {
    #line 3021 
    if (test_and_set_bit_lock(18L,(unsigned long *)(& pf->state))) 
                                                                   #line 3020 
                                                                   goto _LAND;
    else {
      #line 3022 
      ((struct skb_shared_info *)skb_end_pointer(skb))->tx_flags = (unsigned char)((unsigned int)((struct skb_shared_info *)skb_end_pointer(skb))->tx_flags | 4U);
      #line 3023 
      pf->ptp_tx_start = jiffies;
      #line 3024 
      pf->ptp_tx_skb = skb_get(skb);
    }
  }
  else {
    #line 3020 
    _LAND: {
             #line 3026 
             (pf->tx_hwtstamp_skipped) ++;
             #line 3027 
             return 0;
           }
  }
  #line 3030 
  *cd_type_cmd_tso_mss |= 32ULL;
  #line 3033 
  return 1;
}

#line 3045  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_tx_enable_csum(struct sk_buff *skb, u32 *tx_flags, u32 *td_cmd, u32 *td_offset, struct i40e_ring *tx_ring, u32 *cd_tunneling)
{
  #line 3054 
  union __anonunion_ip_7784 ip;
  #line 3059 
  union __anonunion_l4_7785 l4;
  #line 3060 
  unsigned char *exthdr;
  #line 3061 
  u32 offset;
  #line 3062 
  __be16 frag_off;
  #line 3061 
  u32 cmd = 0U;
  #line 3063 
  u8 l4_proto = (unsigned char)0U;
  #line 3065 
  if ((unsigned int)skb->ip_summed != 3U) 
                                          #line 3066 
                                          return 0;
  #line 3068 
  ip.hdr = skb_network_header(skb);
  #line 3069 
  l4.hdr = skb_transport_header(skb);
  #line 3072 
  offset = (unsigned int)((ip.hdr - skb->data) / 2L);
  #line 3074 
  if ((unsigned int)skb->encapsulation != 0U) {
    #line 3075 
    u32 tunnel = 0U;
    #line 3077 
    if (((unsigned long)*tx_flags & 16UL) != 0UL) {
      #line 3078 
      unsigned int tmp;
      #line 3078 
      if (((unsigned long)*tx_flags & 8UL) != 0UL) 
                                                   #line 3078 
                                                   tmp = 3U; else 
                                                                  #line 3078 
                                                                  tmp = 2U;
      #line 3078 
      tunnel = tmp | tunnel;
      #line 3082 
      l4_proto = (ip.v4)->protocol;
    }
    else 
      #line 3083 
      if (((unsigned long)*tx_flags & 32UL) != 0UL) {
        #line 3084 
        tunnel |= 1U;
        #line 3086 
        exthdr = ip.hdr + 40UL;
        #line 3087 
        l4_proto = (ip.v6)->nexthdr;
        #line 3088 
        if (l4.hdr != exthdr) 
                              #line 3089 
                              ipv6_skip_exthdr(skb,(int)(exthdr - skb->data),& l4_proto,& frag_off);
      }
    #line 3094 
    switch ((int)l4_proto) {
      #line 3095 
      case 17: 
               #line 3095 
      ;
      #line 3096 
      tunnel |= 512U;
      #line 3097 
      *tx_flags |= 1024U;
      #line 3098 
      break;
      #line 3099 
      case 47: 
               #line 3099 
      ;
      #line 3100 
      tunnel |= 1024U;
      #line 3101 
      *tx_flags |= 1024U;
      #line 3102 
      break;
      #line 3103 
      case 4: 
              #line 3103 
      ;
      #line 3104 
      case 41: 
               #line 3104 
      ;
      #line 3105 
      *tx_flags |= 1024U;
      #line 3106 
      l4.hdr = skb_inner_network_header(skb);
      #line 3107 
      break;
      #line 3108 
      default: 
               #line 3108 
      ;
      #line 3109 
      if (((unsigned long)*tx_flags & 8UL) != 0UL) 
                                                   #line 3110 
                                                   return -1;
      #line 3112 
      skb_checksum_help(skb);
      #line 3113 
      return 0;
    }
    #line 3117 
    tunnel = (unsigned int)(((l4.hdr - ip.hdr) / 4L << 2) | (long)tunnel);
    #line 3121 
    ip.hdr = skb_inner_network_header(skb);
    #line 3124 
    tunnel = (unsigned int)(((ip.hdr - l4.hdr) / 2L << 12) | (long)tunnel);
    #line 3128 
    if (((unsigned long)*tx_flags & 8UL) != 0UL) {
      #line 3128 
      ;
      #line 3128 
      if ((((struct skb_shared_info *)skb_end_pointer(skb))->gso_type & 4096U) == 0U) {
        #line 3129 
        ;
        #line 3129 
        if ((((struct skb_shared_info *)skb_end_pointer(skb))->gso_type & 2048U) != 0U) 
          #line 3131 
          tunnel |= 8388608U;
      }
    }
    #line 3134 
    *cd_tunneling |= tunnel;
    #line 3137 
    l4.hdr = skb_inner_transport_header(skb);
    #line 3138 
    l4_proto = (unsigned char)0U;
    #line 3141 
    *tx_flags &= 4294967247U;
    #line 3142 
    if ((unsigned int)(ip.v4)->version == 4U) 
                                              #line 3143 
                                              *tx_flags |= 16U;
    #line 3144 
    if ((unsigned int)(ip.v6)->version == 6U) 
                                              #line 3145 
                                              *tx_flags |= 32U;
  }
  #line 3149 
  if (((unsigned long)*tx_flags & 16UL) != 0UL) {
    #line 3154 
    unsigned int tmp_2;
    #line 3150 
    l4_proto = (ip.v4)->protocol;
    #line 3154 
    if (((unsigned long)*tx_flags & 8UL) != 0UL) 
                                                 #line 3154 
                                                 tmp_2 = 96U; else 
                                                                   #line 3154 
                                                                   tmp_2 = 64U;
    #line 3154 
    cmd = tmp_2 | cmd;
  }
  else 
    #line 3157 
    if (((unsigned long)*tx_flags & 32UL) != 0UL) {
      #line 3158 
      cmd |= 32U;
      #line 3160 
      exthdr = ip.hdr + 40UL;
      #line 3161 
      l4_proto = (ip.v6)->nexthdr;
      #line 3162 
      if (l4.hdr != exthdr) 
                            #line 3163 
                            ipv6_skip_exthdr(skb,(int)(exthdr - skb->data),& l4_proto,& frag_off);
    }
  #line 3168 
  offset = (unsigned int)(((l4.hdr - ip.hdr) / 4L << 7) | (long)offset);
  #line 3171 
  switch ((int)l4_proto) {
    #line 3172 
    case 6: 
            #line 3172 
    ;
    #line 3174 
    cmd |= 256U;
    #line 3175 
    offset = (unsigned int)((int)(l4.tcp)->doff << 14) | offset;
    #line 3176 
    break;
    #line 3177 
    case 132: 
              #line 3177 
    ;
    #line 3179 
    cmd |= 512U;
    #line 3180 
    offset |= 49152U;
    #line 3182 
    break;
    #line 3183 
    case 17: 
             #line 3183 
    ;
    #line 3185 
    cmd |= 768U;
    #line 3186 
    offset |= 32768U;
    #line 3188 
    break;
    #line 3189 
    default: 
             #line 3189 
    ;
    #line 3190 
    if (((unsigned long)*tx_flags & 8UL) != 0UL) 
                                                 #line 3191 
                                                 return -1;
    #line 3192 
    skb_checksum_help(skb);
    #line 3193 
    return 0;
  }
  #line 3196 
  *td_cmd |= cmd;
  #line 3197 
  *td_offset |= offset;
  #line 3199 
  return 1;
}

#line 3209  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static void i40e_create_tx_ctx(struct i40e_ring *tx_ring, u64 cd_type_cmd_tso_mss, u32 cd_tunneling, u32 cd_l2tag2)
{
  #line 3213 
  struct i40e_tx_context_desc *context_desc;
  #line 3214 
  int i = (int)tx_ring->next_to_use;
  #line 3216 
  if ((cd_type_cmd_tso_mss == 1ULL && cd_tunneling == 0U) && cd_l2tag2 == 0U) 
    #line 3218 
    return;
  #line 3221 
  context_desc = (struct i40e_tx_context_desc *)tx_ring->desc + (unsigned long)i;
  #line 3223 
  i ++;
  #line 3224 
  if ((int)tx_ring->count > i) 
                               #line 3224 
                               tx_ring->next_to_use = (unsigned short)i; else 
                                                                    #line 3224 
                                                                    tx_ring->next_to_use = (unsigned short)0U;
  #line 3227 
  context_desc->tunneling_params = cd_tunneling;
  #line 3228 
  context_desc->l2tag2 = (unsigned short)cd_l2tag2;
  #line 3229 
  context_desc->rsvd = (unsigned short)0U;
  #line 3230 
  context_desc->type_cmd_tso_mss = cd_type_cmd_tso_mss;
  #line 3231 
  return;
}

#line 3240  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int __i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size)
{
  #line 3247 
  int tmp;
  #line 3242 
  netif_stop_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
  #line 3243 
  ldv_inline_asm();
  #line 3247 
  if ((int)tx_ring->next_to_clean <= (int)tx_ring->next_to_use) 
                                                                #line 3247 
                                                                tmp = (int)tx_ring->count; else 
                                                                    #line 3247 
                                                                    tmp = 0;
  #line 3247 
  ;
  #line 3247 
  if ((long)((tmp + (int)tx_ring->next_to_clean) - (int)tx_ring->next_to_use <= size) != 0L) 
    #line 3248 
    return -16;
  #line 3251 
  netif_start_subqueue(tx_ring->netdev,(unsigned short)((int)tx_ring->queue_index));
  #line 3252 
  (tx_ring->__anonCompField_i40e_ring_222.tx_stats.restart_queue) ++;
  #line 3253 
  return 0;
}

#line 3269  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
bool __i40e_chk_linearize(struct sk_buff *skb)
{
  #line 3271 
  skb_frag_t *frag;
  #line 3271 
  skb_frag_t *stale;
  #line 3272 
  int nr_frags;
  #line 3272 
  int sum;
  #line 3294 
  skb_frag_t *tmp_2;
  #line 3295 
  skb_frag_t *tmp_4;
  #line 3296 
  skb_frag_t *tmp_6;
  #line 3297 
  skb_frag_t *tmp_8;
  #line 3298 
  skb_frag_t *tmp_10;
  #line 3275 
  nr_frags = (int)((struct skb_shared_info *)skb_end_pointer(skb))->nr_frags;
  #line 3276 
  if (nr_frags <= 6) 
                     #line 3277 
                     return (_Bool)0;
  #line 3282 
  nr_frags += -6;
  #line 3283 
  frag = & ((struct skb_shared_info *)skb_end_pointer(skb))->frags[0];
  #line 3291 
  sum = 1 - (int)((struct skb_shared_info *)skb_end_pointer(skb))->gso_size;
  #line 3294 
  tmp_2 = frag;
  #line 3294 
  frag ++;
  #line 3294 
  ;
  #line 3294 
  sum = (int)(skb_frag_size(tmp_2) + (unsigned int)sum);
  #line 3295 
  tmp_4 = frag;
  #line 3295 
  frag ++;
  #line 3295 
  ;
  #line 3295 
  sum = (int)(skb_frag_size(tmp_4) + (unsigned int)sum);
  #line 3296 
  tmp_6 = frag;
  #line 3296 
  frag ++;
  #line 3296 
  ;
  #line 3296 
  sum = (int)(skb_frag_size(tmp_6) + (unsigned int)sum);
  #line 3297 
  tmp_8 = frag;
  #line 3297 
  frag ++;
  #line 3297 
  ;
  #line 3297 
  sum = (int)(skb_frag_size(tmp_8) + (unsigned int)sum);
  #line 3298 
  tmp_10 = frag;
  #line 3298 
  frag ++;
  #line 3298 
  ;
  #line 3298 
  sum = (int)(skb_frag_size(tmp_10) + (unsigned int)sum);
  #line 3303 
  stale = & ((struct skb_shared_info *)skb_end_pointer(skb))->frags[0];
  #line 3303 
  while (1) {
    {
      #line 3306 
      skb_frag_t *tmp_14;
      #line 3331 
      int tmp_17;
      #line 3304 
      int stale_size = (int)skb_frag_size(stale);
      #line 3306 
      tmp_14 = frag;
      #line 3306 
      frag ++;
      #line 3306 
      ;
      #line 3306 
      sum = (int)(skb_frag_size(tmp_14) + (unsigned int)sum);
      #line 3314 
      if (stale_size > 16383) {
        #line 3315 
        int align_pad = (int)(- skb_frag_off(stale)) & 4095;
        #line 3318 
        sum -= align_pad;
        #line 3319 
        stale_size -= align_pad;
        #line 3321 
        while (1) {
          #line 3322 
          sum += -12288;
          #line 3323 
          stale_size += -12288;
          #line 3324 
          if (! (stale_size > 16383)) 
                                      #line 3321 
                                      break;
        }
      }
      #line 3328 
      if (sum < 0) 
                   #line 3329 
                   return (_Bool)1;
      #line 3331 
      tmp_17 = nr_frags;
      #line 3331 
      nr_frags --;
      #line 3331 
      ;
      #line 3331 
      if (tmp_17 == 0) 
                       #line 3332 
                       break;
      #line 3334 
      sum -= stale_size;
    }
    #line 3303 
    stale ++;
  }
  #line 3337 
  return (_Bool)0;
}

#line 3352  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
__inline static int i40e_tx_map(struct i40e_ring *tx_ring, struct sk_buff *skb, struct i40e_tx_buffer *first, u32 tx_flags, u8 hdr_len, u32 td_cmd, u32 td_offset)
{
  #line 3358 
  skb_frag_t *frag;
  #line 3359 
  struct i40e_tx_buffer *tx_bi;
  #line 3360 
  struct i40e_tx_desc *tx_desc;
  #line 3363 
  dma_addr_t dma;
  #line 3356 
  unsigned int data_len = skb->data_len;
  #line 3357 
  unsigned int size = skb_headlen(skb);
  #line 3361 
  u16 i = tx_ring->next_to_use;
  #line 3362 
  u32 td_tag = 0U;
  #line 3364 
  u16 desc_count = (unsigned short)1U;
  #line 3366 
  if (((unsigned long)tx_flags & 2UL) != 0UL) {
    #line 3367 
    td_cmd |= 8U;
    #line 3368 
    td_tag = tx_flags >> 16;
  }
  #line 3372 
  first->tx_flags = tx_flags;
  #line 3374 
  dma = dma_map_single_attrs(tx_ring->dev,(void *)skb->data,(unsigned long)size,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
  #line 3376 
  tx_desc = (struct i40e_tx_desc *)tx_ring->desc + (unsigned long)i;
  #line 3377 
  tx_bi = first;
  #line 3379 
  frag = & ((struct skb_shared_info *)skb_end_pointer(skb))->frags[0];
  #line 3379 
  while (1) {
    {
      #line 3380 
      unsigned int max_data = 12288U;
      #line 3382 
      if (dma_mapping_error(tx_ring->dev,dma) != 0) 
                                                    #line 3383 
                                                    goto dma_error;
      #line 3386 
      tx_bi->len = size;
      #line 3387 
      tx_bi->dma = dma;
      #line 3390 
      max_data = (- ((unsigned int)dma) & 4095U) + max_data;
      #line 3391 
      tx_desc->buffer_addr = dma;
      #line 3393 
      while ((long)(size > 16383U) != 0L) {
        #line 3394 
        tx_desc->cmd_type_offset_bsz = build_ctob(td_cmd,td_offset,max_data,td_tag);
        #line 3398 
        tx_desc ++;
        #line 3399 
        i = (u16)((int)i + 1);
        #line 3400 
        desc_count = (u16)((int)desc_count + 1);
        #line 3402 
        if ((int)tx_ring->count == (int)i) {
          #line 3403 
          tx_desc = (struct i40e_tx_desc *)tx_ring->desc;
          #line 3404 
          i = (unsigned short)0U;
        }
        #line 3407 
        dma = (unsigned long long)max_data + dma;
        #line 3408 
        size -= max_data;
        #line 3410 
        max_data = 12288U;
        #line 3411 
        tx_desc->buffer_addr = dma;
      }
      #line 3414 
      if ((long)(data_len == 0U) != 0L) 
                                        #line 3415 
                                        break;
      #line 3417 
      tx_desc->cmd_type_offset_bsz = build_ctob(td_cmd,td_offset,size,td_tag);
      #line 3420 
      tx_desc ++;
      #line 3421 
      i = (u16)((int)i + 1);
      #line 3422 
      desc_count = (u16)((int)desc_count + 1);
      #line 3424 
      if ((int)tx_ring->count == (int)i) {
        #line 3425 
        tx_desc = (struct i40e_tx_desc *)tx_ring->desc;
        #line 3426 
        i = (unsigned short)0U;
      }
      #line 3429 
      size = skb_frag_size(frag);
      #line 3430 
      data_len -= size;
      #line 3432 
      dma = skb_frag_dma_map(tx_ring->dev,frag,0UL,(unsigned long)size,(enum dma_data_direction)DMA_TO_DEVICE);
      #line 3435 
      tx_bi = tx_ring->__anonCompField_i40e_ring_221.tx_bi + (unsigned long)i;
    }
    #line 3379 
    frag ++;
  }
  #line 3438 
  ;
  #line 3438 
  netdev_tx_sent_queue(txring_txq(tx_ring),first->bytecount);
  #line 3440 
  i = (u16)((int)i + 1);
  #line 3441 
  if ((int)tx_ring->count == (int)i) 
                                     #line 3442 
                                     i = (unsigned short)0U;
  #line 3444 
  tx_ring->next_to_use = i;
  #line 3446 
  i40e_maybe_stop_tx(tx_ring,23);
  #line 3449 
  td_cmd |= 1U;
  #line 3454 
  tx_ring->packet_stride = (u8)((int)tx_ring->packet_stride + 1);
  #line 3454 
  desc_count = (unsigned short)((int)((unsigned short)tx_ring->packet_stride) | (int)desc_count);
  #line 3456 
  if ((unsigned int)desc_count > 3U) {
    #line 3458 
    td_cmd |= 2U;
    #line 3459 
    tx_ring->packet_stride = (unsigned char)0U;
  }
  #line 3462 
  tx_desc->cmd_type_offset_bsz = build_ctob(td_cmd,td_offset,size,td_tag);
  #line 3465 
  skb_tx_timestamp(skb);
  #line 3466 
  ldv_inline_asm();
  #line 3476 
  first->next_to_watch = tx_desc;
  #line 3479 
  if ((int)netif_xmit_stopped(txring_txq(tx_ring)) != 0) 
                                                         #line 3480 
                                                         writel((unsigned int)i,(void *)tx_ring->tail);
  else {
    #line 3479 
    if (! netdev_xmit_more()) 
                              #line 3480 
                              writel((unsigned int)i,(void *)tx_ring->tail);
  }
  #line 3483 
  return 0;
  #line 3485 
  dma_error: 
             #line 3485 
  ;
  #line 3486 
  _dev_info(tx_ring->dev,(char *)"TX DMA map failed\n");
  #line 3489 
  while (1) {
    #line 3490 
    tx_bi = tx_ring->__anonCompField_i40e_ring_221.tx_bi + (unsigned long)i;
    #line 3491 
    i40e_unmap_and_free_tx_resource(tx_ring,tx_bi);
    #line 3492 
    if (tx_bi == first) 
                        #line 3493 
                        break;
    #line 3494 
    if ((unsigned int)i == 0U) 
                               #line 3495 
                               i = tx_ring->count;
    #line 3496 
    i = (u16)((int)i - 1);
  }
  #line 3499 
  tx_ring->next_to_use = i;
  #line 3501 
  return -1;
}

#line 3509  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static int i40e_xmit_xdp_ring(struct xdp_frame *xdpf, struct i40e_ring *xdp_ring)
{
  #line 3513 
  struct i40e_tx_buffer *tx_bi;
  #line 3514 
  struct i40e_tx_desc *tx_desc;
  #line 3517 
  dma_addr_t dma;
  #line 3519 
  int tmp;
  #line 3512 
  u16 i = xdp_ring->next_to_use;
  #line 3515 
  void *data = xdpf->data;
  #line 3516 
  u32 size = (unsigned int)xdpf->len;
  #line 3519 
  if ((int)xdp_ring->next_to_clean <= (int)xdp_ring->next_to_use) 
                                                                  #line 3519 
                                                                  tmp = (int)xdp_ring->count; else 
                                                                    #line 3519 
                                                                    tmp = 0;
  #line 3519 
  ;
  #line 3519 
  if ((long)((tmp + (int)xdp_ring->next_to_clean) - (int)xdp_ring->next_to_use != 1) == 0L) {
    #line 3520 
    (xdp_ring->__anonCompField_i40e_ring_222.tx_stats.tx_busy) ++;
    #line 3521 
    return 1;
  }
  #line 3523 
  dma = dma_map_single_attrs(xdp_ring->dev,data,(unsigned long)size,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
  #line 3524 
  if (dma_mapping_error(xdp_ring->dev,dma) != 0) 
                                                 #line 3525 
                                                 return 1;
  #line 3527 
  tx_bi = xdp_ring->__anonCompField_i40e_ring_221.tx_bi + (unsigned long)i;
  #line 3528 
  tx_bi->bytecount = size;
  #line 3529 
  tx_bi->gso_segs = (unsigned short)1U;
  #line 3530 
  tx_bi->__anonCompField_i40e_tx_buffer_217.xdpf = xdpf;
  #line 3533 
  tx_bi->len = size;
  #line 3534 
  tx_bi->dma = dma;
  #line 3536 
  tx_desc = (struct i40e_tx_desc *)xdp_ring->desc + (unsigned long)i;
  #line 3537 
  tx_desc->buffer_addr = dma;
  #line 3538 
  tx_desc->cmd_type_offset_bsz = build_ctob(7U,0U,size,0U);
  #line 3539 
  ldv_inline_asm();
  #line 3547 
  i = (u16)((int)i + 1);
  #line 3548 
  if ((int)xdp_ring->count == (int)i) 
                                      #line 3549 
                                      i = (unsigned short)0U;
  #line 3551 
  tx_bi->next_to_watch = tx_desc;
  #line 3552 
  xdp_ring->next_to_use = i;
  #line 3554 
  return 2;
}

#line 3564  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
static netdev_tx_t i40e_xmit_frame_ring(struct sk_buff *skb, struct i40e_ring *tx_ring)
{
  #line 3569 
  struct i40e_tx_buffer *first;
  #line 3572 
  __be16 protocol;
  #line 3575 
  int tso;
  #line 3575 
  int count;
  #line 3576 
  int tsyn;
  #line 3567 
  u64 cd_type_cmd_tso_mss = 1ULL;
  #line 3568 
  u32 cd_tunneling = 0U;
  #line 3568 
  u32 cd_l2tag2 = 0U;
  #line 3570 
  u32 td_offset = 0U;
  #line 3571 
  u32 tx_flags = 0U;
  #line 3573 
  u32 td_cmd = 0U;
  #line 3574 
  u8 hdr_len = (unsigned char)0U;
  #line 3579 
  __builtin_prefetch((void const *)((void *)skb->data));
  #line 3581 
  trace_i40e_xmit_frame_ring(skb,tx_ring);
  #line 3583 
  count = i40e_xmit_descriptor_count(skb);
  #line 3584 
  if ((int)i40e_chk_linearize(skb,count) != 0) {
    #line 3585 
    if (__skb_linearize(skb) != 0) {
      #line 3586 
      dev_kfree_skb_any(skb);
      #line 3587 
      return NETDEV_TX_OK;
    }
    #line 3589 
    count = (int)i40e_txd_use_count(skb->len);
    #line 3590 
    (tx_ring->__anonCompField_i40e_ring_222.tx_stats.tx_linearize) ++;
  }
  #line 3599 
  if (i40e_maybe_stop_tx(tx_ring,count + 5) != 0) {
    #line 3600 
    (tx_ring->__anonCompField_i40e_ring_222.tx_stats.tx_busy) ++;
    #line 3601 
    return NETDEV_TX_BUSY;
  }
  #line 3605 
  first = tx_ring->__anonCompField_i40e_ring_221.tx_bi + (unsigned long)tx_ring->next_to_use;
  #line 3606 
  first->__anonCompField_i40e_tx_buffer_217.skb = skb;
  #line 3607 
  first->bytecount = skb->len;
  #line 3608 
  first->gso_segs = (unsigned short)1U;
  #line 3611 
  if (i40e_tx_prepare_vlan_flags(skb,tx_ring,& tx_flags) != 0) 
                                                               #line 3612 
                                                               goto out_drop;
  #line 3615 
  protocol = vlan_get_protocol(skb);
  #line 3618 
  if ((unsigned int)protocol == 8U) 
                                    #line 3619 
                                    tx_flags |= 16U;
  else 
    #line 3620 
    if ((unsigned int)protocol == 56710U) 
                                          #line 3621 
                                          tx_flags |= 32U;
  #line 3623 
  tso = i40e_tso(first,& hdr_len,& cd_type_cmd_tso_mss);
  #line 3625 
  if (tso < 0) 
               #line 3626 
               goto out_drop;
  else 
    #line 3627 
    if (tso != 0) 
                  #line 3628 
                  tx_flags |= 8U;
  #line 3631 
  tso = i40e_tx_enable_csum(skb,& tx_flags,& td_cmd,& td_offset,tx_ring,& cd_tunneling);
  #line 3633 
  if (tso < 0) 
               #line 3634 
               goto out_drop;
  #line 3636 
  tsyn = i40e_tsyn(tx_ring,skb,tx_flags,& cd_type_cmd_tso_mss);
  #line 3638 
  if (tsyn != 0) 
                 #line 3639 
                 tx_flags |= 256U;
  #line 3642 
  td_cmd |= 4U;
  #line 3644 
  i40e_create_tx_ctx(tx_ring,cd_type_cmd_tso_mss,cd_tunneling,cd_l2tag2);
  #line 3651 
  i40e_atr(tx_ring,skb,tx_flags);
  #line 3653 
  if (i40e_tx_map(tx_ring,skb,first,tx_flags,(unsigned char)((int)hdr_len),
                    td_cmd,td_offset) != 0) 
    #line 3655 
    goto cleanup_tx_tstamp;
  #line 3657 
  return NETDEV_TX_OK;
  #line 3659 
  out_drop: 
            #line 3659 
  ;
  #line 3660 
  trace_i40e_xmit_frame_ring_drop(first->__anonCompField_i40e_tx_buffer_217.skb,tx_ring);
  #line 3661 
  dev_kfree_skb_any(first->__anonCompField_i40e_tx_buffer_217.skb);
  #line 3662 
  first->__anonCompField_i40e_tx_buffer_217.skb = (struct sk_buff *)0;
  #line 3663 
  cleanup_tx_tstamp: 
                     #line 3663 
  ;
  #line 3664 
  if ((long)(((unsigned long)tx_flags & 256UL) != 0UL) != 0L) {
    #line 3665 
    struct i40e_pf *pf = i40e_netdev_to_pf(tx_ring->netdev);
    #line 3667 
    dev_kfree_skb_any(pf->ptp_tx_skb);
    #line 3668 
    pf->ptp_tx_skb = (struct sk_buff *)0;
    #line 3669 
    clear_bit_unlock(18L,(unsigned long *)(& pf->state));
  }
  #line 3672 
  return NETDEV_TX_OK;
}

#line 3682  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
netdev_tx_t i40e_lan_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
{
  #line 3684 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 3685 
  struct i40e_vsi *vsi = np->vsi;
  #line 3686 
  struct i40e_ring *tx_ring = *(vsi->tx_rings + (unsigned long)skb->queue_mapping);
  #line 3691 
  if (skb_put_padto(skb,17U) != 0) 
                                   #line 3692 
                                   return NETDEV_TX_OK;
  #line 3694 
  return i40e_xmit_frame_ring(skb,tx_ring);
}

#line 3708  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.c"
int i40e_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **frames, u32 flags)
{
  #line 3712 
  int pscr_ret__;
  #line 3715 
  struct i40e_ring *xdp_ring;
  #line 3717 
  int i;
  #line 3711 
  struct i40e_netdev_priv *np = netdev_priv(dev);
  #line 3712 
  __this_cpu_preempt_check((char *)"read");
  {
    #line 3712 
    void *__vpp_verify = (void *)0;
    #line 3712 
    void *tmp_2 = __vpp_verify;
  }
  #line 3712 
  switch (4UL) {
    #line 3712 
    int pfo_ret__;
    #line 3712 
    int pfo_ret___0;
    #line 3712 
    int pfo_ret___1;
    #line 3712 
    int pfo_ret___2;
    #line 3712 
    case (unsigned long)1: 
                           #line 3712 
    ;
    #line 3712 
    switch (4UL) {
      #line 3712 
      case (unsigned long)1: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      case (unsigned long)2: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      case (unsigned long)4: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      case (unsigned long)8: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      default: 
               #line 3712 
      ;
      #line 3712 
      __bad_percpu_size();
    }
    #line 3712 
    pscr_ret__ = pfo_ret__;
    #line 3712 
    break;
    #line 3712 
    case (unsigned long)2: 
                           #line 3712 
    ;
    #line 3712 
    switch (4UL) {
      #line 3712 
      case (unsigned long)1: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      case (unsigned long)2: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      case (unsigned long)4: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      case (unsigned long)8: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      default: 
               #line 3712 
      ;
      #line 3712 
      __bad_percpu_size();
    }
    #line 3712 
    pscr_ret__ = pfo_ret___0;
    #line 3712 
    break;
    #line 3712 
    case (unsigned long)4: 
                           #line 3712 
    ;
    #line 3712 
    switch (4UL) {
      #line 3712 
      case (unsigned long)1: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      case (unsigned long)2: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      case (unsigned long)4: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      case (unsigned long)8: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      default: 
               #line 3712 
      ;
      #line 3712 
      __bad_percpu_size();
    }
    #line 3712 
    pscr_ret__ = pfo_ret___1;
    #line 3712 
    break;
    #line 3712 
    case (unsigned long)8: 
                           #line 3712 
    ;
    #line 3712 
    switch (4UL) {
      #line 3712 
      case (unsigned long)1: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      case (unsigned long)2: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      case (unsigned long)4: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      case (unsigned long)8: 
                             #line 3712 
      ;
      #line 3713 
      ldv_inline_asm();
      #line 3712 
      break;
      #line 3712 
      default: 
               #line 3712 
      ;
      #line 3712 
      __bad_percpu_size();
    }
    #line 3712 
    pscr_ret__ = pfo_ret___2;
    #line 3712 
    break;
    #line 3712 
    default: 
             #line 3712 
    ;
    #line 3712 
    __bad_size_call_parameter();
    #line 3712 
    break;
  }
  #line 3712 
  unsigned int queue_index = (unsigned int)pscr_ret__;
  #line 3713 
  struct i40e_vsi *vsi = np->vsi;
  #line 3714 
  struct i40e_pf *pf = vsi->back;
  #line 3716 
  int drops = 0;
  #line 3719 
  if ((int)test_bit(0L,(unsigned long *)(& vsi->state)) != 0) 
                                                              #line 3720 
                                                              return -100;
  #line 3722 
  if (i40e_enabled_xdp_vsi(vsi)) 
    #line 3722 
    if ((unsigned int)vsi->num_queue_pairs <= queue_index) 
                                                           #line 3724 
                                                           return -6;
    else {
      #line 3722 
      if ((int)test_bit(1L,(unsigned long *)(& pf->state)) != 0) 
                                                                 #line 3724 
                                                                 return -6;
    }
  else 
       #line 3724 
       return -6;
  #line 3726 
  if ((long)((flags & 4294967294U) != 0U) != 0L) 
                                                 #line 3727 
                                                 return -22;
  #line 3729 
  xdp_ring = *(vsi->xdp_rings + (unsigned long)queue_index);
  #line 3731 
  i = 0;
  #line 3731 
  while (i < n) {
    {
      #line 3733 
      int err;
      #line 3732 
      struct xdp_frame *xdpf = *(frames + (unsigned long)i);
      #line 3735 
      err = i40e_xmit_xdp_ring(xdpf,xdp_ring);
      #line 3736 
      if (err != 2) {
        #line 3737 
        xdp_return_frame_rx_napi(xdpf);
        #line 3738 
        drops ++;
      }
    }
    #line 3731 
    i ++;
  }
  #line 3742 
  if ((long)((flags & 1U) != 0U) != 0L) 
                                        #line 3743 
                                        i40e_xdp_ring_update_tail(xdp_ring);
  #line 3745 
  return n - drops;
}

#line 120  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
static void cif_set_bit_0(long nr, unsigned long *addr)
{
  #line 123 
  ldv_set_bit(nr,addr);
  #line 124 
  return;
}

#line 127  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
static void cif_clear_bit_0(long nr, unsigned long *addr)
{
  #line 130 
  ldv_clear_bit(nr,addr);
  #line 131 
  return;
}

#line 162  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
static void atomic_add(int i, atomic_t *v)
{
  #line 165 
  ldv_atomic_add(i,v);
  #line 166 
  return;
}

#line 204  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
static void *ERR_PTR(long error)
{
  #line 207 
  return ldv_err_ptr(error);
}

#line 211  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
static long PTR_ERR_0(void *ptr)
{
  #line 214 
  return ldv_ptr_err(ptr);
}

#line 218  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
static bool IS_ERR_0(void *ptr)
{
  #line 221 
  return ldv_is_err(ptr);
}

#line 365  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_txrx.i.aux"
static void *kzalloc_0(size_t size, gfp_t flags)
{
  #line 368 
  return ldv_kzalloc(size,flags);
}

#line 324  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static int fls(unsigned int x)
{
  #line 326 
  int r;
  #line 327 
  ldv_inline_asm();
  #line 351 
  return r + 1;
}

#line 366  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x)
{
  #line 368 
  int bitpos = -1;
  #line 369 
  ldv_inline_asm();
  #line 377 
  return bitpos + 1;
}

#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/find.h"
#line 269  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static unsigned long cif_find_next_bit_0(unsigned long *addr, unsigned long size, unsigned long offset);
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/find.h"
#line 311  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static unsigned long cif_find_first_bit_0(unsigned long *addr, unsigned long size);
#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/find.h"
#line 70 
unsigned long find_first_zero_bit(unsigned long *, unsigned long);
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 276  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_set_bit_1(long nr, unsigned long *addr);
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 283  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_clear_bit_1(long nr, unsigned long *addr);
#line 179  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bitops.h"
__inline static unsigned int fls_long(unsigned long l)
{
  #line 183 
  return (unsigned int)fls64((unsigned long long)l);
}

#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/log2.h"
__inline static int __ilog2_u32(u32 n)
{
  #line 24 
  return fls(n) + -1;
}

#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/log2.h"
__inline static bool is_power_of_2(unsigned long n)
{
  #line 47 
  return (_Bool)((n != 0UL && ((n + 18446744073709551615UL) & n) == 0UL) != 0);
}

#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/log2.h"
__inline static unsigned long __roundup_pow_of_two(unsigned long n)
{
  #line 57 
  return 1UL << fls_long(n + 18446744073709551615UL);
}

#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_debug.h"
#line 70 
void __dynamic_netdev_dbg(struct _ddebug *, struct net_device *, char * , ...);
#line 570  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernel.h"
#line 570 
extern enum system_states system_state;
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
#line 290  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void INIT_LIST_HEAD(struct list_head *list);
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
#line 33 
bool __list_add_valid(struct list_head *, struct list_head *, struct list_head *);
#line 36 
#line 36 
bool __list_del_entry_valid(struct list_head *);
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next)
{
  #line 60 
  if (! __list_add_valid(new,prev,next)) 
                                         #line 61 
                                         return;
  #line 63 
  next->prev = new;
  #line 64 
  new->next = next;
  #line 65 
  new->prev = prev;
  {
    #line 67 
    union __anonunion___u_7798 __u = {.__val = new};
    #line 66 
    __write_once_size((void *)(& prev->next),(void *)(& __u.__c),8);
    #line 66 
    struct list_head *tmp_2 = __u.__val;
  }
  #line 68 
  return;
}

#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new, struct list_head *head)
{
  #line 93 
  __list_add(new,head->prev,head);
  #line 94 
  return;
}

#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_del(struct list_head *prev, struct list_head *next)
{
  #line 97 
  next->prev = prev;
  {
    #line 107 
    union __anonunion___u_7800 __u = {.__val = next};
    #line 106 
    __write_once_size((void *)(& prev->next),(void *)(& __u.__c),8);
    #line 106 
    struct list_head *tmp = __u.__val;
  }
  #line 108 
  return;
}

#line 129  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_del_entry(struct list_head *entry)
{
  #line 131 
  if (! __list_del_entry_valid(entry)) 
                                       #line 132 
                                       return;
  #line 134 
  __list_del(entry->prev,entry->next);
  #line 135 
  return;
}

#line 137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void list_del(struct list_head *entry)
{
  #line 139 
  __list_del_entry(entry);
  #line 140 
  entry->next = (struct list_head *)(-2401263026318606080);
  #line 141 
  entry->prev = (struct list_head *)(-2401263026318606046);
  #line 142 
  return;
}

#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static int list_empty(struct list_head *head)
{
  #line 269 
  union __anonunion___u_7802 __u;
  #line 268 
  __read_once_size((void *)(& head->next),(void *)(& __u.__c),8);
  #line 268 
  ;
  #line 268 
  return (__u.__val) == head;
}

#line 747  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static int hlist_unhashed(struct hlist_node *h)
{
  #line 749 
  return h->pprev == (struct hlist_node **)0;
}

#line 752  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static int hlist_empty(struct hlist_head *h)
{
  #line 755 
  union __anonunion___u_7804 __u;
  #line 754 
  __read_once_size((void *)(& h->first),(void *)(& __u.__c),8);
  #line 754 
  return (__u.__val) == (struct hlist_node *)0;
}

#line 757  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __hlist_del_0(struct hlist_node *n)
{
  #line 759 
  struct hlist_node *next = n->next;
  #line 760 
  struct hlist_node **pprev = n->pprev;
  {
    #line 763 
    union __anonunion___u_7806 __u = {.__val = next};
    #line 762 
    __write_once_size((void *)pprev,(void *)(& __u.__c),8);
    #line 762 
    struct hlist_node *tmp = __u.__val;
  }
  #line 763 
  if (next != (struct hlist_node *)0) 
                                      #line 764 
                                      next->pprev = pprev;
  #line 765 
  return;
}

#line 767  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void hlist_del_0(struct hlist_node *n)
{
  #line 769 
  __hlist_del_0(n);
  #line 770 
  n->next = (struct hlist_node *)(-2401263026318606080);
  #line 771 
  n->pprev = (struct hlist_node **)(-2401263026318606046);
  #line 772 
  return;
}

#line 774  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void hlist_del_init(struct hlist_node *n)
{
  #line 776 
  if (hlist_unhashed(n) == 0) {
    #line 777 
    __hlist_del_0(n);
    #line 778 
    INIT_HLIST_NODE(n);
  }
  #line 780 
  return;
}

#line 782  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void hlist_add_head_0(struct hlist_node *n, struct hlist_head *h)
{
  #line 784 
  struct hlist_node *first = h->first;
  #line 785 
  n->next = first;
  #line 786 
  if (first != (struct hlist_node *)0) 
                                       #line 787 
                                       first->pprev = & n->next;
  {
    #line 789 
    union __anonunion___u_7808 __u = {.__val = n};
    #line 788 
    __write_once_size((void *)(& h->first),(void *)(& __u.__c),8);
    #line 788 
    struct hlist_node *tmp = __u.__val;
  }
  #line 789 
  n->pprev = & h->first;
  #line 790 
  return;
}

#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/string_64.h"
#line 15 
void *__memcpy(void *, void *, size_t);
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bitmap.h"
#line 115 
unsigned long *bitmap_zalloc(unsigned int, gfp_t);
#line 116 
#line 116 
void bitmap_free(unsigned long *);
#line 230 
#line 353  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_bitmap_zero(unsigned long *dst, unsigned int nbits);
#line 237  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bitmap.h"
__inline static void bitmap_copy(unsigned long *dst, unsigned long *src, unsigned int nbits)
{
  #line 240 
  unsigned int len = (unsigned int)(((unsigned long)nbits + 63UL) / 64UL) * 8U;
  #line 241 
  __memcpy((void *)dst,(void *)src,(unsigned long)len);
  #line 242 
  return;
}

#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/cmpxchg.h"
#line 13 
void __xchg_wrong_size(void);
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/cmpxchg_64.h"
__inline static int arch_atomic_read_0(atomic_t *v)
{
  #line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
  union __anonunion___u_7852 __u;
  #line 31 
  __read_once_size((void *)(& v->counter),(void *)(& __u.__c),4);
  #line 31 
  return (__u.__val);
}

#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/atomic-instrumented.h"
__inline static int atomic_read_0(atomic_t *v)
{
  #line 26 
  kasan_check_read((void *)v,4U);
  #line 27 
  return arch_atomic_read_0(v);
}

#line 90  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
#line 90 
extern struct cpumask __cpu_possible_mask;
#line 99 
#line 99 
extern atomic_t __num_online_cpus;
#line 110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
__inline static unsigned int num_online_cpus(void)
{
  #line 112 
  return (unsigned int)atomic_read_0(& __num_online_cpus);
}

#line 212  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
__inline static unsigned int cpumask_first(struct cpumask *srcp)
{
  #line 214 
  return (unsigned int)cif_find_first_bit_0((unsigned long *)(& srcp->bits),
                           (unsigned long)nr_cpu_ids);
}

#line 228 
#line 228 
unsigned int cpumask_next(int, struct cpumask *);
#line 247 
#line 247 
unsigned int cpumask_local_spread(unsigned int, int);
#line 590  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
__inline static void cpumask_copy(struct cpumask *dstp, struct cpumask *srcp)
{
  #line 593 
  bitmap_copy((unsigned long *)(& dstp->bits),(unsigned long *)(& srcp->bits),nr_cpu_ids);
  #line 594 
  return;
}

#line 877 
#line 877 
extern unsigned long cpu_bit_bitmap[65U][128U];
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
__inline static struct cpumask *get_cpu_mask(unsigned int cpu)
{
  #line 881 
  unsigned long *p = (unsigned long *)(& cpu_bit_bitmap[(cpu & 63U) + 1U]);
  #line 882 
  p += - (cpu / 64U);
  #line 883 
  return (struct cpumask *)p;
}

#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 360  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void *ERR_PTR_0(long error);
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void)
{
  #line 26 
  int pfo_ret__;
  #line 26 
  switch (4UL) {
    #line 26 
    case (unsigned long)1: 
                           #line 26 
    ;
    #line 27 
    ldv_inline_asm();
    #line 26 
    break;
    #line 26 
    case (unsigned long)2: 
                           #line 26 
    ;
    #line 27 
    ldv_inline_asm();
    #line 26 
    break;
    #line 26 
    case (unsigned long)4: 
                           #line 26 
    ;
    #line 27 
    ldv_inline_asm();
    #line 26 
    break;
    #line 26 
    case (unsigned long)8: 
                           #line 26 
    ;
    #line 27 
    ldv_inline_asm();
    #line 26 
    break;
    #line 26 
    default: 
             #line 26 
    ;
    #line 26 
    __bad_percpu_size();
  }
  #line 26 
  return pfo_ret__ & 2147483647;
}

#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bottom_half.h"
#line 8 
void __local_bh_disable_ip(unsigned long, unsigned int);
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bottom_half.h"
__inline static void local_bh_disable(void)
{
  #line 19 
  __here_0: 
            #line 19 
  ;
  #line 19 
  __local_bh_disable_ip((unsigned long)((void *)0),512U);
  #line 21 
  return;
}

#line 23 
#line 23 
void __local_bh_enable_ip(unsigned long, unsigned int);
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bottom_half.h"
__inline static void local_bh_enable(void)
{
  #line 32 
  __here_0: 
            #line 32 
  ;
  #line 32 
  __local_bh_enable_ip((unsigned long)((void *)0),512U);
  #line 34 
  return;
}

#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/debug_locks.h"
#line 11 
extern int debug_locks;
#line 302  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
#line 302 
void lockdep_init_map(struct lockdep_map *, char *, struct lock_class_key *, int);
#line 357 
#line 357 
int lock_is_held_type(struct lockdep_map *, int);
#line 359  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
__inline static int lock_is_held(struct lockdep_map *lock)
{
  #line 361 
  return lock_is_held_type(lock,-1);
}

#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_api_smp.h"
#line 22 
void _raw_spin_lock(raw_spinlock_t *);
#line 39 
#line 39 
void _raw_spin_unlock(raw_spinlock_t *);
#line 336  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_lock(spinlock_t *lock)
{
  #line 338 
  _raw_spin_lock(& lock->__anonCompField_spinlock_25.rlock);
  #line 339 
  return;
}

#line 340 
#line 702  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_spin_lock__xmit_lock_of_netdev_queue(spinlock_t *lock);
#line 341  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_lock_bh_1(spinlock_t *lock)
{
  #line 343 
  _raw_spin_lock_bh(& lock->__anonCompField_spinlock_25.rlock);
  #line 344 
  return;
}

#line 345 
#line 1015  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(spinlock_t *lock);
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_unlock(spinlock_t *lock)
{
  #line 378 
  _raw_spin_unlock(& lock->__anonCompField_spinlock_25.rlock);
  #line 379 
  return;
}

#line 380 
#line 742  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_spin_unlock__xmit_lock_of_netdev_queue(spinlock_t *lock);
#line 381  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_unlock_bh_1(spinlock_t *lock)
{
  #line 383 
  _raw_spin_unlock_bh(& lock->__anonCompField_spinlock_25.rlock);
  #line 384 
  return;
}

#line 385 
#line 1024  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(spinlock_t *lock);
#line 26 
#line 1057 
static void cif_mutex_lock_switch_mutex_of_i40e_pf(struct mutex *lock);
#line 27  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/bitmap.h"
#line 27 
void ldv_bitmap_zero(unsigned long *dst, unsigned int nbits);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/list.h"
#line 23 
void ldv_init_list_head(struct list_head *list);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 24 
void *ldv_kmalloc(size_t size, gfp_t flags);
#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcupdate.h"
#line 40 
void synchronize_rcu(void);
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcutree.h"
#line 36 
void kfree_call_rcu(struct callback_head *, void (*)(struct callback_head *));
#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mutex.h"
#line 86 
void mutex_destroy(struct mutex *);
#line 185 
#line 1064  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_mutex_unlock_switch_mutex_of_i40e_pf(struct mutex *lock);
#line 90  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
#line 90 
void init_timer_key(struct timer_list *, void (*)(struct timer_list *), unsigned int, char *, struct lock_class_key *);
#line 173 
#line 1049  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static int cif_mod_timer(struct timer_list *timer, unsigned long expires);
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
#line 1103  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static int cif_del_timer_sync(struct timer_list *timer);
#line 209  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
#line 209 
unsigned long round_jiffies(unsigned long);
#line 207  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/workqueue.h"
#line 207 
void __init_work(struct work_struct *, int);
#line 407 
#line 407 
struct workqueue_struct *alloc_workqueue(char *, unsigned int, int , ...);
#line 436 
#line 436 
void destroy_workqueue(struct workqueue_struct *);
#line 462 
#line 462 
bool cancel_work_sync(struct work_struct *);
#line 496 
#line 460  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static bool cif_queue_work(struct workqueue_struct *wq, struct work_struct *work);
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static u64 readq(void *addr)
{
  #line 95 
  u64 ret;
  #line 96 
  ldv_inline_asm();
  #line 95 
  return ret;
}

#line 206 
#line 206 
void *ioremap(resource_size_t, unsigned long);
#line 209 
#line 209 
void iounmap(void *);
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hash.h"
__inline static u32 hash_64_generic(u64 val, unsigned int bits)
{
  #line 81 
  return (unsigned int)(val * 7046029254386353131ULL >> (64U - bits));
}

#line 542  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 549  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void *kmalloc(size_t size, gfp_t flags);
#line 607  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 563  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void *kcalloc_0(size_t n, size_t size, gfp_t flags);
#line 668  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 584  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void *kzalloc_1(size_t size, gfp_t flags);
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/random.h"
#line 38 
void get_random_bytes(void *, int);
#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm_wakeup.h"
#line 108 
int device_set_wakeup_enable(struct device *, bool);
#line 1422  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev, void *data)
{
  #line 1424 
  dev->driver_data = data;
  #line 1425 
  return;
}

#line 1716 
#line 1716 
void _dev_notice(struct device *, char * , ...);
#line 460  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
#line 460 
int dma_set_mask(struct device *, u64);
#line 461 
#line 461 
int dma_set_coherent_mask(struct device *, u64);
#line 669  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static int dma_set_mask_and_coherent(struct device *dev, u64 mask)
{
  #line 671 
  int rc = dma_set_mask(dev,mask);
  #line 672 
  if (rc == 0) 
               #line 673 
               dma_set_coherent_mask(dev,mask);
  #line 674 
  return rc;
}

#line 332  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_dissector.h"
__inline static bool dissector_uses_key(struct flow_dissector *flow_dissector, enum flow_dissector_key_id key_id)
{
  #line 335 
  return (_Bool)((flow_dissector->used_keys & (unsigned int)(1 << (unsigned int)key_id)) != 0U);
}

#line 158  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/u64_stats_sync.h"
__inline static unsigned int __u64_stats_fetch_begin(struct u64_stats_sync *syncp)
{
  #line 163 
  return 0U;
}

#line 175  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/u64_stats_sync.h"
__inline static bool __u64_stats_fetch_retry(struct u64_stats_sync *syncp, unsigned int start)
{
  #line 181 
  return (_Bool)0;
}

#line 200  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/u64_stats_sync.h"
__inline static unsigned int u64_stats_fetch_begin_irq(struct u64_stats_sync *syncp)
{
  #line 205 
  return __u64_stats_fetch_begin(syncp);
}

#line 208  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/u64_stats_sync.h"
__inline static bool u64_stats_fetch_retry_irq(struct u64_stats_sync *syncp, unsigned int start)
{
  #line 214 
  return __u64_stats_fetch_retry(syncp,start);
}

#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hardirq.h"
#line 12 
void synchronize_irq(unsigned int);
#line 162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/interrupt.h"
#line 1033  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static int cif_request_irq(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char *name, void *dev);
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/interrupt.h"
#line 1041  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void *cif_free_irq(unsigned int ldv_func_arg1, void *ldv_func_arg2);
#line 352  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/interrupt.h"
#line 352 
int irq_set_affinity_hint(unsigned int, struct cpumask *);
#line 355 
#line 355 
int irq_set_affinity_notifier(unsigned int, struct irq_affinity_notify *);
#line 818  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
#line 818 
void bpf_prog_put(struct bpf_prog *);
#line 152  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
#line 152 
int xdp_rxq_info_reg_mem_model(struct xdp_rxq_info *, enum xdp_mem_type, void *);
#line 154 
#line 154 
void xdp_rxq_info_unreg_mem_model(struct xdp_rxq_info *);
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hashtable.h"
__inline static void __hash_init(struct hlist_head *ht, unsigned int sz)
{
  #line 36 
  unsigned int i;
  #line 38 
  i = 0U;
  #line 38 
  while (i < sz) {
    #line 39 
    (ht + (unsigned long)i)->first = (struct hlist_node *)0;
    #line 38 
    i ++;
  }
  #line 40 
  return;
}

#line 105  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hashtable.h"
__inline static void hash_del(struct hlist_node *node)
{
  #line 107 
  hlist_del_init(node);
  #line 108 
  return;
}

#line 424  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
#line 424 
void __napi_schedule_irqoff(struct napi_struct *);
#line 431 
#line 431 
bool napi_schedule_prep(struct napi_struct *);
#line 452  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void napi_schedule_irqoff(struct napi_struct *n)
{
  #line 454 
  if ((int)napi_schedule_prep(n) != 0) 
                                       #line 455 
                                       __napi_schedule_irqoff(n);
  #line 456 
  return;
}

#line 503 
#line 503 
void napi_disable(struct napi_struct *);
#line 512  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n)
{
  #line 514 
  int tmp_0;
  #line 514 
  if (test_bit(0L,& n->state)) 
                               #line 514 
                               tmp_0 = 0; else 
                                               #line 514 
                                               tmp_0 = 1;
  #line 514 
  if ((long)tmp_0 != 0L) {
    #line 515 
    ldv_inline_asm();
    #line 516 
    ldv_inline_asm();
    #line 517 
    ldv_inline_asm();
    #line 514 
    ;
  }
  #line 516 
  cif_clear_bit_1(0L,& n->state);
  #line 517 
  cif_clear_bit_1(3L,& n->state);
  #line 518 
  return;
}

#line 2100  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static int netdev_set_prio_tc_map(struct net_device *dev, u8 prio, u8 tc)
{
  #line 2102 
  if ((int)tc >= (int)dev->num_tc) 
                                   #line 2103 
                                   return -22;
  #line 2105 
  dev->prio_tc_map[(int)prio & 15] = (unsigned char)((unsigned int)tc & 15U);
  #line 2106 
  return 0;
}

#line 2110 
#line 2110 
void netdev_reset_tc(struct net_device *);
#line 2111 
#line 2111 
int netdev_set_tc_queue(struct net_device *, u8, u16, u16);
#line 2112 
#line 2112 
int netdev_set_num_tc(struct net_device *, u8);
#line 2115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static int netdev_get_num_tc(struct net_device *dev)
{
  #line 2117 
  return (int)dev->num_tc;
}

#line 2120 
#line 2120 
void netdev_unbind_sb_channel(struct net_device *, struct net_device *);
#line 2122 
#line 2122 
int netdev_bind_sb_channel_queue(struct net_device *, struct net_device *, u8, u16, u16);
#line 2125 
#line 2125 
int netdev_set_sb_channel(struct net_device *, u16);
#line 2234 
#line 2234 
void netif_napi_add(struct net_device *, struct napi_struct *, int (*)(struct napi_struct *, int ), int);
#line 2263 
#line 2263 
void netif_napi_del(struct napi_struct *);
#line 2579 
#line 2579 
int call_netdevice_notifiers(unsigned long, struct net_device *);
#line 2679 
#line 1087  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_free_netdev(struct net_device *dev);
#line 3104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_tx_start_queue_0(struct netdev_queue *dev_queue)
{
  #line 3106 
  cif_clear_bit_1(0L,& dev_queue->state);
  #line 3107 
  return;
}

#line 3120  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_tx_start_all_queues(struct net_device *dev)
{
  #line 3122 
  unsigned int i;
  #line 3124 
  i = 0U;
  #line 3124 
  while (dev->num_tx_queues > i) {
    {
      #line 3125 
      struct netdev_queue *txq = netdev_get_tx_queue(dev,i);
      #line 3126 
      netif_tx_start_queue_0(txq);
    }
    #line 3124 
    i ++;
  }
  #line 3128 
  return;
}

#line 3144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_tx_wake_all_queues(struct net_device *dev)
{
  #line 3146 
  unsigned int i;
  #line 3148 
  i = 0U;
  #line 3148 
  while (dev->num_tx_queues > i) {
    {
      #line 3149 
      struct netdev_queue *txq = netdev_get_tx_queue(dev,i);
      #line 3150 
      netif_tx_wake_queue(txq);
    }
    #line 3148 
    i ++;
  }
  #line 3152 
  return;
}

#line 3154  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_tx_stop_queue_0(struct netdev_queue *dev_queue)
{
  #line 3156 
  cif_set_bit_1(0L,& dev_queue->state);
  #line 3157 
  return;
}

#line 3171 
#line 3171 
void netif_tx_stop_all_queues(struct net_device *);
#line 3387  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netif_running(struct net_device *dev)
{
  #line 3389 
  return test_bit(0L,& dev->state);
}

#line 3462 
#line 3462 
int netif_set_xps_queue(struct net_device *, struct cpumask *, u16);
#line 3572  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netif_is_multiqueue(struct net_device *dev)
{
  #line 3574 
  return (_Bool)(dev->num_tx_queues > 1U);
}

#line 3577 
#line 3577 
int netif_set_real_num_tx_queues(struct net_device *, unsigned int);
#line 3580 
#line 3580 
int netif_set_real_num_rx_queues(struct net_device *, unsigned int);
#line 3812 
#line 3812 
void netif_carrier_on(struct net_device *);
#line 3814 
#line 3814 
void netif_carrier_off(struct net_device *);
#line 3923  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static u32 netif_msg_init(int debug_value, int default_msg_enable_bits)
{
  #line 3926 
  if ((unsigned int)debug_value > 31U) 
                                       #line 3927 
                                       return (unsigned int)default_msg_enable_bits;
  #line 3928 
  if (debug_value == 0) 
                        #line 3929 
                        return 0U;
  #line 3931 
  return (1U << debug_value) + 4294967295U;
}

#line 3934  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq, int cpu)
{
  #line 3936 
  cif_spin_lock__xmit_lock_of_netdev_queue(& txq->_xmit_lock);
  #line 3937 
  txq->xmit_lock_owner = cpu;
  #line 3938 
  return;
}

#line 3965  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq)
{
  #line 3967 
  txq->xmit_lock_owner = -1;
  #line 3968 
  cif_spin_unlock__xmit_lock_of_netdev_queue(& txq->_xmit_lock);
  #line 3969 
  return;
}

#line 4070  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_tx_disable(struct net_device *dev)
{
  #line 4076 
  int pscr_ret__;
  #line 4072 
  unsigned int i;
  #line 4073 
  int cpu;
  #line 4075 
  local_bh_disable();
  #line 4076 
  __this_cpu_preempt_check((char *)"read");
  {
    #line 4076 
    void *__vpp_verify = (void *)0;
    #line 4076 
    void *tmp = __vpp_verify;
  }
  #line 4076 
  switch (4UL) {
    #line 4076 
    int pfo_ret___1;
    #line 4076 
    int pfo_ret___2;
    #line 4076 
    int pfo_ret__;
    #line 4076 
    int pfo_ret___0;
    #line 4076 
    case (unsigned long)1: 
                           #line 4076 
    ;
    #line 4076 
    switch (4UL) {
      #line 4076 
      case (unsigned long)1: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)2: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)4: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)8: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      default: 
               #line 4076 
      ;
      #line 4076 
      __bad_percpu_size();
    }
    #line 4076 
    pscr_ret__ = pfo_ret__;
    #line 4076 
    break;
    #line 4076 
    case (unsigned long)2: 
                           #line 4076 
    ;
    #line 4076 
    switch (4UL) {
      #line 4076 
      case (unsigned long)1: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)2: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)4: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)8: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      default: 
               #line 4076 
      ;
      #line 4076 
      __bad_percpu_size();
    }
    #line 4076 
    pscr_ret__ = pfo_ret___0;
    #line 4076 
    break;
    #line 4076 
    case (unsigned long)4: 
                           #line 4076 
    ;
    #line 4076 
    switch (4UL) {
      #line 4076 
      case (unsigned long)1: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)2: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)4: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)8: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      default: 
               #line 4076 
      ;
      #line 4076 
      __bad_percpu_size();
    }
    #line 4076 
    pscr_ret__ = pfo_ret___1;
    #line 4076 
    break;
    #line 4076 
    case (unsigned long)8: 
                           #line 4076 
    ;
    #line 4076 
    switch (4UL) {
      #line 4076 
      case (unsigned long)1: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)2: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)4: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      case (unsigned long)8: 
                             #line 4076 
      ;
      #line 4077 
      ldv_inline_asm();
      #line 4076 
      break;
      #line 4076 
      default: 
               #line 4076 
      ;
      #line 4076 
      __bad_percpu_size();
    }
    #line 4076 
    pscr_ret__ = pfo_ret___2;
    #line 4076 
    break;
    #line 4076 
    default: 
             #line 4076 
    ;
    #line 4076 
    __bad_size_call_parameter();
    #line 4076 
    break;
  }
  #line 4076 
  cpu = pscr_ret__;
  #line 4077 
  i = 0U;
  #line 4077 
  while (dev->num_tx_queues > i) {
    {
      #line 4078 
      struct netdev_queue *txq = netdev_get_tx_queue(dev,i);
      #line 4080 
      __netif_tx_lock(txq,cpu);
      #line 4081 
      netif_tx_stop_queue_0(txq);
      #line 4082 
      __netif_tx_unlock(txq);
    }
    #line 4077 
    i ++;
  }
  #line 4084 
  local_bh_enable();
  #line 4085 
  return;
}

#line 4131 
#line 1095  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static int cif_register_netdev(struct net_device *dev);
#line 4132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
#line 1079  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_unregister_netdev(struct net_device *dev);
#line 4137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
#line 4137 
int __hw_addr_sync_dev(struct netdev_hw_addr_list *, struct net_device *, int (*)(struct net_device *, unsigned char *), int (*)(struct net_device *, unsigned char *));
#line 4152 
#line 4152 
void __hw_addr_unsync_dev(struct netdev_hw_addr_list *, struct net_device *, int (*)(struct net_device *, unsigned char *));
#line 4167 
#line 4167 
int dev_uc_add(struct net_device *, unsigned char *);
#line 4168 
#line 4168 
int dev_uc_add_excl(struct net_device *, unsigned char *);
#line 4186  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static int __dev_uc_sync(struct net_device *dev, int (*sync)(struct net_device *, unsigned char *), int (*unsync)(struct net_device *, unsigned char *))
{
  #line 4192 
  return __hw_addr_sync_dev(& dev->uc,dev,sync,unsync);
}

#line 4202  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void __dev_uc_unsync(struct net_device *dev, int (*unsync)(struct net_device *, unsigned char *))
{
  #line 4206 
  __hw_addr_unsync_dev(& dev->uc,dev,unsync);
  #line 4207 
  return;
}

#line 4212 
#line 4212 
int dev_mc_add_excl(struct net_device *, unsigned char *);
#line 4230  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static int __dev_mc_sync(struct net_device *dev, int (*sync)(struct net_device *, unsigned char *), int (*unsync)(struct net_device *, unsigned char *))
{
  #line 4236 
  return __hw_addr_sync_dev(& dev->mc,dev,sync,unsync);
}

#line 4246  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void __dev_mc_unsync(struct net_device *dev, int (*unsync)(struct net_device *, unsigned char *))
{
  #line 4250 
  __hw_addr_unsync_dev(& dev->mc,dev,unsync);
  #line 4251 
  return;
}

#line 4371 
#line 4371 
void netdev_rss_key_fill(void *, size_t);
#line 4750 
#line 4750 
void netdev_err(struct net_device *, char * , ...);
#line 4752 
#line 4752 
void netdev_warn(struct net_device *, char * , ...);
#line 4756 
#line 4756 
void netdev_info(struct net_device *, char * , ...);
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
#line 28 
int eth_platform_get_mac_address(struct device *, u8 *);
#line 47 
#line 47 
int eth_validate_addr(struct net_device *);
#line 51 
#line 1071  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static struct net_device *cif_alloc_etherdev_mqs(int sizeof_priv, unsigned int txqs, unsigned int rxqs);
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
static u8 eth_reserved_addr_base[6U] = {(unsigned char)1U, (unsigned char)128U, (unsigned char)194U};
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool is_link_local_ether_addr(u8 *addr)
{
  #line 78 
  __be16 *a = (__be16 *)addr;
  #line 79 
  __be16 *b = (__be16 *)(& eth_reserved_addr_base);
  #line 80 
  __be16 m = (unsigned short)61695U;
  #line 84 
  return (_Bool)(((*((u32 *)addr) ^ *((u32 *)b)) | ((unsigned int)((int)*(a + 2U) ^ (int)*(b + 2U)) & 61695U)) == 0U);
}

#line 175  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool is_unicast_ether_addr(u8 *addr)
{
  #line 177 
  int tmp_0;
  #line 177 
  if ((int)is_multicast_ether_addr(addr) != 0) 
                                               #line 177 
                                               tmp_0 = 0; else 
                                                               #line 177 
                                                               tmp_0 = 1;
  #line 177 
  return (_Bool)(tmp_0 != 0);
}

#line 223  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static void eth_random_addr(u8 *addr)
{
  #line 225 
  get_random_bytes((void *)addr,6);
  #line 226 
  *addr = (unsigned char)((unsigned int)*addr & 254U);
  #line 227 
  *addr = (unsigned char)((unsigned int)*addr | 2U);
  #line 228 
  return;
}

#line 1083  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
#line 1083 
int pci_read_config_byte(struct pci_dev *, int, u8 *);
#line 1090 
#line 1090 
int pcie_capability_read_word(struct pci_dev *, int, u16 *);
#line 1133 
#line 1133 
int pci_enable_device_mem(struct pci_dev *);
#line 1157 
#line 1157 
void pci_disable_device(struct pci_dev *);
#line 1160 
#line 1160 
void pci_set_master(struct pci_dev *);
#line 1202 
#line 1202 
int pci_select_bars(struct pci_dev *, unsigned long);
#line 1219 
#line 1219 
int pci_save_state(struct pci_dev *);
#line 1220 
#line 1220 
void pci_restore_state(struct pci_dev *);
#line 1233 
#line 1233 
int pci_set_power_state(struct pci_dev *, pci_power_t);
#line 1238 
#line 1238 
int pci_wake_from_d3(struct pci_dev *, bool);
#line 1286 
#line 1286 
int pci_request_selected_regions(struct pci_dev *, int, char *);
#line 1288 
#line 1288 
void pci_release_selected_regions(struct pci_dev *, int);
#line 1346 
#line 1111  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static int cif___pci_register_driver(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char *mod_name);
#line 1352  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
#line 1119  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_pci_unregister_driver(struct pci_driver *dev);
#line 1431  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
#line 1431 
void pci_disable_msi(struct pci_dev *);
#line 1433 
#line 1433 
void pci_disable_msix(struct pci_dev *);
#line 1436 
#line 1436 
int pci_enable_msi(struct pci_dev *);
#line 1437 
#line 1437 
int pci_enable_msix_range(struct pci_dev *, struct msix_entry *, int, int);
#line 1626  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static int pci_request_mem_regions(struct pci_dev *pdev, char *name)
{
  #line 1628 
  ;
  #line 1628 
  ;
  #line 1628 
  return pci_request_selected_regions(pdev,pci_select_bars(pdev,512UL),name);
}

#line 1633  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static void pci_release_mem_regions(struct pci_dev *pdev)
{
  #line 1635 
  ;
  #line 1635 
  pci_release_selected_regions(pdev,pci_select_bars(pdev,512UL));
  #line 1637 
  return;
}

#line 1838  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev, void *data)
{
  #line 1840 
  dev_set_drvdata(& pdev->dev,data);
  #line 1841 
  return;
}

#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rtnetlink.h"
#line 33 
void rtnl_lock(void);
#line 34 
#line 34 
void rtnl_unlock(void);
#line 36 
#line 36 
int rtnl_is_locked(void);
#line 130 
#line 130 
int ndo_dflt_bridge_getlink(struct sk_buff *, u32, u32, struct net_device *, u16, u32, u32, int, u32, int (*)(struct sk_buff *, struct net_device *, u32 ));
#line 441  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
#line 441 
struct nlattr *nla_find(struct nlattr *, int, int);
#line 501  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static void *nlmsg_data(struct nlmsghdr *nlh)
{
  #line 503 
  return (void *)((unsigned char *)nlh + 16U);
}

#line 510  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static int nlmsg_len(struct nlmsghdr *nlh)
{
  #line 512 
  return (int)(nlh->nlmsg_len + 4294967280U);
}

#line 520  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static struct nlattr *nlmsg_attrdata(struct nlmsghdr *nlh, int hdrlen)
{
  #line 523 
  unsigned char *data = nlmsg_data(nlh);
  #line 524 
  return (struct nlattr *)(data + ((unsigned long)((unsigned int)hdrlen + 3U) & (unsigned long)4294967292U));
}

#line 532  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static int nlmsg_attrlen(struct nlmsghdr *nlh, int hdrlen)
{
  #line 534 
  ;
  #line 534 
  return (int)((unsigned int)nlmsg_len(nlh) - (((unsigned int)hdrlen + 3U) & 4294967292U));
}

#line 738  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static struct nlattr *nlmsg_find_attr(struct nlmsghdr *nlh, int hdrlen, int attrtype)
{
  #line 741 
  ;
  #line 741 
  return nla_find(nlmsg_attrdata(nlh,hdrlen),nlmsg_attrlen(nlh,hdrlen),
                 attrtype);
}

#line 1063  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static int nla_type(struct nlattr *nla)
{
  #line 1065 
  return (int)nla->nla_type & -49153;
}

#line 1072  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static void *nla_data(struct nlattr *nla)
{
  #line 1074 
  return (void *)((char *)nla + 4U);
}

#line 1081  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static int nla_len(struct nlattr *nla)
{
  #line 1083 
  return (int)nla->nla_len + -4;
}

#line 1091  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static int nla_ok(struct nlattr *nla, int remaining)
{
  #line 1094 
  return ((remaining > 3 && (unsigned int)nla->nla_len > 3U) && (int)nla->nla_len <= remaining) != 0;
}

#line 1106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static struct nlattr *nla_next(struct nlattr *nla, int *remaining)
{
  #line 1108 
  unsigned int totlen = (unsigned int)((int)nla->nla_len + 3) & 4294967292U;
  #line 1110 
  *remaining = (int)((unsigned int)*remaining - totlen);
  #line 1111 
  return (struct nlattr *)((char *)nla + (unsigned long)totlen);
}

#line 1499  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netlink.h"
__inline static u16 nla_get_u16(struct nlattr *nla)
{
  #line 1501 
  return *((u16 *)nla_data(nla));
}

#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
#line 75 
void flow_rule_match_basic(struct flow_rule *, struct flow_match_basic *);
#line 77 
#line 77 
void flow_rule_match_control(struct flow_rule *, struct flow_match_control *);
#line 79 
#line 79 
void flow_rule_match_eth_addrs(struct flow_rule *, struct flow_match_eth_addrs *);
#line 81 
#line 81 
void flow_rule_match_vlan(struct flow_rule *, struct flow_match_vlan *);
#line 85 
#line 85 
void flow_rule_match_ipv4_addrs(struct flow_rule *, struct flow_match_ipv4_addrs *);
#line 87 
#line 87 
void flow_rule_match_ipv6_addrs(struct flow_rule *, struct flow_match_ipv6_addrs *);
#line 91 
#line 91 
void flow_rule_match_ports(struct flow_rule *, struct flow_match_ports *);
#line 109 
#line 109 
void flow_rule_match_enc_keyid(struct flow_rule *, struct flow_match_enc_keyid *);
#line 250  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
__inline static bool flow_rule_match_key(struct flow_rule *rule, enum flow_dissector_key_id key)
{
  #line 253 
  return dissector_uses_key(rule->match.dissector,key);
}

#line 340 
#line 340 
int flow_block_cb_setup_simple(struct flow_block_offload *, struct list_head *, flow_setup_cb_t *, void *, void *, bool);
#line 370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/flow_offload.h"
__inline static struct flow_rule *flow_cls_offload_flow_rule(struct flow_cls_offload *flow_cmd)
{
  #line 372 
  return flow_cmd->rule;
}

#line 615  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/sch_generic.h"
__inline static int tc_classid_to_hwtc(struct net_device *dev, u32 classid)
{
  #line 619 
  int tmp_0;
  #line 617 
  u32 hwtc = (classid & 65535U) + 4294901792U;
  #line 619 
  ;
  #line 619 
  if ((unsigned int)netdev_get_num_tc(dev) > hwtc) 
                                                   #line 619 
                                                   tmp_0 = (int)hwtc; else 
                                                                    #line 619 
                                                                    tmp_0 = -22;
  #line 619 
  return tmp_0;
}

#line 635  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ipv6.h"
__inline static bool ipv6_addr_any(struct in6_addr *a)
{
  #line 638 
  unsigned long *ul = (unsigned long *)a;
  #line 640 
  return (_Bool)((*ul | *(ul + 1U)) == 0UL);
}

#line 671  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/ipv6.h"
__inline static bool ipv6_addr_loopback(struct in6_addr *a)
{
  #line 674 
  __be64 *be = (__be64 *)a;
  #line 676 
  return (_Bool)((*be | (*(be + 1U) ^ 72057594037927936ULL)) == 0ULL);
}

#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/aer.h"
#line 45 
int pci_enable_pcie_error_reporting(struct pci_dev *);
#line 46 
#line 46 
int pci_disable_pcie_error_reporting(struct pci_dev *);
#line 100  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_macvlan.h"
__inline static int macvlan_release_l2fw_offload(struct net_device *dev)
{
  #line 102 
  struct macvlan_dev *macvlan = netdev_priv(dev);
  #line 104 
  macvlan->accel_priv = (void *)0;
  #line 105 
  return dev_uc_add(macvlan->lowerdev,dev->dev_addr);
}

#line 565  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
__inline static bool tc_can_offload(struct net_device *dev)
{
  #line 567 
  return (_Bool)((dev->features & 281474976710656ULL) != 0ULL);
}

#line 570  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
__inline static bool tc_can_offload_extack(struct net_device *dev, struct netlink_ext_ack *extack)
{
  #line 573 
  bool can = tc_can_offload(dev);
  #line 575 
  if (! can) {
    #line 576 
    char __msg[37U] = {(char)'T', (char)'C', (char)' ', (char)'o', (char)'f', (char)'f', (char)'l', (char)'o', (char)'a', (char)'d', (char)' ', (char)'i', (char)'s', (char)' ', (char)'d', (char)'i', (char)'s', (char)'a', (char)'b', (char)'l', (char)'e', (char)'d', (char)' ', (char)'o', (char)'n', (char)' ', (char)'n', (char)'e', (char)'t', (char)' ', (char)'d', (char)'e', (char)'v', (char)'i', (char)'c', (char)'e', (char)'\000'};
    #line 576 
    struct netlink_ext_ack *__extack = extack;
    #line 576 
    if (__extack != (struct netlink_ext_ack *)0) 
                                                 #line 576 
                                                 __extack->_msg = (char *)(& __msg);
  }
  #line 578 
  return can;
}

#line 582  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/pkt_cls.h"
__inline static bool tc_cls_can_offload_and_chain0(struct net_device *dev, struct flow_cls_common_offload *common)
{
  #line 585 
  if (! tc_can_offload_extack(dev,common->extack)) 
                                                   #line 586 
                                                   return (_Bool)0;
  #line 587 
  if (common->chain_index != 0U) {
    {
      #line 588 
      char __msg[40U] = {(char)'D', (char)'r', (char)'i', (char)'v', (char)'e', (char)'r', (char)' ', (char)'s', (char)'u', (char)'p', (char)'p', (char)'o', (char)'r', (char)'t', (char)'s', (char)' ', (char)'o', (char)'n', (char)'l', (char)'y', (char)' ', (char)'o', (char)'f', (char)'f', (char)'l', (char)'o', (char)'a', (char)'d', (char)' ', (char)'o', (char)'f', (char)' ', (char)'c', (char)'h', (char)'a', (char)'i', (char)'n', (char)' ', (char)'0', (char)'\000'};
      #line 588 
      struct netlink_ext_ack *__extack = common->extack;
      #line 588 
      if (__extack != (struct netlink_ext_ack *)0) 
                                                   #line 588 
                                                   __extack->_msg = (char *)(& __msg);
    }
    #line 590 
    return (_Bool)0;
  }
  #line 592 
  return (_Bool)1;
}

#line 131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
#line 131 
struct xdp_umem *xdp_get_umem_from_qid(struct net_device *, u16);
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.h"
__inline static int i40e_aq_rc_to_posix(int aq_ret, int aq_rc)
{
  #line 93 
  int aq_to_posix[23U] = {0, -1, -2, -3, -4, -5, -6, -7, -11, -12, -13, -14, -16, -17, -22, -25, -28, -38, -34, -32, -29, -30, -27};
  #line 120 
  if (aq_ret == -54) 
                     #line 121 
                     return -11;
  #line 123 
  if ((unsigned int)aq_rc > 22U) 
                                 #line 124 
                                 return -34;
  #line 126 
  return aq_to_posix[aq_rc];
}

#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 19 
i40e_status i40e_init_adminq(struct i40e_hw *hw);
#line 20 
#line 20 
i40e_status i40e_shutdown_adminq(struct i40e_hw *hw);
#line 22 
#line 22 
i40e_status i40e_clean_arq_element(struct i40e_hw *hw, struct i40e_arq_event_info *e, u16 *pending);
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static u16 i40e_intrl_usec_to_reg(int intrl)
{
  #line 50 
  if (intrl >> 2 != 0) 
                       #line 51 
                       return (unsigned short)((intrl >> 2) | 64); else 
                                                                    #line 53 
                                                                    return (unsigned short)0U;
}

#line 430  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static void set_ring_build_skb_enabled(struct i40e_ring *ring)
{
  #line 432 
  ring->flags = (unsigned short)((unsigned int)ring->flags | 2U);
  #line 433 
  return;
}

#line 435  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static void clear_ring_build_skb_enabled(struct i40e_ring *ring)
{
  #line 437 
  ring->flags = (unsigned short)((unsigned int)ring->flags & 65533U);
  #line 438 
  return;
}

#line 445  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx.h"
__inline static void set_ring_xdp(struct i40e_ring *ring)
{
  #line 447 
  ring->flags = (unsigned short)((unsigned int)ring->flags | 4U);
  #line 448 
  return;
}

#line 128  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.h"
#line 128 
i40e_status i40e_aq_get_dcb_config(struct i40e_hw *hw, u8 mib_type, u8 bridgetype, struct i40e_dcbx_config *dcbcfg);
#line 131 
#line 131 
i40e_status i40e_get_dcb_config(struct i40e_hw *hw);
#line 132 
#line 132 
i40e_status i40e_init_dcb(struct i40e_hw *hw, bool enable_mib_change);
#line 440  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static bool i40e_is_channel_macvlan(struct i40e_channel *ch)
{
  #line 442 
  return (_Bool)(ch->fwd != (struct i40e_fwd_adapter *)0);
}

#line 445  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static u8 *i40e_channel_mac(struct i40e_channel *ch)
{
  #line 447 
  if ((int)i40e_is_channel_macvlan(ch) != 0) 
                                             #line 448 
                                             return ((ch->fwd)->netdev)->dev_addr; else 
                                                                    #line 450 
                                                                    return (u8 *)0U;
}

#line 666  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static u64 i40e_addr_to_hkey(u8 *macaddr)
{
  #line 668 
  u64 key = 0ULL;
  #line 670 
  ether_addr_copy((u8 *)(& key),macaddr);
  #line 671 
  return key;
}

#line 887  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static char *i40e_nvm_version_str(struct i40e_hw *hw)
{
  #line 889 
  char buf[32U];
  #line 890 
  u32 full_ver;
  #line 892 
  full_ver = hw->nvm.oem_ver;
  #line 894 
  if (hw->nvm.eetrack == 4294967295U) {
    #line 895 
    u8 gen;
    #line 895 
    u8 snap;
    #line 896 
    u16 release;
    #line 898 
    gen = (unsigned char)(full_ver >> 24);
    #line 899 
    snap = (unsigned char)(full_ver >> 16);
    #line 901 
    release = (unsigned short)full_ver;
    #line 903 
    snprintf((char *)(& buf),32UL,(char *)"%x.%x.%x",(int)gen,(int)snap,(int)release);
  }
  else {
    #line 905 
    u8 ver;
    #line 905 
    u8 patch;
    #line 906 
    u16 build;
    #line 908 
    ver = (unsigned char)(full_ver >> 24);
    #line 909 
    build = (unsigned short)(full_ver >> 8);
    #line 911 
    patch = (unsigned char)full_ver;
    #line 913 
    snprintf((char *)(& buf),32UL,(char *)"%x.%02x 0x%x %d.%d.%d",(int)hw->nvm.version >> 12,(int)hw->nvm.version & 255,hw->nvm.eetrack,(int)ver,(int)build,(int)patch);
  }
  #line 922 
  return (char *)(& buf);
}

#line 939  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static void i40e_vsi_setup_irqhandler(struct i40e_vsi *vsi, irqreturn_t (*irq_handler)(int , void *))
{
  #line 942 
  vsi->irq_handler = irq_handler;
  #line 943 
  return;
}

#line 982  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static void i40e_write_fd_input_set(struct i40e_pf *pf, u16 addr, u64 val)
{
  #line 985 
  i40e_write_rx_ctl(& pf->hw,(unsigned int)((int)addr * 64 + 2424864),(unsigned int)(val >> 32));
  #line 987 
  i40e_write_rx_ctl(& pf->hw,(unsigned int)(((int)addr + 37888) * 64),(unsigned int)val);
  #line 989 
  return;
}

#line 992 
#line 6698  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_up(struct i40e_vsi *vsi);
#line 993  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 6805  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_down(struct i40e_vsi *vsi);
#line 995  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
char i40e_driver_version_str[9U];
#line 997  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 8436  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_do_reset(struct i40e_pf *pf, u32 reset_flags, bool lock_acquired);
#line 999  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 11590  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_get_rss(struct i40e_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
#line 1000  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 11607  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_fill_rss_lut(struct i40e_pf *pf, u8 *lut, u16 rss_table_size, u16 rss_size);
#line 1022  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 1102  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_update_stats(struct i40e_vsi *vsi);
#line 1023  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_update_veb_stats(struct i40e_veb *veb);
#line 1025  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 401  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct rtnl_link_stats64 *i40e_get_vsi_stats_struct(struct i40e_vsi *vsi);
#line 1026  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 14190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_fetch_switch_configuration(struct i40e_pf *pf, bool printconfig);
#line 1031  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 8861  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_fdir_check_and_reenable(struct i40e_pf *pf);
#line 1032  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 8752  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
u32 i40e_get_current_fd_count(struct i40e_pf *pf);
#line 1033  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 8739  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
u32 i40e_get_cur_guaranteed_fd_count(struct i40e_pf *pf);
#line 1036  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 12047  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
bool i40e_set_ntuple(struct i40e_pf *pf, netdev_features_t features);
#line 1037  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 1037 
void i40e_set_ethtool_ops(struct net_device *netdev);
#line 1038 
#line 1370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct i40e_mac_filter *i40e_add_filter(struct i40e_vsi *vsi, u8 *macaddr, s16 vlan);
#line 1041  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 1465  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_del_filter(struct i40e_vsi *vsi, u8 *macaddr, s16 vlan);
#line 1057  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 11692  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count);
#line 1058  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 14030  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct i40e_veb *i40e_veb_setup(struct i40e_pf *pf, u16 flags, u16 uplink_seid, u16 vsi_seid, u8 enabled_tc);
#line 1060  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 13923  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_veb_release(struct i40e_veb *veb);
#line 1062  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 6321  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_veb_config_tc(struct i40e_veb *veb, u8 enabled_tc);
#line 1065  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 492  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_vsi_reset_stats(struct i40e_vsi *vsi);
#line 1066  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 524  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_pf_reset_stats(struct i40e_pf *pf);
#line 1068  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 1068 
void i40e_dbg_pf_init(struct i40e_pf *pf);
#line 1069 
#line 1069 
void i40e_dbg_pf_exit(struct i40e_pf *pf);
#line 1070 
#line 1070 
void i40e_dbg_init(void);
#line 1071 
#line 1071 
void i40e_dbg_exit(void);
#line 1079 
#line 1079 
int i40e_lan_add_device(struct i40e_pf *pf);
#line 1080 
#line 1080 
int i40e_lan_del_device(struct i40e_pf *pf);
#line 1081 
#line 1081 
void i40e_client_subtask(struct i40e_pf *pf);
#line 1082 
#line 1082 
void i40e_notify_client_of_l2_param_changes(struct i40e_vsi *vsi);
#line 1083 
#line 1083 
void i40e_notify_client_of_netdev_close(struct i40e_vsi *vsi, bool reset);
#line 1086 
#line 1086 
void i40e_client_update_msix_info(struct i40e_pf *pf);
#line 1093  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static void i40e_irq_dynamic_enable(struct i40e_vsi *vsi, int vector)
{
  #line 1097 
  u32 val;
  #line 1095 
  struct i40e_pf *pf = vsi->back;
  #line 1096 
  struct i40e_hw *hw = & pf->hw;
  #line 1099 
  val = 27U;
  #line 1102 
  writel(val,(void *)(hw->hw_addr + (unsigned long)(((vsi->base_vector + vector) + 53759) * 4)));
  #line 1103 
  return;
}

#line 1108 
#line 2683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);
#line 1109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 8207  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_open(struct net_device *netdev);
#line 1110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 8415  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_close(struct net_device *netdev);
#line 1111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 8251  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_vsi_open(struct i40e_vsi *vsi);
#line 1125  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 1125 
void i40e_dcbnl_flush_apps(struct i40e_pf *pf, struct i40e_dcbx_config *old_cfg, struct i40e_dcbx_config *new_cfg);
#line 1128 
#line 1128 
void i40e_dcbnl_set_all(struct i40e_vsi *vsi);
#line 1129 
#line 1129 
void i40e_dcbnl_setup(struct i40e_vsi *vsi);
#line 1130 
#line 8531  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
bool i40e_dcb_need_reconfig(struct i40e_pf *pf, struct i40e_dcbx_config *old_cfg, struct i40e_dcbx_config *new_cfg);
#line 1145  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 13064  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_is_vsi_uplink_mode_veb(struct i40e_vsi *vsi);
#line 1146  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 11737  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_get_partition_bw_setting(struct i40e_pf *pf);
#line 1147  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 11760  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_set_partition_bw_setting(struct i40e_pf *pf);
#line 1148  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 11780  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_commit_partition_bw_setting(struct i40e_pf *pf);
#line 1149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 6513  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_print_link_message(struct i40e_vsi *vsi, bool isup);
#line 1151  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 14550  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_set_fec_in_flags(u8 fec_cfg, u32 *flags);
#line 1153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static bool i40e_enabled_xdp_vsi_0(struct i40e_vsi *vsi)
{
  #line 1156 
  union __anonunion___u_8900 __u;
  #line 1155 
  __read_once_size((void *)(& vsi->xdp_prog),(void *)(& __u.__c),8);
  #line 1155 
  return (_Bool)((__u.__val) != (struct bpf_prog *)0);
}

#line 1158 
#line 6152  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_create_queue_channel(struct i40e_vsi *vsi, struct i40e_channel *ch);
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.h"
#line 12778  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_queue_pair_disable(struct i40e_vsi *vsi, int queue_pair);
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.h"
#line 12802  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_queue_pair_enable(struct i40e_vsi *vsi, int queue_pair);
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.h"
#line 13 
int i40e_xsk_umem_setup(struct i40e_vsi *vsi, struct xdp_umem *umem, u16 qid);
#line 15 
#line 15 
void i40e_zca_free(struct zero_copy_allocator *alloc, unsigned long handle);
#line 16 
#line 16 
bool i40e_alloc_rx_buffers_zc(struct i40e_ring *rx_ring, u16 count);
#line 21 
#line 21 
int i40e_xsk_wakeup(struct net_device *dev, u32 queue_id, u32 flags);
#line 128  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/udp_tunnel.h"
__inline static void udp_tunnel_get_rx_info(struct net_device *dev)
{
  {
    #line 130 
    bool __warned;
    #line 130 
    int __ret_warn_once = rtnl_is_locked() == 0;
    #line 130 
    if ((long)(__ret_warn_once != 0) != 0L && (long)(! __warned) != 0L) {
      #line 130 
      __warned = (_Bool)1;
      {
        #line 130 
        int __ret_warn_on = 1;
        #line 130 
        if ((long)(__ret_warn_on != 0) != 0L) {
          #line 130 
          __warn_printk((char *)"RTNL: assertion failed at %s (%d)\n",(char *)"./include/net/udp_tunnel.h",130);
          #line 131 
          ldv_inline_asm();
          #line 132 
          ldv_inline_asm();
        }
        #line 130 
        long tmp_2 = (long)(__ret_warn_on != 0);
      }
    }
    #line 130 
    long tmp_4 = (long)(__ret_warn_once != 0);
  }
  #line 131 
  call_netdevice_notifiers(28UL,dev);
  #line 132 
  return;
}

#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
static char __tpstrtab_i40e_clean_tx_irq[18U] = {(char)'i', (char)'4', (char)'0', (char)'e', (char)'_', (char)'c', (char)'l', (char)'e', (char)'a', (char)'n', (char)'_', (char)'t', (char)'x', (char)'_', (char)'i', (char)'r', (char)'q'};
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
struct tracepoint __tracepoint_i40e_clean_tx_irq = {.name = (char *)(& __tpstrtab_i40e_clean_tx_irq)};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
static char __tpstrtab_i40e_clean_tx_irq_unmap[24U] = {(char)'i', (char)'4', (char)'0', (char)'e', (char)'_', (char)'c', (char)'l', (char)'e', (char)'a', (char)'n', (char)'_', (char)'t', (char)'x', (char)'_', (char)'i', (char)'r', (char)'q', (char)'_', (char)'u', (char)'n', (char)'m', (char)'a', (char)'p'};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
struct tracepoint __tracepoint_i40e_clean_tx_irq_unmap = {.name = (char *)(& __tpstrtab_i40e_clean_tx_irq_unmap)};
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
static char __tpstrtab_i40e_clean_rx_irq[18U] = {(char)'i', (char)'4', (char)'0', (char)'e', (char)'_', (char)'c', (char)'l', (char)'e', (char)'a', (char)'n', (char)'_', (char)'r', (char)'x', (char)'_', (char)'i', (char)'r', (char)'q'};
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
struct tracepoint __tracepoint_i40e_clean_rx_irq = {.name = (char *)(& __tpstrtab_i40e_clean_rx_irq)};
#line 148  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
static char __tpstrtab_i40e_clean_rx_irq_rx[21U] = {(char)'i', (char)'4', (char)'0', (char)'e', (char)'_', (char)'c', (char)'l', (char)'e', (char)'a', (char)'n', (char)'_', (char)'r', (char)'x', (char)'_', (char)'i', (char)'r', (char)'q', (char)'_', (char)'r', (char)'x'};
#line 148  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
struct tracepoint __tracepoint_i40e_clean_rx_irq_rx = {.name = (char *)(& __tpstrtab_i40e_clean_rx_irq_rx)};
#line 182  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
static char __tpstrtab_i40e_xmit_frame_ring[21U] = {(char)'i', (char)'4', (char)'0', (char)'e', (char)'_', (char)'x', (char)'m', (char)'i', (char)'t', (char)'_', (char)'f', (char)'r', (char)'a', (char)'m', (char)'e', (char)'_', (char)'r', (char)'i', (char)'n', (char)'g'};
#line 182  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
struct tracepoint __tracepoint_i40e_xmit_frame_ring = {.name = (char *)(& __tpstrtab_i40e_xmit_frame_ring)};
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
static char __tpstrtab_i40e_xmit_frame_ring_drop[26U] = {(char)'i', (char)'4', (char)'0', (char)'e', (char)'_', (char)'x', (char)'m', (char)'i', (char)'t', (char)'_', (char)'f', (char)'r', (char)'a', (char)'m', (char)'e', (char)'_', (char)'r', (char)'i', (char)'n', (char)'g', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p'};
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_trace.h"
struct tracepoint __tracepoint_i40e_xmit_frame_ring_drop = {.name = (char *)(& __tpstrtab_i40e_xmit_frame_ring_drop)};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
char i40e_driver_name[5U] = {(char)'i', (char)'4', (char)'0', (char)'e'};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static char i40e_driver_string[50U] = {(char)'I', (char)'n', (char)'t', (char)'e', (char)'l', (char)'(', (char)'R', (char)')', (char)' ', (char)'E', (char)'t', (char)'h', (char)'e', (char)'r', (char)'n', (char)'e', (char)'t', (char)' ', (char)'C', (char)'o', (char)'n', (char)'n', (char)'e', (char)'c', (char)'t', (char)'i', (char)'o', (char)'n', (char)' ', (char)'X', (char)'L', (char)'7', (char)'1', (char)'0', (char)' ', (char)'N', (char)'e', (char)'t', (char)'w', (char)'o', (char)'r', (char)'k', (char)' ', (char)'D', (char)'r', (char)'i', (char)'v', (char)'e', (char)'r'};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
char i40e_driver_version_str[9U] = {(char)'2'};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static char i40e_copyright[45U] = {(char)'C', (char)'o', (char)'p', (char)'y', (char)'r', (char)'i', (char)'g', (char)'h', (char)'t', (char)' ', (char)'(', (char)'c', (char)')', (char)' ', (char)'2', (char)'0', (char)'1', (char)'3', (char)' ', (char)'-', (char)' ', (char)'2', (char)'0', (char)'1', (char)'9', (char)' ', (char)'I', (char)'n', (char)'t', (char)'e', (char)'l', (char)' ', (char)'C', (char)'o', (char)'r', (char)'p', (char)'o', (char)'r', (char)'a', (char)'t', (char)'i', (char)'o', (char)'n', (char)'.'};
#line 38 
#line 6681 
static void i40e_vsi_reinit_locked(struct i40e_vsi *vsi);
#line 39 
#line 10264 
static void i40e_handle_reset_warning(struct i40e_pf *pf, bool lock_acquired);
#line 40 
#line 13099 
static int i40e_add_vsi(struct i40e_vsi *vsi);
#line 41 
#line 13968 
static int i40e_add_veb(struct i40e_veb *veb, struct i40e_vsi *vsi);
#line 42 
#line 14247 
static int i40e_setup_pf_switch(struct i40e_pf *pf, bool reinit);
#line 43 
#line 11397 
static int i40e_setup_misc_vector(struct i40e_pf *pf);
#line 44 
#line 14359 
static void i40e_determine_queue_usage(struct i40e_pf *pf);
#line 45 
#line 14466 
static int i40e_setup_pf_filter_control(struct i40e_pf *pf);
#line 46 
#line 9814 
static void i40e_prep_for_reset(struct i40e_pf *pf, bool lock_acquired);
#line 47 
#line 9922 
static int i40e_reset(struct i40e_pf *pf);
#line 48 
#line 9945 
static void i40e_rebuild(struct i40e_pf *pf, bool reinit, bool lock_acquired);
#line 49 
#line 11357 
static int i40e_setup_misc_vector_for_recovery_mode(struct i40e_pf *pf);
#line 50 
#line 11303 
static int i40e_restore_interrupt_scheme(struct i40e_pf *pf);
#line 51 
#line 14577 
static bool i40e_check_recovery_mode(struct i40e_pf *pf);
#line 52 
#line 14660 
static int i40e_init_recovery_mode(struct i40e_pf *pf, struct i40e_hw *hw);
#line 53 
#line 9652 
static void i40e_fdir_sb_setup(struct i40e_pf *pf);
#line 54 
#line 13760 
static int i40e_veb_get_bw_info(struct i40e_veb *veb);
#line 55 
#line 9571 
static int i40e_get_capabilities(struct i40e_pf *pf, enum i40e_admin_queue_opc list_type);
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct pci_device_id i40e_pci_tbl[25U] = {{.vendor = 32902U, .device = 5490U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5492U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5504U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5505U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5507U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5508U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5509U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5510U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5513U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5631U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 4174U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 4175U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 14286U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 14287U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 14288U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 14289U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 14290U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 14291U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5511U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5512U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 3320U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 3416U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5514U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 32902U, .device = 5515U, .subvendor = 4294967295U, .subdevice = 4294967295U}};
#line 94  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct pci_device_id __mod_pci__i40e_pci_tbl_device_table[25U];
#line 97  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int debug = -1;
#line 106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct workqueue_struct *i40e_wq;
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_allocate_dma_mem_d(struct i40e_hw *hw, struct i40e_dma_mem *mem, u64 size, u32 alignment)
{
  #line 118 
  struct i40e_pf *pf = (struct i40e_pf *)hw->back;
  #line 120 
  mem->size = (((unsigned int)size + alignment) + 4294967295U) & - alignment;
  #line 121 
  mem->va = dma_alloc_coherent(& (pf->pdev)->dev,(unsigned long)mem->size,& mem->pa,3264U);
  #line 123 
  if (mem->va == (void *)0) 
                            #line 124 
                            return I40E_ERR_MASTER_REQUESTS_PENDING;
  #line 126 
  return I40E_SUCCESS;
}

#line 134  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_free_dma_mem_d(struct i40e_hw *hw, struct i40e_dma_mem *mem)
{
  #line 136 
  struct i40e_pf *pf = (struct i40e_pf *)hw->back;
  #line 138 
  dma_free_coherent(& (pf->pdev)->dev,(unsigned long)mem->size,mem->va,mem->pa);
  #line 139 
  mem->va = (void *)0;
  #line 140 
  mem->pa = 0ULL;
  #line 141 
  mem->size = 0U;
  #line 143 
  return I40E_SUCCESS;
}

#line 152  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_allocate_virt_mem_d(struct i40e_hw *hw, struct i40e_virt_mem *mem, u32 size)
{
  #line 155 
  mem->size = size;
  #line 156 
  mem->va = kzalloc_1((unsigned long)size,3264U);
  #line 158 
  if (mem->va == (void *)0) 
                            #line 159 
                            return I40E_ERR_MASTER_REQUESTS_PENDING;
  #line 161 
  return I40E_SUCCESS;
}

#line 169  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_free_virt_mem_d(struct i40e_hw *hw, struct i40e_virt_mem *mem)
{
  #line 172 
  kfree(mem->va);
  #line 173 
  mem->va = (void *)0;
  #line 174 
  mem->size = 0U;
  #line 176 
  return I40E_SUCCESS;
}

#line 192  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_get_lump(struct i40e_pf *pf, struct i40e_lump_tracking *pile, u16 needed, u16 id)
{
  #line 196 
  int i;
  #line 196 
  int j;
  #line 195 
  int ret = -12;
  #line 198 
  if ((pile == (struct i40e_lump_tracking *)0 || (unsigned int)needed == 0U) || (int)id < 0) {
    #line 199 
    char *tmp;
    #line 199 
    ;
    #line 199 
    ;
    #line 199 
    if (pile != (struct i40e_lump_tracking *)0) 
                                                #line 199 
                                                tmp = (char *)"<valid>"; else 
                                                                    #line 199 
                                                                    tmp = (char *)"<null>";
    #line 199 
    ;
    #line 199 
    _dev_info(& (pf->pdev)->dev,(char *)"param err: pile=%s needed=%d id=0x%04x\n",tmp,(int)needed,(int)id);
    #line 202 
    return -22;
  }
  #line 206 
  i = (int)pile->search_hint;
  #line 207 
  while ((int)pile->num_entries > i) {
    #line 209 
    if (((int)pile->list[i] & 32768) != 0) {
      #line 210 
      i ++;
      #line 211 
      continue;
    }
    #line 215 
    j = 0;
    #line 215 
    while ((int)needed > j && i + j < (int)pile->num_entries) {
      #line 216 
      if (((int)pile->list[i + j] & 32768) != 0) 
                                                 #line 217 
                                                 break;
      #line 215 
      j ++;
    }
    #line 220 
    if ((int)needed == j) {
      #line 222 
      j = 0;
      #line 222 
      while ((int)needed > j) {
        #line 223 
        pile->list[i + j] = (unsigned short)((unsigned int)id | 32768U);
        #line 222 
        j ++;
      }
      #line 224 
      ret = i;
      #line 225 
      pile->search_hint = (unsigned short)((int)((unsigned short)i) + (int)((unsigned short)j));
      #line 226 
      break;
    }
    #line 230 
    i += j;
  }
  #line 233 
  return ret;
}

#line 244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_put_lump(struct i40e_lump_tracking *pile, u16 index, u16 id)
{
  #line 248 
  int i;
  #line 246 
  int valid_id = (int)((unsigned int)id | 32768U);
  #line 247 
  int count = 0;
  #line 250 
  if (pile == (struct i40e_lump_tracking *)0 || (int)pile->num_entries <= (int)index) 
    #line 251 
    return -22;
  #line 253 
  i = (int)index;
  #line 253 
  while ((int)pile->num_entries > i && (int)pile->list[i] == valid_id) {
    #line 256 
    pile->list[i] = (unsigned short)0U;
    #line 257 
    count ++;
    #line 254 
    i ++;
  }
  #line 260 
  if (count != 0 && (int)pile->search_hint > (int)index) 
                                                         #line 261 
                                                         pile->search_hint = index;
  #line 263 
  return count;
}

#line 271  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct i40e_vsi *i40e_find_vsi_from_id(struct i40e_pf *pf, u16 id)
{
  #line 273 
  int i;
  #line 275 
  i = 0;
  #line 275 
  while ((int)pf->num_alloc_vsi > i) {
    #line 276 
    if (*(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + (unsigned long)i))->id == (int)id) 
      #line 277 
      return *(pf->vsi + (unsigned long)i);
    #line 275 
    i ++;
  }
  #line 279 
  return (struct i40e_vsi *)0;
}

#line 288  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_service_event_schedule(struct i40e_pf *pf)
{
  #line 290 
  if (test_bit(3L,(unsigned long *)(& pf->state))) {
    #line 290 
    _LAND: 
    #line 291 
    if ((int)test_bit(34L,(unsigned long *)(& pf->state)) != 0) 
                                                                #line 293 
                                                                cif_queue_work(i40e_wq,& pf->service_task);
  }
  else {
    #line 291 
    if (test_bit(8L,(unsigned long *)(& pf->state))) 
                                                     #line 290 
                                                     goto _LAND; else 
                                                                   #line 293 
                                                                   cif_queue_work(i40e_wq,& pf->service_task);
  }
  #line 294 
  return;
}

#line 304  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_tx_timeout(struct net_device *netdev)
{
  #line 310 
  unsigned int i;
  #line 311 
  u32 head;
  #line 311 
  u32 val;
  #line 306 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 307 
  struct i40e_vsi *vsi = np->vsi;
  #line 308 
  struct i40e_pf *pf = vsi->back;
  #line 309 
  struct i40e_ring *tx_ring = (struct i40e_ring *)0;
  #line 310 
  unsigned int hung_queue = 0U;
  #line 313 
  (pf->tx_timeout_count) ++;
  #line 316 
  i = 0U;
  #line 316 
  while (netdev->num_tx_queues > i) {
    {
      #line 317 
      struct netdev_queue *q;
      #line 318 
      unsigned long trans_start;
      #line 320 
      q = netdev_get_tx_queue(netdev,i);
      #line 321 
      trans_start = q->trans_start;
      {
        #line 323 
        unsigned long __dummy;
        #line 323 
        unsigned long __dummy2;
        }
      #line 322 
      if (1 != 0) {
        {
          #line 323 
          unsigned long __dummy_0;
          #line 323 
          unsigned long __dummy2_0;
          }
        #line 323 
        if (1 != 0) 
          #line 323 
          if ((long)(((unsigned long)netdev->watchdog_timeo + trans_start) - jiffies) < 0L) {
            #line 322 
            if ((int)netif_xmit_stopped(q) != 0) {
              #line 325 
              hung_queue = i;
              #line 326 
              break;
            }
          }
      }
    }
    #line 316 
    i ++;
  }
  #line 330 
  if (netdev->num_tx_queues == i) 
                                  #line 331 
                                  netdev_info(netdev,(char *)"tx_timeout: no netdev hung queue found\n");
  else {
    #line 334 
    i = 0U;
    #line 334 
    while ((unsigned int)vsi->num_queue_pairs > i) {
      #line 335 
      if (*(vsi->tx_rings + (unsigned long)i) != (struct i40e_ring *)0 && (*(vsi->tx_rings + (unsigned long)i))->desc != (void *)0) 
        #line 337 
        if ((unsigned int)(*(vsi->tx_rings + (unsigned long)i))->queue_index == hung_queue) {
          #line 338 
          tx_ring = *(vsi->tx_rings + (unsigned long)i);
          #line 339 
          break;
        }
      #line 334 
      i ++;
    }
  }
  {
    #line 345 
    unsigned long __dummy_3;
    #line 345 
    unsigned long __dummy2_3;
    }
  #line 345 
  if (1 != 0) {
    {
      #line 345 
      unsigned long __dummy_4;
      #line 345 
      unsigned long __dummy2_4;
      }
    #line 345 
    if (1 != 0) {
      #line 345 
      if ((long)((pf->tx_timeout_last_recovery - jiffies) + 5000UL) < 0L) 
        #line 346 
        pf->tx_timeout_recovery_level = 1U; else 
                                                 #line 345 
                                                 goto _LAND_0;
    }
    else 
         #line 345 
         goto _LAND_0;
  }
  else {
    #line 345 
    _LAND_0: {
               #line 347 
               unsigned long __dummy_1;
               #line 347 
               unsigned long __dummy2_1;
               }
    #line 347 
    if (1 != 0) {
      {
        #line 347 
        unsigned long __dummy_2;
        #line 347 
        unsigned long __dummy2_2;
        }
      #line 347 
      if (1 != 0) 
        #line 347 
        if ((long)(jiffies - (pf->tx_timeout_last_recovery + (unsigned long)netdev->watchdog_timeo)) < 0L) 
          #line 349 
          return;
    }
  }
  #line 352 
  if ((int)test_and_set_bit(9L,(unsigned long *)(& pf->state)) != 0) 
    #line 353 
    return;
  #line 355 
  if (tx_ring != (struct i40e_ring *)0) {
    #line 356 
    head = i40e_get_head(tx_ring);
    #line 358 
    if (((unsigned long)pf->flags & 4UL) != 0UL) 
                                                 #line 359 
                                                 val = readl((void *)(pf->hw.hw_addr + (unsigned long)((((int)(tx_ring->q_vector)->v_idx + (tx_ring->vsi)->base_vector) + 53759) * 4))); else 
                                                                    #line 363 
                                                                    val = readl((void *)(pf->hw.hw_addr + 230528U));
    #line 365 
    ;
    #line 365 
    ;
    #line 365 
    ;
    #line 365 
    ;
    #line 365 
    ;
    #line 365 
    ;
    #line 365 
    ;
    #line 365 
    netdev_info(netdev,(char *)"tx_timeout: VSI_seid: %d, Q %d, NTC: 0x%x, HWB: 0x%x, NTU: 0x%x, TAIL: 0x%x, INT: 0x%x\n",(int)vsi->seid,hung_queue,(int)tx_ring->next_to_clean,head,(int)tx_ring->next_to_use,readl((void *)tx_ring->tail),val);
  }
  #line 371 
  pf->tx_timeout_last_recovery = jiffies;
  #line 372 
  netdev_info(netdev,(char *)"tx_timeout recovery level %d, hung_queue %d\n",pf->tx_timeout_recovery_level,hung_queue);
  #line 375 
  switch (pf->tx_timeout_recovery_level) {
    #line 376 
    case (u32)1: 
                 #line 376 
    ;
    #line 377 
    cif_set_bit_1(13L,(unsigned long *)(& pf->state));
    #line 378 
    break;
    #line 379 
    case (u32)2: 
                 #line 379 
    ;
    #line 380 
    cif_set_bit_1(14L,(unsigned long *)(& pf->state));
    #line 381 
    break;
    #line 382 
    case (u32)3: 
                 #line 382 
    ;
    #line 383 
    cif_set_bit_1(15L,(unsigned long *)(& pf->state));
    #line 384 
    break;
    #line 385 
    default: 
             #line 385 
    ;
    #line 386 
    netdev_err(netdev,(char *)"tx_timeout recovery unsuccessful\n");
    #line 387 
    break;
  }
  #line 390 
  i40e_service_event_schedule(pf);
  #line 391 
  (pf->tx_timeout_recovery_level) ++;
  #line 392 
  return;
}

#line 401  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct rtnl_link_stats64 *i40e_get_vsi_stats_struct(struct i40e_vsi *vsi)
{
  #line 403 
  return & vsi->net_stats;
}

#line 411  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring, struct rtnl_link_stats64 *stats)
{
  #line 414 
  u64 bytes;
  #line 414 
  u64 packets;
  #line 415 
  unsigned int start;
  #line 417 
  while (1) {
    #line 418 
    start = u64_stats_fetch_begin_irq(& ring->syncp);
    #line 419 
    packets = ring->stats.packets;
    #line 420 
    bytes = ring->stats.bytes;
    #line 421 
    if (! ((int)u64_stats_fetch_retry_irq(& ring->syncp,start) != 0)) 
      #line 417 
      break;
  }
  #line 423 
  stats->tx_packets += packets;
  #line 424 
  stats->tx_bytes += bytes;
  #line 425 
  return;
}

#line 435  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_get_netdev_stats_struct(struct net_device *netdev, struct rtnl_link_stats64 *stats)
{
  #line 441 
  struct i40e_ring *ring;
  #line 442 
  int i;
  #line 438 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 439 
  struct i40e_vsi *vsi = np->vsi;
  #line 440 
  struct rtnl_link_stats64 *vsi_stats = i40e_get_vsi_stats_struct(vsi);
  #line 444 
  if ((int)test_bit(0L,(unsigned long *)(& vsi->state)) != 0) 
                                                              #line 445 
                                                              return;
  #line 447 
  if (vsi->tx_rings == (struct i40e_ring **)0) 
                                               #line 448 
                                               return;
  #line 450 
  rcu_read_lock();
  #line 451 
  i = 0;
  #line 451 
  while ((int)vsi->num_queue_pairs > i) {
    {
      #line 456 
      union __anonunion___u_9011 __u;
      #line 452 
      u64 bytes;
      #line 452 
      u64 packets;
      #line 453 
      unsigned int start;
      #line 455 
      __read_once_size((void *)(vsi->tx_rings + (unsigned long)i),(void *)(& __u.__c),8);
      #line 455 
      ring = (__u.__val);
      #line 456 
      if (ring == (struct i40e_ring *)0) 
                                         #line 457 
                                         goto __Cont;
      #line 458 
      i40e_get_netdev_stats_struct_tx(ring,stats);
      #line 460 
      if ((int)i40e_enabled_xdp_vsi_0(vsi) != 0) {
        #line 461 
        ring ++;
        #line 462 
        i40e_get_netdev_stats_struct_tx(ring,stats);
      }
      #line 465 
      ring ++;
      #line 466 
      while (1) {
        #line 467 
        start = u64_stats_fetch_begin_irq(& ring->syncp);
        #line 468 
        packets = ring->stats.packets;
        #line 469 
        bytes = ring->stats.bytes;
        #line 470 
        if (! ((int)u64_stats_fetch_retry_irq(& ring->syncp,start) != 0)) 
          #line 466 
          break;
      }
      #line 472 
      stats->rx_packets += packets;
      #line 473 
      stats->rx_bytes += bytes;
    }
    #line 451 
    __Cont: 
            #line 451 
    i ++;
  }
  #line 476 
  rcu_read_unlock();
  #line 479 
  stats->multicast = vsi_stats->multicast;
  #line 480 
  stats->tx_errors = vsi_stats->tx_errors;
  #line 481 
  stats->tx_dropped = vsi_stats->tx_dropped;
  #line 482 
  stats->rx_errors = vsi_stats->rx_errors;
  #line 483 
  stats->rx_dropped = vsi_stats->rx_dropped;
  #line 484 
  stats->rx_crc_errors = vsi_stats->rx_crc_errors;
  #line 485 
  stats->rx_length_errors = vsi_stats->rx_length_errors;
  #line 486 
  return;
}

#line 492  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_vsi_reset_stats(struct i40e_vsi *vsi)
{
  #line 494 
  struct rtnl_link_stats64 *ns;
  #line 495 
  int i;
  #line 497 
  if (vsi == (struct i40e_vsi *)0) 
                                   #line 498 
                                   return;
  #line 500 
  ns = i40e_get_vsi_stats_struct(vsi);
  #line 501 
  memset((void *)ns,0,192UL);
  #line 502 
  memset((void *)(& vsi->net_stats_offsets),0,192UL);
  #line 503 
  memset((void *)(& vsi->eth_stats),0,96UL);
  #line 504 
  memset((void *)(& vsi->eth_stats_offsets),0,96UL);
  #line 505 
  if (vsi->rx_rings != (struct i40e_ring **)0 && *(vsi->rx_rings) != (struct i40e_ring *)0) {
    #line 506 
    i = 0;
    #line 506 
    while ((int)vsi->num_queue_pairs > i) {
      #line 507 
      memset((void *)(& (*(vsi->rx_rings + (unsigned long)i))->stats),0,16UL);
      #line 509 
      memset((void *)(& (*(vsi->rx_rings + (unsigned long)i))->__anonCompField_i40e_ring_222.rx_stats),0,40UL);
      #line 511 
      memset((void *)(& (*(vsi->tx_rings + (unsigned long)i))->stats),0,16UL);
      #line 513 
      memset((void *)(& (*(vsi->tx_rings + (unsigned long)i))->__anonCompField_i40e_ring_222.tx_stats),0,48UL);
      #line 506 
      i ++;
    }
  }
  #line 517 
  vsi->stat_offsets_loaded = (_Bool)0;
  #line 518 
  return;
}

#line 524  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_pf_reset_stats(struct i40e_pf *pf)
{
  #line 526 
  int i;
  #line 528 
  memset((void *)(& pf->stats),0,720UL);
  #line 529 
  memset((void *)(& pf->stats_offsets),0,720UL);
  #line 530 
  pf->stat_offsets_loaded = (_Bool)0;
  #line 532 
  i = 0;
  #line 532 
  while (i <= 15) {
    #line 533 
    if (pf->veb[i] != (struct i40e_veb *)0) {
      #line 534 
      memset((void *)(& (pf->veb[i])->stats),0,96UL);
      #line 536 
      memset((void *)(& (pf->veb[i])->stats_offsets),0,96UL);
      #line 538 
      memset((void *)(& (pf->veb[i])->tc_stats),0,256UL);
      #line 540 
      memset((void *)(& (pf->veb[i])->tc_stats_offsets),0,256UL);
      #line 542 
      (pf->veb[i])->stat_offsets_loaded = (_Bool)0;
    }
    #line 532 
    i ++;
  }
  #line 545 
  pf->hw_csum_rx_error = 0U;
  #line 546 
  return;
}

#line 563  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_stat_update48(struct i40e_hw *hw, u32 hireg, u32 loreg, bool offset_loaded, u64 *offset, u64 *stat)
{
  #line 566 
  u64 new_data;
  #line 568 
  if ((unsigned int)hw->device_id == 5492U) {
    #line 569 
    new_data = (unsigned long long)readl((void *)(hw->hw_addr + (unsigned long)loreg));
    #line 570 
    new_data = (((unsigned long long)readl((void *)(hw->hw_addr + (unsigned long)hireg)) << 32) & 281470681743360ULL) | new_data;
  }
  else 
       #line 572 
       new_data = readq((void *)(hw->hw_addr + (unsigned long)loreg));
  #line 574 
  if (! offset_loaded) 
                       #line 575 
                       *offset = new_data;
  #line 576 
  if ((long)(*offset <= new_data) != 0L) 
                                         #line 577 
                                         *stat = new_data - *offset; else 
                                                                    #line 579 
                                                                    *stat = (new_data - *offset) + 281474976710656ULL;
  #line 580 
  *stat &= 281474976710655ULL;
  #line 581 
  return;
}

#line 591  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_stat_update32(struct i40e_hw *hw, u32 reg, bool offset_loaded, u64 *offset, u64 *stat)
{
  #line 594 
  u32 new_data;
  #line 596 
  new_data = readl((void *)(hw->hw_addr + (unsigned long)reg));
  #line 597 
  if (! offset_loaded) 
                       #line 598 
                       *offset = (unsigned long long)new_data;
  #line 599 
  if ((long)((unsigned long long)new_data >= *offset) != 0L) 
                                                             #line 600 
                                                             *stat = (unsigned long long)(new_data - (unsigned int)*offset); else 
                                                                    #line 602 
                                                                    *stat = (unsigned long long)(new_data - (unsigned int)*offset);
  #line 603 
  return;
}

#line 611  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_stat_update_and_clear32(struct i40e_hw *hw, u32 reg, u64 *stat)
{
  #line 613 
  u32 new_data = readl((void *)(hw->hw_addr + (unsigned long)reg));
  #line 615 
  writel(1U,(void *)(hw->hw_addr + (unsigned long)reg));
  #line 616 
  *stat += (unsigned long long)new_data;
  #line 617 
  return;
}

#line 623  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_update_eth_stats(struct i40e_vsi *vsi)
{
  #line 628 
  struct i40e_eth_stats *oes;
  #line 629 
  struct i40e_eth_stats *es;
  #line 625 
  int stat_idx = (int)vsi->info.stat_counter_idx;
  #line 626 
  struct i40e_pf *pf = vsi->back;
  #line 627 
  struct i40e_hw *hw = & pf->hw;
  #line 631 
  es = & vsi->eth_stats;
  #line 632 
  oes = & vsi->eth_stats_offsets;
  #line 635 
  i40e_stat_update32(hw,(unsigned int)((stat_idx + 428032) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->tx_errors,& es->tx_errors);
  #line 638 
  i40e_stat_update32(hw,(unsigned int)((stat_idx + 401408) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->rx_discards,& es->rx_discards);
  #line 641 
  i40e_stat_update32(hw,(unsigned int)((stat_idx + 449664) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->rx_unknown_protocol,& es->rx_unknown_protocol);
  #line 645 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3506180),(unsigned int)((stat_idx + 438272) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->rx_bytes,& es->rx_bytes);
  #line 649 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3588100),(unsigned int)((stat_idx + 448512) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->rx_unicast,& es->rx_unicast);
  #line 653 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3591172),(unsigned int)((stat_idx + 448896) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->rx_multicast,& es->rx_multicast);
  #line 657 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3594244),(unsigned int)((stat_idx + 449280) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->rx_broadcast,& es->rx_broadcast);
  #line 662 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3309572),(unsigned int)((stat_idx + 413696) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->tx_bytes,& es->tx_bytes);
  #line 666 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3391492),(unsigned int)((stat_idx + 423936) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->tx_unicast,& es->tx_unicast);
  #line 670 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3394564),(unsigned int)((stat_idx + 424320) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->tx_multicast,& es->tx_multicast);
  #line 674 
  i40e_stat_update48(hw,(unsigned int)(stat_idx * 8 + 3397636),(unsigned int)((stat_idx + 424704) * 8),(_Bool)((bool)((int)vsi->stat_offsets_loaded) != 0),& oes->tx_broadcast,& es->tx_broadcast);
  #line 678 
  vsi->stat_offsets_loaded = (_Bool)1;
  #line 679 
  return;
}

#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_update_veb_stats(struct i40e_veb *veb)
{
  #line 689 
  struct i40e_eth_stats *oes;
  #line 690 
  struct i40e_eth_stats *es;
  #line 691 
  struct i40e_veb_tc_stats *veb_oes;
  #line 692 
  struct i40e_veb_tc_stats *veb_es;
  #line 693 
  int i;
  #line 687 
  struct i40e_pf *pf = veb->pf;
  #line 688 
  struct i40e_hw *hw = & pf->hw;
  #line 693 
  int idx = 0;
  #line 695 
  idx = (int)veb->stats_idx;
  #line 696 
  es = & veb->stats;
  #line 697 
  oes = & veb->stats_offsets;
  #line 698 
  veb_es = & veb->tc_stats;
  #line 699 
  veb_oes = & veb->tc_stats_offsets;
  #line 702 
  i40e_stat_update32(hw,(unsigned int)((idx + 430080) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->tx_discards,& es->tx_discards);
  #line 705 
  if ((unsigned int)hw->revision_id != 0U) 
                                           #line 706 
                                           i40e_stat_update32(hw,(unsigned int)((idx + 450608) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->rx_unknown_protocol,& es->rx_unknown_protocol);
  #line 710 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3522564),(unsigned int)((idx + 440320) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->rx_bytes,& es->rx_bytes);
  #line 713 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3604484),(unsigned int)((idx + 450560) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->rx_unicast,& es->rx_unicast);
  #line 716 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3604612),(unsigned int)((idx + 450576) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->rx_multicast,& es->rx_multicast);
  #line 719 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3604740),(unsigned int)((idx + 450592) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->rx_broadcast,& es->rx_broadcast);
  #line 723 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3325956),(unsigned int)((idx + 415744) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->tx_bytes,& es->tx_bytes);
  #line 726 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3407876),(unsigned int)((idx + 425984) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->tx_unicast,& es->tx_unicast);
  #line 729 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3408004),(unsigned int)((idx + 426000) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->tx_multicast,& es->tx_multicast);
  #line 732 
  i40e_stat_update48(hw,(unsigned int)(idx * 8 + 3408132),(unsigned int)((idx + 426016) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& oes->tx_broadcast,& es->tx_broadcast);
  #line 735 
  i = 0;
  #line 735 
  while (i <= 7) {
    #line 736 
    i40e_stat_update48(hw,(unsigned int)((idx * 8 + i) * 8 + 3571716),(unsigned int)(((idx * 8 + i) + 446464) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& veb_oes->tc_rx_packets[i],& veb_es->tc_rx_packets[i]);
    #line 741 
    i40e_stat_update48(hw,(unsigned int)((idx * 8 + i) * 8 + 3555332),(unsigned int)(((idx * 8 + i) + 444416) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& veb_oes->tc_rx_bytes[i],& veb_es->tc_rx_bytes[i]);
    #line 746 
    i40e_stat_update48(hw,(unsigned int)((idx * 8 + i) * 8 + 3375108),(unsigned int)(((idx * 8 + i) + 421888) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& veb_oes->tc_tx_packets[i],& veb_es->tc_tx_packets[i]);
    #line 751 
    i40e_stat_update48(hw,(unsigned int)((idx * 8 + i) * 8 + 3358724),(unsigned int)(((idx * 8 + i) + 419840) * 8),(_Bool)((bool)((int)veb->stat_offsets_loaded) != 0),& veb_oes->tc_tx_bytes[i],& veb_es->tc_tx_bytes[i]);
    #line 735 
    i ++;
  }
  #line 757 
  veb->stat_offsets_loaded = (_Bool)1;
  #line 758 
  return;
}

#line 770  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_update_vsi_stats(struct i40e_vsi *vsi)
{
  #line 773 
  struct rtnl_link_stats64 *ons;
  #line 774 
  struct rtnl_link_stats64 *ns;
  #line 775 
  struct i40e_eth_stats *oes;
  #line 776 
  struct i40e_eth_stats *es;
  #line 777 
  u32 tx_restart;
  #line 777 
  u32 tx_busy;
  #line 778 
  struct i40e_ring *p;
  #line 779 
  u32 rx_page;
  #line 779 
  u32 rx_buf;
  #line 780 
  u64 bytes;
  #line 780 
  u64 packets;
  #line 781 
  unsigned int start;
  #line 782 
  u64 tx_linearize;
  #line 783 
  u64 tx_force_wb;
  #line 784 
  u64 rx_p;
  #line 784 
  u64 rx_b;
  #line 785 
  u64 tx_p;
  #line 785 
  u64 tx_b;
  #line 786 
  u16 q;
  #line 772 
  struct i40e_pf *pf = vsi->back;
  #line 788 
  if ((int)test_bit(0L,(unsigned long *)(& vsi->state)) != 0) 
                                                              #line 790 
                                                              return;
  else {
    #line 788 
    if ((int)test_bit(1L,(unsigned long *)(& pf->state)) != 0) 
                                                               #line 790 
                                                               return;
  }
  #line 792 
  ns = i40e_get_vsi_stats_struct(vsi);
  #line 793 
  ons = & vsi->net_stats_offsets;
  #line 794 
  es = & vsi->eth_stats;
  #line 795 
  oes = & vsi->eth_stats_offsets;
  #line 800 
  rx_p = 0ULL;
  #line 800 
  rx_b = rx_p;
  #line 801 
  tx_p = 0ULL;
  #line 801 
  tx_b = tx_p;
  #line 802 
  tx_force_wb = 0ULL;
  #line 802 
  tx_linearize = tx_force_wb;
  #line 802 
  tx_busy = (unsigned int)tx_linearize;
  #line 802 
  tx_restart = tx_busy;
  #line 803 
  rx_page = 0U;
  #line 804 
  rx_buf = 0U;
  #line 805 
  rcu_read_lock();
  #line 806 
  q = (unsigned short)0U;
  #line 806 
  while ((int)vsi->num_queue_pairs > (int)q) {
    {
      #line 809 
      union __anonunion___u_9013 __u;
      #line 808 
      __read_once_size((void *)(vsi->tx_rings + (unsigned long)q),(void *)(& __u.__c),8);
      #line 808 
      p = (__u.__val);
      #line 810 
      while (1) {
        #line 811 
        start = u64_stats_fetch_begin_irq(& p->syncp);
        #line 812 
        packets = p->stats.packets;
        #line 813 
        bytes = p->stats.bytes;
        #line 814 
        if (! ((int)u64_stats_fetch_retry_irq(& p->syncp,start) != 0)) 
          #line 810 
          break;
      }
      #line 815 
      tx_b += bytes;
      #line 816 
      tx_p += packets;
      #line 817 
      tx_restart = (unsigned int)p->__anonCompField_i40e_ring_222.tx_stats.restart_queue + tx_restart;
      #line 818 
      tx_busy = (unsigned int)p->__anonCompField_i40e_ring_222.tx_stats.tx_busy + tx_busy;
      #line 819 
      tx_linearize = p->__anonCompField_i40e_ring_222.tx_stats.tx_linearize + tx_linearize;
      #line 820 
      tx_force_wb = p->__anonCompField_i40e_ring_222.tx_stats.tx_force_wb + tx_force_wb;
      #line 823 
      p ++;
      #line 824 
      while (1) {
        #line 825 
        start = u64_stats_fetch_begin_irq(& p->syncp);
        #line 826 
        packets = p->stats.packets;
        #line 827 
        bytes = p->stats.bytes;
        #line 828 
        if (! ((int)u64_stats_fetch_retry_irq(& p->syncp,start) != 0)) 
          #line 824 
          break;
      }
      #line 829 
      rx_b += bytes;
      #line 830 
      rx_p += packets;
      #line 831 
      rx_buf = (unsigned int)p->__anonCompField_i40e_ring_222.rx_stats.alloc_buff_failed + rx_buf;
      #line 832 
      rx_page = (unsigned int)p->__anonCompField_i40e_ring_222.rx_stats.alloc_page_failed + rx_page;
    }
    #line 806 
    q = (u16)((int)q + 1);
  }
  #line 834 
  rcu_read_unlock();
  #line 835 
  vsi->tx_restart = tx_restart;
  #line 836 
  vsi->tx_busy = tx_busy;
  #line 837 
  vsi->tx_linearize = tx_linearize;
  #line 838 
  vsi->tx_force_wb = tx_force_wb;
  #line 839 
  vsi->rx_page_failed = rx_page;
  #line 840 
  vsi->rx_buf_failed = rx_buf;
  #line 842 
  ns->rx_packets = rx_p;
  #line 843 
  ns->rx_bytes = rx_b;
  #line 844 
  ns->tx_packets = tx_p;
  #line 845 
  ns->tx_bytes = tx_b;
  #line 848 
  i40e_update_eth_stats(vsi);
  #line 849 
  ons->tx_errors = oes->tx_errors;
  #line 850 
  ns->tx_errors = es->tx_errors;
  #line 851 
  ons->multicast = oes->rx_multicast;
  #line 852 
  ns->multicast = es->rx_multicast;
  #line 853 
  ons->rx_dropped = oes->rx_discards;
  #line 854 
  ns->rx_dropped = es->rx_discards;
  #line 855 
  ons->tx_dropped = oes->tx_discards;
  #line 856 
  ns->tx_dropped = es->tx_discards;
  #line 859 
  if (*(pf->vsi + (unsigned long)pf->lan_vsi) == vsi) {
    #line 860 
    ns->rx_crc_errors = pf->stats.crc_errors;
    #line 861 
    ns->rx_errors = pf->stats.crc_errors + pf->stats.illegal_bytes;
    #line 862 
    ns->rx_length_errors = pf->stats.rx_length_errors;
  }
  #line 864 
  return;
}

#line 870  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_update_pf_stats(struct i40e_pf *pf)
{
  #line 875 
  u32 val;
  #line 876 
  int i;
  #line 872 
  struct i40e_hw_port_stats *osd = & pf->stats_offsets;
  #line 873 
  struct i40e_hw_port_stats *nsd = & pf->stats;
  #line 874 
  struct i40e_hw *hw = & pf->hw;
  #line 878 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3145732),(unsigned int)(((int)hw->port + 393216) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.rx_bytes,& nsd->eth.rx_bytes);
  #line 882 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147396),(unsigned int)(((int)hw->port + 393424) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.tx_bytes,& nsd->eth.tx_bytes);
  #line 886 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393408) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.rx_discards,& nsd->eth.rx_discards);
  #line 890 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147172),(unsigned int)(((int)hw->port + 393396) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.rx_unicast,& nsd->eth.rx_unicast);
  #line 895 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147204),(unsigned int)(((int)hw->port + 393400) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.rx_multicast,& nsd->eth.rx_multicast);
  #line 900 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147236),(unsigned int)(((int)hw->port + 393404) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.rx_broadcast,& nsd->eth.rx_broadcast);
  #line 905 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3148228),(unsigned int)(((int)hw->port + 393528) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.tx_unicast,& nsd->eth.tx_unicast);
  #line 910 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3148260),(unsigned int)(((int)hw->port + 393532) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.tx_multicast,& nsd->eth.tx_multicast);
  #line 915 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3148292),(unsigned int)(((int)hw->port + 393536) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->eth.tx_broadcast,& nsd->eth.tx_broadcast);
  #line 921 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393540) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_dropped_link_down,& nsd->tx_dropped_link_down);
  #line 926 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393232) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->crc_errors,& nsd->crc_errors);
  #line 930 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393244) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->illegal_bytes,& nsd->illegal_bytes);
  #line 934 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393220) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->mac_local_faults,& nsd->mac_local_faults);
  #line 938 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393224) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->mac_remote_faults,& nsd->mac_remote_faults);
  #line 943 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393236) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_length_errors,& nsd->rx_length_errors);
  #line 948 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393256) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->link_xon_rx,& nsd->link_xon_rx);
  #line 951 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393520) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->link_xon_tx,& nsd->link_xon_tx);
  #line 954 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393260) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->link_xoff_rx,& nsd->link_xoff_rx);
  #line 957 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393524) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->link_xoff_tx,& nsd->link_xoff_tx);
  #line 961 
  i = 0;
  #line 961 
  while (i <= 7) {
    #line 962 
    i40e_stat_update32(hw,(unsigned int)((((int)hw->port + i * 4) + 393296) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->priority_xoff_rx[i],& nsd->priority_xoff_rx[i]);
    #line 966 
    i40e_stat_update32(hw,(unsigned int)((((int)hw->port + i * 4) + 393264) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->priority_xon_rx[i],& nsd->priority_xon_rx[i]);
    #line 970 
    i40e_stat_update32(hw,(unsigned int)((((int)hw->port + i * 4) + 393456) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->priority_xon_tx[i],& nsd->priority_xon_tx[i]);
    #line 974 
    i40e_stat_update32(hw,(unsigned int)((((int)hw->port + i * 4) + 393488) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->priority_xoff_tx[i],& nsd->priority_xoff_tx[i]);
    #line 978 
    i40e_stat_update32(hw,(unsigned int)((((int)hw->port + i * 4) + 393328) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->priority_xon_2_xoff[i],& nsd->priority_xon_2_xoff[i]);
    #line 961 
    i ++;
  }
  #line 985 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3146884),(unsigned int)(((int)hw->port + 393360) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_size_64,& nsd->rx_size_64);
  #line 989 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3146916),(unsigned int)(((int)hw->port + 393364) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_size_127,& nsd->rx_size_127);
  #line 993 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3146948),(unsigned int)(((int)hw->port + 393368) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_size_255,& nsd->rx_size_255);
  #line 997 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3146980),(unsigned int)(((int)hw->port + 393372) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_size_511,& nsd->rx_size_511);
  #line 1001 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147012),(unsigned int)(((int)hw->port + 393376) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_size_1023,& nsd->rx_size_1023);
  #line 1005 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147044),(unsigned int)(((int)hw->port + 393380) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_size_1522,& nsd->rx_size_1522);
  #line 1009 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147076),(unsigned int)(((int)hw->port + 393384) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_size_big,& nsd->rx_size_big);
  #line 1014 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147428),(unsigned int)(((int)hw->port + 393428) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_size_64,& nsd->tx_size_64);
  #line 1018 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147460),(unsigned int)(((int)hw->port + 393432) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_size_127,& nsd->tx_size_127);
  #line 1022 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147492),(unsigned int)(((int)hw->port + 393436) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_size_255,& nsd->tx_size_255);
  #line 1026 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147524),(unsigned int)(((int)hw->port + 393440) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_size_511,& nsd->tx_size_511);
  #line 1030 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147556),(unsigned int)(((int)hw->port + 393444) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_size_1023,& nsd->tx_size_1023);
  #line 1034 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147588),(unsigned int)(((int)hw->port + 393448) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_size_1522,& nsd->tx_size_1522);
  #line 1038 
  i40e_stat_update48(hw,(unsigned int)((int)hw->port * 8 + 3147620),(unsigned int)(((int)hw->port + 393452) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_size_big,& nsd->tx_size_big);
  #line 1043 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393248) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_undersize,& nsd->rx_undersize);
  #line 1046 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393388) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_fragments,& nsd->rx_fragments);
  #line 1049 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393252) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_oversize,& nsd->rx_oversize);
  #line 1052 
  i40e_stat_update32(hw,(unsigned int)(((int)hw->port + 393392) * 8),(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_jabber,& nsd->rx_jabber);
  #line 1057 
  i40e_stat_update_and_clear32(hw,(unsigned int)((int)hw->pf_id * 12 + 2516992),& nsd->fd_atr_match);
  #line 1060 
  i40e_stat_update_and_clear32(hw,(unsigned int)(((int)hw->pf_id * 3 + 629249) * 4),& nsd->fd_sb_match);
  #line 1063 
  i40e_stat_update_and_clear32(hw,(unsigned int)(((int)hw->pf_id * 3 + 629250) * 4),& nsd->fd_atr_tunnel_match);
  #line 1067 
  val = readl((void *)(hw->hw_addr + 1983264U));
  #line 1068 
  nsd->tx_lpi_status = val >> 31;
  #line 1071 
  nsd->rx_lpi_status = (val >> 30) & 1U;
  #line 1074 
  i40e_stat_update32(hw,1983424U,(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->tx_lpi_count,& nsd->tx_lpi_count);
  #line 1077 
  i40e_stat_update32(hw,1983392U,(_Bool)((bool)((int)pf->stat_offsets_loaded) != 0),& osd->rx_lpi_count,& nsd->rx_lpi_count);
  #line 1081 
  if (((unsigned long)pf->flags & 256UL) != 0UL) {
    #line 1082 
    if (test_bit(23L,(unsigned long *)(& pf->state))) 
                                                      #line 1085 
                                                      nsd->fd_sb_status = 0U; else 
                                                                    #line 1083 
                                                                    nsd->fd_sb_status = 1U;
  }
  else 
       #line 1085 
       nsd->fd_sb_status = 0U;
  #line 1087 
  if (((unsigned long)pf->flags & 512UL) != 0UL) {
    #line 1088 
    if (test_bit(22L,(unsigned long *)(& pf->state))) 
                                                      #line 1091 
                                                      nsd->fd_atr_status = 0U; else 
                                                                    #line 1089 
                                                                    nsd->fd_atr_status = 1U;
  }
  else 
       #line 1091 
       nsd->fd_atr_status = 0U;
  #line 1093 
  pf->stat_offsets_loaded = (_Bool)1;
  #line 1094 
  return;
}

#line 1102  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_update_stats(struct i40e_vsi *vsi)
{
  #line 1104 
  struct i40e_pf *pf = vsi->back;
  #line 1106 
  if (*(pf->vsi + (unsigned long)pf->lan_vsi) == vsi) 
                                                      #line 1107 
                                                      i40e_update_pf_stats(pf);
  #line 1109 
  i40e_update_vsi_stats(vsi);
  #line 1110 
  return;
}

#line 1118  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_count_filters(struct i40e_vsi *vsi)
{
  #line 1120 
  struct i40e_mac_filter *f;
  #line 1121 
  struct hlist_node *h;
  #line 1122 
  int bkt;
  #line 1123 
  int cnt = 0;
  #line 1125 
  bkt = 0;
  #line 1125 
  f = (struct i40e_mac_filter *)0;
  #line 1125 
  while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
    {
      #line 1125 
      void *__mptr;
      #line 1125 
      struct i40e_mac_filter *tmp_0;
      {
        #line 1125 
        struct hlist_node *____ptr = vsi->mac_filter_hash[bkt].first;
        #line 1125 
        if (____ptr != (struct hlist_node *)0) {
          #line 1125 
          __mptr = (void *)____ptr;
          #line 1125 
          tmp_0 = ((struct i40e_mac_filter *)__mptr);
        }
        else 
             #line 1125 
             tmp_0 = (struct i40e_mac_filter *)0;
        }
      #line 1125 
      f = tmp_0;
      #line 1125 
      while (1) {
        #line 1125 
        struct i40e_mac_filter *tmp_3;
        #line 1125 
        void *__mptr_0;
        #line 1125 
        if (f != (struct i40e_mac_filter *)0) {
          #line 1125 
          h = f->hlist.next;
          #line 1125 
          if (! (1 != 0)) 
                          #line 1125 
                          break;
        }
        else 
             #line 1125 
             break;
        #line 1126 
        cnt ++;
        {
          #line 1125 
          struct hlist_node *____ptr_0 = h;
          #line 1125 
          if (____ptr_0 != (struct hlist_node *)0) {
            #line 1125 
            __mptr_0 = (void *)____ptr_0;
            #line 1125 
            tmp_3 = ((struct i40e_mac_filter *)__mptr_0);
          }
          else 
               #line 1125 
               tmp_3 = (struct i40e_mac_filter *)0;
          }
        #line 1125 
        f = tmp_3;
      }
    }
    #line 1125 
    bkt ++;
  }
  #line 1128 
  return cnt;
}

#line 1139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct i40e_mac_filter *i40e_find_filter(struct i40e_vsi *vsi, u8 *macaddr, s16 vlan)
{
  #line 1149 
  void *__mptr;
  #line 1149 
  struct i40e_mac_filter *tmp_1;
  #line 1142 
  struct i40e_mac_filter *f;
  #line 1143 
  u64 key;
  #line 1145 
  if (vsi == (struct i40e_vsi *)0 || macaddr == (u8 *)0U) 
                                                          #line 1146 
                                                          return (struct i40e_mac_filter *)0;
  #line 1148 
  key = i40e_addr_to_hkey(macaddr);
  {
    #line 1149 
    struct hlist_node *____ptr = vsi->mac_filter_hash[hash_64_generic(key,8U)].first;
    #line 1149 
    if (____ptr != (struct hlist_node *)0) {
      #line 1149 
      __mptr = (void *)____ptr;
      #line 1149 
      tmp_1 = ((struct i40e_mac_filter *)__mptr);
    }
    else 
         #line 1149 
         tmp_1 = (struct i40e_mac_filter *)0;
    }
  #line 1149 
  f = tmp_1;
  #line 1149 
  while (f != (struct i40e_mac_filter *)0) {
    #line 1149 
    struct i40e_mac_filter *tmp_4;
    #line 1149 
    void *__mptr_0;
    #line 1150 
    if ((int)ether_addr_equal(macaddr,(u8 *)(& f->macaddr)) != 0) 
      #line 1150 
      if ((int)f->vlan == (int)vlan) 
                                     #line 1152 
                                     return f;
    {
      #line 1149 
      struct hlist_node *____ptr_0 = f->hlist.next;
      #line 1149 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 1149 
        __mptr_0 = (void *)____ptr_0;
        #line 1149 
        tmp_4 = ((struct i40e_mac_filter *)__mptr_0);
      }
      else 
           #line 1149 
           tmp_4 = (struct i40e_mac_filter *)0;
      }
    #line 1149 
    f = tmp_4;
  }
  #line 1154 
  return (struct i40e_mac_filter *)0;
}

#line 1165  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct i40e_mac_filter *i40e_find_mac(struct i40e_vsi *vsi, u8 *macaddr)
{
  #line 1174 
  void *__mptr;
  #line 1174 
  struct i40e_mac_filter *tmp_1;
  #line 1167 
  struct i40e_mac_filter *f;
  #line 1168 
  u64 key;
  #line 1170 
  if (vsi == (struct i40e_vsi *)0 || macaddr == (u8 *)0U) 
                                                          #line 1171 
                                                          return (struct i40e_mac_filter *)0;
  #line 1173 
  key = i40e_addr_to_hkey(macaddr);
  {
    #line 1174 
    struct hlist_node *____ptr = vsi->mac_filter_hash[hash_64_generic(key,8U)].first;
    #line 1174 
    if (____ptr != (struct hlist_node *)0) {
      #line 1174 
      __mptr = (void *)____ptr;
      #line 1174 
      tmp_1 = ((struct i40e_mac_filter *)__mptr);
    }
    else 
         #line 1174 
         tmp_1 = (struct i40e_mac_filter *)0;
    }
  #line 1174 
  f = tmp_1;
  #line 1174 
  while (f != (struct i40e_mac_filter *)0) {
    #line 1174 
    struct i40e_mac_filter *tmp_4;
    #line 1174 
    void *__mptr_0;
    #line 1175 
    if ((int)ether_addr_equal(macaddr,(u8 *)(& f->macaddr)) != 0) 
                                                                  #line 1176 
                                                                  return f;
    {
      #line 1174 
      struct hlist_node *____ptr_0 = f->hlist.next;
      #line 1174 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 1174 
        __mptr_0 = (void *)____ptr_0;
        #line 1174 
        tmp_4 = ((struct i40e_mac_filter *)__mptr_0);
      }
      else 
           #line 1174 
           tmp_4 = (struct i40e_mac_filter *)0;
      }
    #line 1174 
    f = tmp_4;
  }
  #line 1178 
  return (struct i40e_mac_filter *)0;
}

#line 1187  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
bool i40e_is_vsi_in_vlan(struct i40e_vsi *vsi)
{
  #line 1190 
  if ((unsigned int)vsi->info.pvid != 0U) 
                                          #line 1191 
                                          return (_Bool)1;
  #line 1213 
  return vsi->has_vlan_filter;
}

#line 1245  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_correct_mac_vlan_filters(struct i40e_vsi *vsi, struct hlist_head *tmp_add_list, struct hlist_head *tmp_del_list, int vlan_filters)
{
  #line 1271 
  void *__mptr;
  #line 1271 
  struct i40e_new_mac_filter *tmp_0;
  #line 1251 
  struct i40e_mac_filter *f;
  #line 1251 
  struct i40e_mac_filter *add_head;
  #line 1252 
  struct i40e_new_mac_filter *new;
  #line 1253 
  struct hlist_node *h;
  #line 1254 
  int bkt;
  #line 1254 
  int new_vlan;
  #line 1250 
  s16 pvid = (short)vsi->info.pvid;
  {
    #line 1271 
    struct hlist_node *____ptr = tmp_add_list->first;
    #line 1271 
    if (____ptr != (struct hlist_node *)0) {
      #line 1271 
      __mptr = (void *)____ptr;
      #line 1271 
      tmp_0 = ((struct i40e_new_mac_filter *)__mptr);
    }
    else 
         #line 1271 
         tmp_0 = (struct i40e_new_mac_filter *)0;
    }
  #line 1271 
  new = tmp_0;
  #line 1271 
  while (new != (struct i40e_new_mac_filter *)0) {
    #line 1271 
    struct i40e_new_mac_filter *tmp_3;
    #line 1271 
    void *__mptr_0;
    #line 1272 
    if ((int)pvid != 0 && (int)(new->f)->vlan != (int)pvid) 
                                                            #line 1273 
                                                            (new->f)->vlan = pvid;
    else 
      #line 1274 
      if (vlan_filters != 0 && (int)(new->f)->vlan == -1) 
                                                          #line 1275 
                                                          (new->f)->vlan = (short)0;
      else 
        #line 1276 
        if (vlan_filters == 0 && (int)(new->f)->vlan == 0) 
                                                           #line 1277 
                                                           (new->f)->vlan = (short)(-1);
    {
      #line 1271 
      struct hlist_node *____ptr_0 = new->hlist.next;
      #line 1271 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 1271 
        __mptr_0 = (void *)____ptr_0;
        #line 1271 
        tmp_3 = ((struct i40e_new_mac_filter *)__mptr_0);
      }
      else 
           #line 1271 
           tmp_3 = (struct i40e_new_mac_filter *)0;
      }
    #line 1271 
    new = tmp_3;
  }
  #line 1281 
  bkt = 0;
  #line 1281 
  f = (struct i40e_mac_filter *)0;
  #line 1281 
  while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
    {
      #line 1281 
      void *__mptr_1;
      #line 1281 
      struct i40e_mac_filter *tmp_6;
      {
        #line 1281 
        struct hlist_node *____ptr_1 = vsi->mac_filter_hash[bkt].first;
        #line 1281 
        if (____ptr_1 != (struct hlist_node *)0) {
          #line 1281 
          __mptr_1 = (void *)____ptr_1;
          #line 1281 
          tmp_6 = ((struct i40e_mac_filter *)__mptr_1);
        }
        else 
             #line 1281 
             tmp_6 = (struct i40e_mac_filter *)0;
        }
      #line 1281 
      f = tmp_6;
      #line 1281 
      while (1) {
        #line 1281 
        void *__mptr_2;
        #line 1281 
        struct i40e_mac_filter *tmp_9;
        #line 1281 
        if (f != (struct i40e_mac_filter *)0) {
          #line 1281 
          h = f->hlist.next;
          #line 1281 
          if (! (1 != 0)) 
                          #line 1281 
                          break;
        }
        else 
             #line 1281 
             break;
        #line 1287 
        if (((int)pvid != 0 && (int)f->vlan != (int)pvid || vlan_filters != 0 && (int)f->vlan == -1) || vlan_filters == 0 && (int)f->vlan == 0) {
          #line 1291 
          if ((int)pvid != 0) 
                              #line 1292 
                              new_vlan = (int)pvid;
          else 
            #line 1293 
            if (vlan_filters != 0) 
                                   #line 1294 
                                   new_vlan = 0; else 
                                                      #line 1296 
                                                      new_vlan = -1;
          #line 1299 
          add_head = i40e_add_filter(vsi,(u8 *)(& f->macaddr),(short)((int)((short)new_vlan)));
          #line 1300 
          if (add_head == (struct i40e_mac_filter *)0) 
                                                       #line 1301 
                                                       return -12;
          #line 1304 
          new = (struct i40e_new_mac_filter *)kzalloc_1(32UL,2592U);
          #line 1305 
          if (new == (struct i40e_new_mac_filter *)0) 
                                                      #line 1306 
                                                      return -12;
          #line 1308 
          new->f = add_head;
          #line 1309 
          new->state = add_head->state;
          #line 1312 
          hlist_add_head_0(& new->hlist,tmp_add_list);
          #line 1315 
          f->state = I40E_FILTER_REMOVE;
          #line 1316 
          hash_del(& f->hlist);
          #line 1317 
          hlist_add_head_0(& f->hlist,tmp_del_list);
        }
        {
          #line 1281 
          struct hlist_node *____ptr_2 = h;
          #line 1281 
          if (____ptr_2 != (struct hlist_node *)0) {
            #line 1281 
            __mptr_2 = (void *)____ptr_2;
            #line 1281 
            tmp_9 = ((struct i40e_mac_filter *)__mptr_2);
          }
          else 
               #line 1281 
               tmp_9 = (struct i40e_mac_filter *)0;
          }
        #line 1281 
        f = tmp_9;
      }
    }
    #line 1281 
    bkt ++;
  }
  #line 1321 
  vsi->has_vlan_filter = (_Bool)(vlan_filters != 0);
  #line 1323 
  return 0;
}

#line 1334  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_rm_default_mac_filter(struct i40e_vsi *vsi, u8 *macaddr)
{
  #line 1336 
  struct i40e_aqc_remove_macvlan_element_data element;
  #line 1337 
  struct i40e_pf *pf = vsi->back;
  #line 1340 
  if (vsi->type != (unsigned int)I40E_VSI_MAIN) 
                                                #line 1341 
                                                return;
  #line 1343 
  memset((void *)(& element),0,16UL);
  #line 1344 
  ether_addr_copy((u8 *)(& element.mac_addr),macaddr);
  #line 1345 
  element.vlan_tag = (unsigned short)0U;
  #line 1347 
  element.flags = (unsigned char)1U;
  #line 1348 
  i40e_aq_remove_macvlan(& pf->hw,(unsigned short)((int)vsi->seid),& element,(unsigned short)1,(struct i40e_asq_cmd_details *)0);
  #line 1350 
  memset((void *)(& element),0,16UL);
  #line 1351 
  ether_addr_copy((u8 *)(& element.mac_addr),macaddr);
  #line 1352 
  element.vlan_tag = (unsigned short)0U;
  #line 1354 
  element.flags = (unsigned char)9U;
  #line 1356 
  i40e_aq_remove_macvlan(& pf->hw,(unsigned short)((int)vsi->seid),& element,(unsigned short)1,(struct i40e_asq_cmd_details *)0);
  #line 1357 
  return;
}

#line 1370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct i40e_mac_filter *i40e_add_filter(struct i40e_vsi *vsi, u8 *macaddr, s16 vlan)
{
  #line 1373 
  struct i40e_mac_filter *f;
  #line 1374 
  u64 key;
  #line 1376 
  if (vsi == (struct i40e_vsi *)0 || macaddr == (u8 *)0U) 
                                                          #line 1377 
                                                          return (struct i40e_mac_filter *)0;
  #line 1379 
  f = i40e_find_filter(vsi,macaddr,(short)((int)vlan));
  #line 1380 
  if (f == (struct i40e_mac_filter *)0) {
    #line 1381 
    f = (struct i40e_mac_filter *)kzalloc_1(32UL,2592U);
    #line 1382 
    if (f == (struct i40e_mac_filter *)0) 
                                          #line 1383 
                                          return (struct i40e_mac_filter *)0;
    #line 1388 
    if ((int)vlan >= 0) 
                        #line 1389 
                        vsi->has_vlan_filter = (_Bool)1;
    #line 1391 
    ether_addr_copy((u8 *)(& f->macaddr),macaddr);
    #line 1392 
    f->vlan = vlan;
    #line 1393 
    f->state = I40E_FILTER_NEW;
    #line 1394 
    INIT_HLIST_NODE(& f->hlist);
    #line 1396 
    key = i40e_addr_to_hkey(macaddr);
    #line 1397 
    ;
    #line 1397 
    ;
    #line 1397 
    hlist_add_head_0(& f->hlist,& vsi->mac_filter_hash[hash_64_generic(key,8U)]);
    #line 1399 
    vsi->flags |= 1UL;
    #line 1400 
    cif_set_bit_1(27L,(unsigned long *)(& (vsi->back)->state));
  }
  #line 1411 
  if (f->state == (unsigned int)I40E_FILTER_REMOVE) 
                                                    #line 1412 
                                                    f->state = I40E_FILTER_ACTIVE;
  #line 1414 
  return f;
}

#line 1432  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void __i40e_del_filter(struct i40e_vsi *vsi, struct i40e_mac_filter *f)
{
  #line 1434 
  if (f == (struct i40e_mac_filter *)0) 
                                        #line 1435 
                                        return;
  #line 1441 
  if (f->state == (unsigned int)I40E_FILTER_FAILED || f->state == (unsigned int)I40E_FILTER_NEW) {
    #line 1443 
    hash_del(& f->hlist);
    #line 1444 
    kfree((void *)f);
  }
  else 
       #line 1446 
       f->state = I40E_FILTER_REMOVE;
  #line 1449 
  vsi->flags |= 1UL;
  #line 1450 
  cif_set_bit_1(27L,(unsigned long *)(& (vsi->back)->state));
  #line 1451 
  return;
}

#line 1465  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_del_filter(struct i40e_vsi *vsi, u8 *macaddr, s16 vlan)
{
  #line 1467 
  struct i40e_mac_filter *f;
  #line 1469 
  if (vsi == (struct i40e_vsi *)0 || macaddr == (u8 *)0U) 
                                                          #line 1470 
                                                          return;
  #line 1472 
  f = i40e_find_filter(vsi,macaddr,(short)((int)vlan));
  #line 1473 
  __i40e_del_filter(vsi,f);
  #line 1474 
  return;
}

#line 1488  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi, u8 *macaddr)
{
  #line 1491 
  struct i40e_mac_filter *f;
  #line 1492 
  struct hlist_node *h;
  #line 1493 
  int bkt;
  #line 1491 
  struct i40e_mac_filter *add = (struct i40e_mac_filter *)0;
  #line 1495 
  if ((unsigned int)vsi->info.pvid != 0U) {
    #line 1496 
    return i40e_add_filter(vsi,macaddr,(short)((int)((short)vsi->info.pvid)));
  }
  #line 1499 
  if (! i40e_is_vsi_in_vlan(vsi)) {
    #line 1500 
    return i40e_add_filter(vsi,macaddr,(short)(-1));
  }
  #line 1502 
  bkt = 0;
  #line 1502 
  f = (struct i40e_mac_filter *)0;
  #line 1502 
  while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
    {
      #line 1502 
      void *__mptr;
      #line 1502 
      struct i40e_mac_filter *tmp_3;
      {
        #line 1502 
        struct hlist_node *____ptr = vsi->mac_filter_hash[bkt].first;
        #line 1502 
        if (____ptr != (struct hlist_node *)0) {
          #line 1502 
          __mptr = (void *)____ptr;
          #line 1502 
          tmp_3 = ((struct i40e_mac_filter *)__mptr);
        }
        else 
             #line 1502 
             tmp_3 = (struct i40e_mac_filter *)0;
        }
      #line 1502 
      f = tmp_3;
      #line 1502 
      while (1) {
        #line 1502 
        void *__mptr_0;
        #line 1502 
        struct i40e_mac_filter *tmp_6;
        #line 1502 
        if (f != (struct i40e_mac_filter *)0) {
          #line 1502 
          h = f->hlist.next;
          #line 1502 
          if (! (1 != 0)) 
                          #line 1502 
                          break;
        }
        else 
             #line 1502 
             break;
        #line 1503 
        if (f->state == (unsigned int)I40E_FILTER_REMOVE) 
                                                          #line 1504 
                                                          goto __Cont;
        #line 1505 
        add = i40e_add_filter(vsi,macaddr,(short)((int)f->vlan));
        #line 1506 
        if (add == (struct i40e_mac_filter *)0) 
                                                #line 1507 
                                                return (struct i40e_mac_filter *)0;
        #line 1502 
        __Cont: { /* sequence */
                  {
                    #line 1502 
                    struct hlist_node *____ptr_0 = h;
                    #line 1502 
                    if (____ptr_0 != (struct hlist_node *)0) {
                      #line 1502 
                      __mptr_0 = (void *)____ptr_0;
                      #line 1502 
                      tmp_6 = ((struct i40e_mac_filter *)__mptr_0);
                    }
                    else 
                         #line 1502 
                         tmp_6 = (struct i40e_mac_filter *)0;
                    }
                  #line 1502 
                  f = tmp_6;
                }
      }
    }
    #line 1502 
    bkt ++;
  }
  #line 1510 
  return add;
}

#line 1523  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_del_mac_filter(struct i40e_vsi *vsi, u8 *macaddr)
{
  #line 1525 
  struct i40e_mac_filter *f;
  #line 1526 
  struct hlist_node *h;
  #line 1528 
  int bkt;
  #line 1527 
  bool found = (_Bool)0;
  {
    #line 1530 
    int tmp_0;
    #line 1530 
    if (debug_locks != 0) {
      #line 1530 
      if (lock_is_held(& vsi->mac_filter_hash_lock.__anonCompField_spinlock_25.__anonCompField___anonunion_97_24.dep_map) == 0) 
        #line 1530 
        tmp_0 = 1; else 
                        #line 1530 
                        tmp_0 = 0;
    }
    else 
         #line 1530 
         tmp_0 = 0;
    #line 1530 
    int __ret_warn_on = tmp_0;
    #line 1530 
    if ((long)(__ret_warn_on != 0) != 0L) {
      #line 1531 
      ldv_inline_asm();
      #line 1532 
      ldv_inline_asm();
    }
    #line 1530 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  #line 1531 
  bkt = 0;
  #line 1531 
  f = (struct i40e_mac_filter *)0;
  #line 1531 
  while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
    {
      #line 1531 
      struct i40e_mac_filter *tmp_2_3;
      #line 1531 
      void *__mptr;
      {
        #line 1531 
        struct hlist_node *____ptr = vsi->mac_filter_hash[bkt].first;
        #line 1531 
        if (____ptr != (struct hlist_node *)0) {
          #line 1531 
          __mptr = (void *)____ptr;
          #line 1531 
          tmp_2_3 = ((struct i40e_mac_filter *)__mptr);
        }
        else 
             #line 1531 
             tmp_2_3 = (struct i40e_mac_filter *)0;
        }
      #line 1531 
      f = tmp_2_3;
      #line 1531 
      while (1) {
        #line 1531 
        void *__mptr_0;
        #line 1531 
        struct i40e_mac_filter *tmp_5;
        #line 1531 
        if (f != (struct i40e_mac_filter *)0) {
          #line 1531 
          h = f->hlist.next;
          #line 1531 
          if (! (1 != 0)) 
                          #line 1531 
                          break;
        }
        else 
             #line 1531 
             break;
        #line 1532 
        if ((int)ether_addr_equal(macaddr,(u8 *)(& f->macaddr)) != 0) {
          #line 1533 
          __i40e_del_filter(vsi,f);
          #line 1534 
          found = (_Bool)1;
        }
        {
          #line 1531 
          struct hlist_node *____ptr_0 = h;
          #line 1531 
          if (____ptr_0 != (struct hlist_node *)0) {
            #line 1531 
            __mptr_0 = (void *)____ptr_0;
            #line 1531 
            tmp_5 = ((struct i40e_mac_filter *)__mptr_0);
          }
          else 
               #line 1531 
               tmp_5 = (struct i40e_mac_filter *)0;
          }
        #line 1531 
        f = tmp_5;
      }
    }
    #line 1531 
    bkt ++;
  }
  #line 1538 
  if ((int)found != 0) 
                       #line 1539 
                       return 0; else 
                                      #line 1541 
                                      return -2;
}

#line 1551  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_set_mac(struct net_device *netdev, void *p)
{
  #line 1553 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1554 
  struct i40e_vsi *vsi = np->vsi;
  #line 1555 
  struct i40e_pf *pf = vsi->back;
  #line 1556 
  struct i40e_hw *hw = & pf->hw;
  #line 1557 
  struct sockaddr *addr = (struct sockaddr *)p;
  #line 1559 
  if (! is_valid_ether_addr((u8 *)(& addr->sa_data))) 
                                                      #line 1560 
                                                      return -99;
  #line 1562 
  if ((int)ether_addr_equal(netdev->dev_addr,(u8 *)(& addr->sa_data)) != 0) {
    #line 1563 
    netdev_info(netdev,(char *)"already using mac address %pM\n",(char *)(& addr->sa_data));
    #line 1565 
    return 0;
  }
  #line 1568 
  if ((int)test_bit(3L,(unsigned long *)(& pf->state)) != 0) 
                                                             #line 1570 
                                                             return -99;
  else {
    #line 1568 
    if ((int)test_bit(8L,(unsigned long *)(& pf->state)) != 0) 
                                                               #line 1570 
                                                               return -99;
  }
  #line 1572 
  if ((int)ether_addr_equal((u8 *)(& hw->mac.addr),(u8 *)(& addr->sa_data)) != 0) 
    #line 1573 
    netdev_info(netdev,(char *)"returning to hw mac address %pM\n",(u8 *)(& hw->mac.addr)); else 
                                                                    #line 1576 
                                                                    netdev_info(netdev,(char *)"set new mac address %pM\n",(char *)(& addr->sa_data));
  #line 1584 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 1585 
  i40e_del_mac_filter(vsi,netdev->dev_addr);
  #line 1586 
  ether_addr_copy(netdev->dev_addr,(u8 *)(& addr->sa_data));
  #line 1587 
  i40e_add_mac_filter(vsi,netdev->dev_addr);
  #line 1588 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 1590 
  if (vsi->type == (unsigned int)I40E_VSI_MAIN) {
    #line 1591 
    i40e_status ret;
    #line 1593 
    ret = i40e_aq_mac_address_write(hw,(unsigned short)16384,(u8 *)(& addr->sa_data),(struct i40e_asq_cmd_details *)0);
    #line 1595 
    if (ret != I40E_SUCCESS) {
      #line 1596 
      ;
      #line 1596 
      netdev_info(netdev,(char *)"Ignoring error from firmware on LAA update, status %s, AQ ret %s\n",i40e_stat_str(hw,ret),i40e_aq_str(hw,hw->aq.asq_last_status));
    }
  }
  #line 1604 
  i40e_service_event_schedule(pf);
  #line 1605 
  return 0;
}

#line 1613  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_config_rss_aq(struct i40e_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size)
{
  #line 1616 
  struct i40e_pf *pf = vsi->back;
  #line 1617 
  struct i40e_hw *hw = & pf->hw;
  #line 1618 
  int ret = 0;
  #line 1620 
  if (seed != (u8 *)0U) {
    #line 1621 
    struct i40e_aqc_get_set_rss_key_data *seed_dw = (struct i40e_aqc_get_set_rss_key_data *)seed;
    #line 1623 
    ret = (int)i40e_aq_set_rss_key(hw,(unsigned short)((int)vsi->id),seed_dw);
    #line 1624 
    if (ret != 0) {
      #line 1625 
      ;
      #line 1625 
      _dev_info(& (pf->pdev)->dev,(char *)"Cannot set RSS key, err %s aq_err %s\n",i40e_stat_str(hw,(enum i40e_status_code)ret),i40e_aq_str(hw,hw->aq.asq_last_status));
      #line 1629 
      return ret;
    }
  }
  #line 1632 
  if (lut != (u8 *)0U) {
    #line 1633 
    bool pf_lut = (_Bool)(vsi->type == (unsigned int)I40E_VSI_MAIN);
    #line 1635 
    ret = (int)i40e_aq_set_rss_lut(hw,(unsigned short)((int)vsi->id),
                            (_Bool)((bool)((int)pf_lut) != 0),lut,
                            (unsigned short)((int)lut_size));
    #line 1636 
    if (ret != 0) {
      #line 1637 
      ;
      #line 1637 
      _dev_info(& (pf->pdev)->dev,(char *)"Cannot set RSS lut, err %s aq_err %s\n",i40e_stat_str(hw,(enum i40e_status_code)ret),i40e_aq_str(hw,hw->aq.asq_last_status));
      #line 1641 
      return ret;
    }
  }
  #line 1644 
  return ret;
}

#line 1651  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_config_rss(struct i40e_vsi *vsi)
{
  #line 1654 
  u8 seed[52U];
  #line 1655 
  u8 *lut;
  #line 1656 
  int ret;
  #line 1653 
  struct i40e_pf *pf = vsi->back;
  #line 1658 
  if (((unsigned long)pf->hw_features & 1UL) == 0UL) 
                                                     #line 1659 
                                                     return 0;
  #line 1660 
  if ((unsigned int)vsi->rss_size == 0U) {
    #line 1661 
    int __UNIQUE_ID___x582;
    #line 1661 
    int tmp;
    {
      #line 1661 
      __UNIQUE_ID___x582 = (int)pf->alloc_rss_size;
      #line 1661 
      int __UNIQUE_ID___y583 = (int)vsi->num_queue_pairs;
      #line 1661 
      if (__UNIQUE_ID___x582 < __UNIQUE_ID___y583) 
                                                   #line 1661 
                                                   tmp = __UNIQUE_ID___x582; else 
                                                                    #line 1661 
                                                                    tmp = __UNIQUE_ID___y583;
      }
    #line 1661 
    vsi->rss_size = (unsigned short)tmp;
  }
  #line 1663 
  if ((unsigned int)vsi->rss_size == 0U) 
                                         #line 1664 
                                         return -22;
  #line 1665 
  lut = (u8 *)kzalloc_1((unsigned long)vsi->rss_table_size,3264U);
  #line 1666 
  if (lut == (u8 *)0U) 
                       #line 1667 
                       return -12;
  #line 1672 
  if (vsi->rss_lut_user != (u8 *)0U) 
                                     #line 1673 
                                     memcpy((void *)lut,(void *)vsi->rss_lut_user,(unsigned long)vsi->rss_table_size); else 
                                                                    #line 1675 
                                                                    i40e_fill_rss_lut(pf,lut,(unsigned short)((int)vsi->rss_table_size),(unsigned short)((int)vsi->rss_size));
  #line 1676 
  if (vsi->rss_hkey_user != (u8 *)0U) 
                                      #line 1677 
                                      memcpy((void *)(& seed),(void *)vsi->rss_hkey_user,52UL); else 
                                                                    #line 1679 
                                                                    netdev_rss_key_fill((void *)(& seed),52UL);
  #line 1680 
  ret = i40e_config_rss_aq(vsi,(u8 *)(& seed),lut,(unsigned short)((int)vsi->rss_table_size));
  #line 1681 
  kfree((void *)lut);
  #line 1682 
  return ret;
}

#line 1693  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_setup_queue_map_mqprio(struct i40e_vsi *vsi, struct i40e_vsi_context *ctxt, u8 enabled_tc)
{
  #line 1697 
  u16 max_qcount;
  #line 1697 
  u16 qmap;
  #line 1698 
  int i;
  #line 1698 
  int override_q;
  #line 1698 
  int pow;
  #line 1698 
  int num_qps;
  #line 1698 
  int ret;
  #line 1697 
  u16 qcount = (unsigned short)0U;
  #line 1697 
  u16 sections = (unsigned short)0U;
  #line 1699 
  u8 netdev_tc = (unsigned char)0U;
  #line 1699 
  u8 offset = (unsigned char)0U;
  #line 1701 
  if (vsi->type != (unsigned int)I40E_VSI_MAIN) 
                                                #line 1702 
                                                return -22;
  #line 1703 
  sections = (unsigned short)64U;
  #line 1704 
  sections = (unsigned short)((unsigned int)sections | 512U);
  #line 1705 
  vsi->tc_config.numtc = vsi->mqprio_qopt.qopt.num_tc;
  #line 1706 
  if ((unsigned int)enabled_tc != 0U) 
                                      #line 1706 
                                      vsi->tc_config.enabled_tc = enabled_tc; else 
                                                                    #line 1706 
                                                                    vsi->tc_config.enabled_tc = (unsigned char)1U;
  #line 1707 
  num_qps = (int)vsi->mqprio_qopt.qopt.count[0];
  #line 1710 
  if (0 != 0) {
    #line 1710 
    int tmp_30;
    #line 1710 
    int tmp;
    #line 1710 
    int tmp_31;
    #line 1710 
    int tmp_32;
    #line 1710 
    int tmp_0;
    #line 1710 
    int tmp_1;
    #line 1710 
    int tmp_33;
    #line 1710 
    int tmp_34;
    #line 1710 
    int tmp_2;
    #line 1710 
    int tmp_3;
    #line 1710 
    int tmp_35;
    #line 1710 
    int tmp_36;
    #line 1710 
    int tmp_4;
    #line 1710 
    int tmp_5;
    #line 1710 
    int tmp_37;
    #line 1710 
    int tmp_38;
    #line 1710 
    int tmp_6;
    #line 1710 
    int tmp_7;
    #line 1710 
    int tmp_39;
    #line 1710 
    int tmp_40;
    #line 1710 
    int tmp_8;
    #line 1710 
    int tmp_9;
    #line 1710 
    int tmp_41;
    #line 1710 
    int tmp_42;
    #line 1710 
    int tmp_10;
    #line 1710 
    int tmp_11;
    #line 1710 
    int tmp_43;
    #line 1710 
    int tmp_44;
    #line 1710 
    int tmp_12;
    #line 1710 
    int tmp_13;
    #line 1710 
    int tmp_45;
    #line 1710 
    int tmp_46;
    #line 1710 
    int tmp_14;
    #line 1710 
    int tmp_15;
    #line 1710 
    int tmp_47;
    #line 1710 
    int tmp_48;
    #line 1710 
    int tmp_16;
    #line 1710 
    int tmp_17;
    #line 1710 
    int tmp_49;
    #line 1710 
    int tmp_50;
    #line 1710 
    int tmp_18;
    #line 1710 
    int tmp_19;
    #line 1710 
    int tmp_51;
    #line 1710 
    int tmp_52;
    #line 1710 
    int tmp_20;
    #line 1710 
    int tmp_21;
    #line 1710 
    int tmp_53;
    #line 1710 
    int tmp_54;
    #line 1710 
    int tmp_22;
    #line 1710 
    int tmp_23;
    #line 1710 
    int tmp_55;
    #line 1710 
    int tmp_56;
    #line 1710 
    int tmp_24;
    #line 1710 
    int tmp_25;
    #line 1710 
    int tmp_57;
    #line 1710 
    int tmp_58;
    #line 1710 
    int tmp_26;
    #line 1710 
    int tmp_27;
    #line 1710 
    int tmp_59;
    #line 1710 
    int tmp_60;
    #line 1710 
    int tmp_28;
    #line 1710 
    int tmp_29;
    #line 1710 
    int tmp_61;
    #line 1710 
    if (num_qps > 1) {
      #line 1710 
      if (((unsigned long long)num_qps & 9223372036854775808ULL) == 0ULL) {
        #line 1710 
        if (((unsigned long long)num_qps & 4611686018427387904ULL) == 0ULL) {
          #line 1710 
          if (((unsigned long long)num_qps & 2305843009213693952ULL) == 0ULL) {
            #line 1710 
            if (((unsigned long long)num_qps & 1152921504606846976ULL) == 0ULL) {
              #line 1710 
              if (((unsigned long long)num_qps & 576460752303423488ULL) == 0ULL) {
                #line 1710 
                if (((unsigned long long)num_qps & 288230376151711744ULL) == 0ULL) {
                  #line 1710 
                  if (((unsigned long long)num_qps & 144115188075855872ULL) == 0ULL) {
                    #line 1710 
                    if (((unsigned long long)num_qps & 72057594037927936ULL) == 0ULL) {
                      #line 1710 
                      if (((unsigned long long)num_qps & 36028797018963968ULL) == 0ULL) {
                        #line 1710 
                        if (((unsigned long long)num_qps & 18014398509481984ULL) == 0ULL) {
                          #line 1710 
                          if (((unsigned long long)num_qps & 9007199254740992ULL) == 0ULL) {
                            #line 1710 
                            if (((unsigned long long)num_qps & 4503599627370496ULL) == 0ULL) {
                              #line 1710 
                              if (((unsigned long long)num_qps & 2251799813685248ULL) == 0ULL) {
                                #line 1710 
                                if (((unsigned long long)num_qps & 1125899906842624ULL) == 0ULL) {
                                  #line 1710 
                                  if (((unsigned long long)num_qps & 562949953421312ULL) == 0ULL) {
                                    #line 1710 
                                    if (((unsigned long long)num_qps & 281474976710656ULL) == 0ULL) {
                                      #line 1710 
                                      if (((unsigned long long)num_qps & 140737488355328ULL) == 0ULL) {
                                        #line 1710 
                                        if (((unsigned long long)num_qps & 70368744177664ULL) == 0ULL) {
                                          #line 1710 
                                          if (((unsigned long long)num_qps & 35184372088832ULL) == 0ULL) {
                                            #line 1710 
                                            if (((unsigned long long)num_qps & 17592186044416ULL) == 0ULL) {
                                              #line 1710 
                                              if (((unsigned long long)num_qps & 8796093022208ULL) == 0ULL) {
                                                #line 1710 
                                                if (((unsigned long long)num_qps & 4398046511104ULL) == 0ULL) {
                                                  #line 1710 
                                                  if (((unsigned long long)num_qps & 2199023255552ULL) == 0ULL) {
                                                    #line 1710 
                                                    if (((unsigned long long)num_qps & 1099511627776ULL) == 0ULL) {
                                                      #line 1710 
                                                      if (((unsigned long long)num_qps & 549755813888ULL) == 0ULL) {
                                                        #line 1710 
                                                        if (((unsigned long long)num_qps & 274877906944ULL) == 0ULL) {
                                                          #line 1710 
                                                          if (((unsigned long long)num_qps & 137438953472ULL) == 0ULL) {
                                                            #line 1710 
                                                            if (((unsigned long long)num_qps & 68719476736ULL) == 0ULL) {
                                                              #line 1710 
                                                              if (((unsigned long long)num_qps & 34359738368ULL) == 0ULL) {
                                                                #line 1710 
                                                                if (((unsigned long long)num_qps & 17179869184ULL) == 0ULL) {
                                                                  #line 1710 
                                                                  if (
                                                                    ((unsigned long long)num_qps & 8589934592ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 4294967296ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 2147483648ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 1073741824ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 536870912ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 268435456ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 134217728ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 67108864ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 33554432ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 16777216ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 8388608ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 4194304ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 2097152ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 1048576ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 524288ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 262144ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 131072ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 65536ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 32768ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 16384ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 8192ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 4096ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 2048ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 1024ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 512ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 256ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 128ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 64ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 32ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 16ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 8ULL) == 0ULL) {
                                                                    #line 1710 
                                                                    if (
                                                                    ((unsigned long long)num_qps & 4ULL) != 0ULL) 
                                                                    #line 1710 
                                                                    tmp = 2; else 
                                                                    #line 1710 
                                                                    tmp = 1;
                                                                    #line 1710 
                                                                    tmp_0 = tmp;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_0 = 3;
                                                                    #line 1710 
                                                                    tmp_1 = tmp_0;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_1 = 4;
                                                                    #line 1710 
                                                                    tmp_2 = tmp_1;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_2 = 5;
                                                                    #line 1710 
                                                                    tmp_3 = tmp_2;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_3 = 6;
                                                                    #line 1710 
                                                                    tmp_4 = tmp_3;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_4 = 7;
                                                                    #line 1710 
                                                                    tmp_5 = tmp_4;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_5 = 8;
                                                                    #line 1710 
                                                                    tmp_6 = tmp_5;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_6 = 9;
                                                                    #line 1710 
                                                                    tmp_7 = tmp_6;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_7 = 10;
                                                                    #line 1710 
                                                                    tmp_8 = tmp_7;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_8 = 11;
                                                                    #line 1710 
                                                                    tmp_9 = tmp_8;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_9 = 12;
                                                                    #line 1710 
                                                                    tmp_10 = tmp_9;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_10 = 13;
                                                                    #line 1710 
                                                                    tmp_11 = tmp_10;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_11 = 14;
                                                                    #line 1710 
                                                                    tmp_12 = tmp_11;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_12 = 15;
                                                                    #line 1710 
                                                                    tmp_13 = tmp_12;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_13 = 16;
                                                                    #line 1710 
                                                                    tmp_14 = tmp_13;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_14 = 17;
                                                                    #line 1710 
                                                                    tmp_15 = tmp_14;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_15 = 18;
                                                                    #line 1710 
                                                                    tmp_16 = tmp_15;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_16 = 19;
                                                                    #line 1710 
                                                                    tmp_17 = tmp_16;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_17 = 20;
                                                                    #line 1710 
                                                                    tmp_18 = tmp_17;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_18 = 21;
                                                                    #line 1710 
                                                                    tmp_19 = tmp_18;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_19 = 22;
                                                                    #line 1710 
                                                                    tmp_20 = tmp_19;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_20 = 23;
                                                                    #line 1710 
                                                                    tmp_21 = tmp_20;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_21 = 24;
                                                                    #line 1710 
                                                                    tmp_22 = tmp_21;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_22 = 25;
                                                                    #line 1710 
                                                                    tmp_23 = tmp_22;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_23 = 26;
                                                                    #line 1710 
                                                                    tmp_24 = tmp_23;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_24 = 27;
                                                                    #line 1710 
                                                                    tmp_25 = tmp_24;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_25 = 28;
                                                                    #line 1710 
                                                                    tmp_26 = tmp_25;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_26 = 29;
                                                                    #line 1710 
                                                                    tmp_27 = tmp_26;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_27 = 30;
                                                                    #line 1710 
                                                                    tmp_28 = tmp_27;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_28 = 31;
                                                                    #line 1710 
                                                                    tmp_29 = tmp_28;
                                                                    }
                                                                    else 
                                                                    #line 1710 
                                                                    tmp_29 = 32;
                                                                    #line 1710 
                                                                    tmp_30 = tmp_29;
                                                                  }
                                                                  else 
                                                                    #line 1710 
                                                                    tmp_30 = 33;
                                                                  #line 1710 
                                                                  tmp_31 = tmp_30;
                                                                }
                                                                else 
                                                                  #line 1710 
                                                                  tmp_31 = 34;
                                                                #line 1710 
                                                                tmp_32 = tmp_31;
                                                              }
                                                              else 
                                                                   #line 1710 
                                                                   tmp_32 = 35;
                                                              #line 1710 
                                                              tmp_33 = tmp_32;
                                                            }
                                                            else 
                                                                 #line 1710 
                                                                 tmp_33 = 36;
                                                            #line 1710 
                                                            tmp_34 = tmp_33;
                                                          }
                                                          else 
                                                               #line 1710 
                                                               tmp_34 = 37;
                                                          #line 1710 
                                                          tmp_35 = tmp_34;
                                                        }
                                                        else 
                                                             #line 1710 
                                                             tmp_35 = 38;
                                                        #line 1710 
                                                        tmp_36 = tmp_35;
                                                      }
                                                      else 
                                                           #line 1710 
                                                           tmp_36 = 39;
                                                      #line 1710 
                                                      tmp_37 = tmp_36;
                                                    }
                                                    else 
                                                         #line 1710 
                                                         tmp_37 = 40;
                                                    #line 1710 
                                                    tmp_38 = tmp_37;
                                                  }
                                                  else 
                                                       #line 1710 
                                                       tmp_38 = 41;
                                                  #line 1710 
                                                  tmp_39 = tmp_38;
                                                }
                                                else 
                                                     #line 1710 
                                                     tmp_39 = 42;
                                                #line 1710 
                                                tmp_40 = tmp_39;
                                              }
                                              else 
                                                   #line 1710 
                                                   tmp_40 = 43;
                                              #line 1710 
                                              tmp_41 = tmp_40;
                                            }
                                            else 
                                                 #line 1710 
                                                 tmp_41 = 44;
                                            #line 1710 
                                            tmp_42 = tmp_41;
                                          }
                                          else 
                                               #line 1710 
                                               tmp_42 = 45;
                                          #line 1710 
                                          tmp_43 = tmp_42;
                                        }
                                        else 
                                             #line 1710 
                                             tmp_43 = 46;
                                        #line 1710 
                                        tmp_44 = tmp_43;
                                      }
                                      else 
                                           #line 1710 
                                           tmp_44 = 47;
                                      #line 1710 
                                      tmp_45 = tmp_44;
                                    }
                                    else 
                                         #line 1710 
                                         tmp_45 = 48;
                                    #line 1710 
                                    tmp_46 = tmp_45;
                                  }
                                  else 
                                       #line 1710 
                                       tmp_46 = 49;
                                  #line 1710 
                                  tmp_47 = tmp_46;
                                }
                                else 
                                     #line 1710 
                                     tmp_47 = 50;
                                #line 1710 
                                tmp_48 = tmp_47;
                              }
                              else 
                                   #line 1710 
                                   tmp_48 = 51;
                              #line 1710 
                              tmp_49 = tmp_48;
                            }
                            else 
                                 #line 1710 
                                 tmp_49 = 52;
                            #line 1710 
                            tmp_50 = tmp_49;
                          }
                          else 
                               #line 1710 
                               tmp_50 = 53;
                          #line 1710 
                          tmp_51 = tmp_50;
                        }
                        else 
                             #line 1710 
                             tmp_51 = 54;
                        #line 1710 
                        tmp_52 = tmp_51;
                      }
                      else 
                           #line 1710 
                           tmp_52 = 55;
                      #line 1710 
                      tmp_53 = tmp_52;
                    }
                    else 
                         #line 1710 
                         tmp_53 = 56;
                    #line 1710 
                    tmp_54 = tmp_53;
                  }
                  else 
                       #line 1710 
                       tmp_54 = 57;
                  #line 1710 
                  tmp_55 = tmp_54;
                }
                else 
                     #line 1710 
                     tmp_55 = 58;
                #line 1710 
                tmp_56 = tmp_55;
              }
              else 
                   #line 1710 
                   tmp_56 = 59;
              #line 1710 
              tmp_57 = tmp_56;
            }
            else 
                 #line 1710 
                 tmp_57 = 60;
            #line 1710 
            tmp_58 = tmp_57;
          }
          else 
               #line 1710 
               tmp_58 = 61;
          #line 1710 
          tmp_59 = tmp_58;
        }
        else 
             #line 1710 
             tmp_59 = 62;
        #line 1710 
        tmp_60 = tmp_59;
      }
      else 
           #line 1710 
           tmp_60 = 63;
      #line 1710 
      tmp_61 = tmp_60;
    }
    else 
         #line 1710 
         tmp_61 = 0;
    #line 1710 
    pow = tmp_61;
  }
  else 
       #line 1710 
       pow = __ilog2_u32((unsigned int)num_qps);
  #line 1711 
  if (! is_power_of_2((unsigned long)num_qps)) 
                                               #line 1712 
                                               pow ++;
  #line 1713 
  qmap = (unsigned short)((int)offset | (pow << 9));
  #line 1717 
  max_qcount = vsi->mqprio_qopt.qopt.count[0];
  #line 1718 
  i = 0;
  #line 1718 
  while (i <= 7) {
    #line 1720 
    if ((((unsigned long)vsi->tc_config.enabled_tc >> i) & 1UL) != 0UL) {
      #line 1727 
      u8 tmp_64;
      #line 1721 
      offset = (unsigned char)vsi->mqprio_qopt.qopt.offset[i];
      #line 1722 
      qcount = vsi->mqprio_qopt.qopt.count[i];
      #line 1723 
      if ((int)qcount > (int)max_qcount) 
                                         #line 1724 
                                         max_qcount = qcount;
      #line 1725 
      vsi->tc_config.tc_info[i].qoffset = (unsigned short)offset;
      #line 1726 
      vsi->tc_config.tc_info[i].qcount = qcount;
      #line 1727 
      tmp_64 = netdev_tc;
      #line 1727 
      netdev_tc = (u8)((int)netdev_tc + 1);
      #line 1727 
      vsi->tc_config.tc_info[i].netdev_tc = tmp_64;
    }
    else {
      #line 1733 
      vsi->tc_config.tc_info[i].qoffset = (unsigned short)0U;
      #line 1734 
      vsi->tc_config.tc_info[i].qcount = (unsigned short)1U;
      #line 1735 
      vsi->tc_config.tc_info[i].netdev_tc = (unsigned char)0U;
    }
    #line 1718 
    i ++;
  }
  #line 1740 
  vsi->num_queue_pairs = (unsigned short)((int)((unsigned short)offset) + (int)qcount);
  #line 1743 
  ctxt->info.tc_mapping[0] = qmap;
  #line 1744 
  ctxt->info.mapping_flags = ctxt->info.mapping_flags;
  #line 1745 
  ctxt->info.queue_mapping[0] = vsi->base_queue;
  #line 1746 
  ctxt->info.valid_sections = (unsigned short)((int)ctxt->info.valid_sections | (int)sections);
  #line 1749 
  vsi->rss_size = max_qcount;
  #line 1750 
  ret = i40e_vsi_config_rss(vsi);
  #line 1751 
  if (ret != 0) {
    #line 1752 
    _dev_info(& ((vsi->back)->pdev)->dev,(char *)"Failed to reconfig rss for num_queues (%u)\n",(int)max_qcount);
    #line 1755 
    return ret;
  }
  #line 1757 
  vsi->reconfig_rss = (_Bool)1;
  {
    #line 1758 
    bool branch;
    #line 1758 
    struct _ddebug __UNIQUE_ID_ddebug584 = {.modname = (char *)"i40e", .function = (char *)"i40e_vsi_setup_queue_map_mqprio", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Reconfigured rss with num_queues (%u)\n", .lineno = (unsigned int)1758U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 1758 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug584.key.dd_key_false.key,(_Bool)0);
    #line 1758 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 1758 
                                                __dynamic_dev_dbg(& __UNIQUE_ID_ddebug584,& ((vsi->back)->pdev)->dev,(char *)"Reconfigured rss with num_queues (%u)\n",(int)max_qcount);
  }
  #line 1764 
  override_q = (int)vsi->mqprio_qopt.qopt.count[0];
  #line 1765 
  if (override_q != 0 && (int)vsi->num_queue_pairs > override_q) {
    #line 1766 
    vsi->cnt_q_avail = (unsigned short)((int)vsi->num_queue_pairs - (int)((unsigned short)override_q));
    #line 1767 
    vsi->next_base_queue = (unsigned short)override_q;
  }
  #line 1769 
  return 0;
}

#line 1781  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_setup_queue_map(struct i40e_vsi *vsi, struct i40e_vsi_context *ctxt, u8 enabled_tc, bool is_add)
{
  #line 1790 
  u16 qcount;
  #line 1791 
  u8 offset;
  #line 1792 
  u16 qmap;
  #line 1793 
  int i;
  #line 1786 
  struct i40e_pf *pf = vsi->back;
  #line 1787 
  u16 sections = (unsigned short)0U;
  #line 1788 
  u8 netdev_tc = (unsigned char)0U;
  #line 1789 
  u16 numtc = (unsigned short)1U;
  #line 1794 
  u16 num_tc_qps = (unsigned short)0U;
  #line 1796 
  sections = (unsigned short)64U;
  #line 1797 
  offset = (unsigned char)0U;
  #line 1800 
  num_tc_qps = vsi->alloc_queue_pairs;
  #line 1801 
  if ((unsigned int)enabled_tc != 0U && ((unsigned long)(vsi->back)->flags & 128UL) != 0UL) {
    #line 1812 
    int __UNIQUE_ID___x585;
    #line 1812 
    int tmp_0;
    #line 1803 
    i = 0;
    #line 1803 
    numtc = (unsigned short)0U;
    #line 1803 
    while (i <= 7) {
      #line 1804 
      if ((((unsigned long)enabled_tc >> i) & 1UL) != 0UL) 
                                                           #line 1805 
                                                           numtc = (u16)((int)numtc + 1);
      #line 1803 
      i ++;
    }
    #line 1807 
    if ((unsigned int)numtc == 0U) {
      #line 1808 
      _dev_warn(& (pf->pdev)->dev,(char *)"DCB is enabled but no TC enabled, forcing TC0\n");
      #line 1809 
      numtc = (unsigned short)1U;
    }
    #line 1811 
    num_tc_qps = (unsigned short)((int)num_tc_qps / (int)numtc);
    {
      #line 1812 
      int tmp;
      #line 1812 
      __UNIQUE_ID___x585 = (int)num_tc_qps;
      #line 1812 
      if (((unsigned long)pf->hw_features & 2UL) != 0UL) 
                                                         #line 1812 
                                                         tmp = 128; else 
                                                                    #line 1812 
                                                                    tmp = 64;
      #line 1812 
      int __UNIQUE_ID___y586 = tmp;
      #line 1812 
      if (__UNIQUE_ID___x585 < __UNIQUE_ID___y586) 
                                                   #line 1812 
                                                   tmp_0 = __UNIQUE_ID___x585; else 
                                                                    #line 1812 
                                                                    tmp_0 = __UNIQUE_ID___y586;
      }
    #line 1812 
    num_tc_qps = (unsigned short)tmp_0;
  }
  #line 1816 
  vsi->tc_config.numtc = (unsigned char)numtc;
  #line 1817 
  if ((unsigned int)enabled_tc != 0U) 
                                      #line 1817 
                                      vsi->tc_config.enabled_tc = enabled_tc; else 
                                                                    #line 1817 
                                                                    vsi->tc_config.enabled_tc = (unsigned char)1U;
  #line 1820 
  if (((unsigned long)pf->flags & 4UL) != 0UL) {
    #line 1821 
    int __UNIQUE_ID___x587;
    #line 1821 
    int tmp_2;
    {
      #line 1821 
      __UNIQUE_ID___x587 = (int)num_tc_qps;
      #line 1821 
      int __UNIQUE_ID___y588 = (int)pf->num_lan_msix;
      #line 1821 
      if (__UNIQUE_ID___x587 < __UNIQUE_ID___y588) 
                                                   #line 1821 
                                                   tmp_2 = __UNIQUE_ID___x587; else 
                                                                    #line 1821 
                                                                    tmp_2 = __UNIQUE_ID___y588;
      }
    #line 1821 
    num_tc_qps = (unsigned short)tmp_2;
  }
  #line 1824 
  i = 0;
  #line 1824 
  while (i <= 7) {
    #line 1826 
    if ((((unsigned long)vsi->tc_config.enabled_tc >> i) & 1UL) != 0UL) {
      #line 1828 
      int pow;
      #line 1828 
      int num_qps;
      #line 1859 
      u8 tmp_6_0;
      #line 1830 
      switch ((unsigned int)vsi->type) {
        #line 1831 
        case (unsigned int)0: 
                              #line 1831 
        ;
        #line 1832 
        if (((unsigned long)pf->flags & 768UL) == 0UL || (unsigned int)vsi->tc_config.enabled_tc != 1U) {
          #line 1835 
          int __UNIQUE_ID___x589;
          #line 1835 
          int tmp_4;
          {
            #line 1835 
            __UNIQUE_ID___x589 = (int)pf->alloc_rss_size;
            #line 1835 
            int __UNIQUE_ID___y590 = (int)num_tc_qps;
            #line 1835 
            if (__UNIQUE_ID___x589 < __UNIQUE_ID___y590) 
                                                         #line 1835 
                                                         tmp_4 = __UNIQUE_ID___x589; else 
                                                                    #line 1835 
                                                                    tmp_4 = __UNIQUE_ID___y590;
            }
          #line 1835 
          qcount = (unsigned short)tmp_4;
          #line 1837 
          break;
        }
        #line 1840 
        case (unsigned int)7: 
                              #line 1840 
        ;
        #line 1841 
        case (unsigned int)6: 
                              #line 1841 
        ;
        #line 1842 
        case (unsigned int)2: 
                              #line 1842 
        ;
        #line 1843 
        default: 
                 #line 1843 
        ;
        #line 1844 
        qcount = num_tc_qps;
        {
          #line 1845 
          int __ret_warn_on = i != 0;
          #line 1845 
          if ((long)(__ret_warn_on != 0) != 0L) {
            #line 1846 
            ldv_inline_asm();
            #line 1847 
            ldv_inline_asm();
          }
          #line 1845 
          long tmp_6 = (long)(__ret_warn_on != 0);
        }
        #line 1846 
        break;
      }
      #line 1848 
      vsi->tc_config.tc_info[i].qoffset = (unsigned short)offset;
      #line 1849 
      vsi->tc_config.tc_info[i].qcount = qcount;
      #line 1852 
      num_qps = (int)qcount;
      #line 1853 
      pow = 0;
      #line 1854 
      while (num_qps != 0 && 1ULL << pow < (unsigned long long)qcount) {
        #line 1855 
        pow ++;
        #line 1856 
        num_qps >>= 1;
      }
      #line 1859 
      tmp_6_0 = netdev_tc;
      #line 1859 
      netdev_tc = (u8)((int)netdev_tc + 1);
      #line 1859 
      vsi->tc_config.tc_info[i].netdev_tc = tmp_6_0;
      #line 1860 
      qmap = (unsigned short)((int)offset | (pow << 9));
      #line 1864 
      offset = (unsigned char)((int)((unsigned char)qcount) + (int)offset);
    }
    else {
      #line 1870 
      vsi->tc_config.tc_info[i].qoffset = (unsigned short)0U;
      #line 1871 
      vsi->tc_config.tc_info[i].qcount = (unsigned short)1U;
      #line 1872 
      vsi->tc_config.tc_info[i].netdev_tc = (unsigned char)0U;
      #line 1874 
      qmap = (unsigned short)0U;
    }
    #line 1876 
    ctxt->info.tc_mapping[i] = qmap;
    #line 1824 
    i ++;
  }
  #line 1880 
  vsi->num_queue_pairs = (unsigned short)offset;
  #line 1881 
  if (vsi->type == (unsigned int)I40E_VSI_MAIN && (unsigned int)numtc == 1U) 
    #line 1882 
    if ((unsigned int)vsi->req_queue_pairs != 0U) 
                                                  #line 1883 
                                                  vsi->num_queue_pairs = vsi->req_queue_pairs;
    else 
      #line 1884 
      if (((unsigned long)pf->flags & 4UL) != 0UL) 
                                                   #line 1885 
                                                   vsi->num_queue_pairs = pf->num_lan_msix;
  #line 1889 
  if ((int)is_add != 0) {
    #line 1890 
    sections = (unsigned short)((unsigned int)sections | 512U);
    #line 1892 
    ctxt->info.up_enable_bits = enabled_tc;
  }
  #line 1894 
  if (vsi->type == (unsigned int)I40E_VSI_SRIOV) {
    #line 1895 
    ctxt->info.mapping_flags = (unsigned short)((unsigned int)ctxt->info.mapping_flags | 1U);
    #line 1897 
    i = 0;
    #line 1897 
    while ((int)vsi->num_queue_pairs > i) {
      #line 1898 
      ctxt->info.queue_mapping[i] = (unsigned short)((int)vsi->base_queue + (int)((unsigned short)i));
      #line 1897 
      i ++;
    }
  }
  else {
    #line 1901 
    ctxt->info.mapping_flags = ctxt->info.mapping_flags;
    #line 1903 
    ctxt->info.queue_mapping[0] = vsi->base_queue;
  }
  #line 1905 
  ctxt->info.valid_sections = (unsigned short)((int)ctxt->info.valid_sections | (int)sections);
  #line 1906 
  return;
}

#line 1916  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_addr_sync(struct net_device *netdev, u8 *addr)
{
  #line 1918 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1919 
  struct i40e_vsi *vsi = np->vsi;
  #line 1921 
  if (i40e_add_mac_filter(vsi,addr) != (struct i40e_mac_filter *)0) 
                                                                    #line 1922 
                                                                    return 0; else 
                                                                    #line 1924 
                                                                    return -12;
}

#line 1935  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_addr_unsync(struct net_device *netdev, u8 *addr)
{
  #line 1937 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1938 
  struct i40e_vsi *vsi = np->vsi;
  #line 1945 
  if ((int)ether_addr_equal(addr,netdev->dev_addr) != 0) 
                                                         #line 1946 
                                                         return 0;
  #line 1948 
  i40e_del_mac_filter(vsi,addr);
  #line 1950 
  return 0;
}

#line 1957  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_set_rx_mode(struct net_device *netdev)
{
  #line 1959 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1960 
  struct i40e_vsi *vsi = np->vsi;
  #line 1962 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 1964 
  __dev_uc_sync(netdev,& i40e_addr_sync,& i40e_addr_unsync);
  #line 1965 
  __dev_mc_sync(netdev,& i40e_addr_sync,& i40e_addr_unsync);
  #line 1967 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 1970 
  if (vsi->current_netdev_flags != (vsi->netdev)->flags) {
    #line 1971 
    vsi->flags |= 1UL;
    #line 1972 
    cif_set_bit_1(27L,(unsigned long *)(& (vsi->back)->state));
  }
  #line 1974 
  return;
}

#line 1984  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_undo_del_filter_entries(struct i40e_vsi *vsi, struct hlist_head *from)
{
  #line 1990 
  void *__mptr;
  #line 1990 
  struct i40e_mac_filter *tmp_0;
  #line 1987 
  struct i40e_mac_filter *f;
  #line 1988 
  struct hlist_node *h;
  {
    #line 1990 
    struct hlist_node *____ptr = from->first;
    #line 1990 
    if (____ptr != (struct hlist_node *)0) {
      #line 1990 
      __mptr = (void *)____ptr;
      #line 1990 
      tmp_0 = ((struct i40e_mac_filter *)__mptr);
    }
    else 
         #line 1990 
         tmp_0 = (struct i40e_mac_filter *)0;
    }
  #line 1990 
  f = tmp_0;
  #line 1990 
  while (1) {
    #line 1990 
    void *__mptr_0;
    #line 1990 
    struct i40e_mac_filter *tmp_3;
    #line 1990 
    if (f != (struct i40e_mac_filter *)0) {
      #line 1990 
      h = f->hlist.next;
      #line 1990 
      if (! (1 != 0)) 
                      #line 1990 
                      break;
    }
    else 
         #line 1990 
         break;
    {
      #line 1991 
      u64 key = i40e_addr_to_hkey((u8 *)(& f->macaddr));
      #line 1994 
      hlist_del_0(& f->hlist);
      #line 1995 
      ;
      #line 1995 
      ;
      #line 1995 
      hlist_add_head_0(& f->hlist,& vsi->mac_filter_hash[hash_64_generic(key,8U)]);
    }
    {
      #line 1990 
      struct hlist_node *____ptr_0 = h;
      #line 1990 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 1990 
        __mptr_0 = (void *)____ptr_0;
        #line 1990 
        tmp_3 = ((struct i40e_mac_filter *)__mptr_0);
      }
      else 
           #line 1990 
           tmp_3 = (struct i40e_mac_filter *)0;
      }
    #line 1990 
    f = tmp_3;
  }
  #line 1997 
  return;
}

#line 2007  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_undo_add_filter_entries(struct i40e_vsi *vsi, struct hlist_head *from)
{
  #line 2013 
  void *__mptr;
  #line 2013 
  struct i40e_new_mac_filter *tmp_0;
  #line 2010 
  struct i40e_new_mac_filter *new;
  #line 2011 
  struct hlist_node *h;
  {
    #line 2013 
    struct hlist_node *____ptr = from->first;
    #line 2013 
    if (____ptr != (struct hlist_node *)0) {
      #line 2013 
      __mptr = (void *)____ptr;
      #line 2013 
      tmp_0 = ((struct i40e_new_mac_filter *)__mptr);
    }
    else 
         #line 2013 
         tmp_0 = (struct i40e_new_mac_filter *)0;
    }
  #line 2013 
  new = tmp_0;
  #line 2013 
  while (1) {
    #line 2013 
    void *__mptr_0;
    #line 2013 
    struct i40e_new_mac_filter *tmp_3;
    #line 2013 
    if (new != (struct i40e_new_mac_filter *)0) {
      #line 2013 
      h = new->hlist.next;
      #line 2013 
      if (! (1 != 0)) 
                      #line 2013 
                      break;
    }
    else 
         #line 2013 
         break;
    #line 2015 
    hlist_del_0(& new->hlist);
    #line 2016 
    kfree((void *)new);
    {
      #line 2013 
      struct hlist_node *____ptr_0 = h;
      #line 2013 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 2013 
        __mptr_0 = (void *)____ptr_0;
        #line 2013 
        tmp_3 = ((struct i40e_new_mac_filter *)__mptr_0);
      }
      else 
           #line 2013 
           tmp_3 = (struct i40e_new_mac_filter *)0;
      }
    #line 2013 
    new = tmp_3;
  }
  #line 2018 
  return;
}

#line 2029  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct i40e_new_mac_filter *i40e_next_filter(struct i40e_new_mac_filter *next)
{
  #line 2031 
  void *__mptr;
  #line 2031 
  struct i40e_new_mac_filter *tmp_0;
  {
    #line 2031 
    struct hlist_node *____ptr = next->hlist.next;
    #line 2031 
    if (____ptr != (struct hlist_node *)0) {
      #line 2031 
      __mptr = (void *)____ptr;
      #line 2031 
      tmp_0 = ((struct i40e_new_mac_filter *)__mptr);
    }
    else 
         #line 2031 
         tmp_0 = (struct i40e_new_mac_filter *)0;
    }
  #line 2031 
  next = tmp_0;
  #line 2031 
  while (next != (struct i40e_new_mac_filter *)0) {
    #line 2031 
    void *__mptr_0;
    #line 2031 
    struct i40e_new_mac_filter *tmp_3;
    #line 2032 
    if (! is_broadcast_ether_addr((u8 *)(& (next->f)->macaddr))) 
                                                                 #line 2033 
                                                                 return next;
    {
      #line 2031 
      struct hlist_node *____ptr_0 = next->hlist.next;
      #line 2031 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 2031 
        __mptr_0 = (void *)____ptr_0;
        #line 2031 
        tmp_3 = ((struct i40e_new_mac_filter *)__mptr_0);
      }
      else 
           #line 2031 
           tmp_3 = (struct i40e_new_mac_filter *)0;
      }
    #line 2031 
    next = tmp_3;
  }
  #line 2036 
  return (struct i40e_new_mac_filter *)0;
}

#line 2050  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_update_filter_state(int count, struct i40e_aqc_add_macvlan_element_data *add_list, struct i40e_new_mac_filter *add_head)
{
  #line 2055 
  int i;
  #line 2054 
  int retval = 0;
  #line 2057 
  i = 0;
  #line 2057 
  while (i < count) {
    #line 2064 
    if ((unsigned int)(add_list + (unsigned long)i)->match_method == 255U) 
      #line 2065 
      add_head->state = I40E_FILTER_FAILED;
    else {
      #line 2067 
      add_head->state = I40E_FILTER_ACTIVE;
      #line 2068 
      retval ++;
    }
    #line 2071 
    add_head = i40e_next_filter(add_head);
    #line 2072 
    if (add_head == (struct i40e_new_mac_filter *)0) 
                                                     #line 2073 
                                                     break;
    #line 2057 
    i ++;
  }
  #line 2076 
  return retval;
}

#line 2093  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_aqc_del_filters(struct i40e_vsi *vsi, char *vsi_name, struct i40e_aqc_remove_macvlan_element_data *list, int num_del, int *retval)
{
  #line 2098 
  i40e_status aq_ret;
  #line 2099 
  int aq_err;
  #line 2097 
  struct i40e_hw *hw = & (vsi->back)->hw;
  #line 2101 
  aq_ret = i40e_aq_remove_macvlan(hw,(unsigned short)((int)vsi->seid),list,(unsigned short)((int)((unsigned short)num_del)),(struct i40e_asq_cmd_details *)0);
  #line 2102 
  aq_err = (int)hw->aq.asq_last_status;
  #line 2105 
  if (aq_ret != I40E_SUCCESS && aq_err != 2) {
    #line 2106 
    *retval = -5;
    #line 2107 
    ;
    #line 2107 
    ;
    #line 2107 
    _dev_info(& ((vsi->back)->pdev)->dev,(char *)"ignoring delete macvlan error on %s, err %s, aq_err %s\n",vsi_name,i40e_stat_str(hw,aq_ret),i40e_aq_str(hw,(enum i40e_admin_queue_err)aq_err));
  }
  #line 2109 
  return;
}

#line 2127  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_aqc_add_filters(struct i40e_vsi *vsi, char *vsi_name, struct i40e_aqc_add_macvlan_element_data *list, struct i40e_new_mac_filter *add_head, int num_add)
{
  #line 2133 
  int aq_err;
  #line 2133 
  int fcnt;
  #line 2132 
  struct i40e_hw *hw = & (vsi->back)->hw;
  #line 2135 
  i40e_aq_add_macvlan(hw,(unsigned short)((int)vsi->seid),list,(unsigned short)((int)((unsigned short)num_add)),(struct i40e_asq_cmd_details *)0);
  #line 2136 
  aq_err = (int)hw->aq.asq_last_status;
  #line 2137 
  fcnt = i40e_update_filter_state(num_add,list,add_head);
  #line 2139 
  if (fcnt != num_add) 
    #line 2140 
    if (vsi->type == (unsigned int)I40E_VSI_MAIN) {
      #line 2141 
      cif_set_bit_1(3L,(unsigned long *)(& vsi->state));
      #line 2142 
      ;
      #line 2142 
      ;
      #line 2142 
      _dev_warn(& ((vsi->back)->pdev)->dev,(char *)"Error %s adding RX filters on %s, promiscuous mode forced on\n",i40e_aq_str(hw,(enum i40e_admin_queue_err)aq_err),vsi_name);
    }
    else 
      #line 2145 
      if ((vsi->type == (unsigned int)I40E_VSI_SRIOV || vsi->type == (unsigned int)I40E_VSI_VMDQ1) || vsi->type == (unsigned int)I40E_VSI_VMDQ2) {
        #line 2148 
        ;
        #line 2148 
        ;
        #line 2148 
        ;
        #line 2148 
        _dev_warn(& ((vsi->back)->pdev)->dev,(char *)"Error %s adding RX filters on %s, please set promiscuous on manually for %s\n",i40e_aq_str(hw,(enum i40e_admin_queue_err)aq_err),vsi_name,vsi_name);
      }
      else {
        #line 2152 
        ;
        #line 2152 
        ;
        #line 2152 
        ;
        #line 2152 
        _dev_warn(& ((vsi->back)->pdev)->dev,(char *)"Error %s adding RX filters on %s, incorrect VSI type: %i.\n",i40e_aq_str(hw,(enum i40e_admin_queue_err)aq_err),vsi_name,(unsigned int)vsi->type);
      }
  #line 2153 
  return;
}

#line 2172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static i40e_status i40e_aqc_broadcast_filter(struct i40e_vsi *vsi, char *vsi_name, struct i40e_mac_filter *f)
{
  #line 2177 
  i40e_status aq_ret;
  #line 2175 
  bool enable = (_Bool)(f->state == (unsigned int)I40E_FILTER_NEW);
  #line 2176 
  struct i40e_hw *hw = & (vsi->back)->hw;
  #line 2179 
  if ((int)f->vlan == -1) 
                          #line 2180 
                          aq_ret = i40e_aq_set_vsi_broadcast(hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)enable) != 0),(struct i40e_asq_cmd_details *)0); else 
                                                                    #line 2185 
                                                                    aq_ret = i40e_aq_set_vsi_bc_promisc_on_vlan(hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)enable) != 0),(unsigned short)((int)((unsigned short)f->vlan)),(struct i40e_asq_cmd_details *)0);
  #line 2192 
  if (aq_ret != I40E_SUCCESS) {
    #line 2193 
    cif_set_bit_1(3L,(unsigned long *)(& vsi->state));
    #line 2194 
    ;
    #line 2194 
    ;
    #line 2194 
    _dev_warn(& ((vsi->back)->pdev)->dev,(char *)"Error %s, forcing overflow promiscuous on %s\n",i40e_aq_str(hw,hw->aq.asq_last_status),vsi_name);
  }
  #line 2200 
  return aq_ret;
}

#line 2212  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_set_promiscuous(struct i40e_pf *pf, bool promisc)
{
  #line 2216 
  i40e_status aq_ret;
  #line 2214 
  struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)pf->lan_vsi);
  #line 2215 
  struct i40e_hw *hw = & pf->hw;
  #line 2218 
  if ((vsi->type == (unsigned int)I40E_VSI_MAIN && (unsigned int)pf->lan_veb != 65535U) && ((unsigned long)pf->flags & 1024UL) == 0UL) {
    #line 2226 
    if ((int)promisc != 0) 
                           #line 2227 
                           aq_ret = i40e_aq_set_default_vsi(hw,(unsigned short)((int)vsi->seid),(struct i40e_asq_cmd_details *)0); else 
                                                                    #line 2231 
                                                                    aq_ret = i40e_aq_clear_default_vsi(hw,(unsigned short)((int)vsi->seid),(struct i40e_asq_cmd_details *)0);
    #line 2234 
    if (aq_ret != I40E_SUCCESS) {
      #line 2235 
      ;
      #line 2235 
      _dev_info(& (pf->pdev)->dev,(char *)"Set default VSI failed, err %s, aq_err %s\n",i40e_stat_str(hw,aq_ret),i40e_aq_str(hw,hw->aq.asq_last_status));
    }
  }
  else {
    #line 2241 
    aq_ret = i40e_aq_set_vsi_unicast_promiscuous(hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)promisc) != 0),(struct i40e_asq_cmd_details *)0,(_Bool)1);
    #line 2246 
    if (aq_ret != I40E_SUCCESS) {
      #line 2247 
      ;
      #line 2247 
      _dev_info(& (pf->pdev)->dev,(char *)"set unicast promisc failed, err %s, aq_err %s\n",i40e_stat_str(hw,aq_ret),i40e_aq_str(hw,hw->aq.asq_last_status));
    }
    #line 2252 
    aq_ret = i40e_aq_set_vsi_multicast_promiscuous(hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)promisc) != 0),(struct i40e_asq_cmd_details *)0);
    #line 2256 
    if (aq_ret != I40E_SUCCESS) {
      #line 2257 
      ;
      #line 2257 
      _dev_info(& (pf->pdev)->dev,(char *)"set multicast promisc failed, err %s, aq_err %s\n",i40e_stat_str(hw,aq_ret),i40e_aq_str(hw,hw->aq.asq_last_status));
    }
  }
  #line 2264 
  if (aq_ret == I40E_SUCCESS) 
                              #line 2265 
                              pf->cur_promisc = promisc;
  #line 2267 
  return (int)aq_ret;
}

#line 2278  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_sync_vsi_filters(struct i40e_vsi *vsi)
{
  #line 2280 
  struct hlist_head tmp_add_list;
  #line 2280 
  struct hlist_head tmp_del_list;
  #line 2281 
  struct i40e_mac_filter *f;
  #line 2282 
  struct i40e_new_mac_filter *new;
  #line 2284 
  bool old_overflow;
  #line 2284 
  bool new_overflow;
  #line 2291 
  struct hlist_node *h;
  #line 2292 
  struct i40e_pf *pf;
  #line 2296 
  u16 cmd_flags;
  #line 2297 
  int list_size;
  #line 2298 
  int bkt;
  #line 2301 
  struct i40e_aqc_add_macvlan_element_data *add_list;
  #line 2302 
  struct i40e_aqc_remove_macvlan_element_data *del_list;
  #line 2282 
  struct i40e_new_mac_filter *add_head = (struct i40e_new_mac_filter *)0;
  #line 2283 
  struct i40e_hw *hw = & (vsi->back)->hw;
  #line 2285 
  unsigned int failed_filters = 0U;
  #line 2286 
  unsigned int vlan_filters = 0U;
  #line 2287 
  char vsi_name[16U] = {(char)'P', (char)'F', (char)'\000'};
  #line 2288 
  int filter_list_len = 0;
  #line 2289 
  i40e_status aq_ret = 0;
  #line 2290 
  u32 changed_flags = 0U;
  #line 2293 
  int num_add = 0;
  #line 2294 
  int num_del = 0;
  #line 2295 
  int retval = 0;
  #line 2304 
  while (1) {
    #line 2304 
    if (! ((int)test_and_set_bit(2L,(unsigned long *)(& vsi->state)) != 0)) 
      #line 2304 
      break;
    #line 2305 
    usleep_range(1000UL,2000UL);
  }
  #line 2306 
  pf = vsi->back;
  #line 2308 
  old_overflow = test_bit(3L,(unsigned long *)(& vsi->state));
  #line 2310 
  if (vsi->netdev != (struct net_device *)0) {
    #line 2311 
    changed_flags = vsi->current_netdev_flags ^ (vsi->netdev)->flags;
    #line 2312 
    vsi->current_netdev_flags = (vsi->netdev)->flags;
  }
  #line 2315 
  tmp_add_list.first = (struct hlist_node *)0;
  #line 2316 
  tmp_del_list.first = (struct hlist_node *)0;
  #line 2318 
  if (vsi->type == (unsigned int)I40E_VSI_SRIOV) 
                                                 #line 2319 
                                                 snprintf((char *)(& vsi_name),15UL,(char *)"VF %d",(int)vsi->vf_id);
  else 
    #line 2320 
    if (vsi->type != (unsigned int)I40E_VSI_MAIN) 
                                                  #line 2321 
                                                  snprintf((char *)(& vsi_name),15UL,(char *)"vsi %d",(int)vsi->seid);
  #line 2323 
  if ((vsi->flags & 1UL) != 0UL) {
    #line 2324 
    vsi->flags &= 18446744073709551614UL;
    #line 2326 
    cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
    #line 2328 
    bkt = 0;
    #line 2328 
    f = (struct i40e_mac_filter *)0;
    #line 2328 
    while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
      {
        #line 2328 
        void *__mptr;
        #line 2328 
        struct i40e_mac_filter *tmp_1;
        {
          #line 2328 
          struct hlist_node *____ptr = vsi->mac_filter_hash[bkt].first;
          #line 2328 
          if (____ptr != (struct hlist_node *)0) {
            #line 2328 
            __mptr = (void *)____ptr;
            #line 2328 
            tmp_1 = ((struct i40e_mac_filter *)__mptr);
          }
          else 
               #line 2328 
               tmp_1 = (struct i40e_mac_filter *)0;
          }
        #line 2328 
        f = tmp_1;
        #line 2328 
        while (1) {
          #line 2328 
          void *__mptr_0;
          #line 2328 
          struct i40e_mac_filter *tmp_4;
          #line 2328 
          if (f != (struct i40e_mac_filter *)0) {
            #line 2328 
            h = f->hlist.next;
            #line 2328 
            if (! (1 != 0)) 
                            #line 2328 
                            break;
          }
          else 
               #line 2328 
               break;
          #line 2329 
          if (f->state == (unsigned int)I40E_FILTER_REMOVE) {
            #line 2331 
            hash_del(& f->hlist);
            #line 2332 
            hlist_add_head_0(& f->hlist,& tmp_del_list);
            #line 2335 
            goto __Cont;
          }
          #line 2337 
          if (f->state == (unsigned int)I40E_FILTER_NEW) {
            #line 2339 
            new = (struct i40e_new_mac_filter *)kzalloc_1(32UL,2592U);
            #line 2340 
            if (new == (struct i40e_new_mac_filter *)0) 
                                                        #line 2341 
                                                        goto err_no_memory_locked;
            #line 2344 
            new->f = f;
            #line 2345 
            new->state = f->state;
            #line 2348 
            hlist_add_head_0(& new->hlist,& tmp_add_list);
          }
          #line 2355 
          if ((int)f->vlan > 0) 
                                #line 2356 
                                vlan_filters ++;
          #line 2328 
          __Cont: { /* sequence */
                    {
                      #line 2328 
                      struct hlist_node *____ptr_0 = h;
                      #line 2328 
                      if (____ptr_0 != (struct hlist_node *)0) {
                        #line 2328 
                        __mptr_0 = (void *)____ptr_0;
                        #line 2328 
                        tmp_4 = ((struct i40e_mac_filter *)__mptr_0);
                      }
                      else 
                           #line 2328 
                           tmp_4 = (struct i40e_mac_filter *)0;
                      }
                    #line 2328 
                    f = tmp_4;
                  }
        }
      }
      #line 2328 
      bkt ++;
    }
    #line 2359 
    retval = i40e_correct_mac_vlan_filters(vsi,& tmp_add_list,& tmp_del_list,(int)vlan_filters);
    #line 2363 
    if (retval != 0) 
                     #line 2364 
                     goto err_no_memory_locked;
    #line 2366 
    cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  }
  #line 2370 
  if (hlist_empty(& tmp_del_list) == 0) {
    #line 2379 
    void *__mptr_1;
    #line 2379 
    struct i40e_mac_filter *tmp_9;
    #line 2371 
    filter_list_len = (int)((unsigned int)hw->aq.asq_buf_size / 16U);
    #line 2373 
    list_size = (int)((unsigned long)filter_list_len * (unsigned long)16U);
    #line 2375 
    del_list = (struct i40e_aqc_remove_macvlan_element_data *)kzalloc_1((unsigned long)list_size,2592U);
    #line 2376 
    if (del_list == (struct i40e_aqc_remove_macvlan_element_data *)0) 
      #line 2377 
      goto err_no_memory;
    {
      #line 2379 
      struct hlist_node *____ptr_1 = tmp_del_list.first;
      #line 2379 
      if (____ptr_1 != (struct hlist_node *)0) {
        #line 2379 
        __mptr_1 = (void *)____ptr_1;
        #line 2379 
        tmp_9 = ((struct i40e_mac_filter *)__mptr_1);
      }
      else 
           #line 2379 
           tmp_9 = (struct i40e_mac_filter *)0;
      }
    #line 2379 
    f = tmp_9;
    #line 2379 
    while (1) {
      #line 2379 
      void *__mptr_2;
      #line 2379 
      struct i40e_mac_filter *tmp_12;
      #line 2379 
      if (f != (struct i40e_mac_filter *)0) {
        #line 2379 
        h = f->hlist.next;
        #line 2379 
        if (! (1 != 0)) 
                        #line 2379 
                        break;
      }
      else 
           #line 2379 
           break;
      {
        #line 2380 
        cmd_flags = (unsigned short)0U;
        #line 2385 
        if ((int)is_broadcast_ether_addr((u8 *)(& f->macaddr)) != 0) {
          #line 2386 
          i40e_aqc_broadcast_filter(vsi,(char *)(& vsi_name),f);
          #line 2388 
          hlist_del_0(& f->hlist);
          #line 2389 
          kfree((void *)f);
          #line 2390 
          goto __Cont_0;
        }
        #line 2394 
        ether_addr_copy((u8 *)(& (del_list + (unsigned long)num_del)->mac_addr),(u8 *)(& f->macaddr));
        #line 2395 
        if ((int)f->vlan == -1) {
          #line 2396 
          (del_list + (unsigned long)num_del)->vlan_tag = (unsigned short)0U;
          #line 2397 
          cmd_flags = (unsigned short)((unsigned int)cmd_flags | 8U);
        }
        else 
             #line 2399 
             (del_list + (unsigned long)num_del)->vlan_tag = (unsigned short)f->vlan;
        #line 2403 
        cmd_flags = (unsigned short)((unsigned int)cmd_flags | 1U);
        #line 2404 
        (del_list + (unsigned long)num_del)->flags = (unsigned char)cmd_flags;
        #line 2405 
        num_del ++;
        #line 2408 
        if (num_del == filter_list_len) {
          #line 2409 
          i40e_aqc_del_filters(vsi,(char *)(& vsi_name),del_list,num_del,& retval);
          #line 2411 
          memset((void *)del_list,0,(unsigned long)list_size);
          #line 2412 
          num_del = 0;
        }
        #line 2417 
        hlist_del_0(& f->hlist);
        #line 2418 
        kfree((void *)f);
      }
      #line 2379 
      __Cont_0: { /* sequence */
                  {
                    #line 2379 
                    struct hlist_node *____ptr_2 = h;
                    #line 2379 
                    if (____ptr_2 != (struct hlist_node *)0) {
                      #line 2379 
                      __mptr_2 = (void *)____ptr_2;
                      #line 2379 
                      tmp_12 = ((struct i40e_mac_filter *)__mptr_2);
                    }
                    else 
                         #line 2379 
                         tmp_12 = (struct i40e_mac_filter *)0;
                    }
                  #line 2379 
                  f = tmp_12;
                }
    }
    #line 2421 
    if (num_del != 0) 
                      #line 2422 
                      i40e_aqc_del_filters(vsi,(char *)(& vsi_name),del_list,num_del,& retval);
    #line 2426 
    kfree((void *)del_list);
    #line 2427 
    del_list = (struct i40e_aqc_remove_macvlan_element_data *)0;
  }
  #line 2430 
  if (hlist_empty(& tmp_add_list) == 0) {
    #line 2441 
    void *__mptr_3;
    #line 2490 
    void *__mptr_5;
    #line 2441 
    struct i40e_new_mac_filter *tmp_18;
    #line 2490 
    struct i40e_new_mac_filter *tmp_26;
    #line 2432 
    filter_list_len = (int)((unsigned int)hw->aq.asq_buf_size / 16U);
    #line 2434 
    list_size = (int)((unsigned long)filter_list_len * (unsigned long)16U);
    #line 2436 
    add_list = (struct i40e_aqc_add_macvlan_element_data *)kzalloc_1((unsigned long)list_size,2592U);
    #line 2437 
    if (add_list == (struct i40e_aqc_add_macvlan_element_data *)0) 
                                                                   #line 2438 
                                                                   goto err_no_memory;
    #line 2440 
    num_add = 0;
    {
      #line 2441 
      struct hlist_node *____ptr_3 = tmp_add_list.first;
      #line 2441 
      if (____ptr_3 != (struct hlist_node *)0) {
        #line 2441 
        __mptr_3 = (void *)____ptr_3;
        #line 2441 
        tmp_18 = ((struct i40e_new_mac_filter *)__mptr_3);
      }
      else 
           #line 2441 
           tmp_18 = (struct i40e_new_mac_filter *)0;
      }
    #line 2441 
    new = tmp_18;
    #line 2441 
    while (1) {
      #line 2441 
      void *__mptr_4;
      #line 2441 
      struct i40e_new_mac_filter *tmp_21;
      #line 2441 
      if (new != (struct i40e_new_mac_filter *)0) {
        #line 2441 
        h = new->hlist.next;
        #line 2441 
        if (! (1 != 0)) 
                        #line 2441 
                        break;
      }
      else 
           #line 2441 
           break;
      {
        #line 2445 
        if ((int)is_broadcast_ether_addr((u8 *)(& (new->f)->macaddr)) != 0) {
          #line 2446 
          if (i40e_aqc_broadcast_filter(vsi,(char *)(& vsi_name),new->f) != I40E_SUCCESS) 
            #line 2448 
            new->state = I40E_FILTER_FAILED; else 
                                                  #line 2450 
                                                  new->state = I40E_FILTER_ACTIVE;
          #line 2451 
          goto __Cont_1;
        }
        #line 2455 
        if (num_add == 0) 
                          #line 2456 
                          add_head = new;
        #line 2457 
        cmd_flags = (unsigned short)0U;
        #line 2458 
        ether_addr_copy((u8 *)(& (add_list + (unsigned long)num_add)->mac_addr),(u8 *)(& (new->f)->macaddr));
        #line 2460 
        if ((int)(new->f)->vlan == -1) {
          #line 2461 
          (add_list + (unsigned long)num_add)->vlan_tag = (unsigned short)0U;
          #line 2462 
          cmd_flags = (unsigned short)((unsigned int)cmd_flags | 4U);
        }
        else 
             #line 2464 
             (add_list + (unsigned long)num_add)->vlan_tag = (unsigned short)(new->f)->vlan;
        #line 2467 
        (add_list + (unsigned long)num_add)->queue_number = (unsigned short)0U;
        #line 2469 
        (add_list + (unsigned long)num_add)->match_method = (unsigned char)255U;
        #line 2470 
        cmd_flags = (unsigned short)((unsigned int)cmd_flags | 1U);
        #line 2471 
        (add_list + (unsigned long)num_add)->flags = cmd_flags;
        #line 2472 
        num_add ++;
        #line 2475 
        if (num_add == filter_list_len) {
          #line 2476 
          i40e_aqc_add_filters(vsi,(char *)(& vsi_name),add_list,add_head,num_add);
          #line 2478 
          memset((void *)add_list,0,(unsigned long)list_size);
          #line 2479 
          num_add = 0;
        }
      }
      #line 2441 
      __Cont_1: { /* sequence */
                  {
                    #line 2441 
                    struct hlist_node *____ptr_4 = h;
                    #line 2441 
                    if (____ptr_4 != (struct hlist_node *)0) {
                      #line 2441 
                      __mptr_4 = (void *)____ptr_4;
                      #line 2441 
                      tmp_21 = ((struct i40e_new_mac_filter *)__mptr_4);
                    }
                    else 
                         #line 2441 
                         tmp_21 = (struct i40e_new_mac_filter *)0;
                    }
                  #line 2441 
                  new = tmp_21;
                }
    }
    #line 2482 
    if (num_add != 0) 
                      #line 2483 
                      i40e_aqc_add_filters(vsi,(char *)(& vsi_name),add_list,add_head,num_add);
    #line 2489 
    cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
    {
      #line 2490 
      struct hlist_node *____ptr_5 = tmp_add_list.first;
      #line 2490 
      if (____ptr_5 != (struct hlist_node *)0) {
        #line 2490 
        __mptr_5 = (void *)____ptr_5;
        #line 2490 
        tmp_26 = ((struct i40e_new_mac_filter *)__mptr_5);
      }
      else 
           #line 2490 
           tmp_26 = (struct i40e_new_mac_filter *)0;
      }
    #line 2490 
    new = tmp_26;
    #line 2490 
    while (1) {
      #line 2490 
      struct i40e_new_mac_filter *tmp_29;
      #line 2490 
      void *__mptr_6;
      #line 2490 
      if (new != (struct i40e_new_mac_filter *)0) {
        #line 2490 
        h = new->hlist.next;
        #line 2490 
        if (! (1 != 0)) 
                        #line 2490 
                        break;
      }
      else 
           #line 2490 
           break;
      #line 2492 
      if ((new->f)->state == (unsigned int)I40E_FILTER_NEW) 
                                                            #line 2493 
                                                            (new->f)->state = new->state;
      #line 2494 
      hlist_del_0(& new->hlist);
      #line 2495 
      kfree((void *)new);
      {
        #line 2490 
        struct hlist_node *____ptr_6 = h;
        #line 2490 
        if (____ptr_6 != (struct hlist_node *)0) {
          #line 2490 
          __mptr_6 = (void *)____ptr_6;
          #line 2490 
          tmp_29 = ((struct i40e_new_mac_filter *)__mptr_6);
        }
        else 
             #line 2490 
             tmp_29 = (struct i40e_new_mac_filter *)0;
        }
      #line 2490 
      new = tmp_29;
    }
    #line 2497 
    cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
    #line 2498 
    kfree((void *)add_list);
    #line 2499 
    add_list = (struct i40e_aqc_add_macvlan_element_data *)0;
  }
  #line 2503 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 2504 
  vsi->active_filters = 0U;
  #line 2505 
  bkt = 0;
  #line 2505 
  f = (struct i40e_mac_filter *)0;
  #line 2505 
  while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
    {
      #line 2505 
      void *__mptr_7;
      #line 2505 
      struct i40e_mac_filter *tmp_33;
      {
        #line 2505 
        struct hlist_node *____ptr_7 = vsi->mac_filter_hash[bkt].first;
        #line 2505 
        if (____ptr_7 != (struct hlist_node *)0) {
          #line 2505 
          __mptr_7 = (void *)____ptr_7;
          #line 2505 
          tmp_33 = ((struct i40e_mac_filter *)__mptr_7);
        }
        else 
             #line 2505 
             tmp_33 = (struct i40e_mac_filter *)0;
        }
      #line 2505 
      f = tmp_33;
      #line 2505 
      while (f != (struct i40e_mac_filter *)0) {
        #line 2505 
        void *__mptr_8;
        #line 2505 
        struct i40e_mac_filter *tmp_36;
        #line 2506 
        if (f->state == (unsigned int)I40E_FILTER_ACTIVE) 
                                                          #line 2507 
                                                          (vsi->active_filters) ++;
        else 
          #line 2508 
          if (f->state == (unsigned int)I40E_FILTER_FAILED) 
                                                            #line 2509 
                                                            failed_filters ++;
        {
          #line 2505 
          struct hlist_node *____ptr_8 = f->hlist.next;
          #line 2505 
          if (____ptr_8 != (struct hlist_node *)0) {
            #line 2505 
            __mptr_8 = (void *)____ptr_8;
            #line 2505 
            tmp_36 = ((struct i40e_mac_filter *)__mptr_8);
          }
          else 
               #line 2505 
               tmp_36 = (struct i40e_mac_filter *)0;
          }
        #line 2505 
        f = tmp_36;
      }
    }
    #line 2505 
    bkt ++;
  }
  #line 2511 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 2517 
  if (((int)old_overflow != 0 && failed_filters == 0U) && vsi->active_filters < vsi->promisc_threshold) {
    #line 2519 
    _dev_info(& (pf->pdev)->dev,(char *)"filter logjam cleared on %s, leaving overflow promiscuous mode\n",(char *)(& vsi_name));
    #line 2522 
    cif_clear_bit_1(3L,(unsigned long *)(& vsi->state));
    #line 2523 
    vsi->promisc_threshold = 0U;
  }
  #line 2527 
  if (vsi->type == (unsigned int)I40E_VSI_SRIOV && ! (pf->vf + (unsigned long)vsi->vf_id)->trusted) {
    #line 2528 
    cif_clear_bit_1(3L,(unsigned long *)(& vsi->state));
    #line 2529 
    goto out;
  }
  #line 2532 
  new_overflow = test_bit(3L,(unsigned long *)(& vsi->state));
  #line 2537 
  if (! old_overflow && (int)new_overflow != 0) 
                                                #line 2538 
                                                vsi->promisc_threshold = (vsi->active_filters * 3U) / 4U;
  #line 2541 
  if ((changed_flags & 512U) != 0U) {
    #line 2542 
    bool cur_multipromisc;
    #line 2544 
    cur_multipromisc = (_Bool)((vsi->current_netdev_flags & 512U) != 0U);
    #line 2545 
    aq_ret = i40e_aq_set_vsi_multicast_promiscuous(& (vsi->back)->hw,(unsigned short)((int)vsi->seid),(_Bool)((bool)((int)cur_multipromisc) != 0),(struct i40e_asq_cmd_details *)0);
    #line 2549 
    if (aq_ret != I40E_SUCCESS) {
      #line 2550 
      retval = i40e_aq_rc_to_posix((int)aq_ret,(int)hw->aq.asq_last_status);
      #line 2552 
      ;
      #line 2552 
      _dev_info(& (pf->pdev)->dev,(char *)"set multi promisc failed on %s, err %s aq_err %s\n",(char *)(& vsi_name),i40e_stat_str(hw,aq_ret),i40e_aq_str(hw,hw->aq.asq_last_status));
    }
    else {
      #line 2558 
      char *tmp_40;
      #line 2558 
      if ((int)cur_multipromisc != 0) 
                                      #line 2558 
                                      tmp_40 = (char *)"entering"; else 
                                                                    #line 2558 
                                                                    tmp_40 = (char *)"leaving";
      #line 2558 
      ;
      #line 2558 
      ;
      #line 2558 
      _dev_info(& (pf->pdev)->dev,(char *)"%s is %s allmulti mode.\n",(char *)(& (vsi->netdev)->name),tmp_40);
    }
  }
  #line 2564 
  if ((changed_flags & 256U) != 0U || (int)old_overflow != (int)new_overflow) {
    #line 2565 
    bool cur_promisc;
    #line 2567 
    cur_promisc = (_Bool)(((vsi->current_netdev_flags & 256U) != 0U || (int)new_overflow != 0) != 0);
    #line 2569 
    aq_ret = (enum i40e_status_code)i40e_set_promiscuous(pf,(_Bool)((bool)((int)cur_promisc) != 0));
    #line 2570 
    if (aq_ret != I40E_SUCCESS) {
      #line 2573 
      char *tmp_42;
      #line 2573 
      char *tmp_43;
      #line 2573 
      char *tmp_44;
      #line 2571 
      retval = i40e_aq_rc_to_posix((int)aq_ret,(int)hw->aq.asq_last_status);
      #line 2573 
      tmp_42 = i40e_aq_str(hw,hw->aq.asq_last_status);
      #line 2573 
      tmp_43 = i40e_stat_str(hw,aq_ret);
      #line 2573 
      if ((int)cur_promisc != 0) 
                                 #line 2573 
                                 tmp_44 = (char *)"on"; else 
                                                             #line 2573 
                                                             tmp_44 = (char *)"off";
      #line 2573 
      ;
      #line 2573 
      _dev_info(& (pf->pdev)->dev,(char *)"Setting promiscuous %s failed on %s, err %s aq_err %s\n",tmp_44,(char *)(& vsi_name),tmp_43,tmp_42);
    }
  }
  #line 2581 
  out: 
       #line 2581 
  ;
  #line 2583 
  if (retval != 0) 
                   #line 2584 
                   vsi->flags |= 1UL;
  #line 2586 
  cif_clear_bit_1(2L,(unsigned long *)(& vsi->state));
  #line 2587 
  return retval;
  #line 2589 
  err_no_memory: 
                 #line 2589 
  ;
  #line 2591 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 2592 
  err_no_memory_locked: 
                        #line 2592 
  ;
  #line 2593 
  i40e_undo_del_filter_entries(vsi,& tmp_del_list);
  #line 2594 
  i40e_undo_add_filter_entries(vsi,& tmp_add_list);
  #line 2595 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 2597 
  vsi->flags |= 1UL;
  #line 2598 
  cif_clear_bit_1(2L,(unsigned long *)(& vsi->state));
  #line 2599 
  return -12;
}

#line 2606  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_sync_filters_subtask(struct i40e_pf *pf)
{
  #line 2608 
  int v;
  #line 2610 
  if (pf == (struct i40e_pf *)0) 
                                 #line 2611 
                                 return;
  #line 2612 
  if (! test_and_set_bit(27L,(unsigned long *)(& pf->state))) 
                                                              #line 2613 
                                                              return;
  #line 2614 
  if ((int)test_and_set_bit(26L,(unsigned long *)(& pf->state)) != 0) {
    #line 2615 
    cif_set_bit_1(27L,(unsigned long *)(& pf->state));
    #line 2616 
    return;
  }
  #line 2619 
  v = 0;
  #line 2619 
  while ((int)pf->num_alloc_vsi > v) {
    #line 2620 
    if (*(pf->vsi + (unsigned long)v) != (struct i40e_vsi *)0 && ((*(pf->vsi + (unsigned long)v))->flags & 1UL) != 0UL) {
      #line 2622 
      int ret = i40e_sync_vsi_filters(*(pf->vsi + (unsigned long)v));
      #line 2624 
      if (ret != 0) {
        #line 2626 
        cif_set_bit_1(27L,(unsigned long *)(& pf->state));
        #line 2628 
        break;
      }
    }
    #line 2619 
    v ++;
  }
  #line 2632 
  cif_clear_bit_1(26L,(unsigned long *)(& pf->state));
  #line 2633 
  return;
}

#line 2639  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_max_xdp_frame_size(struct i40e_vsi *vsi)
{
  #line 2641 
  if (((unsigned long)(vsi->back)->flags & 65536UL) != 0UL) 
                                                            #line 2642 
                                                            return 2048; else 
                                                                    #line 2644 
                                                                    return 3072;
}

#line 2654  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_change_mtu(struct net_device *netdev, int new_mtu)
{
  #line 2656 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2657 
  struct i40e_vsi *vsi = np->vsi;
  #line 2658 
  struct i40e_pf *pf = vsi->back;
  #line 2660 
  if ((int)i40e_enabled_xdp_vsi_0(vsi) != 0) {
    #line 2661 
    int frame_size = new_mtu + 22;
    #line 2663 
    ;
    #line 2663 
    if (i40e_max_xdp_frame_size(vsi) < frame_size) 
                                                   #line 2664 
                                                   return -22;
  }
  {
    #line 2667 
    bool branch;
    #line 2667 
    struct _ddebug __UNIQUE_ID_ddebug592 = {.modname = (char *)"i40e", .function = (char *)"i40e_change_mtu", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"changing MTU from %d to %d\n", .lineno = (unsigned int)2667U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 2667 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug592.key.dd_key_false.key,(_Bool)0);
    #line 2667 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 2667 
                                                __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug592,netdev,(char *)"changing MTU from %d to %d\n",netdev->mtu,new_mtu);
  }
  #line 2669 
  netdev->mtu = (unsigned int)new_mtu;
  #line 2670 
  if ((int)netif_running(netdev) != 0) 
                                       #line 2671 
                                       i40e_vsi_reinit_locked(vsi);
  #line 2672 
  cif_set_bit_1(30L,(unsigned long *)(& pf->state));
  #line 2673 
  cif_set_bit_1(31L,(unsigned long *)(& pf->state));
  #line 2674 
  return 0;
}

#line 2683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
{
  #line 2685 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2686 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 2688 
  switch (cmd) {
    #line 2689 
    case 35249: 
                #line 2689 
    ;
    #line 2690 
    return i40e_ptp_get_ts_config(pf,ifr);
    #line 2691 
    case 35248: 
                #line 2691 
    ;
    #line 2692 
    return i40e_ptp_set_ts_config(pf,ifr);
    #line 2693 
    default: 
             #line 2693 
    ;
    #line 2694 
    return -95;
  }
}

#line 2702  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_vlan_stripping_enable(struct i40e_vsi *vsi)
{
  #line 2704 
  struct i40e_vsi_context ctxt;
  #line 2705 
  i40e_status ret;
  #line 2708 
  if ((unsigned int)vsi->info.pvid != 0U) 
                                          #line 2709 
                                          return;
  #line 2711 
  if (((int)vsi->info.valid_sections & 4) != 0 && ((int)vsi->info.port_vlan_flags & 3) == 0) 
    #line 2714 
    return;
  #line 2716 
  vsi->info.valid_sections = (unsigned short)4U;
  #line 2717 
  vsi->info.port_vlan_flags = (unsigned char)3U;
  #line 2720 
  ctxt.seid = vsi->seid;
  #line 2721 
  ctxt.info = vsi->info;
  #line 2722 
  ret = i40e_aq_update_vsi_params(& (vsi->back)->hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  #line 2723 
  if (ret != I40E_SUCCESS) {
    #line 2724 
    ;
    #line 2724 
    _dev_info(& ((vsi->back)->pdev)->dev,(char *)"update vlan stripping failed, err %s aq_err %s\n",i40e_stat_str(& (vsi->back)->hw,ret),i40e_aq_str(& (vsi->back)->hw,(vsi->back)->hw.aq.asq_last_status));
  }
  #line 2725 
  return;
}

#line 2736  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_vlan_stripping_disable(struct i40e_vsi *vsi)
{
  #line 2738 
  struct i40e_vsi_context ctxt;
  #line 2739 
  i40e_status ret;
  #line 2742 
  if ((unsigned int)vsi->info.pvid != 0U) 
                                          #line 2743 
                                          return;
  #line 2745 
  if (((int)vsi->info.valid_sections & 4) != 0 && ((int)vsi->info.port_vlan_flags & 24) == 24) 
    #line 2749 
    return;
  #line 2751 
  vsi->info.valid_sections = (unsigned short)4U;
  #line 2752 
  vsi->info.port_vlan_flags = (unsigned char)27U;
  #line 2755 
  ctxt.seid = vsi->seid;
  #line 2756 
  ctxt.info = vsi->info;
  #line 2757 
  ret = i40e_aq_update_vsi_params(& (vsi->back)->hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  #line 2758 
  if (ret != I40E_SUCCESS) {
    #line 2759 
    ;
    #line 2759 
    _dev_info(& ((vsi->back)->pdev)->dev,(char *)"update vlan stripping failed, err %s aq_err %s\n",i40e_stat_str(& (vsi->back)->hw,ret),i40e_aq_str(& (vsi->back)->hw,(vsi->back)->hw.aq.asq_last_status));
  }
  #line 2760 
  return;
}

#line 2780  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_add_vlan_all_mac(struct i40e_vsi *vsi, s16 vid)
{
  #line 2782 
  struct i40e_mac_filter *f;
  #line 2782 
  struct i40e_mac_filter *add_f;
  #line 2783 
  struct hlist_node *h;
  #line 2784 
  int bkt;
  #line 2786 
  bkt = 0;
  #line 2786 
  f = (struct i40e_mac_filter *)0;
  #line 2786 
  while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
    {
      #line 2786 
      void *__mptr;
      #line 2786 
      struct i40e_mac_filter *tmp_0;
      {
        #line 2786 
        struct hlist_node *____ptr = vsi->mac_filter_hash[bkt].first;
        #line 2786 
        if (____ptr != (struct hlist_node *)0) {
          #line 2786 
          __mptr = (void *)____ptr;
          #line 2786 
          tmp_0 = ((struct i40e_mac_filter *)__mptr);
        }
        else 
             #line 2786 
             tmp_0 = (struct i40e_mac_filter *)0;
        }
      #line 2786 
      f = tmp_0;
      #line 2786 
      while (1) {
        #line 2786 
        struct i40e_mac_filter *tmp_3;
        #line 2786 
        void *__mptr_0;
        #line 2786 
        if (f != (struct i40e_mac_filter *)0) {
          #line 2786 
          h = f->hlist.next;
          #line 2786 
          if (! (1 != 0)) 
                          #line 2786 
                          break;
        }
        else 
             #line 2786 
             break;
        #line 2787 
        if (f->state == (unsigned int)I40E_FILTER_REMOVE) 
                                                          #line 2788 
                                                          goto __Cont;
        #line 2789 
        add_f = i40e_add_filter(vsi,(u8 *)(& f->macaddr),(short)((int)vid));
        #line 2790 
        if (add_f == (struct i40e_mac_filter *)0) {
          #line 2791 
          _dev_info(& ((vsi->back)->pdev)->dev,(char *)"Could not add vlan filter %d for %pM\n",(int)vid,(u8 *)(& f->macaddr));
          #line 2794 
          return -12;
        }
        #line 2786 
        __Cont: { /* sequence */
                  {
                    #line 2786 
                    struct hlist_node *____ptr_0 = h;
                    #line 2786 
                    if (____ptr_0 != (struct hlist_node *)0) {
                      #line 2786 
                      __mptr_0 = (void *)____ptr_0;
                      #line 2786 
                      tmp_3 = ((struct i40e_mac_filter *)__mptr_0);
                    }
                    else 
                         #line 2786 
                         tmp_3 = (struct i40e_mac_filter *)0;
                    }
                  #line 2786 
                  f = tmp_3;
                }
      }
    }
    #line 2786 
    bkt ++;
  }
  #line 2798 
  return 0;
}

#line 2806  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_vsi_add_vlan(struct i40e_vsi *vsi, u16 vid)
{
  #line 2808 
  int err;
  #line 2810 
  if ((unsigned int)vsi->info.pvid != 0U) 
                                          #line 2811 
                                          return -22;
  #line 2821 
  if ((unsigned int)vid == 0U) 
                               #line 2822 
                               return 0;
  #line 2825 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 2826 
  err = i40e_add_vlan_all_mac(vsi,(short)((int)((short)vid)));
  #line 2827 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 2828 
  if (err != 0) 
                #line 2829 
                return err;
  #line 2834 
  i40e_service_event_schedule(vsi->back);
  #line 2835 
  return 0;
}

#line 2851  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_rm_vlan_all_mac(struct i40e_vsi *vsi, s16 vid)
{
  #line 2853 
  struct i40e_mac_filter *f;
  #line 2854 
  struct hlist_node *h;
  #line 2855 
  int bkt;
  #line 2857 
  bkt = 0;
  #line 2857 
  f = (struct i40e_mac_filter *)0;
  #line 2857 
  while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
    {
      #line 2857 
      void *__mptr;
      #line 2857 
      struct i40e_mac_filter *tmp_0;
      {
        #line 2857 
        struct hlist_node *____ptr = vsi->mac_filter_hash[bkt].first;
        #line 2857 
        if (____ptr != (struct hlist_node *)0) {
          #line 2857 
          __mptr = (void *)____ptr;
          #line 2857 
          tmp_0 = ((struct i40e_mac_filter *)__mptr);
        }
        else 
             #line 2857 
             tmp_0 = (struct i40e_mac_filter *)0;
        }
      #line 2857 
      f = tmp_0;
      #line 2857 
      while (1) {
        #line 2857 
        void *__mptr_0;
        #line 2857 
        struct i40e_mac_filter *tmp_3;
        #line 2857 
        if (f != (struct i40e_mac_filter *)0) {
          #line 2857 
          h = f->hlist.next;
          #line 2857 
          if (! (1 != 0)) 
                          #line 2857 
                          break;
        }
        else 
             #line 2857 
             break;
        #line 2858 
        if ((int)f->vlan == (int)vid) 
                                      #line 2859 
                                      __i40e_del_filter(vsi,f);
        {
          #line 2857 
          struct hlist_node *____ptr_0 = h;
          #line 2857 
          if (____ptr_0 != (struct hlist_node *)0) {
            #line 2857 
            __mptr_0 = (void *)____ptr_0;
            #line 2857 
            tmp_3 = ((struct i40e_mac_filter *)__mptr_0);
          }
          else 
               #line 2857 
               tmp_3 = (struct i40e_mac_filter *)0;
          }
        #line 2857 
        f = tmp_3;
      }
    }
    #line 2857 
    bkt ++;
  }
  #line 2861 
  return;
}

#line 2868  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_vsi_kill_vlan(struct i40e_vsi *vsi, u16 vid)
{
  #line 2870 
  if ((unsigned int)vid == 0U || (unsigned int)vsi->info.pvid != 0U) 
    #line 2871 
    return;
  #line 2873 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 2874 
  i40e_rm_vlan_all_mac(vsi,(short)((int)((short)vid)));
  #line 2875 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 2880 
  i40e_service_event_schedule(vsi->back);
  #line 2881 
  return;
}

#line 2891  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vlan_rx_add_vid(struct net_device *netdev, __be16 proto, u16 vid)
{
  #line 2894 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2895 
  struct i40e_vsi *vsi = np->vsi;
  #line 2896 
  int ret = 0;
  #line 2898 
  if ((unsigned int)vid > 4095U) 
                                 #line 2899 
                                 return -22;
  #line 2901 
  ret = i40e_vsi_add_vlan(vsi,(unsigned short)((int)vid));
  #line 2902 
  if (ret == 0) 
                #line 2903 
                cif_set_bit_1((long)vid,(unsigned long *)(& vsi->active_vlans));
  #line 2905 
  return ret;
}

#line 2914  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vlan_rx_add_vid_up(struct net_device *netdev, __be16 proto, u16 vid)
{
  #line 2917 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2918 
  struct i40e_vsi *vsi = np->vsi;
  #line 2920 
  if ((unsigned int)vid > 4095U) 
                                 #line 2921 
                                 return;
  #line 2922 
  cif_set_bit_1((long)vid,(unsigned long *)(& vsi->active_vlans));
  #line 2923 
  return;
}

#line 2933  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vlan_rx_kill_vid(struct net_device *netdev, __be16 proto, u16 vid)
{
  #line 2936 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2937 
  struct i40e_vsi *vsi = np->vsi;
  #line 2943 
  i40e_vsi_kill_vlan(vsi,(unsigned short)((int)vid));
  #line 2945 
  cif_clear_bit_1((long)vid,(unsigned long *)(& vsi->active_vlans));
  #line 2947 
  return 0;
}

#line 2954  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_restore_vlan(struct i40e_vsi *vsi)
{
  #line 2956 
  u16 vid;
  #line 2958 
  if (vsi->netdev == (struct net_device *)0) 
                                             #line 2959 
                                             return;
  #line 2961 
  if (((vsi->netdev)->features & 256ULL) != 0ULL) 
                                                  #line 2962 
                                                  i40e_vlan_stripping_enable(vsi); else 
                                                                    #line 2964 
                                                                    i40e_vlan_stripping_disable(vsi);
  #line 2966 
  vid = (unsigned short)cif_find_first_bit_0((unsigned long *)(& vsi->active_vlans),4096UL);
  #line 2966 
  while ((unsigned int)vid <= 4095U) {
    #line 2967 
    i40e_vlan_rx_add_vid_up(vsi->netdev,(unsigned short)129,(unsigned short)((int)vid));
    #line 2966 
    vid = (unsigned short)cif_find_next_bit_0((unsigned long *)(& vsi->active_vlans),4096UL,
                            (unsigned long)((int)vid + 1));
  }
  #line 2968 
  return;
}

#line 2976  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_vsi_add_pvid(struct i40e_vsi *vsi, u16 vid)
{
  #line 2978 
  struct i40e_vsi_context ctxt;
  #line 2979 
  i40e_status ret;
  #line 2981 
  vsi->info.valid_sections = (unsigned short)4U;
  #line 2982 
  vsi->info.pvid = vid;
  #line 2983 
  vsi->info.port_vlan_flags = (unsigned char)21U;
  #line 2987 
  ctxt.seid = vsi->seid;
  #line 2988 
  ctxt.info = vsi->info;
  #line 2989 
  ret = i40e_aq_update_vsi_params(& (vsi->back)->hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  #line 2990 
  if (ret != I40E_SUCCESS) {
    #line 2991 
    ;
    #line 2991 
    _dev_info(& ((vsi->back)->pdev)->dev,(char *)"add pvid failed, err %s aq_err %s\n",i40e_stat_str(& (vsi->back)->hw,ret),i40e_aq_str(& (vsi->back)->hw,(vsi->back)->hw.aq.asq_last_status));
    #line 2996 
    return -2;
  }
  #line 2999 
  return 0;
}

#line 3008  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_vsi_remove_pvid(struct i40e_vsi *vsi)
{
  #line 3010 
  vsi->info.pvid = (unsigned short)0U;
  #line 3012 
  i40e_vlan_stripping_disable(vsi);
  #line 3013 
  return;
}

#line 3025  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_setup_tx_resources(struct i40e_vsi *vsi)
{
  #line 3027 
  int i;
  #line 3027 
  int err = 0;
  #line 3029 
  i = 0;
  #line 3029 
  while ((int)vsi->num_queue_pairs > i && err == 0) {
    #line 3030 
    err = i40e_setup_tx_descriptors(*(vsi->tx_rings + (unsigned long)i));
    #line 3029 
    i ++;
  }
  #line 3032 
  if (! i40e_enabled_xdp_vsi_0(vsi)) 
                                     #line 3033 
                                     return err;
  #line 3035 
  i = 0;
  #line 3035 
  while ((int)vsi->num_queue_pairs > i && err == 0) {
    #line 3036 
    err = i40e_setup_tx_descriptors(*(vsi->xdp_rings + (unsigned long)i));
    #line 3035 
    i ++;
  }
  #line 3038 
  return err;
}

#line 3047  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_free_tx_resources(struct i40e_vsi *vsi)
{
  #line 3049 
  int i;
  #line 3051 
  if (vsi->tx_rings != (struct i40e_ring **)0) {
    #line 3052 
    i = 0;
    #line 3052 
    while ((int)vsi->num_queue_pairs > i) {
      #line 3053 
      if (*(vsi->tx_rings + (unsigned long)i) != (struct i40e_ring *)0 && (*(vsi->tx_rings + (unsigned long)i))->desc != (void *)0) 
        #line 3054 
        i40e_free_tx_resources(*(vsi->tx_rings + (unsigned long)i));
      #line 3052 
      i ++;
    }
  }
  #line 3057 
  if (vsi->xdp_rings != (struct i40e_ring **)0) {
    #line 3058 
    i = 0;
    #line 3058 
    while ((int)vsi->num_queue_pairs > i) {
      #line 3059 
      if (*(vsi->xdp_rings + (unsigned long)i) != (struct i40e_ring *)0 && (*(vsi->xdp_rings + (unsigned long)i))->desc != (void *)0) 
        #line 3060 
        i40e_free_tx_resources(*(vsi->xdp_rings + (unsigned long)i));
      #line 3058 
      i ++;
    }
  }
  #line 3062 
  return;
}

#line 3074  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_setup_rx_resources(struct i40e_vsi *vsi)
{
  #line 3076 
  int i;
  #line 3076 
  int err = 0;
  #line 3078 
  i = 0;
  #line 3078 
  while ((int)vsi->num_queue_pairs > i && err == 0) {
    #line 3079 
    err = i40e_setup_rx_descriptors(*(vsi->rx_rings + (unsigned long)i));
    #line 3078 
    i ++;
  }
  #line 3080 
  return err;
}

#line 3089  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_free_rx_resources(struct i40e_vsi *vsi)
{
  #line 3091 
  int i;
  #line 3093 
  if (vsi->rx_rings == (struct i40e_ring **)0) 
                                               #line 3094 
                                               return;
  #line 3096 
  i = 0;
  #line 3096 
  while ((int)vsi->num_queue_pairs > i) {
    #line 3097 
    if (*(vsi->rx_rings + (unsigned long)i) != (struct i40e_ring *)0 && (*(vsi->rx_rings + (unsigned long)i))->desc != (void *)0) 
      #line 3098 
      i40e_free_rx_resources(*(vsi->rx_rings + (unsigned long)i));
    #line 3096 
    i ++;
  }
  #line 3099 
  return;
}

#line 3108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_config_xps_tx_ring(struct i40e_ring *ring)
{
  #line 3110 
  int cpu;
  #line 3112 
  if ((ring->q_vector == (struct i40e_q_vector *)0 || ring->netdev == (struct net_device *)0) || ring->ch != (struct i40e_channel *)0) 
    #line 3113 
    return;
  #line 3116 
  if ((int)test_and_set_bit(1L,(unsigned long *)(& ring->state)) != 0) 
    #line 3117 
    return;
  #line 3119 
  cpu = (int)cpumask_local_spread((unsigned int)(ring->q_vector)->v_idx,-1);
  #line 3120 
  ;
  #line 3120 
  ;
  #line 3120 
  netif_set_xps_queue(ring->netdev,get_cpu_mask((unsigned int)cpu),(unsigned short)((int)ring->queue_index));
  #line 3122 
  return;
}

#line 3130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct xdp_umem *i40e_xsk_umem(struct i40e_ring *ring)
{
  #line 3132 
  bool xdp_on = i40e_enabled_xdp_vsi_0(ring->vsi);
  #line 3133 
  int qid = (int)ring->queue_index;
  #line 3135 
  if ((int)ring_is_xdp(ring) != 0) 
                                   #line 3136 
                                   qid -= (int)(ring->vsi)->alloc_queue_pairs;
  #line 3138 
  if (! xdp_on) 
                #line 3139 
                return (struct xdp_umem *)0;
  else {
    #line 3138 
    if (! test_bit((long)qid,(ring->vsi)->af_xdp_zc_qps)) 
                                                          #line 3139 
                                                          return (struct xdp_umem *)0;
  }
  #line 3141 
  return xdp_get_umem_from_qid((ring->vsi)->netdev,
                              (unsigned short)((int)((unsigned short)qid)));
}

#line 3150  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_configure_tx_ring(struct i40e_ring *ring)
{
  #line 3155 
  struct i40e_hmc_obj_txq tx_ctx;
  #line 3152 
  struct i40e_vsi *vsi = ring->vsi;
  #line 3153 
  u16 pf_q = (unsigned short)((int)vsi->base_queue + (int)ring->queue_index);
  #line 3154 
  struct i40e_hw *hw = & (vsi->back)->hw;
  #line 3156 
  i40e_status err = 0;
  #line 3157 
  u32 qtx_ctl = 0U;
  #line 3159 
  if ((int)ring_is_xdp(ring) != 0) 
                                   #line 3160 
                                   ring->xsk_umem = i40e_xsk_umem(ring);
  #line 3163 
  if (((unsigned long)(vsi->back)->flags & 512UL) != 0UL) {
    #line 3164 
    ring->atr_sample_rate = (vsi->back)->atr_sample_rate;
    #line 3165 
    ring->atr_count = (unsigned char)0U;
  }
  else 
       #line 3167 
       ring->atr_sample_rate = (unsigned char)0U;
  #line 3171 
  i40e_config_xps_tx_ring(ring);
  #line 3174 
  memset((void *)(& tx_ctx),0,48UL);
  #line 3176 
  tx_ctx.new_context = (unsigned char)1U;
  #line 3177 
  tx_ctx.base = ring->dma / 128ULL;
  #line 3178 
  tx_ctx.qlen = ring->count;
  #line 3179 
  tx_ctx.fd_ena = (unsigned char)(((unsigned long)(vsi->back)->flags & 768UL) != 0UL);
  #line 3181 
  tx_ctx.timesync_ena = (unsigned char)(((unsigned long)(vsi->back)->flags & 131072UL) != 0UL);
  #line 3183 
  if (vsi->type != (unsigned int)I40E_VSI_FDIR) 
                                                #line 3184 
                                                tx_ctx.head_wb_ena = (unsigned char)1U;
  #line 3185 
  tx_ctx.head_wb_addr = ring->dma + (unsigned long long)((unsigned long)ring->count * 16UL);
  #line 3199 
  if (ring->ch != (struct i40e_channel *)0) 
                                            #line 3200 
                                            tx_ctx.rdylist = (ring->ch)->info.qs_handle[(int)ring->dcb_tc]; else 
                                                                    #line 3204 
                                                                    tx_ctx.rdylist = vsi->info.qs_handle[(int)ring->dcb_tc];
  #line 3206 
  tx_ctx.rdylist_act = (unsigned char)0U;
  #line 3209 
  err = i40e_clear_lan_tx_queue_context(hw,(unsigned short)((int)pf_q));
  #line 3210 
  if (err != I40E_SUCCESS) {
    #line 3211 
    _dev_info(& ((vsi->back)->pdev)->dev,(char *)"Failed to clear LAN Tx queue context on Tx ring %d (pf_q %d), error: %d\n",(int)ring->queue_index,(int)pf_q,(int)err);
    #line 3214 
    return -12;
  }
  #line 3218 
  err = i40e_set_lan_tx_queue_context(hw,(unsigned short)((int)pf_q),& tx_ctx);
  #line 3219 
  if (err != I40E_SUCCESS) {
    #line 3220 
    _dev_info(& ((vsi->back)->pdev)->dev,(char *)"Failed to set LAN Tx queue context on Tx ring %d (pf_q %d, error: %d\n",(int)ring->queue_index,(int)pf_q,(int)err);
    #line 3223 
    return -12;
  }
  #line 3227 
  if (ring->ch != (struct i40e_channel *)0) {
    #line 3228 
    if ((unsigned int)(ring->ch)->type == 2U) 
                                              #line 3229 
                                              qtx_ctl = 1U; else 
                                                                 #line 3231 
                                                                 return -22;
    #line 3233 
    qtx_ctl = ((unsigned int)((int)(ring->ch)->vsi_number << 7) & 65535U) | qtx_ctl;
  }
  else 
    #line 3237 
    if (vsi->type == (unsigned int)I40E_VSI_VMDQ2) {
      #line 3238 
      qtx_ctl = 1U;
      #line 3239 
      qtx_ctl = ((unsigned int)((int)vsi->id << 7) & 65535U) | qtx_ctl;
    }
    else 
         #line 3242 
         qtx_ctl = 2U;
  #line 3246 
  qtx_ctl = ((unsigned int)((int)hw->pf_id << 2) & 60U) | qtx_ctl;
  #line 3248 
  writel(qtx_ctl,(void *)(hw->hw_addr + (unsigned long)(((int)pf_q + 266240) * 4)));
  #line 3249 
  readl((void *)(hw->hw_addr + 745772U));
  #line 3252 
  ring->tail = hw->hw_addr + (unsigned long)(((int)pf_q + 270336) * 4);
  #line 3254 
  return 0;
}

#line 3263  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_configure_rx_ring(struct i40e_ring *ring)
{
  #line 3326 
  unsigned short __UNIQUE_ID___x593;
  #line 3326 
  int tmp;
  #line 3269 
  struct i40e_hmc_obj_rxq rx_ctx;
  #line 3271 
  bool ok;
  #line 3272 
  int ret;
  #line 3265 
  struct i40e_vsi *vsi = ring->vsi;
  #line 3266 
  u32 chain_len = (unsigned int)(vsi->back)->hw.func_caps.rx_buf_chain_len;
  #line 3267 
  u16 pf_q = (unsigned short)((int)vsi->base_queue + (int)ring->queue_index);
  #line 3268 
  struct i40e_hw *hw = & (vsi->back)->hw;
  #line 3270 
  i40e_status err = 0;
  #line 3274 
  cif_bitmap_zero((unsigned long *)(& ring->state),2U);
  #line 3277 
  memset((void *)(& rx_ctx),0,48UL);
  #line 3279 
  if ((ring->vsi)->type == (unsigned int)I40E_VSI_MAIN) 
                                                        #line 3280 
                                                        xdp_rxq_info_unreg_mem_model(& ring->xdp_rxq);
  #line 3282 
  ring->xsk_umem = i40e_xsk_umem(ring);
  #line 3283 
  if (ring->xsk_umem != (struct xdp_umem *)0) {
    #line 3284 
    ring->rx_buf_len = (unsigned short)((unsigned int)((unsigned short)(ring->xsk_umem)->chunk_size_nohr) + 65280U);
    #line 3290 
    chain_len = 1U;
    #line 3291 
    ring->zca.free = & i40e_zca_free;
    #line 3292 
    ret = xdp_rxq_info_reg_mem_model(& ring->xdp_rxq,(enum xdp_mem_type)MEM_TYPE_ZERO_COPY,(void *)(& ring->zca));
    #line 3295 
    if (ret != 0) 
                  #line 3296 
                  return ret;
    #line 3297 
    _dev_info(& ((vsi->back)->pdev)->dev,(char *)"Registered XDP mem model MEM_TYPE_ZERO_COPY on Rx ring %d\n",(int)ring->queue_index);
  }
  else {
    #line 3302 
    ring->rx_buf_len = vsi->rx_buf_len;
    #line 3303 
    if ((ring->vsi)->type == (unsigned int)I40E_VSI_MAIN) {
      #line 3304 
      ret = xdp_rxq_info_reg_mem_model(& ring->xdp_rxq,(enum xdp_mem_type)MEM_TYPE_PAGE_SHARED,(void *)0);
      #line 3307 
      if (ret != 0) 
                    #line 3308 
                    return ret;
    }
  }
  #line 3312 
  rx_ctx.dbuff = (unsigned short)(((unsigned long long)ring->rx_buf_len + 127ULL) / 128ULL);
  #line 3315 
  rx_ctx.base = ring->dma / 128ULL;
  #line 3316 
  rx_ctx.qlen = ring->count;
  #line 3319 
  rx_ctx.dsize = (unsigned char)1U;
  #line 3324 
  rx_ctx.hsplit_0 = (unsigned char)0U;
  {
    #line 3326 
    __UNIQUE_ID___x593 = vsi->max_frame;
    #line 3326 
    unsigned short __UNIQUE_ID___y594 = (unsigned short)((int)((unsigned short)chain_len) * (int)ring->rx_buf_len);
    #line 3326 
    if ((int)__UNIQUE_ID___x593 < (int)__UNIQUE_ID___y594) 
                                                           #line 3326 
                                                           tmp = (int)__UNIQUE_ID___x593; else 
                                                                    #line 3326 
                                                                    tmp = (int)__UNIQUE_ID___y594;
    }
  #line 3326 
  rx_ctx.rxmax = (unsigned int)tmp;
  #line 3327 
  if ((unsigned int)hw->revision_id == 0U) 
                                           #line 3328 
                                           rx_ctx.lrxqthresh = (unsigned short)0U; else 
                                                                    #line 3330 
                                                                    rx_ctx.lrxqthresh = (unsigned short)1U;
  #line 3331 
  rx_ctx.crcstrip = (unsigned char)1U;
  #line 3332 
  rx_ctx.l2tsel = (unsigned char)1U;
  #line 3334 
  rx_ctx.showiv = (unsigned char)0U;
  #line 3336 
  rx_ctx.prefena = (unsigned char)1U;
  #line 3339 
  err = i40e_clear_lan_rx_queue_context(hw,(unsigned short)((int)pf_q));
  #line 3340 
  if (err != I40E_SUCCESS) {
    #line 3341 
    _dev_info(& ((vsi->back)->pdev)->dev,(char *)"Failed to clear LAN Rx queue context on Rx ring %d (pf_q %d), error: %d\n",(int)ring->queue_index,(int)pf_q,(int)err);
    #line 3344 
    return -12;
  }
  #line 3348 
  err = i40e_set_lan_rx_queue_context(hw,(unsigned short)((int)pf_q),& rx_ctx);
  #line 3349 
  if (err != I40E_SUCCESS) {
    #line 3350 
    _dev_info(& ((vsi->back)->pdev)->dev,(char *)"Failed to set LAN Rx queue context on Rx ring %d (pf_q %d), error: %d\n",(int)ring->queue_index,(int)pf_q,(int)err);
    #line 3353 
    return -12;
  }
  #line 3357 
  if (vsi->netdev == (struct net_device *)0 || ((unsigned long)(vsi->back)->flags & 65536UL) != 0UL) 
    #line 3358 
    clear_ring_build_skb_enabled(ring); else 
                                             #line 3360 
                                             set_ring_build_skb_enabled(ring);
  #line 3363 
  ring->tail = hw->hw_addr + (unsigned long)(((int)pf_q + 303104) * 4);
  #line 3364 
  writel(0U,(void *)ring->tail);
  #line 3366 
  if (ring->xsk_umem != (struct xdp_umem *)0) {
    #line 3367 
    unsigned int tmp_1;
    #line 3367 
    if ((int)ring->next_to_clean <= (int)ring->next_to_use) 
                                                            #line 3367 
                                                            tmp_1 = (unsigned int)ring->count; else 
                                                                    #line 3367 
                                                                    tmp_1 = 0U;
    #line 3367 
    ;
    #line 3367 
    ;
    #line 3366 
    ok = (_Bool)((int)i40e_alloc_rx_buffers_zc(ring,
                                 (unsigned short)((int)(((tmp_1 + (unsigned int)ring->next_to_clean) - (unsigned int)ring->next_to_use) + 65535U))) != 0);
  }
  else {
    #line 3368 
    int tmp_5;
    #line 3368 
    unsigned int tmp_3;
    #line 3368 
    if ((int)ring->next_to_clean <= (int)ring->next_to_use) 
                                                            #line 3368 
                                                            tmp_3 = (unsigned int)ring->count; else 
                                                                    #line 3368 
                                                                    tmp_3 = 0U;
    #line 3368 
    ;
    #line 3368 
    ;
    #line 3368 
    if ((int)i40e_alloc_rx_buffers(ring,
                              (unsigned short)((int)(((tmp_3 + (unsigned int)ring->next_to_clean) - (unsigned int)ring->next_to_use) + 65535U))) != 0) 
      #line 3368 
      tmp_5 = 0; else 
                      #line 3368 
                      tmp_5 = 1;
    #line 3366 
    ok = (_Bool)(tmp_5 != 0);
  }
  #line 3369 
  if (! ok) {
    #line 3373 
    char *tmp_6;
    #line 3373 
    ;
    #line 3373 
    ;
    #line 3373 
    if (ring->xsk_umem != (struct xdp_umem *)0) 
                                                #line 3373 
                                                tmp_6 = (char *)"UMEM enabled "; else 
                                                                    #line 3373 
                                                                    tmp_6 = (char *)"";
    #line 3373 
    ;
    #line 3373 
    _dev_info(& ((vsi->back)->pdev)->dev,(char *)"Failed to allocate some buffers on %sRx ring %d (pf_q %d)\n",tmp_6,(int)ring->queue_index,(int)pf_q);
  }
  #line 3379 
  return 0;
}

#line 3388  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_configure_tx(struct i40e_vsi *vsi)
{
  #line 3391 
  u16 i;
  #line 3390 
  int err = 0;
  #line 3393 
  i = (unsigned short)0U;
  #line 3393 
  while ((int)vsi->num_queue_pairs > (int)i && err == 0) {
    #line 3394 
    err = i40e_configure_tx_ring(*(vsi->tx_rings + (unsigned long)i));
    #line 3393 
    i = (u16)((int)i + 1);
  }
  #line 3396 
  if (err != 0) 
                #line 3397 
                return err;
  else {
    #line 3396 
    if (! i40e_enabled_xdp_vsi_0(vsi)) 
                                       #line 3397 
                                       return err;
  }
  #line 3399 
  i = (unsigned short)0U;
  #line 3399 
  while ((int)vsi->num_queue_pairs > (int)i && err == 0) {
    #line 3400 
    err = i40e_configure_tx_ring(*(vsi->xdp_rings + (unsigned long)i));
    #line 3399 
    i = (u16)((int)i + 1);
  }
  #line 3402 
  return err;
}

#line 3411  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_configure_rx(struct i40e_vsi *vsi)
{
  #line 3414 
  u16 i;
  #line 3413 
  int err = 0;
  #line 3416 
  if (vsi->netdev == (struct net_device *)0 || ((unsigned long)(vsi->back)->flags & 65536UL) != 0UL) {
    #line 3417 
    vsi->max_frame = (unsigned short)9728U;
    #line 3418 
    vsi->rx_buf_len = (unsigned short)2048U;
  }
  else 
    #line 3420 
    if ((vsi->netdev)->mtu <= 1500U) {
      #line 3422 
      vsi->max_frame = (unsigned short)1536U;
      #line 3423 
      vsi->rx_buf_len = (unsigned short)1536U;
    }
    else {
      #line 3426 
      vsi->max_frame = (unsigned short)9728U;
      #line 3427 
      vsi->rx_buf_len = (unsigned short)3072U;
    }
  #line 3432 
  i = (unsigned short)0U;
  #line 3432 
  while ((int)vsi->num_queue_pairs > (int)i && err == 0) {
    #line 3433 
    err = i40e_configure_rx_ring(*(vsi->rx_rings + (unsigned long)i));
    #line 3432 
    i = (u16)((int)i + 1);
  }
  #line 3435 
  return err;
}

#line 3442  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_config_dcb_rings(struct i40e_vsi *vsi)
{
  #line 3444 
  struct i40e_ring *tx_ring;
  #line 3444 
  struct i40e_ring *rx_ring;
  #line 3445 
  u16 qoffset;
  #line 3445 
  u16 qcount;
  #line 3446 
  int i;
  #line 3446 
  int n;
  #line 3448 
  if (((unsigned long)(vsi->back)->flags & 128UL) == 0UL) {
    #line 3450 
    i = 0;
    #line 3450 
    while ((int)vsi->num_queue_pairs > i) {
      #line 3451 
      rx_ring = *(vsi->rx_rings + (unsigned long)i);
      #line 3452 
      tx_ring = *(vsi->tx_rings + (unsigned long)i);
      #line 3453 
      rx_ring->dcb_tc = (unsigned char)0U;
      #line 3454 
      tx_ring->dcb_tc = (unsigned char)0U;
      #line 3450 
      i ++;
    }
    #line 3456 
    return;
  }
  #line 3459 
  n = 0;
  #line 3459 
  while (n <= 7) {
    #line 3460 
    if ((((unsigned long long)vsi->tc_config.enabled_tc >> n) & 1ULL) == 0ULL) 
      #line 3461 
      goto __Cont;
    #line 3463 
    qoffset = vsi->tc_config.tc_info[n].qoffset;
    #line 3464 
    qcount = vsi->tc_config.tc_info[n].qcount;
    #line 3465 
    i = (int)qoffset;
    #line 3465 
    while ((int)qoffset + (int)qcount > i) {
      #line 3466 
      rx_ring = *(vsi->rx_rings + (unsigned long)i);
      #line 3467 
      tx_ring = *(vsi->tx_rings + (unsigned long)i);
      #line 3468 
      rx_ring->dcb_tc = (unsigned char)n;
      #line 3469 
      tx_ring->dcb_tc = (unsigned char)n;
      #line 3465 
      i ++;
    }
    #line 3459 
    __Cont: 
            #line 3459 
    n ++;
  }
  #line 3472 
  return;
}

#line 3478  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_set_vsi_rx_mode(struct i40e_vsi *vsi)
{
  #line 3480 
  if (vsi->netdev != (struct net_device *)0) 
                                             #line 3481 
                                             i40e_set_rx_mode(vsi->netdev);
  #line 3482 
  return;
}

#line 3491  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_fdir_filter_restore(struct i40e_vsi *vsi)
{
  #line 3506 
  void *__mptr;
  #line 3506 
  struct i40e_fdir_filter *tmp_0;
  #line 3493 
  struct i40e_fdir_filter *filter;
  #line 3495 
  struct hlist_node *node;
  #line 3494 
  struct i40e_pf *pf = vsi->back;
  #line 3497 
  if (((unsigned long)pf->flags & 256UL) == 0UL) 
                                                 #line 3498 
                                                 return;
  #line 3501 
  pf->fd_tcp4_filter_cnt = (unsigned short)0U;
  #line 3502 
  pf->fd_udp4_filter_cnt = (unsigned short)0U;
  #line 3503 
  pf->fd_sctp4_filter_cnt = (unsigned short)0U;
  #line 3504 
  pf->fd_ip4_filter_cnt = (unsigned short)0U;
  {
    #line 3506 
    struct hlist_node *____ptr = pf->fdir_filter_list.first;
    #line 3506 
    if (____ptr != (struct hlist_node *)0) {
      #line 3506 
      __mptr = (void *)____ptr;
      #line 3506 
      tmp_0 = ((struct i40e_fdir_filter *)__mptr);
    }
    else 
         #line 3506 
         tmp_0 = (struct i40e_fdir_filter *)0;
    }
  #line 3506 
  filter = tmp_0;
  #line 3506 
  while (1) {
    #line 3506 
    struct i40e_fdir_filter *tmp_3;
    #line 3506 
    void *__mptr_0;
    #line 3506 
    if (filter != (struct i40e_fdir_filter *)0) {
      #line 3506 
      node = filter->fdir_node.next;
      #line 3506 
      if (! (1 != 0)) 
                      #line 3506 
                      break;
    }
    else 
         #line 3506 
         break;
    #line 3508 
    i40e_add_del_fdir(vsi,filter,(_Bool)1);
    {
      #line 3506 
      struct hlist_node *____ptr_0 = node;
      #line 3506 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 3506 
        __mptr_0 = (void *)____ptr_0;
        #line 3506 
        tmp_3 = ((struct i40e_fdir_filter *)__mptr_0);
      }
      else 
           #line 3506 
           tmp_3 = (struct i40e_fdir_filter *)0;
      }
    #line 3506 
    filter = tmp_3;
  }
  #line 3509 
  return;
}

#line 3516  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_configure(struct i40e_vsi *vsi)
{
  #line 3518 
  int err;
  #line 3520 
  i40e_set_vsi_rx_mode(vsi);
  #line 3521 
  i40e_restore_vlan(vsi);
  #line 3522 
  i40e_vsi_config_dcb_rings(vsi);
  #line 3523 
  err = i40e_vsi_configure_tx(vsi);
  #line 3524 
  if (err == 0) 
                #line 3525 
                err = i40e_vsi_configure_rx(vsi);
  #line 3527 
  return err;
}

#line 3534  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_configure_msix(struct i40e_vsi *vsi)
{
  #line 3539 
  u16 vector;
  #line 3540 
  int i;
  #line 3540 
  int q;
  #line 3541 
  u32 qp;
  #line 3536 
  bool has_xdp = i40e_enabled_xdp_vsi_0(vsi);
  #line 3537 
  struct i40e_pf *pf = vsi->back;
  #line 3538 
  struct i40e_hw *hw = & pf->hw;
  #line 3547 
  qp = (unsigned int)vsi->base_queue;
  #line 3548 
  vector = (unsigned short)vsi->base_vector;
  #line 3549 
  i = 0;
  #line 3549 
  while (vsi->num_q_vectors > i) {
    {
      #line 3550 
      struct i40e_q_vector *q_vector = *(vsi->q_vectors + (unsigned long)i);
      #line 3552 
      q_vector->rx.next_update = jiffies + 1UL;
      #line 3553 
      q_vector->rx.target_itr = (unsigned short)((unsigned int)(*(vsi->rx_rings + (unsigned long)i))->itr_setting & 32767U);
      #line 3555 
      writel((unsigned int)((int)q_vector->rx.target_itr >> 1),(void *)(hw->hw_addr + (unsigned long)(((int)vector + 49151) * 4)));
      #line 3557 
      q_vector->rx.current_itr = q_vector->rx.target_itr;
      #line 3559 
      q_vector->tx.next_update = jiffies + 1UL;
      #line 3560 
      q_vector->tx.target_itr = (unsigned short)((unsigned int)(*(vsi->tx_rings + (unsigned long)i))->itr_setting & 32767U);
      #line 3562 
      writel((unsigned int)((int)q_vector->tx.target_itr >> 1),(void *)(hw->hw_addr + (unsigned long)(((int)vector + 49663) * 4)));
      #line 3564 
      q_vector->tx.current_itr = q_vector->tx.target_itr;
      #line 3566 
      ;
      #line 3566 
      writel((unsigned int)i40e_intrl_usec_to_reg((int)vsi->int_rate_limit),(void *)(hw->hw_addr + (unsigned long)(((int)vector + 54783) * 4)));
      #line 3570 
      writel(qp,(void *)(hw->hw_addr + (unsigned long)(((int)vector + 54271) * 4)));
      #line 3571 
      q = 0;
      #line 3571 
      while ((int)q_vector->num_ringpairs > q) {
        {
          #line 3572 
          unsigned int tmp_1;
          #line 3573 
          u32 val;
          #line 3572 
          if ((int)has_xdp != 0) 
                                 #line 3572 
                                 tmp_1 = (unsigned int)vsi->alloc_queue_pairs + qp; else 
                                                                    #line 3572 
                                                                    tmp_1 = qp;
          #line 3572 
          u32 nextqp = tmp_1;
          #line 3575 
          val = ((unsigned int)vector | (nextqp << 16)) | 1207959552U;
          #line 3582 
          writel(val,(void *)(hw->hw_addr + (unsigned long)((qp + 59392U) * 4U)));
          #line 3584 
          if ((int)has_xdp != 0) {
            #line 3585 
            val = ((unsigned int)vector | (qp << 16)) | 1207961600U;
            #line 3592 
            writel(val,(void *)(hw->hw_addr + (unsigned long)((nextqp + 61440U) * 4U)));
          }
          #line 3595 
          val = ((unsigned int)vector | ((qp + 1U) << 16)) | 1073743872U;
          #line 3603 
          if ((int)q_vector->num_ringpairs + -1 == q) 
                                                      #line 3604 
                                                      val |= 134152192U;
          #line 3607 
          writel(val,(void *)(hw->hw_addr + (unsigned long)((qp + 61440U) * 4U)));
          #line 3608 
          qp ++;
        }
        #line 3571 
        q ++;
      }
    }
    #line 3549 
    i ++;
    #line 3549 
    vector = (u16)((int)vector + 1);
  }
  #line 3612 
  readl((void *)(hw->hw_addr + 745772U));
  #line 3613 
  return;
}

#line 3619  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_enable_misc_int_causes(struct i40e_pf *pf)
{
  #line 3622 
  u32 val;
  #line 3621 
  struct i40e_hw *hw = & pf->hw;
  #line 3625 
  writel(0U,(void *)(hw->hw_addr + 231424U));
  #line 3626 
  readl((void *)(hw->hw_addr + 231296U));
  #line 3628 
  val = 1685651456U;
  #line 3637 
  if (((unsigned long)pf->flags & 262144UL) != 0UL) 
                                                    #line 3638 
                                                    val |= 268435456U;
  #line 3640 
  if (((unsigned long)pf->flags & 131072UL) != 0UL) 
                                                    #line 3641 
                                                    val |= 8388608U;
  #line 3643 
  writel(val,(void *)(hw->hw_addr + 231424U));
  #line 3646 
  writel(2248146944U,(void *)(hw->hw_addr + 230528U));
  #line 3650 
  writel(0U,(void *)(hw->hw_addr + 230400U));
  #line 3651 
  return;
}

#line 3657  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_configure_msi_and_legacy(struct i40e_vsi *vsi)
{
  #line 3659 
  unsigned int tmp_0;
  #line 3663 
  u32 val;
  #line 3659 
  if ((int)i40e_enabled_xdp_vsi_0(vsi) != 0) 
                                             #line 3659 
                                             tmp_0 = (unsigned int)vsi->alloc_queue_pairs; else 
                                                                    #line 3659 
                                                                    tmp_0 = 0U;
  #line 3659 
  u32 nextqp = tmp_0;
  #line 3660 
  struct i40e_q_vector *q_vector = *(vsi->q_vectors);
  #line 3661 
  struct i40e_pf *pf = vsi->back;
  #line 3662 
  struct i40e_hw *hw = & pf->hw;
  #line 3666 
  q_vector->rx.next_update = jiffies + 1UL;
  #line 3667 
  q_vector->rx.target_itr = (unsigned short)((unsigned int)(*(vsi->rx_rings))->itr_setting & 32767U);
  #line 3668 
  writel((unsigned int)((int)q_vector->rx.target_itr >> 1),(void *)(hw->hw_addr + 229376U));
  #line 3669 
  q_vector->rx.current_itr = q_vector->rx.target_itr;
  #line 3670 
  q_vector->tx.next_update = jiffies + 1UL;
  #line 3671 
  q_vector->tx.target_itr = (unsigned short)((unsigned int)(*(vsi->tx_rings))->itr_setting & 32767U);
  #line 3672 
  writel((unsigned int)((int)q_vector->tx.target_itr >> 1),(void *)(hw->hw_addr + 229504U));
  #line 3673 
  q_vector->tx.current_itr = q_vector->tx.target_itr;
  #line 3675 
  i40e_enable_misc_int_causes(pf);
  #line 3678 
  writel(0U,(void *)(hw->hw_addr + 230656U));
  #line 3681 
  val = (nextqp << 16) | 1207959552U;
  #line 3686 
  writel(val,(void *)(hw->hw_addr + 237568U));
  #line 3688 
  if ((int)i40e_enabled_xdp_vsi_0(vsi) != 0) {
    #line 3689 
    val = 1207961600U;
    #line 3694 
    writel(val,(void *)(hw->hw_addr + (unsigned long)((nextqp + 61440U) * 4U)));
  }
  #line 3697 
  val = 1207896064U;
  #line 3701 
  writel(val,(void *)(hw->hw_addr + 245760U));
  #line 3702 
  readl((void *)(hw->hw_addr + 745772U));
  #line 3703 
  return;
}

#line 3709  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_irq_dynamic_disable_icr0(struct i40e_pf *pf)
{
  #line 3711 
  struct i40e_hw *hw = & pf->hw;
  #line 3713 
  writel(24U,(void *)(hw->hw_addr + 230528U));
  #line 3715 
  readl((void *)(hw->hw_addr + 745772U));
  #line 3716 
  return;
}

#line 3722  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_irq_dynamic_enable_icr0(struct i40e_pf *pf)
{
  #line 3725 
  u32 val;
  #line 3724 
  struct i40e_hw *hw = & pf->hw;
  #line 3727 
  val = 27U;
  #line 3731 
  writel(val,(void *)(hw->hw_addr + 230528U));
  #line 3732 
  readl((void *)(hw->hw_addr + 745772U));
  #line 3733 
  return;
}

#line 3740  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static irqreturn_t i40e_msix_clean_rings(int irq, void *data)
{
  #line 3742 
  struct i40e_q_vector *q_vector = (struct i40e_q_vector *)data;
  #line 3744 
  if (q_vector->tx.ring == (struct i40e_ring *)0 && q_vector->rx.ring == (struct i40e_ring *)0) 
    #line 3745 
    return IRQ_HANDLED;
  #line 3747 
  napi_schedule_irqoff(& q_vector->napi);
  #line 3749 
  return IRQ_HANDLED;
}

#line 3760  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_irq_affinity_notify(struct irq_affinity_notify *notify, cpumask_t *mask)
{
  #line 3764 
  void *__mptr;
  #line 3764 
  __mptr = (void *)notify;
  #line 3763 
  struct i40e_q_vector *q_vector = ((struct i40e_q_vector *)(__mptr + 18446744073709550112U));
  #line 3766 
  cpumask_copy(& q_vector->affinity_mask,mask);
  #line 3767 
  return;
}

#line 3777  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_irq_affinity_release(struct kref *ref)
{
  #line 3779 
  return;
}

#line 3786  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_request_irq_msix(struct i40e_vsi *vsi, char *basename)
{
  #line 3793 
  int vector;
  #line 3793 
  int err;
  #line 3794 
  int irq_num;
  #line 3795 
  int cpu;
  #line 3788 
  int q_vectors = vsi->num_q_vectors;
  #line 3789 
  struct i40e_pf *pf = vsi->back;
  #line 3790 
  int base = vsi->base_vector;
  #line 3791 
  int rx_int_idx = 0;
  #line 3792 
  int tx_int_idx = 0;
  #line 3797 
  vector = 0;
  #line 3797 
  while (vector < q_vectors) {
    {
      #line 3798 
      struct i40e_q_vector *q_vector = *(vsi->q_vectors + (unsigned long)vector);
      #line 3800 
      irq_num = (int)(pf->msix_entries + (unsigned long)(base + vector))->vector;
      #line 3802 
      if (q_vector->tx.ring != (struct i40e_ring *)0 && q_vector->rx.ring != (struct i40e_ring *)0) {
        #line 3804 
        int tmp;
        #line 3804 
        tmp = rx_int_idx;
        #line 3804 
        rx_int_idx ++;
        #line 3803 
        ;
        #line 3803 
        ;
        #line 3803 
        ;
        #line 3803 
        snprintf((char *)(& q_vector->name),31UL,(char *)"%s-%s-%d",basename,(char *)"TxRx",tmp);
        #line 3805 
        tx_int_idx ++;
      }
      else 
        #line 3806 
        if (q_vector->rx.ring != (struct i40e_ring *)0) {
          #line 3808 
          int tmp_0;
          #line 3808 
          tmp_0 = rx_int_idx;
          #line 3808 
          rx_int_idx ++;
          #line 3807 
          ;
          #line 3807 
          ;
          #line 3807 
          ;
          #line 3807 
          snprintf((char *)(& q_vector->name),31UL,(char *)"%s-%s-%d",basename,(char *)"rx",tmp_0);
        }
        else 
          #line 3809 
          if (q_vector->tx.ring != (struct i40e_ring *)0) {
            #line 3811 
            int tmp_1;
            #line 3811 
            tmp_1 = tx_int_idx;
            #line 3811 
            tx_int_idx ++;
            #line 3810 
            ;
            #line 3810 
            ;
            #line 3810 
            ;
            #line 3810 
            snprintf((char *)(& q_vector->name),31UL,(char *)"%s-%s-%d",basename,(char *)"tx",tmp_1);
          }
          else 
               #line 3814 
               goto __Cont;
      #line 3816 
      err = cif_request_irq((unsigned int)irq_num,vsi->irq_handler,0UL,(char *)(& q_vector->name),(void *)q_vector);
      #line 3821 
      if (err != 0) {
        #line 3822 
        _dev_info(& (pf->pdev)->dev,(char *)"MSIX request_irq failed, error: %d\n",err);
        #line 3824 
        goto free_queue_irqs;
      }
      #line 3828 
      q_vector->affinity_notify.notify = & i40e_irq_affinity_notify;
      #line 3829 
      q_vector->affinity_notify.release = & i40e_irq_affinity_release;
      #line 3830 
      irq_set_affinity_notifier((unsigned int)irq_num,& q_vector->affinity_notify);
      #line 3837 
      cpu = (int)cpumask_local_spread((unsigned int)q_vector->v_idx,-1);
      #line 3838 
      ;
      #line 3838 
      irq_set_affinity_hint((unsigned int)irq_num,get_cpu_mask((unsigned int)cpu));
    }
    #line 3797 
    __Cont: 
            #line 3797 
    vector ++;
  }
  #line 3841 
  vsi->irqs_ready = (_Bool)1;
  #line 3842 
  return 0;
  #line 3844 
  free_queue_irqs: 
                   #line 3844 
  ;
  #line 3845 
  while (vector != 0) {
    #line 3846 
    vector --;
    #line 3847 
    irq_num = (int)(pf->msix_entries + (unsigned long)(base + vector))->vector;
    #line 3848 
    irq_set_affinity_notifier((unsigned int)irq_num,(struct irq_affinity_notify *)0);
    #line 3849 
    irq_set_affinity_hint((unsigned int)irq_num,(struct cpumask *)0);
    #line 3850 
    cif_free_irq((unsigned int)irq_num,(void *)(vsi->q_vectors + (unsigned long)vector));
  }
  #line 3852 
  return err;
}

#line 3859  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_disable_irq(struct i40e_vsi *vsi)
{
  #line 3864 
  int i;
  #line 3861 
  struct i40e_pf *pf = vsi->back;
  #line 3862 
  struct i40e_hw *hw = & pf->hw;
  #line 3863 
  int base = vsi->base_vector;
  #line 3867 
  i = 0;
  #line 3867 
  while ((int)vsi->num_queue_pairs > i) {
    {
      #line 3868 
      u32 val;
      #line 3870 
      val = readl((void *)(hw->hw_addr + (unsigned long)(((int)(*(vsi->tx_rings + (unsigned long)i))->reg_idx + 61440) * 4)));
      #line 3871 
      val &= 3221225471U;
      #line 3872 
      writel(val,(void *)(hw->hw_addr + (unsigned long)(((int)(*(vsi->tx_rings + (unsigned long)i))->reg_idx + 61440) * 4)));
      #line 3874 
      val = readl((void *)(hw->hw_addr + (unsigned long)(((int)(*(vsi->rx_rings + (unsigned long)i))->reg_idx + 59392) * 4)));
      #line 3875 
      val &= 3221225471U;
      #line 3876 
      writel(val,(void *)(hw->hw_addr + (unsigned long)(((int)(*(vsi->rx_rings + (unsigned long)i))->reg_idx + 59392) * 4)));
      #line 3878 
      if (! i40e_enabled_xdp_vsi_0(vsi)) 
                                         #line 3879 
                                         goto __Cont;
      #line 3880 
      writel(0U,(void *)(hw->hw_addr + (unsigned long)(((int)(*(vsi->xdp_rings + (unsigned long)i))->reg_idx + 61440) * 4)));
    }
    #line 3867 
    __Cont: 
            #line 3867 
    i ++;
  }
  #line 3884 
  if (((unsigned long)pf->flags & 4UL) != 0UL) {
    #line 3885 
    i = vsi->base_vector;
    #line 3885 
    while (vsi->num_q_vectors + vsi->base_vector > i) {
      #line 3887 
      writel(0U,(void *)(hw->hw_addr + (unsigned long)((i + 53759) * 4)));
      #line 3886 
      i ++;
    }
    #line 3889 
    readl((void *)(hw->hw_addr + 745772U));
    #line 3890 
    i = 0;
    #line 3890 
    while (vsi->num_q_vectors > i) {
      #line 3891 
      synchronize_irq((pf->msix_entries + (unsigned long)(i + base))->vector);
      #line 3890 
      i ++;
    }
  }
  else {
    #line 3894 
    writel(0U,(void *)(hw->hw_addr + 231424U));
    #line 3895 
    writel(0U,(void *)(hw->hw_addr + 230528U));
    #line 3896 
    readl((void *)(hw->hw_addr + 745772U));
    #line 3897 
    synchronize_irq((pf->pdev)->irq);
  }
  #line 3899 
  return;
}

#line 3905  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_enable_irq(struct i40e_vsi *vsi)
{
  #line 3908 
  int i;
  #line 3907 
  struct i40e_pf *pf = vsi->back;
  #line 3910 
  if (((unsigned long)pf->flags & 4UL) != 0UL) {
    #line 3911 
    i = 0;
    #line 3911 
    while (vsi->num_q_vectors > i) {
      #line 3912 
      i40e_irq_dynamic_enable(vsi,i);
      #line 3911 
      i ++;
    }
  }
  else 
       #line 3914 
       i40e_irq_dynamic_enable_icr0(pf);
  #line 3917 
  readl((void *)(pf->hw.hw_addr + 745772U));
  #line 3918 
  return 0;
}

#line 3925  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_free_misc_vector(struct i40e_pf *pf)
{
  #line 3928 
  writel(0U,(void *)(pf->hw.hw_addr + 231424U));
  #line 3929 
  readl((void *)(pf->hw.hw_addr + 745772U));
  #line 3931 
  if (((unsigned long)pf->flags & 4UL) != 0UL && pf->msix_entries != (struct msix_entry *)0) {
    #line 3932 
    synchronize_irq((pf->msix_entries)->vector);
    #line 3933 
    cif_free_irq((pf->msix_entries)->vector,(void *)pf);
    #line 3934 
    cif_clear_bit_1(10L,(unsigned long *)(& pf->state));
  }
  #line 3936 
  return;
}

#line 3947  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static irqreturn_t i40e_intr(int irq, void *data)
{
  #line 3952 
  u32 icr0;
  #line 3952 
  u32 icr0_remaining;
  #line 3953 
  u32 val;
  #line 3953 
  u32 ena_mask;
  #line 3949 
  struct i40e_pf *pf = (struct i40e_pf *)data;
  #line 3950 
  struct i40e_hw *hw = & pf->hw;
  #line 3951 
  irqreturn_t ret = IRQ_NONE;
  #line 3955 
  icr0 = readl((void *)(hw->hw_addr + 231296U));
  #line 3956 
  ena_mask = readl((void *)(hw->hw_addr + 231424U));
  #line 3959 
  if ((icr0 & 1U) == 0U) 
                         #line 3960 
                         goto enable_intr;
  #line 3963 
  if ((icr0 & 4294967294U) == 0U || (icr0 & 2147483648U) != 0U) 
                                                                #line 3965 
                                                                pf->sw_int_count = (u16)((int)pf->sw_int_count + 1);
  #line 3967 
  if (((unsigned long)pf->flags & 262144UL) != 0UL && (icr0 & 268435456U) != 0U) {
    #line 3969 
    ena_mask &= 4026531839U;
    {
      #line 3970 
      bool branch;
      #line 3970 
      struct _ddebug __UNIQUE_ID_ddebug597 = {.modname = (char *)"i40e", .function = (char *)"i40e_intr", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"cleared PE_CRITERR\n", .lineno = (unsigned int)3970U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 3970 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug597.key.dd_key_false.key,(_Bool)0);
      #line 3970 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 3970 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug597,& (pf->pdev)->dev,(char *)"cleared PE_CRITERR\n");
    }
    #line 3971 
    cif_set_bit_1(14L,(unsigned long *)(& pf->state));
  }
  #line 3975 
  if ((icr0 & 2U) != 0U) {
    #line 3976 
    struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)pf->lan_vsi);
    #line 3977 
    struct i40e_q_vector *q_vector = *(vsi->q_vectors);
    #line 3985 
    if (! test_bit(3L,(unsigned long *)(& pf->state))) 
                                                       #line 3986 
                                                       napi_schedule_irqoff(& q_vector->napi);
  }
  #line 3989 
  if ((icr0 & 1073741824U) != 0U) {
    #line 3990 
    ena_mask &= 3221225471U;
    #line 3991 
    cif_set_bit_1(5L,(unsigned long *)(& pf->state));
    #line 3992 
    if ((pf->hw.debug_mask & 128U) != 0U) 
                                          #line 3992 
                                          printk((char *)"\001",(int)pf->hw.bus.bus_id,(int)pf->hw.bus.device,(int)pf->hw.bus.func);
  }
  #line 3995 
  if ((icr0 & 524288U) != 0U) {
    #line 3996 
    ena_mask &= 4294443007U;
    #line 3997 
    cif_set_bit_1(6L,(unsigned long *)(& pf->state));
  }
  #line 4000 
  if ((icr0 & 536870912U) != 0U) {
    #line 4001 
    ena_mask &= 3758096383U;
    #line 4002 
    cif_set_bit_1(7L,(unsigned long *)(& pf->state));
  }
  #line 4005 
  if ((icr0 & 1048576U) != 0U) {
    #line 4006 
    if (! test_bit(8L,(unsigned long *)(& pf->state))) 
                                                       #line 4007 
                                                       cif_set_bit_1(11L,(unsigned long *)(& pf->state));
    #line 4008 
    ena_mask &= 4293918719U;
    #line 4009 
    val = readl((void *)(hw->hw_addr + 754056U));
    #line 4010 
    val = (val >> 2) & 3U;
    #line 4012 
    if (val == 1U) 
                   #line 4013 
                   pf->corer_count = (u16)((int)pf->corer_count + 1);
    else 
      #line 4014 
      if (val == 2U) 
                     #line 4015 
                     pf->globr_count = (u16)((int)pf->globr_count + 1);
      else 
        #line 4016 
        if (val == 3U) {
          #line 4017 
          pf->empr_count = (u16)((int)pf->empr_count + 1);
          #line 4018 
          cif_set_bit_1(16L,(unsigned long *)(& pf->state));
        }
  }
  #line 4022 
  if ((icr0 & 67108864U) != 0U) {
    #line 4023 
    icr0 &= 4227858431U;
    #line 4024 
    _dev_info(& (pf->pdev)->dev,(char *)"HMC error interrupt\n");
    #line 4025 
    ;
    #line 4025 
    _dev_info(& (pf->pdev)->dev,(char *)"HMC error info 0x%x, HMC error data 0x%x\n",readl((void *)(hw->hw_addr + 787456U)),readl((void *)(hw->hw_addr + 787712U)));
  }
  #line 4030 
  if ((icr0 & 8388608U) != 0U) {
    #line 4031 
    u32 prttsyn_stat = readl((void *)(hw->hw_addr + 1983008U));
    #line 4033 
    if ((prttsyn_stat & 16U) != 0U) {
      #line 4034 
      icr0 &= 4286578687U;
      #line 4035 
      i40e_ptp_tx_hwtstamp(pf);
    }
  }
  #line 4043 
  icr0_remaining = icr0 & ena_mask;
  #line 4044 
  if (icr0_remaining != 0U) {
    #line 4045 
    _dev_info(& (pf->pdev)->dev,(char *)"unhandled interrupt icr0=0x%08x\n",icr0_remaining);
    #line 4047 
    if (((icr0_remaining & 268435456U) != 0U || (icr0_remaining & 2097152U) != 0U) || (icr0_remaining & 65536U) != 0U) {
      #line 4050 
      _dev_info(& (pf->pdev)->dev,(char *)"device will be reset\n");
      #line 4051 
      cif_set_bit_1(13L,(unsigned long *)(& pf->state));
      #line 4052 
      i40e_service_event_schedule(pf);
    }
    #line 4054 
    ena_mask = ~ icr0_remaining & ena_mask;
  }
  #line 4056 
  ret = IRQ_HANDLED;
  #line 4058 
  enable_intr: 
               #line 4058 
  ;
  #line 4060 
  writel(ena_mask,(void *)(hw->hw_addr + 231424U));
  #line 4061 
  if (test_bit(3L,(unsigned long *)(& pf->state))) {
    #line 4061 
    if ((int)test_bit(34L,(unsigned long *)(& pf->state)) != 0) {
      #line 4061 
      _LOR: {
              #line 4063 
              i40e_service_event_schedule(pf);
              #line 4064 
              i40e_irq_dynamic_enable_icr0(pf);
            }
    }
  }
  else 
       #line 4061 
       goto _LOR;
  #line 4067 
  return ret;
}

#line 4077  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static bool i40e_clean_fdir_tx_irq(struct i40e_ring *tx_ring, int budget)
{
  #line 4081 
  struct i40e_tx_buffer *tx_buf;
  #line 4082 
  struct i40e_tx_desc *tx_desc;
  #line 4079 
  struct i40e_vsi *vsi = tx_ring->vsi;
  #line 4080 
  u16 i = tx_ring->next_to_clean;
  #line 4084 
  tx_buf = tx_ring->__anonCompField_i40e_ring_221.tx_bi + (unsigned long)i;
  #line 4085 
  tx_desc = (struct i40e_tx_desc *)tx_ring->desc + (unsigned long)i;
  #line 4086 
  i = (unsigned short)((int)i - (int)tx_ring->count);
  #line 4088 
  while (1) {
    {
      #line 4089 
      struct i40e_tx_desc *eop_desc = tx_buf->next_to_watch;
      #line 4092 
      if (eop_desc == (struct i40e_tx_desc *)0) 
                                                #line 4093 
                                                break;
      #line 4094 
      ldv_inline_asm();
      #line 4099 
      if ((eop_desc->cmd_type_offset_bsz & 15ULL) == 0ULL) 
                                                           #line 4101 
                                                           break;
      #line 4104 
      tx_buf->next_to_watch = (struct i40e_tx_desc *)0;
      #line 4106 
      tx_desc->buffer_addr = 0ULL;
      #line 4107 
      tx_desc->cmd_type_offset_bsz = 0ULL;
      #line 4109 
      tx_buf ++;
      #line 4110 
      tx_desc ++;
      #line 4111 
      i = (u16)((int)i + 1);
      #line 4112 
      if ((long)((unsigned int)i == 0U) != 0L) {
        #line 4113 
        i = (unsigned short)((int)i - (int)tx_ring->count);
        #line 4114 
        tx_buf = tx_ring->__anonCompField_i40e_ring_221.tx_bi;
        #line 4115 
        tx_desc = (struct i40e_tx_desc *)tx_ring->desc;
      }
      #line 4118 
      dma_unmap_single_attrs(tx_ring->dev,tx_buf->dma,(unsigned long)tx_buf->len,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
      #line 4122 
      if (((unsigned long)tx_buf->tx_flags & 512UL) != 0UL) 
                                                            #line 4123 
                                                            kfree(tx_buf->__anonCompField_i40e_tx_buffer_217.raw_buf);
      #line 4125 
      tx_buf->__anonCompField_i40e_tx_buffer_217.raw_buf = (void *)0;
      #line 4126 
      tx_buf->tx_flags = 0U;
      #line 4127 
      tx_buf->next_to_watch = (struct i40e_tx_desc *)0;
      #line 4128 
      tx_buf->len = 0U;
      #line 4129 
      tx_desc->buffer_addr = 0ULL;
      #line 4130 
      tx_desc->cmd_type_offset_bsz = 0ULL;
      #line 4133 
      tx_buf ++;
      #line 4134 
      tx_desc ++;
      #line 4135 
      i = (u16)((int)i + 1);
      #line 4136 
      if ((long)((unsigned int)i == 0U) != 0L) {
        #line 4137 
        i = (unsigned short)((int)i - (int)tx_ring->count);
        #line 4138 
        tx_buf = tx_ring->__anonCompField_i40e_ring_221.tx_bi;
        #line 4139 
        tx_desc = (struct i40e_tx_desc *)tx_ring->desc;
      }
      #line 4143 
      budget --;
    }
    #line 4144 
    if (! ((long)(budget != 0) != 0L)) 
                                       #line 4088 
                                       break;
  }
  #line 4146 
  i = (unsigned short)((int)tx_ring->count + (int)i);
  #line 4147 
  tx_ring->next_to_clean = i;
  #line 4149 
  if (((unsigned long)(vsi->back)->flags & 4UL) != 0UL) 
                                                        #line 4150 
                                                        i40e_irq_dynamic_enable(vsi,(int)(tx_ring->q_vector)->v_idx);
  #line 4152 
  return (_Bool)(budget > 0);
}

#line 4160  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static irqreturn_t i40e_fdir_clean_ring(int irq, void *data)
{
  #line 4163 
  struct i40e_vsi *vsi;
  #line 4162 
  struct i40e_q_vector *q_vector = (struct i40e_q_vector *)data;
  #line 4165 
  if (q_vector->tx.ring == (struct i40e_ring *)0) 
                                                  #line 4166 
                                                  return IRQ_HANDLED;
  #line 4168 
  vsi = (q_vector->tx.ring)->vsi;
  #line 4169 
  i40e_clean_fdir_tx_irq(q_vector->tx.ring,(int)vsi->work_limit);
  #line 4171 
  return IRQ_HANDLED;
}

#line 4180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_map_vector_to_qp(struct i40e_vsi *vsi, int v_idx, int qp_idx)
{
  #line 4182 
  struct i40e_q_vector *q_vector = *(vsi->q_vectors + (unsigned long)v_idx);
  #line 4183 
  struct i40e_ring *tx_ring = *(vsi->tx_rings + (unsigned long)qp_idx);
  #line 4184 
  struct i40e_ring *rx_ring = *(vsi->rx_rings + (unsigned long)qp_idx);
  #line 4186 
  tx_ring->q_vector = q_vector;
  #line 4187 
  tx_ring->next = q_vector->tx.ring;
  #line 4188 
  q_vector->tx.ring = tx_ring;
  #line 4189 
  q_vector->tx.count = (u16)((int)q_vector->tx.count + 1);
  #line 4192 
  if ((int)i40e_enabled_xdp_vsi_0(vsi) != 0) {
    #line 4193 
    struct i40e_ring *xdp_ring = *(vsi->xdp_rings + (unsigned long)qp_idx);
    #line 4195 
    xdp_ring->q_vector = q_vector;
    #line 4196 
    xdp_ring->next = q_vector->tx.ring;
    #line 4197 
    q_vector->tx.ring = xdp_ring;
    #line 4198 
    q_vector->tx.count = (u16)((int)q_vector->tx.count + 1);
  }
  #line 4201 
  rx_ring->q_vector = q_vector;
  #line 4202 
  rx_ring->next = q_vector->rx.ring;
  #line 4203 
  q_vector->rx.ring = rx_ring;
  #line 4204 
  q_vector->rx.count = (u16)((int)q_vector->rx.count + 1);
  #line 4205 
  return;
}

#line 4216  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_map_rings_to_vectors(struct i40e_vsi *vsi)
{
  #line 4220 
  int num_ringpairs;
  #line 4218 
  int qp_remaining = (int)vsi->num_queue_pairs;
  #line 4219 
  int q_vectors = vsi->num_q_vectors;
  #line 4221 
  int v_start = 0;
  #line 4222 
  int qp_idx = 0;
  #line 4231 
  while (v_start < q_vectors) {
    {
      #line 4232 
      struct i40e_q_vector *q_vector = *(vsi->q_vectors + (unsigned long)v_start);
      #line 4234 
      num_ringpairs = (((q_vectors - v_start) + qp_remaining) + -1) / (q_vectors - v_start);
      #line 4236 
      q_vector->num_ringpairs = (unsigned char)num_ringpairs;
      #line 4237 
      q_vector->reg_idx = (unsigned short)((unsigned int)((int)q_vector->v_idx + (int)((unsigned short)vsi->base_vector)) + 65535U);
      #line 4239 
      q_vector->rx.count = (unsigned short)0U;
      #line 4240 
      q_vector->tx.count = (unsigned short)0U;
      #line 4241 
      q_vector->rx.ring = (struct i40e_ring *)0;
      #line 4242 
      q_vector->tx.ring = (struct i40e_ring *)0;
      #line 4244 
      while (1) {
        #line 4244 
        int tmp;
        #line 4244 
        tmp = num_ringpairs;
        #line 4244 
        num_ringpairs --;
        #line 4244 
        ;
        #line 4244 
        if (! (tmp != 0)) 
                          #line 4244 
                          break;
        #line 4245 
        i40e_map_vector_to_qp(vsi,v_start,qp_idx);
        #line 4246 
        qp_idx ++;
        #line 4247 
        qp_remaining --;
      }
    }
    #line 4231 
    v_start ++;
  }
  #line 4250 
  return;
}

#line 4257  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_request_irq(struct i40e_vsi *vsi, char *basename)
{
  #line 4260 
  int err;
  #line 4259 
  struct i40e_pf *pf = vsi->back;
  #line 4262 
  if (((unsigned long)pf->flags & 4UL) != 0UL) 
                                               #line 4263 
                                               err = i40e_vsi_request_irq_msix(vsi,basename);
  else 
    #line 4264 
    if (((unsigned long)pf->flags & 2UL) != 0UL) 
                                                 #line 4265 
                                                 err = cif_request_irq((pf->pdev)->irq,& i40e_intr,0UL,(char *)(& pf->int_name),(void *)pf); else 
                                                                    #line 4268 
                                                                    err = cif_request_irq((pf->pdev)->irq,& i40e_intr,128UL,(char *)(& pf->int_name),(void *)pf);
  #line 4271 
  if (err != 0) 
                #line 4272 
                _dev_info(& (pf->pdev)->dev,(char *)"request_irq failed, Error %d\n",err);
  #line 4274 
  return err;
}

#line 4285  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_netpoll(struct net_device *netdev)
{
  #line 4290 
  int i;
  #line 4287 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 4288 
  struct i40e_vsi *vsi = np->vsi;
  #line 4289 
  struct i40e_pf *pf = vsi->back;
  #line 4293 
  if ((int)test_bit(0L,(unsigned long *)(& vsi->state)) != 0) 
                                                              #line 4294 
                                                              return;
  #line 4296 
  if (((unsigned long)pf->flags & 4UL) != 0UL) {
    #line 4297 
    i = 0;
    #line 4297 
    while (vsi->num_q_vectors > i) {
      #line 4298 
      i40e_msix_clean_rings(0,(void *)*(vsi->q_vectors + (unsigned long)i));
      #line 4297 
      i ++;
    }
  }
  else 
       #line 4300 
       i40e_intr((int)(pf->pdev)->irq,(void *)netdev);
  #line 4301 
  return;
}

#line 4318  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_pf_txq_wait(struct i40e_pf *pf, int pf_q, bool enable)
{
  #line 4320 
  int i;
  #line 4321 
  u32 tx_reg;
  #line 4323 
  i = 0;
  #line 4323 
  while (i <= 9) {
    #line 4324 
    tx_reg = readl((void *)(pf->hw.hw_addr + (unsigned long)((pf_q + 262144) * 4)));
    #line 4325 
    if ((int)enable == ((tx_reg & 4U) != 0U)) 
                                              #line 4326 
                                              break;
    #line 4328 
    usleep_range(10UL,20UL);
    #line 4323 
    i ++;
  }
  #line 4330 
  if (i > 9) 
             #line 4331 
             return -110;
  #line 4333 
  return 0;
}

#line 4346  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_control_tx_q(struct i40e_pf *pf, int pf_q, bool enable)
{
  #line 4349 
  u32 tx_reg;
  #line 4350 
  int i;
  #line 4348 
  struct i40e_hw *hw = & pf->hw;
  #line 4353 
  i40e_pre_tx_queue_cfg(& pf->hw,(unsigned int)pf_q,(_Bool)((bool)((int)enable) != 0));
  #line 4354 
  if (! enable) 
                #line 4355 
                usleep_range(10UL,20UL);
  #line 4357 
  i = 0;
  #line 4357 
  while (i <= 49) {
    #line 4358 
    tx_reg = readl((void *)(hw->hw_addr + (unsigned long)((pf_q + 262144) * 4)));
    #line 4359 
    if ((((tx_reg >> 2) ^ tx_reg) & 1U) == 0U) 
                                               #line 4361 
                                               break;
    #line 4362 
    usleep_range(1000UL,2000UL);
    #line 4357 
    i ++;
  }
  #line 4366 
  if ((int)enable == ((tx_reg & 4U) != 0U)) 
                                            #line 4367 
                                            return;
  #line 4370 
  if ((int)enable != 0) {
    #line 4371 
    writel(0U,(void *)(hw->hw_addr + (unsigned long)((pf_q + 233472) * 4)));
    #line 4372 
    tx_reg |= 1U;
  }
  else 
       #line 4374 
       tx_reg &= 4294967294U;
  #line 4377 
  writel(tx_reg,(void *)(hw->hw_addr + (unsigned long)((pf_q + 262144) * 4)));
  #line 4378 
  return;
}

#line 4388  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_control_wait_tx_q(int seid, struct i40e_pf *pf, int pf_q, bool is_xdp, bool enable)
{
  #line 4391 
  int ret;
  #line 4393 
  i40e_control_tx_q(pf,pf_q,(_Bool)((bool)((int)enable) != 0));
  #line 4396 
  ret = i40e_pf_txq_wait(pf,pf_q,(_Bool)((bool)((int)enable) != 0));
  #line 4397 
  if (ret != 0) {
    #line 4398 
    char *tmp;
    #line 4398 
    char *tmp_0;
    #line 4398 
    if ((int)enable != 0) 
                          #line 4398 
                          tmp = (char *)"en"; else 
                                                   #line 4398 
                                                   tmp = (char *)"dis";
    #line 4398 
    ;
    #line 4398 
    if ((int)is_xdp != 0) 
                          #line 4398 
                          tmp_0 = (char *)"XDP "; else 
                                                       #line 4398 
                                                       tmp_0 = (char *)"";
    #line 4398 
    ;
    #line 4398 
    ;
    #line 4398 
    _dev_info(& (pf->pdev)->dev,(char *)"VSI seid %d %sTx ring %d %sable timeout\n",seid,tmp_0,pf_q,tmp);
  }
  #line 4404 
  return ret;
}

#line 4412  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_control_tx(struct i40e_vsi *vsi, bool enable)
{
  #line 4415 
  int i;
  #line 4415 
  int pf_q;
  #line 4414 
  struct i40e_pf *pf = vsi->back;
  #line 4415 
  int ret = 0;
  #line 4417 
  pf_q = (int)vsi->base_queue;
  #line 4418 
  i = 0;
  #line 4418 
  while ((int)vsi->num_queue_pairs > i) {
    {
      #line 4419 
      ret = i40e_control_wait_tx_q((int)vsi->seid,pf,pf_q,(_Bool)0,(_Bool)((bool)((int)enable) != 0));
      #line 4422 
      if (ret != 0) 
                    #line 4423 
                    break;
      #line 4425 
      if (! i40e_enabled_xdp_vsi_0(vsi)) 
                                         #line 4426 
                                         goto __Cont;
      #line 4428 
      ret = i40e_control_wait_tx_q((int)vsi->seid,pf,(int)vsi->alloc_queue_pairs + pf_q,(_Bool)1,(_Bool)((bool)((int)enable) != 0));
      #line 4431 
      if (ret != 0) 
                    #line 4432 
                    break;
    }
    #line 4418 
    __Cont: 
            #line 4418 
    i ++;
    #line 4418 
    pf_q ++;
  }
  #line 4434 
  return ret;
}

#line 4448  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_pf_rxq_wait(struct i40e_pf *pf, int pf_q, bool enable)
{
  #line 4450 
  int i;
  #line 4451 
  u32 rx_reg;
  #line 4453 
  i = 0;
  #line 4453 
  while (i <= 9) {
    #line 4454 
    rx_reg = readl((void *)(pf->hw.hw_addr + (unsigned long)((pf_q + 294912) * 4)));
    #line 4455 
    if ((int)enable == ((rx_reg & 4U) != 0U)) 
                                              #line 4456 
                                              break;
    #line 4458 
    usleep_range(10UL,20UL);
    #line 4453 
    i ++;
  }
  #line 4460 
  if (i > 9) 
             #line 4461 
             return -110;
  #line 4463 
  return 0;
}

#line 4476  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_control_rx_q(struct i40e_pf *pf, int pf_q, bool enable)
{
  #line 4479 
  u32 rx_reg;
  #line 4480 
  int i;
  #line 4478 
  struct i40e_hw *hw = & pf->hw;
  #line 4482 
  i = 0;
  #line 4482 
  while (i <= 49) {
    #line 4483 
    rx_reg = readl((void *)(hw->hw_addr + (unsigned long)((pf_q + 294912) * 4)));
    #line 4484 
    if ((((rx_reg >> 2) ^ rx_reg) & 1U) == 0U) 
                                               #line 4486 
                                               break;
    #line 4487 
    usleep_range(1000UL,2000UL);
    #line 4482 
    i ++;
  }
  #line 4491 
  if ((int)enable == ((rx_reg & 4U) != 0U)) 
                                            #line 4492 
                                            return;
  #line 4495 
  if ((int)enable != 0) 
                        #line 4496 
                        rx_reg |= 1U; else 
                                           #line 4498 
                                           rx_reg &= 4294967294U;
  #line 4500 
  writel(rx_reg,(void *)(hw->hw_addr + (unsigned long)((pf_q + 294912) * 4)));
  #line 4501 
  return;
}

#line 4513  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_control_wait_rx_q(struct i40e_pf *pf, int pf_q, bool enable)
{
  #line 4515 
  int ret = 0;
  #line 4517 
  i40e_control_rx_q(pf,pf_q,(_Bool)((bool)((int)enable) != 0));
  #line 4520 
  ret = i40e_pf_rxq_wait(pf,pf_q,(_Bool)((bool)((int)enable) != 0));
  #line 4521 
  if (ret != 0) 
                #line 4522 
                return ret;
  #line 4524 
  return ret;
}

#line 4532  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_control_rx(struct i40e_vsi *vsi, bool enable)
{
  #line 4535 
  int i;
  #line 4535 
  int pf_q;
  #line 4534 
  struct i40e_pf *pf = vsi->back;
  #line 4535 
  int ret = 0;
  #line 4537 
  pf_q = (int)vsi->base_queue;
  #line 4538 
  i = 0;
  #line 4538 
  while ((int)vsi->num_queue_pairs > i) {
    #line 4539 
    ret = i40e_control_wait_rx_q(pf,pf_q,(_Bool)((bool)((int)enable) != 0));
    #line 4540 
    if (ret != 0) {
      #line 4541 
      char *tmp;
      #line 4541 
      if ((int)enable != 0) 
                            #line 4541 
                            tmp = (char *)"en"; else 
                                                     #line 4541 
                                                     tmp = (char *)"dis";
      #line 4541 
      ;
      #line 4541 
      ;
      #line 4541 
      ;
      #line 4541 
      _dev_info(& (pf->pdev)->dev,(char *)"VSI seid %d Rx ring %d %sable timeout\n",(int)vsi->seid,pf_q,tmp);
      #line 4544 
      break;
    }
    #line 4538 
    i ++;
    #line 4538 
    pf_q ++;
  }
  #line 4551 
  if (! enable) {
    #line 4552 
    unsigned long __ms = 50UL;
    #line 4552 
    while (1) {
      #line 4552 
      unsigned long tmp_0;
      #line 4552 
      tmp_0 = __ms;
      #line 4552 
      __ms --;
      #line 4552 
      ;
      #line 4552 
      if (! (tmp_0 != 0UL)) 
                            #line 4552 
                            break;
      #line 4552 
      __const_udelay(4295000UL);
    }
  }
  #line 4554 
  return ret;
}

#line 4561  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_vsi_start_rings(struct i40e_vsi *vsi)
{
  #line 4563 
  int ret = 0;
  #line 4566 
  ret = i40e_vsi_control_rx(vsi,(_Bool)1);
  #line 4567 
  if (ret != 0) 
                #line 4568 
                return ret;
  #line 4569 
  ret = i40e_vsi_control_tx(vsi,(_Bool)1);
  #line 4571 
  return ret;
}

#line 4578  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_vsi_stop_rings(struct i40e_vsi *vsi)
{
  #line 4581 
  if ((int)test_bit(25L,(unsigned long *)(& (vsi->back)->state)) != 0) 
    #line 4582 
    i40e_vsi_stop_rings_no_wait(vsi);
  #line 4587 
  i40e_vsi_control_tx(vsi,(_Bool)0);
  #line 4588 
  i40e_vsi_control_rx(vsi,(_Bool)0);
  #line 4589 
  return;
}

#line 4602  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_vsi_stop_rings_no_wait(struct i40e_vsi *vsi)
{
  #line 4605 
  int i;
  #line 4605 
  int pf_q;
  #line 4604 
  struct i40e_pf *pf = vsi->back;
  #line 4607 
  pf_q = (int)vsi->base_queue;
  #line 4608 
  i = 0;
  #line 4608 
  while ((int)vsi->num_queue_pairs > i) {
    #line 4609 
    i40e_control_tx_q(pf,pf_q,(_Bool)0);
    #line 4610 
    i40e_control_rx_q(pf,pf_q,(_Bool)0);
    #line 4608 
    i ++;
    #line 4608 
    pf_q ++;
  }
  #line 4612 
  return;
}

#line 4618  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_free_irq(struct i40e_vsi *vsi)
{
  #line 4623 
  u32 val;
  #line 4623 
  u32 qp;
  #line 4624 
  int i;
  #line 4620 
  struct i40e_pf *pf = vsi->back;
  #line 4621 
  struct i40e_hw *hw = & pf->hw;
  #line 4622 
  int base = vsi->base_vector;
  #line 4626 
  if (((unsigned long)pf->flags & 4UL) != 0UL) {
    #line 4627 
    if (vsi->q_vectors == (struct i40e_q_vector **)0) 
                                                      #line 4628 
                                                      return;
    #line 4630 
    if (! vsi->irqs_ready) 
                           #line 4631 
                           return;
    #line 4633 
    vsi->irqs_ready = (_Bool)0;
    #line 4634 
    i = 0;
    #line 4634 
    while (vsi->num_q_vectors > i) {
      {
        #line 4635 
        int irq_num;
        #line 4636 
        u16 vector;
        #line 4638 
        vector = (unsigned short)((int)((unsigned short)i) + (int)((unsigned short)base));
        #line 4639 
        irq_num = (int)(pf->msix_entries + (unsigned long)vector)->vector;
        #line 4642 
        if (*(vsi->q_vectors + (unsigned long)i) == (struct i40e_q_vector *)0 || (unsigned int)(*(vsi->q_vectors + (unsigned long)i))->num_ringpairs == 0U) 
          #line 4644 
          goto __Cont;
        #line 4647 
        irq_set_affinity_notifier((unsigned int)irq_num,(struct irq_affinity_notify *)0);
        #line 4649 
        irq_set_affinity_hint((unsigned int)irq_num,(struct cpumask *)0);
        #line 4650 
        synchronize_irq((unsigned int)irq_num);
        #line 4651 
        cif_free_irq((unsigned int)irq_num,(void *)*(vsi->q_vectors + (unsigned long)i));
        #line 4660 
        val = readl((void *)(hw->hw_addr + (unsigned long)(((int)vector + 54271) * 4)));
        #line 4661 
        qp = val & 2047U;
        #line 4663 
        val |= 2047U;
        #line 4665 
        writel(val,(void *)(hw->hw_addr + (unsigned long)(((int)vector + 54271) * 4)));
        #line 4667 
        while (qp != 2047U) {
          #line 4668 
          u32 next;
          #line 4670 
          val = readl((void *)(hw->hw_addr + (unsigned long)((qp + 59392U) * 4U)));
          #line 4672 
          val &= 1073684224U;
          #line 4677 
          val |= 134158336U;
          #line 4680 
          writel(val,(void *)(hw->hw_addr + (unsigned long)((qp + 59392U) * 4U)));
          #line 4682 
          val = readl((void *)(hw->hw_addr + (unsigned long)((qp + 61440U) * 4U)));
          #line 4684 
          next = (val >> 16) & 2047U;
          #line 4687 
          val &= 1073684224U;
          #line 4692 
          val |= 134158336U;
          #line 4695 
          writel(val,(void *)(hw->hw_addr + (unsigned long)((qp + 61440U) * 4U)));
          #line 4696 
          qp = next;
        }
      }
      #line 4634 
      __Cont: 
              #line 4634 
      i ++;
    }
  }
  else {
    #line 4700 
    cif_free_irq((pf->pdev)->irq,(void *)pf);
    #line 4702 
    val = readl((void *)(hw->hw_addr + 230656U));
    #line 4703 
    qp = val & 2047U;
    #line 4705 
    val |= 2047U;
    #line 4707 
    writel(val,(void *)(hw->hw_addr + 230656U));
    #line 4709 
    val = readl((void *)(hw->hw_addr + (unsigned long)((qp + 59392U) * 4U)));
    #line 4710 
    val &= 1073684224U;
    #line 4715 
    val |= 134158336U;
    #line 4718 
    writel(val,(void *)(hw->hw_addr + (unsigned long)((qp + 59392U) * 4U)));
    #line 4720 
    val = readl((void *)(hw->hw_addr + (unsigned long)((qp + 61440U) * 4U)));
    #line 4722 
    val &= 1073684224U;
    #line 4727 
    val |= 134158336U;
    #line 4730 
    writel(val,(void *)(hw->hw_addr + (unsigned long)((qp + 61440U) * 4U)));
  }
  #line 4732 
  return;
}

#line 4743  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_free_q_vector(struct i40e_vsi *vsi, int v_idx)
{
  #line 4746 
  struct i40e_ring *ring;
  #line 4745 
  struct i40e_q_vector *q_vector = *(vsi->q_vectors + (unsigned long)v_idx);
  #line 4748 
  if (q_vector == (struct i40e_q_vector *)0) 
                                             #line 4749 
                                             return;
  #line 4752 
  ring = q_vector->tx.ring;
  #line 4752 
  while (ring != (struct i40e_ring *)0) {
    #line 4753 
    ring->q_vector = (struct i40e_q_vector *)0;
    #line 4752 
    ring = ring->next;
  }
  #line 4755 
  ring = q_vector->rx.ring;
  #line 4755 
  while (ring != (struct i40e_ring *)0) {
    #line 4756 
    ring->q_vector = (struct i40e_q_vector *)0;
    #line 4755 
    ring = ring->next;
  }
  #line 4759 
  if (vsi->netdev != (struct net_device *)0) 
                                             #line 4760 
                                             netif_napi_del(& q_vector->napi);
  #line 4762 
  *(vsi->q_vectors + (unsigned long)v_idx) = (struct i40e_q_vector *)0;
  {
    #line 4764 
    struct i40e_q_vector *___p = q_vector;
    #line 4764 
    if (___p != (struct i40e_q_vector *)0) 
                                           #line 4764 
                                           kfree_call_rcu(& ___p->rcu,(void (*)(struct callback_head *))1608);
  }
  #line 4767 
  return;
}

#line 4774  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_free_q_vectors(struct i40e_vsi *vsi)
{
  #line 4776 
  int v_idx;
  #line 4778 
  v_idx = 0;
  #line 4778 
  while (vsi->num_q_vectors > v_idx) {
    #line 4779 
    i40e_free_q_vector(vsi,v_idx);
    #line 4778 
    v_idx ++;
  }
  #line 4780 
  return;
}

#line 4786  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_reset_interrupt_capability(struct i40e_pf *pf)
{
  #line 4789 
  if (((unsigned long)pf->flags & 4UL) != 0UL) {
    #line 4790 
    pci_disable_msix(pf->pdev);
    #line 4791 
    kfree((void *)pf->msix_entries);
    #line 4792 
    pf->msix_entries = (struct msix_entry *)0;
    #line 4793 
    kfree((void *)pf->irq_pile);
    #line 4794 
    pf->irq_pile = (struct i40e_lump_tracking *)0;
  }
  else 
    #line 4795 
    if (((unsigned long)pf->flags & 2UL) != 0UL) 
                                                 #line 4796 
                                                 pci_disable_msi(pf->pdev);
  #line 4798 
  pf->flags &= 4294967289U;
  #line 4799 
  return;
}

#line 4808  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_clear_interrupt_scheme(struct i40e_pf *pf)
{
  #line 4810 
  int i;
  #line 4812 
  i40e_free_misc_vector(pf);
  #line 4814 
  i40e_put_lump(pf->irq_pile,(unsigned short)((int)((unsigned short)pf->iwarp_base_vector)),(unsigned short)32766);
  #line 4817 
  i40e_put_lump(pf->irq_pile,(unsigned short)0,(unsigned short)32767);
  #line 4818 
  i = 0;
  #line 4818 
  while ((int)pf->num_alloc_vsi > i) {
    #line 4819 
    if (*(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0) 
                                                               #line 4820 
                                                               i40e_vsi_free_q_vectors(*(pf->vsi + (unsigned long)i));
    #line 4818 
    i ++;
  }
  #line 4821 
  i40e_reset_interrupt_capability(pf);
  #line 4822 
  return;
}

#line 4828  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_napi_enable_all(struct i40e_vsi *vsi)
{
  #line 4830 
  int q_idx;
  #line 4832 
  if (vsi->netdev == (struct net_device *)0) 
                                             #line 4833 
                                             return;
  #line 4835 
  q_idx = 0;
  #line 4835 
  while (vsi->num_q_vectors > q_idx) {
    {
      #line 4836 
      struct i40e_q_vector *q_vector = *(vsi->q_vectors + (unsigned long)q_idx);
      #line 4838 
      if (q_vector->rx.ring != (struct i40e_ring *)0 || q_vector->tx.ring != (struct i40e_ring *)0) 
        #line 4839 
        napi_enable(& q_vector->napi);
    }
    #line 4835 
    q_idx ++;
  }
  #line 4841 
  return;
}

#line 4847  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_napi_disable_all(struct i40e_vsi *vsi)
{
  #line 4849 
  int q_idx;
  #line 4851 
  if (vsi->netdev == (struct net_device *)0) 
                                             #line 4852 
                                             return;
  #line 4854 
  q_idx = 0;
  #line 4854 
  while (vsi->num_q_vectors > q_idx) {
    {
      #line 4855 
      struct i40e_q_vector *q_vector = *(vsi->q_vectors + (unsigned long)q_idx);
      #line 4857 
      if (q_vector->rx.ring != (struct i40e_ring *)0 || q_vector->tx.ring != (struct i40e_ring *)0) 
        #line 4858 
        napi_disable(& q_vector->napi);
    }
    #line 4854 
    q_idx ++;
  }
  #line 4860 
  return;
}

#line 4866  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_close(struct i40e_vsi *vsi)
{
  #line 4868 
  struct i40e_pf *pf = vsi->back;
  #line 4869 
  if (! test_and_set_bit(0L,(unsigned long *)(& vsi->state))) 
                                                              #line 4870 
                                                              i40e_down(vsi);
  #line 4871 
  i40e_vsi_free_irq(vsi);
  #line 4872 
  i40e_vsi_free_tx_resources(vsi);
  #line 4873 
  i40e_vsi_free_rx_resources(vsi);
  #line 4874 
  vsi->current_netdev_flags = 0U;
  #line 4875 
  cif_set_bit_1(30L,(unsigned long *)(& pf->state));
  #line 4876 
  if ((int)test_bit(8L,(unsigned long *)(& pf->state)) != 0) 
                                                             #line 4877 
                                                             cif_set_bit_1(32L,(unsigned long *)(& pf->state));
  #line 4878 
  return;
}

#line 4884  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_quiesce_vsi(struct i40e_vsi *vsi)
{
  #line 4886 
  if ((int)test_bit(0L,(unsigned long *)(& vsi->state)) != 0) 
                                                              #line 4887 
                                                              return;
  #line 4889 
  cif_set_bit_1(1L,(unsigned long *)(& vsi->state));
  #line 4890 
  if (vsi->netdev != (struct net_device *)0) {
    #line 4890 
    if ((int)netif_running(vsi->netdev) != 0) 
                                              #line 4891 
                                              (*(((vsi->netdev)->netdev_ops)->ndo_stop))(vsi->netdev); else 
                                                                    #line 4893 
                                                                    i40e_vsi_close(vsi);
  }
  else 
       #line 4893 
       i40e_vsi_close(vsi);
  #line 4894 
  return;
}

#line 4900  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_unquiesce_vsi(struct i40e_vsi *vsi)
{
  #line 4902 
  if (! test_and_set_bit(1L,(unsigned long *)(& vsi->state))) 
                                                              #line 4903 
                                                              return;
  #line 4905 
  if (vsi->netdev != (struct net_device *)0) {
    #line 4905 
    if ((int)netif_running(vsi->netdev) != 0) 
                                              #line 4906 
                                              (*(((vsi->netdev)->netdev_ops)->ndo_open))(vsi->netdev); else 
                                                                    #line 4908 
                                                                    i40e_vsi_open(vsi);
  }
  else 
       #line 4908 
       i40e_vsi_open(vsi);
  #line 4909 
  return;
}

#line 4915  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_pf_quiesce_all_vsi(struct i40e_pf *pf)
{
  #line 4917 
  int v;
  #line 4919 
  v = 0;
  #line 4919 
  while ((int)pf->num_alloc_vsi > v) {
    #line 4920 
    if (*(pf->vsi + (unsigned long)v) != (struct i40e_vsi *)0) 
                                                               #line 4921 
                                                               i40e_quiesce_vsi(*(pf->vsi + (unsigned long)v));
    #line 4919 
    v ++;
  }
  #line 4922 
  return;
}

#line 4929  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_pf_unquiesce_all_vsi(struct i40e_pf *pf)
{
  #line 4931 
  int v;
  #line 4933 
  v = 0;
  #line 4933 
  while ((int)pf->num_alloc_vsi > v) {
    #line 4934 
    if (*(pf->vsi + (unsigned long)v) != (struct i40e_vsi *)0) 
                                                               #line 4935 
                                                               i40e_unquiesce_vsi(*(pf->vsi + (unsigned long)v));
    #line 4933 
    v ++;
  }
  #line 4936 
  return;
}

#line 4945  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_vsi_wait_queues_disabled(struct i40e_vsi *vsi)
{
  #line 4948 
  int i;
  #line 4948 
  int pf_q;
  #line 4948 
  int ret;
  #line 4947 
  struct i40e_pf *pf = vsi->back;
  #line 4950 
  pf_q = (int)vsi->base_queue;
  #line 4951 
  i = 0;
  #line 4951 
  while ((int)vsi->num_queue_pairs > i) {
    {
      #line 4953 
      ret = i40e_pf_txq_wait(pf,pf_q,(_Bool)0);
      #line 4954 
      if (ret != 0) {
        #line 4955 
        _dev_info(& (pf->pdev)->dev,(char *)"VSI seid %d Tx ring %d disable timeout\n",(int)vsi->seid,pf_q);
        #line 4958 
        return ret;
      }
      #line 4961 
      if (! i40e_enabled_xdp_vsi_0(vsi)) 
                                         #line 4962 
                                         goto wait_rx;
      #line 4965 
      ret = i40e_pf_txq_wait(pf,(int)vsi->alloc_queue_pairs + pf_q,(_Bool)0);
      #line 4967 
      if (ret != 0) {
        #line 4968 
        _dev_info(& (pf->pdev)->dev,(char *)"VSI seid %d XDP Tx ring %d disable timeout\n",(int)vsi->seid,pf_q);
        #line 4971 
        return ret;
      }
      #line 4973 
      wait_rx: 
               #line 4973 
      ;
      #line 4975 
      ret = i40e_pf_rxq_wait(pf,pf_q,(_Bool)0);
      #line 4976 
      if (ret != 0) {
        #line 4977 
        _dev_info(& (pf->pdev)->dev,(char *)"VSI seid %d Rx ring %d disable timeout\n",(int)vsi->seid,pf_q);
        #line 4980 
        return ret;
      }
    }
    #line 4951 
    i ++;
    #line 4951 
    pf_q ++;
  }
  #line 4984 
  return 0;
}

#line 4995  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_pf_wait_queues_disabled(struct i40e_pf *pf)
{
  #line 4997 
  int v;
  #line 4997 
  int ret = 0;
  #line 4999 
  v = 0;
  #line 4999 
  while (pf->hw.func_caps.num_vsis > (unsigned int)v) {
    #line 5000 
    if (*(pf->vsi + (unsigned long)v) != (struct i40e_vsi *)0) {
      #line 5001 
      ret = i40e_vsi_wait_queues_disabled(*(pf->vsi + (unsigned long)v));
      #line 5002 
      if (ret != 0) 
                    #line 5003 
                    break;
    }
    #line 4999 
    v ++;
  }
  #line 5007 
  return ret;
}

#line 5019  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static u8 i40e_get_iscsi_tc_map(struct i40e_pf *pf)
{
  #line 5021 
  struct i40e_dcb_app_priority_table app;
  #line 5024 
  u8 tc;
  #line 5024 
  u8 i;
  #line 5022 
  struct i40e_hw *hw = & pf->hw;
  #line 5023 
  u8 enabled_tc = (unsigned char)1U;
  #line 5026 
  struct i40e_dcbx_config *dcbcfg = & hw->local_dcbx_config;
  #line 5028 
  i = (unsigned char)0U;
  #line 5028 
  while ((unsigned int)i < dcbcfg->numapps) {
    #line 5029 
    app = dcbcfg->app[(int)i];
    #line 5030 
    if ((unsigned int)app.selector == 2U && (unsigned int)app.protocolid == 3260U) {
      #line 5032 
      tc = dcbcfg->etscfg.prioritytable[(int)app.priority];
      #line 5033 
      enabled_tc = (unsigned char)((int)((unsigned char)(1UL << (int)tc)) | (int)enabled_tc);
      #line 5034 
      break;
    }
    #line 5028 
    i = (u8)((int)i + 1);
  }
  #line 5038 
  return enabled_tc;
}

#line 5047  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static u8 i40e_dcb_get_num_tc(struct i40e_dcbx_config *dcbcfg)
{
  #line 5049 
  int i;
  #line 5049 
  int tc_unused = 0;
  #line 5050 
  u8 num_tc = (unsigned char)0U;
  #line 5051 
  u8 ret = (unsigned char)0U;
  #line 5057 
  i = 0;
  #line 5057 
  while (i <= 7) {
    #line 5058 
    num_tc = (unsigned char)((int)((unsigned char)(1UL << (int)dcbcfg->etscfg.prioritytable[i])) | (int)num_tc);
    #line 5057 
    i ++;
  }
  #line 5063 
  i = 0;
  #line 5063 
  while (i <= 7) {
    #line 5064 
    if ((((unsigned long)num_tc >> i) & 1UL) != 0UL) 
      #line 5065 
      if (tc_unused == 0) 
                          #line 5066 
                          ret = (u8)((int)ret + 1);
      else {
        #line 5068 
        printk((char *)"\001");
        #line 5069 
        return (unsigned char)1U;
      }
    else 
         #line 5072 
         tc_unused = 1;
    #line 5063 
    i ++;
  }
  #line 5077 
  if ((unsigned int)ret == 0U) 
                               #line 5078 
                               ret = (unsigned char)1U;
  #line 5080 
  return ret;
}

#line 5090  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static u8 i40e_dcb_get_enabled_tc(struct i40e_dcbx_config *dcbcfg)
{
  #line 5094 
  u8 i;
  #line 5092 
  u8 num_tc = i40e_dcb_get_num_tc(dcbcfg);
  #line 5093 
  u8 enabled_tc = (unsigned char)1U;
  #line 5096 
  i = (unsigned char)0U;
  #line 5096 
  while ((int)i < (int)num_tc) {
    #line 5097 
    enabled_tc = (unsigned char)((int)((unsigned char)(1UL << (int)i)) | (int)enabled_tc);
    #line 5096 
    i = (u8)((int)i + 1);
  }
  #line 5099 
  return enabled_tc;
}

#line 5109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static u8 i40e_mqprio_get_enabled_tc(struct i40e_pf *pf)
{
  #line 5113 
  u8 i;
  #line 5111 
  struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)pf->lan_vsi);
  #line 5112 
  u8 num_tc = vsi->mqprio_qopt.qopt.num_tc;
  #line 5113 
  u8 enabled_tc = (unsigned char)1U;
  #line 5115 
  i = (unsigned char)1U;
  #line 5115 
  while ((int)i < (int)num_tc) {
    #line 5116 
    enabled_tc = (unsigned char)((int)((unsigned char)(1UL << (int)i)) | (int)enabled_tc);
    #line 5115 
    i = (u8)((int)i + 1);
  }
  #line 5117 
  return enabled_tc;
}

#line 5126  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static u8 i40e_pf_get_num_tc(struct i40e_pf *pf)
{
  #line 5129 
  u8 i;
  #line 5128 
  struct i40e_hw *hw = & pf->hw;
  #line 5129 
  u8 enabled_tc = (unsigned char)1U;
  #line 5130 
  u8 num_tc = (unsigned char)0U;
  #line 5131 
  struct i40e_dcbx_config *dcbcfg = & hw->local_dcbx_config;
  #line 5133 
  if (((unsigned long)pf->flags & 2097152UL) != 0UL) 
                                                     #line 5134 
                                                     return (*(pf->vsi + (unsigned long)pf->lan_vsi))->mqprio_qopt.qopt.num_tc;
  #line 5137 
  if (((unsigned long)pf->flags & 128UL) == 0UL) 
                                                 #line 5138 
                                                 return (unsigned char)1U;
  #line 5141 
  if (((unsigned long)pf->flags & 1024UL) == 0UL) {
    #line 5142 
    return i40e_dcb_get_num_tc(dcbcfg);
  }
  #line 5145 
  if ((int)pf->hw.func_caps.iscsi != 0) 
                                        #line 5146 
                                        enabled_tc = i40e_get_iscsi_tc_map(pf); else 
                                                                    #line 5148 
                                                                    return (unsigned char)1U;
  #line 5150 
  i = (unsigned char)0U;
  #line 5150 
  while ((unsigned int)i <= 7U) {
    #line 5151 
    if ((((unsigned long)enabled_tc >> (int)i) & 1UL) != 0UL) 
                                                              #line 5152 
                                                              num_tc = (u8)((int)num_tc + 1);
    #line 5150 
    i = (u8)((int)i + 1);
  }
  #line 5154 
  return num_tc;
}

#line 5163  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static u8 i40e_pf_get_tc_map(struct i40e_pf *pf)
{
  #line 5165 
  if (((unsigned long)pf->flags & 2097152UL) != 0UL) {
    #line 5166 
    return i40e_mqprio_get_enabled_tc(pf);
  }
  #line 5171 
  if (((unsigned long)pf->flags & 128UL) == 0UL) 
                                                 #line 5172 
                                                 return (unsigned char)1U;
  #line 5175 
  if (((unsigned long)pf->flags & 1024UL) == 0UL) {
    #line 5176 
    return i40e_dcb_get_enabled_tc(& pf->hw.local_dcbx_config);
  }
  #line 5179 
  if ((int)pf->hw.func_caps.iscsi != 0) {
    #line 5180 
    return i40e_get_iscsi_tc_map(pf);
  }
  else 
       #line 5182 
       return (unsigned char)1U;
}

#line 5191  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_get_bw_info(struct i40e_vsi *vsi)
{
  #line 5197 
  i40e_status ret;
  #line 5198 
  u32 tc_bw_max;
  #line 5199 
  int i;
  #line 5193 
  struct i40e_aqc_query_vsi_ets_sla_config_resp bw_ets_config = {.tc_valid_bits = (unsigned char)0U, .reserved = {(unsigned char)0, (unsigned char)0, (unsigned char)0}, .share_credits = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .credits = {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0}, .tc_bw_max = {(unsigned short)0, (unsigned short)0}};
  #line 5194 
  struct i40e_aqc_query_vsi_bw_config_resp bw_config = {.tc_valid_bits = (unsigned char)0U, .tc_suspended_bits = (unsigned char)0, .reserved = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .qs_handles = {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0}, .reserved1 = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .port_bw_limit = (unsigned short)0, .reserved2 = {(unsigned char)0, (unsigned char)0}, .max_bw = (unsigned char)0, .reserved3 = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}};
  #line 5195 
  struct i40e_pf *pf = vsi->back;
  #line 5196 
  struct i40e_hw *hw = & pf->hw;
  #line 5202 
  ret = i40e_aq_query_vsi_bw_config(hw,(unsigned short)((int)vsi->seid),& bw_config,(struct i40e_asq_cmd_details *)0);
  #line 5203 
  if (ret != I40E_SUCCESS) {
    #line 5204 
    ;
    #line 5204 
    _dev_info(& (pf->pdev)->dev,(char *)"couldn\'t get PF vsi bw config, err %s aq_err %s\n",i40e_stat_str(& pf->hw,ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 5208 
    return -22;
  }
  #line 5212 
  ret = i40e_aq_query_vsi_ets_sla_config(hw,(unsigned short)((int)vsi->seid),& bw_ets_config,(struct i40e_asq_cmd_details *)0);
  #line 5214 
  if (ret != I40E_SUCCESS) {
    #line 5215 
    ;
    #line 5215 
    _dev_info(& (pf->pdev)->dev,(char *)"couldn\'t get PF vsi ets bw config, err %s aq_err %s\n",i40e_stat_str(& pf->hw,ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 5219 
    return -22;
  }
  #line 5222 
  if ((int)bw_config.tc_valid_bits != (int)bw_ets_config.tc_valid_bits) 
    #line 5223 
    _dev_info(& (pf->pdev)->dev,(char *)"Enabled TCs mismatch from querying VSI BW info 0x%08x 0x%08x\n",(int)bw_config.tc_valid_bits,(int)bw_ets_config.tc_valid_bits);
  #line 5230 
  vsi->bw_limit = bw_config.port_bw_limit;
  #line 5231 
  vsi->bw_max_quanta = bw_config.max_bw;
  #line 5232 
  tc_bw_max = (unsigned int)((int)bw_ets_config.tc_bw_max[0] | ((int)bw_ets_config.tc_bw_max[1] << 16));
  #line 5234 
  i = 0;
  #line 5234 
  while (i <= 7) {
    #line 5235 
    vsi->bw_ets_share_credits[i] = bw_ets_config.share_credits[i];
    #line 5236 
    vsi->bw_ets_limit_credits[i] = bw_ets_config.credits[i];
    #line 5239 
    vsi->bw_ets_max_quanta[i] = (unsigned char)((unsigned int)((unsigned char)(tc_bw_max >> i * 4)) & 7U);
    #line 5234 
    i ++;
  }
  #line 5242 
  return 0;
}

#line 5253  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_configure_bw_alloc(struct i40e_vsi *vsi, u8 enabled_tc, u8 *bw_share)
{
  #line 5256 
  struct i40e_aqc_configure_vsi_tc_bw_data bw_data;
  #line 5258 
  i40e_status ret;
  #line 5259 
  int i;
  #line 5257 
  struct i40e_pf *pf = vsi->back;
  #line 5262 
  if (((unsigned long)pf->flags & 2097152UL) != 0UL) 
                                                     #line 5263 
                                                     return 0;
  #line 5264 
  if ((unsigned int)vsi->mqprio_qopt.qopt.hw == 0U && ((unsigned long)pf->flags & 128UL) == 0UL) {
    #line 5265 
    ret = (enum i40e_status_code)i40e_set_bw_limit(vsi,(unsigned short)((int)vsi->seid),0ULL);
    #line 5266 
    if (ret != I40E_SUCCESS) 
                             #line 5267 
                             _dev_info(& (pf->pdev)->dev,(char *)"Failed to reset tx rate for vsi->seid %u\n",(int)vsi->seid);
    #line 5270 
    return (int)ret;
  }
  #line 5272 
  bw_data.tc_valid_bits = enabled_tc;
  #line 5273 
  i = 0;
  #line 5273 
  while (i <= 7) {
    #line 5274 
    bw_data.tc_bw_credits[i] = *(bw_share + (unsigned long)i);
    #line 5273 
    i ++;
  }
  #line 5276 
  ret = i40e_aq_config_vsi_tc_bw(& pf->hw,(unsigned short)((int)vsi->seid),& bw_data,(struct i40e_asq_cmd_details *)0);
  #line 5277 
  if (ret != I40E_SUCCESS) {
    #line 5278 
    _dev_info(& (pf->pdev)->dev,(char *)"AQ command Config VSI BW allocation per TC failed = %d\n",(unsigned int)pf->hw.aq.asq_last_status);
    #line 5281 
    return -22;
  }
  #line 5284 
  i = 0;
  #line 5284 
  while (i <= 7) {
    #line 5285 
    vsi->info.qs_handle[i] = bw_data.qs_handles[i];
    #line 5284 
    i ++;
  }
  #line 5287 
  return 0;
}

#line 5296  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_config_netdev_tc(struct i40e_vsi *vsi, u8 enabled_tc)
{
  #line 5302 
  int i;
  #line 5298 
  struct net_device *netdev = vsi->netdev;
  #line 5299 
  struct i40e_pf *pf = vsi->back;
  #line 5300 
  struct i40e_hw *hw = & pf->hw;
  #line 5301 
  u8 netdev_tc = (unsigned char)0U;
  #line 5303 
  struct i40e_dcbx_config *dcbcfg = & hw->local_dcbx_config;
  #line 5305 
  if (netdev == (struct net_device *)0) 
                                        #line 5306 
                                        return;
  #line 5308 
  if ((unsigned int)enabled_tc == 0U) {
    #line 5309 
    netdev_reset_tc(netdev);
    #line 5310 
    return;
  }
  #line 5314 
  if (netdev_set_num_tc(netdev,(unsigned char)((int)vsi->tc_config.numtc)) != 0) 
    #line 5315 
    return;
  #line 5318 
  i = 0;
  #line 5318 
  while (i <= 7) {
    #line 5326 
    if ((((unsigned long)vsi->tc_config.enabled_tc >> i) & 1UL) != 0UL) 
      #line 5327 
      netdev_set_tc_queue(netdev,(unsigned char)((int)vsi->tc_config.tc_info[i].netdev_tc),(unsigned short)((int)vsi->tc_config.tc_info[i].qcount),(unsigned short)((int)vsi->tc_config.tc_info[i].qoffset));
    #line 5318 
    i ++;
  }
  #line 5333 
  if (((unsigned long)pf->flags & 2097152UL) != 0UL) 
                                                     #line 5334 
                                                     return;
  #line 5337 
  i = 0;
  #line 5337 
  while (i <= 7) {
    {
      #line 5339 
      u8 ets_tc = dcbcfg->etscfg.prioritytable[i];
      #line 5341 
      netdev_tc = vsi->tc_config.tc_info[(int)ets_tc].netdev_tc;
      #line 5342 
      netdev_set_prio_tc_map(netdev,(unsigned char)((int)((unsigned char)i)),(unsigned char)((int)netdev_tc));
    }
    #line 5337 
    i ++;
  }
  #line 5344 
  return;
}

#line 5351  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_update_queue_map(struct i40e_vsi *vsi, struct i40e_vsi_context *ctxt)
{
  #line 5358 
  vsi->info.mapping_flags = ctxt->info.mapping_flags;
  #line 5359 
  memcpy((void *)(& vsi->info.queue_mapping),(void *)(& ctxt->info.queue_mapping),32UL);
  #line 5361 
  memcpy((void *)(& vsi->info.tc_mapping),(void *)(& ctxt->info.tc_mapping),16UL);
  #line 5362 
  return;
}

#line 5378  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_config_tc(struct i40e_vsi *vsi, u8 enabled_tc)
{
  #line 5383 
  struct i40e_vsi_context ctxt;
  #line 5385 
  int i;
  #line 5380 
  u8 bw_share[8U] = {(unsigned char)0U};
  #line 5381 
  struct i40e_pf *pf = vsi->back;
  #line 5382 
  struct i40e_hw *hw = & pf->hw;
  #line 5384 
  int ret = 0;
  #line 5388 
  if ((int)vsi->tc_config.enabled_tc == (int)enabled_tc && (unsigned int)vsi->mqprio_qopt.mode != 1U) 
    #line 5390 
    return ret;
  #line 5393 
  i = 0;
  #line 5393 
  while (i <= 7) {
    #line 5394 
    if ((((unsigned long)enabled_tc >> i) & 1UL) != 0UL) 
                                                         #line 5395 
                                                         bw_share[i] = (unsigned char)1U;
    #line 5393 
    i ++;
  }
  #line 5398 
  ret = i40e_vsi_configure_bw_alloc(vsi,(unsigned char)((int)enabled_tc),(u8 *)(& bw_share));
  #line 5399 
  if (ret != 0) {
    #line 5400 
    struct i40e_aqc_query_vsi_bw_config_resp bw_config = {.tc_valid_bits = (unsigned char)0U, .tc_suspended_bits = (unsigned char)0, .reserved = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .qs_handles = {(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0}, .reserved1 = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .port_bw_limit = (unsigned short)0, .reserved2 = {(unsigned char)0, (unsigned char)0}, .max_bw = (unsigned char)0, .reserved3 = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}};
    #line 5402 
    _dev_info(& (pf->pdev)->dev,(char *)"Failed configuring TC map %d for VSI %d\n",(int)enabled_tc,(int)vsi->seid);
    #line 5405 
    ret = (int)i40e_aq_query_vsi_bw_config(hw,(unsigned short)((int)vsi->seid),
                                  & bw_config,
                                  (struct i40e_asq_cmd_details *)0);
    #line 5407 
    if (ret != 0) {
      #line 5408 
      ;
      #line 5408 
      _dev_info(& (pf->pdev)->dev,(char *)"Failed querying vsi bw info, err %s aq_err %s\n",i40e_stat_str(hw,(enum i40e_status_code)ret),i40e_aq_str(hw,hw->aq.asq_last_status));
      #line 5412 
      goto out;
    }
    #line 5414 
    if (((int)bw_config.tc_valid_bits & (int)enabled_tc) != (int)enabled_tc) {
      #line 5415 
      u8 valid_tc = (unsigned char)((int)bw_config.tc_valid_bits & (int)enabled_tc);
      #line 5417 
      if ((unsigned int)valid_tc == 0U) 
                                        #line 5418 
                                        valid_tc = bw_config.tc_valid_bits;
      #line 5420 
      valid_tc = (unsigned char)((unsigned int)valid_tc | 1U);
      #line 5421 
      _dev_info(& (pf->pdev)->dev,(char *)"Requested tc 0x%x, but FW reports 0x%x as valid. Attempting to use 0x%x.\n",(int)enabled_tc,(int)bw_config.tc_valid_bits,(int)valid_tc);
      #line 5424 
      enabled_tc = valid_tc;
    }
    #line 5427 
    ret = i40e_vsi_configure_bw_alloc(vsi,(unsigned char)((int)enabled_tc),(u8 *)(& bw_share));
    #line 5428 
    if (ret != 0) {
      #line 5429 
      _dev_err(& (pf->pdev)->dev,(char *)"Unable to  configure TC map %d for VSI %d\n",(int)enabled_tc,(int)vsi->seid);
      #line 5432 
      goto out;
    }
  }
  #line 5437 
  ctxt.seid = vsi->seid;
  #line 5438 
  ctxt.pf_num = (vsi->back)->hw.pf_id;
  #line 5439 
  ctxt.vf_num = (unsigned char)0U;
  #line 5440 
  ctxt.uplink_seid = vsi->uplink_seid;
  #line 5441 
  ctxt.info = vsi->info;
  #line 5442 
  if (((unsigned long)(vsi->back)->flags & 2097152UL) != 0UL) {
    #line 5443 
    ret = i40e_vsi_setup_queue_map_mqprio(vsi,& ctxt,(unsigned char)((int)enabled_tc));
    #line 5444 
    if (ret != 0) 
                  #line 5445 
                  goto out;
  }
  else 
       #line 5447 
       i40e_vsi_setup_queue_map(vsi,& ctxt,(unsigned char)((int)enabled_tc),(_Bool)0);
  #line 5453 
  if ((unsigned int)vsi->mqprio_qopt.qopt.hw == 0U && (int)vsi->reconfig_rss != 0) {
    #line 5454 
    int __UNIQUE_ID___x598;
    #line 5454 
    int tmp_2;
    {
      #line 5454 
      __UNIQUE_ID___x598 = (int)(vsi->back)->alloc_rss_size;
      #line 5454 
      int __UNIQUE_ID___y599 = (int)vsi->num_queue_pairs;
      #line 5454 
      if (__UNIQUE_ID___x598 < __UNIQUE_ID___y599) 
                                                   #line 5454 
                                                   tmp_2 = __UNIQUE_ID___x598; else 
                                                                    #line 5454 
                                                                    tmp_2 = __UNIQUE_ID___y599;
      }
    #line 5454 
    vsi->rss_size = (unsigned short)tmp_2;
    #line 5456 
    ret = i40e_vsi_config_rss(vsi);
    #line 5457 
    if (ret != 0) {
      #line 5458 
      _dev_info(& ((vsi->back)->pdev)->dev,(char *)"Failed to reconfig rss for num_queues\n");
      #line 5460 
      return ret;
    }
    #line 5462 
    vsi->reconfig_rss = (_Bool)0;
  }
  #line 5464 
  if (((unsigned long)(vsi->back)->flags & 262144UL) != 0UL) {
    #line 5465 
    ctxt.info.valid_sections = (unsigned short)((unsigned int)ctxt.info.valid_sections | 128U);
    #line 5467 
    ctxt.info.queueing_opt_flags = (unsigned char)((unsigned int)ctxt.info.queueing_opt_flags | 16U);
  }
  #line 5473 
  ret = (int)i40e_aq_update_vsi_params(hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  #line 5474 
  if (ret != 0) {
    #line 5475 
    ;
    #line 5475 
    _dev_info(& (pf->pdev)->dev,(char *)"Update vsi tc config failed, err %s aq_err %s\n",i40e_stat_str(hw,(enum i40e_status_code)ret),i40e_aq_str(hw,hw->aq.asq_last_status));
    #line 5479 
    goto out;
  }
  #line 5482 
  i40e_vsi_update_queue_map(vsi,& ctxt);
  #line 5483 
  vsi->info.valid_sections = (unsigned short)0U;
  #line 5486 
  ret = i40e_vsi_get_bw_info(vsi);
  #line 5487 
  if (ret != 0) {
    #line 5488 
    ;
    #line 5488 
    _dev_info(& (pf->pdev)->dev,(char *)"Failed updating vsi bw info, err %s aq_err %s\n",i40e_stat_str(hw,(enum i40e_status_code)ret),i40e_aq_str(hw,hw->aq.asq_last_status));
    #line 5492 
    goto out;
  }
  #line 5496 
  i40e_vsi_config_netdev_tc(vsi,(unsigned char)((int)enabled_tc));
  #line 5497 
  out: 
       #line 5497 
  ;
  #line 5498 
  return ret;
}

#line 5506  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_get_link_speed(struct i40e_vsi *vsi)
{
  #line 5508 
  struct i40e_pf *pf = vsi->back;
  #line 5510 
  switch ((unsigned int)pf->hw.phy.link_info.link_speed) {
    #line 5511 
    case (unsigned int)16: 
                           #line 5511 
    ;
    #line 5512 
    return 40000;
    #line 5513 
    case (unsigned int)64: 
                           #line 5513 
    ;
    #line 5514 
    return 25000;
    #line 5515 
    case (unsigned int)32: 
                           #line 5515 
    ;
    #line 5516 
    return 20000;
    #line 5517 
    case (unsigned int)8: 
                          #line 5517 
    ;
    #line 5518 
    return 10000;
    #line 5519 
    case (unsigned int)4: 
                          #line 5519 
    ;
    #line 5520 
    return 1000;
    #line 5521 
    default: 
             #line 5521 
    ;
    #line 5522 
    return -22;
  }
}

#line 5534  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_set_bw_limit(struct i40e_vsi *vsi, u16 seid, u64 max_tx_rate)
{
  #line 5536 
  struct i40e_pf *pf = vsi->back;
  #line 5537 
  u64 credits = 0ULL;
  #line 5538 
  int speed = 0;
  #line 5539 
  int ret = 0;
  #line 5541 
  speed = i40e_get_link_speed(vsi);
  #line 5542 
  if ((unsigned long long)speed < max_tx_rate) {
    #line 5543 
    _dev_err(& (pf->pdev)->dev,(char *)"Invalid max tx rate %llu specified for VSI seid %d.",max_tx_rate,(int)seid);
    #line 5546 
    return -22;
  }
  #line 5548 
  if (max_tx_rate + 18446744073709551615ULL <= 48ULL) {
    #line 5549 
    _dev_warn(& (pf->pdev)->dev,(char *)"Setting max tx rate to minimum usable value of 50Mbps.\n");
    #line 5551 
    max_tx_rate = 50ULL;
  }
  #line 5555 
  credits = max_tx_rate;
  {
    #line 5556 
    uint32_t __rem;
    #line 5556 
    uint32_t __base = 50U;
    #line 5556 
    __rem = (unsigned int)(credits % (unsigned long long)__base);
    #line 5556 
    credits /= (unsigned long long)__base;
    #line 5556 
    uint32_t tmp = __rem;
  }
  #line 5557 
  ret = (int)i40e_aq_config_vsi_bw_limit(& pf->hw,(unsigned short)((int)seid),
                                    (unsigned short)((int)((unsigned short)credits)),
                                    (unsigned char)4,
                                    (struct i40e_asq_cmd_details *)0);
  #line 5559 
  if (ret != 0) {
    #line 5560 
    ;
    #line 5560 
    ;
    #line 5560 
    ;
    #line 5560 
    _dev_err(& (pf->pdev)->dev,(char *)"Failed set tx rate (%llu Mbps) for vsi->seid %u, err %s aq_err %s\n",max_tx_rate,(int)seid,i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
  }
  #line 5564 
  return ret;
}

#line 5573  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_remove_queue_channels(struct i40e_vsi *vsi)
{
  #line 5591 
  void *__mptr;
  #line 5591 
  void *__mptr_0;
  #line 5575 
  enum i40e_admin_queue_err last_aq_status;
  #line 5576 
  struct i40e_cloud_filter *cfilter;
  #line 5577 
  struct i40e_channel *ch;
  #line 5577 
  struct i40e_channel *ch_tmp;
  #line 5579 
  struct hlist_node *node;
  #line 5580 
  int ret;
  #line 5580 
  int i;
  #line 5578 
  struct i40e_pf *pf = vsi->back;
  #line 5585 
  vsi->current_rss_size = (unsigned short)0U;
  #line 5588 
  if (list_empty(& vsi->ch_list) != 0) 
                                       #line 5589 
                                       return;
  #line 5591 
  __mptr = (void *)vsi->ch_list.next;
  #line 5591 
  ch = ((struct i40e_channel *)__mptr);
  #line 5591 
  __mptr_0 = (void *)ch->list.next;
  #line 5592 
  ch_tmp = ((struct i40e_channel *)__mptr_0);
  #line 5591 
  while (& ch->list != & vsi->ch_list) {
    #line 5591 
    void *__mptr_1;
    {
      #line 5621 
      void *__mptr_2;
      #line 5621 
      struct i40e_cloud_filter *tmp_4;
      #line 5592 
      struct i40e_vsi *p_vsi;
      #line 5594 
      list_del(& ch->list);
      #line 5595 
      p_vsi = ch->parent_vsi;
      #line 5596 
      if (p_vsi == (struct i40e_vsi *)0 || ! ch->initialized) {
        #line 5597 
        kfree((void *)ch);
        #line 5598 
        goto __Cont;
      }
      #line 5601 
      i = 0;
      #line 5601 
      while ((int)ch->num_queue_pairs > i) {
        {
          #line 5602 
          struct i40e_ring *tx_ring;
          #line 5602 
          struct i40e_ring *rx_ring;
          #line 5603 
          u16 pf_q;
          #line 5605 
          pf_q = (unsigned short)((int)ch->base_queue + (int)((unsigned short)i));
          #line 5606 
          tx_ring = *(vsi->tx_rings + (unsigned long)pf_q);
          #line 5607 
          tx_ring->ch = (struct i40e_channel *)0;
          #line 5609 
          rx_ring = *(vsi->rx_rings + (unsigned long)pf_q);
          #line 5610 
          rx_ring->ch = (struct i40e_channel *)0;
        }
        #line 5601 
        i ++;
      }
      #line 5614 
      ret = i40e_set_bw_limit(vsi,(unsigned short)((int)ch->seid),0ULL);
      #line 5615 
      if (ret != 0) 
                    #line 5616 
                    _dev_info(& ((vsi->back)->pdev)->dev,(char *)"Failed to reset tx rate for ch->seid %u\n",(int)ch->seid);
      {
        #line 5621 
        struct hlist_node *____ptr = pf->cloud_filter_list.first;
        #line 5621 
        if (____ptr != (struct hlist_node *)0) {
          #line 5621 
          __mptr_2 = (void *)____ptr;
          #line 5621 
          tmp_4 = ((struct i40e_cloud_filter *)__mptr_2);
        }
        else 
             #line 5621 
             tmp_4 = (struct i40e_cloud_filter *)0;
        }
      #line 5621 
      cfilter = tmp_4;
      #line 5621 
      while (1) {
        #line 5621 
        struct i40e_cloud_filter *tmp_7;
        #line 5621 
        void *__mptr_3;
        #line 5621 
        if (cfilter != (struct i40e_cloud_filter *)0) {
          #line 5621 
          node = cfilter->cloud_node.next;
          #line 5621 
          if (! (1 != 0)) 
                          #line 5621 
                          break;
        }
        else 
             #line 5621 
             break;
        #line 5623 
        if ((int)cfilter->seid != (int)ch->seid) 
                                                 #line 5624 
                                                 goto __Cont_0;
        #line 5626 
        hash_del(& cfilter->cloud_node);
        #line 5627 
        if ((unsigned int)cfilter->dst_port != 0U) 
                                                   #line 5628 
                                                   ret = i40e_add_del_cloud_filter_big_buf(vsi,cfilter,(_Bool)0); else 
                                                                    #line 5632 
                                                                    ret = i40e_add_del_cloud_filter(vsi,cfilter,(_Bool)0);
        #line 5634 
        last_aq_status = pf->hw.aq.asq_last_status;
        #line 5635 
        if (ret != 0) {
          #line 5636 
          ;
          #line 5636 
          _dev_info(& (pf->pdev)->dev,(char *)"Failed to delete cloud filter, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,last_aq_status));
        }
        #line 5640 
        kfree((void *)cfilter);
        #line 5621 
        __Cont_0: { /* sequence */
                    {
                      #line 5621 
                      struct hlist_node *____ptr_0 = node;
                      #line 5621 
                      if (____ptr_0 != (struct hlist_node *)0) {
                        #line 5621 
                        __mptr_3 = (void *)____ptr_0;
                        #line 5621 
                        tmp_7 = ((struct i40e_cloud_filter *)__mptr_3);
                      }
                      else 
                           #line 5621 
                           tmp_7 = (struct i40e_cloud_filter *)0;
                      }
                    #line 5621 
                    cfilter = tmp_7;
                  }
      }
      #line 5644 
      ret = (int)i40e_aq_delete_element(& (vsi->back)->hw,
                                (unsigned short)((int)ch->seid),
                                (struct i40e_asq_cmd_details *)0);
      #line 5646 
      if (ret != 0) 
                    #line 5647 
                    _dev_err(& ((vsi->back)->pdev)->dev,(char *)"unable to remove channel (%d) for parent VSI(%d)\n",(int)ch->seid,(int)p_vsi->seid);
      #line 5650 
      kfree((void *)ch);
    }
    #line 5591 
    __Cont: 
            #line 5591 
    ch = ch_tmp;
    #line 5591 
    __mptr_1 = (void *)ch_tmp->list.next;
    #line 5591 
    ch_tmp = ((struct i40e_channel *)__mptr_1);
  }
  #line 5652 
  INIT_LIST_HEAD(& vsi->ch_list);
  #line 5653 
  return;
}

#line 5661  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static bool i40e_is_any_channel(struct i40e_vsi *vsi)
{
  #line 5665 
  void *__mptr;
  #line 5665 
  void *__mptr_0;
  #line 5663 
  struct i40e_channel *ch;
  #line 5663 
  struct i40e_channel *ch_tmp;
  #line 5665 
  __mptr = (void *)vsi->ch_list.next;
  #line 5665 
  ch = ((struct i40e_channel *)__mptr);
  #line 5665 
  __mptr_0 = (void *)ch->list.next;
  #line 5666 
  ch_tmp = ((struct i40e_channel *)__mptr_0);
  #line 5665 
  while (& ch->list != & vsi->ch_list) {
    #line 5665 
    void *__mptr_1;
    #line 5666 
    if ((int)ch->initialized != 0) 
                                   #line 5667 
                                   return (_Bool)1;
    #line 5665 
    ch = ch_tmp;
    #line 5665 
    __mptr_1 = (void *)ch_tmp->list.next;
    #line 5665 
    ch_tmp = ((struct i40e_channel *)__mptr_1);
  }
  #line 5670 
  return (_Bool)0;
}

#line 5680  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_get_max_queues_for_channel(struct i40e_vsi *vsi)
{
  #line 5685 
  void *__mptr;
  #line 5685 
  void *__mptr_0;
  #line 5682 
  struct i40e_channel *ch;
  #line 5682 
  struct i40e_channel *ch_tmp;
  #line 5683 
  int max = 0;
  #line 5685 
  __mptr = (void *)vsi->ch_list.next;
  #line 5685 
  ch = ((struct i40e_channel *)__mptr);
  #line 5685 
  __mptr_0 = (void *)ch->list.next;
  #line 5686 
  ch_tmp = ((struct i40e_channel *)__mptr_0);
  #line 5685 
  while (& ch->list != & vsi->ch_list) {
    #line 5685 
    void *__mptr_1;
    #line 5686 
    if (! ch->initialized) 
                           #line 5687 
                           goto __Cont;
    #line 5688 
    if ((int)ch->num_queue_pairs > max) 
                                        #line 5689 
                                        max = (int)ch->num_queue_pairs;
    #line 5685 
    __Cont: 
            #line 5685 
    ch = ch_tmp;
    #line 5685 
    __mptr_1 = (void *)ch_tmp->list.next;
    #line 5685 
    ch_tmp = ((struct i40e_channel *)__mptr_1);
  }
  #line 5692 
  return max;
}

#line 5706  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_validate_num_queues(struct i40e_pf *pf, int num_queues, struct i40e_vsi *vsi, bool *reconfig_rss)
{
  #line 5709 
  int max_ch_queues;
  #line 5711 
  if (reconfig_rss == (bool *)0) 
                                 #line 5712 
                                 return -22;
  #line 5714 
  *reconfig_rss = (_Bool)0;
  #line 5715 
  if ((unsigned int)vsi->current_rss_size != 0U) 
    #line 5716 
    if ((int)vsi->current_rss_size < num_queues) {
      {
        #line 5717 
        bool branch;
        #line 5717 
        struct _ddebug __UNIQUE_ID_ddebug600 = {.modname = (char *)"i40e", .function = (char *)"i40e_validate_num_queues", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Error: num_queues (%d) > vsi\'s current_size(%d)\n", .lineno = (unsigned int)5717U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 5717 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug600.key.dd_key_false.key,(_Bool)0);
        #line 5717 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 5717 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug600,& (pf->pdev)->dev,(char *)"Error: num_queues (%d) > vsi\'s current_size(%d)\n",num_queues,(int)vsi->current_rss_size);
      }
      #line 5720 
      return -22;
    }
    else 
      #line 5721 
      if ((int)vsi->current_rss_size > num_queues) {
        #line 5722 
        if (! is_power_of_2((unsigned long)num_queues)) {
          {
            #line 5723 
            bool branch_0;
            #line 5723 
            struct _ddebug __UNIQUE_ID_ddebug601 = {.modname = (char *)"i40e", .function = (char *)"i40e_validate_num_queues", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Error: num_queues (%d) < vsi\'s current_size(%d), but not power of 2\n", .lineno = (unsigned int)5723U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
            #line 5723 
            branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug601.key.dd_key_false.key,(_Bool)0);
            #line 5723 
            if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                          #line 5723 
                                                          __dynamic_dev_dbg(& __UNIQUE_ID_ddebug601,& (pf->pdev)->dev,(char *)"Error: num_queues (%d) < vsi\'s current_size(%d), but not power of 2\n",num_queues,(int)vsi->current_rss_size);
          }
          #line 5726 
          return -22;
        }
      }
  #line 5730 
  if (! is_power_of_2((unsigned long)num_queues)) {
    #line 5736 
    max_ch_queues = i40e_get_max_queues_for_channel(vsi);
    #line 5737 
    if (num_queues < max_ch_queues) {
      {
        #line 5738 
        bool branch_1;
        #line 5738 
        struct _ddebug __UNIQUE_ID_ddebug602 = {.modname = (char *)"i40e", .function = (char *)"i40e_validate_num_queues", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Error: num_queues (%d) < max queues configured for channel(%d)\n", .lineno = (unsigned int)5738U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 5738 
        branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug602.key.dd_key_false.key,(_Bool)0);
        #line 5738 
        if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                      #line 5738 
                                                      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug602,& (pf->pdev)->dev,(char *)"Error: num_queues (%d) < max queues configured for channel(%d)\n",num_queues,max_ch_queues);
      }
      #line 5741 
      return -22;
    }
    #line 5743 
    *reconfig_rss = (_Bool)1;
  }
  #line 5746 
  return 0;
}

#line 5756  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_reconfig_rss(struct i40e_vsi *vsi, u16 rss_size)
{
  #line 5771 
  int __UNIQUE_ID___x603;
  #line 5771 
  int tmp;
  #line 5759 
  u8 seed[52U];
  #line 5761 
  int local_rss_size;
  #line 5762 
  u8 *lut;
  #line 5763 
  int ret;
  #line 5758 
  struct i40e_pf *pf = vsi->back;
  #line 5760 
  struct i40e_hw *hw = & pf->hw;
  #line 5765 
  if ((unsigned int)vsi->rss_size == 0U) 
                                         #line 5766 
                                         return -22;
  #line 5768 
  if ((int)vsi->rss_size < (int)rss_size) 
                                          #line 5769 
                                          return -22;
  {
    #line 5771 
    __UNIQUE_ID___x603 = (int)vsi->rss_size;
    #line 5771 
    int __UNIQUE_ID___y604 = (int)rss_size;
    #line 5771 
    if (__UNIQUE_ID___x603 < __UNIQUE_ID___y604) 
                                                 #line 5771 
                                                 tmp = __UNIQUE_ID___x603; else 
                                                                    #line 5771 
                                                                    tmp = __UNIQUE_ID___y604;
    }
  #line 5771 
  local_rss_size = tmp;
  #line 5772 
  lut = (u8 *)kzalloc_1((unsigned long)vsi->rss_table_size,3264U);
  #line 5773 
  if (lut == (u8 *)0U) 
                       #line 5774 
                       return -12;
  #line 5777 
  i40e_fill_rss_lut(pf,lut,(unsigned short)((int)vsi->rss_table_size),(unsigned short)((int)((unsigned short)local_rss_size)));
  #line 5782 
  if (vsi->rss_hkey_user != (u8 *)0U) 
                                      #line 5783 
                                      memcpy((void *)(& seed),(void *)vsi->rss_hkey_user,52UL); else 
                                                                    #line 5785 
                                                                    netdev_rss_key_fill((void *)(& seed),52UL);
  #line 5787 
  ret = i40e_config_rss(vsi,(u8 *)(& seed),lut,(unsigned short)((int)vsi->rss_table_size));
  #line 5788 
  if (ret != 0) {
    #line 5789 
    ;
    #line 5789 
    _dev_info(& (pf->pdev)->dev,(char *)"Cannot set RSS lut, err %s aq_err %s\n",i40e_stat_str(hw,(enum i40e_status_code)ret),i40e_aq_str(hw,hw->aq.asq_last_status));
    #line 5793 
    kfree((void *)lut);
    #line 5794 
    return ret;
  }
  #line 5796 
  kfree((void *)lut);
  #line 5799 
  if ((unsigned int)vsi->orig_rss_size == 0U) 
                                              #line 5800 
                                              vsi->orig_rss_size = vsi->rss_size;
  #line 5801 
  vsi->current_rss_size = (unsigned short)local_rss_size;
  #line 5803 
  return ret;
}

#line 5815  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_channel_setup_queue_map(struct i40e_pf *pf, struct i40e_vsi_context *ctxt, struct i40e_channel *ch)
{
  #line 5826 
  int __UNIQUE_ID___x605;
  #line 5826 
  int tmp;
  #line 5819 
  u16 qcount;
  #line 5819 
  u16 qmap;
  #line 5821 
  int pow;
  #line 5819 
  u16 sections = (unsigned short)0U;
  #line 5820 
  u8 offset = (unsigned char)0U;
  #line 5823 
  sections = (unsigned short)64U;
  #line 5824 
  sections = (unsigned short)((unsigned int)sections | 512U);
  {
    #line 5826 
    __UNIQUE_ID___x605 = (int)ch->num_queue_pairs;
    #line 5826 
    int __UNIQUE_ID___y606 = (int)pf->num_lan_msix;
    #line 5826 
    if (__UNIQUE_ID___x605 < __UNIQUE_ID___y606) 
                                                 #line 5826 
                                                 tmp = __UNIQUE_ID___x605; else 
                                                                    #line 5826 
                                                                    tmp = __UNIQUE_ID___y606;
    }
  #line 5826 
  qcount = (unsigned short)tmp;
  #line 5827 
  ch->num_queue_pairs = qcount;
  #line 5830 
  if (0 != 0) {
    #line 5830 
    int tmp_40;
    #line 5830 
    int tmp_8;
    #line 5830 
    int tmp_9;
    #line 5830 
    int tmp_41;
    #line 5830 
    int tmp_42;
    #line 5830 
    int tmp_10;
    #line 5830 
    int tmp_11;
    #line 5830 
    int tmp_43;
    #line 5830 
    int tmp_44;
    #line 5830 
    int tmp_12;
    #line 5830 
    int tmp_13;
    #line 5830 
    int tmp_45;
    #line 5830 
    int tmp_46;
    #line 5830 
    int tmp_14;
    #line 5830 
    int tmp_15;
    #line 5830 
    int tmp_47;
    #line 5830 
    int tmp_48;
    #line 5830 
    int tmp_16;
    #line 5830 
    int tmp_17;
    #line 5830 
    int tmp_49;
    #line 5830 
    int tmp_50;
    #line 5830 
    int tmp_18;
    #line 5830 
    int tmp_19;
    #line 5830 
    int tmp_51;
    #line 5830 
    int tmp_52;
    #line 5830 
    int tmp_20;
    #line 5830 
    int tmp_21;
    #line 5830 
    int tmp_53;
    #line 5830 
    int tmp_54;
    #line 5830 
    int tmp_22;
    #line 5830 
    int tmp_23;
    #line 5830 
    int tmp_55;
    #line 5830 
    int tmp_56;
    #line 5830 
    int tmp_24;
    #line 5830 
    int tmp_25;
    #line 5830 
    int tmp_57;
    #line 5830 
    int tmp_58;
    #line 5830 
    int tmp_26;
    #line 5830 
    int tmp_27;
    #line 5830 
    int tmp_59;
    #line 5830 
    int tmp_60;
    #line 5830 
    int tmp_28;
    #line 5830 
    int tmp_29;
    #line 5830 
    int tmp_61;
    #line 5830 
    int tmp_62;
    #line 5830 
    int tmp_30;
    #line 5830 
    int tmp_31;
    #line 5830 
    int tmp_32;
    #line 5830 
    int tmp_1;
    #line 5830 
    int tmp_33;
    #line 5830 
    int tmp_34;
    #line 5830 
    int tmp_2;
    #line 5830 
    int tmp_3;
    #line 5830 
    int tmp_35;
    #line 5830 
    int tmp_36;
    #line 5830 
    int tmp_4;
    #line 5830 
    int tmp_5;
    #line 5830 
    int tmp_37;
    #line 5830 
    int tmp_38;
    #line 5830 
    int tmp_6;
    #line 5830 
    int tmp_7;
    #line 5830 
    int tmp_39;
    #line 5830 
    int tmp_63;
    #line 5830 
    if ((unsigned int)qcount > 1U) {
      #line 5830 
      if (((unsigned long long)qcount & 9223372036854775808ULL) == 0ULL) {
        #line 5830 
        if (((unsigned long long)qcount & 4611686018427387904ULL) == 0ULL) {
          #line 5830 
          if (((unsigned long long)qcount & 2305843009213693952ULL) == 0ULL) {
            #line 5830 
            if (((unsigned long long)qcount & 1152921504606846976ULL) == 0ULL) {
              #line 5830 
              if (((unsigned long long)qcount & 576460752303423488ULL) == 0ULL) {
                #line 5830 
                if (((unsigned long long)qcount & 288230376151711744ULL) == 0ULL) {
                  #line 5830 
                  if (((unsigned long long)qcount & 144115188075855872ULL) == 0ULL) {
                    #line 5830 
                    if (((unsigned long long)qcount & 72057594037927936ULL) == 0ULL) {
                      #line 5830 
                      if (((unsigned long long)qcount & 36028797018963968ULL) == 0ULL) {
                        #line 5830 
                        if (((unsigned long long)qcount & 18014398509481984ULL) == 0ULL) {
                          #line 5830 
                          if (((unsigned long long)qcount & 9007199254740992ULL) == 0ULL) {
                            #line 5830 
                            if (((unsigned long long)qcount & 4503599627370496ULL) == 0ULL) {
                              #line 5830 
                              if (((unsigned long long)qcount & 2251799813685248ULL) == 0ULL) {
                                #line 5830 
                                if (((unsigned long long)qcount & 1125899906842624ULL) == 0ULL) {
                                  #line 5830 
                                  if (((unsigned long long)qcount & 562949953421312ULL) == 0ULL) {
                                    #line 5830 
                                    if (((unsigned long long)qcount & 281474976710656ULL) == 0ULL) {
                                      #line 5830 
                                      if (((unsigned long long)qcount & 140737488355328ULL) == 0ULL) {
                                        #line 5830 
                                        if (((unsigned long long)qcount & 70368744177664ULL) == 0ULL) {
                                          #line 5830 
                                          if (((unsigned long long)qcount & 35184372088832ULL) == 0ULL) {
                                            #line 5830 
                                            if (((unsigned long long)qcount & 17592186044416ULL) == 0ULL) {
                                              #line 5830 
                                              if (((unsigned long long)qcount & 8796093022208ULL) == 0ULL) {
                                                #line 5830 
                                                if (((unsigned long long)qcount & 4398046511104ULL) == 0ULL) {
                                                  #line 5830 
                                                  if (((unsigned long long)qcount & 2199023255552ULL) == 0ULL) {
                                                    #line 5830 
                                                    if (((unsigned long long)qcount & 1099511627776ULL) == 0ULL) {
                                                      #line 5830 
                                                      if (((unsigned long long)qcount & 549755813888ULL) == 0ULL) {
                                                        #line 5830 
                                                        if (((unsigned long long)qcount & 274877906944ULL) == 0ULL) {
                                                          #line 5830 
                                                          if (((unsigned long long)qcount & 137438953472ULL) == 0ULL) {
                                                            #line 5830 
                                                            if (((unsigned long long)qcount & 68719476736ULL) == 0ULL) {
                                                              #line 5830 
                                                              if (((unsigned long long)qcount & 34359738368ULL) == 0ULL) {
                                                                #line 5830 
                                                                if (((unsigned long long)qcount & 17179869184ULL) == 0ULL) {
                                                                  #line 5830 
                                                                  if (
                                                                    ((unsigned long long)qcount & 8589934592ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 4294967296ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 2147483648ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 1073741824ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 536870912ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 268435456ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 134217728ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 67108864ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 33554432ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 16777216ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 8388608ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 4194304ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 2097152ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 1048576ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 524288ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 262144ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 131072ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 65536ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 32768ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 16384ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 8192ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 4096ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 2048ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 1024ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 512ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 256ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 128ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 64ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 32ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 16ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 8ULL) == 0ULL) {
                                                                    #line 5830 
                                                                    if (
                                                                    ((unsigned long long)qcount & 4ULL) != 0ULL) 
                                                                    #line 5830 
                                                                    tmp_1 = 2; else 
                                                                    #line 5830 
                                                                    tmp_1 = 1;
                                                                    #line 5830 
                                                                    tmp_2 = tmp_1;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_2 = 3;
                                                                    #line 5830 
                                                                    tmp_3 = tmp_2;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_3 = 4;
                                                                    #line 5830 
                                                                    tmp_4 = tmp_3;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_4 = 5;
                                                                    #line 5830 
                                                                    tmp_5 = tmp_4;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_5 = 6;
                                                                    #line 5830 
                                                                    tmp_6 = tmp_5;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_6 = 7;
                                                                    #line 5830 
                                                                    tmp_7 = tmp_6;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_7 = 8;
                                                                    #line 5830 
                                                                    tmp_8 = tmp_7;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_8 = 9;
                                                                    #line 5830 
                                                                    tmp_9 = tmp_8;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_9 = 10;
                                                                    #line 5830 
                                                                    tmp_10 = tmp_9;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_10 = 11;
                                                                    #line 5830 
                                                                    tmp_11 = tmp_10;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_11 = 12;
                                                                    #line 5830 
                                                                    tmp_12 = tmp_11;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_12 = 13;
                                                                    #line 5830 
                                                                    tmp_13 = tmp_12;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_13 = 14;
                                                                    #line 5830 
                                                                    tmp_14 = tmp_13;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_14 = 15;
                                                                    #line 5830 
                                                                    tmp_15 = tmp_14;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_15 = 16;
                                                                    #line 5830 
                                                                    tmp_16 = tmp_15;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_16 = 17;
                                                                    #line 5830 
                                                                    tmp_17 = tmp_16;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_17 = 18;
                                                                    #line 5830 
                                                                    tmp_18 = tmp_17;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_18 = 19;
                                                                    #line 5830 
                                                                    tmp_19 = tmp_18;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_19 = 20;
                                                                    #line 5830 
                                                                    tmp_20 = tmp_19;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_20 = 21;
                                                                    #line 5830 
                                                                    tmp_21 = tmp_20;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_21 = 22;
                                                                    #line 5830 
                                                                    tmp_22 = tmp_21;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_22 = 23;
                                                                    #line 5830 
                                                                    tmp_23 = tmp_22;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_23 = 24;
                                                                    #line 5830 
                                                                    tmp_24 = tmp_23;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_24 = 25;
                                                                    #line 5830 
                                                                    tmp_25 = tmp_24;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_25 = 26;
                                                                    #line 5830 
                                                                    tmp_26 = tmp_25;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_26 = 27;
                                                                    #line 5830 
                                                                    tmp_27 = tmp_26;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_27 = 28;
                                                                    #line 5830 
                                                                    tmp_28 = tmp_27;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_28 = 29;
                                                                    #line 5830 
                                                                    tmp_29 = tmp_28;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_29 = 30;
                                                                    #line 5830 
                                                                    tmp_30 = tmp_29;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_30 = 31;
                                                                    #line 5830 
                                                                    tmp_31 = tmp_30;
                                                                    }
                                                                    else 
                                                                    #line 5830 
                                                                    tmp_31 = 32;
                                                                    #line 5830 
                                                                    tmp_32 = tmp_31;
                                                                  }
                                                                  else 
                                                                    #line 5830 
                                                                    tmp_32 = 33;
                                                                  #line 5830 
                                                                  tmp_33 = tmp_32;
                                                                }
                                                                else 
                                                                  #line 5830 
                                                                  tmp_33 = 34;
                                                                #line 5830 
                                                                tmp_34 = tmp_33;
                                                              }
                                                              else 
                                                                   #line 5830 
                                                                   tmp_34 = 35;
                                                              #line 5830 
                                                              tmp_35 = tmp_34;
                                                            }
                                                            else 
                                                                 #line 5830 
                                                                 tmp_35 = 36;
                                                            #line 5830 
                                                            tmp_36 = tmp_35;
                                                          }
                                                          else 
                                                               #line 5830 
                                                               tmp_36 = 37;
                                                          #line 5830 
                                                          tmp_37 = tmp_36;
                                                        }
                                                        else 
                                                             #line 5830 
                                                             tmp_37 = 38;
                                                        #line 5830 
                                                        tmp_38 = tmp_37;
                                                      }
                                                      else 
                                                           #line 5830 
                                                           tmp_38 = 39;
                                                      #line 5830 
                                                      tmp_39 = tmp_38;
                                                    }
                                                    else 
                                                         #line 5830 
                                                         tmp_39 = 40;
                                                    #line 5830 
                                                    tmp_40 = tmp_39;
                                                  }
                                                  else 
                                                       #line 5830 
                                                       tmp_40 = 41;
                                                  #line 5830 
                                                  tmp_41 = tmp_40;
                                                }
                                                else 
                                                     #line 5830 
                                                     tmp_41 = 42;
                                                #line 5830 
                                                tmp_42 = tmp_41;
                                              }
                                              else 
                                                   #line 5830 
                                                   tmp_42 = 43;
                                              #line 5830 
                                              tmp_43 = tmp_42;
                                            }
                                            else 
                                                 #line 5830 
                                                 tmp_43 = 44;
                                            #line 5830 
                                            tmp_44 = tmp_43;
                                          }
                                          else 
                                               #line 5830 
                                               tmp_44 = 45;
                                          #line 5830 
                                          tmp_45 = tmp_44;
                                        }
                                        else 
                                             #line 5830 
                                             tmp_45 = 46;
                                        #line 5830 
                                        tmp_46 = tmp_45;
                                      }
                                      else 
                                           #line 5830 
                                           tmp_46 = 47;
                                      #line 5830 
                                      tmp_47 = tmp_46;
                                    }
                                    else 
                                         #line 5830 
                                         tmp_47 = 48;
                                    #line 5830 
                                    tmp_48 = tmp_47;
                                  }
                                  else 
                                       #line 5830 
                                       tmp_48 = 49;
                                  #line 5830 
                                  tmp_49 = tmp_48;
                                }
                                else 
                                     #line 5830 
                                     tmp_49 = 50;
                                #line 5830 
                                tmp_50 = tmp_49;
                              }
                              else 
                                   #line 5830 
                                   tmp_50 = 51;
                              #line 5830 
                              tmp_51 = tmp_50;
                            }
                            else 
                                 #line 5830 
                                 tmp_51 = 52;
                            #line 5830 
                            tmp_52 = tmp_51;
                          }
                          else 
                               #line 5830 
                               tmp_52 = 53;
                          #line 5830 
                          tmp_53 = tmp_52;
                        }
                        else 
                             #line 5830 
                             tmp_53 = 54;
                        #line 5830 
                        tmp_54 = tmp_53;
                      }
                      else 
                           #line 5830 
                           tmp_54 = 55;
                      #line 5830 
                      tmp_55 = tmp_54;
                    }
                    else 
                         #line 5830 
                         tmp_55 = 56;
                    #line 5830 
                    tmp_56 = tmp_55;
                  }
                  else 
                       #line 5830 
                       tmp_56 = 57;
                  #line 5830 
                  tmp_57 = tmp_56;
                }
                else 
                     #line 5830 
                     tmp_57 = 58;
                #line 5830 
                tmp_58 = tmp_57;
              }
              else 
                   #line 5830 
                   tmp_58 = 59;
              #line 5830 
              tmp_59 = tmp_58;
            }
            else 
                 #line 5830 
                 tmp_59 = 60;
            #line 5830 
            tmp_60 = tmp_59;
          }
          else 
               #line 5830 
               tmp_60 = 61;
          #line 5830 
          tmp_61 = tmp_60;
        }
        else 
             #line 5830 
             tmp_61 = 62;
        #line 5830 
        tmp_62 = tmp_61;
      }
      else 
           #line 5830 
           tmp_62 = 63;
      #line 5830 
      tmp_63 = tmp_62;
    }
    else 
         #line 5830 
         tmp_63 = 0;
    #line 5830 
    pow = tmp_63;
  }
  else 
       #line 5830 
       pow = __ilog2_u32((unsigned int)qcount);
  #line 5831 
  if (! is_power_of_2((unsigned long)qcount)) 
                                              #line 5832 
                                              pow ++;
  #line 5834 
  qmap = (unsigned short)((int)offset | (pow << 9));
  #line 5838 
  ctxt->info.tc_mapping[0] = qmap;
  #line 5840 
  ctxt->info.up_enable_bits = (unsigned char)1U;
  #line 5841 
  ctxt->info.mapping_flags = ctxt->info.mapping_flags;
  #line 5842 
  ctxt->info.queue_mapping[0] = ch->base_queue;
  #line 5843 
  ctxt->info.valid_sections = (unsigned short)((int)ctxt->info.valid_sections | (int)sections);
  #line 5844 
  return;
}

#line 5854  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_add_channel(struct i40e_pf *pf, u16 uplink_seid, struct i40e_channel *ch)
{
  #line 5858 
  struct i40e_vsi_context ctxt;
  #line 5860 
  int ret;
  #line 5900 
  int tmp_3;
  #line 5857 
  struct i40e_hw *hw = & pf->hw;
  #line 5859 
  u8 enabled_tc = (unsigned char)1U;
  #line 5862 
  if ((unsigned int)ch->type != 2U) {
    #line 5863 
    _dev_info(& (pf->pdev)->dev,(char *)"add new vsi failed, ch->type %d\n",(int)ch->type);
    #line 5865 
    return -22;
  }
  #line 5868 
  memset((void *)(& ctxt),0,144UL);
  #line 5869 
  ctxt.pf_num = hw->pf_id;
  #line 5870 
  ctxt.vf_num = (unsigned char)0U;
  #line 5871 
  ctxt.uplink_seid = uplink_seid;
  #line 5872 
  ctxt.connection_type = (unsigned char)1U;
  #line 5873 
  if ((unsigned int)ch->type == 2U) 
                                    #line 5874 
                                    ctxt.flags = (unsigned short)1U;
  #line 5876 
  if (((unsigned long)pf->flags & 4096UL) != 0UL) {
    #line 5877 
    ctxt.info.valid_sections = (unsigned short)((unsigned int)ctxt.info.valid_sections | 1U);
    #line 5879 
    ctxt.info.switch_id = (unsigned short)8192U;
  }
  #line 5884 
  i40e_channel_setup_queue_map(pf,& ctxt,ch);
  #line 5887 
  ret = (int)i40e_aq_add_vsi(hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  #line 5888 
  if (ret != 0) {
    #line 5889 
    ;
    #line 5889 
    _dev_info(& (pf->pdev)->dev,(char *)"add new vsi failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 5894 
    return -2;
  }
  #line 5900 
  if (i40e_is_channel_macvlan(ch)) 
                                   #line 5900 
                                   tmp_3 = 0;
  else 
    #line 5900 
    if ((unsigned int)enabled_tc != 0U) 
                                        #line 5900 
                                        tmp_3 = 1; else 
                                                        #line 5900 
                                                        tmp_3 = 0;
  #line 5900 
  ch->enabled_tc = (unsigned char)tmp_3;
  #line 5901 
  ch->seid = ctxt.seid;
  #line 5902 
  ch->vsi_number = ctxt.vsi_number;
  #line 5903 
  ch->stat_counter_idx = ctxt.info.stat_counter_idx;
  #line 5909 
  ch->info.mapping_flags = ctxt.info.mapping_flags;
  #line 5910 
  memcpy((void *)(& ch->info.queue_mapping),(void *)(& ctxt.info.queue_mapping),32UL);
  #line 5912 
  memcpy((void *)(& ch->info.tc_mapping),(void *)(& ctxt.info.tc_mapping),16UL);
  #line 5915 
  return 0;
}

#line 5918  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_channel_config_bw(struct i40e_vsi *vsi, struct i40e_channel *ch, u8 *bw_share)
{
  #line 5921 
  struct i40e_aqc_configure_vsi_tc_bw_data bw_data;
  #line 5922 
  i40e_status ret;
  #line 5923 
  int i;
  #line 5925 
  bw_data.tc_valid_bits = ch->enabled_tc;
  #line 5926 
  i = 0;
  #line 5926 
  while (i <= 7) {
    #line 5927 
    bw_data.tc_bw_credits[i] = *(bw_share + (unsigned long)i);
    #line 5926 
    i ++;
  }
  #line 5929 
  ret = i40e_aq_config_vsi_tc_bw(& (vsi->back)->hw,(unsigned short)((int)ch->seid),& bw_data,(struct i40e_asq_cmd_details *)0);
  #line 5931 
  if (ret != I40E_SUCCESS) {
    #line 5932 
    _dev_info(& ((vsi->back)->pdev)->dev,(char *)"Config VSI BW allocation per TC failed, aq_err: %d for new_vsi->seid %u\n",(unsigned int)(vsi->back)->hw.aq.asq_last_status,(int)ch->seid);
    #line 5935 
    return -22;
  }
  #line 5938 
  i = 0;
  #line 5938 
  while (i <= 7) {
    #line 5939 
    ch->info.qs_handle[i] = bw_data.qs_handles[i];
    #line 5938 
    i ++;
  }
  #line 5941 
  return 0;
}

#line 5953  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_channel_config_tx_ring(struct i40e_pf *pf, struct i40e_vsi *vsi, struct i40e_channel *ch)
{
  #line 5957 
  i40e_status ret;
  #line 5958 
  int i;
  #line 5959 
  u8 bw_share[8U] = {(unsigned char)0U};
  #line 5962 
  i = 0;
  #line 5962 
  while (i <= 7) {
    #line 5963 
    if ((((unsigned long)ch->enabled_tc >> i) & 1UL) != 0UL) 
                                                             #line 5964 
                                                             bw_share[i] = (unsigned char)1U;
    #line 5962 
    i ++;
  }
  #line 5968 
  ret = (enum i40e_status_code)i40e_channel_config_bw(vsi,ch,(u8 *)(& bw_share));
  #line 5969 
  if (ret != I40E_SUCCESS) {
    #line 5970 
    _dev_info(& ((vsi->back)->pdev)->dev,(char *)"Failed configuring TC map %d for channel (seid %u)\n",(int)ch->enabled_tc,(int)ch->seid);
    #line 5973 
    return (int)ret;
  }
  #line 5976 
  i = 0;
  #line 5976 
  while ((int)ch->num_queue_pairs > i) {
    {
      #line 5977 
      struct i40e_ring *tx_ring;
      #line 5977 
      struct i40e_ring *rx_ring;
      #line 5978 
      u16 pf_q;
      #line 5980 
      pf_q = (unsigned short)((int)ch->base_queue + (int)((unsigned short)i));
      #line 5985 
      tx_ring = *(vsi->tx_rings + (unsigned long)pf_q);
      #line 5986 
      tx_ring->ch = ch;
      #line 5989 
      rx_ring = *(vsi->rx_rings + (unsigned long)pf_q);
      #line 5990 
      rx_ring->ch = ch;
    }
    #line 5976 
    i ++;
  }
  #line 5993 
  return 0;
}

#line 6007  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
__inline static int i40e_setup_hw_channel(struct i40e_pf *pf, struct i40e_vsi *vsi, struct i40e_channel *ch, u16 uplink_seid, u8 type)
{
  #line 6012 
  int ret;
  #line 6014 
  ch->initialized = (_Bool)0;
  #line 6015 
  ch->base_queue = vsi->next_base_queue;
  #line 6016 
  ch->type = type;
  #line 6019 
  ret = i40e_add_channel(pf,(unsigned short)((int)uplink_seid),ch);
  #line 6020 
  if (ret != 0) {
    #line 6021 
    _dev_info(& (pf->pdev)->dev,(char *)"failed to add_channel using uplink_seid %u\n",(int)uplink_seid);
    #line 6024 
    return ret;
  }
  #line 6028 
  ch->initialized = (_Bool)1;
  #line 6031 
  ret = i40e_channel_config_tx_ring(pf,vsi,ch);
  #line 6032 
  if (ret != 0) {
    #line 6033 
    _dev_info(& (pf->pdev)->dev,(char *)"failed to configure TX rings for channel %u\n",(int)ch->seid);
    #line 6036 
    return ret;
  }
  #line 6040 
  vsi->next_base_queue = (unsigned short)((int)vsi->next_base_queue + (int)ch->num_queue_pairs);
  {
    #line 6041 
    bool branch;
    #line 6041 
    struct _ddebug __UNIQUE_ID_ddebug607 = {.modname = (char *)"i40e", .function = (char *)"i40e_setup_hw_channel", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Added channel: vsi_seid %u, vsi_number %u, stat_counter_idx %u, num_queue_pairs %u, pf->next_base_queue %d\n", .lineno = (unsigned int)6041U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 6041 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug607.key.dd_key_false.key,(_Bool)0);
    #line 6041 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 6041 
                                                __dynamic_dev_dbg(& __UNIQUE_ID_ddebug607,& (pf->pdev)->dev,(char *)"Added channel: vsi_seid %u, vsi_number %u, stat_counter_idx %u, num_queue_pairs %u, pf->next_base_queue %d\n",(int)ch->seid,(int)ch->vsi_number,(int)ch->stat_counter_idx,(int)ch->num_queue_pairs,(int)vsi->next_base_queue);
  }
  #line 6046 
  return ret;
}

#line 6059  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static bool i40e_setup_channel(struct i40e_pf *pf, struct i40e_vsi *vsi, struct i40e_channel *ch)
{
  #line 6062 
  u8 vsi_type;
  #line 6063 
  u16 seid;
  #line 6064 
  int ret;
  #line 6066 
  if (vsi->type == (unsigned int)I40E_VSI_MAIN) 
                                                #line 6067 
                                                vsi_type = (unsigned char)2U;
  else {
    #line 6069 
    _dev_err(& (pf->pdev)->dev,(char *)"unsupported parent vsi type(%d)\n",(unsigned int)vsi->type);
    #line 6071 
    return (_Bool)0;
  }
  #line 6075 
  seid = (*(pf->vsi + (unsigned long)pf->lan_vsi))->uplink_seid;
  #line 6078 
  ret = i40e_setup_hw_channel(pf,vsi,ch,(unsigned short)((int)seid),(unsigned char)((int)vsi_type));
  #line 6079 
  if (ret != 0) {
    #line 6080 
    _dev_err(& (pf->pdev)->dev,(char *)"failed to setup hw_channel\n");
    #line 6081 
    return (_Bool)0;
  }
  #line 6084 
  return (_Bool)((int)ch->initialized != 0);
}

#line 6094  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_validate_and_set_switch_mode(struct i40e_vsi *vsi)
{
  #line 6096 
  u8 mode;
  #line 6099 
  int ret;
  #line 6097 
  struct i40e_pf *pf = vsi->back;
  #line 6098 
  struct i40e_hw *hw = & pf->hw;
  #line 6101 
  ret = i40e_get_capabilities(pf,(enum i40e_admin_queue_opc)i40e_aqc_opc_list_dev_capabilities);
  #line 6102 
  if (ret != 0) 
                #line 6103 
                return -22;
  #line 6105 
  if (hw->dev_caps.switch_mode != 0U) {
    #line 6109 
    u32 switch_mode = hw->dev_caps.switch_mode & 15U;
    #line 6111 
    if (switch_mode > 5U) {
      #line 6112 
      if (switch_mode == 7U) 
                             #line 6113 
                             return 0;
      #line 6114 
      _dev_err(& (pf->pdev)->dev,(char *)"Invalid switch_mode (%d), only non-tunneled mode for cloud filter is supported\n",hw->dev_caps.switch_mode);
      #line 6117 
      return -22;
    }
  }
  #line 6122 
  mode = (unsigned char)128U;
  #line 6125 
  mode = (unsigned char)((unsigned int)mode | 16U);
  #line 6128 
  mode = (unsigned char)((unsigned int)mode | 2U);
  #line 6131 
  ret = (int)i40e_aq_set_switch_config(hw,
                                (unsigned short)((int)pf->last_sw_conf_flags),
                                (unsigned short)((int)pf->last_sw_conf_valid_flags),
                                (unsigned char)((int)mode),
                                (struct i40e_asq_cmd_details *)0);
  #line 6134 
  if (ret != 0 && hw->aq.asq_last_status != (unsigned int)I40E_AQ_RC_ESRCH) {
    #line 6135 
    ;
    #line 6135 
    _dev_err(& (pf->pdev)->dev,(char *)"couldn\'t set switch config bits, err %s aq_err %s\n",i40e_stat_str(hw,(enum i40e_status_code)ret),i40e_aq_str(hw,hw->aq.asq_last_status));
  }
  #line 6141 
  return ret;
}

#line 6152  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_create_queue_channel(struct i40e_vsi *vsi, struct i40e_channel *ch)
{
  #line 6156 
  bool reconfig_rss;
  #line 6157 
  int err;
  #line 6155 
  struct i40e_pf *pf = vsi->back;
  #line 6159 
  if (ch == (struct i40e_channel *)0) 
                                      #line 6160 
                                      return -22;
  #line 6162 
  if ((unsigned int)ch->num_queue_pairs == 0U) {
    #line 6163 
    _dev_err(& (pf->pdev)->dev,(char *)"Invalid num_queues requested: %d\n",(int)ch->num_queue_pairs);
    #line 6165 
    return -22;
  }
  #line 6169 
  err = i40e_validate_num_queues(pf,(int)ch->num_queue_pairs,vsi,& reconfig_rss);
  #line 6171 
  if (err != 0) {
    #line 6172 
    _dev_info(& (pf->pdev)->dev,(char *)"Failed to validate num_queues (%d)\n",(int)ch->num_queue_pairs);
    #line 6174 
    return -22;
  }
  #line 6180 
  if (((unsigned long)pf->flags & 4096UL) == 0UL) 
                                                  #line 6180 
                                                  goto _LOR;
  else {
    #line 6181 
    if (! i40e_is_any_channel(vsi)) {
      #line 6180 
      _LOR: {
              #line 6182 
              if (! is_power_of_2((unsigned long)vsi->tc_config.tc_info[0].qcount)) {
                {
                  #line 6183 
                  bool branch;
                  #line 6183 
                  struct _ddebug __UNIQUE_ID_ddebug608 = {.modname = (char *)"i40e", .function = (char *)"i40e_create_queue_channel", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Failed to create channel. Override queues (%u) not power of 2\n", .lineno = (unsigned int)6183U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
                  #line 6183 
                  branch = arch_static_branch(& __UNIQUE_ID_ddebug608.key.dd_key_false.key,(_Bool)0);
                  #line 6183 
                  if ((long)((long)((int)branch != 0)) != 0L) 
                                                              #line 6183 
                                                              __dynamic_dev_dbg(& __UNIQUE_ID_ddebug608,& (pf->pdev)->dev,(char *)"Failed to create channel. Override queues (%u) not power of 2\n",(int)vsi->tc_config.tc_info[0].qcount);
                }
                #line 6186 
                return -22;
              }
              #line 6189 
              if (((unsigned long)pf->flags & 4096UL) == 0UL) {
                #line 6190 
                pf->flags |= 4096U;
                #line 6192 
                if (vsi->type == (unsigned int)I40E_VSI_MAIN) 
                  #line 6193 
                  if (((unsigned long)pf->flags & 2097152UL) != 0UL) 
                    #line 6194 
                    i40e_do_reset(pf,8192U,(_Bool)1); else 
                                                           #line 6197 
                                                           i40e_do_reset_safe(pf,8192U);
              }
            }
    }
  }
  #line 6209 
  if ((unsigned int)vsi->cnt_q_avail == 0U || (int)vsi->cnt_q_avail < (int)ch->num_queue_pairs) {
    {
      #line 6210 
      bool branch_0;
      #line 6210 
      struct _ddebug __UNIQUE_ID_ddebug609 = {.modname = (char *)"i40e", .function = (char *)"i40e_create_queue_channel", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Error: cnt_q_avail (%u) less than num_queues %d\n", .lineno = (unsigned int)6210U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 6210 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug609.key.dd_key_false.key,(_Bool)0);
      #line 6210 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 6210 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug609,& (pf->pdev)->dev,(char *)"Error: cnt_q_avail (%u) less than num_queues %d\n",(int)vsi->cnt_q_avail,(int)ch->num_queue_pairs);
    }
    #line 6213 
    return -22;
  }
  #line 6217 
  if ((int)reconfig_rss != 0 && vsi->type == (unsigned int)I40E_VSI_MAIN) {
    #line 6218 
    err = i40e_vsi_reconfig_rss(vsi,(unsigned short)((int)ch->num_queue_pairs));
    #line 6219 
    if (err != 0) {
      #line 6220 
      _dev_info(& (pf->pdev)->dev,(char *)"Error: unable to reconfig rss for num_queues (%u)\n",(int)ch->num_queue_pairs);
      #line 6223 
      return -22;
    }
  }
  #line 6227 
  if (! i40e_setup_channel(pf,vsi,ch)) {
    #line 6228 
    _dev_info(& (pf->pdev)->dev,(char *)"Failed to setup channel\n");
    #line 6229 
    return -22;
  }
  #line 6232 
  _dev_info(& (pf->pdev)->dev,(char *)"Setup channel (id:%u) utilizing num_queues %d\n",(int)ch->seid,(int)ch->num_queue_pairs);
  #line 6237 
  if (ch->max_tx_rate != 0ULL) {
    #line 6238 
    u64 credits = ch->max_tx_rate;
    #line 6240 
    if (i40e_set_bw_limit(vsi,(unsigned short)((int)ch->seid),
                          ch->max_tx_rate) != 0) 
      #line 6241 
      return -22;
    {
      #line 6243 
      uint32_t __rem;
      #line 6243 
      uint32_t __base = 50U;
      #line 6243 
      __rem = (unsigned int)(credits % (unsigned long long)__base);
      #line 6243 
      credits /= (unsigned long long)__base;
      #line 6243 
      uint32_t tmp_5 = __rem;
    }
    {
      #line 6244 
      bool branch_1;
      #line 6244 
      struct _ddebug __UNIQUE_ID_ddebug610 = {.modname = (char *)"i40e", .function = (char *)"i40e_create_queue_channel", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Set tx rate of %llu Mbps (count of 50Mbps %llu) for vsi->seid %u\n", .lineno = (unsigned int)6244U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 6244 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug610.key.dd_key_false.key,(_Bool)0);
      #line 6244 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 6244 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug610,& (pf->pdev)->dev,(char *)"Set tx rate of %llu Mbps (count of 50Mbps %llu) for vsi->seid %u\n",ch->max_tx_rate,credits,(int)ch->seid);
    }
  }
  #line 6252 
  ch->parent_vsi = vsi;
  #line 6255 
  vsi->cnt_q_avail = (unsigned short)((int)vsi->cnt_q_avail - (int)ch->num_queue_pairs);
  #line 6257 
  return 0;
}

#line 6266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_configure_queue_channels(struct i40e_vsi *vsi)
{
  #line 6268 
  struct i40e_channel *ch;
  #line 6270 
  int i;
  #line 6269 
  u64 max_rate = 0ULL;
  #line 6270 
  int ret = 0;
  #line 6273 
  vsi->tc_seid_map[0] = vsi->seid;
  #line 6274 
  i = 1;
  #line 6274 
  while (i <= 7) {
    #line 6275 
    if ((((unsigned long)vsi->tc_config.enabled_tc >> i) & 1UL) != 0UL) {
      #line 6276 
      ch = (struct i40e_channel *)kzalloc_1(184UL,3264U);
      #line 6277 
      if (ch == (struct i40e_channel *)0) {
        #line 6278 
        ret = -12;
        #line 6279 
        goto err_free;
      }
      #line 6282 
      INIT_LIST_HEAD(& ch->list);
      #line 6283 
      ch->num_queue_pairs = vsi->tc_config.tc_info[i].qcount;
      #line 6285 
      ch->base_queue = vsi->tc_config.tc_info[i].qoffset;
      #line 6291 
      max_rate = vsi->mqprio_qopt.max_rate[i];
      {
        #line 6292 
        uint32_t __rem;
        #line 6292 
        uint32_t __base = 125000U;
        #line 6292 
        __rem = (unsigned int)(max_rate % (unsigned long long)__base);
        #line 6292 
        max_rate /= (unsigned long long)__base;
        #line 6292 
        uint32_t tmp_2 = __rem;
      }
      #line 6293 
      ch->max_tx_rate = max_rate;
      #line 6295 
      list_add_tail(& ch->list,& vsi->ch_list);
      #line 6297 
      ret = i40e_create_queue_channel(vsi,ch);
      #line 6298 
      if (ret != 0) {
        #line 6299 
        _dev_err(& ((vsi->back)->pdev)->dev,(char *)"Failed creating queue channel with TC%d: queues %d\n",i,(int)ch->num_queue_pairs);
        #line 6302 
        goto err_free;
      }
      #line 6304 
      vsi->tc_seid_map[i] = ch->seid;
    }
    #line 6274 
    i ++;
  }
  #line 6307 
  return ret;
  #line 6309 
  err_free: 
            #line 6309 
  ;
  #line 6310 
  i40e_remove_queue_channels(vsi);
  #line 6311 
  return ret;
}

#line 6321  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_veb_config_tc(struct i40e_veb *veb, u8 enabled_tc)
{
  #line 6326 
  int i;
  #line 6323 
  struct i40e_aqc_configure_switching_comp_bw_config_data bw_data = {.tc_valid_bits = (unsigned char)0U, .reserved = {(unsigned char)0, (unsigned char)0}, .absolute_credits = (unsigned char)0, .tc_bw_share_credits = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, .reserved1 = {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}};
  #line 6324 
  struct i40e_pf *pf = veb->pf;
  #line 6325 
  int ret = 0;
  #line 6329 
  if ((unsigned int)enabled_tc == 0U || (int)veb->enabled_tc == (int)enabled_tc) 
    #line 6330 
    return ret;
  #line 6332 
  bw_data.tc_valid_bits = enabled_tc;
  #line 6336 
  i = 0;
  #line 6336 
  while (i <= 7) {
    #line 6337 
    if ((((unsigned long)enabled_tc >> i) & 1UL) != 0UL) 
                                                         #line 6338 
                                                         bw_data.tc_bw_share_credits[i] = (unsigned char)1U;
    #line 6336 
    i ++;
  }
  #line 6341 
  ret = (int)i40e_aq_config_switch_comp_bw_config(& pf->hw,
                                           (unsigned short)((int)veb->seid),
                                           & bw_data,
                                           (struct i40e_asq_cmd_details *)0);
  #line 6343 
  if (ret != 0) {
    #line 6344 
    ;
    #line 6344 
    _dev_info(& (pf->pdev)->dev,(char *)"VEB bw config failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 6348 
    goto out;
  }
  #line 6352 
  ret = i40e_veb_get_bw_info(veb);
  #line 6353 
  if (ret != 0) {
    #line 6354 
    ;
    #line 6354 
    _dev_info(& (pf->pdev)->dev,(char *)"Failed getting veb bw config, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
  }
  #line 6360 
  out: 
       #line 6360 
  ;
  #line 6361 
  return ret;
}

#line 6373  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_dcb_reconfigure(struct i40e_pf *pf)
{
  #line 6376 
  int ret;
  #line 6377 
  u8 v;
  #line 6375 
  u8 tc_map = (unsigned char)0U;
  #line 6380 
  tc_map = i40e_pf_get_tc_map(pf);
  #line 6381 
  v = (unsigned char)0U;
  #line 6381 
  while ((unsigned int)v <= 15U) {
    #line 6382 
    if (pf->veb[(int)v] == (struct i40e_veb *)0) 
                                                 #line 6383 
                                                 goto __Cont;
    #line 6384 
    ret = i40e_veb_config_tc(pf->veb[(int)v],(unsigned char)((int)tc_map));
    #line 6385 
    if (ret != 0) 
                  #line 6386 
                  _dev_info(& (pf->pdev)->dev,(char *)"Failed configuring TC for VEB seid=%d\n",(int)(pf->veb[(int)v])->seid);
    #line 6381 
    __Cont: 
            #line 6381 
    v = (u8)((int)v + 1);
  }
  #line 6394 
  v = (unsigned char)0U;
  #line 6394 
  while ((int)((unsigned short)v) < (int)pf->num_alloc_vsi) {
    #line 6395 
    if (*(pf->vsi + (unsigned long)v) == (struct i40e_vsi *)0) 
                                                               #line 6396 
                                                               goto __Cont_0;
    #line 6401 
    if ((int)((unsigned short)v) == (int)pf->lan_vsi) 
                                                      #line 6402 
                                                      tc_map = i40e_pf_get_tc_map(pf); else 
                                                                    #line 6404 
                                                                    tc_map = (unsigned char)1U;
    #line 6406 
    ret = i40e_vsi_config_tc(*(pf->vsi + (unsigned long)v),(unsigned char)((int)tc_map));
    #line 6407 
    if (ret != 0) 
                  #line 6408 
                  _dev_info(& (pf->pdev)->dev,(char *)"Failed configuring TC for VSI seid=%d\n",(int)(*(pf->vsi + (unsigned long)v))->seid);
    else {
      #line 6414 
      i40e_vsi_map_rings_to_vectors(*(pf->vsi + (unsigned long)v));
      #line 6415 
      if ((*(pf->vsi + (unsigned long)v))->netdev != (struct net_device *)0) 
        #line 6416 
        i40e_dcbnl_set_all(*(pf->vsi + (unsigned long)v));
    }
    #line 6394 
    __Cont_0: 
              #line 6394 
    v = (u8)((int)v + 1);
  }
  #line 6419 
  return;
}

#line 6428  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_resume_port_tx(struct i40e_pf *pf)
{
  #line 6431 
  int ret;
  #line 6430 
  struct i40e_hw *hw = & pf->hw;
  #line 6433 
  ret = (int)i40e_aq_resume_port_tx(hw,(struct i40e_asq_cmd_details *)0);
  #line 6434 
  if (ret != 0) {
    #line 6435 
    ;
    #line 6435 
    _dev_info(& (pf->pdev)->dev,(char *)"Resume Port Tx failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 6440 
    cif_set_bit_1(13L,(unsigned long *)(& pf->state));
    #line 6441 
    i40e_service_event_schedule(pf);
  }
  #line 6444 
  return ret;
}

#line 6454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_init_pf_dcb(struct i40e_pf *pf)
{
  #line 6456 
  struct i40e_hw *hw = & pf->hw;
  #line 6457 
  int err = 0;
  #line 6462 
  if (((unsigned long)pf->hw_features & 128UL) != 0UL || ((unsigned long)pf->flags & 16777216UL) != 0UL) {
    #line 6464 
    _dev_info(& (pf->pdev)->dev,(char *)"DCB is not supported or FW LLDP is disabled\n");
    #line 6465 
    err = -64;
    #line 6466 
    goto out;
  }
  #line 6469 
  err = (int)i40e_init_dcb(hw,(_Bool)1);
  #line 6470 
  if (err == 0) 
    #line 6472 
    if (! hw->func_caps.dcb || (unsigned int)hw->dcbx_status == 7U) 
                                                                    #line 6474 
                                                                    _dev_info(& (pf->pdev)->dev,(char *)"DCBX offload is not supported or is disabled for this PF.\n");
    else {
      #line 6478 
      pf->dcbx_cap = (unsigned short)10U;
      #line 6481 
      pf->flags |= 64U;
      #line 6485 
      if ((unsigned int)i40e_dcb_get_num_tc(& hw->local_dcbx_config) > 1U) 
        #line 6486 
        pf->flags |= 128U; else 
                                #line 6488 
                                pf->flags &= 4294967167U;
      {
        #line 6489 
        bool branch;
        #line 6489 
        struct _ddebug __UNIQUE_ID_ddebug611 = {.modname = (char *)"i40e", .function = (char *)"i40e_init_pf_dcb", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"DCBX offload is supported for this PF.\n", .lineno = (unsigned int)6489U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 6489 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug611.key.dd_key_false.key,(_Bool)0);
        #line 6489 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 6489 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug611,& (pf->pdev)->dev,(char *)"DCBX offload is supported for this PF.\n");
      }
    }
  else 
    #line 6492 
    if (pf->hw.aq.asq_last_status == (unsigned int)I40E_AQ_RC_EPERM) {
      #line 6493 
      _dev_info(& (pf->pdev)->dev,(char *)"FW LLDP disabled for this PF.\n");
      #line 6494 
      pf->flags |= 16777216U;
    }
    else {
      #line 6496 
      ;
      #line 6496 
      _dev_info(& (pf->pdev)->dev,(char *)"Query for DCB configuration failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)err),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    }
  #line 6502 
  out: 
       #line 6502 
  ;
  #line 6503 
  return err;
}

#line 6513  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_print_link_message(struct i40e_vsi *vsi, bool isup)
{
  #line 6515 
  enum i40e_aq_link_speed new_speed;
  #line 6516 
  struct i40e_pf *pf = vsi->back;
  #line 6517 
  char *speed = (char *)"Unknown";
  #line 6518 
  char *fc = (char *)"Unknown";
  #line 6519 
  char *fec = (char *)"";
  #line 6520 
  char *req_fec = (char *)"";
  #line 6521 
  char *an = (char *)"";
  #line 6523 
  if ((int)isup != 0) 
                      #line 6524 
                      new_speed = pf->hw.phy.link_info.link_speed; else 
                                                                    #line 6526 
                                                                    new_speed = I40E_LINK_SPEED_UNKNOWN;
  #line 6528 
  if ((int)vsi->current_isup == (int)isup && vsi->current_speed == new_speed) 
    #line 6529 
    return;
  #line 6530 
  vsi->current_isup = isup;
  #line 6531 
  vsi->current_speed = new_speed;
  #line 6532 
  if (! isup) {
    #line 6533 
    netdev_info(vsi->netdev,(char *)"NIC Link is Down\n");
    #line 6534 
    return;
  }
  #line 6540 
  if (pf->hw.func_caps.npar_enable != 0U && (pf->hw.phy.link_info.link_speed == (unsigned int)I40E_LINK_SPEED_1GB || pf->hw.phy.link_info.link_speed == (unsigned int)I40E_LINK_SPEED_100MB)) 
    #line 6543 
    netdev_warn(vsi->netdev,(char *)"The partition detected link speed that is less than 10Gbps\n");
  #line 6546 
  switch ((unsigned int)pf->hw.phy.link_info.link_speed) {
    #line 6547 
    case (unsigned int)16: 
                           #line 6547 
    ;
    #line 6548 
    speed = (char *)"40 G";
    #line 6549 
    break;
    #line 6550 
    case (unsigned int)32: 
                           #line 6550 
    ;
    #line 6551 
    speed = (char *)"20 G";
    #line 6552 
    break;
    #line 6553 
    case (unsigned int)64: 
                           #line 6553 
    ;
    #line 6554 
    speed = (char *)"25 G";
    #line 6555 
    break;
    #line 6556 
    case (unsigned int)8: 
                          #line 6556 
    ;
    #line 6557 
    speed = (char *)"10 G";
    #line 6558 
    break;
    #line 6559 
    case (unsigned int)128: 
                            #line 6559 
    ;
    #line 6560 
    speed = (char *)"5 G";
    #line 6561 
    break;
    #line 6562 
    case (unsigned int)1: 
                          #line 6562 
    ;
    #line 6563 
    speed = (char *)"2.5 G";
    #line 6564 
    break;
    #line 6565 
    case (unsigned int)4: 
                          #line 6565 
    ;
    #line 6566 
    speed = (char *)"1000 M";
    #line 6567 
    break;
    #line 6568 
    case (unsigned int)2: 
                          #line 6568 
    ;
    #line 6569 
    speed = (char *)"100 M";
    #line 6570 
    break;
    #line 6571 
    default: 
             #line 6571 
    ;
    #line 6572 
    break;
  }
  #line 6575 
  switch ((unsigned int)pf->hw.fc.current_mode) {
    #line 6576 
    case (unsigned int)3: 
                          #line 6576 
    ;
    #line 6577 
    fc = (char *)"RX/TX";
    #line 6578 
    break;
    #line 6579 
    case (unsigned int)2: 
                          #line 6579 
    ;
    #line 6580 
    fc = (char *)"TX";
    #line 6581 
    break;
    #line 6582 
    case (unsigned int)1: 
                          #line 6582 
    ;
    #line 6583 
    fc = (char *)"RX";
    #line 6584 
    break;
    #line 6585 
    default: 
             #line 6585 
    ;
    #line 6586 
    fc = (char *)"None";
    #line 6587 
    break;
  }
  #line 6590 
  if (pf->hw.phy.link_info.link_speed == (unsigned int)I40E_LINK_SPEED_25GB) {
    #line 6591 
    req_fec = (char *)"None";
    #line 6592 
    fec = (char *)"None";
    #line 6593 
    an = (char *)"False";
    #line 6595 
    if (((int)pf->hw.phy.link_info.an_info & 1) != 0) 
                                                      #line 6596 
                                                      an = (char *)"True";
    #line 6598 
    if (((int)pf->hw.phy.link_info.fec_info & 1) != 0) 
                                                       #line 6600 
                                                       fec = (char *)"CL74 FC-FEC/BASE-R";
    else 
      #line 6601 
      if (((int)pf->hw.phy.link_info.fec_info & 2) != 0) 
                                                         #line 6603 
                                                         fec = (char *)"CL108 RS-FEC";
    #line 6608 
    if (((int)(vsi->back)->hw.phy.link_info.req_fec_info & 12) != 0) 
      #line 6610 
      if (((int)(vsi->back)->hw.phy.link_info.req_fec_info & 8) != 0) 
        #line 6612 
        req_fec = (char *)"CL108 RS-FEC"; else 
                                               #line 6614 
                                               req_fec = (char *)"CL74 FC-FEC/BASE-R";
    #line 6616 
    netdev_info(vsi->netdev,(char *)"NIC Link is Up, %sbps Full Duplex, Requested FEC: %s, Negotiated FEC: %s, Autoneg: %s, Flow Control: %s\n",speed,req_fec,fec,an,fc);
  }
  else 
       #line 6620 
       netdev_info(vsi->netdev,(char *)"NIC Link is Up, %sbps Full Duplex, Flow Control: %s\n",speed,fc);
  #line 6622 
  return;
}

#line 6631  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_up_complete(struct i40e_vsi *vsi)
{
  #line 6634 
  int err;
  #line 6633 
  struct i40e_pf *pf = vsi->back;
  #line 6636 
  if (((unsigned long)pf->flags & 4UL) != 0UL) 
                                               #line 6637 
                                               i40e_vsi_configure_msix(vsi); else 
                                                                    #line 6639 
                                                                    i40e_configure_msi_and_legacy(vsi);
  #line 6642 
  err = i40e_vsi_start_rings(vsi);
  #line 6643 
  if (err != 0) 
                #line 6644 
                return err;
  #line 6646 
  cif_clear_bit_1(0L,(unsigned long *)(& vsi->state));
  #line 6647 
  i40e_napi_enable_all(vsi);
  #line 6648 
  i40e_vsi_enable_irq(vsi);
  #line 6650 
  if (((int)pf->hw.phy.link_info.link_info & 1) != 0 && vsi->netdev != (struct net_device *)0) {
    #line 6652 
    i40e_print_link_message(vsi,(_Bool)1);
    #line 6653 
    netif_tx_start_all_queues(vsi->netdev);
    #line 6654 
    netif_carrier_on(vsi->netdev);
  }
  #line 6658 
  if (vsi->type == (unsigned int)I40E_VSI_FDIR) {
    #line 6660 
    pf->fd_add_err = 0U;
    #line 6661 
    pf->fd_atr_cnt = 0U;
    #line 6662 
    i40e_fdir_filter_restore(vsi);
  }
  #line 6668 
  cif_set_bit_1(30L,(unsigned long *)(& pf->state));
  #line 6669 
  i40e_service_event_schedule(pf);
  #line 6671 
  return 0;
}

#line 6681  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_reinit_locked(struct i40e_vsi *vsi)
{
  #line 6683 
  struct i40e_pf *pf = vsi->back;
  {
    #line 6685 
    int __ret_warn_on = ((unsigned long)preempt_count() & 2096896UL) != 0UL;
    #line 6685 
    if ((long)(__ret_warn_on != 0) != 0L) {
      #line 6686 
      ldv_inline_asm();
      #line 6687 
      ldv_inline_asm();
    }
    #line 6685 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  #line 6686 
  while (1) {
    #line 6686 
    if (! ((int)test_and_set_bit(1L,(unsigned long *)(& pf->state)) != 0)) 
      #line 6686 
      break;
    #line 6687 
    usleep_range(1000UL,2000UL);
  }
  #line 6688 
  i40e_down(vsi);
  #line 6690 
  i40e_up(vsi);
  #line 6691 
  cif_clear_bit_1(1L,(unsigned long *)(& pf->state));
  #line 6692 
  return;
}

#line 6698  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_up(struct i40e_vsi *vsi)
{
  #line 6700 
  int err;
  #line 6702 
  err = i40e_vsi_configure(vsi);
  #line 6703 
  if (err == 0) 
                #line 6704 
                err = i40e_up_complete(vsi);
  #line 6706 
  return err;
}

#line 6714  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static i40e_status i40e_force_link_state(struct i40e_pf *pf, bool is_up)
{
  #line 6716 
  struct i40e_aq_get_phy_abilities_resp abilities;
  #line 6719 
  i40e_status err;
  #line 6720 
  u64 mask;
  #line 6721 
  u8 speed;
  #line 6717 
  struct i40e_aq_set_phy_config config = {.phy_type = 0U, .link_speed = (unsigned char)0, .abilities = (unsigned char)0, .eee_capability = (unsigned short)0, .eeer = 0U, .low_power_ctrl = (unsigned char)0, .phy_type_ext = (unsigned char)0, .fec_config = (unsigned char)0, .reserved = (unsigned char)0};
  #line 6718 
  struct i40e_hw *hw = & pf->hw;
  #line 6729 
  err = i40e_aq_get_phy_capabilities(hw,(_Bool)0,(_Bool)1,& abilities,(struct i40e_asq_cmd_details *)0);
  #line 6731 
  if (err != I40E_SUCCESS) {
    #line 6732 
    ;
    #line 6732 
    _dev_err(& (pf->pdev)->dev,(char *)"failed to get phy cap., ret =  %s last_status =  %s\n",i40e_stat_str(hw,err),i40e_aq_str(hw,hw->aq.asq_last_status));
    #line 6736 
    return err;
  }
  #line 6738 
  speed = abilities.link_speed;
  #line 6741 
  err = i40e_aq_get_phy_capabilities(hw,(_Bool)0,(_Bool)0,& abilities,(struct i40e_asq_cmd_details *)0);
  #line 6743 
  if (err != I40E_SUCCESS) {
    #line 6744 
    ;
    #line 6744 
    _dev_err(& (pf->pdev)->dev,(char *)"failed to get phy cap., ret =  %s last_status =  %s\n",i40e_stat_str(hw,err),i40e_aq_str(hw,hw->aq.asq_last_status));
    #line 6748 
    return err;
  }
  #line 6754 
  if (((int)is_up != 0 && abilities.phy_type != 0U) && (unsigned int)abilities.link_speed != 0U) 
    #line 6755 
    return I40E_SUCCESS;
  #line 6761 
  mask = 844562369019903ULL;
  #line 6762 
  if ((int)is_up != 0) 
                       #line 6762 
                       config.phy_type = (unsigned int)mask; else 
                                                                  #line 6762 
                                                                  config.phy_type = 0U;
  #line 6763 
  if ((int)is_up != 0) 
                       #line 6763 
                       config.phy_type_ext = (unsigned char)(mask >> 32); else 
                                                                    #line 6763 
                                                                    config.phy_type_ext = (unsigned char)0U;
  #line 6765 
  config.abilities = abilities.abilities;
  #line 6766 
  if ((unsigned int)abilities.link_speed != 0U) 
                                                #line 6767 
                                                config.link_speed = abilities.link_speed; else 
                                                                    #line 6769 
                                                                    config.link_speed = speed;
  #line 6770 
  config.eee_capability = abilities.eee_capability;
  #line 6771 
  config.eeer = abilities.eeer_val;
  #line 6772 
  config.low_power_ctrl = abilities.d3_lpan;
  #line 6773 
  config.fec_config = (unsigned char)((unsigned int)abilities.fec_cfg_curr_mod_ext_info & 31U);
  #line 6775 
  err = i40e_aq_set_phy_config(hw,& config,(struct i40e_asq_cmd_details *)0);
  #line 6777 
  if (err != I40E_SUCCESS) {
    #line 6778 
    ;
    #line 6778 
    _dev_err(& (pf->pdev)->dev,(char *)"set phy config ret =  %s last_status =  %s\n",i40e_stat_str(& pf->hw,err),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 6782 
    return err;
  }
  #line 6786 
  err = i40e_update_link_info(hw);
  #line 6787 
  if (err != I40E_SUCCESS) {
    #line 6792 
    msleep(1000U);
    #line 6793 
    i40e_update_link_info(hw);
  }
  #line 6796 
  i40e_aq_set_link_restart_an(hw,(_Bool)1,(struct i40e_asq_cmd_details *)0);
  #line 6798 
  return I40E_SUCCESS;
}

#line 6805  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_down(struct i40e_vsi *vsi)
{
  #line 6807 
  int i;
  #line 6812 
  if (vsi->netdev != (struct net_device *)0) {
    #line 6813 
    netif_carrier_off(vsi->netdev);
    #line 6814 
    netif_tx_disable(vsi->netdev);
  }
  #line 6816 
  i40e_vsi_disable_irq(vsi);
  #line 6817 
  i40e_vsi_stop_rings(vsi);
  #line 6818 
  if (vsi->type == (unsigned int)I40E_VSI_MAIN && ((unsigned long)(vsi->back)->flags & 524288UL) != 0UL) 
    #line 6820 
    i40e_force_link_state(vsi->back,(_Bool)0);
  #line 6821 
  i40e_napi_disable_all(vsi);
  #line 6823 
  i = 0;
  #line 6823 
  while ((int)vsi->num_queue_pairs > i) {
    {
      #line 6824 
      i40e_clean_tx_ring(*(vsi->tx_rings + (unsigned long)i));
      #line 6825 
      if ((int)i40e_enabled_xdp_vsi_0(vsi) != 0) {
        #line 6829 
        synchronize_rcu();
        #line 6830 
        i40e_clean_tx_ring(*(vsi->xdp_rings + (unsigned long)i));
      }
      #line 6832 
      i40e_clean_rx_ring(*(vsi->rx_rings + (unsigned long)i));
    }
    #line 6823 
    i ++;
  }
  #line 6834 
  return;
}

#line 6842  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_validate_mqprio_qopt(struct i40e_vsi *vsi, struct tc_mqprio_qopt_offload *mqprio_qopt)
{
  #line 6847 
  int i;
  #line 6845 
  u64 sum_max_rate = 0ULL;
  #line 6846 
  u64 max_rate = 0ULL;
  #line 6849 
  if (((unsigned int)mqprio_qopt->qopt.offset[0] != 0U || (unsigned int)mqprio_qopt->qopt.num_tc == 0U) || (unsigned int)mqprio_qopt->qopt.num_tc > 8U) 
    #line 6852 
    return -22;
  #line 6853 
  i = 0;
  #line 6853 
  while (1) {
    #line 6854 
    if ((unsigned int)mqprio_qopt->qopt.count[i] == 0U) 
                                                        #line 6855 
                                                        return -22;
    #line 6856 
    if (mqprio_qopt->min_rate[i] != 0ULL) {
      #line 6857 
      _dev_err(& ((vsi->back)->pdev)->dev,(char *)"Invalid min tx rate (greater than 0) specified\n");
      #line 6859 
      return -22;
    }
    #line 6861 
    max_rate = mqprio_qopt->max_rate[i];
    {
      #line 6862 
      uint32_t __rem;
      #line 6862 
      uint32_t __base = 125000U;
      #line 6862 
      __rem = (unsigned int)(max_rate % (unsigned long long)__base);
      #line 6862 
      max_rate /= (unsigned long long)__base;
      #line 6862 
      uint32_t tmp = __rem;
    }
    #line 6863 
    sum_max_rate += max_rate;
    #line 6865 
    if ((int)mqprio_qopt->qopt.num_tc + -1 <= i) 
                                                 #line 6866 
                                                 break;
    #line 6867 
    if ((int)mqprio_qopt->qopt.offset[i + 1] != (int)mqprio_qopt->qopt.offset[i] + (int)mqprio_qopt->qopt.count[i]) 
      #line 6869 
      return -22;
    #line 6853 
    i ++;
  }
  #line 6871 
  if ((int)vsi->num_queue_pairs < (int)mqprio_qopt->qopt.offset[i] + (int)mqprio_qopt->qopt.count[i]) 
    #line 6873 
    return -22;
  #line 6875 
  ;
  #line 6875 
  if ((unsigned long long)i40e_get_link_speed(vsi) < sum_max_rate) {
    #line 6876 
    _dev_err(& ((vsi->back)->pdev)->dev,(char *)"Invalid max tx rate specified\n");
    #line 6878 
    return -22;
  }
  #line 6880 
  return 0;
}

#line 6887  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_set_default_tc_config(struct i40e_vsi *vsi)
{
  #line 6895 
  int __UNIQUE_ID___x613;
  #line 6895 
  int tmp_0;
  #line 6889 
  u16 qcount;
  #line 6890 
  int i;
  #line 6893 
  vsi->tc_config.numtc = (unsigned char)1U;
  #line 6894 
  vsi->tc_config.enabled_tc = (unsigned char)1U;
  {
    #line 6895 
    int tmp;
    #line 6895 
    __UNIQUE_ID___x613 = (int)vsi->alloc_queue_pairs;
    #line 6895 
    if (((unsigned long)(vsi->back)->hw_features & 2UL) != 0UL) 
                                                                #line 6895 
                                                                tmp = 128; else 
                                                                    #line 6895 
                                                                    tmp = 64;
    #line 6895 
    int __UNIQUE_ID___y614 = tmp;
    #line 6895 
    if (__UNIQUE_ID___x613 < __UNIQUE_ID___y614) 
                                                 #line 6895 
                                                 tmp_0 = __UNIQUE_ID___x613; else 
                                                                    #line 6895 
                                                                    tmp_0 = __UNIQUE_ID___y614;
    }
  #line 6895 
  qcount = (unsigned short)tmp_0;
  #line 6897 
  i = 0;
  #line 6897 
  while (i <= 7) {
    #line 6901 
    vsi->tc_config.tc_info[i].qoffset = (unsigned short)0U;
    #line 6902 
    if (i == 0) 
                #line 6903 
                vsi->tc_config.tc_info[i].qcount = qcount; else 
                                                                #line 6905 
                                                                vsi->tc_config.tc_info[i].qcount = (unsigned short)1U;
    #line 6906 
    vsi->tc_config.tc_info[i].netdev_tc = (unsigned char)0U;
    #line 6897 
    i ++;
  }
  #line 6908 
  return;
}

#line 6920  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static i40e_status i40e_del_macvlan_filter(struct i40e_hw *hw, u16 seid, u8 *macaddr, int *aq_err)
{
  #line 6923 
  struct i40e_aqc_remove_macvlan_element_data element;
  #line 6924 
  i40e_status status;
  #line 6926 
  memset((void *)(& element),0,16UL);
  #line 6927 
  ether_addr_copy((u8 *)(& element.mac_addr),macaddr);
  #line 6928 
  element.vlan_tag = (unsigned short)0U;
  #line 6929 
  element.flags = (unsigned char)1U;
  #line 6930 
  status = i40e_aq_remove_macvlan(hw,(unsigned short)((int)seid),& element,(unsigned short)1,(struct i40e_asq_cmd_details *)0);
  #line 6931 
  *aq_err = (int)hw->aq.asq_last_status;
  #line 6933 
  return status;
}

#line 6946  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static i40e_status i40e_add_macvlan_filter(struct i40e_hw *hw, u16 seid, u8 *macaddr, int *aq_err)
{
  #line 6949 
  struct i40e_aqc_add_macvlan_element_data element;
  #line 6950 
  i40e_status status;
  #line 6951 
  u16 cmd_flags = (unsigned short)0U;
  #line 6953 
  ether_addr_copy((u8 *)(& element.mac_addr),macaddr);
  #line 6954 
  element.vlan_tag = (unsigned short)0U;
  #line 6955 
  element.queue_number = (unsigned short)0U;
  #line 6956 
  element.match_method = (unsigned char)255U;
  #line 6957 
  cmd_flags = (unsigned short)((unsigned int)cmd_flags | 1U);
  #line 6958 
  element.flags = cmd_flags;
  #line 6959 
  status = i40e_aq_add_macvlan(hw,(unsigned short)((int)seid),& element,(unsigned short)1,(struct i40e_asq_cmd_details *)0);
  #line 6960 
  *aq_err = (int)hw->aq.asq_last_status;
  #line 6962 
  return status;
}

#line 6970  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_reset_ch_rings(struct i40e_vsi *vsi, struct i40e_channel *ch)
{
  #line 6972 
  struct i40e_ring *tx_ring;
  #line 6972 
  struct i40e_ring *rx_ring;
  #line 6973 
  u16 pf_q;
  #line 6974 
  int i;
  #line 6976 
  i = 0;
  #line 6976 
  while ((int)ch->num_queue_pairs > i) {
    #line 6977 
    pf_q = (unsigned short)((int)ch->base_queue + (int)((unsigned short)i));
    #line 6978 
    tx_ring = *(vsi->tx_rings + (unsigned long)pf_q);
    #line 6979 
    tx_ring->ch = (struct i40e_channel *)0;
    #line 6980 
    rx_ring = *(vsi->rx_rings + (unsigned long)pf_q);
    #line 6981 
    rx_ring->ch = (struct i40e_channel *)0;
    #line 6976 
    i ++;
  }
  #line 6983 
  return;
}

#line 6993  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_free_macvlan_channels(struct i40e_vsi *vsi)
{
  #line 7001 
  void *__mptr_0;
  #line 7001 
  void *__mptr;
  #line 6995 
  struct i40e_channel *ch;
  #line 6995 
  struct i40e_channel *ch_tmp;
  #line 6996 
  int ret;
  #line 6998 
  if (list_empty(& vsi->macvlan_list) != 0) 
                                            #line 6999 
                                            return;
  #line 7001 
  __mptr = (void *)vsi->macvlan_list.next;
  #line 7001 
  ch = ((struct i40e_channel *)__mptr);
  #line 7001 
  __mptr_0 = (void *)ch->list.next;
  #line 7002 
  ch_tmp = ((struct i40e_channel *)__mptr_0);
  #line 7001 
  while (& ch->list != & vsi->macvlan_list) {
    #line 7001 
    void *__mptr_1;
    {
      #line 7002 
      struct i40e_vsi *parent_vsi;
      #line 7004 
      if ((int)i40e_is_channel_macvlan(ch) != 0) {
        #line 7005 
        i40e_reset_ch_rings(vsi,ch);
        #line 7006 
        cif_clear_bit_1((long)(ch->fwd)->bit_no,(unsigned long *)(& vsi->fwd_bitmask));
        #line 7007 
        netdev_unbind_sb_channel(vsi->netdev,(ch->fwd)->netdev);
        #line 7008 
        netdev_set_sb_channel((ch->fwd)->netdev,(unsigned short)0);
        #line 7009 
        kfree((void *)ch->fwd);
        #line 7010 
        ch->fwd = (struct i40e_fwd_adapter *)0;
      }
      #line 7013 
      list_del(& ch->list);
      #line 7014 
      parent_vsi = ch->parent_vsi;
      #line 7015 
      if (parent_vsi == (struct i40e_vsi *)0 || ! ch->initialized) {
        #line 7016 
        kfree((void *)ch);
        #line 7017 
        goto __Cont;
      }
      #line 7021 
      ret = (int)i40e_aq_delete_element(& (vsi->back)->hw,
                               (unsigned short)((int)ch->seid),
                               (struct i40e_asq_cmd_details *)0);
      #line 7023 
      if (ret != 0) 
                    #line 7024 
                    _dev_err(& ((vsi->back)->pdev)->dev,(char *)"unable to remove channel (%d) for parent VSI(%d)\n",(int)ch->seid,(int)parent_vsi->seid);
      #line 7027 
      kfree((void *)ch);
    }
    #line 7001 
    __Cont: 
            #line 7001 
    ch = ch_tmp;
    #line 7001 
    __mptr_1 = (void *)ch_tmp->list.next;
    #line 7001 
    ch_tmp = ((struct i40e_channel *)__mptr_1);
  }
  #line 7029 
  vsi->macvlan_cnt = 0;
  #line 7030 
  return;
}

#line 7038  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_fwd_ring_up(struct i40e_vsi *vsi, struct net_device *vdev, struct i40e_fwd_adapter *fwd)
{
  #line 7050 
  void *__mptr;
  #line 7050 
  void *__mptr_0;
  #line 7041 
  int i;
  #line 7041 
  int aq_err;
  #line 7042 
  struct i40e_channel *ch;
  #line 7042 
  struct i40e_channel *ch_tmp;
  #line 7041 
  int ret = 0;
  #line 7041 
  int num_tc = 1;
  #line 7043 
  struct i40e_pf *pf = vsi->back;
  #line 7044 
  struct i40e_hw *hw = & pf->hw;
  #line 7046 
  if (list_empty(& vsi->macvlan_list) != 0) 
                                            #line 7047 
                                            return -22;
  #line 7050 
  __mptr = (void *)vsi->macvlan_list.next;
  #line 7050 
  ch = ((struct i40e_channel *)__mptr);
  #line 7050 
  __mptr_0 = (void *)ch->list.next;
  #line 7051 
  ch_tmp = ((struct i40e_channel *)__mptr_0);
  #line 7050 
  while (& ch->list != & vsi->macvlan_list) {
    #line 7050 
    void *__mptr_1;
    #line 7051 
    if (! i40e_is_channel_macvlan(ch)) {
      #line 7052 
      ch->fwd = fwd;
      #line 7054 
      i = 0;
      #line 7054 
      while (i < num_tc) {
        #line 7055 
        netdev_bind_sb_channel_queue(vsi->netdev,vdev,(unsigned char)((int)((unsigned char)i)),(unsigned short)((int)ch->num_queue_pairs),(unsigned short)((int)ch->base_queue));
        #line 7054 
        i ++;
      }
      #line 7059 
      i = 0;
      #line 7059 
      while ((int)ch->num_queue_pairs > i) {
        {
          #line 7060 
          struct i40e_ring *tx_ring;
          #line 7060 
          struct i40e_ring *rx_ring;
          #line 7061 
          u16 pf_q;
          #line 7063 
          pf_q = (unsigned short)((int)ch->base_queue + (int)((unsigned short)i));
          #line 7066 
          tx_ring = *(vsi->tx_rings + (unsigned long)pf_q);
          #line 7067 
          tx_ring->ch = ch;
          #line 7070 
          rx_ring = *(vsi->rx_rings + (unsigned long)pf_q);
          #line 7071 
          rx_ring->ch = ch;
        }
        #line 7059 
        i ++;
      }
      #line 7073 
      break;
    }
    #line 7050 
    ch = ch_tmp;
    #line 7050 
    __mptr_1 = (void *)ch_tmp->list.next;
    #line 7050 
    ch_tmp = ((struct i40e_channel *)__mptr_1);
  }
  #line 7075 
  ldv_inline_asm();
  #line 7083 
  ret = (int)i40e_add_macvlan_filter(hw,(unsigned short)((int)ch->seid),
                                vdev->dev_addr,& aq_err);
  #line 7084 
  if (ret != 0) {
    #line 7086 
    macvlan_release_l2fw_offload(vdev);
    #line 7087 
    i = 0;
    #line 7087 
    while ((int)ch->num_queue_pairs > i) {
      {
        #line 7088 
        struct i40e_ring *rx_ring_0;
        #line 7089 
        u16 pf_q_0;
        #line 7091 
        pf_q_0 = (unsigned short)((int)ch->base_queue + (int)((unsigned short)i));
        #line 7092 
        rx_ring_0 = *(vsi->rx_rings + (unsigned long)pf_q_0);
        #line 7093 
        rx_ring_0->netdev = (struct net_device *)0;
      }
      #line 7087 
      i ++;
    }
    #line 7095 
    ;
    #line 7095 
    _dev_info(& (pf->pdev)->dev,(char *)"Error adding mac filter on macvlan err %s, aq_err %s\n",i40e_stat_str(hw,(enum i40e_status_code)ret),i40e_aq_str(hw,(enum i40e_admin_queue_err)aq_err));
    #line 7099 
    netdev_err(vdev,(char *)"L2fwd offload disabled to L2 filter error\n");
  }
  #line 7102 
  return ret;
}

#line 7112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_setup_macvlans(struct i40e_vsi *vsi, u16 macvlan_cnt, u16 qcnt, struct net_device *vdev)
{
  #line 7129 
  unsigned int tmp_59;
  #line 7129 
  unsigned int tmp_60;
  #line 7129 
  unsigned int tmp_61;
  #line 7129 
  unsigned int tmp;
  #line 7129 
  unsigned int tmp_63;
  #line 7129 
  unsigned int tmp_64;
  #line 7129 
  unsigned int tmp_0;
  #line 7129 
  unsigned int tmp_1;
  #line 7129 
  unsigned int tmp_2;
  #line 7149 
  unsigned short __UNIQUE_ID___x615;
  #line 7129 
  unsigned int tmp_3;
  #line 7129 
  unsigned int tmp_4;
  #line 7149 
  int tmp_67;
  #line 7129 
  unsigned int tmp_5;
  #line 7129 
  unsigned int tmp_6;
  #line 7129 
  unsigned int tmp_7;
  #line 7129 
  unsigned int tmp_8;
  #line 7129 
  unsigned int tmp_9;
  #line 7129 
  unsigned int tmp_10;
  #line 7129 
  unsigned int tmp_11;
  #line 7129 
  unsigned int tmp_12;
  #line 7129 
  unsigned int tmp_13;
  #line 7129 
  unsigned int tmp_14;
  #line 7129 
  unsigned int tmp_15;
  #line 7129 
  unsigned int tmp_16;
  #line 7129 
  unsigned int tmp_17;
  #line 7129 
  unsigned int tmp_18;
  #line 7129 
  unsigned int tmp_19;
  #line 7129 
  unsigned int tmp_20;
  #line 7129 
  unsigned int tmp_21;
  #line 7129 
  unsigned int tmp_22;
  #line 7129 
  unsigned int tmp_23;
  #line 7129 
  unsigned int tmp_24;
  #line 7129 
  unsigned int tmp_25;
  #line 7129 
  unsigned int tmp_26;
  #line 7129 
  unsigned int tmp_27;
  #line 7129 
  unsigned int tmp_28;
  #line 7129 
  unsigned int tmp_29;
  #line 7129 
  unsigned int tmp_30;
  #line 7129 
  unsigned int tmp_31;
  #line 7129 
  unsigned int tmp_32;
  #line 7129 
  unsigned int tmp_33;
  #line 7129 
  unsigned int tmp_34;
  #line 7129 
  unsigned int tmp_35;
  #line 7129 
  unsigned int tmp_36;
  #line 7129 
  unsigned int tmp_37;
  #line 7129 
  unsigned int tmp_38;
  #line 7129 
  unsigned int tmp_39;
  #line 7129 
  unsigned int tmp_40;
  #line 7129 
  unsigned int tmp_41;
  #line 7129 
  unsigned int tmp_42;
  #line 7129 
  unsigned int tmp_43;
  #line 7129 
  unsigned int tmp_44;
  #line 7129 
  unsigned int tmp_45;
  #line 7129 
  unsigned int tmp_46;
  #line 7129 
  unsigned int tmp_47;
  #line 7129 
  unsigned int tmp_48;
  #line 7129 
  unsigned int tmp_49;
  #line 7129 
  unsigned int tmp_50;
  #line 7129 
  unsigned int tmp_51;
  #line 7129 
  unsigned int tmp_52;
  #line 7129 
  unsigned int tmp_53;
  #line 7129 
  unsigned int tmp_54;
  #line 7129 
  unsigned int tmp_55;
  #line 7129 
  unsigned int tmp_56;
  #line 7129 
  unsigned int tmp_57;
  #line 7129 
  unsigned int tmp_58;
  #line 7117 
  struct i40e_vsi_context ctxt;
  #line 7118 
  u16 sections;
  #line 7118 
  u16 qmap;
  #line 7118 
  u16 num_qps;
  #line 7119 
  struct i40e_channel *ch;
  #line 7120 
  int i;
  #line 7120 
  int pow;
  #line 7129 
  unsigned int tmp_66;
  #line 7115 
  struct i40e_pf *pf = vsi->back;
  #line 7116 
  struct i40e_hw *hw = & pf->hw;
  #line 7120 
  int ret = 0;
  #line 7121 
  u8 offset = (unsigned char)0U;
  #line 7123 
  if (vsi->type != (unsigned int)I40E_VSI_MAIN || (unsigned int)macvlan_cnt == 0U) 
    #line 7124 
    return -22;
  #line 7126 
  num_qps = (unsigned short)((int)vsi->num_queue_pairs - (int)macvlan_cnt * (int)qcnt);
  #line 7129 
  if (0 != 0) {
    #line 7129 
    if ((unsigned int)num_qps != 1U) {
      #line 7129 
      if (0 != 0) {
        #line 7129 
        if ((unsigned int)num_qps > 2U) {
          #line 7129 
          if (((unsigned long long)((int)num_qps + -1) & 9223372036854775808ULL) == 0ULL) {
            #line 7129 
            if (((unsigned long long)((int)num_qps + -1) & 4611686018427387904ULL) == 0ULL) {
              #line 7129 
              if (((unsigned long long)((int)num_qps + -1) & 2305843009213693952ULL) == 0ULL) {
                #line 7129 
                if (((unsigned long long)((int)num_qps + -1) & 1152921504606846976ULL) == 0ULL) {
                  #line 7129 
                  if (((unsigned long long)((int)num_qps + -1) & 576460752303423488ULL) == 0ULL) {
                    #line 7129 
                    if (((unsigned long long)((int)num_qps + -1) & 288230376151711744ULL) == 0ULL) {
                      #line 7129 
                      if (((unsigned long long)((int)num_qps + -1) & 144115188075855872ULL) == 0ULL) {
                        #line 7129 
                        if (((unsigned long long)((int)num_qps + -1) & 72057594037927936ULL) == 0ULL) {
                          #line 7129 
                          if (((unsigned long long)((int)num_qps + -1) & 36028797018963968ULL) == 0ULL) {
                            #line 7129 
                            if (((unsigned long long)((int)num_qps + -1) & 18014398509481984ULL) == 0ULL) {
                              #line 7129 
                              if (((unsigned long long)((int)num_qps + -1) & 9007199254740992ULL) == 0ULL) {
                                #line 7129 
                                if (((unsigned long long)((int)num_qps + -1) & 4503599627370496ULL) == 0ULL) {
                                  #line 7129 
                                  if (((unsigned long long)((int)num_qps + -1) & 2251799813685248ULL) == 0ULL) {
                                    #line 7129 
                                    if (((unsigned long long)((int)num_qps + -1) & 1125899906842624ULL) == 0ULL) {
                                      #line 7129 
                                      if (((unsigned long long)((int)num_qps + -1) & 562949953421312ULL) == 0ULL) {
                                        #line 7129 
                                        if (((unsigned long long)((int)num_qps + -1) & 281474976710656ULL) == 0ULL) {
                                          #line 7129 
                                          if (((unsigned long long)((int)num_qps + -1) & 140737488355328ULL) == 0ULL) {
                                            #line 7129 
                                            if (((unsigned long long)((int)num_qps + -1) & 70368744177664ULL) == 0ULL) {
                                              #line 7129 
                                              if (((unsigned long long)((int)num_qps + -1) & 35184372088832ULL) == 0ULL) {
                                                #line 7129 
                                                if (((unsigned long long)((int)num_qps + -1) & 17592186044416ULL) == 0ULL) {
                                                  #line 7129 
                                                  if (((unsigned long long)((int)num_qps + -1) & 8796093022208ULL) == 0ULL) {
                                                    #line 7129 
                                                    if (((unsigned long long)((int)num_qps + -1) & 4398046511104ULL) == 0ULL) {
                                                      #line 7129 
                                                      if (((unsigned long long)((int)num_qps + -1) & 2199023255552ULL) == 0ULL) {
                                                        #line 7129 
                                                        if (((unsigned long long)((int)num_qps + -1) & 1099511627776ULL) == 0ULL) {
                                                          #line 7129 
                                                          if (((unsigned long long)((int)num_qps + -1) & 549755813888ULL) == 0ULL) {
                                                            #line 7129 
                                                            if (((unsigned long long)((int)num_qps + -1) & 274877906944ULL) == 0ULL) {
                                                              #line 7129 
                                                              if (((unsigned long long)((int)num_qps + -1) & 137438953472ULL) == 0ULL) {
                                                                #line 7129 
                                                                if (((unsigned long long)((int)num_qps + -1) & 68719476736ULL) == 0ULL) {
                                                                  #line 7129 
                                                                  if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 34359738368ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 17179869184ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 8589934592ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 4294967296ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 2147483648ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 1073741824ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 536870912ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 268435456ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 134217728ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 67108864ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 33554432ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 16777216ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 8388608ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 4194304ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 2097152ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 1048576ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 524288ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 262144ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 131072ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 65536ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 32768ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 16384ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 8192ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 4096ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 2048ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 1024ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 512ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 256ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 128ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 64ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 32ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 16ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 8ULL) == 0ULL) {
                                                                    #line 7129 
                                                                    if (
                                                                    ((unsigned long long)((int)num_qps + -1) & 4ULL) != 0ULL) 
                                                                    #line 7129 
                                                                    tmp = 7U; else 
                                                                    #line 7129 
                                                                    tmp = 3U;
                                                                    #line 7129 
                                                                    tmp_0 = tmp;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_0 = 15U;
                                                                    #line 7129 
                                                                    tmp_1 = tmp_0;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_1 = 31U;
                                                                    #line 7129 
                                                                    tmp_2 = tmp_1;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_2 = 63U;
                                                                    #line 7129 
                                                                    tmp_3 = tmp_2;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_3 = 127U;
                                                                    #line 7129 
                                                                    tmp_4 = tmp_3;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_4 = 255U;
                                                                    #line 7129 
                                                                    tmp_5 = tmp_4;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_5 = 511U;
                                                                    #line 7129 
                                                                    tmp_6 = tmp_5;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_6 = 1023U;
                                                                    #line 7129 
                                                                    tmp_7 = tmp_6;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_7 = 2047U;
                                                                    #line 7129 
                                                                    tmp_8 = tmp_7;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_8 = 4095U;
                                                                    #line 7129 
                                                                    tmp_9 = tmp_8;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_9 = 8191U;
                                                                    #line 7129 
                                                                    tmp_10 = tmp_9;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_10 = 16383U;
                                                                    #line 7129 
                                                                    tmp_11 = tmp_10;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_11 = 32767U;
                                                                    #line 7129 
                                                                    tmp_12 = tmp_11;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_12 = 65535U;
                                                                    #line 7129 
                                                                    tmp_13 = tmp_12;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_13 = 131071U;
                                                                    #line 7129 
                                                                    tmp_14 = tmp_13;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_14 = 262143U;
                                                                    #line 7129 
                                                                    tmp_15 = tmp_14;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_15 = 524287U;
                                                                    #line 7129 
                                                                    tmp_16 = tmp_15;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_16 = 1048575U;
                                                                    #line 7129 
                                                                    tmp_17 = tmp_16;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_17 = 2097151U;
                                                                    #line 7129 
                                                                    tmp_18 = tmp_17;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_18 = 4194303U;
                                                                    #line 7129 
                                                                    tmp_19 = tmp_18;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_19 = 8388607U;
                                                                    #line 7129 
                                                                    tmp_20 = tmp_19;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_20 = 16777215U;
                                                                    #line 7129 
                                                                    tmp_21 = tmp_20;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_21 = 33554431U;
                                                                    #line 7129 
                                                                    tmp_22 = tmp_21;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_22 = 67108863U;
                                                                    #line 7129 
                                                                    tmp_23 = tmp_22;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_23 = 134217727U;
                                                                    #line 7129 
                                                                    tmp_24 = tmp_23;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_24 = 268435455U;
                                                                    #line 7129 
                                                                    tmp_25 = tmp_24;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_25 = 536870911U;
                                                                    #line 7129 
                                                                    tmp_26 = tmp_25;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_26 = 1073741823U;
                                                                    #line 7129 
                                                                    tmp_27 = tmp_26;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_27 = 2147483647U;
                                                                    #line 7129 
                                                                    tmp_28 = tmp_27;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_28 = 4294967295U;
                                                                    #line 7129 
                                                                    tmp_29 = tmp_28;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_29 = 4294967295U;
                                                                    #line 7129 
                                                                    tmp_30 = tmp_29;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_30 = 4294967295U;
                                                                    #line 7129 
                                                                    tmp_31 = tmp_30;
                                                                    }
                                                                    else 
                                                                    #line 7129 
                                                                    tmp_31 = 4294967295U;
                                                                    #line 7129 
                                                                    tmp_32 = tmp_31;
                                                                  }
                                                                  else 
                                                                    #line 7129 
                                                                    tmp_32 = 4294967295U;
                                                                  #line 7129 
                                                                  tmp_33 = tmp_32;
                                                                }
                                                                else 
                                                                  #line 7129 
                                                                  tmp_33 = 4294967295U;
                                                                #line 7129 
                                                                tmp_34 = tmp_33;
                                                              }
                                                              else 
                                                                   #line 7129 
                                                                   tmp_34 = 4294967295U;
                                                              #line 7129 
                                                              tmp_35 = tmp_34;
                                                            }
                                                            else 
                                                                 #line 7129 
                                                                 tmp_35 = 4294967295U;
                                                            #line 7129 
                                                            tmp_36 = tmp_35;
                                                          }
                                                          else 
                                                               #line 7129 
                                                               tmp_36 = 4294967295U;
                                                          #line 7129 
                                                          tmp_37 = tmp_36;
                                                        }
                                                        else 
                                                             #line 7129 
                                                             tmp_37 = 4294967295U;
                                                        #line 7129 
                                                        tmp_38 = tmp_37;
                                                      }
                                                      else 
                                                           #line 7129 
                                                           tmp_38 = 4294967295U;
                                                      #line 7129 
                                                      tmp_39 = tmp_38;
                                                    }
                                                    else 
                                                         #line 7129 
                                                         tmp_39 = 4294967295U;
                                                    #line 7129 
                                                    tmp_40 = tmp_39;
                                                  }
                                                  else 
                                                       #line 7129 
                                                       tmp_40 = 4294967295U;
                                                  #line 7129 
                                                  tmp_41 = tmp_40;
                                                }
                                                else 
                                                     #line 7129 
                                                     tmp_41 = 4294967295U;
                                                #line 7129 
                                                tmp_42 = tmp_41;
                                              }
                                              else 
                                                   #line 7129 
                                                   tmp_42 = 4294967295U;
                                              #line 7129 
                                              tmp_43 = tmp_42;
                                            }
                                            else 
                                                 #line 7129 
                                                 tmp_43 = 4294967295U;
                                            #line 7129 
                                            tmp_44 = tmp_43;
                                          }
                                          else 
                                               #line 7129 
                                               tmp_44 = 4294967295U;
                                          #line 7129 
                                          tmp_45 = tmp_44;
                                        }
                                        else 
                                             #line 7129 
                                             tmp_45 = 4294967295U;
                                        #line 7129 
                                        tmp_46 = tmp_45;
                                      }
                                      else 
                                           #line 7129 
                                           tmp_46 = 4294967295U;
                                      #line 7129 
                                      tmp_47 = tmp_46;
                                    }
                                    else 
                                         #line 7129 
                                         tmp_47 = 4294967295U;
                                    #line 7129 
                                    tmp_48 = tmp_47;
                                  }
                                  else 
                                       #line 7129 
                                       tmp_48 = 4294967295U;
                                  #line 7129 
                                  tmp_49 = tmp_48;
                                }
                                else 
                                     #line 7129 
                                     tmp_49 = 4294967295U;
                                #line 7129 
                                tmp_50 = tmp_49;
                              }
                              else 
                                   #line 7129 
                                   tmp_50 = 4294967295U;
                              #line 7129 
                              tmp_51 = tmp_50;
                            }
                            else 
                                 #line 7129 
                                 tmp_51 = 4294967295U;
                            #line 7129 
                            tmp_52 = tmp_51;
                          }
                          else 
                               #line 7129 
                               tmp_52 = 4294967295U;
                          #line 7129 
                          tmp_53 = tmp_52;
                        }
                        else 
                             #line 7129 
                             tmp_53 = 4294967295U;
                        #line 7129 
                        tmp_54 = tmp_53;
                      }
                      else 
                           #line 7129 
                           tmp_54 = 4294967295U;
                      #line 7129 
                      tmp_55 = tmp_54;
                    }
                    else 
                         #line 7129 
                         tmp_55 = 4294967295U;
                    #line 7129 
                    tmp_56 = tmp_55;
                  }
                  else 
                       #line 7129 
                       tmp_56 = 4294967295U;
                  #line 7129 
                  tmp_57 = tmp_56;
                }
                else 
                     #line 7129 
                     tmp_57 = 4294967295U;
                #line 7129 
                tmp_58 = tmp_57;
              }
              else 
                   #line 7129 
                   tmp_58 = 4294967295U;
              #line 7129 
              tmp_59 = tmp_58;
            }
            else 
                 #line 7129 
                 tmp_59 = 4294967295U;
            #line 7129 
            tmp_60 = tmp_59;
          }
          else 
               #line 7129 
               tmp_60 = 4294967295U;
          #line 7129 
          tmp_61 = tmp_60;
        }
        else 
             #line 7129 
             tmp_61 = 1U;
        #line 7129 
        tmp_63 = tmp_61;
      }
      else {
        #line 7129 
        tmp_63 = (unsigned int)(1UL << (__ilog2_u32((unsigned int)((int)num_qps + -1)) + 1)) + 4294967295U;
      }
      #line 7129 
      tmp_64 = tmp_63;
    }
    else 
         #line 7129 
         tmp_64 = 0U;
    #line 7129 
    tmp_66 = tmp_64;
  }
  else {
    #line 7129 
    tmp_66 = (unsigned int)__roundup_pow_of_two((unsigned long)num_qps) + 4294967295U;
  }
  #line 7129 
  pow = fls(tmp_66);
  #line 7131 
  qmap = (unsigned short)((int)offset | (pow << 9));
  #line 7135 
  sections = (unsigned short)64U;
  #line 7136 
  sections = (unsigned short)((unsigned int)sections | 512U);
  #line 7137 
  memset((void *)(& ctxt),0,144UL);
  #line 7138 
  ctxt.seid = vsi->seid;
  #line 7139 
  ctxt.pf_num = (vsi->back)->hw.pf_id;
  #line 7140 
  ctxt.vf_num = (unsigned char)0U;
  #line 7141 
  ctxt.uplink_seid = vsi->uplink_seid;
  #line 7142 
  ctxt.info = vsi->info;
  #line 7143 
  ctxt.info.tc_mapping[0] = qmap;
  #line 7144 
  ctxt.info.mapping_flags = ctxt.info.mapping_flags;
  #line 7145 
  ctxt.info.queue_mapping[0] = vsi->base_queue;
  #line 7146 
  ctxt.info.valid_sections = (unsigned short)((int)ctxt.info.valid_sections | (int)sections);
  {
    #line 7149 
    __UNIQUE_ID___x615 = num_qps;
    #line 7149 
    unsigned short __UNIQUE_ID___y616 = qcnt;
    #line 7149 
    if ((int)__UNIQUE_ID___x615 > (int)__UNIQUE_ID___y616) 
                                                           #line 7149 
                                                           tmp_67 = (int)__UNIQUE_ID___x615; else 
                                                                    #line 7149 
                                                                    tmp_67 = (int)__UNIQUE_ID___y616;
    }
  #line 7149 
  vsi->rss_size = (unsigned short)tmp_67;
  #line 7150 
  ret = i40e_vsi_config_rss(vsi);
  #line 7151 
  if (ret != 0) {
    #line 7152 
    _dev_info(& (pf->pdev)->dev,(char *)"Failed to reconfig RSS for num_queues (%u)\n",(int)vsi->rss_size);
    #line 7155 
    return ret;
  }
  #line 7157 
  vsi->reconfig_rss = (_Bool)1;
  {
    #line 7158 
    bool branch;
    #line 7158 
    struct _ddebug __UNIQUE_ID_ddebug617 = {.modname = (char *)"i40e", .function = (char *)"i40e_setup_macvlans", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Reconfigured RSS with num_queues (%u)\n", .lineno = (unsigned int)7158U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 7158 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug617.key.dd_key_false.key,(_Bool)0);
    #line 7158 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 7158 
                                                __dynamic_dev_dbg(& __UNIQUE_ID_ddebug617,& ((vsi->back)->pdev)->dev,(char *)"Reconfigured RSS with num_queues (%u)\n",(int)vsi->rss_size);
  }
  #line 7160 
  vsi->next_base_queue = num_qps;
  #line 7161 
  vsi->cnt_q_avail = (unsigned short)((int)vsi->num_queue_pairs - (int)num_qps);
  #line 7166 
  ret = (int)i40e_aq_update_vsi_params(hw,& ctxt,
                                   (struct i40e_asq_cmd_details *)0);
  #line 7167 
  if (ret != 0) {
    #line 7168 
    ;
    #line 7168 
    _dev_info(& (pf->pdev)->dev,(char *)"Update vsi tc config failed, err %s aq_err %s\n",i40e_stat_str(hw,(enum i40e_status_code)ret),i40e_aq_str(hw,hw->aq.asq_last_status));
    #line 7172 
    return ret;
  }
  #line 7175 
  i40e_vsi_update_queue_map(vsi,& ctxt);
  #line 7176 
  vsi->info.valid_sections = (unsigned short)0U;
  #line 7179 
  INIT_LIST_HEAD(& vsi->macvlan_list);
  #line 7180 
  i = 0;
  #line 7180 
  while ((int)macvlan_cnt > i) {
    {
      #line 7181 
      ch = (struct i40e_channel *)kzalloc_1(184UL,3264U);
      #line 7182 
      if (ch == (struct i40e_channel *)0) {
        #line 7183 
        ret = -12;
        #line 7184 
        goto err_free;
      }
      #line 7186 
      INIT_LIST_HEAD(& ch->list);
      #line 7187 
      ch->num_queue_pairs = qcnt;
      #line 7188 
      if (! i40e_setup_channel(pf,vsi,ch)) {
        #line 7189 
        ret = -22;
        #line 7190 
        kfree((void *)ch);
        #line 7191 
        goto err_free;
      }
      #line 7193 
      ch->parent_vsi = vsi;
      #line 7194 
      vsi->cnt_q_avail = (unsigned short)((int)vsi->cnt_q_avail - (int)ch->num_queue_pairs);
      #line 7195 
      (vsi->macvlan_cnt) ++;
      #line 7196 
      list_add_tail(& ch->list,& vsi->macvlan_list);
    }
    #line 7180 
    i ++;
  }
  #line 7199 
  return ret;
  #line 7201 
  err_free: 
            #line 7201 
  ;
  #line 7202 
  _dev_info(& (pf->pdev)->dev,(char *)"Failed to setup macvlans\n");
  #line 7203 
  i40e_free_macvlan_channels(vsi);
  #line 7205 
  return ret;
}

#line 7213  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void *i40e_fwd_add(struct net_device *netdev, struct net_device *vdev)
{
  #line 7216 
  u16 vectors;
  #line 7219 
  struct i40e_fwd_adapter *fwd;
  #line 7220 
  int avail_macvlan;
  #line 7220 
  int ret;
  #line 7215 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 7216 
  u16 q_per_macvlan = (unsigned short)0U;
  #line 7216 
  u16 macvlan_cnt = (unsigned short)0U;
  #line 7217 
  struct i40e_vsi *vsi = np->vsi;
  #line 7218 
  struct i40e_pf *pf = vsi->back;
  #line 7222 
  if (((unsigned long)pf->flags & 128UL) != 0UL) {
    #line 7223 
    netdev_info(netdev,(char *)"Macvlans are not supported when DCB is enabled\n");
    #line 7224 
    return ERR_PTR_0(-22L);
  }
  #line 7226 
  if (((unsigned long)pf->flags & 2097152UL) != 0UL) {
    #line 7227 
    netdev_info(netdev,(char *)"Macvlans are not supported when HW TC offload is on\n");
    #line 7228 
    return ERR_PTR_0(-22L);
  }
  #line 7230 
  if ((unsigned int)pf->num_lan_msix <= 1U) {
    #line 7231 
    netdev_info(netdev,(char *)"Not enough vectors available to support macvlans\n");
    #line 7232 
    return ERR_PTR_0(-22L);
  }
  #line 7238 
  if ((int)netif_is_multiqueue(vdev) != 0) {
    #line 7239 
    return ERR_PTR_0(-34L);
  }
  #line 7241 
  if (vsi->macvlan_cnt == 0) {
    #line 7243 
    cif_set_bit_1(0L,(unsigned long *)(& vsi->fwd_bitmask));
    #line 7249 
    vectors = pf->num_lan_msix;
    #line 7250 
    if ((unsigned int)vectors + 65471U <= 63U) {
      #line 7252 
      q_per_macvlan = (unsigned short)4U;
      #line 7253 
      macvlan_cnt = (unsigned short)(((int)vectors + -32) / 4);
    }
    else 
      #line 7254 
      if ((unsigned int)vectors + 65503U <= 31U) {
        #line 7256 
        q_per_macvlan = (unsigned short)2U;
        #line 7257 
        macvlan_cnt = (unsigned short)(((int)vectors + -16) / 2);
      }
      else 
        #line 7258 
        if ((unsigned int)vectors + 65519U <= 15U) {
          #line 7260 
          q_per_macvlan = (unsigned short)1U;
          #line 7261 
          macvlan_cnt = (unsigned short)((unsigned int)vectors + 65520U);
        }
        else 
          #line 7262 
          if ((unsigned int)vectors + 65527U <= 7U) {
            #line 7264 
            q_per_macvlan = (unsigned short)1U;
            #line 7265 
            macvlan_cnt = (unsigned short)((unsigned int)vectors + 65528U);
          }
          else {
            #line 7268 
            q_per_macvlan = (unsigned short)1U;
            #line 7269 
            macvlan_cnt = (unsigned short)((unsigned int)vectors + 65535U);
          }
    #line 7272 
    if ((unsigned int)macvlan_cnt == 0U) {
      #line 7273 
      return ERR_PTR_0(-16L);
    }
    #line 7276 
    i40e_quiesce_vsi(vsi);
    #line 7279 
    ret = i40e_setup_macvlans(vsi,(unsigned short)((int)macvlan_cnt),(unsigned short)((int)q_per_macvlan),vdev);
    #line 7281 
    if (ret != 0) {
      #line 7282 
      return ERR_PTR_0((long)ret);
    }
    #line 7285 
    i40e_unquiesce_vsi(vsi);
  }
  #line 7287 
  avail_macvlan = (int)find_first_zero_bit((unsigned long *)(& vsi->fwd_bitmask),
                            (unsigned long)vsi->macvlan_cnt);
  #line 7289 
  if (avail_macvlan > 127) {
    #line 7290 
    return ERR_PTR_0(-16L);
  }
  #line 7293 
  fwd = (struct i40e_fwd_adapter *)kzalloc_1(16UL,3264U);
  #line 7294 
  if (fwd == (struct i40e_fwd_adapter *)0) {
    #line 7295 
    return ERR_PTR_0(-12L);
  }
  #line 7297 
  cif_set_bit_1((long)avail_macvlan,(unsigned long *)(& vsi->fwd_bitmask));
  #line 7298 
  fwd->bit_no = avail_macvlan;
  #line 7299 
  netdev_set_sb_channel(vdev,(unsigned short)((int)((unsigned short)avail_macvlan)));
  #line 7300 
  fwd->netdev = vdev;
  #line 7302 
  if (! netif_running(netdev)) 
                               #line 7303 
                               return (void *)fwd;
  #line 7306 
  ret = i40e_fwd_ring_up(vsi,vdev,fwd);
  #line 7307 
  if (ret != 0) {
    #line 7309 
    netdev_unbind_sb_channel(netdev,vdev);
    #line 7310 
    netdev_set_sb_channel(vdev,(unsigned short)0);
    #line 7312 
    kfree((void *)fwd);
    #line 7313 
    return ERR_PTR_0(-22L);
  }
  #line 7316 
  return (void *)fwd;
}

#line 7323  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_del_all_macvlans(struct i40e_vsi *vsi)
{
  #line 7333 
  void *__mptr;
  #line 7333 
  void *__mptr_0;
  #line 7325 
  struct i40e_channel *ch;
  #line 7325 
  struct i40e_channel *ch_tmp;
  #line 7328 
  int aq_err;
  #line 7326 
  struct i40e_pf *pf = vsi->back;
  #line 7327 
  struct i40e_hw *hw = & pf->hw;
  #line 7328 
  int ret = 0;
  #line 7330 
  if (list_empty(& vsi->macvlan_list) != 0) 
                                            #line 7331 
                                            return;
  #line 7333 
  __mptr = (void *)vsi->macvlan_list.next;
  #line 7333 
  ch = ((struct i40e_channel *)__mptr);
  #line 7333 
  __mptr_0 = (void *)ch->list.next;
  #line 7334 
  ch_tmp = ((struct i40e_channel *)__mptr_0);
  #line 7333 
  while (& ch->list != & vsi->macvlan_list) {
    #line 7333 
    void *__mptr_1;
    #line 7334 
    if ((int)i40e_is_channel_macvlan(ch) != 0) {
      #line 7335 
      ;
      #line 7335 
      ;
      #line 7335 
      ret = (int)i40e_del_macvlan_filter(hw,(unsigned short)((int)ch->seid),
                                i40e_channel_mac(ch),& aq_err);
      #line 7338 
      if (ret == 0) {
        #line 7340 
        i40e_reset_ch_rings(vsi,ch);
        #line 7341 
        cif_clear_bit_1((long)(ch->fwd)->bit_no,(unsigned long *)(& vsi->fwd_bitmask));
        #line 7342 
        netdev_unbind_sb_channel(vsi->netdev,(ch->fwd)->netdev);
        #line 7344 
        netdev_set_sb_channel((ch->fwd)->netdev,(unsigned short)0);
        #line 7345 
        kfree((void *)ch->fwd);
        #line 7346 
        ch->fwd = (struct i40e_fwd_adapter *)0;
      }
    }
    #line 7333 
    ch = ch_tmp;
    #line 7333 
    __mptr_1 = (void *)ch_tmp->list.next;
    #line 7333 
    ch_tmp = ((struct i40e_channel *)__mptr_1);
  }
  #line 7349 
  return;
}

#line 7357  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_fwd_del(struct net_device *netdev, void *vdev)
{
  #line 7368 
  void *__mptr_0;
  #line 7368 
  void *__mptr;
  #line 7361 
  struct i40e_channel *ch;
  #line 7361 
  struct i40e_channel *ch_tmp;
  #line 7365 
  int aq_err;
  #line 7359 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 7360 
  struct i40e_fwd_adapter *fwd = (struct i40e_fwd_adapter *)vdev;
  #line 7362 
  struct i40e_vsi *vsi = np->vsi;
  #line 7363 
  struct i40e_pf *pf = vsi->back;
  #line 7364 
  struct i40e_hw *hw = & pf->hw;
  #line 7365 
  int ret = 0;
  #line 7368 
  __mptr = (void *)vsi->macvlan_list.next;
  #line 7368 
  ch = ((struct i40e_channel *)__mptr);
  #line 7368 
  __mptr_0 = (void *)ch->list.next;
  #line 7369 
  ch_tmp = ((struct i40e_channel *)__mptr_0);
  #line 7368 
  while (& ch->list != & vsi->macvlan_list) {
    #line 7368 
    void *__mptr_1;
    #line 7369 
    if ((int)i40e_is_channel_macvlan(ch) != 0) {
      #line 7369 
      ;
      #line 7369 
      if ((int)ether_addr_equal(i40e_channel_mac(ch),(fwd->netdev)->dev_addr) != 0) {
        #line 7372 
        ;
        #line 7372 
        ;
        #line 7372 
        ret = (int)i40e_del_macvlan_filter(hw,(unsigned short)((int)ch->seid),
                                i40e_channel_mac(ch),& aq_err);
        #line 7375 
        if (ret == 0) {
          #line 7377 
          i40e_reset_ch_rings(vsi,ch);
          #line 7378 
          cif_clear_bit_1((long)(ch->fwd)->bit_no,(unsigned long *)(& vsi->fwd_bitmask));
          #line 7379 
          netdev_unbind_sb_channel(netdev,fwd->netdev);
          #line 7380 
          netdev_set_sb_channel(fwd->netdev,(unsigned short)0);
          #line 7381 
          kfree((void *)ch->fwd);
          #line 7382 
          ch->fwd = (struct i40e_fwd_adapter *)0;
        }
        else {
          #line 7384 
          ;
          #line 7384 
          _dev_info(& (pf->pdev)->dev,(char *)"Error deleting mac filter on macvlan err %s, aq_err %s\n",i40e_stat_str(hw,(enum i40e_status_code)ret),i40e_aq_str(hw,(enum i40e_admin_queue_err)aq_err));
        }
        #line 7389 
        break;
      }
    }
    #line 7368 
    ch = ch_tmp;
    #line 7368 
    __mptr_1 = (void *)ch_tmp->list.next;
    #line 7368 
    ch_tmp = ((struct i40e_channel *)__mptr_1);
  }
  #line 7391 
  return;
}

#line 7399  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_setup_tc(struct net_device *netdev, void *type_data)
{
  #line 7405 
  u8 num_tc;
  #line 7405 
  u8 hw;
  #line 7407 
  int old_queue_pairs;
  #line 7409 
  u16 mode;
  #line 7410 
  int i;
  #line 7401 
  struct tc_mqprio_qopt_offload *mqprio_qopt = (struct tc_mqprio_qopt_offload *)type_data;
  #line 7402 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 7403 
  struct i40e_vsi *vsi = np->vsi;
  #line 7404 
  struct i40e_pf *pf = vsi->back;
  #line 7405 
  u8 enabled_tc = (unsigned char)0U;
  #line 7406 
  bool need_reset = (_Bool)0;
  #line 7408 
  int ret = -22;
  #line 7412 
  old_queue_pairs = (int)vsi->num_queue_pairs;
  #line 7413 
  num_tc = mqprio_qopt->qopt.num_tc;
  #line 7414 
  hw = mqprio_qopt->qopt.hw;
  #line 7415 
  mode = mqprio_qopt->mode;
  #line 7416 
  if ((unsigned int)hw == 0U) {
    #line 7417 
    pf->flags &= 4292870143U;
    #line 7418 
    memcpy((void *)(& vsi->mqprio_qopt),(void *)mqprio_qopt,352UL);
    #line 7419 
    goto config_tc;
  }
  #line 7423 
  if (((unsigned long)pf->flags & 1024UL) != 0UL) {
    #line 7424 
    netdev_info(netdev,(char *)"Configuring TC not supported in MFP mode\n");
    #line 7426 
    return ret;
  }
  #line 7428 
  switch ((int)mode) {
    #line 7429 
    case 0: 
            #line 7429 
    ;
    #line 7430 
    pf->flags &= 4292870143U;
    #line 7433 
    if (((unsigned long)pf->flags & 128UL) == 0UL) {
      #line 7434 
      netdev_info(netdev,(char *)"DCB is not enabled for adapter\n");
      #line 7436 
      return ret;
    }
    #line 7440 
    ;
    #line 7440 
    if ((int)i40e_pf_get_num_tc(pf) < (int)num_tc) {
      #line 7441 
      netdev_info(netdev,(char *)"TC count greater than enabled on link for adapter\n");
      #line 7443 
      return ret;
    }
    #line 7445 
    break;
    #line 7446 
    case 1: 
            #line 7446 
    ;
    #line 7447 
    if (((unsigned long)pf->flags & 128UL) != 0UL) {
      #line 7448 
      netdev_info(netdev,(char *)"Full offload of TC Mqprio options is not supported when DCB is enabled\n");
      #line 7450 
      return ret;
    }
    #line 7452 
    if (((unsigned long)pf->flags & 4UL) == 0UL) 
                                                 #line 7453 
                                                 return ret;
    #line 7454 
    ret = i40e_validate_mqprio_qopt(vsi,mqprio_qopt);
    #line 7455 
    if (ret != 0) 
                  #line 7456 
                  return ret;
    #line 7457 
    memcpy((void *)(& vsi->mqprio_qopt),(void *)mqprio_qopt,352UL);
    #line 7459 
    pf->flags |= 2097152U;
    #line 7460 
    pf->flags &= 4294967167U;
    #line 7461 
    break;
    #line 7462 
    default: 
             #line 7462 
    ;
    #line 7463 
    return -22;
  }
  #line 7466 
  config_tc: 
             #line 7466 
  ;
  #line 7468 
  i = 0;
  #line 7468 
  while ((int)num_tc > i) {
    #line 7469 
    enabled_tc = (unsigned char)((int)((unsigned char)(1UL << i)) | (int)enabled_tc);
    #line 7468 
    i ++;
  }
  #line 7472 
  if ((int)vsi->tc_config.enabled_tc == (int)enabled_tc && (unsigned int)mode != 1U) 
    #line 7474 
    return 0;
  #line 7477 
  i40e_quiesce_vsi(vsi);
  #line 7479 
  if ((unsigned int)hw == 0U && ((unsigned long)pf->flags & 2097152UL) == 0UL) 
    #line 7480 
    i40e_remove_queue_channels(vsi);
  #line 7483 
  ret = i40e_vsi_config_tc(vsi,(unsigned char)((int)enabled_tc));
  #line 7484 
  if (ret != 0) {
    #line 7485 
    netdev_info(netdev,(char *)"Failed configuring TC for VSI seid=%d\n",(int)vsi->seid);
    #line 7487 
    need_reset = (_Bool)1;
    #line 7488 
    goto exit;
  }
  else 
       #line 7490 
       _dev_info(& ((vsi->back)->pdev)->dev,(char *)"Setup channel (id:%u) utilizing num_queues %d\n",(int)vsi->seid,(int)vsi->tc_config.tc_info[0].qcount);
  #line 7495 
  if (((unsigned long)pf->flags & 2097152UL) != 0UL) {
    #line 7496 
    if (vsi->mqprio_qopt.max_rate[0] != 0ULL) {
      #line 7497 
      u64 max_tx_rate = vsi->mqprio_qopt.max_rate[0];
      {
        #line 7499 
        uint32_t __rem;
        #line 7499 
        uint32_t __base = 125000U;
        #line 7499 
        __rem = (unsigned int)(max_tx_rate % (unsigned long long)__base);
        #line 7499 
        max_tx_rate /= (unsigned long long)__base;
        #line 7499 
        uint32_t tmp_2 = __rem;
      }
      #line 7500 
      ret = i40e_set_bw_limit(vsi,(unsigned short)((int)vsi->seid),max_tx_rate);
      #line 7501 
      if (ret == 0) {
        #line 7502 
        u64 credits = max_tx_rate;
        {
          #line 7504 
          uint32_t __rem_0;
          #line 7504 
          uint32_t __base_0 = 50U;
          #line 7504 
          __rem_0 = (unsigned int)(credits % (unsigned long long)__base_0);
          #line 7504 
          credits /= (unsigned long long)__base_0;
          #line 7504 
          uint32_t tmp_4 = __rem_0;
        }
        {
          #line 7505 
          bool branch;
          #line 7505 
          struct _ddebug __UNIQUE_ID_ddebug618 = {.modname = (char *)"i40e", .function = (char *)"i40e_setup_tc", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Set tx rate of %llu Mbps (count of 50Mbps %llu) for vsi->seid %u\n", .lineno = (unsigned int)7505U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 7505 
          branch = arch_static_branch(& __UNIQUE_ID_ddebug618.key.dd_key_false.key,(_Bool)0);
          #line 7505 
          if ((long)((long)((int)branch != 0)) != 0L) 
                                                      #line 7505 
                                                      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug618,& ((vsi->back)->pdev)->dev,(char *)"Set tx rate of %llu Mbps (count of 50Mbps %llu) for vsi->seid %u\n",max_tx_rate,credits,(int)vsi->seid);
        }
      }
      else {
        #line 7511 
        need_reset = (_Bool)1;
        #line 7512 
        goto exit;
      }
    }
    #line 7515 
    ret = i40e_configure_queue_channels(vsi);
    #line 7516 
    if (ret != 0) {
      #line 7517 
      vsi->num_queue_pairs = (unsigned short)old_queue_pairs;
      #line 7518 
      netdev_info(netdev,(char *)"Failed configuring queue channels\n");
      #line 7520 
      need_reset = (_Bool)1;
      #line 7521 
      goto exit;
    }
  }
  #line 7525 
  exit: 
        #line 7525 
  ;
  #line 7527 
  if ((int)need_reset != 0) {
    #line 7528 
    i40e_vsi_set_default_tc_config(vsi);
    #line 7529 
    need_reset = (_Bool)0;
  }
  #line 7533 
  i40e_unquiesce_vsi(vsi);
  #line 7534 
  return ret;
}

#line 7545  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
__inline static void i40e_set_cld_element(struct i40e_cloud_filter *filter, struct i40e_aqc_cloud_filters_element_data *cld)
{
  #line 7548 
  int i;
  #line 7548 
  int j;
  #line 7549 
  u32 ipa;
  #line 7551 
  memset((void *)cld,0,64UL);
  #line 7552 
  ether_addr_copy((u8 *)(& cld->outer_mac),(u8 *)(& filter->dst_mac));
  #line 7553 
  ether_addr_copy((u8 *)(& cld->inner_mac),(u8 *)(& filter->src_mac));
  #line 7555 
  if ((unsigned int)filter->n_proto != 2048U && (unsigned int)filter->n_proto != 34525U) 
    #line 7556 
    return;
  #line 7558 
  if ((unsigned int)filter->n_proto == 34525U) {
    #line 7560 
    i = 0;
    #line 7560 
    j = 0;
    #line 7560 
    while ((unsigned int)i <= 3U) {
      #line 7562 
      ipa = __builtin_bswap32(filter->ip.v6.dst_ip6.in6_u.u6_addr32[3UL - (unsigned long)i]);
      #line 7563 
      ipa = ipa;
      #line 7564 
      memcpy((void *)(& cld->ipaddr.raw_v6.data[j]),(void *)(& ipa),4UL);
      #line 7560 
      i ++;
      #line 7561 
      j += 2;
    }
  }
  else {
    #line 7567 
    ipa = __builtin_bswap32(filter->ip.v4.dst_ip.s_addr);
    #line 7568 
    memcpy((void *)(& cld->ipaddr.v4.data),(void *)(& ipa),4UL);
  }
  #line 7571 
  cld->inner_vlan = __builtin_bswap16((unsigned short)((int)filter->vlan_id));
  #line 7576 
  if (filter->tenant_id != 0U) 
                               #line 7577 
                               return;
  #line 7578 
  return;
}

#line 7589  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_add_del_cloud_filter(struct i40e_vsi *vsi, struct i40e_cloud_filter *filter, bool add)
{
  #line 7592 
  struct i40e_aqc_cloud_filters_element_data cld_filter;
  #line 7594 
  int ret;
  #line 7593 
  struct i40e_pf *pf = vsi->back;
  #line 7595 
  u16 flag_table[128U] = {[1] = (unsigned short)9U, (unsigned short)10U, [6] = (unsigned short)3U, [10] = (unsigned short)6U, (unsigned short)11U, [14] = (unsigned short)4U, [16] = (unsigned short)12U};
  #line 7612 
  if ((int)filter->flags < 0) 
                              #line 7613 
                              return -4;
  #line 7616 
  i40e_set_cld_element(filter,& cld_filter);
  #line 7618 
  if ((unsigned int)filter->tunnel_type != 255U) 
                                                 #line 7619 
                                                 cld_filter.flags = (unsigned short)((int)((unsigned short)filter->tunnel_type) << 9U);
  #line 7622 
  if ((unsigned int)filter->n_proto == 34525U) 
                                               #line 7623 
                                               cld_filter.flags = (unsigned short)((unsigned int)((int)cld_filter.flags | (int)flag_table[(int)filter->flags]) | 256U); else 
                                                                    #line 7626 
                                                                    cld_filter.flags = (unsigned short)((int)cld_filter.flags | (int)flag_table[(int)filter->flags]);
  #line 7629 
  if ((int)add != 0) {
    #line 7630 
    ret = (int)i40e_aq_add_cloud_filters(& pf->hw,(unsigned short)((int)filter->seid),
                                & cld_filter,(unsigned char)1);
  }
  else {
    #line 7633 
    ret = (int)i40e_aq_rem_cloud_filters(& pf->hw,
                                  (unsigned short)((int)filter->seid),
                                  & cld_filter,(unsigned char)1);
  }
  #line 7635 
  if (ret != 0) {
    #line 7636 
    bool branch;
    #line 7636 
    struct _ddebug __UNIQUE_ID_ddebug619 = {.modname = (char *)"i40e", .function = (char *)"i40e_add_del_cloud_filter", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Failed to %s cloud filter using l4 port %u, err %d aq_err %d\n", .lineno = (unsigned int)7636U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 7636 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug619.key.dd_key_false.key,(_Bool)0);
    #line 7636 
    if ((long)((long)((int)branch != 0)) != 0L) {
      #line 7636 
      char *tmp_1;
      #line 7636 
      ;
      #line 7636 
      ;
      #line 7636 
      ;
      #line 7636 
      if ((int)add != 0) 
                         #line 7636 
                         tmp_1 = (char *)"add"; else 
                                                     #line 7636 
                                                     tmp_1 = (char *)"delete";
      #line 7636 
      ;
      #line 7636 
      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug619,& (pf->pdev)->dev,(char *)"Failed to %s cloud filter using l4 port %u, err %d aq_err %d\n",tmp_1,(int)filter->dst_port,ret,(unsigned int)pf->hw.aq.asq_last_status);
    }
  }
  else {
    #line 7641 
    char *tmp_3;
    #line 7641 
    ;
    #line 7641 
    if ((int)add != 0) 
                       #line 7641 
                       tmp_3 = (char *)"Added"; else 
                                                     #line 7641 
                                                     tmp_3 = (char *)"Deleted";
    #line 7641 
    ;
    #line 7641 
    _dev_info(& (pf->pdev)->dev,(char *)"%s cloud filter for VSI: %d\n",tmp_3,(int)filter->seid);
  }
  #line 7644 
  return ret;
}

#line 7656  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_add_del_cloud_filter_big_buf(struct i40e_vsi *vsi, struct i40e_cloud_filter *filter, bool add)
{
  #line 7660 
  struct i40e_aqc_cloud_filters_element_bb cld_filter;
  #line 7662 
  int ret;
  #line 7661 
  struct i40e_pf *pf = vsi->back;
  #line 7665 
  if ((int)is_valid_ether_addr((u8 *)(& filter->dst_mac)) != 0) {
    #line 7665 
    if ((int)is_valid_ether_addr((u8 *)(& filter->src_mac)) != 0) 
                                                                  #line 7669 
                                                                  return -95; else 
                                                                    #line 7665 
                                                                    goto _LAND;
  }
  else {
    #line 7665 
    _LAND: 
    #line 7666 
    if ((int)is_multicast_ether_addr((u8 *)(& filter->dst_mac)) != 0) {
      #line 7667 
      if ((int)is_multicast_ether_addr((u8 *)(& filter->src_mac)) != 0) 
        #line 7669 
        return -95;
    }
  }
  #line 7674 
  if ((unsigned int)filter->dst_port == 0U || (unsigned int)filter->ip_proto == 17U) 
    #line 7675 
    return -95;
  #line 7678 
  if ((unsigned int)filter->src_port != 0U || filter->ip.v4.src_ip.s_addr != 0U) 
    #line 7680 
    return -95;
  else {
    #line 7679 
    if (! ipv6_addr_any(& filter->ip.v6.src_ip6)) 
                                                  #line 7680 
                                                  return -95;
  }
  #line 7683 
  i40e_set_cld_element(filter,& cld_filter.element);
  #line 7685 
  if ((int)is_valid_ether_addr((u8 *)(& filter->dst_mac)) != 0) 
                                                                #line 7685 
                                                                goto _LOR_0;
  else {
    #line 7685 
    if ((int)is_valid_ether_addr((u8 *)(& filter->src_mac)) != 0) 
                                                                  #line 7685 
                                                                  goto _LOR_0;
    else {
      #line 7686 
      if ((int)is_multicast_ether_addr((u8 *)(& filter->dst_mac)) != 0) 
        #line 7685 
        goto _LOR_0;
      else {
        #line 7687 
        if ((int)is_multicast_ether_addr((u8 *)(& filter->src_mac)) != 0) {
          #line 7685 
          _LOR_0: {
                    #line 7690 
                    if (filter->ip.v4.dst_ip.s_addr != 0U) 
                                                           #line 7691 
                                                           return -95;
                    #line 7697 
                    cld_filter.element.flags = (unsigned short)17U;
                    #line 7700 
                    if ((unsigned int)filter->vlan_id != 0U) 
                                                             #line 7701 
                                                             cld_filter.element.flags = (unsigned short)18U;
                  }
        }
        else 
          #line 7705 
          if (filter->ip.v4.dst_ip.s_addr != 0U) 
                                                 #line 7705 
                                                 goto _LOR;
          else {
            #line 7706 
            if (ipv6_addr_any(& filter->ip.v6.dst_ip6)) {
              #line 7716 
              _dev_err(& (pf->pdev)->dev,(char *)"either mac or ip has to be valid for cloud filter\n");
              #line 7718 
              return -22;
            }
            else {
              #line 7705 
              _LOR: {
                      #line 7707 
                      cld_filter.element.flags = (unsigned short)16U;
                      #line 7709 
                      if ((unsigned int)filter->n_proto == 34525U) 
                                                                   #line 7710 
                                                                   cld_filter.element.flags = (unsigned short)((unsigned int)cld_filter.element.flags | 256U); else 
                                                                    #line 7713 
                                                                    cld_filter.element.flags = cld_filter.element.flags;
                    }
            }
          }
      }
    }
  }
  #line 7722 
  cld_filter.general_fields[15] = __builtin_bswap16((unsigned short)((int)filter->dst_port));
  #line 7725 
  if ((int)add != 0) {
    #line 7727 
    ret = i40e_validate_and_set_switch_mode(vsi);
    #line 7728 
    if (ret != 0) {
      #line 7729 
      _dev_err(& (pf->pdev)->dev,(char *)"failed to set switch mode, ret %d\n",ret);
      #line 7732 
      return ret;
    }
    #line 7735 
    ret = (int)i40e_aq_add_cloud_filters_bb(& pf->hw,
                                     (unsigned short)((int)filter->seid),
                                     & cld_filter,(unsigned char)1);
  }
  else {
    #line 7738 
    ret = (int)i40e_aq_rem_cloud_filters_bb(& pf->hw,
                                      (unsigned short)((int)filter->seid),
                                      & cld_filter,(unsigned char)1);
  }
  #line 7742 
  if (ret != 0) {
    #line 7743 
    bool branch;
    #line 7743 
    struct _ddebug __UNIQUE_ID_ddebug620 = {.modname = (char *)"i40e", .function = (char *)"i40e_add_del_cloud_filter_big_buf", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Failed to %s cloud filter(big buffer) err %d aq_err %d\n", .lineno = (unsigned int)7743U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 7743 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug620.key.dd_key_false.key,(_Bool)0);
    #line 7743 
    if ((long)((long)((int)branch != 0)) != 0L) {
      #line 7743 
      char *tmp_11;
      #line 7743 
      ;
      #line 7743 
      ;
      #line 7743 
      if ((int)add != 0) 
                         #line 7743 
                         tmp_11 = (char *)"add"; else 
                                                      #line 7743 
                                                      tmp_11 = (char *)"delete";
      #line 7743 
      ;
      #line 7743 
      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug620,& (pf->pdev)->dev,(char *)"Failed to %s cloud filter(big buffer) err %d aq_err %d\n",tmp_11,ret,(unsigned int)pf->hw.aq.asq_last_status);
    }
  }
  else {
    #line 7747 
    unsigned short tmp_13;
    #line 7747 
    char *tmp_14;
    #line 7747 
    tmp_13 = __builtin_bswap16((unsigned short)((int)filter->dst_port));
    #line 7747 
    ;
    #line 7747 
    if ((int)add != 0) 
                       #line 7747 
                       tmp_14 = (char *)"add"; else 
                                                    #line 7747 
                                                    tmp_14 = (char *)"delete";
    #line 7747 
    ;
    #line 7747 
    _dev_info(& (pf->pdev)->dev,(char *)"%s cloud filter for VSI: %d, L4 port: %d\n",tmp_14,(int)filter->seid,(int)tmp_13);
  }
  #line 7751 
  return ret;
}

#line 7761  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_parse_cls_flower(struct i40e_vsi *vsi, struct flow_cls_offload *f, struct i40e_cloud_filter *filter)
{
  #line 7765 
  struct flow_rule *rule = flow_cls_offload_flow_rule(f);
  #line 7766 
  struct flow_dissector *dissector = rule->match.dissector;
  #line 7767 
  u16 n_proto_mask = (unsigned short)0U;
  #line 7767 
  u16 n_proto_key = (unsigned short)0U;
  #line 7767 
  u16 addr_type = (unsigned short)0U;
  #line 7768 
  struct i40e_pf *pf = vsi->back;
  #line 7769 
  u8 field_flags = (unsigned char)0U;
  #line 7771 
  if (((unsigned long)dissector->used_keys & 18446744073709534048UL) != 0UL) {
    #line 7780 
    _dev_err(& (pf->pdev)->dev,(char *)"Unsupported key used: 0x%x\n",dissector->used_keys);
    #line 7782 
    return -95;
  }
  #line 7785 
  if ((int)flow_rule_match_key(rule,
                            (enum flow_dissector_key_id)FLOW_DISSECTOR_KEY_ENC_KEYID) != 0) {
    #line 7786 
    struct flow_match_enc_keyid match;
    #line 7788 
    flow_rule_match_enc_keyid(rule,& match);
    #line 7789 
    if ((match.mask)->keyid != 0U) 
                                   #line 7790 
                                   field_flags = (unsigned char)((unsigned int)field_flags | 8U);
    #line 7792 
    filter->tenant_id = __builtin_bswap32((match.key)->keyid);
  }
  #line 7795 
  if ((int)flow_rule_match_key(rule,
                            (enum flow_dissector_key_id)FLOW_DISSECTOR_KEY_BASIC) != 0) {
    #line 7796 
    struct flow_match_basic match_0;
    #line 7798 
    flow_rule_match_basic(rule,& match_0);
    #line 7799 
    n_proto_key = __builtin_bswap16((unsigned short)((int)(match_0.key)->n_proto));
    #line 7800 
    n_proto_mask = __builtin_bswap16((unsigned short)((int)(match_0.mask)->n_proto));
    #line 7802 
    if ((unsigned int)n_proto_key == 3U) {
      #line 7803 
      n_proto_key = (unsigned short)0U;
      #line 7804 
      n_proto_mask = (unsigned short)0U;
    }
    #line 7806 
    filter->n_proto = (unsigned short)((int)n_proto_key & (int)n_proto_mask);
    #line 7807 
    filter->ip_proto = (match_0.key)->ip_proto;
  }
  #line 7810 
  if ((int)flow_rule_match_key(rule,
                            (enum flow_dissector_key_id)FLOW_DISSECTOR_KEY_ETH_ADDRS) != 0) {
    #line 7811 
    struct flow_match_eth_addrs match_1;
    #line 7813 
    flow_rule_match_eth_addrs(rule,& match_1);
    #line 7816 
    if (! is_zero_ether_addr((u8 *)(& (match_1.mask)->dst))) {
      #line 7817 
      if ((int)is_broadcast_ether_addr((u8 *)(& (match_1.mask)->dst)) != 0) 
        #line 7818 
        field_flags = (unsigned char)((unsigned int)field_flags | 1U);
      else {
        #line 7820 
        _dev_err(& (pf->pdev)->dev,(char *)"Bad ether dest mask %pM\n",(unsigned char *)(& (match_1.mask)->dst));
        #line 7822 
        return -4;
      }
    }
    #line 7826 
    if (! is_zero_ether_addr((u8 *)(& (match_1.mask)->src))) {
      #line 7827 
      if ((int)is_broadcast_ether_addr((u8 *)(& (match_1.mask)->src)) != 0) 
        #line 7828 
        field_flags = (unsigned char)((unsigned int)field_flags | 2U);
      else {
        #line 7830 
        _dev_err(& (pf->pdev)->dev,(char *)"Bad ether src mask %pM\n",(unsigned char *)(& (match_1.mask)->src));
        #line 7832 
        return -4;
      }
    }
    #line 7835 
    ether_addr_copy((u8 *)(& filter->dst_mac),(u8 *)(& (match_1.key)->dst));
    #line 7836 
    ether_addr_copy((u8 *)(& filter->src_mac),(u8 *)(& (match_1.key)->src));
  }
  #line 7839 
  if ((int)flow_rule_match_key(rule,
                            (enum flow_dissector_key_id)FLOW_DISSECTOR_KEY_VLAN) != 0) {
    #line 7840 
    struct flow_match_vlan match_2;
    #line 7842 
    flow_rule_match_vlan(rule,& match_2);
    #line 7843 
    if ((unsigned int)(match_2.mask)->__anonCompField_flow_dissector_key_vlan_74.__anonCompField___anonunion_8254_73.vlan_id != 0U) 
      #line 7844 
      if ((unsigned int)(match_2.mask)->__anonCompField_flow_dissector_key_vlan_74.__anonCompField___anonunion_8254_73.vlan_id == 4095U) 
        #line 7845 
        field_flags = (unsigned char)((unsigned int)field_flags | 4U);
      else {
        #line 7848 
        _dev_err(& (pf->pdev)->dev,(char *)"Bad vlan mask 0x%04x\n",(int)(match_2.mask)->__anonCompField_flow_dissector_key_vlan_74.__anonCompField___anonunion_8254_73.vlan_id);
        #line 7850 
        return -4;
      }
    #line 7854 
    filter->vlan_id = __builtin_bswap16((unsigned short)((int)(match_2.key)->__anonCompField_flow_dissector_key_vlan_74.__anonCompField___anonunion_8254_73.vlan_id));
  }
  #line 7857 
  if ((int)flow_rule_match_key(rule,
                            (enum flow_dissector_key_id)FLOW_DISSECTOR_KEY_CONTROL) != 0) {
    #line 7858 
    struct flow_match_control match_3;
    #line 7860 
    flow_rule_match_control(rule,& match_3);
    #line 7861 
    addr_type = (match_3.key)->addr_type;
  }
  #line 7864 
  if ((unsigned int)addr_type == 2U) {
    #line 7865 
    struct flow_match_ipv4_addrs match_4;
    #line 7867 
    flow_rule_match_ipv4_addrs(rule,& match_4);
    #line 7868 
    if ((match_4.mask)->dst != 0U) 
      #line 7869 
      if ((match_4.mask)->dst == 4294967295U) 
                                              #line 7870 
                                              field_flags = (unsigned char)((unsigned int)field_flags | 16U);
      else {
        #line 7872 
        _dev_err(& (pf->pdev)->dev,(char *)"Bad ip dst mask %pI4b\n",& (match_4.mask)->dst);
        #line 7874 
        return -4;
      }
    #line 7878 
    if ((match_4.mask)->src != 0U) 
      #line 7879 
      if ((match_4.mask)->src == 4294967295U) 
                                              #line 7880 
                                              field_flags = (unsigned char)((unsigned int)field_flags | 16U);
      else {
        #line 7882 
        _dev_err(& (pf->pdev)->dev,(char *)"Bad ip src mask %pI4b\n",& (match_4.mask)->src);
        #line 7884 
        return -4;
      }
    #line 7888 
    if (((unsigned long)field_flags & 8UL) != 0UL) {
      #line 7889 
      _dev_err(& (pf->pdev)->dev,(char *)"Tenant id not allowed for ip filter\n");
      #line 7890 
      return -4;
    }
    #line 7892 
    filter->ip.v4.dst_ip.s_addr = (match_4.key)->dst;
    #line 7893 
    filter->ip.v4.src_ip.s_addr = (match_4.key)->src;
  }
  #line 7896 
  if ((unsigned int)addr_type == 3U) {
    #line 7897 
    struct flow_match_ipv6_addrs match_5;
    #line 7899 
    flow_rule_match_ipv6_addrs(rule,& match_5);
    #line 7904 
    if ((int)ipv6_addr_loopback(& (match_5.key)->dst) != 0) 
                                                            #line 7904 
                                                            goto _LOR;
    else {
      #line 7904 
      if ((int)ipv6_addr_loopback(& (match_5.key)->src) != 0) {
        #line 7904 
        _LOR: {
                #line 7906 
                _dev_err(& (pf->pdev)->dev,(char *)"Bad ipv6, addr is LOOPBACK\n");
                #line 7908 
                return -4;
              }
      }
    }
    #line 7910 
    if (ipv6_addr_any(& (match_5.mask)->dst)) {
      #line 7911 
      if (! ipv6_addr_any(& (match_5.mask)->src)) 
                                                  #line 7912 
                                                  field_flags = (unsigned char)((unsigned int)field_flags | 16U);
    }
    else 
         #line 7912 
         field_flags = (unsigned char)((unsigned int)field_flags | 16U);
    #line 7914 
    memcpy((void *)(& filter->ip.v6.src_ip6.in6_u.u6_addr32),(void *)(& (match_5.key)->src.in6_u.u6_addr32),16UL);
    #line 7916 
    memcpy((void *)(& filter->ip.v6.dst_ip6.in6_u.u6_addr32),(void *)(& (match_5.key)->dst.in6_u.u6_addr32),16UL);
  }
  #line 7920 
  if ((int)flow_rule_match_key(rule,
                             (enum flow_dissector_key_id)FLOW_DISSECTOR_KEY_PORTS) != 0) {
    #line 7921 
    struct flow_match_ports match_6;
    #line 7923 
    flow_rule_match_ports(rule,& match_6);
    #line 7924 
    if ((unsigned int)(match_6.mask)->__anonCompField_flow_dissector_key_ports_77.__anonCompField___anonunion_8257_76.src != 0U) 
      #line 7925 
      if ((unsigned int)(match_6.mask)->__anonCompField_flow_dissector_key_ports_77.__anonCompField___anonunion_8257_76.src == 65535U) 
        #line 7926 
        field_flags = (unsigned char)((unsigned int)field_flags | 16U);
      else {
        #line 7928 
        ;
        #line 7928 
        _dev_err(& (pf->pdev)->dev,(char *)"Bad src port mask 0x%04x\n",(int)__builtin_bswap16((unsigned short)((int)(match_6.mask)->__anonCompField_flow_dissector_key_ports_77.__anonCompField___anonunion_8257_76.src)));
        #line 7930 
        return -4;
      }
    #line 7934 
    if ((unsigned int)(match_6.mask)->__anonCompField_flow_dissector_key_ports_77.__anonCompField___anonunion_8257_76.dst != 0U) 
      #line 7935 
      if ((unsigned int)(match_6.mask)->__anonCompField_flow_dissector_key_ports_77.__anonCompField___anonunion_8257_76.dst == 65535U) 
        #line 7936 
        field_flags = (unsigned char)((unsigned int)field_flags | 16U);
      else {
        #line 7938 
        ;
        #line 7938 
        _dev_err(& (pf->pdev)->dev,(char *)"Bad dst port mask 0x%04x\n",(int)__builtin_bswap16((unsigned short)((int)(match_6.mask)->__anonCompField_flow_dissector_key_ports_77.__anonCompField___anonunion_8257_76.dst)));
        #line 7940 
        return -4;
      }
    #line 7944 
    filter->dst_port = (match_6.key)->__anonCompField_flow_dissector_key_ports_77.__anonCompField___anonunion_8257_76.dst;
    #line 7945 
    filter->src_port = (match_6.key)->__anonCompField_flow_dissector_key_ports_77.__anonCompField___anonunion_8257_76.src;
    #line 7947 
    switch ((int)filter->ip_proto) {
      #line 7948 
      case 6: 
              #line 7948 
      ;
      #line 7949 
      case 17: 
               #line 7949 
      ;
      #line 7950 
      break;
      #line 7951 
      default: 
               #line 7951 
      ;
      #line 7952 
      _dev_err(& (pf->pdev)->dev,(char *)"Only UDP and TCP transport are supported\n");
      #line 7954 
      return -22;
    }
  }
  #line 7957 
  filter->flags = field_flags;
  #line 7958 
  return 0;
}

#line 7968  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_handle_tclass(struct i40e_vsi *vsi, u32 tc, struct i40e_cloud_filter *filter)
{
  #line 7971 
  struct i40e_channel *ch;
  #line 7971 
  struct i40e_channel *ch_tmp;
  #line 7974 
  if (tc == 0U) {
    #line 7975 
    filter->seid = vsi->seid;
    #line 7976 
    return 0;
  }
  else 
    #line 7977 
    if ((((unsigned long)vsi->tc_config.enabled_tc >> tc) & 1UL) != 0UL) {
      #line 7985 
      void *__mptr;
      #line 7985 
      void *__mptr_0;
      #line 7978 
      if ((unsigned int)filter->dst_port == 0U) {
        #line 7979 
        _dev_err(& ((vsi->back)->pdev)->dev,(char *)"Specify destination port to direct to traffic class that is not default\n");
        #line 7981 
        return -22;
      }
      #line 7983 
      if (list_empty(& vsi->ch_list) != 0) 
                                           #line 7984 
                                           return -22;
      #line 7985 
      __mptr = (void *)vsi->ch_list.next;
      #line 7985 
      ch = ((struct i40e_channel *)__mptr);
      #line 7985 
      __mptr_0 = (void *)ch->list.next;
      #line 7986 
      ch_tmp = ((struct i40e_channel *)__mptr_0);
      #line 7985 
      while (& ch->list != & vsi->ch_list) {
        #line 7985 
        void *__mptr_1;
        #line 7987 
        if ((int)ch->seid == (int)vsi->tc_seid_map[tc]) 
                                                        #line 7988 
                                                        filter->seid = ch->seid;
        #line 7985 
        ch = ch_tmp;
        #line 7985 
        __mptr_1 = (void *)ch_tmp->list.next;
        #line 7985 
        ch_tmp = ((struct i40e_channel *)__mptr_1);
      }
      #line 7990 
      return 0;
    }
  #line 7992 
  _dev_err(& ((vsi->back)->pdev)->dev,(char *)"TC is not enabled\n");
  #line 7993 
  return -22;
}

#line 8002  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_configure_clsflower(struct i40e_vsi *vsi, struct flow_cls_offload *cls_flower)
{
  #line 8005 
  int tc = tc_classid_to_hwtc(vsi->netdev,cls_flower->classid);
  #line 8006 
  struct i40e_cloud_filter *filter = (struct i40e_cloud_filter *)0;
  #line 8007 
  struct i40e_pf *pf = vsi->back;
  #line 8008 
  int err = 0;
  #line 8010 
  if (tc < 0) {
    #line 8011 
    _dev_err(& ((vsi->back)->pdev)->dev,(char *)"Invalid traffic class\n");
    #line 8012 
    return -95;
  }
  #line 8015 
  if ((int)test_bit(8L,(unsigned long *)(& pf->state)) != 0) 
                                                             #line 8017 
                                                             return -16;
  else {
    #line 8015 
    if ((int)test_bit(11L,(unsigned long *)(& pf->state)) != 0) 
                                                                #line 8017 
                                                                return -16;
  }
  #line 8019 
  if ((unsigned int)pf->fdir_pf_active_filters != 0U) 
                                                      #line 8019 
                                                      goto _LOR;
  else {
    #line 8019 
    if (hlist_empty(& pf->fdir_filter_list) == 0) {
      #line 8019 
      _LOR: {
              #line 8021 
              _dev_err(& ((vsi->back)->pdev)->dev,(char *)"Flow Director Sideband filters exists, turn ntuple off to configure cloud filters\n");
              #line 8023 
              return -22;
            }
    }
  }
  #line 8026 
  if (((unsigned long)(vsi->back)->flags & 256UL) != 0UL) {
    #line 8027 
    _dev_err(& ((vsi->back)->pdev)->dev,(char *)"Disable Flow Director Sideband, configuring Cloud filters via tc-flower\n");
    #line 8029 
    (vsi->back)->flags &= 4294967039U;
    #line 8030 
    (vsi->back)->flags |= 8388608U;
  }
  #line 8033 
  filter = (struct i40e_cloud_filter *)kzalloc_1(88UL,3264U);
  #line 8034 
  if (filter == (struct i40e_cloud_filter *)0) 
                                               #line 8035 
                                               return -12;
  #line 8037 
  filter->cookie = cls_flower->cookie;
  #line 8039 
  err = i40e_parse_cls_flower(vsi,cls_flower,filter);
  #line 8040 
  if (err < 0) 
               #line 8041 
               goto err;
  #line 8043 
  err = i40e_handle_tclass(vsi,(unsigned int)tc,filter);
  #line 8044 
  if (err < 0) 
               #line 8045 
               goto err;
  #line 8048 
  if ((unsigned int)filter->dst_port != 0U) 
                                            #line 8049 
                                            err = i40e_add_del_cloud_filter_big_buf(vsi,filter,(_Bool)1); else 
                                                                    #line 8051 
                                                                    err = i40e_add_del_cloud_filter(vsi,filter,(_Bool)1);
  #line 8053 
  if (err != 0) {
    #line 8054 
    ;
    #line 8054 
    _dev_err(& (pf->pdev)->dev,(char *)"Failed to add cloud filter, err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)err));
    #line 8057 
    goto err;
  }
  #line 8061 
  INIT_HLIST_NODE(& filter->cloud_node);
  #line 8063 
  hlist_add_head_0(& filter->cloud_node,& pf->cloud_filter_list);
  #line 8065 
  pf->num_cloud_filters = (u16)((int)pf->num_cloud_filters + 1);
  #line 8067 
  return err;
  #line 8068 
  err: 
       #line 8068 
  ;
  #line 8069 
  kfree((void *)filter);
  #line 8070 
  return err;
}

#line 8079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct i40e_cloud_filter *i40e_find_cloud_filter(struct i40e_vsi *vsi, unsigned long *cookie)
{
  #line 8085 
  void *__mptr;
  #line 8085 
  struct i40e_cloud_filter *tmp_0;
  #line 8083 
  struct hlist_node *node2;
  #line 8082 
  struct i40e_cloud_filter *filter = (struct i40e_cloud_filter *)0;
  {
    #line 8085 
    struct hlist_node *____ptr = (vsi->back)->cloud_filter_list.first;
    #line 8085 
    if (____ptr != (struct hlist_node *)0) {
      #line 8085 
      __mptr = (void *)____ptr;
      #line 8085 
      tmp_0 = ((struct i40e_cloud_filter *)__mptr);
    }
    else 
         #line 8085 
         tmp_0 = (struct i40e_cloud_filter *)0;
    }
  #line 8085 
  filter = tmp_0;
  #line 8085 
  while (1) {
    #line 8085 
    struct i40e_cloud_filter *tmp_3;
    #line 8085 
    void *__mptr_0;
    #line 8085 
    if (filter != (struct i40e_cloud_filter *)0) {
      #line 8085 
      node2 = filter->cloud_node.next;
      #line 8085 
      if (! (1 != 0)) 
                      #line 8085 
                      break;
    }
    else 
         #line 8085 
         break;
    #line 8087 
    if (memcmp((void *)cookie,(void *)(& filter->cookie),8UL) == 0) 
                                                                    #line 8088 
                                                                    return filter;
    {
      #line 8085 
      struct hlist_node *____ptr_0 = node2;
      #line 8085 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 8085 
        __mptr_0 = (void *)____ptr_0;
        #line 8085 
        tmp_3 = ((struct i40e_cloud_filter *)__mptr_0);
      }
      else 
           #line 8085 
           tmp_3 = (struct i40e_cloud_filter *)0;
      }
    #line 8085 
    filter = tmp_3;
  }
  #line 8089 
  return (struct i40e_cloud_filter *)0;
}

#line 8098  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_delete_clsflower(struct i40e_vsi *vsi, struct flow_cls_offload *cls_flower)
{
  #line 8101 
  struct i40e_cloud_filter *filter = (struct i40e_cloud_filter *)0;
  #line 8102 
  struct i40e_pf *pf = vsi->back;
  #line 8103 
  int err = 0;
  #line 8105 
  filter = i40e_find_cloud_filter(vsi,& cls_flower->cookie);
  #line 8107 
  if (filter == (struct i40e_cloud_filter *)0) 
                                               #line 8108 
                                               return -22;
  #line 8110 
  hash_del(& filter->cloud_node);
  #line 8112 
  if ((unsigned int)filter->dst_port != 0U) 
                                            #line 8113 
                                            err = i40e_add_del_cloud_filter_big_buf(vsi,filter,(_Bool)0); else 
                                                                    #line 8115 
                                                                    err = i40e_add_del_cloud_filter(vsi,filter,(_Bool)0);
  #line 8117 
  kfree((void *)filter);
  #line 8118 
  if (err != 0) {
    #line 8119 
    ;
    #line 8119 
    _dev_err(& (pf->pdev)->dev,(char *)"Failed to delete cloud filter, err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)err));
    #line 8122 
    return i40e_aq_rc_to_posix(err,(int)pf->hw.aq.asq_last_status);
  }
  #line 8125 
  pf->num_cloud_filters = (u16)((int)pf->num_cloud_filters - 1);
  #line 8126 
  if ((unsigned int)pf->num_cloud_filters == 0U) 
    #line 8127 
    if (((unsigned long)pf->flags & 8388608UL) != 0UL && ((unsigned long)pf->flags & 4194304UL) == 0UL) {
      #line 8129 
      pf->flags |= 256U;
      #line 8130 
      pf->flags &= 4286578687U;
      #line 8131 
      pf->flags &= 4290772991U;
    }
  #line 8133 
  return 0;
}

#line 8141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_setup_tc_cls_flower(struct i40e_netdev_priv *np, struct flow_cls_offload *cls_flower)
{
  #line 8144 
  struct i40e_vsi *vsi = np->vsi;
  #line 8146 
  switch ((unsigned int)cls_flower->command) {
    #line 8147 
    case (unsigned int)0: 
                          #line 8147 
    ;
    #line 8148 
    return i40e_configure_clsflower(vsi,cls_flower);
    #line 8149 
    case (unsigned int)1: 
                          #line 8149 
    ;
    #line 8150 
    return i40e_delete_clsflower(vsi,cls_flower);
    #line 8151 
    case (unsigned int)2: 
                          #line 8151 
    ;
    #line 8152 
    return -95;
    #line 8153 
    default: 
             #line 8153 
    ;
    #line 8154 
    return -95;
  }
}

#line 8158  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_setup_tc_block_cb(enum tc_setup_type type, void *type_data, void *cb_priv)
{
  #line 8161 
  struct i40e_netdev_priv *np = (struct i40e_netdev_priv *)cb_priv;
  #line 8163 
  if (! tc_cls_can_offload_and_chain0((np->vsi)->netdev,
                                    (struct flow_cls_common_offload *)type_data)) 
    #line 8164 
    return -95;
  #line 8166 
  switch ((unsigned int)type) {
    #line 8167 
    case (unsigned int)2: 
                          #line 8167 
    ;
    #line 8168 
    return i40e_setup_tc_cls_flower(np,(struct flow_cls_offload *)type_data);
    #line 8170 
    default: 
             #line 8170 
    ;
    #line 8171 
    return -95;
  }
}

#line 8175  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct list_head i40e_block_cb_list = {.next = & i40e_block_cb_list, .prev = & i40e_block_cb_list};
#line 8177  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int __i40e_setup_tc(struct net_device *netdev, enum tc_setup_type type, void *type_data)
{
  #line 8180 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 8182 
  switch ((unsigned int)type) {
    #line 8183 
    case (unsigned int)0: 
                          #line 8183 
    ;
    #line 8184 
    return i40e_setup_tc(netdev,type_data);
    #line 8185 
    case (unsigned int)5: 
                          #line 8185 
    ;
    #line 8186 
    return flow_block_cb_setup_simple((struct flow_block_offload *)type_data,
                                   & i40e_block_cb_list,
                                   & i40e_setup_tc_block_cb,(void *)np,
                                   (void *)np,(_Bool)1);
    #line 8190 
    default: 
             #line 8190 
    ;
    #line 8191 
    return -95;
  }
}

#line 8207  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_open(struct net_device *netdev)
{
  #line 8212 
  int err;
  #line 8209 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 8210 
  struct i40e_vsi *vsi = np->vsi;
  #line 8211 
  struct i40e_pf *pf = vsi->back;
  #line 8215 
  if ((int)test_bit(0L,(unsigned long *)(& pf->state)) != 0) 
                                                             #line 8217 
                                                             return -16;
  else {
    #line 8215 
    if ((int)test_bit(19L,(unsigned long *)(& pf->state)) != 0) 
                                                                #line 8217 
                                                                return -16;
  }
  #line 8219 
  netif_carrier_off(netdev);
  #line 8221 
  if (i40e_force_link_state(pf,(_Bool)1) != I40E_SUCCESS) 
                                                          #line 8222 
                                                          return -11;
  #line 8224 
  err = i40e_vsi_open(vsi);
  #line 8225 
  if (err != 0) 
                #line 8226 
                return err;
  #line 8229 
  writel(9U,(void *)(pf->hw.hw_addr + 279256U));
  #line 8231 
  writel(137U,(void *)(pf->hw.hw_addr + 279260U));
  #line 8234 
  writel(128U,(void *)(pf->hw.hw_addr + 279264U));
  #line 8236 
  udp_tunnel_get_rx_info(netdev);
  #line 8238 
  return 0;
}

#line 8251  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_vsi_open(struct i40e_vsi *vsi)
{
  #line 8254 
  char int_name[32U];
  #line 8255 
  int err;
  #line 8253 
  struct i40e_pf *pf = vsi->back;
  #line 8258 
  err = i40e_vsi_setup_tx_resources(vsi);
  #line 8259 
  if (err != 0) 
                #line 8260 
                goto err_setup_tx;
  #line 8261 
  err = i40e_vsi_setup_rx_resources(vsi);
  #line 8262 
  if (err != 0) 
                #line 8263 
                goto err_setup_rx;
  #line 8265 
  err = i40e_vsi_configure(vsi);
  #line 8266 
  if (err != 0) 
                #line 8267 
                goto err_setup_rx;
  #line 8269 
  if (vsi->netdev != (struct net_device *)0) {
    #line 8270 
    ;
    #line 8270 
    snprintf((char *)(& int_name),31UL,(char *)"%s-%s",dev_driver_string(& (pf->pdev)->dev),(char *)(& (vsi->netdev)->name));
    #line 8272 
    err = i40e_vsi_request_irq(vsi,(char *)(& int_name));
    #line 8273 
    if (err != 0) 
                  #line 8274 
                  goto err_setup_rx;
    #line 8277 
    err = netif_set_real_num_tx_queues(vsi->netdev,(unsigned int)vsi->num_queue_pairs);
    #line 8279 
    if (err != 0) 
                  #line 8280 
                  goto err_set_queues;
    #line 8282 
    err = netif_set_real_num_rx_queues(vsi->netdev,(unsigned int)vsi->num_queue_pairs);
    #line 8284 
    if (err != 0) 
                  #line 8285 
                  goto err_set_queues;
  }
  else 
    #line 8287 
    if (vsi->type == (unsigned int)I40E_VSI_FDIR) {
      #line 8288 
      snprintf((char *)(& int_name),31UL,(char *)"%s-%s:fdir",dev_driver_string(& (pf->pdev)->dev),dev_name(& (pf->pdev)->dev));
      #line 8291 
      err = i40e_vsi_request_irq(vsi,(char *)(& int_name));
    }
    else {
      #line 8294 
      err = -22;
      #line 8295 
      goto err_setup_rx;
    }
  #line 8298 
  err = i40e_up_complete(vsi);
  #line 8299 
  if (err != 0) 
                #line 8300 
                goto err_up_complete;
  #line 8302 
  return 0;
  #line 8304 
  err_up_complete: 
                   #line 8304 
  ;
  #line 8305 
  i40e_down(vsi);
  #line 8306 
  err_set_queues: 
                  #line 8306 
  ;
  #line 8307 
  i40e_vsi_free_irq(vsi);
  #line 8308 
  err_setup_rx: 
                #line 8308 
  ;
  #line 8309 
  i40e_vsi_free_rx_resources(vsi);
  #line 8310 
  err_setup_tx: 
                #line 8310 
  ;
  #line 8311 
  i40e_vsi_free_tx_resources(vsi);
  #line 8312 
  if (*(pf->vsi + (unsigned long)pf->lan_vsi) == vsi) 
                                                      #line 8313 
                                                      i40e_do_reset(pf,8192U,(_Bool)1);
  #line 8315 
  return err;
}

#line 8325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_fdir_filter_exit(struct i40e_pf *pf)
{
  #line 8343 
  void *__mptr_5;
  #line 8331 
  struct i40e_fdir_filter *tmp_1;
  #line 8337 
  void *__mptr_2;
  #line 8343 
  void *__mptr_4;
  #line 8337 
  void *__mptr_1;
  #line 8331 
  void *__mptr;
  #line 8327 
  struct i40e_fdir_filter *filter;
  #line 8328 
  struct i40e_flex_pit *pit_entry;
  #line 8328 
  struct i40e_flex_pit *tmp;
  #line 8329 
  struct hlist_node *node2;
  {
    #line 8331 
    struct hlist_node *____ptr = pf->fdir_filter_list.first;
    #line 8331 
    if (____ptr != (struct hlist_node *)0) {
      #line 8331 
      __mptr = (void *)____ptr;
      #line 8331 
      tmp_1 = ((struct i40e_fdir_filter *)__mptr);
    }
    else 
         #line 8331 
         tmp_1 = (struct i40e_fdir_filter *)0;
    }
  #line 8331 
  filter = tmp_1;
  #line 8331 
  while (1) {
    #line 8331 
    void *__mptr_0;
    #line 8331 
    struct i40e_fdir_filter *tmp_4;
    #line 8331 
    if (filter != (struct i40e_fdir_filter *)0) {
      #line 8331 
      node2 = filter->fdir_node.next;
      #line 8331 
      if (! (1 != 0)) 
                      #line 8331 
                      break;
    }
    else 
         #line 8331 
         break;
    #line 8333 
    hlist_del_0(& filter->fdir_node);
    #line 8334 
    kfree((void *)filter);
    {
      #line 8331 
      struct hlist_node *____ptr_0 = node2;
      #line 8331 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 8331 
        __mptr_0 = (void *)____ptr_0;
        #line 8331 
        tmp_4 = ((struct i40e_fdir_filter *)__mptr_0);
      }
      else 
           #line 8331 
           tmp_4 = (struct i40e_fdir_filter *)0;
      }
    #line 8331 
    filter = tmp_4;
  }
  #line 8337 
  __mptr_1 = (void *)pf->l3_flex_pit_list.next;
  #line 8337 
  pit_entry = ((struct i40e_flex_pit *)__mptr_1);
  #line 8337 
  __mptr_2 = (void *)pit_entry->list.next;
  #line 8338 
  tmp = ((struct i40e_flex_pit *)__mptr_2);
  #line 8337 
  while (& pit_entry->list != & pf->l3_flex_pit_list) {
    #line 8337 
    void *__mptr_3;
    #line 8338 
    list_del(& pit_entry->list);
    #line 8339 
    kfree((void *)pit_entry);
    #line 8337 
    pit_entry = tmp;
    #line 8337 
    __mptr_3 = (void *)tmp->list.next;
    #line 8337 
    tmp = ((struct i40e_flex_pit *)__mptr_3);
  }
  #line 8341 
  INIT_LIST_HEAD(& pf->l3_flex_pit_list);
  #line 8343 
  __mptr_4 = (void *)pf->l4_flex_pit_list.next;
  #line 8343 
  pit_entry = ((struct i40e_flex_pit *)__mptr_4);
  #line 8343 
  __mptr_5 = (void *)pit_entry->list.next;
  #line 8344 
  tmp = ((struct i40e_flex_pit *)__mptr_5);
  #line 8343 
  while (& pit_entry->list != & pf->l4_flex_pit_list) {
    #line 8343 
    void *__mptr_6;
    #line 8344 
    list_del(& pit_entry->list);
    #line 8345 
    kfree((void *)pit_entry);
    #line 8343 
    pit_entry = tmp;
    #line 8343 
    __mptr_6 = (void *)tmp->list.next;
    #line 8343 
    tmp = ((struct i40e_flex_pit *)__mptr_6);
  }
  #line 8347 
  INIT_LIST_HEAD(& pf->l4_flex_pit_list);
  #line 8349 
  pf->fdir_pf_active_filters = (unsigned short)0U;
  #line 8350 
  pf->fd_tcp4_filter_cnt = (unsigned short)0U;
  #line 8351 
  pf->fd_udp4_filter_cnt = (unsigned short)0U;
  #line 8352 
  pf->fd_sctp4_filter_cnt = (unsigned short)0U;
  #line 8353 
  pf->fd_ip4_filter_cnt = (unsigned short)0U;
  #line 8356 
  i40e_write_fd_input_set(pf,(unsigned short)33,422341314084864ULL);
  #line 8361 
  i40e_write_fd_input_set(pf,(unsigned short)31,422341314084864ULL);
  #line 8366 
  i40e_write_fd_input_set(pf,(unsigned short)34,422341314084864ULL);
  #line 8371 
  i40e_write_fd_input_set(pf,(unsigned short)35,422315544281088ULL);
  #line 8374 
  i40e_write_fd_input_set(pf,(unsigned short)36,422315544281088ULL);
  #line 8375 
  return;
}

#line 8385  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_cloud_filter_exit(struct i40e_pf *pf)
{
  #line 8390 
  void *__mptr;
  #line 8390 
  struct i40e_cloud_filter *tmp_0;
  #line 8387 
  struct i40e_cloud_filter *cfilter;
  #line 8388 
  struct hlist_node *node;
  {
    #line 8390 
    struct hlist_node *____ptr = pf->cloud_filter_list.first;
    #line 8390 
    if (____ptr != (struct hlist_node *)0) {
      #line 8390 
      __mptr = (void *)____ptr;
      #line 8390 
      tmp_0 = ((struct i40e_cloud_filter *)__mptr);
    }
    else 
         #line 8390 
         tmp_0 = (struct i40e_cloud_filter *)0;
    }
  #line 8390 
  cfilter = tmp_0;
  #line 8390 
  while (1) {
    #line 8390 
    void *__mptr_0;
    #line 8390 
    struct i40e_cloud_filter *tmp_3;
    #line 8390 
    if (cfilter != (struct i40e_cloud_filter *)0) {
      #line 8390 
      node = cfilter->cloud_node.next;
      #line 8390 
      if (! (1 != 0)) 
                      #line 8390 
                      break;
    }
    else 
         #line 8390 
         break;
    #line 8392 
    hlist_del_0(& cfilter->cloud_node);
    #line 8393 
    kfree((void *)cfilter);
    {
      #line 8390 
      struct hlist_node *____ptr_0 = node;
      #line 8390 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 8390 
        __mptr_0 = (void *)____ptr_0;
        #line 8390 
        tmp_3 = ((struct i40e_cloud_filter *)__mptr_0);
      }
      else 
           #line 8390 
           tmp_3 = (struct i40e_cloud_filter *)0;
      }
    #line 8390 
    cfilter = tmp_3;
  }
  #line 8395 
  pf->num_cloud_filters = (unsigned short)0U;
  #line 8397 
  if (((unsigned long)pf->flags & 8388608UL) != 0UL && ((unsigned long)pf->flags & 4194304UL) == 0UL) {
    #line 8399 
    pf->flags |= 256U;
    #line 8400 
    pf->flags &= 4286578687U;
    #line 8401 
    pf->flags &= 4290772991U;
  }
  #line 8403 
  return;
}

#line 8415  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_close(struct net_device *netdev)
{
  #line 8417 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 8418 
  struct i40e_vsi *vsi = np->vsi;
  #line 8420 
  i40e_vsi_close(vsi);
  #line 8422 
  return 0;
}

#line 8436  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_do_reset(struct i40e_pf *pf, u32 reset_flags, bool lock_acquired)
{
  #line 8438 
  u32 val;
  {
    #line 8440 
    int __ret_warn_on = ((unsigned long)preempt_count() & 2096896UL) != 0UL;
    #line 8440 
    if ((long)(__ret_warn_on != 0) != 0L) {
      #line 8441 
      ldv_inline_asm();
      #line 8442 
      ldv_inline_asm();
    }
    #line 8440 
    long tmp_2 = (long)(__ret_warn_on != 0);
  }
  #line 8444 
  if (((unsigned long long)reset_flags & 32768ULL) != 0ULL) {
    {
      #line 8454 
      bool branch;
      #line 8454 
      struct _ddebug __UNIQUE_ID_ddebug622 = {.modname = (char *)"i40e", .function = (char *)"i40e_do_reset", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"GlobalR requested\n", .lineno = (unsigned int)8454U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 8454 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug622.key.dd_key_false.key,(_Bool)0);
      #line 8454 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 8454 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug622,& (pf->pdev)->dev,(char *)"GlobalR requested\n");
    }
    #line 8455 
    val = readl((void *)(pf->hw.hw_addr + 754064U));
    #line 8456 
    val |= 2U;
    #line 8457 
    writel(val,(void *)(pf->hw.hw_addr + 754064U));
  }
  else 
    #line 8459 
    if (((unsigned long long)reset_flags & 16384ULL) != 0ULL) {
      {
        #line 8465 
        bool branch_0;
        #line 8465 
        struct _ddebug __UNIQUE_ID_ddebug623 = {.modname = (char *)"i40e", .function = (char *)"i40e_do_reset", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"CoreR requested\n", .lineno = (unsigned int)8465U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 8465 
        branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug623.key.dd_key_false.key,(_Bool)0);
        #line 8465 
        if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                      #line 8465 
                                                      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug623,& (pf->pdev)->dev,(char *)"CoreR requested\n");
      }
      #line 8466 
      val = readl((void *)(pf->hw.hw_addr + 754064U));
      #line 8467 
      val |= 1U;
      #line 8468 
      writel(val,(void *)(pf->hw.hw_addr + 754064U));
      #line 8469 
      readl((void *)(pf->hw.hw_addr + 745772U));
    }
    else 
      #line 8471 
      if (((unsigned long long)reset_flags & 8192ULL) != 0ULL) {
        #line 8484 
        char *tmp_3;
        {
          #line 8481 
          bool branch_1;
          #line 8481 
          struct _ddebug __UNIQUE_ID_ddebug624 = {.modname = (char *)"i40e", .function = (char *)"i40e_do_reset", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"PFR requested\n", .lineno = (unsigned int)8481U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 8481 
          branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug624.key.dd_key_false.key,(_Bool)0);
          #line 8481 
          if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                        #line 8481 
                                                        __dynamic_dev_dbg(& __UNIQUE_ID_ddebug624,& (pf->pdev)->dev,(char *)"PFR requested\n");
        }
        #line 8482 
        i40e_handle_reset_warning(pf,(_Bool)((bool)((int)lock_acquired) != 0));
        #line 8484 
        if (((unsigned long)pf->flags & 16777216UL) != 0UL) 
                                                            #line 8484 
                                                            tmp_3 = (char *)"FW LLDP is disabled\n"; else 
                                                                    #line 8484 
                                                                    tmp_3 = (char *)"FW LLDP is enabled\n";
        #line 8484 
        ;
        #line 8484 
        _dev_info(& (pf->pdev)->dev,tmp_3);
      }
      else 
        #line 8489 
        if (((unsigned long long)reset_flags & 4096ULL) != 0ULL) {
          #line 8490 
          int v;
          #line 8493 
          _dev_info(& (pf->pdev)->dev,(char *)"VSI reinit requested\n");
          #line 8495 
          v = 0;
          #line 8495 
          while ((int)pf->num_alloc_vsi > v) {
            {
              #line 8496 
              struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)v);
              #line 8498 
              if (vsi != (struct i40e_vsi *)0) {
                #line 8498 
                if ((int)test_and_set_bit(4L,(unsigned long *)(& vsi->state)) != 0) 
                  #line 8501 
                  i40e_vsi_reinit_locked(*(pf->vsi + (unsigned long)v));
              }
            }
            #line 8495 
            v ++;
          }
        }
        else 
          #line 8503 
          if (((unsigned long long)reset_flags & 1048576ULL) != 0ULL) {
            #line 8504 
            int v_0;
            #line 8507 
            _dev_info(& (pf->pdev)->dev,(char *)"VSI down requested\n");
            #line 8508 
            v_0 = 0;
            #line 8508 
            while ((int)pf->num_alloc_vsi > v_0) {
              {
                #line 8509 
                struct i40e_vsi *vsi_0 = *(pf->vsi + (unsigned long)v_0);
                #line 8511 
                if (vsi_0 != (struct i40e_vsi *)0) {
                  #line 8511 
                  if ((int)test_and_set_bit(5L,(unsigned long *)(& vsi_0->state)) != 0) {
                    #line 8514 
                    cif_set_bit_1(0L,(unsigned long *)(& vsi_0->state));
                    #line 8515 
                    i40e_down(vsi_0);
                  }
                }
              }
              #line 8508 
              v_0 ++;
            }
          }
          else 
               #line 8519 
               _dev_info(& (pf->pdev)->dev,(char *)"bad reset request 0x%08x\n",reset_flags);
  #line 8520 
  return;
}

#line 8531  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
bool i40e_dcb_need_reconfig(struct i40e_pf *pf, struct i40e_dcbx_config *old_cfg, struct i40e_dcbx_config *new_cfg)
{
  #line 8535 
  bool need_reconfig = (_Bool)0;
  #line 8538 
  if (memcmp((void *)(& new_cfg->etscfg),(void *)(& old_cfg->etscfg),27UL) != 0) {
    #line 8542 
    if (memcmp((void *)(& new_cfg->etscfg.prioritytable),
               (void *)(& old_cfg->etscfg.prioritytable),8UL) != 0) {
      #line 8545 
      need_reconfig = (_Bool)1;
      {
        #line 8546 
        bool branch;
        #line 8546 
        struct _ddebug __UNIQUE_ID_ddebug625 = {.modname = (char *)"i40e", .function = (char *)"i40e_dcb_need_reconfig", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"ETS UP2TC changed.\n", .lineno = (unsigned int)8546U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 8546 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug625.key.dd_key_false.key,(_Bool)0);
        #line 8546 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 8546 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug625,& (pf->pdev)->dev,(char *)"ETS UP2TC changed.\n");
      }
    }
    #line 8549 
    if (memcmp((void *)(& new_cfg->etscfg.tcbwtable),
               (void *)(& old_cfg->etscfg.tcbwtable),8UL) != 0) {
      #line 8552 
      bool branch_0;
      #line 8552 
      struct _ddebug __UNIQUE_ID_ddebug626 = {.modname = (char *)"i40e", .function = (char *)"i40e_dcb_need_reconfig", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"ETS TC BW Table changed.\n", .lineno = (unsigned int)8552U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 8552 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug626.key.dd_key_false.key,(_Bool)0);
      #line 8552 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 8552 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug626,& (pf->pdev)->dev,(char *)"ETS TC BW Table changed.\n");
    }
    #line 8554 
    if (memcmp((void *)(& new_cfg->etscfg.tsatable),
               (void *)(& old_cfg->etscfg.tsatable),8UL) != 0) {
      #line 8557 
      bool branch_1;
      #line 8557 
      struct _ddebug __UNIQUE_ID_ddebug627 = {.modname = (char *)"i40e", .function = (char *)"i40e_dcb_need_reconfig", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"ETS TSA Table changed.\n", .lineno = (unsigned int)8557U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 8557 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug627.key.dd_key_false.key,(_Bool)0);
      #line 8557 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 8557 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug627,& (pf->pdev)->dev,(char *)"ETS TSA Table changed.\n");
    }
  }
  #line 8561 
  if (memcmp((void *)(& new_cfg->pfc),(void *)(& old_cfg->pfc),4UL) != 0) {
    #line 8564 
    need_reconfig = (_Bool)1;
    {
      #line 8565 
      bool branch_2;
      #line 8565 
      struct _ddebug __UNIQUE_ID_ddebug628 = {.modname = (char *)"i40e", .function = (char *)"i40e_dcb_need_reconfig", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"PFC config change detected.\n", .lineno = (unsigned int)8565U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 8565 
      branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug628.key.dd_key_false.key,(_Bool)0);
      #line 8565 
      if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                    #line 8565 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug628,& (pf->pdev)->dev,(char *)"PFC config change detected.\n");
    }
  }
  #line 8569 
  if (memcmp((void *)(& new_cfg->app),(void *)(& old_cfg->app),128UL) != 0) {
    #line 8572 
    need_reconfig = (_Bool)1;
    {
      #line 8573 
      bool branch_3;
      #line 8573 
      struct _ddebug __UNIQUE_ID_ddebug629 = {.modname = (char *)"i40e", .function = (char *)"i40e_dcb_need_reconfig", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"APP Table change detected.\n", .lineno = (unsigned int)8573U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 8573 
      branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug629.key.dd_key_false.key,(_Bool)0);
      #line 8573 
      if ((long)((long)((int)branch_3 != 0)) != 0L) 
                                                    #line 8573 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug629,& (pf->pdev)->dev,(char *)"APP Table change detected.\n");
    }
  }
  {
    #line 8576 
    bool branch_4;
    #line 8576 
    struct _ddebug __UNIQUE_ID_ddebug630 = {.modname = (char *)"i40e", .function = (char *)"i40e_dcb_need_reconfig", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"dcb need_reconfig=%d\n", .lineno = (unsigned int)8576U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 8576 
    branch_4 = arch_static_branch(& __UNIQUE_ID_ddebug630.key.dd_key_false.key,(_Bool)0);
    #line 8576 
    if ((long)((long)((int)branch_4 != 0)) != 0L) 
                                                  #line 8576 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug630,& (pf->pdev)->dev,(char *)"dcb need_reconfig=%d\n",(int)need_reconfig);
  }
  #line 8577 
  return need_reconfig;
}

#line 8585  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_handle_lldp_event(struct i40e_pf *pf, struct i40e_arq_event_info *e)
{
  #line 8591 
  struct i40e_dcbx_config tmp_dcbx_cfg;
  #line 8594 
  u8 type;
  #line 8588 
  struct i40e_aqc_lldp_get_mib *mib = (struct i40e_aqc_lldp_get_mib *)(& e->desc.params.raw);
  #line 8590 
  struct i40e_hw *hw = & pf->hw;
  #line 8592 
  bool need_reconfig = (_Bool)0;
  #line 8593 
  int ret = 0;
  #line 8597 
  if (((unsigned long)pf->flags & 64UL) == 0UL) 
                                                #line 8598 
                                                return ret;
  #line 8601 
  type = (unsigned char)((unsigned int)((unsigned char)((int)mib->type >> 2)) & 12U);
  {
    #line 8603 
    bool branch;
    #line 8603 
    struct _ddebug __UNIQUE_ID_ddebug631 = {.modname = (char *)"i40e", .function = (char *)"i40e_handle_lldp_event", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"LLDP event mib bridge type 0x%x\n", .lineno = (unsigned int)8603U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 8603 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug631.key.dd_key_false.key,(_Bool)0);
    #line 8603 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 8603 
                                                __dynamic_dev_dbg(& __UNIQUE_ID_ddebug631,& (pf->pdev)->dev,(char *)"LLDP event mib bridge type 0x%x\n",(int)type);
  }
  #line 8604 
  if ((unsigned int)type != 0U) 
                                #line 8605 
                                return ret;
  #line 8608 
  type = (unsigned char)((unsigned int)mib->type & 3U);
  {
    #line 8609 
    bool branch_0;
    #line 8609 
    struct _ddebug __UNIQUE_ID_ddebug632 = {.modname = (char *)"i40e", .function = (char *)"i40e_handle_lldp_event", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"LLDP event mib type %s\n", .lineno = (unsigned int)8609U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 8609 
    branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug632.key.dd_key_false.key,(_Bool)0);
    #line 8609 
    if ((long)((long)((int)branch_0 != 0)) != 0L) {
      #line 8609 
      char *tmp_0;
      #line 8609 
      if ((unsigned int)type != 0U) 
                                    #line 8609 
                                    tmp_0 = (char *)"remote"; else 
                                                                   #line 8609 
                                                                   tmp_0 = (char *)"local";
      #line 8609 
      ;
      #line 8609 
      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug632,& (pf->pdev)->dev,(char *)"LLDP event mib type %s\n",tmp_0);
    }
  }
  #line 8611 
  if ((unsigned int)type == 1U) {
    #line 8613 
    ret = (int)i40e_aq_get_dcb_config(hw,(unsigned char)1,(unsigned char)0,
                               & hw->remote_dcbx_config);
    #line 8616 
    goto exit;
  }
  #line 8620 
  tmp_dcbx_cfg = hw->local_dcbx_config;
  #line 8623 
  memset((void *)(& hw->local_dcbx_config),0,200UL);
  #line 8625 
  ret = (int)i40e_get_dcb_config(& pf->hw);
  #line 8626 
  if (ret != 0) {
    #line 8627 
    ;
    #line 8627 
    _dev_info(& (pf->pdev)->dev,(char *)"Failed querying DCB configuration data from firmware, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 8631 
    goto exit;
  }
  #line 8635 
  if (memcmp((void *)(& tmp_dcbx_cfg),(void *)(& hw->local_dcbx_config),
               200UL) == 0) {
    {
      #line 8637 
      bool branch_1;
      #line 8637 
      struct _ddebug __UNIQUE_ID_ddebug633 = {.modname = (char *)"i40e", .function = (char *)"i40e_handle_lldp_event", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"No change detected in DCBX configuration.\n", .lineno = (unsigned int)8637U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 8637 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug633.key.dd_key_false.key,(_Bool)0);
      #line 8637 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 8637 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug633,& (pf->pdev)->dev,(char *)"No change detected in DCBX configuration.\n");
    }
    #line 8638 
    goto exit;
  }
  #line 8641 
  need_reconfig = i40e_dcb_need_reconfig(pf,& tmp_dcbx_cfg,& hw->local_dcbx_config);
  #line 8644 
  i40e_dcbnl_flush_apps(pf,& tmp_dcbx_cfg,& hw->local_dcbx_config);
  #line 8646 
  if (! need_reconfig) 
                       #line 8647 
                       goto exit;
  #line 8650 
  if ((unsigned int)i40e_dcb_get_num_tc(& hw->local_dcbx_config) > 1U) 
    #line 8651 
    pf->flags |= 128U; else 
                            #line 8653 
                            pf->flags &= 4294967167U;
  #line 8655 
  cif_set_bit_1(25L,(unsigned long *)(& pf->state));
  #line 8657 
  i40e_pf_quiesce_all_vsi(pf);
  #line 8660 
  i40e_dcb_reconfigure(pf);
  #line 8662 
  ret = i40e_resume_port_tx(pf);
  #line 8664 
  cif_clear_bit_1(25L,(unsigned long *)(& pf->state));
  #line 8666 
  if (ret != 0) 
                #line 8667 
                goto exit;
  #line 8670 
  ret = i40e_pf_wait_queues_disabled(pf);
  #line 8671 
  if (ret != 0) {
    #line 8673 
    cif_set_bit_1(13L,(unsigned long *)(& pf->state));
    #line 8674 
    i40e_service_event_schedule(pf);
  }
  else {
    #line 8676 
    i40e_pf_unquiesce_all_vsi(pf);
    #line 8677 
    cif_set_bit_1(30L,(unsigned long *)(& pf->state));
    #line 8678 
    cif_set_bit_1(31L,(unsigned long *)(& pf->state));
  }
  #line 8681 
  exit: 
        #line 8681 
  ;
  #line 8682 
  return ret;
}

#line 8692  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_do_reset_safe(struct i40e_pf *pf, u32 reset_flags)
{
  #line 8694 
  rtnl_lock();
  #line 8695 
  i40e_do_reset(pf,reset_flags,(_Bool)1);
  #line 8696 
  rtnl_unlock();
  #line 8697 
  return;
}

#line 8707  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_handle_lan_overflow_event(struct i40e_pf *pf, struct i40e_arq_event_info *e)
{
  #line 8715 
  struct i40e_vf *vf;
  #line 8716 
  u16 vf_id;
  #line 8710 
  struct i40e_aqc_lan_overflow *data = (struct i40e_aqc_lan_overflow *)(& e->desc.params.raw);
  #line 8712 
  u32 queue = data->prtdcb_rupto;
  #line 8713 
  u32 qtx_ctl = data->otx_ctl;
  #line 8714 
  struct i40e_hw *hw = & pf->hw;
  {
    #line 8718 
    bool branch;
    #line 8718 
    struct _ddebug __UNIQUE_ID_ddebug634 = {.modname = (char *)"i40e", .function = (char *)"i40e_handle_lan_overflow_event", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"overflow Rx Queue Number = %d QTX_CTL=0x%08x\n", .lineno = (unsigned int)8718U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 8718 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug634.key.dd_key_false.key,(_Bool)0);
    #line 8718 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 8718 
                                                __dynamic_dev_dbg(& __UNIQUE_ID_ddebug634,& (pf->pdev)->dev,(char *)"overflow Rx Queue Number = %d QTX_CTL=0x%08x\n",queue,qtx_ctl);
  }
  #line 8722 
  if ((qtx_ctl & 3U) == 0U) {
    #line 8724 
    vf_id = (unsigned short)((unsigned int)((unsigned short)(qtx_ctl >> 7)) & 511U);
    #line 8726 
    vf_id = (unsigned short)((int)vf_id - (int)((unsigned short)hw->func_caps.vf_base_id));
    #line 8727 
    vf = pf->vf + (unsigned long)vf_id;
    #line 8728 
    i40e_vc_notify_vf_reset(vf);
    #line 8730 
    msleep(20U);
    #line 8731 
    i40e_reset_vf(vf,(_Bool)0);
  }
  #line 8733 
  return;
}

#line 8739  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
u32 i40e_get_cur_guaranteed_fd_count(struct i40e_pf *pf)
{
  #line 8741 
  u32 val;
  #line 8741 
  u32 fcnt_prog;
  #line 8743 
  val = readl((void *)(pf->hw.hw_addr + 2384768U));
  #line 8744 
  fcnt_prog = val & 8191U;
  #line 8745 
  return fcnt_prog;
}

#line 8752  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
u32 i40e_get_current_fd_count(struct i40e_pf *pf)
{
  #line 8754 
  u32 val;
  #line 8754 
  u32 fcnt_prog;
  #line 8756 
  val = readl((void *)(pf->hw.hw_addr + 2384768U));
  #line 8757 
  fcnt_prog = (val & 8191U) + ((val >> 16) & 8191U);
  #line 8760 
  return fcnt_prog;
}

#line 8767  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
u32 i40e_get_global_fd_count(struct i40e_pf *pf)
{
  #line 8769 
  u32 val;
  #line 8769 
  u32 fcnt_prog;
  #line 8771 
  val = readl((void *)(pf->hw.hw_addr + 2530220U));
  #line 8772 
  fcnt_prog = (val & 8191U) + ((val >> 13) & 8191U);
  #line 8775 
  return fcnt_prog;
}

#line 8782  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_reenable_fdir_sb(struct i40e_pf *pf)
{
  #line 8784 
  if ((int)test_and_set_bit(23L,(unsigned long *)(& pf->state)) != 0) 
    #line 8785 
    if (((unsigned long)pf->flags & 256UL) != 0UL && (pf->hw.debug_mask & 4096U) != 0U) 
      #line 8787 
      _dev_info(& (pf->pdev)->dev,(char *)"FD Sideband/ntuple is being enabled since we have space in the table now\n");
  #line 8788 
  return;
}

#line 8794  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_reenable_fdir_atr(struct i40e_pf *pf)
{
  #line 8796 
  if ((int)test_and_set_bit(22L,(unsigned long *)(& pf->state)) != 0) {
    #line 8802 
    i40e_write_fd_input_set(pf,(unsigned short)33,422341314084864ULL);
    #line 8806 
    if (((unsigned long)pf->flags & 512UL) != 0UL && (pf->hw.debug_mask & 4096U) != 0U) 
      #line 8808 
      _dev_info(& (pf->pdev)->dev,(char *)"ATR is being enabled since we have space in the table and there are no conflicting ntuple rules\n");
  }
  #line 8810 
  return;
}

#line 8817  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_delete_invalid_filter(struct i40e_pf *pf, struct i40e_fdir_filter *filter)
{
  #line 8821 
  pf->fdir_pf_active_filters = (u16)((int)pf->fdir_pf_active_filters - 1);
  #line 8822 
  pf->fd_inv = 0U;
  #line 8824 
  switch ((int)filter->flow_type) {
    #line 8825 
    case 1: 
            #line 8825 
    ;
    #line 8826 
    pf->fd_tcp4_filter_cnt = (u16)((int)pf->fd_tcp4_filter_cnt - 1);
    #line 8827 
    break;
    #line 8828 
    case 2: 
            #line 8828 
    ;
    #line 8829 
    pf->fd_udp4_filter_cnt = (u16)((int)pf->fd_udp4_filter_cnt - 1);
    #line 8830 
    break;
    #line 8831 
    case 3: 
            #line 8831 
    ;
    #line 8832 
    pf->fd_sctp4_filter_cnt = (u16)((int)pf->fd_sctp4_filter_cnt - 1);
    #line 8833 
    break;
    #line 8834 
    case 13: 
             #line 8834 
    ;
    #line 8835 
    switch ((int)filter->ip4_proto) {
      #line 8836 
      case 6: 
              #line 8836 
      ;
      #line 8837 
      pf->fd_tcp4_filter_cnt = (u16)((int)pf->fd_tcp4_filter_cnt - 1);
      #line 8838 
      break;
      #line 8839 
      case 17: 
               #line 8839 
      ;
      #line 8840 
      pf->fd_udp4_filter_cnt = (u16)((int)pf->fd_udp4_filter_cnt - 1);
      #line 8841 
      break;
      #line 8842 
      case 132: 
                #line 8842 
      ;
      #line 8843 
      pf->fd_sctp4_filter_cnt = (u16)((int)pf->fd_sctp4_filter_cnt - 1);
      #line 8844 
      break;
      #line 8845 
      case 0: 
              #line 8845 
      ;
      #line 8846 
      pf->fd_ip4_filter_cnt = (u16)((int)pf->fd_ip4_filter_cnt - 1);
      #line 8847 
      break;
    }
    #line 8849 
    break;
  }
  #line 8853 
  hlist_del_0(& filter->fdir_node);
  #line 8854 
  kfree((void *)filter);
  #line 8855 
  return;
}

#line 8861  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_fdir_check_and_reenable(struct i40e_pf *pf)
{
  #line 8863 
  struct i40e_fdir_filter *filter;
  #line 8864 
  u32 fcnt_prog;
  #line 8864 
  u32 fcnt_avail;
  #line 8865 
  struct hlist_node *node;
  #line 8867 
  if ((int)test_bit(21L,(unsigned long *)(& pf->state)) != 0) 
                                                              #line 8868 
                                                              return;
  #line 8871 
  fcnt_prog = i40e_get_global_fd_count(pf);
  #line 8872 
  fcnt_avail = (unsigned int)pf->fdir_pf_filter_count;
  #line 8873 
  if (fcnt_avail + 4294967264U > fcnt_prog || pf->fd_add_err == 0U) 
                                                                    #line 8876 
                                                                    i40e_reenable_fdir_sb(pf);
  else {
    #line 8874 
    ;
    #line 8874 
    if (i40e_get_current_atr_cnt(pf) < pf->fd_atr_cnt) 
                                                       #line 8876 
                                                       i40e_reenable_fdir_sb(pf);
  }
  #line 8882 
  if (fcnt_avail + 4294967168U > fcnt_prog && (unsigned int)pf->fd_tcp4_filter_cnt == 0U) 
    #line 8884 
    i40e_reenable_fdir_atr(pf);
  #line 8887 
  if (pf->fd_inv != 0U) {
    #line 8888 
    struct i40e_fdir_filter *tmp_2;
    #line 8888 
    void *__mptr;
    {
      #line 8888 
      struct hlist_node *____ptr = pf->fdir_filter_list.first;
      #line 8888 
      if (____ptr != (struct hlist_node *)0) {
        #line 8888 
        __mptr = (void *)____ptr;
        #line 8888 
        tmp_2 = ((struct i40e_fdir_filter *)__mptr);
      }
      else 
           #line 8888 
           tmp_2 = (struct i40e_fdir_filter *)0;
      }
    #line 8888 
    filter = tmp_2;
    #line 8888 
    while (1) {
      #line 8888 
      void *__mptr_0;
      #line 8888 
      struct i40e_fdir_filter *tmp_5;
      #line 8888 
      if (filter != (struct i40e_fdir_filter *)0) {
        #line 8888 
        node = filter->fdir_node.next;
        #line 8888 
        if (! (1 != 0)) 
                        #line 8888 
                        break;
      }
      else 
           #line 8888 
           break;
      #line 8890 
      if (filter->fd_id == pf->fd_inv) 
                                       #line 8891 
                                       i40e_delete_invalid_filter(pf,filter);
      {
        #line 8888 
        struct hlist_node *____ptr_0 = node;
        #line 8888 
        if (____ptr_0 != (struct hlist_node *)0) {
          #line 8888 
          __mptr_0 = (void *)____ptr_0;
          #line 8888 
          tmp_5 = ((struct i40e_fdir_filter *)__mptr_0);
        }
        else 
             #line 8888 
             tmp_5 = (struct i40e_fdir_filter *)0;
        }
      #line 8888 
      filter = tmp_5;
    }
  }
  #line 8893 
  return;
}

#line 8901  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_fdir_flush_and_replay(struct i40e_pf *pf)
{
  #line 8903 
  unsigned long min_flush_time;
  #line 8906 
  int fd_room;
  #line 8907 
  int reg;
  #line 8904 
  int flush_wait_retry = 50;
  #line 8905 
  bool disable_atr = (_Bool)0;
  {
    #line 8909 
    unsigned long __dummy;
    #line 8909 
    unsigned long __dummy2;
    }
  #line 8909 
  if (1 == 0) 
              #line 8911 
              return;
  else {
    {
      #line 8909 
      unsigned long __dummy_0;
      #line 8909 
      unsigned long __dummy2_0;
      }
    #line 8909 
    if (1 == 0) 
                #line 8911 
                return;
    else 
      #line 8909 
      if ((long)((pf->fd_flush_timestamp - jiffies) + 2500UL) >= 0L) 
        #line 8911 
        return;
  }
  #line 8916 
  min_flush_time = pf->fd_flush_timestamp + 7500UL;
  #line 8918 
  fd_room = (int)pf->fdir_pf_filter_count - (int)pf->fdir_pf_active_filters;
  {
    #line 8920 
    unsigned long __dummy_1;
    #line 8920 
    unsigned long __dummy2_1;
    }
  #line 8920 
  if (1 == 0) 
              #line 8920 
              goto _LOR;
  else {
    {
      #line 8920 
      unsigned long __dummy_2;
      #line 8920 
      unsigned long __dummy2_2;
      }
    #line 8920 
    if (1 == 0) 
                #line 8920 
                goto _LOR;
    else 
      #line 8920 
      if ((long)(min_flush_time - jiffies) >= 0L) {
        #line 8920 
        _LOR: 
              #line 8920 
        ;
        #line 8920 
        if (fd_room <= 127) {
          #line 8922 
          if ((pf->hw.debug_mask & 4096U) != 0U) 
                                                 #line 8923 
                                                 _dev_info(& (pf->pdev)->dev,(char *)"ATR disabled, not enough FD filter space.\n");
          #line 8924 
          disable_atr = (_Bool)1;
        }
      }
  }
  #line 8927 
  pf->fd_flush_timestamp = jiffies;
  #line 8928 
  cif_set_bit_1(22L,(unsigned long *)(& pf->state));
  #line 8930 
  writel(1U,(void *)(pf->hw.hw_addr + 2383232U));
  #line 8932 
  readl((void *)(pf->hw.hw_addr + 745772U));
  #line 8933 
  (pf->fd_flush_cnt) ++;
  #line 8934 
  pf->fd_add_err = 0U;
  #line 8935 
  while (1) {
    #line 8941 
    int tmp_4;
    {
      #line 8937 
      usleep_range(5000UL,6000UL);
      #line 8938 
      reg = (int)readl((void *)(pf->hw.hw_addr + 2383232U));
      #line 8939 
      if (((unsigned int)reg & 1U) == 0U) 
                                          #line 8940 
                                          break;
    }
    #line 8941 
    tmp_4 = flush_wait_retry;
    #line 8941 
    flush_wait_retry --;
    #line 8941 
    ;
    #line 8941 
    if (! (tmp_4 != 0)) 
                        #line 8935 
                        break;
  }
  #line 8942 
  if (((unsigned int)reg & 1U) != 0U) 
                                      #line 8943 
                                      _dev_warn(& (pf->pdev)->dev,(char *)"FD table did not flush, needs more time\n");
  else {
    #line 8946 
    i40e_fdir_filter_restore(*(pf->vsi + (unsigned long)pf->lan_vsi));
    #line 8947 
    if (! disable_atr && (unsigned int)pf->fd_tcp4_filter_cnt == 0U) 
      #line 8948 
      cif_clear_bit_1(22L,(unsigned long *)(& pf->state));
    #line 8949 
    cif_clear_bit_1(21L,(unsigned long *)(& pf->state));
    #line 8950 
    if ((pf->hw.debug_mask & 4096U) != 0U) 
                                           #line 8951 
                                           _dev_info(& (pf->pdev)->dev,(char *)"FD Filter table flushed and FD-SB replayed.\n");
  }
  #line 8953 
  return;
}

#line 8959  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
u32 i40e_get_current_atr_cnt(struct i40e_pf *pf)
{
  #line 8961 
  ;
  #line 8961 
  return i40e_get_current_fd_count(pf) - (unsigned int)pf->fdir_pf_active_filters;
}

#line 8975  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_fdir_reinit_subtask(struct i40e_pf *pf)
{
  #line 8979 
  if ((int)test_bit(3L,(unsigned long *)(& pf->state)) != 0) 
                                                             #line 8980 
                                                             return;
  #line 8982 
  if ((int)test_bit(21L,(unsigned long *)(& pf->state)) != 0) 
                                                              #line 8983 
                                                              i40e_fdir_flush_and_replay(pf);
  #line 8985 
  i40e_fdir_check_and_reenable(pf);
  #line 8986 
  return;
}

#line 8994  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_link_event(struct i40e_vsi *vsi, bool link_up)
{
  #line 8996 
  if (vsi == (struct i40e_vsi *)0) 
                                   #line 8997 
                                   return;
  else {
    #line 8996 
    if ((int)test_bit(0L,(unsigned long *)(& vsi->state)) != 0) 
                                                                #line 8997 
                                                                return;
  }
  #line 8999 
  switch ((unsigned int)vsi->type) {
    #line 9000 
    case (unsigned int)0: 
                          #line 9000 
    ;
    #line 9001 
    if (vsi->netdev == (struct net_device *)0 || ! vsi->netdev_registered) 
      #line 9002 
      break;
    #line 9004 
    if ((int)link_up != 0) {
      #line 9005 
      netif_carrier_on(vsi->netdev);
      #line 9006 
      netif_tx_wake_all_queues(vsi->netdev);
    }
    else {
      #line 9008 
      netif_carrier_off(vsi->netdev);
      #line 9009 
      netif_tx_stop_all_queues(vsi->netdev);
    }
    #line 9011 
    break;
    #line 9013 
    case (unsigned int)6: 
                          #line 9013 
    ;
    #line 9014 
    case (unsigned int)2: 
                          #line 9014 
    ;
    #line 9015 
    case (unsigned int)3: 
                          #line 9015 
    ;
    #line 9016 
    case (unsigned int)8: 
                          #line 9016 
    ;
    #line 9017 
    case (unsigned int)5: 
                          #line 9017 
    ;
    #line 9018 
    default: 
             #line 9018 
    ;
    #line 9020 
    break;
  }
  #line 9022 
  return;
}

#line 9029  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_veb_link_event(struct i40e_veb *veb, bool link_up)
{
  #line 9031 
  struct i40e_pf *pf;
  #line 9032 
  int i;
  #line 9034 
  if (veb == (struct i40e_veb *)0 || veb->pf == (struct i40e_pf *)0) 
    #line 9035 
    return;
  #line 9036 
  pf = veb->pf;
  #line 9039 
  i = 0;
  #line 9039 
  while (i <= 15) {
    #line 9040 
    if (pf->veb[i] != (struct i40e_veb *)0 && (int)(pf->veb[i])->uplink_seid == (int)veb->seid) 
      #line 9041 
      i40e_veb_link_event(pf->veb[i],(_Bool)((bool)((int)link_up) != 0));
    #line 9039 
    i ++;
  }
  #line 9044 
  i = 0;
  #line 9044 
  while ((int)pf->num_alloc_vsi > i) {
    #line 9045 
    if (*(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + (unsigned long)i))->uplink_seid == (int)veb->seid) 
      #line 9046 
      i40e_vsi_link_event(*(pf->vsi + (unsigned long)i),(_Bool)((bool)((int)link_up) != 0));
    #line 9044 
    i ++;
  }
  #line 9047 
  return;
}

#line 9053  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_link_event(struct i40e_pf *pf)
{
  #line 9056 
  u8 new_link_speed;
  #line 9056 
  u8 old_link_speed;
  #line 9057 
  i40e_status status;
  #line 9058 
  bool new_link;
  #line 9058 
  bool old_link;
  #line 9055 
  struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)pf->lan_vsi);
  #line 9061 
  pf->hw.phy.get_link_info = (_Bool)1;
  #line 9062 
  old_link = (_Bool)(((int)pf->hw.phy.link_info_old.link_info & 1) != 0);
  #line 9063 
  status = i40e_get_link_status(& pf->hw,& new_link);
  #line 9066 
  if (status == I40E_SUCCESS) 
                              #line 9067 
                              cif_clear_bit_1(29L,(unsigned long *)(& pf->state));
  else {
    #line 9072 
    cif_set_bit_1(29L,(unsigned long *)(& pf->state));
    {
      #line 9073 
      bool branch;
      #line 9073 
      struct _ddebug __UNIQUE_ID_ddebug635 = {.modname = (char *)"i40e", .function = (char *)"i40e_link_event", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"couldn\'t get link state, status: %d\n", .lineno = (unsigned int)9073U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 9073 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug635.key.dd_key_false.key,(_Bool)0);
      #line 9073 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 9073 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug635,& (pf->pdev)->dev,(char *)"couldn\'t get link state, status: %d\n",(int)status);
    }
    #line 9075 
    return;
  }
  #line 9078 
  old_link_speed = (unsigned char)pf->hw.phy.link_info_old.link_speed;
  #line 9079 
  new_link_speed = (unsigned char)pf->hw.phy.link_info.link_speed;
  #line 9081 
  if ((int)new_link == (int)old_link && (int)new_link_speed == (int)old_link_speed) {
    #line 9082 
    if ((int)test_bit(0L,(unsigned long *)(& vsi->state)) != 0) 
                                                                #line 9085 
                                                                return;
    else {
      #line 9083 
      ;
      #line 9083 
      if ((int)netif_carrier_ok(vsi->netdev) == (int)new_link) 
                                                               #line 9085 
                                                               return;
    }
  }
  #line 9087 
  i40e_print_link_message(vsi,(_Bool)((bool)((int)new_link) != 0));
  #line 9092 
  if ((unsigned int)pf->lan_veb <= 15U && pf->veb[(int)pf->lan_veb] != (struct i40e_veb *)0) 
    #line 9093 
    i40e_veb_link_event(pf->veb[(int)pf->lan_veb],(_Bool)((bool)((int)new_link) != 0)); else 
                                                                    #line 9095 
                                                                    i40e_vsi_link_event(vsi,(_Bool)((bool)((int)new_link) != 0));
  #line 9097 
  if (pf->vf != (struct i40e_vf *)0) 
                                     #line 9098 
                                     i40e_vc_notify_link_state(pf);
  #line 9100 
  if (((unsigned long)pf->flags & 131072UL) != 0UL) 
                                                    #line 9101 
                                                    i40e_ptp_set_increment(pf);
  #line 9102 
  return;
}

#line 9108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_watchdog_subtask(struct i40e_pf *pf)
{
  #line 9110 
  int i;
  #line 9113 
  if ((int)test_bit(3L,(unsigned long *)(& pf->state)) != 0) 
                                                             #line 9115 
                                                             return;
  else {
    #line 9113 
    if ((int)test_bit(1L,(unsigned long *)(& pf->state)) != 0) 
                                                               #line 9115 
                                                               return;
  }
  {
    #line 9118 
    unsigned long __dummy;
    #line 9118 
    unsigned long __dummy2;
    }
  #line 9118 
  if (1 != 0) {
    {
      #line 9118 
      unsigned long __dummy_0;
      #line 9118 
      unsigned long __dummy2_0;
      }
    #line 9118 
    if (1 != 0) 
      #line 9118 
      if ((long)(jiffies - (pf->service_timer_previous + pf->service_timer_period)) < 0L) 
        #line 9120 
        return;
  }
  #line 9121 
  pf->service_timer_previous = jiffies;
  #line 9123 
  if (((unsigned long)pf->flags & 16384UL) != 0UL) 
                                                   #line 9125 
                                                   i40e_link_event(pf);
  else {
    #line 9123 
    if ((int)test_bit(29L,(unsigned long *)(& pf->state)) != 0) 
                                                                #line 9125 
                                                                i40e_link_event(pf);
  }
  #line 9130 
  i = 0;
  #line 9130 
  while ((int)pf->num_alloc_vsi > i) {
    #line 9131 
    if (*(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0 && (*(pf->vsi + (unsigned long)i))->netdev != (struct net_device *)0) 
      #line 9132 
      i40e_update_stats(*(pf->vsi + (unsigned long)i));
    #line 9130 
    i ++;
  }
  #line 9134 
  if (((unsigned long)pf->flags & 8192UL) != 0UL) {
    #line 9136 
    i = 0;
    #line 9136 
    while (i <= 15) {
      #line 9137 
      if (pf->veb[i] != (struct i40e_veb *)0) 
                                              #line 9138 
                                              i40e_update_veb_stats(pf->veb[i]);
      #line 9136 
      i ++;
    }
  }
  #line 9141 
  i40e_ptp_rx_hang(pf);
  #line 9142 
  i40e_ptp_tx_hang(pf);
  #line 9143 
  return;
}

#line 9149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_reset_subtask(struct i40e_pf *pf)
{
  #line 9151 
  u32 reset_flags = 0U;
  #line 9153 
  if ((int)test_bit(12L,(unsigned long *)(& pf->state)) != 0) {
    #line 9154 
    reset_flags |= 4096U;
    #line 9155 
    cif_clear_bit_1(12L,(unsigned long *)(& pf->state));
  }
  #line 9157 
  if ((int)test_bit(13L,(unsigned long *)(& pf->state)) != 0) {
    #line 9158 
    reset_flags |= 8192U;
    #line 9159 
    cif_clear_bit_1(13L,(unsigned long *)(& pf->state));
  }
  #line 9161 
  if ((int)test_bit(14L,(unsigned long *)(& pf->state)) != 0) {
    #line 9162 
    reset_flags |= 16384U;
    #line 9163 
    cif_clear_bit_1(14L,(unsigned long *)(& pf->state));
  }
  #line 9165 
  if ((int)test_bit(15L,(unsigned long *)(& pf->state)) != 0) {
    #line 9166 
    reset_flags |= 32768U;
    #line 9167 
    cif_clear_bit_1(15L,(unsigned long *)(& pf->state));
  }
  #line 9169 
  if ((int)test_bit(20L,(unsigned long *)(& pf->state)) != 0) {
    #line 9170 
    reset_flags |= 1048576U;
    #line 9171 
    cif_clear_bit_1(20L,(unsigned long *)(& pf->state));
  }
  #line 9177 
  if ((int)test_bit(11L,(unsigned long *)(& pf->state)) != 0) {
    #line 9178 
    i40e_prep_for_reset(pf,(_Bool)0);
    #line 9179 
    i40e_reset(pf);
    #line 9180 
    i40e_rebuild(pf,(_Bool)0,(_Bool)0);
  }
  #line 9184 
  if (reset_flags != 0U) {
    #line 9185 
    if (! test_bit(3L,(unsigned long *)(& pf->state))) {
      #line 9186 
      if (! test_bit(1L,(unsigned long *)(& pf->state))) 
                                                         #line 9187 
                                                         i40e_do_reset(pf,reset_flags,(_Bool)0);
    }
  }
  #line 9188 
  return;
}

#line 9196  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_handle_link_event(struct i40e_pf *pf, struct i40e_arq_event_info *e)
{
  #line 9199 
  struct i40e_aqc_get_link_status *status = (struct i40e_aqc_get_link_status *)(& e->desc.params.raw);
  #line 9208 
  i40e_link_event(pf);
  #line 9211 
  if ((unsigned int)status->phy_type == 253U) {
    #line 9212 
    _dev_err(& (pf->pdev)->dev,(char *)"Rx/Tx is disabled on this device because the module does not meet thermal requirements.\n");
    #line 9214 
    _dev_err(& (pf->pdev)->dev,(char *)"Refer to the Intel(R) Ethernet Adapters and Devices User Guide for a list of supported modules.\n");
  }
  else 
    #line 9220 
    if (((((int)status->link_info & 64) != 0 && ((int)status->an_info & 128) == 0) && ((int)status->link_info & 1) == 0) && ((unsigned long)pf->flags & 524288UL) == 0UL) {
      #line 9224 
      _dev_err(& (pf->pdev)->dev,(char *)"Rx/Tx is disabled on this device because an unsupported SFP module type was detected.\n");
      #line 9226 
      _dev_err(& (pf->pdev)->dev,(char *)"Refer to the Intel(R) Ethernet Adapters and Devices User Guide for a list of supported modules.\n");
    }
  #line 9228 
  return;
}

#line 9236  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_clean_adminq_subtask(struct i40e_pf *pf)
{
  #line 9238 
  struct i40e_arq_event_info event;
  #line 9240 
  u16 pending;
  #line 9241 
  i40e_status ret;
  #line 9242 
  u16 opcode;
  #line 9243 
  u32 oldval;
  #line 9244 
  u32 val;
  #line 9239 
  struct i40e_hw *hw = & pf->hw;
  #line 9240 
  u16 i = (unsigned short)0U;
  #line 9247 
  if ((int)test_bit(24L,(unsigned long *)(& pf->state)) != 0) 
                                                              #line 9248 
                                                              return;
  #line 9251 
  val = readl((void *)(pf->hw.hw_addr + (unsigned long)pf->hw.aq.arq.len));
  #line 9252 
  oldval = val;
  #line 9253 
  if ((val & 268435456U) != 0U) {
    #line 9254 
    if ((hw->debug_mask & 251658240U) != 0U) 
                                             #line 9255 
                                             _dev_info(& (pf->pdev)->dev,(char *)"ARQ VF Error detected\n");
    #line 9256 
    val &= 4026531839U;
  }
  #line 9258 
  if ((val & 536870912U) != 0U) {
    #line 9259 
    if ((hw->debug_mask & 251658240U) != 0U) 
                                             #line 9260 
                                             _dev_info(& (pf->pdev)->dev,(char *)"ARQ Overflow Error detected\n");
    #line 9261 
    val &= 3758096383U;
    #line 9262 
    (pf->arq_overflows) ++;
  }
  #line 9264 
  if ((val & 1073741824U) != 0U) {
    #line 9265 
    if ((hw->debug_mask & 251658240U) != 0U) 
                                             #line 9266 
                                             _dev_info(& (pf->pdev)->dev,(char *)"ARQ Critical Error detected\n");
    #line 9267 
    val &= 3221225471U;
  }
  #line 9269 
  if (oldval != val) 
                     #line 9270 
                     writel(val,(void *)(pf->hw.hw_addr + (unsigned long)pf->hw.aq.arq.len));
  #line 9272 
  val = readl((void *)(pf->hw.hw_addr + (unsigned long)pf->hw.aq.asq.len));
  #line 9273 
  oldval = val;
  #line 9274 
  if ((val & 268435456U) != 0U) {
    #line 9275 
    if ((pf->hw.debug_mask & 251658240U) != 0U) 
                                                #line 9276 
                                                _dev_info(& (pf->pdev)->dev,(char *)"ASQ VF Error detected\n");
    #line 9277 
    val &= 4026531839U;
  }
  #line 9279 
  if ((val & 536870912U) != 0U) {
    #line 9280 
    if ((pf->hw.debug_mask & 251658240U) != 0U) 
                                                #line 9281 
                                                _dev_info(& (pf->pdev)->dev,(char *)"ASQ Overflow Error detected\n");
    #line 9282 
    val &= 3758096383U;
  }
  #line 9284 
  if ((val & 1073741824U) != 0U) {
    #line 9285 
    if ((pf->hw.debug_mask & 251658240U) != 0U) 
                                                #line 9286 
                                                _dev_info(& (pf->pdev)->dev,(char *)"ASQ Critical Error detected\n");
    #line 9287 
    val &= 3221225471U;
  }
  #line 9289 
  if (oldval != val) 
                     #line 9290 
                     writel(val,(void *)(pf->hw.hw_addr + (unsigned long)pf->hw.aq.asq.len));
  #line 9292 
  event.buf_len = (unsigned short)4096U;
  #line 9293 
  event.msg_buf = (u8 *)kzalloc_1((unsigned long)event.buf_len,3264U);
  #line 9294 
  if (event.msg_buf == (u8 *)0U) 
                                 #line 9295 
                                 return;
  #line 9297 
  while (1) {
    #line 9348 
    u16 tmp_5;
    #line 9298 
    ret = i40e_clean_arq_element(hw,& event,& pending);
    #line 9299 
    if (ret == I40E_ERR_ADMIN_QUEUE_NO_WORK) 
                                             #line 9300 
                                             break;
    else 
      #line 9301 
      if (ret != I40E_SUCCESS) {
        #line 9302 
        _dev_info(& (pf->pdev)->dev,(char *)"ARQ event error %d\n",(int)ret);
        #line 9303 
        break;
      }
    #line 9306 
    opcode = event.desc.opcode;
    #line 9307 
    switch ((int)opcode) {
      #line 9309 
      case 1543: 
                 #line 9309 
      ;
      #line 9310 
      i40e_handle_link_event(pf,& event);
      #line 9311 
      break;
      #line 9312 
      case 2049: 
                 #line 9312 
      ;
      #line 9313 
      ret = (enum i40e_status_code)i40e_vc_process_vf_msg(pf,(short)((int)((short)event.desc.retval)),
                               event.desc.cookie_high,event.desc.cookie_low,
                               event.msg_buf,
                               (unsigned short)((int)event.msg_len));
      #line 9319 
      break;
      #line 9320 
      case 2561: 
                 #line 9320 
      ;
      {
        #line 9321 
        bool branch;
        #line 9321 
        struct _ddebug __UNIQUE_ID_ddebug636 = {.modname = (char *)"i40e", .function = (char *)"i40e_clean_adminq_subtask", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"ARQ: Update LLDP MIB event received\n", .lineno = (unsigned int)9321U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 9321 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug636.key.dd_key_false.key,(_Bool)0);
        #line 9321 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 9321 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug636,& (pf->pdev)->dev,(char *)"ARQ: Update LLDP MIB event received\n");
      }
      #line 9323 
      rtnl_lock();
      #line 9324 
      ret = (enum i40e_status_code)i40e_handle_lldp_event(pf,& event);
      #line 9325 
      rtnl_unlock();
      #line 9327 
      break;
      #line 9328 
      case 4097: 
                 #line 9328 
      ;
      {
        #line 9329 
        bool branch_0;
        #line 9329 
        struct _ddebug __UNIQUE_ID_ddebug637 = {.modname = (char *)"i40e", .function = (char *)"i40e_clean_adminq_subtask", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"ARQ LAN queue overflow event received\n", .lineno = (unsigned int)9329U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 9329 
        branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug637.key.dd_key_false.key,(_Bool)0);
        #line 9329 
        if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                      #line 9329 
                                                      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug637,& (pf->pdev)->dev,(char *)"ARQ LAN queue overflow event received\n");
      }
      #line 9330 
      i40e_handle_lan_overflow_event(pf,& event);
      #line 9331 
      break;
      #line 9332 
      case 2051: 
                 #line 9332 
      ;
      #line 9333 
      _dev_info(& (pf->pdev)->dev,(char *)"ARQ: Msg from other pf\n");
      #line 9334 
      break;
      #line 9335 
      case 1794: 
                 #line 9335 
      ;
      #line 9336 
      case 1795: 
                 #line 9336 
      ;
      #line 9337 
      case 1824: 
                 #line 9337 
      ;
      #line 9338 
      if ((pf->hw.debug_mask & 128U) != 0U) 
                                            #line 9338 
                                            printk((char *)"\001",(int)pf->hw.bus.bus_id,(int)pf->hw.bus.device,(int)pf->hw.bus.func,(int)opcode);
      #line 9341 
      break;
      #line 9342 
      default: 
               #line 9342 
      ;
      #line 9343 
      _dev_info(& (pf->pdev)->dev,(char *)"ARQ: Unknown event 0x%04x ignored\n",(int)opcode);
      #line 9346 
      break;
    }
    #line 9348 
    tmp_5 = i;
    #line 9348 
    i = (u16)((int)i + 1);
    #line 9348 
    ;
    #line 9348 
    if (! ((int)tmp_5 < (int)pf->adminq_work_limit)) 
                                                     #line 9297 
                                                     break;
  }
  #line 9350 
  if ((int)pf->adminq_work_limit > (int)i) 
                                           #line 9351 
                                           cif_clear_bit_1(5L,(unsigned long *)(& pf->state));
  #line 9354 
  val = readl((void *)(hw->hw_addr + 231424U));
  #line 9355 
  val |= 1073741824U;
  #line 9356 
  writel(val,(void *)(hw->hw_addr + 231424U));
  #line 9357 
  readl((void *)(hw->hw_addr + 745772U));
  #line 9359 
  kfree((void *)event.msg_buf);
  #line 9360 
  return;
}

#line 9366  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_verify_eeprom(struct i40e_pf *pf)
{
  #line 9368 
  int err;
  #line 9370 
  err = (int)i40e_diag_eeprom_test(& pf->hw);
  #line 9371 
  if (err != 0) {
    #line 9373 
    err = (int)i40e_diag_eeprom_test(& pf->hw);
    #line 9374 
    if (err != 0) {
      #line 9375 
      _dev_info(& (pf->pdev)->dev,(char *)"eeprom check failed (%d), Tx/Rx traffic disabled\n",err);
      #line 9377 
      cif_set_bit_1(19L,(unsigned long *)(& pf->state));
    }
  }
  #line 9381 
  if (err == 0) {
    #line 9381 
    if ((int)test_bit(19L,(unsigned long *)(& pf->state)) != 0) {
      #line 9382 
      _dev_info(& (pf->pdev)->dev,(char *)"eeprom check passed, Tx/Rx traffic enabled\n");
      #line 9383 
      cif_clear_bit_1(19L,(unsigned long *)(& pf->state));
    }
  }
  #line 9385 
  return;
}

#line 9393  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_enable_pf_switch_lb(struct i40e_pf *pf)
{
  #line 9396 
  struct i40e_vsi_context ctxt;
  #line 9397 
  int ret;
  #line 9395 
  struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)pf->lan_vsi);
  #line 9399 
  ctxt.seid = pf->main_vsi_seid;
  #line 9400 
  ctxt.pf_num = pf->hw.pf_id;
  #line 9401 
  ctxt.vf_num = (unsigned char)0U;
  #line 9402 
  ret = (int)i40e_aq_get_vsi_params(& pf->hw,& ctxt,
                             (struct i40e_asq_cmd_details *)0);
  #line 9403 
  if (ret != 0) {
    #line 9404 
    ;
    #line 9404 
    _dev_info(& (pf->pdev)->dev,(char *)"couldn\'t get PF vsi config, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 9408 
    return;
  }
  #line 9410 
  ctxt.flags = (unsigned short)2U;
  #line 9411 
  ctxt.info.valid_sections = (unsigned short)1U;
  #line 9412 
  ctxt.info.switch_id = (unsigned short)((unsigned int)ctxt.info.switch_id | 8192U);
  #line 9414 
  ret = (int)i40e_aq_update_vsi_params(& (vsi->back)->hw,& ctxt,
                                  (struct i40e_asq_cmd_details *)0);
  #line 9415 
  if (ret != 0) {
    #line 9416 
    ;
    #line 9416 
    _dev_info(& (pf->pdev)->dev,(char *)"update vsi switch failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
  }
  #line 9417 
  return;
}

#line 9429  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_disable_pf_switch_lb(struct i40e_pf *pf)
{
  #line 9432 
  struct i40e_vsi_context ctxt;
  #line 9433 
  int ret;
  #line 9431 
  struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)pf->lan_vsi);
  #line 9435 
  ctxt.seid = pf->main_vsi_seid;
  #line 9436 
  ctxt.pf_num = pf->hw.pf_id;
  #line 9437 
  ctxt.vf_num = (unsigned char)0U;
  #line 9438 
  ret = (int)i40e_aq_get_vsi_params(& pf->hw,& ctxt,
                             (struct i40e_asq_cmd_details *)0);
  #line 9439 
  if (ret != 0) {
    #line 9440 
    ;
    #line 9440 
    _dev_info(& (pf->pdev)->dev,(char *)"couldn\'t get PF vsi config, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 9444 
    return;
  }
  #line 9446 
  ctxt.flags = (unsigned short)2U;
  #line 9447 
  ctxt.info.valid_sections = (unsigned short)1U;
  #line 9448 
  ctxt.info.switch_id = (unsigned short)((unsigned int)ctxt.info.switch_id & 57343U);
  #line 9450 
  ret = (int)i40e_aq_update_vsi_params(& (vsi->back)->hw,& ctxt,
                                  (struct i40e_asq_cmd_details *)0);
  #line 9451 
  if (ret != 0) {
    #line 9452 
    ;
    #line 9452 
    _dev_info(& (pf->pdev)->dev,(char *)"update vsi switch failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
  }
  #line 9453 
  return;
}

#line 9467  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_config_bridge_mode(struct i40e_veb *veb)
{
  #line 9469 
  struct i40e_pf *pf = veb->pf;
  #line 9471 
  if ((pf->hw.debug_mask & 256U) != 0U) {
    #line 9472 
    char *tmp;
    #line 9472 
    if ((unsigned int)veb->bridge_mode == 1U) 
                                              #line 9472 
                                              tmp = (char *)"VEPA"; else 
                                                                    #line 9472 
                                                                    tmp = (char *)"VEB";
    #line 9472 
    ;
    #line 9472 
    _dev_info(& (pf->pdev)->dev,(char *)"enabling bridge mode: %s\n",tmp);
  }
  #line 9474 
  if (((int)veb->bridge_mode & 1) != 0) 
                                        #line 9475 
                                        i40e_disable_pf_switch_lb(pf); else 
                                                                    #line 9477 
                                                                    i40e_enable_pf_switch_lb(pf);
  #line 9478 
  return;
}

#line 9489  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_reconstitute_veb(struct i40e_veb *veb)
{
  #line 9493 
  int v;
  #line 9493 
  int veb_idx;
  #line 9494 
  int ret;
  #line 9491 
  struct i40e_vsi *ctl_vsi = (struct i40e_vsi *)0;
  #line 9492 
  struct i40e_pf *pf = veb->pf;
  #line 9497 
  v = 0;
  #line 9497 
  while ((int)pf->num_alloc_vsi > v && ctl_vsi == (struct i40e_vsi *)0) {
    #line 9498 
    if ((*(pf->vsi + (unsigned long)v) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + (unsigned long)v))->veb_idx == (int)veb->idx) && ((*(pf->vsi + (unsigned long)v))->flags & 2UL) != 0UL) {
      #line 9501 
      ctl_vsi = *(pf->vsi + (unsigned long)v);
      #line 9502 
      break;
    }
    #line 9497 
    v ++;
  }
  #line 9505 
  if (ctl_vsi == (struct i40e_vsi *)0) {
    #line 9506 
    _dev_info(& (pf->pdev)->dev,(char *)"missing owner VSI for veb_idx %d\n",(int)veb->idx);
    #line 9508 
    ret = -2;
    #line 9509 
    goto end_reconstitute;
  }
  #line 9511 
  if (*(pf->vsi + (unsigned long)pf->lan_vsi) != ctl_vsi) 
                                                          #line 9512 
                                                          ctl_vsi->uplink_seid = (*(pf->vsi + (unsigned long)pf->lan_vsi))->uplink_seid;
  #line 9513 
  ret = i40e_add_vsi(ctl_vsi);
  #line 9514 
  if (ret != 0) {
    #line 9515 
    _dev_info(& (pf->pdev)->dev,(char *)"rebuild of veb_idx %d owner VSI failed: %d\n",(int)veb->idx,ret);
    #line 9518 
    goto end_reconstitute;
  }
  #line 9520 
  i40e_vsi_reset_stats(ctl_vsi);
  #line 9523 
  ret = i40e_add_veb(veb,ctl_vsi);
  #line 9524 
  if (ret != 0) 
                #line 9525 
                goto end_reconstitute;
  #line 9527 
  if (((unsigned long)pf->flags & 4096UL) != 0UL) 
                                                  #line 9528 
                                                  veb->bridge_mode = (unsigned short)0U; else 
                                                                    #line 9530 
                                                                    veb->bridge_mode = (unsigned short)1U;
  #line 9531 
  i40e_config_bridge_mode(veb);
  #line 9534 
  v = 0;
  #line 9534 
  while ((int)pf->num_alloc_vsi > v) {
    #line 9535 
    if (*(pf->vsi + (unsigned long)v) == (struct i40e_vsi *)0 || *(pf->vsi + (unsigned long)v) == ctl_vsi) 
      #line 9536 
      goto __Cont;
    #line 9538 
    if ((int)(*(pf->vsi + (unsigned long)v))->veb_idx == (int)veb->idx) {
      #line 9539 
      struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)v);
      #line 9541 
      vsi->uplink_seid = veb->seid;
      #line 9542 
      ret = i40e_add_vsi(vsi);
      #line 9543 
      if (ret != 0) {
        #line 9544 
        _dev_info(& (pf->pdev)->dev,(char *)"rebuild of vsi_idx %d failed: %d\n",v,ret);
        #line 9547 
        goto end_reconstitute;
      }
      #line 9549 
      i40e_vsi_reset_stats(vsi);
    }
    #line 9534 
    __Cont: 
            #line 9534 
    v ++;
  }
  #line 9554 
  veb_idx = 0;
  #line 9554 
  while (veb_idx <= 15) {
    #line 9555 
    if (pf->veb[veb_idx] != (struct i40e_veb *)0 && (int)(pf->veb[veb_idx])->veb_idx == (int)veb->idx) {
      #line 9556 
      (pf->veb[veb_idx])->uplink_seid = veb->seid;
      #line 9557 
      ret = i40e_reconstitute_veb(pf->veb[veb_idx]);
      #line 9558 
      if (ret != 0) 
                    #line 9559 
                    break;
    }
    #line 9554 
    veb_idx ++;
  }
  #line 9563 
  end_reconstitute: 
                    #line 9563 
  ;
  #line 9564 
  return ret;
}

#line 9571  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_get_capabilities(struct i40e_pf *pf, enum i40e_admin_queue_opc list_type)
{
  #line 9574 
  struct i40e_aqc_list_capabilities_element_resp *cap_buf;
  #line 9575 
  u16 data_size;
  #line 9576 
  int buf_len;
  #line 9577 
  int err;
  #line 9579 
  buf_len = 1280;
  #line 9580 
  while (1) {
    {
      #line 9581 
      cap_buf = (struct i40e_aqc_list_capabilities_element_resp *)kzalloc_1((unsigned long)buf_len,3264U);
      #line 9582 
      if (cap_buf == (struct i40e_aqc_list_capabilities_element_resp *)0) 
        #line 9583 
        return -12;
      #line 9586 
      err = (int)i40e_aq_discover_capabilities(& pf->hw,(void *)cap_buf,
                                      (unsigned short)((int)((unsigned short)buf_len)),
                                      & data_size,list_type,
                                      (struct i40e_asq_cmd_details *)0);
      #line 9590 
      kfree((void *)cap_buf);
      #line 9592 
      if (pf->hw.aq.asq_last_status == (unsigned int)I40E_AQ_RC_ENOMEM) 
        #line 9594 
        buf_len = (int)data_size;
      else 
        #line 9595 
        if (pf->hw.aq.asq_last_status != (unsigned int)I40E_AQ_RC_OK) {
          #line 9596 
          ;
          #line 9596 
          _dev_info(& (pf->pdev)->dev,(char *)"capability discovery failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)err),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
          #line 9601 
          return -19;
        }
    }
    #line 9603 
    if (! (err != 0)) 
                      #line 9580 
                      break;
  }
  #line 9605 
  if ((pf->hw.debug_mask & 4026531840U) != 0U) 
    #line 9606 
    if (list_type == (unsigned int)i40e_aqc_opc_list_func_capabilities) 
      #line 9607 
      _dev_info(& (pf->pdev)->dev,(char *)"pf=%d, num_vfs=%d, msix_pf=%d, msix_vf=%d, fd_g=%d, fd_b=%d, pf_max_q=%d num_vsi=%d\n",(int)pf->hw.pf_id,pf->hw.func_caps.num_vfs,pf->hw.func_caps.num_msix_vectors,pf->hw.func_caps.num_msix_vectors_vf,pf->hw.func_caps.fd_filters_guaranteed,pf->hw.func_caps.fd_filters_best_effort,pf->hw.func_caps.num_tx_qp,pf->hw.func_caps.num_vsis);
    else 
      #line 9616 
      if (list_type == (unsigned int)i40e_aqc_opc_list_dev_capabilities) {
        #line 9617 
        _dev_info(& (pf->pdev)->dev,(char *)"switch_mode=0x%04x, function_valid=0x%08x\n",pf->hw.dev_caps.switch_mode,pf->hw.dev_caps.valid_functions);
        #line 9621 
        _dev_info(& (pf->pdev)->dev,(char *)"SR-IOV=%d, num_vfs for all function=%u\n",(int)pf->hw.dev_caps.sr_iov_1_1,pf->hw.dev_caps.num_vfs);
        #line 9625 
        _dev_info(& (pf->pdev)->dev,(char *)"num_vsis=%u, num_rx:%u, num_tx=%u\n",pf->hw.dev_caps.num_vsis,pf->hw.dev_caps.num_rx_qp,pf->hw.dev_caps.num_tx_qp);
      }
  #line 9632 
  if (list_type == (unsigned int)i40e_aqc_opc_list_func_capabilities) 
    #line 9635 
    if ((unsigned int)pf->hw.revision_id == 0U) {
      #line 9636 
      unsigned int tmp_5;
      #line 9636 
      if ((int)pf->hw.func_caps.fcoe != 0) 
                                           #line 9636 
                                           tmp_5 = 2U; else 
                                                            #line 9636 
                                                            tmp_5 = 1U;
      #line 9635 
      ;
      #line 9635 
      if (pf->hw.func_caps.num_vsis < tmp_5 + pf->hw.func_caps.num_vfs) {
        #line 9637 
        unsigned int tmp_3;
        #line 9640 
        unsigned int tmp_4;
        #line 9637 
        if ((int)pf->hw.func_caps.fcoe != 0) 
                                             #line 9637 
                                             tmp_3 = 2U; else 
                                                              #line 9637 
                                                              tmp_3 = 1U;
        #line 9637 
        ;
        #line 9637 
        ;
        #line 9637 
        ;
        #line 9637 
        _dev_info(& (pf->pdev)->dev,(char *)"got num_vsis %d, setting num_vsis to %d\n",pf->hw.func_caps.num_vsis,tmp_3 + pf->hw.func_caps.num_vfs);
        #line 9640 
        if ((int)pf->hw.func_caps.fcoe != 0) 
                                             #line 9640 
                                             tmp_4 = 2U; else 
                                                              #line 9640 
                                                              tmp_4 = 1U;
        #line 9640 
        pf->hw.func_caps.num_vsis = tmp_4 + pf->hw.func_caps.num_vfs;
      }
    }
  #line 9643 
  return 0;
}

#line 9646 
#line 10780 
static int i40e_vsi_clear(struct i40e_vsi *vsi);
#line 9652  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_fdir_sb_setup(struct i40e_pf *pf)
{
  #line 9654 
  struct i40e_vsi *vsi;
  #line 9659 
  if (readl((void *)(pf->hw.hw_addr + 2556224U)) == 0U) {
    #line 9665 
    int i;
    #line 9660 
    u32 hkey[13U] = {3863008063U, 3456014507U, 1945792865U, 226131254U, 3939204449U, 2857305526U, 2623310317U, 4232207835U, 2758101042U, 4235485652U, 2407691801U, 4123409441U, 2511578989U};
    #line 9667 
    i = 0;
    #line 9667 
    while (i <= 12) {
      #line 9668 
      writel(hkey[i],(void *)(pf->hw.hw_addr + (unsigned long)((i + 639056) * 4)));
      #line 9667 
      i ++;
    }
  }
  #line 9671 
  if (((unsigned long)pf->flags & 256UL) == 0UL) 
                                                 #line 9672 
                                                 return;
  #line 9675 
  vsi = i40e_find_vsi_by_type(pf,(unsigned short)7);
  #line 9678 
  if (vsi == (struct i40e_vsi *)0) {
    #line 9679 
    vsi = i40e_vsi_setup(pf,(unsigned char)7,(unsigned short)((int)(*(pf->vsi + (unsigned long)pf->lan_vsi))->seid),0U);
    #line 9681 
    if (vsi == (struct i40e_vsi *)0) {
      #line 9682 
      _dev_info(& (pf->pdev)->dev,(char *)"Couldn\'t create FDir VSI\n");
      #line 9683 
      pf->flags &= 4294967039U;
      #line 9684 
      pf->flags |= 4194304U;
      #line 9685 
      return;
    }
  }
  #line 9689 
  i40e_vsi_setup_irqhandler(vsi,& i40e_fdir_clean_ring);
  #line 9690 
  return;
}

#line 9696  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_fdir_teardown(struct i40e_pf *pf)
{
  #line 9698 
  struct i40e_vsi *vsi;
  #line 9700 
  i40e_fdir_filter_exit(pf);
  #line 9701 
  vsi = i40e_find_vsi_by_type(pf,(unsigned short)7);
  #line 9702 
  if (vsi != (struct i40e_vsi *)0) 
                                   #line 9703 
                                   i40e_vsi_release(vsi);
  #line 9704 
  return;
}

#line 9714  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_rebuild_cloud_filters(struct i40e_vsi *vsi, u16 seid)
{
  #line 9722 
  void *__mptr;
  #line 9722 
  struct i40e_cloud_filter *tmp_0;
  #line 9716 
  struct i40e_cloud_filter *cfilter;
  #line 9718 
  struct hlist_node *node;
  #line 9719 
  i40e_status ret;
  #line 9717 
  struct i40e_pf *pf = vsi->back;
  {
    #line 9722 
    struct hlist_node *____ptr = pf->cloud_filter_list.first;
    #line 9722 
    if (____ptr != (struct hlist_node *)0) {
      #line 9722 
      __mptr = (void *)____ptr;
      #line 9722 
      tmp_0 = ((struct i40e_cloud_filter *)__mptr);
    }
    else 
         #line 9722 
         tmp_0 = (struct i40e_cloud_filter *)0;
    }
  #line 9722 
  cfilter = tmp_0;
  #line 9722 
  while (1) {
    #line 9722 
    void *__mptr_0;
    #line 9722 
    struct i40e_cloud_filter *tmp_3;
    #line 9722 
    if (cfilter != (struct i40e_cloud_filter *)0) {
      #line 9722 
      node = cfilter->cloud_node.next;
      #line 9722 
      if (! (1 != 0)) 
                      #line 9722 
                      break;
    }
    else 
         #line 9722 
         break;
    #line 9724 
    if ((int)cfilter->seid != (int)seid) 
                                         #line 9725 
                                         goto __Cont;
    #line 9727 
    if ((unsigned int)cfilter->dst_port != 0U) {
      #line 9728 
      ret = (enum i40e_status_code)i40e_add_del_cloud_filter_big_buf(vsi,cfilter,(_Bool)1);
    }
    else {
      #line 9731 
      ret = (enum i40e_status_code)i40e_add_del_cloud_filter(vsi,cfilter,(_Bool)1);
    }
    #line 9733 
    if (ret != I40E_SUCCESS) {
      {
        #line 9734 
        bool branch;
        #line 9734 
        struct _ddebug __UNIQUE_ID_ddebug638 = {.modname = (char *)"i40e", .function = (char *)"i40e_rebuild_cloud_filters", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Failed to rebuild cloud filter, err %s aq_err %s\n", .lineno = (unsigned int)9734U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 9734 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug638.key.dd_key_false.key,(_Bool)0);
        #line 9734 
        if ((long)((long)((int)branch != 0)) != 0L) {
          #line 9734 
          ;
          #line 9734 
          __dynamic_dev_dbg(& __UNIQUE_ID_ddebug638,& (pf->pdev)->dev,(char *)"Failed to rebuild cloud filter, err %s aq_err %s\n",i40e_stat_str(& pf->hw,ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
        }
      }
      #line 9739 
      return (int)ret;
    }
    #line 9722 
    __Cont: { /* sequence */
              {
                #line 9722 
                struct hlist_node *____ptr_0 = node;
                #line 9722 
                if (____ptr_0 != (struct hlist_node *)0) {
                  #line 9722 
                  __mptr_0 = (void *)____ptr_0;
                  #line 9722 
                  tmp_3 = ((struct i40e_cloud_filter *)__mptr_0);
                }
                else 
                     #line 9722 
                     tmp_3 = (struct i40e_cloud_filter *)0;
                }
              #line 9722 
              cfilter = tmp_3;
            }
  }
  #line 9742 
  return 0;
}

#line 9751  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_rebuild_channels(struct i40e_vsi *vsi)
{
  #line 9759 
  void *__mptr;
  #line 9759 
  void *__mptr_0;
  #line 9753 
  struct i40e_channel *ch;
  #line 9753 
  struct i40e_channel *ch_tmp;
  #line 9754 
  i40e_status ret;
  #line 9756 
  if (list_empty(& vsi->ch_list) != 0) 
                                       #line 9757 
                                       return 0;
  #line 9759 
  __mptr = (void *)vsi->ch_list.next;
  #line 9759 
  ch = ((struct i40e_channel *)__mptr);
  #line 9759 
  __mptr_0 = (void *)ch->list.next;
  #line 9760 
  ch_tmp = ((struct i40e_channel *)__mptr_0);
  #line 9759 
  while (& ch->list != & vsi->ch_list) {
    #line 9759 
    void *__mptr_1;
    {
      #line 9760 
      if (! ch->initialized) 
                             #line 9761 
                             break;
      #line 9763 
      ret = (enum i40e_status_code)i40e_add_channel(vsi->back,(unsigned short)((int)vsi->uplink_seid),
                         ch);
      #line 9764 
      if (ret != I40E_SUCCESS) {
        #line 9765 
        _dev_info(& ((vsi->back)->pdev)->dev,(char *)"failed to rebuild channels using uplink_seid %u\n",(int)vsi->uplink_seid);
        #line 9768 
        return (int)ret;
      }
      #line 9771 
      ret = (enum i40e_status_code)i40e_channel_config_tx_ring(vsi->back,vsi,ch);
      #line 9772 
      if (ret != I40E_SUCCESS) {
        #line 9773 
        _dev_info(& ((vsi->back)->pdev)->dev,(char *)"failed to configure TX rings for channel %u\n",(int)ch->seid);
        #line 9776 
        return (int)ret;
      }
      #line 9779 
      vsi->next_base_queue = (unsigned short)((int)vsi->next_base_queue + (int)ch->num_queue_pairs);
      #line 9781 
      if (ch->max_tx_rate != 0ULL) {
        #line 9782 
        u64 credits = ch->max_tx_rate;
        #line 9784 
        if (i40e_set_bw_limit(vsi,(unsigned short)((int)ch->seid),
                          ch->max_tx_rate) != 0) 
          #line 9786 
          return -22;
        {
          #line 9788 
          uint32_t __rem;
          #line 9788 
          uint32_t __base = 50U;
          #line 9788 
          __rem = (unsigned int)(credits % (unsigned long long)__base);
          #line 9788 
          credits /= (unsigned long long)__base;
          #line 9788 
          uint32_t tmp_6 = __rem;
        }
        {
          #line 9789 
          bool branch;
          #line 9789 
          struct _ddebug __UNIQUE_ID_ddebug639 = {.modname = (char *)"i40e", .function = (char *)"i40e_rebuild_channels", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Set tx rate of %llu Mbps (count of 50Mbps %llu) for vsi->seid %u\n", .lineno = (unsigned int)9789U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 9789 
          branch = arch_static_branch(& __UNIQUE_ID_ddebug639.key.dd_key_false.key,(_Bool)0);
          #line 9789 
          if ((long)((long)((int)branch != 0)) != 0L) 
                                                      #line 9789 
                                                      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug639,& ((vsi->back)->pdev)->dev,(char *)"Set tx rate of %llu Mbps (count of 50Mbps %llu) for vsi->seid %u\n",ch->max_tx_rate,credits,(int)ch->seid);
        }
      }
      #line 9795 
      ret = (enum i40e_status_code)i40e_rebuild_cloud_filters(vsi,(unsigned short)((int)ch->seid));
      #line 9796 
      if (ret != I40E_SUCCESS) {
        {
          #line 9797 
          bool branch_0;
          #line 9797 
          struct _ddebug __UNIQUE_ID_ddebug640 = {.modname = (char *)"i40e", .function = (char *)"i40e_rebuild_channels", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Failed to rebuild cloud filters for channel VSI %u\n", .lineno = (unsigned int)9797U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
          #line 9797 
          branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug640.key.dd_key_false.key,(_Bool)0);
          #line 9797 
          if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                        #line 9797 
                                                        __dynamic_dev_dbg(& __UNIQUE_ID_ddebug640,& ((vsi->back)->pdev)->dev,(char *)"Failed to rebuild cloud filters for channel VSI %u\n",(int)ch->seid);
        }
        #line 9800 
        return (int)ret;
      }
    }
    #line 9759 
    ch = ch_tmp;
    #line 9759 
    __mptr_1 = (void *)ch_tmp->list.next;
    #line 9759 
    ch_tmp = ((struct i40e_channel *)__mptr_1);
  }
  #line 9803 
  return 0;
}

#line 9814  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_prep_for_reset(struct i40e_pf *pf, bool lock_acquired)
{
  #line 9818 
  u32 v;
  #line 9816 
  struct i40e_hw *hw = & pf->hw;
  #line 9817 
  i40e_status ret = 0;
  #line 9820 
  cif_clear_bit_1(11L,(unsigned long *)(& pf->state));
  #line 9821 
  if ((int)test_and_set_bit(8L,(unsigned long *)(& pf->state)) != 0) 
    #line 9822 
    return;
  #line 9823 
  if ((int)i40e_check_asq_alive(& pf->hw) != 0) 
                                                #line 9824 
                                                i40e_vc_notify_reset(pf);
  {
    #line 9826 
    bool branch;
    #line 9826 
    struct _ddebug __UNIQUE_ID_ddebug641 = {.modname = (char *)"i40e", .function = (char *)"i40e_prep_for_reset", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Tearing down internal switch for reset\n", .lineno = (unsigned int)9826U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 9826 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug641.key.dd_key_false.key,(_Bool)0);
    #line 9826 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 9826 
                                                __dynamic_dev_dbg(& __UNIQUE_ID_ddebug641,& (pf->pdev)->dev,(char *)"Tearing down internal switch for reset\n");
  }
  #line 9830 
  if (! lock_acquired) 
                       #line 9831 
                       rtnl_lock();
  #line 9832 
  i40e_pf_quiesce_all_vsi(pf);
  #line 9833 
  if (! lock_acquired) 
                       #line 9834 
                       rtnl_unlock();
  #line 9836 
  v = 0U;
  #line 9836 
  while ((unsigned int)pf->num_alloc_vsi > v) {
    #line 9837 
    if (*(pf->vsi + (unsigned long)v) != (struct i40e_vsi *)0) 
                                                               #line 9838 
                                                               (*(pf->vsi + (unsigned long)v))->seid = (unsigned short)0U;
    #line 9836 
    v ++;
  }
  #line 9841 
  i40e_shutdown_adminq(& pf->hw);
  #line 9844 
  if (hw->hmc.hmc_obj != (struct i40e_hmc_obj_info *)0) {
    #line 9845 
    ret = i40e_shutdown_lan_hmc(hw);
    #line 9846 
    if (ret != I40E_SUCCESS) 
                             #line 9847 
                             _dev_warn(& (pf->pdev)->dev,(char *)"shutdown_lan_hmc failed: %d\n",(int)ret);
  }
  #line 9854 
  i40e_ptp_save_hw_time(pf);
  #line 9855 
  return;
}

#line 9861  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_send_version(struct i40e_pf *pf)
{
  #line 9863 
  struct i40e_driver_version dv;
  #line 9865 
  dv.major_version = (unsigned char)2U;
  #line 9866 
  dv.minor_version = (unsigned char)8U;
  #line 9867 
  dv.build_version = (unsigned char)20U;
  #line 9868 
  dv.subbuild_version = (unsigned char)0U;
  #line 9869 
  strlcpy((char *)(& dv.driver_string),(char *)"2",32UL);
  #line 9870 
  i40e_aq_send_driver_version(& pf->hw,& dv,(struct i40e_asq_cmd_details *)0);
  #line 9871 
  return;
}

#line 9877  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_get_oem_version(struct i40e_hw *hw)
{
  #line 9879 
  u16 block_offset = (unsigned short)65535U;
  #line 9880 
  u16 block_length = (unsigned short)0U;
  #line 9881 
  u16 capabilities = (unsigned short)0U;
  #line 9882 
  u16 gen_snap = (unsigned short)0U;
  #line 9883 
  u16 release = (unsigned short)0U;
  #line 9894 
  i40e_read_nvm_word(hw,(unsigned short)27,& block_offset);
  #line 9895 
  if ((unsigned int)block_offset == 65535U) 
                                            #line 9896 
                                            return;
  #line 9899 
  i40e_read_nvm_word(hw,(unsigned short)((int)block_offset),& block_length);
  #line 9901 
  if ((unsigned int)block_length <= 2U) 
                                        #line 9902 
                                        return;
  #line 9905 
  i40e_read_nvm_word(hw,(unsigned short)((int)((unsigned int)block_offset + 1U)),& capabilities);
  #line 9907 
  if (((int)capabilities & 15) != 0) 
                                     #line 9908 
                                     return;
  #line 9910 
  i40e_read_nvm_word(hw,(unsigned short)((int)((unsigned int)block_offset + 2U)),& gen_snap);
  #line 9912 
  i40e_read_nvm_word(hw,(unsigned short)((int)((unsigned int)block_offset + 3U)),& release);
  #line 9914 
  hw->nvm.oem_ver = (unsigned int)(((int)gen_snap << 16) | (int)release);
  #line 9915 
  hw->nvm.eetrack = 4294967295U;
  #line 9916 
  return;
}

#line 9922  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_reset(struct i40e_pf *pf)
{
  #line 9925 
  i40e_status ret;
  #line 9924 
  struct i40e_hw *hw = & pf->hw;
  #line 9927 
  ret = i40e_pf_reset(hw);
  #line 9928 
  if (ret != I40E_SUCCESS) {
    #line 9929 
    _dev_info(& (pf->pdev)->dev,(char *)"PF reset failed, %d\n",(int)ret);
    #line 9930 
    cif_set_bit_1(24L,(unsigned long *)(& pf->state));
    #line 9931 
    cif_clear_bit_1(8L,(unsigned long *)(& pf->state));
  }
  else 
       #line 9933 
       pf->pfr_count = (u16)((int)pf->pfr_count + 1);
  #line 9935 
  return (int)ret;
}

#line 9945  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_rebuild(struct i40e_pf *pf, bool reinit, bool lock_acquired)
{
  #line 9951 
  i40e_status ret;
  #line 9952 
  u32 val;
  #line 9953 
  int v;
  #line 9947 
  int old_recovery_mode_bit = (int)test_bit(34L,(unsigned long *)(& pf->state));
  #line 9948 
  struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)pf->lan_vsi);
  #line 9949 
  struct i40e_hw *hw = & pf->hw;
  #line 9950 
  u8 set_fc_aq_fail = (unsigned char)0U;
  #line 9955 
  if ((int)test_bit(16L,(unsigned long *)(& pf->state)) != 0) {
    #line 9955 
    if ((int)i40e_check_recovery_mode(pf) != 0) 
                                                #line 9957 
                                                i40e_set_ethtool_ops((*(pf->vsi + (unsigned long)pf->lan_vsi))->netdev);
  }
  #line 9960 
  if ((int)test_bit(3L,(unsigned long *)(& pf->state)) != 0) {
    #line 9961 
    if (! test_bit(34L,(unsigned long *)(& pf->state))) 
      #line 9961 
      if (old_recovery_mode_bit == 0) 
                                      #line 9963 
                                      goto clear_recovery;
  }
  {
    #line 9964 
    bool branch;
    #line 9964 
    struct _ddebug __UNIQUE_ID_ddebug642 = {.modname = (char *)"i40e", .function = (char *)"i40e_rebuild", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Rebuilding internal switch\n", .lineno = (unsigned int)9964U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 9964 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug642.key.dd_key_false.key,(_Bool)0);
    #line 9964 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 9964 
                                                __dynamic_dev_dbg(& __UNIQUE_ID_ddebug642,& (pf->pdev)->dev,(char *)"Rebuilding internal switch\n");
  }
  #line 9967 
  ret = i40e_init_adminq(& pf->hw);
  #line 9968 
  if (ret != I40E_SUCCESS) {
    #line 9969 
    ;
    #line 9969 
    _dev_info(& (pf->pdev)->dev,(char *)"Rebuild AdminQ failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 9972 
    goto clear_recovery;
  }
  #line 9974 
  i40e_get_oem_version(& pf->hw);
  #line 9976 
  if ((int)test_bit(16L,(unsigned long *)(& pf->state)) != 0) 
    #line 9976 
    if ((unsigned int)hw->aq.fw_maj_ver == 4U && (unsigned int)hw->aq.fw_min_ver <= 33U || (unsigned int)hw->aq.fw_maj_ver <= 3U) 
      #line 9978 
      if (hw->mac.type == (unsigned int)I40E_MAC_XL710) {
        #line 9984 
        unsigned long __ms = 300UL;
        #line 9984 
        while (1) {
          #line 9984 
          unsigned long tmp_7;
          #line 9984 
          tmp_7 = __ms;
          #line 9984 
          __ms --;
          #line 9984 
          ;
          #line 9984 
          if (! (tmp_7 != 0UL)) 
                                #line 9984 
                                break;
          #line 9984 
          __const_udelay(4295000UL);
        }
      }
  #line 9988 
  if ((int)test_and_set_bit(16L,(unsigned long *)(& pf->state)) != 0) 
    #line 9989 
    i40e_verify_eeprom(pf);
  #line 9995 
  if ((int)test_bit(34L,(unsigned long *)(& pf->state)) != 0) 
                                                              #line 9995 
                                                              goto _LOR;
  else 
    #line 9995 
    if (old_recovery_mode_bit != 0) {
      #line 9995 
      _LOR: {
              #line 9997 
              if (i40e_get_capabilities(pf,
                               (enum i40e_admin_queue_opc)i40e_aqc_opc_list_func_capabilities) != 0) 
                #line 9999 
                goto end_unlock;
              #line 10001 
              if ((int)test_bit(34L,(unsigned long *)(& pf->state)) != 0) {
                #line 10005 
                if (i40e_setup_misc_vector_for_recovery_mode(pf) != 0) 
                  #line 10006 
                  goto end_unlock;
              }
              else {
                #line 10008 
                if (! lock_acquired) 
                                     #line 10009 
                                     rtnl_lock();
                #line 10014 
                cif_free_irq((pf->pdev)->irq,(void *)pf);
                #line 10015 
                i40e_clear_interrupt_scheme(pf);
                #line 10016 
                if (i40e_restore_interrupt_scheme(pf) != 0) 
                                                            #line 10017 
                                                            goto end_unlock;
              }
              #line 10021 
              i40e_send_version(pf);
              #line 10026 
              goto end_unlock;
            }
    }
  #line 10029 
  i40e_clear_pxe_mode(hw);
  #line 10030 
  ret = (enum i40e_status_code)i40e_get_capabilities(pf,
                               (enum i40e_admin_queue_opc)i40e_aqc_opc_list_func_capabilities);
  #line 10031 
  if (ret != I40E_SUCCESS) 
                           #line 10032 
                           goto end_core_reset;
  #line 10034 
  ret = i40e_init_lan_hmc(hw,hw->func_caps.num_tx_qp,hw->func_caps.num_rx_qp,0U,0U);
  #line 10036 
  if (ret != I40E_SUCCESS) {
    #line 10037 
    _dev_info(& (pf->pdev)->dev,(char *)"init_lan_hmc failed: %d\n",(int)ret);
    #line 10038 
    goto end_core_reset;
  }
  #line 10040 
  ret = i40e_configure_lan_hmc(hw,(enum i40e_hmc_model)I40E_HMC_MODEL_DIRECT_ONLY);
  #line 10041 
  if (ret != I40E_SUCCESS) {
    #line 10042 
    _dev_info(& (pf->pdev)->dev,(char *)"configure_lan_hmc failed: %d\n",(int)ret);
    #line 10043 
    goto end_core_reset;
  }
  #line 10047 
  i40e_aq_set_dcb_parameters(hw,(_Bool)1,(struct i40e_asq_cmd_details *)0);
  #line 10050 
  ret = (enum i40e_status_code)i40e_init_pf_dcb(pf);
  #line 10051 
  if (ret != I40E_SUCCESS) {
    #line 10052 
    _dev_info(& (pf->pdev)->dev,(char *)"DCB init failed %d, disabled\n",(int)ret);
    #line 10053 
    pf->flags &= 4294967231U;
  }
  #line 10058 
  if (! lock_acquired) 
                       #line 10059 
                       rtnl_lock();
  #line 10060 
  ret = (enum i40e_status_code)i40e_setup_pf_switch(pf,(_Bool)((bool)((int)reinit) != 0));
  #line 10061 
  if (ret != I40E_SUCCESS) 
                           #line 10062 
                           goto end_unlock;
  #line 10067 
  ret = i40e_aq_set_phy_int_mask(& pf->hw,(unsigned short)65273,(struct i40e_asq_cmd_details *)0);
  #line 10071 
  if (ret != I40E_SUCCESS) {
    #line 10072 
    ;
    #line 10072 
    _dev_info(& (pf->pdev)->dev,(char *)"set phy mask fail, err %s aq_err %s\n",i40e_stat_str(& pf->hw,ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
  }
  #line 10077 
  ret = i40e_set_fc(& pf->hw,& set_fc_aq_fail,(_Bool)1);
  #line 10078 
  if (ret != I40E_SUCCESS) {
    #line 10079 
    bool branch_0;
    #line 10079 
    struct _ddebug __UNIQUE_ID_ddebug643 = {.modname = (char *)"i40e", .function = (char *)"i40e_rebuild", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"setting flow control: ret = %s last_status = %s\n", .lineno = (unsigned int)10079U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 10079 
    branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug643.key.dd_key_false.key,(_Bool)0);
    #line 10079 
    if ((long)((long)((int)branch_0 != 0)) != 0L) {
      #line 10079 
      ;
      #line 10079 
      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug643,& (pf->pdev)->dev,(char *)"setting flow control: ret = %s last_status = %s\n",i40e_stat_str(& pf->hw,ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    }
  }
  #line 10090 
  if ((int)vsi->uplink_seid != (int)pf->mac_seid) {
    {
      #line 10091 
      bool branch_1;
      #line 10091 
      struct _ddebug __UNIQUE_ID_ddebug644 = {.modname = (char *)"i40e", .function = (char *)"i40e_rebuild", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"attempting to rebuild switch\n", .lineno = (unsigned int)10091U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 10091 
      branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug644.key.dd_key_false.key,(_Bool)0);
      #line 10091 
      if ((long)((long)((int)branch_1 != 0)) != 0L) 
                                                    #line 10091 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug644,& (pf->pdev)->dev,(char *)"attempting to rebuild switch\n");
    }
    #line 10093 
    v = 0;
    #line 10093 
    while (v <= 15) {
      #line 10094 
      if (pf->veb[v] == (struct i40e_veb *)0) 
                                              #line 10095 
                                              goto __Cont;
      #line 10097 
      if ((int)(pf->veb[v])->uplink_seid == (int)pf->mac_seid || (unsigned int)(pf->veb[v])->uplink_seid == 0U) {
        #line 10099 
        ret = (enum i40e_status_code)i40e_reconstitute_veb(pf->veb[v]);
        #line 10101 
        if (ret == I40E_SUCCESS) 
                                 #line 10102 
                                 goto __Cont;
        #line 10110 
        if ((int)(pf->veb[v])->uplink_seid == (int)pf->mac_seid) {
          #line 10111 
          _dev_info(& (pf->pdev)->dev,(char *)"rebuild of switch failed: %d, will try to set up simple PF connection\n",(int)ret);
          #line 10114 
          vsi->uplink_seid = pf->mac_seid;
          #line 10115 
          break;
        }
        else 
          #line 10116 
          if ((unsigned int)(pf->veb[v])->uplink_seid == 0U) 
                                                             #line 10117 
                                                             _dev_info(& (pf->pdev)->dev,(char *)"rebuild of orphan VEB failed: %d\n",(int)ret);
      }
      #line 10093 
      __Cont: 
              #line 10093 
      v ++;
    }
  }
  #line 10125 
  if ((int)vsi->uplink_seid == (int)pf->mac_seid) {
    {
      #line 10126 
      bool branch_2;
      #line 10126 
      struct _ddebug __UNIQUE_ID_ddebug645 = {.modname = (char *)"i40e", .function = (char *)"i40e_rebuild", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"attempting to rebuild PF VSI\n", .lineno = (unsigned int)10126U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 10126 
      branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug645.key.dd_key_false.key,(_Bool)0);
      #line 10126 
      if ((long)((long)((int)branch_2 != 0)) != 0L) 
                                                    #line 10126 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug645,& (pf->pdev)->dev,(char *)"attempting to rebuild PF VSI\n");
    }
    #line 10128 
    ret = (enum i40e_status_code)i40e_add_vsi(vsi);
    #line 10129 
    if (ret != I40E_SUCCESS) {
      #line 10130 
      _dev_info(& (pf->pdev)->dev,(char *)"rebuild of Main VSI failed: %d\n",(int)ret);
      #line 10132 
      goto end_unlock;
    }
  }
  #line 10136 
  if (vsi->mqprio_qopt.max_rate[0] != 0ULL) {
    #line 10137 
    u64 max_tx_rate = vsi->mqprio_qopt.max_rate[0];
    #line 10138 
    u64 credits = 0ULL;
    {
      #line 10140 
      uint32_t __rem;
      #line 10140 
      uint32_t __base = 125000U;
      #line 10140 
      __rem = (unsigned int)(max_tx_rate % (unsigned long long)__base);
      #line 10140 
      max_tx_rate /= (unsigned long long)__base;
      #line 10140 
      uint32_t tmp_27 = __rem;
    }
    #line 10141 
    ret = (enum i40e_status_code)i40e_set_bw_limit(vsi,(unsigned short)((int)vsi->seid),
                             max_tx_rate);
    #line 10142 
    if (ret != I40E_SUCCESS) 
                             #line 10143 
                             goto end_unlock;
    #line 10145 
    credits = max_tx_rate;
    {
      #line 10146 
      uint32_t __rem_0;
      #line 10146 
      uint32_t __base_0 = 50U;
      #line 10146 
      __rem_0 = (unsigned int)(credits % (unsigned long long)__base_0);
      #line 10146 
      credits /= (unsigned long long)__base_0;
      #line 10146 
      uint32_t tmp_29 = __rem_0;
    }
    {
      #line 10147 
      bool branch_3;
      #line 10147 
      struct _ddebug __UNIQUE_ID_ddebug646 = {.modname = (char *)"i40e", .function = (char *)"i40e_rebuild", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Set tx rate of %llu Mbps (count of 50Mbps %llu) for vsi->seid %u\n", .lineno = (unsigned int)10147U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 10147 
      branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug646.key.dd_key_false.key,(_Bool)0);
      #line 10147 
      if ((long)((long)((int)branch_3 != 0)) != 0L) 
                                                    #line 10147 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug646,& ((vsi->back)->pdev)->dev,(char *)"Set tx rate of %llu Mbps (count of 50Mbps %llu) for vsi->seid %u\n",max_tx_rate,credits,(int)vsi->seid);
    }
  }
  #line 10154 
  ret = (enum i40e_status_code)i40e_rebuild_cloud_filters(vsi,(unsigned short)((int)vsi->seid));
  #line 10155 
  if (ret != I40E_SUCCESS) 
                           #line 10156 
                           goto end_unlock;
  #line 10161 
  ret = (enum i40e_status_code)i40e_rebuild_channels(vsi);
  #line 10162 
  if (ret != I40E_SUCCESS) 
                           #line 10163 
                           goto end_unlock;
  #line 10172 
  val = readl((void *)(hw->hw_addr + 943324U));
  #line 10173 
  if ((val & 67043328U) > 4194304U) {
    #line 10174 
    val &= 4227923967U;
    #line 10175 
    val |= 4194304U;
    #line 10176 
    writel(val,(void *)(hw->hw_addr + 943324U));
  }
  #line 10179 
  if (((unsigned long)pf->hw_features & 262144UL) != 0UL) {
    #line 10180 
    msleep(75U);
    #line 10181 
    ret = i40e_aq_set_link_restart_an(& pf->hw,(_Bool)1,(struct i40e_asq_cmd_details *)0);
    #line 10182 
    if (ret != I40E_SUCCESS) {
      #line 10183 
      ;
      #line 10183 
      _dev_info(& (pf->pdev)->dev,(char *)"link restart failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    }
  }
  #line 10189 
  if (((unsigned long)pf->flags & 4UL) != 0UL) {
    #line 10190 
    ret = (enum i40e_status_code)i40e_setup_misc_vector(pf);
  }
  #line 10198 
  i40e_add_filter_to_drop_tx_flow_control_frames(& pf->hw,(unsigned short)((int)pf->main_vsi_seid));
  #line 10202 
  i40e_pf_unquiesce_all_vsi(pf);
  #line 10205 
  if (! lock_acquired) 
                       #line 10206 
                       rtnl_unlock();
  #line 10209 
  ret = (enum i40e_status_code)i40e_set_promiscuous(pf,(_Bool)((bool)((int)pf->cur_promisc) != 0));
  #line 10210 
  if (ret != I40E_SUCCESS) {
    #line 10211 
    char *tmp_35;
    #line 10211 
    char *tmp_36;
    #line 10211 
    char *tmp_37;
    #line 10211 
    tmp_35 = i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status);
    #line 10211 
    tmp_36 = i40e_stat_str(& pf->hw,ret);
    #line 10211 
    if ((int)pf->cur_promisc != 0) 
                                   #line 10211 
                                   tmp_37 = (char *)"on"; else 
                                                               #line 10211 
                                                               tmp_37 = (char *)"off";
    #line 10211 
    ;
    #line 10211 
    _dev_warn(& (pf->pdev)->dev,(char *)"Failed to restore promiscuous setting: %s, err %s aq_err %s\n",tmp_37,tmp_36,tmp_35);
  }
  #line 10217 
  i40e_reset_all_vfs(pf,(_Bool)1);
  #line 10220 
  i40e_send_version(pf);
  #line 10223 
  goto end_core_reset;
  #line 10225 
  end_unlock: 
              #line 10225 
  ;
  #line 10226 
  if (! lock_acquired) 
                       #line 10227 
                       rtnl_unlock();
  #line 10228 
  end_core_reset: 
                  #line 10228 
  ;
  #line 10229 
  cif_clear_bit_1(24L,(unsigned long *)(& pf->state));
  #line 10230 
  clear_recovery: 
                  #line 10230 
  ;
  #line 10231 
  cif_clear_bit_1(8L,(unsigned long *)(& pf->state));
  #line 10232 
  cif_clear_bit_1(9L,(unsigned long *)(& pf->state));
  #line 10233 
  return;
}

#line 10242  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_reset_and_rebuild(struct i40e_pf *pf, bool reinit, bool lock_acquired)
{
  #line 10245 
  int ret;
  #line 10250 
  ret = i40e_reset(pf);
  #line 10251 
  if (ret == 0) 
                #line 10252 
                i40e_rebuild(pf,(_Bool)((bool)((int)reinit) != 0),(_Bool)((bool)((int)lock_acquired) != 0));
  #line 10253 
  return;
}

#line 10264  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_handle_reset_warning(struct i40e_pf *pf, bool lock_acquired)
{
  #line 10266 
  i40e_prep_for_reset(pf,(_Bool)((bool)((int)lock_acquired) != 0));
  #line 10267 
  i40e_reset_and_rebuild(pf,(_Bool)0,(_Bool)((bool)((int)lock_acquired) != 0));
  #line 10268 
  return;
}

#line 10276  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_handle_mdd_event(struct i40e_pf *pf)
{
  #line 10280 
  struct i40e_vf *vf;
  #line 10281 
  u32 reg;
  #line 10282 
  int i;
  #line 10278 
  struct i40e_hw *hw = & pf->hw;
  #line 10279 
  bool mdd_detected = (_Bool)0;
  #line 10284 
  if (! test_bit(6L,(unsigned long *)(& pf->state))) 
                                                     #line 10285 
                                                     return;
  #line 10288 
  reg = readl((void *)(hw->hw_addr + 943232U));
  #line 10289 
  if ((reg & 2147483648U) != 0U) {
    #line 10290 
    u8 pf_num = (unsigned char)((unsigned int)((unsigned char)(reg >> 21)) & 15U);
    #line 10292 
    u16 vf_num = (unsigned short)((unsigned int)((unsigned short)(reg >> 12)) & 511U);
    #line 10294 
    u8 event = (unsigned char)((unsigned int)((unsigned char)(reg >> 25)) & 31U);
    #line 10296 
    u16 queue = (unsigned short)(((unsigned int)((unsigned short)reg) & 4095U) - (unsigned int)((unsigned short)pf->hw.func_caps.base_queue));
    #line 10299 
    if ((pf->msg_enable & 128U) != 0U) 
                                       #line 10300 
                                       _dev_info(& (pf->pdev)->dev,(char *)"Malicious Driver Detection event 0x%02x on TX queue %d PF number 0x%02x VF number 0x%02x\n",(int)event,(int)queue,(int)pf_num,(int)vf_num);
    #line 10302 
    writel(4294967295U,(void *)(hw->hw_addr + 943232U));
    #line 10303 
    mdd_detected = (_Bool)1;
  }
  #line 10305 
  reg = readl((void *)(hw->hw_addr + 1221904U));
  #line 10306 
  if ((reg & 2147483648U) != 0U) {
    #line 10307 
    u8 func = (unsigned char)reg;
    #line 10309 
    u8 event_0 = (unsigned char)(reg >> 8);
    #line 10311 
    u16 queue_0 = (unsigned short)(((unsigned int)((unsigned short)(reg >> 17)) & 16383U) - (unsigned int)((unsigned short)pf->hw.func_caps.base_queue));
    #line 10314 
    if ((pf->msg_enable & 64U) != 0U) 
                                      #line 10315 
                                      _dev_info(& (pf->pdev)->dev,(char *)"Malicious Driver Detection event 0x%02x on RX queue %d of function 0x%02x\n",(int)event_0,(int)queue_0,(int)func);
    #line 10317 
    writel(4294967295U,(void *)(hw->hw_addr + 1221904U));
    #line 10318 
    mdd_detected = (_Bool)1;
  }
  #line 10321 
  if ((int)mdd_detected != 0) {
    #line 10322 
    reg = readl((void *)(hw->hw_addr + 943104U));
    #line 10323 
    if ((reg & 1U) != 0U) {
      #line 10324 
      writel(65535U,(void *)(hw->hw_addr + 943104U));
      {
        #line 10325 
        bool branch;
        #line 10325 
        struct _ddebug __UNIQUE_ID_ddebug647 = {.modname = (char *)"i40e", .function = (char *)"i40e_handle_mdd_event", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"TX driver issue detected on PF\n", .lineno = (unsigned int)10325U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 10325 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug647.key.dd_key_false.key,(_Bool)0);
        #line 10325 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 10325 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug647,& (pf->pdev)->dev,(char *)"TX driver issue detected on PF\n");
      }
    }
    #line 10327 
    reg = readl((void *)(hw->hw_addr + 1221632U));
    #line 10328 
    if ((reg & 1U) != 0U) {
      #line 10329 
      writel(65535U,(void *)(hw->hw_addr + 1221632U));
      {
        #line 10330 
        bool branch_0;
        #line 10330 
        struct _ddebug __UNIQUE_ID_ddebug648 = {.modname = (char *)"i40e", .function = (char *)"i40e_handle_mdd_event", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"RX driver issue detected on PF\n", .lineno = (unsigned int)10330U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 10330 
        branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug648.key.dd_key_false.key,(_Bool)0);
        #line 10330 
        if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                      #line 10330 
                                                      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug648,& (pf->pdev)->dev,(char *)"RX driver issue detected on PF\n");
      }
    }
  }
  #line 10335 
  i = 0;
  #line 10335 
  while (pf->num_alloc_vfs > i && (int)mdd_detected != 0) {
    #line 10336 
    vf = pf->vf + (unsigned long)i;
    #line 10337 
    reg = readl((void *)(hw->hw_addr + (unsigned long)((i + 235520) * 4)));
    #line 10338 
    if ((reg & 1U) != 0U) {
      #line 10339 
      writel(65535U,(void *)(hw->hw_addr + (unsigned long)((i + 235520) * 4)));
      #line 10340 
      (vf->num_mdd_events) ++;
      #line 10341 
      _dev_info(& (pf->pdev)->dev,(char *)"TX driver issue detected on VF %d\n",i);
      #line 10343 
      _dev_info(& (pf->pdev)->dev,(char *)"Use PF Control I/F to re-enable the VF\n");
      #line 10345 
      cif_set_bit_1(3L,& vf->vf_states);
    }
    #line 10348 
    reg = readl((void *)(hw->hw_addr + (unsigned long)((i + 305152) * 4)));
    #line 10349 
    if ((reg & 1U) != 0U) {
      #line 10350 
      writel(65535U,(void *)(hw->hw_addr + (unsigned long)((i + 305152) * 4)));
      #line 10351 
      (vf->num_mdd_events) ++;
      #line 10352 
      _dev_info(& (pf->pdev)->dev,(char *)"RX driver issue detected on VF %d\n",i);
      #line 10354 
      _dev_info(& (pf->pdev)->dev,(char *)"Use PF Control I/F to re-enable the VF\n");
      #line 10356 
      cif_set_bit_1(3L,& vf->vf_states);
    }
    #line 10335 
    i ++;
  }
  #line 10361 
  cif_clear_bit_1(6L,(unsigned long *)(& pf->state));
  #line 10362 
  reg = readl((void *)(hw->hw_addr + 231424U));
  #line 10363 
  reg |= 524288U;
  #line 10364 
  writel(reg,(void *)(hw->hw_addr + 231424U));
  #line 10365 
  readl((void *)(hw->hw_addr + 745772U));
  #line 10366 
  return;
}

#line 10368  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static char *i40e_tunnel_name(u8 type)
{
  #line 10370 
  switch ((int)type) {
    #line 10371 
    case 0: 
            #line 10371 
    ;
    #line 10372 
    return (char *)"vxlan";
    #line 10373 
    case 1: 
            #line 10373 
    ;
    #line 10374 
    return (char *)"geneve";
    #line 10375 
    default: 
             #line 10375 
    ;
    #line 10376 
    return (char *)"unknown";
  }
}

#line 10384  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_sync_udp_filters(struct i40e_pf *pf)
{
  #line 10386 
  int i;
  #line 10389 
  i = 0;
  #line 10389 
  while (i <= 15) {
    #line 10390 
    if ((unsigned int)pf->udp_ports[i].port != 0U) 
                                                   #line 10391 
                                                   pf->pending_udp_bitmap = (unsigned short)((int)pf->pending_udp_bitmap | (int)((unsigned short)(1ULL << i)));
    #line 10389 
    i ++;
  }
  #line 10394 
  cif_set_bit_1(28L,(unsigned long *)(& pf->state));
  #line 10395 
  return;
}

#line 10401  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_sync_udp_filters_subtask(struct i40e_pf *pf)
{
  #line 10404 
  u8 filter_index;
  #line 10404 
  u8 type;
  #line 10405 
  u16 port;
  #line 10406 
  int i;
  #line 10403 
  struct i40e_hw *hw = & pf->hw;
  #line 10408 
  if (! test_and_set_bit(28L,(unsigned long *)(& pf->state))) 
                                                              #line 10409 
                                                              return;
  #line 10412 
  rtnl_lock();
  #line 10414 
  i = 0;
  #line 10414 
  while (i <= 15) {
    #line 10415 
    if ((((unsigned long long)pf->pending_udp_bitmap >> i) & 1ULL) != 0ULL) {
      #line 10425 
      union __anonunion___u_9846 __u_1;
      #line 10423 
      union __anonunion___u_9842 __u;
      #line 10424 
      union __anonunion___u_9844 __u_0;
      #line 10416 
      struct i40e_udp_port_config *udp_port;
      #line 10417 
      i40e_status ret = 0;
      #line 10419 
      udp_port = & pf->udp_ports[i];
      #line 10420 
      pf->pending_udp_bitmap = (unsigned short)((int)pf->pending_udp_bitmap & ~ ((int)((unsigned short)(1ULL << i))));
      #line 10422 
      __read_once_size((void *)(& udp_port->port),(void *)(& __u.__c),2);
      #line 10422 
      port = (__u.__val);
      #line 10423 
      __read_once_size((void *)(& udp_port->type),(void *)(& __u_0.__c),1);
      #line 10423 
      type = (__u_0.__val);
      #line 10424 
      __read_once_size((void *)(& udp_port->filter_index),(void *)(& __u_1.__c),1);
      #line 10424 
      filter_index = (__u_1.__val);
      #line 10427 
      rtnl_unlock();
      #line 10429 
      if ((unsigned int)port != 0U) 
                                    #line 10430 
                                    ret = i40e_aq_add_udp_tunnel(hw,(unsigned short)((int)port),(unsigned char)((int)type),& filter_index,(struct i40e_asq_cmd_details *)0);
      else 
        #line 10434 
        if ((unsigned int)filter_index != 255U) 
                                                #line 10435 
                                                ret = i40e_aq_del_udp_tunnel(hw,(unsigned char)((int)filter_index),(struct i40e_asq_cmd_details *)0);
      #line 10439 
      rtnl_lock();
      #line 10441 
      if (ret != I40E_SUCCESS) {
        #line 10442 
        char *tmp_3;
        #line 10442 
        char *tmp_4;
        #line 10442 
        char *tmp_5;
        #line 10442 
        tmp_3 = i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status);
        #line 10442 
        tmp_4 = i40e_stat_str(& pf->hw,ret);
        #line 10442 
        ;
        #line 10442 
        ;
        #line 10442 
        if ((unsigned int)port != 0U) 
                                      #line 10442 
                                      tmp_5 = (char *)"add"; else 
                                                                  #line 10442 
                                                                  tmp_5 = (char *)"delete";
        #line 10442 
        ;
        #line 10442 
        _dev_info(& (pf->pdev)->dev,(char *)"%s %s port %d, index %d failed, err %s aq_err %s\n",i40e_tunnel_name((unsigned char)((int)type)),tmp_5,(int)port,(int)filter_index,tmp_4,tmp_3);
        #line 10451 
        if ((unsigned int)port != 0U) {
          #line 10455 
          udp_port->port = (unsigned short)0U;
          #line 10456 
          pf->pending_udp_bitmap = (unsigned short)((int)pf->pending_udp_bitmap & ~ ((int)((unsigned short)(1ULL << i))));
        }
      }
      else 
        #line 10458 
        if ((unsigned int)port != 0U) 
                                      #line 10460 
                                      udp_port->filter_index = filter_index;
    }
    #line 10414 
    i ++;
  }
  #line 10465 
  rtnl_unlock();
  #line 10466 
  return;
}

#line 10472  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_service_task(struct work_struct *work)
{
  #line 10474 
  void *__mptr;
  #line 10474 
  __mptr = (void *)work;
  #line 10474 
  struct i40e_pf *pf = ((struct i40e_pf *)(__mptr + 18446744073709549248U));
  #line 10477 
  unsigned long start_time = jiffies;
  #line 10480 
  if ((int)test_bit(8L,(unsigned long *)(& pf->state)) != 0) 
                                                             #line 10482 
                                                             return;
  else {
    #line 10480 
    if ((int)test_bit(17L,(unsigned long *)(& pf->state)) != 0) 
                                                                #line 10482 
                                                                return;
  }
  #line 10484 
  if ((int)test_and_set_bit(4L,(unsigned long *)(& pf->state)) != 0) 
    #line 10485 
    return;
  #line 10487 
  if (test_bit(34L,(unsigned long *)(& pf->state))) 
                                                    #line 10509 
                                                    i40e_reset_subtask(pf);
  else {
    #line 10488 
    i40e_detect_recover_hung(*(pf->vsi + (unsigned long)pf->lan_vsi));
    #line 10489 
    i40e_sync_filters_subtask(pf);
    #line 10490 
    i40e_reset_subtask(pf);
    #line 10491 
    i40e_handle_mdd_event(pf);
    #line 10492 
    i40e_vc_process_vflr_event(pf);
    #line 10493 
    i40e_watchdog_subtask(pf);
    #line 10494 
    i40e_fdir_reinit_subtask(pf);
    #line 10495 
    if ((int)test_and_set_bit(32L,(unsigned long *)(& pf->state)) != 0) 
      #line 10497 
      i40e_notify_client_of_netdev_close(*(pf->vsi + (unsigned long)pf->lan_vsi),(_Bool)1);
    else {
      #line 10500 
      i40e_client_subtask(pf);
      #line 10501 
      if ((int)test_and_set_bit(31L,(unsigned long *)(& pf->state)) != 0) 
        #line 10503 
        i40e_notify_client_of_l2_param_changes(*(pf->vsi + (unsigned long)pf->lan_vsi));
    }
    #line 10506 
    i40e_sync_filters_subtask(pf);
    #line 10507 
    i40e_sync_udp_filters_subtask(pf);
  }
  #line 10512 
  i40e_clean_adminq_subtask(pf);
  #line 10516 
  cif_clear_bit_1(4L,(unsigned long *)(& pf->state));
  {
    #line 10522 
    unsigned long __dummy;
    #line 10522 
    unsigned long __dummy2;
    }
  #line 10522 
  if (1 != 0) {
    {
      #line 10522 
      unsigned long __dummy_0;
      #line 10522 
      unsigned long __dummy2_0;
      }
    #line 10522 
    if (1 != 0) {
      #line 10522 
      if ((long)((pf->service_timer_period + start_time) - jiffies) < 0L) 
        #line 10526 
        i40e_service_event_schedule(pf); else 
                                              #line 10522 
                                              goto _LAND_0;
    }
    else 
         #line 10522 
         goto _LAND_0;
  }
  else {
    #line 10522 
    _LAND_0: 
    #line 10522 
    if ((int)test_bit(5L,(unsigned long *)(& pf->state)) != 0) 
                                                               #line 10526 
                                                               i40e_service_event_schedule(pf);
    else {
      #line 10523 
      if ((int)test_bit(6L,(unsigned long *)(& pf->state)) != 0) 
                                                                 #line 10526 
                                                                 i40e_service_event_schedule(pf);
      else {
        #line 10524 
        if ((int)test_bit(7L,(unsigned long *)(& pf->state)) != 0) 
                                                                   #line 10526 
                                                                   i40e_service_event_schedule(pf);
      }
    }
  }
  #line 10527 
  return;
}

#line 10533  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_service_timer(struct timer_list *t)
{
  #line 10535 
  void *__mptr;
  #line 10535 
  __mptr = (void *)t;
  #line 10535 
  struct i40e_pf *pf = ((struct i40e_pf *)(__mptr + 18446744073709549336U));
  #line 10537 
  ;
  #line 10537 
  cif_mod_timer(& pf->service_timer,round_jiffies(pf->service_timer_period + jiffies));
  #line 10539 
  i40e_service_event_schedule(pf);
  #line 10540 
  return;
}

#line 10546  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_set_num_rings_in_vsi(struct i40e_vsi *vsi)
{
  #line 10548 
  struct i40e_pf *pf = vsi->back;
  #line 10550 
  switch ((unsigned int)vsi->type) {
    #line 10551 
    case (unsigned int)0: 
                          #line 10551 
    ;
    #line 10552 
    vsi->alloc_queue_pairs = pf->num_lan_qps;
    #line 10553 
    if ((unsigned int)vsi->num_tx_desc == 0U) 
                                              #line 10554 
                                              vsi->num_tx_desc = (unsigned short)512U;
    #line 10556 
    if ((unsigned int)vsi->num_rx_desc == 0U) 
                                              #line 10557 
                                              vsi->num_rx_desc = (unsigned short)512U;
    #line 10559 
    if (((unsigned long)pf->flags & 4UL) != 0UL) 
                                                 #line 10560 
                                                 vsi->num_q_vectors = (int)pf->num_lan_msix; else 
                                                                    #line 10562 
                                                                    vsi->num_q_vectors = 1;
    #line 10564 
    break;
    #line 10566 
    case (unsigned int)7: 
                          #line 10566 
    ;
    #line 10567 
    vsi->alloc_queue_pairs = (unsigned short)1U;
    #line 10568 
    vsi->num_tx_desc = (unsigned short)32U;
    #line 10570 
    vsi->num_rx_desc = (unsigned short)32U;
    #line 10572 
    vsi->num_q_vectors = (int)pf->num_fdsb_msix;
    #line 10573 
    break;
    #line 10575 
    case (unsigned int)2: 
                          #line 10575 
    ;
    #line 10576 
    vsi->alloc_queue_pairs = pf->num_vmdq_qps;
    #line 10577 
    if ((unsigned int)vsi->num_tx_desc == 0U) 
                                              #line 10578 
                                              vsi->num_tx_desc = (unsigned short)512U;
    #line 10580 
    if ((unsigned int)vsi->num_rx_desc == 0U) 
                                              #line 10581 
                                              vsi->num_rx_desc = (unsigned short)512U;
    #line 10583 
    vsi->num_q_vectors = (int)pf->num_vmdq_msix;
    #line 10584 
    break;
    #line 10586 
    case (unsigned int)6: 
                          #line 10586 
    ;
    #line 10587 
    vsi->alloc_queue_pairs = pf->num_vf_qps;
    #line 10588 
    if ((unsigned int)vsi->num_tx_desc == 0U) 
                                              #line 10589 
                                              vsi->num_tx_desc = (unsigned short)512U;
    #line 10591 
    if ((unsigned int)vsi->num_rx_desc == 0U) 
                                              #line 10592 
                                              vsi->num_rx_desc = (unsigned short)512U;
    #line 10594 
    break;
    #line 10596 
    default: 
             #line 10596 
    ;
    {
      #line 10597 
      int __ret_warn_on = 1;
      #line 10597 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 10598 
        ldv_inline_asm();
        #line 10599 
        ldv_inline_asm();
      }
      #line 10597 
      long tmp = (long)(__ret_warn_on != 0);
    }
    #line 10598 
    return -61;
  }
  #line 10601 
  return 0;
}

#line 10612  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_alloc_arrays(struct i40e_vsi *vsi, bool alloc_qvectors)
{
  #line 10614 
  struct i40e_ring **next_rings;
  #line 10615 
  int size;
  #line 10619 
  unsigned int tmp_0;
  #line 10616 
  int ret = 0;
  #line 10619 
  if ((int)i40e_enabled_xdp_vsi_0(vsi) != 0) 
                                             #line 10619 
                                             tmp_0 = 3U; else 
                                                              #line 10619 
                                                              tmp_0 = 2U;
  #line 10619 
  size = (int)(((unsigned int)vsi->alloc_queue_pairs * tmp_0) * 8U);
  #line 10621 
  vsi->tx_rings = (struct i40e_ring **)kzalloc_1((unsigned long)size,3264U);
  #line 10622 
  if (vsi->tx_rings == (struct i40e_ring **)0) 
                                               #line 10623 
                                               return -12;
  #line 10624 
  next_rings = vsi->tx_rings + (unsigned long)vsi->alloc_queue_pairs;
  #line 10625 
  if ((int)i40e_enabled_xdp_vsi_0(vsi) != 0) {
    #line 10626 
    vsi->xdp_rings = next_rings;
    #line 10627 
    next_rings += (unsigned long)vsi->alloc_queue_pairs;
  }
  #line 10629 
  vsi->rx_rings = next_rings;
  #line 10631 
  if ((int)alloc_qvectors != 0) {
    #line 10633 
    size = (int)((unsigned long)vsi->num_q_vectors * (unsigned long)8U);
    #line 10634 
    vsi->q_vectors = (struct i40e_q_vector **)kzalloc_1((unsigned long)size,3264U);
    #line 10635 
    if (vsi->q_vectors == (struct i40e_q_vector **)0) {
      #line 10636 
      ret = -12;
      #line 10637 
      goto err_vectors;
    }
  }
  #line 10640 
  return ret;
  #line 10642 
  err_vectors: 
               #line 10642 
  ;
  #line 10643 
  kfree((void *)vsi->tx_rings);
  #line 10644 
  return ret;
}

#line 10655  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_mem_alloc(struct i40e_pf *pf, enum i40e_vsi_type type)
{
  #line 10658 
  struct i40e_vsi *vsi;
  #line 10659 
  int vsi_idx;
  #line 10660 
  int i;
  #line 10657 
  int ret = -19;
  #line 10663 
  cif_mutex_lock_switch_mutex_of_i40e_pf(& pf->switch_mutex);
  #line 10671 
  i = (int)pf->next_vsi;
  #line 10672 
  while ((int)pf->num_alloc_vsi > i && *(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0) 
    #line 10673 
    i ++;
  #line 10674 
  if ((int)pf->num_alloc_vsi <= i) {
    #line 10675 
    i = 0;
    #line 10676 
    while ((int)pf->next_vsi > i && *(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0) 
      #line 10677 
      i ++;
  }
  #line 10680 
  if ((int)pf->num_alloc_vsi > i && *(pf->vsi + (unsigned long)i) == (struct i40e_vsi *)0) 
    #line 10681 
    vsi_idx = i;
  else {
    #line 10683 
    ret = -19;
    #line 10684 
    goto unlock_pf;
  }
  #line 10686 
  i ++;
  #line 10686 
  pf->next_vsi = (unsigned short)i;
  #line 10688 
  vsi = (struct i40e_vsi *)kzalloc_1(8192UL,3264U);
  #line 10689 
  if (vsi == (struct i40e_vsi *)0) {
    #line 10690 
    ret = -12;
    #line 10691 
    goto unlock_pf;
  }
  #line 10693 
  vsi->type = type;
  #line 10694 
  vsi->back = pf;
  #line 10695 
  cif_set_bit_1(0L,(unsigned long *)(& vsi->state));
  #line 10696 
  vsi->flags = 0UL;
  #line 10697 
  vsi->idx = (unsigned short)vsi_idx;
  #line 10698 
  vsi->int_rate_limit = (unsigned short)0U;
  #line 10699 
  if (vsi->type == (unsigned int)I40E_VSI_MAIN) 
                                                #line 10699 
                                                vsi->rss_table_size = pf->rss_table_size; else 
                                                                    #line 10699 
                                                                    vsi->rss_table_size = (unsigned short)64U;
  #line 10701 
  vsi->netdev_registered = (_Bool)0;
  #line 10702 
  vsi->work_limit = (unsigned short)256U;
  #line 10703 
  __hash_init((struct hlist_head *)(& vsi->mac_filter_hash),256U);
  #line 10704 
  vsi->irqs_ready = (_Bool)0;
  #line 10706 
  if (type == (unsigned int)I40E_VSI_MAIN) {
    #line 10707 
    vsi->af_xdp_zc_qps = bitmap_zalloc((unsigned int)pf->num_lan_qps,3264U);
    #line 10708 
    if (vsi->af_xdp_zc_qps == (unsigned long *)0UL) 
                                                    #line 10709 
                                                    goto err_rings;
  }
  #line 10712 
  ret = i40e_set_num_rings_in_vsi(vsi);
  #line 10713 
  if (ret != 0) 
                #line 10714 
                goto err_rings;
  #line 10716 
  ret = i40e_vsi_alloc_arrays(vsi,(_Bool)1);
  #line 10717 
  if (ret != 0) 
                #line 10718 
                goto err_rings;
  #line 10721 
  i40e_vsi_setup_irqhandler(vsi,& i40e_msix_clean_rings);
  #line 10724 
  spinlock_check(& vsi->mac_filter_hash_lock);
  {
    #line 10724 
    struct lock_class_key __key;
    #line 10724 
    __raw_spin_lock_init(& vsi->mac_filter_hash_lock.__anonCompField_spinlock_25.rlock,(char *)"&(&vsi->mac_filter_hash_lock)->rlock",& __key);
  }
  #line 10725 
  *(pf->vsi + (unsigned long)vsi_idx) = vsi;
  #line 10726 
  ret = vsi_idx;
  #line 10727 
  goto unlock_pf;
  #line 10729 
  err_rings: 
             #line 10729 
  ;
  #line 10730 
  bitmap_free(vsi->af_xdp_zc_qps);
  #line 10731 
  pf->next_vsi = (unsigned short)((unsigned int)((unsigned short)i) + 65535U);
  #line 10732 
  kfree((void *)vsi);
  #line 10733 
  unlock_pf: 
             #line 10733 
  ;
  #line 10734 
  cif_mutex_unlock_switch_mutex_of_i40e_pf(& pf->switch_mutex);
  #line 10735 
  return ret;
}

#line 10746  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_free_arrays(struct i40e_vsi *vsi, bool free_qvectors)
{
  #line 10749 
  if ((int)free_qvectors != 0) {
    #line 10750 
    kfree((void *)vsi->q_vectors);
    #line 10751 
    vsi->q_vectors = (struct i40e_q_vector **)0;
  }
  #line 10753 
  kfree((void *)vsi->tx_rings);
  #line 10754 
  vsi->tx_rings = (struct i40e_ring **)0;
  #line 10755 
  vsi->rx_rings = (struct i40e_ring **)0;
  #line 10756 
  vsi->xdp_rings = (struct i40e_ring **)0;
  #line 10757 
  return;
}

#line 10764  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_clear_rss_config_user(struct i40e_vsi *vsi)
{
  #line 10766 
  if (vsi == (struct i40e_vsi *)0) 
                                   #line 10767 
                                   return;
  #line 10769 
  kfree((void *)vsi->rss_hkey_user);
  #line 10770 
  vsi->rss_hkey_user = (u8 *)0U;
  #line 10772 
  kfree((void *)vsi->rss_lut_user);
  #line 10773 
  vsi->rss_lut_user = (u8 *)0U;
  #line 10774 
  return;
}

#line 10780  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_clear(struct i40e_vsi *vsi)
{
  #line 10782 
  struct i40e_pf *pf;
  #line 10784 
  if (vsi == (struct i40e_vsi *)0) 
                                   #line 10785 
                                   return 0;
  #line 10787 
  if (vsi->back == (struct i40e_pf *)0) 
                                        #line 10788 
                                        goto free_vsi;
  #line 10789 
  pf = vsi->back;
  #line 10791 
  cif_mutex_lock_switch_mutex_of_i40e_pf(& pf->switch_mutex);
  #line 10792 
  if (*(pf->vsi + (unsigned long)vsi->idx) == (struct i40e_vsi *)0) {
    #line 10793 
    _dev_err(& (pf->pdev)->dev,(char *)"pf->vsi[%d] is NULL, just free vsi[%d](type %d)\n",(int)vsi->idx,(int)vsi->idx,(unsigned int)vsi->type);
    #line 10795 
    goto unlock_vsi;
  }
  #line 10798 
  if (*(pf->vsi + (unsigned long)vsi->idx) != vsi) {
    #line 10799 
    _dev_err(& (pf->pdev)->dev,(char *)"pf->vsi[%d](type %d) != vsi[%d](type %d): no free!\n",(int)(*(pf->vsi + (unsigned long)vsi->idx))->idx,(unsigned int)(*(pf->vsi + (unsigned long)vsi->idx))->type,(int)vsi->idx,(unsigned int)vsi->type);
    #line 10804 
    goto unlock_vsi;
  }
  #line 10808 
  i40e_put_lump(pf->qp_pile,(unsigned short)((int)vsi->base_queue),(unsigned short)((int)vsi->idx));
  #line 10809 
  i40e_put_lump(pf->irq_pile,(unsigned short)((int)((unsigned short)vsi->base_vector)),(unsigned short)((int)vsi->idx));
  #line 10811 
  bitmap_free(vsi->af_xdp_zc_qps);
  #line 10812 
  i40e_vsi_free_arrays(vsi,(_Bool)1);
  #line 10813 
  i40e_clear_rss_config_user(vsi);
  #line 10815 
  *(pf->vsi + (unsigned long)vsi->idx) = (struct i40e_vsi *)0;
  #line 10816 
  if ((int)vsi->idx < (int)pf->next_vsi) 
                                         #line 10817 
                                         pf->next_vsi = vsi->idx;
  #line 10819 
  unlock_vsi: 
              #line 10819 
  ;
  #line 10820 
  cif_mutex_unlock_switch_mutex_of_i40e_pf(& pf->switch_mutex);
  #line 10821 
  free_vsi: 
            #line 10821 
  ;
  #line 10822 
  kfree((void *)vsi);
  #line 10824 
  return 0;
}

#line 10831  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_clear_rings(struct i40e_vsi *vsi)
{
  #line 10833 
  int i;
  #line 10835 
  if (vsi->tx_rings != (struct i40e_ring **)0 && *(vsi->tx_rings) != (struct i40e_ring *)0) {
    #line 10836 
    i = 0;
    #line 10836 
    while ((int)vsi->alloc_queue_pairs > i) {
      {
        #line 10837 
        struct i40e_ring *___p = *(vsi->tx_rings + (unsigned long)i);
        #line 10837 
        if (___p != (struct i40e_ring *)0) 
                                           #line 10837 
                                           kfree_call_rcu(& ___p->rcu,(void (*)(struct callback_head *))192);
      }
      #line 10838 
      *(vsi->tx_rings + (unsigned long)i) = (struct i40e_ring *)0;
      #line 10839 
      *(vsi->rx_rings + (unsigned long)i) = (struct i40e_ring *)0;
      #line 10840 
      if (vsi->xdp_rings != (struct i40e_ring **)0) 
                                                    #line 10841 
                                                    *(vsi->xdp_rings + (unsigned long)i) = (struct i40e_ring *)0;
      #line 10836 
      i ++;
    }
  }
  #line 10844 
  return;
}

#line 10850  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_alloc_rings(struct i40e_vsi *vsi)
{
  #line 10852 
  int i;
  #line 10852 
  int tmp_0;
  #line 10854 
  struct i40e_ring *ring;
  #line 10852 
  if ((int)i40e_enabled_xdp_vsi_0(vsi) != 0) 
                                             #line 10852 
                                             tmp_0 = 3; else 
                                                             #line 10852 
                                                             tmp_0 = 2;
  #line 10852 
  int qpv = tmp_0;
  #line 10853 
  struct i40e_pf *pf = vsi->back;
  #line 10857 
  i = 0;
  #line 10857 
  while ((int)vsi->alloc_queue_pairs > i) {
    {
      #line 10875 
      struct i40e_ring *tmp_2;
      #line 10893 
      struct i40e_ring *tmp_4;
      #line 10859 
      ring = (struct i40e_ring *)kcalloc_0((unsigned long)qpv,4096UL,3264U);
      #line 10860 
      if (ring == (struct i40e_ring *)0) 
                                         #line 10861 
                                         goto err_out;
      #line 10863 
      ring->queue_index = (unsigned short)i;
      #line 10864 
      ring->reg_idx = (unsigned short)((int)vsi->base_queue + (int)((unsigned short)i));
      #line 10865 
      ring->ring_active = (_Bool)0;
      #line 10866 
      ring->vsi = vsi;
      #line 10867 
      ring->netdev = vsi->netdev;
      #line 10868 
      ring->dev = & (pf->pdev)->dev;
      #line 10869 
      ring->count = vsi->num_tx_desc;
      #line 10870 
      ring->size = 0U;
      #line 10871 
      ring->dcb_tc = (unsigned char)0U;
      #line 10872 
      if (((unsigned long)(vsi->back)->hw_features & 8UL) != 0UL) 
                                                                  #line 10873 
                                                                  ring->flags = (unsigned short)1U;
      #line 10874 
      ring->itr_setting = pf->tx_itr_default;
      #line 10875 
      tmp_2 = ring;
      #line 10875 
      ring ++;
      #line 10875 
      *(vsi->tx_rings + (unsigned long)i) = tmp_2;
      #line 10877 
      if (! i40e_enabled_xdp_vsi_0(vsi)) 
                                         #line 10878 
                                         goto setup_rx;
      #line 10880 
      ring->queue_index = (unsigned short)((int)vsi->alloc_queue_pairs + (int)((unsigned short)i));
      #line 10881 
      ring->reg_idx = (unsigned short)((int)vsi->base_queue + (int)ring->queue_index);
      #line 10882 
      ring->ring_active = (_Bool)0;
      #line 10883 
      ring->vsi = vsi;
      #line 10884 
      ring->netdev = (struct net_device *)0;
      #line 10885 
      ring->dev = & (pf->pdev)->dev;
      #line 10886 
      ring->count = vsi->num_tx_desc;
      #line 10887 
      ring->size = 0U;
      #line 10888 
      ring->dcb_tc = (unsigned char)0U;
      #line 10889 
      if (((unsigned long)(vsi->back)->hw_features & 8UL) != 0UL) 
                                                                  #line 10890 
                                                                  ring->flags = (unsigned short)1U;
      #line 10891 
      set_ring_xdp(ring);
      #line 10892 
      ring->itr_setting = pf->tx_itr_default;
      #line 10893 
      tmp_4 = ring;
      #line 10893 
      ring ++;
      #line 10893 
      *(vsi->xdp_rings + (unsigned long)i) = tmp_4;
      #line 10895 
      setup_rx: 
                #line 10895 
      ;
      #line 10896 
      ring->queue_index = (unsigned short)i;
      #line 10897 
      ring->reg_idx = (unsigned short)((int)vsi->base_queue + (int)((unsigned short)i));
      #line 10898 
      ring->ring_active = (_Bool)0;
      #line 10899 
      ring->vsi = vsi;
      #line 10900 
      ring->netdev = vsi->netdev;
      #line 10901 
      ring->dev = & (pf->pdev)->dev;
      #line 10902 
      ring->count = vsi->num_rx_desc;
      #line 10903 
      ring->size = 0U;
      #line 10904 
      ring->dcb_tc = (unsigned char)0U;
      #line 10905 
      ring->itr_setting = pf->rx_itr_default;
      #line 10906 
      *(vsi->rx_rings + (unsigned long)i) = ring;
    }
    #line 10857 
    i ++;
  }
  #line 10909 
  return 0;
  #line 10911 
  err_out: 
           #line 10911 
  ;
  #line 10912 
  i40e_vsi_clear_rings(vsi);
  #line 10913 
  return -12;
}

#line 10923  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_reserve_msix_vectors(struct i40e_pf *pf, int vectors)
{
  #line 10925 
  vectors = pci_enable_msix_range(pf->pdev,pf->msix_entries,2,vectors);
  #line 10927 
  if (vectors < 0) {
    #line 10928 
    _dev_info(& (pf->pdev)->dev,(char *)"MSI-X vector reservation failed: %d\n",vectors);
    #line 10930 
    vectors = 0;
  }
  #line 10933 
  return vectors;
}

#line 10944  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_init_msix(struct i40e_pf *pf)
{
  #line 11054 
  int __UNIQUE_ID___x656;
  #line 11054 
  int tmp_6;
  #line 10988 
  int __UNIQUE_ID___x650;
  #line 10988 
  int tmp_0;
  #line 10947 
  int cpus;
  #line 10947 
  int extra_vectors;
  #line 10948 
  int vectors_left;
  #line 10949 
  int v_budget;
  #line 10949 
  int i;
  #line 10950 
  int v_actual;
  #line 10946 
  struct i40e_hw *hw = & pf->hw;
  #line 10951 
  int iwarp_requested = 0;
  #line 10953 
  if (((unsigned long)pf->flags & 4UL) == 0UL) 
                                               #line 10954 
                                               return -19;
  #line 10971 
  vectors_left = (int)hw->func_caps.num_msix_vectors;
  #line 10972 
  v_budget = 0;
  #line 10975 
  if (vectors_left != 0) {
    #line 10976 
    v_budget ++;
    #line 10977 
    vectors_left --;
  }
  #line 10987 
  cpus = (int)num_online_cpus();
  {
    #line 10988 
    __UNIQUE_ID___x650 = cpus;
    #line 10988 
    int __UNIQUE_ID___y651 = vectors_left / 2;
    #line 10988 
    if (__UNIQUE_ID___x650 < __UNIQUE_ID___y651) 
                                                 #line 10988 
                                                 tmp_0 = __UNIQUE_ID___x650; else 
                                                                    #line 10988 
                                                                    tmp_0 = __UNIQUE_ID___y651;
    }
  #line 10988 
  pf->num_lan_msix = (unsigned short)tmp_0;
  #line 10989 
  vectors_left -= (int)pf->num_lan_msix;
  #line 10992 
  if (((unsigned long)pf->flags & 256UL) != 0UL) 
    #line 10993 
    if (vectors_left != 0) {
      #line 10994 
      pf->num_fdsb_msix = (unsigned short)1U;
      #line 10995 
      v_budget ++;
      #line 10996 
      vectors_left --;
    }
    else 
         #line 10998 
         pf->num_fdsb_msix = (unsigned short)0U;
  #line 11003 
  if (((unsigned long)pf->flags & 262144UL) != 0UL) {
    #line 11004 
    iwarp_requested = (int)pf->num_iwarp_msix;
    #line 11006 
    if (vectors_left == 0) 
                           #line 11007 
                           pf->num_iwarp_msix = (unsigned short)0U;
    else 
      #line 11008 
      if ((int)pf->num_iwarp_msix > vectors_left) 
                                                  #line 11009 
                                                  pf->num_iwarp_msix = (unsigned short)1U;
    #line 11010 
    v_budget = (int)pf->num_iwarp_msix + v_budget;
    #line 11011 
    vectors_left -= (int)pf->num_iwarp_msix;
  }
  #line 11015 
  if (((unsigned long)pf->flags & 16UL) != 0UL) 
    #line 11016 
    if (vectors_left == 0) {
      #line 11017 
      pf->num_vmdq_msix = (unsigned short)0U;
      #line 11018 
      pf->num_vmdq_qps = (unsigned short)0U;
    }
    else {
      #line 11023 
      int __UNIQUE_ID___x652;
      #line 11023 
      int tmp_2;
      #line 11020 
      int vmdq_vecs_wanted = (int)pf->num_vmdq_vsis * (int)pf->num_vmdq_qps;
      {
        #line 11023 
        __UNIQUE_ID___x652 = vectors_left;
        #line 11023 
        int __UNIQUE_ID___y653 = vmdq_vecs_wanted;
        #line 11023 
        if (__UNIQUE_ID___x652 < __UNIQUE_ID___y653) 
                                                     #line 11023 
                                                     tmp_2 = __UNIQUE_ID___x652; else 
                                                                    #line 11023 
                                                                    tmp_2 = __UNIQUE_ID___y653;
        }
      #line 11022 
      int vmdq_vecs = tmp_2;
      #line 11031 
      if (vectors_left < vmdq_vecs_wanted) {
        #line 11034 
        int tmp_4;
        #line 11034 
        int __UNIQUE_ID___x654;
        #line 11032 
        pf->num_vmdq_qps = (unsigned short)1U;
        #line 11033 
        vmdq_vecs_wanted = (int)pf->num_vmdq_vsis;
        {
          #line 11034 
          __UNIQUE_ID___x654 = vectors_left;
          #line 11034 
          int __UNIQUE_ID___y655 = vmdq_vecs_wanted;
          #line 11034 
          if (__UNIQUE_ID___x654 < __UNIQUE_ID___y655) 
                                                       #line 11034 
                                                       tmp_4 = __UNIQUE_ID___x654; else 
                                                                    #line 11034 
                                                                    tmp_4 = __UNIQUE_ID___y655;
          }
        #line 11034 
        vmdq_vecs = tmp_4;
      }
      #line 11038 
      pf->num_vmdq_msix = pf->num_vmdq_qps;
      #line 11040 
      v_budget += vmdq_vecs;
      #line 11041 
      vectors_left -= vmdq_vecs;
    }
  {
    #line 11054 
    __UNIQUE_ID___x656 = cpus - (int)pf->num_lan_msix;
    #line 11054 
    int __UNIQUE_ID___y657 = vectors_left;
    #line 11054 
    if (__UNIQUE_ID___x656 < __UNIQUE_ID___y657) 
                                                 #line 11054 
                                                 tmp_6 = __UNIQUE_ID___x656; else 
                                                                    #line 11054 
                                                                    tmp_6 = __UNIQUE_ID___y657;
    }
  #line 11054 
  extra_vectors = tmp_6;
  #line 11055 
  pf->num_lan_msix = (unsigned short)((int)pf->num_lan_msix + (int)((unsigned short)extra_vectors));
  #line 11056 
  vectors_left -= extra_vectors;
  {
    #line 11058 
    int __ret_warn_on = vectors_left < 0;
    #line 11058 
    if ((long)(__ret_warn_on != 0) != 0L) {
      #line 11058 
      __warn_printk((char *)"Calculation of remaining vectors underflowed. This is an accounting bug when determining total MSI-X vectors.\n");
      #line 11059 
      ldv_inline_asm();
      #line 11060 
      ldv_inline_asm();
    }
    #line 11058 
    long tmp_8 = (long)(__ret_warn_on != 0);
  }
  #line 11061 
  v_budget = (int)pf->num_lan_msix + v_budget;
  #line 11062 
  pf->msix_entries = (struct msix_entry *)kcalloc_0((unsigned long)v_budget,8UL,3264U);
  #line 11064 
  if (pf->msix_entries == (struct msix_entry *)0) 
                                                  #line 11065 
                                                  return -12;
  #line 11067 
  i = 0;
  #line 11067 
  while (i < v_budget) {
    #line 11068 
    (pf->msix_entries + (unsigned long)i)->entry = (unsigned short)i;
    #line 11067 
    i ++;
  }
  #line 11069 
  v_actual = i40e_reserve_msix_vectors(pf,v_budget);
  #line 11071 
  if (v_actual <= 1) {
    #line 11072 
    pf->flags &= 4294967291U;
    #line 11073 
    kfree((void *)pf->msix_entries);
    #line 11074 
    pf->msix_entries = (struct msix_entry *)0;
    #line 11075 
    pci_disable_msix(pf->pdev);
    #line 11076 
    return -19;
  }
  else 
    #line 11078 
    if (v_actual == 2) {
      #line 11080 
      pf->num_vmdq_vsis = (unsigned short)0U;
      #line 11081 
      pf->num_vmdq_qps = (unsigned short)0U;
      #line 11082 
      pf->num_lan_qps = (unsigned short)1U;
      #line 11083 
      pf->num_lan_msix = (unsigned short)1U;
    }
    else 
      #line 11085 
      if (v_actual != v_budget) {
        #line 11091 
        int vec;
        #line 11093 
        _dev_info(& (pf->pdev)->dev,(char *)"MSI-X vector limit reached with %d, wanted %d, attempting to redistribute vectors\n",v_actual,v_budget);
        #line 11097 
        vec = v_actual + -1;
        #line 11100 
        pf->num_vmdq_msix = (unsigned short)1U;
        #line 11101 
        pf->num_vmdq_vsis = (unsigned short)1U;
        #line 11102 
        pf->num_vmdq_qps = (unsigned short)1U;
        #line 11105 
        switch (vec) {
          #line 11131 
          int __UNIQUE_ID___x665;
          #line 11131 
          int tmp_15;
          #line 11106 
          case 2: 
                  #line 11106 
          ;
          #line 11107 
          pf->num_lan_msix = (unsigned short)1U;
          #line 11108 
          break;
          #line 11109 
          case 3: 
                  #line 11109 
          ;
          #line 11110 
          if (((unsigned long)pf->flags & 262144UL) != 0UL) {
            #line 11111 
            pf->num_lan_msix = (unsigned short)1U;
            #line 11112 
            pf->num_iwarp_msix = (unsigned short)1U;
          }
          else 
               #line 11114 
               pf->num_lan_msix = (unsigned short)2U;
          #line 11116 
          break;
          #line 11117 
          default: 
                   #line 11117 
          ;
          #line 11118 
          if (((unsigned long)pf->flags & 262144UL) != 0UL) {
            #line 11121 
            int tmp_11;
            #line 11119 
            int __UNIQUE_ID___x659;
            #line 11119 
            int tmp_9;
            #line 11121 
            int __UNIQUE_ID___x661;
            {
              #line 11119 
              __UNIQUE_ID___x659 = vec / 3;
              #line 11119 
              int __UNIQUE_ID___y660 = iwarp_requested;
              #line 11119 
              if (__UNIQUE_ID___x659 < __UNIQUE_ID___y660) 
                                                           #line 11119 
                                                           tmp_9 = __UNIQUE_ID___x659; else 
                                                                    #line 11119 
                                                                    tmp_9 = __UNIQUE_ID___y660;
              }
            #line 11119 
            pf->num_iwarp_msix = (unsigned short)tmp_9;
            {
              #line 11121 
              __UNIQUE_ID___x661 = vec / 3;
              #line 11121 
              int __UNIQUE_ID___y662 = 8;
              #line 11121 
              if (__UNIQUE_ID___x661 < __UNIQUE_ID___y662) 
                                                           #line 11121 
                                                           tmp_11 = __UNIQUE_ID___x661; else 
                                                                    #line 11121 
                                                                    tmp_11 = __UNIQUE_ID___y662;
              }
            #line 11121 
            pf->num_vmdq_vsis = (unsigned short)tmp_11;
          }
          else {
            #line 11124 
            int __UNIQUE_ID___x663;
            #line 11124 
            int tmp_13;
            {
              #line 11124 
              __UNIQUE_ID___x663 = vec / 2;
              #line 11124 
              int __UNIQUE_ID___y664 = 8;
              #line 11124 
              if (__UNIQUE_ID___x663 < __UNIQUE_ID___y664) 
                                                           #line 11124 
                                                           tmp_13 = __UNIQUE_ID___x663; else 
                                                                    #line 11124 
                                                                    tmp_13 = __UNIQUE_ID___y664;
              }
            #line 11124 
            pf->num_vmdq_vsis = (unsigned short)tmp_13;
          }
          #line 11127 
          if (((unsigned long)pf->flags & 256UL) != 0UL) {
            #line 11128 
            pf->num_fdsb_msix = (unsigned short)1U;
            #line 11129 
            vec --;
          }
          {
            #line 11131 
            __UNIQUE_ID___x665 = vec - ((int)pf->num_iwarp_msix + (int)pf->num_vmdq_vsis);
            #line 11131 
            int __UNIQUE_ID___y666 = (int)pf->num_lan_msix;
            #line 11131 
            if (__UNIQUE_ID___x665 < __UNIQUE_ID___y666) 
                                                         #line 11131 
                                                         tmp_15 = __UNIQUE_ID___x665; else 
                                                                    #line 11131 
                                                                    tmp_15 = __UNIQUE_ID___y666;
            }
          #line 11131 
          pf->num_lan_msix = (unsigned short)tmp_15;
          #line 11134 
          pf->num_lan_qps = pf->num_lan_msix;
          #line 11135 
          break;
        }
      }
  #line 11139 
  if (((unsigned long)pf->flags & 256UL) != 0UL && (unsigned int)pf->num_fdsb_msix == 0U) {
    #line 11141 
    _dev_info(& (pf->pdev)->dev,(char *)"Sideband Flowdir disabled, not enough MSI-X vectors\n");
    #line 11142 
    pf->flags &= 4294967039U;
    #line 11143 
    pf->flags |= 4194304U;
  }
  #line 11145 
  if (((unsigned long)pf->flags & 16UL) != 0UL && (unsigned int)pf->num_vmdq_msix == 0U) {
    #line 11147 
    _dev_info(& (pf->pdev)->dev,(char *)"VMDq disabled, not enough MSI-X vectors\n");
    #line 11148 
    pf->flags &= 4294967279U;
  }
  #line 11151 
  if (((unsigned long)pf->flags & 262144UL) != 0UL && (unsigned int)pf->num_iwarp_msix == 0U) {
    #line 11153 
    _dev_info(& (pf->pdev)->dev,(char *)"IWARP disabled, not enough MSI-X vectors\n");
    #line 11154 
    pf->flags &= 4294705151U;
  }
  #line 11156 
  if ((pf->hw.debug_mask & 1U) != 0U) 
                                      #line 11156 
                                      printk((char *)"\001",(int)pf->hw.bus.bus_id,(int)pf->hw.bus.device,(int)pf->hw.bus.func,(int)pf->num_lan_msix,(int)pf->num_vmdq_msix * (int)pf->num_vmdq_vsis,(int)pf->num_fdsb_msix,(int)pf->num_iwarp_msix);
  #line 11163 
  return v_actual;
}

#line 11174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_alloc_q_vector(struct i40e_vsi *vsi, int v_idx, int cpu)
{
  #line 11176 
  struct i40e_q_vector *q_vector;
  #line 11179 
  q_vector = (struct i40e_q_vector *)kzalloc_1(4096UL,3264U);
  #line 11180 
  if (q_vector == (struct i40e_q_vector *)0) 
                                             #line 11181 
                                             return -12;
  #line 11183 
  q_vector->vsi = vsi;
  #line 11184 
  q_vector->v_idx = (unsigned short)v_idx;
  #line 11185 
  cpumask_copy(& q_vector->affinity_mask,& __cpu_possible_mask);
  #line 11187 
  if (vsi->netdev != (struct net_device *)0) 
                                             #line 11188 
                                             netif_napi_add(vsi->netdev,& q_vector->napi,& i40e_napi_poll,64);
  #line 11192 
  *(vsi->q_vectors + (unsigned long)v_idx) = q_vector;
  #line 11194 
  return 0;
}

#line 11204  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_alloc_q_vectors(struct i40e_vsi *vsi)
{
  #line 11207 
  int err;
  #line 11207 
  int v_idx;
  #line 11207 
  int num_q_vectors;
  #line 11207 
  int current_cpu;
  #line 11206 
  struct i40e_pf *pf = vsi->back;
  #line 11210 
  if (((unsigned long)pf->flags & 4UL) != 0UL) 
                                               #line 11211 
                                               num_q_vectors = vsi->num_q_vectors;
  else 
    #line 11212 
    if (*(pf->vsi + (unsigned long)pf->lan_vsi) == vsi) 
                                                        #line 11213 
                                                        num_q_vectors = 1; else 
                                                                    #line 11215 
                                                                    return -22;
  #line 11217 
  current_cpu = (int)cpumask_first(& __cpu_online_mask);
  #line 11219 
  v_idx = 0;
  #line 11219 
  while (v_idx < num_q_vectors) {
    {
      #line 11220 
      err = i40e_vsi_alloc_q_vector(vsi,v_idx,current_cpu);
      #line 11221 
      if (err != 0) 
                    #line 11222 
                    goto err_out;
      #line 11223 
      current_cpu = (int)cpumask_next(current_cpu,& __cpu_online_mask);
      #line 11224 
      if ((long)((unsigned int)current_cpu >= nr_cpu_ids) != 0L) {
        #line 11225 
        current_cpu = (int)cpumask_first(& __cpu_online_mask);
      }
    }
    #line 11219 
    v_idx ++;
  }
  #line 11228 
  return 0;
  #line 11230 
  err_out: 
           #line 11230 
  ;
  #line 11231 
  while (1) {
    #line 11231 
    int tmp_2;
    #line 11231 
    tmp_2 = v_idx;
    #line 11231 
    v_idx --;
    #line 11231 
    ;
    #line 11231 
    if (! (tmp_2 != 0)) 
                        #line 11231 
                        break;
    #line 11232 
    i40e_free_q_vector(vsi,v_idx);
  }
  #line 11234 
  return err;
}

#line 11241  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_init_interrupt_scheme(struct i40e_pf *pf)
{
  #line 11244 
  ssize_t size;
  #line 11243 
  int vectors = 0;
  #line 11246 
  if (((unsigned long)pf->flags & 4UL) != 0UL) {
    #line 11247 
    vectors = i40e_init_msix(pf);
    #line 11248 
    if (vectors < 0) {
      #line 11249 
      pf->flags &= 4294704131U;
      #line 11258 
      pf->flags |= 4194304U;
      #line 11261 
      i40e_determine_queue_usage(pf);
    }
  }
  #line 11265 
  if (((unsigned long)pf->flags & 4UL) == 0UL && ((unsigned long)pf->flags & 2UL) != 0UL) {
    #line 11267 
    _dev_info(& (pf->pdev)->dev,(char *)"MSI-X not available, trying MSI\n");
    #line 11268 
    vectors = pci_enable_msi(pf->pdev);
    #line 11269 
    if (vectors < 0) {
      #line 11270 
      _dev_info(& (pf->pdev)->dev,(char *)"MSI init failed - %d\n",vectors);
      #line 11272 
      pf->flags &= 4294967293U;
    }
    #line 11274 
    vectors = 1;
  }
  #line 11277 
  if (((unsigned long)pf->flags & 6UL) == 0UL) 
                                               #line 11278 
                                               _dev_info(& (pf->pdev)->dev,(char *)"MSI-X and MSI not available, falling back to Legacy IRQ\n");
  #line 11281 
  size = (long)(((unsigned long)vectors + 2UL) * 2UL);
  #line 11282 
  pf->irq_pile = (struct i40e_lump_tracking *)kzalloc_1((unsigned long)size,3264U);
  #line 11283 
  if (pf->irq_pile == (struct i40e_lump_tracking *)0) 
                                                      #line 11284 
                                                      return -12;
  #line 11286 
  (pf->irq_pile)->num_entries = (unsigned short)vectors;
  #line 11287 
  (pf->irq_pile)->search_hint = (unsigned short)0U;
  #line 11290 
  i40e_get_lump(pf,pf->irq_pile,(unsigned short)1,(unsigned short)32767);
  #line 11292 
  return 0;
}

#line 11303  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_restore_interrupt_scheme(struct i40e_pf *pf)
{
  #line 11305 
  int err;
  #line 11305 
  int i;
  #line 11311 
  pf->flags |= 6U;
  #line 11313 
  err = i40e_init_interrupt_scheme(pf);
  #line 11314 
  if (err != 0) 
                #line 11315 
                return err;
  #line 11320 
  i = 0;
  #line 11320 
  while ((int)pf->num_alloc_vsi > i) {
    #line 11321 
    if (*(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0) {
      #line 11322 
      err = i40e_vsi_alloc_q_vectors(*(pf->vsi + (unsigned long)i));
      #line 11323 
      if (err != 0) 
                    #line 11324 
                    goto err_unwind;
      #line 11325 
      i40e_vsi_map_rings_to_vectors(*(pf->vsi + (unsigned long)i));
    }
    #line 11320 
    i ++;
  }
  #line 11329 
  err = i40e_setup_misc_vector(pf);
  #line 11330 
  if (err != 0) 
                #line 11331 
                goto err_unwind;
  #line 11333 
  if (((unsigned long)pf->flags & 262144UL) != 0UL) 
                                                    #line 11334 
                                                    i40e_client_update_msix_info(pf);
  #line 11336 
  return 0;
  #line 11338 
  err_unwind: 
              #line 11338 
  ;
  #line 11339 
  while (1) {
    #line 11339 
    int tmp;
    #line 11339 
    tmp = i;
    #line 11339 
    i --;
    #line 11339 
    ;
    #line 11339 
    if (! (tmp != 0)) 
                      #line 11339 
                      break;
    #line 11340 
    if (*(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0) 
                                                               #line 11341 
                                                               i40e_vsi_free_q_vectors(*(pf->vsi + (unsigned long)i));
  }
  #line 11344 
  return err;
}

#line 11357  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_setup_misc_vector_for_recovery_mode(struct i40e_pf *pf)
{
  #line 11359 
  int err;
  #line 11361 
  if (((unsigned long)pf->flags & 4UL) != 0UL) {
    #line 11362 
    err = i40e_setup_misc_vector(pf);
    #line 11364 
    if (err != 0) {
      #line 11365 
      _dev_info(& (pf->pdev)->dev,(char *)"MSI-X misc vector request failed, error %d\n",err);
      #line 11368 
      return err;
    }
  }
  else {
    #line 11371 
    unsigned int tmp;
    #line 11371 
    if (((unsigned long)pf->flags & 2UL) != 0UL) 
                                                 #line 11371 
                                                 tmp = 0U; else 
                                                                #line 11371 
                                                                tmp = 128U;
    #line 11371 
    u32 flags = tmp;
    #line 11373 
    err = cif_request_irq((pf->pdev)->irq,& i40e_intr,(unsigned long)flags,(char *)(& pf->int_name),(void *)pf);
    #line 11376 
    if (err != 0) {
      #line 11377 
      _dev_info(& (pf->pdev)->dev,(char *)"MSI/legacy misc vector request failed, error %d\n",err);
      #line 11380 
      return err;
    }
    #line 11382 
    i40e_enable_misc_int_causes(pf);
    #line 11383 
    i40e_irq_dynamic_enable_icr0(pf);
  }
  #line 11386 
  return 0;
}

#line 11397  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_setup_misc_vector(struct i40e_pf *pf)
{
  #line 11399 
  struct i40e_hw *hw = & pf->hw;
  #line 11400 
  int err = 0;
  #line 11403 
  if (! test_and_set_bit(10L,(unsigned long *)(& pf->state))) {
    #line 11404 
    err = cif_request_irq((pf->msix_entries)->vector,& i40e_intr,0UL,(char *)(& pf->int_name),(void *)pf);
    #line 11406 
    if (err != 0) {
      #line 11407 
      cif_clear_bit_1(10L,(unsigned long *)(& pf->state));
      #line 11408 
      _dev_info(& (pf->pdev)->dev,(char *)"request_irq for %s failed: %d\n",(char *)(& pf->int_name),err);
      #line 11411 
      return -14;
    }
  }
  #line 11415 
  i40e_enable_misc_int_causes(pf);
  #line 11418 
  writel(2047U,(void *)(hw->hw_addr + 230656U));
  #line 11419 
  writel(61U,(void *)(hw->hw_addr + 229376U));
  #line 11421 
  readl((void *)(hw->hw_addr + 745772U));
  #line 11423 
  i40e_irq_dynamic_enable_icr0(pf);
  #line 11425 
  return err;
}

#line 11437  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_get_rss_aq(struct i40e_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size)
{
  #line 11440 
  struct i40e_pf *pf = vsi->back;
  #line 11441 
  struct i40e_hw *hw = & pf->hw;
  #line 11442 
  int ret = 0;
  #line 11444 
  if (seed != (u8 *)0U) {
    #line 11445 
    ret = (int)i40e_aq_get_rss_key(hw,(unsigned short)((int)vsi->id),
                          (struct i40e_aqc_get_set_rss_key_data *)seed);
    #line 11447 
    if (ret != 0) {
      #line 11448 
      ;
      #line 11448 
      _dev_info(& (pf->pdev)->dev,(char *)"Cannot get RSS key, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
      #line 11453 
      return ret;
    }
  }
  #line 11457 
  if (lut != (u8 *)0U) {
    #line 11458 
    bool pf_lut = (_Bool)(vsi->type == (unsigned int)I40E_VSI_MAIN);
    #line 11460 
    ret = (int)i40e_aq_get_rss_lut(hw,(unsigned short)((int)vsi->id),
                            (_Bool)((bool)((int)pf_lut) != 0),lut,
                            (unsigned short)((int)lut_size));
    #line 11461 
    if (ret != 0) {
      #line 11462 
      ;
      #line 11462 
      _dev_info(& (pf->pdev)->dev,(char *)"Cannot get RSS lut, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
      #line 11467 
      return ret;
    }
  }
  #line 11471 
  return ret;
}

#line 11483  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_config_rss_reg(struct i40e_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size)
{
  #line 11489 
  u8 i;
  #line 11486 
  struct i40e_pf *pf = vsi->back;
  #line 11487 
  struct i40e_hw *hw = & pf->hw;
  #line 11488 
  u16 vf_id = (unsigned short)vsi->vf_id;
  #line 11492 
  if (seed != (u8 *)0U) {
    #line 11493 
    u32 *seed_dw = (u32 *)seed;
    #line 11495 
    if (vsi->type == (unsigned int)I40E_VSI_MAIN) {
      #line 11496 
      i = (unsigned char)0U;
      #line 11496 
      while ((unsigned int)i <= 12U) {
        #line 11497 
        writel(*(seed_dw + (unsigned long)i),(void *)(hw->hw_addr + (unsigned long)(((int)i + 18576) * 128)));
        #line 11496 
        i = (u8)((int)i + 1);
      }
    }
    else 
      #line 11498 
      if (vsi->type == (unsigned int)I40E_VSI_SRIOV) {
        #line 11499 
        i = (unsigned char)0U;
        #line 11499 
        while ((unsigned int)i <= 12U) {
          #line 11500 
          writel(*(seed_dw + (unsigned long)i),(void *)(hw->hw_addr + (unsigned long)((((int)i * 256 + (int)vf_id) + 565248) * 4)));
          #line 11499 
          i = (u8)((int)i + 1);
        }
      }
      else 
           #line 11502 
           _dev_err(& (pf->pdev)->dev,(char *)"Cannot set RSS seed - invalid VSI type\n");
  }
  #line 11506 
  if (lut != (u8 *)0U) {
    #line 11507 
    u32 *lut_dw = (u32 *)lut;
    #line 11509 
    if (vsi->type == (unsigned int)I40E_VSI_MAIN) {
      #line 11510 
      if ((unsigned int)lut_size != 512U) 
                                          #line 11511 
                                          return -22;
      #line 11512 
      i = (unsigned char)0U;
      #line 11512 
      while ((int)i >= 0) {
        #line 11513 
        writel(*(lut_dw + (unsigned long)i),(void *)(hw->hw_addr + (unsigned long)(((int)i + 18432) * 128)));
        #line 11512 
        i = (u8)((int)i + 1);
      }
    }
    else 
      #line 11514 
      if (vsi->type == (unsigned int)I40E_VSI_SRIOV) {
        #line 11515 
        if ((unsigned int)lut_size != 64U) 
                                           #line 11516 
                                           return -22;
        #line 11517 
        i = (unsigned char)0U;
        #line 11517 
        while ((unsigned int)i <= 15U) {
          #line 11518 
          writel(*(lut_dw + (unsigned long)i),(void *)(hw->hw_addr + (unsigned long)((((int)i * 256 + (int)vf_id) + 557056) * 4)));
          #line 11517 
          i = (u8)((int)i + 1);
        }
      }
      else 
           #line 11520 
           _dev_err(& (pf->pdev)->dev,(char *)"Cannot set RSS LUT - invalid VSI type\n");
  }
  #line 11523 
  readl((void *)(hw->hw_addr + 745772U));
  #line 11525 
  return 0;
}

#line 11537  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_get_rss_reg(struct i40e_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size)
{
  #line 11542 
  u16 i;
  #line 11540 
  struct i40e_pf *pf = vsi->back;
  #line 11541 
  struct i40e_hw *hw = & pf->hw;
  #line 11544 
  if (seed != (u8 *)0U) {
    #line 11545 
    u32 *seed_dw = (u32 *)seed;
    #line 11547 
    i = (unsigned short)0U;
    #line 11547 
    while ((unsigned int)i <= 12U) {
      #line 11548 
      *(seed_dw + (unsigned long)i) = i40e_read_rx_ctl(hw,(unsigned int)(((int)i + 18576) * 128));
      #line 11547 
      i = (u16)((int)i + 1);
    }
  }
  #line 11550 
  if (lut != (u8 *)0U) {
    #line 11551 
    u32 *lut_dw = (u32 *)lut;
    #line 11553 
    if ((unsigned int)lut_size != 512U) 
                                        #line 11554 
                                        return -22;
    #line 11555 
    i = (unsigned short)0U;
    #line 11555 
    while ((unsigned int)i <= 127U) {
      #line 11556 
      *(lut_dw + (unsigned long)i) = readl((void *)(hw->hw_addr + (unsigned long)(((int)i + 18432) * 128)));
      #line 11555 
      i = (u16)((int)i + 1);
    }
  }
  #line 11559 
  return 0;
}

#line 11571  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_config_rss(struct i40e_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size)
{
  #line 11573 
  struct i40e_pf *pf = vsi->back;
  #line 11575 
  if (((unsigned long)pf->hw_features & 1UL) != 0UL) {
    #line 11576 
    return i40e_config_rss_aq(vsi,seed,lut,(unsigned short)((int)lut_size));
  }
  else {
    #line 11578 
    return i40e_config_rss_reg(vsi,seed,lut,(unsigned short)((int)lut_size));
  }
}

#line 11590  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_get_rss(struct i40e_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size)
{
  #line 11592 
  struct i40e_pf *pf = vsi->back;
  #line 11594 
  if (((unsigned long)pf->hw_features & 1UL) != 0UL) {
    #line 11595 
    return i40e_get_rss_aq(vsi,seed,lut,(unsigned short)((int)lut_size));
  }
  else {
    #line 11597 
    return i40e_get_rss_reg(vsi,seed,lut,(unsigned short)((int)lut_size));
  }
}

#line 11607  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_fill_rss_lut(struct i40e_pf *pf, u8 *lut, u16 rss_table_size, u16 rss_size)
{
  #line 11610 
  u16 i;
  #line 11612 
  i = (unsigned short)0U;
  #line 11612 
  while ((int)i < (int)rss_table_size) {
    #line 11613 
    *(lut + (unsigned long)i) = (unsigned char)((int)i % (int)rss_size);
    #line 11612 
    i = (u16)((int)i + 1);
  }
  #line 11614 
  return;
}

#line 11620  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_pf_config_rss(struct i40e_pf *pf)
{
  #line 11623 
  u8 seed[52U];
  #line 11624 
  u8 *lut;
  #line 11626 
  u32 reg_val;
  #line 11627 
  u64 hena;
  #line 11628 
  int ret;
  #line 11633 
  unsigned long long tmp_1;
  #line 11622 
  struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)pf->lan_vsi);
  #line 11625 
  struct i40e_hw *hw = & pf->hw;
  #line 11631 
  hena = (unsigned long long)i40e_read_rx_ctl(hw,2382080U) | ((unsigned long long)i40e_read_rx_ctl(hw,2382208U) << 32);
  #line 11633 
  if (((unsigned long)pf->hw_features & 16UL) != 0UL) 
                                                      #line 11633 
                                                      tmp_1 = 9223512361489399808ULL; else 
                                                                    #line 11633 
                                                                    tmp_1 = 9223506308269867008ULL;
  #line 11633 
  hena = tmp_1 | hena;
  #line 11635 
  i40e_write_rx_ctl(hw,2382080U,(unsigned int)hena);
  #line 11636 
  i40e_write_rx_ctl(hw,2382208U,(unsigned int)(hena >> 32));
  #line 11639 
  reg_val = i40e_read_rx_ctl(hw,1837760U);
  #line 11640 
  if ((unsigned int)pf->rss_table_size == 512U) 
                                                #line 11640 
                                                reg_val |= 65536U; else 
                                                                    #line 11640 
                                                                    reg_val &= 4294901759U;
  #line 11643 
  i40e_write_rx_ctl(hw,1837760U,reg_val);
  #line 11646 
  if ((unsigned int)vsi->rss_size == 0U) {
    #line 11655 
    int __UNIQUE_ID___x667;
    #line 11655 
    int tmp_3;
    #line 11647 
    u16 qcount;
    #line 11653 
    int tmp_2;
    #line 11653 
    if ((unsigned int)vsi->tc_config.numtc != 0U) 
                                                  #line 11653 
                                                  tmp_2 = (int)vsi->tc_config.numtc; else 
                                                                    #line 11653 
                                                                    tmp_2 = 1;
    #line 11653 
    qcount = (unsigned short)((int)vsi->num_queue_pairs / tmp_2);
    {
      #line 11655 
      __UNIQUE_ID___x667 = (int)pf->alloc_rss_size;
      #line 11655 
      int __UNIQUE_ID___y668 = (int)qcount;
      #line 11655 
      if (__UNIQUE_ID___x667 < __UNIQUE_ID___y668) 
                                                   #line 11655 
                                                   tmp_3 = __UNIQUE_ID___x667; else 
                                                                    #line 11655 
                                                                    tmp_3 = __UNIQUE_ID___y668;
      }
    #line 11655 
    vsi->rss_size = (unsigned short)tmp_3;
  }
  #line 11657 
  if ((unsigned int)vsi->rss_size == 0U) 
                                         #line 11658 
                                         return -22;
  #line 11660 
  lut = (u8 *)kzalloc_1((unsigned long)vsi->rss_table_size,3264U);
  #line 11661 
  if (lut == (u8 *)0U) 
                       #line 11662 
                       return -12;
  #line 11665 
  if (vsi->rss_lut_user != (u8 *)0U) 
                                     #line 11666 
                                     memcpy((void *)lut,(void *)vsi->rss_lut_user,(unsigned long)vsi->rss_table_size); else 
                                                                    #line 11668 
                                                                    i40e_fill_rss_lut(pf,lut,(unsigned short)((int)vsi->rss_table_size),(unsigned short)((int)vsi->rss_size));
  #line 11673 
  if (vsi->rss_hkey_user != (u8 *)0U) 
                                      #line 11674 
                                      memcpy((void *)(& seed),(void *)vsi->rss_hkey_user,52UL); else 
                                                                    #line 11676 
                                                                    netdev_rss_key_fill((void *)(& seed),52UL);
  #line 11677 
  ret = i40e_config_rss(vsi,(u8 *)(& seed),lut,(unsigned short)((int)vsi->rss_table_size));
  #line 11678 
  kfree((void *)lut);
  #line 11680 
  return ret;
}

#line 11692  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)
{
  #line 11700 
  int __UNIQUE_ID___x669;
  #line 11700 
  int tmp_0;
  #line 11701 
  int __UNIQUE_ID___x671;
  #line 11701 
  int tmp_2;
  #line 11695 
  int new_rss_size;
  #line 11694 
  struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)pf->lan_vsi);
  #line 11697 
  if (((unsigned long)pf->flags & 8UL) == 0UL) 
                                               #line 11698 
                                               return 0;
  {
    #line 11700 
    __UNIQUE_ID___x669 = queue_count;
    #line 11700 
    int __UNIQUE_ID___y670 = (int)num_online_cpus();
    #line 11700 
    if (__UNIQUE_ID___x669 < __UNIQUE_ID___y670) 
                                                 #line 11700 
                                                 tmp_0 = __UNIQUE_ID___x669; else 
                                                                    #line 11700 
                                                                    tmp_0 = __UNIQUE_ID___y670;
    }
  #line 11700 
  queue_count = tmp_0;
  {
    #line 11701 
    __UNIQUE_ID___x671 = queue_count;
    #line 11701 
    int __UNIQUE_ID___y672 = (int)pf->rss_size_max;
    #line 11701 
    if (__UNIQUE_ID___x671 < __UNIQUE_ID___y672) 
                                                 #line 11701 
                                                 tmp_2 = __UNIQUE_ID___x671; else 
                                                                    #line 11701 
                                                                    tmp_2 = __UNIQUE_ID___y672;
    }
  #line 11701 
  new_rss_size = tmp_2;
  #line 11703 
  if ((int)vsi->num_queue_pairs != queue_count) {
    #line 11724 
    int __UNIQUE_ID___x674;
    #line 11724 
    int tmp_5;
    #line 11704 
    u16 qcount;
    #line 11706 
    vsi->req_queue_pairs = (unsigned short)queue_count;
    #line 11707 
    i40e_prep_for_reset(pf,(_Bool)1);
    #line 11709 
    pf->alloc_rss_size = (unsigned short)new_rss_size;
    #line 11711 
    i40e_reset_and_rebuild(pf,(_Bool)1,(_Bool)1);
    #line 11716 
    if ((int)vsi->rss_size > queue_count) {
      #line 11717 
      i40e_clear_rss_config_user(vsi);
      {
        #line 11718 
        bool branch;
        #line 11718 
        struct _ddebug __UNIQUE_ID_ddebug673 = {.modname = (char *)"i40e", .function = (char *)"i40e_reconfig_rss_queues", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"discard user configured hash keys and lut\n", .lineno = (unsigned int)11718U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 11718 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug673.key.dd_key_false.key,(_Bool)0);
        #line 11718 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 11718 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug673,& (pf->pdev)->dev,(char *)"discard user configured hash keys and lut\n");
      }
    }
    #line 11723 
    qcount = (unsigned short)((int)vsi->num_queue_pairs / (int)vsi->tc_config.numtc);
    {
      #line 11724 
      __UNIQUE_ID___x674 = (int)pf->alloc_rss_size;
      #line 11724 
      int __UNIQUE_ID___y675 = (int)qcount;
      #line 11724 
      if (__UNIQUE_ID___x674 < __UNIQUE_ID___y675) 
                                                   #line 11724 
                                                   tmp_5 = __UNIQUE_ID___x674; else 
                                                                    #line 11724 
                                                                    tmp_5 = __UNIQUE_ID___y675;
      }
    #line 11724 
    vsi->rss_size = (unsigned short)tmp_5;
    #line 11726 
    i40e_pf_config_rss(pf);
  }
  #line 11728 
  _dev_info(& (pf->pdev)->dev,(char *)"User requested queue count/HW max RSS count:  %d/%d\n",(int)vsi->req_queue_pairs,(int)pf->rss_size_max);
  #line 11730 
  return (int)pf->alloc_rss_size;
}

#line 11737  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_get_partition_bw_setting(struct i40e_pf *pf)
{
  #line 11739 
  i40e_status status;
  #line 11740 
  bool min_valid;
  #line 11740 
  bool max_valid;
  #line 11741 
  u32 max_bw;
  #line 11741 
  u32 min_bw;
  #line 11743 
  status = i40e_read_bw_from_alt_ram(& pf->hw,& max_bw,& min_bw,& min_valid,& max_valid);
  #line 11746 
  if (status == I40E_SUCCESS) {
    #line 11747 
    if ((int)min_valid != 0) 
                             #line 11748 
                             pf->min_bw = min_bw;
    #line 11749 
    if ((int)max_valid != 0) 
                             #line 11750 
                             pf->max_bw = max_bw;
  }
  #line 11753 
  return status;
}

#line 11760  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_set_partition_bw_setting(struct i40e_pf *pf)
{
  #line 11762 
  struct i40e_aqc_configure_partition_bw_data bw_data;
  #line 11763 
  i40e_status status;
  #line 11766 
  bw_data.pf_valid_bits = (unsigned short)(1UL << (int)pf->hw.pf_id);
  #line 11767 
  bw_data.max_bw[(int)pf->hw.pf_id] = (unsigned char)pf->max_bw;
  #line 11768 
  bw_data.min_bw[(int)pf->hw.pf_id] = (unsigned char)pf->min_bw;
  #line 11771 
  status = i40e_aq_configure_partition_bw(& pf->hw,& bw_data,(struct i40e_asq_cmd_details *)0);
  #line 11773 
  return status;
}

#line 11780  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
i40e_status i40e_commit_partition_bw_setting(struct i40e_pf *pf)
{
  #line 11783 
  enum i40e_admin_queue_err last_aq_status;
  #line 11784 
  i40e_status ret;
  #line 11785 
  u16 nvm_word;
  #line 11787 
  if ((unsigned int)pf->hw.partition_id != 1U) {
    #line 11788 
    _dev_info(& (pf->pdev)->dev,(char *)"Commit BW only works on partition 1! This is partition %d",(int)pf->hw.partition_id);
    #line 11791 
    ret = I40E_NOT_SUPPORTED;
    #line 11792 
    goto bw_commit_out;
  }
  #line 11796 
  ret = i40e_acquire_nvm(& pf->hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
  #line 11797 
  last_aq_status = pf->hw.aq.asq_last_status;
  #line 11798 
  if (ret != I40E_SUCCESS) {
    #line 11799 
    ;
    #line 11799 
    _dev_info(& (pf->pdev)->dev,(char *)"Cannot acquire NVM for read access, err %s aq_err %s\n",i40e_stat_str(& pf->hw,ret),i40e_aq_str(& pf->hw,last_aq_status));
    #line 11803 
    goto bw_commit_out;
  }
  #line 11807 
  ret = i40e_aq_read_nvm(& pf->hw,(unsigned char)0,16U,(unsigned short)2,(void *)(& nvm_word),(_Bool)0,(struct i40e_asq_cmd_details *)0);
  #line 11814 
  last_aq_status = pf->hw.aq.asq_last_status;
  #line 11815 
  i40e_release_nvm(& pf->hw);
  #line 11816 
  if (ret != I40E_SUCCESS) {
    #line 11817 
    ;
    #line 11817 
    _dev_info(& (pf->pdev)->dev,(char *)"NVM read error, err %s aq_err %s\n",i40e_stat_str(& pf->hw,ret),i40e_aq_str(& pf->hw,last_aq_status));
    #line 11820 
    goto bw_commit_out;
  }
  #line 11824 
  msleep(50U);
  #line 11827 
  ret = i40e_acquire_nvm(& pf->hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_WRITE);
  #line 11828 
  last_aq_status = pf->hw.aq.asq_last_status;
  #line 11829 
  if (ret != I40E_SUCCESS) {
    #line 11830 
    ;
    #line 11830 
    _dev_info(& (pf->pdev)->dev,(char *)"Cannot acquire NVM for write access, err %s aq_err %s\n",i40e_stat_str(& pf->hw,ret),i40e_aq_str(& pf->hw,last_aq_status));
    #line 11834 
    goto bw_commit_out;
  }
  #line 11840 
  ret = i40e_aq_update_nvm(& pf->hw,(unsigned char)0,16U,(unsigned short)2,(void *)(& nvm_word),(_Bool)1,(unsigned char)0,(struct i40e_asq_cmd_details *)0);
  #line 11847 
  last_aq_status = pf->hw.aq.asq_last_status;
  #line 11848 
  i40e_release_nvm(& pf->hw);
  #line 11849 
  if (ret != I40E_SUCCESS) {
    #line 11850 
    ;
    #line 11850 
    _dev_info(& (pf->pdev)->dev,(char *)"BW settings NOT SAVED, err %s aq_err %s\n",i40e_stat_str(& pf->hw,ret),i40e_aq_str(& pf->hw,last_aq_status));
  }
  #line 11854 
  bw_commit_out: 
                 #line 11854 
  ;
  #line 11856 
  return ret;
}

#line 11867  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_sw_init(struct i40e_pf *pf)
{
  #line 11887 
  int __UNIQUE_ID___x676;
  #line 11887 
  int tmp;
  #line 11870 
  int size;
  #line 11869 
  int err = 0;
  #line 11873 
  pf->flags = 7U;
  #line 11878 
  pf->rx_itr_default = (unsigned short)32818U;
  #line 11879 
  pf->tx_itr_default = (unsigned short)32818U;
  #line 11884 
  pf->rss_size_max = (unsigned short)(1UL << pf->hw.func_caps.rss_table_entry_width);
  #line 11885 
  pf->alloc_rss_size = (unsigned short)1U;
  #line 11886 
  pf->rss_table_size = (unsigned short)pf->hw.func_caps.rss_table_size;
  {
    #line 11887 
    __UNIQUE_ID___x676 = (int)pf->rss_size_max;
    #line 11887 
    int __UNIQUE_ID___y677 = (int)pf->hw.func_caps.num_tx_qp;
    #line 11887 
    if (__UNIQUE_ID___x676 < __UNIQUE_ID___y677) 
                                                 #line 11887 
                                                 tmp = __UNIQUE_ID___x676; else 
                                                                    #line 11887 
                                                                    tmp = __UNIQUE_ID___y677;
    }
  #line 11887 
  pf->rss_size_max = (unsigned short)tmp;
  #line 11889 
  if ((int)pf->hw.func_caps.rss != 0) {
    #line 11891 
    int __UNIQUE_ID___x678;
    #line 11891 
    int tmp_2;
    #line 11890 
    pf->flags |= 8U;
    {
      #line 11891 
      __UNIQUE_ID___x678 = (int)pf->rss_size_max;
      #line 11891 
      int __UNIQUE_ID___y679 = (int)num_online_cpus();
      #line 11891 
      if (__UNIQUE_ID___x678 < __UNIQUE_ID___y679) 
                                                   #line 11891 
                                                   tmp_2 = __UNIQUE_ID___x678; else 
                                                                    #line 11891 
                                                                    tmp_2 = __UNIQUE_ID___y679;
      }
    #line 11891 
    pf->alloc_rss_size = (unsigned short)tmp_2;
  }
  #line 11896 
  if (pf->hw.func_caps.npar_enable != 0U || (int)pf->hw.func_caps.flex10_enable != 0) {
    #line 11897 
    pf->flags |= 1024U;
    #line 11898 
    _dev_info(& (pf->pdev)->dev,(char *)"MFP mode Enabled\n");
    #line 11899 
    if (i40e_get_partition_bw_setting(pf) != I40E_SUCCESS) 
                                                           #line 11900 
                                                           _dev_warn(& (pf->pdev)->dev,(char *)"Could not get partition bw settings\n");
    else {
      #line 11903 
      _dev_info(& (pf->pdev)->dev,(char *)"Partition BW Min = %8.8x, Max = %8.8x\n",pf->min_bw,pf->max_bw);
      #line 11908 
      i40e_set_partition_bw_setting(pf);
    }
  }
  #line 11912 
  if (pf->hw.func_caps.fd_filters_guaranteed != 0U || pf->hw.func_caps.fd_filters_best_effort != 0U) {
    #line 11914 
    pf->flags |= 512U;
    #line 11915 
    pf->atr_sample_rate = (unsigned char)20U;
    #line 11916 
    if (((unsigned long)pf->flags & 1024UL) != 0UL && (unsigned int)pf->hw.num_partitions > 1U) 
      #line 11918 
      _dev_info(& (pf->pdev)->dev,(char *)"Flow Director Sideband mode Disabled in MFP mode\n"); else 
                                                                    #line 11921 
                                                                    pf->flags |= 256U;
    #line 11922 
    pf->fdir_pf_filter_count = (unsigned short)pf->hw.func_caps.fd_filters_guaranteed;
    #line 11924 
    pf->hw.fdir_shared_filter_count = (unsigned short)pf->hw.func_caps.fd_filters_best_effort;
  }
  #line 11928 
  if (pf->hw.mac.type == (unsigned int)I40E_MAC_X722) {
    #line 11929 
    pf->hw_features |= 20287U;
    #line 11942 
    if (readl((void *)(pf->hw.hw_addr + 2556808U)) != 3075U) {
      #line 11944 
      _dev_warn(& (pf->pdev)->dev,(char *)"FD EVICT PCTYPES are not right, disable FD HW EVICT\n");
      #line 11946 
      pf->hw_features &= 4294967291U;
    }
  }
  else 
    #line 11948 
    if ((unsigned int)pf->hw.aq.api_maj_ver > 1U || (unsigned int)pf->hw.aq.api_maj_ver == 1U && (unsigned int)pf->hw.aq.api_min_ver > 4U) 
      #line 11952 
      pf->hw_features |= 512U;
  #line 11956 
  if (((unsigned long)pf->hw_features & 4UL) != 0UL) 
                                                     #line 11957 
                                                     pf->flags |= 2048U;
  #line 11959 
  if (pf->hw.mac.type == (unsigned int)I40E_MAC_XL710 && ((unsigned int)pf->hw.aq.fw_maj_ver == 4U && (unsigned int)pf->hw.aq.fw_min_ver <= 32U || (unsigned int)pf->hw.aq.fw_maj_ver <= 3U)) {
    #line 11962 
    pf->hw_features |= 262144U;
    #line 11964 
    pf->hw_features |= 128U;
  }
  #line 11968 
  if (pf->hw.mac.type == (unsigned int)I40E_MAC_XL710 && ((unsigned int)pf->hw.aq.fw_maj_ver == 4U && (unsigned int)pf->hw.aq.fw_min_ver <= 2U || (unsigned int)pf->hw.aq.fw_maj_ver <= 3U)) 
    #line 11971 
    pf->hw_features |= 65536U;
  #line 11974 
  if (pf->hw.mac.type == (unsigned int)I40E_MAC_XL710 && ((unsigned int)pf->hw.aq.fw_maj_ver == 4U && (unsigned int)pf->hw.aq.fw_min_ver > 39U || (unsigned int)pf->hw.aq.fw_maj_ver > 4U)) 
    #line 11977 
    pf->hw_features |= 256U;
  #line 11980 
  if (pf->hw.mac.type == (unsigned int)I40E_MAC_XL710 && (unsigned int)pf->hw.aq.fw_maj_ver > 5U) 
    #line 11982 
    pf->hw_features |= 1024U;
  #line 11984 
  if ((int)pf->hw.func_caps.vmdq != 0) {
    #line 11984 
    if (num_online_cpus() != 1U) {
      #line 11985 
      pf->num_vmdq_vsis = (unsigned short)8U;
      #line 11986 
      pf->flags |= 16U;
      #line 11987 
      if (((unsigned long)pf->hw_features & 1UL) != 0UL) 
                                                         #line 11987 
                                                         pf->num_vmdq_qps = (unsigned short)4U; else 
                                                                    #line 11987 
                                                                    pf->num_vmdq_qps = (unsigned short)1U;
    }
  }
  #line 11990 
  if ((int)pf->hw.func_caps.iwarp != 0) {
    #line 11990 
    if (num_online_cpus() != 1U) {
      #line 11991 
      pf->flags |= 262144U;
      #line 11993 
      pf->num_iwarp_msix = (unsigned short)((unsigned int)((unsigned short)num_online_cpus()) + 1U);
    }
  }
  #line 12000 
  if ((pf->hw.mac.type == (unsigned int)I40E_MAC_XL710 && pf->hw.func_caps.npar_enable != 0U) && (pf->hw.flags & 16ULL) != 0ULL) 
    #line 12003 
    pf->hw.flags &= 18446744073709551599ULL;
  #line 12006 
  if (pf->hw.func_caps.num_vfs != 0U && (unsigned int)pf->hw.partition_id == 1U) {
    #line 12009 
    int __UNIQUE_ID___x680;
    #line 12009 
    int tmp_9;
    #line 12007 
    pf->num_vf_qps = (unsigned short)4U;
    #line 12008 
    pf->flags |= 32U;
    {
      #line 12009 
      __UNIQUE_ID___x680 = (int)pf->hw.func_caps.num_vfs;
      #line 12009 
      int __UNIQUE_ID___y681 = 128;
      #line 12009 
      if (__UNIQUE_ID___x680 < __UNIQUE_ID___y681) 
                                                   #line 12009 
                                                   tmp_9 = __UNIQUE_ID___x680; else 
                                                                    #line 12009 
                                                                    tmp_9 = __UNIQUE_ID___y681;
      }
    #line 12009 
    pf->num_req_vfs = (unsigned short)tmp_9;
  }
  #line 12014 
  pf->eeprom_version = (unsigned short)57005U;
  #line 12015 
  pf->lan_veb = (unsigned short)65535U;
  #line 12016 
  pf->lan_vsi = (unsigned short)65535U;
  #line 12019 
  pf->flags &= 4294959103U;
  #line 12022 
  size = (int)(((unsigned long)pf->hw.func_caps.num_tx_qp + 2UL) * (unsigned long)2U);
  #line 12024 
  pf->qp_pile = (struct i40e_lump_tracking *)kzalloc_1((unsigned long)size,3264U);
  #line 12025 
  if (pf->qp_pile == (struct i40e_lump_tracking *)0) {
    #line 12026 
    err = -12;
    #line 12027 
    goto sw_init_done;
  }
  #line 12029 
  (pf->qp_pile)->num_entries = (unsigned short)pf->hw.func_caps.num_tx_qp;
  #line 12030 
  (pf->qp_pile)->search_hint = (unsigned short)0U;
  #line 12032 
  pf->tx_timeout_recovery_level = 1U;
  {
    #line 12034 
    struct lock_class_key __key;
    #line 12034 
    __mutex_init(& pf->switch_mutex,(char *)"&pf->switch_mutex",& __key);
  }
  #line 12036 
  sw_init_done: 
                #line 12036 
  ;
  #line 12037 
  return err;
}

#line 12047  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
bool i40e_set_ntuple(struct i40e_pf *pf, netdev_features_t features)
{
  #line 12049 
  bool need_reset = (_Bool)0;
  #line 12054 
  if ((features & 137438953472ULL) != 0ULL) {
    #line 12056 
    if (((unsigned long)pf->flags & 256UL) == 0UL) 
                                                   #line 12057 
                                                   need_reset = (_Bool)1;
    #line 12061 
    if ((unsigned int)pf->num_fdsb_msix != 0U && (unsigned int)pf->num_cloud_filters == 0U) {
      #line 12062 
      pf->flags |= 256U;
      #line 12063 
      pf->flags &= 4290772991U;
    }
  }
  else {
    #line 12067 
    if (((unsigned long)pf->flags & 256UL) != 0UL) {
      #line 12068 
      need_reset = (_Bool)1;
      #line 12069 
      i40e_fdir_filter_exit(pf);
    }
    #line 12071 
    pf->flags &= 4294967039U;
    #line 12072 
    cif_clear_bit_1(23L,(unsigned long *)(& pf->state));
    #line 12073 
    pf->flags |= 4194304U;
    #line 12076 
    pf->fd_add_err = 0U;
    #line 12077 
    pf->fd_atr_cnt = 0U;
    #line 12079 
    if ((int)test_and_set_bit(22L,(unsigned long *)(& pf->state)) != 0) 
      #line 12080 
      if (((unsigned long)pf->flags & 512UL) != 0UL && (pf->hw.debug_mask & 4096U) != 0U) 
        #line 12082 
        _dev_info(& (pf->pdev)->dev,(char *)"ATR re-enabled.\n");
  }
  #line 12084 
  return need_reset;
}

#line 12091  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_clear_rss_lut(struct i40e_vsi *vsi)
{
  #line 12096 
  u8 i;
  #line 12093 
  struct i40e_pf *pf = vsi->back;
  #line 12094 
  struct i40e_hw *hw = & pf->hw;
  #line 12095 
  u16 vf_id = (unsigned short)vsi->vf_id;
  #line 12098 
  if (vsi->type == (unsigned int)I40E_VSI_MAIN) {
    #line 12099 
    i = (unsigned char)0U;
    #line 12099 
    while ((int)i >= 0) {
      #line 12100 
      writel(0U,(void *)(hw->hw_addr + (unsigned long)(((int)i + 18432) * 128)));
      #line 12099 
      i = (u8)((int)i + 1);
    }
  }
  else 
    #line 12101 
    if (vsi->type == (unsigned int)I40E_VSI_SRIOV) {
      #line 12102 
      i = (unsigned char)0U;
      #line 12102 
      while ((unsigned int)i <= 15U) {
        #line 12103 
        i40e_write_rx_ctl(hw,(unsigned int)((((int)i * 256 + (int)vf_id) + 557056) * 4),0U);
        #line 12102 
        i = (u8)((int)i + 1);
      }
    }
    else 
         #line 12105 
         _dev_err(& (pf->pdev)->dev,(char *)"Cannot set RSS LUT - invalid VSI type\n");
  #line 12106 
  return;
}

#line 12115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_set_features(struct net_device *netdev, netdev_features_t features)
{
  #line 12121 
  bool need_reset;
  #line 12118 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 12119 
  struct i40e_vsi *vsi = np->vsi;
  #line 12120 
  struct i40e_pf *pf = vsi->back;
  #line 12123 
  if ((features & 274877906944ULL) != 0ULL && (netdev->features & 274877906944ULL) == 0ULL) 
    #line 12124 
    i40e_pf_config_rss(pf);
  else 
    #line 12125 
    if ((features & 274877906944ULL) == 0ULL && (netdev->features & 274877906944ULL) != 0ULL) 
      #line 12127 
      i40e_clear_rss_lut(vsi);
  #line 12129 
  if ((features & 256ULL) != 0ULL) 
                                   #line 12130 
                                   i40e_vlan_stripping_enable(vsi); else 
                                                                    #line 12132 
                                                                    i40e_vlan_stripping_disable(vsi);
  #line 12134 
  if ((features & 281474976710656ULL) == 0ULL && (unsigned int)pf->num_cloud_filters != 0U) {
    #line 12135 
    _dev_err(& (pf->pdev)->dev,(char *)"Offloaded tc filters active, can\'t turn hw_tc_offload off");
    #line 12137 
    return -22;
  }
  #line 12140 
  if ((features & 140737488355328ULL) == 0ULL && vsi->macvlan_cnt != 0) 
    #line 12141 
    i40e_del_all_macvlans(vsi);
  #line 12143 
  need_reset = i40e_set_ntuple(pf,features);
  #line 12145 
  if ((int)need_reset != 0) 
                            #line 12146 
                            i40e_do_reset(pf,8192U,(_Bool)1);
  #line 12148 
  return 0;
}

#line 12158  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static u8 i40e_get_udp_port_idx(struct i40e_pf *pf, u16 port)
{
  #line 12160 
  u8 i;
  #line 12162 
  i = (unsigned char)0U;
  #line 12162 
  while ((unsigned int)i <= 15U) {
    #line 12166 
    if ((unsigned int)port == 0U && (((unsigned long long)pf->pending_udp_bitmap >> (int)i) & 1ULL) != 0ULL) 
      #line 12167 
      goto __Cont;
    #line 12168 
    if ((int)pf->udp_ports[(int)i].port == (int)port) 
                                                      #line 12169 
                                                      return i;
    #line 12162 
    __Cont: 
            #line 12162 
    i = (u8)((int)i + 1);
  }
  #line 12172 
  return i;
}

#line 12180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_udp_tunnel_add(struct net_device *netdev, struct udp_tunnel_info *ti)
{
  #line 12187 
  u8 next_idx;
  #line 12188 
  u8 idx;
  #line 12183 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 12184 
  struct i40e_vsi *vsi = np->vsi;
  #line 12185 
  struct i40e_pf *pf = vsi->back;
  #line 12186 
  u16 port = __builtin_bswap16((unsigned short)((int)ti->port));
  #line 12190 
  idx = i40e_get_udp_port_idx(pf,(unsigned short)((int)port));
  #line 12193 
  if ((unsigned int)idx <= 15U) {
    #line 12194 
    netdev_info(netdev,(char *)"port %d already offloaded\n",(int)port);
    #line 12195 
    return;
  }
  #line 12199 
  next_idx = i40e_get_udp_port_idx(pf,(unsigned short)0);
  #line 12201 
  if ((unsigned int)next_idx == 16U) {
    #line 12202 
    netdev_info(netdev,(char *)"maximum number of offloaded UDP ports reached, not adding port %d\n",(int)port);
    #line 12204 
    return;
  }
  #line 12207 
  switch ((int)ti->type) {
    #line 12208 
    case 0: 
            #line 12208 
    ;
    #line 12209 
    pf->udp_ports[(int)next_idx].type = (unsigned char)0U;
    #line 12210 
    break;
    #line 12211 
    case 1: 
            #line 12211 
    ;
    #line 12212 
    if (((unsigned long)pf->hw_features & 512UL) == 0UL) 
                                                         #line 12213 
                                                         return;
    #line 12214 
    pf->udp_ports[(int)next_idx].type = (unsigned char)1U;
    #line 12215 
    break;
    #line 12216 
    default: 
             #line 12216 
    ;
    #line 12217 
    return;
  }
  #line 12221 
  pf->udp_ports[(int)next_idx].port = port;
  #line 12222 
  pf->udp_ports[(int)next_idx].filter_index = (unsigned char)255U;
  #line 12223 
  pf->pending_udp_bitmap = (unsigned short)((int)pf->pending_udp_bitmap | (int)((unsigned short)(1ULL << (int)next_idx)));
  #line 12224 
  cif_set_bit_1(28L,(unsigned long *)(& pf->state));
  #line 12225 
  return;
}

#line 12232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_udp_tunnel_del(struct net_device *netdev, struct udp_tunnel_info *ti)
{
  #line 12239 
  u8 idx;
  #line 12235 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 12236 
  struct i40e_vsi *vsi = np->vsi;
  #line 12237 
  struct i40e_pf *pf = vsi->back;
  #line 12238 
  u16 port = __builtin_bswap16((unsigned short)((int)ti->port));
  #line 12241 
  idx = i40e_get_udp_port_idx(pf,(unsigned short)((int)port));
  #line 12244 
  if ((unsigned int)idx > 15U) 
                               #line 12245 
                               goto not_found;
  #line 12247 
  switch ((int)ti->type) {
    #line 12248 
    case 0: 
            #line 12248 
    ;
    #line 12249 
    if ((unsigned int)pf->udp_ports[(int)idx].type != 0U) 
                                                          #line 12250 
                                                          goto not_found;
    #line 12251 
    break;
    #line 12252 
    case 1: 
            #line 12252 
    ;
    #line 12253 
    if ((unsigned int)pf->udp_ports[(int)idx].type != 1U) 
                                                          #line 12254 
                                                          goto not_found;
    #line 12255 
    break;
    #line 12256 
    default: 
             #line 12256 
    ;
    #line 12257 
    goto not_found;
  }
  #line 12263 
  pf->udp_ports[(int)idx].port = (unsigned short)0U;
  #line 12269 
  pf->pending_udp_bitmap = (unsigned short)((int)pf->pending_udp_bitmap ^ (int)((unsigned short)(1ULL << (int)idx)));
  #line 12270 
  cif_set_bit_1(28L,(unsigned long *)(& pf->state));
  #line 12272 
  return;
  #line 12273 
  not_found: 
             #line 12273 
  ;
  #line 12274 
  netdev_warn(netdev,(char *)"UDP port %d was not found, not deleting\n",(int)port);
  #line 12275 
  return;
}

#line 12278  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_get_phys_port_id(struct net_device *netdev, struct netdev_phys_item_id *ppid)
{
  #line 12281 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 12282 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 12283 
  struct i40e_hw *hw = & pf->hw;
  #line 12285 
  if (((unsigned long)pf->hw_features & 131072UL) == 0UL) 
                                                          #line 12286 
                                                          return -95;
  #line 12288 
  ppid->id_len = (unsigned char)6U;
  #line 12289 
  memcpy((void *)(& ppid->id),(void *)(& hw->mac.port_addr),(unsigned long)ppid->id_len);
  #line 12291 
  return 0;
}

#line 12303  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_ndo_fdb_add(struct ndmsg *ndm, struct nlattr **tb, struct net_device *dev, unsigned char *addr, u16 vid, u16 flags, struct netlink_ext_ack *extack)
{
  #line 12309 
  struct i40e_netdev_priv *np = netdev_priv(dev);
  #line 12310 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 12311 
  int err = 0;
  #line 12313 
  if (((unsigned long)pf->flags & 32UL) == 0UL) 
                                                #line 12314 
                                                return -95;
  #line 12316 
  if ((unsigned int)vid != 0U) {
    #line 12317 
    printk((char *)"\001",(char *)(& dev->name));
    #line 12318 
    return -22;
  }
  #line 12324 
  if ((unsigned int)ndm->ndm_state != 0U && ((int)ndm->ndm_state & 128) == 0) {
    #line 12325 
    netdev_info(dev,(char *)"FDB only supports static addresses\n");
    #line 12326 
    return -22;
  }
  #line 12329 
  if ((int)is_unicast_ether_addr(addr) != 0) 
                                             #line 12329 
                                             goto _LOR;
  else {
    #line 12329 
    if ((int)is_link_local_ether_addr(addr) != 0) 
                                                  #line 12329 
                                                  _LOR: 
                                                        #line 12330 
                                                        err = dev_uc_add_excl(dev,addr);
    else {
      #line 12331 
      if ((int)is_multicast_ether_addr(addr) != 0) 
                                                   #line 12332 
                                                   err = dev_mc_add_excl(dev,addr); else 
                                                                    #line 12334 
                                                                    err = -22;
    }
  }
  #line 12337 
  if (err == -17 && ((int)flags & 512) == 0) 
                                             #line 12338 
                                             err = 0;
  #line 12340 
  return err;
}

#line 12359  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_ndo_bridge_setlink(struct net_device *dev, struct nlmsghdr *nlh, u16 flags, struct netlink_ext_ack *extack)
{
  #line 12368 
  struct nlattr *attr;
  #line 12368 
  struct nlattr *br_spec;
  #line 12369 
  int i;
  #line 12369 
  int rem;
  #line 12364 
  struct i40e_netdev_priv *np = netdev_priv(dev);
  #line 12365 
  struct i40e_vsi *vsi = np->vsi;
  #line 12366 
  struct i40e_pf *pf = vsi->back;
  #line 12367 
  struct i40e_veb *veb = (struct i40e_veb *)0;
  #line 12372 
  if ((int)vsi->seid != (int)(*(pf->vsi + (unsigned long)pf->lan_vsi))->seid) 
    #line 12373 
    return -95;
  #line 12376 
  i = 0;
  #line 12376 
  while (i <= 15 && veb == (struct i40e_veb *)0) {
    #line 12377 
    if (pf->veb[i] != (struct i40e_veb *)0 && (int)(pf->veb[i])->seid == (int)vsi->uplink_seid) 
      #line 12378 
      veb = pf->veb[i];
    #line 12376 
    i ++;
  }
  #line 12381 
  br_spec = nlmsg_find_attr(nlh,16,26);
  #line 12383 
  attr = (struct nlattr *)nla_data(br_spec);
  #line 12383 
  rem = nla_len(br_spec);
  #line 12383 
  while (1) {
    #line 12383 
    if (! (nla_ok(attr,rem) != 0)) 
                                   #line 12383 
                                   break;
    {
      #line 12384 
      __u16 mode;
      #line 12386 
      if (nla_type(attr) != 1) 
                               #line 12387 
                               goto __Cont;
      #line 12389 
      mode = nla_get_u16(attr);
      #line 12390 
      if ((unsigned int)mode > 1U) 
                                   #line 12392 
                                   return -22;
      #line 12395 
      if (veb == (struct i40e_veb *)0) {
        #line 12396 
        veb = i40e_veb_setup(pf,(unsigned short)0,(unsigned short)((int)vsi->uplink_seid),(unsigned short)((int)vsi->seid),(unsigned char)((int)vsi->tc_config.enabled_tc));
        #line 12398 
        if (veb != (struct i40e_veb *)0) {
          #line 12399 
          veb->bridge_mode = mode;
          #line 12400 
          i40e_config_bridge_mode(veb);
        }
        else 
             #line 12403 
             return -2;
        #line 12405 
        break;
      }
      else 
        #line 12406 
        if ((int)veb->bridge_mode != (int)mode) {
          #line 12408 
          veb->bridge_mode = mode;
          #line 12410 
          if ((unsigned int)mode == 0U) 
                                        #line 12411 
                                        pf->flags |= 4096U; else 
                                                                 #line 12413 
                                                                 pf->flags &= 4294963199U;
          #line 12414 
          i40e_do_reset(pf,8192U,(_Bool)1);
          #line 12415 
          break;
        }
    }
    #line 12383 
    __Cont: 
            #line 12383 
    attr = nla_next(attr,& rem);
  }
  #line 12419 
  return 0;
}

#line 12434  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_ndo_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq, struct net_device *dev, u32 filter_mask, int nlflags)
{
  #line 12443 
  int i;
  #line 12439 
  struct i40e_netdev_priv *np = netdev_priv(dev);
  #line 12440 
  struct i40e_vsi *vsi = np->vsi;
  #line 12441 
  struct i40e_pf *pf = vsi->back;
  #line 12442 
  struct i40e_veb *veb = (struct i40e_veb *)0;
  #line 12446 
  if ((int)vsi->seid != (int)(*(pf->vsi + (unsigned long)pf->lan_vsi))->seid) 
    #line 12447 
    return -95;
  #line 12450 
  i = 0;
  #line 12450 
  while (i <= 15 && veb == (struct i40e_veb *)0) {
    #line 12451 
    if (pf->veb[i] != (struct i40e_veb *)0 && (int)(pf->veb[i])->seid == (int)vsi->uplink_seid) 
      #line 12452 
      veb = pf->veb[i];
    #line 12450 
    i ++;
  }
  #line 12455 
  if (veb == (struct i40e_veb *)0) 
                                   #line 12456 
                                   return 0;
  #line 12458 
  return ndo_dflt_bridge_getlink(skb,pid,seq,dev,
                                (unsigned short)((int)veb->bridge_mode),0U,
                                0U,nlflags,filter_mask,
                                (int (*)(struct sk_buff *,
                                         struct net_device *, u32 ))0);
}

#line 12468  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static netdev_features_t i40e_features_check(struct sk_buff *skb, struct net_device *dev, netdev_features_t features)
{
  #line 12472 
  size_t len;
  #line 12478 
  if ((unsigned int)skb->ip_summed != 3U) 
                                          #line 12479 
                                          return features;
  #line 12484 
  if ((int)skb_is_gso(skb) != 0) {
    #line 12484 
    ;
    #line 12484 
    if ((unsigned int)((struct skb_shared_info *)skb_end_pointer(skb))->gso_size <= 63U) 
      #line 12485 
      features &= 18446744056529747967ULL;
  }
  #line 12488 
  len = (unsigned long)(skb_network_header(skb) - skb->data);
  #line 12489 
  if ((len & 18446744073709551489UL) != 0UL) 
                                             #line 12490 
                                             goto out_err;
  #line 12493 
  len = (unsigned long)(skb_transport_header(skb) - skb_network_header(skb));
  #line 12494 
  if ((len & 18446744073709551107UL) != 0UL) 
                                             #line 12495 
                                             goto out_err;
  #line 12497 
  if ((unsigned int)skb->encapsulation != 0U) {
    #line 12499 
    len = (unsigned long)(skb_inner_network_header(skb) - skb_transport_header(skb));
    #line 12500 
    if ((len & 18446744073709551361UL) != 0UL) 
                                               #line 12501 
                                               goto out_err;
    #line 12504 
    len = (unsigned long)(skb_inner_transport_header(skb) - skb_inner_network_header(skb));
    #line 12506 
    if ((len & 18446744073709551107UL) != 0UL) 
                                               #line 12507 
                                               goto out_err;
  }
  #line 12515 
  return features;
  #line 12516 
  out_err: 
           #line 12516 
  ;
  #line 12517 
  return features & 18446744056529747941ULL;
}

#line 12525  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_xdp_setup(struct i40e_vsi *vsi, struct bpf_prog *prog)
{
  #line 12547 
  struct bpf_prog *__ret;
  #line 12530 
  struct bpf_prog *old_prog;
  #line 12531 
  bool need_reset;
  #line 12532 
  int i;
  #line 12528 
  int frame_size = (int)((vsi->netdev)->mtu + 22U);
  #line 12529 
  struct i40e_pf *pf = vsi->back;
  #line 12535 
  if ((int)vsi->rx_buf_len < frame_size) 
                                         #line 12536 
                                         return -22;
  #line 12538 
  if (! i40e_enabled_xdp_vsi_0(vsi)) 
    #line 12538 
    if (prog == (struct bpf_prog *)0) 
                                      #line 12539 
                                      return 0;
  #line 12542 
  need_reset = (_Bool)((int)i40e_enabled_xdp_vsi_0(vsi) != (prog != (struct bpf_prog *)0));
  #line 12544 
  if ((int)need_reset != 0) 
                            #line 12545 
                            i40e_prep_for_reset(pf,(_Bool)1);
  {
    #line 12547 
    struct bpf_prog **__ai_ptr = & vsi->xdp_prog;
    #line 12547 
    kasan_check_read((void *)__ai_ptr,8U);
    #line 12547 
    __ret = prog;
    #line 12547 
    switch (8UL) {
      #line 12547 
      case (unsigned long)1: 
                             #line 12547 
      ;
      #line 12548 
      ldv_inline_asm();
      #line 12547 
      break;
      #line 12547 
      case (unsigned long)2: 
                             #line 12547 
      ;
      #line 12548 
      ldv_inline_asm();
      #line 12547 
      break;
      #line 12547 
      case (unsigned long)4: 
                             #line 12547 
      ;
      #line 12548 
      ldv_inline_asm();
      #line 12547 
      break;
      #line 12547 
      case (unsigned long)8: 
                             #line 12547 
      ;
      #line 12548 
      ldv_inline_asm();
      #line 12547 
      break;
      #line 12547 
      default: 
               #line 12547 
      ;
      #line 12547 
      __xchg_wrong_size();
    }
    }
  #line 12547 
  old_prog = __ret;
  #line 12549 
  if ((int)need_reset != 0) {
    #line 12550 
    if (prog == (struct bpf_prog *)0) 
                                      #line 12552 
                                      synchronize_rcu();
    #line 12553 
    i40e_reset_and_rebuild(pf,(_Bool)1,(_Bool)1);
  }
  #line 12556 
  i = 0;
  #line 12556 
  while ((int)vsi->num_queue_pairs > i) {
    {
      #line 12558 
      union __anonunion___u_9849 __u = {.__val = vsi->xdp_prog};
      #line 12557 
      __write_once_size((void *)(& (*(vsi->rx_rings + (unsigned long)i))->xdp_prog),(void *)(& __u.__c),8);
      #line 12557 
      struct bpf_prog *tmp_3 = __u.__val;
    }
    #line 12556 
    i ++;
  }
  #line 12559 
  if (old_prog != (struct bpf_prog *)0) 
                                        #line 12560 
                                        bpf_prog_put(old_prog);
  #line 12565 
  if ((int)need_reset != 0 && prog != (struct bpf_prog *)0) {
    #line 12566 
    i = 0;
    #line 12566 
    while ((int)vsi->num_queue_pairs > i) {
      #line 12567 
      if ((*(vsi->xdp_rings + (unsigned long)i))->xsk_umem != (struct xdp_umem *)0) 
        #line 12568 
        i40e_xsk_wakeup(vsi->netdev,(unsigned int)i,1U);
      #line 12566 
      i ++;
    }
  }
  #line 12571 
  return 0;
}

#line 12580  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_enter_busy_conf(struct i40e_vsi *vsi)
{
  #line 12582 
  struct i40e_pf *pf = vsi->back;
  #line 12583 
  int timeout = 50;
  #line 12585 
  while (1) {
    #line 12585 
    if (! ((int)test_and_set_bit(1L,(unsigned long *)(& pf->state)) != 0)) 
      #line 12585 
      break;
    #line 12586 
    timeout --;
    #line 12587 
    if (timeout == 0) 
                      #line 12588 
                      return -16;
    #line 12589 
    usleep_range(1000UL,2000UL);
  }
  #line 12592 
  return 0;
}

#line 12599  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_exit_busy_conf(struct i40e_vsi *vsi)
{
  #line 12601 
  struct i40e_pf *pf = vsi->back;
  #line 12603 
  cif_clear_bit_1(1L,(unsigned long *)(& pf->state));
  #line 12604 
  return;
}

#line 12611  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_queue_pair_reset_stats(struct i40e_vsi *vsi, int queue_pair)
{
  #line 12613 
  memset((void *)(& (*(vsi->rx_rings + (unsigned long)queue_pair))->__anonCompField_i40e_ring_222.rx_stats),0,40UL);
  #line 12615 
  memset((void *)(& (*(vsi->tx_rings + (unsigned long)queue_pair))->stats),0,16UL);
  #line 12617 
  if ((int)i40e_enabled_xdp_vsi_0(vsi) != 0) 
                                             #line 12618 
                                             memset((void *)(& (*(vsi->xdp_rings + (unsigned long)queue_pair))->stats),0,16UL);
  #line 12619 
  return;
}

#line 12628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_queue_pair_clean_rings(struct i40e_vsi *vsi, int queue_pair)
{
  #line 12630 
  i40e_clean_tx_ring(*(vsi->tx_rings + (unsigned long)queue_pair));
  #line 12631 
  if ((int)i40e_enabled_xdp_vsi_0(vsi) != 0) {
    #line 12635 
    synchronize_rcu();
    #line 12636 
    i40e_clean_tx_ring(*(vsi->xdp_rings + (unsigned long)queue_pair));
  }
  #line 12638 
  i40e_clean_rx_ring(*(vsi->rx_rings + (unsigned long)queue_pair));
  #line 12639 
  return;
}

#line 12647  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_queue_pair_toggle_napi(struct i40e_vsi *vsi, int queue_pair, bool enable)
{
  #line 12650 
  struct i40e_ring *rxr = *(vsi->rx_rings + (unsigned long)queue_pair);
  #line 12651 
  struct i40e_q_vector *q_vector = rxr->q_vector;
  #line 12653 
  if (vsi->netdev == (struct net_device *)0) 
                                             #line 12654 
                                             return;
  #line 12657 
  if (q_vector->rx.ring != (struct i40e_ring *)0 || q_vector->tx.ring != (struct i40e_ring *)0) 
    #line 12658 
    if ((int)enable != 0) 
                          #line 12659 
                          napi_enable(& q_vector->napi); else 
                                                              #line 12661 
                                                              napi_disable(& q_vector->napi);
  #line 12662 
  return;
}

#line 12673  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_queue_pair_toggle_rings(struct i40e_vsi *vsi, int queue_pair, bool enable)
{
  #line 12677 
  int pf_q;
  #line 12676 
  struct i40e_pf *pf = vsi->back;
  #line 12677 
  int ret = 0;
  #line 12679 
  pf_q = (int)vsi->base_queue + queue_pair;
  #line 12680 
  ret = i40e_control_wait_tx_q((int)vsi->seid,pf,pf_q,(_Bool)0,(_Bool)((bool)((int)enable) != 0));
  #line 12682 
  if (ret != 0) {
    #line 12683 
    char *tmp;
    #line 12683 
    if ((int)enable != 0) 
                          #line 12683 
                          tmp = (char *)"en"; else 
                                                   #line 12683 
                                                   tmp = (char *)"dis";
    #line 12683 
    ;
    #line 12683 
    ;
    #line 12683 
    ;
    #line 12683 
    _dev_info(& (pf->pdev)->dev,(char *)"VSI seid %d Tx ring %d %sable timeout\n",(int)vsi->seid,pf_q,tmp);
    #line 12686 
    return ret;
  }
  #line 12689 
  i40e_control_rx_q(pf,pf_q,(_Bool)((bool)((int)enable) != 0));
  #line 12690 
  ret = i40e_pf_rxq_wait(pf,pf_q,(_Bool)((bool)((int)enable) != 0));
  #line 12691 
  if (ret != 0) {
    #line 12692 
    char *tmp_0;
    #line 12692 
    if ((int)enable != 0) 
                          #line 12692 
                          tmp_0 = (char *)"en"; else 
                                                     #line 12692 
                                                     tmp_0 = (char *)"dis";
    #line 12692 
    ;
    #line 12692 
    ;
    #line 12692 
    ;
    #line 12692 
    _dev_info(& (pf->pdev)->dev,(char *)"VSI seid %d Rx ring %d %sable timeout\n",(int)vsi->seid,pf_q,tmp_0);
    #line 12695 
    return ret;
  }
  #line 12701 
  if (! enable) {
    #line 12702 
    unsigned long __ms = 50UL;
    #line 12702 
    while (1) {
      #line 12702 
      unsigned long tmp_1;
      #line 12702 
      tmp_1 = __ms;
      #line 12702 
      __ms --;
      #line 12702 
      ;
      #line 12702 
      if (! (tmp_1 != 0UL)) 
                            #line 12702 
                            break;
      #line 12702 
      __const_udelay(4295000UL);
    }
  }
  #line 12704 
  if (! i40e_enabled_xdp_vsi_0(vsi)) 
                                     #line 12705 
                                     return ret;
  #line 12707 
  ret = i40e_control_wait_tx_q((int)vsi->seid,pf,(int)vsi->alloc_queue_pairs + pf_q,(_Bool)1,(_Bool)((bool)((int)enable) != 0));
  #line 12710 
  if (ret != 0) {
    #line 12711 
    char *tmp_3;
    #line 12711 
    if ((int)enable != 0) 
                          #line 12711 
                          tmp_3 = (char *)"en"; else 
                                                     #line 12711 
                                                     tmp_3 = (char *)"dis";
    #line 12711 
    ;
    #line 12711 
    ;
    #line 12711 
    ;
    #line 12711 
    _dev_info(& (pf->pdev)->dev,(char *)"VSI seid %d XDP Tx ring %d %sable timeout\n",(int)vsi->seid,pf_q,tmp_3);
  }
  #line 12716 
  return ret;
}

#line 12724  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_queue_pair_enable_irq(struct i40e_vsi *vsi, int queue_pair)
{
  #line 12726 
  struct i40e_ring *rxr = *(vsi->rx_rings + (unsigned long)queue_pair);
  #line 12727 
  struct i40e_pf *pf = vsi->back;
  #line 12728 
  struct i40e_hw *hw = & pf->hw;
  #line 12731 
  if (((unsigned long)pf->flags & 4UL) != 0UL) 
                                               #line 12732 
                                               i40e_irq_dynamic_enable(vsi,(int)(rxr->q_vector)->v_idx); else 
                                                                    #line 12734 
                                                                    i40e_irq_dynamic_enable_icr0(pf);
  #line 12736 
  readl((void *)(hw->hw_addr + 745772U));
  #line 12737 
  return;
}

#line 12744  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_queue_pair_disable_irq(struct i40e_vsi *vsi, int queue_pair)
{
  #line 12746 
  struct i40e_ring *rxr = *(vsi->rx_rings + (unsigned long)queue_pair);
  #line 12747 
  struct i40e_pf *pf = vsi->back;
  #line 12748 
  struct i40e_hw *hw = & pf->hw;
  #line 12756 
  if (((unsigned long)pf->flags & 4UL) != 0UL) {
    #line 12757 
    u32 intpf = (unsigned int)(vsi->base_vector + (int)(rxr->q_vector)->v_idx);
    #line 12759 
    writel(0U,(void *)(hw->hw_addr + (unsigned long)((intpf + 53759U) * 4U)));
    #line 12760 
    readl((void *)(hw->hw_addr + 745772U));
    #line 12761 
    synchronize_irq((pf->msix_entries + (unsigned long)intpf)->vector);
  }
  else {
    #line 12764 
    writel(0U,(void *)(hw->hw_addr + 231424U));
    #line 12765 
    writel(0U,(void *)(hw->hw_addr + 230528U));
    #line 12766 
    readl((void *)(hw->hw_addr + 745772U));
    #line 12767 
    synchronize_irq((pf->pdev)->irq);
  }
  #line 12769 
  return;
}

#line 12778  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_queue_pair_disable(struct i40e_vsi *vsi, int queue_pair)
{
  #line 12780 
  int err;
  #line 12782 
  err = i40e_enter_busy_conf(vsi);
  #line 12783 
  if (err != 0) 
                #line 12784 
                return err;
  #line 12786 
  i40e_queue_pair_disable_irq(vsi,queue_pair);
  #line 12787 
  err = i40e_queue_pair_toggle_rings(vsi,queue_pair,(_Bool)0);
  #line 12788 
  i40e_queue_pair_toggle_napi(vsi,queue_pair,(_Bool)0);
  #line 12789 
  i40e_queue_pair_clean_rings(vsi,queue_pair);
  #line 12790 
  i40e_queue_pair_reset_stats(vsi,queue_pair);
  #line 12792 
  return err;
}

#line 12802  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_queue_pair_enable(struct i40e_vsi *vsi, int queue_pair)
{
  #line 12804 
  int err;
  #line 12806 
  err = i40e_configure_tx_ring(*(vsi->tx_rings + (unsigned long)queue_pair));
  #line 12807 
  if (err != 0) 
                #line 12808 
                return err;
  #line 12810 
  if ((int)i40e_enabled_xdp_vsi_0(vsi) != 0) {
    #line 12811 
    err = i40e_configure_tx_ring(*(vsi->xdp_rings + (unsigned long)queue_pair));
    #line 12812 
    if (err != 0) 
                  #line 12813 
                  return err;
  }
  #line 12816 
  err = i40e_configure_rx_ring(*(vsi->rx_rings + (unsigned long)queue_pair));
  #line 12817 
  if (err != 0) 
                #line 12818 
                return err;
  #line 12820 
  err = i40e_queue_pair_toggle_rings(vsi,queue_pair,(_Bool)1);
  #line 12821 
  i40e_queue_pair_toggle_napi(vsi,queue_pair,(_Bool)1);
  #line 12822 
  i40e_queue_pair_enable_irq(vsi,queue_pair);
  #line 12824 
  i40e_exit_busy_conf(vsi);
  #line 12826 
  return err;
}

#line 12834  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_xdp(struct net_device *dev, struct netdev_bpf *xdp)
{
  #line 12837 
  struct i40e_netdev_priv *np = netdev_priv(dev);
  #line 12838 
  struct i40e_vsi *vsi = np->vsi;
  #line 12840 
  if (vsi->type != (unsigned int)I40E_VSI_MAIN) 
                                                #line 12841 
                                                return -22;
  #line 12843 
  switch ((unsigned int)xdp->command) {
    #line 12844 
    case (unsigned int)0: 
                          #line 12844 
    ;
    #line 12845 
    return i40e_xdp_setup(vsi,
                       xdp->__anonCompField_netdev_bpf_158.__anonCompField___anonunion_674_155.prog);
    #line 12846 
    case (unsigned int)2: 
                          #line 12846 
    ;
    #line 12847 
    if (vsi->xdp_prog != (struct bpf_prog *)0) 
                                               #line 12847 
                                               xdp->__anonCompField_netdev_bpf_158.__anonCompField___anonunion_674_156.prog_id = ((vsi->xdp_prog)->aux)->id; else 
                                                                    #line 12847 
                                                                    xdp->__anonCompField_netdev_bpf_158.__anonCompField___anonunion_674_156.prog_id = 0U;
    #line 12848 
    return 0;
    #line 12849 
    case (unsigned int)6: 
                          #line 12849 
    ;
    #line 12850 
    return i40e_xsk_umem_setup(vsi,xdp->__anonCompField_netdev_bpf_158.xsk.umem,
                            (unsigned short)((int)xdp->__anonCompField_netdev_bpf_158.xsk.queue_id));
    #line 12852 
    default: 
             #line 12852 
    ;
    #line 12853 
    return -22;
  }
}

#line 12857  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct net_device_ops i40e_netdev_ops = {.ndo_open = & i40e_open, .ndo_stop = & i40e_close, .ndo_start_xmit = & i40e_lan_xmit_frame, .ndo_features_check = & i40e_features_check, .ndo_set_rx_mode = & i40e_set_rx_mode, .ndo_set_mac_address = & i40e_set_mac, .ndo_validate_addr = & eth_validate_addr, .ndo_do_ioctl = & i40e_ioctl, .ndo_change_mtu = & i40e_change_mtu, .ndo_tx_timeout = & i40e_tx_timeout, .ndo_get_stats64 = & i40e_get_netdev_stats_struct, .ndo_vlan_rx_add_vid = & i40e_vlan_rx_add_vid, .ndo_vlan_rx_kill_vid = & i40e_vlan_rx_kill_vid, .ndo_poll_controller = & i40e_netpoll, .ndo_set_vf_mac = & i40e_ndo_set_vf_mac, .ndo_set_vf_vlan = & i40e_ndo_set_vf_port_vlan, .ndo_set_vf_rate = & i40e_ndo_set_vf_bw, .ndo_set_vf_spoofchk = & i40e_ndo_set_vf_spoofchk, .ndo_set_vf_trust = & i40e_ndo_set_vf_trust, .ndo_get_vf_config = & i40e_ndo_get_vf_config, .ndo_set_vf_link_state = & i40e_ndo_set_vf_link_state, .ndo_get_vf_stats = & i40e_get_vf_stats, .ndo_setup_tc = & __i40e_setup_tc, .ndo_set_features = & i40e_set_features, .ndo_fdb_add = & i40e_ndo_fdb_add, .ndo_bridge_setlink = & i40e_ndo_bridge_setlink, .ndo_bridge_getlink = & i40e_ndo_bridge_getlink, .ndo_get_phys_port_id = & i40e_get_phys_port_id, .ndo_udp_tunnel_add = & i40e_udp_tunnel_add, .ndo_udp_tunnel_del = & i40e_udp_tunnel_del, .ndo_dfwd_add_station = & i40e_fwd_add, .ndo_dfwd_del_station = & i40e_fwd_del, .ndo_bpf = & i40e_xdp, .ndo_xdp_xmit = & i40e_xdp_xmit, .ndo_xsk_wakeup = & i40e_xsk_wakeup};
#line 12903  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_config_netdev(struct i40e_vsi *vsi)
{
  #line 12907 
  struct i40e_netdev_priv *np;
  #line 12908 
  struct net_device *netdev;
  #line 12909 
  u8 broadcast[6U];
  #line 12910 
  u8 mac_addr[6U];
  #line 12911 
  int etherdev_size;
  #line 12912 
  netdev_features_t hw_enc_features;
  #line 12913 
  netdev_features_t hw_features;
  #line 12905 
  struct i40e_pf *pf = vsi->back;
  #line 12906 
  struct i40e_hw *hw = & pf->hw;
  #line 12915 
  etherdev_size = 8;
  #line 12916 
  netdev = cif_alloc_etherdev_mqs(etherdev_size,(unsigned int)vsi->alloc_queue_pairs,(unsigned int)vsi->alloc_queue_pairs);
  #line 12917 
  if (netdev == (struct net_device *)0) 
                                        #line 12918 
                                        return -12;
  #line 12920 
  vsi->netdev = netdev;
  #line 12921 
  np = (struct i40e_netdev_priv *)netdev_priv(netdev);
  #line 12922 
  np->vsi = vsi;
  #line 12924 
  hw_enc_features = 868117465139ULL;
  #line 12945 
  if (((unsigned long)pf->hw_features & 16384UL) == 0UL) 
                                                         #line 12946 
                                                         netdev->gso_partial_features |= 134217728ULL;
  #line 12948 
  netdev->gso_partial_features |= 8388608ULL;
  #line 12950 
  netdev->hw_enc_features |= hw_enc_features;
  #line 12953 
  netdev->vlan_features = (netdev->vlan_features | hw_enc_features) | 524288ULL;
  #line 12956 
  netdev->hw_features |= 140737488355328ULL;
  #line 12958 
  hw_features = hw_enc_features | 384ULL;
  #line 12962 
  if (((unsigned long)pf->flags & 1024UL) == 0UL) 
                                                  #line 12963 
                                                  hw_features |= 281612415664128ULL;
  #line 12965 
  netdev->hw_features |= hw_features;
  #line 12967 
  netdev->features = (netdev->features | hw_features) | 512ULL;
  #line 12968 
  netdev->hw_enc_features |= 524288ULL;
  #line 12970 
  if (vsi->type == (unsigned int)I40E_VSI_MAIN) {
    #line 12971 
    netdev->dev.parent = & (pf->pdev)->dev;
    #line 12972 
    ether_addr_copy((u8 *)(& mac_addr),(u8 *)(& hw->mac.perm_addr));
    #line 12983 
    i40e_rm_default_mac_filter(vsi,(u8 *)(& mac_addr));
    #line 12984 
    cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
    #line 12985 
    i40e_add_mac_filter(vsi,(u8 *)(& mac_addr));
    #line 12986 
    cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  }
  else {
    #line 12993 
    snprintf((char *)(& netdev->name),16UL,(char *)"%.*sv%%d",12,(char *)(& ((*(pf->vsi + (unsigned long)pf->lan_vsi))->netdev)->name));
    #line 12996 
    eth_random_addr((u8 *)(& mac_addr));
    #line 12998 
    cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
    #line 12999 
    i40e_add_mac_filter(vsi,(u8 *)(& mac_addr));
    #line 13000 
    cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  }
  #line 13016 
  eth_broadcast_addr((u8 *)(& broadcast));
  #line 13017 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 13018 
  i40e_add_mac_filter(vsi,(u8 *)(& broadcast));
  #line 13019 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 13021 
  ether_addr_copy(netdev->dev_addr,(u8 *)(& mac_addr));
  #line 13022 
  ether_addr_copy((u8 *)(& netdev->perm_addr),(u8 *)(& mac_addr));
  #line 13025 
  netdev->neigh_priv_len = (unsigned short)16U;
  #line 13027 
  netdev->priv_flags |= 4096U;
  #line 13028 
  netdev->priv_flags |= 16384U;
  #line 13030 
  i40e_vsi_config_netdev_tc(vsi,(unsigned char)((int)vsi->tc_config.enabled_tc));
  #line 13032 
  netdev->netdev_ops = & i40e_netdev_ops;
  #line 13033 
  netdev->watchdog_timeo = 1250;
  #line 13034 
  i40e_set_ethtool_ops(netdev);
  #line 13037 
  netdev->min_mtu = 68U;
  #line 13038 
  netdev->max_mtu = 9702U;
  #line 13040 
  return 0;
}

#line 13049  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_vsi_delete(struct i40e_vsi *vsi)
{
  #line 13052 
  if (*((vsi->back)->vsi + (unsigned long)(vsi->back)->lan_vsi) == vsi) 
    #line 13053 
    return;
  #line 13055 
  i40e_aq_delete_element(& (vsi->back)->hw,(unsigned short)((int)vsi->seid),(struct i40e_asq_cmd_details *)0);
  #line 13056 
  return;
}

#line 13064  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_is_vsi_uplink_mode_veb(struct i40e_vsi *vsi)
{
  #line 13066 
  struct i40e_veb *veb;
  #line 13067 
  struct i40e_pf *pf = vsi->back;
  #line 13070 
  if ((unsigned int)vsi->veb_idx > 15U) 
                                        #line 13071 
                                        return 1;
  #line 13073 
  veb = pf->veb[(int)vsi->veb_idx];
  #line 13074 
  if (veb == (struct i40e_veb *)0) {
    #line 13075 
    _dev_info(& (pf->pdev)->dev,(char *)"There is no veb associated with the bridge\n");
    #line 13077 
    return -2;
  }
  #line 13081 
  if (((int)veb->bridge_mode & 1) != 0) 
                                        #line 13082 
                                        return 0; else 
                                                       #line 13085 
                                                       return 1;
  #line 13089 
  return 0;
}

#line 13099  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_add_vsi(struct i40e_vsi *vsi)
{
  #line 13104 
  struct i40e_vsi_context ctxt;
  #line 13105 
  struct i40e_mac_filter *f;
  #line 13106 
  struct hlist_node *h;
  #line 13107 
  int bkt;
  #line 13101 
  int ret = -19;
  #line 13102 
  struct i40e_pf *pf = vsi->back;
  #line 13103 
  struct i40e_hw *hw = & pf->hw;
  #line 13109 
  u8 enabled_tc = (unsigned char)1U;
  #line 13110 
  int f_count = 0;
  #line 13112 
  memset((void *)(& ctxt),0,144UL);
  #line 13113 
  switch ((unsigned int)vsi->type) {
    #line 13114 
    case (unsigned int)0: 
                          #line 13114 
    ;
    #line 13120 
    ctxt.seid = pf->main_vsi_seid;
    #line 13121 
    ctxt.pf_num = pf->hw.pf_id;
    #line 13122 
    ctxt.vf_num = (unsigned char)0U;
    #line 13123 
    ret = (int)i40e_aq_get_vsi_params(& pf->hw,& ctxt,
                             (struct i40e_asq_cmd_details *)0);
    #line 13124 
    ctxt.flags = (unsigned short)2U;
    #line 13125 
    if (ret != 0) {
      #line 13126 
      ;
      #line 13126 
      _dev_info(& (pf->pdev)->dev,(char *)"couldn\'t get PF vsi config, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
      #line 13131 
      return -2;
    }
    #line 13133 
    vsi->info = ctxt.info;
    #line 13134 
    vsi->info.valid_sections = (unsigned short)0U;
    #line 13136 
    vsi->seid = ctxt.seid;
    #line 13137 
    vsi->id = ctxt.vsi_number;
    #line 13139 
    enabled_tc = i40e_pf_get_tc_map(pf);
    #line 13145 
    if (((unsigned long)pf->flags & 1048576UL) != 0UL) {
      #line 13146 
      memset((void *)(& ctxt),0,144UL);
      #line 13147 
      ctxt.seid = pf->main_vsi_seid;
      #line 13148 
      ctxt.pf_num = pf->hw.pf_id;
      #line 13149 
      ctxt.vf_num = (unsigned char)0U;
      #line 13150 
      ctxt.info.valid_sections = (unsigned short)((unsigned int)ctxt.info.valid_sections | 1U);
      #line 13152 
      ctxt.info.switch_id = (unsigned short)16384U;
      #line 13154 
      ret = (int)i40e_aq_update_vsi_params(hw,& ctxt,(struct i40e_asq_cmd_details *)0);
      #line 13155 
      if (ret != 0) {
        #line 13156 
        ;
        #line 13156 
        _dev_info(& (pf->pdev)->dev,(char *)"update vsi failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
        #line 13161 
        ret = -2;
        #line 13162 
        goto err;
      }
    }
    #line 13167 
    if (((unsigned long)pf->flags & 1024UL) != 0UL && ! pf->hw.func_caps.iscsi) {
      #line 13169 
      memset((void *)(& ctxt),0,144UL);
      #line 13170 
      ctxt.seid = pf->main_vsi_seid;
      #line 13171 
      ctxt.pf_num = pf->hw.pf_id;
      #line 13172 
      ctxt.vf_num = (unsigned char)0U;
      #line 13173 
      i40e_vsi_setup_queue_map(vsi,& ctxt,(unsigned char)((int)enabled_tc),(_Bool)0);
      #line 13174 
      ret = (int)i40e_aq_update_vsi_params(hw,& ctxt,(struct i40e_asq_cmd_details *)0);
      #line 13175 
      if (ret != 0) {
        #line 13176 
        ;
        #line 13176 
        _dev_info(& (pf->pdev)->dev,(char *)"update vsi failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
        #line 13181 
        ret = -2;
        #line 13182 
        goto err;
      }
      #line 13185 
      i40e_vsi_update_queue_map(vsi,& ctxt);
      #line 13186 
      vsi->info.valid_sections = (unsigned short)0U;
    }
    else {
      #line 13194 
      ret = i40e_vsi_config_tc(vsi,(unsigned char)((int)enabled_tc));
      #line 13195 
      if (ret != 0) {
        #line 13199 
        ;
        #line 13199 
        ;
        #line 13199 
        _dev_info(& (pf->pdev)->dev,(char *)"failed to configure TCs for main VSI tc_map 0x%08x, err %s aq_err %s\n",(int)enabled_tc,i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
      }
    }
    #line 13207 
    break;
    #line 13209 
    case (unsigned int)7: 
                          #line 13209 
    ;
    #line 13210 
    ctxt.pf_num = hw->pf_id;
    #line 13211 
    ctxt.vf_num = (unsigned char)0U;
    #line 13212 
    ctxt.uplink_seid = vsi->uplink_seid;
    #line 13213 
    ctxt.connection_type = (unsigned char)1U;
    #line 13214 
    ctxt.flags = (unsigned short)2U;
    #line 13215 
    if (((unsigned long)pf->flags & 4096UL) != 0UL) {
      #line 13215 
      if (i40e_is_vsi_uplink_mode_veb(vsi) != 0) {
        #line 13217 
        ctxt.info.valid_sections = (unsigned short)((unsigned int)ctxt.info.valid_sections | 1U);
        #line 13219 
        ctxt.info.switch_id = (unsigned short)8192U;
      }
    }
    #line 13222 
    i40e_vsi_setup_queue_map(vsi,& ctxt,(unsigned char)((int)enabled_tc),(_Bool)1);
    #line 13223 
    break;
    #line 13225 
    case (unsigned int)2: 
                          #line 13225 
    ;
    #line 13226 
    ctxt.pf_num = hw->pf_id;
    #line 13227 
    ctxt.vf_num = (unsigned char)0U;
    #line 13228 
    ctxt.uplink_seid = vsi->uplink_seid;
    #line 13229 
    ctxt.connection_type = (unsigned char)1U;
    #line 13230 
    ctxt.flags = (unsigned short)1U;
    #line 13235 
    if (i40e_is_vsi_uplink_mode_veb(vsi) != 0) {
      #line 13236 
      ctxt.info.valid_sections = (unsigned short)((unsigned int)ctxt.info.valid_sections | 1U);
      #line 13238 
      ctxt.info.switch_id = (unsigned short)8192U;
    }
    #line 13243 
    i40e_vsi_setup_queue_map(vsi,& ctxt,(unsigned char)((int)enabled_tc),(_Bool)1);
    #line 13244 
    break;
    #line 13246 
    case (unsigned int)6: 
                          #line 13246 
    ;
    #line 13247 
    ctxt.pf_num = hw->pf_id;
    #line 13248 
    ctxt.vf_num = (unsigned char)((int)((unsigned char)vsi->vf_id) + (int)((unsigned char)hw->func_caps.vf_base_id));
    #line 13249 
    ctxt.uplink_seid = vsi->uplink_seid;
    #line 13250 
    ctxt.connection_type = (unsigned char)1U;
    #line 13251 
    ctxt.flags = (unsigned short)0U;
    #line 13256 
    if (i40e_is_vsi_uplink_mode_veb(vsi) != 0) {
      #line 13257 
      ctxt.info.valid_sections = (unsigned short)((unsigned int)ctxt.info.valid_sections | 1U);
      #line 13259 
      ctxt.info.switch_id = (unsigned short)8192U;
    }
    #line 13263 
    if (((unsigned long)(vsi->back)->flags & 262144UL) != 0UL) {
      #line 13264 
      ctxt.info.valid_sections = (unsigned short)((unsigned int)ctxt.info.valid_sections | 128U);
      #line 13266 
      ctxt.info.queueing_opt_flags = (unsigned char)((unsigned int)ctxt.info.queueing_opt_flags | 80U);
    }
    #line 13271 
    ctxt.info.valid_sections = (unsigned short)((unsigned int)ctxt.info.valid_sections | 4U);
    #line 13272 
    ctxt.info.port_vlan_flags = (unsigned char)((unsigned int)ctxt.info.port_vlan_flags | 3U);
    #line 13273 
    if ((int)(pf->vf + (unsigned long)vsi->vf_id)->spoofchk != 0) {
      #line 13274 
      ctxt.info.valid_sections = (unsigned short)((unsigned int)ctxt.info.valid_sections | 2U);
      #line 13276 
      ctxt.info.sec_flags = (unsigned char)((unsigned int)ctxt.info.sec_flags | 6U);
    }
    #line 13281 
    i40e_vsi_setup_queue_map(vsi,& ctxt,(unsigned char)((int)enabled_tc),(_Bool)1);
    #line 13282 
    break;
    #line 13284 
    case (unsigned int)8: 
                          #line 13284 
    ;
    #line 13286 
    break;
    #line 13288 
    default: 
             #line 13288 
    ;
    #line 13289 
    return -19;
  }
  #line 13292 
  if (vsi->type != (unsigned int)I40E_VSI_MAIN) {
    #line 13293 
    ret = (int)i40e_aq_add_vsi(hw,& ctxt,(struct i40e_asq_cmd_details *)0);
    #line 13294 
    if (ret != 0) {
      #line 13295 
      ;
      #line 13295 
      _dev_info(& ((vsi->back)->pdev)->dev,(char *)"add vsi failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
      #line 13300 
      ret = -2;
      #line 13301 
      goto err;
    }
    #line 13303 
    vsi->info = ctxt.info;
    #line 13304 
    vsi->info.valid_sections = (unsigned short)0U;
    #line 13305 
    vsi->seid = ctxt.seid;
    #line 13306 
    vsi->id = ctxt.vsi_number;
  }
  #line 13309 
  vsi->active_filters = 0U;
  #line 13310 
  cif_clear_bit_1(3L,(unsigned long *)(& vsi->state));
  #line 13311 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 13313 
  bkt = 0;
  #line 13313 
  f = (struct i40e_mac_filter *)0;
  #line 13313 
  while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
    {
      #line 13313 
      void *__mptr;
      #line 13313 
      struct i40e_mac_filter *tmp_17;
      {
        #line 13313 
        struct hlist_node *____ptr = vsi->mac_filter_hash[bkt].first;
        #line 13313 
        if (____ptr != (struct hlist_node *)0) {
          #line 13313 
          __mptr = (void *)____ptr;
          #line 13313 
          tmp_17 = ((struct i40e_mac_filter *)__mptr);
        }
        else 
             #line 13313 
             tmp_17 = (struct i40e_mac_filter *)0;
        }
      #line 13313 
      f = tmp_17;
      #line 13313 
      while (1) {
        #line 13313 
        void *__mptr_0;
        #line 13313 
        struct i40e_mac_filter *tmp_20;
        #line 13313 
        if (f != (struct i40e_mac_filter *)0) {
          #line 13313 
          h = f->hlist.next;
          #line 13313 
          if (! (1 != 0)) 
                          #line 13313 
                          break;
        }
        else 
             #line 13313 
             break;
        #line 13314 
        f->state = I40E_FILTER_NEW;
        #line 13315 
        f_count ++;
        {
          #line 13313 
          struct hlist_node *____ptr_0 = h;
          #line 13313 
          if (____ptr_0 != (struct hlist_node *)0) {
            #line 13313 
            __mptr_0 = (void *)____ptr_0;
            #line 13313 
            tmp_20 = ((struct i40e_mac_filter *)__mptr_0);
          }
          else 
               #line 13313 
               tmp_20 = (struct i40e_mac_filter *)0;
          }
        #line 13313 
        f = tmp_20;
      }
    }
    #line 13313 
    bkt ++;
  }
  #line 13317 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 13319 
  if (f_count != 0) {
    #line 13320 
    vsi->flags |= 1UL;
    #line 13321 
    cif_set_bit_1(27L,(unsigned long *)(& pf->state));
  }
  #line 13325 
  ret = i40e_vsi_get_bw_info(vsi);
  #line 13326 
  if (ret != 0) {
    #line 13327 
    ;
    #line 13327 
    _dev_info(& (pf->pdev)->dev,(char *)"couldn\'t get vsi bw info, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 13332 
    ret = 0;
  }
  #line 13335 
  err: 
       #line 13335 
  ;
  #line 13336 
  return ret;
}

#line 13345  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_vsi_release(struct i40e_vsi *vsi)
{
  #line 13347 
  struct i40e_mac_filter *f;
  #line 13348 
  struct hlist_node *h;
  #line 13350 
  struct i40e_pf *pf;
  #line 13351 
  u16 uplink_seid;
  #line 13352 
  int i;
  #line 13352 
  int n;
  #line 13352 
  int bkt;
  #line 13349 
  struct i40e_veb *veb = (struct i40e_veb *)0;
  #line 13354 
  pf = vsi->back;
  #line 13357 
  if ((vsi->flags & 2UL) != 0UL) {
    #line 13358 
    _dev_info(& (pf->pdev)->dev,(char *)"VSI %d has existing VEB %d\n",(int)vsi->seid,(int)vsi->uplink_seid);
    #line 13360 
    return -19;
  }
  #line 13362 
  if (*(pf->vsi + (unsigned long)pf->lan_vsi) == vsi) {
    #line 13363 
    if (! test_bit(3L,(unsigned long *)(& pf->state))) {
      #line 13364 
      _dev_info(& (pf->pdev)->dev,(char *)"Can\'t remove PF VSI\n");
      #line 13365 
      return -19;
    }
  }
  #line 13368 
  uplink_seid = vsi->uplink_seid;
  #line 13369 
  if (vsi->type != (unsigned int)I40E_VSI_SRIOV) {
    #line 13370 
    if ((int)vsi->netdev_registered != 0) {
      #line 13371 
      vsi->netdev_registered = (_Bool)0;
      #line 13372 
      if (vsi->netdev != (struct net_device *)0) 
                                                 #line 13374 
                                                 cif_unregister_netdev(vsi->netdev);
    }
    else 
         #line 13377 
         i40e_vsi_close(vsi);
    #line 13379 
    i40e_vsi_disable_irq(vsi);
  }
  #line 13382 
  cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 13385 
  if (vsi->netdev != (struct net_device *)0) {
    #line 13386 
    __dev_uc_unsync(vsi->netdev,(int (*)(struct net_device *, unsigned char *))0);
    #line 13387 
    __dev_mc_unsync(vsi->netdev,(int (*)(struct net_device *, unsigned char *))0);
  }
  #line 13391 
  bkt = 0;
  #line 13391 
  f = (struct i40e_mac_filter *)0;
  #line 13391 
  while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
    {
      #line 13391 
      void *__mptr;
      #line 13391 
      struct i40e_mac_filter *tmp_1;
      {
        #line 13391 
        struct hlist_node *____ptr = vsi->mac_filter_hash[bkt].first;
        #line 13391 
        if (____ptr != (struct hlist_node *)0) {
          #line 13391 
          __mptr = (void *)____ptr;
          #line 13391 
          tmp_1 = ((struct i40e_mac_filter *)__mptr);
        }
        else 
             #line 13391 
             tmp_1 = (struct i40e_mac_filter *)0;
        }
      #line 13391 
      f = tmp_1;
      #line 13391 
      while (1) {
        #line 13391 
        struct i40e_mac_filter *tmp_4;
        #line 13391 
        void *__mptr_0;
        #line 13391 
        if (f != (struct i40e_mac_filter *)0) {
          #line 13391 
          h = f->hlist.next;
          #line 13391 
          if (! (1 != 0)) 
                          #line 13391 
                          break;
        }
        else 
             #line 13391 
             break;
        #line 13392 
        __i40e_del_filter(vsi,f);
        {
          #line 13391 
          struct hlist_node *____ptr_0 = h;
          #line 13391 
          if (____ptr_0 != (struct hlist_node *)0) {
            #line 13391 
            __mptr_0 = (void *)____ptr_0;
            #line 13391 
            tmp_4 = ((struct i40e_mac_filter *)__mptr_0);
          }
          else 
               #line 13391 
               tmp_4 = (struct i40e_mac_filter *)0;
          }
        #line 13391 
        f = tmp_4;
      }
    }
    #line 13391 
    bkt ++;
  }
  #line 13394 
  cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(& vsi->mac_filter_hash_lock);
  #line 13396 
  i40e_sync_vsi_filters(vsi);
  #line 13398 
  i40e_vsi_delete(vsi);
  #line 13399 
  i40e_vsi_free_q_vectors(vsi);
  #line 13400 
  if (vsi->netdev != (struct net_device *)0) {
    #line 13401 
    cif_free_netdev(vsi->netdev);
    #line 13402 
    vsi->netdev = (struct net_device *)0;
  }
  #line 13404 
  i40e_vsi_clear_rings(vsi);
  #line 13405 
  i40e_vsi_clear(vsi);
  #line 13415 
  n = 0;
  #line 13415 
  i = 0;
  #line 13415 
  while ((int)pf->num_alloc_vsi > i) {
    #line 13416 
    if ((*(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + (unsigned long)i))->uplink_seid == (int)uplink_seid) && ((*(pf->vsi + (unsigned long)i))->flags & 2UL) == 0UL) 
      #line 13419 
      n ++;
    #line 13415 
    i ++;
  }
  #line 13422 
  i = 0;
  #line 13422 
  while (i <= 15) {
    #line 13423 
    if (pf->veb[i] == (struct i40e_veb *)0) 
                                            #line 13424 
                                            goto __Cont;
    #line 13425 
    if ((int)(pf->veb[i])->uplink_seid == (int)uplink_seid) 
                                                            #line 13426 
                                                            n ++;
    #line 13427 
    if ((int)(pf->veb[i])->seid == (int)uplink_seid) 
                                                     #line 13428 
                                                     veb = pf->veb[i];
    #line 13422 
    __Cont: 
            #line 13422 
    i ++;
  }
  #line 13430 
  if ((n == 0 && veb != (struct i40e_veb *)0) && (unsigned int)veb->uplink_seid != 0U) 
    #line 13431 
    i40e_veb_release(veb);
  #line 13433 
  return 0;
}

#line 13446  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_vsi_setup_vectors(struct i40e_vsi *vsi)
{
  #line 13448 
  int ret = -2;
  #line 13449 
  struct i40e_pf *pf = vsi->back;
  #line 13451 
  if (*(vsi->q_vectors) != (struct i40e_q_vector *)0) {
    #line 13452 
    _dev_info(& (pf->pdev)->dev,(char *)"VSI %d has existing q_vectors\n",(int)vsi->seid);
    #line 13454 
    return -17;
  }
  #line 13457 
  if (vsi->base_vector != 0) {
    #line 13458 
    _dev_info(& (pf->pdev)->dev,(char *)"VSI %d has non-zero base vector %d\n",(int)vsi->seid,vsi->base_vector);
    #line 13460 
    return -17;
  }
  #line 13463 
  ret = i40e_vsi_alloc_q_vectors(vsi);
  #line 13464 
  if (ret != 0) {
    #line 13465 
    _dev_info(& (pf->pdev)->dev,(char *)"failed to allocate %d q_vector for VSI %d, ret=%d\n",vsi->num_q_vectors,(int)vsi->seid,ret);
    #line 13468 
    vsi->num_q_vectors = 0;
    #line 13469 
    goto vector_setup_out;
  }
  #line 13475 
  if (((unsigned long)pf->flags & 4UL) == 0UL) 
                                               #line 13476 
                                               return ret;
  #line 13477 
  if (vsi->num_q_vectors != 0) 
                               #line 13478 
                               vsi->base_vector = i40e_get_lump(pf,pf->irq_pile,(unsigned short)((int)((unsigned short)vsi->num_q_vectors)),(unsigned short)((int)vsi->idx));
  #line 13480 
  if (vsi->base_vector < 0) {
    #line 13481 
    _dev_info(& (pf->pdev)->dev,(char *)"failed to get tracking for %d vectors for VSI %d, err=%d\n",vsi->num_q_vectors,(int)vsi->seid,vsi->base_vector);
    #line 13484 
    i40e_vsi_free_q_vectors(vsi);
    #line 13485 
    ret = -2;
    #line 13486 
    goto vector_setup_out;
  }
  #line 13489 
  vector_setup_out: 
                    #line 13489 
  ;
  #line 13490 
  return ret;
}

#line 13502  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct i40e_vsi *i40e_vsi_reinit_setup(struct i40e_vsi *vsi)
{
  #line 13504 
  u16 alloc_queue_pairs;
  #line 13505 
  struct i40e_pf *pf;
  #line 13506 
  u8 enabled_tc;
  #line 13507 
  int ret;
  #line 13523 
  unsigned int tmp_0;
  #line 13509 
  if (vsi == (struct i40e_vsi *)0) 
                                   #line 13510 
                                   return (struct i40e_vsi *)0;
  #line 13512 
  pf = vsi->back;
  #line 13514 
  i40e_put_lump(pf->qp_pile,(unsigned short)((int)vsi->base_queue),(unsigned short)((int)vsi->idx));
  #line 13515 
  i40e_vsi_clear_rings(vsi);
  #line 13517 
  i40e_vsi_free_arrays(vsi,(_Bool)0);
  #line 13518 
  i40e_set_num_rings_in_vsi(vsi);
  #line 13519 
  ret = i40e_vsi_alloc_arrays(vsi,(_Bool)0);
  #line 13520 
  if (ret != 0) 
                #line 13521 
                goto err_vsi;
  #line 13523 
  if ((int)i40e_enabled_xdp_vsi_0(vsi) != 0) 
                                             #line 13523 
                                             tmp_0 = 2U; else 
                                                              #line 13523 
                                                              tmp_0 = 1U;
  #line 13523 
  alloc_queue_pairs = (unsigned short)((unsigned int)vsi->alloc_queue_pairs * tmp_0);
  #line 13526 
  ret = i40e_get_lump(pf,pf->qp_pile,(unsigned short)((int)alloc_queue_pairs),(unsigned short)((int)vsi->idx));
  #line 13527 
  if (ret < 0) {
    #line 13528 
    _dev_info(& (pf->pdev)->dev,(char *)"failed to get tracking for %d queues for VSI %d err %d\n",(int)alloc_queue_pairs,(int)vsi->seid,ret);
    #line 13531 
    goto err_vsi;
  }
  #line 13533 
  vsi->base_queue = (unsigned short)ret;
  #line 13538 
  enabled_tc = (*(pf->vsi + (unsigned long)pf->lan_vsi))->tc_config.enabled_tc;
  #line 13539 
  (*(pf->vsi + (unsigned long)pf->lan_vsi))->tc_config.enabled_tc = (unsigned char)0U;
  #line 13540 
  (*(pf->vsi + (unsigned long)pf->lan_vsi))->seid = pf->main_vsi_seid;
  #line 13541 
  i40e_vsi_config_tc(*(pf->vsi + (unsigned long)pf->lan_vsi),(unsigned char)((int)enabled_tc));
  #line 13542 
  if (vsi->type == (unsigned int)I40E_VSI_MAIN) 
                                                #line 13543 
                                                i40e_rm_default_mac_filter(vsi,(u8 *)(& pf->hw.mac.perm_addr));
  #line 13546 
  ret = i40e_alloc_rings(vsi);
  #line 13547 
  if (ret != 0) 
                #line 13548 
                goto err_rings;
  #line 13551 
  i40e_vsi_map_rings_to_vectors(vsi);
  #line 13552 
  return vsi;
  #line 13554 
  err_rings: 
             #line 13554 
  ;
  #line 13555 
  i40e_vsi_free_q_vectors(vsi);
  #line 13556 
  if ((int)vsi->netdev_registered != 0) {
    #line 13557 
    vsi->netdev_registered = (_Bool)0;
    #line 13558 
    cif_unregister_netdev(vsi->netdev);
    #line 13559 
    cif_free_netdev(vsi->netdev);
    #line 13560 
    vsi->netdev = (struct net_device *)0;
  }
  #line 13562 
  i40e_aq_delete_element(& pf->hw,(unsigned short)((int)vsi->seid),(struct i40e_asq_cmd_details *)0);
  #line 13563 
  err_vsi: 
           #line 13563 
  ;
  #line 13564 
  i40e_vsi_clear(vsi);
  #line 13565 
  return (struct i40e_vsi *)0;
}

#line 13581  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct i40e_vsi *i40e_vsi_setup(struct i40e_pf *pf, u8 type, u16 uplink_seid, u32 param1)
{
  #line 13586 
  u16 alloc_queue_pairs;
  #line 13587 
  int ret;
  #line 13587 
  int i;
  #line 13588 
  int v_idx;
  #line 13674 
  unsigned int tmp_0;
  #line 13584 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  #line 13585 
  struct i40e_veb *veb = (struct i40e_veb *)0;
  #line 13603 
  i = 0;
  #line 13603 
  while (i <= 15) {
    #line 13604 
    if (pf->veb[i] != (struct i40e_veb *)0 && (int)(pf->veb[i])->seid == (int)uplink_seid) {
      #line 13605 
      veb = pf->veb[i];
      #line 13606 
      break;
    }
    #line 13603 
    i ++;
  }
  #line 13610 
  if (veb == (struct i40e_veb *)0 && (int)pf->mac_seid != (int)uplink_seid) {
    #line 13612 
    i = 0;
    #line 13612 
    while ((int)pf->num_alloc_vsi > i) {
      #line 13613 
      if (*(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + (unsigned long)i))->seid == (int)uplink_seid) {
        #line 13614 
        vsi = *(pf->vsi + (unsigned long)i);
        #line 13615 
        break;
      }
      #line 13612 
      i ++;
    }
    #line 13618 
    if (vsi == (struct i40e_vsi *)0) {
      #line 13619 
      _dev_info(& (pf->pdev)->dev,(char *)"no such uplink_seid %d\n",(int)uplink_seid);
      #line 13621 
      return (struct i40e_vsi *)0;
    }
    #line 13624 
    if ((int)vsi->uplink_seid == (int)pf->mac_seid) 
                                                    #line 13625 
                                                    veb = i40e_veb_setup(pf,(unsigned short)0,(unsigned short)((int)pf->mac_seid),(unsigned short)((int)vsi->seid),(unsigned char)((int)vsi->tc_config.enabled_tc));
    else 
      #line 13627 
      if ((vsi->flags & 2UL) == 0UL) 
                                     #line 13628 
                                     veb = i40e_veb_setup(pf,(unsigned short)0,(unsigned short)((int)vsi->uplink_seid),(unsigned short)((int)vsi->seid),(unsigned char)((int)vsi->tc_config.enabled_tc));
    #line 13630 
    if (veb != (struct i40e_veb *)0) {
      #line 13631 
      if ((int)vsi->seid != (int)(*(pf->vsi + (unsigned long)pf->lan_vsi))->seid) {
        #line 13632 
        _dev_info(& ((vsi->back)->pdev)->dev,(char *)"New VSI creation error, uplink seid of LAN VSI expected.\n");
        #line 13634 
        return (struct i40e_vsi *)0;
      }
      #line 13640 
      if (((unsigned long)pf->flags & 4096UL) == 0UL) {
        #line 13641 
        veb->bridge_mode = (unsigned short)1U;
        #line 13642 
        pf->flags &= 4294963199U;
      }
      #line 13644 
      i40e_config_bridge_mode(veb);
    }
    #line 13646 
    i = 0;
    #line 13646 
    while (i <= 15 && veb == (struct i40e_veb *)0) {
      #line 13647 
      if (pf->veb[i] != (struct i40e_veb *)0 && (int)(pf->veb[i])->seid == (int)vsi->uplink_seid) 
        #line 13648 
        veb = pf->veb[i];
      #line 13646 
      i ++;
    }
    #line 13650 
    if (veb == (struct i40e_veb *)0) {
      #line 13651 
      _dev_info(& (pf->pdev)->dev,(char *)"couldn\'t add VEB\n");
      #line 13652 
      return (struct i40e_vsi *)0;
    }
    #line 13655 
    vsi->flags |= 2UL;
    #line 13656 
    uplink_seid = veb->seid;
  }
  #line 13660 
  v_idx = i40e_vsi_mem_alloc(pf,(enum i40e_vsi_type)type);
  #line 13661 
  if (v_idx < 0) 
                 #line 13662 
                 goto err_alloc;
  #line 13663 
  vsi = *(pf->vsi + (unsigned long)v_idx);
  #line 13664 
  if (vsi == (struct i40e_vsi *)0) 
                                   #line 13665 
                                   goto err_alloc;
  #line 13666 
  vsi->type = (enum i40e_vsi_type)type;
  #line 13667 
  if (veb != (struct i40e_veb *)0) 
                                   #line 13667 
                                   vsi->veb_idx = veb->idx; else 
                                                                 #line 13667 
                                                                 vsi->veb_idx = (unsigned short)65535U;
  #line 13669 
  if ((unsigned int)type == 0U) 
                                #line 13670 
                                pf->lan_vsi = (unsigned short)v_idx;
  else 
    #line 13671 
    if ((unsigned int)type == 6U) 
                                  #line 13672 
                                  vsi->vf_id = (short)param1;
  #line 13674 
  if ((int)i40e_enabled_xdp_vsi_0(vsi) != 0) 
                                             #line 13674 
                                             tmp_0 = 2U; else 
                                                              #line 13674 
                                                              tmp_0 = 1U;
  #line 13674 
  alloc_queue_pairs = (unsigned short)((unsigned int)vsi->alloc_queue_pairs * tmp_0);
  #line 13677 
  ret = i40e_get_lump(pf,pf->qp_pile,(unsigned short)((int)alloc_queue_pairs),(unsigned short)((int)vsi->idx));
  #line 13678 
  if (ret < 0) {
    #line 13679 
    _dev_info(& (pf->pdev)->dev,(char *)"failed to get tracking for %d queues for VSI %d err=%d\n",(int)alloc_queue_pairs,(int)vsi->seid,ret);
    #line 13682 
    goto err_vsi;
  }
  #line 13684 
  vsi->base_queue = (unsigned short)ret;
  #line 13687 
  vsi->uplink_seid = uplink_seid;
  #line 13688 
  ret = i40e_add_vsi(vsi);
  #line 13689 
  if (ret != 0) 
                #line 13690 
                goto err_vsi;
  #line 13692 
  switch ((unsigned int)vsi->type) {
    #line 13694 
    case (unsigned int)0: 
                          #line 13694 
    ;
    #line 13695 
    case (unsigned int)2: 
                          #line 13695 
    ;
    #line 13696 
    ret = i40e_config_netdev(vsi);
    #line 13697 
    if (ret != 0) 
                  #line 13698 
                  goto err_netdev;
    #line 13699 
    ret = cif_register_netdev(vsi->netdev);
    #line 13700 
    if (ret != 0) 
                  #line 13701 
                  goto err_netdev;
    #line 13702 
    vsi->netdev_registered = (_Bool)1;
    #line 13703 
    netif_carrier_off(vsi->netdev);
    #line 13706 
    i40e_dcbnl_setup(vsi);
    #line 13710 
    case (unsigned int)7: 
                          #line 13710 
    ;
    #line 13712 
    ret = i40e_vsi_setup_vectors(vsi);
    #line 13713 
    if (ret != 0) 
                  #line 13714 
                  goto err_msix;
    #line 13716 
    ret = i40e_alloc_rings(vsi);
    #line 13717 
    if (ret != 0) 
                  #line 13718 
                  goto err_rings;
    #line 13721 
    i40e_vsi_map_rings_to_vectors(vsi);
    #line 13723 
    i40e_vsi_reset_stats(vsi);
    #line 13724 
    break;
    #line 13726 
    default: 
             #line 13726 
    ;
    #line 13728 
    break;
  }
  #line 13731 
  if (((unsigned long)pf->hw_features & 1UL) != 0UL && vsi->type == (unsigned int)I40E_VSI_VMDQ2) 
    #line 13733 
    ret = i40e_vsi_config_rss(vsi);
  #line 13735 
  return vsi;
  #line 13737 
  err_rings: 
             #line 13737 
  ;
  #line 13738 
  i40e_vsi_free_q_vectors(vsi);
  #line 13739 
  err_msix: 
            #line 13739 
  ;
  #line 13740 
  if ((int)vsi->netdev_registered != 0) {
    #line 13741 
    vsi->netdev_registered = (_Bool)0;
    #line 13742 
    cif_unregister_netdev(vsi->netdev);
    #line 13743 
    cif_free_netdev(vsi->netdev);
    #line 13744 
    vsi->netdev = (struct net_device *)0;
  }
  #line 13746 
  err_netdev: 
              #line 13746 
  ;
  #line 13747 
  i40e_aq_delete_element(& pf->hw,(unsigned short)((int)vsi->seid),(struct i40e_asq_cmd_details *)0);
  #line 13748 
  err_vsi: 
           #line 13748 
  ;
  #line 13749 
  i40e_vsi_clear(vsi);
  #line 13750 
  err_alloc: 
             #line 13750 
  ;
  #line 13751 
  return (struct i40e_vsi *)0;
}

#line 13760  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_veb_get_bw_info(struct i40e_veb *veb)
{
  #line 13762 
  struct i40e_aqc_query_switching_comp_ets_config_resp ets_data;
  #line 13763 
  struct i40e_aqc_query_switching_comp_bw_config_resp bw_data;
  #line 13766 
  u32 tc_bw_max;
  #line 13768 
  int i;
  #line 13764 
  struct i40e_pf *pf = veb->pf;
  #line 13765 
  struct i40e_hw *hw = & pf->hw;
  #line 13767 
  int ret = 0;
  #line 13770 
  ret = (int)i40e_aq_query_switch_comp_bw_config(hw,
                                          (unsigned short)((int)veb->seid),
                                          & bw_data,
                                          (struct i40e_asq_cmd_details *)0);
  #line 13772 
  if (ret != 0) {
    #line 13773 
    ;
    #line 13773 
    _dev_info(& (pf->pdev)->dev,(char *)"query veb bw config failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,hw->aq.asq_last_status));
    #line 13777 
    goto out;
  }
  #line 13780 
  ret = (int)i40e_aq_query_switch_comp_ets_config(hw,
                                             (unsigned short)((int)veb->seid),
                                             & ets_data,
                                             (struct i40e_asq_cmd_details *)0);
  #line 13782 
  if (ret != 0) {
    #line 13783 
    ;
    #line 13783 
    _dev_info(& (pf->pdev)->dev,(char *)"query veb bw ets config failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,hw->aq.asq_last_status));
    #line 13787 
    goto out;
  }
  #line 13790 
  veb->bw_limit = ets_data.port_bw_limit;
  #line 13791 
  veb->bw_max_quanta = ets_data.tc_bw_max;
  #line 13792 
  veb->is_abs_credits = (_Bool)((unsigned int)bw_data.absolute_credits_enable != 0U);
  #line 13793 
  veb->enabled_tc = ets_data.tc_valid_bits;
  #line 13794 
  tc_bw_max = (unsigned int)((int)bw_data.tc_bw_max[0] | ((int)bw_data.tc_bw_max[1] << 16));
  #line 13796 
  i = 0;
  #line 13796 
  while (i <= 7) {
    #line 13797 
    veb->bw_tc_share_credits[i] = bw_data.tc_bw_share_credits[i];
    #line 13798 
    veb->bw_tc_limit_credits[i] = bw_data.tc_bw_limits[i];
    #line 13800 
    veb->bw_tc_max_quanta[i] = (unsigned char)((unsigned int)((unsigned char)(tc_bw_max >> i * 4)) & 7U);
    #line 13796 
    i ++;
  }
  #line 13803 
  out: 
       #line 13803 
  ;
  #line 13804 
  return ret;
}

#line 13814  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_veb_mem_alloc(struct i40e_pf *pf)
{
  #line 13817 
  struct i40e_veb *veb;
  #line 13818 
  int i;
  #line 13816 
  int ret = -2;
  #line 13821 
  cif_mutex_lock_switch_mutex_of_i40e_pf(& pf->switch_mutex);
  #line 13829 
  i = 0;
  #line 13830 
  while (i <= 15 && pf->veb[i] != (struct i40e_veb *)0) 
                                                        #line 13831 
                                                        i ++;
  #line 13832 
  if (i > 15) {
    #line 13833 
    ret = -12;
    #line 13834 
    goto err_alloc_veb;
  }
  #line 13837 
  veb = (struct i40e_veb *)kzalloc_1(784UL,3264U);
  #line 13838 
  if (veb == (struct i40e_veb *)0) {
    #line 13839 
    ret = -12;
    #line 13840 
    goto err_alloc_veb;
  }
  #line 13842 
  veb->pf = pf;
  #line 13843 
  veb->idx = (unsigned short)i;
  #line 13844 
  veb->enabled_tc = (unsigned char)1U;
  #line 13846 
  pf->veb[i] = veb;
  #line 13847 
  ret = i;
  #line 13848 
  err_alloc_veb: 
                 #line 13848 
  ;
  #line 13849 
  cif_mutex_unlock_switch_mutex_of_i40e_pf(& pf->switch_mutex);
  #line 13850 
  return ret;
}

#line 13860  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_switch_branch_release(struct i40e_veb *branch)
{
  #line 13865 
  int i;
  #line 13862 
  struct i40e_pf *pf = branch->pf;
  #line 13863 
  u16 branch_seid = branch->seid;
  #line 13864 
  u16 veb_idx = branch->idx;
  #line 13868 
  i = 0;
  #line 13868 
  while (i <= 15) {
    #line 13869 
    if (pf->veb[i] == (struct i40e_veb *)0) 
                                            #line 13870 
                                            goto __Cont;
    #line 13871 
    if ((int)(pf->veb[i])->uplink_seid == (int)branch->seid) 
                                                             #line 13872 
                                                             i40e_switch_branch_release(pf->veb[i]);
    #line 13868 
    __Cont: 
            #line 13868 
    i ++;
  }
  #line 13880 
  i = 0;
  #line 13880 
  while ((int)pf->num_alloc_vsi > i) {
    #line 13881 
    if (*(pf->vsi + (unsigned long)i) == (struct i40e_vsi *)0) 
                                                               #line 13882 
                                                               goto __Cont_0;
    #line 13883 
    if ((int)(*(pf->vsi + (unsigned long)i))->uplink_seid == (int)branch_seid && ((*(pf->vsi + (unsigned long)i))->flags & 2UL) == 0UL) 
      #line 13885 
      i40e_vsi_release(*(pf->vsi + (unsigned long)i));
    #line 13880 
    __Cont_0: 
              #line 13880 
    i ++;
  }
  #line 13894 
  if (pf->veb[(int)veb_idx] != (struct i40e_veb *)0) 
                                                     #line 13895 
                                                     i40e_veb_release(pf->veb[(int)veb_idx]);
  #line 13896 
  return;
}

#line 13902  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_veb_clear(struct i40e_veb *veb)
{
  #line 13904 
  if (veb == (struct i40e_veb *)0) 
                                   #line 13905 
                                   return;
  #line 13907 
  if (veb->pf != (struct i40e_pf *)0) {
    #line 13908 
    struct i40e_pf *pf = veb->pf;
    #line 13910 
    cif_mutex_lock_switch_mutex_of_i40e_pf(& pf->switch_mutex);
    #line 13911 
    if (pf->veb[(int)veb->idx] == veb) 
                                       #line 13912 
                                       pf->veb[(int)veb->idx] = (struct i40e_veb *)0;
    #line 13913 
    cif_mutex_unlock_switch_mutex_of_i40e_pf(& pf->switch_mutex);
  }
  #line 13916 
  kfree((void *)veb);
  #line 13917 
  return;
}

#line 13923  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_veb_release(struct i40e_veb *veb)
{
  #line 13926 
  struct i40e_pf *pf;
  #line 13927 
  int i;
  #line 13925 
  struct i40e_vsi *vsi = (struct i40e_vsi *)0;
  #line 13927 
  int n = 0;
  #line 13929 
  pf = veb->pf;
  #line 13932 
  i = 0;
  #line 13932 
  while ((int)pf->num_alloc_vsi > i) {
    #line 13933 
    if (*(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + (unsigned long)i))->uplink_seid == (int)veb->seid) {
      #line 13934 
      n ++;
      #line 13935 
      vsi = *(pf->vsi + (unsigned long)i);
    }
    #line 13932 
    i ++;
  }
  #line 13938 
  if (n != 1) {
    #line 13939 
    _dev_info(& (pf->pdev)->dev,(char *)"can\'t remove VEB %d with %d VSIs left\n",(int)veb->seid,n);
    #line 13942 
    return;
  }
  #line 13946 
  vsi->flags &= 18446744073709551613UL;
  #line 13947 
  if ((unsigned int)veb->uplink_seid != 0U) {
    #line 13948 
    vsi->uplink_seid = veb->uplink_seid;
    #line 13949 
    if ((int)veb->uplink_seid == (int)pf->mac_seid) 
                                                    #line 13950 
                                                    vsi->veb_idx = (unsigned short)65535U; else 
                                                                    #line 13952 
                                                                    vsi->veb_idx = veb->veb_idx;
  }
  else {
    #line 13955 
    vsi->uplink_seid = (*(pf->vsi + (unsigned long)pf->lan_vsi))->uplink_seid;
    #line 13956 
    vsi->veb_idx = (*(pf->vsi + (unsigned long)pf->lan_vsi))->veb_idx;
  }
  #line 13959 
  i40e_aq_delete_element(& pf->hw,(unsigned short)((int)veb->seid),(struct i40e_asq_cmd_details *)0);
  #line 13960 
  i40e_veb_clear(veb);
  #line 13961 
  return;
}

#line 13968  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_add_veb(struct i40e_veb *veb, struct i40e_vsi *vsi)
{
  #line 13972 
  int ret;
  #line 13970 
  struct i40e_pf *pf = veb->pf;
  #line 13971 
  bool enable_stats = (_Bool)(((unsigned long)pf->flags & 8192UL) != 0UL);
  #line 13974 
  ret = (int)i40e_aq_add_veb(& pf->hw,(unsigned short)((int)veb->uplink_seid),
                      (unsigned short)((int)vsi->seid),
                      (unsigned char)((int)veb->enabled_tc),(_Bool)0,
                      & veb->seid,(_Bool)((bool)((int)enable_stats) != 0),
                      (struct i40e_asq_cmd_details *)0);
  #line 13979 
  if (ret != 0) {
    #line 13980 
    ;
    #line 13980 
    _dev_info(& (pf->pdev)->dev,(char *)"couldn\'t add VEB, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 13984 
    return -1;
  }
  #line 13988 
  ret = (int)i40e_aq_get_veb_parameters(& pf->hw,(unsigned short)((int)veb->seid),
                                   (u16 *)0U,(bool *)0,& veb->stats_idx,
                                   (u16 *)0U,(u16 *)0U,
                                   (struct i40e_asq_cmd_details *)0);
  #line 13990 
  if (ret != 0) {
    #line 13991 
    ;
    #line 13991 
    _dev_info(& (pf->pdev)->dev,(char *)"couldn\'t get VEB statistics idx, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 13995 
    return -1;
  }
  #line 13997 
  ret = i40e_veb_get_bw_info(veb);
  #line 13998 
  if (ret != 0) {
    #line 13999 
    ;
    #line 13999 
    _dev_info(& (pf->pdev)->dev,(char *)"couldn\'t get VEB bw info, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 14003 
    i40e_aq_delete_element(& pf->hw,(unsigned short)((int)veb->seid),(struct i40e_asq_cmd_details *)0);
    #line 14004 
    return -2;
  }
  #line 14007 
  vsi->uplink_seid = veb->seid;
  #line 14008 
  vsi->veb_idx = veb->idx;
  #line 14009 
  vsi->flags |= 2UL;
  #line 14011 
  return 0;
}

#line 14030  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
struct i40e_veb *i40e_veb_setup(struct i40e_pf *pf, u16 flags, u16 uplink_seid, u16 vsi_seid, u8 enabled_tc)
{
  #line 14034 
  struct i40e_veb *veb;
  #line 14035 
  int vsi_idx;
  #line 14035 
  int veb_idx;
  #line 14036 
  int ret;
  #line 14034 
  struct i40e_veb *uplink_veb = (struct i40e_veb *)0;
  #line 14039 
  if (((unsigned int)uplink_seid == 0U || (unsigned int)vsi_seid == 0U) && (int)uplink_seid + (int)vsi_seid != 0) {
    #line 14041 
    _dev_info(& (pf->pdev)->dev,(char *)"one, not both seid\'s are 0: uplink=%d vsi=%d\n",(int)uplink_seid,(int)vsi_seid);
    #line 14044 
    return (struct i40e_veb *)0;
  }
  #line 14048 
  vsi_idx = 0;
  #line 14048 
  while ((int)pf->num_alloc_vsi > vsi_idx) {
    #line 14049 
    if (*(pf->vsi + (unsigned long)vsi_idx) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + (unsigned long)vsi_idx))->seid == (int)vsi_seid) 
      #line 14050 
      break;
    #line 14048 
    vsi_idx ++;
  }
  #line 14051 
  if ((int)pf->num_alloc_vsi == vsi_idx && (unsigned int)vsi_seid != 0U) {
    #line 14052 
    _dev_info(& (pf->pdev)->dev,(char *)"vsi seid %d not found\n",(int)vsi_seid);
    #line 14054 
    return (struct i40e_veb *)0;
  }
  #line 14057 
  if ((unsigned int)uplink_seid != 0U && (int)pf->mac_seid != (int)uplink_seid) {
    #line 14058 
    veb_idx = 0;
    #line 14058 
    while (veb_idx <= 15) {
      #line 14059 
      if (pf->veb[veb_idx] != (struct i40e_veb *)0 && (int)(pf->veb[veb_idx])->seid == (int)uplink_seid) {
        #line 14061 
        uplink_veb = pf->veb[veb_idx];
        #line 14062 
        break;
      }
      #line 14058 
      veb_idx ++;
    }
    #line 14065 
    if (uplink_veb == (struct i40e_veb *)0) {
      #line 14066 
      _dev_info(& (pf->pdev)->dev,(char *)"uplink seid %d not found\n",(int)uplink_seid);
      #line 14068 
      return (struct i40e_veb *)0;
    }
  }
  #line 14073 
  veb_idx = i40e_veb_mem_alloc(pf);
  #line 14074 
  if (veb_idx < 0) 
                   #line 14075 
                   goto err_alloc;
  #line 14076 
  veb = pf->veb[veb_idx];
  #line 14077 
  veb->flags = flags;
  #line 14078 
  veb->uplink_seid = uplink_seid;
  #line 14079 
  if (uplink_veb != (struct i40e_veb *)0) 
                                          #line 14079 
                                          veb->veb_idx = uplink_veb->idx; else 
                                                                    #line 14079 
                                                                    veb->veb_idx = (unsigned short)65535U;
  #line 14080 
  if ((unsigned int)enabled_tc != 0U) 
                                      #line 14080 
                                      veb->enabled_tc = enabled_tc; else 
                                                                    #line 14080 
                                                                    veb->enabled_tc = (unsigned char)1U;
  #line 14083 
  ret = i40e_add_veb(veb,*(pf->vsi + (unsigned long)vsi_idx));
  #line 14084 
  if (ret != 0) 
                #line 14085 
                goto err_veb;
  #line 14086 
  if ((int)pf->lan_vsi == vsi_idx) 
                                   #line 14087 
                                   pf->lan_veb = veb->idx;
  #line 14089 
  return veb;
  #line 14091 
  err_veb: 
           #line 14091 
  ;
  #line 14092 
  i40e_veb_clear(veb);
  #line 14093 
  err_alloc: 
             #line 14093 
  ;
  #line 14094 
  return (struct i40e_veb *)0;
}

#line 14106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_setup_pf_switch_element(struct i40e_pf *pf, struct i40e_aqc_switch_config_element_resp *ele, u16 num_reported, bool printconfig)
{
  #line 14110 
  u16 downlink_seid = ele->downlink_seid;
  #line 14111 
  u16 uplink_seid = ele->uplink_seid;
  #line 14112 
  u8 element_type = ele->element_type;
  #line 14113 
  u16 seid = ele->seid;
  #line 14115 
  if ((int)printconfig != 0) 
                             #line 14116 
                             _dev_info(& (pf->pdev)->dev,(char *)"type=%d seid=%d uplink=%d downlink=%d\n",(int)element_type,(int)seid,(int)uplink_seid,(int)downlink_seid);
  #line 14120 
  switch ((int)element_type) {
    #line 14121 
    case 1: 
            #line 14121 
    ;
    #line 14122 
    pf->mac_seid = seid;
    #line 14123 
    break;
    #line 14124 
    case 17: 
             #line 14124 
    ;
    #line 14126 
    if ((int)pf->mac_seid != (int)uplink_seid) 
                                               #line 14127 
                                               break;
    #line 14128 
    if ((unsigned int)pf->lan_veb > 15U) {
      #line 14129 
      int v;
      #line 14132 
      v = 0;
      #line 14132 
      while (v <= 15) {
        #line 14133 
        if (pf->veb[v] != (struct i40e_veb *)0 && (int)(pf->veb[v])->seid == (int)seid) {
          #line 14134 
          pf->lan_veb = (unsigned short)v;
          #line 14135 
          break;
        }
        #line 14132 
        v ++;
      }
      #line 14138 
      if ((unsigned int)pf->lan_veb > 15U) {
        #line 14139 
        v = i40e_veb_mem_alloc(pf);
        #line 14140 
        if (v < 0) 
                   #line 14141 
                   break;
        #line 14142 
        pf->lan_veb = (unsigned short)v;
      }
    }
    #line 14145 
    if ((unsigned int)pf->lan_veb > 15U) 
                                         #line 14146 
                                         break;
    #line 14148 
    (pf->veb[(int)pf->lan_veb])->seid = seid;
    #line 14149 
    (pf->veb[(int)pf->lan_veb])->uplink_seid = pf->mac_seid;
    #line 14150 
    (pf->veb[(int)pf->lan_veb])->pf = pf;
    #line 14151 
    (pf->veb[(int)pf->lan_veb])->veb_idx = (unsigned short)65535U;
    #line 14152 
    break;
    #line 14153 
    case 19: 
             #line 14153 
    ;
    #line 14154 
    if ((unsigned int)num_reported != 1U) 
                                          #line 14155 
                                          break;
    #line 14159 
    pf->mac_seid = uplink_seid;
    #line 14160 
    pf->pf_seid = downlink_seid;
    #line 14161 
    pf->main_vsi_seid = seid;
    #line 14162 
    if ((int)printconfig != 0) 
                               #line 14163 
                               _dev_info(& (pf->pdev)->dev,(char *)"pf_seid=%d main_vsi_seid=%d\n",(int)pf->pf_seid,(int)pf->main_vsi_seid);
    #line 14166 
    break;
    #line 14167 
    case 2: 
            #line 14167 
    ;
    #line 14168 
    case 3: 
            #line 14168 
    ;
    #line 14169 
    case 4: 
            #line 14169 
    ;
    #line 14170 
    case 6: 
            #line 14170 
    ;
    #line 14171 
    case 16: 
             #line 14171 
    ;
    #line 14172 
    case 18: 
             #line 14172 
    ;
    #line 14174 
    break;
    #line 14175 
    default: 
             #line 14175 
    ;
    #line 14176 
    _dev_info(& (pf->pdev)->dev,(char *)"unknown element type=%d seid=%d\n",(int)element_type,(int)seid);
    #line 14178 
    break;
  }
  #line 14180 
  return;
}

#line 14190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
int i40e_fetch_switch_configuration(struct i40e_pf *pf, bool printconfig)
{
  #line 14192 
  struct i40e_aqc_get_switch_config_resp *sw_config;
  #line 14195 
  u8 *aq_buf;
  #line 14196 
  int i;
  #line 14193 
  u16 next_seid = (unsigned short)0U;
  #line 14194 
  int ret = 0;
  #line 14198 
  aq_buf = (u8 *)kzalloc_1(512UL,3264U);
  #line 14199 
  if (aq_buf == (u8 *)0U) 
                          #line 14200 
                          return -12;
  #line 14202 
  sw_config = (struct i40e_aqc_get_switch_config_resp *)aq_buf;
  #line 14203 
  while (1) {
    {
      #line 14204 
      u16 num_reported;
      #line 14204 
      u16 num_total;
      #line 14206 
      ret = (int)i40e_aq_get_switch_config(& pf->hw,sw_config,(unsigned short)512,
                                  & next_seid,
                                  (struct i40e_asq_cmd_details *)0);
      #line 14209 
      if (ret != 0) {
        #line 14210 
        ;
        #line 14210 
        _dev_info(& (pf->pdev)->dev,(char *)"get switch config failed err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
        #line 14215 
        kfree((void *)aq_buf);
        #line 14216 
        return -2;
      }
      #line 14219 
      num_reported = sw_config->header.num_reported;
      #line 14220 
      num_total = sw_config->header.num_total;
      #line 14222 
      if ((int)printconfig != 0) 
                                 #line 14223 
                                 _dev_info(& (pf->pdev)->dev,(char *)"header: %d reported %d total\n",(int)num_reported,(int)num_total);
      #line 14227 
      i = 0;
      #line 14227 
      while ((int)num_reported > i) {
        {
          #line 14228 
          struct i40e_aqc_switch_config_element_resp *ele = & sw_config->element[i];
          #line 14231 
          i40e_setup_pf_switch_element(pf,ele,(unsigned short)((int)num_reported),(_Bool)((bool)((int)printconfig) != 0));
        }
        #line 14227 
        i ++;
      }
    }
    #line 14233 
    if (! ((unsigned int)next_seid != 0U)) 
                                           #line 14203 
                                           break;
  }
  #line 14236 
  kfree((void *)aq_buf);
  #line 14237 
  return ret;
}

#line 14247  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_setup_pf_switch(struct i40e_pf *pf, bool reinit)
{
  #line 14250 
  int ret;
  #line 14249 
  u16 flags = (unsigned short)0U;
  #line 14253 
  ret = i40e_fetch_switch_configuration(pf,(_Bool)0);
  #line 14254 
  if (ret != 0) {
    #line 14255 
    ;
    #line 14255 
    _dev_info(& (pf->pdev)->dev,(char *)"couldn\'t fetch switch config, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 14259 
    return ret;
  }
  #line 14261 
  i40e_pf_reset_stats(pf);
  #line 14269 
  if ((unsigned int)pf->hw.pf_id == 0U && ((unsigned long)pf->flags & 32768UL) == 0UL) {
    #line 14271 
    flags = (unsigned short)1U;
    #line 14272 
    pf->last_sw_conf_flags = flags;
  }
  #line 14275 
  if ((unsigned int)pf->hw.pf_id == 0U) {
    #line 14276 
    u16 valid_flags;
    #line 14278 
    valid_flags = (unsigned short)1U;
    #line 14279 
    ret = (int)i40e_aq_set_switch_config(& pf->hw,(unsigned short)((int)flags),
                                  (unsigned short)((int)valid_flags),
                                  (unsigned char)0,
                                  (struct i40e_asq_cmd_details *)0);
    #line 14281 
    if (ret != 0 && pf->hw.aq.asq_last_status != (unsigned int)I40E_AQ_RC_ESRCH) {
      #line 14282 
      ;
      #line 14282 
      _dev_info(& (pf->pdev)->dev,(char *)"couldn\'t set switch config bits, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    }
    #line 14289 
    pf->last_sw_conf_valid_flags = valid_flags;
  }
  #line 14293 
  if ((unsigned int)pf->lan_vsi == 65535U || (int)reinit != 0) {
    #line 14295 
    u16 uplink_seid;
    #line 14294 
    struct i40e_vsi *vsi = (struct i40e_vsi *)0;
    #line 14300 
    if ((unsigned int)pf->lan_veb <= 15U && pf->veb[(int)pf->lan_veb] != (struct i40e_veb *)0) 
      #line 14301 
      uplink_seid = (pf->veb[(int)pf->lan_veb])->seid; else 
                                                            #line 14303 
                                                            uplink_seid = pf->mac_seid;
    #line 14304 
    if ((unsigned int)pf->lan_vsi == 65535U) 
                                             #line 14305 
                                             vsi = i40e_vsi_setup(pf,(unsigned char)0,(unsigned short)((int)uplink_seid),0U);
    else 
      #line 14306 
      if ((int)reinit != 0) 
                            #line 14307 
                            vsi = i40e_vsi_reinit_setup(*(pf->vsi + (unsigned long)pf->lan_vsi));
    #line 14308 
    if (vsi == (struct i40e_vsi *)0) {
      #line 14309 
      _dev_info(& (pf->pdev)->dev,(char *)"setup of MAIN VSI failed\n");
      #line 14310 
      i40e_cloud_filter_exit(pf);
      #line 14311 
      i40e_fdir_teardown(pf);
      #line 14312 
      return -11;
    }
  }
  else {
    #line 14316 
    u8 enabled_tc = (*(pf->vsi + (unsigned long)pf->lan_vsi))->tc_config.enabled_tc;
    #line 14318 
    (*(pf->vsi + (unsigned long)pf->lan_vsi))->tc_config.enabled_tc = (unsigned char)0U;
    #line 14319 
    (*(pf->vsi + (unsigned long)pf->lan_vsi))->seid = pf->main_vsi_seid;
    #line 14320 
    i40e_vsi_config_tc(*(pf->vsi + (unsigned long)pf->lan_vsi),(unsigned char)((int)enabled_tc));
  }
  #line 14322 
  i40e_vlan_stripping_disable(*(pf->vsi + (unsigned long)pf->lan_vsi));
  #line 14324 
  i40e_fdir_sb_setup(pf);
  #line 14327 
  ret = i40e_setup_pf_filter_control(pf);
  #line 14328 
  if (ret != 0) 
                #line 14329 
                _dev_info(& (pf->pdev)->dev,(char *)"setup_pf_filter_control failed: %d\n",ret);
  #line 14337 
  if (((unsigned long)pf->flags & 8UL) != 0UL) 
                                               #line 14338 
                                               i40e_pf_config_rss(pf);
  #line 14341 
  i40e_link_event(pf);
  #line 14344 
  pf->fc_autoneg_status = (_Bool)(((int)pf->hw.phy.link_info.an_info & 1) != 0);
  #line 14347 
  i40e_ptp_init(pf);
  #line 14350 
  i40e_sync_udp_filters(pf);
  #line 14352 
  return ret;
}

#line 14359  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_determine_queue_usage(struct i40e_pf *pf)
{
  #line 14361 
  int queues_left;
  #line 14362 
  int q_max;
  #line 14364 
  pf->num_lan_qps = (unsigned short)0U;
  #line 14370 
  queues_left = (int)pf->hw.func_caps.num_tx_qp;
  #line 14372 
  if (queues_left == 1 || ((unsigned long)pf->flags & 4UL) == 0UL) {
    #line 14375 
    queues_left = 0;
    #line 14376 
    pf->num_lan_qps = ((unsigned short)1U);
    #line 14376 
    pf->alloc_rss_size = ((unsigned short)1U);
    #line 14379 
    pf->flags &= 4294704135U;
    #line 14387 
    pf->flags |= 4194304U;
  }
  else 
    #line 14388 
    if (((unsigned long)pf->flags & 840UL) == 0UL) {
      #line 14393 
      pf->num_lan_qps = ((unsigned short)1U);
      #line 14393 
      pf->alloc_rss_size = ((unsigned short)1U);
      #line 14394 
      queues_left -= (int)pf->num_lan_qps;
      #line 14396 
      pf->flags &= 4294704231U;
      #line 14402 
      pf->flags |= 4194304U;
    }
    else {
      #line 14413 
      int __UNIQUE_ID___x684;
      #line 14413 
      int tmp_2;
      #line 14414 
      int __UNIQUE_ID___x686;
      #line 14414 
      int tmp_4;
      #line 14415 
      int __UNIQUE_ID___x688;
      #line 14415 
      int tmp_6;
      #line 14405 
      if (((unsigned long)pf->flags & 64UL) != 0UL && queues_left <= 7) {
        #line 14407 
        pf->flags &= 4294967103U;
        #line 14409 
        _dev_info(& (pf->pdev)->dev,(char *)"not enough queues for DCB. DCB is disabled.\n");
      }
      {
        #line 14413 
        __UNIQUE_ID___x684 = (int)pf->rss_size_max;
        #line 14413 
        int __UNIQUE_ID___y685 = (int)num_online_cpus();
        #line 14413 
        if (__UNIQUE_ID___x684 > __UNIQUE_ID___y685) 
                                                     #line 14413 
                                                     tmp_2 = __UNIQUE_ID___x684; else 
                                                                    #line 14413 
                                                                    tmp_2 = __UNIQUE_ID___y685;
        }
      #line 14413 
      q_max = tmp_2;
      {
        #line 14414 
        __UNIQUE_ID___x686 = q_max;
        #line 14414 
        int __UNIQUE_ID___y687 = (int)pf->hw.func_caps.num_tx_qp;
        #line 14414 
        if (__UNIQUE_ID___x686 < __UNIQUE_ID___y687) 
                                                     #line 14414 
                                                     tmp_4 = __UNIQUE_ID___x686; else 
                                                                    #line 14414 
                                                                    tmp_4 = __UNIQUE_ID___y687;
        }
      #line 14414 
      q_max = tmp_4;
      {
        #line 14415 
        __UNIQUE_ID___x688 = q_max;
        #line 14415 
        int __UNIQUE_ID___y689 = (int)pf->hw.func_caps.num_msix_vectors;
        #line 14415 
        if (__UNIQUE_ID___x688 < __UNIQUE_ID___y689) 
                                                     #line 14415 
                                                     tmp_6 = __UNIQUE_ID___x688; else 
                                                                    #line 14415 
                                                                    tmp_6 = __UNIQUE_ID___y689;
        }
      #line 14415 
      q_max = tmp_6;
      #line 14416 
      pf->num_lan_qps = (unsigned short)q_max;
      #line 14418 
      queues_left -= (int)pf->num_lan_qps;
    }
  #line 14421 
  if (((unsigned long)pf->flags & 256UL) != 0UL) 
    #line 14422 
    if (queues_left > 1) 
                         #line 14423 
                         queues_left += -1;
    else {
      #line 14425 
      pf->flags &= 4294967039U;
      #line 14426 
      pf->flags |= 4194304U;
      #line 14427 
      _dev_info(& (pf->pdev)->dev,(char *)"not enough queues for Flow Director. Flow Director feature is disabled\n");
    }
  #line 14431 
  if (((((unsigned long)pf->flags & 32UL) != 0UL && (unsigned int)pf->num_vf_qps != 0U) && (unsigned int)pf->num_req_vfs != 0U) && queues_left != 0) {
    #line 14433 
    int tmp_8;
    #line 14433 
    int __UNIQUE_ID___x690;
    {
      #line 14433 
      __UNIQUE_ID___x690 = (int)pf->num_req_vfs;
      #line 14433 
      int __UNIQUE_ID___y691 = queues_left / (int)pf->num_vf_qps;
      #line 14433 
      if (__UNIQUE_ID___x690 < __UNIQUE_ID___y691) 
                                                   #line 14433 
                                                   tmp_8 = __UNIQUE_ID___x690; else 
                                                                    #line 14433 
                                                                    tmp_8 = __UNIQUE_ID___y691;
      }
    #line 14433 
    pf->num_req_vfs = (unsigned short)tmp_8;
    #line 14435 
    queues_left -= (int)pf->num_req_vfs * (int)pf->num_vf_qps;
  }
  #line 14438 
  if (((((unsigned long)pf->flags & 16UL) != 0UL && (unsigned int)pf->num_vmdq_vsis != 0U) && (unsigned int)pf->num_vmdq_qps != 0U) && queues_left != 0) {
    #line 14440 
    int __UNIQUE_ID___x692;
    #line 14440 
    int tmp_10;
    {
      #line 14440 
      __UNIQUE_ID___x692 = (int)pf->num_vmdq_vsis;
      #line 14440 
      int __UNIQUE_ID___y693 = queues_left / (int)pf->num_vmdq_qps;
      #line 14440 
      if (__UNIQUE_ID___x692 < __UNIQUE_ID___y693) 
                                                   #line 14440 
                                                   tmp_10 = __UNIQUE_ID___x692; else 
                                                                    #line 14440 
                                                                    tmp_10 = __UNIQUE_ID___y693;
      }
    #line 14440 
    pf->num_vmdq_vsis = (unsigned short)tmp_10;
    #line 14442 
    queues_left -= (int)pf->num_vmdq_vsis * (int)pf->num_vmdq_qps;
  }
  #line 14445 
  pf->queues_left = queues_left;
  {
    #line 14446 
    bool branch;
    #line 14446 
    struct _ddebug __UNIQUE_ID_ddebug694 = {.modname = (char *)"i40e", .function = (char *)"i40e_determine_queue_usage", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"qs_avail=%d FD SB=%d lan_qs=%d lan_tc0=%d vf=%d*%d vmdq=%d*%d, remaining=%d\n", .lineno = (unsigned int)14446U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 14446 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug694.key.dd_key_false.key,(_Bool)0);
    #line 14446 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 14446 
                                                __dynamic_dev_dbg(& __UNIQUE_ID_ddebug694,& (pf->pdev)->dev,(char *)"qs_avail=%d FD SB=%d lan_qs=%d lan_tc0=%d vf=%d*%d vmdq=%d*%d, remaining=%d\n",pf->hw.func_caps.num_tx_qp,((unsigned long)pf->flags & 256UL) != 0UL,(int)pf->num_lan_qps,(int)pf->alloc_rss_size,(int)pf->num_req_vfs,(int)pf->num_vf_qps,(int)pf->num_vmdq_vsis,(int)pf->num_vmdq_qps,queues_left);
  }
  #line 14448 
  return;
}

#line 14466  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_setup_pf_filter_control(struct i40e_pf *pf)
{
  #line 14468 
  struct i40e_filter_control_settings *settings = & pf->filter_settings;
  #line 14470 
  settings->hash_lut_size = I40E_HASH_LUT_SIZE_128;
  #line 14473 
  if (((unsigned long)pf->flags & 768UL) != 0UL) 
                                                 #line 14474 
                                                 settings->enable_fdir = (_Bool)1;
  #line 14477 
  settings->enable_ethtype = (_Bool)1;
  #line 14478 
  settings->enable_macvlan = (_Bool)1;
  #line 14480 
  if (i40e_set_filter_control(& pf->hw,settings) != I40E_SUCCESS) 
                                                                  #line 14481 
                                                                  return -2;
  #line 14483 
  return 0;
}

#line 14488  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_print_features(struct i40e_pf *pf)
{
  #line 14491 
  char *buf;
  #line 14492 
  int i;
  #line 14490 
  struct i40e_hw *hw = & pf->hw;
  #line 14494 
  buf = (char *)kmalloc(255UL,3264U);
  #line 14495 
  if (buf == (char *)0) 
                        #line 14496 
                        return;
  #line 14498 
  i = snprintf(buf,255UL,(char *)"Features: PF-id[%d]",(int)hw->pf_id);
  #line 14500 
  i = snprintf(buf + (unsigned long)i,(unsigned long)(255 - i),
                 (char *)" VFs: %d",(int)pf->num_req_vfs) + i;
  #line 14504 
  i = snprintf(buf + (unsigned long)i,(unsigned long)(255 - i),
                 (char *)" VSIs: %d QP: %d",pf->hw.func_caps.num_vsis,
                 (int)(*(pf->vsi + (unsigned long)pf->lan_vsi))->num_queue_pairs) + i;
  #line 14505 
  if (((unsigned long)pf->flags & 8UL) != 0UL) {
    #line 14506 
    i = snprintf(buf + (unsigned long)i,(unsigned long)(255 - i),
                 (char *)" RSS") + i;
  }
  #line 14507 
  if (((unsigned long)pf->flags & 512UL) != 0UL) {
    #line 14508 
    i = snprintf(buf + (unsigned long)i,(unsigned long)(255 - i),
                 (char *)" FD_ATR") + i;
  }
  #line 14509 
  if (((unsigned long)pf->flags & 256UL) != 0UL) {
    #line 14510 
    i = snprintf(buf + (unsigned long)i,(unsigned long)(255 - i),
                 (char *)" FD_SB") + i;
    #line 14511 
    i = snprintf(buf + (unsigned long)i,(unsigned long)(255 - i),
                 (char *)" NTUPLE") + i;
  }
  #line 14513 
  if (((unsigned long)pf->flags & 64UL) != 0UL) {
    #line 14514 
    i = snprintf(buf + (unsigned long)i,(unsigned long)(255 - i),
                 (char *)" DCB") + i;
  }
  #line 14515 
  i = snprintf(buf + (unsigned long)i,(unsigned long)(255 - i),
                 (char *)" VxLAN") + i;
  #line 14516 
  i = snprintf(buf + (unsigned long)i,(unsigned long)(255 - i),
                 (char *)" Geneve") + i;
  #line 14517 
  if (((unsigned long)pf->flags & 131072UL) != 0UL) {
    #line 14518 
    i = snprintf(buf + (unsigned long)i,(unsigned long)(255 - i),
                 (char *)" PTP") + i;
  }
  #line 14519 
  if (((unsigned long)pf->flags & 4096UL) != 0UL) {
    #line 14520 
    i = snprintf(buf + (unsigned long)i,(unsigned long)(255 - i),
                  (char *)" VEB") + i;
  }
  else {
    #line 14522 
    i = snprintf(buf + (unsigned long)i,(unsigned long)(255 - i),
                  (char *)" VEPA") + i;
  }
  #line 14524 
  _dev_info(& (pf->pdev)->dev,(char *)"%s\n",buf);
  #line 14525 
  kfree((void *)buf);
  {
    #line 14526 
    int __ret_warn_on = i > 255;
    #line 14526 
    if ((long)(__ret_warn_on != 0) != 0L) {
      #line 14527 
      ldv_inline_asm();
      #line 14528 
      ldv_inline_asm();
    }
    #line 14526 
    long tmp_12 = (long)(__ret_warn_on != 0);
  }
  #line 14528 
  return;
}

#line 14539  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_get_platform_mac_addr(struct pci_dev *pdev, struct i40e_pf *pf)
{
  #line 14541 
  if (eth_platform_get_mac_address(& pdev->dev,(u8 *)(& pf->hw.mac.addr)) != 0) 
    #line 14542 
    i40e_get_mac_addr(& pf->hw,(u8 *)(& pf->hw.mac.addr));
  #line 14543 
  return;
}

#line 14550  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
void i40e_set_fec_in_flags(u8 fec_cfg, u32 *flags)
{
  #line 14552 
  if (((unsigned long)fec_cfg & 16UL) != 0UL) 
                                              #line 14553 
                                              *flags |= 100663296U;
  #line 14554 
  if (((unsigned long)fec_cfg & 8UL) != 0UL || ((unsigned long)fec_cfg & 2UL) != 0UL) {
    #line 14556 
    *flags |= 33554432U;
    #line 14557 
    *flags &= 4227858431U;
  }
  #line 14559 
  if (((unsigned long)fec_cfg & 4UL) != 0UL || ((unsigned long)fec_cfg & 1UL) != 0UL) {
    #line 14561 
    *flags |= 67108864U;
    #line 14562 
    *flags &= 4261412863U;
  }
  #line 14564 
  if ((unsigned int)fec_cfg == 0U) 
                                   #line 14565 
                                   *flags &= 4194303999U;
  #line 14566 
  return;
}

#line 14577  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static bool i40e_check_recovery_mode(struct i40e_pf *pf)
{
  #line 14579 
  u32 val = readl((void *)(pf->hw.hw_addr + 536648U)) & 16711680U;
  #line 14580 
  bool is_recovery_mode = (_Bool)0;
  #line 14582 
  if (pf->hw.mac.type == (unsigned int)I40E_MAC_XL710) 
                                                       #line 14583 
                                                       is_recovery_mode = (_Bool)(((val == 3145728U || val == 3211264U) || (val == 3276800U || val == 3342336U)) != 0);
  #line 14588 
  if (pf->hw.mac.type == (unsigned int)I40E_MAC_X722) 
                                                      #line 14589 
                                                      is_recovery_mode = (_Bool)((val == 720896U || val == 786432U) != 0);
  #line 14592 
  if ((int)is_recovery_mode != 0) {
    #line 14593 
    _dev_notice(& (pf->pdev)->dev,(char *)"Firmware recovery mode detected. Limiting functionality.\n");
    #line 14594 
    _dev_notice(& (pf->pdev)->dev,(char *)"Refer to the Intel(R) Ethernet Adapters and Devices User Guide for details on firmware recovery mode.\n");
    #line 14595 
    cif_set_bit_1(34L,(unsigned long *)(& pf->state));
    #line 14597 
    return (_Bool)1;
  }
  #line 14599 
  if ((int)test_and_set_bit(34L,(unsigned long *)(& pf->state)) != 0) 
    #line 14600 
    _dev_info(& (pf->pdev)->dev,(char *)"Reinitializing in normal mode with full functionality.\n");
  #line 14602 
  return (_Bool)0;
}

#line 14626  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static i40e_status i40e_pf_loop_reset(struct i40e_pf *pf)
{
  #line 14631 
  i40e_status ret;
  #line 14632 
  int cnt;
  #line 14628 
  unsigned short MAX_CNT = (unsigned short)1000U;
  #line 14629 
  unsigned short MSECS = (unsigned short)10U;
  #line 14630 
  struct i40e_hw *hw = & pf->hw;
  #line 14634 
  cnt = 0;
  #line 14634 
  while (cnt <= 999) {
    #line 14635 
    ret = i40e_pf_reset(hw);
    #line 14636 
    if (ret == I40E_SUCCESS) 
                             #line 14637 
                             break;
    #line 14638 
    msleep(10U);
    #line 14634 
    cnt ++;
  }
  #line 14641 
  if (cnt == 1000) {
    #line 14642 
    _dev_info(& (pf->pdev)->dev,(char *)"PF reset failed: %d\n",(int)ret);
    #line 14643 
    return ret;
  }
  #line 14646 
  pf->pfr_count = (u16)((int)pf->pfr_count + 1);
  #line 14647 
  return ret;
}

#line 14660  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_init_recovery_mode(struct i40e_pf *pf, struct i40e_hw *hw)
{
  #line 14662 
  struct i40e_vsi *vsi;
  #line 14663 
  int err;
  #line 14664 
  int v_idx;
  #line 14666 
  pci_save_state(pf->pdev);
  {
    #line 14669 
    struct lock_class_key __key;
    #line 14669 
    init_timer_key(& pf->service_timer,& i40e_service_timer,0U,(char *)"(&pf->service_timer)",& __key);
  }
  #line 14670 
  pf->service_timer_period = 250UL;
  {
    #line 14672 
    struct lock_class_key __key_0;
    #line 14672 
    __init_work(& pf->service_task,0);
    #line 14672 
    atomic_long_t __constr_expr_45 = {.counter = 137438953408LL};
    #line 14672 
    pf->service_task.data = __constr_expr_45;
    #line 14672 
    lockdep_init_map(& pf->service_task.lockdep_map,(char *)"(work_completion)",& __key_0,0);
    #line 14672 
    INIT_LIST_HEAD(& pf->service_task.entry);
    #line 14672 
    pf->service_task.func = & i40e_service_task;
  }
  #line 14673 
  cif_clear_bit_1(4L,(unsigned long *)(& pf->state));
  #line 14675 
  err = i40e_init_interrupt_scheme(pf);
  #line 14676 
  if (err != 0) 
                #line 14677 
                goto err_switch_setup;
  #line 14684 
  if (pf->hw.func_caps.num_vsis <= 82U) 
                                        #line 14685 
                                        pf->num_alloc_vsi = (unsigned short)83U; else 
                                                                    #line 14687 
                                                                    pf->num_alloc_vsi = (unsigned short)pf->hw.func_caps.num_vsis;
  #line 14690 
  pf->vsi = (struct i40e_vsi **)kcalloc_0((unsigned long)pf->num_alloc_vsi,8UL,3264U);
  #line 14692 
  if (pf->vsi == (struct i40e_vsi **)0) {
    #line 14693 
    err = -12;
    #line 14694 
    goto err_switch_setup;
  }
  #line 14700 
  v_idx = i40e_vsi_mem_alloc(pf,(enum i40e_vsi_type)I40E_VSI_MAIN);
  #line 14701 
  if (v_idx < 0) 
                 #line 14702 
                 goto err_switch_setup;
  #line 14703 
  pf->lan_vsi = (unsigned short)v_idx;
  #line 14704 
  vsi = *(pf->vsi + (unsigned long)v_idx);
  #line 14705 
  if (vsi == (struct i40e_vsi *)0) 
                                   #line 14706 
                                   goto err_switch_setup;
  #line 14707 
  vsi->alloc_queue_pairs = (unsigned short)1U;
  #line 14708 
  err = i40e_config_netdev(vsi);
  #line 14709 
  if (err != 0) 
                #line 14710 
                goto err_switch_setup;
  #line 14711 
  err = cif_register_netdev(vsi->netdev);
  #line 14712 
  if (err != 0) 
                #line 14713 
                goto err_switch_setup;
  #line 14714 
  vsi->netdev_registered = (_Bool)1;
  #line 14715 
  i40e_dbg_pf_init(pf);
  #line 14717 
  err = i40e_setup_misc_vector_for_recovery_mode(pf);
  #line 14718 
  if (err != 0) 
                #line 14719 
                goto err_switch_setup;
  #line 14722 
  i40e_send_version(pf);
  #line 14725 
  ;
  #line 14725 
  cif_mod_timer(& pf->service_timer,round_jiffies(pf->service_timer_period + jiffies));
  #line 14728 
  return 0;
  #line 14730 
  err_switch_setup: 
                    #line 14730 
  ;
  #line 14731 
  i40e_reset_interrupt_capability(pf);
  #line 14732 
  cif_del_timer_sync(& pf->service_timer);
  #line 14733 
  i40e_shutdown_adminq(hw);
  #line 14734 
  iounmap((void *)hw->hw_addr);
  #line 14735 
  pci_disable_pcie_error_reporting(pf->pdev);
  #line 14736 
  pci_release_mem_regions(pf->pdev);
  #line 14737 
  pci_disable_device(pf->pdev);
  #line 14738 
  kfree((void *)pf);
  #line 14740 
  return err;
}

#line 14754  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_probe(struct pci_dev *pdev, struct pci_device_id *ent)
{
  #line 14810 
  int __UNIQUE_ID___x696;
  #line 14810 
  int tmp_1;
  #line 14756 
  struct i40e_aq_get_phy_abilities_resp abilities;
  #line 14757 
  struct i40e_pf *pf;
  #line 14758 
  struct i40e_hw *hw;
  #line 14759 
  u16 pfs_found;
  #line 14760 
  u16 wol_nvm_bits;
  #line 14761 
  u16 link_status;
  #line 14762 
  int err;
  #line 14763 
  u32 val;
  #line 14764 
  u32 i;
  #line 14765 
  u8 set_fc_aq_fail;
  #line 15015 
  char *tmp_18;
  #line 14767 
  err = pci_enable_device_mem(pdev);
  #line 14768 
  if (err != 0) 
                #line 14769 
                return err;
  #line 14772 
  err = dma_set_mask_and_coherent(& pdev->dev,18446744073709551615ULL);
  #line 14773 
  if (err != 0) {
    #line 14774 
    err = dma_set_mask_and_coherent(& pdev->dev,4294967295ULL);
    #line 14775 
    if (err != 0) {
      #line 14776 
      _dev_err(& pdev->dev,(char *)"DMA configuration failed: 0x%x\n",err);
      #line 14778 
      goto err_dma;
    }
  }
  #line 14783 
  err = pci_request_mem_regions(pdev,(char *)(& i40e_driver_name));
  #line 14784 
  if (err != 0) {
    #line 14785 
    _dev_info(& pdev->dev,(char *)"pci_request_selected_regions failed %d\n",err);
    #line 14787 
    goto err_pci_reg;
  }
  #line 14790 
  pci_enable_pcie_error_reporting(pdev);
  #line 14791 
  pci_set_master(pdev);
  #line 14798 
  pf = (struct i40e_pf *)kzalloc_1(4888UL,3264U);
  #line 14799 
  if (pf == (struct i40e_pf *)0) {
    #line 14800 
    err = -12;
    #line 14801 
    goto err_pf_alloc;
  }
  #line 14803 
  pf->next_vsi = (unsigned short)0U;
  #line 14804 
  pf->pdev = pdev;
  #line 14805 
  cif_set_bit_1(3L,(unsigned long *)(& pf->state));
  #line 14807 
  hw = & pf->hw;
  #line 14808 
  hw->back = (void *)pf;
  {
    #line 14810 
    int tmp_0;
    #line 14810 
    if (pdev->resource[0].start != 0ULL || pdev->resource[0].end != pdev->resource[0].start) 
      #line 14810 
      tmp_0 = (int)((pdev->resource[0].end - pdev->resource[0].start) + 1ULL); else 
                                                                    #line 14810 
                                                                    tmp_0 = 0;
    #line 14810 
    __UNIQUE_ID___x696 = tmp_0;
    #line 14810 
    int __UNIQUE_ID___y697 = 4128768;
    #line 14810 
    if (__UNIQUE_ID___x696 < __UNIQUE_ID___y697) 
                                                 #line 14810 
                                                 tmp_1 = __UNIQUE_ID___x696; else 
                                                                    #line 14810 
                                                                    tmp_1 = __UNIQUE_ID___y697;
    }
  #line 14810 
  pf->ioremap_len = (unsigned int)tmp_1;
  #line 14817 
  if (pf->ioremap_len <= 3735555U) {
    #line 14818 
    _dev_err(& pdev->dev,(char *)"Cannot map registers, bar size 0x%X too small, aborting\n",pf->ioremap_len);
    #line 14820 
    err = -12;
    #line 14821 
    goto err_ioremap;
  }
  #line 14823 
  hw->hw_addr = (u8 *)ioremap(pdev->resource[0].start,(unsigned long)pf->ioremap_len);
  #line 14824 
  if (hw->hw_addr == (u8 *)0U) {
    #line 14825 
    err = -5;
    #line 14826 
    _dev_info(& pdev->dev,(char *)"ioremap(0x%04x, 0x%04x) failed: 0x%x\n",(unsigned int)pdev->resource[0].start,pf->ioremap_len,err);
    #line 14829 
    goto err_ioremap;
  }
  #line 14831 
  hw->vendor_id = pdev->vendor;
  #line 14832 
  hw->device_id = pdev->device;
  #line 14833 
  pci_read_config_byte(pdev,8,& hw->revision_id);
  #line 14834 
  hw->subsystem_vendor_id = pdev->subsystem_vendor;
  #line 14835 
  hw->subsystem_device_id = pdev->subsystem_device;
  #line 14836 
  hw->bus.device = (unsigned short)((unsigned int)((unsigned short)(pdev->devfn >> 3)) & 31U);
  #line 14837 
  hw->bus.func = (unsigned short)((unsigned int)((unsigned short)pdev->devfn) & 7U);
  #line 14838 
  hw->bus.bus_id = (unsigned short)(pdev->bus)->number;
  #line 14839 
  pf->instance = pfs_found;
  #line 14844 
  hw->switch_tag = (unsigned short)65535U;
  #line 14845 
  hw->first_tag = (unsigned short)34984U;
  #line 14846 
  hw->second_tag = (unsigned short)33024U;
  #line 14848 
  INIT_LIST_HEAD(& pf->l3_flex_pit_list);
  #line 14849 
  INIT_LIST_HEAD(& pf->l4_flex_pit_list);
  #line 14850 
  INIT_LIST_HEAD(& pf->ddp_old_prof);
  {
    #line 14855 
    struct lock_class_key __key;
    #line 14855 
    __mutex_init(& hw->aq.asq_mutex,(char *)"&hw->aq.asq_mutex",& __key);
  }
  {
    #line 14856 
    struct lock_class_key __key_0;
    #line 14856 
    __mutex_init(& hw->aq.arq_mutex,(char *)"&hw->aq.arq_mutex",& __key_0);
  }
  #line 14858 
  pf->msg_enable = netif_msg_init(debug,7);
  #line 14862 
  if (debug < -1) 
                  #line 14863 
                  pf->hw.debug_mask = (unsigned int)debug;
  #line 14866 
  if ((unsigned int)hw->revision_id == 0U) {
    #line 14866 
    if ((readl((void *)(hw->hw_addr + 1221888U)) & 1U) != 0U) {
      #line 14868 
      writel(1U,(void *)(hw->hw_addr + 754064U));
      #line 14869 
      readl((void *)(hw->hw_addr + 745772U));
      #line 14870 
      msleep(200U);
      #line 14871 
      pf->corer_count = (u16)((int)pf->corer_count + 1);
      #line 14873 
      i40e_clear_pxe_mode(hw);
    }
  }
  #line 14877 
  i40e_clear_hw(hw);
  #line 14879 
  err = (int)i40e_set_mac_type(hw);
  #line 14880 
  if (err != 0) {
    #line 14881 
    _dev_warn(& pdev->dev,(char *)"unidentified MAC or BLANK NVM: %d\n",err);
    #line 14883 
    goto err_pf_reset;
  }
  #line 14886 
  err = (int)i40e_pf_loop_reset(pf);
  #line 14887 
  if (err != 0) {
    #line 14888 
    _dev_info(& pdev->dev,(char *)"Initial pf_reset failed: %d\n",err);
    #line 14889 
    goto err_pf_reset;
  }
  #line 14892 
  i40e_check_recovery_mode(pf);
  #line 14894 
  hw->aq.num_arq_entries = (unsigned short)256U;
  #line 14895 
  hw->aq.num_asq_entries = (unsigned short)256U;
  #line 14896 
  hw->aq.arq_buf_size = (unsigned short)4096U;
  #line 14897 
  hw->aq.asq_buf_size = (unsigned short)4096U;
  #line 14898 
  pf->adminq_work_limit = (unsigned short)66U;
  #line 14900 
  ;
  #line 14900 
  snprintf((char *)(& pf->int_name),31UL,(char *)"%s-%s:misc",dev_driver_string(& (pf->pdev)->dev),dev_name(& pdev->dev));
  #line 14904 
  err = (int)i40e_init_shared_code(hw);
  #line 14905 
  if (err != 0) {
    #line 14906 
    _dev_warn(& pdev->dev,(char *)"unidentified MAC or BLANK NVM: %d\n",err);
    #line 14908 
    goto err_pf_reset;
  }
  #line 14912 
  pf->hw.fc.requested_mode = I40E_FC_NONE;
  #line 14914 
  err = (int)i40e_init_adminq(hw);
  #line 14915 
  if (err != 0) {
    #line 14916 
    if (err == -65) 
                    #line 14917 
                    _dev_info(& pdev->dev,(char *)"The driver for the device stopped because the NVM image v%u.%u is newer than expected v%u.%u. You must install the most recent version of the network driver.\n",(int)hw->aq.api_maj_ver,(int)hw->aq.api_min_ver,1,9); else 
                                                                    #line 14924 
                                                                    _dev_info(& pdev->dev,(char *)"The driver for the device stopped because the device firmware failed to init. Try updating your NVM image.\n");
    #line 14927 
    goto err_pf_reset;
  }
  #line 14929 
  i40e_get_oem_version(hw);
  #line 14932 
  ;
  #line 14932 
  ;
  #line 14932 
  ;
  #line 14932 
  ;
  #line 14932 
  ;
  #line 14932 
  ;
  #line 14932 
  ;
  #line 14932 
  ;
  #line 14932 
  ;
  #line 14932 
  ;
  #line 14932 
  _dev_info(& pdev->dev,(char *)"fw %d.%d.%05d api %d.%d nvm %s [%04x:%04x] [%04x:%04x]\n",(int)hw->aq.fw_maj_ver,(int)hw->aq.fw_min_ver,hw->aq.fw_build,(int)hw->aq.api_maj_ver,(int)hw->aq.api_min_ver,i40e_nvm_version_str(hw),(int)hw->vendor_id,(int)hw->device_id,(int)hw->subsystem_vendor_id,(int)hw->subsystem_device_id);
  #line 14938 
  if ((unsigned int)hw->aq.api_maj_ver == 1U && (unsigned int)hw->aq.api_min_ver > 9U) 
    #line 14940 
    _dev_info(& pdev->dev,(char *)"The driver for the device detected a newer version of the NVM image v%u.%u than expected v%u.%u. Please install the most recent version of the network driver.\n",(int)hw->aq.api_maj_ver,(int)hw->aq.api_min_ver,1,9);
  else 
    #line 14946 
    if ((unsigned int)hw->aq.api_maj_ver == 1U && (unsigned int)hw->aq.api_min_ver <= 3U) 
      #line 14947 
      _dev_info(& pdev->dev,(char *)"The driver for the device detected an older version of the NVM image v%u.%u than expected v%u.%u. Please update the NVM image.\n",(int)hw->aq.api_maj_ver,(int)hw->aq.api_min_ver,1,9);
  #line 14954 
  i40e_verify_eeprom(pf);
  #line 14957 
  if ((unsigned int)hw->revision_id == 0U) 
                                           #line 14958 
                                           _dev_warn(& pdev->dev,(char *)"This device is a pre-production adapter/LOM. Please be aware there may be issues with your hardware. If you are experiencing problems please contact your Intel or hardware representative who provided you with this hardware.\n");
  #line 14960 
  i40e_clear_pxe_mode(hw);
  #line 14962 
  err = i40e_get_capabilities(pf,(enum i40e_admin_queue_opc)i40e_aqc_opc_list_func_capabilities);
  #line 14963 
  if (err != 0) 
                #line 14964 
                goto err_adminq_setup;
  #line 14966 
  err = i40e_sw_init(pf);
  #line 14967 
  if (err != 0) {
    #line 14968 
    _dev_info(& pdev->dev,(char *)"sw_init failed: %d\n",err);
    #line 14969 
    goto err_sw_init;
  }
  #line 14972 
  if ((int)test_bit(34L,(unsigned long *)(& pf->state)) != 0) {
    #line 14973 
    return i40e_init_recovery_mode(pf,hw);
  }
  #line 14975 
  err = (int)i40e_init_lan_hmc(hw,hw->func_caps.num_tx_qp,
                           hw->func_caps.num_rx_qp,0U,0U);
  #line 14977 
  if (err != 0) {
    #line 14978 
    _dev_info(& pdev->dev,(char *)"init_lan_hmc failed: %d\n",err);
    #line 14979 
    goto err_init_lan_hmc;
  }
  #line 14982 
  err = (int)i40e_configure_lan_hmc(hw,
                                (enum i40e_hmc_model)I40E_HMC_MODEL_DIRECT_ONLY);
  #line 14983 
  if (err != 0) {
    #line 14984 
    _dev_info(& pdev->dev,(char *)"configure_lan_hmc failed: %d\n",err);
    #line 14985 
    err = -2;
    #line 14986 
    goto err_configure_lan_hmc;
  }
  #line 14993 
  if (((unsigned long)pf->hw_features & 65536UL) != 0UL) {
    #line 14994 
    _dev_info(& pdev->dev,(char *)"Stopping firmware LLDP agent.\n");
    #line 14995 
    i40e_aq_stop_lldp(hw,(_Bool)1,(_Bool)0,(struct i40e_asq_cmd_details *)0);
  }
  #line 14999 
  i40e_get_platform_mac_addr(pdev,pf);
  #line 15001 
  if (! is_valid_ether_addr((u8 *)(& hw->mac.addr))) {
    #line 15002 
    _dev_info(& pdev->dev,(char *)"invalid MAC address %pM\n",(u8 *)(& hw->mac.addr));
    #line 15003 
    err = -5;
    #line 15004 
    goto err_mac_addr;
  }
  #line 15006 
  _dev_info(& pdev->dev,(char *)"MAC address: %pM\n",(u8 *)(& hw->mac.addr));
  #line 15007 
  ether_addr_copy((u8 *)(& hw->mac.perm_addr),(u8 *)(& hw->mac.addr));
  #line 15008 
  i40e_get_port_mac_addr(hw,(u8 *)(& hw->mac.port_addr));
  #line 15009 
  if ((int)is_valid_ether_addr((u8 *)(& hw->mac.port_addr)) != 0) 
                                                                  #line 15010 
                                                                  pf->hw_features |= 131072U;
  #line 15012 
  pci_set_drvdata(pdev,(void *)pf);
  #line 15013 
  pci_save_state(pdev);
  #line 15015 
  if (((unsigned long)pf->flags & 16777216UL) != 0UL) 
                                                      #line 15015 
                                                      tmp_18 = (char *)"FW LLDP is disabled\n"; else 
                                                                    #line 15015 
                                                                    tmp_18 = (char *)"FW LLDP is enabled\n";
  #line 15015 
  ;
  #line 15015 
  _dev_info(& pdev->dev,tmp_18);
  #line 15021 
  i40e_aq_set_dcb_parameters(hw,(_Bool)1,(struct i40e_asq_cmd_details *)0);
  #line 15024 
  err = i40e_init_pf_dcb(pf);
  #line 15025 
  if (err != 0) {
    #line 15026 
    _dev_info(& pdev->dev,(char *)"DCB init failed %d, disabled\n",err);
    #line 15027 
    pf->flags &= 4294967103U;
  }
  {
    #line 15033 
    struct lock_class_key __key_1;
    #line 15033 
    init_timer_key(& pf->service_timer,& i40e_service_timer,0U,(char *)"(&pf->service_timer)",& __key_1);
  }
  #line 15034 
  pf->service_timer_period = 250UL;
  {
    #line 15036 
    struct lock_class_key __key_2;
    #line 15036 
    __init_work(& pf->service_task,0);
    #line 15036 
    atomic_long_t __constr_expr_46 = {.counter = 137438953408LL};
    #line 15036 
    pf->service_task.data = __constr_expr_46;
    #line 15036 
    lockdep_init_map(& pf->service_task.lockdep_map,(char *)"(work_completion)",& __key_2,0);
    #line 15036 
    INIT_LIST_HEAD(& pf->service_task.entry);
    #line 15036 
    pf->service_task.func = & i40e_service_task;
  }
  #line 15037 
  cif_clear_bit_1(4L,(unsigned long *)(& pf->state));
  #line 15040 
  i40e_read_nvm_word(hw,(unsigned short)25,& wol_nvm_bits);
  #line 15041 
  if ((((unsigned long)wol_nvm_bits >> (int)hw->port) & 1UL) != 0UL || (unsigned int)hw->partition_id != 1U) 
    #line 15042 
    pf->wol_en = (_Bool)0; else 
                                #line 15044 
                                pf->wol_en = (_Bool)1;
  #line 15045 
  device_set_wakeup_enable(& (pf->pdev)->dev,(_Bool)((bool)((int)pf->wol_en) != 0));
  #line 15048 
  i40e_determine_queue_usage(pf);
  #line 15049 
  err = i40e_init_interrupt_scheme(pf);
  #line 15050 
  if (err != 0) 
                #line 15051 
                goto err_switch_setup;
  #line 15058 
  if (pf->hw.func_caps.num_vsis <= 82U) 
                                        #line 15059 
                                        pf->num_alloc_vsi = (unsigned short)83U; else 
                                                                    #line 15061 
                                                                    pf->num_alloc_vsi = (unsigned short)pf->hw.func_caps.num_vsis;
  #line 15064 
  pf->vsi = (struct i40e_vsi **)kcalloc_0((unsigned long)pf->num_alloc_vsi,8UL,3264U);
  #line 15066 
  if (pf->vsi == (struct i40e_vsi **)0) {
    #line 15067 
    err = -12;
    #line 15068 
    goto err_switch_setup;
  }
  #line 15073 
  if (((unsigned long)pf->flags & 32UL) != 0UL && ((unsigned long)pf->flags & 4UL) != 0UL) {
    #line 15075 
    if (! test_bit(19L,(unsigned long *)(& pf->state))) {
      #line 15076 
      if (pci_num_vf(pdev) != 0) 
                                 #line 15077 
                                 pf->flags |= 4096U;
    }
  }
  #line 15080 
  err = i40e_setup_pf_switch(pf,(_Bool)0);
  #line 15081 
  if (err != 0) {
    #line 15082 
    _dev_info(& pdev->dev,(char *)"setup_pf_switch failed: %d\n",err);
    #line 15083 
    goto err_vsis;
  }
  #line 15085 
  INIT_LIST_HEAD(& (*(pf->vsi + (unsigned long)pf->lan_vsi))->ch_list);
  #line 15088 
  err = (int)i40e_set_fc(hw,& set_fc_aq_fail,(_Bool)1);
  #line 15089 
  if (((int)set_fc_aq_fail & 1) != 0) {
    #line 15090 
    bool branch;
    #line 15090 
    struct _ddebug __UNIQUE_ID_ddebug698 = {.modname = (char *)"i40e", .function = (char *)"i40e_probe", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Set fc with err %s aq_err %s on get_phy_cap\n", .lineno = (unsigned int)15090U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 15090 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug698.key.dd_key_false.key,(_Bool)0);
    #line 15090 
    if ((long)((long)((int)branch != 0)) != 0L) {
      #line 15090 
      ;
      #line 15090 
      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug698,& (pf->pdev)->dev,(char *)"Set fc with err %s aq_err %s on get_phy_cap\n",i40e_stat_str(hw,(enum i40e_status_code)err),i40e_aq_str(hw,hw->aq.asq_last_status));
    }
  }
  #line 15094 
  if (((int)set_fc_aq_fail & 2) != 0) {
    #line 15095 
    bool branch_0;
    #line 15095 
    struct _ddebug __UNIQUE_ID_ddebug699 = {.modname = (char *)"i40e", .function = (char *)"i40e_probe", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Set fc with err %s aq_err %s on set_phy_config\n", .lineno = (unsigned int)15095U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 15095 
    branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug699.key.dd_key_false.key,(_Bool)0);
    #line 15095 
    if ((long)((long)((int)branch_0 != 0)) != 0L) {
      #line 15095 
      ;
      #line 15095 
      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug699,& (pf->pdev)->dev,(char *)"Set fc with err %s aq_err %s on set_phy_config\n",i40e_stat_str(hw,(enum i40e_status_code)err),i40e_aq_str(hw,hw->aq.asq_last_status));
    }
  }
  #line 15099 
  if (((int)set_fc_aq_fail & 4) != 0) {
    #line 15100 
    bool branch_1;
    #line 15100 
    struct _ddebug __UNIQUE_ID_ddebug700 = {.modname = (char *)"i40e", .function = (char *)"i40e_probe", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"Set fc with err %s aq_err %s on get_link_info\n", .lineno = (unsigned int)15100U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 15100 
    branch_1 = arch_static_branch(& __UNIQUE_ID_ddebug700.key.dd_key_false.key,(_Bool)0);
    #line 15100 
    if ((long)((long)((int)branch_1 != 0)) != 0L) {
      #line 15100 
      ;
      #line 15100 
      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug700,& (pf->pdev)->dev,(char *)"Set fc with err %s aq_err %s on get_link_info\n",i40e_stat_str(hw,(enum i40e_status_code)err),i40e_aq_str(hw,hw->aq.asq_last_status));
    }
  }
  #line 15106 
  i = 0U;
  #line 15106 
  while ((unsigned int)pf->num_alloc_vsi > i) {
    #line 15107 
    if (*(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0 && (*(pf->vsi + (unsigned long)i))->type == (unsigned int)I40E_VSI_FDIR) {
      #line 15108 
      i40e_vsi_open(*(pf->vsi + (unsigned long)i));
      #line 15109 
      break;
    }
    #line 15106 
    i ++;
  }
  #line 15116 
  err = (int)i40e_aq_set_phy_int_mask(& pf->hw,(unsigned short)65273,
                                  (struct i40e_asq_cmd_details *)0);
  #line 15120 
  if (err != 0) {
    #line 15121 
    ;
    #line 15121 
    _dev_info(& (pf->pdev)->dev,(char *)"set phy mask fail, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)err),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
  }
  #line 15129 
  val = readl((void *)(hw->hw_addr + 943324U));
  #line 15130 
  if ((val & 67043328U) > 4194304U) {
    #line 15131 
    val &= 4227923967U;
    #line 15132 
    val |= 4194304U;
    #line 15133 
    writel(val,(void *)(hw->hw_addr + 943324U));
  }
  #line 15136 
  if (((unsigned long)pf->hw_features & 262144UL) != 0UL) {
    #line 15137 
    msleep(75U);
    #line 15138 
    err = (int)i40e_aq_set_link_restart_an(& pf->hw,(_Bool)1,
                                     (struct i40e_asq_cmd_details *)0);
    #line 15139 
    if (err != 0) {
      #line 15140 
      ;
      #line 15140 
      _dev_info(& (pf->pdev)->dev,(char *)"link restart failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)err),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    }
  }
  #line 15149 
  cif_clear_bit_1(3L,(unsigned long *)(& pf->state));
  #line 15156 
  if (((unsigned long)pf->flags & 4UL) != 0UL) {
    #line 15157 
    err = i40e_setup_misc_vector(pf);
    #line 15158 
    if (err != 0) {
      #line 15159 
      _dev_info(& pdev->dev,(char *)"setup of misc vector failed: %d\n",err);
      #line 15161 
      goto err_vsis;
    }
  }
  #line 15167 
  if (((unsigned long)pf->flags & 32UL) != 0UL && ((unsigned long)pf->flags & 4UL) != 0UL) {
    #line 15169 
    if (! test_bit(19L,(unsigned long *)(& pf->state))) {
      #line 15171 
      val = readl((void *)(hw->hw_addr + 258304U));
      #line 15172 
      val &= 4294967279U;
      #line 15173 
      writel(val,(void *)(hw->hw_addr + 258304U));
      #line 15174 
      readl((void *)(hw->hw_addr + 745772U));
      #line 15176 
      if (pci_num_vf(pdev) != 0) {
        #line 15177 
        _dev_info(& pdev->dev,(char *)"Active VFs found, allocating resources.\n");
        #line 15179 
        ;
        #line 15179 
        err = i40e_alloc_vfs(pf,(unsigned short)((int)((unsigned short)pci_num_vf(pdev))));
        #line 15180 
        if (err != 0) 
                      #line 15181 
                      _dev_info(& pdev->dev,(char *)"Error %d allocating resources for existing VFs\n",err);
      }
    }
  }
  #line 15188 
  if (((unsigned long)pf->flags & 262144UL) != 0UL) {
    #line 15189 
    pf->iwarp_base_vector = i40e_get_lump(pf,pf->irq_pile,(unsigned short)((int)pf->num_iwarp_msix),(unsigned short)32766);
    #line 15192 
    if (pf->iwarp_base_vector < 0) {
      #line 15193 
      _dev_info(& pdev->dev,(char *)"failed to get tracking for %d vectors for IWARP err=%d\n",(int)pf->num_iwarp_msix,pf->iwarp_base_vector);
      #line 15196 
      pf->flags &= 4294705151U;
    }
  }
  #line 15200 
  i40e_dbg_pf_init(pf);
  #line 15203 
  i40e_send_version(pf);
  #line 15206 
  ;
  #line 15206 
  cif_mod_timer(& pf->service_timer,round_jiffies(pf->service_timer_period + jiffies));
  #line 15210 
  if (((unsigned long)pf->flags & 262144UL) != 0UL) {
    #line 15211 
    err = i40e_lan_add_device(pf);
    #line 15212 
    if (err != 0) 
                  #line 15213 
                  _dev_info(& pdev->dev,(char *)"Failed to add PF to client API service list: %d\n",err);
  }
  #line 15223 
  if (((unsigned long)pf->hw_features & 32UL) == 0UL) {
    #line 15224 
    char speed[8U] = {(char)'U', (char)'n', (char)'k', (char)'n', (char)'o', (char)'w', (char)'n', (char)'\000'};
    #line 15225 
    char width[8U] = {(char)'U', (char)'n', (char)'k', (char)'n', (char)'o', (char)'w', (char)'n', (char)'\000'};
    #line 15230 
    pcie_capability_read_word(pf->pdev,18,& link_status);
    #line 15233 
    i40e_set_pci_config_data(hw,(unsigned short)((int)link_status));
    #line 15235 
    switch ((unsigned int)hw->bus.speed) {
      #line 15236 
      case (unsigned int)8000: 
                               #line 15236 
      ;
      #line 15237 
      strlcpy((char *)(& speed),(char *)"8.0",8UL);
      #line 15237 
      break;
      #line 15238 
      case (unsigned int)5000: 
                               #line 15238 
      ;
      #line 15239 
      strlcpy((char *)(& speed),(char *)"5.0",8UL);
      #line 15239 
      break;
      #line 15240 
      case (unsigned int)2500: 
                               #line 15240 
      ;
      #line 15241 
      strlcpy((char *)(& speed),(char *)"2.5",8UL);
      #line 15241 
      break;
      #line 15242 
      default: 
               #line 15242 
      ;
      #line 15243 
      break;
    }
    #line 15245 
    switch ((unsigned int)hw->bus.width) {
      #line 15246 
      case (unsigned int)8: 
                            #line 15246 
      ;
      #line 15247 
      strlcpy((char *)(& width),(char *)"8",8UL);
      #line 15247 
      break;
      #line 15248 
      case (unsigned int)4: 
                            #line 15248 
      ;
      #line 15249 
      strlcpy((char *)(& width),(char *)"4",8UL);
      #line 15249 
      break;
      #line 15250 
      case (unsigned int)2: 
                            #line 15250 
      ;
      #line 15251 
      strlcpy((char *)(& width),(char *)"2",8UL);
      #line 15251 
      break;
      #line 15252 
      case (unsigned int)1: 
                            #line 15252 
      ;
      #line 15253 
      strlcpy((char *)(& width),(char *)"1",8UL);
      #line 15253 
      break;
      #line 15254 
      default: 
               #line 15254 
      ;
      #line 15255 
      break;
    }
    #line 15258 
    _dev_info(& pdev->dev,(char *)"PCI-Express: Speed %sGT/s Width x%s\n",(char *)(& speed),(char *)(& width));
    #line 15261 
    if (hw->bus.width <= (unsigned int)7 || hw->bus.speed <= (unsigned int)7999) {
      #line 15263 
      _dev_warn(& pdev->dev,(char *)"PCI-Express bandwidth available for this device may be insufficient for optimal performance.\n");
      #line 15264 
      _dev_warn(& pdev->dev,(char *)"Please move the device to a different PCI-e link with more lanes and/or higher transfer rate.\n");
    }
  }
  #line 15269 
  err = (int)i40e_aq_get_phy_capabilities(hw,(_Bool)0,(_Bool)0,& abilities,
                                      (struct i40e_asq_cmd_details *)0);
  #line 15270 
  if (err != 0) {
    #line 15271 
    bool branch_2;
    #line 15271 
    struct _ddebug __UNIQUE_ID_ddebug701 = {.modname = (char *)"i40e", .function = (char *)"i40e_probe", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"get requested speeds ret =  %s last_status =  %s\n", .lineno = (unsigned int)15271U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 15271 
    branch_2 = arch_static_branch(& __UNIQUE_ID_ddebug701.key.dd_key_false.key,(_Bool)0);
    #line 15271 
    if ((long)((long)((int)branch_2 != 0)) != 0L) {
      #line 15271 
      ;
      #line 15271 
      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug701,& (pf->pdev)->dev,(char *)"get requested speeds ret =  %s last_status =  %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)err),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    }
  }
  #line 15274 
  pf->hw.phy.link_info.requested_speeds = abilities.link_speed;
  #line 15277 
  i40e_set_fec_in_flags((unsigned char)((int)abilities.fec_cfg_curr_mod_ext_info),& pf->flags);
  #line 15280 
  err = (int)i40e_aq_get_phy_capabilities(hw,(_Bool)0,(_Bool)1,& abilities,
                                      (struct i40e_asq_cmd_details *)0);
  #line 15281 
  if (err != 0) {
    #line 15282 
    bool branch_3;
    #line 15282 
    struct _ddebug __UNIQUE_ID_ddebug702 = {.modname = (char *)"i40e", .function = (char *)"i40e_probe", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"get supported phy types ret =  %s last_status =  %s\n", .lineno = (unsigned int)15282U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 15282 
    branch_3 = arch_static_branch(& __UNIQUE_ID_ddebug702.key.dd_key_false.key,(_Bool)0);
    #line 15282 
    if ((long)((long)((int)branch_3 != 0)) != 0L) {
      #line 15282 
      ;
      #line 15282 
      __dynamic_dev_dbg(& __UNIQUE_ID_ddebug702,& (pf->pdev)->dev,(char *)"get supported phy types ret =  %s last_status =  %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)err),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    }
  }
  #line 15292 
  i40e_add_filter_to_drop_tx_flow_control_frames(& pf->hw,(unsigned short)((int)pf->main_vsi_seid));
  #line 15295 
  if ((unsigned int)pf->hw.device_id == 5510U || (unsigned int)pf->hw.device_id == 5513U) 
    #line 15297 
    pf->hw_features |= 32768U;
  #line 15298 
  if ((unsigned int)pf->hw.device_id == 14291U) 
                                                #line 15299 
                                                pf->hw_features |= 8192U;
  #line 15301 
  i40e_print_features(pf);
  #line 15303 
  return 0;
  #line 15306 
  err_vsis: 
            #line 15306 
  ;
  #line 15307 
  cif_set_bit_1(3L,(unsigned long *)(& pf->state));
  #line 15308 
  i40e_clear_interrupt_scheme(pf);
  #line 15309 
  kfree((void *)pf->vsi);
  #line 15310 
  err_switch_setup: 
                    #line 15310 
  ;
  #line 15311 
  i40e_reset_interrupt_capability(pf);
  #line 15312 
  cif_del_timer_sync(& pf->service_timer);
  #line 15313 
  err_mac_addr: 
                #line 15313 
  ;
  #line 15314 
  err_configure_lan_hmc: 
                         #line 15314 
  ;
  #line 15315 
  i40e_shutdown_lan_hmc(hw);
  #line 15316 
  err_init_lan_hmc: 
                    #line 15316 
  ;
  #line 15317 
  kfree((void *)pf->qp_pile);
  #line 15318 
  err_sw_init: 
               #line 15318 
  ;
  #line 15319 
  err_adminq_setup: 
                    #line 15319 
  ;
  #line 15320 
  err_pf_reset: 
                #line 15320 
  ;
  #line 15321 
  iounmap((void *)hw->hw_addr);
  #line 15322 
  err_ioremap: 
               #line 15322 
  ;
  #line 15323 
  kfree((void *)pf);
  #line 15324 
  err_pf_alloc: 
                #line 15324 
  ;
  #line 15325 
  pci_disable_pcie_error_reporting(pdev);
  #line 15326 
  pci_release_mem_regions(pdev);
  #line 15327 
  err_pci_reg: 
               #line 15327 
  ;
  #line 15328 
  err_dma: 
           #line 15328 
  ;
  #line 15329 
  pci_disable_device(pdev);
  #line 15330 
  return err;
}

#line 15342  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_remove(struct pci_dev *pdev)
{
  #line 15346 
  i40e_status ret_code;
  #line 15347 
  int i;
  #line 15344 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  #line 15345 
  struct i40e_hw *hw = & pf->hw;
  #line 15349 
  i40e_dbg_pf_exit(pf);
  #line 15351 
  i40e_ptp_stop(pf);
  #line 15354 
  i40e_write_rx_ctl(hw,2382080U,0U);
  #line 15355 
  i40e_write_rx_ctl(hw,2382208U,0U);
  #line 15358 
  cif_set_bit_1(17L,(unsigned long *)(& pf->state));
  #line 15359 
  cif_set_bit_1(3L,(unsigned long *)(& pf->state));
  #line 15360 
  if (pf->service_timer.function != (void (*)(struct timer_list *))0) 
    #line 15361 
    cif_del_timer_sync(& pf->service_timer);
  #line 15362 
  if (pf->service_task.func != (void (*)(struct work_struct *))0) 
                                                                  #line 15363 
                                                                  cancel_work_sync(& pf->service_task);
  #line 15365 
  if ((int)test_bit(34L,(unsigned long *)(& pf->state)) != 0) {
    #line 15366 
    struct i40e_vsi *vsi = *(pf->vsi);
    #line 15372 
    cif_unregister_netdev(vsi->netdev);
    #line 15373 
    cif_free_netdev(vsi->netdev);
    #line 15375 
    goto unmap;
  }
  #line 15381 
  i40e_notify_client_of_netdev_close(*(pf->vsi + (unsigned long)pf->lan_vsi),(_Bool)0);
  #line 15383 
  if (((unsigned long)pf->flags & 32UL) != 0UL) {
    #line 15384 
    i40e_free_vfs(pf);
    #line 15385 
    pf->flags &= 4294967263U;
  }
  #line 15388 
  i40e_fdir_teardown(pf);
  #line 15393 
  i = 0;
  #line 15393 
  while (i <= 15) {
    #line 15394 
    if (pf->veb[i] == (struct i40e_veb *)0) 
                                            #line 15395 
                                            goto __Cont;
    #line 15397 
    if ((int)(pf->veb[i])->uplink_seid == (int)pf->mac_seid || (unsigned int)(pf->veb[i])->uplink_seid == 0U) 
      #line 15399 
      i40e_switch_branch_release(pf->veb[i]);
    #line 15393 
    __Cont: 
            #line 15393 
    i ++;
  }
  #line 15405 
  if (*(pf->vsi + (unsigned long)pf->lan_vsi) != (struct i40e_vsi *)0) 
    #line 15406 
    i40e_vsi_release(*(pf->vsi + (unsigned long)pf->lan_vsi));
  #line 15408 
  i40e_cloud_filter_exit(pf);
  #line 15411 
  if (((unsigned long)pf->flags & 262144UL) != 0UL) {
    #line 15412 
    ret_code = (enum i40e_status_code)i40e_lan_del_device(pf);
    #line 15413 
    if (ret_code != I40E_SUCCESS) 
                                  #line 15414 
                                  _dev_warn(& pdev->dev,(char *)"Failed to delete client device: %d\n",(int)ret_code);
  }
  #line 15419 
  if (hw->hmc.hmc_obj != (struct i40e_hmc_obj_info *)0) {
    #line 15420 
    ret_code = i40e_shutdown_lan_hmc(hw);
    #line 15421 
    if (ret_code != I40E_SUCCESS) 
                                  #line 15422 
                                  _dev_warn(& pdev->dev,(char *)"Failed to destroy the HMC resources: %d\n",(int)ret_code);
  }
  #line 15427 
  unmap: 
         #line 15427 
  ;
  #line 15429 
  if ((int)test_bit(34L,(unsigned long *)(& pf->state)) != 0) 
    #line 15429 
    if (((unsigned long)pf->flags & 4UL) == 0UL) 
                                                 #line 15431 
                                                 cif_free_irq((pf->pdev)->irq,(void *)pf);
  #line 15434 
  i40e_shutdown_adminq(hw);
  #line 15437 
  mutex_destroy(& hw->aq.arq_mutex);
  #line 15438 
  mutex_destroy(& hw->aq.asq_mutex);
  #line 15441 
  rtnl_lock();
  #line 15442 
  i40e_clear_interrupt_scheme(pf);
  #line 15443 
  i = 0;
  #line 15443 
  while ((int)pf->num_alloc_vsi > i) {
    #line 15444 
    if (*(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0) {
      #line 15445 
      if (! test_bit(34L,(unsigned long *)(& pf->state))) 
                                                          #line 15446 
                                                          i40e_vsi_clear_rings(*(pf->vsi + (unsigned long)i));
      #line 15447 
      i40e_vsi_clear(*(pf->vsi + (unsigned long)i));
      #line 15448 
      *(pf->vsi + (unsigned long)i) = (struct i40e_vsi *)0;
    }
    #line 15443 
    i ++;
  }
  #line 15451 
  rtnl_unlock();
  #line 15453 
  i = 0;
  #line 15453 
  while (i <= 15) {
    #line 15454 
    kfree((void *)pf->veb[i]);
    #line 15455 
    pf->veb[i] = (struct i40e_veb *)0;
    #line 15453 
    i ++;
  }
  #line 15458 
  kfree((void *)pf->qp_pile);
  #line 15459 
  kfree((void *)pf->vsi);
  #line 15461 
  iounmap((void *)hw->hw_addr);
  #line 15462 
  kfree((void *)pf);
  #line 15463 
  pci_release_mem_regions(pdev);
  #line 15465 
  pci_disable_pcie_error_reporting(pdev);
  #line 15466 
  pci_disable_device(pdev);
  #line 15467 
  return;
}

#line 15478  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static pci_ers_result_t i40e_pci_error_detected(struct pci_dev *pdev, enum pci_channel_state error)
{
  #line 15481 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  #line 15483 
  _dev_info(& pdev->dev,(char *)"%s: error %d\n",(char *)"i40e_pci_error_detected",(unsigned int)error);
  #line 15485 
  if (pf == (struct i40e_pf *)0) {
    #line 15486 
    _dev_info(& pdev->dev,(char *)"Cannot recover - error happened during device probe\n");
    #line 15488 
    return 4U;
  }
  #line 15492 
  if (! test_bit(17L,(unsigned long *)(& pf->state))) 
                                                      #line 15493 
                                                      i40e_prep_for_reset(pf,(_Bool)0);
  #line 15496 
  return 3U;
}

#line 15508  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static pci_ers_result_t i40e_pci_error_slot_reset(struct pci_dev *pdev)
{
  #line 15511 
  pci_ers_result_t result;
  #line 15512 
  u32 reg;
  #line 15510 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  {
    #line 15514 
    bool branch;
    #line 15514 
    struct _ddebug __UNIQUE_ID_ddebug703 = {.modname = (char *)"i40e", .function = (char *)"i40e_pci_error_slot_reset", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"%s\n", .lineno = (unsigned int)15514U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 15514 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug703.key.dd_key_false.key,(_Bool)0);
    #line 15514 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 15514 
                                                __dynamic_dev_dbg(& __UNIQUE_ID_ddebug703,& pdev->dev,(char *)"%s\n",(char *)"i40e_pci_error_slot_reset");
  }
  #line 15515 
  if (pci_enable_device_mem(pdev) != 0) {
    #line 15516 
    _dev_info(& pdev->dev,(char *)"Cannot re-enable PCI device after reset.\n");
    #line 15518 
    result = 4U;
  }
  else {
    #line 15520 
    pci_set_master(pdev);
    #line 15521 
    pci_restore_state(pdev);
    #line 15522 
    pci_save_state(pdev);
    #line 15523 
    pci_wake_from_d3(pdev,(_Bool)0);
    #line 15525 
    reg = readl((void *)(pf->hw.hw_addr + 754064U));
    #line 15526 
    if (reg == 0U) 
                   #line 15527 
                   result = 5U; else 
                                     #line 15529 
                                     result = 4U;
  }
  #line 15532 
  return result;
}

#line 15539  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_pci_error_reset_prepare(struct pci_dev *pdev)
{
  #line 15541 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  #line 15543 
  i40e_prep_for_reset(pf,(_Bool)0);
  #line 15544 
  return;
}

#line 15550  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_pci_error_reset_done(struct pci_dev *pdev)
{
  #line 15552 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  #line 15554 
  i40e_reset_and_rebuild(pf,(_Bool)0,(_Bool)0);
  #line 15555 
  return;
}

#line 15564  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_pci_error_resume(struct pci_dev *pdev)
{
  #line 15566 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  {
    #line 15568 
    bool branch;
    #line 15568 
    struct _ddebug __UNIQUE_ID_ddebug704 = {.modname = (char *)"i40e", .function = (char *)"i40e_pci_error_resume", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c", .format = (char *)"%s\n", .lineno = (unsigned int)15568U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
    #line 15568 
    branch = arch_static_branch(& __UNIQUE_ID_ddebug704.key.dd_key_false.key,(_Bool)0);
    #line 15568 
    if ((long)((long)((int)branch != 0)) != 0L) 
                                                #line 15568 
                                                __dynamic_dev_dbg(& __UNIQUE_ID_ddebug704,& pdev->dev,(char *)"%s\n",(char *)"i40e_pci_error_resume");
  }
  #line 15569 
  if ((int)test_bit(17L,(unsigned long *)(& pf->state)) != 0) 
                                                              #line 15570 
                                                              return;
  #line 15572 
  i40e_handle_reset_warning(pf,(_Bool)0);
  #line 15573 
  return;
}

#line 15580  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_enable_mc_magic_wake(struct i40e_pf *pf)
{
  #line 15583 
  i40e_status ret;
  #line 15584 
  u8 mac_addr[6U];
  #line 15582 
  struct i40e_hw *hw = & pf->hw;
  #line 15585 
  u16 flags = (unsigned short)0U;
  #line 15588 
  if (*(pf->vsi + (unsigned long)pf->lan_vsi) != (struct i40e_vsi *)0 && (*(pf->vsi + (unsigned long)pf->lan_vsi))->netdev != (struct net_device *)0) 
    #line 15589 
    ether_addr_copy((u8 *)(& mac_addr),((*(pf->vsi + (unsigned long)pf->lan_vsi))->netdev)->dev_addr);
  else {
    #line 15592 
    _dev_err(& (pf->pdev)->dev,(char *)"Failed to retrieve MAC address; using default\n");
    #line 15594 
    ether_addr_copy((u8 *)(& mac_addr),(u8 *)(& hw->mac.addr));
  }
  #line 15601 
  flags = (unsigned short)16384U;
  #line 15603 
  if ((int)hw->func_caps.flex10_enable != 0 && (unsigned int)hw->partition_id != 1U) 
    #line 15604 
    flags = (unsigned short)0U;
  #line 15606 
  ret = i40e_aq_mac_address_write(hw,(unsigned short)((int)flags),(u8 *)(& mac_addr),(struct i40e_asq_cmd_details *)0);
  #line 15607 
  if (ret != I40E_SUCCESS) {
    #line 15608 
    _dev_err(& (pf->pdev)->dev,(char *)"Failed to update MAC address registers; cannot enable Multicast Magic packet wake up");
    #line 15610 
    return;
  }
  #line 15613 
  flags = (unsigned short)49920U;
  #line 15616 
  ret = i40e_aq_mac_address_write(hw,(unsigned short)((int)flags),(u8 *)(& mac_addr),(struct i40e_asq_cmd_details *)0);
  #line 15617 
  if (ret != I40E_SUCCESS) 
                           #line 15618 
                           _dev_err(& (pf->pdev)->dev,(char *)"Failed to enable Multicast Magic Packet wake up\n");
  #line 15619 
  return;
}

#line 15626  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_shutdown(struct pci_dev *pdev)
{
  #line 15649 
  unsigned int tmp_0;
  #line 15651 
  unsigned int tmp_1;
  #line 15628 
  struct i40e_pf *pf = pci_get_drvdata(pdev);
  #line 15629 
  struct i40e_hw *hw = & pf->hw;
  #line 15631 
  cif_set_bit_1(17L,(unsigned long *)(& pf->state));
  #line 15632 
  cif_set_bit_1(3L,(unsigned long *)(& pf->state));
  #line 15634 
  cif_del_timer_sync(& pf->service_timer);
  #line 15635 
  cancel_work_sync(& pf->service_task);
  #line 15636 
  i40e_cloud_filter_exit(pf);
  #line 15637 
  i40e_fdir_teardown(pf);
  #line 15642 
  i40e_notify_client_of_netdev_close(*(pf->vsi + (unsigned long)pf->lan_vsi),(_Bool)0);
  #line 15644 
  if ((int)pf->wol_en != 0 && ((unsigned long)pf->hw_features & 2048UL) != 0UL) 
    #line 15645 
    i40e_enable_mc_magic_wake(pf);
  #line 15647 
  i40e_prep_for_reset(pf,(_Bool)0);
  #line 15649 
  ;
  #line 15649 
  if ((int)pf->wol_en != 0) 
                            #line 15649 
                            tmp_0 = 1U; else 
                                             #line 15649 
                                             tmp_0 = 0U;
  #line 15649 
  writel(tmp_0,(void *)(hw->hw_addr + 753792U));
  #line 15651 
  ;
  #line 15651 
  if ((int)pf->wol_en != 0) 
                            #line 15651 
                            tmp_1 = 2U; else 
                                             #line 15651 
                                             tmp_1 = 0U;
  #line 15651 
  writel(tmp_1,(void *)(hw->hw_addr + 439296U));
  #line 15655 
  if ((int)test_bit(34L,(unsigned long *)(& pf->state)) != 0) 
    #line 15655 
    if (((unsigned long)pf->flags & 4UL) == 0UL) 
                                                 #line 15657 
                                                 cif_free_irq((pf->pdev)->irq,(void *)pf);
  #line 15663 
  rtnl_lock();
  #line 15664 
  i40e_clear_interrupt_scheme(pf);
  #line 15665 
  rtnl_unlock();
  #line 15667 
  if (system_state == (unsigned int)SYSTEM_POWER_OFF) {
    #line 15668 
    pci_wake_from_d3(pdev,(_Bool)((bool)((int)pf->wol_en) != 0));
    #line 15669 
    pci_set_power_state(pdev,3);
  }
  #line 15671 
  return;
}

#line 15677  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_suspend(struct device *dev)
{
  #line 15708 
  unsigned int tmp_1;
  #line 15709 
  unsigned int tmp_2;
  #line 15679 
  struct i40e_pf *pf = dev_get_drvdata(dev);
  #line 15680 
  struct i40e_hw *hw = & pf->hw;
  #line 15683 
  if ((int)test_and_set_bit(17L,(unsigned long *)(& pf->state)) != 0) 
    #line 15684 
    return 0;
  #line 15686 
  cif_set_bit_1(3L,(unsigned long *)(& pf->state));
  #line 15689 
  cif_del_timer_sync(& pf->service_timer);
  #line 15690 
  cancel_work_sync(& pf->service_task);
  #line 15695 
  i40e_notify_client_of_netdev_close(*(pf->vsi + (unsigned long)pf->lan_vsi),(_Bool)0);
  #line 15697 
  if ((int)pf->wol_en != 0 && ((unsigned long)pf->hw_features & 2048UL) != 0UL) 
    #line 15698 
    i40e_enable_mc_magic_wake(pf);
  #line 15704 
  rtnl_lock();
  #line 15706 
  i40e_prep_for_reset(pf,(_Bool)1);
  #line 15708 
  ;
  #line 15708 
  if ((int)pf->wol_en != 0) 
                            #line 15708 
                            tmp_1 = 1U; else 
                                             #line 15708 
                                             tmp_1 = 0U;
  #line 15708 
  writel(tmp_1,(void *)(hw->hw_addr + 753792U));
  #line 15709 
  ;
  #line 15709 
  if ((int)pf->wol_en != 0) 
                            #line 15709 
                            tmp_2 = 2U; else 
                                             #line 15709 
                                             tmp_2 = 0U;
  #line 15709 
  writel(tmp_2,(void *)(hw->hw_addr + 439296U));
  #line 15716 
  i40e_clear_interrupt_scheme(pf);
  #line 15718 
  rtnl_unlock();
  #line 15720 
  return 0;
}

#line 15727  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_resume(struct device *dev)
{
  #line 15730 
  int err;
  #line 15729 
  struct i40e_pf *pf = dev_get_drvdata(dev);
  #line 15733 
  if (! test_bit(17L,(unsigned long *)(& pf->state))) 
                                                      #line 15734 
                                                      return 0;
  #line 15739 
  rtnl_lock();
  #line 15744 
  err = i40e_restore_interrupt_scheme(pf);
  #line 15745 
  if (err != 0) 
                #line 15746 
                _dev_err(dev,(char *)"Cannot restore interrupt scheme: %d\n",err);
  #line 15750 
  cif_clear_bit_1(3L,(unsigned long *)(& pf->state));
  #line 15751 
  i40e_reset_and_rebuild(pf,(_Bool)0,(_Bool)1);
  #line 15753 
  rtnl_unlock();
  #line 15756 
  cif_clear_bit_1(17L,(unsigned long *)(& pf->state));
  #line 15759 
  ;
  #line 15759 
  cif_mod_timer(& pf->service_timer,round_jiffies(pf->service_timer_period + jiffies));
  #line 15762 
  return 0;
}

#line 15765  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct pci_error_handlers i40e_err_handler = {.error_detected = & i40e_pci_error_detected, .slot_reset = & i40e_pci_error_slot_reset, .reset_prepare = & i40e_pci_error_reset_prepare, .reset_done = & i40e_pci_error_reset_done, .resume = & i40e_pci_error_resume};
#line 15773  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct dev_pm_ops i40e_pm_ops = {.suspend = & i40e_suspend, .resume = & i40e_resume, .freeze = & i40e_suspend, .thaw = & i40e_resume, .poweroff = & i40e_suspend, .restore = & i40e_resume};
#line 15775  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static struct pci_driver i40e_driver = {.name = (char *)(& i40e_driver_name), .id_table = (struct pci_device_id *)(& i40e_pci_tbl), .probe = & i40e_probe, .remove = & i40e_remove, .shutdown = & i40e_shutdown, .sriov_configure = & i40e_pci_sriov_configure, .err_handler = & i40e_err_handler, .driver = {.pm = & i40e_pm_ops}};
#line 15794  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static int i40e_init_module(void)
{
  #line 15796 
  printk((char *)"\001",(char *)(& i40e_driver_name),(char *)(& i40e_driver_string),(char *)(& i40e_driver_version_str));
  #line 15798 
  printk((char *)"\001",(char *)(& i40e_driver_name),(char *)(& i40e_copyright));
  #line 15807 
  i40e_wq = alloc_workqueue((char *)"%s",8U,0,(char *)(& i40e_driver_name));
  #line 15808 
  if (i40e_wq == (struct workqueue_struct *)0) {
    #line 15809 
    printk((char *)"\001",(char *)(& i40e_driver_name));
    #line 15810 
    return -12;
  }
  #line 15813 
  i40e_dbg_init();
  #line 15814 
  return cif___pci_register_driver(& i40e_driver,& __this_module,(char *)"i40e");
}

#line 15824  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_main.c"
static void i40e_exit_module(void)
{
  #line 15826 
  cif_pci_unregister_driver(& i40e_driver);
  #line 15827 
  destroy_workqueue(i40e_wq);
  #line 15828 
  i40e_dbg_exit();
  #line 15829 
  return;
}

#line 93  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int (*emg_alias_eth_validate_addr)(struct net_device *) = & eth_validate_addr;
#line 94  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
struct pci_driver *emg_alias_i40e_driver = & i40e_driver;
#line 95  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
struct pci_device_id (*emg_alias_i40e_pci_tbl)[25U] = & i40e_pci_tbl;
#line 96  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
struct dev_pm_ops *emg_alias_i40e_pm_ops = & i40e_pm_ops;
#line 99 
#line 99 
int emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2);
#line 100 
#line 100 
struct net_device *emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2);
#line 101 
#line 101 
int emg_del_timer_sync(struct timer_list *arg0);
#line 102 
#line 102 
void *emg_free_irq(unsigned int arg0, void *arg1);
#line 103 
#line 103 
void emg_free_netdev(struct net_device *arg0);
#line 104 
#line 104 
int emg_mod_timer(struct timer_list *arg0, unsigned long arg1);
#line 105 
#line 105 
void emg_pci_unregister_driver(struct pci_driver *arg0);
#line 106 
#line 106 
_Bool emg_queue_work(struct workqueue_struct *arg0, struct work_struct *arg1);
#line 107 
#line 107 
int emg_register_netdev(struct net_device *arg0);
#line 108 
#line 108 
int emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4);
#line 109 
#line 109 
void emg_unregister_netdev(struct net_device *arg0);
#line 113  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper___i40e_setup_tc(struct net_device *arg0, enum tc_setup_type arg1, void *arg2)
{
  #line 114 
  return __i40e_setup_tc(arg0,arg1,arg2);
}

#line 118  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_change_mtu(struct net_device *arg0, int arg1)
{
  #line 119 
  return i40e_change_mtu(arg0,arg1);
}

#line 123  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_close(struct net_device *arg0)
{
  #line 124 
  return i40e_close(arg0);
}

#line 128  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
unsigned long long emg_wrapper_i40e_features_check(struct sk_buff *arg0, struct net_device *arg1, unsigned long long arg2)
{
  #line 129 
  return i40e_features_check(arg0,arg1,arg2);
}

#line 133  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
void *emg_wrapper_i40e_fwd_add(struct net_device *arg0, struct net_device *arg1)
{
  #line 134 
  return i40e_fwd_add(arg0,arg1);
}

#line 138  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
void emg_wrapper_i40e_fwd_del(struct net_device *arg0, void *arg1)
{
  #line 139 
  i40e_fwd_del(arg0,arg1);
  #line 140 
  return;
}

#line 143  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
void emg_wrapper_i40e_get_netdev_stats_struct(struct net_device *arg0, struct rtnl_link_stats64 *arg1)
{
  #line 144 
  i40e_get_netdev_stats_struct(arg0,arg1);
  #line 145 
  return;
}

#line 148  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_get_phys_port_id(struct net_device *arg0, struct netdev_phys_item_id *arg1)
{
  #line 149 
  return i40e_get_phys_port_id(arg0,arg1);
}

#line 153  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
enum irqreturn emg_wrapper_i40e_intr(int arg0, void *arg1)
{
  #line 154 
  return i40e_intr(arg0,arg1);
}

#line 158  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_ndo_bridge_getlink(struct sk_buff *arg0, unsigned int arg1, unsigned int arg2, struct net_device *arg3, unsigned int arg4, int arg5)
{
  #line 159 
  return i40e_ndo_bridge_getlink(arg0,arg1,arg2,arg3,arg4,arg5);
}

#line 163  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_ndo_bridge_setlink(struct net_device *arg0, struct nlmsghdr *arg1, unsigned short arg2, struct netlink_ext_ack *arg3)
{
  #line 164 
  return i40e_ndo_bridge_setlink(arg0,arg1,(unsigned short)((int)arg2),arg3);
}

#line 168  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_ndo_fdb_add(struct ndmsg *arg0, struct nlattr **arg1, struct net_device *arg2, unsigned char *arg3, unsigned short arg4, unsigned short arg5, struct netlink_ext_ack *arg6)
{
  #line 169 
  return i40e_ndo_fdb_add(arg0,arg1,arg2,arg3,(unsigned short)((int)arg4),
                       (unsigned short)((int)arg5),arg6);
}

#line 173  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
void emg_wrapper_i40e_netpoll(struct net_device *arg0)
{
  #line 174 
  i40e_netpoll(arg0);
  #line 175 
  return;
}

#line 178  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_open(struct net_device *arg0)
{
  #line 179 
  return i40e_open(arg0);
}

#line 183  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_probe(struct pci_dev *arg0, struct pci_device_id *arg1)
{
  #line 184 
  return i40e_probe(arg0,arg1);
}

#line 188  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
void emg_wrapper_i40e_remove(struct pci_dev *arg0)
{
  #line 189 
  i40e_remove(arg0);
  #line 190 
  return;
}

#line 193  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_resume(struct device *arg0)
{
  #line 194 
  return i40e_resume(arg0);
}

#line 198  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_set_features(struct net_device *arg0, unsigned long long arg1)
{
  #line 199 
  return i40e_set_features(arg0,arg1);
}

#line 203  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_set_mac(struct net_device *arg0, void *arg1)
{
  #line 204 
  return i40e_set_mac(arg0,arg1);
}

#line 208  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
void emg_wrapper_i40e_set_rx_mode(struct net_device *arg0)
{
  #line 209 
  i40e_set_rx_mode(arg0);
  #line 210 
  return;
}

#line 213  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
void emg_wrapper_i40e_shutdown(struct pci_dev *arg0)
{
  #line 214 
  i40e_shutdown(arg0);
  #line 215 
  return;
}

#line 218  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_suspend(struct device *arg0)
{
  #line 219 
  return i40e_suspend(arg0);
}

#line 223  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
void emg_wrapper_i40e_tx_timeout(struct net_device *arg0)
{
  #line 224 
  i40e_tx_timeout(arg0);
  #line 225 
  return;
}

#line 228  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
void emg_wrapper_i40e_udp_tunnel_add(struct net_device *arg0, struct udp_tunnel_info *arg1)
{
  #line 229 
  i40e_udp_tunnel_add(arg0,arg1);
  #line 230 
  return;
}

#line 233  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
void emg_wrapper_i40e_udp_tunnel_del(struct net_device *arg0, struct udp_tunnel_info *arg1)
{
  #line 234 
  i40e_udp_tunnel_del(arg0,arg1);
  #line 235 
  return;
}

#line 238  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_vlan_rx_add_vid(struct net_device *arg0, unsigned short arg1, unsigned short arg2)
{
  #line 239 
  return i40e_vlan_rx_add_vid(arg0,(unsigned short)((int)arg1),
                           (unsigned short)((int)arg2));
}

#line 243  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_vlan_rx_kill_vid(struct net_device *arg0, unsigned short arg1, unsigned short arg2)
{
  #line 244 
  return i40e_vlan_rx_kill_vid(arg0,(unsigned short)((int)arg1),
                            (unsigned short)((int)arg2));
}

#line 248  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_wrapper_i40e_xdp(struct net_device *arg0, struct netdev_bpf *arg1)
{
  #line 249 
  return i40e_xdp(arg0,arg1);
}

#line 253  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
void emg_i40e_exit_module(void)
{
  #line 254 
  i40e_exit_module();
  #line 255 
  return;
}

#line 257  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
int emg_i40e_init_module(void)
{
  #line 258 
  return i40e_init_module();
}

#line 269  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static unsigned long cif_find_next_bit_0(unsigned long *addr, unsigned long size, unsigned long offset)
{
  #line 272 
  return ldv_find_next_bit(addr,size,offset);
}

#line 276  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_set_bit_1(long nr, unsigned long *addr)
{
  #line 279 
  ldv_set_bit(nr,addr);
  #line 280 
  return;
}

#line 283  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_clear_bit_1(long nr, unsigned long *addr)
{
  #line 286 
  ldv_clear_bit(nr,addr);
  #line 287 
  return;
}

#line 290  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void INIT_LIST_HEAD(struct list_head *list)
{
  #line 293 
  ldv_init_list_head(list);
  #line 294 
  return;
}

#line 311  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static unsigned long cif_find_first_bit_0(unsigned long *addr, unsigned long size)
{
  #line 314 
  return ldv_find_first_bit(addr,size);
}

#line 353  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_bitmap_zero(unsigned long *dst, unsigned int nbits)
{
  #line 356 
  ldv_bitmap_zero(dst,nbits);
  #line 357 
  return;
}

#line 360  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void *ERR_PTR_0(long error)
{
  #line 363 
  return ldv_err_ptr(error);
}

#line 460  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static bool cif_queue_work(struct workqueue_struct *wq, struct work_struct *work)
{
  #line 464 
  return emg_queue_work(wq,work);
}

#line 549  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void *kmalloc(size_t size, gfp_t flags)
{
  #line 552 
  return ldv_kmalloc(size,flags);
}

#line 563  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void *kcalloc_0(size_t n, size_t size, gfp_t flags)
{
  #line 566 
  return ldv_kcalloc(n,size,flags);
}

#line 584  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void *kzalloc_1(size_t size, gfp_t flags)
{
  #line 587 
  return ldv_kzalloc(size,flags);
}

#line 702  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_spin_lock__xmit_lock_of_netdev_queue(spinlock_t *lock)
{
  #line 705 
  ldv_spin_model_lock((char *)"_xmit_lock_of_netdev_queue");
  #line 707 
  spin_lock(lock);
  #line 708 
  return;
}

#line 742  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_spin_unlock__xmit_lock_of_netdev_queue(spinlock_t *lock)
{
  #line 745 
  ldv_spin_model_unlock((char *)"_xmit_lock_of_netdev_queue");
  #line 747 
  spin_unlock(lock);
  #line 748 
  return;
}

#line 1015  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_spin_lock_bh_mac_filter_hash_lock_of_i40e_vsi_0(spinlock_t *lock)
{
  #line 1018 
  ldv_spin_model_lock((char *)"mac_filter_hash_lock_of_i40e_vsi");
  #line 1020 
  spin_lock_bh_1(lock);
  #line 1021 
  return;
}

#line 1024  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_spin_unlock_bh_mac_filter_hash_lock_of_i40e_vsi_0(spinlock_t *lock)
{
  #line 1027 
  ldv_spin_model_unlock((char *)"mac_filter_hash_lock_of_i40e_vsi");
  #line 1029 
  spin_unlock_bh_1(lock);
  #line 1030 
  return;
}

#line 1033  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static int cif_request_irq(unsigned int irq, irqreturn_t (*handler)(int , void *), unsigned long flags, char *name, void *dev)
{
  #line 1037 
  return emg_request_irq(irq,handler,flags,name,dev);
}

#line 1041  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void *cif_free_irq(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  #line 1045 
  return emg_free_irq(ldv_func_arg1,ldv_func_arg2);
}

#line 1049  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static int cif_mod_timer(struct timer_list *timer, unsigned long expires)
{
  #line 1053 
  return emg_mod_timer(timer,expires);
}

#line 1057  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_mutex_lock_switch_mutex_of_i40e_pf(struct mutex *lock)
{
  #line 1060 
  ldv_mutex_model_lock(lock,(char *)"switch_mutex_of_i40e_pf");
  #line 1061 
  return;
}

#line 1064  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_mutex_unlock_switch_mutex_of_i40e_pf(struct mutex *lock)
{
  #line 1067 
  ldv_mutex_model_unlock(lock,(char *)"switch_mutex_of_i40e_pf");
  #line 1068 
  return;
}

#line 1071  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static struct net_device *cif_alloc_etherdev_mqs(int sizeof_priv, unsigned int txqs, unsigned int rxqs)
{
  #line 1075 
  return emg_alloc_etherdev_mqs(sizeof_priv,txqs,rxqs);
}

#line 1079  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_unregister_netdev(struct net_device *dev)
{
  #line 1083 
  emg_unregister_netdev(dev);
  #line 1084 
  return;
}

#line 1087  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_free_netdev(struct net_device *dev)
{
  #line 1091 
  emg_free_netdev(dev);
  #line 1092 
  return;
}

#line 1095  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static int cif_register_netdev(struct net_device *dev)
{
  #line 1099 
  return emg_register_netdev(dev);
}

#line 1103  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static int cif_del_timer_sync(struct timer_list *timer)
{
  #line 1107 
  return emg_del_timer_sync(timer);
}

#line 1111  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static int cif___pci_register_driver(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char *mod_name)
{
  #line 1115 
  return emg___pci_register_driver(ldv_func_arg1,ldv_func_arg2,mod_name);
}

#line 1119  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_main.i.aux"
static void cif_pci_unregister_driver(struct pci_driver *dev)
{
  #line 1123 
  emg_pci_unregister_driver(dev);
  #line 1124 
  return;
}

#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_add_0(struct list_head *new, struct list_head *prev, struct list_head *next)
{
  #line 60 
  if (! __list_add_valid(new,prev,next)) 
                                         #line 61 
                                         return;
  #line 63 
  next->prev = new;
  #line 64 
  new->next = next;
  #line 65 
  new->prev = prev;
  {
    #line 67 
    union __anonunion___u_9864 __u = {.__val = new};
    #line 66 
    __write_once_size((void *)(& prev->next),(void *)(& __u.__c),8);
    #line 66 
    struct list_head *tmp_2 = __u.__val;
  }
  #line 68 
  return;
}

#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void list_add(struct list_head *new, struct list_head *head)
{
  #line 79 
  __list_add_0(new,head,head->next);
  #line 80 
  return;
}

#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_del_0(struct list_head *prev, struct list_head *next)
{
  #line 97 
  next->prev = prev;
  {
    #line 107 
    union __anonunion___u_9866 __u = {.__val = next};
    #line 106 
    __write_once_size((void *)(& prev->next),(void *)(& __u.__c),8);
    #line 106 
    struct list_head *tmp = __u.__val;
  }
  #line 108 
  return;
}

#line 129  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_del_entry_0(struct list_head *entry)
{
  #line 131 
  if (! __list_del_entry_valid(entry)) 
                                       #line 132 
                                       return;
  #line 134 
  __list_del_0(entry->prev,entry->next);
  #line 135 
  return;
}

#line 137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void list_del_0(struct list_head *entry)
{
  #line 139 
  __list_del_entry_0(entry);
  #line 140 
  entry->next = (struct list_head *)(-2401263026318606080);
  #line 141 
  entry->prev = (struct list_head *)(-2401263026318606046);
  #line 142 
  return;
}

#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static int list_empty_0(struct list_head *head)
{
  #line 269 
  union __anonunion___u_9868 __u;
  #line 268 
  __read_once_size((void *)(& head->next),(void *)(& __u.__c),8);
  #line 268 
  ;
  #line 268 
  return (__u.__val) == head;
}

#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/string.h"
#line 26 
char *strncpy(char *, char *, __kernel_size_t);
#line 42 
#line 42 
char *strncat(char *, char *, __kernel_size_t);
#line 52 
#line 141  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ddp.i.aux"
static int cif_strncmp(char *cs, char *ct, __kernel_size_t count);
#line 51 
#line 51 
int ldv_request_firmware(struct firmware **fw);
#line 52 
#line 52 
void ldv_release_firmware(struct firmware *fw);
#line 27  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/string.h"
#line 27 
int ldv_strncmp(char *cs, char *ct, __kernel_size_t count);
#line 668  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 428  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ddp.i.aux"
static void *kzalloc_2(size_t size, gfp_t flags);
#line 331  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 264  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ddp.c"
int i40e_ddp_load(struct net_device *netdev, u8 *data, size_t size, bool is_add);
#line 333  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
#line 415  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ddp.c"
int i40e_ddp_flash(struct net_device *netdev, struct ethtool_flash *flash);
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/firmware.h"
#line 831  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ddp.i.aux"
static int cif_request_firmware(struct firmware **fw, char *name, struct device *device);
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/firmware.h"
#line 838  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ddp.i.aux"
static void cif_release_firmware(struct firmware *fw);
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ddp.c"
static bool i40e_ddp_profiles_eq(struct i40e_profile_info *a, struct i40e_profile_info *b)
{
  #line 20 
  int tmp_1;
  #line 20 
  if (a->track_id == b->track_id) {
    #line 19 
    if (memcmp((void *)(& a->version),(void *)(& b->version),4UL) == 0) {
      #line 20 
      if (memcmp((void *)(& a->name),(void *)(& b->name),32UL) == 0) 
        #line 20 
        tmp_1 = 1; else 
                        #line 20 
                        tmp_1 = 0;
    }
    else 
         #line 20 
         tmp_1 = 0;
  }
  else 
       #line 20 
       tmp_1 = 0;
  #line 20 
  return (_Bool)(tmp_1 != 0);
}

#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ddp.c"
static int i40e_ddp_does_profile_exist(struct i40e_hw *hw, struct i40e_profile_info *pinfo)
{
  #line 37 
  struct i40e_ddp_profile_list *profile_list;
  #line 38 
  u8 buff[772U];
  #line 39 
  i40e_status status;
  #line 40 
  int i;
  #line 42 
  status = i40e_aq_get_ddp_list(hw,(void *)(& buff),(unsigned short)772,(unsigned char)0,(struct i40e_asq_cmd_details *)0);
  #line 44 
  if (status != I40E_SUCCESS) 
                              #line 45 
                              return -1;
  #line 47 
  profile_list = (struct i40e_ddp_profile_list *)(& buff);
  #line 48 
  i = 0;
  #line 48 
  while (profile_list->p_count > (unsigned int)i) {
    #line 49 
    if ((int)i40e_ddp_profiles_eq(pinfo,& profile_list->p_info[i]) != 0) 
      #line 50 
      return 1;
    #line 48 
    i ++;
  }
  #line 52 
  return 0;
}

#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ddp.c"
static bool i40e_ddp_profiles_overlap(struct i40e_profile_info *new, struct i40e_profile_info *old)
{
  #line 66 
  unsigned int group_id_old = (unsigned int)((unsigned char)(old->track_id >> 16));
  #line 67 
  unsigned int group_id_new = (unsigned int)((unsigned char)(new->track_id >> 16));
  #line 70 
  if (group_id_new == 0U) 
                          #line 71 
                          return (_Bool)1;
  #line 73 
  if (group_id_new == 255U || group_id_old == 255U) 
                                                    #line 74 
                                                    return (_Bool)0;
  #line 76 
  return (_Bool)(group_id_old != group_id_new);
}

#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ddp.c"
static int i40e_ddp_does_profile_overlap(struct i40e_hw *hw, struct i40e_profile_info *pinfo)
{
  #line 92 
  struct i40e_ddp_profile_list *profile_list;
  #line 93 
  u8 buff[772U];
  #line 94 
  i40e_status status;
  #line 95 
  int i;
  #line 97 
  status = i40e_aq_get_ddp_list(hw,(void *)(& buff),(unsigned short)772,(unsigned char)0,(struct i40e_asq_cmd_details *)0);
  #line 99 
  if (status != I40E_SUCCESS) 
                              #line 100 
                              return -5;
  #line 102 
  profile_list = (struct i40e_ddp_profile_list *)(& buff);
  #line 103 
  i = 0;
  #line 103 
  while (profile_list->p_count > (unsigned int)i) {
    #line 104 
    if ((int)i40e_ddp_profiles_overlap(pinfo,& profile_list->p_info[i]) != 0) 
      #line 106 
      return 1;
    #line 103 
    i ++;
  }
  #line 108 
  return 0;
}

#line 121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ddp.c"
static enum i40e_status_code i40e_add_pinfo(struct i40e_hw *hw, struct i40e_profile_segment *profile, u8 *profile_info_sec, u32 track_id)
{
  #line 124 
  struct i40e_profile_section_header *sec;
  #line 125 
  struct i40e_profile_info *pinfo;
  #line 126 
  i40e_status status;
  #line 127 
  u32 offset = 0U;
  #line 127 
  u32 info = 0U;
  #line 129 
  sec = (struct i40e_profile_section_header *)profile_info_sec;
  #line 130 
  sec->tbl_size = (unsigned short)1U;
  #line 131 
  sec->data_end = (unsigned short)64U;
  #line 133 
  sec->section.type = 16U;
  #line 134 
  sec->section.offset = 16U;
  #line 135 
  sec->section.size = 48U;
  #line 136 
  pinfo = (struct i40e_profile_info *)(profile_info_sec + (unsigned long)sec->section.offset);
  #line 138 
  pinfo->track_id = track_id;
  #line 139 
  pinfo->version = profile->version;
  #line 140 
  pinfo->op = (unsigned char)1U;
  #line 143 
  memset((void *)(& pinfo->reserved),0,7UL);
  #line 144 
  memcpy((void *)(& pinfo->name),(void *)(& profile->name),32UL);
  #line 146 
  status = i40e_aq_write_ddp(hw,(void *)sec,(unsigned short)((int)sec->data_end),track_id,& offset,& info,(struct i40e_asq_cmd_details *)0);
  #line 148 
  return status;
}

#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ddp.c"
static enum i40e_status_code i40e_del_pinfo(struct i40e_hw *hw, struct i40e_profile_segment *profile, u8 *profile_info_sec, u32 track_id)
{
  #line 164 
  struct i40e_profile_section_header *sec;
  #line 165 
  struct i40e_profile_info *pinfo;
  #line 166 
  i40e_status status;
  #line 167 
  u32 offset = 0U;
  #line 167 
  u32 info = 0U;
  #line 169 
  sec = (struct i40e_profile_section_header *)profile_info_sec;
  #line 170 
  sec->tbl_size = (unsigned short)1U;
  #line 171 
  sec->data_end = (unsigned short)64U;
  #line 173 
  sec->section.type = 16U;
  #line 174 
  sec->section.offset = 16U;
  #line 175 
  sec->section.size = 48U;
  #line 176 
  pinfo = (struct i40e_profile_info *)(profile_info_sec + (unsigned long)sec->section.offset);
  #line 178 
  pinfo->track_id = track_id;
  #line 179 
  pinfo->version = profile->version;
  #line 180 
  pinfo->op = (unsigned char)2U;
  #line 183 
  memset((void *)(& pinfo->reserved),0,7UL);
  #line 184 
  memcpy((void *)(& pinfo->name),(void *)(& profile->name),32UL);
  #line 186 
  status = i40e_aq_write_ddp(hw,(void *)sec,(unsigned short)((int)sec->data_end),track_id,& offset,& info,(struct i40e_asq_cmd_details *)0);
  #line 188 
  return status;
}

#line 201  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ddp.c"
static bool i40e_ddp_is_pkg_hdr_valid(struct net_device *netdev, struct i40e_package_header *pkg_hdr, size_t size_huge)
{
  #line 206 
  u32 pkg_hdr_size;
  #line 207 
  u32 segment;
  #line 205 
  u32 size = (unsigned int)size_huge;
  #line 209 
  if (pkg_hdr == (struct i40e_package_header *)0) 
                                                  #line 210 
                                                  return (_Bool)0;
  #line 212 
  if ((unsigned int)pkg_hdr->version.major != 0U) {
    #line 213 
    struct i40e_ddp_version ver = pkg_hdr->version;
    #line 215 
    netdev_err(netdev,(char *)"Unsupported DDP profile version %u.%u.%u.%u",(int)ver.major,(int)ver.minor,(int)ver.update,(int)ver.draft);
    #line 217 
    return (_Bool)0;
  }
  #line 219 
  if ((unsigned long)size < size_huge) {
    #line 220 
    netdev_err(netdev,(char *)"Invalid DDP profile - size is bigger than 4G");
    #line 221 
    return (_Bool)0;
  }
  #line 223 
  if (size <= 103U) {
    #line 225 
    netdev_err(netdev,(char *)"Invalid DDP profile - size is too small.");
    #line 226 
    return (_Bool)0;
  }
  #line 229 
  pkg_hdr_size = (pkg_hdr->segment_count + 2U) * 4U;
  #line 230 
  if (size < pkg_hdr_size) {
    #line 231 
    netdev_err(netdev,(char *)"Invalid DDP profile - too many segments");
    #line 232 
    return (_Bool)0;
  }
  #line 234 
  segment = 0U;
  #line 234 
  while (pkg_hdr->segment_count > segment) {
    {
      #line 235 
      u32 offset = pkg_hdr->segment_offset[segment];
      #line 237 
      if ((offset & 15U) != 0U) {
        #line 238 
        netdev_err(netdev,(char *)"Invalid DDP profile %u segment alignment",segment);
        #line 241 
        return (_Bool)0;
      }
      #line 243 
      if (pkg_hdr_size > offset || offset >= size) {
        #line 244 
        netdev_err(netdev,(char *)"Invalid DDP profile %u segment offset",segment);
        #line 247 
        return (_Bool)0;
      }
    }
    #line 234 
    segment ++;
  }
  #line 251 
  return (_Bool)1;
}

#line 264  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ddp.c"
int i40e_ddp_load(struct net_device *netdev, u8 *data, size_t size, bool is_add)
{
  #line 268 
  u8 profile_info_sec[64U];
  #line 269 
  struct i40e_metadata_segment *metadata_hdr;
  #line 270 
  struct i40e_profile_segment *profile_hdr;
  #line 271 
  struct i40e_profile_info pinfo;
  #line 272 
  struct i40e_package_header *pkg_hdr;
  #line 273 
  i40e_status status;
  #line 277 
  u32 track_id;
  #line 278 
  int istatus;
  #line 274 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 275 
  struct i40e_vsi *vsi = np->vsi;
  #line 276 
  struct i40e_pf *pf = vsi->back;
  #line 280 
  pkg_hdr = (struct i40e_package_header *)data;
  #line 281 
  if (! i40e_ddp_is_pkg_hdr_valid(netdev,pkg_hdr,size)) 
                                                        #line 282 
                                                        return -22;
  #line 284 
  if (size <= 103UL) {
    #line 286 
    netdev_err(netdev,(char *)"Invalid DDP recipe size.");
    #line 287 
    return -22;
  }
  #line 291 
  metadata_hdr = (struct i40e_metadata_segment *)i40e_find_segment_in_package(1U,pkg_hdr);
  #line 293 
  if (metadata_hdr == (struct i40e_metadata_segment *)0) {
    #line 294 
    netdev_err(netdev,(char *)"Failed to find metadata segment in DDP recipe.");
    #line 295 
    return -22;
  }
  #line 298 
  track_id = metadata_hdr->track_id;
  #line 299 
  profile_hdr = (struct i40e_profile_segment *)i40e_find_segment_in_package(17U,pkg_hdr);
  #line 301 
  if (profile_hdr == (struct i40e_profile_segment *)0) {
    #line 302 
    netdev_err(netdev,(char *)"Failed to find profile segment in DDP recipe.");
    #line 303 
    return -22;
  }
  #line 306 
  pinfo.track_id = track_id;
  #line 307 
  pinfo.version = profile_hdr->version;
  #line 308 
  if ((int)is_add != 0) 
                        #line 309 
                        pinfo.op = (unsigned char)1U; else 
                                                           #line 311 
                                                           pinfo.op = (unsigned char)2U;
  #line 313 
  memcpy((void *)(& pinfo.name),(void *)(& profile_hdr->name),32UL);
  #line 316 
  istatus = i40e_ddp_does_profile_exist(& pf->hw,& pinfo);
  #line 317 
  if (istatus < 0) {
    #line 318 
    netdev_err(netdev,(char *)"Failed to fetch loaded profiles.");
    #line 319 
    return istatus;
  }
  #line 321 
  if ((int)is_add != 0) {
    #line 322 
    if (istatus > 0) {
      #line 323 
      netdev_err(netdev,(char *)"DDP profile already loaded.");
      #line 324 
      return -22;
    }
    #line 326 
    istatus = i40e_ddp_does_profile_overlap(& pf->hw,& pinfo);
    #line 327 
    if (istatus < 0) {
      #line 328 
      netdev_err(netdev,(char *)"Failed to fetch loaded profiles.");
      #line 329 
      return istatus;
    }
    #line 331 
    if (istatus > 0) {
      #line 332 
      netdev_err(netdev,(char *)"DDP profile overlaps with existing one.");
      #line 333 
      return -22;
    }
  }
  else 
    #line 336 
    if (istatus == 0) {
      #line 337 
      netdev_err(netdev,(char *)"DDP profile for deletion does not exist.");
      #line 339 
      return -22;
    }
  #line 344 
  if ((int)is_add != 0) {
    #line 345 
    status = i40e_write_profile(& pf->hw,profile_hdr,track_id);
    #line 346 
    if (status != I40E_SUCCESS) {
      #line 347 
      if (status == I40E_ERR_DEVICE_NOT_SUPPORTED) {
        #line 348 
        netdev_err(netdev,(char *)"Profile is not supported by the device.");
        #line 350 
        return -1;
      }
      #line 352 
      netdev_err(netdev,(char *)"Failed to write DDP profile.");
      #line 353 
      return -5;
    }
  }
  else {
    #line 356 
    status = i40e_rollback_profile(& pf->hw,profile_hdr,track_id);
    #line 357 
    if (status != I40E_SUCCESS) {
      #line 358 
      netdev_err(netdev,(char *)"Failed to remove DDP profile.");
      #line 359 
      return -5;
    }
  }
  #line 364 
  if ((int)is_add != 0) {
    #line 365 
    status = i40e_add_pinfo(& pf->hw,profile_hdr,(u8 *)(& profile_info_sec),track_id);
    #line 367 
    if (status != I40E_SUCCESS) {
      #line 368 
      netdev_err(netdev,(char *)"Failed to add DDP profile info.");
      #line 369 
      return -5;
    }
  }
  else {
    #line 372 
    status = i40e_del_pinfo(& pf->hw,profile_hdr,(u8 *)(& profile_info_sec),track_id);
    #line 374 
    if (status != I40E_SUCCESS) {
      #line 375 
      netdev_err(netdev,(char *)"Failed to restore DDP profile info.");
      #line 376 
      return -5;
    }
  }
  #line 380 
  return 0;
}

#line 390  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ddp.c"
static int i40e_ddp_restore(struct i40e_pf *pf)
{
  #line 392 
  struct i40e_ddp_old_profile_list *entry;
  #line 393 
  struct net_device *netdev = (*(pf->vsi + (unsigned long)pf->lan_vsi))->netdev;
  #line 394 
  int status = 0;
  #line 396 
  if (list_empty_0(& pf->ddp_old_prof) == 0) {
    #line 397 
    void *__mptr;
    #line 397 
    __mptr = (void *)pf->ddp_old_prof.next;
    #line 397 
    entry = ((struct i40e_ddp_old_profile_list *)__mptr);
    #line 400 
    status = i40e_ddp_load(netdev,(u8 *)(& entry->old_ddp_buf),entry->old_ddp_size,(_Bool)0);
    #line 402 
    list_del_0(& entry->list);
    #line 403 
    kfree((void *)entry);
  }
  #line 405 
  return status;
}

#line 415  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ddp.c"
int i40e_ddp_flash(struct net_device *netdev, struct ethtool_flash *flash)
{
  #line 417 
  struct firmware *ddp_config;
  #line 418 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 419 
  struct i40e_vsi *vsi = np->vsi;
  #line 420 
  struct i40e_pf *pf = vsi->back;
  #line 421 
  int status = 0;
  #line 424 
  if (flash->region != 100U) {
    #line 425 
    netdev_err(netdev,(char *)"Requested firmware region is not recognized by this driver.");
    #line 426 
    return -22;
  }
  #line 428 
  if ((unsigned int)pf->hw.bus.func != 0U) {
    #line 429 
    netdev_err(netdev,(char *)"Any DDP operation is allowed only on Phy0 NIC interface");
    #line 430 
    return -22;
  }
  #line 436 
  if (cif_strncmp((char *)(& flash->data),(char *)"-",2UL) != 0) {
    #line 437 
    struct i40e_ddp_old_profile_list *list_entry;
    #line 439 
    char profile_name[80U];
    #line 441 
    profile_name[79UL] = (char)0;
    #line 442 
    strncpy((char *)(& profile_name),(char *)"intel/i40e/ddp/",79UL);
    #line 444 
    strncat((char *)(& profile_name),(char *)(& flash->data),64UL);
    #line 446 
    status = cif_request_firmware(& ddp_config,(char *)(& profile_name),& netdev->dev);
    #line 448 
    if (status != 0) {
      #line 449 
      netdev_err(netdev,(char *)"DDP recipe file request failed.");
      #line 450 
      return status;
    }
    #line 453 
    status = i40e_ddp_load(netdev,ddp_config->data,ddp_config->size,(_Bool)1);
    #line 456 
    if (status == 0) {
      #line 458 
      list_entry = (struct i40e_ddp_old_profile_list *)kzalloc_2(ddp_config->size + 24UL,3264U);
      #line 460 
      if (list_entry == (struct i40e_ddp_old_profile_list *)0) {
        #line 461 
        netdev_info(netdev,(char *)"Failed to allocate memory for previous DDP profile data.");
        #line 462 
        netdev_info(netdev,(char *)"New profile loaded but roll-back will be impossible.");
      }
      else {
        #line 464 
        memcpy((void *)(& list_entry->old_ddp_buf),(void *)ddp_config->data,ddp_config->size);
        #line 466 
        list_entry->old_ddp_size = ddp_config->size;
        #line 467 
        list_add(& list_entry->list,& pf->ddp_old_prof);
      }
    }
    #line 471 
    cif_release_firmware(ddp_config);
  }
  else {
    #line 473 
    if (list_empty_0(& pf->ddp_old_prof) == 0) 
                                               #line 474 
                                               status = i40e_ddp_restore(pf);
    else {
      #line 476 
      netdev_warn(netdev,(char *)"There is no DDP profile to restore.");
      #line 477 
      status = -2;
    }
  }
  #line 480 
  return status;
}

#line 141  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ddp.i.aux"
static int cif_strncmp(char *cs, char *ct, __kernel_size_t count)
{
  #line 144 
  return ldv_strncmp(cs,ct,count);
}

#line 428  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ddp.i.aux"
static void *kzalloc_2(size_t size, gfp_t flags)
{
  #line 431 
  return ldv_kzalloc(size,flags);
}

#line 831  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ddp.i.aux"
static int cif_request_firmware(struct firmware **fw, char *name, struct device *device)
{
  #line 834 
  return ldv_request_firmware(fw);
}

#line 838  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ddp.i.aux"
static void cif_release_firmware(struct firmware *fw)
{
  #line 841 
  ldv_release_firmware(fw);
  #line 842 
  return;
}

#line 26  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_nvm.i.aux"
#line 799 
static void cif_mutex_lock_arq_mutex_of_i40e_adminq_info(struct mutex *lock);
#line 185  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mutex.h"
#line 806  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_nvm.i.aux"
static void cif_mutex_unlock_arq_mutex_of_i40e_adminq_info(struct mutex *lock);
#line 318  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 333  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
enum i40e_status_code i40e_read_nvm_module_data(struct i40e_hw *hw, u8 module_ptr, u16 module_offset, u16 data_offset, u16 words_data_size, u16 *data_ptr);
#line 324  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_read_nvm_buffer(struct i40e_hw *hw, u16 offset, u16 *words, u16 *data);
#line 326  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 678  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_update_nvm_checksum(struct i40e_hw *hw);
#line 329  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 809  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_nvmupd_command(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno);
#line 332  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1257  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
void i40e_nvmupd_check_wait_event(struct i40e_hw *hw, u16 opcode, struct i40e_aq_desc *desc);
#line 334  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1220  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
void i40e_nvmupd_clear_wait_state(struct i40e_hw *hw);
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_init_nvm(struct i40e_hw *hw)
{
  #line 20 
  u32 fla;
  #line 20 
  u32 gens;
  #line 21 
  u8 sr_size;
  #line 18 
  struct i40e_nvm_info *nvm = & hw->nvm;
  #line 19 
  i40e_status ret_code = 0;
  #line 26 
  gens = readl((void *)(hw->hw_addr + 745728U));
  #line 27 
  sr_size = (unsigned char)((unsigned int)((unsigned char)(gens >> 5)) & 7U);
  #line 30 
  nvm->sr_size = (unsigned short)(512UL << (int)sr_size);
  #line 33 
  fla = readl((void *)(hw->hw_addr + 745736U));
  #line 34 
  if ((fla & 64U) != 0U) {
    #line 36 
    nvm->timeout = 18000U;
    #line 37 
    nvm->blank_nvm_mode = (_Bool)0;
  }
  else {
    #line 39 
    nvm->blank_nvm_mode = (_Bool)1;
    #line 40 
    ret_code = I40E_ERR_NVM_BLANK_MODE;
    #line 41 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 41 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
  }
  #line 44 
  return ret_code;
}

#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_acquire_nvm(struct i40e_hw *hw, enum i40e_aq_resource_access_type access)
{
  #line 59 
  u64 gtime;
  #line 59 
  u64 timeout;
  #line 58 
  i40e_status ret_code = 0;
  #line 60 
  u64 time_left = 0ULL;
  #line 62 
  if ((int)hw->nvm.blank_nvm_mode != 0) 
                                        #line 63 
                                        goto i40e_i40e_acquire_nvm_exit;
  #line 65 
  ret_code = i40e_aq_request_resource(hw,(enum i40e_aq_resources_ids)I40E_NVM_RESOURCE_ID,access,(unsigned char)0,& time_left,(struct i40e_asq_cmd_details *)0);
  #line 68 
  gtime = (unsigned long long)readl((void *)(hw->hw_addr + 557500U));
  #line 71 
  hw->nvm.hw_semaphore_timeout = time_left * 1000ULL + gtime;
  #line 73 
  if (ret_code != I40E_SUCCESS) 
    #line 74 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 74 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(unsigned int)access,time_left,(int)ret_code,(unsigned int)hw->aq.asq_last_status);
  #line 78 
  if (ret_code != I40E_SUCCESS && time_left != 0ULL) {
    #line 80 
    timeout = gtime + 18000000ULL;
    #line 81 
    while (gtime < timeout && time_left != 0ULL) {
      #line 82 
      usleep_range(10000UL,20000UL);
      #line 83 
      gtime = (unsigned long long)readl((void *)(hw->hw_addr + 557500U));
      #line 84 
      ret_code = i40e_aq_request_resource(hw,(enum i40e_aq_resources_ids)I40E_NVM_RESOURCE_ID,access,(unsigned char)0,& time_left,(struct i40e_asq_cmd_details *)0);
      #line 88 
      if (ret_code == I40E_SUCCESS) {
        #line 89 
        hw->nvm.hw_semaphore_timeout = time_left * 1000ULL + gtime;
        #line 91 
        break;
      }
    }
    #line 94 
    if (ret_code != I40E_SUCCESS) {
      #line 95 
      hw->nvm.hw_semaphore_timeout = 0ULL;
      #line 96 
      if ((hw->debug_mask & 128U) != 0U) 
                                         #line 96 
                                         printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,time_left,(int)ret_code,(unsigned int)hw->aq.asq_last_status);
    }
  }
  #line 102 
  i40e_i40e_acquire_nvm_exit: 
                              #line 102 
  ;
  #line 103 
  return ret_code;
}

#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
void i40e_release_nvm(struct i40e_hw *hw)
{
  #line 114 
  i40e_status ret_code = 0;
  #line 115 
  u32 total_delay = 0U;
  #line 117 
  if ((int)hw->nvm.blank_nvm_mode != 0) 
                                        #line 118 
                                        return;
  #line 120 
  ret_code = i40e_aq_release_resource(hw,(enum i40e_aq_resources_ids)I40E_NVM_RESOURCE_ID,(unsigned char)0,(struct i40e_asq_cmd_details *)0);
  #line 125 
  while (ret_code == I40E_ERR_ADMIN_QUEUE_TIMEOUT && hw->aq.asq_cmd_timeout > total_delay) {
    #line 127 
    usleep_range(1000UL,2000UL);
    #line 128 
    ret_code = i40e_aq_release_resource(hw,(enum i40e_aq_resources_ids)I40E_NVM_RESOURCE_ID,(unsigned char)0,(struct i40e_asq_cmd_details *)0);
    #line 131 
    total_delay ++;
  }
  #line 133 
  return;
}

#line 141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_poll_sr_srctl_done_bit(struct i40e_hw *hw)
{
  #line 144 
  u32 srctl;
  #line 144 
  u32 wait_cnt;
  #line 143 
  i40e_status ret_code = -37;
  #line 147 
  wait_cnt = 0U;
  #line 147 
  while (wait_cnt <= 99999U) {
    #line 148 
    srctl = readl((void *)(hw->hw_addr + 745744U));
    #line 149 
    if ((srctl & 2147483648U) != 0U) {
      #line 150 
      ret_code = I40E_SUCCESS;
      #line 151 
      break;
    }
    #line 153 
    __const_udelay(21475UL);
    #line 147 
    wait_cnt ++;
  }
  #line 155 
  if (ret_code == I40E_ERR_TIMEOUT) 
    #line 156 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 156 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
  #line 157 
  return ret_code;
}

#line 168  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_read_nvm_word_srctl(struct i40e_hw *hw, u16 offset, u16 *data)
{
  #line 172 
  u32 sr_reg;
  #line 171 
  i40e_status ret_code = -37;
  #line 174 
  if ((int)hw->nvm.sr_size <= (int)offset) {
    #line 175 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 175 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)offset,(int)hw->nvm.sr_size);
    #line 178 
    ret_code = I40E_ERR_PARAM;
    #line 179 
    goto read_nvm_exit;
  }
  #line 183 
  ret_code = i40e_poll_sr_srctl_done_bit(hw);
  #line 184 
  if (ret_code == I40E_SUCCESS) {
    #line 186 
    sr_reg = ((unsigned int)offset << 14) | 1073741824U;
    #line 188 
    writel(sr_reg,(void *)(hw->hw_addr + 745744U));
    #line 191 
    ret_code = i40e_poll_sr_srctl_done_bit(hw);
    #line 192 
    if (ret_code == I40E_SUCCESS) {
      #line 193 
      sr_reg = readl((void *)(hw->hw_addr + 745748U));
      #line 194 
      *data = (unsigned short)(sr_reg >> 16);
    }
  }
  #line 199 
  if (ret_code != I40E_SUCCESS) 
    #line 200 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 200 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)offset);
  #line 204 
  read_nvm_exit: 
                 #line 204 
  ;
  #line 205 
  return ret_code;
}

#line 219  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_read_nvm_aq(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 words, void *data, bool last_command)
{
  #line 225 
  struct i40e_asq_cmd_details cmd_details;
  #line 224 
  i40e_status ret_code = -1;
  #line 227 
  memset((void *)(& cmd_details),0,32UL);
  #line 228 
  cmd_details.wb_desc = & hw->nvm_wb_desc;
  #line 235 
  if ((unsigned int)words + offset > (unsigned int)hw->nvm.sr_size) {
    #line 236 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 236 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(unsigned int)words + offset,(int)hw->nvm.sr_size);
  }
  else 
    #line 239 
    if ((unsigned int)words > 2048U) {
      #line 241 
      if ((hw->debug_mask & 128U) != 0U) 
                                         #line 241 
                                         printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)words,2048);
    }
    else 
      #line 244 
      if ((((unsigned int)words + offset) + 4294967295U) / 2048U != offset / 2048U) {
        #line 247 
        if ((hw->debug_mask & 128U) != 0U) 
                                           #line 247 
                                           printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,offset,(int)words);
      }
      else 
           #line 251 
           ret_code = i40e_aq_read_nvm(hw,(unsigned char)((int)module_pointer),offset * 2U,(unsigned short)((int)((unsigned int)words * 2U)),data,(_Bool)((bool)((int)last_command) != 0),& cmd_details);
  #line 256 
  return ret_code;
}

#line 267  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_read_nvm_word_aq(struct i40e_hw *hw, u16 offset, u16 *data)
{
  #line 270 
  i40e_status ret_code = -37;
  #line 272 
  ret_code = i40e_read_nvm_aq(hw,(unsigned char)0,(unsigned int)offset,(unsigned short)1,(void *)data,(_Bool)1);
  #line 273 
  *data = *data;
  #line 275 
  return ret_code;
}

#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status __i40e_read_nvm_word(struct i40e_hw *hw, u16 offset, u16 *data)
{
  #line 292 
  if ((hw->flags & 1ULL) != 0ULL) {
    #line 293 
    return i40e_read_nvm_word_aq(hw,(unsigned short)((int)offset),data);
  }
  #line 295 
  return i40e_read_nvm_word_srctl(hw,(unsigned short)((int)offset),data);
}

#line 306  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_read_nvm_word(struct i40e_hw *hw, u16 offset, u16 *data)
{
  #line 309 
  i40e_status ret_code = 0;
  #line 311 
  if ((hw->flags & 8ULL) != 0ULL) 
                                  #line 312 
                                  ret_code = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
  #line 313 
  if (ret_code != I40E_SUCCESS) 
                                #line 314 
                                return ret_code;
  #line 316 
  ret_code = __i40e_read_nvm_word(hw,(unsigned short)((int)offset),data);
  #line 318 
  if ((hw->flags & 8ULL) != 0ULL) 
                                  #line 319 
                                  i40e_release_nvm(hw);
  #line 321 
  return ret_code;
}

#line 333  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
enum i40e_status_code i40e_read_nvm_module_data(struct i40e_hw *hw, u8 module_ptr, u16 module_offset, u16 data_offset, u16 words_data_size, u16 *data_ptr)
{
  #line 340 
  i40e_status status;
  #line 341 
  u16 specific_ptr = (unsigned short)0U;
  #line 342 
  u16 ptr_value = (unsigned short)0U;
  #line 343 
  u32 offset = 0U;
  #line 345 
  if ((unsigned int)module_ptr != 0U) {
    #line 346 
    status = i40e_read_nvm_word(hw,(unsigned short)((int)module_ptr),& ptr_value);
    #line 347 
    if (status != I40E_SUCCESS) {
      #line 348 
      if (hw->debug_mask != 0U) 
                                #line 348 
                                printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)status);
      #line 351 
      return I40E_ERR_NVM;
    }
  }
  #line 358 
  if ((unsigned int)ptr_value == 32767U || (unsigned int)ptr_value == 65535U) {
    #line 360 
    if (hw->debug_mask != 0U) 
                              #line 360 
                              printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
    #line 361 
    return I40E_ERR_BAD_PTR;
  }
  #line 365 
  if (((unsigned long)ptr_value & 32768UL) != 0UL) {
    #line 367 
    if (hw->debug_mask != 0U) 
                              #line 367 
                              printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
    #line 370 
    return I40E_ERR_PARAM;
  }
  else {
    #line 374 
    status = i40e_read_nvm_word(hw,(unsigned short)((int)ptr_value + (int)module_offset),& specific_ptr);
    #line 376 
    if (status != I40E_SUCCESS) {
      #line 377 
      if (hw->debug_mask != 0U) 
                                #line 377 
                                printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)status);
      #line 380 
      return I40E_ERR_NVM;
    }
    #line 383 
    offset = (unsigned int)((((int)ptr_value + (int)module_offset) + (int)specific_ptr) + (int)data_offset);
    #line 386 
    status = i40e_read_nvm_buffer(hw,(unsigned short)((int)((unsigned short)offset)),& words_data_size,data_ptr);
    #line 388 
    if (status != I40E_SUCCESS) 
      #line 389 
      if (hw->debug_mask != 0U) 
                                #line 389 
                                printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)status);
  }
  #line 395 
  return status;
}

#line 409  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_read_nvm_buffer_srctl(struct i40e_hw *hw, u16 offset, u16 *words, u16 *data)
{
  #line 413 
  u16 index;
  #line 413 
  u16 word;
  #line 412 
  i40e_status ret_code = 0;
  #line 416 
  word = (unsigned short)0U;
  #line 416 
  while ((int)*words > (int)word) {
    #line 417 
    index = (unsigned short)((int)offset + (int)word);
    #line 418 
    ret_code = i40e_read_nvm_word_srctl(hw,(unsigned short)((int)index),data + (unsigned long)word);
    #line 419 
    if (ret_code != I40E_SUCCESS) 
                                  #line 420 
                                  break;
    #line 416 
    word = (u16)((int)word + 1);
  }
  #line 424 
  *words = word;
  #line 426 
  return ret_code;
}

#line 440  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_read_nvm_buffer_aq(struct i40e_hw *hw, u16 offset, u16 *words, u16 *data)
{
  #line 443 
  i40e_status ret_code;
  #line 444 
  u16 read_size;
  #line 445 
  bool last_cmd = (_Bool)0;
  #line 446 
  u16 words_read = (unsigned short)0U;
  #line 447 
  u16 i = (unsigned short)0U;
  #line 449 
  while (1) {
    #line 454 
    if (((unsigned int)offset & 2047U) != 0U) {
      #line 455 
      int tmp;
      #line 455 
      u16 __UNIQUE_ID___x534;
      {
        #line 455 
        __UNIQUE_ID___x534 = *words;
        #line 455 
        unsigned short __UNIQUE_ID___y535 = (unsigned short)(2048U - ((unsigned int)offset & 2047U));
        #line 455 
        if ((int)__UNIQUE_ID___x534 < (int)__UNIQUE_ID___y535) 
                                                               #line 455 
                                                               tmp = (int)__UNIQUE_ID___x534; else 
                                                                    #line 455 
                                                                    tmp = (int)__UNIQUE_ID___y535;
        }
      #line 455 
      read_size = (unsigned short)tmp;
    }
    else {
      #line 459 
      int __UNIQUE_ID___x536;
      #line 459 
      int tmp_1;
      {
        #line 459 
        __UNIQUE_ID___x536 = (int)*words - (int)words_read;
        #line 459 
        int __UNIQUE_ID___y537 = 2048;
        #line 459 
        if (__UNIQUE_ID___x536 < __UNIQUE_ID___y537) 
                                                     #line 459 
                                                     tmp_1 = __UNIQUE_ID___x536; else 
                                                                    #line 459 
                                                                    tmp_1 = __UNIQUE_ID___y537;
        }
      #line 459 
      read_size = (unsigned short)tmp_1;
    }
    #line 463 
    if ((int)words_read + (int)read_size >= (int)*words) 
                                                         #line 464 
                                                         last_cmd = (_Bool)1;
    #line 466 
    ret_code = i40e_read_nvm_aq(hw,(unsigned char)0,(unsigned int)offset,(unsigned short)((int)read_size),(void *)(data + (unsigned long)words_read),(_Bool)((bool)((int)last_cmd) != 0));
    #line 468 
    if (ret_code != I40E_SUCCESS) 
                                  #line 469 
                                  goto read_nvm_buffer_aq_exit;
    #line 474 
    words_read = (unsigned short)((int)words_read + (int)read_size);
    #line 475 
    offset = (unsigned short)((int)offset + (int)read_size);
    #line 476 
    if (! ((int)*words > (int)words_read)) 
                                           #line 449 
                                           break;
  }
  #line 478 
  i = (unsigned short)0U;
  #line 478 
  while ((int)*words > (int)i) {
    #line 479 
    *(data + (unsigned long)i) = *(data + (unsigned long)i);
    #line 478 
    i = (u16)((int)i + 1);
  }
  #line 481 
  read_nvm_buffer_aq_exit: 
                           #line 481 
  ;
  #line 482 
  *words = words_read;
  #line 483 
  return ret_code;
}

#line 496  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status __i40e_read_nvm_buffer(struct i40e_hw *hw, u16 offset, u16 *words, u16 *data)
{
  #line 500 
  if ((hw->flags & 1ULL) != 0ULL) {
    #line 501 
    return i40e_read_nvm_buffer_aq(hw,(unsigned short)((int)offset),words,data);
  }
  #line 503 
  return i40e_read_nvm_buffer_srctl(hw,(unsigned short)((int)offset),words,
                                   data);
}

#line 517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_read_nvm_buffer(struct i40e_hw *hw, u16 offset, u16 *words, u16 *data)
{
  #line 520 
  i40e_status ret_code = 0;
  #line 522 
  if ((hw->flags & 1ULL) != 0ULL) {
    #line 523 
    ret_code = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
    #line 524 
    if (ret_code == I40E_SUCCESS) {
      #line 525 
      ret_code = i40e_read_nvm_buffer_aq(hw,(unsigned short)((int)offset),words,data);
      #line 527 
      i40e_release_nvm(hw);
    }
  }
  else 
       #line 530 
       ret_code = i40e_read_nvm_buffer_srctl(hw,(unsigned short)((int)offset),words,data);
  #line 533 
  return ret_code;
}

#line 547  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_write_nvm_aq(struct i40e_hw *hw, u8 module_pointer, u32 offset, u16 words, void *data, bool last_command)
{
  #line 552 
  struct i40e_asq_cmd_details cmd_details;
  #line 551 
  i40e_status ret_code = -1;
  #line 554 
  memset((void *)(& cmd_details),0,32UL);
  #line 555 
  cmd_details.wb_desc = & hw->nvm_wb_desc;
  #line 562 
  if ((unsigned int)words + offset > (unsigned int)hw->nvm.sr_size) {
    #line 563 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 563 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(unsigned int)words + offset,(int)hw->nvm.sr_size);
  }
  else 
    #line 566 
    if ((unsigned int)words > 2048U) {
      #line 568 
      if ((hw->debug_mask & 128U) != 0U) 
                                         #line 568 
                                         printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)words,2048);
    }
    else 
      #line 571 
      if ((((unsigned int)words + offset) + 4294967295U) / 2048U != offset / 2048U) {
        #line 574 
        if ((hw->debug_mask & 128U) != 0U) 
                                           #line 574 
                                           printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,offset,(int)words);
      }
      else 
           #line 578 
           ret_code = i40e_aq_update_nvm(hw,(unsigned char)((int)module_pointer),offset * 2U,(unsigned short)((int)((unsigned int)words * 2U)),data,(_Bool)((bool)((int)last_command) != 0),(unsigned char)0,& cmd_details);
  #line 584 
  return ret_code;
}

#line 597  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_calc_nvm_checksum(struct i40e_hw *hw, u16 *checksum)
{
  #line 600 
  i40e_status ret_code;
  #line 601 
  struct i40e_virt_mem vmem;
  #line 605 
  u16 *data;
  #line 602 
  u16 pcie_alt_module = (unsigned short)0U;
  #line 603 
  u16 checksum_local = (unsigned short)0U;
  #line 604 
  u16 vpd_module = (unsigned short)0U;
  #line 606 
  u16 i = (unsigned short)0U;
  #line 608 
  ret_code = i40e_allocate_virt_mem_d(hw,& vmem,4096U);
  #line 610 
  if (ret_code != I40E_SUCCESS) 
                                #line 611 
                                goto i40e_calc_nvm_checksum_exit;
  #line 612 
  data = (u16 *)vmem.va;
  #line 615 
  ret_code = __i40e_read_nvm_word(hw,(unsigned short)47,& vpd_module);
  #line 616 
  if (ret_code != I40E_SUCCESS) {
    #line 617 
    ret_code = I40E_ERR_NVM_CHECKSUM;
    #line 618 
    goto i40e_calc_nvm_checksum_exit;
  }
  #line 622 
  ret_code = __i40e_read_nvm_word(hw,(unsigned short)62,& pcie_alt_module);
  #line 624 
  if (ret_code != I40E_SUCCESS) {
    #line 625 
    ret_code = I40E_ERR_NVM_CHECKSUM;
    #line 626 
    goto i40e_calc_nvm_checksum_exit;
  }
  #line 632 
  i = (unsigned short)0U;
  #line 632 
  while ((int)hw->nvm.sr_size > (int)i) {
    #line 634 
    if (((unsigned int)i & 2047U) == 0U) {
      #line 635 
      u16 words = (unsigned short)2048U;
      #line 637 
      ret_code = __i40e_read_nvm_buffer(hw,(unsigned short)((int)i),& words,data);
      #line 638 
      if (ret_code != I40E_SUCCESS) {
        #line 639 
        ret_code = I40E_ERR_NVM_CHECKSUM;
        #line 640 
        goto i40e_calc_nvm_checksum_exit;
      }
    }
    #line 645 
    if ((unsigned int)i == 63U) 
                                #line 646 
                                goto __Cont;
    #line 648 
    if ((int)i >= (int)vpd_module && (unsigned int)i < (unsigned int)vpd_module + 512U) 
      #line 651 
      goto __Cont;
    #line 654 
    if ((int)i >= (int)pcie_alt_module && (unsigned int)i < (unsigned int)pcie_alt_module + 512U) 
      #line 657 
      goto __Cont;
    #line 660 
    checksum_local = (unsigned short)((int)*(data + ((unsigned long)i & (unsigned long)2047U)) + (int)checksum_local);
    #line 632 
    __Cont: 
            #line 632 
    i = (u16)((int)i + 1);
  }
  #line 663 
  *checksum = (unsigned short)(47802U - (unsigned int)checksum_local);
  #line 665 
  i40e_calc_nvm_checksum_exit: 
                               #line 665 
  ;
  #line 666 
  i40e_free_virt_mem_d(hw,& vmem);
  #line 667 
  return ret_code;
}

#line 678  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_update_nvm_checksum(struct i40e_hw *hw)
{
  #line 680 
  i40e_status ret_code;
  #line 681 
  u16 checksum;
  #line 682 
  __le16 le_sum;
  #line 684 
  ret_code = i40e_calc_nvm_checksum(hw,& checksum);
  #line 685 
  le_sum = checksum;
  #line 686 
  if (ret_code == I40E_SUCCESS) 
                                #line 687 
                                ret_code = i40e_write_nvm_aq(hw,(unsigned char)0,63U,(unsigned short)1,(void *)(& le_sum),(_Bool)1);
  #line 690 
  return ret_code;
}

#line 701  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_validate_nvm_checksum(struct i40e_hw *hw, u16 *checksum)
{
  #line 704 
  i40e_status ret_code = 0;
  #line 705 
  u16 checksum_sr = (unsigned short)0U;
  #line 706 
  u16 checksum_local = (unsigned short)0U;
  #line 713 
  ret_code = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
  #line 714 
  if (ret_code != I40E_SUCCESS) 
                                #line 715 
                                return ret_code;
  #line 716 
  ret_code = i40e_calc_nvm_checksum(hw,& checksum_local);
  #line 717 
  __i40e_read_nvm_word(hw,(unsigned short)63,& checksum_sr);
  #line 718 
  i40e_release_nvm(hw);
  #line 719 
  if (ret_code != I40E_SUCCESS) 
                                #line 720 
                                return ret_code;
  #line 725 
  if ((int)checksum_local != (int)checksum_sr) 
                                               #line 726 
                                               ret_code = I40E_ERR_NVM_CHECKSUM;
  #line 729 
  if (checksum != (u16 *)0U) 
                             #line 730 
                             *checksum = checksum_local;
  #line 732 
  return ret_code;
}

#line 735 
#line 925 
static i40e_status i40e_nvmupd_state_init(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno);
#line 738 
#line 1064 
static i40e_status i40e_nvmupd_state_reading(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno);
#line 741 
#line 1106 
static i40e_status i40e_nvmupd_state_writing(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno);
#line 744 
#line 1276 
static enum i40e_nvmupd_cmd i40e_nvmupd_validate_command(struct i40e_hw *hw, struct i40e_nvm_access *cmd, int *perrno);
#line 747 
#line 1598 
static i40e_status i40e_nvmupd_nvm_erase(struct i40e_hw *hw, struct i40e_nvm_access *cmd, int *perrno);
#line 750 
#line 1638 
static i40e_status i40e_nvmupd_nvm_write(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno);
#line 753 
#line 1559 
static i40e_status i40e_nvmupd_nvm_read(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno);
#line 756 
#line 1372 
static i40e_status i40e_nvmupd_exec_aq(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno);
#line 759 
#line 1456 
static i40e_status i40e_nvmupd_get_aq_result(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno);
#line 762 
#line 1525 
static i40e_status i40e_nvmupd_get_aq_event(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno);
#line 765  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
__inline static u8 i40e_nvmupd_get_module(u32 val)
{
  #line 767 
  return (unsigned char)val;
}

#line 769  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
__inline static u8 i40e_nvmupd_get_transaction(u32 val)
{
  #line 771 
  return (unsigned char)((unsigned int)((unsigned char)(val >> 8)) & 15U);
}

#line 774  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
__inline static u8 i40e_nvmupd_get_preservation_flags(u32 val)
{
  #line 776 
  return (unsigned char)((unsigned int)((unsigned char)(val >> 12)) & 3U);
}

#line 780  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static char *i40e_nvm_update_state_str[17U] = {(char *)"I40E_NVMUPD_INVALID", (char *)"I40E_NVMUPD_READ_CON", (char *)"I40E_NVMUPD_READ_SNT", (char *)"I40E_NVMUPD_READ_LCB", (char *)"I40E_NVMUPD_READ_SA", (char *)"I40E_NVMUPD_WRITE_ERA", (char *)"I40E_NVMUPD_WRITE_CON", (char *)"I40E_NVMUPD_WRITE_SNT", (char *)"I40E_NVMUPD_WRITE_LCB", (char *)"I40E_NVMUPD_WRITE_SA", (char *)"I40E_NVMUPD_CSUM_CON", (char *)"I40E_NVMUPD_CSUM_SA", (char *)"I40E_NVMUPD_CSUM_LCB", (char *)"I40E_NVMUPD_STATUS", (char *)"I40E_NVMUPD_EXEC_AQ", (char *)"I40E_NVMUPD_GET_AQ_RESULT", (char *)"I40E_NVMUPD_GET_AQ_EVENT"};
#line 809  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
i40e_status i40e_nvmupd_command(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno)
{
  #line 813 
  i40e_status status;
  #line 814 
  enum i40e_nvmupd_cmd upd_cmd;
  #line 817 
  *perrno = 0;
  #line 820 
  upd_cmd = i40e_nvmupd_validate_command(hw,cmd,perrno);
  #line 822 
  if ((hw->debug_mask & 128U) != 0U) 
                                     #line 822 
                                     printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,i40e_nvm_update_state_str[(unsigned int)upd_cmd],(unsigned int)hw->nvmupd_state,(int)hw->nvm_release_on_done,(int)hw->nvm_wait_opcode,cmd->command,cmd->config,cmd->offset,cmd->data_size);
  #line 828 
  if (upd_cmd == (unsigned int)I40E_NVMUPD_INVALID) {
    #line 829 
    *perrno = -14;
    #line 830 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 830 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(unsigned int)upd_cmd,*perrno);
  }
  #line 838 
  if (upd_cmd == (unsigned int)I40E_NVMUPD_STATUS) {
    #line 839 
    if (cmd->data_size == 0U) {
      #line 840 
      *perrno = -14;
      #line 841 
      return I40E_ERR_BUF_TOO_SHORT;
    }
    #line 844 
    *bytes = (unsigned char)hw->nvmupd_state;
    #line 846 
    if (cmd->data_size > 3U) {
      #line 847 
      *(bytes + 1U) = (unsigned char)0U;
      #line 848 
      *((u16 *)(bytes + 2U)) = hw->nvm_wait_opcode;
    }
    #line 852 
    if (hw->nvmupd_state == (unsigned int)I40E_NVMUPD_STATE_ERROR) 
                                                                   #line 853 
                                                                   hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
    #line 855 
    return I40E_SUCCESS;
  }
  #line 859 
  if (hw->nvmupd_state == (unsigned int)I40E_NVMUPD_STATE_ERROR) {
    #line 860 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 860 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
    #line 862 
    hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
  }
  #line 873 
  cif_mutex_lock_arq_mutex_of_i40e_adminq_info(& hw->aq.arq_mutex);
  #line 874 
  switch ((unsigned int)hw->nvmupd_state) {
    #line 875 
    case (unsigned int)0: 
                          #line 875 
    ;
    #line 876 
    status = i40e_nvmupd_state_init(hw,cmd,bytes,perrno);
    #line 877 
    break;
    #line 879 
    case (unsigned int)1: 
                          #line 879 
    ;
    #line 880 
    status = i40e_nvmupd_state_reading(hw,cmd,bytes,perrno);
    #line 881 
    break;
    #line 883 
    case (unsigned int)2: 
                          #line 883 
    ;
    #line 884 
    status = i40e_nvmupd_state_writing(hw,cmd,bytes,perrno);
    #line 885 
    break;
    #line 887 
    case (unsigned int)3: 
                          #line 887 
    ;
    #line 888 
    case (unsigned int)4: 
                          #line 888 
    ;
    #line 892 
    if (cmd->offset == 65535U) {
      #line 893 
      i40e_nvmupd_clear_wait_state(hw);
      #line 894 
      status = I40E_SUCCESS;
      #line 895 
      break;
    }
    #line 898 
    status = I40E_ERR_NOT_READY;
    #line 899 
    *perrno = -16;
    #line 900 
    break;
    #line 902 
    default: 
             #line 902 
    ;
    #line 904 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 904 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(unsigned int)hw->nvmupd_state);
    #line 906 
    status = I40E_NOT_SUPPORTED;
    #line 907 
    *perrno = -3;
    #line 908 
    break;
  }
  #line 911 
  cif_mutex_unlock_arq_mutex_of_i40e_adminq_info(& hw->aq.arq_mutex);
  #line 912 
  return status;
}

#line 925  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_state_init(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno)
{
  #line 930 
  enum i40e_nvmupd_cmd upd_cmd;
  #line 929 
  i40e_status status = 0;
  #line 932 
  upd_cmd = i40e_nvmupd_validate_command(hw,cmd,perrno);
  #line 934 
  switch ((unsigned int)upd_cmd) {
    #line 935 
    case (unsigned int)4: 
                          #line 935 
    ;
    #line 936 
    status = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
    #line 937 
    if (status != I40E_SUCCESS) 
                                #line 938 
                                *perrno = i40e_aq_rc_to_posix((int)status,(int)hw->aq.asq_last_status);
    else {
      #line 941 
      status = i40e_nvmupd_nvm_read(hw,cmd,bytes,perrno);
      #line 942 
      i40e_release_nvm(hw);
    }
    #line 944 
    break;
    #line 946 
    case (unsigned int)2: 
                          #line 946 
    ;
    #line 947 
    status = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
    #line 948 
    if (status != I40E_SUCCESS) 
                                #line 949 
                                *perrno = i40e_aq_rc_to_posix((int)status,(int)hw->aq.asq_last_status);
    else {
      #line 952 
      status = i40e_nvmupd_nvm_read(hw,cmd,bytes,perrno);
      #line 953 
      if (status != I40E_SUCCESS) 
                                  #line 954 
                                  i40e_release_nvm(hw); else 
                                                             #line 956 
                                                             hw->nvmupd_state = I40E_NVMUPD_STATE_READING;
    }
    #line 958 
    break;
    #line 960 
    case (unsigned int)5: 
                          #line 960 
    ;
    #line 961 
    status = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_WRITE);
    #line 962 
    if (status != I40E_SUCCESS) 
                                #line 963 
                                *perrno = i40e_aq_rc_to_posix((int)status,(int)hw->aq.asq_last_status);
    else {
      #line 966 
      status = i40e_nvmupd_nvm_erase(hw,cmd,perrno);
      #line 967 
      if (status != I40E_SUCCESS) 
                                  #line 968 
                                  i40e_release_nvm(hw);
      else {
        #line 970 
        hw->nvm_release_on_done = (_Bool)1;
        #line 971 
        hw->nvm_wait_opcode = (unsigned short)1794U;
        #line 972 
        hw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;
      }
    }
    #line 975 
    break;
    #line 977 
    case (unsigned int)9: 
                          #line 977 
    ;
    #line 978 
    status = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_WRITE);
    #line 979 
    if (status != I40E_SUCCESS) 
                                #line 980 
                                *perrno = i40e_aq_rc_to_posix((int)status,(int)hw->aq.asq_last_status);
    else {
      #line 983 
      status = i40e_nvmupd_nvm_write(hw,cmd,bytes,perrno);
      #line 984 
      if (status != I40E_SUCCESS) 
                                  #line 985 
                                  i40e_release_nvm(hw);
      else {
        #line 987 
        hw->nvm_release_on_done = (_Bool)1;
        #line 988 
        hw->nvm_wait_opcode = (unsigned short)1795U;
        #line 989 
        hw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;
      }
    }
    #line 992 
    break;
    #line 994 
    case (unsigned int)7: 
                          #line 994 
    ;
    #line 995 
    status = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_WRITE);
    #line 996 
    if (status != I40E_SUCCESS) 
                                #line 997 
                                *perrno = i40e_aq_rc_to_posix((int)status,(int)hw->aq.asq_last_status);
    else {
      #line 1000 
      status = i40e_nvmupd_nvm_write(hw,cmd,bytes,perrno);
      #line 1001 
      if (status != I40E_SUCCESS) 
                                  #line 1002 
                                  i40e_release_nvm(hw);
      else {
        #line 1004 
        hw->nvm_wait_opcode = (unsigned short)1795U;
        #line 1005 
        hw->nvmupd_state = I40E_NVMUPD_STATE_WRITE_WAIT;
      }
    }
    #line 1008 
    break;
    #line 1010 
    case (unsigned int)11: 
                           #line 1010 
    ;
    #line 1011 
    status = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_WRITE);
    #line 1012 
    if (status != I40E_SUCCESS) 
                                #line 1013 
                                *perrno = i40e_aq_rc_to_posix((int)status,(int)hw->aq.asq_last_status);
    else {
      #line 1016 
      status = i40e_update_nvm_checksum(hw);
      #line 1017 
      if (status != I40E_SUCCESS) {
        #line 1018 
        if (hw->aq.asq_last_status != (unsigned int)I40E_AQ_RC_OK) 
                                                                   #line 1018 
                                                                   *perrno = i40e_aq_rc_to_posix((int)status,(int)hw->aq.asq_last_status); else 
                                                                    #line 1018 
                                                                    *perrno = -5;
        #line 1022 
        i40e_release_nvm(hw);
      }
      else {
        #line 1024 
        hw->nvm_release_on_done = (_Bool)1;
        #line 1025 
        hw->nvm_wait_opcode = (unsigned short)1795U;
        #line 1026 
        hw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;
      }
    }
    #line 1029 
    break;
    #line 1031 
    case (unsigned int)14: 
                           #line 1031 
    ;
    #line 1032 
    status = i40e_nvmupd_exec_aq(hw,cmd,bytes,perrno);
    #line 1033 
    break;
    #line 1035 
    case (unsigned int)15: 
                           #line 1035 
    ;
    #line 1036 
    status = i40e_nvmupd_get_aq_result(hw,cmd,bytes,perrno);
    #line 1037 
    break;
    #line 1039 
    case (unsigned int)16: 
                           #line 1039 
    ;
    #line 1040 
    status = i40e_nvmupd_get_aq_event(hw,cmd,bytes,perrno);
    #line 1041 
    break;
    #line 1043 
    default: 
             #line 1043 
    ;
    #line 1044 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1044 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,i40e_nvm_update_state_str[(unsigned int)upd_cmd]);
    #line 1047 
    status = I40E_ERR_NVM;
    #line 1048 
    *perrno = -3;
    #line 1049 
    break;
  }
  #line 1051 
  return status;
}

#line 1064  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_state_reading(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno)
{
  #line 1069 
  enum i40e_nvmupd_cmd upd_cmd;
  #line 1068 
  i40e_status status = 0;
  #line 1071 
  upd_cmd = i40e_nvmupd_validate_command(hw,cmd,perrno);
  #line 1073 
  switch ((unsigned int)upd_cmd) {
    #line 1074 
    case (unsigned int)4: 
                          #line 1074 
    ;
    #line 1075 
    case (unsigned int)1: 
                          #line 1075 
    ;
    #line 1076 
    status = i40e_nvmupd_nvm_read(hw,cmd,bytes,perrno);
    #line 1077 
    break;
    #line 1079 
    case (unsigned int)3: 
                          #line 1079 
    ;
    #line 1080 
    status = i40e_nvmupd_nvm_read(hw,cmd,bytes,perrno);
    #line 1081 
    i40e_release_nvm(hw);
    #line 1082 
    hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
    #line 1083 
    break;
    #line 1085 
    default: 
             #line 1085 
    ;
    #line 1086 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1086 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,i40e_nvm_update_state_str[(unsigned int)upd_cmd]);
    #line 1089 
    status = I40E_NOT_SUPPORTED;
    #line 1090 
    *perrno = -3;
    #line 1091 
    break;
  }
  #line 1093 
  return status;
}

#line 1106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_state_writing(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno)
{
  #line 1111 
  enum i40e_nvmupd_cmd upd_cmd;
  #line 1110 
  i40e_status status = 0;
  #line 1112 
  bool retry_attempt = (_Bool)0;
  #line 1114 
  upd_cmd = i40e_nvmupd_validate_command(hw,cmd,perrno);
  #line 1116 
  retry: 
         #line 1116 
  ;
  #line 1117 
  switch ((unsigned int)upd_cmd) {
    #line 1118 
    case (unsigned int)6: 
                          #line 1118 
    ;
    #line 1119 
    status = i40e_nvmupd_nvm_write(hw,cmd,bytes,perrno);
    #line 1120 
    if (status == I40E_SUCCESS) {
      #line 1121 
      hw->nvm_wait_opcode = (unsigned short)1795U;
      #line 1122 
      hw->nvmupd_state = I40E_NVMUPD_STATE_WRITE_WAIT;
    }
    #line 1124 
    break;
    #line 1126 
    case (unsigned int)8: 
                          #line 1126 
    ;
    #line 1127 
    status = i40e_nvmupd_nvm_write(hw,cmd,bytes,perrno);
    #line 1128 
    if (status != I40E_SUCCESS) {
      #line 1129 
      if (hw->aq.asq_last_status != (unsigned int)I40E_AQ_RC_OK) 
                                                                 #line 1129 
                                                                 *perrno = i40e_aq_rc_to_posix((int)status,(int)hw->aq.asq_last_status); else 
                                                                    #line 1129 
                                                                    *perrno = -5;
      #line 1133 
      hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
    }
    else {
      #line 1135 
      hw->nvm_release_on_done = (_Bool)1;
      #line 1136 
      hw->nvm_wait_opcode = (unsigned short)1795U;
      #line 1137 
      hw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;
    }
    #line 1139 
    break;
    #line 1141 
    case (unsigned int)10: 
                           #line 1141 
    ;
    #line 1143 
    status = i40e_update_nvm_checksum(hw);
    #line 1144 
    if (status != I40E_SUCCESS) {
      #line 1145 
      if (hw->aq.asq_last_status != (unsigned int)I40E_AQ_RC_OK) 
                                                                 #line 1145 
                                                                 *perrno = i40e_aq_rc_to_posix((int)status,(int)hw->aq.asq_last_status); else 
                                                                    #line 1145 
                                                                    *perrno = -5;
      #line 1149 
      hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
    }
    else {
      #line 1151 
      hw->nvm_wait_opcode = (unsigned short)1795U;
      #line 1152 
      hw->nvmupd_state = I40E_NVMUPD_STATE_WRITE_WAIT;
    }
    #line 1154 
    break;
    #line 1156 
    case (unsigned int)12: 
                           #line 1156 
    ;
    #line 1158 
    status = i40e_update_nvm_checksum(hw);
    #line 1159 
    if (status != I40E_SUCCESS) {
      #line 1160 
      if (hw->aq.asq_last_status != (unsigned int)I40E_AQ_RC_OK) 
                                                                 #line 1160 
                                                                 *perrno = i40e_aq_rc_to_posix((int)status,(int)hw->aq.asq_last_status); else 
                                                                    #line 1160 
                                                                    *perrno = -5;
      #line 1164 
      hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
    }
    else {
      #line 1166 
      hw->nvm_release_on_done = (_Bool)1;
      #line 1167 
      hw->nvm_wait_opcode = (unsigned short)1795U;
      #line 1168 
      hw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;
    }
    #line 1170 
    break;
    #line 1172 
    default: 
             #line 1172 
    ;
    #line 1173 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1173 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,i40e_nvm_update_state_str[(unsigned int)upd_cmd]);
    #line 1176 
    status = I40E_NOT_SUPPORTED;
    #line 1177 
    *perrno = -3;
    #line 1178 
    break;
  }
  #line 1187 
  if ((status != I40E_SUCCESS && hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_EBUSY) && ! retry_attempt) {
    #line 1191 
    u32 gtime;
    #line 1189 
    i40e_status old_status = status;
    #line 1190 
    u32 old_asq_status = hw->aq.asq_last_status;
    #line 1193 
    gtime = readl((void *)(hw->hw_addr + 557500U));
    #line 1194 
    if ((unsigned long long)gtime >= hw->nvm.hw_semaphore_timeout) {
      #line 1195 
      if (hw->debug_mask != 0U) 
                                #line 1195 
                                printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,gtime,hw->nvm.hw_semaphore_timeout);
      #line 1198 
      i40e_release_nvm(hw);
      #line 1199 
      status = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_WRITE);
      #line 1200 
      if (status != I40E_SUCCESS) {
        #line 1201 
        if (hw->debug_mask != 0U) 
                                  #line 1201 
                                  printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(unsigned int)hw->aq.asq_last_status);
        #line 1204 
        status = old_status;
        #line 1205 
        hw->aq.asq_last_status = (enum i40e_admin_queue_err)old_asq_status;
      }
      else {
        #line 1207 
        retry_attempt = (_Bool)1;
        #line 1208 
        goto retry;
      }
    }
  }
  #line 1213 
  return status;
}

#line 1220  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
void i40e_nvmupd_clear_wait_state(struct i40e_hw *hw)
{
  #line 1222 
  if ((hw->debug_mask & 128U) != 0U) 
                                     #line 1222 
                                     printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)hw->nvm_wait_opcode);
  #line 1226 
  if ((int)hw->nvm_release_on_done != 0) {
    #line 1227 
    i40e_release_nvm(hw);
    #line 1228 
    hw->nvm_release_on_done = (_Bool)0;
  }
  #line 1230 
  hw->nvm_wait_opcode = (unsigned short)0U;
  #line 1232 
  if (hw->aq.arq_last_status != (unsigned int)I40E_AQ_RC_OK) {
    #line 1233 
    hw->nvmupd_state = I40E_NVMUPD_STATE_ERROR;
    #line 1234 
    return;
  }
  #line 1237 
  switch ((unsigned int)hw->nvmupd_state) {
    #line 1238 
    case (unsigned int)3: 
                          #line 1238 
    ;
    #line 1239 
    hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
    #line 1240 
    break;
    #line 1242 
    case (unsigned int)4: 
                          #line 1242 
    ;
    #line 1243 
    hw->nvmupd_state = I40E_NVMUPD_STATE_WRITING;
    #line 1244 
    break;
    #line 1246 
    default: 
             #line 1246 
    ;
    #line 1247 
    break;
  }
  #line 1249 
  return;
}

#line 1257  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
void i40e_nvmupd_check_wait_event(struct i40e_hw *hw, u16 opcode, struct i40e_aq_desc *desc)
{
  #line 1260 
  u32 aq_desc_len = 32U;
  #line 1262 
  if ((int)hw->nvm_wait_opcode == (int)opcode) {
    #line 1263 
    memcpy((void *)(& hw->nvm_aq_event_desc),(void *)desc,(unsigned long)aq_desc_len);
    #line 1264 
    i40e_nvmupd_clear_wait_state(hw);
  }
  #line 1266 
  return;
}

#line 1276  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static enum i40e_nvmupd_cmd i40e_nvmupd_validate_command(struct i40e_hw *hw, struct i40e_nvm_access *cmd, int *perrno)
{
  #line 1280 
  enum i40e_nvmupd_cmd upd_cmd;
  #line 1281 
  u8 module;
  #line 1281 
  u8 transaction;
  #line 1284 
  upd_cmd = I40E_NVMUPD_INVALID;
  #line 1286 
  transaction = i40e_nvmupd_get_transaction(cmd->config);
  #line 1287 
  module = i40e_nvmupd_get_module(cmd->config);
  #line 1290 
  if (cmd->data_size + 4294967295U > 4095U) {
    #line 1292 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1292 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,cmd->data_size);
    #line 1295 
    *perrno = -14;
    #line 1296 
    return I40E_NVMUPD_INVALID;
  }
  #line 1299 
  switch (cmd->command) {
    #line 1300 
    case (u32)11: 
                  #line 1300 
    ;
    #line 1301 
    switch ((int)transaction) {
      #line 1302 
      case 0: 
              #line 1302 
      ;
      #line 1303 
      upd_cmd = I40E_NVMUPD_READ_CON;
      #line 1304 
      break;
      #line 1305 
      case 1: 
              #line 1305 
      ;
      #line 1306 
      upd_cmd = I40E_NVMUPD_READ_SNT;
      #line 1307 
      break;
      #line 1308 
      case 2: 
              #line 1308 
      ;
      #line 1309 
      upd_cmd = I40E_NVMUPD_READ_LCB;
      #line 1310 
      break;
      #line 1311 
      case 3: 
              #line 1311 
      ;
      #line 1312 
      upd_cmd = I40E_NVMUPD_READ_SA;
      #line 1313 
      break;
      #line 1314 
      case 15: 
               #line 1314 
      ;
      #line 1315 
      if ((unsigned int)module == 15U) 
                                       #line 1316 
                                       upd_cmd = I40E_NVMUPD_STATUS;
      else 
        #line 1317 
        if ((unsigned int)module == 0U) 
                                        #line 1318 
                                        upd_cmd = I40E_NVMUPD_GET_AQ_RESULT;
      #line 1319 
      break;
      #line 1320 
      case 14: 
               #line 1320 
      ;
      #line 1321 
      upd_cmd = I40E_NVMUPD_GET_AQ_EVENT;
      #line 1322 
      break;
    }
    #line 1324 
    break;
    #line 1326 
    case (u32)12: 
                  #line 1326 
    ;
    #line 1327 
    switch ((int)transaction) {
      #line 1328 
      case 0: 
              #line 1328 
      ;
      #line 1329 
      upd_cmd = I40E_NVMUPD_WRITE_CON;
      #line 1330 
      break;
      #line 1331 
      case 1: 
              #line 1331 
      ;
      #line 1332 
      upd_cmd = I40E_NVMUPD_WRITE_SNT;
      #line 1333 
      break;
      #line 1334 
      case 2: 
              #line 1334 
      ;
      #line 1335 
      upd_cmd = I40E_NVMUPD_WRITE_LCB;
      #line 1336 
      break;
      #line 1337 
      case 3: 
              #line 1337 
      ;
      #line 1338 
      upd_cmd = I40E_NVMUPD_WRITE_SA;
      #line 1339 
      break;
      #line 1340 
      case 4: 
              #line 1340 
      ;
      #line 1341 
      upd_cmd = I40E_NVMUPD_WRITE_ERA;
      #line 1342 
      break;
      #line 1343 
      case 8: 
              #line 1343 
      ;
      #line 1344 
      upd_cmd = I40E_NVMUPD_CSUM_CON;
      #line 1345 
      break;
      #line 1346 
      case 11: 
               #line 1346 
      ;
      #line 1347 
      upd_cmd = I40E_NVMUPD_CSUM_SA;
      #line 1348 
      break;
      #line 1349 
      case 10: 
               #line 1349 
      ;
      #line 1350 
      upd_cmd = I40E_NVMUPD_CSUM_LCB;
      #line 1351 
      break;
      #line 1352 
      case 15: 
               #line 1352 
      ;
      #line 1353 
      if ((unsigned int)module == 0U) 
                                      #line 1354 
                                      upd_cmd = I40E_NVMUPD_EXEC_AQ;
      #line 1355 
      break;
    }
    #line 1357 
    break;
  }
  #line 1360 
  return upd_cmd;
}

#line 1372  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_exec_aq(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno)
{
  #line 1406 
  unsigned int __UNIQUE_ID___x538;
  #line 1406 
  unsigned int tmp;
  #line 1376 
  struct i40e_asq_cmd_details cmd_details;
  #line 1377 
  i40e_status status;
  #line 1378 
  struct i40e_aq_desc *aq_desc;
  #line 1381 
  u32 aq_desc_len;
  #line 1382 
  u32 aq_data_len;
  #line 1379 
  u32 buff_size = 0U;
  #line 1380 
  u8 *buff = (u8 *)0U;
  #line 1384 
  if ((hw->debug_mask & 128U) != 0U) 
                                     #line 1384 
                                     printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(char *)"i40e_nvmupd_exec_aq");
  #line 1385 
  if (cmd->offset == 65535U) 
                             #line 1386 
                             return I40E_SUCCESS;
  #line 1388 
  memset((void *)(& cmd_details),0,32UL);
  #line 1389 
  cmd_details.wb_desc = & hw->nvm_wb_desc;
  #line 1391 
  aq_desc_len = 32U;
  #line 1392 
  memset((void *)(& hw->nvm_wb_desc),0,(unsigned long)aq_desc_len);
  #line 1395 
  if (cmd->data_size < aq_desc_len) {
    #line 1396 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1396 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,cmd->data_size,aq_desc_len);
    #line 1399 
    *perrno = -22;
    #line 1400 
    return I40E_ERR_PARAM;
  }
  #line 1402 
  aq_desc = (struct i40e_aq_desc *)bytes;
  #line 1405 
  aq_data_len = cmd->data_size - aq_desc_len;
  {
    #line 1406 
    __UNIQUE_ID___x538 = aq_data_len;
    #line 1406 
    unsigned int __UNIQUE_ID___y539 = (unsigned int)aq_desc->datalen;
    #line 1406 
    if (__UNIQUE_ID___x538 > __UNIQUE_ID___y539) 
                                                 #line 1406 
                                                 tmp = __UNIQUE_ID___x538; else 
                                                                    #line 1406 
                                                                    tmp = __UNIQUE_ID___y539;
    }
  #line 1406 
  buff_size = tmp;
  #line 1407 
  if (buff_size != 0U) {
    #line 1408 
    if (hw->nvm_buff.va == (void *)0) {
      #line 1409 
      status = i40e_allocate_virt_mem_d(hw,& hw->nvm_buff,(unsigned int)hw->aq.asq_buf_size);
      #line 1411 
      if (status != I40E_SUCCESS) 
        #line 1412 
        if ((hw->debug_mask & 128U) != 0U) 
                                           #line 1412 
                                           printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)status);
    }
    #line 1417 
    if (hw->nvm_buff.va != (void *)0) {
      #line 1418 
      buff = (u8 *)hw->nvm_buff.va;
      #line 1419 
      memcpy((void *)buff,(void *)(bytes + (unsigned long)aq_desc_len),(unsigned long)aq_data_len);
    }
  }
  #line 1423 
  if (cmd->offset != 0U) 
                         #line 1424 
                         memset((void *)(& hw->nvm_aq_event_desc),0,(unsigned long)aq_desc_len);
  #line 1427 
  status = i40e_asq_send_command(hw,aq_desc,(void *)buff,(unsigned short)((int)((unsigned short)buff_size)),& cmd_details);
  #line 1429 
  if (status != I40E_SUCCESS) {
    #line 1430 
    if ((hw->debug_mask & 128U) != 0U) {
      #line 1430 
      ;
      #line 1430 
      ;
      #line 1430 
      ;
      #line 1430 
      printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,i40e_stat_str(hw,status),i40e_aq_str(hw,hw->aq.asq_last_status));
    }
    #line 1434 
    *perrno = i40e_aq_rc_to_posix((int)status,(int)hw->aq.asq_last_status);
    #line 1435 
    return status;
  }
  #line 1439 
  if (cmd->offset != 0U) {
    #line 1440 
    hw->nvm_wait_opcode = (unsigned short)cmd->offset;
    #line 1441 
    hw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;
  }
  #line 1444 
  return status;
}

#line 1456  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_get_aq_result(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno)
{
  #line 1460 
  u32 aq_total_len;
  #line 1461 
  u32 aq_desc_len;
  #line 1462 
  int remainder;
  #line 1463 
  u8 *buff;
  #line 1465 
  if ((hw->debug_mask & 128U) != 0U) 
                                     #line 1465 
                                     printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(char *)"i40e_nvmupd_get_aq_result");
  #line 1467 
  aq_desc_len = 32U;
  #line 1468 
  aq_total_len = (unsigned int)hw->nvm_wb_desc.datalen + aq_desc_len;
  #line 1471 
  if (cmd->offset > aq_total_len) {
    #line 1472 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1472 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(char *)"i40e_nvmupd_get_aq_result",cmd->offset,aq_total_len);
    #line 1474 
    *perrno = -22;
    #line 1475 
    return I40E_ERR_PARAM;
  }
  #line 1479 
  if (cmd->data_size > aq_total_len - cmd->offset) {
    #line 1480 
    int new_len = (int)(aq_total_len - cmd->offset);
    #line 1482 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1482 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(char *)"i40e_nvmupd_get_aq_result",cmd->data_size,new_len);
    #line 1484 
    cmd->data_size = (unsigned int)new_len;
  }
  #line 1487 
  remainder = (int)cmd->data_size;
  #line 1488 
  if (cmd->offset < aq_desc_len) {
    #line 1491 
    u32 __UNIQUE_ID___x540;
    #line 1491 
    u32 tmp;
    #line 1489 
    u32 len = aq_desc_len - cmd->offset;
    {
      #line 1491 
      __UNIQUE_ID___x540 = len;
      #line 1491 
      u32 __UNIQUE_ID___y541 = cmd->data_size;
      #line 1491 
      if (__UNIQUE_ID___x540 < __UNIQUE_ID___y541) 
                                                   #line 1491 
                                                   tmp = __UNIQUE_ID___x540; else 
                                                                    #line 1491 
                                                                    tmp = __UNIQUE_ID___y541;
      }
    #line 1491 
    len = tmp;
    #line 1492 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1492 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(char *)"i40e_nvmupd_get_aq_result",cmd->offset,cmd->offset + len);
    #line 1495 
    buff = (u8 *)(& hw->nvm_wb_desc) + (unsigned long)cmd->offset;
    #line 1496 
    memcpy((void *)bytes,(void *)buff,(unsigned long)len);
    #line 1498 
    bytes += (unsigned long)len;
    #line 1499 
    remainder = (int)((unsigned int)remainder - len);
    #line 1500 
    buff = (u8 *)hw->nvm_buff.va;
  }
  else 
       #line 1502 
       buff = (u8 *)(hw->nvm_buff.va + (unsigned long)(cmd->offset - aq_desc_len));
  #line 1505 
  if (remainder > 0) {
    #line 1506 
    int start_byte = (int)(buff - (u8 *)hw->nvm_buff.va);
    #line 1508 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1508 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(char *)"i40e_nvmupd_get_aq_result",start_byte,start_byte + remainder);
    #line 1510 
    memcpy((void *)bytes,(void *)buff,(unsigned long)remainder);
  }
  #line 1513 
  return I40E_SUCCESS;
}

#line 1525  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_get_aq_event(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno)
{
  #line 1529 
  u32 aq_total_len;
  #line 1530 
  u32 aq_desc_len;
  #line 1532 
  if ((hw->debug_mask & 128U) != 0U) 
                                     #line 1532 
                                     printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(char *)"i40e_nvmupd_get_aq_event");
  #line 1534 
  aq_desc_len = 32U;
  #line 1535 
  aq_total_len = (unsigned int)hw->nvm_aq_event_desc.datalen + aq_desc_len;
  #line 1538 
  if (cmd->data_size > aq_total_len) {
    #line 1539 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1539 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(char *)"i40e_nvmupd_get_aq_event",cmd->data_size,aq_total_len);
    #line 1542 
    cmd->data_size = aq_total_len;
  }
  #line 1545 
  memcpy((void *)bytes,(void *)(& hw->nvm_aq_event_desc),(unsigned long)cmd->data_size);
  #line 1547 
  return I40E_SUCCESS;
}

#line 1559  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_nvm_read(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno)
{
  #line 1563 
  struct i40e_asq_cmd_details cmd_details;
  #line 1564 
  i40e_status status;
  #line 1565 
  u8 module;
  #line 1565 
  u8 transaction;
  #line 1566 
  bool last;
  #line 1568 
  transaction = i40e_nvmupd_get_transaction(cmd->config);
  #line 1569 
  module = i40e_nvmupd_get_module(cmd->config);
  #line 1570 
  last = (_Bool)((unsigned int)transaction + 254U <= 1U);
  #line 1572 
  memset((void *)(& cmd_details),0,32UL);
  #line 1573 
  cmd_details.wb_desc = & hw->nvm_wb_desc;
  #line 1575 
  status = i40e_aq_read_nvm(hw,(unsigned char)((int)module),cmd->offset,(unsigned short)((int)((unsigned short)cmd->data_size)),(void *)bytes,(_Bool)((bool)((int)last) != 0),& cmd_details);
  #line 1577 
  if (status != I40E_SUCCESS) {
    #line 1578 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1578 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)module,cmd->offset,cmd->data_size);
    #line 1581 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1581 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)status,(unsigned int)hw->aq.asq_last_status);
    #line 1584 
    *perrno = i40e_aq_rc_to_posix((int)status,(int)hw->aq.asq_last_status);
  }
  #line 1587 
  return status;
}

#line 1598  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_nvm_erase(struct i40e_hw *hw, struct i40e_nvm_access *cmd, int *perrno)
{
  #line 1603 
  struct i40e_asq_cmd_details cmd_details;
  #line 1604 
  u8 module;
  #line 1604 
  u8 transaction;
  #line 1605 
  bool last;
  #line 1602 
  i40e_status status = 0;
  #line 1607 
  transaction = i40e_nvmupd_get_transaction(cmd->config);
  #line 1608 
  module = i40e_nvmupd_get_module(cmd->config);
  #line 1609 
  last = (_Bool)(((int)transaction & 2) != 0);
  #line 1611 
  memset((void *)(& cmd_details),0,32UL);
  #line 1612 
  cmd_details.wb_desc = & hw->nvm_wb_desc;
  #line 1614 
  status = i40e_aq_erase_nvm(hw,(unsigned char)((int)module),cmd->offset,(unsigned short)((int)((unsigned short)cmd->data_size)),(_Bool)((bool)((int)last) != 0),& cmd_details);
  #line 1616 
  if (status != I40E_SUCCESS) {
    #line 1617 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1617 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)module,cmd->offset,cmd->data_size);
    #line 1620 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1620 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)status,(unsigned int)hw->aq.asq_last_status);
    #line 1623 
    *perrno = i40e_aq_rc_to_posix((int)status,(int)hw->aq.asq_last_status);
  }
  #line 1626 
  return status;
}

#line 1638  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_nvm.c"
static i40e_status i40e_nvmupd_nvm_write(struct i40e_hw *hw, struct i40e_nvm_access *cmd, u8 *bytes, int *perrno)
{
  #line 1643 
  struct i40e_asq_cmd_details cmd_details;
  #line 1644 
  u8 module;
  #line 1644 
  u8 transaction;
  #line 1645 
  u8 preservation_flags;
  #line 1646 
  bool last;
  #line 1642 
  i40e_status status = 0;
  #line 1648 
  transaction = i40e_nvmupd_get_transaction(cmd->config);
  #line 1649 
  module = i40e_nvmupd_get_module(cmd->config);
  #line 1650 
  last = (_Bool)(((int)transaction & 2) != 0);
  #line 1651 
  preservation_flags = i40e_nvmupd_get_preservation_flags(cmd->config);
  #line 1653 
  memset((void *)(& cmd_details),0,32UL);
  #line 1654 
  cmd_details.wb_desc = & hw->nvm_wb_desc;
  #line 1656 
  status = i40e_aq_update_nvm(hw,(unsigned char)((int)module),cmd->offset,(unsigned short)((int)((unsigned short)cmd->data_size)),(void *)bytes,(_Bool)((bool)((int)last) != 0),(unsigned char)((int)preservation_flags),& cmd_details);
  #line 1659 
  if (status != I40E_SUCCESS) {
    #line 1660 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1660 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)module,cmd->offset,cmd->data_size);
    #line 1663 
    if ((hw->debug_mask & 128U) != 0U) 
                                       #line 1663 
                                       printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)status,(unsigned int)hw->aq.asq_last_status);
    #line 1666 
    *perrno = i40e_aq_rc_to_posix((int)status,(int)hw->aq.asq_last_status);
  }
  #line 1669 
  return status;
}

#line 799  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_nvm.i.aux"
static void cif_mutex_lock_arq_mutex_of_i40e_adminq_info(struct mutex *lock)
{
  #line 802 
  ldv_mutex_model_lock(lock,(char *)"arq_mutex_of_i40e_adminq_info");
  #line 803 
  return;
}

#line 806  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_nvm.i.aux"
static void cif_mutex_unlock_arq_mutex_of_i40e_adminq_info(struct mutex *lock)
{
  #line 809 
  ldv_mutex_model_unlock(lock,(char *)"arq_mutex_of_i40e_adminq_info");
  #line 810 
  return;
}

#line 487  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernel.h"
#line 487 
int sscanf(char *, char * , ...);
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/string.h"
#line 169  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
static int cif_strncmp_0(char *cs, char *ct, __kernel_size_t count);
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/string.h"
#line 59 
char *strchr(char *, int);
#line 186 
#line 713  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
static void *cif_kmemdup(void *src, size_t len, gfp_t gfp);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/string.h"
#line 23 
void *ldv_kmemdup(void *src, size_t len, gfp_t gfp);
#line 3300  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
#line 3300 
int simple_open(struct inode *, struct file *);
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/debugfs.h"
#line 867  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
static struct dentry *cif_debugfs_create_file(char *name, umode_t mode, struct dentry *parent, void *data, struct file_operations *fops);
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/debugfs.h"
#line 859  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
static struct dentry *cif_debugfs_create_dir(char *name, struct dentry *parent);
#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/debugfs.h"
#line 85 
void debugfs_remove_recursive(struct dentry *);
#line 668  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 456  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
static void *kzalloc_3(size_t size, gfp_t flags);
#line 423  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
#line 423 
void __napi_schedule(struct napi_struct *);
#line 440  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void napi_schedule(struct napi_struct *n)
{
  #line 442 
  if ((int)napi_schedule_prep(n) != 0) 
                                       #line 443 
                                       __napi_schedule(n);
  #line 444 
  return;
}

#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rtnetlink.h"
#line 35 
int rtnl_trylock(void);
#line 1843  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static char *pci_name(struct pci_dev *pdev)
{
  #line 1845 
  return dev_name(& pdev->dev);
}

#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static struct dentry *i40e_dbg_root;
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static struct i40e_vsi *i40e_dbg_find_vsi(struct i40e_pf *pf, int seid)
{
  #line 20 
  int i;
  #line 22 
  if (seid < 0) 
                #line 23 
                _dev_info(& (pf->pdev)->dev,(char *)"%d: bad seid\n",seid);
  else {
    #line 25 
    i = 0;
    #line 25 
    while ((int)pf->num_alloc_vsi > i) {
      #line 26 
      if (*(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0 && (int)(*(pf->vsi + (unsigned long)i))->seid == seid) 
        #line 27 
        return *(pf->vsi + (unsigned long)i);
      #line 25 
      i ++;
    }
  }
  #line 29 
  return (struct i40e_vsi *)0;
}

#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static struct i40e_veb *i40e_dbg_find_veb(struct i40e_pf *pf, int seid)
{
  #line 39 
  int i;
  #line 41 
  i = 0;
  #line 41 
  while (i <= 15) {
    #line 42 
    if (pf->veb[i] != (struct i40e_veb *)0 && (int)(pf->veb[i])->seid == seid) 
      #line 43 
      return pf->veb[i];
    #line 41 
    i ++;
  }
  #line 44 
  return (struct i40e_veb *)0;
}

#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static char i40e_dbg_command_buf[256U] = {(char)'\000'};
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static ssize_t i40e_dbg_command_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
{
  #line 67 
  int bytes_not_copied;
  #line 69 
  char *buf;
  #line 70 
  int len;
  #line 66 
  struct i40e_pf *pf = (struct i40e_pf *)filp->private_data;
  #line 68 
  int buf_size = 256;
  #line 73 
  if (*ppos != 0LL) 
                    #line 74 
                    return 0L;
  #line 75 
  if ((unsigned long)buf_size > count) 
                                       #line 76 
                                       return -28L;
  #line 78 
  buf = (char *)kzalloc_3((unsigned long)buf_size,3264U);
  #line 79 
  if (buf == (char *)0) 
                        #line 80 
                        return -28L;
  #line 82 
  len = snprintf(buf,(unsigned long)buf_size,(char *)"%s: %s\n",(char *)(& ((*(pf->vsi + (unsigned long)pf->lan_vsi))->netdev)->name),(char *)(& i40e_dbg_command_buf));
  #line 86 
  bytes_not_copied = (int)copy_to_user((void *)buffer,(void *)buf,(unsigned long)len);
  #line 87 
  kfree((void *)buf);
  #line 89 
  if (bytes_not_copied != 0) 
                             #line 90 
                             return -14L;
  #line 92 
  *ppos = (long long)len;
  #line 93 
  return (long)len;
}

#line 96  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static char *i40e_filter_state_string[5U] = {(char *)"INVALID", (char *)"NEW", (char *)"ACTIVE", (char *)"FAILED", (char *)"REMOVE"};
#line 109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_vsi_seid(struct i40e_pf *pf, int seid)
{
  #line 111 
  struct rtnl_link_stats64 *nstat;
  #line 112 
  struct i40e_mac_filter *f;
  #line 113 
  struct i40e_vsi *vsi;
  #line 114 
  int i;
  #line 114 
  int bkt;
  #line 153 
  char *tmp_6;
  #line 116 
  vsi = i40e_dbg_find_vsi(pf,seid);
  #line 117 
  if (vsi == (struct i40e_vsi *)0) {
    #line 118 
    _dev_info(& (pf->pdev)->dev,(char *)"dump %d: seid not found\n",seid);
    #line 120 
    return;
  }
  #line 122 
  _dev_info(& (pf->pdev)->dev,(char *)"vsi seid %d\n",seid);
  #line 123 
  if (vsi->netdev != (struct net_device *)0) {
    #line 124 
    struct net_device *nd = vsi->netdev;
    #line 126 
    _dev_info(& (pf->pdev)->dev,(char *)"    netdev: name = %s, state = %lu, flags = 0x%08x\n",(char *)(& nd->name),nd->state,nd->flags);
    #line 128 
    _dev_info(& (pf->pdev)->dev,(char *)"        features      = 0x%08lx\n",(unsigned long)nd->features);
    #line 130 
    _dev_info(& (pf->pdev)->dev,(char *)"        hw_features   = 0x%08lx\n",(unsigned long)nd->hw_features);
    #line 132 
    _dev_info(& (pf->pdev)->dev,(char *)"        vlan_features = 0x%08lx\n",(unsigned long)nd->vlan_features);
  }
  #line 135 
  _dev_info(& (pf->pdev)->dev,(char *)"    flags = 0x%08lx, netdev_registered = %i, current_netdev_flags = 0x%04x\n",vsi->flags,(int)vsi->netdev_registered,vsi->current_netdev_flags);
  #line 138 
  i = 0;
  #line 138 
  while (i == 0) {
    #line 139 
    _dev_info(& (pf->pdev)->dev,(char *)"    state[%d] = %08lx\n",i,vsi->state[i]);
    #line 138 
    i ++;
  }
  #line 142 
  if (*(pf->vsi + (unsigned long)pf->lan_vsi) == vsi) 
                                                      #line 143 
                                                      _dev_info(& (pf->pdev)->dev,(char *)"    MAC address: %pM SAN MAC: %pM Port MAC: %pM\n",(u8 *)(& pf->hw.mac.addr),(u8 *)(& pf->hw.mac.san_addr),(u8 *)(& pf->hw.mac.port_addr));
  #line 147 
  bkt = 0;
  #line 147 
  f = (struct i40e_mac_filter *)0;
  #line 147 
  while (f == (struct i40e_mac_filter *)0 && (unsigned int)bkt <= 255U) {
    {
      #line 147 
      struct i40e_mac_filter *tmp_0;
      #line 147 
      void *__mptr;
      {
        #line 147 
        struct hlist_node *____ptr = vsi->mac_filter_hash[bkt].first;
        #line 147 
        if (____ptr != (struct hlist_node *)0) {
          #line 147 
          __mptr = (void *)____ptr;
          #line 147 
          tmp_0 = ((struct i40e_mac_filter *)__mptr);
        }
        else 
             #line 147 
             tmp_0 = (struct i40e_mac_filter *)0;
        }
      #line 147 
      f = tmp_0;
      #line 147 
      while (f != (struct i40e_mac_filter *)0) {
        #line 147 
        void *__mptr_0;
        #line 147 
        struct i40e_mac_filter *tmp_3;
        #line 148 
        _dev_info(& (pf->pdev)->dev,(char *)"    mac_filter_hash: %pM vid=%d, state %s\n",(u8 *)(& f->macaddr),(int)f->vlan,i40e_filter_state_string[(unsigned int)f->state]);
        {
          #line 147 
          struct hlist_node *____ptr_0 = f->hlist.next;
          #line 147 
          if (____ptr_0 != (struct hlist_node *)0) {
            #line 147 
            __mptr_0 = (void *)____ptr_0;
            #line 147 
            tmp_3 = ((struct i40e_mac_filter *)__mptr_0);
          }
          else 
               #line 147 
               tmp_3 = (struct i40e_mac_filter *)0;
          }
        #line 147 
        f = tmp_3;
      }
    }
    #line 147 
    bkt ++;
  }
  #line 153 
  if ((int)test_bit(3L,(unsigned long *)(& vsi->state)) != 0) 
                                                              #line 153 
                                                              tmp_6 = (char *)"ON"; else 
                                                                    #line 153 
                                                                    tmp_6 = (char *)"OFF";
  #line 153 
  ;
  #line 153 
  ;
  #line 153 
  ;
  #line 153 
  _dev_info(& (pf->pdev)->dev,(char *)"    active_filters %u, promisc_threshold %u, overflow promisc %s\n",vsi->active_filters,vsi->promisc_threshold,tmp_6);
  #line 157 
  nstat = i40e_get_vsi_stats_struct(vsi);
  #line 158 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats: rx_packets = %lu, rx_bytes = %lu, rx_errors = %lu, rx_dropped = %lu\n",(unsigned long)nstat->rx_packets,(unsigned long)nstat->rx_bytes,(unsigned long)nstat->rx_errors,(unsigned long)nstat->rx_dropped);
  #line 164 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats: tx_packets = %lu, tx_bytes = %lu, tx_errors = %lu, tx_dropped = %lu\n",(unsigned long)nstat->tx_packets,(unsigned long)nstat->tx_bytes,(unsigned long)nstat->tx_errors,(unsigned long)nstat->tx_dropped);
  #line 170 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats: multicast = %lu, collisions = %lu\n",(unsigned long)nstat->multicast,(unsigned long)nstat->collisions);
  #line 174 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats: rx_length_errors = %lu, rx_over_errors = %lu, rx_crc_errors = %lu\n",(unsigned long)nstat->rx_length_errors,(unsigned long)nstat->rx_over_errors,(unsigned long)nstat->rx_crc_errors);
  #line 179 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats: rx_frame_errors = %lu, rx_fifo_errors = %lu, rx_missed_errors = %lu\n",(unsigned long)nstat->rx_frame_errors,(unsigned long)nstat->rx_fifo_errors,(unsigned long)nstat->rx_missed_errors);
  #line 184 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats: tx_aborted_errors = %lu, tx_carrier_errors = %lu, tx_fifo_errors = %lu\n",(unsigned long)nstat->tx_aborted_errors,(unsigned long)nstat->tx_carrier_errors,(unsigned long)nstat->tx_fifo_errors);
  #line 189 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats: tx_heartbeat_errors = %lu, tx_window_errors = %lu\n",(unsigned long)nstat->tx_heartbeat_errors,(unsigned long)nstat->tx_window_errors);
  #line 193 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats: rx_compressed = %lu, tx_compressed = %lu\n",(unsigned long)nstat->rx_compressed,(unsigned long)nstat->tx_compressed);
  #line 197 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats_offsets: rx_packets = %lu, rx_bytes = %lu, rx_errors = %lu, rx_dropped = %lu\n",(unsigned long)vsi->net_stats_offsets.rx_packets,(unsigned long)vsi->net_stats_offsets.rx_bytes,(unsigned long)vsi->net_stats_offsets.rx_errors,(unsigned long)vsi->net_stats_offsets.rx_dropped);
  #line 203 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats_offsets: tx_packets = %lu, tx_bytes = %lu, tx_errors = %lu, tx_dropped = %lu\n",(unsigned long)vsi->net_stats_offsets.tx_packets,(unsigned long)vsi->net_stats_offsets.tx_bytes,(unsigned long)vsi->net_stats_offsets.tx_errors,(unsigned long)vsi->net_stats_offsets.tx_dropped);
  #line 209 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats_offsets: multicast = %lu, collisions = %lu\n",(unsigned long)vsi->net_stats_offsets.multicast,(unsigned long)vsi->net_stats_offsets.collisions);
  #line 213 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats_offsets: rx_length_errors = %lu, rx_over_errors = %lu, rx_crc_errors = %lu\n",(unsigned long)vsi->net_stats_offsets.rx_length_errors,(unsigned long)vsi->net_stats_offsets.rx_over_errors,(unsigned long)vsi->net_stats_offsets.rx_crc_errors);
  #line 218 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats_offsets: rx_frame_errors = %lu, rx_fifo_errors = %lu, rx_missed_errors = %lu\n",(unsigned long)vsi->net_stats_offsets.rx_frame_errors,(unsigned long)vsi->net_stats_offsets.rx_fifo_errors,(unsigned long)vsi->net_stats_offsets.rx_missed_errors);
  #line 223 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats_offsets: tx_aborted_errors = %lu, tx_carrier_errors = %lu, tx_fifo_errors = %lu\n",(unsigned long)vsi->net_stats_offsets.tx_aborted_errors,(unsigned long)vsi->net_stats_offsets.tx_carrier_errors,(unsigned long)vsi->net_stats_offsets.tx_fifo_errors);
  #line 228 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats_offsets: tx_heartbeat_errors = %lu, tx_window_errors = %lu\n",(unsigned long)vsi->net_stats_offsets.tx_heartbeat_errors,(unsigned long)vsi->net_stats_offsets.tx_window_errors);
  #line 232 
  _dev_info(& (pf->pdev)->dev,(char *)"    net_stats_offsets: rx_compressed = %lu, tx_compressed = %lu\n",(unsigned long)vsi->net_stats_offsets.rx_compressed,(unsigned long)vsi->net_stats_offsets.tx_compressed);
  #line 236 
  _dev_info(& (pf->pdev)->dev,(char *)"    tx_restart = %d, tx_busy = %d, rx_buf_failed = %d, rx_page_failed = %d\n",vsi->tx_restart,vsi->tx_busy,vsi->rx_buf_failed,vsi->rx_page_failed);
  #line 240 
  rcu_read_lock();
  #line 241 
  i = 0;
  #line 241 
  while ((int)vsi->num_queue_pairs > i) {
    {
      #line 243 
      union __anonunion___u_13076 __u;
      #line 279 
      char *tmp_8;
      #line 242 
      __read_once_size((void *)(vsi->rx_rings + (unsigned long)i),(void *)(& __u.__c),8);
      #line 242 
      struct i40e_ring *rx_ring = (__u.__val);
      #line 244 
      if (rx_ring == (struct i40e_ring *)0) 
                                            #line 245 
                                            goto __Cont;
      #line 247 
      _dev_info(& (pf->pdev)->dev,(char *)"    rx_rings[%i]: state = %lu, queue_index = %d, reg_idx = %d\n",i,*((unsigned long *)(& rx_ring->state)),(int)rx_ring->queue_index,(int)rx_ring->reg_idx);
      #line 252 
      _dev_info(& (pf->pdev)->dev,(char *)"    rx_rings[%i]: rx_buf_len = %d\n",i,(int)rx_ring->rx_buf_len);
      #line 255 
      _dev_info(& (pf->pdev)->dev,(char *)"    rx_rings[%i]: next_to_use = %d, next_to_clean = %d, ring_active = %i\n",i,(int)rx_ring->next_to_use,(int)rx_ring->next_to_clean,(int)rx_ring->ring_active);
      #line 261 
      _dev_info(& (pf->pdev)->dev,(char *)"    rx_rings[%i]: rx_stats: packets = %lld, bytes = %lld, non_eop_descs = %lld\n",i,rx_ring->stats.packets,rx_ring->stats.bytes,rx_ring->__anonCompField_i40e_ring_222.rx_stats.non_eop_descs);
      #line 266 
      _dev_info(& (pf->pdev)->dev,(char *)"    rx_rings[%i]: rx_stats: alloc_page_failed = %lld, alloc_buff_failed = %lld\n",i,rx_ring->__anonCompField_i40e_ring_222.rx_stats.alloc_page_failed,rx_ring->__anonCompField_i40e_ring_222.rx_stats.alloc_buff_failed);
      #line 271 
      _dev_info(& (pf->pdev)->dev,(char *)"    rx_rings[%i]: rx_stats: realloc_count = %lld, page_reuse_count = %lld\n",i,rx_ring->__anonCompField_i40e_ring_222.rx_stats.realloc_count,rx_ring->__anonCompField_i40e_ring_222.rx_stats.page_reuse_count);
      #line 276 
      _dev_info(& (pf->pdev)->dev,(char *)"    rx_rings[%i]: size = %i\n",i,rx_ring->size);
      #line 279 
      if (((int)rx_ring->itr_setting & 32768) != 0) 
                                                    #line 279 
                                                    tmp_8 = (char *)"dynamic"; else 
                                                                    #line 279 
                                                                    tmp_8 = (char *)"fixed";
      #line 279 
      ;
      #line 279 
      ;
      #line 279 
      ;
      #line 279 
      _dev_info(& (pf->pdev)->dev,(char *)"    rx_rings[%i]: itr_setting = %d (%s)\n",i,(int)rx_ring->itr_setting,tmp_8);
    }
    #line 241 
    __Cont: 
            #line 241 
    i ++;
  }
  #line 284 
  i = 0;
  #line 284 
  while ((int)vsi->num_queue_pairs > i) {
    {
      #line 286 
      union __anonunion___u_13078 __u_0;
      #line 317 
      char *tmp_10;
      #line 285 
      __read_once_size((void *)(vsi->tx_rings + (unsigned long)i),(void *)(& __u_0.__c),8);
      #line 285 
      struct i40e_ring *tx_ring = (__u_0.__val);
      #line 287 
      if (tx_ring == (struct i40e_ring *)0) 
                                            #line 288 
                                            goto __Cont_0;
      #line 290 
      _dev_info(& (pf->pdev)->dev,(char *)"    tx_rings[%i]: state = %lu, queue_index = %d, reg_idx = %d\n",i,*((unsigned long *)(& tx_ring->state)),(int)tx_ring->queue_index,(int)tx_ring->reg_idx);
      #line 295 
      _dev_info(& (pf->pdev)->dev,(char *)"    tx_rings[%i]: next_to_use = %d, next_to_clean = %d, ring_active = %i\n",i,(int)tx_ring->next_to_use,(int)tx_ring->next_to_clean,(int)tx_ring->ring_active);
      #line 301 
      _dev_info(& (pf->pdev)->dev,(char *)"    tx_rings[%i]: tx_stats: packets = %lld, bytes = %lld, restart_queue = %lld\n",i,tx_ring->stats.packets,tx_ring->stats.bytes,tx_ring->__anonCompField_i40e_ring_222.tx_stats.restart_queue);
      #line 306 
      _dev_info(& (pf->pdev)->dev,(char *)"    tx_rings[%i]: tx_stats: tx_busy = %lld, tx_done_old = %lld\n",i,tx_ring->__anonCompField_i40e_ring_222.tx_stats.tx_busy,tx_ring->__anonCompField_i40e_ring_222.tx_stats.tx_done_old);
      #line 311 
      _dev_info(& (pf->pdev)->dev,(char *)"    tx_rings[%i]: size = %i\n",i,tx_ring->size);
      #line 314 
      _dev_info(& (pf->pdev)->dev,(char *)"    tx_rings[%i]: DCB tc = %d\n",i,(int)tx_ring->dcb_tc);
      #line 317 
      if (((int)tx_ring->itr_setting & 32768) != 0) 
                                                    #line 317 
                                                    tmp_10 = (char *)"dynamic"; else 
                                                                    #line 317 
                                                                    tmp_10 = (char *)"fixed";
      #line 317 
      ;
      #line 317 
      ;
      #line 317 
      ;
      #line 317 
      _dev_info(& (pf->pdev)->dev,(char *)"    tx_rings[%i]: itr_setting = %d (%s)\n",i,(int)tx_ring->itr_setting,tmp_10);
    }
    #line 284 
    __Cont_0: 
              #line 284 
    i ++;
  }
  #line 322 
  rcu_read_unlock();
  #line 323 
  _dev_info(& (pf->pdev)->dev,(char *)"    work_limit = %d\n",(int)vsi->work_limit);
  #line 326 
  _dev_info(& (pf->pdev)->dev,(char *)"    max_frame = %d, rx_buf_len = %d dtype = %d\n",(int)vsi->max_frame,(int)vsi->rx_buf_len,0);
  #line 329 
  _dev_info(& (pf->pdev)->dev,(char *)"    num_q_vectors = %i, base_vector = %i\n",vsi->num_q_vectors,vsi->base_vector);
  #line 332 
  _dev_info(& (pf->pdev)->dev,(char *)"    seid = %d, id = %d, uplink_seid = %d\n",(int)vsi->seid,(int)vsi->id,(int)vsi->uplink_seid);
  #line 335 
  _dev_info(& (pf->pdev)->dev,(char *)"    base_queue = %d, num_queue_pairs = %d, num_tx_desc = %d, num_rx_desc = %d\n",(int)vsi->base_queue,(int)vsi->num_queue_pairs,(int)vsi->num_tx_desc,(int)vsi->num_rx_desc);
  #line 339 
  _dev_info(& (pf->pdev)->dev,(char *)"    type = %i\n",(unsigned int)vsi->type);
  #line 340 
  if (vsi->type == (unsigned int)I40E_VSI_SRIOV) 
                                                 #line 341 
                                                 _dev_info(& (pf->pdev)->dev,(char *)"    VF ID = %i\n",(int)vsi->vf_id);
  #line 342 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: valid_sections = 0x%04x, switch_id = 0x%04x\n",(int)vsi->info.valid_sections,(int)vsi->info.switch_id);
  #line 345 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: sw_reserved[] = 0x%02x 0x%02x\n",(int)vsi->info.sw_reserved[0],(int)vsi->info.sw_reserved[1]);
  #line 348 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: sec_flags = 0x%02x, sec_reserved = 0x%02x\n",(int)vsi->info.sec_flags,(int)vsi->info.sec_reserved);
  #line 351 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: pvid = 0x%04x, fcoe_pvid = 0x%04x, port_vlan_flags = 0x%02x\n",(int)vsi->info.pvid,(int)vsi->info.fcoe_pvid,(int)vsi->info.port_vlan_flags);
  #line 355 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: pvlan_reserved[] = 0x%02x 0x%02x 0x%02x\n",(int)vsi->info.pvlan_reserved[0],(int)vsi->info.pvlan_reserved[1],(int)vsi->info.pvlan_reserved[2]);
  #line 359 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: ingress_table = 0x%08x, egress_table = 0x%08x\n",vsi->info.ingress_table,vsi->info.egress_table);
  #line 362 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: cas_pv_stag = 0x%04x, cas_pv_flags= 0x%02x, cas_pv_reserved = 0x%02x\n",(int)vsi->info.cas_pv_tag,(int)vsi->info.cas_pv_flags,(int)vsi->info.cas_pv_reserved);
  #line 366 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: queue_mapping[0..7 ] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",(int)vsi->info.queue_mapping[0],(int)vsi->info.queue_mapping[1],(int)vsi->info.queue_mapping[2],(int)vsi->info.queue_mapping[3],(int)vsi->info.queue_mapping[4],(int)vsi->info.queue_mapping[5],(int)vsi->info.queue_mapping[6],(int)vsi->info.queue_mapping[7]);
  #line 372 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: queue_mapping[8..15] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",(int)vsi->info.queue_mapping[8],(int)vsi->info.queue_mapping[9],(int)vsi->info.queue_mapping[10],(int)vsi->info.queue_mapping[11],(int)vsi->info.queue_mapping[12],(int)vsi->info.queue_mapping[13],(int)vsi->info.queue_mapping[14],(int)vsi->info.queue_mapping[15]);
  #line 378 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: tc_mapping[] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",(int)vsi->info.tc_mapping[0],(int)vsi->info.tc_mapping[1],(int)vsi->info.tc_mapping[2],(int)vsi->info.tc_mapping[3],(int)vsi->info.tc_mapping[4],(int)vsi->info.tc_mapping[5],(int)vsi->info.tc_mapping[6],(int)vsi->info.tc_mapping[7]);
  #line 384 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: queueing_opt_flags = 0x%02x  queueing_opt_reserved[0..2] = 0x%02x 0x%02x 0x%02x\n",(int)vsi->info.queueing_opt_flags,(int)vsi->info.queueing_opt_reserved[0],(int)vsi->info.queueing_opt_reserved[1],(int)vsi->info.queueing_opt_reserved[2]);
  #line 390 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: up_enable_bits = 0x%02x\n",(int)vsi->info.up_enable_bits);
  #line 393 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: sched_reserved = 0x%02x, outer_up_table = 0x%04x\n",(int)vsi->info.sched_reserved,vsi->info.outer_up_table);
  #line 396 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: cmd_reserved[] = 0x%02x 0x%02x 0x%02x 0x0%02x 0x%02x 0x%02x 0x%02x 0x0%02x\n",(int)vsi->info.cmd_reserved[0],(int)vsi->info.cmd_reserved[1],(int)vsi->info.cmd_reserved[2],(int)vsi->info.cmd_reserved[3],(int)vsi->info.cmd_reserved[4],(int)vsi->info.cmd_reserved[5],(int)vsi->info.cmd_reserved[6],(int)vsi->info.cmd_reserved[7]);
  #line 402 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: qs_handle[] = 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x 0x%04x\n",(int)vsi->info.qs_handle[0],(int)vsi->info.qs_handle[1],(int)vsi->info.qs_handle[2],(int)vsi->info.qs_handle[3],(int)vsi->info.qs_handle[4],(int)vsi->info.qs_handle[5],(int)vsi->info.qs_handle[6],(int)vsi->info.qs_handle[7]);
  #line 408 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: stat_counter_idx = 0x%04x, sched_id = 0x%04x\n",(int)vsi->info.stat_counter_idx,(int)vsi->info.sched_id);
  #line 411 
  _dev_info(& (pf->pdev)->dev,(char *)"    info: resp_reserved[] = 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",(int)vsi->info.resp_reserved[0],(int)vsi->info.resp_reserved[1],(int)vsi->info.resp_reserved[2],(int)vsi->info.resp_reserved[3],(int)vsi->info.resp_reserved[4],(int)vsi->info.resp_reserved[5],(int)vsi->info.resp_reserved[6],(int)vsi->info.resp_reserved[7],(int)vsi->info.resp_reserved[8],(int)vsi->info.resp_reserved[9],(int)vsi->info.resp_reserved[10],(int)vsi->info.resp_reserved[11]);
  #line 419 
  _dev_info(& (pf->pdev)->dev,(char *)"    idx = %d\n",(int)vsi->idx);
  #line 420 
  _dev_info(& (pf->pdev)->dev,(char *)"    tc_config: numtc = %d, enabled_tc = 0x%x\n",(int)vsi->tc_config.numtc,(int)vsi->tc_config.enabled_tc);
  #line 423 
  i = 0;
  #line 423 
  while (i <= 7) {
    #line 424 
    _dev_info(& (pf->pdev)->dev,(char *)"    tc_config: tc = %d, qoffset = %d, qcount = %d, netdev_tc = %d\n",i,(int)vsi->tc_config.tc_info[i].qoffset,(int)vsi->tc_config.tc_info[i].qcount,(int)vsi->tc_config.tc_info[i].netdev_tc);
    #line 423 
    i ++;
  }
  #line 430 
  _dev_info(& (pf->pdev)->dev,(char *)"    bw: bw_limit = %d, bw_max_quanta = %d\n",(int)vsi->bw_limit,(int)vsi->bw_max_quanta);
  #line 433 
  i = 0;
  #line 433 
  while (i <= 7) {
    #line 434 
    _dev_info(& (pf->pdev)->dev,(char *)"    bw[%d]: ets_share_credits = %d, ets_limit_credits = %d, max_quanta = %d\n",i,(int)vsi->bw_ets_share_credits[i],(int)vsi->bw_ets_limit_credits[i],(int)vsi->bw_ets_max_quanta[i]);
    #line 433 
    i ++;
  }
  #line 435 
  return;
}

#line 446  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_aq_desc(struct i40e_pf *pf)
{
  #line 448 
  struct i40e_adminq_ring *ring;
  #line 450 
  char hdr[32U];
  #line 451 
  int i;
  #line 449 
  struct i40e_hw *hw = & pf->hw;
  #line 453 
  snprintf((char *)(& hdr),32UL,(char *)"%s %s:         ",dev_driver_string(& (pf->pdev)->dev),dev_name(& (pf->pdev)->dev));
  #line 458 
  _dev_info(& (pf->pdev)->dev,(char *)"AdminQ Tx Ring\n");
  #line 459 
  ring = & hw->aq.asq;
  #line 460 
  i = 0;
  #line 460 
  while ((int)ring->count > i) {
    {
      #line 461 
      struct i40e_aq_desc *d = (struct i40e_aq_desc *)ring->desc_buf.va + (unsigned long)i;
      #line 463 
      _dev_info(& (pf->pdev)->dev,(char *)"   at[%02d] flags=0x%04x op=0x%04x dlen=0x%04x ret=0x%04x cookie_h=0x%08x cookie_l=0x%08x\n",i,(int)d->flags,(int)d->opcode,(int)d->datalen,(int)d->retval,d->cookie_high,d->cookie_low);
      #line 467 
      print_hex_dump((char *)"\001",(char *)(& hdr),0,16,1,(void *)(& d->params.raw),16UL,(_Bool)0);
    }
    #line 460 
    i ++;
  }
  #line 471 
  _dev_info(& (pf->pdev)->dev,(char *)"AdminQ Rx Ring\n");
  #line 472 
  ring = & hw->aq.arq;
  #line 473 
  i = 0;
  #line 473 
  while ((int)ring->count > i) {
    {
      #line 474 
      struct i40e_aq_desc *d_0 = (struct i40e_aq_desc *)ring->desc_buf.va + (unsigned long)i;
      #line 476 
      _dev_info(& (pf->pdev)->dev,(char *)"   ar[%02d] flags=0x%04x op=0x%04x dlen=0x%04x ret=0x%04x cookie_h=0x%08x cookie_l=0x%08x\n",i,(int)d_0->flags,(int)d_0->opcode,(int)d_0->datalen,(int)d_0->retval,d_0->cookie_high,d_0->cookie_low);
      #line 480 
      print_hex_dump((char *)"\001",(char *)(& hdr),0,16,1,(void *)(& d_0->params.raw),16UL,(_Bool)0);
    }
    #line 473 
    i ++;
  }
  #line 483 
  return;
}

#line 494  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_desc(int cnt, int vsi_seid, int ring_id, int desc_n, struct i40e_pf *pf, bool is_rx_ring)
{
  #line 497 
  struct i40e_tx_desc *txd;
  #line 498 
  union i40e_32byte_rx_desc *rxd;
  #line 499 
  struct i40e_ring *ring;
  #line 500 
  struct i40e_vsi *vsi;
  #line 501 
  int i;
  #line 520 
  struct i40e_ring *tmp;
  #line 503 
  vsi = i40e_dbg_find_vsi(pf,vsi_seid);
  #line 504 
  if (vsi == (struct i40e_vsi *)0) {
    #line 505 
    _dev_info(& (pf->pdev)->dev,(char *)"vsi %d not found\n",vsi_seid);
    #line 506 
    return;
  }
  #line 508 
  if ((int)vsi->num_queue_pairs <= ring_id || ring_id < 0) {
    #line 509 
    _dev_info(& (pf->pdev)->dev,(char *)"ring %d not found\n",ring_id);
    #line 510 
    return;
  }
  #line 512 
  if (vsi->tx_rings == (struct i40e_ring **)0 || (*(vsi->tx_rings))->desc == (void *)0) {
    #line 513 
    _dev_info(& (pf->pdev)->dev,(char *)"descriptor rings have not been allocated for vsi %d\n",vsi_seid);
    #line 516 
    return;
  }
  #line 520 
  if ((int)is_rx_ring != 0) 
                            #line 520 
                            tmp = *(vsi->rx_rings + (unsigned long)ring_id); else 
                                                                    #line 520 
                                                                    tmp = *(vsi->tx_rings + (unsigned long)ring_id);
  #line 519 
  ring = (struct i40e_ring *)cif_kmemdup((void *)tmp,4096UL,3264U);
  #line 522 
  if (ring == (struct i40e_ring *)0) 
                                     #line 523 
                                     return;
  #line 525 
  if (cnt == 2) {
    #line 526 
    char *tmp_1;
    #line 526 
    ;
    #line 526 
    if ((int)is_rx_ring != 0) 
                              #line 526 
                              tmp_1 = (char *)"rx"; else 
                                                         #line 526 
                                                         tmp_1 = (char *)"tx";
    #line 526 
    ;
    #line 526 
    ;
    #line 526 
    _dev_info(& (pf->pdev)->dev,(char *)"vsi = %02i %s ring = %02i\n",vsi_seid,tmp_1,ring_id);
    #line 528 
    i = 0;
    #line 528 
    while ((int)ring->count > i) {
      #line 529 
      if (! is_rx_ring) {
        #line 530 
        txd = (struct i40e_tx_desc *)ring->desc + (unsigned long)i;
        #line 531 
        _dev_info(& (pf->pdev)->dev,(char *)"   d[%03x] = 0x%016llx 0x%016llx\n",i,txd->buffer_addr,txd->cmd_type_offset_bsz);
      }
      else {
        #line 536 
        rxd = (union i40e_32byte_rx_desc *)ring->desc + (unsigned long)i;
        #line 537 
        _dev_info(& (pf->pdev)->dev,(char *)"   d[%03x] = 0x%016llx 0x%016llx 0x%016llx 0x%016llx\n",i,rxd->read.pkt_addr,rxd->read.hdr_addr,rxd->read.rsvd1,rxd->read.rsvd2);
      }
      #line 528 
      i ++;
    }
  }
  else 
    #line 544 
    if (cnt == 3) {
      #line 545 
      if ((int)ring->count <= desc_n || desc_n < 0) {
        #line 546 
        _dev_info(& (pf->pdev)->dev,(char *)"descriptor %d not found\n",desc_n);
        #line 548 
        goto out;
      }
      #line 550 
      if (! is_rx_ring) {
        #line 551 
        txd = (struct i40e_tx_desc *)ring->desc + (unsigned long)desc_n;
        #line 552 
        _dev_info(& (pf->pdev)->dev,(char *)"vsi = %02i tx ring = %02i d[%03x] = 0x%016llx 0x%016llx\n",vsi_seid,ring_id,desc_n,txd->buffer_addr,txd->cmd_type_offset_bsz);
      }
      else {
        #line 557 
        rxd = (union i40e_32byte_rx_desc *)ring->desc + (unsigned long)desc_n;
        #line 558 
        _dev_info(& (pf->pdev)->dev,(char *)"vsi = %02i rx ring = %02i d[%03x] = 0x%016llx 0x%016llx 0x%016llx 0x%016llx\n",vsi_seid,ring_id,desc_n,rxd->read.pkt_addr,rxd->read.hdr_addr,rxd->read.rsvd1,rxd->read.rsvd2);
      }
    }
    else 
         #line 565 
         _dev_info(& (pf->pdev)->dev,(char *)"dump desc rx/tx <vsi_seid> <ring_id> [<desc_n>]\n");
  #line 568 
  out: 
       #line 568 
  ;
  #line 569 
  kfree((void *)ring);
  #line 570 
  return;
}

#line 576  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_vsi_no_seid(struct i40e_pf *pf)
{
  #line 578 
  int i;
  #line 580 
  i = 0;
  #line 580 
  while ((int)pf->num_alloc_vsi > i) {
    #line 581 
    if (*(pf->vsi + (unsigned long)i) != (struct i40e_vsi *)0) 
                                                               #line 582 
                                                               _dev_info(& (pf->pdev)->dev,(char *)"dump vsi[%d]: %d\n",i,(int)(*(pf->vsi + (unsigned long)i))->seid);
    #line 580 
    i ++;
  }
  #line 583 
  return;
}

#line 591  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_eth_stats(struct i40e_pf *pf, struct i40e_eth_stats *estats)
{
  #line 594 
  _dev_info(& (pf->pdev)->dev,(char *)"  ethstats:\n");
  #line 595 
  _dev_info(& (pf->pdev)->dev,(char *)"    rx_bytes = \t%lld \trx_unicast = \t\t%lld \trx_multicast = \t%lld\n",estats->rx_bytes,estats->rx_unicast,estats->rx_multicast);
  #line 598 
  _dev_info(& (pf->pdev)->dev,(char *)"    rx_broadcast = \t%lld \trx_discards = \t\t%lld\n",estats->rx_broadcast,estats->rx_discards);
  #line 601 
  _dev_info(& (pf->pdev)->dev,(char *)"    rx_unknown_protocol = \t%lld \ttx_bytes = \t%lld\n",estats->rx_unknown_protocol,estats->tx_bytes);
  #line 604 
  _dev_info(& (pf->pdev)->dev,(char *)"    tx_unicast = \t%lld \ttx_multicast = \t\t%lld \ttx_broadcast = \t%lld\n",estats->tx_unicast,estats->tx_multicast,estats->tx_broadcast);
  #line 607 
  _dev_info(& (pf->pdev)->dev,(char *)"    tx_discards = \t%lld \ttx_errors = \t\t%lld\n",estats->tx_discards,estats->tx_errors);
  #line 608 
  return;
}

#line 617  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_veb_seid(struct i40e_pf *pf, int seid)
{
  #line 619 
  struct i40e_veb *veb;
  #line 626 
  char *tmp;
  #line 621 
  veb = i40e_dbg_find_veb(pf,seid);
  #line 622 
  if (veb == (struct i40e_veb *)0) {
    #line 623 
    _dev_info(& (pf->pdev)->dev,(char *)"can\'t find veb %d\n",seid);
    #line 624 
    return;
  }
  #line 626 
  if ((unsigned int)veb->bridge_mode == 1U) 
                                            #line 626 
                                            tmp = (char *)"VEPA"; else 
                                                                    #line 626 
                                                                    tmp = (char *)"VEB";
  #line 626 
  ;
  #line 626 
  ;
  #line 626 
  ;
  #line 626 
  ;
  #line 626 
  ;
  #line 626 
  ;
  #line 626 
  _dev_info(& (pf->pdev)->dev,(char *)"veb idx=%d,%d stats_ic=%d  seid=%d uplink=%d mode=%s\n",(int)veb->idx,(int)veb->veb_idx,(int)veb->stats_idx,(int)veb->seid,(int)veb->uplink_seid,tmp);
  #line 631 
  i40e_dbg_dump_eth_stats(pf,& veb->stats);
  #line 632 
  return;
}

#line 638  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_veb_all(struct i40e_pf *pf)
{
  #line 640 
  struct i40e_veb *veb;
  #line 641 
  int i;
  #line 643 
  i = 0;
  #line 643 
  while (i <= 15) {
    #line 644 
    veb = pf->veb[i];
    #line 645 
    if (veb != (struct i40e_veb *)0) 
                                     #line 646 
                                     i40e_dbg_dump_veb_seid(pf,(int)veb->seid);
    #line 643 
    i ++;
  }
  #line 648 
  return;
}

#line 655  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_vf(struct i40e_pf *pf, int vf_id)
{
  #line 657 
  struct i40e_vf *vf;
  #line 658 
  struct i40e_vsi *vsi;
  #line 660 
  if (pf->num_alloc_vfs == 0) 
                              #line 661 
                              _dev_info(& (pf->pdev)->dev,(char *)"no VFs allocated\n");
  else 
    #line 662 
    if (vf_id >= 0 && pf->num_alloc_vfs > vf_id) {
      #line 663 
      vf = pf->vf + (unsigned long)vf_id;
      #line 664 
      vsi = *(pf->vsi + (unsigned long)vf->lan_vsi_idx);
      #line 665 
      _dev_info(& (pf->pdev)->dev,(char *)"vf %2d: VSI id=%d, seid=%d, qps=%d\n",vf_id,(int)vf->lan_vsi_id,(int)vsi->seid,(int)vf->num_queue_pairs);
      #line 667 
      _dev_info(& (pf->pdev)->dev,(char *)"       num MDD=%lld, invalid msg=%lld, valid msg=%lld\n",vf->num_mdd_events,vf->num_invalid_msgs,vf->num_valid_msgs);
    }
    else 
         #line 672 
         _dev_info(& (pf->pdev)->dev,(char *)"invalid VF id %d\n",vf_id);
  #line 673 
  return;
}

#line 680  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static void i40e_dbg_dump_vf_all(struct i40e_pf *pf)
{
  #line 682 
  int i;
  #line 684 
  if (pf->num_alloc_vfs == 0) 
                              #line 685 
                              _dev_info(& (pf->pdev)->dev,(char *)"no VFs enabled!\n");
  else {
    #line 687 
    i = 0;
    #line 687 
    while (pf->num_alloc_vfs > i) {
      #line 688 
      i40e_dbg_dump_vf(pf,i);
      #line 687 
      i ++;
    }
  }
  #line 690 
  return;
}

#line 699  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static ssize_t i40e_dbg_command_write(struct file *filp, char *buffer, size_t count, loff_t *ppos)
{
  #line 704 
  char *cmd_buf;
  #line 704 
  char *cmd_buf_tmp;
  #line 705 
  int bytes_not_copied;
  #line 706 
  struct i40e_vsi *vsi;
  #line 707 
  int vsi_seid;
  #line 708 
  int veb_seid;
  #line 709 
  int vf_id;
  #line 710 
  int cnt;
  #line 703 
  struct i40e_pf *pf = (struct i40e_pf *)filp->private_data;
  #line 713 
  if (*ppos != 0LL) 
                    #line 714 
                    return 0L;
  #line 716 
  cmd_buf = (char *)kzalloc_3(count + 1UL,3264U);
  #line 717 
  if (cmd_buf == (char *)0) 
                            #line 718 
                            return (long)count;
  #line 719 
  bytes_not_copied = (int)copy_from_user((void *)cmd_buf,(void *)buffer,count);
  #line 720 
  if (bytes_not_copied != 0) {
    #line 721 
    kfree((void *)cmd_buf);
    #line 722 
    return -14L;
  }
  #line 724 
  *(cmd_buf + count) = (char)0;
  #line 726 
  cmd_buf_tmp = strchr(cmd_buf,10);
  #line 727 
  if (cmd_buf_tmp != (char *)0) {
    #line 728 
    *cmd_buf_tmp = (char)0;
    #line 729 
    count = (unsigned long)((cmd_buf_tmp - cmd_buf) + 1L);
  }
  #line 732 
  if (cif_strncmp_0(cmd_buf,(char *)"add vsi",7UL) == 0) {
    #line 733 
    vsi_seid = -1;
    #line 734 
    cnt = sscanf(cmd_buf + 7U,(char *)"%i",& vsi_seid);
    #line 735 
    if (cnt == 0) 
                  #line 737 
                  vsi_seid = (int)(*(pf->vsi + (unsigned long)pf->lan_vsi))->seid;
    else 
      #line 738 
      if (vsi_seid < 0) {
        #line 739 
        _dev_info(& (pf->pdev)->dev,(char *)"add VSI %d: bad vsi seid\n",vsi_seid);
        #line 741 
        goto command_write_done;
      }
    #line 747 
    if (((unsigned long)pf->flags & 4096UL) == 0UL) {
      #line 748 
      pf->flags |= 4096U;
      #line 749 
      i40e_do_reset_safe(pf,8192U);
    }
    #line 752 
    vsi = i40e_vsi_setup(pf,(unsigned char)2,(unsigned short)((int)((unsigned short)vsi_seid)),0U);
    #line 753 
    if (vsi != (struct i40e_vsi *)0) 
                                     #line 754 
                                     _dev_info(& (pf->pdev)->dev,(char *)"added VSI %d to relay %d\n",(int)vsi->seid,(int)vsi->uplink_seid); else 
                                                                    #line 757 
                                                                    _dev_info(& (pf->pdev)->dev,(char *)"\'%s\' failed\n",cmd_buf);
  }
  else {
    #line 759 
    if (cif_strncmp_0(cmd_buf,(char *)"del vsi",7UL) == 0) {
      #line 760 
      cnt = sscanf(cmd_buf + 7U,(char *)"%i",& vsi_seid);
      #line 761 
      if (cnt != 1) {
        #line 762 
        _dev_info(& (pf->pdev)->dev,(char *)"del vsi: bad command string, cnt=%d\n",cnt);
        #line 765 
        goto command_write_done;
      }
      #line 767 
      vsi = i40e_dbg_find_vsi(pf,vsi_seid);
      #line 768 
      if (vsi == (struct i40e_vsi *)0) {
        #line 769 
        _dev_info(& (pf->pdev)->dev,(char *)"del VSI %d: seid not found\n",vsi_seid);
        #line 771 
        goto command_write_done;
      }
      #line 774 
      _dev_info(& (pf->pdev)->dev,(char *)"deleting VSI %d\n",vsi_seid);
      #line 775 
      i40e_vsi_release(vsi);
    }
    else {
      #line 777 
      if (cif_strncmp_0(cmd_buf,(char *)"add relay",9UL) == 0) {
        #line 778 
        struct i40e_veb *veb;
        #line 779 
        int uplink_seid;
        #line 779 
        int i;
        #line 781 
        cnt = sscanf(cmd_buf + 9U,(char *)"%i %i",& uplink_seid,& vsi_seid);
        #line 782 
        if (cnt != 2) {
          #line 783 
          _dev_info(& (pf->pdev)->dev,(char *)"add relay: bad command string, cnt=%d\n",cnt);
          #line 786 
          goto command_write_done;
        }
        else 
          #line 787 
          if (uplink_seid < 0) {
            #line 788 
            _dev_info(& (pf->pdev)->dev,(char *)"add relay %d: bad uplink seid\n",uplink_seid);
            #line 791 
            goto command_write_done;
          }
        #line 794 
        vsi = i40e_dbg_find_vsi(pf,vsi_seid);
        #line 795 
        if (vsi == (struct i40e_vsi *)0) {
          #line 796 
          _dev_info(& (pf->pdev)->dev,(char *)"add relay: VSI %d not found\n",vsi_seid);
          #line 798 
          goto command_write_done;
        }
        #line 801 
        i = 0;
        #line 801 
        while (i <= 15) {
          #line 802 
          if (pf->veb[i] != (struct i40e_veb *)0 && (int)(pf->veb[i])->seid == uplink_seid) 
            #line 803 
            break;
          #line 801 
          i ++;
        }
        #line 804 
        if ((i > 15 && uplink_seid != 0) && (int)pf->mac_seid != uplink_seid) {
          #line 806 
          _dev_info(& (pf->pdev)->dev,(char *)"add relay: relay uplink %d not found\n",uplink_seid);
          #line 809 
          goto command_write_done;
        }
        #line 812 
        veb = i40e_veb_setup(pf,(unsigned short)0,(unsigned short)((int)((unsigned short)uplink_seid)),(unsigned short)((int)((unsigned short)vsi_seid)),(unsigned char)((int)vsi->tc_config.enabled_tc));
        #line 814 
        if (veb != (struct i40e_veb *)0) 
                                         #line 815 
                                         _dev_info(& (pf->pdev)->dev,(char *)"added relay %d\n",(int)veb->seid); else 
                                                                    #line 817 
                                                                    _dev_info(& (pf->pdev)->dev,(char *)"add relay failed\n");
      }
      else {
        #line 819 
        if (cif_strncmp_0(cmd_buf,(char *)"del relay",9UL) == 0) {
          #line 820 
          int i_0;
          #line 821 
          cnt = sscanf(cmd_buf + 9U,(char *)"%i",& veb_seid);
          #line 822 
          if (cnt != 1) {
            #line 823 
            _dev_info(& (pf->pdev)->dev,(char *)"del relay: bad command string, cnt=%d\n",cnt);
            #line 826 
            goto command_write_done;
          }
          else 
            #line 827 
            if (veb_seid < 0) {
              #line 828 
              _dev_info(& (pf->pdev)->dev,(char *)"del relay %d: bad relay seid\n",veb_seid);
              #line 830 
              goto command_write_done;
            }
          #line 834 
          i_0 = 0;
          #line 834 
          while (i_0 <= 15) {
            #line 835 
            if (pf->veb[i_0] != (struct i40e_veb *)0 && (int)(pf->veb[i_0])->seid == veb_seid) 
              #line 836 
              break;
            #line 834 
            i_0 ++;
          }
          #line 837 
          if (i_0 > 15) {
            #line 838 
            _dev_info(& (pf->pdev)->dev,(char *)"del relay: relay %d not found\n",veb_seid);
            #line 840 
            goto command_write_done;
          }
          #line 843 
          _dev_info(& (pf->pdev)->dev,(char *)"deleting relay %d\n",veb_seid);
          #line 844 
          i40e_veb_release(pf->veb[i_0]);
        }
        else {
          #line 845 
          if (cif_strncmp_0(cmd_buf,(char *)"add pvid",8UL) == 0) {
            #line 846 
            i40e_status ret;
            #line 847 
            u16 vid;
            #line 848 
            unsigned int v;
            #line 850 
            cnt = sscanf(cmd_buf + 8U,(char *)"%i %u",& vsi_seid,& v);
            #line 851 
            if (cnt != 2) {
              #line 852 
              _dev_info(& (pf->pdev)->dev,(char *)"add pvid: bad command string, cnt=%d\n",cnt);
              #line 854 
              goto command_write_done;
            }
            #line 857 
            vsi = i40e_dbg_find_vsi(pf,vsi_seid);
            #line 858 
            if (vsi == (struct i40e_vsi *)0) {
              #line 859 
              _dev_info(& (pf->pdev)->dev,(char *)"add pvid: VSI %d not found\n",vsi_seid);
              #line 861 
              goto command_write_done;
            }
            #line 864 
            vid = (unsigned short)v;
            #line 865 
            ret = (enum i40e_status_code)i40e_vsi_add_pvid(vsi,(unsigned short)((int)vid));
            #line 866 
            if (ret == I40E_SUCCESS) 
                                     #line 867 
                                     _dev_info(& (pf->pdev)->dev,(char *)"add pvid: %d added to VSI %d\n",(int)vid,vsi_seid); else 
                                                                    #line 871 
                                                                    _dev_info(& (pf->pdev)->dev,(char *)"add pvid: %d to VSI %d failed, ret=%d\n",(int)vid,vsi_seid,(int)ret);
          }
          else {
            #line 875 
            if (cif_strncmp_0(cmd_buf,(char *)"del pvid",8UL) == 0) {
              #line 877 
              cnt = sscanf(cmd_buf + 8U,(char *)"%i",& vsi_seid);
              #line 878 
              if (cnt != 1) {
                #line 879 
                _dev_info(& (pf->pdev)->dev,(char *)"del pvid: bad command string, cnt=%d\n",cnt);
                #line 882 
                goto command_write_done;
              }
              #line 885 
              vsi = i40e_dbg_find_vsi(pf,vsi_seid);
              #line 886 
              if (vsi == (struct i40e_vsi *)0) {
                #line 887 
                _dev_info(& (pf->pdev)->dev,(char *)"del pvid: VSI %d not found\n",vsi_seid);
                #line 889 
                goto command_write_done;
              }
              #line 892 
              i40e_vsi_remove_pvid(vsi);
              #line 893 
              _dev_info(& (pf->pdev)->dev,(char *)"del pvid: removed from VSI %d\n",vsi_seid);
            }
            else {
              #line 896 
              if (cif_strncmp_0(cmd_buf,(char *)"dump",4UL) == 0) {
                #line 897 
                if (cif_strncmp_0(cmd_buf + 5U,(char *)"switch",6UL) == 0) 
                  #line 898 
                  i40e_fetch_switch_configuration(pf,(_Bool)1);
                else {
                  #line 899 
                  if (cif_strncmp_0(cmd_buf + 5U,(char *)"vsi",3UL) == 0) {
                    #line 900 
                    cnt = sscanf(cmd_buf + 8U,(char *)"%i",& vsi_seid);
                    #line 901 
                    if (cnt > 0) 
                                 #line 902 
                                 i40e_dbg_dump_vsi_seid(pf,vsi_seid); else 
                                                                    #line 904 
                                                                    i40e_dbg_dump_vsi_no_seid(pf);
                  }
                  else {
                    #line 905 
                    if (cif_strncmp_0(cmd_buf + 5U,(char *)"veb",3UL) == 0) {
                      #line 906 
                      cnt = sscanf(cmd_buf + 8U,(char *)"%i",& vsi_seid);
                      #line 907 
                      if (cnt > 0) 
                                   #line 908 
                                   i40e_dbg_dump_veb_seid(pf,vsi_seid); else 
                                                                    #line 910 
                                                                    i40e_dbg_dump_veb_all(pf);
                    }
                    else {
                      #line 911 
                      if (cif_strncmp_0(cmd_buf + 5U,(char *)"vf",2UL) == 0) {
                        #line 912 
                        cnt = sscanf(cmd_buf + 7U,(char *)"%i",& vf_id);
                        #line 913 
                        if (cnt > 0) 
                                     #line 914 
                                     i40e_dbg_dump_vf(pf,vf_id); else 
                                                                   #line 916 
                                                                   i40e_dbg_dump_vf_all(pf);
                      }
                      else {
                        #line 917 
                        if (cif_strncmp_0(cmd_buf + 5U,(char *)"desc",4UL) == 0) {
                          #line 918 
                          int ring_id;
                          #line 918 
                          int desc_n;
                          #line 919 
                          if (cif_strncmp_0(cmd_buf + 10U,(char *)"rx",2UL) == 0) {
                            #line 920 
                            cnt = sscanf(cmd_buf + 12U,(char *)"%i %i %i",& vsi_seid,& ring_id,& desc_n);
                            #line 922 
                            i40e_dbg_dump_desc(cnt,vsi_seid,ring_id,desc_n,pf,(_Bool)1);
                          }
                          else {
                            #line 924 
                            if (cif_strncmp_0(cmd_buf + 10U,(char *)"tx",2UL) == 0) {
                              #line 926 
                              cnt = sscanf(cmd_buf + 12U,(char *)"%i %i %i",& vsi_seid,& ring_id,& desc_n);
                              #line 928 
                              i40e_dbg_dump_desc(cnt,vsi_seid,ring_id,desc_n,pf,(_Bool)0);
                            }
                            else {
                              #line 930 
                              if (cif_strncmp_0(cmd_buf + 10U,(char *)"aq",2UL) == 0) 
                                #line 931 
                                i40e_dbg_dump_aq_desc(pf);
                              else {
                                #line 933 
                                _dev_info(& (pf->pdev)->dev,(char *)"dump desc tx <vsi_seid> <ring_id> [<desc_n>]\n");
                                #line 935 
                                _dev_info(& (pf->pdev)->dev,(char *)"dump desc rx <vsi_seid> <ring_id> [<desc_n>]\n");
                                #line 937 
                                _dev_info(& (pf->pdev)->dev,(char *)"dump desc aq\n");
                              }
                            }
                          }
                        }
                        else {
                          #line 939 
                          if (cif_strncmp_0(cmd_buf + 5U,(char *)"reset stats",11UL) == 0) {
                            #line 940 
                            _dev_info(& (pf->pdev)->dev,(char *)"core reset count: %d\n",(int)pf->corer_count);
                            #line 942 
                            _dev_info(& (pf->pdev)->dev,(char *)"global reset count: %d\n",(int)pf->globr_count);
                            #line 944 
                            _dev_info(& (pf->pdev)->dev,(char *)"emp reset count: %d\n",(int)pf->empr_count);
                            #line 946 
                            _dev_info(& (pf->pdev)->dev,(char *)"pf reset count: %d\n",(int)pf->pfr_count);
                            #line 948 
                            _dev_info(& (pf->pdev)->dev,(char *)"pf tx sluggish count: %d\n",pf->tx_sluggish_count);
                          }
                          else {
                            #line 951 
                            if (cif_strncmp_0(cmd_buf + 5U,(char *)"port",4UL) == 0) {
                              #line 952 
                              struct i40e_aqc_query_port_ets_config_resp *bw_data;
                              #line 957 
                              int i_1;
                              #line 957 
                              int ret_0;
                              #line 958 
                              u16 switch_id;
                              #line 953 
                              struct i40e_dcbx_config *cfg = & pf->hw.local_dcbx_config;
                              #line 955 
                              struct i40e_dcbx_config *r_cfg = & pf->hw.remote_dcbx_config;
                              #line 960 
                              bw_data = (struct i40e_aqc_query_port_ets_config_resp *)kzalloc_3(68UL,3264U);
                              #line 963 
                              if (bw_data == (struct i40e_aqc_query_port_ets_config_resp *)0) {
                                #line 964 
                                ret_0 = -12;
                                #line 965 
                                goto command_write_done;
                              }
                              #line 968 
                              vsi = *(pf->vsi + (unsigned long)pf->lan_vsi);
                              #line 969 
                              switch_id = (unsigned short)((unsigned int)vsi->info.switch_id & 4095U);
                              #line 973 
                              ret_0 = (int)i40e_aq_query_port_ets_config(& pf->hw,
                                      (unsigned short)((int)switch_id),
                                      bw_data,
                                      (struct i40e_asq_cmd_details *)0);
                              #line 976 
                              if (ret_0 != 0) {
                                #line 977 
                                _dev_info(& (pf->pdev)->dev,(char *)"Query Port ETS Config AQ command failed =0x%x\n",(unsigned int)pf->hw.aq.asq_last_status);
                                #line 980 
                                kfree((void *)bw_data);
                                #line 981 
                                bw_data = (struct i40e_aqc_query_port_ets_config_resp *)0;
                                #line 982 
                                goto command_write_done;
                              }
                              #line 984 
                              _dev_info(& (pf->pdev)->dev,(char *)"port bw: tc_valid=0x%x tc_strict_prio=0x%x, tc_bw_max=0x%04x,0x%04x\n",(int)bw_data->tc_valid_bits,(int)bw_data->tc_strict_priority_bits,(int)bw_data->tc_bw_max[0],(int)bw_data->tc_bw_max[1]);
                              #line 990 
                              i_1 = 0;
                              #line 990 
                              while (i_1 <= 7) {
                                #line 991 
                                _dev_info(& (pf->pdev)->dev,(char *)"port bw: tc_bw_share=%d tc_bw_limit=%d\n",(int)bw_data->tc_bw_share_credits[i_1],(int)bw_data->tc_bw_limits[i_1]);
                                #line 990 
                                i_1 ++;
                              }
                              #line 996 
                              kfree((void *)bw_data);
                              #line 997 
                              bw_data = (struct i40e_aqc_query_port_ets_config_resp *)0;
                              #line 999 
                              _dev_info(& (pf->pdev)->dev,(char *)"port dcbx_mode=%d\n",(int)cfg->dcbx_mode);
                              #line 1001 
                              _dev_info(& (pf->pdev)->dev,(char *)"port ets_cfg: willing=%d cbs=%d, maxtcs=%d\n",(int)cfg->etscfg.willing,(int)cfg->etscfg.cbs,(int)cfg->etscfg.maxtcs);
                              #line 1005 
                              i_1 = 0;
                              #line 1005 
                              while (i_1 <= 7) {
                                #line 1006 
                                _dev_info(& (pf->pdev)->dev,(char *)"port ets_cfg: %d prio_tc=%d tcbw=%d tctsa=%d\n",i_1,(int)cfg->etscfg.prioritytable[i_1],(int)cfg->etscfg.tcbwtable[i_1],(int)cfg->etscfg.tsatable[i_1]);
                                #line 1005 
                                i_1 ++;
                              }
                              #line 1011 
                              i_1 = 0;
                              #line 1011 
                              while (i_1 <= 7) {
                                #line 1012 
                                _dev_info(& (pf->pdev)->dev,(char *)"port ets_rec: %d prio_tc=%d tcbw=%d tctsa=%d\n",i_1,(int)cfg->etsrec.prioritytable[i_1],(int)cfg->etsrec.tcbwtable[i_1],(int)cfg->etsrec.tsatable[i_1]);
                                #line 1011 
                                i_1 ++;
                              }
                              #line 1017 
                              _dev_info(& (pf->pdev)->dev,(char *)"port pfc_cfg: willing=%d mbc=%d, pfccap=%d pfcenable=0x%x\n",(int)cfg->pfc.willing,(int)cfg->pfc.mbc,(int)cfg->pfc.pfccap,(int)cfg->pfc.pfcenable);
                              #line 1021 
                              _dev_info(& (pf->pdev)->dev,(char *)"port app_table: num_apps=%d\n",cfg->numapps);
                              #line 1023 
                              i_1 = 0;
                              #line 1023 
                              while (cfg->numapps > (unsigned int)i_1) {
                                #line 1024 
                                _dev_info(& (pf->pdev)->dev,(char *)"port app_table: %d prio=%d selector=%d protocol=0x%x\n",i_1,(int)cfg->app[i_1].priority,(int)cfg->app[i_1].selector,(int)cfg->app[i_1].protocolid);
                                #line 1023 
                                i_1 ++;
                              }
                              #line 1030 
                              _dev_info(& (pf->pdev)->dev,(char *)"remote port ets_cfg: willing=%d cbs=%d, maxtcs=%d\n",(int)r_cfg->etscfg.willing,(int)r_cfg->etscfg.cbs,(int)r_cfg->etscfg.maxtcs);
                              #line 1034 
                              i_1 = 0;
                              #line 1034 
                              while (i_1 <= 7) {
                                #line 1035 
                                _dev_info(& (pf->pdev)->dev,(char *)"remote port ets_cfg: %d prio_tc=%d tcbw=%d tctsa=%d\n",i_1,(int)r_cfg->etscfg.prioritytable[i_1],(int)r_cfg->etscfg.tcbwtable[i_1],(int)r_cfg->etscfg.tsatable[i_1]);
                                #line 1034 
                                i_1 ++;
                              }
                              #line 1040 
                              i_1 = 0;
                              #line 1040 
                              while (i_1 <= 7) {
                                #line 1041 
                                _dev_info(& (pf->pdev)->dev,(char *)"remote port ets_rec: %d prio_tc=%d tcbw=%d tctsa=%d\n",i_1,(int)r_cfg->etsrec.prioritytable[i_1],(int)r_cfg->etsrec.tcbwtable[i_1],(int)r_cfg->etsrec.tsatable[i_1]);
                                #line 1040 
                                i_1 ++;
                              }
                              #line 1046 
                              _dev_info(& (pf->pdev)->dev,(char *)"remote port pfc_cfg: willing=%d mbc=%d, pfccap=%d pfcenable=0x%x\n",(int)r_cfg->pfc.willing,(int)r_cfg->pfc.mbc,(int)r_cfg->pfc.pfccap,(int)r_cfg->pfc.pfcenable);
                              #line 1052 
                              _dev_info(& (pf->pdev)->dev,(char *)"remote port app_table: num_apps=%d\n",r_cfg->numapps);
                              #line 1055 
                              i_1 = 0;
                              #line 1055 
                              while (r_cfg->numapps > (unsigned int)i_1) {
                                #line 1056 
                                _dev_info(& (pf->pdev)->dev,(char *)"remote port app_table: %d prio=%d selector=%d protocol=0x%x\n",i_1,(int)r_cfg->app[i_1].priority,(int)r_cfg->app[i_1].selector,(int)r_cfg->app[i_1].protocolid);
                                #line 1055 
                                i_1 ++;
                              }
                            }
                            else {
                              #line 1061 
                              if (cif_strncmp_0(cmd_buf + 5U,(char *)"debug fwdata",12UL) == 0) {
                                #line 1062 
                                int cluster_id;
                                #line 1062 
                                int table_id;
                                #line 1063 
                                int index;
                                #line 1063 
                                int ret_1;
                                #line 1065 
                                u32 next_index;
                                #line 1066 
                                u8 next_table;
                                #line 1067 
                                u8 *buff;
                                #line 1068 
                                u16 rlen;
                                #line 1064 
                                u16 buff_len = (unsigned short)4096U;
                                #line 1070 
                                cnt = sscanf(cmd_buf + 18U,(char *)"%i %i %i",& cluster_id,& table_id,& index);
                                #line 1072 
                                if (cnt != 3) {
                                  #line 1073 
                                  _dev_info(& (pf->pdev)->dev,(char *)"dump debug fwdata <cluster_id> <table_id> <index>\n");
                                  #line 1075 
                                  goto command_write_done;
                                }
                                #line 1078 
                                _dev_info(& (pf->pdev)->dev,(char *)"AQ debug dump fwdata params %x %x %x %x\n",cluster_id,table_id,index,(int)buff_len);
                                #line 1081 
                                buff = (u8 *)kzalloc_3((unsigned long)buff_len,3264U);
                                #line 1082 
                                if (buff == (u8 *)0U) 
                                                      #line 1083 
                                                      goto command_write_done;
                                #line 1085 
                                ret_1 = (int)i40e_aq_debug_dump(& pf->hw,
                           (unsigned char)((int)((unsigned char)cluster_id)),
                           (unsigned char)((int)((unsigned char)table_id)),
                           (unsigned int)index,
                           (unsigned short)((int)buff_len),(void *)buff,
                           & rlen,& next_table,& next_index,
                           (struct i40e_asq_cmd_details *)0);
                                #line 1089 
                                if (ret_1 != 0) {
                                  #line 1090 
                                  _dev_info(& (pf->pdev)->dev,(char *)"debug dump fwdata AQ Failed %d 0x%x\n",ret_1,(unsigned int)pf->hw.aq.asq_last_status);
                                  #line 1093 
                                  kfree((void *)buff);
                                  #line 1094 
                                  buff = (u8 *)0U;
                                  #line 1095 
                                  goto command_write_done;
                                }
                                #line 1097 
                                _dev_info(& (pf->pdev)->dev,(char *)"AQ debug dump fwdata rlen=0x%x next_table=0x%x next_index=0x%x\n",(int)rlen,(int)next_table,next_index);
                                #line 1100 
                                print_hex_dump((char *)"\001",(char *)"AQ buffer WB: ",2,16,1,(void *)buff,(unsigned long)rlen,(_Bool)1);
                                #line 1103 
                                kfree((void *)buff);
                                #line 1104 
                                buff = (u8 *)0U;
                              }
                              else {
                                #line 1106 
                                _dev_info(& (pf->pdev)->dev,(char *)"dump desc tx <vsi_seid> <ring_id> [<desc_n>], dump desc rx <vsi_seid> <ring_id> [<desc_n>],\n");
                                #line 1108 
                                _dev_info(& (pf->pdev)->dev,(char *)"dump switch\n");
                                #line 1109 
                                _dev_info(& (pf->pdev)->dev,(char *)"dump vsi [seid]\n");
                                #line 1110 
                                _dev_info(& (pf->pdev)->dev,(char *)"dump reset stats\n");
                                #line 1111 
                                _dev_info(& (pf->pdev)->dev,(char *)"dump port\n");
                                #line 1112 
                                _dev_info(& (pf->pdev)->dev,(char *)"dump vf [vf_id]\n");
                                #line 1113 
                                _dev_info(& (pf->pdev)->dev,(char *)"dump debug fwdata <cluster_id> <table_id> <index>\n");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              else {
                #line 1116 
                if (cif_strncmp_0(cmd_buf,(char *)"pfr",3UL) == 0) {
                  #line 1117 
                  _dev_info(& (pf->pdev)->dev,(char *)"debugfs: forcing PFR\n");
                  #line 1118 
                  i40e_do_reset_safe(pf,8192U);
                }
                else {
                  #line 1120 
                  if (cif_strncmp_0(cmd_buf,(char *)"corer",5UL) == 0) {
                    #line 1121 
                    _dev_info(& (pf->pdev)->dev,(char *)"debugfs: forcing CoreR\n");
                    #line 1122 
                    i40e_do_reset_safe(pf,16384U);
                  }
                  else {
                    #line 1124 
                    if (cif_strncmp_0(cmd_buf,(char *)"globr",5UL) == 0) {
                      #line 1125 
                      _dev_info(& (pf->pdev)->dev,(char *)"debugfs: forcing GlobR\n");
                      #line 1126 
                      i40e_do_reset_safe(pf,32768U);
                    }
                    else {
                      #line 1128 
                      if (cif_strncmp_0(cmd_buf,(char *)"read",4UL) == 0) {
                        #line 1129 
                        u32 address;
                        #line 1130 
                        u32 value;
                        #line 1132 
                        cnt = sscanf(cmd_buf + 4U,(char *)"%i",& address);
                        #line 1133 
                        if (cnt != 1) {
                          #line 1134 
                          _dev_info(& (pf->pdev)->dev,(char *)"read <reg>\n");
                          #line 1135 
                          goto command_write_done;
                        }
                        #line 1139 
                        if ((unsigned long)address > (unsigned long)pf->ioremap_len + 18446744073709551612UL) {
                          #line 1140 
                          _dev_info(& (pf->pdev)->dev,(char *)"read reg address 0x%08x too large, max=0x%08lx\n",address,(unsigned long)pf->ioremap_len + 18446744073709551612UL);
                          #line 1142 
                          goto command_write_done;
                        }
                        #line 1145 
                        value = readl((void *)(pf->hw.hw_addr + (unsigned long)address));
                        #line 1146 
                        _dev_info(& (pf->pdev)->dev,(char *)"read: 0x%08x = 0x%08x\n",address,value);
                      }
                      else {
                        #line 1149 
                        if (cif_strncmp_0(cmd_buf,(char *)"write",5UL) == 0) {
                          #line 1150 
                          u32 address_0;
                          #line 1150 
                          u32 value_0;
                          #line 1152 
                          cnt = sscanf(cmd_buf + 5U,(char *)"%i %i",& address_0,& value_0);
                          #line 1153 
                          if (cnt != 2) {
                            #line 1154 
                            _dev_info(& (pf->pdev)->dev,(char *)"write <reg> <value>\n");
                            #line 1155 
                            goto command_write_done;
                          }
                          #line 1159 
                          if ((unsigned long)address_0 > (unsigned long)pf->ioremap_len + 18446744073709551612UL) {
                            #line 1160 
                            _dev_info(& (pf->pdev)->dev,(char *)"write reg address 0x%08x too large, max=0x%08lx\n",address_0,(unsigned long)pf->ioremap_len + 18446744073709551612UL);
                            #line 1162 
                            goto command_write_done;
                          }
                          #line 1164 
                          writel(value_0,(void *)(pf->hw.hw_addr + (unsigned long)address_0));
                          #line 1165 
                          value_0 = readl((void *)(pf->hw.hw_addr + (unsigned long)address_0));
                          #line 1166 
                          _dev_info(& (pf->pdev)->dev,(char *)"write: 0x%08x = 0x%08x\n",address_0,value_0);
                        }
                        else {
                          #line 1168 
                          if (cif_strncmp_0(cmd_buf,(char *)"clear_stats",11UL) == 0) {
                            #line 1169 
                            if (cif_strncmp_0(cmd_buf + 12U,(char *)"vsi",3UL) == 0) {
                              #line 1170 
                              cnt = sscanf(cmd_buf + 15U,(char *)"%i",& vsi_seid);
                              #line 1171 
                              if (cnt == 0) {
                                #line 1172 
                                int i_2;
                                #line 1174 
                                i_2 = 0;
                                #line 1174 
                                while ((int)pf->num_alloc_vsi > i_2) {
                                  #line 1175 
                                  i40e_vsi_reset_stats(*(pf->vsi + (unsigned long)i_2));
                                  #line 1174 
                                  i_2 ++;
                                }
                                #line 1176 
                                _dev_info(& (pf->pdev)->dev,(char *)"vsi clear stats called for all vsi\'s\n");
                              }
                              else 
                                #line 1177 
                                if (cnt == 1) {
                                  #line 1178 
                                  vsi = i40e_dbg_find_vsi(pf,vsi_seid);
                                  #line 1179 
                                  if (vsi == (struct i40e_vsi *)0) {
                                    #line 1180 
                                    _dev_info(& (pf->pdev)->dev,(char *)"clear_stats vsi: bad vsi %d\n",vsi_seid);
                                    #line 1183 
                                    goto command_write_done;
                                  }
                                  #line 1185 
                                  i40e_vsi_reset_stats(vsi);
                                  #line 1186 
                                  _dev_info(& (pf->pdev)->dev,(char *)"vsi clear stats called for vsi %d\n",vsi_seid);
                                }
                                else 
                                     #line 1190 
                                     _dev_info(& (pf->pdev)->dev,(char *)"clear_stats vsi [seid]\n");
                            }
                            else {
                              #line 1192 
                              if (cif_strncmp_0(cmd_buf + 12U,(char *)"port",4UL) == 0) 
                                #line 1193 
                                if ((unsigned int)pf->hw.partition_id == 1U) {
                                  #line 1194 
                                  i40e_pf_reset_stats(pf);
                                  #line 1195 
                                  _dev_info(& (pf->pdev)->dev,(char *)"port stats cleared\n");
                                }
                                else 
                                     #line 1197 
                                     _dev_info(& (pf->pdev)->dev,(char *)"clear port stats not allowed on this port partition\n");
                              else 
                                   #line 1200 
                                   _dev_info(& (pf->pdev)->dev,(char *)"clear_stats vsi [seid] or clear_stats port\n");
                            }
                          }
                          else {
                            #line 1202 
                            if (cif_strncmp_0(cmd_buf,(char *)"send aq_cmd",11UL) == 0) {
                              #line 1203 
                              struct i40e_aq_desc *desc;
                              #line 1204 
                              i40e_status ret_2;
                              #line 1206 
                              desc = (struct i40e_aq_desc *)kzalloc_3(32UL,3264U);
                              #line 1207 
                              if (desc == (struct i40e_aq_desc *)0) 
                                                                    #line 1208 
                                                                    goto command_write_done;
                              #line 1209 
                              cnt = sscanf(cmd_buf + 11U,(char *)"%hi %hi %hi %hi %i %i %i %i %i %i",& desc->flags,& desc->opcode,& desc->datalen,& desc->retval,& desc->cookie_high,& desc->cookie_low,& desc->params.internal.param0,& desc->params.internal.param1,& desc->params.internal.param2,& desc->params.internal.param3);
                              #line 1218 
                              if (cnt != 10) {
                                #line 1219 
                                _dev_info(& (pf->pdev)->dev,(char *)"send aq_cmd: bad command string, cnt=%d\n",cnt);
                                #line 1222 
                                kfree((void *)desc);
                                #line 1223 
                                desc = (struct i40e_aq_desc *)0;
                                #line 1224 
                                goto command_write_done;
                              }
                              #line 1226 
                              ret_2 = i40e_asq_send_command(& pf->hw,desc,(void *)0,(unsigned short)0,(struct i40e_asq_cmd_details *)0);
                              #line 1227 
                              if (ret_2 == I40E_SUCCESS) 
                                                         #line 1228 
                                                         _dev_info(& (pf->pdev)->dev,(char *)"AQ command sent Status : Success\n");
                              else 
                                #line 1229 
                                if (ret_2 == I40E_ERR_ADMIN_QUEUE_ERROR) 
                                  #line 1230 
                                  _dev_info(& (pf->pdev)->dev,(char *)"AQ command send failed Opcode %x AQ Error: %d\n",(int)desc->opcode,(unsigned int)pf->hw.aq.asq_last_status); else 
                                                                    #line 1234 
                                                                    _dev_info(& (pf->pdev)->dev,(char *)"AQ command send failed Opcode %x Status: %d\n",(int)desc->opcode,(int)ret_2);
                              #line 1238 
                              _dev_info(& (pf->pdev)->dev,(char *)"AQ desc WB 0x%04x 0x%04x 0x%04x 0x%04x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",(int)desc->flags,(int)desc->opcode,(int)desc->datalen,(int)desc->retval,desc->cookie_high,desc->cookie_low,desc->params.internal.param0,desc->params.internal.param1,desc->params.internal.param2,desc->params.internal.param3);
                              #line 1246 
                              kfree((void *)desc);
                              #line 1247 
                              desc = (struct i40e_aq_desc *)0;
                            }
                            else {
                              #line 1248 
                              if (cif_strncmp_0(cmd_buf,(char *)"send indirect aq_cmd",20UL) == 0) {
                                #line 1249 
                                struct i40e_aq_desc *desc_0;
                                #line 1250 
                                i40e_status ret_3;
                                #line 1251 
                                u16 buffer_len;
                                #line 1252 
                                u8 *buff_0;
                                #line 1254 
                                desc_0 = (struct i40e_aq_desc *)kzalloc_3(32UL,3264U);
                                #line 1255 
                                if (desc_0 == (struct i40e_aq_desc *)0) 
                                  #line 1256 
                                  goto command_write_done;
                                #line 1257 
                                cnt = sscanf(cmd_buf + 20U,(char *)"%hi %hi %hi %hi %i %i %i %i %i %i %hi",& desc_0->flags,& desc_0->opcode,& desc_0->datalen,& desc_0->retval,& desc_0->cookie_high,& desc_0->cookie_low,& desc_0->params.internal.param0,& desc_0->params.internal.param1,& desc_0->params.internal.param2,& desc_0->params.internal.param3,& buffer_len);
                                #line 1267 
                                if (cnt != 11) {
                                  #line 1268 
                                  _dev_info(& (pf->pdev)->dev,(char *)"send indirect aq_cmd: bad command string, cnt=%d\n",cnt);
                                  #line 1271 
                                  kfree((void *)desc_0);
                                  #line 1272 
                                  desc_0 = (struct i40e_aq_desc *)0;
                                  #line 1273 
                                  goto command_write_done;
                                }
                                #line 1276 
                                if ((unsigned int)buffer_len == 0U) 
                                                                    #line 1277 
                                                                    buffer_len = (unsigned short)1280U;
                                #line 1279 
                                buff_0 = (u8 *)kzalloc_3((unsigned long)buffer_len,3264U);
                                #line 1280 
                                if (buff_0 == (u8 *)0U) {
                                  #line 1281 
                                  kfree((void *)desc_0);
                                  #line 1282 
                                  desc_0 = (struct i40e_aq_desc *)0;
                                  #line 1283 
                                  goto command_write_done;
                                }
                                #line 1285 
                                desc_0->flags = (unsigned short)((unsigned int)desc_0->flags | 4096U);
                                #line 1286 
                                ret_3 = i40e_asq_send_command(& pf->hw,desc_0,(void *)buff_0,(unsigned short)((int)buffer_len),(struct i40e_asq_cmd_details *)0);
                                #line 1288 
                                if (ret_3 == I40E_SUCCESS) 
                                                           #line 1289 
                                                           _dev_info(& (pf->pdev)->dev,(char *)"AQ command sent Status : Success\n");
                                else 
                                  #line 1290 
                                  if (ret_3 == I40E_ERR_ADMIN_QUEUE_ERROR) 
                                    #line 1291 
                                    _dev_info(& (pf->pdev)->dev,(char *)"AQ command send failed Opcode %x AQ Error: %d\n",(int)desc_0->opcode,(unsigned int)pf->hw.aq.asq_last_status); else 
                                                                    #line 1295 
                                                                    _dev_info(& (pf->pdev)->dev,(char *)"AQ command send failed Opcode %x Status: %d\n",(int)desc_0->opcode,(int)ret_3);
                                #line 1299 
                                _dev_info(& (pf->pdev)->dev,(char *)"AQ desc WB 0x%04x 0x%04x 0x%04x 0x%04x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",(int)desc_0->flags,(int)desc_0->opcode,(int)desc_0->datalen,(int)desc_0->retval,desc_0->cookie_high,desc_0->cookie_low,desc_0->params.internal.param0,desc_0->params.internal.param1,desc_0->params.internal.param2,desc_0->params.internal.param3);
                                #line 1307 
                                print_hex_dump((char *)"\001",(char *)"AQ buffer WB: ",2,16,1,(void *)buff_0,(unsigned long)buffer_len,(_Bool)1);
                                #line 1310 
                                kfree((void *)buff_0);
                                #line 1311 
                                buff_0 = (u8 *)0U;
                                #line 1312 
                                kfree((void *)desc_0);
                                #line 1313 
                                desc_0 = (struct i40e_aq_desc *)0;
                              }
                              else {
                                #line 1314 
                                if (cif_strncmp_0(cmd_buf,(char *)"fd current cnt",14UL) == 0) {
                                  #line 1315 
                                  ;
                                  #line 1315 
                                  _dev_info(& (pf->pdev)->dev,(char *)"FD current total filter count for this interface: %d\n",i40e_get_current_fd_count(pf));
                                }
                                else {
                                  #line 1317 
                                  if (cif_strncmp_0(cmd_buf,(char *)"lldp",4UL) == 0) {
                                    #line 1318 
                                    if (cif_strncmp_0(cmd_buf + 5U,(char *)"stop",4UL) == 0) {
                                      #line 1319 
                                      int ret_4;
                                      #line 1321 
                                      ret_4 = (int)i40e_aq_stop_lldp(& pf->hw,(_Bool)0,(_Bool)0,
                           (struct i40e_asq_cmd_details *)0);
                                      #line 1322 
                                      if (ret_4 != 0) {
                                        #line 1323 
                                        _dev_info(& (pf->pdev)->dev,(char *)"Stop LLDP AQ command failed =0x%x\n",(unsigned int)pf->hw.aq.asq_last_status);
                                        #line 1326 
                                        goto command_write_done;
                                      }
                                      #line 1328 
                                      ret_4 = (int)i40e_aq_add_rem_control_packet_filter(& pf->hw,
                                               (u8 *)(& pf->hw.mac.addr),
                                               (unsigned short)35020,
                                               (unsigned short)0,
                                               (unsigned short)((int)(*(
                                               pf->vsi + (unsigned long)pf->lan_vsi))->seid),
                                               (unsigned short)0,(_Bool)1,
                                               (struct i40e_control_filter_stats *)0,
                                               (struct i40e_asq_cmd_details *)0);
                                      #line 1333 
                                      if (ret_4 != 0) {
                                        #line 1334 
                                        _dev_info(& (pf->pdev)->dev,(char *)"%s: Add Control Packet Filter AQ command failed =0x%x\n",(char *)"i40e_dbg_command_write",(unsigned int)pf->hw.aq.asq_last_status);
                                        #line 1337 
                                        goto command_write_done;
                                      }
                                      #line 1340 
                                      pf->dcbx_cap = (unsigned short)9U;
                                    }
                                    else {
                                      #line 1343 
                                      if (cif_strncmp_0(cmd_buf + 5U,(char *)"start",5UL) == 0) {
                                        #line 1344 
                                        int ret_5;
                                        #line 1346 
                                        ret_5 = (int)i40e_aq_add_rem_control_packet_filter(& pf->hw,
                                               (u8 *)(& pf->hw.mac.addr),
                                               (unsigned short)35020,
                                               (unsigned short)0,
                                               (unsigned short)((int)(*(
                                               pf->vsi + (unsigned long)pf->lan_vsi))->seid),
                                               (unsigned short)0,(_Bool)0,
                                               (struct i40e_control_filter_stats *)0,
                                               (struct i40e_asq_cmd_details *)0);
                                        #line 1351 
                                        if (ret_5 != 0) 
                                                        #line 1352 
                                                        _dev_info(& (pf->pdev)->dev,(char *)"%s: Remove Control Packet Filter AQ command failed =0x%x\n",(char *)"i40e_dbg_command_write",(unsigned int)pf->hw.aq.asq_last_status);
                                        #line 1358 
                                        ret_5 = (int)i40e_aq_start_lldp(& pf->hw,(_Bool)0,
                            (struct i40e_asq_cmd_details *)0);
                                        #line 1359 
                                        if (ret_5 != 0) {
                                          #line 1360 
                                          _dev_info(& (pf->pdev)->dev,(char *)"Start LLDP AQ command failed =0x%x\n",(unsigned int)pf->hw.aq.asq_last_status);
                                          #line 1363 
                                          goto command_write_done;
                                        }
                                        #line 1366 
                                        pf->dcbx_cap = (unsigned short)10U;
                                      }
                                      else {
                                        #line 1369 
                                        if (cif_strncmp_0(cmd_buf + 5U,(char *)"get local",9UL) == 0) {
                                          #line 1371 
                                          u16 llen;
                                          #line 1371 
                                          u16 rlen_0;
                                          #line 1372 
                                          int ret_6;
                                          #line 1373 
                                          u8 *buff_1;
                                          #line 1375 
                                          buff_1 = (u8 *)kzalloc_3(1500UL,3264U);
                                          #line 1376 
                                          if (buff_1 == (u8 *)0U) 
                                                                  #line 1377 
                                                                  goto command_write_done;
                                          #line 1379 
                                          ret_6 = (int)i40e_aq_get_lldp_mib(& pf->hw,(unsigned char)0,(unsigned char)0,
                              (void *)buff_1,(unsigned short)1500,& llen,
                              & rlen_0,(struct i40e_asq_cmd_details *)0);
                                          #line 1383 
                                          if (ret_6 != 0) {
                                            #line 1384 
                                            _dev_info(& (pf->pdev)->dev,(char *)"Get LLDP MIB (local) AQ command failed =0x%x\n",(unsigned int)pf->hw.aq.asq_last_status);
                                            #line 1387 
                                            kfree((void *)buff_1);
                                            #line 1388 
                                            buff_1 = (u8 *)0U;
                                            #line 1389 
                                            goto command_write_done;
                                          }
                                          #line 1391 
                                          _dev_info(& (pf->pdev)->dev,(char *)"LLDP MIB (local)\n");
                                          #line 1392 
                                          print_hex_dump((char *)"\001",(char *)"LLDP MIB (local): ",2,16,1,(void *)buff_1,1500UL,(_Bool)1);
                                          #line 1395 
                                          kfree((void *)buff_1);
                                          #line 1396 
                                          buff_1 = (u8 *)0U;
                                        }
                                        else {
                                          #line 1397 
                                          if (cif_strncmp_0(cmd_buf + 5U,(char *)"get remote",10UL) == 0) {
                                            #line 1398 
                                            u16 llen_0;
                                            #line 1398 
                                            u16 rlen_1;
                                            #line 1399 
                                            int ret_7;
                                            #line 1400 
                                            u8 *buff_2;
                                            #line 1402 
                                            buff_2 = (u8 *)kzalloc_3(1500UL,3264U);
                                            #line 1403 
                                            if (buff_2 == (u8 *)0U) 
                                                                    #line 1404 
                                                                    goto command_write_done;
                                            #line 1406 
                                            ret_7 = (int)i40e_aq_get_lldp_mib(& pf->hw,(unsigned char)0,(unsigned char)1,
                              (void *)buff_2,(unsigned short)1500,& llen_0,
                              & rlen_1,(struct i40e_asq_cmd_details *)0);
                                            #line 1411 
                                            if (ret_7 != 0) {
                                              #line 1412 
                                              _dev_info(& (pf->pdev)->dev,(char *)"Get LLDP MIB (remote) AQ command failed =0x%x\n",(unsigned int)pf->hw.aq.asq_last_status);
                                              #line 1415 
                                              kfree((void *)buff_2);
                                              #line 1416 
                                              buff_2 = (u8 *)0U;
                                              #line 1417 
                                              goto command_write_done;
                                            }
                                            #line 1419 
                                            _dev_info(& (pf->pdev)->dev,(char *)"LLDP MIB (remote)\n");
                                            #line 1420 
                                            print_hex_dump((char *)"\001",(char *)"LLDP MIB (remote): ",2,16,1,(void *)buff_2,1500UL,(_Bool)1);
                                            #line 1423 
                                            kfree((void *)buff_2);
                                            #line 1424 
                                            buff_2 = (u8 *)0U;
                                          }
                                          else {
                                            #line 1425 
                                            if (cif_strncmp_0(cmd_buf + 5U,(char *)"event on",8UL) == 0) {
                                              #line 1426 
                                              int ret_8;
                                              #line 1428 
                                              ret_8 = (int)i40e_aq_cfg_lldp_mib_change_event(& pf->hw,(_Bool)1,
                                           (struct i40e_asq_cmd_details *)0);
                                              #line 1430 
                                              if (ret_8 != 0) {
                                                #line 1431 
                                                _dev_info(& (pf->pdev)->dev,(char *)"Config LLDP MIB Change Event (on) AQ command failed =0x%x\n",(unsigned int)pf->hw.aq.asq_last_status);
                                                #line 1434 
                                                goto command_write_done;
                                              }
                                            }
                                            else {
                                              #line 1436 
                                              if (cif_strncmp_0(cmd_buf + 5U,(char *)"event off",9UL) == 0) {
                                                #line 1437 
                                                int ret_9;
                                                #line 1439 
                                                ret_9 = (int)i40e_aq_cfg_lldp_mib_change_event(& pf->hw,(_Bool)0,
                                           (struct i40e_asq_cmd_details *)0);
                                                #line 1441 
                                                if (ret_9 != 0) {
                                                  #line 1442 
                                                  _dev_info(& (pf->pdev)->dev,(char *)"Config LLDP MIB Change Event (off) AQ command failed =0x%x\n",(unsigned int)pf->hw.aq.asq_last_status);
                                                  #line 1445 
                                                  goto command_write_done;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  else {
                                    #line 1448 
                                    if (cif_strncmp_0(cmd_buf,(char *)"nvm read",8UL) == 0) {
                                      #line 1473 
                                      unsigned short __UNIQUE_ID___x558;
                                      #line 1473 
                                      int tmp_39;
                                      #line 1478 
                                      unsigned short __UNIQUE_ID___x562;
                                      #line 1478 
                                      int tmp_43;
                                      #line 1449 
                                      u16 buffer_len_0;
                                      #line 1449 
                                      u16 bytes;
                                      #line 1450 
                                      u16 module;
                                      #line 1451 
                                      u32 offset;
                                      #line 1452 
                                      u16 *buff_3;
                                      #line 1453 
                                      int ret_10;
                                      #line 1455 
                                      cnt = sscanf(cmd_buf + 8U,(char *)"%hx %x %hx",& module,& offset,& buffer_len_0);
                                      #line 1457 
                                      if (cnt == 0) {
                                        #line 1458 
                                        module = (unsigned short)0U;
                                        #line 1459 
                                        offset = 0U;
                                        #line 1460 
                                        buffer_len_0 = (unsigned short)0U;
                                      }
                                      else 
                                        #line 1461 
                                        if (cnt == 1) {
                                          #line 1462 
                                          offset = 0U;
                                          #line 1463 
                                          buffer_len_0 = (unsigned short)0U;
                                        }
                                        else 
                                          #line 1464 
                                          if (cnt == 2) 
                                                        #line 1465 
                                                        buffer_len_0 = (unsigned short)0U;
                                          else 
                                            #line 1466 
                                            if (cnt > 3) {
                                              #line 1467 
                                              _dev_info(& (pf->pdev)->dev,(char *)"nvm read: bad command string, cnt=%d\n",cnt);
                                              #line 1469 
                                              goto command_write_done;
                                            }
                                      {
                                        #line 1473 
                                        __UNIQUE_ID___x558 = buffer_len_0;
                                        #line 1473 
                                        unsigned short __UNIQUE_ID___y559 = (unsigned short)2048U;
                                        #line 1473 
                                        if ((int)__UNIQUE_ID___x558 < (int)__UNIQUE_ID___y559) 
                                          #line 1473 
                                          tmp_39 = (int)__UNIQUE_ID___x558; else 
                                                                    #line 1473 
                                                                    tmp_39 = (int)__UNIQUE_ID___y559;
                                        }
                                      #line 1473 
                                      buffer_len_0 = (unsigned short)tmp_39;
                                      #line 1475 
                                      bytes = (unsigned short)((unsigned int)buffer_len_0 * 2U);
                                      {
                                        #line 1478 
                                        u16 __UNIQUE_ID___x560;
                                        #line 1478 
                                        int tmp_41;
                                        {
                                          #line 1478 
                                          __UNIQUE_ID___x560 = bytes;
                                          #line 1478 
                                          unsigned short __UNIQUE_ID___y561 = (unsigned short)1024U;
                                          #line 1478 
                                          if ((int)__UNIQUE_ID___x560 > (int)__UNIQUE_ID___y561) 
                                            #line 1478 
                                            tmp_41 = (int)__UNIQUE_ID___x560; else 
                                                                    #line 1478 
                                                                    tmp_41 = (int)__UNIQUE_ID___y561;
                                          }
                                        #line 1478 
                                        __UNIQUE_ID___x562 = (unsigned short)tmp_41;
                                        #line 1478 
                                        unsigned short __UNIQUE_ID___y563 = (unsigned short)4096U;
                                        #line 1478 
                                        if ((int)__UNIQUE_ID___x562 < (int)__UNIQUE_ID___y563) 
                                          #line 1478 
                                          tmp_43 = (int)__UNIQUE_ID___x562; else 
                                                                    #line 1478 
                                                                    tmp_43 = (int)__UNIQUE_ID___y563;
                                        }
                                      #line 1478 
                                      bytes = (unsigned short)tmp_43;
                                      #line 1479 
                                      buff_3 = (u16 *)kzalloc_3((unsigned long)bytes,3264U);
                                      #line 1480 
                                      if (buff_3 == (u16 *)0U) 
                                                               #line 1481 
                                                               goto command_write_done;
                                      #line 1483 
                                      ret_10 = (int)i40e_acquire_nvm(& pf->hw,
                          (enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
                                      #line 1484 
                                      if (ret_10 != 0) {
                                        #line 1485 
                                        _dev_info(& (pf->pdev)->dev,(char *)"Failed Acquiring NVM resource for read err=%d status=0x%x\n",ret_10,(unsigned int)pf->hw.aq.asq_last_status);
                                        #line 1488 
                                        kfree((void *)buff_3);
                                        #line 1489 
                                        goto command_write_done;
                                      }
                                      #line 1492 
                                      ret_10 = (int)i40e_aq_read_nvm(& pf->hw,
                          (unsigned char)((int)((unsigned char)module)),
                          offset * 2U,(unsigned short)((int)bytes),
                          (void *)buff_3,(_Bool)1,
                          (struct i40e_asq_cmd_details *)0);
                                      #line 1494 
                                      i40e_release_nvm(& pf->hw);
                                      #line 1495 
                                      if (ret_10 != 0) 
                                                       #line 1496 
                                                       _dev_info(& (pf->pdev)->dev,(char *)"Read NVM AQ failed err=%d status=0x%x\n",ret_10,(unsigned int)pf->hw.aq.asq_last_status);
                                      else {
                                        #line 1500 
                                        _dev_info(& (pf->pdev)->dev,(char *)"Read NVM module=0x%x offset=0x%x words=%d\n",(int)module,offset,(int)buffer_len_0);
                                        #line 1503 
                                        if ((unsigned int)bytes != 0U) 
                                          #line 1504 
                                          print_hex_dump((char *)"\001",(char *)"NVM Dump: ",2,16,2,(void *)buff_3,(unsigned long)bytes,(_Bool)1);
                                      }
                                      #line 1508 
                                      kfree((void *)buff_3);
                                      #line 1509 
                                      buff_3 = (u16 *)0U;
                                    }
                                    else {
                                      #line 1511 
                                      _dev_info(& (pf->pdev)->dev,(char *)"unknown command \'%s\'\n",cmd_buf);
                                      #line 1512 
                                      _dev_info(& (pf->pdev)->dev,(char *)"available commands\n");
                                      #line 1513 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  add vsi [relay_seid]\n");
                                      #line 1514 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  del vsi [vsi_seid]\n");
                                      #line 1515 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  add relay <uplink_seid> <vsi_seid>\n");
                                      #line 1516 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  del relay <relay_seid>\n");
                                      #line 1517 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  add pvid <vsi_seid> <vid>\n");
                                      #line 1518 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  del pvid <vsi_seid>\n");
                                      #line 1519 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  dump switch\n");
                                      #line 1520 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  dump vsi [seid]\n");
                                      #line 1521 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  dump desc tx <vsi_seid> <ring_id> [<desc_n>]\n");
                                      #line 1522 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  dump desc rx <vsi_seid> <ring_id> [<desc_n>]\n");
                                      #line 1523 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  dump desc aq\n");
                                      #line 1524 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  dump reset stats\n");
                                      #line 1525 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  dump debug fwdata <cluster_id> <table_id> <index>\n");
                                      #line 1526 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  read <reg>\n");
                                      #line 1527 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  write <reg> <value>\n");
                                      #line 1528 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  clear_stats vsi [seid]\n");
                                      #line 1529 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  clear_stats port\n");
                                      #line 1530 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  pfr\n");
                                      #line 1531 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  corer\n");
                                      #line 1532 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  globr\n");
                                      #line 1533 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  send aq_cmd <flags> <opcode> <datalen> <retval> <cookie_h> <cookie_l> <param0> <param1> <param2> <param3>\n");
                                      #line 1534 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  send indirect aq_cmd <flags> <opcode> <datalen> <retval> <cookie_h> <cookie_l> <param0> <param1> <param2> <param3> <buffer_len>\n");
                                      #line 1535 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  fd current cnt");
                                      #line 1536 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  lldp start\n");
                                      #line 1537 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  lldp stop\n");
                                      #line 1538 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  lldp get local\n");
                                      #line 1539 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  lldp get remote\n");
                                      #line 1540 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  lldp event on\n");
                                      #line 1541 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  lldp event off\n");
                                      #line 1542 
                                      _dev_info(& (pf->pdev)->dev,(char *)"  nvm read [module] [word_offset] [word_count]\n");
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  #line 1545 
  command_write_done: 
                      #line 1545 
  ;
  #line 1546 
  kfree((void *)cmd_buf);
  #line 1547 
  cmd_buf = (char *)0;
  #line 1548 
  return (long)count;
}

#line 1551  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static struct file_operations i40e_dbg_command_fops = {.owner = & __this_module, .read = & i40e_dbg_command_read, .write = & i40e_dbg_command_write, .open = & simple_open};
#line 1563  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static char i40e_dbg_netdev_ops_buf[256U] = {(char)'\000'};
#line 1572  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static ssize_t i40e_dbg_netdev_ops_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
{
  #line 1576 
  int bytes_not_copied;
  #line 1578 
  char *buf;
  #line 1579 
  int len;
  #line 1575 
  struct i40e_pf *pf = (struct i40e_pf *)filp->private_data;
  #line 1577 
  int buf_size = 256;
  #line 1582 
  if (*ppos != 0LL) 
                    #line 1583 
                    return 0L;
  #line 1584 
  if ((unsigned long)buf_size > count) 
                                       #line 1585 
                                       return -28L;
  #line 1587 
  buf = (char *)kzalloc_3((unsigned long)buf_size,3264U);
  #line 1588 
  if (buf == (char *)0) 
                        #line 1589 
                        return -28L;
  #line 1591 
  len = snprintf(buf,(unsigned long)buf_size,(char *)"%s: %s\n",(char *)(& ((*(pf->vsi + (unsigned long)pf->lan_vsi))->netdev)->name),(char *)(& i40e_dbg_netdev_ops_buf));
  #line 1595 
  bytes_not_copied = (int)copy_to_user((void *)buffer,(void *)buf,(unsigned long)len);
  #line 1596 
  kfree((void *)buf);
  #line 1598 
  if (bytes_not_copied != 0) 
                             #line 1599 
                             return -14L;
  #line 1601 
  *ppos = (long long)len;
  #line 1602 
  return (long)len;
}

#line 1612  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static ssize_t i40e_dbg_netdev_ops_write(struct file *filp, char *buffer, size_t count, loff_t *ppos)
{
  #line 1617 
  int bytes_not_copied;
  #line 1618 
  struct i40e_vsi *vsi;
  #line 1619 
  char *buf_tmp;
  #line 1620 
  int vsi_seid;
  #line 1621 
  int i;
  #line 1621 
  int cnt;
  #line 1616 
  struct i40e_pf *pf = (struct i40e_pf *)filp->private_data;
  #line 1624 
  if (*ppos != 0LL) 
                    #line 1625 
                    return 0L;
  #line 1626 
  if (count > 255UL) 
                     #line 1627 
                     return -28L;
  #line 1629 
  memset((void *)(& i40e_dbg_netdev_ops_buf),0,256UL);
  #line 1630 
  bytes_not_copied = (int)copy_from_user((void *)(& i40e_dbg_netdev_ops_buf),(void *)buffer,
                     count);
  #line 1632 
  if (bytes_not_copied != 0) 
                             #line 1633 
                             return -14L;
  #line 1634 
  i40e_dbg_netdev_ops_buf[count] = (char)0;
  #line 1636 
  buf_tmp = strchr((char *)(& i40e_dbg_netdev_ops_buf),10);
  #line 1637 
  if (buf_tmp != (char *)0) {
    #line 1638 
    *buf_tmp = (char)0;
    #line 1639 
    count = (unsigned long)((buf_tmp - (char *)(& i40e_dbg_netdev_ops_buf)) + 1L);
  }
  #line 1642 
  if (cif_strncmp_0((char *)(& i40e_dbg_netdev_ops_buf),
                      (char *)"change_mtu",10UL) == 0) {
    #line 1643 
    int mtu;
    #line 1645 
    cnt = sscanf(& i40e_dbg_netdev_ops_buf[11],(char *)"%i %i",& vsi_seid,& mtu);
    #line 1647 
    if (cnt != 2) {
      #line 1648 
      _dev_info(& (pf->pdev)->dev,(char *)"change_mtu <vsi_seid> <mtu>\n");
      #line 1649 
      goto netdev_ops_write_done;
    }
    #line 1651 
    vsi = i40e_dbg_find_vsi(pf,vsi_seid);
    #line 1652 
    if (vsi == (struct i40e_vsi *)0) 
                                     #line 1653 
                                     _dev_info(& (pf->pdev)->dev,(char *)"change_mtu: VSI %d not found\n",vsi_seid);
    else 
      #line 1655 
      if (vsi->netdev == (struct net_device *)0) 
                                                 #line 1656 
                                                 _dev_info(& (pf->pdev)->dev,(char *)"change_mtu: no netdev for VSI %d\n",vsi_seid);
      else {
        #line 1658 
        if (rtnl_trylock() != 0) {
          #line 1659 
          (*(((vsi->netdev)->netdev_ops)->ndo_change_mtu))(vsi->netdev,mtu);
          #line 1661 
          rtnl_unlock();
          #line 1662 
          _dev_info(& (pf->pdev)->dev,(char *)"change_mtu called\n");
        }
        else 
             #line 1664 
             _dev_info(& (pf->pdev)->dev,(char *)"Could not acquire RTNL - please try again\n");
      }
  }
  else {
    #line 1667 
    if (cif_strncmp_0((char *)(& i40e_dbg_netdev_ops_buf),
                      (char *)"set_rx_mode",11UL) == 0) {
      #line 1668 
      cnt = sscanf(& i40e_dbg_netdev_ops_buf[11],(char *)"%i",& vsi_seid);
      #line 1669 
      if (cnt != 1) {
        #line 1670 
        _dev_info(& (pf->pdev)->dev,(char *)"set_rx_mode <vsi_seid>\n");
        #line 1671 
        goto netdev_ops_write_done;
      }
      #line 1673 
      vsi = i40e_dbg_find_vsi(pf,vsi_seid);
      #line 1674 
      if (vsi == (struct i40e_vsi *)0) 
                                       #line 1675 
                                       _dev_info(& (pf->pdev)->dev,(char *)"set_rx_mode: VSI %d not found\n",vsi_seid);
      else 
        #line 1677 
        if (vsi->netdev == (struct net_device *)0) 
                                                   #line 1678 
                                                   _dev_info(& (pf->pdev)->dev,(char *)"set_rx_mode: no netdev for VSI %d\n",vsi_seid);
        else {
          #line 1680 
          if (rtnl_trylock() != 0) {
            #line 1681 
            (*(((vsi->netdev)->netdev_ops)->ndo_set_rx_mode))(vsi->netdev);
            #line 1682 
            rtnl_unlock();
            #line 1683 
            _dev_info(& (pf->pdev)->dev,(char *)"set_rx_mode called\n");
          }
          else 
               #line 1685 
               _dev_info(& (pf->pdev)->dev,(char *)"Could not acquire RTNL - please try again\n");
        }
    }
    else {
      #line 1688 
      if (cif_strncmp_0((char *)(& i40e_dbg_netdev_ops_buf),(char *)"napi",4UL) == 0) {
        #line 1689 
        cnt = sscanf(& i40e_dbg_netdev_ops_buf[4],(char *)"%i",& vsi_seid);
        #line 1690 
        if (cnt != 1) {
          #line 1691 
          _dev_info(& (pf->pdev)->dev,(char *)"napi <vsi_seid>\n");
          #line 1692 
          goto netdev_ops_write_done;
        }
        #line 1694 
        vsi = i40e_dbg_find_vsi(pf,vsi_seid);
        #line 1695 
        if (vsi == (struct i40e_vsi *)0) 
                                         #line 1696 
                                         _dev_info(& (pf->pdev)->dev,(char *)"napi: VSI %d not found\n",vsi_seid);
        else 
          #line 1698 
          if (vsi->netdev == (struct net_device *)0) 
                                                     #line 1699 
                                                     _dev_info(& (pf->pdev)->dev,(char *)"napi: no netdev for VSI %d\n",vsi_seid);
          else {
            #line 1702 
            i = 0;
            #line 1702 
            while (vsi->num_q_vectors > i) {
              #line 1703 
              napi_schedule(& (*(vsi->q_vectors + (unsigned long)i))->napi);
              #line 1702 
              i ++;
            }
            #line 1704 
            _dev_info(& (pf->pdev)->dev,(char *)"napi called\n");
          }
      }
      else {
        #line 1707 
        _dev_info(& (pf->pdev)->dev,(char *)"unknown command \'%s\'\n",(char *)(& i40e_dbg_netdev_ops_buf));
        #line 1709 
        _dev_info(& (pf->pdev)->dev,(char *)"available commands\n");
        #line 1710 
        _dev_info(& (pf->pdev)->dev,(char *)"  change_mtu <vsi_seid> <mtu>\n");
        #line 1711 
        _dev_info(& (pf->pdev)->dev,(char *)"  set_rx_mode <vsi_seid>\n");
        #line 1712 
        _dev_info(& (pf->pdev)->dev,(char *)"  napi <vsi_seid>\n");
      }
    }
  }
  #line 1714 
  netdev_ops_write_done: 
                         #line 1714 
  ;
  #line 1715 
  return (long)count;
}

#line 1718  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
static struct file_operations i40e_dbg_netdev_ops_fops = {.owner = & __this_module, .read = & i40e_dbg_netdev_ops_read, .write = & i40e_dbg_netdev_ops_write, .open = & simple_open};
#line 1729  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
void i40e_dbg_pf_init(struct i40e_pf *pf)
{
  #line 1731 
  char *name = pci_name(pf->pdev);
  #line 1733 
  pf->i40e_dbg_pf = cif_debugfs_create_dir(name,i40e_dbg_root);
  #line 1735 
  cif_debugfs_create_file((char *)"command",(unsigned short)384,pf->i40e_dbg_pf,(void *)pf,& i40e_dbg_command_fops);
  #line 1738 
  cif_debugfs_create_file((char *)"netdev_ops",(unsigned short)384,pf->i40e_dbg_pf,(void *)pf,& i40e_dbg_netdev_ops_fops);
  #line 1740 
  return;
}

#line 1746  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
void i40e_dbg_pf_exit(struct i40e_pf *pf)
{
  #line 1748 
  debugfs_remove_recursive(pf->i40e_dbg_pf);
  #line 1749 
  pf->i40e_dbg_pf = (struct dentry *)0;
  #line 1750 
  return;
}

#line 1755  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
void i40e_dbg_init(void)
{
  #line 1757 
  i40e_dbg_root = cif_debugfs_create_dir((char *)(& i40e_driver_name),(struct dentry *)0);
  #line 1758 
  if (i40e_dbg_root == (struct dentry *)0) 
                                           #line 1759 
                                           printk((char *)"\001");
  #line 1760 
  return;
}

#line 1765  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_debugfs.c"
void i40e_dbg_exit(void)
{
  #line 1767 
  debugfs_remove_recursive(i40e_dbg_root);
  #line 1768 
  i40e_dbg_root = (struct dentry *)0;
  #line 1769 
  return;
}

#line 93  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
struct file_operations *emg_alias_i40e_dbg_command_fops = & i40e_dbg_command_fops;
#line 94  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
struct file_operations *emg_alias_i40e_dbg_netdev_ops_fops = & i40e_dbg_netdev_ops_fops;
#line 99 
#line 99 
struct dentry *emg_debugfs_create_dir(char *arg0, struct dentry *arg1);
#line 100 
#line 100 
struct dentry *emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4);
#line 113  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
long emg_wrapper_i40e_dbg_command_read(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  #line 114 
  return i40e_dbg_command_read(arg0,arg1,arg2,arg3);
}

#line 118  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
long emg_wrapper_i40e_dbg_command_write(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  #line 119 
  return i40e_dbg_command_write(arg0,arg1,arg2,arg3);
}

#line 123  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
long emg_wrapper_i40e_dbg_netdev_ops_read(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  #line 124 
  return i40e_dbg_netdev_ops_read(arg0,arg1,arg2,arg3);
}

#line 128  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
long emg_wrapper_i40e_dbg_netdev_ops_write(struct file *arg0, char *arg1, unsigned long arg2, long long *arg3)
{
  #line 129 
  return i40e_dbg_netdev_ops_write(arg0,arg1,arg2,arg3);
}

#line 169  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
static int cif_strncmp_0(char *cs, char *ct, __kernel_size_t count)
{
  #line 172 
  return ldv_strncmp(cs,ct,count);
}

#line 456  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
static void *kzalloc_3(size_t size, gfp_t flags)
{
  #line 459 
  return ldv_kzalloc(size,flags);
}

#line 713  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
static void *cif_kmemdup(void *src, size_t len, gfp_t gfp)
{
  #line 716 
  return ldv_kmemdup(src,len,gfp);
}

#line 859  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
static struct dentry *cif_debugfs_create_dir(char *name, struct dentry *parent)
{
  #line 863 
  return emg_debugfs_create_dir(name,parent);
}

#line 867  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_debugfs.i.aux"
static struct dentry *cif_debugfs_create_file(char *name, umode_t mode, struct dentry *parent, void *data, struct file_operations *fops)
{
  #line 871 
  return emg_debugfs_create_file(name,(unsigned short)((int)mode),parent,data,
                              fops);
}

#line 290  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_prototype.h"
#line 1006  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_read_lldp_cfg(struct i40e_hw *hw, struct i40e_lldp_variables *lldp_cfg);
#line 124  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.h"
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_get_dcbx_status(struct i40e_hw *hw, u16 *status);
#line 126  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.h"
#line 500  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_lldp_to_dcb_config(u8 *lldpmib, struct i40e_dcbx_config *dcbcfg);
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_get_dcbx_status(struct i40e_hw *hw, u16 *status)
{
  #line 17 
  u32 reg;
  #line 19 
  if (status == (u16 *)0U) 
                           #line 20 
                           return I40E_ERR_PARAM;
  #line 22 
  reg = readl((void *)(hw->hw_addr + 536608U));
  #line 23 
  *status = (unsigned short)((unsigned int)((unsigned short)reg) & 7U);
  #line 26 
  return I40E_SUCCESS;
}

#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_ieee_etscfg_tlv(struct i40e_lldp_org_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  #line 39 
  struct i40e_dcb_ets_config *etscfg;
  #line 42 
  u8 priority;
  #line 43 
  int i;
  #line 40 
  u8 *buf = (u8 *)(& tlv->tlvinfo);
  #line 41 
  u16 offset = (unsigned short)0U;
  #line 52 
  etscfg = & dcbcfg->etscfg;
  #line 53 
  etscfg->willing = (unsigned char)((int)*(buf + (unsigned long)offset) >> 7);
  #line 55 
  etscfg->cbs = (unsigned char)((unsigned int)((unsigned char)((unsigned long)*(buf + (unsigned long)offset) >> 6)) & 1U);
  #line 57 
  etscfg->maxtcs = (unsigned char)((unsigned int)*(buf + (unsigned long)offset) & 7U);
  #line 61 
  offset = (u16)((int)offset + 1);
  #line 71 
  i = 0;
  #line 71 
  while (i <= 3) {
    #line 72 
    priority = (unsigned char)((unsigned int)((unsigned char)((int)*(buf + (unsigned long)offset) >> 4)) & 7U);
    #line 74 
    etscfg->prioritytable[i * 2] = priority;
    #line 75 
    priority = (unsigned char)((unsigned int)*(buf + (unsigned long)offset) & 7U);
    #line 77 
    etscfg->prioritytable[i * 2 + 1] = priority;
    #line 78 
    offset = (u16)((int)offset + 1);
    #line 71 
    i ++;
  }
  #line 87 
  i = 0;
  #line 87 
  while (i <= 7) {
    #line 88 
    u16 tmp;
    #line 88 
    tmp = offset;
    #line 88 
    offset = (u16)((int)offset + 1);
    #line 88 
    etscfg->tcbwtable[i] = *(buf + (unsigned long)tmp);
    #line 87 
    i ++;
  }
  #line 96 
  i = 0;
  #line 96 
  while (i <= 7) {
    #line 97 
    u16 tmp_0;
    #line 97 
    tmp_0 = offset;
    #line 97 
    offset = (u16)((int)offset + 1);
    #line 97 
    etscfg->tsatable[i] = *(buf + (unsigned long)tmp_0);
    #line 96 
    i ++;
  }
  #line 98 
  return;
}

#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_ieee_etsrec_tlv(struct i40e_lldp_org_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  #line 112 
  u8 priority;
  #line 113 
  int i;
  #line 110 
  u8 *buf = (u8 *)(& tlv->tlvinfo);
  #line 111 
  u16 offset = (unsigned short)0U;
  #line 116 
  offset = (u16)((int)offset + 1);
  #line 126 
  i = 0;
  #line 126 
  while (i <= 3) {
    #line 127 
    priority = (unsigned char)((unsigned int)((unsigned char)((int)*(buf + (unsigned long)offset) >> 4)) & 7U);
    #line 129 
    dcbcfg->etsrec.prioritytable[i * 2] = priority;
    #line 130 
    priority = (unsigned char)((unsigned int)*(buf + (unsigned long)offset) & 7U);
    #line 132 
    dcbcfg->etsrec.prioritytable[i * 2 + 1] = priority;
    #line 133 
    offset = (u16)((int)offset + 1);
    #line 126 
    i ++;
  }
  #line 142 
  i = 0;
  #line 142 
  while (i <= 7) {
    #line 143 
    u16 tmp;
    #line 143 
    tmp = offset;
    #line 143 
    offset = (u16)((int)offset + 1);
    #line 143 
    dcbcfg->etsrec.tcbwtable[i] = *(buf + (unsigned long)tmp);
    #line 142 
    i ++;
  }
  #line 151 
  i = 0;
  #line 151 
  while (i <= 7) {
    #line 152 
    u16 tmp_0;
    #line 152 
    tmp_0 = offset;
    #line 152 
    offset = (u16)((int)offset + 1);
    #line 152 
    dcbcfg->etsrec.tsatable[i] = *(buf + (unsigned long)tmp_0);
    #line 151 
    i ++;
  }
  #line 153 
  return;
}

#line 162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_ieee_pfccfg_tlv(struct i40e_lldp_org_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  #line 165 
  u8 *buf = (u8 *)(& tlv->tlvinfo);
  #line 173 
  dcbcfg->pfc.willing = (unsigned char)((int)*buf >> 7);
  #line 175 
  dcbcfg->pfc.mbc = (unsigned char)((unsigned int)((unsigned char)((unsigned long)*buf >> 6)) & 1U);
  #line 177 
  dcbcfg->pfc.pfccap = (unsigned char)((unsigned int)*buf & 15U);
  #line 179 
  dcbcfg->pfc.pfcenable = *(buf + 1U);
  #line 180 
  return;
}

#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_ieee_app_tlv(struct i40e_lldp_org_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  #line 192 
  u16 typelength;
  #line 194 
  u16 length;
  #line 196 
  u8 *buf;
  #line 193 
  u16 offset = (unsigned short)0U;
  #line 195 
  int i = 0;
  #line 198 
  typelength = __builtin_bswap16((unsigned short)((int)tlv->typelength));
  #line 199 
  length = (unsigned short)((unsigned int)typelength & 511U);
  #line 201 
  buf = (u8 *)(& tlv->tlvinfo);
  #line 204 
  length = (unsigned short)((unsigned int)length + 65531U);
  #line 207 
  offset = (u16)((int)offset + 1);
  #line 217 
  while ((int)offset < (int)length) {
    #line 218 
    dcbcfg->app[i].priority = (unsigned char)((int)*(buf + (unsigned long)offset) >> 5);
    #line 221 
    dcbcfg->app[i].selector = (unsigned char)((unsigned int)*(buf + (unsigned long)offset) & 7U);
    #line 224 
    dcbcfg->app[i].protocolid = (unsigned short)(((int)*(buf + ((unsigned long)offset + (unsigned long)1U)) << 8) | (int)*(buf + ((unsigned long)offset + (unsigned long)2U)));
    #line 227 
    offset = (unsigned short)((unsigned int)offset + 3U);
    #line 228 
    i ++;
    #line 229 
    if (i > 31) 
                #line 230 
                break;
  }
  #line 233 
  dcbcfg->numapps = (unsigned int)i;
  #line 234 
  return;
}

#line 244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_ieee_tlv(struct i40e_lldp_org_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  #line 247 
  u32 ouisubtype;
  #line 248 
  u8 subtype;
  #line 250 
  ouisubtype = __builtin_bswap32(tlv->ouisubtype);
  #line 251 
  subtype = (unsigned char)ouisubtype;
  #line 253 
  switch ((int)subtype) {
    #line 254 
    case 9: 
            #line 254 
    ;
    #line 255 
    i40e_parse_ieee_etscfg_tlv(tlv,dcbcfg);
    #line 256 
    break;
    #line 257 
    case 10: 
             #line 257 
    ;
    #line 258 
    i40e_parse_ieee_etsrec_tlv(tlv,dcbcfg);
    #line 259 
    break;
    #line 260 
    case 11: 
             #line 260 
    ;
    #line 261 
    i40e_parse_ieee_pfccfg_tlv(tlv,dcbcfg);
    #line 262 
    break;
    #line 263 
    case 12: 
             #line 263 
    ;
    #line 264 
    i40e_parse_ieee_app_tlv(tlv,dcbcfg);
    #line 265 
    break;
    #line 266 
    default: 
             #line 266 
    ;
    #line 267 
    break;
  }
  #line 269 
  return;
}

#line 278  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_cee_pgcfg_tlv(struct i40e_cee_feat_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  #line 281 
  struct i40e_dcb_ets_config *etscfg;
  #line 284 
  u8 priority;
  #line 285 
  int i;
  #line 282 
  u8 *buf = (u8 *)(& tlv->tlvinfo);
  #line 283 
  u16 offset = (unsigned short)0U;
  #line 287 
  etscfg = & dcbcfg->etscfg;
  #line 289 
  if (((int)tlv->en_will_err & 64) != 0) 
                                         #line 290 
                                         etscfg->willing = (unsigned char)1U;
  #line 292 
  etscfg->cbs = (unsigned char)0U;
  #line 301 
  i = 0;
  #line 301 
  while (i <= 3) {
    #line 302 
    priority = (unsigned char)((int)*(buf + (unsigned long)offset) >> 4);
    #line 304 
    etscfg->prioritytable[i * 2] = priority;
    #line 305 
    priority = (unsigned char)((unsigned int)*(buf + (unsigned long)offset) & 15U);
    #line 307 
    etscfg->prioritytable[i * 2 + 1] = priority;
    #line 308 
    offset = (u16)((int)offset + 1);
    #line 301 
    i ++;
  }
  #line 317 
  i = 0;
  #line 317 
  while (i <= 7) {
    #line 318 
    u16 tmp;
    #line 318 
    tmp = offset;
    #line 318 
    offset = (u16)((int)offset + 1);
    #line 318 
    etscfg->tcbwtable[i] = *(buf + (unsigned long)tmp);
    #line 317 
    i ++;
  }
  #line 321 
  etscfg->maxtcs = *(buf + (unsigned long)offset);
  #line 322 
  return;
}

#line 331  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_cee_pfccfg_tlv(struct i40e_cee_feat_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  #line 334 
  u8 *buf = (u8 *)(& tlv->tlvinfo);
  #line 336 
  if (((int)tlv->en_will_err & 64) != 0) 
                                         #line 337 
                                         dcbcfg->pfc.willing = (unsigned char)1U;
  #line 344 
  dcbcfg->pfc.pfcenable = *buf;
  #line 345 
  dcbcfg->pfc.pfccap = *(buf + 1U);
  #line 346 
  return;
}

#line 355  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_cee_app_tlv(struct i40e_cee_feat_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  #line 358 
  u16 length;
  #line 358 
  u16 typelength;
  #line 359 
  struct i40e_cee_app_prio *app;
  #line 360 
  u8 i;
  #line 358 
  u16 offset = (unsigned short)0U;
  #line 362 
  typelength = __builtin_bswap16((unsigned short)((int)tlv->hdr.typelen));
  #line 363 
  length = (unsigned short)((unsigned int)typelength & 511U);
  #line 366 
  dcbcfg->numapps = (unsigned int)length / 6U;
  #line 368 
  if (dcbcfg->numapps == 0U) 
                             #line 369 
                             return;
  #line 370 
  if (dcbcfg->numapps > 32U) 
                             #line 371 
                             dcbcfg->numapps = 32U;
  #line 373 
  i = (unsigned char)0U;
  #line 373 
  while ((unsigned int)i < dcbcfg->numapps) {
    {
      #line 374 
      u8 up;
      #line 374 
      u8 selector;
      #line 376 
      app = (struct i40e_cee_app_prio *)((u8 *)(& tlv->tlvinfo) + (unsigned long)offset);
      #line 377 
      up = (unsigned char)0U;
      #line 377 
      while ((unsigned int)up <= 7U) {
        #line 378 
        if ((((unsigned long)app->prio_map >> (int)up) & 1UL) != 0UL) 
          #line 379 
          break;
        #line 377 
        up = (u8)((int)up + 1);
      }
      #line 381 
      dcbcfg->app[(int)i].priority = up;
      #line 384 
      selector = (unsigned char)((unsigned int)app->upper_oui_sel & 3U);
      #line 385 
      switch ((int)selector) {
        #line 386 
        case 0: 
                #line 386 
        ;
        #line 387 
        dcbcfg->app[(int)i].selector = (unsigned char)1U;
        #line 388 
        break;
        #line 389 
        case 1: 
                #line 389 
        ;
        #line 390 
        dcbcfg->app[(int)i].selector = (unsigned char)2U;
        #line 391 
        break;
        #line 392 
        default: 
                 #line 392 
        ;
        #line 394 
        dcbcfg->app[(int)i].selector = selector;
      }
      #line 397 
      dcbcfg->app[(int)i].protocolid = __builtin_bswap16((unsigned short)((int)app->protocol));
      #line 399 
      offset = (unsigned short)((unsigned int)offset + 6U);
    }
    #line 373 
    i = (u8)((int)i + 1);
  }
  #line 401 
  return;
}

#line 411  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_cee_tlv(struct i40e_lldp_org_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  #line 414 
  u16 len;
  #line 414 
  u16 tlvlen;
  #line 414 
  u16 sublen;
  #line 414 
  u16 typelength;
  #line 415 
  struct i40e_cee_feat_tlv *sub_tlv;
  #line 416 
  u8 subtype;
  #line 417 
  u32 ouisubtype;
  #line 416 
  u8 feat_tlv_count = (unsigned char)0U;
  #line 419 
  ouisubtype = __builtin_bswap32(tlv->ouisubtype);
  #line 420 
  subtype = (unsigned char)ouisubtype;
  #line 423 
  if ((unsigned int)subtype != 2U) 
                                   #line 424 
                                   return;
  #line 426 
  typelength = __builtin_bswap16((unsigned short)((int)tlv->typelength));
  #line 427 
  tlvlen = (unsigned short)((unsigned int)typelength & 511U);
  #line 429 
  len = (unsigned short)18U;
  #line 432 
  if ((int)tlvlen <= (int)len) 
                               #line 433 
                               return;
  #line 435 
  sub_tlv = (struct i40e_cee_feat_tlv *)((char *)tlv + (unsigned long)len);
  #line 436 
  while ((unsigned int)feat_tlv_count <= 2U) {
    #line 437 
    typelength = __builtin_bswap16((unsigned short)((int)sub_tlv->hdr.typelen));
    #line 438 
    sublen = (unsigned short)((unsigned int)typelength & 511U);
    #line 441 
    subtype = (unsigned char)((int)typelength >> 9);
    #line 443 
    switch ((int)subtype) {
      #line 444 
      case 2: 
              #line 444 
      ;
      #line 445 
      i40e_parse_cee_pgcfg_tlv(sub_tlv,dcbcfg);
      #line 446 
      break;
      #line 447 
      case 3: 
              #line 447 
      ;
      #line 448 
      i40e_parse_cee_pfccfg_tlv(sub_tlv,dcbcfg);
      #line 449 
      break;
      #line 450 
      case 4: 
              #line 450 
      ;
      #line 451 
      i40e_parse_cee_app_tlv(sub_tlv,dcbcfg);
      #line 452 
      break;
      #line 453 
      default: 
               #line 453 
      ;
      #line 454 
      return;
    }
    #line 456 
    feat_tlv_count = (u8)((int)feat_tlv_count + 1);
    #line 458 
    sub_tlv = (struct i40e_cee_feat_tlv *)((char *)sub_tlv + ((unsigned long)sublen + 2UL));
  }
  #line 461 
  return;
}

#line 472  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_parse_org_tlv(struct i40e_lldp_org_tlv *tlv, struct i40e_dcbx_config *dcbcfg)
{
  #line 475 
  u32 ouisubtype;
  #line 476 
  u32 oui;
  #line 478 
  ouisubtype = __builtin_bswap32(tlv->ouisubtype);
  #line 479 
  oui = ouisubtype >> 8;
  #line 481 
  switch (oui) {
    #line 482 
    case (u32)32962: 
                     #line 482 
    ;
    #line 483 
    i40e_parse_ieee_tlv(tlv,dcbcfg);
    #line 484 
    break;
    #line 485 
    case (u32)6945: 
                    #line 485 
    ;
    #line 486 
    i40e_parse_cee_tlv(tlv,dcbcfg);
    #line 487 
    break;
    #line 488 
    default: 
             #line 488 
    ;
    #line 489 
    break;
  }
  #line 491 
  return;
}

#line 500  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_lldp_to_dcb_config(u8 *lldpmib, struct i40e_dcbx_config *dcbcfg)
{
  #line 504 
  struct i40e_lldp_org_tlv *tlv;
  #line 505 
  u16 type;
  #line 506 
  u16 length;
  #line 507 
  u16 typelength;
  #line 503 
  i40e_status ret = 0;
  #line 508 
  u16 offset = (unsigned short)0U;
  #line 510 
  if (lldpmib == (u8 *)0U || dcbcfg == (struct i40e_dcbx_config *)0) 
    #line 511 
    return I40E_ERR_PARAM;
  #line 514 
  lldpmib += 14U;
  #line 515 
  tlv = (struct i40e_lldp_org_tlv *)lldpmib;
  #line 516 
  while (1) {
    #line 517 
    typelength = __builtin_bswap16((unsigned short)((int)tlv->typelength));
    #line 518 
    type = (unsigned short)((int)typelength >> 9);
    #line 520 
    length = (unsigned short)((unsigned int)typelength & 511U);
    #line 522 
    offset = (unsigned short)((unsigned int)((int)offset + (int)length) + 2U);
    #line 525 
    if ((unsigned int)type == 0U || (unsigned int)offset > 1500U) 
                                                                  #line 526 
                                                                  break;
    #line 528 
    switch ((int)type) {
      #line 529 
      case 127: 
                #line 529 
      ;
      #line 530 
      i40e_parse_org_tlv(tlv,dcbcfg);
      #line 531 
      break;
      #line 532 
      default: 
               #line 532 
      ;
      #line 533 
      break;
    }
    #line 537 
    tlv = (struct i40e_lldp_org_tlv *)((char *)tlv + ((unsigned long)length + 2UL));
  }
  #line 542 
  return ret;
}

#line 554  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_aq_get_dcb_config(struct i40e_hw *hw, u8 mib_type, u8 bridgetype, struct i40e_dcbx_config *dcbcfg)
{
  #line 559 
  struct i40e_virt_mem mem;
  #line 560 
  u8 *lldpmib;
  #line 558 
  i40e_status ret = 0;
  #line 563 
  ret = i40e_allocate_virt_mem_d(hw,& mem,1500U);
  #line 564 
  if (ret != I40E_SUCCESS) 
                           #line 565 
                           return ret;
  #line 567 
  lldpmib = (u8 *)mem.va;
  #line 568 
  ret = i40e_aq_get_lldp_mib(hw,(unsigned char)((int)bridgetype),(unsigned char)((int)mib_type),(void *)lldpmib,(unsigned short)1500,(u16 *)0U,(u16 *)0U,(struct i40e_asq_cmd_details *)0);
  #line 571 
  if (ret != I40E_SUCCESS) 
                           #line 572 
                           goto free_mem;
  #line 575 
  ret = i40e_lldp_to_dcb_config(lldpmib,dcbcfg);
  #line 577 
  free_mem: 
            #line 577 
  ;
  #line 578 
  i40e_free_virt_mem_d(hw,& mem);
  #line 579 
  return ret;
}

#line 589  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_cee_to_dcb_v1_config(struct i40e_aqc_get_cee_dcb_cfg_v1_resp *cee_cfg, struct i40e_dcbx_config *dcbcfg)
{
  #line 593 
  u16 status;
  #line 595 
  u8 i;
  #line 595 
  u8 tc;
  #line 595 
  u8 err;
  #line 593 
  u16 tlv_status = cee_cfg->tlv_status;
  #line 594 
  u16 app_prio = cee_cfg->oper_app_prio;
  #line 598 
  dcbcfg->etscfg.maxtcs = cee_cfg->oper_num_tc;
  #line 603 
  i = (unsigned char)0U;
  #line 603 
  while ((unsigned int)i <= 3U) {
    #line 604 
    tc = (unsigned char)((unsigned int)cee_cfg->oper_prio_tc[(int)i] & 15U);
    #line 607 
    dcbcfg->etscfg.prioritytable[(int)i * 2] = tc;
    #line 608 
    tc = (unsigned char)((int)cee_cfg->oper_prio_tc[(int)i] >> 4);
    #line 611 
    dcbcfg->etscfg.prioritytable[(int)i * 2 + 1] = tc;
    #line 603 
    i = (u8)((int)i + 1);
  }
  #line 614 
  i = (unsigned char)0U;
  #line 614 
  while ((unsigned int)i <= 7U) {
    #line 615 
    dcbcfg->etscfg.tcbwtable[(int)i] = cee_cfg->oper_tc_bw[(int)i];
    #line 614 
    i = (u8)((int)i + 1);
  }
  #line 617 
  i = (unsigned char)0U;
  #line 617 
  while ((unsigned int)i <= 7U) {
    #line 618 
    if ((unsigned int)dcbcfg->etscfg.prioritytable[(int)i] == 15U) {
      #line 620 
      dcbcfg->etscfg.prioritytable[(int)i] = (unsigned char)((unsigned int)cee_cfg->oper_num_tc + 255U);
      #line 622 
      dcbcfg->etscfg.tsatable[(int)i] = (unsigned char)0U;
    }
    else 
         #line 624 
         dcbcfg->etscfg.tsatable[(int)i] = (unsigned char)2U;
    #line 617 
    i = (u8)((int)i + 1);
  }
  #line 629 
  dcbcfg->pfc.pfcenable = cee_cfg->oper_pfc_en;
  #line 630 
  dcbcfg->pfc.pfccap = (unsigned char)8U;
  #line 632 
  status = (unsigned short)((unsigned int)((unsigned short)((int)tlv_status >> 8)) & 7U);
  #line 634 
  err = (unsigned char)((unsigned int)((unsigned char)((int)status >> 2)) & 1U);
  #line 636 
  if ((unsigned int)err == 0U) {
    #line 638 
    dcbcfg->numapps = 3U;
    #line 641 
    dcbcfg->app[0].priority = (unsigned char)((unsigned int)((unsigned char)app_prio) & 7U);
    #line 644 
    dcbcfg->app[0].selector = (unsigned char)1U;
    #line 645 
    dcbcfg->app[0].protocolid = (unsigned short)35078U;
    #line 648 
    dcbcfg->app[1].priority = (unsigned char)((unsigned int)((unsigned char)((int)app_prio >> 3)) & 7U);
    #line 651 
    dcbcfg->app[1].selector = (unsigned char)2U;
    #line 652 
    dcbcfg->app[1].protocolid = (unsigned short)3260U;
    #line 655 
    dcbcfg->app[2].priority = (unsigned char)((unsigned int)((unsigned char)((int)app_prio >> 8)) & 7U);
    #line 658 
    dcbcfg->app[2].selector = (unsigned char)1U;
    #line 659 
    dcbcfg->app[2].protocolid = (unsigned short)35092U;
  }
  #line 661 
  return;
}

#line 670  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static void i40e_cee_to_dcb_config(struct i40e_aqc_get_cee_dcb_cfg_resp *cee_cfg, struct i40e_dcbx_config *dcbcfg)
{
  #line 674 
  u32 status;
  #line 676 
  u8 i;
  #line 676 
  u8 tc;
  #line 676 
  u8 err;
  #line 676 
  u8 sync;
  #line 676 
  u8 oper;
  #line 674 
  u32 tlv_status = cee_cfg->tlv_status;
  #line 675 
  u16 app_prio = cee_cfg->oper_app_prio;
  #line 679 
  dcbcfg->etscfg.maxtcs = cee_cfg->oper_num_tc;
  #line 684 
  i = (unsigned char)0U;
  #line 684 
  while ((unsigned int)i <= 3U) {
    #line 685 
    tc = (unsigned char)((unsigned int)cee_cfg->oper_prio_tc[(int)i] & 15U);
    #line 688 
    dcbcfg->etscfg.prioritytable[(int)i * 2] = tc;
    #line 689 
    tc = (unsigned char)((int)cee_cfg->oper_prio_tc[(int)i] >> 4);
    #line 692 
    dcbcfg->etscfg.prioritytable[(int)i * 2 + 1] = tc;
    #line 684 
    i = (u8)((int)i + 1);
  }
  #line 695 
  i = (unsigned char)0U;
  #line 695 
  while ((unsigned int)i <= 7U) {
    #line 696 
    dcbcfg->etscfg.tcbwtable[(int)i] = cee_cfg->oper_tc_bw[(int)i];
    #line 695 
    i = (u8)((int)i + 1);
  }
  #line 698 
  i = (unsigned char)0U;
  #line 698 
  while ((unsigned int)i <= 7U) {
    #line 699 
    if ((unsigned int)dcbcfg->etscfg.prioritytable[(int)i] == 15U) {
      #line 701 
      dcbcfg->etscfg.prioritytable[(int)i] = (unsigned char)((unsigned int)cee_cfg->oper_num_tc + 255U);
      #line 703 
      dcbcfg->etscfg.tsatable[(int)i] = (unsigned char)0U;
    }
    else 
         #line 705 
         dcbcfg->etscfg.tsatable[(int)i] = (unsigned char)2U;
    #line 698 
    i = (u8)((int)i + 1);
  }
  #line 710 
  dcbcfg->pfc.pfcenable = cee_cfg->oper_pfc_en;
  #line 711 
  dcbcfg->pfc.pfccap = (unsigned char)8U;
  #line 713 
  i = (unsigned char)0U;
  #line 714 
  status = (tlv_status >> 8) & 7U;
  #line 716 
  err = (unsigned char)((unsigned int)((unsigned char)(status >> 2)) & 1U);
  #line 717 
  sync = (unsigned char)((unsigned int)((unsigned char)(status >> 1)) & 1U);
  #line 718 
  oper = (unsigned char)((unsigned int)((unsigned char)status) & 1U);
  #line 720 
  if (((unsigned int)err == 0U && (unsigned int)sync != 0U) && (unsigned int)oper != 0U) {
    #line 722 
    dcbcfg->app[(int)i].priority = (unsigned char)((unsigned int)((unsigned char)app_prio) & 7U);
    #line 725 
    dcbcfg->app[(int)i].selector = (unsigned char)1U;
    #line 726 
    dcbcfg->app[(int)i].protocolid = (unsigned short)35078U;
    #line 727 
    i = (u8)((int)i + 1);
  }
  #line 730 
  status = (tlv_status >> 11) & 7U;
  #line 732 
  err = (unsigned char)((unsigned int)((unsigned char)(status >> 2)) & 1U);
  #line 733 
  sync = (unsigned char)((unsigned int)((unsigned char)(status >> 1)) & 1U);
  #line 734 
  oper = (unsigned char)((unsigned int)((unsigned char)status) & 1U);
  #line 736 
  if (((unsigned int)err == 0U && (unsigned int)sync != 0U) && (unsigned int)oper != 0U) {
    #line 738 
    dcbcfg->app[(int)i].priority = (unsigned char)((unsigned int)((unsigned char)((int)app_prio >> 3)) & 7U);
    #line 741 
    dcbcfg->app[(int)i].selector = (unsigned char)2U;
    #line 742 
    dcbcfg->app[(int)i].protocolid = (unsigned short)3260U;
    #line 743 
    i = (u8)((int)i + 1);
  }
  #line 746 
  status = (tlv_status >> 16) & 7U;
  #line 748 
  err = (unsigned char)((unsigned int)((unsigned char)(status >> 2)) & 1U);
  #line 749 
  sync = (unsigned char)((unsigned int)((unsigned char)(status >> 1)) & 1U);
  #line 750 
  oper = (unsigned char)((unsigned int)((unsigned char)status) & 1U);
  #line 752 
  if (((unsigned int)err == 0U && (unsigned int)sync != 0U) && (unsigned int)oper != 0U) {
    #line 754 
    dcbcfg->app[(int)i].priority = (unsigned char)((unsigned int)((unsigned char)((int)app_prio >> 8)) & 7U);
    #line 757 
    dcbcfg->app[(int)i].selector = (unsigned char)1U;
    #line 758 
    dcbcfg->app[(int)i].protocolid = (unsigned short)35092U;
    #line 759 
    i = (u8)((int)i + 1);
  }
  #line 761 
  dcbcfg->numapps = (unsigned int)i;
  #line 762 
  return;
}

#line 770  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static i40e_status i40e_get_ieee_dcb_config(struct i40e_hw *hw)
{
  #line 772 
  i40e_status ret = 0;
  #line 775 
  hw->local_dcbx_config.dcbx_mode = (unsigned char)2U;
  #line 777 
  ret = i40e_aq_get_dcb_config(hw,(unsigned char)0,(unsigned char)0,& hw->local_dcbx_config);
  #line 779 
  if (ret != I40E_SUCCESS) 
                           #line 780 
                           goto out;
  #line 783 
  ret = i40e_aq_get_dcb_config(hw,(unsigned char)1,(unsigned char)0,& hw->remote_dcbx_config);
  #line 787 
  if (hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_ENOENT) 
                                                                 #line 788 
                                                                 ret = I40E_SUCCESS;
  #line 790 
  out: 
       #line 790 
  ;
  #line 791 
  return ret;
}

#line 800  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_get_dcb_config(struct i40e_hw *hw)
{
  #line 803 
  struct i40e_aqc_get_cee_dcb_cfg_resp cee_cfg;
  #line 804 
  struct i40e_aqc_get_cee_dcb_cfg_v1_resp cee_v1_cfg;
  #line 802 
  i40e_status ret = 0;
  #line 807 
  if (hw->mac.type == (unsigned int)I40E_MAC_XL710 && ((unsigned int)hw->aq.fw_maj_ver == 4U && (unsigned int)hw->aq.fw_min_ver <= 32U || (unsigned int)hw->aq.fw_maj_ver <= 3U)) {
    #line 810 
    return i40e_get_ieee_dcb_config(hw);
  }
  #line 813 
  if (((unsigned int)hw->aq.fw_maj_ver == 4U && (unsigned int)hw->aq.fw_min_ver == 33U) && hw->mac.type == (unsigned int)I40E_MAC_XL710) {
    #line 815 
    ret = i40e_aq_get_cee_dcb_config(hw,(void *)(& cee_v1_cfg),(unsigned short)24,(struct i40e_asq_cmd_details *)0);
    #line 817 
    if (ret == I40E_SUCCESS) {
      #line 819 
      hw->local_dcbx_config.dcbx_mode = (unsigned char)1U;
      #line 820 
      hw->local_dcbx_config.tlv_status = (unsigned int)cee_v1_cfg.tlv_status;
      #line 822 
      i40e_cee_to_dcb_v1_config(& cee_v1_cfg,& hw->local_dcbx_config);
    }
  }
  else {
    #line 826 
    ret = i40e_aq_get_cee_dcb_config(hw,(void *)(& cee_cfg),(unsigned short)32,(struct i40e_asq_cmd_details *)0);
    #line 828 
    if (ret == I40E_SUCCESS) {
      #line 830 
      hw->local_dcbx_config.dcbx_mode = (unsigned char)1U;
      #line 831 
      hw->local_dcbx_config.tlv_status = cee_cfg.tlv_status;
      #line 833 
      i40e_cee_to_dcb_config(& cee_cfg,& hw->local_dcbx_config);
    }
  }
  #line 839 
  if (hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_ENOENT) {
    #line 840 
    return i40e_get_ieee_dcb_config(hw);
  }
  #line 842 
  if (ret != I40E_SUCCESS) 
                           #line 843 
                           goto out;
  #line 846 
  ret = i40e_aq_get_dcb_config(hw,(unsigned char)0,(unsigned char)0,& hw->desired_dcbx_config);
  #line 848 
  if (ret != I40E_SUCCESS) 
                           #line 849 
                           goto out;
  #line 852 
  ret = i40e_aq_get_dcb_config(hw,(unsigned char)1,(unsigned char)0,& hw->remote_dcbx_config);
  #line 856 
  if (hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_ENOENT) 
                                                                 #line 857 
                                                                 ret = I40E_SUCCESS;
  #line 859 
  out: 
       #line 859 
  ;
  #line 860 
  return ret;
}

#line 870  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_init_dcb(struct i40e_hw *hw, bool enable_mib_change)
{
  #line 873 
  struct i40e_lldp_variables lldp_cfg;
  #line 872 
  i40e_status ret = 0;
  #line 874 
  u8 adminstatus = (unsigned char)0U;
  #line 876 
  if (! hw->func_caps.dcb) 
                           #line 877 
                           return I40E_NOT_SUPPORTED;
  #line 880 
  if ((hw->flags & 32ULL) != 0ULL) {
    #line 881 
    u8 offset = (unsigned char)0U;
    #line 883 
    if (hw->mac.type == (unsigned int)I40E_MAC_XL710) 
                                                      #line 884 
                                                      offset = (unsigned char)43U;
    else 
      #line 885 
      if (hw->mac.type == (unsigned int)I40E_MAC_X722) 
                                                       #line 886 
                                                       offset = (unsigned char)49U; else 
                                                                    #line 888 
                                                                    return I40E_NOT_SUPPORTED;
    #line 890 
    ret = i40e_read_nvm_module_data(hw,(unsigned char)72,(unsigned short)((int)offset),(unsigned short)1,(unsigned short)1,& lldp_cfg.adminstatus);
  }
  else 
       #line 897 
       ret = i40e_read_lldp_cfg(hw,& lldp_cfg);
  #line 899 
  if (ret != I40E_SUCCESS) 
                           #line 900 
                           return I40E_ERR_NOT_READY;
  #line 903 
  adminstatus = (unsigned char)((int)lldp_cfg.adminstatus >> (int)hw->port * 4);
  #line 904 
  adminstatus = (unsigned char)((unsigned int)adminstatus & 15U);
  #line 907 
  if ((unsigned int)adminstatus == 0U) {
    #line 908 
    hw->dcbx_status = (unsigned short)7U;
    #line 909 
    return I40E_ERR_NOT_READY;
  }
  #line 913 
  ret = i40e_get_dcbx_status(hw,& hw->dcbx_status);
  #line 914 
  if (ret != I40E_SUCCESS) 
                           #line 915 
                           return ret;
  #line 918 
  if ((unsigned int)hw->dcbx_status + 65535U <= 1U) {
    #line 921 
    ret = i40e_get_dcb_config(hw);
    #line 922 
    if (ret != I40E_SUCCESS) 
                             #line 923 
                             return ret;
  }
  else 
    #line 924 
    if ((unsigned int)hw->dcbx_status == 7U) 
                                             #line 925 
                                             return I40E_ERR_NOT_READY;
  #line 929 
  if ((int)enable_mib_change != 0) 
                                   #line 930 
                                   ret = i40e_aq_cfg_lldp_mib_change_event(hw,(_Bool)1,(struct i40e_asq_cmd_details *)0);
  #line 932 
  return ret;
}

#line 944  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
static i40e_status _i40e_read_lldp_cfg(struct i40e_hw *hw, struct i40e_lldp_variables *lldp_cfg, u8 module, u32 word_offset)
{
  #line 948 
  u32 address;
  #line 949 
  i40e_status ret;
  #line 950 
  __le16 raw_mem;
  #line 951 
  u16 mem;
  #line 948 
  u32 offset = word_offset * 2U;
  #line 953 
  ret = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
  #line 954 
  if (ret != I40E_SUCCESS) 
                           #line 955 
                           return ret;
  #line 957 
  ret = i40e_aq_read_nvm(hw,(unsigned char)0,(unsigned int)((int)module * 2),(unsigned short)2,(void *)(& raw_mem),(_Bool)1,(struct i40e_asq_cmd_details *)0);
  #line 959 
  i40e_release_nvm(hw);
  #line 960 
  if (ret != I40E_SUCCESS) 
                           #line 961 
                           return ret;
  #line 963 
  mem = raw_mem;
  #line 967 
  if (((unsigned long)mem & 32768UL) != 0UL) 
                                             #line 968 
                                             address = (unsigned int)(((int)mem & 32767) * 4096); else 
                                                                    #line 970 
                                                                    address = (unsigned int)(((int)mem & 32767) * 2);
  #line 972 
  ret = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
  #line 973 
  if (ret != I40E_SUCCESS) 
                           #line 974 
                           goto err_lldp_cfg;
  #line 976 
  ret = i40e_aq_read_nvm(hw,(unsigned char)((int)module),offset,(unsigned short)2,(void *)(& raw_mem),(_Bool)1,(struct i40e_asq_cmd_details *)0);
  #line 978 
  i40e_release_nvm(hw);
  #line 979 
  if (ret != I40E_SUCCESS) 
                           #line 980 
                           return ret;
  #line 982 
  mem = raw_mem;
  #line 983 
  offset = (unsigned int)mem + word_offset;
  #line 984 
  offset *= 2U;
  #line 986 
  ret = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
  #line 987 
  if (ret != I40E_SUCCESS) 
                           #line 988 
                           goto err_lldp_cfg;
  #line 990 
  ret = i40e_aq_read_nvm(hw,(unsigned char)0,address + offset,(unsigned short)14,(void *)lldp_cfg,(_Bool)1,(struct i40e_asq_cmd_details *)0);
  #line 993 
  i40e_release_nvm(hw);
  #line 995 
  err_lldp_cfg: 
                #line 995 
  ;
  #line 996 
  return ret;
}

#line 1006  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb.c"
i40e_status i40e_read_lldp_cfg(struct i40e_hw *hw, struct i40e_lldp_variables *lldp_cfg)
{
  #line 1010 
  u32 mem;
  #line 1009 
  i40e_status ret = 0;
  #line 1012 
  if (lldp_cfg == (struct i40e_lldp_variables *)0) 
                                                   #line 1013 
                                                   return I40E_ERR_PARAM;
  #line 1015 
  ret = i40e_acquire_nvm(hw,(enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
  #line 1016 
  if (ret != I40E_SUCCESS) 
                           #line 1017 
                           return ret;
  #line 1019 
  ret = i40e_aq_read_nvm(hw,(unsigned char)0,0U,(unsigned short)4,(void *)(& mem),(_Bool)1,(struct i40e_asq_cmd_details *)0);
  #line 1021 
  i40e_release_nvm(hw);
  #line 1022 
  if (ret != I40E_SUCCESS) 
                           #line 1023 
                           return ret;
  #line 1029 
  if (((unsigned long)mem & 4096UL) != 0UL) 
                                            #line 1031 
                                            ret = _i40e_read_lldp_cfg(hw,lldp_cfg,(unsigned char)72,49U); else 
                                                                    #line 1035 
                                                                    ret = _i40e_read_lldp_cfg(hw,lldp_cfg,(unsigned char)15,6U);
  #line 1039 
  return ret;
}

#line 26  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_adminq.i.aux"
#line 799 
static void cif_mutex_lock_asq_mutex_of_i40e_adminq_info(struct mutex *lock);
#line 26 
#line 813 
static void cif_mutex_lock_arq_mutex_of_i40e_adminq_info_0(struct mutex *lock);
#line 185  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mutex.h"
#line 806  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_adminq.i.aux"
static void cif_mutex_unlock_asq_mutex_of_i40e_adminq_info(struct mutex *lock);
#line 185  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mutex.h"
#line 820  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_adminq.i.aux"
static void cif_mutex_unlock_arq_mutex_of_i40e_adminq_info_0(struct mutex *lock);
#line 641  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_type.h"
__inline static bool i40e_is_vf(struct i40e_hw *hw)
{
  #line 643 
  return (_Bool)((hw->mac.type == (unsigned int)I40E_MAC_VF || hw->mac.type == (unsigned int)I40E_MAC_X722_VF) != 0);
}

#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
#line 1088 
static void i40e_resume_aq(struct i40e_hw *hw);
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static void i40e_adminq_init_regs(struct i40e_hw *hw)
{
  #line 21 
  if ((int)i40e_is_vf(hw) != 0) {
    #line 22 
    hw->aq.asq.tail = 33792U;
    #line 23 
    hw->aq.asq.head = 25600U;
    #line 24 
    hw->aq.asq.len = 26624U;
    #line 25 
    hw->aq.asq.bal = 31744U;
    #line 26 
    hw->aq.asq.bah = 30720U;
    #line 27 
    hw->aq.arq.tail = 28672U;
    #line 28 
    hw->aq.arq.head = 29696U;
    #line 29 
    hw->aq.arq.len = 32768U;
    #line 30 
    hw->aq.arq.bal = 27648U;
    #line 31 
    hw->aq.arq.bah = 24576U;
  }
  else {
    #line 33 
    hw->aq.asq.tail = 525312U;
    #line 34 
    hw->aq.asq.head = 525056U;
    #line 35 
    hw->aq.asq.len = 524800U;
    #line 36 
    hw->aq.asq.bal = 524288U;
    #line 37 
    hw->aq.asq.bah = 524544U;
    #line 38 
    hw->aq.arq.tail = 525440U;
    #line 39 
    hw->aq.arq.head = 525184U;
    #line 40 
    hw->aq.arq.len = 524928U;
    #line 41 
    hw->aq.arq.bal = 524416U;
    #line 42 
    hw->aq.arq.bah = 524672U;
  }
  #line 44 
  return;
}

#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_alloc_adminq_asq_ring(struct i40e_hw *hw)
{
  #line 52 
  i40e_status ret_code;
  #line 54 
  ret_code = i40e_allocate_dma_mem_d(hw,& hw->aq.asq.desc_buf,(unsigned long long)((unsigned long)hw->aq.num_asq_entries * 32UL),4096U);
  #line 59 
  if (ret_code != I40E_SUCCESS) 
                                #line 60 
                                return ret_code;
  #line 62 
  ret_code = i40e_allocate_virt_mem_d(hw,& hw->aq.asq.cmd_buf,(unsigned int)hw->aq.num_asq_entries * 32U);
  #line 65 
  if (ret_code != I40E_SUCCESS) {
    #line 66 
    i40e_free_dma_mem_d(hw,& hw->aq.asq.desc_buf);
    #line 67 
    return ret_code;
  }
  #line 70 
  return ret_code;
}

#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_alloc_adminq_arq_ring(struct i40e_hw *hw)
{
  #line 79 
  i40e_status ret_code;
  #line 81 
  ret_code = i40e_allocate_dma_mem_d(hw,& hw->aq.arq.desc_buf,(unsigned long long)((unsigned long)hw->aq.num_arq_entries * 32UL),4096U);
  #line 87 
  return ret_code;
}

#line 97  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static void i40e_free_adminq_asq(struct i40e_hw *hw)
{
  #line 99 
  i40e_free_dma_mem_d(hw,& hw->aq.asq.desc_buf);
  #line 100 
  return;
}

#line 109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static void i40e_free_adminq_arq(struct i40e_hw *hw)
{
  #line 111 
  i40e_free_dma_mem_d(hw,& hw->aq.arq.desc_buf);
  #line 112 
  return;
}

#line 118  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_alloc_arq_bufs(struct i40e_hw *hw)
{
  #line 120 
  i40e_status ret_code;
  #line 121 
  struct i40e_aq_desc *desc;
  #line 122 
  struct i40e_dma_mem *bi;
  #line 123 
  int i;
  #line 130 
  ret_code = i40e_allocate_virt_mem_d(hw,& hw->aq.arq.dma_head,(unsigned int)hw->aq.num_arq_entries * 24U);
  #line 132 
  if (ret_code != I40E_SUCCESS) 
                                #line 133 
                                goto alloc_arq_bufs;
  #line 134 
  hw->aq.arq.r.arq_bi = (struct i40e_dma_mem *)hw->aq.arq.dma_head.va;
  #line 137 
  i = 0;
  #line 137 
  while ((int)hw->aq.num_arq_entries > i) {
    #line 138 
    bi = hw->aq.arq.r.arq_bi + (unsigned long)i;
    #line 139 
    ret_code = i40e_allocate_dma_mem_d(hw,bi,(unsigned long long)hw->aq.arq_buf_size,4096U);
    #line 143 
    if (ret_code != I40E_SUCCESS) 
                                  #line 144 
                                  goto unwind_alloc_arq_bufs;
    #line 147 
    desc = (struct i40e_aq_desc *)hw->aq.arq.desc_buf.va + (unsigned long)i;
    #line 149 
    desc->flags = (unsigned short)4096U;
    #line 150 
    if ((unsigned int)hw->aq.arq_buf_size > 512U) 
                                                  #line 151 
                                                  desc->flags = (unsigned short)((unsigned int)desc->flags | 512U);
    #line 152 
    desc->opcode = (unsigned short)0U;
    #line 156 
    desc->datalen = (unsigned short)bi->size;
    #line 157 
    desc->retval = (unsigned short)0U;
    #line 158 
    desc->cookie_high = 0U;
    #line 159 
    desc->cookie_low = 0U;
    #line 160 
    desc->params.external.addr_high = (unsigned int)(bi->pa >> 32);
    #line 162 
    desc->params.external.addr_low = (unsigned int)bi->pa;
    #line 164 
    desc->params.external.param0 = 0U;
    #line 165 
    desc->params.external.param1 = 0U;
    #line 137 
    i ++;
  }
  #line 168 
  alloc_arq_bufs: 
                  #line 168 
  ;
  #line 169 
  return ret_code;
  #line 171 
  unwind_alloc_arq_bufs: 
                         #line 171 
  ;
  #line 173 
  i --;
  #line 174 
  while (i >= 0) {
    #line 175 
    i40e_free_dma_mem_d(hw,hw->aq.arq.r.arq_bi + (unsigned long)i);
    #line 174 
    i --;
  }
  #line 176 
  i40e_free_virt_mem_d(hw,& hw->aq.arq.dma_head);
  #line 178 
  return ret_code;
}

#line 185  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_alloc_asq_bufs(struct i40e_hw *hw)
{
  #line 187 
  i40e_status ret_code;
  #line 188 
  struct i40e_dma_mem *bi;
  #line 189 
  int i;
  #line 192 
  ret_code = i40e_allocate_virt_mem_d(hw,& hw->aq.asq.dma_head,(unsigned int)hw->aq.num_asq_entries * 24U);
  #line 194 
  if (ret_code != I40E_SUCCESS) 
                                #line 195 
                                goto alloc_asq_bufs;
  #line 196 
  hw->aq.asq.r.asq_bi = (struct i40e_dma_mem *)hw->aq.asq.dma_head.va;
  #line 199 
  i = 0;
  #line 199 
  while ((int)hw->aq.num_asq_entries > i) {
    #line 200 
    bi = hw->aq.asq.r.asq_bi + (unsigned long)i;
    #line 201 
    ret_code = i40e_allocate_dma_mem_d(hw,bi,(unsigned long long)hw->aq.asq_buf_size,4096U);
    #line 205 
    if (ret_code != I40E_SUCCESS) 
                                  #line 206 
                                  goto unwind_alloc_asq_bufs;
    #line 199 
    i ++;
  }
  #line 208 
  alloc_asq_bufs: 
                  #line 208 
  ;
  #line 209 
  return ret_code;
  #line 211 
  unwind_alloc_asq_bufs: 
                         #line 211 
  ;
  #line 213 
  i --;
  #line 214 
  while (i >= 0) {
    #line 215 
    i40e_free_dma_mem_d(hw,hw->aq.asq.r.asq_bi + (unsigned long)i);
    #line 214 
    i --;
  }
  #line 216 
  i40e_free_virt_mem_d(hw,& hw->aq.asq.dma_head);
  #line 218 
  return ret_code;
}

#line 225  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static void i40e_free_arq_bufs(struct i40e_hw *hw)
{
  #line 227 
  int i;
  #line 230 
  i = 0;
  #line 230 
  while ((int)hw->aq.num_arq_entries > i) {
    #line 231 
    i40e_free_dma_mem_d(hw,hw->aq.arq.r.arq_bi + (unsigned long)i);
    #line 230 
    i ++;
  }
  #line 234 
  i40e_free_dma_mem_d(hw,& hw->aq.arq.desc_buf);
  #line 237 
  i40e_free_virt_mem_d(hw,& hw->aq.arq.dma_head);
  #line 238 
  return;
}

#line 244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static void i40e_free_asq_bufs(struct i40e_hw *hw)
{
  #line 246 
  int i;
  #line 249 
  i = 0;
  #line 249 
  while ((int)hw->aq.num_asq_entries > i) {
    #line 250 
    if ((hw->aq.asq.r.asq_bi + (unsigned long)i)->pa != 0ULL) 
                                                              #line 251 
                                                              i40e_free_dma_mem_d(hw,hw->aq.asq.r.asq_bi + (unsigned long)i);
    #line 249 
    i ++;
  }
  #line 254 
  i40e_free_virt_mem_d(hw,& hw->aq.asq.cmd_buf);
  #line 257 
  i40e_free_dma_mem_d(hw,& hw->aq.asq.desc_buf);
  #line 260 
  i40e_free_virt_mem_d(hw,& hw->aq.asq.dma_head);
  #line 261 
  return;
}

#line 269  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_config_asq_regs(struct i40e_hw *hw)
{
  #line 271 
  i40e_status ret_code = 0;
  #line 272 
  u32 reg = 0U;
  #line 275 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)hw->aq.asq.head));
  #line 276 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)hw->aq.asq.tail));
  #line 279 
  writel((unsigned int)hw->aq.num_asq_entries | 2147483648U,(void *)(hw->hw_addr + (unsigned long)hw->aq.asq.len));
  #line 281 
  writel((unsigned int)hw->aq.asq.desc_buf.pa,(void *)(hw->hw_addr + (unsigned long)hw->aq.asq.bal));
  #line 282 
  writel((unsigned int)(hw->aq.asq.desc_buf.pa >> 32),(void *)(hw->hw_addr + (unsigned long)hw->aq.asq.bah));
  #line 285 
  reg = readl((void *)(hw->hw_addr + (unsigned long)hw->aq.asq.bal));
  #line 286 
  if ((unsigned int)hw->aq.asq.desc_buf.pa != reg) 
                                                   #line 287 
                                                   ret_code = I40E_ERR_ADMIN_QUEUE_ERROR;
  #line 289 
  return ret_code;
}

#line 298  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_config_arq_regs(struct i40e_hw *hw)
{
  #line 300 
  i40e_status ret_code = 0;
  #line 301 
  u32 reg = 0U;
  #line 304 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)hw->aq.arq.head));
  #line 305 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)hw->aq.arq.tail));
  #line 308 
  writel((unsigned int)hw->aq.num_arq_entries | 2147483648U,(void *)(hw->hw_addr + (unsigned long)hw->aq.arq.len));
  #line 310 
  writel((unsigned int)hw->aq.arq.desc_buf.pa,(void *)(hw->hw_addr + (unsigned long)hw->aq.arq.bal));
  #line 311 
  writel((unsigned int)(hw->aq.arq.desc_buf.pa >> 32),(void *)(hw->hw_addr + (unsigned long)hw->aq.arq.bah));
  #line 314 
  writel((unsigned int)((int)hw->aq.num_arq_entries + -1),(void *)(hw->hw_addr + (unsigned long)hw->aq.arq.tail));
  #line 317 
  reg = readl((void *)(hw->hw_addr + (unsigned long)hw->aq.arq.bal));
  #line 318 
  if ((unsigned int)hw->aq.arq.desc_buf.pa != reg) 
                                                   #line 319 
                                                   ret_code = I40E_ERR_ADMIN_QUEUE_ERROR;
  #line 321 
  return ret_code;
}

#line 337  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_init_asq(struct i40e_hw *hw)
{
  #line 339 
  i40e_status ret_code = 0;
  #line 341 
  if ((unsigned int)hw->aq.asq.count != 0U) {
    #line 343 
    ret_code = I40E_ERR_NOT_READY;
    #line 344 
    goto init_adminq_exit;
  }
  #line 348 
  if ((unsigned int)hw->aq.num_asq_entries == 0U || (unsigned int)hw->aq.asq_buf_size == 0U) {
    #line 350 
    ret_code = I40E_ERR_CONFIG;
    #line 351 
    goto init_adminq_exit;
  }
  #line 354 
  hw->aq.asq.next_to_use = (unsigned short)0U;
  #line 355 
  hw->aq.asq.next_to_clean = (unsigned short)0U;
  #line 358 
  ret_code = i40e_alloc_adminq_asq_ring(hw);
  #line 359 
  if (ret_code != I40E_SUCCESS) 
                                #line 360 
                                goto init_adminq_exit;
  #line 363 
  ret_code = i40e_alloc_asq_bufs(hw);
  #line 364 
  if (ret_code != I40E_SUCCESS) 
                                #line 365 
                                goto init_adminq_free_rings;
  #line 368 
  ret_code = i40e_config_asq_regs(hw);
  #line 369 
  if (ret_code != I40E_SUCCESS) 
                                #line 370 
                                goto init_adminq_free_rings;
  #line 373 
  hw->aq.asq.count = hw->aq.num_asq_entries;
  #line 374 
  goto init_adminq_exit;
  #line 376 
  init_adminq_free_rings: 
                          #line 376 
  ;
  #line 377 
  i40e_free_adminq_asq(hw);
  #line 379 
  init_adminq_exit: 
                    #line 379 
  ;
  #line 380 
  return ret_code;
}

#line 396  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_init_arq(struct i40e_hw *hw)
{
  #line 398 
  i40e_status ret_code = 0;
  #line 400 
  if ((unsigned int)hw->aq.arq.count != 0U) {
    #line 402 
    ret_code = I40E_ERR_NOT_READY;
    #line 403 
    goto init_adminq_exit;
  }
  #line 407 
  if ((unsigned int)hw->aq.num_arq_entries == 0U || (unsigned int)hw->aq.arq_buf_size == 0U) {
    #line 409 
    ret_code = I40E_ERR_CONFIG;
    #line 410 
    goto init_adminq_exit;
  }
  #line 413 
  hw->aq.arq.next_to_use = (unsigned short)0U;
  #line 414 
  hw->aq.arq.next_to_clean = (unsigned short)0U;
  #line 417 
  ret_code = i40e_alloc_adminq_arq_ring(hw);
  #line 418 
  if (ret_code != I40E_SUCCESS) 
                                #line 419 
                                goto init_adminq_exit;
  #line 422 
  ret_code = i40e_alloc_arq_bufs(hw);
  #line 423 
  if (ret_code != I40E_SUCCESS) 
                                #line 424 
                                goto init_adminq_free_rings;
  #line 427 
  ret_code = i40e_config_arq_regs(hw);
  #line 428 
  if (ret_code != I40E_SUCCESS) 
                                #line 429 
                                goto init_adminq_free_rings;
  #line 432 
  hw->aq.arq.count = hw->aq.num_arq_entries;
  #line 433 
  goto init_adminq_exit;
  #line 435 
  init_adminq_free_rings: 
                          #line 435 
  ;
  #line 436 
  i40e_free_adminq_arq(hw);
  #line 438 
  init_adminq_exit: 
                    #line 438 
  ;
  #line 439 
  return ret_code;
}

#line 448  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_shutdown_asq(struct i40e_hw *hw)
{
  #line 450 
  i40e_status ret_code = 0;
  #line 452 
  cif_mutex_lock_asq_mutex_of_i40e_adminq_info(& hw->aq.asq_mutex);
  #line 454 
  if ((unsigned int)hw->aq.asq.count == 0U) {
    #line 455 
    ret_code = I40E_ERR_NOT_READY;
    #line 456 
    goto shutdown_asq_out;
  }
  #line 460 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)hw->aq.asq.head));
  #line 461 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)hw->aq.asq.tail));
  #line 462 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)hw->aq.asq.len));
  #line 463 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)hw->aq.asq.bal));
  #line 464 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)hw->aq.asq.bah));
  #line 466 
  hw->aq.asq.count = (unsigned short)0U;
  #line 469 
  i40e_free_asq_bufs(hw);
  #line 471 
  shutdown_asq_out: 
                    #line 471 
  ;
  #line 472 
  cif_mutex_unlock_asq_mutex_of_i40e_adminq_info(& hw->aq.asq_mutex);
  #line 473 
  return ret_code;
}

#line 482  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static i40e_status i40e_shutdown_arq(struct i40e_hw *hw)
{
  #line 484 
  i40e_status ret_code = 0;
  #line 486 
  cif_mutex_lock_arq_mutex_of_i40e_adminq_info_0(& hw->aq.arq_mutex);
  #line 488 
  if ((unsigned int)hw->aq.arq.count == 0U) {
    #line 489 
    ret_code = I40E_ERR_NOT_READY;
    #line 490 
    goto shutdown_arq_out;
  }
  #line 494 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)hw->aq.arq.head));
  #line 495 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)hw->aq.arq.tail));
  #line 496 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)hw->aq.arq.len));
  #line 497 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)hw->aq.arq.bal));
  #line 498 
  writel(0U,(void *)(hw->hw_addr + (unsigned long)hw->aq.arq.bah));
  #line 500 
  hw->aq.arq.count = (unsigned short)0U;
  #line 503 
  i40e_free_arq_bufs(hw);
  #line 505 
  shutdown_arq_out: 
                    #line 505 
  ;
  #line 506 
  cif_mutex_unlock_arq_mutex_of_i40e_adminq_info_0(& hw->aq.arq_mutex);
  #line 507 
  return ret_code;
}

#line 514  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static void i40e_set_hw_flags(struct i40e_hw *hw)
{
  #line 516 
  struct i40e_adminq_info *aq = & hw->aq;
  #line 518 
  hw->flags = 0ULL;
  #line 520 
  switch ((unsigned int)hw->mac.type) {
    #line 521 
    case (unsigned int)1: 
                          #line 521 
    ;
    #line 522 
    if ((unsigned int)aq->api_maj_ver > 1U || (unsigned int)aq->api_maj_ver == 1U && (unsigned int)aq->api_min_ver > 6U) {
      #line 525 
      hw->flags |= 4ULL;
      #line 526 
      hw->flags |= 16ULL;
      #line 528 
      hw->flags |= 2ULL;
    }
    #line 530 
    break;
    #line 531 
    case (unsigned int)3: 
                          #line 531 
    ;
    #line 532 
    hw->flags |= 9ULL;
    #line 535 
    if ((unsigned int)aq->api_maj_ver > 1U || (unsigned int)aq->api_maj_ver == 1U && (unsigned int)aq->api_min_ver > 5U) 
      #line 538 
      hw->flags |= 16ULL;
    #line 540 
    if ((unsigned int)aq->api_maj_ver > 1U || (unsigned int)aq->api_maj_ver == 1U && (unsigned int)aq->api_min_ver > 8U) 
      #line 543 
      hw->flags |= 4ULL;
    #line 545 
    default: 
             #line 545 
    ;
    #line 546 
    break;
  }
  #line 550 
  if ((unsigned int)aq->api_maj_ver > 1U || (unsigned int)aq->api_maj_ver == 1U && (unsigned int)aq->api_min_ver > 4U) 
    #line 553 
    hw->flags |= 8ULL;
  #line 555 
  if ((unsigned int)aq->api_maj_ver > 1U || (unsigned int)aq->api_maj_ver == 1U && (unsigned int)aq->api_min_ver > 7U) {
    #line 558 
    hw->flags |= 32ULL;
    #line 559 
    hw->flags |= 128ULL;
  }
  #line 562 
  if ((unsigned int)aq->api_maj_ver > 1U || (unsigned int)aq->api_maj_ver == 1U && (unsigned int)aq->api_min_ver > 8U) 
    #line 565 
    hw->flags |= 64ULL;
  #line 566 
  return;
}

#line 579  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
i40e_status i40e_init_adminq(struct i40e_hw *hw)
{
  #line 581 
  u16 cfg_ptr;
  #line 581 
  u16 oem_hi;
  #line 581 
  u16 oem_lo;
  #line 582 
  u16 eetrack_lo;
  #line 582 
  u16 eetrack_hi;
  #line 583 
  i40e_status ret_code;
  #line 584 
  int retry = 0;
  #line 587 
  if ((((unsigned int)hw->aq.num_arq_entries == 0U || (unsigned int)hw->aq.num_asq_entries == 0U) || (unsigned int)hw->aq.arq_buf_size == 0U) || (unsigned int)hw->aq.asq_buf_size == 0U) {
    #line 591 
    ret_code = I40E_ERR_CONFIG;
    #line 592 
    goto init_adminq_exit;
  }
  #line 596 
  i40e_adminq_init_regs(hw);
  #line 599 
  hw->aq.asq_cmd_timeout = 250000U;
  #line 602 
  ret_code = i40e_init_asq(hw);
  #line 603 
  if (ret_code != I40E_SUCCESS) 
                                #line 604 
                                goto init_adminq_destroy_locks;
  #line 607 
  ret_code = i40e_init_arq(hw);
  #line 608 
  if (ret_code != I40E_SUCCESS) 
                                #line 609 
                                goto init_adminq_free_asq;
  #line 615 
  while (1) {
    #line 616 
    ret_code = i40e_aq_get_firmware_version(hw,& hw->aq.fw_maj_ver,& hw->aq.fw_min_ver,& hw->aq.fw_build,& hw->aq.api_maj_ver,& hw->aq.api_min_ver,(struct i40e_asq_cmd_details *)0);
    #line 623 
    if (ret_code != I40E_ERR_ADMIN_QUEUE_TIMEOUT) 
                                                  #line 624 
                                                  break;
    #line 625 
    retry ++;
    #line 626 
    msleep(100U);
    #line 627 
    i40e_resume_aq(hw);
    #line 628 
    if (! (retry <= 9)) 
                        #line 615 
                        break;
  }
  #line 629 
  if (ret_code != I40E_SUCCESS) 
                                #line 630 
                                goto init_adminq_free_arq;
  #line 635 
  i40e_set_hw_flags(hw);
  #line 638 
  i40e_read_nvm_word(hw,(unsigned short)24,& hw->nvm.version);
  #line 640 
  i40e_read_nvm_word(hw,(unsigned short)45,& eetrack_lo);
  #line 641 
  i40e_read_nvm_word(hw,(unsigned short)46,& eetrack_hi);
  #line 642 
  hw->nvm.eetrack = (unsigned int)(((int)eetrack_hi << 16) | (int)eetrack_lo);
  #line 643 
  i40e_read_nvm_word(hw,(unsigned short)23,& cfg_ptr);
  #line 644 
  i40e_read_nvm_word(hw,(unsigned short)((int)((unsigned int)cfg_ptr + 131U)),& oem_hi);
  #line 646 
  i40e_read_nvm_word(hw,(unsigned short)((int)((unsigned int)cfg_ptr + 132U)),& oem_lo);
  #line 648 
  hw->nvm.oem_ver = ((unsigned int)oem_hi << 16) | (unsigned int)oem_lo;
  #line 650 
  if ((hw->mac.type == (unsigned int)I40E_MAC_XL710 && (unsigned int)hw->aq.api_maj_ver == 1U) && (unsigned int)hw->aq.api_min_ver > 6U) {
    #line 653 
    hw->flags |= 4ULL;
    #line 654 
    hw->flags |= 16ULL;
  }
  #line 656 
  if ((hw->mac.type == (unsigned int)I40E_MAC_X722 && (unsigned int)hw->aq.api_maj_ver == 1U) && (unsigned int)hw->aq.api_min_ver > 5U) 
    #line 659 
    hw->flags |= 16ULL;
  #line 663 
  if ((unsigned int)hw->aq.api_maj_ver > 1U || (unsigned int)hw->aq.api_maj_ver == 1U && (unsigned int)hw->aq.api_min_ver > 6U) 
    #line 666 
    hw->flags |= 2ULL;
  #line 668 
  if ((unsigned int)hw->aq.api_maj_ver > 1U) {
    #line 669 
    ret_code = I40E_ERR_FIRMWARE_API_VERSION;
    #line 670 
    goto init_adminq_free_arq;
  }
  #line 674 
  i40e_aq_release_resource(hw,(enum i40e_aq_resources_ids)I40E_NVM_RESOURCE_ID,(unsigned char)0,(struct i40e_asq_cmd_details *)0);
  #line 675 
  hw->nvm_release_on_done = (_Bool)0;
  #line 676 
  hw->nvmupd_state = I40E_NVMUPD_STATE_INIT;
  #line 678 
  ret_code = I40E_SUCCESS;
  #line 681 
  goto init_adminq_exit;
  #line 683 
  init_adminq_free_arq: 
                        #line 683 
  ;
  #line 684 
  i40e_shutdown_arq(hw);
  #line 685 
  init_adminq_free_asq: 
                        #line 685 
  ;
  #line 686 
  i40e_shutdown_asq(hw);
  #line 687 
  init_adminq_destroy_locks: 
                             #line 687 
  ;
  #line 689 
  init_adminq_exit: 
                    #line 689 
  ;
  #line 690 
  return ret_code;
}

#line 697  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
i40e_status i40e_shutdown_adminq(struct i40e_hw *hw)
{
  #line 699 
  i40e_status ret_code = 0;
  #line 701 
  if ((int)i40e_check_asq_alive(hw) != 0) 
                                          #line 702 
                                          i40e_aq_queue_shutdown(hw,(_Bool)1);
  #line 704 
  i40e_shutdown_asq(hw);
  #line 705 
  i40e_shutdown_arq(hw);
  #line 707 
  if (hw->nvm_buff.va != (void *)0) 
                                    #line 708 
                                    i40e_free_virt_mem_d(hw,& hw->nvm_buff);
  #line 710 
  return ret_code;
}

#line 719  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static u16 i40e_clean_asq(struct i40e_hw *hw)
{
  #line 722 
  struct i40e_asq_cmd_details *details;
  #line 724 
  struct i40e_aq_desc desc_cb;
  #line 725 
  struct i40e_aq_desc *desc;
  #line 750 
  unsigned int tmp_1;
  #line 721 
  struct i40e_adminq_ring *asq = & hw->aq.asq;
  #line 723 
  u16 ntc = asq->next_to_clean;
  #line 727 
  desc = (struct i40e_aq_desc *)asq->desc_buf.va + (unsigned long)ntc;
  #line 728 
  details = (struct i40e_asq_cmd_details *)asq->cmd_buf.va + (unsigned long)ntc;
  #line 729 
  while (1) {
    #line 729 
    ;
    #line 729 
    if (! (readl((void *)(hw->hw_addr + (unsigned long)hw->aq.asq.head)) != (unsigned int)ntc)) 
      #line 729 
      break;
    #line 730 
    if ((hw->debug_mask & 100663296U) != 0U) {
      #line 730 
      ;
      #line 730 
      ;
      #line 730 
      ;
      #line 730 
      ;
      #line 730 
      printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)ntc,readl((void *)(hw->hw_addr + (unsigned long)hw->aq.asq.head)));
    }
    #line 733 
    if (details->callback != (void *)0) {
      #line 734 
      void (*cb_func)(struct i40e_hw *, struct i40e_aq_desc *) = (void (*)(struct i40e_hw *, struct i40e_aq_desc *))details->callback;
      #line 736 
      desc_cb = *desc;
      #line 737 
      (*cb_func)(hw,& desc_cb);
    }
    #line 739 
    memset((void *)desc,0,32UL);
    #line 740 
    memset((void *)details,0,32UL);
    #line 741 
    ntc = (u16)((int)ntc + 1);
    #line 742 
    if ((int)asq->count == (int)ntc) 
                                     #line 743 
                                     ntc = (unsigned short)0U;
    #line 744 
    desc = (struct i40e_aq_desc *)asq->desc_buf.va + (unsigned long)ntc;
    #line 745 
    details = (struct i40e_asq_cmd_details *)asq->cmd_buf.va + (unsigned long)ntc;
  }
  #line 748 
  asq->next_to_clean = ntc;
  #line 750 
  if ((int)asq->next_to_clean <= (int)asq->next_to_use) 
                                                        #line 750 
                                                        tmp_1 = (unsigned int)asq->count; else 
                                                                    #line 750 
                                                                    tmp_1 = 0U;
  #line 750 
  ;
  #line 750 
  return (unsigned short)(((tmp_1 + (unsigned int)asq->next_to_clean) - (unsigned int)asq->next_to_use) + 65535U);
}

#line 760  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static bool i40e_asq_done(struct i40e_hw *hw)
{
  #line 765 
  ;
  #line 765 
  return (_Bool)(readl((void *)(hw->hw_addr + (unsigned long)hw->aq.asq.head)) == (unsigned int)hw->aq.asq.next_to_use);
}

#line 780  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
i40e_status i40e_asq_send_command(struct i40e_hw *hw, struct i40e_aq_desc *desc, void *buff, u16 buff_size, struct i40e_asq_cmd_details *cmd_details)
{
  #line 788 
  struct i40e_asq_cmd_details *details;
  #line 789 
  struct i40e_aq_desc *desc_on_ring;
  #line 786 
  i40e_status status = 0;
  #line 787 
  struct i40e_dma_mem *dma_buff = (struct i40e_dma_mem *)0;
  #line 790 
  bool cmd_completed = (_Bool)0;
  #line 791 
  u16 retval = (unsigned short)0U;
  #line 792 
  u32 val = 0U;
  #line 794 
  cif_mutex_lock_asq_mutex_of_i40e_adminq_info(& hw->aq.asq_mutex);
  #line 796 
  if ((unsigned int)hw->aq.asq.count == 0U) {
    #line 797 
    if ((hw->debug_mask & 16777216U) != 0U) 
                                            #line 797 
                                            printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
    #line 799 
    status = I40E_ERR_QUEUE_EMPTY;
    #line 800 
    goto asq_send_command_error;
  }
  #line 803 
  hw->aq.asq_last_status = I40E_AQ_RC_OK;
  #line 805 
  val = readl((void *)(hw->hw_addr + (unsigned long)hw->aq.asq.head));
  #line 806 
  if ((unsigned int)hw->aq.num_asq_entries <= val) {
    #line 807 
    if ((hw->debug_mask & 16777216U) != 0U) 
                                            #line 807 
                                            printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,val);
    #line 809 
    status = I40E_ERR_ADMIN_QUEUE_FULL;
    #line 810 
    goto asq_send_command_error;
  }
  #line 813 
  details = (struct i40e_asq_cmd_details *)hw->aq.asq.cmd_buf.va + (unsigned long)hw->aq.asq.next_to_use;
  #line 814 
  if (cmd_details != (struct i40e_asq_cmd_details *)0) {
    #line 815 
    *details = *cmd_details;
    #line 821 
    if (details->cookie != 0ULL) {
      #line 822 
      desc->cookie_high = (unsigned int)(details->cookie >> 32);
      #line 824 
      desc->cookie_low = (unsigned int)details->cookie;
    }
  }
  else 
       #line 828 
       memset((void *)details,0,32UL);
  #line 832 
  desc->flags = (unsigned short)((int)desc->flags & ~ ((int)details->flags_dis));
  #line 833 
  desc->flags = (unsigned short)((int)desc->flags | (int)details->flags_ena);
  #line 835 
  if ((int)hw->aq.asq_buf_size < (int)buff_size) {
    #line 836 
    if ((hw->debug_mask & 16777216U) != 0U) 
                                            #line 836 
                                            printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)buff_size);
    #line 840 
    status = I40E_ERR_INVALID_SIZE;
    #line 841 
    goto asq_send_command_error;
  }
  #line 844 
  if ((int)details->postpone != 0 && ! details->async) {
    #line 845 
    if ((hw->debug_mask & 16777216U) != 0U) 
                                            #line 845 
                                            printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
    #line 848 
    status = I40E_ERR_PARAM;
    #line 849 
    goto asq_send_command_error;
  }
  #line 859 
  if ((unsigned int)i40e_clean_asq(hw) == 0U) {
    #line 860 
    if ((hw->debug_mask & 16777216U) != 0U) 
                                            #line 860 
                                            printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
    #line 863 
    status = I40E_ERR_ADMIN_QUEUE_FULL;
    #line 864 
    goto asq_send_command_error;
  }
  #line 868 
  desc_on_ring = (struct i40e_aq_desc *)hw->aq.asq.desc_buf.va + (unsigned long)hw->aq.asq.next_to_use;
  #line 871 
  *desc_on_ring = *desc;
  #line 874 
  if (buff != (void *)0) {
    #line 875 
    dma_buff = hw->aq.asq.r.asq_bi + (unsigned long)hw->aq.asq.next_to_use;
    #line 877 
    memcpy(dma_buff->va,buff,(unsigned long)buff_size);
    #line 878 
    desc_on_ring->datalen = buff_size;
    #line 883 
    desc_on_ring->params.external.addr_high = (unsigned int)(dma_buff->pa >> 32);
    #line 885 
    desc_on_ring->params.external.addr_low = (unsigned int)dma_buff->pa;
  }
  #line 890 
  if ((hw->debug_mask & 100663296U) != 0U) 
                                           #line 890 
                                           printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
  #line 891 
  i40e_debug_aq(hw,(enum i40e_debug_mask)I40E_DEBUG_AQ_COMMAND,(void *)desc_on_ring,buff,(unsigned short)((int)buff_size));
  #line 893 
  hw->aq.asq.next_to_use = (u16)((int)hw->aq.asq.next_to_use + 1);
  #line 894 
  if ((int)hw->aq.asq.next_to_use == (int)hw->aq.asq.count) 
                                                            #line 895 
                                                            hw->aq.asq.next_to_use = (unsigned short)0U;
  #line 896 
  if (! details->postpone) 
                           #line 897 
                           writel((unsigned int)hw->aq.asq.next_to_use,(void *)(hw->hw_addr + (unsigned long)hw->aq.asq.tail));
  #line 902 
  if (! details->async && ! details->postpone) {
    #line 903 
    u32 total_delay = 0U;
    #line 905 
    while (1) {
      {
        #line 909 
        if ((int)i40e_asq_done(hw) != 0) 
                                         #line 910 
                                         break;
        #line 911 
        __const_udelay(214750UL);
        #line 912 
        total_delay += 50U;
      }
      #line 913 
      if (! (hw->aq.asq_cmd_timeout > total_delay)) 
                                                    #line 905 
                                                    break;
    }
  }
  #line 917 
  if ((int)i40e_asq_done(hw) != 0) {
    #line 918 
    *desc = *desc_on_ring;
    #line 919 
    if (buff != (void *)0) 
                           #line 920 
                           memcpy(buff,dma_buff->va,(unsigned long)buff_size);
    #line 921 
    retval = desc->retval;
    #line 922 
    if ((unsigned int)retval != 0U) {
      #line 923 
      if ((hw->debug_mask & 16777216U) != 0U) 
                                              #line 923 
                                              printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(int)retval);
      #line 929 
      retval = (unsigned short)((unsigned int)retval & 255U);
    }
    #line 931 
    cmd_completed = (_Bool)1;
    #line 932 
    if ((unsigned int)retval == 0U) 
                                    #line 933 
                                    status = I40E_SUCCESS;
    else 
      #line 934 
      if ((unsigned int)retval == 12U) 
                                       #line 935 
                                       status = I40E_ERR_NOT_READY; else 
                                                                    #line 937 
                                                                    status = I40E_ERR_ADMIN_QUEUE_ERROR;
    #line 938 
    hw->aq.asq_last_status = (enum i40e_admin_queue_err)retval;
  }
  #line 941 
  if ((hw->debug_mask & 100663296U) != 0U) 
                                           #line 941 
                                           printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
  #line 943 
  i40e_debug_aq(hw,(enum i40e_debug_mask)I40E_DEBUG_AQ_COMMAND,(void *)desc,buff,(unsigned short)((int)buff_size));
  #line 946 
  if (details->wb_desc != (struct i40e_aq_desc *)0) 
                                                    #line 947 
                                                    *(details->wb_desc) = *desc_on_ring;
  #line 951 
  if ((! details->async && ! details->postpone) && ! cmd_completed) {
    #line 952 
    if ((readl((void *)(hw->hw_addr + (unsigned long)hw->aq.asq.len)) & 1073741824U) != 0U) {
      #line 953 
      if ((hw->debug_mask & 16777216U) != 0U) 
                                              #line 953 
                                              printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
      #line 955 
      status = I40E_ERR_ADMIN_QUEUE_CRITICAL_ERROR;
    }
    else {
      #line 957 
      if ((hw->debug_mask & 16777216U) != 0U) 
                                              #line 957 
                                              printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
      #line 959 
      status = I40E_ERR_ADMIN_QUEUE_TIMEOUT;
    }
  }
  #line 963 
  asq_send_command_error: 
                          #line 963 
  ;
  #line 964 
  cif_mutex_unlock_asq_mutex_of_i40e_adminq_info(& hw->aq.asq_mutex);
  #line 965 
  return status;
}

#line 975  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
void i40e_fill_default_direct_cmd_desc(struct i40e_aq_desc *desc, u16 opcode)
{
  #line 979 
  memset((void *)desc,0,32UL);
  #line 980 
  desc->opcode = opcode;
  #line 981 
  desc->flags = (unsigned short)8192U;
  #line 982 
  return;
}

#line 994  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
i40e_status i40e_clean_arq_element(struct i40e_hw *hw, struct i40e_arq_event_info *e, u16 *pending)
{
  #line 1045 
  u16 __UNIQUE_ID___x534;
  #line 1045 
  int tmp_0;
  #line 1000 
  struct i40e_aq_desc *desc;
  #line 1001 
  struct i40e_dma_mem *bi;
  #line 1002 
  u16 desc_idx;
  #line 1003 
  u16 datalen;
  #line 1004 
  u16 flags;
  #line 1005 
  u16 ntu;
  #line 998 
  i40e_status ret_code = 0;
  #line 999 
  u16 ntc = hw->aq.arq.next_to_clean;
  #line 1008 
  memset((void *)(& e->desc),0,32UL);
  #line 1011 
  cif_mutex_lock_arq_mutex_of_i40e_adminq_info_0(& hw->aq.arq_mutex);
  #line 1013 
  if ((unsigned int)hw->aq.arq.count == 0U) {
    #line 1014 
    if ((hw->debug_mask & 16777216U) != 0U) 
                                            #line 1014 
                                            printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
    #line 1016 
    ret_code = I40E_ERR_QUEUE_EMPTY;
    #line 1017 
    goto clean_arq_element_err;
  }
  #line 1021 
  ntu = (unsigned short)((unsigned int)((unsigned short)readl((void *)(hw->hw_addr + (unsigned long)hw->aq.arq.head))) & 1023U);
  #line 1022 
  if ((int)ntu == (int)ntc) {
    #line 1024 
    ret_code = I40E_ERR_ADMIN_QUEUE_NO_WORK;
    #line 1025 
    goto clean_arq_element_out;
  }
  #line 1029 
  desc = (struct i40e_aq_desc *)hw->aq.arq.desc_buf.va + (unsigned long)ntc;
  #line 1030 
  desc_idx = ntc;
  #line 1032 
  hw->aq.arq_last_status = (enum i40e_admin_queue_err)desc->retval;
  #line 1034 
  flags = desc->flags;
  #line 1035 
  if (((unsigned long)flags & 4UL) != 0UL) {
    #line 1036 
    ret_code = I40E_ERR_ADMIN_QUEUE_ERROR;
    #line 1037 
    if ((hw->debug_mask & 16777216U) != 0U) 
                                            #line 1037 
                                            printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func,(unsigned int)hw->aq.arq_last_status);
  }
  #line 1043 
  e->desc = *desc;
  #line 1044 
  datalen = desc->datalen;
  {
    #line 1045 
    __UNIQUE_ID___x534 = datalen;
    #line 1045 
    u16 __UNIQUE_ID___y535 = e->buf_len;
    #line 1045 
    if ((int)__UNIQUE_ID___x534 < (int)__UNIQUE_ID___y535) 
                                                           #line 1045 
                                                           tmp_0 = (int)__UNIQUE_ID___x534; else 
                                                                    #line 1045 
                                                                    tmp_0 = (int)__UNIQUE_ID___y535;
    }
  #line 1045 
  e->msg_len = (unsigned short)tmp_0;
  #line 1046 
  if (e->msg_buf != (u8 *)0U && (unsigned int)e->msg_len != 0U) 
                                                                #line 1047 
                                                                memcpy((void *)e->msg_buf,(hw->aq.arq.r.arq_bi + (unsigned long)desc_idx)->va,(unsigned long)e->msg_len);
  #line 1050 
  if ((hw->debug_mask & 100663296U) != 0U) 
                                           #line 1050 
                                           printk((char *)"\001",(int)hw->bus.bus_id,(int)hw->bus.device,(int)hw->bus.func);
  #line 1051 
  i40e_debug_aq(hw,(enum i40e_debug_mask)I40E_DEBUG_AQ_COMMAND,(void *)desc,(void *)e->msg_buf,(unsigned short)((int)hw->aq.arq_buf_size));
  #line 1058 
  bi = hw->aq.arq.r.arq_bi + (unsigned long)ntc;
  #line 1059 
  memset((void *)desc,0,32UL);
  #line 1061 
  desc->flags = (unsigned short)4096U;
  #line 1062 
  if ((unsigned int)hw->aq.arq_buf_size > 512U) 
                                                #line 1063 
                                                desc->flags = (unsigned short)((unsigned int)desc->flags | 512U);
  #line 1064 
  desc->datalen = (unsigned short)bi->size;
  #line 1065 
  desc->params.external.addr_high = (unsigned int)(bi->pa >> 32);
  #line 1066 
  desc->params.external.addr_low = (unsigned int)bi->pa;
  #line 1069 
  writel((unsigned int)ntc,(void *)(hw->hw_addr + (unsigned long)hw->aq.arq.tail));
  #line 1071 
  ntc = (u16)((int)ntc + 1);
  #line 1072 
  if ((int)hw->aq.num_arq_entries == (int)ntc) 
                                               #line 1073 
                                               ntc = (unsigned short)0U;
  #line 1074 
  hw->aq.arq.next_to_clean = ntc;
  #line 1075 
  hw->aq.arq.next_to_use = ntu;
  #line 1077 
  i40e_nvmupd_check_wait_event(hw,(unsigned short)((int)e->desc.opcode),& e->desc);
  #line 1078 
  clean_arq_element_out: 
                         #line 1078 
  ;
  #line 1080 
  if (pending != (u16 *)0U) {
    #line 1081 
    unsigned int tmp_2;
    #line 1081 
    if ((int)ntc > (int)ntu) 
                             #line 1081 
                             tmp_2 = (unsigned int)hw->aq.arq.count; else 
                                                                    #line 1081 
                                                                    tmp_2 = 0U;
    #line 1081 
    *pending = (unsigned short)(tmp_2 + (unsigned int)((int)ntu - (int)ntc));
  }
  #line 1082 
  clean_arq_element_err: 
                         #line 1082 
  ;
  #line 1083 
  cif_mutex_unlock_arq_mutex_of_i40e_adminq_info_0(& hw->aq.arq_mutex);
  #line 1085 
  return ret_code;
}

#line 1088  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_adminq.c"
static void i40e_resume_aq(struct i40e_hw *hw)
{
  #line 1091 
  hw->aq.asq.next_to_use = (unsigned short)0U;
  #line 1092 
  hw->aq.asq.next_to_clean = (unsigned short)0U;
  #line 1094 
  i40e_config_asq_regs(hw);
  #line 1096 
  hw->aq.arq.next_to_use = (unsigned short)0U;
  #line 1097 
  hw->aq.arq.next_to_clean = (unsigned short)0U;
  #line 1099 
  i40e_config_arq_regs(hw);
  #line 1100 
  return;
}

#line 799  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_adminq.i.aux"
static void cif_mutex_lock_asq_mutex_of_i40e_adminq_info(struct mutex *lock)
{
  #line 802 
  ldv_mutex_model_lock(lock,(char *)"asq_mutex_of_i40e_adminq_info");
  #line 803 
  return;
}

#line 806  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_adminq.i.aux"
static void cif_mutex_unlock_asq_mutex_of_i40e_adminq_info(struct mutex *lock)
{
  #line 809 
  ldv_mutex_model_unlock(lock,(char *)"asq_mutex_of_i40e_adminq_info");
  #line 810 
  return;
}

#line 813  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_adminq.i.aux"
static void cif_mutex_lock_arq_mutex_of_i40e_adminq_info_0(struct mutex *lock)
{
  #line 816 
  ldv_mutex_model_lock(lock,(char *)"arq_mutex_of_i40e_adminq_info");
  #line 817 
  return;
}

#line 820  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_adminq.i.aux"
static void cif_mutex_unlock_arq_mutex_of_i40e_adminq_info_0(struct mutex *lock)
{
  #line 823 
  ldv_mutex_model_unlock(lock,(char *)"arq_mutex_of_i40e_adminq_info");
  #line 824 
  return;
}

#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 120  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_client.i.aux"
static void cif_set_bit_2(long nr, unsigned long *addr);
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 127  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_client.i.aux"
static void cif_clear_bit_2(long nr, unsigned long *addr);
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
#line 134  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_client.i.aux"
static void INIT_LIST_HEAD_0(struct list_head *list);
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_add_1(struct list_head *new, struct list_head *prev, struct list_head *next)
{
  #line 60 
  if (! __list_add_valid(new,prev,next)) 
                                         #line 61 
                                         return;
  #line 63 
  next->prev = new;
  #line 64 
  new->next = next;
  #line 65 
  new->prev = prev;
  {
    #line 67 
    union __anonunion___u_15075 __u = {.__val = new};
    #line 66 
    __write_once_size((void *)(& prev->next),(void *)(& __u.__c),8);
    #line 66 
    struct list_head *tmp_2 = __u.__val;
  }
  #line 68 
  return;
}

#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void list_add_0(struct list_head *new, struct list_head *head)
{
  #line 79 
  __list_add_1(new,head,head->next);
  #line 80 
  return;
}

#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_del_1(struct list_head *prev, struct list_head *next)
{
  #line 97 
  next->prev = prev;
  {
    #line 107 
    union __anonunion___u_15077 __u = {.__val = next};
    #line 106 
    __write_once_size((void *)(& prev->next),(void *)(& __u.__c),8);
    #line 106 
    struct list_head *tmp = __u.__val;
  }
  #line 108 
  return;
}

#line 129  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_del_entry_1(struct list_head *entry)
{
  #line 131 
  if (! __list_del_entry_valid(entry)) 
                                       #line 132 
                                       return;
  #line 134 
  __list_del_1(entry->prev,entry->next);
  #line 135 
  return;
}

#line 137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void list_del_1(struct list_head *entry)
{
  #line 139 
  __list_del_entry_1(entry);
  #line 140 
  entry->next = (struct list_head *)(-2401263026318606080);
  #line 141 
  entry->prev = (struct list_head *)(-2401263026318606046);
  #line 142 
  return;
}

#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/string.h"
#line 148  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_client.i.aux"
static size_t cif_strlen(char *s);
#line 26 
#line 831 
static void cif_mutex_lock_i40e_device_mutex(struct mutex *lock);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/string.h"
#line 25 
size_t ldv_strlen(char *s);
#line 185  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mutex.h"
#line 838  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_client.i.aux"
static void cif_mutex_unlock_i40e_device_mutex(struct mutex *lock);
#line 291  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/overflow.h"
__inline static size_t __ab_c_size_0(size_t a, size_t b, size_t c)
{
  #line 297 
  size_t __b_0;
  #line 297 
  size_t *__d_0;
  #line 295 
  size_t __a;
  #line 295 
  size_t __b;
  #line 295 
  size_t *__d;
  #line 297 
  size_t __a_0;
  #line 293 
  size_t bytes;
  {
    #line 295 
    __a = a;
    #line 295 
    __b = b;
    #line 295 
    __d = & bytes;
    #line 295 
    int tmp = & __a == __d;
    }
  #line 295 
  if (__builtin_mul_overflow(__a,__b,__d) != 0) 
                                                #line 296 
                                                return 18446744073709551615UL;
  {
    #line 297 
    __a_0 = bytes;
    #line 297 
    __b_0 = c;
    #line 297 
    __d_0 = & bytes;
    #line 297 
    int tmp_3 = & __a_0 == __d_0;
    }
  #line 297 
  if (__builtin_add_overflow(__a_0,__b_0,__d_0) != 0) 
                                                      #line 298 
                                                      return 18446744073709551615UL;
  #line 300 
  return bytes;
}

#line 668  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 428  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_client.i.aux"
static void *kzalloc_4(size_t size, gfp_t flags);
#line 200  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.h"
#line 742  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
int i40e_register_client(struct i40e_client *client);
#line 201  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.h"
#line 792  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
int i40e_unregister_client(struct i40e_client *client);
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static char i40e_client_interface_version_str[8U] = {(char)'0'};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static struct i40e_client *registered_client;
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static struct list_head i40e_devices = {.next = & i40e_devices, .prev = & i40e_devices};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static struct mutex i40e_device_mutex = {.wait_lock = {.__anonCompField_spinlock_25 = {.rlock = {.magic = 3735899821U, .owner_cpu = 4294967295U, .owner = (void *)(-1), .dep_map = {.name = (char *)"i40e_device_mutex.wait_lock"}}}}, .wait_list = {.next = & i40e_device_mutex.wait_list, .prev = & i40e_device_mutex.wait_list}, .magic = (void *)(& i40e_device_mutex), .dep_map = {.name = (char *)"i40e_device_mutex"}};
#line 16 
#line 548 
static int i40e_client_virtchnl_send(struct i40e_info *ldev, struct i40e_client *client, u32 vf_id, u8 *msg, u16 len);
#line 20 
#line 573 
static int i40e_client_setup_qvlist(struct i40e_info *ldev, struct i40e_client *client, struct i40e_qvlist_info *qvlist_info);
#line 24 
#line 644 
static void i40e_client_request_reset(struct i40e_info *ldev, struct i40e_client *client, u32 reset_level);
#line 28 
#line 678 
static int i40e_client_update_vsi_ctxt(struct i40e_info *ldev, struct i40e_client *client, bool is_vf, u32 vf_id, u32 flag, u32 valid_flag);
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static struct i40e_ops i40e_lan_ops = {.setup_qvlist = & i40e_client_setup_qvlist, .virtchnl_send = & i40e_client_virtchnl_send, .request_reset = & i40e_client_request_reset, .update_vsi_ctxt = & i40e_client_update_vsi_ctxt};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static int i40e_client_get_params(struct i40e_vsi *vsi, struct i40e_params *params)
{
  #line 49 
  struct i40e_dcbx_config *dcb_cfg = & (vsi->back)->hw.local_dcbx_config;
  #line 50 
  int i = 0;
  #line 52 
  i = 0;
  #line 52 
  while (i <= 7) {
    {
      #line 54 
      u16 qs_handle;
      #line 53 
      u8 tc = dcb_cfg->etscfg.prioritytable[i];
      #line 57 
      if ((((unsigned long)vsi->tc_config.enabled_tc >> (int)tc) & 1UL) == 0UL) 
        #line 58 
        tc = (unsigned char)0U;
      #line 60 
      qs_handle = vsi->info.qs_handle[(int)tc];
      #line 61 
      params->qos.prio_qos[i].tc = tc;
      #line 62 
      params->qos.prio_qos[i].qs_handle = qs_handle;
      #line 63 
      if ((unsigned int)qs_handle == 65535U) {
        #line 64 
        _dev_err(& ((vsi->back)->pdev)->dev,(char *)"Invalid queue set handle for TC = %d, vsi id = %d\n",(int)tc,(int)vsi->id);
        #line 66 
        return -22;
      }
    }
    #line 52 
    i ++;
  }
  #line 70 
  params->mtu = (unsigned short)(vsi->netdev)->mtu;
  #line 71 
  return 0;
}

#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
void i40e_notify_client_of_vf_msg(struct i40e_vsi *vsi, u32 vf_id, u8 *msg, u16 len)
{
  #line 86 
  struct i40e_pf *pf = vsi->back;
  #line 87 
  struct i40e_client_instance *cdev = pf->cinst;
  #line 89 
  if (cdev == (struct i40e_client_instance *)0 || cdev->client == (struct i40e_client *)0) 
    #line 90 
    return;
  #line 91 
  if ((cdev->client)->ops == (struct i40e_client_ops *)0 || ((cdev->client)->ops)->virtchnl_receive == (int (*)(struct i40e_info *, struct i40e_client *, u32 , u8 *, u16 ))0) {
    {
      #line 92 
      bool branch;
      #line 92 
      struct _ddebug __UNIQUE_ID_ddebug558 = {.modname = (char *)"i40e", .function = (char *)"i40e_notify_client_of_vf_msg", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c", .format = (char *)"Cannot locate client instance virtual channel receive routine\n", .lineno = (unsigned int)92U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 92 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug558.key.dd_key_false.key,(_Bool)0);
      #line 92 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 92 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug558,& (pf->pdev)->dev,(char *)"Cannot locate client instance virtual channel receive routine\n");
    }
    #line 94 
    return;
  }
  #line 96 
  if (! test_bit(1L,& cdev->state)) {
    {
      #line 97 
      bool branch_0;
      #line 97 
      struct _ddebug __UNIQUE_ID_ddebug559 = {.modname = (char *)"i40e", .function = (char *)"i40e_notify_client_of_vf_msg", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c", .format = (char *)"Client is not open, abort virtchnl_receive\n", .lineno = (unsigned int)97U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 97 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug559.key.dd_key_false.key,(_Bool)0);
      #line 97 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 97 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug559,& (pf->pdev)->dev,(char *)"Client is not open, abort virtchnl_receive\n");
    }
    #line 98 
    return;
  }
  #line 100 
  (*(((cdev->client)->ops)->virtchnl_receive))(& cdev->lan_info,cdev->client,vf_id,msg,(unsigned short)((int)len));
  #line 101 
  return;
}

#line 110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
void i40e_notify_client_of_l2_param_changes(struct i40e_vsi *vsi)
{
  #line 114 
  struct i40e_params params;
  #line 112 
  struct i40e_pf *pf = vsi->back;
  #line 113 
  struct i40e_client_instance *cdev = pf->cinst;
  #line 116 
  if (cdev == (struct i40e_client_instance *)0 || cdev->client == (struct i40e_client *)0) 
    #line 117 
    return;
  #line 118 
  if ((cdev->client)->ops == (struct i40e_client_ops *)0 || ((cdev->client)->ops)->l2_param_change == (void (*)(struct i40e_info *, struct i40e_client *, struct i40e_params *))0) {
    {
      #line 119 
      bool branch;
      #line 119 
      struct _ddebug __UNIQUE_ID_ddebug560 = {.modname = (char *)"i40e", .function = (char *)"i40e_notify_client_of_l2_param_changes", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c", .format = (char *)"Cannot locate client instance l2_param_change routine\n", .lineno = (unsigned int)119U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 119 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug560.key.dd_key_false.key,(_Bool)0);
      #line 119 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 119 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug560,& ((vsi->back)->pdev)->dev,(char *)"Cannot locate client instance l2_param_change routine\n");
    }
    #line 121 
    return;
  }
  #line 123 
  if (! test_bit(1L,& cdev->state)) {
    {
      #line 124 
      bool branch_0;
      #line 124 
      struct _ddebug __UNIQUE_ID_ddebug561 = {.modname = (char *)"i40e", .function = (char *)"i40e_notify_client_of_l2_param_changes", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c", .format = (char *)"Client is not open, abort l2 param change\n", .lineno = (unsigned int)124U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 124 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug561.key.dd_key_false.key,(_Bool)0);
      #line 124 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 124 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug561,& ((vsi->back)->pdev)->dev,(char *)"Client is not open, abort l2 param change\n");
    }
    #line 125 
    return;
  }
  #line 127 
  memset((void *)(& params),0,34UL);
  #line 128 
  i40e_client_get_params(vsi,& params);
  #line 129 
  memcpy((void *)(& cdev->lan_info.params),(void *)(& params),34UL);
  #line 130 
  (*(((cdev->client)->ops)->l2_param_change))(& cdev->lan_info,cdev->client,& params);
  #line 132 
  return;
}

#line 139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static void i40e_client_release_qvlist(struct i40e_info *ldev)
{
  #line 142 
  u32 i;
  #line 141 
  struct i40e_qvlist_info *qvlist_info = ldev->qvlist_info;
  #line 144 
  if (ldev->qvlist_info == (struct i40e_qvlist_info *)0) 
                                                         #line 145 
                                                         return;
  #line 147 
  i = 0U;
  #line 147 
  while (qvlist_info->num_vectors > i) {
    {
      #line 149 
      struct i40e_qv_info *qv_info;
      #line 150 
      u32 reg_idx;
      #line 148 
      struct i40e_pf *pf = (struct i40e_pf *)ldev->pf;
      #line 152 
      qv_info = & qvlist_info->qv_info[i];
      #line 153 
      if (qv_info == (struct i40e_qv_info *)0) 
                                               #line 154 
                                               goto __Cont;
      #line 155 
      reg_idx = (qv_info->v_idx + 54271U) * 4U;
      #line 156 
      writel(2047U,(void *)(pf->hw.hw_addr + (unsigned long)reg_idx));
    }
    #line 147 
    __Cont: 
            #line 147 
    i ++;
  }
  #line 158 
  kfree((void *)ldev->qvlist_info);
  #line 159 
  ldev->qvlist_info = (struct i40e_qvlist_info *)0;
  #line 160 
  return;
}

#line 169  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
void i40e_notify_client_of_netdev_close(struct i40e_vsi *vsi, bool reset)
{
  #line 171 
  struct i40e_pf *pf = vsi->back;
  #line 172 
  struct i40e_client_instance *cdev = pf->cinst;
  #line 174 
  if (cdev == (struct i40e_client_instance *)0 || cdev->client == (struct i40e_client *)0) 
    #line 175 
    return;
  #line 176 
  if ((cdev->client)->ops == (struct i40e_client_ops *)0 || ((cdev->client)->ops)->close == (void (*)(struct i40e_info *, struct i40e_client *, bool ))0) {
    {
      #line 177 
      bool branch;
      #line 177 
      struct _ddebug __UNIQUE_ID_ddebug562 = {.modname = (char *)"i40e", .function = (char *)"i40e_notify_client_of_netdev_close", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c", .format = (char *)"Cannot locate client instance close routine\n", .lineno = (unsigned int)177U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 177 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug562.key.dd_key_false.key,(_Bool)0);
      #line 177 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 177 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug562,& ((vsi->back)->pdev)->dev,(char *)"Cannot locate client instance close routine\n");
    }
    #line 179 
    return;
  }
  #line 181 
  (*(((cdev->client)->ops)->close))(& cdev->lan_info,cdev->client,(_Bool)((bool)((int)reset) != 0));
  #line 182 
  cif_clear_bit_2(1L,& cdev->state);
  #line 183 
  i40e_client_release_qvlist(& cdev->lan_info);
  #line 184 
  return;
}

#line 193  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
void i40e_notify_client_of_vf_reset(struct i40e_pf *pf, u32 vf_id)
{
  #line 195 
  struct i40e_client_instance *cdev = pf->cinst;
  #line 197 
  if (cdev == (struct i40e_client_instance *)0 || cdev->client == (struct i40e_client *)0) 
    #line 198 
    return;
  #line 199 
  if ((cdev->client)->ops == (struct i40e_client_ops *)0 || ((cdev->client)->ops)->vf_reset == (void (*)(struct i40e_info *, struct i40e_client *, u32 ))0) {
    {
      #line 200 
      bool branch;
      #line 200 
      struct _ddebug __UNIQUE_ID_ddebug563 = {.modname = (char *)"i40e", .function = (char *)"i40e_notify_client_of_vf_reset", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c", .format = (char *)"Cannot locate client instance VF reset routine\n", .lineno = (unsigned int)200U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 200 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug563.key.dd_key_false.key,(_Bool)0);
      #line 200 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 200 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug563,& (pf->pdev)->dev,(char *)"Cannot locate client instance VF reset routine\n");
    }
    #line 202 
    return;
  }
  #line 204 
  if (! test_bit(1L,& cdev->state)) {
    {
      #line 205 
      bool branch_0;
      #line 205 
      struct _ddebug __UNIQUE_ID_ddebug564 = {.modname = (char *)"i40e", .function = (char *)"i40e_notify_client_of_vf_reset", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c", .format = (char *)"Client is not open, abort vf-reset\n", .lineno = (unsigned int)205U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 205 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug564.key.dd_key_false.key,(_Bool)0);
      #line 205 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 205 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug564,& (pf->pdev)->dev,(char *)"Client is not open, abort vf-reset\n");
    }
    #line 206 
    return;
  }
  #line 208 
  (*(((cdev->client)->ops)->vf_reset))(& cdev->lan_info,cdev->client,vf_id);
  #line 209 
  return;
}

#line 218  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
void i40e_notify_client_of_vf_enable(struct i40e_pf *pf, u32 num_vfs)
{
  #line 220 
  struct i40e_client_instance *cdev = pf->cinst;
  #line 222 
  if (cdev == (struct i40e_client_instance *)0 || cdev->client == (struct i40e_client *)0) 
    #line 223 
    return;
  #line 224 
  if ((cdev->client)->ops == (struct i40e_client_ops *)0 || ((cdev->client)->ops)->vf_enable == (void (*)(struct i40e_info *, struct i40e_client *, u32 ))0) {
    {
      #line 225 
      bool branch;
      #line 225 
      struct _ddebug __UNIQUE_ID_ddebug565 = {.modname = (char *)"i40e", .function = (char *)"i40e_notify_client_of_vf_enable", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c", .format = (char *)"Cannot locate client instance VF enable routine\n", .lineno = (unsigned int)225U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 225 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug565.key.dd_key_false.key,(_Bool)0);
      #line 225 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 225 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug565,& (pf->pdev)->dev,(char *)"Cannot locate client instance VF enable routine\n");
    }
    #line 227 
    return;
  }
  #line 229 
  if (! test_bit(1L,& cdev->state)) {
    {
      #line 231 
      bool branch_0;
      #line 231 
      struct _ddebug __UNIQUE_ID_ddebug566 = {.modname = (char *)"i40e", .function = (char *)"i40e_notify_client_of_vf_enable", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c", .format = (char *)"Client is not open, abort vf-enable\n", .lineno = (unsigned int)231U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 231 
      branch_0 = arch_static_branch(& __UNIQUE_ID_ddebug566.key.dd_key_false.key,(_Bool)0);
      #line 231 
      if ((long)((long)((int)branch_0 != 0)) != 0L) 
                                                    #line 231 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug566,& (pf->pdev)->dev,(char *)"Client is not open, abort vf-enable\n");
    }
    #line 232 
    return;
  }
  #line 234 
  (*(((cdev->client)->ops)->vf_enable))(& cdev->lan_info,cdev->client,num_vfs);
  #line 235 
  return;
}

#line 245  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
int i40e_vf_client_capable(struct i40e_pf *pf, u32 vf_id)
{
  #line 247 
  struct i40e_client_instance *cdev = pf->cinst;
  #line 248 
  int capable = 0;
  #line 250 
  if (cdev == (struct i40e_client_instance *)0 || cdev->client == (struct i40e_client *)0) 
    #line 251 
    goto out;
  #line 252 
  if ((cdev->client)->ops == (struct i40e_client_ops *)0 || ((cdev->client)->ops)->vf_capable == (int (*)(struct i40e_info *, struct i40e_client *, u32 ))0) {
    {
      #line 253 
      bool branch;
      #line 253 
      struct _ddebug __UNIQUE_ID_ddebug567 = {.modname = (char *)"i40e", .function = (char *)"i40e_vf_client_capable", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c", .format = (char *)"Cannot locate client instance VF capability routine\n", .lineno = (unsigned int)253U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 253 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug567.key.dd_key_false.key,(_Bool)0);
      #line 253 
      if ((long)((long)((int)branch != 0)) != 0L) 
                                                  #line 253 
                                                  __dynamic_dev_dbg(& __UNIQUE_ID_ddebug567,& (pf->pdev)->dev,(char *)"Cannot locate client instance VF capability routine\n");
    }
    #line 255 
    goto out;
  }
  #line 257 
  if (! test_bit(1L,& cdev->state)) 
                                    #line 258 
                                    goto out;
  #line 260 
  capable = (*(((cdev->client)->ops)->vf_capable))(& cdev->lan_info,cdev->client,vf_id);
  #line 263 
  out: 
       #line 263 
  ;
  #line 264 
  return capable;
}

#line 267  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
void i40e_client_update_msix_info(struct i40e_pf *pf)
{
  #line 269 
  struct i40e_client_instance *cdev = pf->cinst;
  #line 271 
  if (cdev == (struct i40e_client_instance *)0 || cdev->client == (struct i40e_client *)0) 
    #line 272 
    return;
  #line 274 
  cdev->lan_info.msix_count = pf->num_iwarp_msix;
  #line 275 
  cdev->lan_info.msix_entries = pf->msix_entries + (unsigned long)pf->iwarp_base_vector;
  #line 276 
  return;
}

#line 285  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static void i40e_client_add_instance(struct i40e_pf *pf)
{
  #line 319 
  void *__mptr;
  #line 287 
  struct i40e_client_instance *cdev = (struct i40e_client_instance *)0;
  #line 288 
  struct netdev_hw_addr *mac = (struct netdev_hw_addr *)0;
  #line 289 
  struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)pf->lan_vsi);
  #line 291 
  if (registered_client == (struct i40e_client *)0 || pf->cinst != (struct i40e_client_instance *)0) 
    #line 292 
    return;
  #line 294 
  cdev = (struct i40e_client_instance *)kzalloc_4(176UL,3264U);
  #line 295 
  if (cdev == (struct i40e_client_instance *)0) 
                                                #line 296 
                                                return;
  #line 298 
  cdev->lan_info.pf = (void *)pf;
  #line 299 
  cdev->lan_info.netdev = vsi->netdev;
  #line 300 
  cdev->lan_info.pcidev = pf->pdev;
  #line 301 
  cdev->lan_info.fid = pf->hw.pf_id;
  #line 302 
  cdev->lan_info.ftype = (unsigned char)0U;
  #line 303 
  cdev->lan_info.hw_addr = pf->hw.hw_addr;
  #line 304 
  cdev->lan_info.ops = & i40e_lan_ops;
  #line 305 
  cdev->lan_info.version.major = (unsigned char)0U;
  #line 306 
  cdev->lan_info.version.minor = (unsigned char)1U;
  #line 307 
  cdev->lan_info.version.build = (unsigned char)0U;
  #line 308 
  cdev->lan_info.fw_maj_ver = pf->hw.aq.fw_maj_ver;
  #line 309 
  cdev->lan_info.fw_min_ver = pf->hw.aq.fw_min_ver;
  #line 310 
  cdev->lan_info.fw_build = pf->hw.aq.fw_build;
  #line 311 
  cif_set_bit_2(0L,& cdev->state);
  #line 313 
  if (i40e_client_get_params(vsi,& cdev->lan_info.params) != 0) {
    #line 314 
    kfree((void *)cdev);
    #line 315 
    cdev = (struct i40e_client_instance *)0;
    #line 316 
    return;
  }
  #line 319 
  __mptr = (void *)(cdev->lan_info.netdev)->dev_addrs.list.next;
  #line 319 
  mac = ((struct netdev_hw_addr *)__mptr);
  #line 321 
  if (mac != (struct netdev_hw_addr *)0) 
                                         #line 322 
                                         ether_addr_copy((u8 *)(& cdev->lan_info.lanmac),(u8 *)(& mac->addr)); else 
                                                                    #line 324 
                                                                    _dev_err(& (pf->pdev)->dev,(char *)"MAC address list is empty!\n");
  #line 326 
  cdev->client = registered_client;
  #line 327 
  pf->cinst = cdev;
  #line 329 
  i40e_client_update_msix_info(pf);
  #line 330 
  return;
}

#line 338  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static void i40e_client_del_instance(struct i40e_pf *pf)
{
  #line 340 
  kfree((void *)pf->cinst);
  #line 341 
  pf->cinst = (struct i40e_client_instance *)0;
  #line 342 
  return;
}

#line 348  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
void i40e_client_subtask(struct i40e_pf *pf)
{
  #line 351 
  struct i40e_client_instance *cdev;
  #line 350 
  struct i40e_client *client = registered_client;
  #line 352 
  struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)pf->lan_vsi);
  #line 353 
  int ret = 0;
  #line 355 
  if (! test_and_set_bit(30L,(unsigned long *)(& pf->state))) 
                                                              #line 356 
                                                              return;
  #line 357 
  cdev = pf->cinst;
  #line 360 
  if ((int)test_bit(3L,(unsigned long *)(& pf->state)) != 0) 
                                                             #line 362 
                                                             return;
  else {
    #line 360 
    if ((int)test_bit(1L,(unsigned long *)(& pf->state)) != 0) 
                                                               #line 362 
                                                               return;
  }
  #line 364 
  if (client == (struct i40e_client *)0 || cdev == (struct i40e_client_instance *)0) 
    #line 365 
    return;
  #line 370 
  if (! test_bit(1L,& cdev->state)) 
    #line 371 
    if (((int)vsi->netdev_registered != 0 && client->ops != (struct i40e_client_ops *)0) && (client->ops)->open != (int (*)(struct i40e_info *, struct i40e_client *))0) {
      #line 373 
      cif_set_bit_2(1L,& cdev->state);
      #line 374 
      ret = (*((client->ops)->open))(& cdev->lan_info,client);
      #line 375 
      if (ret != 0) {
        #line 377 
        cif_clear_bit_2(1L,& cdev->state);
        #line 379 
        i40e_client_del_instance(pf);
      }
    }
  #line 386 
  if ((int)test_bit(0L,(unsigned long *)(& vsi->state)) != 0) 
                                                              #line 387 
                                                              i40e_client_update_vsi_ctxt(& cdev->lan_info,client,(_Bool)0,0U,0U,2U); else 
                                                                    #line 391 
                                                                    i40e_client_update_vsi_ctxt(& cdev->lan_info,client,(_Bool)0,0U,2U,2U);
  #line 392 
  return;
}

#line 403  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
int i40e_lan_add_device(struct i40e_pf *pf)
{
  #line 409 
  void *__mptr;
  #line 405 
  struct i40e_device *ldev;
  #line 406 
  int ret = 0;
  #line 408 
  cif_mutex_lock_i40e_device_mutex(& i40e_device_mutex);
  #line 409 
  __mptr = (void *)i40e_devices.next;
  #line 409 
  ldev = ((struct i40e_device *)__mptr);
  #line 409 
  while (& ldev->list != & i40e_devices) {
    #line 409 
    void *__mptr_0;
    #line 410 
    if (ldev->pf == pf) {
      #line 411 
      ret = -17;
      #line 412 
      goto out;
    }
    #line 409 
    __mptr_0 = (void *)ldev->list.next;
    #line 409 
    ldev = ((struct i40e_device *)__mptr_0);
  }
  #line 415 
  ldev = (struct i40e_device *)kzalloc_4(24UL,3264U);
  #line 416 
  if (ldev == (struct i40e_device *)0) {
    #line 417 
    ret = -12;
    #line 418 
    goto out;
  }
  #line 420 
  ldev->pf = pf;
  #line 421 
  INIT_LIST_HEAD_0(& ldev->list);
  #line 422 
  list_add_0(& ldev->list,& i40e_devices);
  #line 423 
  _dev_info(& (pf->pdev)->dev,(char *)"Added LAN device PF%d bus=0x%02x dev=0x%02x func=0x%02x\n",(int)pf->hw.pf_id,(int)pf->hw.bus.bus_id,(int)pf->hw.bus.device,(int)pf->hw.bus.func);
  #line 430 
  if (registered_client != (struct i40e_client *)0) 
                                                    #line 431 
                                                    i40e_client_add_instance(pf);
  #line 437 
  cif_set_bit_2(30L,(unsigned long *)(& pf->state));
  #line 438 
  i40e_service_event_schedule(pf);
  #line 440 
  out: 
       #line 440 
  ;
  #line 441 
  cif_mutex_unlock_i40e_device_mutex(& i40e_device_mutex);
  #line 442 
  return ret;
}

#line 451  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
int i40e_lan_del_device(struct i40e_pf *pf)
{
  #line 460 
  void *__mptr;
  #line 460 
  void *__mptr_0;
  #line 453 
  struct i40e_device *ldev;
  #line 453 
  struct i40e_device *tmp;
  #line 454 
  int ret = -19;
  #line 457 
  i40e_client_del_instance(pf);
  #line 459 
  cif_mutex_lock_i40e_device_mutex(& i40e_device_mutex);
  #line 460 
  __mptr = (void *)i40e_devices.next;
  #line 460 
  ldev = ((struct i40e_device *)__mptr);
  #line 460 
  __mptr_0 = (void *)ldev->list.next;
  #line 461 
  tmp = ((struct i40e_device *)__mptr_0);
  #line 460 
  while (& ldev->list != & i40e_devices) {
    #line 460 
    void *__mptr_1;
    #line 461 
    if (ldev->pf == pf) {
      #line 462 
      _dev_info(& (pf->pdev)->dev,(char *)"Deleted LAN device PF%d bus=0x%02x dev=0x%02x func=0x%02x\n",(int)pf->hw.pf_id,(int)pf->hw.bus.bus_id,(int)pf->hw.bus.device,(int)pf->hw.bus.func);
      #line 465 
      list_del_1(& ldev->list);
      #line 466 
      kfree((void *)ldev);
      #line 467 
      ret = 0;
      #line 468 
      break;
    }
    #line 460 
    ldev = tmp;
    #line 460 
    __mptr_1 = (void *)tmp->list.next;
    #line 460 
    tmp = ((struct i40e_device *)__mptr_1);
  }
  #line 471 
  cif_mutex_unlock_i40e_device_mutex(& i40e_device_mutex);
  #line 472 
  return ret;
}

#line 480  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static void i40e_client_release(struct i40e_client *client)
{
  #line 487 
  void *__mptr;
  #line 482 
  struct i40e_client_instance *cdev;
  #line 483 
  struct i40e_device *ldev;
  #line 484 
  struct i40e_pf *pf;
  #line 486 
  cif_mutex_lock_i40e_device_mutex(& i40e_device_mutex);
  #line 487 
  __mptr = (void *)i40e_devices.next;
  #line 487 
  ldev = ((struct i40e_device *)__mptr);
  #line 487 
  while (& ldev->list != & i40e_devices) {
    #line 487 
    void *__mptr_0;
    {
      #line 488 
      pf = ldev->pf;
      #line 489 
      cdev = pf->cinst;
      #line 490 
      if (cdev == (struct i40e_client_instance *)0) 
                                                    #line 491 
                                                    goto __Cont;
      #line 493 
      while (1) {
        #line 493 
        if (! ((int)test_and_set_bit(4L,(unsigned long *)(& pf->state)) != 0)) 
          #line 493 
          break;
        #line 495 
        usleep_range(500UL,1000UL);
      }
      #line 497 
      if ((int)test_bit(1L,& cdev->state) != 0) {
        #line 498 
        if (client->ops != (struct i40e_client_ops *)0 && (client->ops)->close != (void (*)(struct i40e_info *, struct i40e_client *, bool ))0) 
          #line 499 
          (*((client->ops)->close))(& cdev->lan_info,client,(_Bool)0);
        #line 501 
        i40e_client_release_qvlist(& cdev->lan_info);
        #line 502 
        cif_clear_bit_2(1L,& cdev->state);
        #line 504 
        _dev_warn(& (pf->pdev)->dev,(char *)"Client %s instance for PF id %d closed\n",(char *)(& client->name),(int)pf->hw.pf_id);
      }
      #line 509 
      i40e_client_del_instance(pf);
      #line 510 
      _dev_info(& (pf->pdev)->dev,(char *)"Deleted client instance of Client %s\n",(char *)(& client->name));
      #line 512 
      cif_clear_bit_2(4L,(unsigned long *)(& pf->state));
    }
    #line 487 
    __Cont: { /* sequence */
              #line 487 
              __mptr_0 = (void *)ldev->list.next;
              #line 487 
              ldev = ((struct i40e_device *)__mptr_0);
            }
  }
  #line 514 
  cif_mutex_unlock_i40e_device_mutex(& i40e_device_mutex);
  #line 515 
  return;
}

#line 522  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static void i40e_client_prepare(struct i40e_client *client)
{
  #line 528 
  void *__mptr;
  #line 524 
  struct i40e_device *ldev;
  #line 525 
  struct i40e_pf *pf;
  #line 527 
  cif_mutex_lock_i40e_device_mutex(& i40e_device_mutex);
  #line 528 
  __mptr = (void *)i40e_devices.next;
  #line 528 
  ldev = ((struct i40e_device *)__mptr);
  #line 528 
  while (& ldev->list != & i40e_devices) {
    #line 528 
    void *__mptr_0;
    #line 529 
    pf = ldev->pf;
    #line 530 
    i40e_client_add_instance(pf);
    #line 532 
    cif_set_bit_2(30L,(unsigned long *)(& pf->state));
    #line 533 
    i40e_service_event_schedule(pf);
    #line 528 
    __mptr_0 = (void *)ldev->list.next;
    #line 528 
    ldev = ((struct i40e_device *)__mptr_0);
  }
  #line 535 
  cif_mutex_unlock_i40e_device_mutex(& i40e_device_mutex);
  #line 536 
  return;
}

#line 548  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static int i40e_client_virtchnl_send(struct i40e_info *ldev, struct i40e_client *client, u32 vf_id, u8 *msg, u16 len)
{
  #line 554 
  i40e_status err;
  #line 552 
  struct i40e_pf *pf = (struct i40e_pf *)ldev->pf;
  #line 553 
  struct i40e_hw *hw = & pf->hw;
  #line 556 
  err = i40e_aq_send_msg_to_vf(hw,(unsigned short)((int)((unsigned short)vf_id)),20U,0U,msg,(unsigned short)((int)len),(struct i40e_asq_cmd_details *)0);
  #line 558 
  if (err != I40E_SUCCESS) 
                           #line 559 
                           _dev_err(& (pf->pdev)->dev,(char *)"Unable to send iWarp message to VF, error %d, aq status %d\n",(int)err,(unsigned int)hw->aq.asq_last_status);
  #line 562 
  return (int)err;
}

#line 573  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static int i40e_client_setup_qvlist(struct i40e_info *ldev, struct i40e_client *client, struct i40e_qvlist_info *qvlist_info)
{
  #line 579 
  struct i40e_qv_info *qv_info;
  #line 580 
  u32 v_idx;
  #line 580 
  u32 i;
  #line 580 
  u32 reg_idx;
  #line 580 
  u32 reg;
  #line 577 
  struct i40e_pf *pf = (struct i40e_pf *)ldev->pf;
  #line 578 
  struct i40e_hw *hw = & pf->hw;
  #line 582 
  ldev->qvlist_info = (struct i40e_qvlist_info *)kzalloc_4(__ab_c_size_0((unsigned long)(qvlist_info->num_vectors + 4294967295U),
                    12UL,16UL),
                  3264U);
  #line 584 
  if (ldev->qvlist_info == (struct i40e_qvlist_info *)0) 
                                                         #line 585 
                                                         return -12;
  #line 586 
  (ldev->qvlist_info)->num_vectors = qvlist_info->num_vectors;
  #line 588 
  i = 0U;
  #line 588 
  while (qvlist_info->num_vectors > i) {
    #line 589 
    qv_info = & qvlist_info->qv_info[i];
    #line 590 
    if (qv_info == (struct i40e_qv_info *)0) 
                                             #line 591 
                                             goto __Cont;
    #line 592 
    v_idx = qv_info->v_idx;
    #line 595 
    if ((unsigned int)(pf->iwarp_base_vector + (int)pf->num_iwarp_msix) <= v_idx || (unsigned int)pf->iwarp_base_vector > v_idx) 
      #line 597 
      goto err;
    #line 599 
    (ldev->qvlist_info)->qv_info[i] = *qv_info;
    #line 600 
    reg_idx = (v_idx + 54271U) * 4U;
    #line 602 
    if ((unsigned int)qv_info->ceq_idx == 65535U) 
                                                  #line 604 
                                                  writel(2047U,(void *)(hw->hw_addr + (unsigned long)reg_idx));
    else {
      #line 606 
      reg = ((unsigned int)qv_info->ceq_idx & 2047U) | 4096U;
      #line 610 
      writel(reg,(void *)(hw->hw_addr + (unsigned long)reg_idx));
      #line 612 
      reg = ((unsigned int)((int)qv_info->itr_idx << 11) | v_idx) | 1207894016U;
      #line 618 
      writel(reg,(void *)(hw->hw_addr + (unsigned long)(((int)qv_info->ceq_idx + 55808) * 4)));
    }
    #line 620 
    if ((unsigned int)qv_info->aeq_idx != 65535U) {
      #line 621 
      reg = ((unsigned int)((int)qv_info->itr_idx << 11) | v_idx) | 1073741824U;
      #line 626 
      writel(reg,(void *)(hw->hw_addr + 231168U));
    }
    #line 588 
    __Cont: 
            #line 588 
    i ++;
  }
  #line 630 
  readl((void *)(hw->hw_addr + 745772U));
  #line 631 
  return 0;
  #line 632 
  err: 
       #line 632 
  ;
  #line 633 
  kfree((void *)ldev->qvlist_info);
  #line 634 
  ldev->qvlist_info = (struct i40e_qvlist_info *)0;
  #line 635 
  return -22;
}

#line 644  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static void i40e_client_request_reset(struct i40e_info *ldev, struct i40e_client *client, u32 reset_level)
{
  #line 648 
  struct i40e_pf *pf = (struct i40e_pf *)ldev->pf;
  #line 650 
  switch (reset_level) {
    #line 651 
    case (u32)1: 
                 #line 651 
    ;
    #line 652 
    cif_set_bit_2(13L,(unsigned long *)(& pf->state));
    #line 653 
    break;
    #line 654 
    case (u32)2: 
                 #line 654 
    ;
    #line 655 
    cif_set_bit_2(13L,(unsigned long *)(& pf->state));
    #line 656 
    break;
    #line 657 
    default: 
             #line 657 
    ;
    #line 658 
    _dev_warn(& (pf->pdev)->dev,(char *)"Client for PF id %d requested an unsupported reset: %d.\n",(int)pf->hw.pf_id,reset_level);
    #line 661 
    break;
  }
  #line 664 
  i40e_service_event_schedule(pf);
  #line 665 
  return;
}

#line 678  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
static int i40e_client_update_vsi_ctxt(struct i40e_info *ldev, struct i40e_client *client, bool is_vf, u32 vf_id, u32 flag, u32 valid_flag)
{
  #line 685 
  struct i40e_vsi_context ctxt;
  #line 687 
  i40e_status err;
  #line 683 
  struct i40e_pf *pf = (struct i40e_pf *)ldev->pf;
  #line 684 
  struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)pf->lan_vsi);
  #line 686 
  bool update = (_Bool)1;
  #line 690 
  if ((int)is_vf != 0) 
                       #line 691 
                       return -22;
  #line 693 
  ctxt.seid = pf->main_vsi_seid;
  #line 694 
  ctxt.pf_num = pf->hw.pf_id;
  #line 695 
  err = i40e_aq_get_vsi_params(& pf->hw,& ctxt,(struct i40e_asq_cmd_details *)0);
  #line 696 
  ctxt.flags = (unsigned short)2U;
  #line 697 
  if (err != I40E_SUCCESS) {
    #line 698 
    ;
    #line 698 
    _dev_info(& (pf->pdev)->dev,(char *)"couldn\'t get PF vsi config, err %s aq_err %s\n",i40e_stat_str(& pf->hw,err),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    #line 703 
    return -2;
  }
  #line 706 
  if (((unsigned long)valid_flag & 2UL) != 0UL && ((unsigned long)flag & 2UL) != 0UL) {
    #line 708 
    ctxt.info.valid_sections = (unsigned short)128U;
    #line 710 
    ctxt.info.queueing_opt_flags = (unsigned char)((unsigned int)ctxt.info.queueing_opt_flags | 16U);
  }
  else 
    #line 711 
    if (((unsigned long)valid_flag & 2UL) != 0UL && ((unsigned long)flag & 2UL) == 0UL) {
      #line 713 
      ctxt.info.valid_sections = (unsigned short)128U;
      #line 715 
      ctxt.info.queueing_opt_flags = (unsigned char)((unsigned int)ctxt.info.queueing_opt_flags & 239U);
    }
    else {
      #line 717 
      update = (_Bool)0;
      #line 718 
      _dev_warn(& (pf->pdev)->dev,(char *)"Client for PF id %d request an unsupported Config: %x.\n",(int)pf->hw.pf_id,flag);
    }
  #line 723 
  if ((int)update != 0) {
    #line 724 
    err = i40e_aq_update_vsi_params(& (vsi->back)->hw,& ctxt,(struct i40e_asq_cmd_details *)0);
    #line 725 
    if (err != I40E_SUCCESS) {
      #line 726 
      ;
      #line 726 
      _dev_info(& (pf->pdev)->dev,(char *)"update VSI ctxt for PE failed, err %s aq_err %s\n",i40e_stat_str(& pf->hw,err),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    }
  }
  #line 733 
  return (int)err;
}

#line 742  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
int i40e_register_client(struct i40e_client *client)
{
  #line 744 
  int ret = 0;
  #line 746 
  if (client == (struct i40e_client *)0) {
    #line 747 
    ret = -5;
    #line 748 
    goto out;
  }
  #line 751 
  if (cif_strlen((char *)(& client->name)) == 0UL) {
    #line 752 
    printk((char *)"\001");
    #line 753 
    ret = -5;
    #line 754 
    goto out;
  }
  #line 757 
  if (registered_client != (struct i40e_client *)0) {
    #line 758 
    printk((char *)"\001",(char *)(& client->name));
    #line 760 
    ret = -17;
    #line 761 
    goto out;
  }
  #line 764 
  if ((unsigned int)client->version.major != 0U || (unsigned int)client->version.minor != 1U) {
    #line 766 
    printk((char *)"\001",(char *)(& client->name));
    #line 768 
    printk((char *)"\001",(int)client->version.major,(int)client->version.minor,(int)client->version.build,(char *)(& i40e_client_interface_version_str));
    #line 772 
    ret = -5;
    #line 773 
    goto out;
  }
  #line 776 
  registered_client = client;
  #line 778 
  i40e_client_prepare(client);
  #line 780 
  printk((char *)"\001",(char *)(& client->name));
  #line 781 
  out: 
       #line 781 
  ;
  #line 782 
  return ret;
}

#line 792  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_client.c"
int i40e_unregister_client(struct i40e_client *client)
{
  #line 794 
  int ret = 0;
  #line 796 
  if (registered_client != client) {
    #line 797 
    printk((char *)"\001",(char *)(& client->name));
    #line 799 
    ret = -19;
    #line 800 
    goto out;
  }
  #line 802 
  registered_client = (struct i40e_client *)0;
  #line 807 
  i40e_client_release(client);
  #line 809 
  printk((char *)"\001",(char *)(& client->name));
  #line 810 
  out: 
       #line 810 
  ;
  #line 811 
  return ret;
}

#line 120  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_client.i.aux"
static void cif_set_bit_2(long nr, unsigned long *addr)
{
  #line 123 
  ldv_set_bit(nr,addr);
  #line 124 
  return;
}

#line 127  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_client.i.aux"
static void cif_clear_bit_2(long nr, unsigned long *addr)
{
  #line 130 
  ldv_clear_bit(nr,addr);
  #line 131 
  return;
}

#line 134  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_client.i.aux"
static void INIT_LIST_HEAD_0(struct list_head *list)
{
  #line 137 
  ldv_init_list_head(list);
  #line 138 
  return;
}

#line 148  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_client.i.aux"
static size_t cif_strlen(char *s)
{
  #line 151 
  return ldv_strlen(s);
}

#line 428  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_client.i.aux"
static void *kzalloc_4(size_t size, gfp_t flags)
{
  #line 431 
  return ldv_kzalloc(size,flags);
}

#line 831  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_client.i.aux"
static void cif_mutex_lock_i40e_device_mutex(struct mutex *lock)
{
  #line 834 
  ldv_mutex_model_lock(lock,(char *)"i40e_device_mutex");
  #line 835 
  return;
}

#line 838  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_client.i.aux"
static void cif_mutex_unlock_i40e_device_mutex(struct mutex *lock)
{
  #line 841 
  ldv_mutex_model_unlock(lock,(char *)"i40e_device_mutex");
  #line 842 
  return;
}

#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 120  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_xsk.i.aux"
static void cif_set_bit_3(long nr, unsigned long *addr);
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 127  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_xsk.i.aux"
static void cif_clear_bit_3(long nr, unsigned long *addr);
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/cmpxchg.h"
#line 15 
void __cmpxchg_wrong_size(void);
#line 545  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool napi_if_scheduled_mark_missed(struct napi_struct *n)
{
  #line 547 
  unsigned long val;
  #line 547 
  unsigned long new;
  #line 549 
  while (1) {
    #line 558 
    unsigned long __ret;
    {
      #line 551 
      union __anonunion___u_16851 __u;
      #line 550 
      __read_once_size((void *)(& n->state),(void *)(& __u.__c),8);
      #line 550 
      val = (__u.__val);
      #line 551 
      if ((val & 4UL) != 0UL) 
                              #line 552 
                              return (_Bool)1;
      #line 554 
      if ((val & 1UL) == 0UL) 
                              #line 555 
                              return (_Bool)0;
      #line 557 
      new = val | 2UL;
    }
    {
      #line 558 
      unsigned long *__ai_ptr = & n->state;
      #line 558 
      kasan_check_read((void *)__ai_ptr,8U);
      {
        #line 558 
        unsigned long __old = val;
        #line 558 
        unsigned long __new = new;
        #line 558 
        switch (8UL) {
          #line 558 
          case (unsigned long)1: 
                                 #line 558 
          ;
          {
            #line 558 
            u8 *__ptr = (u8 *)__ai_ptr;
            #line 559 
            ldv_inline_asm();
            #line 558 
            break;
          }
          #line 558 
          case (unsigned long)2: 
                                 #line 558 
          ;
          {
            #line 558 
            u16 *__ptr_0 = (u16 *)__ai_ptr;
            #line 559 
            ldv_inline_asm();
            #line 558 
            break;
          }
          #line 558 
          case (unsigned long)4: 
                                 #line 558 
          ;
          {
            #line 558 
            u32 *__ptr_1 = (u32 *)__ai_ptr;
            #line 559 
            ldv_inline_asm();
            #line 558 
            break;
          }
          #line 558 
          case (unsigned long)8: 
                                 #line 558 
          ;
          {
            #line 558 
            u64 *__ptr_2 = (u64 *)__ai_ptr;
            #line 559 
            ldv_inline_asm();
            #line 558 
            break;
          }
          #line 558 
          default: 
                   #line 558 
          ;
          #line 558 
          __cmpxchg_wrong_size();
        }
        }
      }
    #line 558 
    ;
    #line 558 
    if (! (__ret != val)) 
                          #line 549 
                          break;
  }
  #line 560 
  return (_Bool)1;
}

#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/trace/events/xdp.h"
__inline static void trace_xdp_exception_0(struct net_device *dev, struct bpf_prog *xdp, u32 act)
{
  #line 28 
  int pscr_ret___0;
  #line 28 
  if ((int)static_key_false(& __tracepoint_xdp_exception.key) != 0) {
    #line 28 
    int pscr_ret__;
    #line 28 
    struct tracepoint_func *________p1;
    #line 28 
    struct tracepoint_func *it_func_ptr;
    #line 28 
    void *it_func;
    #line 28 
    void *__data;
    #line 28 
    int __idx = 0;
    {
      #line 28 
      void *__vpp_verify = (void *)0;
      #line 28 
      void *tmp = __vpp_verify;
    }
    #line 28 
    switch (4UL) {
      #line 28 
      int pfo_ret___1;
      #line 28 
      int pfo_ret___2;
      #line 28 
      int pfo_ret__;
      #line 28 
      int pfo_ret___0;
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret__;
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret___0;
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret___1;
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 28 
      switch (4UL) {
        #line 28 
        case (unsigned long)1: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)2: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)4: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        case (unsigned long)8: 
                               #line 28 
        ;
        #line 29 
        ldv_inline_asm();
        #line 28 
        break;
        #line 28 
        default: 
                 #line 28 
        ;
        #line 28 
        __bad_percpu_size();
      }
      #line 28 
      pscr_ret__ = pfo_ret___2;
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_size_call_parameter();
      #line 28 
      break;
    }
    #line 28 
    if (cpumask_test_cpu(pscr_ret__,& __cpu_online_mask) == 0) 
                                                               #line 28 
                                                               return;
    {
      #line 28 
      int __ret_warn_on = 0;
      #line 28 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 29 
        ldv_inline_asm();
        #line 30 
        ldv_inline_asm();
      }
      #line 28 
      long tmp_5 = (long)(__ret_warn_on != 0);
    }
    #line 28 
    __preempt_count_add(1);
    #line 29 
    ldv_inline_asm();
    {
      #line 29 
      union __anonunion___u_16973 __u;
      #line 28 
      __read_once_size((void *)(& __tracepoint_xdp_exception.funcs),(void *)(& __u.__c),8);
      #line 28 
      ________p1 = (__u.__val);
      }
    #line 28 
    it_func_ptr = ________p1;
    #line 28 
    if (it_func_ptr != (struct tracepoint_func *)0) 
      #line 28 
      while (1) {
        #line 28 
        it_func = it_func_ptr->func;
        #line 28 
        __data = it_func_ptr->data;
        #line 28 
        (*((void (*)(void *, struct net_device *, struct bpf_prog *, u32 ))it_func))(__data,dev,xdp,act);
        #line 28 
        it_func_ptr ++;
        #line 29 
        ;
        #line 29 
        if (! (it_func_ptr->func != (void *)0)) 
                                                #line 28 
                                                break;
      }
    #line 30 
    ldv_inline_asm();
    #line 28 
    __preempt_count_sub(1);
  }
  {
    #line 28 
    void *__vpp_verify_0 = (void *)0;
    #line 28 
    void *tmp_13 = __vpp_verify_0;
  }
  #line 28 
  switch (4UL) {
    #line 28 
    int pfo_ret___3;
    #line 28 
    int pfo_ret___4;
    #line 28 
    int pfo_ret___5;
    #line 28 
    int pfo_ret___6;
    #line 28 
    case (unsigned long)1: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___3;
    #line 28 
    break;
    #line 28 
    case (unsigned long)2: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___4;
    #line 28 
    break;
    #line 28 
    case (unsigned long)4: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___5;
    #line 28 
    break;
    #line 28 
    case (unsigned long)8: 
                           #line 28 
    ;
    #line 28 
    switch (4UL) {
      #line 28 
      case (unsigned long)1: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)2: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)4: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      case (unsigned long)8: 
                             #line 28 
      ;
      #line 29 
      ldv_inline_asm();
      #line 28 
      break;
      #line 28 
      default: 
               #line 28 
      ;
      #line 28 
      __bad_percpu_size();
    }
    #line 28 
    pscr_ret___0 = pfo_ret___6;
    #line 28 
    break;
    #line 28 
    default: 
             #line 28 
    ;
    #line 28 
    __bad_size_call_parameter();
    #line 28 
    break;
  }
  #line 28 
  if (cpumask_test_cpu(pscr_ret___0,& __cpu_online_mask) != 0) {
    #line 28 
    __rcu_read_lock();
    {
      #line 29 
      union __anonunion___u_16975 __u_0;
      #line 28 
      __read_once_size((void *)(& __tracepoint_xdp_exception.funcs),(void *)(& __u_0.__c),8);
      #line 28 
      struct tracepoint_func *________p1_0 = (__u_0.__val);
      {
        #line 28 
        bool __warned;
        #line 28 
        if (debug_lockdep_rcu_enabled() != 0) 
          #line 28 
          if (! __warned) {
            #line 28 
            if (rcu_read_lock_sched_held() == 0) {
              #line 28 
              __warned = (_Bool)1;
              #line 28 
              lockdep_rcu_suspicious((char *)"./include/trace/events/xdp.h",28,(char *)"suspicious rcu_dereference_check() usage");
            }
          }
      }
      #line 28 
      struct tracepoint_func *tmp_11 = ________p1_0;
    }
    #line 28 
    __rcu_read_unlock();
  }
  #line 30 
  return;
}

#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
#line 122 
u64 *xsk_umem_peek_addr(struct xdp_umem *, u64 *);
#line 123 
#line 123 
void xsk_umem_discard_addr(struct xdp_umem *);
#line 124 
#line 124 
void xsk_umem_complete_tx(struct xdp_umem *, u32);
#line 125 
#line 125 
bool xsk_umem_consume_tx(struct xdp_umem *, struct xdp_desc *);
#line 126 
#line 126 
void xsk_umem_consume_tx_done(struct xdp_umem *);
#line 127 
#line 127 
struct xdp_umem_fq_reuse *xsk_reuseq_prepare(u32);
#line 128 
#line 128 
struct xdp_umem_fq_reuse *xsk_reuseq_swap(struct xdp_umem *, struct xdp_umem_fq_reuse *);
#line 130 
#line 130 
void xsk_reuseq_free(struct xdp_umem_fq_reuse *);
#line 132 
#line 132 
void xsk_set_rx_need_wakeup(struct xdp_umem *);
#line 133 
#line 133 
void xsk_set_tx_need_wakeup(struct xdp_umem *);
#line 134 
#line 134 
void xsk_clear_rx_need_wakeup(struct xdp_umem *);
#line 136 
#line 136 
bool xsk_umem_uses_need_wakeup(struct xdp_umem *);
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static u64 xsk_umem_extract_addr(u64 addr)
{
  #line 161 
  return addr & 281474976710655ULL;
}

#line 164  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static u64 xsk_umem_extract_offset(u64 addr)
{
  #line 166 
  return addr >> 48;
}

#line 169  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static u64 xsk_umem_add_offset_to_addr(u64 addr)
{
  #line 171 
  return xsk_umem_extract_addr(addr) + xsk_umem_extract_offset(addr);
}

#line 174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static char *xdp_umem_get_data(struct xdp_umem *umem, u64 addr)
{
  #line 176 
  unsigned long page_addr;
  #line 178 
  addr = xsk_umem_add_offset_to_addr(addr);
  #line 179 
  page_addr = (unsigned long)(umem->pages + (addr >> 12))->addr;
  #line 181 
  return (char *)(((unsigned long)addr & (unsigned long)4095U) | (page_addr & 18446744073709547520U));
}

#line 184  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static dma_addr_t xdp_umem_get_dma(struct xdp_umem *umem, u64 addr)
{
  #line 186 
  addr = xsk_umem_add_offset_to_addr(addr);
  #line 188 
  return (umem->pages + (addr >> 12))->dma + (addr & 4095ULL);
}

#line 202  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static u64 *xsk_umem_peek_addr_rq(struct xdp_umem *umem, u64 *addr)
{
  #line 204 
  struct xdp_umem_fq_reuse *rq = umem->fq_reuse;
  #line 206 
  if (rq->length == 0U) {
    #line 207 
    return xsk_umem_peek_addr(umem,addr);
  }
  #line 209 
  *addr = rq->handles[rq->length + 4294967295U];
  #line 210 
  return addr;
}

#line 213  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static void xsk_umem_discard_addr_rq(struct xdp_umem *umem)
{
  #line 215 
  struct xdp_umem_fq_reuse *rq = umem->fq_reuse;
  #line 217 
  if (rq->length == 0U) 
                        #line 218 
                        xsk_umem_discard_addr(umem); else 
                                                          #line 220 
                                                          (rq->length) --;
  #line 221 
  return;
}

#line 223  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static void xsk_umem_fq_reuse(struct xdp_umem *umem, u64 addr)
{
  #line 227 
  u32 tmp;
  #line 225 
  struct xdp_umem_fq_reuse *rq = umem->fq_reuse;
  #line 227 
  tmp = rq->length;
  #line 227 
  (rq->length) ++;
  #line 227 
  rq->handles[tmp] = addr;
  #line 228 
  return;
}

#line 234  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp_sock.h"
__inline static u64 xsk_umem_adjust_offset(struct xdp_umem *umem, u64 address, u64 offset)
{
  #line 237 
  if (((int)umem->flags & 1) != 0) 
                                   #line 238 
                                   return (offset << 48) + address; else 
                                                                    #line 240 
                                                                    return address + offset;
}

#line 1153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static bool i40e_enabled_xdp_vsi_1(struct i40e_vsi *vsi)
{
  #line 1156 
  union __anonunion___u_17342 __u;
  #line 1155 
  __read_once_size((void *)(& vsi->xdp_prog),(void *)(& __u.__c),8);
  #line 1155 
  return (_Bool)((__u.__val) != (struct bpf_prog *)0);
}

#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_txrx_common.h"
#line 873  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
bool i40e_xsk_any_rx_ring_enabled(struct i40e_vsi *vsi);
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
static int i40e_xsk_umem_dma_map(struct i40e_vsi *vsi, struct xdp_umem *umem)
{
  #line 22 
  struct device *dev;
  #line 23 
  unsigned int i;
  #line 23 
  unsigned int j;
  #line 24 
  dma_addr_t dma;
  #line 21 
  struct i40e_pf *pf = vsi->back;
  #line 26 
  dev = & (pf->pdev)->dev;
  #line 27 
  i = 0U;
  #line 27 
  while (umem->npgs > i) {
    {
      #line 28 
      dma = dma_map_page_attrs(dev,*(umem->pgs + (unsigned long)i),0UL,4096UL,(enum dma_data_direction)DMA_BIDIRECTIONAL,34UL);
      #line 30 
      if (dma_mapping_error(dev,dma) != 0) 
                                           #line 31 
                                           goto out_unmap;
      #line 33 
      (umem->pages + (unsigned long)i)->dma = dma;
    }
    #line 27 
    i ++;
  }
  #line 36 
  return 0;
  #line 38 
  out_unmap: 
             #line 38 
  ;
  #line 39 
  j = 0U;
  #line 39 
  while (j < i) {
    #line 40 
    dma_unmap_page_attrs(dev,(umem->pages + (unsigned long)i)->dma,4096UL,(enum dma_data_direction)DMA_BIDIRECTIONAL,34UL);
    #line 42 
    (umem->pages + (unsigned long)i)->dma = 0ULL;
    #line 39 
    j ++;
  }
  #line 45 
  return -1;
}

#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
static void i40e_xsk_umem_dma_unmap(struct i40e_vsi *vsi, struct xdp_umem *umem)
{
  #line 56 
  struct device *dev;
  #line 57 
  unsigned int i;
  #line 55 
  struct i40e_pf *pf = vsi->back;
  #line 59 
  dev = & (pf->pdev)->dev;
  #line 61 
  i = 0U;
  #line 61 
  while (umem->npgs > i) {
    #line 62 
    dma_unmap_page_attrs(dev,(umem->pages + (unsigned long)i)->dma,4096UL,(enum dma_data_direction)DMA_BIDIRECTIONAL,34UL);
    #line 65 
    (umem->pages + (unsigned long)i)->dma = 0ULL;
    #line 61 
    i ++;
  }
  #line 67 
  return;
}

#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
static int i40e_xsk_umem_enable(struct i40e_vsi *vsi, struct xdp_umem *umem, u16 qid)
{
  #line 81 
  struct xdp_umem_fq_reuse *reuseq;
  #line 82 
  bool if_running;
  #line 83 
  int err;
  #line 107 
  int tmp_2;
  #line 80 
  struct net_device *netdev = vsi->netdev;
  #line 85 
  if (vsi->type != (unsigned int)I40E_VSI_MAIN) 
                                                #line 86 
                                                return -22;
  #line 88 
  if ((int)vsi->num_queue_pairs <= (int)qid) 
                                             #line 89 
                                             return -22;
  #line 91 
  if ((unsigned int)qid >= netdev->real_num_rx_queues || (unsigned int)qid >= netdev->real_num_tx_queues) 
    #line 93 
    return -22;
  #line 95 
  reuseq = xsk_reuseq_prepare((unsigned int)(*(vsi->rx_rings))->count);
  #line 96 
  if (reuseq == (struct xdp_umem_fq_reuse *)0) 
                                               #line 97 
                                               return -12;
  #line 99 
  xsk_reuseq_free(xsk_reuseq_swap(umem,reuseq));
  #line 101 
  err = i40e_xsk_umem_dma_map(vsi,umem);
  #line 102 
  if (err != 0) 
                #line 103 
                return err;
  #line 105 
  cif_set_bit_3((long)qid,vsi->af_xdp_zc_qps);
  #line 107 
  if ((int)netif_running(vsi->netdev) != 0) {
    #line 107 
    if ((int)i40e_enabled_xdp_vsi_1(vsi) != 0) 
                                               #line 107 
                                               tmp_2 = 1; else 
                                                               #line 107 
                                                               tmp_2 = 0;
  }
  else 
       #line 107 
       tmp_2 = 0;
  #line 107 
  if_running = (_Bool)(tmp_2 != 0);
  #line 109 
  if ((int)if_running != 0) {
    #line 110 
    err = i40e_queue_pair_disable(vsi,(int)qid);
    #line 111 
    if (err != 0) 
                  #line 112 
                  return err;
    #line 114 
    err = i40e_queue_pair_enable(vsi,(int)qid);
    #line 115 
    if (err != 0) 
                  #line 116 
                  return err;
    #line 119 
    err = i40e_xsk_wakeup(vsi->netdev,(unsigned int)qid,1U);
    #line 120 
    if (err != 0) 
                  #line 121 
                  return err;
  }
  #line 124 
  return 0;
}

#line 134  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
static int i40e_xsk_umem_disable(struct i40e_vsi *vsi, u16 qid)
{
  #line 137 
  struct xdp_umem *umem;
  #line 138 
  bool if_running;
  #line 139 
  int err;
  #line 145 
  int tmp_1;
  #line 136 
  struct net_device *netdev = vsi->netdev;
  #line 141 
  umem = xdp_get_umem_from_qid(netdev,(unsigned short)((int)qid));
  #line 142 
  if (umem == (struct xdp_umem *)0) 
                                    #line 143 
                                    return -22;
  #line 145 
  if ((int)netif_running(vsi->netdev) != 0) {
    #line 145 
    if ((int)i40e_enabled_xdp_vsi_1(vsi) != 0) 
                                               #line 145 
                                               tmp_1 = 1; else 
                                                               #line 145 
                                                               tmp_1 = 0;
  }
  else 
       #line 145 
       tmp_1 = 0;
  #line 145 
  if_running = (_Bool)(tmp_1 != 0);
  #line 147 
  if ((int)if_running != 0) {
    #line 148 
    err = i40e_queue_pair_disable(vsi,(int)qid);
    #line 149 
    if (err != 0) 
                  #line 150 
                  return err;
  }
  #line 153 
  cif_clear_bit_3((long)qid,vsi->af_xdp_zc_qps);
  #line 154 
  i40e_xsk_umem_dma_unmap(vsi,umem);
  #line 156 
  if ((int)if_running != 0) {
    #line 157 
    err = i40e_queue_pair_enable(vsi,(int)qid);
    #line 158 
    if (err != 0) 
                  #line 159 
                  return err;
  }
  #line 162 
  return 0;
}

#line 175  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
int i40e_xsk_umem_setup(struct i40e_vsi *vsi, struct xdp_umem *umem, u16 qid)
{
  #line 178 
  int tmp_1;
  #line 178 
  if (umem != (struct xdp_umem *)0) 
                                    #line 178 
                                    tmp_1 = i40e_xsk_umem_enable(vsi,umem,(unsigned short)((int)qid)); else 
                                                                    #line 178 
                                                                    tmp_1 = i40e_xsk_umem_disable(vsi,(unsigned short)((int)qid));
  #line 178 
  return tmp_1;
}

#line 191  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
static int i40e_run_xdp_zc(struct i40e_ring *rx_ring, struct xdp_buff *xdp)
{
  #line 205 
  union __anonunion___u_17344 __u;
  #line 194 
  int err;
  #line 195 
  struct i40e_ring *xdp_ring;
  #line 196 
  struct bpf_prog *xdp_prog;
  #line 197 
  u64 offset;
  #line 198 
  u32 act;
  #line 193 
  struct xdp_umem *umem = rx_ring->xsk_umem;
  #line 194 
  int result = 0;
  #line 200 
  rcu_read_lock();
  #line 204 
  __read_once_size((void *)(& rx_ring->xdp_prog),(void *)(& __u.__c),8);
  #line 204 
  xdp_prog = (__u.__val);
  #line 205 
  act = bpf_prog_run_xdp(xdp_prog,xdp);
  #line 206 
  offset = (unsigned long long)(xdp->data - xdp->data_hard_start);
  #line 208 
  xdp->handle = (unsigned long)xsk_umem_adjust_offset(umem,(unsigned long long)xdp->handle,offset);
  #line 210 
  switch (act) {
    #line 211 
    case (u32)2: 
                 #line 211 
    ;
    #line 212 
    break;
    #line 213 
    case (u32)3: 
                 #line 213 
    ;
    #line 214 
    xdp_ring = *((rx_ring->vsi)->xdp_rings + (unsigned long)rx_ring->queue_index);
    #line 215 
    result = i40e_xmit_xdp_tx_ring(xdp,xdp_ring);
    #line 216 
    break;
    #line 217 
    case (u32)4: 
                 #line 217 
    ;
    #line 218 
    err = xdp_do_redirect(rx_ring->netdev,xdp,xdp_prog);
    #line 219 
    if (err == 0) 
                  #line 219 
                  result = 4; else 
                                   #line 219 
                                   result = 1;
    #line 220 
    break;
    #line 221 
    default: 
             #line 221 
    ;
    #line 222 
    bpf_warn_invalid_xdp_action(act);
    #line 224 
    case (u32)0: 
                 #line 224 
    ;
    #line 225 
    trace_xdp_exception_0(rx_ring->netdev,xdp_prog,act);
    #line 227 
    case (u32)1: 
                 #line 227 
    ;
    #line 228 
    result = 1;
    #line 229 
    break;
  }
  #line 231 
  rcu_read_unlock();
  #line 232 
  return result;
}

#line 245  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
static bool i40e_alloc_buffer_zc(struct i40e_ring *rx_ring, struct i40e_rx_buffer *bi)
{
  #line 250 
  u64 handle;
  #line 250 
  u64 hr;
  #line 248 
  struct xdp_umem *umem = rx_ring->xsk_umem;
  #line 249 
  void *addr = bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.addr;
  #line 252 
  if (addr != (void *)0) {
    #line 253 
    (rx_ring->__anonCompField_i40e_ring_222.rx_stats.page_reuse_count) ++;
    #line 254 
    return (_Bool)1;
  }
  #line 257 
  if (xsk_umem_peek_addr(umem,& handle) == (u64 *)0ULL) {
    #line 258 
    (rx_ring->__anonCompField_i40e_ring_222.rx_stats.alloc_page_failed) ++;
    #line 259 
    return (_Bool)0;
  }
  #line 262 
  hr = (unsigned long long)(umem->headroom + 256U);
  #line 264 
  bi->dma = xdp_umem_get_dma(umem,handle);
  #line 265 
  bi->dma += hr;
  #line 267 
  bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.addr = (void *)xdp_umem_get_data(umem,handle);
  #line 268 
  bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.addr += hr;
  #line 270 
  bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.handle = xsk_umem_adjust_offset(umem,handle,(unsigned long long)umem->headroom);
  #line 272 
  xsk_umem_discard_addr(umem);
  #line 273 
  return (_Bool)1;
}

#line 286  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
static bool i40e_alloc_buffer_slow_zc(struct i40e_ring *rx_ring, struct i40e_rx_buffer *bi)
{
  #line 290 
  u64 handle;
  #line 290 
  u64 hr;
  #line 289 
  struct xdp_umem *umem = rx_ring->xsk_umem;
  #line 292 
  if (xsk_umem_peek_addr_rq(umem,& handle) == (u64 *)0ULL) {
    #line 293 
    (rx_ring->__anonCompField_i40e_ring_222.rx_stats.alloc_page_failed) ++;
    #line 294 
    return (_Bool)0;
  }
  #line 297 
  handle = (rx_ring->xsk_umem)->chunk_mask & handle;
  #line 299 
  hr = (unsigned long long)(umem->headroom + 256U);
  #line 301 
  bi->dma = xdp_umem_get_dma(umem,handle);
  #line 302 
  bi->dma += hr;
  #line 304 
  bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.addr = (void *)xdp_umem_get_data(umem,handle);
  #line 305 
  bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.addr += hr;
  #line 307 
  bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.handle = xsk_umem_adjust_offset(umem,handle,(unsigned long long)umem->headroom);
  #line 309 
  xsk_umem_discard_addr_rq(umem);
  #line 310 
  return (_Bool)1;
}

#line 314  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
__inline static bool __i40e_alloc_rx_buffers_zc(struct i40e_ring *rx_ring, u16 count, bool (*alloc)(struct i40e_ring *, struct i40e_rx_buffer *))
{
  #line 319 
  union i40e_32byte_rx_desc *rx_desc;
  #line 320 
  struct i40e_rx_buffer *bi;
  #line 318 
  u16 ntu = rx_ring->next_to_use;
  #line 321 
  bool ok = (_Bool)1;
  #line 323 
  rx_desc = (union i40e_32byte_rx_desc *)rx_ring->desc + (unsigned long)ntu;
  #line 324 
  bi = rx_ring->__anonCompField_i40e_ring_221.rx_bi + (unsigned long)ntu;
  #line 325 
  while (1) {
    {
      #line 326 
      if (! (*alloc)(rx_ring,bi)) {
        #line 327 
        ok = (_Bool)0;
        #line 328 
        goto no_buffers;
      }
      #line 331 
      dma_sync_single_range_for_device(rx_ring->dev,bi->dma,0UL,(unsigned long)rx_ring->rx_buf_len,(enum dma_data_direction)DMA_BIDIRECTIONAL);
      #line 335 
      rx_desc->read.pkt_addr = bi->dma;
      #line 337 
      rx_desc ++;
      #line 338 
      bi ++;
      #line 339 
      ntu = (u16)((int)ntu + 1);
      #line 341 
      if ((long)((int)rx_ring->count == (int)ntu) != 0L) {
        #line 342 
        rx_desc = (union i40e_32byte_rx_desc *)rx_ring->desc;
        #line 343 
        bi = rx_ring->__anonCompField_i40e_ring_221.rx_bi;
        #line 344 
        ntu = (unsigned short)0U;
      }
      #line 347 
      rx_desc->wb.qword1.status_error_len = 0ULL;
      #line 348 
      count = (u16)((int)count - 1);
    }
    #line 349 
    if (! ((unsigned int)count != 0U)) 
                                       #line 325 
                                       break;
  }
  #line 351 
  no_buffers: 
              #line 351 
  ;
  #line 352 
  if ((int)rx_ring->next_to_use != (int)ntu) 
                                             #line 353 
                                             i40e_release_rx_desc(rx_ring,(unsigned int)ntu);
  #line 355 
  return ok;
}

#line 368  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
bool i40e_alloc_rx_buffers_zc(struct i40e_ring *rx_ring, u16 count)
{
  #line 370 
  return __i40e_alloc_rx_buffers_zc(rx_ring,(unsigned short)((int)count),
                                 & i40e_alloc_buffer_slow_zc);
}

#line 384  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
static bool i40e_alloc_rx_buffers_fast_zc(struct i40e_ring *rx_ring, u16 count)
{
  #line 386 
  return __i40e_alloc_rx_buffers_zc(rx_ring,(unsigned short)((int)count),
                                 & i40e_alloc_buffer_zc);
}

#line 400  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
static struct i40e_rx_buffer *i40e_get_rx_buffer_zc(struct i40e_ring *rx_ring, unsigned int size)
{
  #line 403 
  struct i40e_rx_buffer *bi;
  #line 405 
  bi = rx_ring->__anonCompField_i40e_ring_221.rx_bi + (unsigned long)rx_ring->next_to_clean;
  #line 408 
  dma_sync_single_range_for_cpu(rx_ring->dev,bi->dma,0UL,(unsigned long)size,(enum dma_data_direction)DMA_BIDIRECTIONAL);
  #line 413 
  return bi;
}

#line 424  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
static void i40e_reuse_rx_buffer_zc(struct i40e_ring *rx_ring, struct i40e_rx_buffer *old_bi)
{
  #line 427 
  struct i40e_rx_buffer *new_bi = rx_ring->__anonCompField_i40e_ring_221.rx_bi + (unsigned long)rx_ring->next_to_alloc;
  #line 428 
  u16 nta = rx_ring->next_to_alloc;
  #line 431 
  nta = (u16)((int)nta + 1);
  #line 432 
  if ((int)rx_ring->count > (int)nta) 
                                      #line 432 
                                      rx_ring->next_to_alloc = nta; else 
                                                                    #line 432 
                                                                    rx_ring->next_to_alloc = (unsigned short)0U;
  #line 435 
  new_bi->dma = old_bi->dma;
  #line 436 
  new_bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.addr = old_bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.addr;
  #line 437 
  new_bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.handle = old_bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.handle;
  #line 439 
  old_bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.addr = (void *)0;
  #line 440 
  return;
}

#line 447  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
void i40e_zca_free(struct zero_copy_allocator *alloc, unsigned long handle)
{
  #line 454 
  void *__mptr;
  #line 449 
  struct i40e_rx_buffer *bi;
  #line 450 
  struct i40e_ring *rx_ring;
  #line 451 
  u64 hr;
  #line 451 
  u64 mask;
  #line 452 
  u16 nta;
  #line 454 
  __mptr = (void *)alloc;
  #line 454 
  rx_ring = ((struct i40e_ring *)(__mptr + 18446744073709551288U));
  #line 455 
  hr = (unsigned long long)((rx_ring->xsk_umem)->headroom + 256U);
  #line 456 
  mask = (rx_ring->xsk_umem)->chunk_mask;
  #line 458 
  nta = rx_ring->next_to_alloc;
  #line 459 
  bi = rx_ring->__anonCompField_i40e_ring_221.rx_bi + (unsigned long)nta;
  #line 461 
  nta = (u16)((int)nta + 1);
  #line 462 
  if ((int)rx_ring->count > (int)nta) 
                                      #line 462 
                                      rx_ring->next_to_alloc = nta; else 
                                                                    #line 462 
                                                                    rx_ring->next_to_alloc = (unsigned short)0U;
  #line 464 
  handle = (unsigned long)((unsigned long long)handle & mask);
  #line 466 
  bi->dma = xdp_umem_get_dma(rx_ring->xsk_umem,(unsigned long long)handle);
  #line 467 
  bi->dma += hr;
  #line 469 
  bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.addr = (void *)xdp_umem_get_data(rx_ring->xsk_umem,(unsigned long long)handle);
  #line 470 
  bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.addr += hr;
  #line 472 
  bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.handle = xsk_umem_adjust_offset(rx_ring->xsk_umem,(unsigned long long)handle,(unsigned long long)(rx_ring->xsk_umem)->headroom);
  #line 474 
  return;
}

#line 486  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
static struct sk_buff *i40e_construct_skb_zc(struct i40e_ring *rx_ring, struct i40e_rx_buffer *bi, struct xdp_buff *xdp)
{
  #line 492 
  struct sk_buff *skb;
  #line 490 
  unsigned int metasize = (unsigned int)(xdp->data - xdp->data_meta);
  #line 491 
  unsigned int datasize = (unsigned int)(xdp->data_end - xdp->data);
  #line 495 
  skb = __napi_alloc_skb(& (rx_ring->q_vector)->napi,(unsigned int)(xdp->data_end - xdp->data_hard_start),10784U);
  #line 498 
  if ((long)(skb == (struct sk_buff *)0) != 0L) 
                                                #line 499 
                                                return (struct sk_buff *)0;
  #line 501 
  skb_reserve(skb,(int)(xdp->data - xdp->data_hard_start));
  #line 502 
  ;
  #line 502 
  ;
  #line 502 
  memcpy(__skb_put(skb,datasize),xdp->data,(unsigned long)datasize);
  #line 503 
  if (metasize != 0U) 
                      #line 504 
                      skb_metadata_set(skb,(unsigned char)((int)((unsigned char)metasize)));
  #line 506 
  i40e_reuse_rx_buffer_zc(rx_ring,bi);
  #line 507 
  return skb;
}

#line 514  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
static void i40e_inc_ntc(struct i40e_ring *rx_ring)
{
  #line 516 
  u32 ntc = (unsigned int)((int)rx_ring->next_to_clean + 1);
  #line 518 
  if ((unsigned int)rx_ring->count > ntc) 
                                          #line 518 
                                          ntc = ntc; else 
                                                          #line 518 
                                                          ntc = 0U;
  #line 519 
  rx_ring->next_to_clean = (unsigned short)ntc;
  #line 520 
  __builtin_prefetch((void const *)((void *)((union i40e_32byte_rx_desc *)rx_ring->desc + (unsigned long)ntc)));
  #line 521 
  return;
}

#line 530  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
int i40e_clean_rx_irq_zc(struct i40e_ring *rx_ring, int budget)
{
  #line 533 
  unsigned int tmp;
  #line 534 
  unsigned int xdp_res;
  #line 536 
  struct sk_buff *skb;
  #line 537 
  struct xdp_buff xdp;
  #line 637 
  int tmp_5;
  #line 532 
  unsigned int total_rx_bytes = 0U;
  #line 532 
  unsigned int total_rx_packets = 0U;
  #line 533 
  if ((int)rx_ring->next_to_clean <= (int)rx_ring->next_to_use) 
                                                                #line 533 
                                                                tmp = (unsigned int)rx_ring->count; else 
                                                                    #line 533 
                                                                    tmp = 0U;
  #line 533 
  u16 cleaned_count = (unsigned short)(((tmp + (unsigned int)rx_ring->next_to_clean) - (unsigned int)rx_ring->next_to_use) + 65535U);
  #line 534 
  unsigned int xdp_xmit = 0U;
  #line 535 
  bool failure = (_Bool)0;
  #line 539 
  xdp.rxq = & rx_ring->xdp_rxq;
  #line 541 
  while ((long)(total_rx_packets < (unsigned int)budget) != 0L) {
    #line 542 
    struct i40e_rx_buffer *bi;
    #line 543 
    union i40e_32byte_rx_desc *rx_desc;
    #line 544 
    unsigned int size;
    #line 545 
    u64 qword;
    #line 547 
    if ((unsigned int)cleaned_count > 31U) {
      #line 548 
      int tmp_1;
      #line 548 
      if ((int)failure != 0) 
                             #line 548 
                             tmp_1 = 1;
      else {
        #line 549 
        if (i40e_alloc_rx_buffers_fast_zc(rx_ring,
                                      (unsigned short)((int)cleaned_count))) 
          #line 548 
          tmp_1 = 0; else 
                          #line 548 
                          tmp_1 = 1;
      }
      #line 548 
      failure = (_Bool)(tmp_1 != 0);
      #line 551 
      cleaned_count = (unsigned short)0U;
    }
    #line 554 
    rx_desc = (union i40e_32byte_rx_desc *)rx_ring->desc + (unsigned long)rx_ring->next_to_clean;
    #line 555 
    qword = rx_desc->wb.qword1.status_error_len;
    #line 556 
    ldv_inline_asm();
    #line 563 
    bi = i40e_clean_programming_status(rx_ring,rx_desc,qword);
    #line 565 
    if ((long)(bi != (struct i40e_rx_buffer *)0) != 0L) {
      #line 566 
      i40e_reuse_rx_buffer_zc(rx_ring,bi);
      #line 567 
      cleaned_count = (u16)((int)cleaned_count + 1);
      #line 568 
      continue;
    }
    #line 571 
    size = (unsigned int)(qword >> 38) & 16383U;
    #line 573 
    if (size == 0U) 
                    #line 574 
                    break;
    #line 576 
    bi = i40e_get_rx_buffer_zc(rx_ring,size);
    #line 577 
    xdp.data = bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.addr;
    #line 578 
    xdp.data_meta = xdp.data;
    #line 579 
    xdp.data_hard_start = xdp.data + 18446744073709551360U;
    #line 580 
    xdp.data_end = xdp.data + (unsigned long)size;
    #line 581 
    xdp.handle = (unsigned long)bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.handle;
    #line 583 
    xdp_res = (unsigned int)i40e_run_xdp_zc(rx_ring,& xdp);
    #line 584 
    if (xdp_res != 0U) {
      #line 585 
      if (((unsigned long)xdp_res & 6UL) != 0UL) {
        #line 586 
        xdp_xmit |= xdp_res;
        #line 587 
        bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.addr = (void *)0;
      }
      else 
           #line 589 
           i40e_reuse_rx_buffer_zc(rx_ring,bi);
      #line 592 
      total_rx_bytes += size;
      #line 593 
      total_rx_packets ++;
      #line 595 
      cleaned_count = (u16)((int)cleaned_count + 1);
      #line 596 
      i40e_inc_ntc(rx_ring);
      #line 597 
      continue;
    }
    #line 607 
    skb = i40e_construct_skb_zc(rx_ring,bi,& xdp);
    #line 608 
    if (skb == (struct sk_buff *)0) {
      #line 609 
      (rx_ring->__anonCompField_i40e_ring_222.rx_stats.alloc_buff_failed) ++;
      #line 610 
      break;
    }
    #line 613 
    cleaned_count = (u16)((int)cleaned_count + 1);
    #line 614 
    i40e_inc_ntc(rx_ring);
    #line 616 
    if (eth_skb_pad(skb) != 0) 
                               #line 617 
                               continue;
    #line 619 
    total_rx_bytes = skb->len + total_rx_bytes;
    #line 620 
    total_rx_packets ++;
    #line 622 
    i40e_process_skb_fields(rx_ring,rx_desc,skb);
    #line 623 
    napi_gro_receive(& (rx_ring->q_vector)->napi,skb);
  }
  #line 626 
  i40e_finalize_xdp_rx(rx_ring,xdp_xmit);
  #line 627 
  i40e_update_rx_stats(rx_ring,total_rx_bytes,total_rx_packets);
  #line 629 
  if ((int)xsk_umem_uses_need_wakeup(rx_ring->xsk_umem) != 0) {
    #line 630 
    if ((int)failure != 0 || (int)rx_ring->next_to_clean == (int)rx_ring->next_to_use) 
      #line 631 
      xsk_set_rx_need_wakeup(rx_ring->xsk_umem); else 
                                                      #line 633 
                                                      xsk_clear_rx_need_wakeup(rx_ring->xsk_umem);
    #line 635 
    return (int)total_rx_packets;
  }
  #line 637 
  if ((int)failure != 0) 
                         #line 637 
                         tmp_5 = budget; else 
                                              #line 637 
                                              tmp_5 = (int)total_rx_packets;
  #line 637 
  return tmp_5;
}

#line 647  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
static bool i40e_xmit_zc(struct i40e_ring *xdp_ring, unsigned int budget)
{
  #line 650 
  struct i40e_tx_buffer *tx_bi;
  #line 652 
  struct xdp_desc desc;
  #line 653 
  dma_addr_t dma;
  #line 649 
  struct i40e_tx_desc *tx_desc = (struct i40e_tx_desc *)0;
  #line 651 
  bool work_done = (_Bool)1;
  #line 655 
  while (1) {
    #line 655 
    unsigned int tmp_1;
    #line 655 
    tmp_1 = budget;
    #line 655 
    budget --;
    #line 655 
    ;
    #line 655 
    if (! (tmp_1 != 0U)) 
                         #line 655 
                         break;
    {
      #line 656 
      int tmp;
      #line 656 
      if ((int)xdp_ring->next_to_clean <= (int)xdp_ring->next_to_use) 
        #line 656 
        tmp = (int)xdp_ring->count; else 
                                         #line 656 
                                         tmp = 0;
      #line 656 
      ;
      #line 656 
      if ((long)((tmp + (int)xdp_ring->next_to_clean) - (int)xdp_ring->next_to_use != 1) == 0L) {
        #line 657 
        (xdp_ring->__anonCompField_i40e_ring_222.tx_stats.tx_busy) ++;
        #line 658 
        work_done = (_Bool)0;
        #line 659 
        break;
      }
      #line 662 
      if (! xsk_umem_consume_tx(xdp_ring->xsk_umem,& desc)) 
                                                            #line 663 
                                                            break;
      #line 665 
      dma = xdp_umem_get_dma(xdp_ring->xsk_umem,desc.addr);
      #line 667 
      dma_sync_single_for_device(xdp_ring->dev,dma,(unsigned long)desc.len,(enum dma_data_direction)DMA_BIDIRECTIONAL);
      #line 670 
      tx_bi = xdp_ring->__anonCompField_i40e_ring_221.tx_bi + (unsigned long)xdp_ring->next_to_use;
      #line 671 
      tx_bi->bytecount = desc.len;
      #line 673 
      tx_desc = (struct i40e_tx_desc *)xdp_ring->desc + (unsigned long)xdp_ring->next_to_use;
      #line 674 
      tx_desc->buffer_addr = dma;
      #line 675 
      tx_desc->cmd_type_offset_bsz = build_ctob(5U,0U,desc.len,0U);
      #line 680 
      xdp_ring->next_to_use = (u16)((int)xdp_ring->next_to_use + 1);
      #line 681 
      if ((int)xdp_ring->next_to_use == (int)xdp_ring->count) 
                                                              #line 682 
                                                              xdp_ring->next_to_use = (unsigned short)0U;
    }
  }
  #line 685 
  if (tx_desc != (struct i40e_tx_desc *)0) {
    #line 687 
    tx_desc->cmd_type_offset_bsz |= 32ULL;
    #line 689 
    i40e_xdp_ring_update_tail(xdp_ring);
    #line 691 
    xsk_umem_consume_tx_done(xdp_ring->xsk_umem);
  }
  #line 694 
  return (_Bool)((budget != 0U && (int)work_done != 0) != 0);
}

#line 702  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
static void i40e_clean_xdp_tx_buffer(struct i40e_ring *tx_ring, struct i40e_tx_buffer *tx_bi)
{
  #line 705 
  xdp_return_frame(tx_bi->__anonCompField_i40e_tx_buffer_217.xdpf);
  #line 706 
  dma_unmap_single_attrs(tx_ring->dev,tx_bi->dma,(unsigned long)tx_bi->len,(enum dma_data_direction)DMA_TO_DEVICE,0UL);
  #line 709 
  tx_bi->len = 0U;
  #line 710 
  return;
}

#line 719  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
bool i40e_clean_xdp_tx_irq(struct i40e_vsi *vsi, struct i40e_ring *tx_ring, int napi_budget)
{
  #line 722 
  unsigned int ntc;
  #line 723 
  u32 i;
  #line 723 
  u32 completed_frames;
  #line 723 
  u32 frames_ready;
  #line 726 
  bool xmit_done;
  #line 727 
  struct i40e_tx_buffer *tx_bi;
  #line 722 
  unsigned int total_bytes = 0U;
  #line 722 
  unsigned int budget = (unsigned int)vsi->work_limit;
  #line 723 
  u32 xsk_frames = 0U;
  #line 724 
  struct xdp_umem *umem = tx_ring->xsk_umem;
  #line 725 
  u32 head_idx = i40e_get_head(tx_ring);
  #line 726 
  bool work_done = (_Bool)1;
  #line 729 
  if ((unsigned int)tx_ring->next_to_clean > head_idx) 
                                                       #line 730 
                                                       head_idx = (unsigned int)tx_ring->count + head_idx;
  #line 731 
  frames_ready = head_idx - (unsigned int)tx_ring->next_to_clean;
  #line 733 
  if (frames_ready == 0U) 
                          #line 734 
                          goto out_xmit;
  else 
    #line 735 
    if (frames_ready > budget) {
      #line 736 
      completed_frames = budget;
      #line 737 
      work_done = (_Bool)0;
    }
    else 
         #line 739 
         completed_frames = frames_ready;
  #line 742 
  ntc = (unsigned int)tx_ring->next_to_clean;
  #line 744 
  i = 0U;
  #line 744 
  while (i < completed_frames) {
    #line 745 
    tx_bi = tx_ring->__anonCompField_i40e_ring_221.tx_bi + (unsigned long)ntc;
    #line 747 
    if (tx_bi->__anonCompField_i40e_tx_buffer_217.xdpf != (struct xdp_frame *)0) 
      #line 748 
      i40e_clean_xdp_tx_buffer(tx_ring,tx_bi); else 
                                                    #line 750 
                                                    xsk_frames ++;
    #line 752 
    tx_bi->__anonCompField_i40e_tx_buffer_217.xdpf = (struct xdp_frame *)0;
    #line 753 
    total_bytes = tx_bi->bytecount + total_bytes;
    #line 755 
    ntc ++;
    #line 755 
    ;
    #line 755 
    if (ntc >= (unsigned int)tx_ring->count) 
                                             #line 756 
                                             ntc = 0U;
    #line 744 
    i ++;
  }
  #line 759 
  tx_ring->next_to_clean = (unsigned short)((int)tx_ring->next_to_clean + (int)((unsigned short)completed_frames));
  #line 760 
  if ((long)((int)tx_ring->next_to_clean >= (int)tx_ring->count) != 0L) 
    #line 761 
    tx_ring->next_to_clean = (unsigned short)((int)tx_ring->next_to_clean - (int)tx_ring->count);
  #line 763 
  if (xsk_frames != 0U) 
                        #line 764 
                        xsk_umem_complete_tx(umem,xsk_frames);
  #line 766 
  i40e_arm_wb(tx_ring,vsi,(int)budget);
  #line 767 
  i40e_update_tx_stats(tx_ring,completed_frames,total_bytes);
  #line 769 
  out_xmit: 
            #line 769 
  ;
  #line 770 
  if ((int)xsk_umem_uses_need_wakeup(tx_ring->xsk_umem) != 0) 
                                                              #line 771 
                                                              xsk_set_tx_need_wakeup(tx_ring->xsk_umem);
  #line 773 
  xmit_done = i40e_xmit_zc(tx_ring,budget);
  #line 775 
  return (_Bool)(((int)work_done != 0 && (int)xmit_done != 0) != 0);
}

#line 786  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
int i40e_xsk_wakeup(struct net_device *dev, u32 queue_id, u32 flags)
{
  #line 791 
  struct i40e_ring *ring;
  #line 788 
  struct i40e_netdev_priv *np = netdev_priv(dev);
  #line 789 
  struct i40e_vsi *vsi = np->vsi;
  #line 790 
  struct i40e_pf *pf = vsi->back;
  #line 793 
  if ((int)test_bit(1L,(unsigned long *)(& pf->state)) != 0) 
                                                             #line 794 
                                                             return -100;
  #line 796 
  if ((int)test_bit(0L,(unsigned long *)(& vsi->state)) != 0) 
                                                              #line 797 
                                                              return -100;
  #line 799 
  if (! i40e_enabled_xdp_vsi_1(vsi)) 
                                     #line 800 
                                     return -6;
  #line 802 
  if ((unsigned int)vsi->num_queue_pairs <= queue_id) 
                                                      #line 803 
                                                      return -6;
  #line 805 
  if ((*(vsi->xdp_rings + (unsigned long)queue_id))->xsk_umem == (struct xdp_umem *)0) 
    #line 806 
    return -6;
  #line 808 
  ring = *(vsi->xdp_rings + (unsigned long)queue_id);
  #line 816 
  if (! napi_if_scheduled_mark_missed(& (ring->q_vector)->napi)) 
                                                                 #line 817 
                                                                 i40e_force_wb(vsi,ring->q_vector);
  #line 819 
  return 0;
}

#line 822  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
void i40e_xsk_clean_rx_ring(struct i40e_ring *rx_ring)
{
  #line 824 
  u16 i;
  #line 826 
  i = (unsigned short)0U;
  #line 826 
  while ((int)rx_ring->count > (int)i) {
    {
      #line 827 
      struct i40e_rx_buffer *rx_bi = rx_ring->__anonCompField_i40e_ring_221.rx_bi + (unsigned long)i;
      #line 829 
      if (rx_bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.addr == (void *)0) 
        #line 830 
        goto __Cont;
      #line 832 
      xsk_umem_fq_reuse(rx_ring->xsk_umem,rx_bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.handle);
      #line 833 
      rx_bi->__anonCompField_i40e_rx_buffer_220.__anonCompField___anonunion_1106_219.addr = (void *)0;
    }
    #line 826 
    __Cont: 
            #line 826 
    i = (u16)((int)i + 1);
  }
  #line 835 
  return;
}

#line 841  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
void i40e_xsk_clean_tx_ring(struct i40e_ring *tx_ring)
{
  #line 845 
  struct i40e_tx_buffer *tx_bi;
  #line 843 
  u16 ntc = tx_ring->next_to_clean;
  #line 843 
  u16 ntu = tx_ring->next_to_use;
  #line 844 
  struct xdp_umem *umem = tx_ring->xsk_umem;
  #line 846 
  u32 xsk_frames = 0U;
  #line 848 
  while ((int)ntc != (int)ntu) {
    #line 849 
    tx_bi = tx_ring->__anonCompField_i40e_ring_221.tx_bi + (unsigned long)ntc;
    #line 851 
    if (tx_bi->__anonCompField_i40e_tx_buffer_217.xdpf != (struct xdp_frame *)0) 
      #line 852 
      i40e_clean_xdp_tx_buffer(tx_ring,tx_bi); else 
                                                    #line 854 
                                                    xsk_frames ++;
    #line 856 
    tx_bi->__anonCompField_i40e_tx_buffer_217.xdpf = (struct xdp_frame *)0;
    #line 858 
    ntc = (u16)((int)ntc + 1);
    #line 859 
    if ((int)tx_ring->count <= (int)ntc) 
                                         #line 860 
                                         ntc = (unsigned short)0U;
  }
  #line 863 
  if (xsk_frames != 0U) 
                        #line 864 
                        xsk_umem_complete_tx(umem,xsk_frames);
  #line 865 
  return;
}

#line 873  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_xsk.c"
bool i40e_xsk_any_rx_ring_enabled(struct i40e_vsi *vsi)
{
  #line 876 
  int i;
  #line 875 
  struct net_device *netdev = vsi->netdev;
  #line 878 
  i = 0;
  #line 878 
  while ((int)vsi->num_queue_pairs > i) {
    #line 879 
    if (xdp_get_umem_from_qid(netdev,
                            (unsigned short)((int)((unsigned short)i))) != (struct xdp_umem *)0) 
      #line 880 
      return (_Bool)1;
    #line 878 
    i ++;
  }
  #line 883 
  return (_Bool)0;
}

#line 120  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_xsk.i.aux"
static void cif_set_bit_3(long nr, unsigned long *addr)
{
  #line 123 
  ldv_set_bit(nr,addr);
  #line 124 
  return;
}

#line 127  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_xsk.i.aux"
static void cif_clear_bit_3(long nr, unsigned long *addr)
{
  #line 130 
  ldv_clear_bit(nr,addr);
  #line 131 
  return;
}

#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dcbnl.h"
#line 22 
int dcb_ieee_setapp(struct net_device *, struct dcb_app *);
#line 23 
#line 23 
int dcb_ieee_delapp(struct net_device *, struct dcb_app *);
#line 39 
#line 39 
int dcbnl_ieee_notify(struct net_device *, int, int, u32, u32);
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static void i40e_get_pfc_delay(struct i40e_hw *hw, u16 *delay)
{
  #line 17 
  u32 val;
  #line 19 
  val = readl((void *)(hw->hw_addr + 536576U));
  #line 20 
  *delay = (unsigned short)(val >> 16);
  #line 21 
  return;
}

#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static int i40e_dcbnl_ieee_getets(struct net_device *dev, struct ieee_ets *ets)
{
  #line 35 
  struct i40e_dcbx_config *dcbxcfg;
  #line 34 
  struct i40e_pf *pf = i40e_netdev_to_pf(dev);
  #line 36 
  struct i40e_hw *hw = & pf->hw;
  #line 38 
  if (((int)pf->dcbx_cap & 8) == 0) 
                                    #line 39 
                                    return -22;
  #line 41 
  dcbxcfg = & hw->local_dcbx_config;
  #line 42 
  ets->willing = dcbxcfg->etscfg.willing;
  #line 43 
  ets->ets_cap = dcbxcfg->etscfg.maxtcs;
  #line 44 
  ets->cbs = dcbxcfg->etscfg.cbs;
  #line 45 
  memcpy((void *)(& ets->tc_tx_bw),(void *)(& dcbxcfg->etscfg.tcbwtable),8UL);
  #line 47 
  memcpy((void *)(& ets->tc_rx_bw),(void *)(& dcbxcfg->etscfg.tcbwtable),8UL);
  #line 49 
  memcpy((void *)(& ets->tc_tsa),(void *)(& dcbxcfg->etscfg.tsatable),8UL);
  #line 51 
  memcpy((void *)(& ets->prio_tc),(void *)(& dcbxcfg->etscfg.prioritytable),8UL);
  #line 53 
  memcpy((void *)(& ets->tc_reco_bw),(void *)(& dcbxcfg->etsrec.tcbwtable),8UL);
  #line 55 
  memcpy((void *)(& ets->tc_reco_tsa),(void *)(& dcbxcfg->etsrec.tsatable),8UL);
  #line 57 
  memcpy((void *)(& ets->reco_prio_tc),(void *)(& dcbxcfg->etscfg.prioritytable),8UL);
  #line 60 
  return 0;
}

#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static int i40e_dcbnl_ieee_getpfc(struct net_device *dev, struct ieee_pfc *pfc)
{
  #line 74 
  struct i40e_dcbx_config *dcbxcfg;
  #line 76 
  int i;
  #line 73 
  struct i40e_pf *pf = i40e_netdev_to_pf(dev);
  #line 75 
  struct i40e_hw *hw = & pf->hw;
  #line 78 
  if (((int)pf->dcbx_cap & 8) == 0) 
                                    #line 79 
                                    return -22;
  #line 81 
  dcbxcfg = & hw->local_dcbx_config;
  #line 82 
  pfc->pfc_cap = dcbxcfg->pfc.pfccap;
  #line 83 
  pfc->pfc_en = dcbxcfg->pfc.pfcenable;
  #line 84 
  pfc->mbc = dcbxcfg->pfc.mbc;
  #line 85 
  i40e_get_pfc_delay(hw,& pfc->delay);
  #line 88 
  i = 0;
  #line 88 
  while (i <= 7) {
    #line 89 
    pfc->requests[i] = pf->stats.priority_xoff_tx[i];
    #line 90 
    pfc->indications[i] = pf->stats.priority_xoff_rx[i];
    #line 88 
    i ++;
  }
  #line 93 
  return 0;
}

#line 102  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static u8 i40e_dcbnl_getdcbx(struct net_device *dev)
{
  #line 104 
  struct i40e_pf *pf = i40e_netdev_to_pf(dev);
  #line 106 
  return (unsigned char)pf->dcbx_cap;
}

#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static void i40e_dcbnl_get_perm_hw_addr(struct net_device *dev, u8 *perm_addr)
{
  #line 120 
  int i;
  #line 120 
  int j;
  #line 119 
  struct i40e_pf *pf = i40e_netdev_to_pf(dev);
  #line 122 
  memset((void *)perm_addr,255,32UL);
  #line 124 
  i = 0;
  #line 124 
  while ((int)dev->addr_len > i) {
    #line 125 
    *(perm_addr + (unsigned long)i) = pf->hw.mac.perm_addr[i];
    #line 124 
    i ++;
  }
  #line 127 
  j = 0;
  #line 127 
  while ((int)dev->addr_len > j) {
    #line 128 
    *(perm_addr + (unsigned long)i) = pf->hw.mac.san_addr[j];
    #line 127 
    j ++;
    #line 127 
    i ++;
  }
  #line 129 
  return;
}

#line 131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static struct dcbnl_rtnl_ops dcbnl_ops = {.ieee_getets = & i40e_dcbnl_ieee_getets, .ieee_getpfc = & i40e_dcbnl_ieee_getpfc, .getpermhwaddr = & i40e_dcbnl_get_perm_hw_addr, .getdcbx = & i40e_dcbnl_getdcbx};
#line 145  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
void i40e_dcbnl_set_all(struct i40e_vsi *vsi)
{
  #line 149 
  struct i40e_dcbx_config *dcbxcfg;
  #line 151 
  struct dcb_app sapp;
  #line 152 
  u8 prio;
  #line 152 
  u8 tc_map;
  #line 153 
  int i;
  #line 147 
  struct net_device *dev = vsi->netdev;
  #line 148 
  struct i40e_pf *pf = i40e_netdev_to_pf(dev);
  #line 150 
  struct i40e_hw *hw = & pf->hw;
  #line 156 
  if (((unsigned long)pf->flags & 128UL) == 0UL) 
                                                 #line 157 
                                                 return;
  #line 160 
  if (((unsigned long)pf->flags & 1024UL) != 0UL && ! pf->hw.func_caps.iscsi) 
    #line 161 
    return;
  #line 163 
  dcbxcfg = & hw->local_dcbx_config;
  #line 166 
  i = 0;
  #line 166 
  while (dcbxcfg->numapps > (unsigned int)i) {
    #line 167 
    prio = dcbxcfg->app[i].priority;
    #line 168 
    tc_map = (unsigned char)(1UL << (int)dcbxcfg->etscfg.prioritytable[(int)prio]);
    #line 171 
    if ((unsigned int)((int)vsi->tc_config.enabled_tc & (int)tc_map) != 0U) {
      #line 172 
      sapp.selector = dcbxcfg->app[i].selector;
      #line 173 
      sapp.protocol = dcbxcfg->app[i].protocolid;
      #line 174 
      sapp.priority = prio;
      #line 175 
      dcb_ieee_setapp(dev,& sapp);
    }
    #line 166 
    i ++;
  }
  #line 180 
  dcbnl_ieee_notify(dev,79,20,0U,0U);
  #line 181 
  return;
}

#line 191  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static int i40e_dcbnl_vsi_del_app(struct i40e_vsi *vsi, struct i40e_dcb_app_priority_table *app)
{
  #line 195 
  struct dcb_app sapp;
  #line 194 
  struct net_device *dev = vsi->netdev;
  #line 197 
  if (dev == (struct net_device *)0) 
                                     #line 198 
                                     return -22;
  #line 200 
  sapp.selector = app->selector;
  #line 201 
  sapp.protocol = app->protocolid;
  #line 202 
  sapp.priority = app->priority;
  #line 203 
  return dcb_ieee_delapp(dev,& sapp);
}

#line 213  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static void i40e_dcbnl_del_app(struct i40e_pf *pf, struct i40e_dcb_app_priority_table *app)
{
  #line 216 
  int v;
  #line 216 
  int err;
  #line 218 
  v = 0;
  #line 218 
  while ((int)pf->num_alloc_vsi > v) {
    #line 219 
    if (*(pf->vsi + (unsigned long)v) != (struct i40e_vsi *)0 && (*(pf->vsi + (unsigned long)v))->netdev != (struct net_device *)0) {
      #line 220 
      err = i40e_dcbnl_vsi_del_app(*(pf->vsi + (unsigned long)v),app);
      {
        #line 221 
        bool branch;
        #line 221 
        struct _ddebug __UNIQUE_ID_ddebug558 = {.modname = (char *)"i40e", .function = (char *)"i40e_dcbnl_del_app", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c", .format = (char *)"Deleting app for VSI seid=%d err=%d sel=%d proto=0x%x prio=%d\n", .lineno = (unsigned int)221U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
        #line 221 
        branch = arch_static_branch(& __UNIQUE_ID_ddebug558.key.dd_key_false.key,(_Bool)0);
        #line 221 
        if ((long)((long)((int)branch != 0)) != 0L) 
                                                    #line 221 
                                                    __dynamic_dev_dbg(& __UNIQUE_ID_ddebug558,& (pf->pdev)->dev,(char *)"Deleting app for VSI seid=%d err=%d sel=%d proto=0x%x prio=%d\n",(int)(*(pf->vsi + (unsigned long)v))->seid,err,(int)app->selector,(int)app->protocolid,(int)app->priority);
      }
    }
    #line 218 
    v ++;
  }
  #line 224 
  return;
}

#line 235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
static bool i40e_dcbnl_find_app(struct i40e_dcbx_config *cfg, struct i40e_dcb_app_priority_table *app)
{
  #line 238 
  int i;
  #line 240 
  i = 0;
  #line 240 
  while (cfg->numapps > (unsigned int)i) {
    #line 241 
    if (((int)app->selector == (int)cfg->app[i].selector && (int)app->protocolid == (int)cfg->app[i].protocolid) && (int)app->priority == (int)cfg->app[i].priority) 
      #line 244 
      return (_Bool)1;
    #line 240 
    i ++;
  }
  #line 247 
  return (_Bool)0;
}

#line 259  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
void i40e_dcbnl_flush_apps(struct i40e_pf *pf, struct i40e_dcbx_config *old_cfg, struct i40e_dcbx_config *new_cfg)
{
  #line 263 
  struct i40e_dcb_app_priority_table app;
  #line 264 
  int i;
  #line 267 
  if (((unsigned long)pf->flags & 1024UL) != 0UL && ! pf->hw.func_caps.iscsi) 
    #line 268 
    return;
  #line 270 
  i = 0;
  #line 270 
  while (old_cfg->numapps > (unsigned int)i) {
    {
      #line 271 
      app = old_cfg->app[i];
      #line 273 
      if (! i40e_dcbnl_find_app(new_cfg,& app)) 
                                                #line 274 
                                                i40e_dcbnl_del_app(pf,& app);
    }
    #line 270 
    i ++;
  }
  #line 276 
  return;
}

#line 284  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c"
void i40e_dcbnl_setup(struct i40e_vsi *vsi)
{
  #line 286 
  struct net_device *dev = vsi->netdev;
  #line 287 
  struct i40e_pf *pf = i40e_netdev_to_pf(dev);
  #line 290 
  if (((unsigned long)pf->flags & 64UL) == 0UL) 
                                                #line 291 
                                                return;
  #line 293 
  dev->dcbnl_ops = & dcbnl_ops;
  #line 296 
  i40e_dcbnl_set_all(vsi);
  #line 297 
  return;
}

/* compiler builtin: 
   unsigned long __builtin_bswap64(unsigned long);   */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list);   */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list);   */
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static void arch___set_bit(long nr, unsigned long *addr)
{
  #line 68 
  ldv_inline_asm();
  #line 69 
  return;
}

#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/find.h"
#line 372  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static unsigned long cif_find_first_bit_1(unsigned long *addr, unsigned long size);
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 337  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static void cif_set_bit_4(long nr, unsigned long *addr);
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 344  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static void cif_clear_bit_4(long nr, unsigned long *addr);
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-non-atomic.h"
__inline static void __set_bit(long nr, unsigned long *addr)
{
  #line 27 
  kasan_check_read((void *)(addr + (unsigned long)(nr / 64L)),8U);
  #line 28 
  arch___set_bit(nr,addr);
  #line 29 
  return;
}

#line 474  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernel.h"
#line 474 
int vsnprintf(char *, size_t, char *, __builtin_va_list);
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_add_2(struct list_head *new, struct list_head *prev, struct list_head *next)
{
  #line 60 
  if (! __list_add_valid(new,prev,next)) 
                                         #line 61 
                                         return;
  #line 63 
  next->prev = new;
  #line 64 
  new->next = next;
  #line 65 
  new->prev = prev;
  {
    #line 67 
    union __anonunion___u_18472 __u = {.__val = new};
    #line 66 
    __write_once_size((void *)(& prev->next),(void *)(& __u.__c),8);
    #line 66 
    struct list_head *tmp_2 = __u.__val;
  }
  #line 68 
  return;
}

#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void list_add_tail_0(struct list_head *new, struct list_head *head)
{
  #line 93 
  __list_add_2(new,head->prev,head);
  #line 94 
  return;
}

#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_del_2(struct list_head *prev, struct list_head *next)
{
  #line 97 
  next->prev = prev;
  {
    #line 107 
    union __anonunion___u_18474 __u = {.__val = next};
    #line 106 
    __write_once_size((void *)(& prev->next),(void *)(& __u.__c),8);
    #line 106 
    struct list_head *tmp = __u.__val;
  }
  #line 108 
  return;
}

#line 129  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_del_entry_2(struct list_head *entry)
{
  #line 131 
  if (! __list_del_entry_valid(entry)) 
                                       #line 132 
                                       return;
  #line 134 
  __list_del_2(entry->prev,entry->next);
  #line 135 
  return;
}

#line 137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void list_del_2(struct list_head *entry)
{
  #line 139 
  __list_del_entry_2(entry);
  #line 140 
  entry->next = (struct list_head *)(-2401263026318606080);
  #line 141 
  entry->prev = (struct list_head *)(-2401263026318606046);
  #line 142 
  return;
}

#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static int list_empty_1(struct list_head *head)
{
  #line 269 
  union __anonunion___u_18476 __u;
  #line 268 
  __read_once_size((void *)(& head->next),(void *)(& __u.__c),8);
  #line 268 
  ;
  #line 268 
  return (__u.__val) == head;
}

#line 757  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __hlist_del_1(struct hlist_node *n)
{
  #line 759 
  struct hlist_node *next = n->next;
  #line 760 
  struct hlist_node **pprev = n->pprev;
  {
    #line 763 
    union __anonunion___u_18480 __u = {.__val = next};
    #line 762 
    __write_once_size((void *)pprev,(void *)(& __u.__c),8);
    #line 762 
    struct hlist_node *tmp = __u.__val;
  }
  #line 763 
  if (next != (struct hlist_node *)0) 
                                      #line 764 
                                      next->pprev = pprev;
  #line 765 
  return;
}

#line 767  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void hlist_del_1(struct hlist_node *n)
{
  #line 769 
  __hlist_del_1(n);
  #line 770 
  n->next = (struct hlist_node *)(-2401263026318606080);
  #line 771 
  n->pprev = (struct hlist_node **)(-2401263026318606046);
  #line 772 
  return;
}

#line 782  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void hlist_add_head_1(struct hlist_node *n, struct hlist_head *h)
{
  #line 784 
  struct hlist_node *first = h->first;
  #line 785 
  n->next = first;
  #line 786 
  if (first != (struct hlist_node *)0) 
                                       #line 787 
                                       first->pprev = & n->next;
  {
    #line 789 
    union __anonunion___u_18482 __u = {.__val = n};
    #line 788 
    __write_once_size((void *)(& h->first),(void *)(& __u.__c),8);
    #line 788 
    struct hlist_node *tmp = __u.__val;
  }
  #line 789 
  n->pprev = & h->first;
  #line 790 
  return;
}

#line 802  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void hlist_add_behind(struct hlist_node *n, struct hlist_node *prev)
{
  #line 805 
  n->next = prev->next;
  #line 806 
  prev->next = n;
  #line 807 
  n->pprev = & prev->next;
  #line 809 
  if (n->next != (struct hlist_node *)0) 
                                         #line 810 
                                         (n->next)->pprev = & n->next;
  #line 811 
  return;
}

#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bitmap.h"
#line 149 
int __bitmap_subset(unsigned long *, unsigned long *, unsigned int);
#line 230 
#line 414  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static void cif_bitmap_zero_0(unsigned long *dst, unsigned int nbits);
#line 363  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bitmap.h"
__inline static int bitmap_subset(unsigned long *src1, unsigned long *src2, unsigned int nbits)
{
  #line 366 
  if (0 != 0 && nbits + 4294967295U <= 63U) 
                                            #line 367 
                                            return ((*src1 & ~ *src2) & (18446744073709551615UL >> (- nbits & 63U))) == 0UL;
  else {
    #line 369 
    return __bitmap_subset(src1,src2,nbits);
  }
}

#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 421  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static void *ERR_PTR_1(long error);
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 428  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static long PTR_ERR_1(void *ptr);
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 435  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static bool IS_ERR_1(void *ptr);
#line 607  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 624  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static void *kcalloc_1(size_t n, size_t size, gfp_t flags);
#line 668  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 645  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static void *kzalloc_5(size_t size, gfp_t flags);
#line 929  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
__inline static __u64 ethtool_get_flow_spec_ring(__u64 ring_cookie)
{
  #line 931 
  return ring_cookie & 4294967295ULL;
}

#line 934  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
__inline static __u64 ethtool_get_flow_spec_ring_vf(__u64 ring_cookie)
{
  #line 936 
  return (ring_cookie >> 32) & 255ULL;
}

#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
#line 86 
u32 ethtool_op_get_link(struct net_device *);
#line 87 
#line 87 
int ethtool_op_get_ts_info(struct net_device *, struct ethtool_ts_info *);
#line 170 
#line 170 
void ethtool_intersect_link_masks(struct ethtool_link_ksettings *, struct ethtool_link_ksettings *);
#line 213  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
#line 213 
int ptp_clock_index(struct ptp_clock *);
#line 949  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static int i40e_get_fd_cnt_all(struct i40e_pf *pf)
{
  #line 951 
  return (int)pf->hw.fdir_shared_filter_count + (int)pf->fdir_pf_filter_count;
}

#line 962  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static u64 i40e_read_fd_input_set(struct i40e_pf *pf, u16 addr)
{
  #line 964 
  u64 val;
  #line 966 
  val = (unsigned long long)i40e_read_rx_ctl(& pf->hw,(unsigned int)((int)addr * 64 + 2424864));
  #line 967 
  val <<= 32;
  #line 968 
  val = (unsigned long long)i40e_read_rx_ctl(& pf->hw,(unsigned int)(((int)addr + 37888) * 64)) + val;
  #line 970 
  return val;
}

#line 1153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e.h"
__inline static bool i40e_enabled_xdp_vsi_2(struct i40e_vsi *vsi)
{
  #line 1156 
  union __anonunion___u_19574 __u;
  #line 1155 
  __read_once_size((void *)(& vsi->xdp_prog),(void *)(& __u.__c),8);
  #line 1155 
  return (_Bool)((__u.__val) != (struct bpf_prog *)0);
}

#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_stats i40e_gstrings_queue_stats[2U] = {{.stat_string = {(char)'%', (char)'s', (char)'-', (char)'%', (char)'u', (char)'.', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s'}, .sizeof_stat = 8, .stat_offset = 96}, {.stat_string = {(char)'%', (char)'s', (char)'-', (char)'%', (char)'u', (char)'.', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s'}, .sizeof_stat = 8, .stat_offset = 104}};
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_add_one_ethtool_stat(u64 *data, void *pointer, struct i40e_stats *stat)
{
  #line 80 
  char *p;
  #line 82 
  if (pointer == (void *)0) {
    #line 86 
    *data = 0ULL;
    #line 87 
    return;
  }
  #line 90 
  p = (char *)pointer + (unsigned long)stat->stat_offset;
  #line 91 
  switch (stat->sizeof_stat) {
    #line 92 
    case 8: 
            #line 92 
    ;
    #line 93 
    *data = *((u64 *)p);
    #line 94 
    break;
    #line 95 
    case 4: 
            #line 95 
    ;
    #line 96 
    *data = (unsigned long long)*((u32 *)p);
    #line 97 
    break;
    #line 98 
    case 2: 
            #line 98 
    ;
    #line 99 
    *data = (unsigned long long)*((u16 *)p);
    #line 100 
    break;
    #line 101 
    case 1: 
            #line 101 
    ;
    #line 102 
    *data = (unsigned long long)*((u8 *)p);
    #line 103 
    break;
    #line 104 
    default: 
             #line 104 
    ;
    {
      #line 105 
      bool __warned;
      #line 105 
      int __ret_warn_once = 1;
      #line 105 
      if ((long)(__ret_warn_once != 0) != 0L && (long)(! __warned) != 0L) {
        #line 105 
        __warned = (_Bool)1;
        {
          #line 105 
          int __ret_warn_on = 1;
          #line 105 
          if ((long)(__ret_warn_on != 0) != 0L) {
            #line 105 
            __warn_printk((char *)"unexpected stat size for %s",(char *)(& stat->stat_string));
            #line 106 
            ldv_inline_asm();
            #line 107 
            ldv_inline_asm();
          }
          #line 105 
          long tmp = (long)(__ret_warn_on != 0);
        }
      }
      #line 105 
      long tmp_3 = (long)(__ret_warn_once != 0);
    }
    #line 107 
    *data = 0ULL;
  }
  #line 109 
  return;
}

#line 125  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void __i40e_add_ethtool_stats(u64 **data, void *pointer, struct i40e_stats *stats, unsigned int size)
{
  #line 129 
  unsigned int i;
  #line 131 
  i = 0U;
  #line 131 
  while (i < size) {
    #line 132 
    u64 *tmp;
    #line 132 
    ;
    #line 132 
    ;
    #line 132 
    tmp = *data;
    #line 132 
    (*data) ++;
    #line 132 
    ;
    #line 132 
    i40e_add_one_ethtool_stat(tmp,pointer,stats + (unsigned long)i);
    #line 131 
    i ++;
  }
  #line 133 
  return;
}

#line 166  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_add_queue_stats(u64 **data, struct i40e_ring *ring)
{
  #line 170 
  unsigned int start;
  #line 171 
  unsigned int i;
  #line 168 
  unsigned int size = 2U;
  #line 169 
  struct i40e_stats *stats = (struct i40e_stats *)(& i40e_gstrings_queue_stats);
  #line 178 
  while (1) {
    #line 179 
    if (ring != (struct i40e_ring *)0) 
                                       #line 179 
                                       start = u64_stats_fetch_begin_irq(& ring->syncp); else 
                                                                    #line 179 
                                                                    start = 0U;
    #line 180 
    i = 0U;
    #line 180 
    while (i <= 1U) {
      #line 181 
      i40e_add_one_ethtool_stat(*data + (unsigned long)i,(void *)ring,stats + (unsigned long)i);
      #line 180 
      i ++;
    }
    #line 183 
    if (ring != (struct i40e_ring *)0) {
      #line 184 
      if (! ((int)u64_stats_fetch_retry_irq(& ring->syncp,start) != 0)) 
        #line 178 
        break;
    }
    else 
         #line 178 
         break;
  }
  #line 187 
  *data += 2U;
  #line 188 
  return;
}

#line 199  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void __i40e_add_stat_strings(u8 **p, struct i40e_stats *stats, unsigned int size , ...)
{
  #line 202 
  unsigned int i;
  #line 204 
  i = 0U;
  #line 204 
  while (i < size) {
    {
      #line 205 
      va_list args;
      #line 207 
      #line 207 
      __builtin_va_start(args,size);
      #line 208 
      vsnprintf((char *)*p,32UL,(char *)(& (stats + (unsigned long)i)->stat_string),args);
      #line 209 
      *p += 32U;
      #line 210 
      __builtin_va_end(args);
    }
    #line 204 
    i ++;
  }
  #line 212 
  return;
}

#line 240  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_stats i40e_gstrings_net_stats[11U] = {{.stat_string = {(char)'r', (char)'x', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s'}, .sizeof_stat = 8}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s'}, .sizeof_stat = 8, .stat_offset = 8}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s'}, .sizeof_stat = 8, .stat_offset = 16}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s'}, .sizeof_stat = 8, .stat_offset = 24}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 32}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 40}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d'}, .sizeof_stat = 8, .stat_offset = 48}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d'}, .sizeof_stat = 8, .stat_offset = 56}, {.stat_string = {(char)'c', (char)'o', (char)'l', (char)'l', (char)'i', (char)'s', (char)'i', (char)'o', (char)'n', (char)'s'}, .sizeof_stat = 8, .stat_offset = 72}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'l', (char)'e', (char)'n', (char)'g', (char)'t', (char)'h', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 80}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'c', (char)'r', (char)'c', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 96}};
#line 254  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_stats i40e_gstrings_veb_stats[12U] = {{.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s'}, .sizeof_stat = 8, .stat_offset = 80}, {.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s'}, .sizeof_stat = 8, .stat_offset = 128}, {.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'r', (char)'x', (char)'_', (char)'u', (char)'n', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 88}, {.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'t', (char)'x', (char)'_', (char)'u', (char)'n', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 136}, {.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'r', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 96}, {.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'t', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 144}, {.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'r', (char)'x', (char)'_', (char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 104}, {.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'t', (char)'x', (char)'_', (char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 152}, {.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'r', (char)'x', (char)'_', (char)'d', (char)'i', (char)'s', (char)'c', (char)'a', (char)'r', (char)'d', (char)'s'}, .sizeof_stat = 8, .stat_offset = 112}, {.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'t', (char)'x', (char)'_', (char)'d', (char)'i', (char)'s', (char)'c', (char)'a', (char)'r', (char)'d', (char)'s'}, .sizeof_stat = 8, .stat_offset = 160}, {.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'t', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 168}, {.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'r', (char)'x', (char)'_', (char)'u', (char)'n', (char)'k', (char)'n', (char)'o', (char)'w', (char)'n', (char)'_', (char)'p', (char)'r', (char)'o', (char)'t', (char)'o', (char)'c', (char)'o', (char)'l'}, .sizeof_stat = 8, .stat_offset = 120}};
#line 269  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_stats i40e_gstrings_veb_tc_stats[4U] = {{.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'t', (char)'c', (char)'_', (char)'%', (char)'u', (char)'_', (char)'t', (char)'x', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s'}, .sizeof_stat = 64, .stat_offset = 400}, {.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'t', (char)'c', (char)'_', (char)'%', (char)'u', (char)'_', (char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s'}, .sizeof_stat = 64, .stat_offset = 464}, {.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'t', (char)'c', (char)'_', (char)'%', (char)'u', (char)'_', (char)'r', (char)'x', (char)'_', (char)'p', (char)'a', (char)'c', (char)'k', (char)'e', (char)'t', (char)'s'}, .sizeof_stat = 64, .stat_offset = 272}, {.stat_string = {(char)'v', (char)'e', (char)'b', (char)'.', (char)'t', (char)'c', (char)'_', (char)'%', (char)'u', (char)'_', (char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s'}, .sizeof_stat = 64, .stat_offset = 336}};
#line 276  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_stats i40e_gstrings_misc_stats[12U] = {{.stat_string = {(char)'r', (char)'x', (char)'_', (char)'u', (char)'n', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 3064}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'u', (char)'n', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 3112}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 3072}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 3120}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 3080}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 3128}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'u', (char)'n', (char)'k', (char)'n', (char)'o', (char)'w', (char)'n', (char)'_', (char)'p', (char)'r', (char)'o', (char)'t', (char)'o', (char)'c', (char)'o', (char)'l'}, .sizeof_stat = 8, .stat_offset = 3096}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'l', (char)'i', (char)'n', (char)'e', (char)'a', (char)'r', (char)'i', (char)'z', (char)'e'}, .sizeof_stat = 8, .stat_offset = 3256}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'f', (char)'o', (char)'r', (char)'c', (char)'e', (char)'_', (char)'w', (char)'b'}, .sizeof_stat = 8, .stat_offset = 3264}, {.stat_string = {(char)'t', (char)'x', (char)'_', (char)'b', (char)'u', (char)'s', (char)'y'}, .sizeof_stat = 4, .stat_offset = 3252}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'a', (char)'l', (char)'l', (char)'o', (char)'c', (char)'_', (char)'f', (char)'a', (char)'i', (char)'l'}, .sizeof_stat = 4, .stat_offset = 3272}, {.stat_string = {(char)'r', (char)'x', (char)'_', (char)'p', (char)'g', (char)'_', (char)'a', (char)'l', (char)'l', (char)'o', (char)'c', (char)'_', (char)'f', (char)'a', (char)'i', (char)'l'}, .sizeof_stat = 4, .stat_offset = 3276}};
#line 301  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_stats i40e_gstrings_stats[55U] = {{.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s'}, .sizeof_stat = 8, .stat_offset = 2472}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s'}, .sizeof_stat = 8, .stat_offset = 2520}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'u', (char)'n', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 2480}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'u', (char)'n', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 2528}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 2488}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'m', (char)'u', (char)'l', (char)'t', (char)'i', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 2536}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 2496}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'b', (char)'r', (char)'o', (char)'a', (char)'d', (char)'c', (char)'a', (char)'s', (char)'t'}, .sizeof_stat = 8, .stat_offset = 2544}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 2560}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d'}, .sizeof_stat = 8, .stat_offset = 2504}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'d', (char)'r', (char)'o', (char)'p', (char)'p', (char)'e', (char)'d', (char)'_', (char)'l', (char)'i', (char)'n', (char)'k', (char)'_', (char)'d', (char)'o', (char)'w', (char)'n'}, .sizeof_stat = 8, .stat_offset = 2568}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'c', (char)'r', (char)'c', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 2576}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'i', (char)'l', (char)'l', (char)'e', (char)'g', (char)'a', (char)'l', (char)'_', (char)'b', (char)'y', (char)'t', (char)'e', (char)'s'}, .sizeof_stat = 8, .stat_offset = 2584}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'m', (char)'a', (char)'c', (char)'_', (char)'l', (char)'o', (char)'c', (char)'a', (char)'l', (char)'_', (char)'f', (char)'a', (char)'u', (char)'l', (char)'t', (char)'s'}, .sizeof_stat = 8, .stat_offset = 2600}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'m', (char)'a', (char)'c', (char)'_', (char)'r', (char)'e', (char)'m', (char)'o', (char)'t', (char)'e', (char)'_', (char)'f', (char)'a', (char)'u', (char)'l', (char)'t', (char)'s'}, .sizeof_stat = 8, .stat_offset = 2608}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'t', (char)'i', (char)'m', (char)'e', (char)'o', (char)'u', (char)'t'}, .sizeof_stat = 4, .stat_offset = 3912}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'c', (char)'s', (char)'u', (char)'m', (char)'_', (char)'b', (char)'a', (char)'d'}, .sizeof_stat = 4, .stat_offset = 3932}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'l', (char)'e', (char)'n', (char)'g', (char)'t', (char)'h', (char)'_', (char)'e', (char)'r', (char)'r', (char)'o', (char)'r', (char)'s'}, .sizeof_stat = 8, .stat_offset = 2616}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'l', (char)'i', (char)'n', (char)'k', (char)'_', (char)'x', (char)'o', (char)'n', (char)'_', (char)'r', (char)'x'}, .sizeof_stat = 8, .stat_offset = 2624}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'l', (char)'i', (char)'n', (char)'k', (char)'_', (char)'x', (char)'o', (char)'f', (char)'f', (char)'_', (char)'r', (char)'x'}, .sizeof_stat = 8, .stat_offset = 2632}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'l', (char)'i', (char)'n', (char)'k', (char)'_', (char)'x', (char)'o', (char)'n', (char)'_', (char)'t', (char)'x'}, .sizeof_stat = 8, .stat_offset = 2768}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'l', (char)'i', (char)'n', (char)'k', (char)'_', (char)'x', (char)'o', (char)'f', (char)'f', (char)'_', (char)'t', (char)'x'}, .sizeof_stat = 8, .stat_offset = 2776}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'6', (char)'4'}, .sizeof_stat = 8, .stat_offset = 2976}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'1', (char)'2', (char)'7'}, .sizeof_stat = 8, .stat_offset = 2984}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'2', (char)'5', (char)'5'}, .sizeof_stat = 8, .stat_offset = 2992}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'5', (char)'1', (char)'1'}, .sizeof_stat = 8, .stat_offset = 3000}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'1', (char)'0', (char)'2', (char)'3'}, .sizeof_stat = 8, .stat_offset = 3008}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'1', (char)'5', (char)'2', (char)'2'}, .sizeof_stat = 8, .stat_offset = 3016}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'b', (char)'i', (char)'g'}, .sizeof_stat = 8, .stat_offset = 3024}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'6', (char)'4'}, .sizeof_stat = 8, .stat_offset = 3064}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'1', (char)'2', (char)'7'}, .sizeof_stat = 8, .stat_offset = 3072}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'2', (char)'5', (char)'5'}, .sizeof_stat = 8, .stat_offset = 3080}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'5', (char)'1', (char)'1'}, .sizeof_stat = 8, .stat_offset = 3088}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'1', (char)'0', (char)'2', (char)'3'}, .sizeof_stat = 8, .stat_offset = 3096}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'1', (char)'5', (char)'2', (char)'2'}, .sizeof_stat = 8, .stat_offset = 3104}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'s', (char)'i', (char)'z', (char)'e', (char)'_', (char)'b', (char)'i', (char)'g'}, .sizeof_stat = 8, .stat_offset = 3112}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'u', (char)'n', (char)'d', (char)'e', (char)'r', (char)'s', (char)'i', (char)'z', (char)'e'}, .sizeof_stat = 8, .stat_offset = 3032}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'f', (char)'r', (char)'a', (char)'g', (char)'m', (char)'e', (char)'n', (char)'t', (char)'s'}, .sizeof_stat = 8, .stat_offset = 3040}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'o', (char)'v', (char)'e', (char)'r', (char)'s', (char)'i', (char)'z', (char)'e'}, .sizeof_stat = 8, .stat_offset = 3048}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'j', (char)'a', (char)'b', (char)'b', (char)'e', (char)'r'}, .sizeof_stat = 8, .stat_offset = 3056}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'V', (char)'F', (char)'_', (char)'a', (char)'d', (char)'m', (char)'i', (char)'n', (char)'_', (char)'q', (char)'u', (char)'e', (char)'u', (char)'e', (char)'_', (char)'r', (char)'e', (char)'q', (char)'u', (char)'e', (char)'s', (char)'t', (char)'s'}, .sizeof_stat = 4, .stat_offset = 4316}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'a', (char)'r', (char)'q', (char)'_', (char)'o', (char)'v', (char)'e', (char)'r', (char)'f', (char)'l', (char)'o', (char)'w', (char)'s'}, .sizeof_stat = 4, .stat_offset = 4320}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'h', (char)'w', (char)'t', (char)'s', (char)'t', (char)'a', (char)'m', (char)'p', (char)'_', (char)'t', (char)'i', (char)'m', (char)'e', (char)'o', (char)'u', (char)'t', (char)'s'}, .sizeof_stat = 4, .stat_offset = 4716}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'h', (char)'w', (char)'t', (char)'s', (char)'t', (char)'a', (char)'m', (char)'p', (char)'_', (char)'c', (char)'l', (char)'e', (char)'a', (char)'r', (char)'e', (char)'d'}, .sizeof_stat = 4, .stat_offset = 4724}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'h', (char)'w', (char)'t', (char)'s', (char)'t', (char)'a', (char)'m', (char)'p', (char)'_', (char)'s', (char)'k', (char)'i', (char)'p', (char)'p', (char)'e', (char)'d'}, .sizeof_stat = 4, .stat_offset = 4720}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'f', (char)'d', (char)'i', (char)'r', (char)'_', (char)'f', (char)'l', (char)'u', (char)'s', (char)'h', (char)'_', (char)'c', (char)'n', (char)'t'}, .sizeof_stat = 4, .stat_offset = 2072}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'f', (char)'d', (char)'i', (char)'r', (char)'_', (char)'a', (char)'t', (char)'r', (char)'_', (char)'m', (char)'a', (char)'t', (char)'c', (char)'h'}, .sizeof_stat = 8, .stat_offset = 3136}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'f', (char)'d', (char)'i', (char)'r', (char)'_', (char)'a', (char)'t', (char)'r', (char)'_', (char)'t', (char)'u', (char)'n', (char)'n', (char)'e', (char)'l', (char)'_', (char)'m', (char)'a', (char)'t', (char)'c', (char)'h'}, .sizeof_stat = 8, .stat_offset = 3152}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'f', (char)'d', (char)'i', (char)'r', (char)'_', (char)'a', (char)'t', (char)'r', (char)'_', (char)'s', (char)'t', (char)'a', (char)'t', (char)'u', (char)'s'}, .sizeof_stat = 4, .stat_offset = 3160}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'f', (char)'d', (char)'i', (char)'r', (char)'_', (char)'s', (char)'b', (char)'_', (char)'m', (char)'a', (char)'t', (char)'c', (char)'h'}, .sizeof_stat = 8, .stat_offset = 3144}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'f', (char)'d', (char)'i', (char)'r', (char)'_', (char)'s', (char)'b', (char)'_', (char)'s', (char)'t', (char)'a', (char)'t', (char)'u', (char)'s'}, .sizeof_stat = 4, .stat_offset = 3164}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'l', (char)'p', (char)'i', (char)'_', (char)'s', (char)'t', (char)'a', (char)'t', (char)'u', (char)'s'}, .sizeof_stat = 4, .stat_offset = 3168}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'l', (char)'p', (char)'i', (char)'_', (char)'s', (char)'t', (char)'a', (char)'t', (char)'u', (char)'s'}, .sizeof_stat = 4, .stat_offset = 3172}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'l', (char)'p', (char)'i', (char)'_', (char)'c', (char)'o', (char)'u', (char)'n', (char)'t'}, .sizeof_stat = 8, .stat_offset = 3176}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'l', (char)'p', (char)'i', (char)'_', (char)'c', (char)'o', (char)'u', (char)'n', (char)'t'}, .sizeof_stat = 8, .stat_offset = 3184}};
#line 369  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_stats i40e_gstrings_pfc_stats[5U] = {{.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'p', (char)'r', (char)'i', (char)'o', (char)'r', (char)'i', (char)'t', (char)'y', (char)'_', (char)'%', (char)'u', (char)'_', (char)'x', (char)'o', (char)'n', (char)'_', (char)'t', (char)'x'}, .sizeof_stat = 8, .stat_offset = 16}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'t', (char)'x', (char)'_', (char)'p', (char)'r', (char)'i', (char)'o', (char)'r', (char)'i', (char)'t', (char)'y', (char)'_', (char)'%', (char)'u', (char)'_', (char)'x', (char)'o', (char)'f', (char)'f', (char)'_', (char)'t', (char)'x'}, .sizeof_stat = 8, .stat_offset = 24}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'p', (char)'r', (char)'i', (char)'o', (char)'r', (char)'i', (char)'t', (char)'y', (char)'_', (char)'%', (char)'u', (char)'_', (char)'x', (char)'o', (char)'n', (char)'_', (char)'r', (char)'x'}, .sizeof_stat = 8}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'p', (char)'r', (char)'i', (char)'o', (char)'r', (char)'i', (char)'t', (char)'y', (char)'_', (char)'%', (char)'u', (char)'_', (char)'x', (char)'o', (char)'f', (char)'f', (char)'_', (char)'r', (char)'x'}, .sizeof_stat = 8, .stat_offset = 8}, {.stat_string = {(char)'p', (char)'o', (char)'r', (char)'t', (char)'.', (char)'r', (char)'x', (char)'_', (char)'p', (char)'r', (char)'i', (char)'o', (char)'r', (char)'i', (char)'t', (char)'y', (char)'_', (char)'%', (char)'u', (char)'_', (char)'x', (char)'o', (char)'n', (char)'_', (char)'2', (char)'_', (char)'x', (char)'o', (char)'f', (char)'f'}, .sizeof_stat = 8, .stat_offset = 32}};
#line 407  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static char i40e_gstrings_test[4U][32U] = {{(char)'R', (char)'e', (char)'g', (char)'i', (char)'s', (char)'t', (char)'e', (char)'r', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')'}, {(char)'E', (char)'e', (char)'p', (char)'r', (char)'o', (char)'m', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)' ', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')'}, {(char)'I', (char)'n', (char)'t', (char)'e', (char)'r', (char)'r', (char)'u', (char)'p', (char)'t', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)'(', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')'}, {(char)'L', (char)'i', (char)'n', (char)'k', (char)' ', (char)'t', (char)'e', (char)'s', (char)'t', (char)' ', (char)' ', (char)' ', (char)'(', (char)'o', (char)'n', (char)'/', (char)'o', (char)'f', (char)'f', (char)'l', (char)'i', (char)'n', (char)'e', (char)')'}};
#line 428  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_priv_flags i40e_gstrings_priv_flags[11U] = {{.flag_string = {(char)'M', (char)'F', (char)'P'}, .flag = 1024ULL, .read_only = (_Bool)1}, {.flag_string = {(char)'L', (char)'i', (char)'n', (char)'k', (char)'P', (char)'o', (char)'l', (char)'l', (char)'i', (char)'n', (char)'g'}, .flag = 16384ULL}, {.flag_string = {(char)'f', (char)'l', (char)'o', (char)'w', (char)'-', (char)'d', (char)'i', (char)'r', (char)'e', (char)'c', (char)'t', (char)'o', (char)'r', (char)'-', (char)'a', (char)'t', (char)'r'}, .flag = 512ULL}, {.flag_string = {(char)'v', (char)'e', (char)'b', (char)'-', (char)'s', (char)'t', (char)'a', (char)'t', (char)'s'}, .flag = 8192ULL}, {.flag_string = {(char)'h', (char)'w', (char)'-', (char)'a', (char)'t', (char)'r', (char)'-', (char)'e', (char)'v', (char)'i', (char)'c', (char)'t', (char)'i', (char)'o', (char)'n'}, .flag = 2048ULL}, {.flag_string = {(char)'l', (char)'i', (char)'n', (char)'k', (char)'-', (char)'d', (char)'o', (char)'w', (char)'n', (char)'-', (char)'o', (char)'n', (char)'-', (char)'c', (char)'l', (char)'o', (char)'s', (char)'e'}, .flag = 524288ULL}, {.flag_string = {(char)'l', (char)'e', (char)'g', (char)'a', (char)'c', (char)'y', (char)'-', (char)'r', (char)'x'}, .flag = 65536ULL}, {.flag_string = {(char)'d', (char)'i', (char)'s', (char)'a', (char)'b', (char)'l', (char)'e', (char)'-', (char)'s', (char)'o', (char)'u', (char)'r', (char)'c', (char)'e', (char)'-', (char)'p', (char)'r', (char)'u', (char)'n', (char)'i', (char)'n', (char)'g'}, .flag = 1048576ULL}, {.flag_string = {(char)'d', (char)'i', (char)'s', (char)'a', (char)'b', (char)'l', (char)'e', (char)'-', (char)'f', (char)'w', (char)'-', (char)'l', (char)'l', (char)'d', (char)'p'}, .flag = 16777216ULL}, {.flag_string = {(char)'r', (char)'s', (char)'-', (char)'f', (char)'e', (char)'c'}, .flag = 33554432ULL}, {.flag_string = {(char)'b', (char)'a', (char)'s', (char)'e', (char)'-', (char)'r', (char)'-', (char)'f', (char)'e', (char)'c'}, .flag = 67108864ULL}};
#line 448  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_priv_flags i40e_gl_gstrings_priv_flags[1U] = {{.flag_string = {(char)'v', (char)'f', (char)'-', (char)'t', (char)'r', (char)'u', (char)'e', (char)'-', (char)'p', (char)'r', (char)'o', (char)'m', (char)'i', (char)'s', (char)'c', (char)'-', (char)'s', (char)'u', (char)'p', (char)'p', (char)'o', (char)'r', (char)'t'}, .flag = 32768ULL}};
#line 459  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_partition_setting_complaint(struct i40e_pf *pf)
{
  #line 461 
  _dev_info(& (pf->pdev)->dev,(char *)"The link settings are allowed to be changed only from the first partition of a given port. Please switch to the first partition in order to change the setting.\n");
  #line 462 
  return;
}

#line 471  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_phy_type_to_ethtool(struct i40e_pf *pf, struct ethtool_link_ksettings *ks)
{
  #line 474 
  struct i40e_link_status *hw_link_info = & pf->hw.phy.link_info;
  #line 475 
  u64 phy_types = pf->hw.phy.phy_types;
  #line 477 
  cif_bitmap_zero_0((unsigned long *)(& ks->link_modes.supported),74U);
  #line 478 
  cif_bitmap_zero_0((unsigned long *)(& ks->link_modes.advertising),74U);
  #line 480 
  if ((phy_types & 1ULL) != 0ULL) {
    #line 481 
    __set_bit(5L,(unsigned long *)(& ks->link_modes.supported));
    #line 483 
    if (((int)hw_link_info->requested_speeds & 4) != 0) 
                                                        #line 484 
                                                        __set_bit(5L,(unsigned long *)(& ks->link_modes.advertising));
    #line 486 
    if (((unsigned long)pf->hw_features & 64UL) != 0UL) {
      #line 487 
      __set_bit(3L,(unsigned long *)(& ks->link_modes.supported));
      #line 489 
      __set_bit(3L,(unsigned long *)(& ks->link_modes.advertising));
    }
  }
  #line 493 
  if (((((phy_types & 32ULL) != 0ULL || (phy_types & 64ULL) != 0ULL) || (phy_types & 128ULL) != 0ULL) || (phy_types & 4194304ULL) != 0ULL) || (phy_types & 4096ULL) != 0ULL) {
    #line 498 
    __set_bit(12L,(unsigned long *)(& ks->link_modes.supported));
    #line 500 
    if (((int)hw_link_info->requested_speeds & 8) != 0) 
                                                        #line 501 
                                                        __set_bit(12L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 504 
  if ((phy_types & 524288ULL) != 0ULL) {
    #line 505 
    __set_bit(12L,(unsigned long *)(& ks->link_modes.supported));
    #line 507 
    if (((int)hw_link_info->requested_speeds & 8) != 0) 
                                                        #line 508 
                                                        __set_bit(12L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 511 
  if ((phy_types & 274877906944ULL) != 0ULL) {
    #line 512 
    __set_bit(47L,(unsigned long *)(& ks->link_modes.supported));
    #line 514 
    if (((int)hw_link_info->requested_speeds & 1) != 0) 
                                                        #line 515 
                                                        __set_bit(47L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 518 
  if ((phy_types & 549755813888ULL) != 0ULL) {
    #line 519 
    __set_bit(48L,(unsigned long *)(& ks->link_modes.supported));
    #line 521 
    if (((int)hw_link_info->requested_speeds & 128) != 0) 
                                                          #line 522 
                                                          __set_bit(48L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 525 
  if (((phy_types & 256ULL) != 0ULL || (phy_types & 512ULL) != 0ULL) || (phy_types & 8192ULL) != 0ULL) 
    #line 528 
    __set_bit(24L,(unsigned long *)(& ks->link_modes.supported));
  #line 530 
  if ((phy_types & 1024ULL) != 0ULL || (phy_types & 16777216ULL) != 0ULL) {
    #line 532 
    __set_bit(24L,(unsigned long *)(& ks->link_modes.supported));
    #line 534 
    if (((int)hw_link_info->requested_speeds & 16) != 0) 
                                                         #line 535 
                                                         __set_bit(24L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 538 
  if ((phy_types & 131072ULL) != 0ULL) {
    #line 539 
    __set_bit(3L,(unsigned long *)(& ks->link_modes.supported));
    #line 541 
    if (((int)hw_link_info->requested_speeds & 2) != 0) 
                                                        #line 542 
                                                        __set_bit(3L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 545 
  if ((phy_types & 262144ULL) != 0ULL) {
    #line 546 
    __set_bit(5L,(unsigned long *)(& ks->link_modes.supported));
    #line 548 
    if (((int)hw_link_info->requested_speeds & 4) != 0) 
                                                        #line 549 
                                                        __set_bit(5L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 552 
  if ((phy_types & 33554432ULL) != 0ULL) {
    #line 553 
    __set_bit(25L,(unsigned long *)(& ks->link_modes.supported));
    #line 555 
    __set_bit(25L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 558 
  if ((phy_types & 67108864ULL) != 0ULL) {
    #line 559 
    __set_bit(26L,(unsigned long *)(& ks->link_modes.supported));
    #line 561 
    __set_bit(26L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 564 
  if ((phy_types & 16ULL) != 0ULL) {
    #line 565 
    __set_bit(23L,(unsigned long *)(& ks->link_modes.supported));
    #line 567 
    __set_bit(23L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 570 
  if ((phy_types & 1073741824ULL) != 0ULL) {
    #line 571 
    __set_bit(22L,(unsigned long *)(& ks->link_modes.supported));
    #line 573 
    if (((int)hw_link_info->requested_speeds & 32) != 0) 
                                                         #line 574 
                                                         __set_bit(22L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 577 
  if ((phy_types & 4ULL) != 0ULL) {
    #line 578 
    __set_bit(18L,(unsigned long *)(& ks->link_modes.supported));
    #line 580 
    if (((int)hw_link_info->requested_speeds & 8) != 0) 
                                                        #line 581 
                                                        __set_bit(18L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 584 
  if ((phy_types & 8ULL) != 0ULL && ((unsigned long)pf->hw_features & 8192UL) == 0UL) {
    #line 586 
    __set_bit(19L,(unsigned long *)(& ks->link_modes.supported));
    #line 588 
    if (((int)hw_link_info->requested_speeds & 8) != 0) 
                                                        #line 589 
                                                        __set_bit(19L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 592 
  if ((phy_types & 2ULL) != 0ULL && ((unsigned long)pf->hw_features & 8192UL) == 0UL) {
    #line 594 
    __set_bit(17L,(unsigned long *)(& ks->link_modes.supported));
    #line 596 
    if (((int)hw_link_info->requested_speeds & 4) != 0) 
                                                        #line 597 
                                                        __set_bit(17L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 601 
  if ((phy_types & 4294967296ULL) != 0ULL) {
    #line 602 
    __set_bit(32L,(unsigned long *)(& ks->link_modes.supported));
    #line 604 
    if (((int)hw_link_info->requested_speeds & 64) != 0) 
                                                         #line 605 
                                                         __set_bit(32L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 608 
  if ((phy_types & 8589934592ULL) != 0ULL) {
    #line 609 
    __set_bit(31L,(unsigned long *)(& ks->link_modes.supported));
    #line 611 
    if (((int)hw_link_info->requested_speeds & 64) != 0) 
                                                         #line 612 
                                                         __set_bit(31L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 615 
  if ((phy_types & 17179869184ULL) != 0ULL || (phy_types & 34359738368ULL) != 0ULL) {
    #line 617 
    __set_bit(33L,(unsigned long *)(& ks->link_modes.supported));
    #line 619 
    if (((int)hw_link_info->requested_speeds & 64) != 0) 
                                                         #line 620 
                                                         __set_bit(33L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 623 
  if ((phy_types & 68719476736ULL) != 0ULL || (phy_types & 137438953472ULL) != 0ULL) {
    #line 625 
    __set_bit(31L,(unsigned long *)(& ks->link_modes.supported));
    #line 627 
    if (((int)hw_link_info->requested_speeds & 64) != 0) 
                                                         #line 628 
                                                         __set_bit(31L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 631 
  if ((((((phy_types & 4294967296ULL) != 0ULL || (phy_types & 8589934592ULL) != 0ULL) || (phy_types & 17179869184ULL) != 0ULL) || (phy_types & 34359738368ULL) != 0ULL) || (phy_types & 68719476736ULL) != 0ULL) || (phy_types & 137438953472ULL) != 0ULL) {
    #line 637 
    __set_bit(49L,(unsigned long *)(& ks->link_modes.supported));
    #line 638 
    __set_bit(50L,(unsigned long *)(& ks->link_modes.supported));
    #line 639 
    __set_bit(51L,(unsigned long *)(& ks->link_modes.supported));
    #line 640 
    if (((int)hw_link_info->requested_speeds & 64) != 0) {
      #line 641 
      __set_bit(49L,(unsigned long *)(& ks->link_modes.advertising));
      #line 643 
      __set_bit(50L,(unsigned long *)(& ks->link_modes.advertising));
      #line 645 
      __set_bit(51L,(unsigned long *)(& ks->link_modes.advertising));
    }
  }
  #line 650 
  if ((phy_types & 8388608ULL) != 0ULL || (phy_types & 2048ULL) != 0ULL) {
    #line 652 
    __set_bit(42L,(unsigned long *)(& ks->link_modes.supported));
    #line 654 
    if (((int)hw_link_info->requested_speeds & 8) != 0) 
                                                        #line 655 
                                                        __set_bit(42L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 658 
  if ((phy_types & 1048576ULL) != 0ULL) {
    #line 659 
    __set_bit(43L,(unsigned long *)(& ks->link_modes.supported));
    #line 661 
    if (((int)hw_link_info->requested_speeds & 8) != 0) 
                                                        #line 662 
                                                        __set_bit(43L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 665 
  if ((phy_types & 2097152ULL) != 0ULL) {
    #line 666 
    __set_bit(44L,(unsigned long *)(& ks->link_modes.supported));
    #line 668 
    if (((int)hw_link_info->requested_speeds & 8) != 0) 
                                                        #line 669 
                                                        __set_bit(44L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 672 
  if (((phy_types & 134217728ULL) != 0ULL || (phy_types & 268435456ULL) != 0ULL) || (phy_types & 536870912ULL) != 0ULL) {
    #line 675 
    __set_bit(41L,(unsigned long *)(& ks->link_modes.supported));
    #line 677 
    if (((int)hw_link_info->requested_speeds & 4) != 0) 
                                                        #line 678 
                                                        __set_bit(41L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 682 
  if ((((((((((((((((((((((((phy_types & 1ULL) != 0ULL || (phy_types & 16ULL) != 0ULL) || (phy_types & 1024ULL) != 0ULL) || (phy_types & 16777216ULL) != 0ULL) || (phy_types & 17179869184ULL) != 0ULL) || (phy_types & 34359738368ULL) != 0ULL) || (phy_types & 4294967296ULL) != 0ULL) || (phy_types & 8589934592ULL) != 0ULL) || (phy_types & 1073741824ULL) != 0ULL) || (phy_types & 1048576ULL) != 0ULL) || (phy_types & 2097152ULL) != 0ULL) || (phy_types & 4ULL) != 0ULL) || (phy_types & 8ULL) != 0ULL) || (phy_types & 2048ULL) != 0ULL) || (phy_types & 8388608ULL) != 0ULL) || (phy_types & 524288ULL) != 0ULL) || (phy_types & 549755813888ULL) != 0ULL) || (phy_types & 274877906944ULL) != 0ULL) || (phy_types & 536870912ULL) != 0ULL) || (phy_types & 262144ULL) != 0ULL) || (phy_types & 134217728ULL) != 0ULL) || (phy_types & 268435456ULL) != 0ULL) || (phy_types & 2ULL) != 0ULL) || (phy_types & 131072ULL) != 0ULL) {
    #line 706 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.supported));
    #line 708 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.advertising));
  }
  #line 710 
  return;
}

#line 718  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_settings_link_up_fec(u8 req_fec_info, struct ethtool_link_ksettings *ks)
{
  #line 721 
  __set_bit(49L,(unsigned long *)(& ks->link_modes.supported));
  #line 722 
  __set_bit(50L,(unsigned long *)(& ks->link_modes.supported));
  #line 723 
  __set_bit(51L,(unsigned long *)(& ks->link_modes.supported));
  #line 725 
  if (((unsigned int)req_fec_info & 8U) != 0U && ((unsigned int)req_fec_info & 4U) != 0U) {
    #line 727 
    __set_bit(49L,(unsigned long *)(& ks->link_modes.advertising));
    #line 729 
    __set_bit(51L,(unsigned long *)(& ks->link_modes.advertising));
    #line 731 
    __set_bit(50L,(unsigned long *)(& ks->link_modes.advertising));
  }
  else 
    #line 732 
    if (((unsigned int)req_fec_info & 8U) != 0U) 
                                                 #line 733 
                                                 __set_bit(50L,(unsigned long *)(& ks->link_modes.advertising));
    else 
      #line 734 
      if (((unsigned int)req_fec_info & 4U) != 0U) 
                                                   #line 735 
                                                   __set_bit(51L,(unsigned long *)(& ks->link_modes.advertising)); else 
                                                                    #line 738 
                                                                    __set_bit(49L,(unsigned long *)(& ks->link_modes.advertising));
  #line 739 
  return;
}

#line 750  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_settings_link_up(struct i40e_hw *hw, struct ethtool_link_ksettings *ks, struct net_device *netdev, struct i40e_pf *pf)
{
  #line 756 
  struct ethtool_link_ksettings cap_ksettings;
  #line 755 
  struct i40e_link_status *hw_link_info = & hw->phy.link_info;
  #line 757 
  u32 link_speed = hw_link_info->link_speed;
  #line 760 
  switch ((unsigned int)hw_link_info->phy_type) {
    #line 761 
    case (unsigned int)24: 
                           #line 761 
    ;
    #line 762 
    case (unsigned int)10: 
                           #line 762 
    ;
    #line 763 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.supported));
    #line 764 
    __set_bit(24L,(unsigned long *)(& ks->link_modes.supported));
    #line 766 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.advertising));
    #line 767 
    __set_bit(24L,(unsigned long *)(& ks->link_modes.advertising));
    #line 769 
    break;
    #line 770 
    case (unsigned int)8: 
                          #line 770 
    ;
    #line 771 
    case (unsigned int)9: 
                          #line 771 
    ;
    #line 772 
    case (unsigned int)13: 
                           #line 772 
    ;
    #line 773 
    __set_bit(24L,(unsigned long *)(& ks->link_modes.supported));
    #line 775 
    __set_bit(24L,(unsigned long *)(& ks->link_modes.advertising));
    #line 777 
    break;
    #line 778 
    case (unsigned int)25: 
                           #line 778 
    ;
    #line 779 
    __set_bit(25L,(unsigned long *)(& ks->link_modes.supported));
    #line 781 
    __set_bit(25L,(unsigned long *)(& ks->link_modes.advertising));
    #line 783 
    break;
    #line 784 
    case (unsigned int)26: 
                           #line 784 
    ;
    #line 785 
    __set_bit(26L,(unsigned long *)(& ks->link_modes.supported));
    #line 787 
    __set_bit(26L,(unsigned long *)(& ks->link_modes.advertising));
    #line 789 
    break;
    #line 790 
    case (unsigned int)33: 
                           #line 790 
    ;
    #line 791 
    case (unsigned int)34: 
                           #line 791 
    ;
    #line 792 
    case (unsigned int)20: 
                           #line 792 
    ;
    #line 793 
    case (unsigned int)21: 
                           #line 793 
    ;
    #line 794 
    case (unsigned int)27: 
                           #line 794 
    ;
    #line 795 
    case (unsigned int)28: 
                           #line 795 
    ;
    #line 796 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.supported));
    #line 797 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.advertising));
    #line 798 
    __set_bit(33L,(unsigned long *)(& ks->link_modes.supported));
    #line 800 
    __set_bit(33L,(unsigned long *)(& ks->link_modes.advertising));
    #line 802 
    i40e_get_settings_link_up_fec((unsigned char)((int)hw_link_info->req_fec_info),ks);
    #line 803 
    __set_bit(43L,(unsigned long *)(& ks->link_modes.supported));
    #line 805 
    __set_bit(43L,(unsigned long *)(& ks->link_modes.advertising));
    #line 807 
    __set_bit(44L,(unsigned long *)(& ks->link_modes.supported));
    #line 809 
    __set_bit(44L,(unsigned long *)(& ks->link_modes.advertising));
    #line 811 
    __set_bit(41L,(unsigned long *)(& ks->link_modes.supported));
    #line 813 
    __set_bit(41L,(unsigned long *)(& ks->link_modes.advertising));
    #line 815 
    __set_bit(12L,(unsigned long *)(& ks->link_modes.supported));
    #line 817 
    if (((int)hw_link_info->module_type[2] & 1) != 0 || ((int)hw_link_info->module_type[2] & 2) != 0) {
      #line 821 
      __set_bit(5L,(unsigned long *)(& ks->link_modes.supported));
      #line 823 
      if (((int)hw_link_info->requested_speeds & 4) != 0) 
                                                          #line 825 
                                                          __set_bit(5L,(unsigned long *)(& ks->link_modes.advertising));
    }
    #line 828 
    if (((int)hw_link_info->requested_speeds & 8) != 0) 
                                                        #line 829 
                                                        __set_bit(12L,(unsigned long *)(& ks->link_modes.advertising));
    #line 831 
    break;
    #line 832 
    case (unsigned int)19: 
                           #line 832 
    ;
    #line 833 
    case (unsigned int)49: 
                           #line 833 
    ;
    #line 834 
    case (unsigned int)48: 
                           #line 834 
    ;
    #line 835 
    case (unsigned int)18: 
                           #line 835 
    ;
    #line 836 
    case (unsigned int)17: 
                           #line 836 
    ;
    #line 837 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.supported));
    #line 838 
    __set_bit(12L,(unsigned long *)(& ks->link_modes.supported));
    #line 840 
    __set_bit(48L,(unsigned long *)(& ks->link_modes.supported));
    #line 842 
    __set_bit(47L,(unsigned long *)(& ks->link_modes.supported));
    #line 844 
    __set_bit(5L,(unsigned long *)(& ks->link_modes.supported));
    #line 846 
    __set_bit(3L,(unsigned long *)(& ks->link_modes.supported));
    #line 848 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.advertising));
    #line 849 
    if (((int)hw_link_info->requested_speeds & 8) != 0) 
                                                        #line 850 
                                                        __set_bit(12L,(unsigned long *)(& ks->link_modes.advertising));
    #line 852 
    if (((int)hw_link_info->requested_speeds & 128) != 0) 
                                                          #line 853 
                                                          __set_bit(48L,(unsigned long *)(& ks->link_modes.advertising));
    #line 855 
    if (((int)hw_link_info->requested_speeds & 1) != 0) 
                                                        #line 856 
                                                        __set_bit(47L,(unsigned long *)(& ks->link_modes.advertising));
    #line 858 
    if (((int)hw_link_info->requested_speeds & 4) != 0) 
                                                        #line 859 
                                                        __set_bit(5L,(unsigned long *)(& ks->link_modes.advertising));
    #line 861 
    if (((int)hw_link_info->requested_speeds & 2) != 0) 
                                                        #line 862 
                                                        __set_bit(3L,(unsigned long *)(& ks->link_modes.advertising));
    #line 864 
    break;
    #line 865 
    case (unsigned int)29: 
                           #line 865 
    ;
    #line 866 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.supported));
    #line 867 
    __set_bit(5L,(unsigned long *)(& ks->link_modes.supported));
    #line 869 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.advertising));
    #line 870 
    __set_bit(5L,(unsigned long *)(& ks->link_modes.advertising));
    #line 872 
    break;
    #line 873 
    case (unsigned int)11: 
                           #line 873 
    ;
    #line 874 
    case (unsigned int)23: 
                           #line 874 
    ;
    #line 875 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.supported));
    #line 876 
    __set_bit(12L,(unsigned long *)(& ks->link_modes.supported));
    #line 878 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.advertising));
    #line 879 
    __set_bit(12L,(unsigned long *)(& ks->link_modes.advertising));
    #line 881 
    break;
    #line 882 
    case (unsigned int)5: 
                          #line 882 
    ;
    #line 883 
    case (unsigned int)6: 
                          #line 883 
    ;
    #line 884 
    case (unsigned int)7: 
                          #line 884 
    ;
    #line 885 
    case (unsigned int)22: 
                           #line 885 
    ;
    #line 886 
    case (unsigned int)12: 
                           #line 886 
    ;
    #line 887 
    __set_bit(12L,(unsigned long *)(& ks->link_modes.supported));
    #line 889 
    if (((int)hw_link_info->requested_speeds & 8) != 0) 
                                                        #line 890 
                                                        __set_bit(12L,(unsigned long *)(& ks->link_modes.advertising));
    #line 892 
    break;
    #line 893 
    case (unsigned int)0: 
                          #line 893 
    ;
    #line 894 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.supported));
    #line 895 
    __set_bit(5L,(unsigned long *)(& ks->link_modes.supported));
    #line 897 
    if (((int)hw_link_info->requested_speeds & 4) != 0) 
                                                        #line 898 
                                                        __set_bit(5L,(unsigned long *)(& ks->link_modes.advertising));
    #line 900 
    if (((unsigned long)pf->hw_features & 64UL) != 0UL) {
      #line 901 
      __set_bit(3L,(unsigned long *)(& ks->link_modes.supported));
      #line 903 
      if (((int)hw_link_info->requested_speeds & 2) != 0) 
                                                          #line 905 
                                                          __set_bit(3L,(unsigned long *)(& ks->link_modes.advertising));
    }
    #line 908 
    break;
    #line 909 
    case (unsigned int)4: 
                          #line 909 
    ;
    #line 910 
    case (unsigned int)31: 
                           #line 910 
    ;
    #line 911 
    case (unsigned int)30: 
                           #line 911 
    ;
    #line 912 
    case (unsigned int)3: 
                          #line 912 
    ;
    #line 913 
    case (unsigned int)2: 
                          #line 913 
    ;
    #line 914 
    case (unsigned int)1: 
                          #line 914 
    ;
    #line 915 
    __set_bit(23L,(unsigned long *)(& ks->link_modes.supported));
    #line 917 
    __set_bit(32L,(unsigned long *)(& ks->link_modes.supported));
    #line 919 
    __set_bit(22L,(unsigned long *)(& ks->link_modes.supported));
    #line 921 
    __set_bit(19L,(unsigned long *)(& ks->link_modes.supported));
    #line 923 
    __set_bit(18L,(unsigned long *)(& ks->link_modes.supported));
    #line 925 
    __set_bit(17L,(unsigned long *)(& ks->link_modes.supported));
    #line 927 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.supported));
    #line 928 
    __set_bit(23L,(unsigned long *)(& ks->link_modes.advertising));
    #line 930 
    __set_bit(32L,(unsigned long *)(& ks->link_modes.advertising));
    #line 932 
    i40e_get_settings_link_up_fec((unsigned char)((int)hw_link_info->req_fec_info),ks);
    #line 933 
    __set_bit(22L,(unsigned long *)(& ks->link_modes.advertising));
    #line 935 
    __set_bit(19L,(unsigned long *)(& ks->link_modes.advertising));
    #line 937 
    __set_bit(18L,(unsigned long *)(& ks->link_modes.advertising));
    #line 939 
    __set_bit(17L,(unsigned long *)(& ks->link_modes.advertising));
    #line 941 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.advertising));
    #line 942 
    break;
    #line 943 
    case (unsigned int)32: 
                           #line 943 
    ;
    #line 944 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.supported));
    #line 945 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.advertising));
    #line 946 
    __set_bit(31L,(unsigned long *)(& ks->link_modes.supported));
    #line 948 
    __set_bit(31L,(unsigned long *)(& ks->link_modes.advertising));
    #line 950 
    i40e_get_settings_link_up_fec((unsigned char)((int)hw_link_info->req_fec_info),ks);
    #line 952 
    break;
    #line 953 
    case (unsigned int)35: 
                           #line 953 
    ;
    #line 954 
    case (unsigned int)36: 
                           #line 954 
    ;
    #line 955 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.supported));
    #line 956 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.advertising));
    #line 957 
    __set_bit(31L,(unsigned long *)(& ks->link_modes.supported));
    #line 959 
    __set_bit(31L,(unsigned long *)(& ks->link_modes.advertising));
    #line 961 
    i40e_get_settings_link_up_fec((unsigned char)((int)hw_link_info->req_fec_info),ks);
    #line 963 
    __set_bit(42L,(unsigned long *)(& ks->link_modes.supported));
    #line 965 
    __set_bit(42L,(unsigned long *)(& ks->link_modes.advertising));
    #line 967 
    break;
    #line 968 
    default: 
             #line 968 
    ;
    #line 970 
    netdev_info(netdev,(char *)"WARNING: Link is up but PHY type 0x%x is not recognized.\n",(unsigned int)hw_link_info->phy_type);
  }
  #line 979 
  memset((void *)(& cap_ksettings),0,96UL);
  #line 980 
  i40e_phy_type_to_ethtool(pf,& cap_ksettings);
  #line 981 
  ethtool_intersect_link_masks(ks,& cap_ksettings);
  #line 984 
  switch (link_speed) {
    #line 985 
    case (u32)16: 
                  #line 985 
    ;
    #line 986 
    ks->base.speed = 40000U;
    #line 987 
    break;
    #line 988 
    case (u32)64: 
                  #line 988 
    ;
    #line 989 
    ks->base.speed = 25000U;
    #line 990 
    break;
    #line 991 
    case (u32)32: 
                  #line 991 
    ;
    #line 992 
    ks->base.speed = 20000U;
    #line 993 
    break;
    #line 994 
    case (u32)8: 
                 #line 994 
    ;
    #line 995 
    ks->base.speed = 10000U;
    #line 996 
    break;
    #line 997 
    case (u32)128: 
                   #line 997 
    ;
    #line 998 
    ks->base.speed = 5000U;
    #line 999 
    break;
    #line 1000 
    case (u32)1: 
                 #line 1000 
    ;
    #line 1001 
    ks->base.speed = 2500U;
    #line 1002 
    break;
    #line 1003 
    case (u32)4: 
                 #line 1003 
    ;
    #line 1004 
    ks->base.speed = 1000U;
    #line 1005 
    break;
    #line 1006 
    case (u32)2: 
                 #line 1006 
    ;
    #line 1007 
    ks->base.speed = 100U;
    #line 1008 
    break;
    #line 1009 
    default: 
             #line 1009 
    ;
    #line 1010 
    ks->base.speed = 4294967295U;
    #line 1011 
    break;
  }
  #line 1013 
  ks->base.duplex = (unsigned char)1U;
  #line 1014 
  return;
}

#line 1024  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_settings_link_down(struct i40e_hw *hw, struct ethtool_link_ksettings *ks, struct i40e_pf *pf)
{
  #line 1031 
  i40e_phy_type_to_ethtool(pf,ks);
  #line 1034 
  ks->base.speed = 4294967295U;
  #line 1035 
  ks->base.duplex = (unsigned char)255U;
  #line 1036 
  return;
}

#line 1045  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_link_ksettings(struct net_device *netdev, struct ethtool_link_ksettings *ks)
{
  #line 1048 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1049 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 1050 
  struct i40e_hw *hw = & pf->hw;
  #line 1051 
  struct i40e_link_status *hw_link_info = & hw->phy.link_info;
  #line 1052 
  bool link_up = (_Bool)(((int)hw_link_info->link_info & 1) != 0);
  #line 1054 
  cif_bitmap_zero_0((unsigned long *)(& ks->link_modes.supported),74U);
  #line 1055 
  cif_bitmap_zero_0((unsigned long *)(& ks->link_modes.advertising),74U);
  #line 1057 
  if ((int)link_up != 0) 
                         #line 1058 
                         i40e_get_settings_link_up(hw,ks,netdev,pf); else 
                                                                    #line 1060 
                                                                    i40e_get_settings_link_down(hw,ks,pf);
  #line 1064 
  ks->base.autoneg = (unsigned char)((unsigned int)hw_link_info->an_info & 1U);
  #line 1068 
  switch ((unsigned int)hw->phy.media_type) {
    #line 1069 
    case (unsigned int)3: 
                          #line 1069 
    ;
    #line 1070 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.supported));
    #line 1071 
    __set_bit(16L,(unsigned long *)(& ks->link_modes.supported));
    #line 1072 
    __set_bit(6L,(unsigned long *)(& ks->link_modes.advertising));
    #line 1073 
    __set_bit(16L,(unsigned long *)(& ks->link_modes.advertising));
    #line 1075 
    ks->base.port = (unsigned char)239U;
    #line 1076 
    break;
    #line 1077 
    case (unsigned int)2: 
                          #line 1077 
    ;
    #line 1078 
    __set_bit(7L,(unsigned long *)(& ks->link_modes.supported));
    #line 1079 
    __set_bit(7L,(unsigned long *)(& ks->link_modes.advertising));
    #line 1080 
    ks->base.port = (unsigned char)0U;
    #line 1081 
    break;
    #line 1082 
    case (unsigned int)5: 
                          #line 1082 
    ;
    #line 1083 
    case (unsigned int)4: 
                          #line 1083 
    ;
    #line 1084 
    __set_bit(10L,(unsigned long *)(& ks->link_modes.supported));
    #line 1085 
    __set_bit(10L,(unsigned long *)(& ks->link_modes.advertising));
    #line 1086 
    ks->base.port = (unsigned char)5U;
    #line 1087 
    break;
    #line 1088 
    case (unsigned int)1: 
                          #line 1088 
    ;
    #line 1089 
    __set_bit(10L,(unsigned long *)(& ks->link_modes.supported));
    #line 1090 
    __set_bit(10L,(unsigned long *)(& ks->link_modes.advertising));
    #line 1091 
    ks->base.port = (unsigned char)3U;
    #line 1092 
    break;
    #line 1093 
    case (unsigned int)0: 
                          #line 1093 
    ;
    #line 1094 
    default: 
             #line 1094 
    ;
    #line 1095 
    ks->base.port = (unsigned char)255U;
    #line 1096 
    break;
  }
  #line 1100 
  __set_bit(13L,(unsigned long *)(& ks->link_modes.supported));
  #line 1102 
  switch ((unsigned int)hw->fc.requested_mode) {
    #line 1103 
    case (unsigned int)3: 
                          #line 1103 
    ;
    #line 1104 
    __set_bit(13L,(unsigned long *)(& ks->link_modes.advertising));
    #line 1105 
    break;
    #line 1106 
    case (unsigned int)2: 
                          #line 1106 
    ;
    #line 1107 
    __set_bit(14L,(unsigned long *)(& ks->link_modes.advertising));
    #line 1109 
    break;
    #line 1110 
    case (unsigned int)1: 
                          #line 1110 
    ;
    #line 1111 
    __set_bit(13L,(unsigned long *)(& ks->link_modes.advertising));
    #line 1112 
    __set_bit(14L,(unsigned long *)(& ks->link_modes.advertising));
    #line 1114 
    break;
    #line 1115 
    default: 
             #line 1115 
    ;
    #line 1116 
    __set_bit(13L,(unsigned long *)(& ks->link_modes.advertising));
    #line 1117 
    __set_bit(14L,(unsigned long *)(& ks->link_modes.advertising));
    #line 1119 
    break;
  }
  #line 1122 
  return 0;
}

#line 1132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_link_ksettings(struct net_device *netdev, struct ethtool_link_ksettings *ks)
{
  #line 1136 
  struct i40e_aq_get_phy_abilities_resp abilities;
  #line 1137 
  struct ethtool_link_ksettings safe_ks;
  #line 1138 
  struct ethtool_link_ksettings copy_ks;
  #line 1139 
  struct i40e_aq_set_phy_config config;
  #line 1147 
  u8 autoneg;
  #line 1135 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1140 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 1141 
  struct i40e_vsi *vsi = np->vsi;
  #line 1142 
  struct i40e_hw *hw = & pf->hw;
  #line 1143 
  bool autoneg_changed = (_Bool)0;
  #line 1144 
  i40e_status status = 0;
  #line 1145 
  int timeout = 50;
  #line 1146 
  int err = 0;
  #line 1152 
  if ((unsigned int)hw->partition_id != 1U) {
    #line 1153 
    i40e_partition_setting_complaint(pf);
    #line 1154 
    return -95;
  }
  #line 1156 
  if (*(pf->vsi + (unsigned long)pf->lan_vsi) != vsi) 
                                                      #line 1157 
                                                      return -95;
  #line 1160 
  if (((unsigned int)hw->phy.media_type + 4294967295U > 2U && hw->phy.media_type != (unsigned int)I40E_MEDIA_TYPE_DA) && ((int)hw->phy.link_info.link_info & 1) != 0) 
    #line 1163 
    return -95;
  #line 1164 
  if (((((unsigned int)hw->device_id + 60032U <= 1U || (unsigned int)hw->device_id == 5511U) || (unsigned int)hw->device_id == 5512U) || (unsigned int)hw->device_id == 5514U) || (unsigned int)hw->device_id == 14286U) {
    #line 1170 
    netdev_info(netdev,(char *)"Changing settings is not supported on backplane.\n");
    #line 1171 
    return -95;
  }
  #line 1175 
  memcpy((void *)(& copy_ks),(void *)ks,96UL);
  #line 1178 
  autoneg = copy_ks.base.autoneg;
  #line 1181 
  memset((void *)(& safe_ks),0,96UL);
  #line 1182 
  safe_ks.base.cmd = copy_ks.base.cmd;
  #line 1183 
  safe_ks.base.link_mode_masks_nwords = copy_ks.base.link_mode_masks_nwords;
  #line 1185 
  i40e_get_link_ksettings(netdev,& safe_ks);
  #line 1190 
  if (bitmap_subset((unsigned long *)(& copy_ks.link_modes.advertising),
                      (unsigned long *)(& safe_ks.link_modes.supported),74U) == 0) 
    #line 1193 
    return -22;
  #line 1196 
  copy_ks.base.autoneg = safe_ks.base.autoneg;
  #line 1201 
  if (memcmp((void *)(& copy_ks.base),(void *)(& safe_ks.base),48UL) != 0) 
    #line 1203 
    return -95;
  #line 1205 
  while (1) {
    #line 1205 
    if (! ((int)test_and_set_bit(1L,(unsigned long *)(& pf->state)) != 0)) 
      #line 1205 
      break;
    #line 1206 
    timeout --;
    #line 1207 
    if (timeout == 0) 
                      #line 1208 
                      return -16;
    #line 1209 
    usleep_range(1000UL,2000UL);
  }
  #line 1213 
  status = i40e_aq_get_phy_capabilities(hw,(_Bool)0,(_Bool)0,& abilities,(struct i40e_asq_cmd_details *)0);
  #line 1215 
  if (status != I40E_SUCCESS) {
    #line 1216 
    err = -11;
    #line 1217 
    goto done;
  }
  #line 1223 
  memset((void *)(& config),0,16UL);
  #line 1224 
  config.abilities = abilities.abilities;
  #line 1227 
  if ((unsigned int)autoneg == 1U) {
    #line 1229 
    if (((int)hw->phy.link_info.an_info & 1) == 0) {
      #line 1231 
      if (! test_bit(6L,(unsigned long *)(& safe_ks.link_modes.supported))) {
        #line 1234 
        netdev_info(netdev,(char *)"Autoneg not supported on this phy\n");
        #line 1235 
        err = -22;
        #line 1236 
        goto done;
      }
      #line 1239 
      config.abilities = (unsigned char)((unsigned int)abilities.abilities | 16U);
      #line 1241 
      autoneg_changed = (_Bool)1;
    }
  }
  else 
    #line 1245 
    if (((int)hw->phy.link_info.an_info & 1) != 0) {
      #line 1249 
      if ((int)test_bit(6L,(unsigned long *)(& safe_ks.link_modes.supported)) != 0) 
        #line 1251 
        if (hw->phy.link_info.phy_type != (unsigned int)I40E_PHY_TYPE_10GBASE_T) {
          #line 1254 
          netdev_info(netdev,(char *)"Autoneg cannot be disabled on this phy\n");
          #line 1255 
          err = -22;
          #line 1256 
          goto done;
        }
      #line 1259 
      config.abilities = (unsigned char)((unsigned int)abilities.abilities & 239U);
      #line 1261 
      autoneg_changed = (_Bool)1;
    }
  #line 1265 
  if ((int)test_bit(3L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
    #line 1267 
    config.link_speed = (unsigned char)((unsigned int)config.link_speed | 2U);
  #line 1268 
  if ((int)test_bit(5L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
    #line 1274 
    config.link_speed = (unsigned char)((unsigned int)config.link_speed | 4U);
  else {
    #line 1269 
    if ((int)test_bit(41L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
      #line 1274 
      config.link_speed = (unsigned char)((unsigned int)config.link_speed | 4U);
    else {
      #line 1271 
      if ((int)test_bit(17L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
        #line 1274 
        config.link_speed = (unsigned char)((unsigned int)config.link_speed | 4U);
    }
  }
  #line 1275 
  if ((int)test_bit(12L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
    #line 1287 
    config.link_speed = (unsigned char)((unsigned int)config.link_speed | 8U);
  else {
    #line 1276 
    if ((int)test_bit(18L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
      #line 1287 
      config.link_speed = (unsigned char)((unsigned int)config.link_speed | 8U);
    else {
      #line 1278 
      if ((int)test_bit(19L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
        #line 1287 
        config.link_speed = (unsigned char)((unsigned int)config.link_speed | 8U);
      else {
        #line 1280 
        if ((int)test_bit(42L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
          #line 1287 
          config.link_speed = (unsigned char)((unsigned int)config.link_speed | 8U);
        else {
          #line 1282 
          if ((int)test_bit(43L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
            #line 1287 
            config.link_speed = (unsigned char)((unsigned int)config.link_speed | 8U);
          else {
            #line 1284 
            if ((int)test_bit(44L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
              #line 1287 
              config.link_speed = (unsigned char)((unsigned int)config.link_speed | 8U);
          }
        }
      }
    }
  }
  #line 1288 
  if ((int)test_bit(47L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
    #line 1290 
    config.link_speed = (unsigned char)((unsigned int)config.link_speed | 1U);
  #line 1291 
  if ((int)test_bit(48L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
    #line 1293 
    config.link_speed = (unsigned char)((unsigned int)config.link_speed | 128U);
  #line 1294 
  if ((int)test_bit(22L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
    #line 1296 
    config.link_speed = (unsigned char)((unsigned int)config.link_speed | 32U);
  #line 1297 
  if ((int)test_bit(31L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
    #line 1303 
    config.link_speed = (unsigned char)((unsigned int)config.link_speed | 64U);
  else {
    #line 1298 
    if ((int)test_bit(32L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
      #line 1303 
      config.link_speed = (unsigned char)((unsigned int)config.link_speed | 64U);
    else {
      #line 1300 
      if ((int)test_bit(33L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
        #line 1303 
        config.link_speed = (unsigned char)((unsigned int)config.link_speed | 64U);
    }
  }
  #line 1304 
  if ((int)test_bit(23L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
    #line 1312 
    config.link_speed = (unsigned char)((unsigned int)config.link_speed | 16U);
  else {
    #line 1305 
    if ((int)test_bit(24L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
      #line 1312 
      config.link_speed = (unsigned char)((unsigned int)config.link_speed | 16U);
    else {
      #line 1307 
      if ((int)test_bit(25L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
        #line 1312 
        config.link_speed = (unsigned char)((unsigned int)config.link_speed | 16U);
      else {
        #line 1309 
        if ((int)test_bit(26L,(unsigned long *)(& ks->link_modes.advertising)) != 0) 
          #line 1312 
          config.link_speed = (unsigned char)((unsigned int)config.link_speed | 16U);
      }
    }
  }
  #line 1318 
  if ((unsigned int)config.link_speed == 0U) 
                                             #line 1319 
                                             config.link_speed = abilities.link_speed;
  #line 1320 
  if ((int)autoneg_changed != 0 || (int)abilities.link_speed != (int)config.link_speed) {
    #line 1322 
    config.phy_type = abilities.phy_type;
    #line 1323 
    config.phy_type_ext = abilities.phy_type_ext;
    #line 1324 
    config.eee_capability = abilities.eee_capability;
    #line 1325 
    config.eeer = abilities.eeer_val;
    #line 1326 
    config.low_power_ctrl = abilities.d3_lpan;
    #line 1327 
    config.fec_config = (unsigned char)((unsigned int)abilities.fec_cfg_curr_mod_ext_info & 31U);
    #line 1331 
    hw->phy.link_info.requested_speeds = config.link_speed;
    #line 1333 
    config.abilities = (unsigned char)((unsigned int)config.abilities | 32U);
    #line 1335 
    if (((int)hw->phy.link_info.link_info & 1) != 0) {
      #line 1339 
      i40e_print_link_message(vsi,(_Bool)0);
      #line 1340 
      netif_carrier_off(netdev);
      #line 1341 
      netif_tx_stop_all_queues(netdev);
    }
    #line 1345 
    status = i40e_aq_set_phy_config(hw,& config,(struct i40e_asq_cmd_details *)0);
    #line 1346 
    if (status != I40E_SUCCESS) {
      #line 1347 
      ;
      #line 1347 
      netdev_info(netdev,(char *)"Set phy config failed, err %s aq_err %s\n",i40e_stat_str(hw,status),i40e_aq_str(hw,hw->aq.asq_last_status));
      #line 1351 
      err = -11;
      #line 1352 
      goto done;
    }
    #line 1355 
    status = i40e_update_link_info(hw);
    #line 1356 
    if (status != I40E_SUCCESS) {
      #line 1357 
      bool branch;
      #line 1357 
      struct _ddebug __UNIQUE_ID_ddebug559 = {.modname = (char *)"i40e", .function = (char *)"i40e_set_link_ksettings", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c", .format = (char *)"Updating link info failed with err %s aq_err %s\n", .lineno = (unsigned int)1357U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1357 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug559.key.dd_key_false.key,(_Bool)0);
      #line 1357 
      if ((long)((long)((int)branch != 0)) != 0L) {
        #line 1357 
        ;
        #line 1357 
        __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug559,netdev,(char *)"Updating link info failed with err %s aq_err %s\n",i40e_stat_str(hw,status),i40e_aq_str(hw,hw->aq.asq_last_status));
      }
    }
  }
  else 
       #line 1363 
       netdev_info(netdev,(char *)"Nothing changed, exiting without setting anything.\n");
  #line 1366 
  done: 
        #line 1366 
  ;
  #line 1367 
  cif_clear_bit_4(1L,(unsigned long *)(& pf->state));
  #line 1369 
  return err;
}

#line 1372  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_fec_cfg(struct net_device *netdev, u8 fec_cfg)
{
  #line 1383 
  union __anonunion___u_19577 __u;
  #line 1375 
  struct i40e_aq_get_phy_abilities_resp abilities;
  #line 1374 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1376 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 1377 
  struct i40e_hw *hw = & pf->hw;
  #line 1378 
  i40e_status status = 0;
  #line 1379 
  u32 flags = 0U;
  #line 1380 
  int err = 0;
  #line 1382 
  __read_once_size((void *)(& pf->flags),(void *)(& __u.__c),4);
  #line 1382 
  flags = (__u.__val);
  #line 1383 
  i40e_set_fec_in_flags((unsigned char)((int)fec_cfg),& flags);
  #line 1386 
  memset((void *)(& abilities),0,536UL);
  #line 1387 
  status = i40e_aq_get_phy_capabilities(hw,(_Bool)0,(_Bool)0,& abilities,(struct i40e_asq_cmd_details *)0);
  #line 1389 
  if (status != I40E_SUCCESS) {
    #line 1390 
    err = -11;
    #line 1391 
    goto done;
  }
  #line 1394 
  if ((int)abilities.fec_cfg_curr_mod_ext_info != (int)fec_cfg) {
    #line 1395 
    struct i40e_aq_set_phy_config config;
    #line 1397 
    memset((void *)(& config),0,16UL);
    #line 1398 
    config.phy_type = abilities.phy_type;
    #line 1399 
    config.abilities = abilities.abilities;
    #line 1400 
    config.phy_type_ext = abilities.phy_type_ext;
    #line 1401 
    config.link_speed = abilities.link_speed;
    #line 1402 
    config.eee_capability = abilities.eee_capability;
    #line 1403 
    config.eeer = abilities.eeer_val;
    #line 1404 
    config.low_power_ctrl = abilities.d3_lpan;
    #line 1405 
    config.fec_config = (unsigned char)((unsigned int)fec_cfg & 31U);
    #line 1406 
    status = i40e_aq_set_phy_config(hw,& config,(struct i40e_asq_cmd_details *)0);
    #line 1407 
    if (status != I40E_SUCCESS) {
      #line 1408 
      ;
      #line 1408 
      netdev_info(netdev,(char *)"Set phy config failed, err %s aq_err %s\n",i40e_stat_str(hw,status),i40e_aq_str(hw,hw->aq.asq_last_status));
      #line 1412 
      err = -11;
      #line 1413 
      goto done;
    }
    #line 1415 
    pf->flags = flags;
    #line 1416 
    status = i40e_update_link_info(hw);
    #line 1417 
    if (status != I40E_SUCCESS) {
      #line 1422 
      bool branch;
      #line 1422 
      struct _ddebug __UNIQUE_ID_ddebug560 = {.modname = (char *)"i40e", .function = (char *)"i40e_set_fec_cfg", .filename = (char *)"/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c", .format = (char *)"Updating link info failed with err %s aq_err %s\n", .lineno = (unsigned int)1422U, .flags = (unsigned int)0U, .key = {.dd_key_false = {.key = {.enabled = {.counter = 0}, .__anonCompField_static_key_4 = {.entries = (struct jump_entry *)0}}}}};
      #line 1422 
      branch = arch_static_branch(& __UNIQUE_ID_ddebug560.key.dd_key_false.key,(_Bool)0);
      #line 1422 
      if ((long)((long)((int)branch != 0)) != 0L) {
        #line 1422 
        ;
        #line 1422 
        __dynamic_netdev_dbg(& __UNIQUE_ID_ddebug560,netdev,(char *)"Updating link info failed with err %s aq_err %s\n",i40e_stat_str(hw,status),i40e_aq_str(hw,hw->aq.asq_last_status));
      }
    }
  }
  #line 1428 
  done: 
        #line 1428 
  ;
  #line 1429 
  return err;
}

#line 1432  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_fec_param(struct net_device *netdev, struct ethtool_fecparam *fecparam)
{
  #line 1436 
  struct i40e_aq_get_phy_abilities_resp abilities;
  #line 1441 
  u8 fec_cfg;
  #line 1435 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1437 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 1438 
  struct i40e_hw *hw = & pf->hw;
  #line 1439 
  i40e_status status = 0;
  #line 1440 
  int err = 0;
  #line 1444 
  memset((void *)(& abilities),0,536UL);
  #line 1445 
  status = i40e_aq_get_phy_capabilities(hw,(_Bool)0,(_Bool)0,& abilities,(struct i40e_asq_cmd_details *)0);
  #line 1447 
  if (status != I40E_SUCCESS) {
    #line 1448 
    err = -11;
    #line 1449 
    goto done;
  }
  #line 1452 
  fecparam->fec = 0U;
  #line 1453 
  fec_cfg = abilities.fec_cfg_curr_mod_ext_info;
  #line 1454 
  if (((unsigned long)fec_cfg & 16UL) != 0UL) 
                                              #line 1455 
                                              fecparam->fec |= 2U;
  else 
    #line 1456 
    if (((unsigned long)fec_cfg & 10UL) != 0UL) 
                                                #line 1458 
                                                fecparam->fec |= 8U;
    else 
      #line 1459 
      if (((unsigned long)fec_cfg & 5UL) != 0UL) 
                                                 #line 1461 
                                                 fecparam->fec |= 16U;
  #line 1462 
  if ((unsigned int)fec_cfg == 0U) 
                                   #line 1463 
                                   fecparam->fec |= 4U;
  #line 1465 
  if (((int)hw->phy.link_info.fec_info & 1) != 0) 
                                                  #line 1466 
                                                  fecparam->active_fec = 16U;
  else 
    #line 1467 
    if (((int)hw->phy.link_info.fec_info & 2) != 0) 
                                                    #line 1468 
                                                    fecparam->active_fec = 8U; else 
                                                                    #line 1470 
                                                                    fecparam->active_fec = 4U;
  #line 1471 
  done: 
        #line 1471 
  ;
  #line 1472 
  return err;
}

#line 1475  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_fec_param(struct net_device *netdev, struct ethtool_fecparam *fecparam)
{
  #line 1478 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1479 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 1480 
  struct i40e_hw *hw = & pf->hw;
  #line 1481 
  u8 fec_cfg = (unsigned char)0U;
  #line 1482 
  int err = 0;
  #line 1484 
  if ((unsigned int)hw->device_id + 60022U > 1U) {
    #line 1486 
    err = -1;
    #line 1487 
    goto done;
  }
  #line 1490 
  switch (fecparam->fec) {
    #line 1491 
    case (__u32)2: 
                   #line 1491 
    ;
    #line 1492 
    fec_cfg = (unsigned char)16U;
    #line 1493 
    break;
    #line 1494 
    case (__u32)8: 
                   #line 1494 
    ;
    #line 1495 
    fec_cfg = (unsigned char)10U;
    #line 1497 
    break;
    #line 1498 
    case (__u32)16: 
                    #line 1498 
    ;
    #line 1499 
    fec_cfg = (unsigned char)5U;
    #line 1501 
    break;
    #line 1502 
    case (__u32)4: 
                   #line 1502 
    ;
    #line 1503 
    case (__u32)1: 
                   #line 1503 
    ;
    #line 1504 
    fec_cfg = (unsigned char)0U;
    #line 1505 
    break;
    #line 1506 
    default: 
             #line 1506 
    ;
    #line 1507 
    _dev_warn(& (pf->pdev)->dev,(char *)"Unsupported FEC mode: %d",fecparam->fec);
    #line 1509 
    err = -22;
    #line 1510 
    goto done;
  }
  #line 1513 
  err = i40e_set_fec_cfg(netdev,(unsigned char)((int)fec_cfg));
  #line 1515 
  done: 
        #line 1515 
  ;
  #line 1516 
  return err;
}

#line 1519  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_nway_reset(struct net_device *netdev)
{
  #line 1522 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1523 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 1524 
  struct i40e_hw *hw = & pf->hw;
  #line 1525 
  bool link_up = (_Bool)(((int)hw->phy.link_info.link_info & 1) != 0);
  #line 1526 
  i40e_status ret = 0;
  #line 1528 
  ret = i40e_aq_set_link_restart_an(hw,(_Bool)((bool)((int)link_up) != 0),(struct i40e_asq_cmd_details *)0);
  #line 1529 
  if (ret != I40E_SUCCESS) {
    #line 1530 
    ;
    #line 1530 
    netdev_info(netdev,(char *)"link restart failed, err %s aq_err %s\n",i40e_stat_str(hw,ret),i40e_aq_str(hw,hw->aq.asq_last_status));
    #line 1533 
    return -5;
  }
  #line 1536 
  return 0;
}

#line 1546  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
{
  #line 1549 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1550 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 1551 
  struct i40e_hw *hw = & pf->hw;
  #line 1552 
  struct i40e_link_status *hw_link_info = & hw->phy.link_info;
  #line 1553 
  struct i40e_dcbx_config *dcbx_cfg = & hw->local_dcbx_config;
  #line 1555 
  pause->autoneg = (unsigned int)hw_link_info->an_info & 1U;
  #line 1560 
  if ((unsigned int)dcbx_cfg->pfc.pfcenable != 0U) {
    #line 1561 
    pause->rx_pause = 0U;
    #line 1562 
    pause->tx_pause = 0U;
    #line 1563 
    return;
  }
  #line 1566 
  if (hw->fc.current_mode == (unsigned int)I40E_FC_RX_PAUSE) 
                                                             #line 1567 
                                                             pause->rx_pause = 1U;
  else 
    #line 1568 
    if (hw->fc.current_mode == (unsigned int)I40E_FC_TX_PAUSE) 
                                                               #line 1569 
                                                               pause->tx_pause = 1U;
    else 
      #line 1570 
      if (hw->fc.current_mode == (unsigned int)I40E_FC_FULL) {
        #line 1571 
        pause->rx_pause = 1U;
        #line 1572 
        pause->tx_pause = 1U;
      }
  #line 1574 
  return;
}

#line 1581  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
{
  #line 1591 
  i40e_status status;
  #line 1592 
  u8 aq_failures;
  #line 1594 
  u32 is_an;
  #line 1584 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1585 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 1586 
  struct i40e_vsi *vsi = np->vsi;
  #line 1587 
  struct i40e_hw *hw = & pf->hw;
  #line 1588 
  struct i40e_link_status *hw_link_info = & hw->phy.link_info;
  #line 1589 
  struct i40e_dcbx_config *dcbx_cfg = & hw->local_dcbx_config;
  #line 1590 
  bool link_up = (_Bool)(((int)hw_link_info->link_info & 1) != 0);
  #line 1593 
  int err = 0;
  #line 1599 
  if ((unsigned int)hw->partition_id != 1U) {
    #line 1600 
    i40e_partition_setting_complaint(pf);
    #line 1601 
    return -95;
  }
  #line 1604 
  if (*(pf->vsi + (unsigned long)pf->lan_vsi) != vsi) 
                                                      #line 1605 
                                                      return -95;
  #line 1607 
  is_an = (unsigned int)hw_link_info->an_info & 1U;
  #line 1608 
  if (pause->autoneg != is_an) {
    #line 1609 
    netdev_info(netdev,(char *)"To change autoneg please use: ethtool -s <dev> autoneg <on|off>\n");
    #line 1610 
    return -95;
  }
  #line 1614 
  if (! test_bit(3L,(unsigned long *)(& pf->state))) 
    #line 1614 
    if (is_an == 0U) 
                     #line 1616 
                     netdev_info(netdev,(char *)"Autoneg did not complete so changing settings may not result in an actual change.\n");
  #line 1619 
  if ((unsigned int)dcbx_cfg->pfc.pfcenable != 0U) {
    #line 1620 
    netdev_info(netdev,(char *)"Priority flow control enabled. Cannot set link flow control.\n");
    #line 1622 
    return -95;
  }
  #line 1625 
  if (pause->rx_pause != 0U && pause->tx_pause != 0U) 
                                                      #line 1626 
                                                      hw->fc.requested_mode = I40E_FC_FULL;
  else 
    #line 1627 
    if (pause->rx_pause != 0U && pause->tx_pause == 0U) 
                                                        #line 1628 
                                                        hw->fc.requested_mode = I40E_FC_RX_PAUSE;
    else 
      #line 1629 
      if (pause->rx_pause == 0U && pause->tx_pause != 0U) 
                                                          #line 1630 
                                                          hw->fc.requested_mode = I40E_FC_TX_PAUSE;
      else 
        #line 1631 
        if (pause->rx_pause == 0U && pause->tx_pause == 0U) 
                                                            #line 1632 
                                                            hw->fc.requested_mode = I40E_FC_NONE; else 
                                                                    #line 1634 
                                                                    return -22;
  #line 1639 
  i40e_print_link_message(vsi,(_Bool)0);
  #line 1640 
  netif_carrier_off(netdev);
  #line 1641 
  netif_tx_stop_all_queues(netdev);
  #line 1644 
  status = i40e_set_fc(hw,& aq_failures,(_Bool)((bool)((int)link_up) != 0));
  #line 1646 
  if (((int)aq_failures & 1) != 0) {
    #line 1647 
    ;
    #line 1647 
    netdev_info(netdev,(char *)"Set fc failed on the get_phy_capabilities call with err %s aq_err %s\n",i40e_stat_str(hw,status),i40e_aq_str(hw,hw->aq.asq_last_status));
    #line 1650 
    err = -11;
  }
  #line 1652 
  if (((int)aq_failures & 2) != 0) {
    #line 1653 
    ;
    #line 1653 
    netdev_info(netdev,(char *)"Set fc failed on the set_phy_config call with err %s aq_err %s\n",i40e_stat_str(hw,status),i40e_aq_str(hw,hw->aq.asq_last_status));
    #line 1656 
    err = -11;
  }
  #line 1658 
  if (((int)aq_failures & 4) != 0) {
    #line 1659 
    ;
    #line 1659 
    netdev_info(netdev,(char *)"Set fc failed on the get_link_info call with err %s aq_err %s\n",i40e_stat_str(hw,status),i40e_aq_str(hw,hw->aq.asq_last_status));
    #line 1662 
    err = -11;
  }
  #line 1665 
  if (! test_bit(3L,(unsigned long *)(& pf->state))) 
    #line 1665 
    if (is_an != 0U) {
      #line 1667 
      msleep(75U);
      #line 1668 
      if (! test_bit(3L,(unsigned long *)(& pf->state))) {
        #line 1669 
        return i40e_nway_reset(netdev);
      }
    }
  #line 1672 
  return err;
}

#line 1675  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u32 i40e_get_msglevel(struct net_device *netdev)
{
  #line 1677 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1678 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 1679 
  u32 debug_mask = pf->hw.debug_mask;
  #line 1681 
  if (debug_mask != 0U) 
                        #line 1682 
                        netdev_info(netdev,(char *)"i40e debug_mask: 0x%08X\n",debug_mask);
  #line 1684 
  return pf->msg_enable;
}

#line 1687  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_set_msglevel(struct net_device *netdev, u32 data)
{
  #line 1689 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1690 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 1692 
  if ((data & 4026531840U) != 0U) 
                                  #line 1693 
                                  pf->hw.debug_mask = data; else 
                                                                 #line 1695 
                                                                 pf->msg_enable = data;
  #line 1696 
  return;
}

#line 1698  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_regs_len(struct net_device *netdev)
{
  #line 1701 
  int i;
  #line 1700 
  int reg_count = 0;
  #line 1703 
  i = 0;
  #line 1703 
  while (i40e_reg_list[i].offset != 0U) {
    #line 1704 
    reg_count = (int)(i40e_reg_list[i].elements + (unsigned int)reg_count);
    #line 1703 
    i ++;
  }
  #line 1706 
  return (int)((unsigned long)reg_count * (unsigned long)4U);
}

#line 1709  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_regs(struct net_device *netdev, struct ethtool_regs *regs, void *p)
{
  #line 1716 
  unsigned int i;
  #line 1716 
  unsigned int j;
  #line 1716 
  unsigned int ri;
  #line 1717 
  u32 reg;
  #line 1712 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1713 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 1714 
  struct i40e_hw *hw = & pf->hw;
  #line 1715 
  u32 *reg_buf = (u32 *)p;
  #line 1726 
  regs->version = 1U;
  #line 1729 
  ri = 0U;
  #line 1730 
  i = 0U;
  #line 1730 
  while (i40e_reg_list[i].offset != 0U) {
    #line 1731 
    j = 0U;
    #line 1731 
    while (i40e_reg_list[i].elements > j) {
      {
        #line 1734 
        unsigned int tmp_0;
        #line 1732 
        reg = i40e_reg_list[i].offset + i40e_reg_list[i].stride * j;
        #line 1734 
        tmp_0 = ri;
        #line 1734 
        ri ++;
        #line 1734 
        *(reg_buf + (unsigned long)tmp_0) = readl((void *)(hw->hw_addr + (unsigned long)reg));
      }
      #line 1731 
      j ++;
    }
    #line 1730 
    i ++;
  }
  #line 1737 
  return;
}

#line 1740  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_eeprom(struct net_device *netdev, struct ethtool_eeprom *eeprom, u8 *bytes)
{
  #line 1746 
  int len;
  #line 1746 
  int offset;
  #line 1747 
  u8 *eeprom_buff;
  #line 1748 
  u16 i;
  #line 1748 
  u16 sectors;
  #line 1749 
  bool last;
  #line 1750 
  u32 magic;
  #line 1743 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1744 
  struct i40e_hw *hw = & ((np->vsi)->back)->hw;
  #line 1745 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 1746 
  int ret_val = 0;
  #line 1753 
  if (eeprom->len == 0U) 
                         #line 1754 
                         return -22;
  #line 1757 
  magic = (unsigned int)((int)hw->vendor_id | ((int)hw->device_id << 16));
  #line 1758 
  if (eeprom->magic != 0U && eeprom->magic != magic) {
    #line 1759 
    struct i40e_nvm_access *cmd = (struct i40e_nvm_access *)eeprom;
    #line 1760 
    int errno = 0;
    #line 1763 
    if (eeprom->magic >> 16 != (unsigned int)hw->device_id) 
                                                            #line 1764 
                                                            errno = -22;
    else {
      #line 1765 
      if ((int)test_bit(8L,(unsigned long *)(& pf->state)) != 0) 
                                                                 #line 1765 
                                                                 goto _LOR;
      else {
        #line 1765 
        if ((int)test_bit(11L,(unsigned long *)(& pf->state)) != 0) 
                                                                    #line 1765 
                                                                    _LOR: 
                                                                    #line 1767 
                                                                    errno = -16;
        else {
          #line 1769 
          ret_val = (int)i40e_nvmupd_command(hw,cmd,bytes,& errno);
        }
      }
    }
    #line 1771 
    if ((errno != 0 || ret_val != 0) && (hw->debug_mask & 128U) != 0U) 
      #line 1772 
      _dev_info(& (pf->pdev)->dev,(char *)"NVMUpdate read failed err=%d status=0x%x errno=%d module=%d offset=0x%x size=%d\n",ret_val,(unsigned int)hw->aq.asq_last_status,errno,(int)((unsigned char)cmd->config),cmd->offset,cmd->data_size);
    #line 1778 
    return errno;
  }
  #line 1782 
  eeprom->magic = (unsigned int)((int)hw->vendor_id | ((int)hw->device_id << 16));
  #line 1784 
  eeprom_buff = (u8 *)kzalloc_5((unsigned long)eeprom->len,3264U);
  #line 1785 
  if (eeprom_buff == (u8 *)0U) 
                               #line 1786 
                               return -12;
  #line 1788 
  ret_val = (int)i40e_acquire_nvm(hw,
                         (enum i40e_aq_resource_access_type)I40E_RESOURCE_READ);
  #line 1789 
  if (ret_val != 0) {
    #line 1790 
    _dev_info(& (pf->pdev)->dev,(char *)"Failed Acquiring NVM resource for read err=%d status=0x%x\n",ret_val,(unsigned int)hw->aq.asq_last_status);
    #line 1793 
    goto free_buff;
  }
  #line 1796 
  sectors = (unsigned short)(eeprom->len / 4096U);
  #line 1797 
  sectors = (unsigned short)(((eeprom->len & 4095U) != 0U) + (int)sectors);
  #line 1798 
  len = 4096;
  #line 1799 
  last = (_Bool)0;
  #line 1800 
  i = (unsigned short)0U;
  #line 1800 
  while ((int)i < (int)sectors) {
    {
      #line 1801 
      if ((int)i == (int)sectors + -1) {
        #line 1802 
        len = (int)(eeprom->len - (unsigned int)((int)i * 4096));
        #line 1803 
        last = (_Bool)1;
      }
      #line 1805 
      offset = (int)(eeprom->offset + (unsigned int)((int)i * 4096));
      #line 1805 
      ret_val = (int)i40e_aq_read_nvm(hw,(unsigned char)0,(unsigned int)offset,
                         (unsigned short)((int)((unsigned short)len)),
                         (void *)(eeprom_buff + (unsigned long)((int)i * 4096)),
                         (_Bool)((bool)((int)last) != 0),
                         (struct i40e_asq_cmd_details *)0);
      #line 1809 
      if (ret_val != 0 && hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_EPERM) {
        #line 1810 
        _dev_info(& (pf->pdev)->dev,(char *)"read NVM failed, invalid offset 0x%x\n",offset);
        #line 1813 
        break;
      }
      else 
        #line 1814 
        if (ret_val != 0 && hw->aq.asq_last_status == (unsigned int)I40E_AQ_RC_EACCES) {
          #line 1816 
          _dev_info(& (pf->pdev)->dev,(char *)"read NVM failed, access, offset 0x%x\n",offset);
          #line 1819 
          break;
        }
        else 
          #line 1820 
          if (ret_val != 0) {
            #line 1821 
            _dev_info(& (pf->pdev)->dev,(char *)"read NVM failed offset %d err=%d status=0x%x\n",offset,ret_val,(unsigned int)hw->aq.asq_last_status);
            #line 1824 
            break;
          }
    }
    #line 1800 
    i = (u16)((int)i + 1);
  }
  #line 1828 
  i40e_release_nvm(hw);
  #line 1829 
  memcpy((void *)bytes,(void *)eeprom_buff,(unsigned long)eeprom->len);
  #line 1830 
  free_buff: 
             #line 1830 
  ;
  #line 1831 
  kfree((void *)eeprom_buff);
  #line 1832 
  return ret_val;
}

#line 1835  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_eeprom_len(struct net_device *netdev)
{
  #line 1839 
  u32 val;
  #line 1837 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1838 
  struct i40e_hw *hw = & ((np->vsi)->back)->hw;
  #line 1842 
  if (hw->mac.type == (unsigned int)I40E_MAC_X722) {
    #line 1843 
    val = 6004736U;
    #line 1844 
    return (int)val;
  }
  #line 1846 
  val = (readl((void *)(hw->hw_addr + 779396U)) >> 6) & 7U;
  #line 1850 
  val = (unsigned int)(65536UL << val);
  #line 1851 
  return (int)val;
}

#line 1854  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_eeprom(struct net_device *netdev, struct ethtool_eeprom *eeprom, u8 *bytes)
{
  #line 1863 
  u32 magic;
  #line 1857 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1858 
  struct i40e_hw *hw = & ((np->vsi)->back)->hw;
  #line 1859 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 1860 
  struct i40e_nvm_access *cmd = (struct i40e_nvm_access *)eeprom;
  #line 1861 
  int ret_val = 0;
  #line 1862 
  int errno = 0;
  #line 1866 
  magic = (unsigned int)((int)hw->vendor_id | ((int)hw->device_id << 16));
  #line 1867 
  if (eeprom->magic == magic) 
                              #line 1868 
                              errno = -95;
  else 
    #line 1870 
    if (eeprom->magic == 0U || eeprom->magic >> 16 != (unsigned int)hw->device_id) 
      #line 1871 
      errno = -22;
    else {
      #line 1872 
      if ((int)test_bit(8L,(unsigned long *)(& pf->state)) != 0) 
                                                                 #line 1872 
                                                                 goto _LOR;
      else {
        #line 1872 
        if ((int)test_bit(11L,(unsigned long *)(& pf->state)) != 0) 
                                                                    #line 1872 
                                                                    _LOR: 
                                                                    #line 1874 
                                                                    errno = -16;
        else {
          #line 1876 
          ret_val = (int)i40e_nvmupd_command(hw,cmd,bytes,& errno);
        }
      }
    }
  #line 1878 
  if ((errno != 0 || ret_val != 0) && (hw->debug_mask & 128U) != 0U) 
    #line 1879 
    _dev_info(& (pf->pdev)->dev,(char *)"NVMUpdate write failed err=%d status=0x%x errno=%d module=%d offset=0x%x size=%d\n",ret_val,(unsigned int)hw->aq.asq_last_status,errno,(int)((unsigned char)cmd->config),cmd->offset,cmd->data_size);
  #line 1885 
  return errno;
}

#line 1888  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)
{
  #line 1891 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1892 
  struct i40e_vsi *vsi = np->vsi;
  #line 1893 
  struct i40e_pf *pf = vsi->back;
  #line 1895 
  strlcpy((char *)(& drvinfo->driver),(char *)(& i40e_driver_name),32UL);
  #line 1896 
  strlcpy((char *)(& drvinfo->version),(char *)(& i40e_driver_version_str),32UL);
  #line 1898 
  ;
  #line 1898 
  strlcpy((char *)(& drvinfo->fw_version),i40e_nvm_version_str(& pf->hw),32UL);
  #line 1900 
  ;
  #line 1900 
  strlcpy((char *)(& drvinfo->bus_info),pci_name(pf->pdev),32UL);
  #line 1902 
  drvinfo->n_priv_flags = 11U;
  #line 1903 
  if ((unsigned int)pf->hw.pf_id == 0U) 
                                        #line 1904 
                                        (drvinfo->n_priv_flags) ++;
  #line 1905 
  return;
}

#line 1907  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_ringparam(struct net_device *netdev, struct ethtool_ringparam *ring)
{
  #line 1910 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1911 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 1912 
  struct i40e_vsi *vsi = *(pf->vsi + (unsigned long)pf->lan_vsi);
  #line 1914 
  ring->rx_max_pending = 4096U;
  #line 1915 
  ring->tx_max_pending = 4096U;
  #line 1916 
  ring->rx_mini_max_pending = 0U;
  #line 1917 
  ring->rx_jumbo_max_pending = 0U;
  #line 1918 
  ring->rx_pending = (unsigned int)(*(vsi->rx_rings))->count;
  #line 1919 
  ring->tx_pending = (unsigned int)(*(vsi->tx_rings))->count;
  #line 1920 
  ring->rx_mini_pending = 0U;
  #line 1921 
  ring->rx_jumbo_pending = 0U;
  #line 1922 
  return;
}

#line 1924  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static bool i40e_active_tx_ring_index(struct i40e_vsi *vsi, u16 index)
{
  #line 1926 
  if ((int)i40e_enabled_xdp_vsi_2(vsi) != 0) 
                                             #line 1927 
                                             return (_Bool)(((int)vsi->num_queue_pairs > (int)index || (int)vsi->alloc_queue_pairs <= (int)index && (int)index < (int)vsi->alloc_queue_pairs + (int)vsi->num_queue_pairs) != 0);
  #line 1932 
  return (_Bool)((int)vsi->num_queue_pairs > (int)index);
}

#line 1935  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_ringparam(struct net_device *netdev, struct ethtool_ringparam *ring)
{
  #line 1943 
  u32 new_rx_count;
  #line 1943 
  u32 new_tx_count;
  #line 1944 
  u16 tx_alloc_queue_pairs;
  #line 1946 
  int i;
  #line 2003 
  unsigned int tmp_5;
  #line 1938 
  struct i40e_ring *tx_rings = (struct i40e_ring *)0;
  #line 1938 
  struct i40e_ring *rx_rings = (struct i40e_ring *)0;
  #line 1939 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 1940 
  struct i40e_hw *hw = & ((np->vsi)->back)->hw;
  #line 1941 
  struct i40e_vsi *vsi = np->vsi;
  #line 1942 
  struct i40e_pf *pf = vsi->back;
  #line 1945 
  int timeout = 50;
  #line 1946 
  int err = 0;
  #line 1948 
  if (ring->rx_mini_pending != 0U || ring->rx_jumbo_pending != 0U) 
                                                                   #line 1949 
                                                                   return -22;
  #line 1951 
  if ((ring->tx_pending + 4294967232U > 4032U || ring->rx_pending > 4096U) || ring->rx_pending <= 63U) {
    #line 1955 
    netdev_info(netdev,(char *)"Descriptors requested (Tx: %d / Rx: %d) out of range [%d-%d]\n",ring->tx_pending,ring->rx_pending,64,4096);
    #line 1959 
    return -22;
  }
  #line 1962 
  new_tx_count = (ring->tx_pending + 31U) & 4294967264U;
  #line 1963 
  new_rx_count = (ring->rx_pending + 31U) & 4294967264U;
  #line 1966 
  if ((unsigned int)(*(vsi->tx_rings))->count == new_tx_count && (unsigned int)(*(vsi->rx_rings))->count == new_rx_count) 
    #line 1968 
    return 0;
  #line 1974 
  if ((int)i40e_xsk_any_rx_ring_enabled(vsi) != 0) 
                                                   #line 1975 
                                                   return -16;
  #line 1977 
  while (1) {
    #line 1977 
    if (! ((int)test_and_set_bit(1L,(unsigned long *)(& pf->state)) != 0)) 
      #line 1977 
      break;
    #line 1978 
    timeout --;
    #line 1979 
    if (timeout == 0) 
                      #line 1980 
                      return -16;
    #line 1981 
    usleep_range(1000UL,2000UL);
  }
  #line 1984 
  if (! netif_running(vsi->netdev)) {
    #line 1986 
    i = 0;
    #line 1986 
    while ((int)vsi->num_queue_pairs > i) {
      {
        #line 1987 
        (*(vsi->tx_rings + (unsigned long)i))->count = (unsigned short)new_tx_count;
        #line 1988 
        (*(vsi->rx_rings + (unsigned long)i))->count = (unsigned short)new_rx_count;
        #line 1989 
        if ((int)i40e_enabled_xdp_vsi_2(vsi) != 0) 
                                                   #line 1990 
                                                   (*(vsi->xdp_rings + (unsigned long)i))->count = (unsigned short)new_tx_count;
      }
      #line 1986 
      i ++;
    }
    #line 1992 
    vsi->num_tx_desc = (unsigned short)new_tx_count;
    #line 1993 
    vsi->num_rx_desc = (unsigned short)new_rx_count;
    #line 1994 
    goto done;
  }
  #line 2003 
  if ((int)i40e_enabled_xdp_vsi_2(vsi) != 0) 
                                             #line 2003 
                                             tmp_5 = 2U; else 
                                                              #line 2003 
                                                              tmp_5 = 1U;
  #line 2003 
  tx_alloc_queue_pairs = (unsigned short)((unsigned int)vsi->alloc_queue_pairs * tmp_5);
  #line 2005 
  if ((unsigned int)(*(vsi->tx_rings))->count != new_tx_count) {
    #line 2006 
    netdev_info(netdev,(char *)"Changing Tx descriptor count from %d to %d.\n",(int)(*(vsi->tx_rings))->count,new_tx_count);
    #line 2009 
    tx_rings = (struct i40e_ring *)kcalloc_1((unsigned long)tx_alloc_queue_pairs,4096UL,3264U);
    #line 2011 
    if (tx_rings == (struct i40e_ring *)0) {
      #line 2012 
      err = -12;
      #line 2013 
      goto done;
    }
    #line 2016 
    i = 0;
    #line 2016 
    while ((int)tx_alloc_queue_pairs > i) {
      {
        #line 2017 
        if (! i40e_active_tx_ring_index(vsi,
                                  (unsigned short)((int)((unsigned short)i)))) 
          #line 2018 
          goto __Cont;
        #line 2020 
        *(tx_rings + (unsigned long)i) = *(*(vsi->tx_rings + (unsigned long)i));
        #line 2021 
        (tx_rings + (unsigned long)i)->count = (unsigned short)new_tx_count;
        #line 2025 
        (tx_rings + (unsigned long)i)->desc = (void *)0;
        #line 2026 
        (tx_rings + (unsigned long)i)->__anonCompField_i40e_ring_221.rx_bi = (struct i40e_rx_buffer *)0;
        #line 2027 
        err = i40e_setup_tx_descriptors(tx_rings + (unsigned long)i);
        #line 2028 
        if (err != 0) {
          #line 2029 
          while (i != 0) {
            #line 2030 
            i --;
            #line 2031 
            if (! i40e_active_tx_ring_index(vsi,
                                  (unsigned short)((int)((unsigned short)i)))) 
              #line 2032 
              continue;
            #line 2033 
            i40e_free_tx_resources(tx_rings + (unsigned long)i);
          }
          #line 2035 
          kfree((void *)tx_rings);
          #line 2036 
          tx_rings = (struct i40e_ring *)0;
          #line 2038 
          goto done;
        }
      }
      #line 2016 
      __Cont: 
              #line 2016 
      i ++;
    }
  }
  #line 2044 
  if ((unsigned int)(*(vsi->rx_rings))->count != new_rx_count) {
    #line 2045 
    netdev_info(netdev,(char *)"Changing Rx descriptor count from %d to %d\n",(int)(*(vsi->rx_rings))->count,new_rx_count);
    #line 2048 
    rx_rings = (struct i40e_ring *)kcalloc_1((unsigned long)vsi->alloc_queue_pairs,4096UL,3264U);
    #line 2050 
    if (rx_rings == (struct i40e_ring *)0) {
      #line 2051 
      err = -12;
      #line 2052 
      goto free_tx;
    }
    #line 2055 
    i = 0;
    #line 2055 
    while ((int)vsi->num_queue_pairs > i) {
      {
        #line 2056 
        u16 unused;
        #line 2079 
        unsigned int tmp_10;
        #line 2059 
        *(rx_rings + (unsigned long)i) = *(*(vsi->rx_rings + (unsigned long)i));
        #line 2060 
        (rx_rings + (unsigned long)i)->count = (unsigned short)new_rx_count;
        #line 2064 
        (rx_rings + (unsigned long)i)->desc = (void *)0;
        #line 2065 
        (rx_rings + (unsigned long)i)->__anonCompField_i40e_ring_221.rx_bi = (struct i40e_rx_buffer *)0;
        #line 2067 
        memset((void *)(& (rx_rings + (unsigned long)i)->xdp_rxq),0,64UL);
        #line 2071 
        (rx_rings + (unsigned long)i)->tail = hw->hw_addr + 753920U;
        #line 2072 
        err = i40e_setup_rx_descriptors(rx_rings + (unsigned long)i);
        #line 2073 
        if (err != 0) 
                      #line 2074 
                      goto rx_unwind;
        #line 2079 
        if ((int)(rx_rings + (unsigned long)i)->next_to_clean <= (int)(rx_rings + (unsigned long)i)->next_to_use) 
          #line 2079 
          tmp_10 = (unsigned int)(rx_rings + (unsigned long)i)->count; else 
                                                                    #line 2079 
                                                                    tmp_10 = 0U;
        #line 2079 
        unused = (unsigned short)(((tmp_10 + (unsigned int)(rx_rings + (unsigned long)i)->next_to_clean) - (unsigned int)(rx_rings + (unsigned long)i)->next_to_use) + 65535U);
        #line 2080 
        err = (int)i40e_alloc_rx_buffers(rx_rings + (unsigned long)i,
                               (unsigned short)((int)unused));
        #line 2081 
        rx_unwind: 
                   #line 2081 
        ;
        #line 2082 
        if (err != 0) {
          #line 2083 
          while (1) {
            #line 2084 
            int tmp_12;
            #line 2084 
            i40e_free_rx_resources(rx_rings + (unsigned long)i);
            #line 2084 
            tmp_12 = i;
            #line 2084 
            i --;
            #line 2084 
            ;
            #line 2084 
            if (! (tmp_12 != 0)) 
                                 #line 2083 
                                 break;
          }
          #line 2086 
          kfree((void *)rx_rings);
          #line 2087 
          rx_rings = (struct i40e_ring *)0;
          #line 2089 
          goto free_tx;
        }
      }
      #line 2055 
      i ++;
    }
  }
  #line 2097 
  i40e_down(vsi);
  #line 2099 
  if (tx_rings != (struct i40e_ring *)0) {
    #line 2100 
    i = 0;
    #line 2100 
    while ((int)tx_alloc_queue_pairs > i) {
      #line 2101 
      if ((int)i40e_active_tx_ring_index(vsi,
                                   (unsigned short)((int)((unsigned short)i))) != 0) {
        #line 2102 
        i40e_free_tx_resources(*(vsi->tx_rings + (unsigned long)i));
        #line 2103 
        *(*(vsi->tx_rings + (unsigned long)i)) = *(tx_rings + (unsigned long)i);
      }
      #line 2100 
      i ++;
    }
    #line 2106 
    kfree((void *)tx_rings);
    #line 2107 
    tx_rings = (struct i40e_ring *)0;
  }
  #line 2110 
  if (rx_rings != (struct i40e_ring *)0) {
    #line 2111 
    i = 0;
    #line 2111 
    while ((int)vsi->num_queue_pairs > i) {
      #line 2112 
      i40e_free_rx_resources(*(vsi->rx_rings + (unsigned long)i));
      #line 2114 
      (rx_rings + (unsigned long)i)->tail = (*(vsi->rx_rings + (unsigned long)i))->tail;
      #line 2120 
      (rx_rings + (unsigned long)i)->next_to_use = (unsigned short)0U;
      #line 2121 
      (rx_rings + (unsigned long)i)->next_to_clean = (unsigned short)0U;
      #line 2122 
      (rx_rings + (unsigned long)i)->next_to_alloc = (unsigned short)0U;
      #line 2124 
      *(*(vsi->rx_rings + (unsigned long)i)) = *(rx_rings + (unsigned long)i);
      #line 2111 
      i ++;
    }
    #line 2126 
    kfree((void *)rx_rings);
    #line 2127 
    rx_rings = (struct i40e_ring *)0;
  }
  #line 2130 
  vsi->num_tx_desc = (unsigned short)new_tx_count;
  #line 2131 
  vsi->num_rx_desc = (unsigned short)new_rx_count;
  #line 2132 
  i40e_up(vsi);
  #line 2134 
  free_tx: 
           #line 2134 
  ;
  #line 2136 
  if (tx_rings != (struct i40e_ring *)0) {
    #line 2137 
    i = 0;
    #line 2137 
    while ((int)tx_alloc_queue_pairs > i) {
      #line 2138 
      if ((int)i40e_active_tx_ring_index(vsi,
                                   (unsigned short)((int)((unsigned short)i))) != 0) 
        #line 2139 
        i40e_free_tx_resources(*(vsi->tx_rings + (unsigned long)i));
      #line 2137 
      i ++;
    }
    #line 2141 
    kfree((void *)tx_rings);
    #line 2142 
    tx_rings = (struct i40e_ring *)0;
  }
  #line 2145 
  done: 
        #line 2145 
  ;
  #line 2146 
  cif_clear_bit_4(1L,(unsigned long *)(& pf->state));
  #line 2148 
  return err;
}

#line 2165  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_stats_count(struct net_device *netdev)
{
  #line 2170 
  int stats_len;
  #line 2167 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2168 
  struct i40e_vsi *vsi = np->vsi;
  #line 2169 
  struct i40e_pf *pf = vsi->back;
  #line 2172 
  if (*(pf->vsi + (unsigned long)pf->lan_vsi) == vsi && (unsigned int)pf->hw.partition_id == 1U) 
    #line 2173 
    stats_len = 162; else 
                          #line 2175 
                          stats_len = 23;
  #line 2191 
  stats_len = (int)(netdev->num_tx_queues * 4U + (unsigned int)stats_len);
  #line 2193 
  return stats_len;
}

#line 2196  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_sset_count(struct net_device *netdev, int sset)
{
  #line 2198 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2199 
  struct i40e_vsi *vsi = np->vsi;
  #line 2200 
  struct i40e_pf *pf = vsi->back;
  #line 2202 
  switch (sset) {
    #line 2208 
    int tmp_1;
    #line 2203 
    case 0: 
            #line 2203 
    ;
    #line 2204 
    return 4;
    #line 2205 
    case 1: 
            #line 2205 
    ;
    #line 2206 
    return i40e_get_stats_count(netdev);
    #line 2207 
    case 2: 
            #line 2207 
    ;
    #line 2208 
    if ((unsigned int)pf->hw.pf_id == 0U) 
                                          #line 2208 
                                          tmp_1 = 12; else 
                                                           #line 2208 
                                                           tmp_1 = 11;
    #line 2208 
    return tmp_1;
    #line 2210 
    default: 
             #line 2210 
    ;
    #line 2211 
    return -95;
  }
}

#line 2225  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
__inline static struct i40e_pfc_stats i40e_get_pfc_stats(struct i40e_pf *pf, unsigned int i)
{
  #line 2230 
  struct i40e_pfc_stats pfc = {.priority_xon_rx = pf->stats.priority_xon_rx[i], .priority_xoff_rx = pf->stats.priority_xoff_rx[i], .priority_xon_tx = pf->stats.priority_xon_tx[i], .priority_xoff_tx = pf->stats.priority_xoff_tx[i], .priority_xon_2_xoff = pf->stats.priority_xon_2_xoff[i]};
  #line 2237 
  return pfc;
}

#line 2254  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_ethtool_stats(struct net_device *netdev, struct ethtool_stats *stats, u64 *data)
{
  #line 2261 
  unsigned int i;
  #line 2262 
  bool veb_stats;
  #line 2295 
  void *tmp_3;
  #line 2257 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2258 
  struct i40e_vsi *vsi = np->vsi;
  #line 2259 
  struct i40e_pf *pf = vsi->back;
  #line 2260 
  struct i40e_veb *veb = (struct i40e_veb *)0;
  #line 2263 
  u64 *p = data;
  #line 2265 
  i40e_update_stats(vsi);
  #line 2267 
  __i40e_add_ethtool_stats(& data,(void *)i40e_get_vsi_stats_struct(vsi),(struct i40e_stats *)(& i40e_gstrings_net_stats),11U);
  #line 2270 
  __i40e_add_ethtool_stats(& data,(void *)vsi,(struct i40e_stats *)(& i40e_gstrings_misc_stats),12U);
  #line 2272 
  rcu_read_lock();
  #line 2273 
  i = 0U;
  #line 2273 
  while (netdev->num_tx_queues > i) {
    {
      #line 2276 
      union __anonunion___u_19599 __u_0;
      #line 2275 
      union __anonunion___u_19597 __u;
      #line 2274 
      __read_once_size((void *)(vsi->tx_rings + (unsigned long)i),(void *)(& __u.__c),8);
      #line 2274 
      i40e_add_queue_stats(& data,(__u.__val));
      #line 2275 
      __read_once_size((void *)(vsi->rx_rings + (unsigned long)i),(void *)(& __u_0.__c),8);
      #line 2275 
      i40e_add_queue_stats(& data,(__u_0.__val));
    }
    #line 2273 
    i ++;
  }
  #line 2277 
  rcu_read_unlock();
  #line 2279 
  if (*(pf->vsi + (unsigned long)pf->lan_vsi) != vsi || (unsigned int)pf->hw.partition_id != 1U) 
    #line 2280 
    goto check_data_pointer;
  #line 2282 
  veb_stats = (_Bool)(((unsigned int)pf->lan_veb <= 15U && ((unsigned long)pf->flags & 8192UL) != 0UL) != 0);
  #line 2286 
  if ((int)veb_stats != 0) {
    #line 2287 
    veb = pf->veb[(int)pf->lan_veb];
    #line 2288 
    i40e_update_veb_stats(veb);
  }
  #line 2295 
  if ((int)veb_stats != 0) 
                           #line 2295 
                           tmp_3 = (void *)veb; else 
                                                     #line 2295 
                                                     tmp_3 = (void *)0;
  #line 2295 
  __i40e_add_ethtool_stats(& data,tmp_3,(struct i40e_stats *)(& i40e_gstrings_veb_stats),12U);
  #line 2298 
  i = 0U;
  #line 2298 
  while (i <= 7U) {
    #line 2299 
    void *tmp_4;
    #line 2299 
    if ((int)veb_stats != 0) 
                             #line 2299 
                             tmp_4 = (void *)veb; else 
                                                       #line 2299 
                                                       tmp_4 = (void *)0;
    #line 2299 
    __i40e_add_ethtool_stats(& data,tmp_4,(struct i40e_stats *)(& i40e_gstrings_veb_tc_stats),4U);
    #line 2298 
    i ++;
  }
  #line 2302 
  __i40e_add_ethtool_stats(& data,(void *)pf,(struct i40e_stats *)(& i40e_gstrings_stats),55U);
  #line 2304 
  i = 0U;
  #line 2304 
  while (i <= 7U) {
    {
      #line 2305 
      struct i40e_pfc_stats pfc = i40e_get_pfc_stats(pf,i);
      #line 2307 
      __i40e_add_ethtool_stats(& data,(void *)(& pfc),(struct i40e_stats *)(& i40e_gstrings_pfc_stats),5U);
    }
    #line 2304 
    i ++;
  }
  #line 2310 
  check_data_pointer: 
                      #line 2310 
  ;
  {
    #line 2311 
    bool __warned;
    #line 2311 
    int __ret_warn_once = (data - p) / 8L != (long)i40e_get_stats_count(netdev);
    #line 2311 
    if ((long)(__ret_warn_once != 0) != 0L && (long)(! __warned) != 0L) {
      #line 2311 
      __warned = (_Bool)1;
      {
        #line 2311 
        int __ret_warn_on = 1;
        #line 2311 
        if ((long)(__ret_warn_on != 0) != 0L) {
          #line 2311 
          __warn_printk((char *)"ethtool stats count mismatch!");
          #line 2312 
          ldv_inline_asm();
          #line 2313 
          ldv_inline_asm();
        }
        #line 2311 
        long tmp_7 = (long)(__ret_warn_on != 0);
      }
    }
    #line 2311 
    long tmp_9 = (long)(__ret_warn_once != 0);
  }
  #line 2313 
  return;
}

#line 2325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_stat_strings(struct net_device *netdev, u8 *data)
{
  #line 2330 
  unsigned int i;
  #line 2327 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2328 
  struct i40e_vsi *vsi = np->vsi;
  #line 2329 
  struct i40e_pf *pf = vsi->back;
  #line 2331 
  u8 *p = data;
  #line 2333 
  __i40e_add_stat_strings(& data,(struct i40e_stats *)(& i40e_gstrings_net_stats),11U);
  #line 2335 
  __i40e_add_stat_strings(& data,(struct i40e_stats *)(& i40e_gstrings_misc_stats),12U);
  #line 2337 
  i = 0U;
  #line 2337 
  while (netdev->num_tx_queues > i) {
    #line 2338 
    __i40e_add_stat_strings(& data,(struct i40e_stats *)(& i40e_gstrings_queue_stats),2U,(char *)"tx",i);
    #line 2340 
    __i40e_add_stat_strings(& data,(struct i40e_stats *)(& i40e_gstrings_queue_stats),2U,(char *)"rx",i);
    #line 2337 
    i ++;
  }
  #line 2344 
  if (*(pf->vsi + (unsigned long)pf->lan_vsi) != vsi || (unsigned int)pf->hw.partition_id != 1U) 
    #line 2345 
    goto check_data_pointer;
  #line 2347 
  __i40e_add_stat_strings(& data,(struct i40e_stats *)(& i40e_gstrings_veb_stats),12U);
  #line 2349 
  i = 0U;
  #line 2349 
  while (i <= 7U) {
    #line 2350 
    __i40e_add_stat_strings(& data,(struct i40e_stats *)(& i40e_gstrings_veb_tc_stats),4U,i);
    #line 2349 
    i ++;
  }
  #line 2352 
  __i40e_add_stat_strings(& data,(struct i40e_stats *)(& i40e_gstrings_stats),55U);
  #line 2354 
  i = 0U;
  #line 2354 
  while (i <= 7U) {
    #line 2355 
    __i40e_add_stat_strings(& data,(struct i40e_stats *)(& i40e_gstrings_pfc_stats),5U,i);
    #line 2354 
    i ++;
  }
  #line 2357 
  check_data_pointer: 
                      #line 2357 
  ;
  {
    #line 2358 
    bool __warned;
    #line 2358 
    int __ret_warn_once = data - p != (long)(i40e_get_stats_count(netdev) * 32);
    #line 2358 
    if ((long)(__ret_warn_once != 0) != 0L && (long)(! __warned) != 0L) {
      #line 2358 
      __warned = (_Bool)1;
      {
        #line 2358 
        int __ret_warn_on = 1;
        #line 2358 
        if ((long)(__ret_warn_on != 0) != 0L) {
          #line 2358 
          __warn_printk((char *)"stat strings count mismatch!");
          #line 2359 
          ldv_inline_asm();
          #line 2360 
          ldv_inline_asm();
        }
        #line 2358 
        long tmp_2 = (long)(__ret_warn_on != 0);
      }
    }
    #line 2358 
    long tmp_4 = (long)(__ret_warn_once != 0);
  }
  #line 2360 
  return;
}

#line 2362  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_priv_flag_strings(struct net_device *netdev, u8 *data)
{
  #line 2368 
  unsigned int i;
  #line 2364 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2365 
  struct i40e_vsi *vsi = np->vsi;
  #line 2366 
  struct i40e_pf *pf = vsi->back;
  #line 2367 
  char *p = (char *)data;
  #line 2370 
  i = 0U;
  #line 2370 
  while (i <= 10U) {
    #line 2371 
    snprintf(p,32UL,(char *)"%s",(char *)(& i40e_gstrings_priv_flags[i].flag_string));
    #line 2373 
    p += 32U;
    #line 2370 
    i ++;
  }
  #line 2375 
  if ((unsigned int)pf->hw.pf_id != 0U) 
                                        #line 2376 
                                        return;
  #line 2377 
  i = 0U;
  #line 2377 
  while (i == 0U) {
    #line 2378 
    snprintf(p,32UL,(char *)"%s",(char *)(& i40e_gl_gstrings_priv_flags[i].flag_string));
    #line 2380 
    p += 32U;
    #line 2377 
    i ++;
  }
  #line 2382 
  return;
}

#line 2384  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_strings(struct net_device *netdev, u32 stringset, u8 *data)
{
  #line 2387 
  switch (stringset) {
    #line 2388 
    case (u32)0: 
                 #line 2388 
    ;
    #line 2389 
    memcpy((void *)data,(void *)(& i40e_gstrings_test),128UL);
    #line 2391 
    break;
    #line 2392 
    case (u32)1: 
                 #line 2392 
    ;
    #line 2393 
    i40e_get_stat_strings(netdev,data);
    #line 2394 
    break;
    #line 2395 
    case (u32)2: 
                 #line 2395 
    ;
    #line 2396 
    i40e_get_priv_flag_strings(netdev,data);
    #line 2397 
    break;
    #line 2398 
    default: 
             #line 2398 
    ;
    #line 2399 
    break;
  }
  #line 2401 
  return;
}

#line 2403  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)
{
  #line 2406 
  struct i40e_pf *pf = i40e_netdev_to_pf(dev);
  #line 2409 
  if (((unsigned long)pf->flags & 131072UL) == 0UL) {
    #line 2410 
    return ethtool_op_get_ts_info(dev,info);
  }
  #line 2412 
  info->so_timestamping = 95U;
  #line 2419 
  if (pf->ptp_clock != (struct ptp_clock *)0) 
                                              #line 2420 
                                              info->phc_index = ptp_clock_index(pf->ptp_clock); else 
                                                                    #line 2422 
                                                                    info->phc_index = -1;
  #line 2424 
  info->tx_types = 3U;
  #line 2426 
  info->rx_filters = 3585U;
  #line 2431 
  if (((unsigned long)pf->hw_features & 1024UL) != 0UL) 
                                                        #line 2432 
                                                        info->rx_filters |= 29168U;
  #line 2441 
  return 0;
}

#line 2444  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u64 i40e_link_test(struct net_device *netdev, u64 *data)
{
  #line 2448 
  i40e_status status;
  #line 2446 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2447 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 2449 
  bool link_up = (_Bool)0;
  #line 2451 
  if ((pf->msg_enable & 8192U) != 0U) 
                                      #line 2451 
                                      netdev_info(netdev,(char *)"link test\n");
  #line 2452 
  status = i40e_get_link_status(& pf->hw,& link_up);
  #line 2453 
  if (status != I40E_SUCCESS) {
    #line 2454 
    if ((pf->msg_enable & 1U) != 0U) 
                                     #line 2454 
                                     netdev_err(netdev,(char *)"link query timed out, please retry test\n");
    #line 2455 
    *data = 1ULL;
    #line 2456 
    return *data;
  }
  #line 2459 
  if ((int)link_up != 0) 
                         #line 2460 
                         *data = 0ULL; else 
                                            #line 2462 
                                            *data = 1ULL;
  #line 2464 
  return *data;
}

#line 2467  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u64 i40e_reg_test(struct net_device *netdev, u64 *data)
{
  #line 2469 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2470 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 2472 
  if ((pf->msg_enable & 8192U) != 0U) 
                                      #line 2472 
                                      netdev_info(netdev,(char *)"register test\n");
  #line 2473 
  *data = (unsigned long long)i40e_diag_reg_test(& pf->hw);
  #line 2475 
  return *data;
}

#line 2478  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u64 i40e_eeprom_test(struct net_device *netdev, u64 *data)
{
  #line 2480 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2481 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 2483 
  if ((pf->msg_enable & 8192U) != 0U) 
                                      #line 2483 
                                      netdev_info(netdev,(char *)"eeprom test\n");
  #line 2484 
  *data = (unsigned long long)i40e_diag_eeprom_test(& pf->hw);
  #line 2487 
  pf->hw.nvmupd_state = I40E_NVMUPD_STATE_INIT;
  #line 2489 
  return *data;
}

#line 2492  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u64 i40e_intr_test(struct net_device *netdev, u64 *data)
{
  #line 2494 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2495 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 2496 
  u16 swc_old = pf->sw_int_count;
  #line 2498 
  if ((pf->msg_enable & 8192U) != 0U) 
                                      #line 2498 
                                      netdev_info(netdev,(char *)"interrupt test\n");
  #line 2499 
  writel(117440541U,(void *)(pf->hw.hw_addr + 230528U));
  #line 2505 
  usleep_range(1000UL,2000UL);
  #line 2506 
  *data = (unsigned long long)((int)pf->sw_int_count == (int)swc_old);
  #line 2508 
  return *data;
}

#line 2511  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
__inline static bool i40e_active_vfs(struct i40e_pf *pf)
{
  #line 2514 
  int i;
  #line 2513 
  struct i40e_vf *vfs = pf->vf;
  #line 2516 
  i = 0;
  #line 2516 
  while (pf->num_alloc_vfs > i) {
    #line 2517 
    if ((int)test_bit(1L,& (vfs + (unsigned long)i)->vf_states) != 0) 
      #line 2518 
      return (_Bool)1;
    #line 2516 
    i ++;
  }
  #line 2519 
  return (_Bool)0;
}

#line 2522  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
__inline static bool i40e_active_vmdqs(struct i40e_pf *pf)
{
  #line 2524 
  return (_Bool)(i40e_find_vsi_by_type(pf,(unsigned short)2) != (struct i40e_vsi *)0);
}

#line 2527  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_diag_test(struct net_device *netdev, struct ethtool_test *eth_test, u64 *data)
{
  #line 2530 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2531 
  bool if_running = netif_running(netdev);
  #line 2532 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 2534 
  if (eth_test->flags == 1U) {
    #line 2536 
    if ((pf->msg_enable & 1U) != 0U) 
                                     #line 2536 
                                     netdev_info(netdev,(char *)"offline testing starting\n");
    #line 2538 
    cif_set_bit_4(0L,(unsigned long *)(& pf->state));
    #line 2540 
    if ((int)i40e_active_vfs(pf) != 0) 
                                       #line 2540 
                                       goto _LOR;
    else {
      #line 2540 
      if ((int)i40e_active_vmdqs(pf) != 0) {
        #line 2540 
        _LOR: {
                #line 2541 
                _dev_warn(& (pf->pdev)->dev,(char *)"Please take active VFs and Netqueues offline and restart the adapter before running NIC diagnostics\n");
                #line 2543 
                *data = 1ULL;
                #line 2544 
                *(data + 1U) = 1ULL;
                #line 2545 
                *(data + 2U) = 1ULL;
                #line 2546 
                *(data + 3U) = 1ULL;
                #line 2547 
                eth_test->flags |= 2U;
                #line 2548 
                cif_clear_bit_4(0L,(unsigned long *)(& pf->state));
                #line 2549 
                goto skip_ol_tests;
              }
      }
    }
    #line 2553 
    if ((int)if_running != 0) 
                              #line 2555 
                              i40e_close(netdev); else 
                                                       #line 2562 
                                                       i40e_do_reset(pf,8192U,(_Bool)1);
    #line 2564 
    if (i40e_link_test(netdev,data + 3U) != 0ULL) 
                                                  #line 2565 
                                                  eth_test->flags |= 2U;
    #line 2567 
    if (i40e_eeprom_test(netdev,data + 1U) != 0ULL) 
                                                    #line 2568 
                                                    eth_test->flags |= 2U;
    #line 2570 
    if (i40e_intr_test(netdev,data + 2U) != 0ULL) 
                                                  #line 2571 
                                                  eth_test->flags |= 2U;
    #line 2574 
    if (i40e_reg_test(netdev,data) != 0ULL) 
                                            #line 2575 
                                            eth_test->flags |= 2U;
    #line 2577 
    cif_clear_bit_4(0L,(unsigned long *)(& pf->state));
    #line 2578 
    i40e_do_reset(pf,8192U,(_Bool)1);
    #line 2580 
    if ((int)if_running != 0) 
                              #line 2581 
                              i40e_open(netdev);
  }
  else {
    #line 2584 
    if ((pf->msg_enable & 1U) != 0U) 
                                     #line 2584 
                                     netdev_info(netdev,(char *)"online testing starting\n");
    #line 2586 
    if (i40e_link_test(netdev,data + 3U) != 0ULL) 
                                                  #line 2587 
                                                  eth_test->flags |= 2U;
    #line 2590 
    *data = 0ULL;
    #line 2591 
    *(data + 1U) = 0ULL;
    #line 2592 
    *(data + 2U) = 0ULL;
  }
  #line 2595 
  skip_ol_tests: 
                 #line 2595 
  ;
  #line 2597 
  if ((pf->msg_enable & 1U) != 0U) 
                                   #line 2597 
                                   netdev_info(netdev,(char *)"testing finished\n");
  #line 2598 
  return;
}

#line 2600  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
{
  #line 2606 
  u16 wol_nvm_bits;
  #line 2603 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2604 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 2605 
  struct i40e_hw *hw = & pf->hw;
  #line 2609 
  i40e_read_nvm_word(hw,(unsigned short)25,& wol_nvm_bits);
  #line 2610 
  if ((((unsigned long)wol_nvm_bits >> (int)hw->port) & 1UL) != 0UL || (unsigned int)hw->partition_id != 1U) {
    #line 2611 
    wol->supported = 0U;
    #line 2612 
    wol->wolopts = 0U;
  }
  else {
    #line 2614 
    wol->supported = 32U;
    #line 2615 
    if ((int)pf->wol_en != 0) 
                              #line 2615 
                              wol->wolopts = 32U; else 
                                                       #line 2615 
                                                       wol->wolopts = 0U;
  }
  #line 2617 
  return;
}

#line 2624  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
{
  #line 2630 
  u16 wol_nvm_bits;
  #line 2626 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2627 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 2628 
  struct i40e_vsi *vsi = np->vsi;
  #line 2629 
  struct i40e_hw *hw = & pf->hw;
  #line 2633 
  if ((unsigned int)hw->partition_id != 1U) {
    #line 2634 
    i40e_partition_setting_complaint(pf);
    #line 2635 
    return -95;
  }
  #line 2638 
  if (*(pf->vsi + (unsigned long)pf->lan_vsi) != vsi) 
                                                      #line 2639 
                                                      return -95;
  #line 2642 
  i40e_read_nvm_word(hw,(unsigned short)25,& wol_nvm_bits);
  #line 2643 
  if ((((unsigned long)wol_nvm_bits >> (int)hw->port) & 1UL) != 0UL) 
    #line 2644 
    return -95;
  #line 2647 
  if ((wol->wolopts & 4294967263U) != 0U) 
                                          #line 2648 
                                          return -95;
  #line 2651 
  if ((int)pf->wol_en != (wol->wolopts != 0U)) {
    #line 2652 
    pf->wol_en = (_Bool)(wol->wolopts != 0U);
    #line 2653 
    device_set_wakeup_enable(& (pf->pdev)->dev,(_Bool)((bool)((int)pf->wol_en) != 0));
  }
  #line 2656 
  return 0;
}

#line 2659  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_phys_id(struct net_device *netdev, enum ethtool_phys_id_state state)
{
  #line 2667 
  u16 temp_status;
  #line 2662 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2663 
  i40e_status ret = 0;
  #line 2664 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 2665 
  struct i40e_hw *hw = & pf->hw;
  #line 2666 
  int blink_freq = 2;
  #line 2669 
  switch ((unsigned int)state) {
    #line 2670 
    case (unsigned int)1: 
                          #line 2670 
    ;
    #line 2671 
    if (((unsigned long)pf->hw_features & 32768UL) == 0UL) 
                                                           #line 2672 
                                                           pf->led_status = i40e_led_get(hw);
    else {
      #line 2674 
      if ((hw->flags & 4ULL) == 0ULL) 
                                      #line 2675 
                                      i40e_aq_set_phy_debug(hw,(unsigned char)48,(struct i40e_asq_cmd_details *)0);
      #line 2677 
      ret = i40e_led_get_phy(hw,& temp_status,& pf->phy_led_val);
      #line 2679 
      pf->led_status = (unsigned int)temp_status;
    }
    #line 2681 
    return blink_freq;
    #line 2682 
    case (unsigned int)2: 
                          #line 2682 
    ;
    #line 2683 
    if (((unsigned long)pf->hw_features & 32768UL) == 0UL) 
                                                           #line 2684 
                                                           i40e_led_set(hw,15U,(_Bool)0); else 
                                                                    #line 2686 
                                                                    ret = i40e_led_set_phy(hw,(_Bool)1,(unsigned short)((int)((unsigned short)pf->led_status)),0U);
    #line 2687 
    break;
    #line 2688 
    case (unsigned int)3: 
                          #line 2688 
    ;
    #line 2689 
    if (((unsigned long)pf->hw_features & 32768UL) == 0UL) 
                                                           #line 2690 
                                                           i40e_led_set(hw,0U,(_Bool)0); else 
                                                                    #line 2692 
                                                                    ret = i40e_led_set_phy(hw,(_Bool)0,(unsigned short)((int)((unsigned short)pf->led_status)),0U);
    #line 2693 
    break;
    #line 2694 
    case (unsigned int)0: 
                          #line 2694 
    ;
    #line 2695 
    if (((unsigned long)pf->hw_features & 32768UL) == 0UL) 
                                                           #line 2696 
                                                           i40e_led_set(hw,pf->led_status,(_Bool)0);
    else {
      #line 2698 
      ret = i40e_led_set_phy(hw,(_Bool)0,(unsigned short)((int)((unsigned short)pf->led_status)),(unsigned int)pf->phy_led_val | 2147483648U);
      #line 2701 
      if ((hw->flags & 4ULL) == 0ULL) 
                                      #line 2702 
                                      i40e_aq_set_phy_debug(hw,(unsigned char)0,(struct i40e_asq_cmd_details *)0);
    }
    #line 2704 
    break;
    #line 2705 
    default: 
             #line 2705 
    ;
    #line 2706 
    break;
  }
  #line 2708 
  if (ret != I40E_SUCCESS) 
                           #line 2709 
                           return -2; else 
                                           #line 2711 
                                           return 0;
}

#line 2729  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int __i40e_get_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec, int queue)
{
  #line 2734 
  struct i40e_ring *rx_ring;
  #line 2734 
  struct i40e_ring *tx_ring;
  #line 2733 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2735 
  struct i40e_vsi *vsi = np->vsi;
  #line 2737 
  ec->tx_max_coalesced_frames_irq = (unsigned int)vsi->work_limit;
  #line 2738 
  ec->rx_max_coalesced_frames_irq = (unsigned int)vsi->work_limit;
  #line 2743 
  if (queue < 0) 
                 #line 2744 
                 queue = 0;
  else 
    #line 2745 
    if ((int)vsi->num_queue_pairs <= queue) 
                                            #line 2746 
                                            return -22;
  #line 2748 
  rx_ring = *(vsi->rx_rings + (unsigned long)queue);
  #line 2749 
  tx_ring = *(vsi->tx_rings + (unsigned long)queue);
  #line 2751 
  if (((int)rx_ring->itr_setting & 32768) != 0) 
                                                #line 2752 
                                                ec->use_adaptive_rx_coalesce = 1U;
  #line 2754 
  if (((int)tx_ring->itr_setting & 32768) != 0) 
                                                #line 2755 
                                                ec->use_adaptive_tx_coalesce = 1U;
  #line 2757 
  ec->rx_coalesce_usecs = (unsigned int)rx_ring->itr_setting & 4294934527U;
  #line 2758 
  ec->tx_coalesce_usecs = (unsigned int)tx_ring->itr_setting & 4294934527U;
  #line 2766 
  ec->rx_coalesce_usecs_high = (unsigned int)vsi->int_rate_limit;
  #line 2767 
  ec->tx_coalesce_usecs_high = (unsigned int)vsi->int_rate_limit;
  #line 2769 
  return 0;
}

#line 2781  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec)
{
  #line 2784 
  return __i40e_get_coalesce(netdev,ec,-1);
}

#line 2795  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_per_queue_coalesce(struct net_device *netdev, u32 queue, struct ethtool_coalesce *ec)
{
  #line 2798 
  return __i40e_get_coalesce(netdev,ec,(int)queue);
}

#line 2809  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_set_itr_per_queue(struct i40e_vsi *vsi, struct ethtool_coalesce *ec, int queue)
{
  #line 2817 
  struct i40e_q_vector *q_vector;
  #line 2818 
  u16 intrl;
  #line 2813 
  struct i40e_ring *rx_ring = *(vsi->rx_rings + (unsigned long)queue);
  #line 2814 
  struct i40e_ring *tx_ring = *(vsi->tx_rings + (unsigned long)queue);
  #line 2815 
  struct i40e_pf *pf = vsi->back;
  #line 2816 
  struct i40e_hw *hw = & pf->hw;
  #line 2820 
  intrl = i40e_intrl_usec_to_reg((int)vsi->int_rate_limit);
  #line 2822 
  rx_ring->itr_setting = (unsigned short)(((unsigned int)((unsigned short)ec->rx_coalesce_usecs) + 57345U) & 8190U);
  #line 2823 
  tx_ring->itr_setting = (unsigned short)(((unsigned int)((unsigned short)ec->tx_coalesce_usecs) + 57345U) & 8190U);
  #line 2825 
  if (ec->use_adaptive_rx_coalesce != 0U) 
                                          #line 2826 
                                          rx_ring->itr_setting = (unsigned short)((unsigned int)rx_ring->itr_setting | 32768U); else 
                                                                    #line 2828 
                                                                    rx_ring->itr_setting = (unsigned short)((unsigned int)rx_ring->itr_setting & 32767U);
  #line 2830 
  if (ec->use_adaptive_tx_coalesce != 0U) 
                                          #line 2831 
                                          tx_ring->itr_setting = (unsigned short)((unsigned int)tx_ring->itr_setting | 32768U); else 
                                                                    #line 2833 
                                                                    tx_ring->itr_setting = (unsigned short)((unsigned int)tx_ring->itr_setting & 32767U);
  #line 2835 
  q_vector = rx_ring->q_vector;
  #line 2836 
  q_vector->rx.target_itr = (unsigned short)((unsigned int)rx_ring->itr_setting & 32767U);
  #line 2838 
  q_vector = tx_ring->q_vector;
  #line 2839 
  q_vector->tx.target_itr = (unsigned short)((unsigned int)tx_ring->itr_setting & 32767U);
  #line 2846 
  writel((unsigned int)intrl,(void *)(hw->hw_addr + (unsigned long)(((int)q_vector->reg_idx + 54784) * 4)));
  #line 2847 
  readl((void *)(hw->hw_addr + 745772U));
  #line 2848 
  return;
}

#line 2858  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int __i40e_set_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec, int queue)
{
  #line 2863 
  u16 intrl_reg;
  #line 2863 
  u16 cur_rx_itr;
  #line 2863 
  u16 cur_tx_itr;
  #line 2866 
  int i;
  #line 2862 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 2864 
  struct i40e_vsi *vsi = np->vsi;
  #line 2865 
  struct i40e_pf *pf = vsi->back;
  #line 2868 
  if (ec->tx_max_coalesced_frames_irq != 0U || ec->rx_max_coalesced_frames_irq != 0U) 
    #line 2869 
    vsi->work_limit = (unsigned short)ec->tx_max_coalesced_frames_irq;
  #line 2871 
  if (queue < 0) {
    #line 2872 
    cur_rx_itr = (*(vsi->rx_rings))->itr_setting;
    #line 2873 
    cur_tx_itr = (*(vsi->tx_rings))->itr_setting;
  }
  else 
    #line 2874 
    if ((int)vsi->num_queue_pairs > queue) {
      #line 2875 
      cur_rx_itr = (*(vsi->rx_rings + (unsigned long)queue))->itr_setting;
      #line 2876 
      cur_tx_itr = (*(vsi->tx_rings + (unsigned long)queue))->itr_setting;
    }
    else {
      #line 2878 
      if ((pf->msg_enable & 1U) != 0U) 
                                       #line 2878 
                                       netdev_info(netdev,(char *)"Invalid queue value, queue range is 0 - %d\n",(int)vsi->num_queue_pairs + -1);
      #line 2880 
      return -22;
    }
  #line 2883 
  cur_tx_itr = (unsigned short)((unsigned int)cur_tx_itr & 32767U);
  #line 2884 
  cur_rx_itr = (unsigned short)((unsigned int)cur_rx_itr & 32767U);
  #line 2887 
  if (ec->tx_coalesce_usecs_high != (unsigned int)vsi->int_rate_limit) {
    #line 2888 
    if ((pf->msg_enable & 1U) != 0U) 
                                     #line 2888 
                                     netdev_info(netdev,(char *)"tx-usecs-high is not used, please program rx-usecs-high\n");
    #line 2889 
    return -22;
  }
  #line 2892 
  if (ec->rx_coalesce_usecs_high > 236U) {
    #line 2893 
    if ((pf->msg_enable & 1U) != 0U) 
                                     #line 2893 
                                     netdev_info(netdev,(char *)"Invalid value, rx-usecs-high range is 0-%lu\n",236UL);
    #line 2895 
    return -22;
  }
  #line 2898 
  if (ec->rx_coalesce_usecs != (unsigned int)cur_rx_itr && ec->use_adaptive_rx_coalesce != 0U) {
    #line 2900 
    if ((pf->msg_enable & 1U) != 0U) 
                                     #line 2900 
                                     netdev_info(netdev,(char *)"RX interrupt moderation cannot be changed if adaptive-rx is enabled.\n");
    #line 2901 
    return -22;
  }
  #line 2904 
  if (ec->rx_coalesce_usecs > 8160U) {
    #line 2905 
    if ((pf->msg_enable & 1U) != 0U) 
                                     #line 2905 
                                     netdev_info(netdev,(char *)"Invalid value, rx-usecs range is 0-8160\n");
    #line 2906 
    return -22;
  }
  #line 2909 
  if (ec->tx_coalesce_usecs != (unsigned int)cur_tx_itr && ec->use_adaptive_tx_coalesce != 0U) {
    #line 2911 
    if ((pf->msg_enable & 1U) != 0U) 
                                     #line 2911 
                                     netdev_info(netdev,(char *)"TX interrupt moderation cannot be changed if adaptive-tx is enabled.\n");
    #line 2912 
    return -22;
  }
  #line 2915 
  if (ec->tx_coalesce_usecs > 8160U) {
    #line 2916 
    if ((pf->msg_enable & 1U) != 0U) 
                                     #line 2916 
                                     netdev_info(netdev,(char *)"Invalid value, tx-usecs range is 0-8160\n");
    #line 2917 
    return -22;
  }
  #line 2920 
  if (ec->use_adaptive_rx_coalesce != 0U && (unsigned int)cur_rx_itr == 0U) 
    #line 2921 
    ec->rx_coalesce_usecs = 2U;
  #line 2923 
  if (ec->use_adaptive_tx_coalesce != 0U && (unsigned int)cur_tx_itr == 0U) 
    #line 2924 
    ec->tx_coalesce_usecs = 2U;
  #line 2926 
  intrl_reg = i40e_intrl_usec_to_reg((int)ec->rx_coalesce_usecs_high);
  #line 2927 
  vsi->int_rate_limit = (unsigned short)((unsigned int)((int)intrl_reg << 2U) & 65276U);
  #line 2928 
  if ((unsigned int)vsi->int_rate_limit != ec->rx_coalesce_usecs_high) 
    #line 2929 
    if ((pf->msg_enable & 1U) != 0U) 
                                     #line 2929 
                                     netdev_info(netdev,(char *)"Interrupt rate limit rounded down to %d\n",(int)vsi->int_rate_limit);
  #line 2936 
  if (queue < 0) {
    #line 2937 
    i = 0;
    #line 2937 
    while ((int)vsi->num_queue_pairs > i) {
      #line 2938 
      i40e_set_itr_per_queue(vsi,ec,i);
      #line 2937 
      i ++;
    }
  }
  else 
       #line 2940 
       i40e_set_itr_per_queue(vsi,ec,queue);
  #line 2943 
  return 0;
}

#line 2953  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_coalesce(struct net_device *netdev, struct ethtool_coalesce *ec)
{
  #line 2956 
  return __i40e_set_coalesce(netdev,ec,-1);
}

#line 2967  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_per_queue_coalesce(struct net_device *netdev, u32 queue, struct ethtool_coalesce *ec)
{
  #line 2970 
  return __i40e_set_coalesce(netdev,ec,(int)queue);
}

#line 2980  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_rss_hash_opts(struct i40e_pf *pf, struct ethtool_rxnfc *cmd)
{
  #line 2982 
  struct i40e_hw *hw = & pf->hw;
  #line 2983 
  u8 flow_pctype = (unsigned char)0U;
  #line 2984 
  u64 i_set = 0ULL;
  #line 2986 
  cmd->data = 0ULL;
  #line 2988 
  switch (cmd->flow_type) {
    #line 2989 
    case (__u32)1: 
                   #line 2989 
    ;
    #line 2990 
    flow_pctype = (unsigned char)33U;
    #line 2991 
    break;
    #line 2992 
    case (__u32)2: 
                   #line 2992 
    ;
    #line 2993 
    flow_pctype = (unsigned char)31U;
    #line 2994 
    break;
    #line 2995 
    case (__u32)5: 
                   #line 2995 
    ;
    #line 2996 
    flow_pctype = (unsigned char)43U;
    #line 2997 
    break;
    #line 2998 
    case (__u32)6: 
                   #line 2998 
    ;
    #line 2999 
    flow_pctype = (unsigned char)41U;
    #line 3000 
    break;
    #line 3001 
    case (__u32)3: 
                   #line 3001 
    ;
    #line 3002 
    case (__u32)4: 
                   #line 3002 
    ;
    #line 3003 
    case (__u32)9: 
                   #line 3003 
    ;
    #line 3004 
    case (__u32)10: 
                    #line 3004 
    ;
    #line 3005 
    case (__u32)16: 
                    #line 3005 
    ;
    #line 3006 
    case (__u32)7: 
                   #line 3006 
    ;
    #line 3007 
    case (__u32)8: 
                   #line 3007 
    ;
    #line 3008 
    case (__u32)11: 
                    #line 3008 
    ;
    #line 3009 
    case (__u32)12: 
                    #line 3009 
    ;
    #line 3010 
    case (__u32)17: 
                    #line 3010 
    ;
    #line 3012 
    cmd->data |= 48ULL;
    #line 3013 
    break;
    #line 3014 
    default: 
             #line 3014 
    ;
    #line 3015 
    return -22;
  }
  #line 3019 
  if ((unsigned int)flow_pctype != 0U) {
    #line 3020 
    i_set = (unsigned long long)i40e_read_rx_ctl(hw,(unsigned int)(((int)flow_pctype + 315072) * 8)) | ((unsigned long long)i40e_read_rx_ctl(hw,(unsigned int)((int)flow_pctype * 8 + 2520580)) << 32);
  }
  #line 3027 
  if (i_set != 0ULL) {
    #line 3028 
    if ((i_set & 17179869184ULL) != 0ULL) 
                                          #line 3029 
                                          cmd->data |= 64ULL;
    #line 3030 
    if ((i_set & 8589934592ULL) != 0ULL) 
                                         #line 3031 
                                         cmd->data |= 128ULL;
    #line 3033 
    if (cmd->flow_type + 4294967295U <= 1U) {
      #line 3035 
      if ((i_set & 422212465065984ULL) != 0ULL) 
                                                #line 3036 
                                                cmd->data |= 16ULL;
      #line 3037 
      if ((i_set & 103079215104ULL) != 0ULL) 
                                             #line 3038 
                                             cmd->data |= 32ULL;
    }
    else 
      #line 3039 
      if (cmd->flow_type + 4294967291U <= 1U) {
        #line 3041 
        if ((i_set & 2243003720663040ULL) != 0ULL) 
                                                   #line 3042 
                                                   cmd->data |= 16ULL;
        #line 3043 
        if ((i_set & 8761733283840ULL) != 0ULL) 
                                                #line 3044 
                                                cmd->data |= 32ULL;
      }
  }
  #line 3048 
  return 0;
}

#line 3059  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_check_mask(u64 mask, u64 field)
{
  #line 3061 
  u64 value = mask & field;
  #line 3063 
  if (value == field) 
                      #line 3064 
                      return 1;
  else 
    #line 3065 
    if (value == 0ULL) 
                       #line 3066 
                       return 0; else 
                                      #line 3068 
                                      return -1;
}

#line 3090  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_parse_rx_flow_user_data(struct ethtool_rx_flow_spec *fsp, struct i40e_rx_flow_userdef *data)
{
  #line 3093 
  u64 value;
  #line 3093 
  u64 mask;
  #line 3094 
  int valid;
  #line 3097 
  memset((void *)data,0,6UL);
  #line 3099 
  if ((fsp->flow_type & 2147483648U) == 0U) 
                                            #line 3100 
                                            return 0;
  #line 3102 
  value = (u64)__builtin_bswap64((unsigned long)*((__be64 *)(& fsp->h_ext.data)));
  #line 3103 
  mask = (u64)__builtin_bswap64((unsigned long)*((__be64 *)(& fsp->m_ext.data)));
  #line 3109 
  valid = i40e_check_mask(mask,4294967295ULL);
  #line 3110 
  if (valid < 0) 
                 #line 3111 
                 return -22;
  else 
    #line 3112 
    if (valid != 0) {
      #line 3113 
      data->flex_word = (unsigned short)value;
      #line 3114 
      data->flex_offset = (unsigned short)(value >> 16);
      #line 3116 
      data->flex_filter = (_Bool)1;
    }
  #line 3119 
  return 0;
}

#line 3130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_fill_rx_flow_user_data(struct ethtool_rx_flow_spec *fsp, struct i40e_rx_flow_userdef *data)
{
  #line 3133 
  u64 value = 0ULL;
  #line 3133 
  u64 mask = 0ULL;
  #line 3135 
  if ((int)data->flex_filter != 0) {
    #line 3136 
    value = (unsigned long long)data->flex_word | value;
    #line 3137 
    value = ((unsigned long long)data->flex_offset << 16) | value;
    #line 3138 
    mask |= 4294967295ULL;
  }
  #line 3141 
  if (value != 0ULL || mask != 0ULL) 
                                     #line 3142 
                                     fsp->flow_type |= 2147483648U;
  #line 3144 
  *((__be64 *)(& fsp->h_ext.data)) = (__be64)__builtin_bswap64((unsigned long)value);
  #line 3145 
  *((__be64 *)(& fsp->m_ext.data)) = (__be64)__builtin_bswap64((unsigned long)mask);
  #line 3146 
  return;
}

#line 3159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_ethtool_fdir_all(struct i40e_pf *pf, struct ethtool_rxnfc *cmd, u32 *rule_locs)
{
  #line 3170 
  void *__mptr;
  #line 3170 
  struct i40e_fdir_filter *tmp_1;
  #line 3163 
  struct i40e_fdir_filter *rule;
  #line 3164 
  struct hlist_node *node2;
  #line 3165 
  int cnt = 0;
  #line 3168 
  cmd->data = (unsigned long long)i40e_get_fd_cnt_all(pf);
  {
    #line 3170 
    struct hlist_node *____ptr = pf->fdir_filter_list.first;
    #line 3170 
    if (____ptr != (struct hlist_node *)0) {
      #line 3170 
      __mptr = (void *)____ptr;
      #line 3170 
      tmp_1 = ((struct i40e_fdir_filter *)__mptr);
    }
    else 
         #line 3170 
         tmp_1 = (struct i40e_fdir_filter *)0;
    }
  #line 3170 
  rule = tmp_1;
  #line 3170 
  while (1) {
    #line 3170 
    struct i40e_fdir_filter *tmp_4;
    #line 3170 
    void *__mptr_0;
    #line 3170 
    if (rule != (struct i40e_fdir_filter *)0) {
      #line 3170 
      node2 = rule->fdir_node.next;
      #line 3170 
      if (! (1 != 0)) 
                      #line 3170 
                      break;
    }
    else 
         #line 3170 
         break;
    #line 3172 
    if (cmd->__anonCompField_ethtool_rxnfc_99.rule_cnt == (unsigned int)cnt) 
      #line 3173 
      return -90;
    #line 3175 
    *(rule_locs + (unsigned long)cnt) = rule->fd_id;
    #line 3176 
    cnt ++;
    {
      #line 3170 
      struct hlist_node *____ptr_0 = node2;
      #line 3170 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 3170 
        __mptr_0 = (void *)____ptr_0;
        #line 3170 
        tmp_4 = ((struct i40e_fdir_filter *)__mptr_0);
      }
      else 
           #line 3170 
           tmp_4 = (struct i40e_fdir_filter *)0;
      }
    #line 3170 
    rule = tmp_4;
  }
  #line 3179 
  cmd->__anonCompField_ethtool_rxnfc_99.rule_cnt = (unsigned int)cnt;
  #line 3181 
  return 0;
}

#line 3194  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_ethtool_fdir_entry(struct i40e_pf *pf, struct ethtool_rxnfc *cmd)
{
  #line 3205 
  void *__mptr;
  #line 3205 
  struct i40e_fdir_filter *tmp_0;
  #line 3201 
  struct hlist_node *node2;
  #line 3202 
  u64 input_set;
  #line 3203 
  u16 index;
  #line 3197 
  struct ethtool_rx_flow_spec *fsp = & cmd->fs;
  #line 3199 
  struct i40e_rx_flow_userdef userdef = {.flex_filter = (_Bool)0, .flex_word = (unsigned short)0, .flex_offset = (unsigned short)0};
  #line 3200 
  struct i40e_fdir_filter *rule = (struct i40e_fdir_filter *)0;
  {
    #line 3205 
    struct hlist_node *____ptr = pf->fdir_filter_list.first;
    #line 3205 
    if (____ptr != (struct hlist_node *)0) {
      #line 3205 
      __mptr = (void *)____ptr;
      #line 3205 
      tmp_0 = ((struct i40e_fdir_filter *)__mptr);
    }
    else 
         #line 3205 
         tmp_0 = (struct i40e_fdir_filter *)0;
    }
  #line 3205 
  rule = tmp_0;
  #line 3205 
  while (1) {
    #line 3205 
    struct i40e_fdir_filter *tmp_3;
    #line 3205 
    void *__mptr_0;
    #line 3205 
    if (rule != (struct i40e_fdir_filter *)0) {
      #line 3205 
      node2 = rule->fdir_node.next;
      #line 3205 
      if (! (1 != 0)) 
                      #line 3205 
                      break;
    }
    else 
         #line 3205 
         break;
    #line 3207 
    if (fsp->location <= rule->fd_id) 
                                      #line 3208 
                                      break;
    {
      #line 3205 
      struct hlist_node *____ptr_0 = node2;
      #line 3205 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 3205 
        __mptr_0 = (void *)____ptr_0;
        #line 3205 
        tmp_3 = ((struct i40e_fdir_filter *)__mptr_0);
      }
      else 
           #line 3205 
           tmp_3 = (struct i40e_fdir_filter *)0;
      }
    #line 3205 
    rule = tmp_3;
  }
  #line 3211 
  if (rule == (struct i40e_fdir_filter *)0 || fsp->location != rule->fd_id) 
    #line 3212 
    return -22;
  #line 3214 
  fsp->flow_type = (unsigned int)rule->flow_type;
  #line 3215 
  if (fsp->flow_type == 13U) {
    #line 3216 
    fsp->h_u.usr_ip4_spec.ip_ver = (unsigned char)1U;
    #line 3217 
    fsp->h_u.usr_ip4_spec.proto = (unsigned char)0U;
    #line 3218 
    fsp->m_u.usr_ip4_spec.proto = (unsigned char)0U;
  }
  #line 3224 
  fsp->h_u.tcp_ip4_spec.psrc = rule->dst_port;
  #line 3225 
  fsp->h_u.tcp_ip4_spec.pdst = rule->src_port;
  #line 3226 
  fsp->h_u.tcp_ip4_spec.ip4src = rule->dst_ip;
  #line 3227 
  fsp->h_u.tcp_ip4_spec.ip4dst = rule->src_ip;
  #line 3229 
  switch ((int)rule->flow_type) {
    #line 3230 
    case 3: 
            #line 3230 
    ;
    #line 3231 
    index = (unsigned short)34U;
    #line 3232 
    break;
    #line 3233 
    case 1: 
            #line 3233 
    ;
    #line 3234 
    index = (unsigned short)33U;
    #line 3235 
    break;
    #line 3236 
    case 2: 
            #line 3236 
    ;
    #line 3237 
    index = (unsigned short)31U;
    #line 3238 
    break;
    #line 3239 
    case 13: 
             #line 3239 
    ;
    #line 3240 
    index = (unsigned short)35U;
    #line 3241 
    break;
    #line 3242 
    default: 
             #line 3242 
    ;
    {
      #line 3248 
      int __ret_warn_on = 1;
      #line 3248 
      if ((long)(__ret_warn_on != 0) != 0L) {
        #line 3248 
        __warn_printk((char *)"Missing input set index for flow_type %d\n",(int)rule->flow_type);
        #line 3249 
        ldv_inline_asm();
        #line 3250 
        ldv_inline_asm();
      }
      #line 3248 
      long tmp_5 = (long)(__ret_warn_on != 0);
    }
    #line 3250 
    input_set = 18446744073709551615ULL;
    #line 3251 
    goto no_input_set;
  }
  #line 3254 
  input_set = i40e_read_fd_input_set(pf,(unsigned short)((int)index));
  #line 3256 
  no_input_set: 
                #line 3256 
  ;
  #line 3257 
  if ((input_set & 422212465065984ULL) != 0ULL) 
                                                #line 3258 
                                                fsp->m_u.tcp_ip4_spec.ip4src = 4294967295U;
  #line 3260 
  if ((input_set & 103079215104ULL) != 0ULL) 
                                             #line 3261 
                                             fsp->m_u.tcp_ip4_spec.ip4dst = 4294967295U;
  #line 3263 
  if ((input_set & 17179869184ULL) != 0ULL) 
                                            #line 3264 
                                            fsp->m_u.tcp_ip4_spec.psrc = (unsigned short)65535U;
  #line 3266 
  if ((input_set & 8589934592ULL) != 0ULL) 
                                           #line 3267 
                                           fsp->m_u.tcp_ip4_spec.pdst = (unsigned short)65535U;
  #line 3269 
  if ((unsigned int)rule->dest_ctl == 0U) 
                                          #line 3270 
                                          fsp->ring_cookie = 18446744073709551615ULL; else 
                                                                    #line 3272 
                                                                    fsp->ring_cookie = (unsigned long long)rule->q_index;
  #line 3274 
  if ((int)rule->dest_vsi != (int)(*(pf->vsi + (unsigned long)pf->lan_vsi))->id) {
    #line 3275 
    struct i40e_vsi *vsi;
    #line 3277 
    vsi = i40e_find_vsi_from_id(pf,(unsigned short)((int)rule->dest_vsi));
    #line 3278 
    if (vsi != (struct i40e_vsi *)0 && vsi->type == (unsigned int)I40E_VSI_SRIOV) {
      #line 3282 
      u64 ring_vf = (unsigned long long)((int)vsi->vf_id + 1);
      #line 3284 
      ring_vf <<= 32;
      #line 3285 
      fsp->ring_cookie |= ring_vf;
    }
  }
  #line 3289 
  if ((int)rule->flex_filter != 0) {
    #line 3290 
    userdef.flex_filter = (_Bool)1;
    #line 3291 
    userdef.flex_word = __builtin_bswap16((unsigned short)((int)rule->flex_word));
    #line 3292 
    userdef.flex_offset = rule->flex_offset;
  }
  #line 3295 
  i40e_fill_rx_flow_user_data(fsp,& userdef);
  #line 3297 
  return 0;
}

#line 3308  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd, u32 *rule_locs)
{
  #line 3311 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 3312 
  struct i40e_vsi *vsi = np->vsi;
  #line 3313 
  struct i40e_pf *pf = vsi->back;
  #line 3314 
  int ret = -95;
  #line 3316 
  switch (cmd->cmd) {
    #line 3317 
    case (__u32)45: 
                    #line 3317 
    ;
    #line 3318 
    cmd->data = (unsigned long long)vsi->rss_size;
    #line 3319 
    ret = 0;
    #line 3320 
    break;
    #line 3321 
    case (__u32)41: 
                    #line 3321 
    ;
    #line 3322 
    ret = i40e_get_rss_hash_opts(pf,cmd);
    #line 3323 
    break;
    #line 3324 
    case (__u32)46: 
                    #line 3324 
    ;
    #line 3325 
    cmd->__anonCompField_ethtool_rxnfc_99.rule_cnt = (unsigned int)pf->fdir_pf_active_filters;
    #line 3327 
    cmd->data = (unsigned long long)i40e_get_fd_cnt_all(pf);
    #line 3328 
    ret = 0;
    #line 3329 
    break;
    #line 3330 
    case (__u32)47: 
                    #line 3330 
    ;
    #line 3331 
    ret = i40e_get_ethtool_fdir_entry(pf,cmd);
    #line 3332 
    break;
    #line 3333 
    case (__u32)48: 
                    #line 3333 
    ;
    #line 3334 
    ret = i40e_get_ethtool_fdir_all(pf,cmd,rule_locs);
    #line 3335 
    break;
    #line 3336 
    default: 
             #line 3336 
    ;
    #line 3337 
    break;
  }
  #line 3340 
  return ret;
}

#line 3350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u64 i40e_get_rss_hash_bits(struct ethtool_rxnfc *nfc, u64 i_setc)
{
  #line 3352 
  u64 i_set = i_setc;
  #line 3353 
  u64 src_l3 = 0ULL;
  #line 3353 
  u64 dst_l3 = 0ULL;
  #line 3355 
  if ((nfc->data & 64ULL) != 0ULL) 
                                   #line 3356 
                                   i_set |= 17179869184ULL; else 
                                                                 #line 3358 
                                                                 i_set &= 18446744056529682431ULL;
  #line 3359 
  if ((nfc->data & 128ULL) != 0ULL) 
                                    #line 3360 
                                    i_set |= 8589934592ULL; else 
                                                                 #line 3362 
                                                                 i_set &= 18446744065119617023ULL;
  #line 3364 
  if (nfc->flow_type + 4294967291U <= 1U) {
    #line 3365 
    src_l3 = 2243003720663040ULL;
    #line 3366 
    dst_l3 = 8761733283840ULL;
  }
  else 
    #line 3367 
    if (nfc->flow_type + 4294967295U <= 1U) {
      #line 3369 
      src_l3 = 422212465065984ULL;
      #line 3370 
      dst_l3 = 103079215104ULL;
    }
    else 
         #line 3373 
         return i_set;
  #line 3376 
  if ((nfc->data & 16ULL) != 0ULL) 
                                   #line 3377 
                                   i_set |= src_l3; else 
                                                         #line 3379 
                                                         i_set = ~ src_l3 & i_set;
  #line 3380 
  if ((nfc->data & 32ULL) != 0ULL) 
                                   #line 3381 
                                   i_set |= dst_l3; else 
                                                         #line 3383 
                                                         i_set = ~ dst_l3 & i_set;
  #line 3385 
  return i_set;
}

#line 3395  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_rss_hash_opt(struct i40e_pf *pf, struct ethtool_rxnfc *nfc)
{
  #line 3401 
  u64 i_set;
  #line 3401 
  u64 i_setc;
  #line 3397 
  struct i40e_hw *hw = & pf->hw;
  #line 3398 
  u64 hena = (unsigned long long)i40e_read_rx_ctl(hw,2382080U) | ((unsigned long long)i40e_read_rx_ctl(hw,2382208U) << 32);
  #line 3400 
  u8 flow_pctype = (unsigned char)0U;
  #line 3403 
  if (((unsigned long)pf->flags & 1024UL) != 0UL) {
    #line 3404 
    _dev_err(& (pf->pdev)->dev,(char *)"Change of RSS hash input set is not supported when MFP mode is enabled\n");
    #line 3406 
    return -95;
  }
  #line 3412 
  if ((nfc->data & 18446744073709551375ULL) != 0ULL) 
                                                     #line 3414 
                                                     return -22;
  #line 3416 
  switch (nfc->flow_type) {
    #line 3417 
    case (__u32)1: 
                   #line 3417 
    ;
    #line 3418 
    flow_pctype = (unsigned char)33U;
    #line 3419 
    if (((unsigned long)pf->hw_features & 16UL) != 0UL) 
                                                        #line 3420 
                                                        hena |= 4294967296ULL;
    #line 3422 
    break;
    #line 3423 
    case (__u32)5: 
                   #line 3423 
    ;
    #line 3424 
    flow_pctype = (unsigned char)43U;
    #line 3425 
    if (((unsigned long)pf->hw_features & 16UL) != 0UL) 
                                                        #line 3426 
                                                        hena |= 4294967296ULL;
    #line 3428 
    if (((unsigned long)pf->hw_features & 16UL) != 0UL) 
                                                        #line 3429 
                                                        hena |= 4398046511104ULL;
    #line 3431 
    break;
    #line 3432 
    case (__u32)2: 
                   #line 3432 
    ;
    #line 3433 
    flow_pctype = (unsigned char)31U;
    #line 3434 
    if (((unsigned long)pf->hw_features & 16UL) != 0UL) 
                                                        #line 3435 
                                                        hena |= 1610612736ULL;
    #line 3439 
    hena |= 68719476736ULL;
    #line 3440 
    break;
    #line 3441 
    case (__u32)6: 
                   #line 3441 
    ;
    #line 3442 
    flow_pctype = (unsigned char)41U;
    #line 3443 
    if (((unsigned long)pf->hw_features & 16UL) != 0UL) 
                                                        #line 3444 
                                                        hena |= 1649267441664ULL;
    #line 3448 
    hena |= 70368744177664ULL;
    #line 3449 
    break;
    #line 3450 
    case (__u32)4: 
                   #line 3450 
    ;
    #line 3451 
    case (__u32)9: 
                   #line 3451 
    ;
    #line 3452 
    case (__u32)10: 
                    #line 3452 
    ;
    #line 3453 
    case (__u32)3: 
                   #line 3453 
    ;
    #line 3454 
    if ((nfc->data & 64ULL) != 0ULL || (nfc->data & 128ULL) != 0ULL) 
      #line 3456 
      return -22;
    #line 3457 
    hena |= 34359738368ULL;
    #line 3458 
    break;
    #line 3459 
    case (__u32)8: 
                   #line 3459 
    ;
    #line 3460 
    case (__u32)11: 
                    #line 3460 
    ;
    #line 3461 
    case (__u32)12: 
                    #line 3461 
    ;
    #line 3462 
    case (__u32)7: 
                   #line 3462 
    ;
    #line 3463 
    if ((nfc->data & 64ULL) != 0ULL || (nfc->data & 128ULL) != 0ULL) 
      #line 3465 
      return -22;
    #line 3466 
    hena |= 35184372088832ULL;
    #line 3467 
    break;
    #line 3468 
    case (__u32)16: 
                    #line 3468 
    ;
    #line 3469 
    hena |= 103079215104ULL;
    #line 3471 
    break;
    #line 3472 
    case (__u32)17: 
                    #line 3472 
    ;
    #line 3473 
    hena |= 105553116266496ULL;
    #line 3475 
    break;
    #line 3476 
    default: 
             #line 3476 
    ;
    #line 3477 
    return -22;
  }
  #line 3480 
  if ((unsigned int)flow_pctype != 0U) {
    #line 3481 
    i_setc = (unsigned long long)i40e_read_rx_ctl(hw,(unsigned int)(((int)flow_pctype + 315072) * 8)) | ((unsigned long long)i40e_read_rx_ctl(hw,(unsigned int)((int)flow_pctype * 8 + 2520580)) << 32);
    #line 3485 
    i_set = i40e_get_rss_hash_bits(nfc,i_setc);
    #line 3486 
    i40e_write_rx_ctl(hw,(unsigned int)(((int)flow_pctype + 315072) * 8),(unsigned int)i_set);
    #line 3488 
    i40e_write_rx_ctl(hw,(unsigned int)((int)flow_pctype * 8 + 2520580),(unsigned int)(i_set >> 32));
    #line 3490 
    hena = (1ULL << (int)flow_pctype) | hena;
  }
  #line 3493 
  i40e_write_rx_ctl(hw,2382080U,(unsigned int)hena);
  #line 3494 
  i40e_write_rx_ctl(hw,2382208U,(unsigned int)(hena >> 32));
  #line 3495 
  readl((void *)(hw->hw_addr + 745772U));
  #line 3497 
  return 0;
}

#line 3512  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_update_ethtool_fdir_entry(struct i40e_vsi *vsi, struct i40e_fdir_filter *input, u16 sw_idx, struct ethtool_rxnfc *cmd)
{
  #line 3525 
  void *__mptr;
  #line 3525 
  struct i40e_fdir_filter *tmp_0;
  #line 3517 
  struct i40e_fdir_filter *rule;
  #line 3517 
  struct i40e_fdir_filter *parent;
  #line 3519 
  struct hlist_node *node2;
  #line 3518 
  struct i40e_pf *pf = vsi->back;
  #line 3520 
  int err = -22;
  #line 3522 
  parent = (struct i40e_fdir_filter *)0;
  #line 3523 
  rule = (struct i40e_fdir_filter *)0;
  {
    #line 3525 
    struct hlist_node *____ptr = pf->fdir_filter_list.first;
    #line 3525 
    if (____ptr != (struct hlist_node *)0) {
      #line 3525 
      __mptr = (void *)____ptr;
      #line 3525 
      tmp_0 = ((struct i40e_fdir_filter *)__mptr);
    }
    else 
         #line 3525 
         tmp_0 = (struct i40e_fdir_filter *)0;
    }
  #line 3525 
  rule = tmp_0;
  #line 3525 
  while (1) {
    #line 3525 
    void *__mptr_0;
    #line 3525 
    struct i40e_fdir_filter *tmp_3;
    #line 3525 
    if (rule != (struct i40e_fdir_filter *)0) {
      #line 3525 
      node2 = rule->fdir_node.next;
      #line 3525 
      if (! (1 != 0)) 
                      #line 3525 
                      break;
    }
    else 
         #line 3525 
         break;
    #line 3528 
    if (rule->fd_id >= (unsigned int)sw_idx) 
                                             #line 3529 
                                             break;
    #line 3530 
    parent = rule;
    {
      #line 3525 
      struct hlist_node *____ptr_0 = node2;
      #line 3525 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 3525 
        __mptr_0 = (void *)____ptr_0;
        #line 3525 
        tmp_3 = ((struct i40e_fdir_filter *)__mptr_0);
      }
      else 
           #line 3525 
           tmp_3 = (struct i40e_fdir_filter *)0;
      }
    #line 3525 
    rule = tmp_3;
  }
  #line 3534 
  if (rule != (struct i40e_fdir_filter *)0 && rule->fd_id == (unsigned int)sw_idx) {
    #line 3538 
    err = i40e_add_del_fdir(vsi,rule,(_Bool)0);
    #line 3539 
    hlist_del_1(& rule->fdir_node);
    #line 3540 
    kfree((void *)rule);
    #line 3541 
    pf->fdir_pf_active_filters = (u16)((int)pf->fdir_pf_active_filters - 1);
  }
  #line 3547 
  if (input == (struct i40e_fdir_filter *)0) 
                                             #line 3548 
                                             return err;
  #line 3551 
  INIT_HLIST_NODE(& input->fdir_node);
  #line 3554 
  if (parent != (struct i40e_fdir_filter *)0) 
                                              #line 3555 
                                              hlist_add_behind(& input->fdir_node,& parent->fdir_node); else 
                                                                    #line 3557 
                                                                    hlist_add_head_1(& input->fdir_node,& pf->fdir_filter_list);
  #line 3561 
  pf->fdir_pf_active_filters = (u16)((int)pf->fdir_pf_active_filters + 1);
  #line 3563 
  return 0;
}

#line 3574  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_prune_flex_pit_list(struct i40e_pf *pf)
{
  #line 3580 
  void *__mptr;
  #line 3603 
  void *__mptr_4;
  #line 3580 
  void *__mptr_0;
  #line 3603 
  void *__mptr_5;
  #line 3576 
  struct i40e_flex_pit *entry;
  #line 3576 
  struct i40e_flex_pit *tmp;
  #line 3577 
  struct i40e_fdir_filter *rule;
  #line 3580 
  __mptr = (void *)pf->l3_flex_pit_list.next;
  #line 3580 
  entry = ((struct i40e_flex_pit *)__mptr);
  #line 3580 
  __mptr_0 = (void *)entry->list.next;
  #line 3581 
  tmp = ((struct i40e_flex_pit *)__mptr_0);
  #line 3580 
  while (& entry->list != & pf->l3_flex_pit_list) {
    #line 3580 
    void *__mptr_1;
    {
      #line 3583 
      void *__mptr_2;
      #line 3583 
      struct i40e_fdir_filter *tmp_4;
      #line 3581 
      bool found = (_Bool)0;
      {
        #line 3583 
        struct hlist_node *____ptr = pf->fdir_filter_list.first;
        #line 3583 
        if (____ptr != (struct hlist_node *)0) {
          #line 3583 
          __mptr_2 = (void *)____ptr;
          #line 3583 
          tmp_4 = ((struct i40e_fdir_filter *)__mptr_2);
        }
        else 
             #line 3583 
             tmp_4 = (struct i40e_fdir_filter *)0;
        }
      #line 3583 
      rule = tmp_4;
      #line 3583 
      while (rule != (struct i40e_fdir_filter *)0) {
        #line 3583 
        struct i40e_fdir_filter *tmp_7;
        #line 3583 
        void *__mptr_3;
        #line 3584 
        if ((unsigned int)rule->flow_type != 13U) 
                                                  #line 3585 
                                                  goto __Cont;
        #line 3586 
        if ((int)rule->flex_filter != 0 && (int)rule->flex_offset == (int)entry->src_offset) {
          #line 3588 
          found = (_Bool)1;
          #line 3589 
          break;
        }
        #line 3583 
        __Cont: { /* sequence */
                  {
                    #line 3583 
                    struct hlist_node *____ptr_0 = rule->fdir_node.next;
                    #line 3583 
                    if (____ptr_0 != (struct hlist_node *)0) {
                      #line 3583 
                      __mptr_3 = (void *)____ptr_0;
                      #line 3583 
                      tmp_7 = ((struct i40e_fdir_filter *)__mptr_3);
                    }
                    else 
                         #line 3583 
                         tmp_7 = (struct i40e_fdir_filter *)0;
                    }
                  #line 3583 
                  rule = tmp_7;
                }
      }
      #line 3596 
      if (! found) {
        #line 3597 
        list_del_2(& entry->list);
        #line 3598 
        kfree((void *)entry);
      }
    }
    #line 3580 
    entry = tmp;
    #line 3580 
    __mptr_1 = (void *)tmp->list.next;
    #line 3580 
    tmp = ((struct i40e_flex_pit *)__mptr_1);
  }
  #line 3603 
  __mptr_4 = (void *)pf->l4_flex_pit_list.next;
  #line 3603 
  entry = ((struct i40e_flex_pit *)__mptr_4);
  #line 3603 
  __mptr_5 = (void *)entry->list.next;
  #line 3604 
  tmp = ((struct i40e_flex_pit *)__mptr_5);
  #line 3603 
  while (& entry->list != & pf->l4_flex_pit_list) {
    #line 3603 
    void *__mptr_6;
    {
      #line 3606 
      void *__mptr_7;
      #line 3606 
      struct i40e_fdir_filter *tmp_13;
      #line 3604 
      bool found_0 = (_Bool)0;
      {
        #line 3606 
        struct hlist_node *____ptr_1 = pf->fdir_filter_list.first;
        #line 3606 
        if (____ptr_1 != (struct hlist_node *)0) {
          #line 3606 
          __mptr_7 = (void *)____ptr_1;
          #line 3606 
          tmp_13 = ((struct i40e_fdir_filter *)__mptr_7);
        }
        else 
             #line 3606 
             tmp_13 = (struct i40e_fdir_filter *)0;
        }
      #line 3606 
      rule = tmp_13;
      #line 3606 
      while (rule != (struct i40e_fdir_filter *)0) {
        #line 3606 
        void *__mptr_8;
        #line 3606 
        struct i40e_fdir_filter *tmp_16;
        #line 3610 
        if ((unsigned int)rule->flow_type == 13U) 
                                                  #line 3611 
                                                  goto __Cont_0;
        #line 3612 
        if ((int)rule->flex_filter != 0 && (int)rule->flex_offset == (int)entry->src_offset) {
          #line 3614 
          found_0 = (_Bool)1;
          #line 3615 
          break;
        }
        #line 3606 
        __Cont_0: { /* sequence */
                    {
                      #line 3606 
                      struct hlist_node *____ptr_2 = rule->fdir_node.next;
                      #line 3606 
                      if (____ptr_2 != (struct hlist_node *)0) {
                        #line 3606 
                        __mptr_8 = (void *)____ptr_2;
                        #line 3606 
                        tmp_16 = ((struct i40e_fdir_filter *)__mptr_8);
                      }
                      else 
                           #line 3606 
                           tmp_16 = (struct i40e_fdir_filter *)0;
                      }
                    #line 3606 
                    rule = tmp_16;
                  }
      }
      #line 3622 
      if (! found_0) {
        #line 3623 
        list_del_2(& entry->list);
        #line 3624 
        kfree((void *)entry);
      }
    }
    #line 3603 
    entry = tmp;
    #line 3603 
    __mptr_6 = (void *)tmp->list.next;
    #line 3603 
    tmp = ((struct i40e_flex_pit *)__mptr_6);
  }
  #line 3627 
  return;
}

#line 3639  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_del_fdir_entry(struct i40e_vsi *vsi, struct ethtool_rxnfc *cmd)
{
  #line 3642 
  struct ethtool_rx_flow_spec *fsp = & cmd->fs;
  #line 3644 
  struct i40e_pf *pf = vsi->back;
  #line 3645 
  int ret = 0;
  #line 3647 
  if ((int)test_bit(8L,(unsigned long *)(& pf->state)) != 0) 
                                                             #line 3649 
                                                             return -16;
  else {
    #line 3647 
    if ((int)test_bit(11L,(unsigned long *)(& pf->state)) != 0) 
                                                                #line 3649 
                                                                return -16;
  }
  #line 3651 
  if ((int)test_bit(21L,(unsigned long *)(& pf->state)) != 0) 
                                                              #line 3652 
                                                              return -16;
  #line 3654 
  ret = i40e_update_ethtool_fdir_entry(vsi,(struct i40e_fdir_filter *)0,(unsigned short)((int)((unsigned short)fsp->location)),cmd);
  #line 3656 
  i40e_prune_flex_pit_list(pf);
  #line 3658 
  i40e_fdir_check_and_reenable(pf);
  #line 3659 
  return ret;
}

#line 3671  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u8 i40e_unused_pit_index(struct i40e_pf *pf)
{
  #line 3681 
  void *__mptr;
  #line 3684 
  void *__mptr_1;
  #line 3674 
  struct i40e_flex_pit *entry;
  #line 3673 
  unsigned long available_index = 255UL;
  #line 3681 
  __mptr = (void *)pf->l4_flex_pit_list.next;
  #line 3681 
  entry = ((struct i40e_flex_pit *)__mptr);
  #line 3681 
  while (& entry->list != & pf->l4_flex_pit_list) {
    #line 3681 
    void *__mptr_0;
    #line 3682 
    cif_clear_bit_4((long)entry->pit_index,& available_index);
    #line 3681 
    __mptr_0 = (void *)entry->list.next;
    #line 3681 
    entry = ((struct i40e_flex_pit *)__mptr_0);
  }
  #line 3684 
  __mptr_1 = (void *)pf->l3_flex_pit_list.next;
  #line 3684 
  entry = ((struct i40e_flex_pit *)__mptr_1);
  #line 3684 
  while (& entry->list != & pf->l3_flex_pit_list) {
    #line 3684 
    void *__mptr_2;
    #line 3685 
    cif_clear_bit_4((long)entry->pit_index,& available_index);
    #line 3684 
    __mptr_2 = (void *)entry->list.next;
    #line 3684 
    entry = ((struct i40e_flex_pit *)__mptr_2);
  }
  #line 3687 
  return (unsigned char)cif_find_first_bit_1(& available_index,8UL);
}

#line 3700  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct i40e_flex_pit *i40e_find_flex_offset(struct list_head *flex_pit_list, u16 src_offset)
{
  #line 3709 
  void *__mptr;
  #line 3703 
  struct i40e_flex_pit *entry;
  #line 3704 
  int size = 0;
  #line 3709 
  __mptr = (void *)flex_pit_list->next;
  #line 3709 
  entry = ((struct i40e_flex_pit *)__mptr);
  #line 3709 
  while (& entry->list != flex_pit_list) {
    #line 3709 
    void *__mptr_0;
    #line 3710 
    size ++;
    #line 3711 
    if ((int)entry->src_offset == (int)src_offset) 
                                                   #line 3712 
                                                   return entry;
    #line 3709 
    __mptr_0 = (void *)entry->list.next;
    #line 3709 
    entry = ((struct i40e_flex_pit *)__mptr_0);
  }
  #line 3720 
  if (size > 2) {
    #line 3721 
    return (struct i40e_flex_pit *)ERR_PTR_1(-28L);
  }
  #line 3723 
  return (struct i40e_flex_pit *)0;
}

#line 3739  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_add_flex_offset(struct list_head *flex_pit_list, u16 src_offset, u8 pit_index)
{
  #line 3755 
  void *__mptr;
  #line 3743 
  struct i40e_flex_pit *new_pit;
  #line 3743 
  struct i40e_flex_pit *entry;
  #line 3745 
  new_pit = (struct i40e_flex_pit *)kzalloc_5(24UL,3264U);
  #line 3746 
  if (new_pit == (struct i40e_flex_pit *)0) 
                                            #line 3747 
                                            return -12;
  #line 3749 
  new_pit->src_offset = src_offset;
  #line 3750 
  new_pit->pit_index = pit_index;
  #line 3755 
  __mptr = (void *)flex_pit_list->next;
  #line 3755 
  entry = ((struct i40e_flex_pit *)__mptr);
  #line 3755 
  while (& entry->list != flex_pit_list) {
    #line 3755 
    void *__mptr_0;
    #line 3756 
    if ((int)new_pit->src_offset < (int)entry->src_offset) {
      #line 3757 
      list_add_tail_0(& new_pit->list,& entry->list);
      #line 3758 
      return 0;
    }
    #line 3765 
    if ((int)new_pit->src_offset == (int)entry->src_offset) {
      #line 3766 
      int err = 0;
      #line 3771 
      if ((int)new_pit->pit_index != (int)entry->pit_index) 
                                                            #line 3772 
                                                            err = -22;
      #line 3774 
      kfree((void *)new_pit);
      #line 3775 
      return err;
    }
    #line 3755 
    __mptr_0 = (void *)entry->list.next;
    #line 3755 
    entry = ((struct i40e_flex_pit *)__mptr_0);
  }
  #line 3782 
  list_add_tail_0(& new_pit->list,flex_pit_list);
  #line 3783 
  return 0;
}

#line 3807  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void __i40e_reprogram_flex_pit(struct i40e_pf *pf, struct list_head *flex_pit_list, int flex_pit_start)
{
  #line 3818 
  void *__mptr;
  #line 3811 
  struct i40e_flex_pit *entry = (struct i40e_flex_pit *)0;
  #line 3812 
  u16 last_offset = (unsigned short)0U;
  #line 3813 
  int i = 0;
  #line 3813 
  int j = 0;
  #line 3818 
  __mptr = (void *)flex_pit_list->next;
  #line 3818 
  entry = ((struct i40e_flex_pit *)__mptr);
  #line 3818 
  while (& entry->list != flex_pit_list) {
    #line 3818 
    void *__mptr_0;
    #line 3833 
    j = i + 1;
    #line 3833 
    while (j <= 2) {
      {
        #line 3834 
        u16 offset = (unsigned short)((int)entry->src_offset + (int)((unsigned short)j));
        #line 3835 
        int index = flex_pit_start + i;
        #line 3836 
        u32 value = ((unsigned int)((int)offset + -3) & 31U) | 64544U;
        #line 3840 
        if ((unsigned int)offset > 31U) {
          #line 3841 
          i40e_write_rx_ctl(& pf->hw,(unsigned int)((index + 76432) * 32),value);
          #line 3844 
          i ++;
        }
      }
      #line 3833 
      j ++;
    }
    #line 3849 
    i40e_write_rx_ctl(& pf->hw,(unsigned int)(((flex_pit_start + i) + 76432) * 32),(((unsigned int)(((int)entry->pit_index + 50) << 10) & 65535U) | ((unsigned int)entry->src_offset & 31U)) | 32U);
    #line 3854 
    i ++;
    #line 3818 
    __mptr_0 = (void *)entry->list.next;
    #line 3818 
    entry = ((struct i40e_flex_pit *)__mptr_0);
  }
  #line 3863 
  if (list_empty_1(flex_pit_list) == 0) {
    #line 3864 
    void *__mptr_1;
    #line 3864 
    __mptr_1 = (void *)entry->list.prev;
    #line 3864 
    last_offset = (unsigned short)((unsigned int)((struct i40e_flex_pit *)__mptr_1)->src_offset + 1U);
  }
  #line 3866 
  while (i <= 2) {
    #line 3867 
    i40e_write_rx_ctl(& pf->hw,(unsigned int)(((flex_pit_start + i) + 76432) * 32),((unsigned int)last_offset & 31U) | 64544U);
    #line 3866 
    i ++;
    #line 3866 
    last_offset = (u16)((int)last_offset + 1);
  }
  #line 3870 
  return;
}

#line 3882  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_reprogram_flex_pit(struct i40e_pf *pf)
{
  #line 3884 
  __i40e_reprogram_flex_pit(pf,& pf->l3_flex_pit_list,3);
  #line 3887 
  __i40e_reprogram_flex_pit(pf,& pf->l4_flex_pit_list,6);
  #line 3891 
  i40e_write_rx_ctl(& pf->hw,2525576U,227U);
  #line 3896 
  i40e_write_rx_ctl(& pf->hw,2525580U,230U);
  #line 3897 
  return;
}

#line 3909  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static char *i40e_flow_str(struct ethtool_rx_flow_spec *fsp)
{
  #line 3911 
  switch (fsp->flow_type & 2147483647U) {
    #line 3912 
    case (unsigned int)1: 
                          #line 3912 
    ;
    #line 3913 
    return (char *)"tcp4";
    #line 3914 
    case (unsigned int)2: 
                          #line 3914 
    ;
    #line 3915 
    return (char *)"udp4";
    #line 3916 
    case (unsigned int)3: 
                          #line 3916 
    ;
    #line 3917 
    return (char *)"sctp4";
    #line 3918 
    case (unsigned int)13: 
                           #line 3918 
    ;
    #line 3919 
    return (char *)"ip4";
    #line 3920 
    default: 
             #line 3920 
    ;
    #line 3921 
    return (char *)"unknown";
  }
}

#line 3932  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u64 i40e_pit_index_to_mask(int pit_index)
{
  #line 3934 
  switch (pit_index) {
    #line 3935 
    case 0: 
            #line 3935 
    ;
    #line 3936 
    return 8192ULL;
    #line 3937 
    case 1: 
            #line 3937 
    ;
    #line 3938 
    return 4096ULL;
    #line 3939 
    case 2: 
            #line 3939 
    ;
    #line 3940 
    return 2048ULL;
    #line 3941 
    case 3: 
            #line 3941 
    ;
    #line 3942 
    return 1024ULL;
    #line 3943 
    case 4: 
            #line 3943 
    ;
    #line 3944 
    return 512ULL;
    #line 3945 
    case 5: 
            #line 3945 
    ;
    #line 3946 
    return 256ULL;
    #line 3947 
    case 6: 
            #line 3947 
    ;
    #line 3948 
    return 128ULL;
    #line 3949 
    case 7: 
            #line 3949 
    ;
    #line 3950 
    return 64ULL;
    #line 3951 
    default: 
             #line 3951 
    ;
    #line 3952 
    return 0ULL;
  }
}

#line 3966  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_print_input_set(struct i40e_vsi *vsi, u64 old, u64 new)
{
  #line 3969 
  bool old_value;
  #line 3969 
  bool new_value;
  #line 3970 
  int i;
  #line 3968 
  struct i40e_pf *pf = vsi->back;
  #line 3972 
  old_value = (_Bool)((old & 422212465065984ULL) != 0ULL);
  #line 3973 
  new_value = (_Bool)((new & 422212465065984ULL) != 0ULL);
  #line 3974 
  if ((int)old_value != (int)new_value) 
    #line 3975 
    if ((pf->msg_enable & 1U) != 0U) {
      #line 3975 
      char *tmp;
      #line 3975 
      char *tmp_0;
      #line 3975 
      if ((int)new_value != 0) 
                               #line 3975 
                               tmp = (char *)"ON"; else 
                                                        #line 3975 
                                                        tmp = (char *)"OFF";
      #line 3975 
      if ((int)old_value != 0) 
                               #line 3975 
                               tmp_0 = (char *)"ON"; else 
                                                          #line 3975 
                                                          tmp_0 = (char *)"OFF";
      #line 3975 
      ;
      #line 3975 
      netdev_info(vsi->netdev,(char *)"L3 source address: %s -> %s\n",tmp_0,tmp);
    }
  #line 3979 
  old_value = (_Bool)((old & 103079215104ULL) != 0ULL);
  #line 3980 
  new_value = (_Bool)((new & 103079215104ULL) != 0ULL);
  #line 3981 
  if ((int)old_value != (int)new_value) 
    #line 3982 
    if ((pf->msg_enable & 1U) != 0U) {
      #line 3982 
      char *tmp_1;
      #line 3982 
      char *tmp_2;
      #line 3982 
      if ((int)new_value != 0) 
                               #line 3982 
                               tmp_1 = (char *)"ON"; else 
                                                          #line 3982 
                                                          tmp_1 = (char *)"OFF";
      #line 3982 
      if ((int)old_value != 0) 
                               #line 3982 
                               tmp_2 = (char *)"ON"; else 
                                                          #line 3982 
                                                          tmp_2 = (char *)"OFF";
      #line 3982 
      ;
      #line 3982 
      netdev_info(vsi->netdev,(char *)"L3 destination address: %s -> %s\n",tmp_2,tmp_1);
    }
  #line 3986 
  old_value = (_Bool)((old & 17179869184ULL) != 0ULL);
  #line 3987 
  new_value = (_Bool)((new & 17179869184ULL) != 0ULL);
  #line 3988 
  if ((int)old_value != (int)new_value) 
    #line 3989 
    if ((pf->msg_enable & 1U) != 0U) {
      #line 3989 
      char *tmp_3;
      #line 3989 
      char *tmp_4;
      #line 3989 
      if ((int)new_value != 0) 
                               #line 3989 
                               tmp_3 = (char *)"ON"; else 
                                                          #line 3989 
                                                          tmp_3 = (char *)"OFF";
      #line 3989 
      if ((int)old_value != 0) 
                               #line 3989 
                               tmp_4 = (char *)"ON"; else 
                                                          #line 3989 
                                                          tmp_4 = (char *)"OFF";
      #line 3989 
      ;
      #line 3989 
      netdev_info(vsi->netdev,(char *)"L4 source port: %s -> %s\n",tmp_4,tmp_3);
    }
  #line 3993 
  old_value = (_Bool)((old & 8589934592ULL) != 0ULL);
  #line 3994 
  new_value = (_Bool)((new & 8589934592ULL) != 0ULL);
  #line 3995 
  if ((int)old_value != (int)new_value) 
    #line 3996 
    if ((pf->msg_enable & 1U) != 0U) {
      #line 3996 
      char *tmp_5;
      #line 3996 
      char *tmp_6;
      #line 3996 
      if ((int)new_value != 0) 
                               #line 3996 
                               tmp_5 = (char *)"ON"; else 
                                                          #line 3996 
                                                          tmp_5 = (char *)"OFF";
      #line 3996 
      if ((int)old_value != 0) 
                               #line 3996 
                               tmp_6 = (char *)"ON"; else 
                                                          #line 3996 
                                                          tmp_6 = (char *)"OFF";
      #line 3996 
      ;
      #line 3996 
      netdev_info(vsi->netdev,(char *)"L4 destination port: %s -> %s\n",tmp_6,tmp_5);
    }
  #line 4000 
  old_value = (_Bool)((old & 6442450944ULL) != 0ULL);
  #line 4001 
  new_value = (_Bool)((new & 6442450944ULL) != 0ULL);
  #line 4002 
  if ((int)old_value != (int)new_value) 
    #line 4003 
    if ((pf->msg_enable & 1U) != 0U) {
      #line 4003 
      char *tmp_7;
      #line 4003 
      char *tmp_8;
      #line 4003 
      if ((int)new_value != 0) 
                               #line 4003 
                               tmp_7 = (char *)"ON"; else 
                                                          #line 4003 
                                                          tmp_7 = (char *)"OFF";
      #line 4003 
      if ((int)old_value != 0) 
                               #line 4003 
                               tmp_8 = (char *)"ON"; else 
                                                          #line 4003 
                                                          tmp_8 = (char *)"OFF";
      #line 4003 
      ;
      #line 4003 
      netdev_info(vsi->netdev,(char *)"SCTP verification tag: %s -> %s\n",tmp_8,tmp_7);
    }
  #line 4008 
  i = 0;
  #line 4008 
  while (i <= 7) {
    {
      #line 4009 
      u64 flex_mask = i40e_pit_index_to_mask(i);
      #line 4011 
      old_value = (_Bool)((old & flex_mask) != 0ULL);
      #line 4012 
      new_value = (_Bool)((new & flex_mask) != 0ULL);
      #line 4013 
      if ((int)old_value != (int)new_value) 
        #line 4014 
        if ((pf->msg_enable & 1U) != 0U) {
          #line 4014 
          char *tmp_10;
          #line 4014 
          char *tmp_11;
          #line 4014 
          if ((int)new_value != 0) 
                                   #line 4014 
                                   tmp_10 = (char *)"ON"; else 
                                                               #line 4014 
                                                               tmp_10 = (char *)"OFF";
          #line 4014 
          if ((int)old_value != 0) 
                                   #line 4014 
                                   tmp_11 = (char *)"ON"; else 
                                                               #line 4014 
                                                               tmp_11 = (char *)"OFF";
          #line 4014 
          ;
          #line 4014 
          ;
          #line 4014 
          netdev_info(vsi->netdev,(char *)"FLEX index %d: %s -> %s\n",i,tmp_11,tmp_10);
        }
    }
    #line 4008 
    i ++;
  }
  #line 4020 
  if ((pf->msg_enable & 1U) != 0U) 
                                   #line 4020 
                                   netdev_info(vsi->netdev,(char *)"  Current input set: %0llx\n",old);
  #line 4022 
  if ((pf->msg_enable & 1U) != 0U) 
                                   #line 4022 
                                   netdev_info(vsi->netdev,(char *)"Requested input set: %0llx\n",new);
  #line 4023 
  return;
}

#line 4051  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_check_fdir_input_set(struct i40e_vsi *vsi, struct ethtool_rx_flow_spec *fsp, struct i40e_rx_flow_userdef *userdef)
{
  #line 4056 
  struct ethtool_tcpip4_spec *tcp_ip4_spec;
  #line 4057 
  struct ethtool_usrip4_spec *usr_ip4_spec;
  #line 4058 
  u64 current_mask;
  #line 4058 
  u64 new_mask;
  #line 4061 
  u16 *fdir_filter_count;
  #line 4062 
  u16 index;
  #line 4064 
  int err;
  #line 4055 
  struct i40e_pf *pf = vsi->back;
  #line 4059 
  bool new_flex_offset = (_Bool)0;
  #line 4060 
  bool flex_l3 = (_Bool)0;
  #line 4062 
  u16 src_offset = (unsigned short)0U;
  #line 4063 
  u8 pit_index = (unsigned char)0U;
  #line 4066 
  switch (fsp->flow_type & 2147483647U) {
    #line 4067 
    case (unsigned int)3: 
                          #line 4067 
    ;
    #line 4068 
    index = (unsigned short)34U;
    #line 4069 
    fdir_filter_count = & pf->fd_sctp4_filter_cnt;
    #line 4070 
    break;
    #line 4071 
    case (unsigned int)1: 
                          #line 4071 
    ;
    #line 4072 
    index = (unsigned short)33U;
    #line 4073 
    fdir_filter_count = & pf->fd_tcp4_filter_cnt;
    #line 4074 
    break;
    #line 4075 
    case (unsigned int)2: 
                          #line 4075 
    ;
    #line 4076 
    index = (unsigned short)31U;
    #line 4077 
    fdir_filter_count = & pf->fd_udp4_filter_cnt;
    #line 4078 
    break;
    #line 4079 
    case (unsigned int)13: 
                           #line 4079 
    ;
    #line 4080 
    index = (unsigned short)35U;
    #line 4081 
    fdir_filter_count = & pf->fd_ip4_filter_cnt;
    #line 4082 
    flex_l3 = (_Bool)1;
    #line 4083 
    break;
    #line 4084 
    default: 
             #line 4084 
    ;
    #line 4085 
    return -95;
  }
  #line 4089 
  current_mask = i40e_read_fd_input_set(pf,(unsigned short)((int)index));
  #line 4090 
  new_mask = current_mask;
  #line 4101 
  switch (fsp->flow_type & 2147483647U) {
    #line 4102 
    case (unsigned int)3: 
                          #line 4102 
    ;
    #line 4103 
    new_mask &= 18446744067267100671ULL;
    #line 4105 
    case (unsigned int)1: 
                          #line 4105 
    ;
    #line 4106 
    case (unsigned int)2: 
                          #line 4106 
    ;
    #line 4107 
    tcp_ip4_spec = & fsp->m_u.tcp_ip4_spec;
    #line 4110 
    if (tcp_ip4_spec->ip4src == 4294967295U) 
                                             #line 4111 
                                             new_mask |= 422212465065984ULL;
    else 
      #line 4112 
      if (tcp_ip4_spec->ip4src == 0U) 
                                      #line 4113 
                                      new_mask &= 18446321861244485631ULL; else 
                                                                    #line 4115 
                                                                    return -95;
    #line 4118 
    if (tcp_ip4_spec->ip4dst == 4294967295U) 
                                             #line 4119 
                                             new_mask |= 103079215104ULL;
    else 
      #line 4120 
      if (tcp_ip4_spec->ip4dst == 0U) 
                                      #line 4121 
                                      new_mask &= 18446743970630336511ULL; else 
                                                                    #line 4123 
                                                                    return -95;
    #line 4126 
    if ((unsigned int)tcp_ip4_spec->psrc == 65535U) 
                                                    #line 4127 
                                                    new_mask |= 17179869184ULL;
    else 
      #line 4128 
      if ((unsigned int)tcp_ip4_spec->psrc == 0U) 
                                                  #line 4129 
                                                  new_mask &= 18446744056529682431ULL; else 
                                                                    #line 4131 
                                                                    return -95;
    #line 4134 
    if ((unsigned int)tcp_ip4_spec->pdst == 65535U) 
                                                    #line 4135 
                                                    new_mask |= 8589934592ULL;
    else 
      #line 4136 
      if ((unsigned int)tcp_ip4_spec->pdst == 0U) 
                                                  #line 4137 
                                                  new_mask &= 18446744065119617023ULL; else 
                                                                    #line 4139 
                                                                    return -95;
    #line 4142 
    if ((unsigned int)tcp_ip4_spec->tos != 0U) 
                                               #line 4143 
                                               return -95;
    #line 4145 
    break;
    #line 4146 
    case (unsigned int)13: 
                           #line 4146 
    ;
    #line 4147 
    usr_ip4_spec = & fsp->m_u.usr_ip4_spec;
    #line 4150 
    if (usr_ip4_spec->ip4src == 4294967295U) 
                                             #line 4151 
                                             new_mask |= 422212465065984ULL;
    else 
      #line 4152 
      if (usr_ip4_spec->ip4src == 0U) 
                                      #line 4153 
                                      new_mask &= 18446321861244485631ULL; else 
                                                                    #line 4155 
                                                                    return -95;
    #line 4158 
    if (usr_ip4_spec->ip4dst == 4294967295U) 
                                             #line 4159 
                                             new_mask |= 103079215104ULL;
    else 
      #line 4160 
      if (usr_ip4_spec->ip4dst == 0U) 
                                      #line 4161 
                                      new_mask &= 18446743970630336511ULL; else 
                                                                    #line 4163 
                                                                    return -95;
    #line 4166 
    if (usr_ip4_spec->l4_4_bytes == 4294967295U) 
                                                 #line 4167 
                                                 new_mask |= 25769803776ULL;
    else 
      #line 4168 
      if (usr_ip4_spec->l4_4_bytes == 0U) 
                                          #line 4169 
                                          new_mask &= 18446744047939747839ULL; else 
                                                                    #line 4171 
                                                                    return -95;
    #line 4174 
    if ((unsigned int)usr_ip4_spec->tos != 0U) 
                                               #line 4175 
                                               return -95;
    #line 4178 
    if ((unsigned int)usr_ip4_spec->ip_ver != 0U) 
                                                  #line 4179 
                                                  return -22;
    #line 4182 
    if ((unsigned int)usr_ip4_spec->proto != 0U) 
                                                 #line 4183 
                                                 return -22;
    #line 4185 
    break;
    #line 4186 
    default: 
             #line 4186 
    ;
    #line 4187 
    return -95;
  }
  #line 4191 
  new_mask &= 18446744073709535295ULL;
  #line 4198 
  if ((int)userdef->flex_filter != 0) {
    #line 4199 
    struct i40e_flex_pit *l3_flex_pit = (struct i40e_flex_pit *)0;
    #line 4199 
    struct i40e_flex_pit *flex_pit = (struct i40e_flex_pit *)0;
    #line 4204 
    if (((int)userdef->flex_offset & 1) != 0) {
      #line 4205 
      _dev_warn(& (pf->pdev)->dev,(char *)"Flexible data offset must be 2-byte aligned\n");
      #line 4207 
      return -22;
    }
    #line 4210 
    src_offset = (unsigned short)((int)userdef->flex_offset >> 1);
    #line 4213 
    if ((unsigned int)src_offset > 31U) {
      #line 4214 
      _dev_warn(& (pf->pdev)->dev,(char *)"Flexible data must reside within first 64 bytes of the packet payload\n");
      #line 4216 
      return -22;
    }
    #line 4224 
    flex_pit = i40e_find_flex_offset(& pf->l4_flex_pit_list,(unsigned short)((int)src_offset));
    #line 4226 
    if ((int)IS_ERR_1((void *)flex_pit) != 0) {
      #line 4227 
      return (int)PTR_ERR_1((void *)flex_pit);
    }
    #line 4236 
    if ((int)flex_l3 != 0) {
      #line 4237 
      l3_flex_pit = i40e_find_flex_offset(& pf->l3_flex_pit_list,(unsigned short)((int)src_offset));
      #line 4240 
      if ((int)IS_ERR_1((void *)l3_flex_pit) != 0) {
        #line 4241 
        return (int)PTR_ERR_1((void *)l3_flex_pit);
      }
      #line 4243 
      if (flex_pit != (struct i40e_flex_pit *)0) 
        #line 4248 
        if (l3_flex_pit != (struct i40e_flex_pit *)0) {
          #line 4249 
          if ((int)l3_flex_pit->pit_index != (int)flex_pit->pit_index) 
            #line 4251 
            return -22;
        }
        else 
             #line 4254 
             new_flex_offset = (_Bool)1;
      else 
           #line 4257 
           flex_pit = l3_flex_pit;
    }
    #line 4266 
    if (flex_pit == (struct i40e_flex_pit *)0) {
      #line 4267 
      new_flex_offset = (_Bool)1;
      #line 4268 
      pit_index = i40e_unused_pit_index(pf);
    }
    else 
         #line 4270 
         pit_index = flex_pit->pit_index;
    #line 4274 
    new_mask = i40e_pit_index_to_mask((int)pit_index) | new_mask;
  }
  #line 4281 
  if (new_mask == current_mask && ! new_flex_offset) 
                                                     #line 4282 
                                                     return 0;
  #line 4284 
  if ((pf->msg_enable & 1U) != 0U) {
    #line 4284 
    ;
    #line 4284 
    netdev_info(vsi->netdev,(char *)"Input set change requested for %s flows:\n",i40e_flow_str(fsp));
  }
  #line 4286 
  i40e_print_input_set(vsi,current_mask,new_mask);
  #line 4287 
  if ((int)new_flex_offset != 0) 
    #line 4288 
    if ((pf->msg_enable & 1U) != 0U) 
                                     #line 4288 
                                     netdev_info(vsi->netdev,(char *)"FLEX index %d: Offset -> %d",(int)pit_index,(int)src_offset);
  #line 4296 
  if (((unsigned long)pf->flags & 1024UL) != 0UL) {
    #line 4297 
    if ((pf->msg_enable & 1U) != 0U) 
                                     #line 4297 
                                     netdev_err(vsi->netdev,(char *)"Cannot change Flow Director input sets while MFP is enabled\n");
    #line 4298 
    return -95;
  }
  #line 4310 
  if ((unsigned int)*fdir_filter_count != 0U) {
    #line 4311 
    if ((pf->msg_enable & 1U) != 0U) {
      #line 4311 
      ;
      #line 4311 
      ;
      #line 4311 
      netdev_err(vsi->netdev,(char *)"Cannot change input set for %s flows until %d preexisting filters are removed\n",i40e_flow_str(fsp),(int)*fdir_filter_count);
    }
    #line 4314 
    return -95;
  }
  #line 4317 
  i40e_write_fd_input_set(pf,(unsigned short)((int)index),new_mask);
  #line 4325 
  if ((unsigned int)index == 35U) 
                                  #line 4326 
                                  i40e_write_fd_input_set(pf,(unsigned short)36,new_mask);
  #line 4330 
  if ((int)new_flex_offset != 0) {
    #line 4331 
    err = i40e_add_flex_offset(& pf->l4_flex_pit_list,(unsigned short)((int)src_offset),(unsigned char)((int)pit_index));
    #line 4333 
    if (err != 0) 
                  #line 4334 
                  return err;
    #line 4336 
    if ((int)flex_l3 != 0) {
      #line 4337 
      err = i40e_add_flex_offset(& pf->l3_flex_pit_list,(unsigned short)((int)src_offset),(unsigned char)((int)pit_index));
      #line 4340 
      if (err != 0) 
                    #line 4341 
                    return err;
    }
    #line 4344 
    i40e_reprogram_flex_pit(pf);
  }
  #line 4347 
  return 0;
}

#line 4360  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static bool i40e_match_fdir_filter(struct i40e_fdir_filter *a, struct i40e_fdir_filter *b)
{
  #line 4364 
  if (((((a->dst_ip != b->dst_ip || a->src_ip != b->src_ip) || (int)a->dst_port != (int)b->dst_port) || (int)a->src_port != (int)b->src_port) || (int)a->flow_type != (int)b->flow_type) || (int)a->ip4_proto != (int)b->ip4_proto) 
    #line 4370 
    return (_Bool)0;
  #line 4372 
  return (_Bool)1;
}

#line 4400  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_disallow_matching_filters(struct i40e_vsi *vsi, struct i40e_fdir_filter *input)
{
  #line 4408 
  void *__mptr;
  #line 4408 
  struct i40e_fdir_filter *tmp_0;
  #line 4404 
  struct i40e_fdir_filter *rule;
  #line 4405 
  struct hlist_node *node2;
  #line 4403 
  struct i40e_pf *pf = vsi->back;
  {
    #line 4408 
    struct hlist_node *____ptr = pf->fdir_filter_list.first;
    #line 4408 
    if (____ptr != (struct hlist_node *)0) {
      #line 4408 
      __mptr = (void *)____ptr;
      #line 4408 
      tmp_0 = ((struct i40e_fdir_filter *)__mptr);
    }
    else 
         #line 4408 
         tmp_0 = (struct i40e_fdir_filter *)0;
    }
  #line 4408 
  rule = tmp_0;
  #line 4408 
  while (1) {
    #line 4408 
    void *__mptr_0;
    #line 4408 
    struct i40e_fdir_filter *tmp_3;
    #line 4408 
    if (rule != (struct i40e_fdir_filter *)0) {
      #line 4408 
      node2 = rule->fdir_node.next;
      #line 4408 
      if (! (1 != 0)) 
                      #line 4408 
                      break;
    }
    else 
         #line 4408 
         break;
    {
      #line 4414 
      if (rule->fd_id == input->fd_id) 
                                       #line 4415 
                                       goto __Cont;
      #line 4420 
      if ((int)i40e_match_fdir_filter(rule,input) != 0) {
        #line 4421 
        _dev_warn(& (pf->pdev)->dev,(char *)"Existing user defined filter %d already matches this flow.\n",rule->fd_id);
        #line 4424 
        return -22;
      }
    }
    #line 4408 
    __Cont: { /* sequence */
              {
                #line 4408 
                struct hlist_node *____ptr_0 = node2;
                #line 4408 
                if (____ptr_0 != (struct hlist_node *)0) {
                  #line 4408 
                  __mptr_0 = (void *)____ptr_0;
                  #line 4408 
                  tmp_3 = ((struct i40e_fdir_filter *)__mptr_0);
                }
                else 
                     #line 4408 
                     tmp_3 = (struct i40e_fdir_filter *)0;
                }
              #line 4408 
              rule = tmp_3;
            }
  }
  #line 4428 
  return 0;
}

#line 4439  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_add_fdir_ethtool(struct i40e_vsi *vsi, struct ethtool_rxnfc *cmd)
{
  #line 4442 
  struct i40e_rx_flow_userdef userdef;
  #line 4443 
  struct ethtool_rx_flow_spec *fsp;
  #line 4444 
  struct i40e_fdir_filter *input;
  #line 4446 
  struct i40e_pf *pf;
  #line 4448 
  u8 dest_ctl;
  #line 4445 
  u16 dest_vsi = (unsigned short)0U;
  #line 4445 
  u16 q_index = (unsigned short)0U;
  #line 4447 
  int ret = -22;
  #line 4450 
  if (vsi == (struct i40e_vsi *)0) 
                                   #line 4451 
                                   return -22;
  #line 4452 
  pf = vsi->back;
  #line 4454 
  if (((unsigned long)pf->flags & 256UL) == 0UL) 
                                                 #line 4455 
                                                 return -95;
  #line 4457 
  if ((int)test_bit(23L,(unsigned long *)(& pf->state)) != 0) 
                                                              #line 4458 
                                                              return -28;
  #line 4460 
  if ((int)test_bit(8L,(unsigned long *)(& pf->state)) != 0) 
                                                             #line 4462 
                                                             return -16;
  else {
    #line 4460 
    if ((int)test_bit(11L,(unsigned long *)(& pf->state)) != 0) 
                                                                #line 4462 
                                                                return -16;
  }
  #line 4464 
  if ((int)test_bit(21L,(unsigned long *)(& pf->state)) != 0) 
                                                              #line 4465 
                                                              return -16;
  #line 4467 
  fsp = & cmd->fs;
  #line 4470 
  if (i40e_parse_rx_flow_user_data(fsp,& userdef) != 0) 
                                                        #line 4471 
                                                        return -22;
  #line 4474 
  if ((fsp->flow_type & 1073741824U) != 0U) 
                                            #line 4475 
                                            return -22;
  #line 4477 
  ret = i40e_check_fdir_input_set(vsi,fsp,& userdef);
  #line 4478 
  if (ret != 0) 
                #line 4479 
                return ret;
  #line 4481 
  if (fsp->location >= pf->hw.func_caps.fd_filters_best_effort + pf->hw.func_caps.fd_filters_guaranteed) 
    #line 4483 
    return -22;
  #line 4489 
  if (fsp->ring_cookie == 18446744073709551615ULL) 
                                                   #line 4490 
                                                   dest_ctl = (unsigned char)0U;
  else {
    #line 4492 
    u32 ring = (unsigned int)ethtool_get_flow_spec_ring(fsp->ring_cookie);
    #line 4493 
    u8 vf = (unsigned char)ethtool_get_flow_spec_ring_vf(fsp->ring_cookie);
    #line 4495 
    if ((unsigned int)vf == 0U) {
      #line 4496 
      if ((unsigned int)vsi->num_queue_pairs <= ring) 
                                                      #line 4497 
                                                      return -22;
      #line 4498 
      dest_vsi = vsi->id;
    }
    else {
      #line 4501 
      vf = (u8)((int)vf - 1);
      #line 4503 
      if ((int)vf >= pf->num_alloc_vfs) 
                                        #line 4504 
                                        return -22;
      #line 4505 
      if ((unsigned int)(pf->vf + (unsigned long)vf)->num_queue_pairs <= ring) 
        #line 4506 
        return -22;
      #line 4507 
      dest_vsi = (pf->vf + (unsigned long)vf)->lan_vsi_id;
    }
    #line 4509 
    dest_ctl = (unsigned char)1U;
    #line 4510 
    q_index = (unsigned short)ring;
  }
  #line 4513 
  input = (struct i40e_fdir_filter *)kzalloc_5(56UL,3264U);
  #line 4515 
  if (input == (struct i40e_fdir_filter *)0) 
                                             #line 4516 
                                             return -12;
  #line 4518 
  input->fd_id = fsp->location;
  #line 4519 
  input->q_index = q_index;
  #line 4520 
  input->dest_vsi = dest_vsi;
  #line 4521 
  input->dest_ctl = dest_ctl;
  #line 4522 
  input->fd_status = (unsigned char)1U;
  #line 4523 
  input->cnt_index = (unsigned short)((unsigned int)((unsigned short)pf->hw.pf_id) * 3U + 1U);
  #line 4524 
  input->dst_ip = fsp->h_u.tcp_ip4_spec.ip4src;
  #line 4525 
  input->src_ip = fsp->h_u.tcp_ip4_spec.ip4dst;
  #line 4526 
  input->flow_type = (unsigned char)fsp->flow_type;
  #line 4527 
  input->ip4_proto = fsp->h_u.usr_ip4_spec.proto;
  #line 4532 
  input->dst_port = fsp->h_u.tcp_ip4_spec.psrc;
  #line 4533 
  input->src_port = fsp->h_u.tcp_ip4_spec.pdst;
  #line 4534 
  input->dst_ip = fsp->h_u.tcp_ip4_spec.ip4src;
  #line 4535 
  input->src_ip = fsp->h_u.tcp_ip4_spec.ip4dst;
  #line 4537 
  if ((int)userdef.flex_filter != 0) {
    #line 4538 
    input->flex_filter = (_Bool)1;
    #line 4539 
    input->flex_word = __builtin_bswap16((unsigned short)((int)userdef.flex_word));
    #line 4540 
    input->flex_offset = userdef.flex_offset;
  }
  #line 4544 
  ret = i40e_disallow_matching_filters(vsi,input);
  #line 4545 
  if (ret != 0) 
                #line 4546 
                goto free_filter_memory;
  #line 4552 
  i40e_update_ethtool_fdir_entry(vsi,input,(unsigned short)((int)((unsigned short)fsp->location)),(struct ethtool_rxnfc *)0);
  #line 4553 
  ret = i40e_add_del_fdir(vsi,input,(_Bool)1);
  #line 4554 
  if (ret != 0) 
                #line 4555 
                goto remove_sw_rule;
  #line 4556 
  return 0;
  #line 4558 
  remove_sw_rule: 
                  #line 4558 
  ;
  #line 4559 
  hlist_del_1(& input->fdir_node);
  #line 4560 
  pf->fdir_pf_active_filters = (u16)((int)pf->fdir_pf_active_filters - 1);
  #line 4561 
  free_filter_memory: 
                      #line 4561 
  ;
  #line 4562 
  kfree((void *)input);
  #line 4563 
  return ret;
}

#line 4573  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd)
{
  #line 4575 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 4576 
  struct i40e_vsi *vsi = np->vsi;
  #line 4577 
  struct i40e_pf *pf = vsi->back;
  #line 4578 
  int ret = -95;
  #line 4580 
  switch (cmd->cmd) {
    #line 4581 
    case (__u32)42: 
                    #line 4581 
    ;
    #line 4582 
    ret = i40e_set_rss_hash_opt(pf,cmd);
    #line 4583 
    break;
    #line 4584 
    case (__u32)50: 
                    #line 4584 
    ;
    #line 4585 
    ret = i40e_add_fdir_ethtool(vsi,cmd);
    #line 4586 
    break;
    #line 4587 
    case (__u32)49: 
                    #line 4587 
    ;
    #line 4588 
    ret = i40e_del_fdir_entry(vsi,cmd);
    #line 4589 
    break;
    #line 4590 
    default: 
             #line 4590 
    ;
    #line 4591 
    break;
  }
  #line 4594 
  return ret;
}

#line 4601  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static unsigned int i40e_max_channels(struct i40e_vsi *vsi)
{
  #line 4604 
  return (unsigned int)vsi->alloc_queue_pairs;
}

#line 4617  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static void i40e_get_channels(struct net_device *dev, struct ethtool_channels *ch)
{
  #line 4620 
  struct i40e_netdev_priv *np = netdev_priv(dev);
  #line 4621 
  struct i40e_vsi *vsi = np->vsi;
  #line 4622 
  struct i40e_pf *pf = vsi->back;
  #line 4625 
  ch->max_combined = i40e_max_channels(vsi);
  #line 4628 
  ch->other_count = (unsigned int)((unsigned long)pf->flags >> 8) & 1U;
  #line 4629 
  ch->max_other = ch->other_count;
  #line 4632 
  ch->combined_count = (unsigned int)vsi->num_queue_pairs;
  #line 4633 
  return;
}

#line 4643  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_channels(struct net_device *dev, struct ethtool_channels *ch)
{
  #line 4681 
  void *__mptr;
  #line 4681 
  struct i40e_fdir_filter *tmp_2;
  #line 4651 
  struct i40e_fdir_filter *rule;
  #line 4652 
  struct hlist_node *node2;
  #line 4653 
  int new_count;
  #line 4646 
  u8 drop = (unsigned char)0U;
  #line 4647 
  struct i40e_netdev_priv *np = netdev_priv(dev);
  #line 4648 
  unsigned int count = ch->combined_count;
  #line 4649 
  struct i40e_vsi *vsi = np->vsi;
  #line 4650 
  struct i40e_pf *pf = vsi->back;
  #line 4654 
  int err = 0;
  #line 4657 
  if (vsi->type != (unsigned int)I40E_VSI_MAIN) 
                                                #line 4658 
                                                return -22;
  #line 4663 
  if (((unsigned long)pf->flags & 2097152UL) != 0UL) 
                                                     #line 4664 
                                                     return -22;
  #line 4667 
  if ((count == 0U || ch->rx_count != 0U) || ch->tx_count != 0U) 
                                                                 #line 4668 
                                                                 return -22;
  #line 4671 
  if (ch->other_count != ((unsigned int)((unsigned long)pf->flags >> 8) & 1U)) 
    #line 4672 
    return -22;
  #line 4675 
  ;
  #line 4675 
  if (i40e_max_channels(vsi) < count) 
                                      #line 4676 
                                      return -22;
  {
    #line 4681 
    struct hlist_node *____ptr = pf->fdir_filter_list.first;
    #line 4681 
    if (____ptr != (struct hlist_node *)0) {
      #line 4681 
      __mptr = (void *)____ptr;
      #line 4681 
      tmp_2 = ((struct i40e_fdir_filter *)__mptr);
    }
    else 
         #line 4681 
         tmp_2 = (struct i40e_fdir_filter *)0;
    }
  #line 4681 
  rule = tmp_2;
  #line 4681 
  while (1) {
    #line 4681 
    struct i40e_fdir_filter *tmp_5;
    #line 4681 
    void *__mptr_0;
    #line 4681 
    if (rule != (struct i40e_fdir_filter *)0) {
      #line 4681 
      node2 = rule->fdir_node.next;
      #line 4681 
      if (! (1 != 0)) 
                      #line 4681 
                      break;
    }
    else 
         #line 4681 
         break;
    #line 4683 
    if ((unsigned int)rule->dest_ctl != 0U && (unsigned int)rule->q_index >= count) {
      #line 4684 
      _dev_warn(& (pf->pdev)->dev,(char *)"Existing user defined filter %d assigns flow to queue %d\n",rule->fd_id,(int)rule->q_index);
      #line 4687 
      err = -22;
    }
    {
      #line 4681 
      struct hlist_node *____ptr_0 = node2;
      #line 4681 
      if (____ptr_0 != (struct hlist_node *)0) {
        #line 4681 
        __mptr_0 = (void *)____ptr_0;
        #line 4681 
        tmp_5 = ((struct i40e_fdir_filter *)__mptr_0);
      }
      else 
           #line 4681 
           tmp_5 = (struct i40e_fdir_filter *)0;
      }
    #line 4681 
    rule = tmp_5;
  }
  #line 4691 
  if (err != 0) {
    #line 4692 
    _dev_err(& (pf->pdev)->dev,(char *)"Existing filter rules must be deleted to reduce combined channel count to %d\n",count);
    #line 4695 
    return err;
  }
  #line 4704 
  new_count = i40e_reconfig_rss_queues(pf,(int)count);
  #line 4705 
  if (new_count > 0) 
                     #line 4706 
                     return 0; else 
                                    #line 4708 
                                    return -22;
}

#line 4717  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u32 i40e_get_rxfh_key_size(struct net_device *netdev)
{
  #line 4719 
  return 52U;
}

#line 4728  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u32 i40e_get_rxfh_indir_size(struct net_device *netdev)
{
  #line 4730 
  return 512U;
}

#line 4743  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key, u8 *hfunc)
{
  #line 4748 
  u8 *lut;
  #line 4749 
  int ret;
  #line 4750 
  u16 i;
  #line 4746 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 4747 
  struct i40e_vsi *vsi = np->vsi;
  #line 4748 
  u8 *seed = (u8 *)0U;
  #line 4752 
  if (hfunc != (u8 *)0U) 
                         #line 4753 
                         *hfunc = (unsigned char)1U;
  #line 4755 
  if (indir == (u32 *)0U) 
                          #line 4756 
                          return 0;
  #line 4758 
  seed = key;
  #line 4759 
  lut = (u8 *)kzalloc_5(512UL,3264U);
  #line 4760 
  if (lut == (u8 *)0U) 
                       #line 4761 
                       return -12;
  #line 4762 
  ret = i40e_get_rss(vsi,seed,lut,(unsigned short)512);
  #line 4763 
  if (ret != 0) 
                #line 4764 
                goto out;
  #line 4765 
  i = (unsigned short)0U;
  #line 4765 
  while ((unsigned int)i <= 511U) {
    #line 4766 
    *(indir + (unsigned long)i) = (unsigned int)*(lut + (unsigned long)i);
    #line 4765 
    i = (u16)((int)i + 1);
  }
  #line 4768 
  out: 
       #line 4768 
  ;
  #line 4769 
  kfree((void *)lut);
  #line 4771 
  return ret;
}

#line 4784  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_rxfh(struct net_device *netdev, u32 *indir, u8 *key, u8 hfunc)
{
  #line 4791 
  u16 i;
  #line 4787 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 4788 
  struct i40e_vsi *vsi = np->vsi;
  #line 4789 
  struct i40e_pf *pf = vsi->back;
  #line 4790 
  u8 *seed = (u8 *)0U;
  #line 4793 
  if ((unsigned int)hfunc > 1U) 
                                #line 4794 
                                return -95;
  #line 4796 
  if (key != (u8 *)0U) {
    #line 4797 
    if (vsi->rss_hkey_user == (u8 *)0U) {
      #line 4798 
      vsi->rss_hkey_user = (u8 *)kzalloc_5(52UL,3264U);
      #line 4800 
      if (vsi->rss_hkey_user == (u8 *)0U) 
                                          #line 4801 
                                          return -12;
    }
    #line 4803 
    memcpy((void *)vsi->rss_hkey_user,(void *)key,52UL);
    #line 4804 
    seed = vsi->rss_hkey_user;
  }
  #line 4806 
  if (vsi->rss_lut_user == (u8 *)0U) {
    #line 4807 
    vsi->rss_lut_user = (u8 *)kzalloc_5(512UL,3264U);
    #line 4808 
    if (vsi->rss_lut_user == (u8 *)0U) 
                                       #line 4809 
                                       return -12;
  }
  #line 4813 
  if (indir != (u32 *)0U) {
    #line 4814 
    i = (unsigned short)0U;
    #line 4814 
    while ((unsigned int)i <= 511U) {
      #line 4815 
      *(vsi->rss_lut_user + (unsigned long)i) = (unsigned char)*(indir + (unsigned long)i);
      #line 4814 
      i = (u16)((int)i + 1);
    }
  }
  else 
       #line 4817 
       i40e_fill_rss_lut(pf,vsi->rss_lut_user,(unsigned short)512,(unsigned short)((int)vsi->rss_size));
  #line 4820 
  return i40e_config_rss(vsi,seed,vsi->rss_lut_user,(unsigned short)512);
}

#line 4834  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static u32 i40e_get_priv_flags(struct net_device *dev)
{
  #line 4839 
  u32 i;
  #line 4839 
  u32 j;
  #line 4836 
  struct i40e_netdev_priv *np = netdev_priv(dev);
  #line 4837 
  struct i40e_vsi *vsi = np->vsi;
  #line 4838 
  struct i40e_pf *pf = vsi->back;
  #line 4839 
  u32 ret_flags = 0U;
  #line 4841 
  i = 0U;
  #line 4841 
  while (i <= 10U) {
    {
      #line 4842 
      struct i40e_priv_flags *priv_flags;
      #line 4844 
      priv_flags = & i40e_gstrings_priv_flags[i];
      #line 4846 
      if ((priv_flags->flag & (unsigned long long)pf->flags) != 0ULL) 
        #line 4847 
        ret_flags = (unsigned int)(1UL << i) | ret_flags;
    }
    #line 4841 
    i ++;
  }
  #line 4850 
  if ((unsigned int)pf->hw.pf_id != 0U) 
                                        #line 4851 
                                        return ret_flags;
  #line 4853 
  j = 0U;
  #line 4853 
  while (j == 0U) {
    {
      #line 4854 
      struct i40e_priv_flags *priv_flags_0;
      #line 4856 
      priv_flags_0 = & i40e_gl_gstrings_priv_flags[j];
      #line 4858 
      if ((priv_flags_0->flag & (unsigned long long)pf->flags) != 0ULL) 
        #line 4859 
        ret_flags = (unsigned int)(1UL << (i + j)) | ret_flags;
    }
    #line 4853 
    j ++;
  }
  #line 4862 
  return ret_flags;
}

#line 4870  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_priv_flags(struct net_device *dev, u32 flags)
{
  #line 4882 
  union __anonunion___u_19616 __u;
  #line 4873 
  u64 orig_flags;
  #line 4873 
  u64 new_flags;
  #line 4873 
  u64 changed_flags;
  #line 4874 
  enum i40e_admin_queue_err adq_err;
  #line 4877 
  bool is_reset_needed;
  #line 4878 
  i40e_status status;
  #line 4879 
  u32 i;
  #line 4879 
  u32 j;
  #line 4872 
  struct i40e_netdev_priv *np = netdev_priv(dev);
  #line 4875 
  struct i40e_vsi *vsi = np->vsi;
  #line 4876 
  struct i40e_pf *pf = vsi->back;
  #line 4881 
  __read_once_size((void *)(& pf->flags),(void *)(& __u.__c),4);
  #line 4881 
  orig_flags = (unsigned long long)(__u.__val);
  #line 4882 
  new_flags = orig_flags;
  #line 4884 
  i = 0U;
  #line 4884 
  while (i <= 10U) {
    {
      #line 4885 
      struct i40e_priv_flags *priv_flags;
      #line 4887 
      priv_flags = & i40e_gstrings_priv_flags[i];
      #line 4889 
      if ((((unsigned long)flags >> i) & 1UL) != 0UL) 
                                                      #line 4890 
                                                      new_flags = priv_flags->flag | new_flags; else 
                                                                    #line 4892 
                                                                    new_flags = ~ priv_flags->flag & new_flags;
      #line 4895 
      if ((int)priv_flags->read_only != 0 && ((orig_flags ^ new_flags) & (unsigned long long)(~ (1UL << i))) != 0ULL) 
        #line 4897 
        return -95;
    }
    #line 4884 
    i ++;
  }
  #line 4900 
  if ((unsigned int)pf->hw.pf_id != 0U) 
                                        #line 4901 
                                        goto flags_complete;
  #line 4903 
  j = 0U;
  #line 4903 
  while (j == 0U) {
    {
      #line 4904 
      struct i40e_priv_flags *priv_flags_0;
      #line 4906 
      priv_flags_0 = & i40e_gl_gstrings_priv_flags[j];
      #line 4908 
      if ((((unsigned long)flags >> (i + j)) & 1UL) != 0UL) 
                                                            #line 4909 
                                                            new_flags = priv_flags_0->flag | new_flags; else 
                                                                    #line 4911 
                                                                    new_flags = ~ priv_flags_0->flag & new_flags;
      #line 4914 
      if ((int)priv_flags_0->read_only != 0 && ((orig_flags ^ new_flags) & (unsigned long long)(~ (1UL << i))) != 0ULL) 
        #line 4916 
        return -95;
    }
    #line 4903 
    j ++;
  }
  #line 4919 
  flags_complete: 
                  #line 4919 
  ;
  #line 4920 
  changed_flags = orig_flags ^ new_flags;
  #line 4922 
  is_reset_needed = (_Bool)((changed_flags & 17899520ULL) != 0ULL);
  #line 4931 
  if ((new_flags & 2048ULL) != 0ULL && ((unsigned long)pf->hw_features & 4UL) == 0UL) 
    #line 4933 
    return -95;
  #line 4943 
  if ((changed_flags & 16777216ULL) != 0ULL) 
    #line 4944 
    if ((pf->hw.flags & 16ULL) == 0ULL) {
      #line 4945 
      _dev_warn(& (pf->pdev)->dev,(char *)"Device does not support changing FW LLDP\n");
      #line 4947 
      return -95;
    }
  #line 4951 
  if ((((changed_flags & 33554432ULL) != 0ULL || (changed_flags & 67108864ULL) != 0ULL) && (unsigned int)pf->hw.device_id != 5515U) && (unsigned int)pf->hw.device_id != 5514U) {
    #line 4955 
    _dev_warn(& (pf->pdev)->dev,(char *)"Device does not support changing FEC configuration\n");
    #line 4957 
    return -95;
  }
  #line 4966 
  if ((changed_flags & 512ULL) != 0ULL && (new_flags & 512ULL) == 0ULL) {
    #line 4968 
    cif_set_bit_4(22L,(unsigned long *)(& pf->state));
    #line 4969 
    cif_set_bit_4(21L,(unsigned long *)(& pf->state));
  }
  #line 4972 
  if ((changed_flags & 32768ULL) != 0ULL) {
    #line 4974 
    int ret;
    #line 4973 
    u16 sw_flags = (unsigned short)0U;
    #line 4973 
    u16 valid_flags = (unsigned short)0U;
    #line 4976 
    if ((new_flags & 32768ULL) == 0ULL) 
                                        #line 4977 
                                        sw_flags = (unsigned short)1U;
    #line 4978 
    valid_flags = (unsigned short)1U;
    #line 4979 
    ret = (int)i40e_aq_set_switch_config(& pf->hw,(unsigned short)((int)sw_flags),
                                  (unsigned short)((int)valid_flags),
                                  (unsigned char)0,
                                  (struct i40e_asq_cmd_details *)0);
    #line 4981 
    if (ret != 0 && pf->hw.aq.asq_last_status != (unsigned int)I40E_AQ_RC_ESRCH) {
      #line 4982 
      ;
      #line 4982 
      _dev_info(& (pf->pdev)->dev,(char *)"couldn\'t set switch config bits, err %s aq_err %s\n",i40e_stat_str(& pf->hw,(enum i40e_status_code)ret),i40e_aq_str(& pf->hw,pf->hw.aq.asq_last_status));
    }
  }
  #line 4991 
  if ((changed_flags & 33554432ULL) != 0ULL || (changed_flags & 67108864ULL) != 0ULL) {
    #line 4993 
    u8 fec_cfg = (unsigned char)0U;
    #line 4995 
    if ((new_flags & 33554432ULL) != 0ULL && (new_flags & 67108864ULL) != 0ULL) 
      #line 4997 
      fec_cfg = (unsigned char)16U;
    else 
      #line 4998 
      if ((new_flags & 33554432ULL) != 0ULL) 
                                             #line 4999 
                                             fec_cfg = (unsigned char)10U;
      else 
        #line 5001 
        if ((new_flags & 67108864ULL) != 0ULL) 
                                               #line 5002 
                                               fec_cfg = (unsigned char)5U;
    #line 5005 
    if (i40e_set_fec_cfg(dev,(unsigned char)((int)fec_cfg)) != 0) 
                                                                  #line 5006 
                                                                  _dev_warn(& (pf->pdev)->dev,(char *)"Cannot change FEC config\n");
  }
  #line 5009 
  if (((changed_flags & new_flags) & 524288ULL) != 0ULL && (new_flags & 1024ULL) != 0ULL) 
    #line 5012 
    _dev_warn(& (pf->pdev)->dev,(char *)"Turning on link-down-on-close flag may affect other partitions\n");
  #line 5015 
  if ((changed_flags & 16777216ULL) != 0ULL) 
    #line 5016 
    if ((new_flags & 16777216ULL) != 0ULL) {
      #line 5017 
      struct i40e_dcbx_config *dcbcfg;
      #line 5019 
      i40e_aq_stop_lldp(& pf->hw,(_Bool)1,(_Bool)0,(struct i40e_asq_cmd_details *)0);
      #line 5020 
      i40e_aq_set_dcb_parameters(& pf->hw,(_Bool)1,(struct i40e_asq_cmd_details *)0);
      #line 5022 
      dcbcfg = & pf->hw.local_dcbx_config;
      #line 5023 
      dcbcfg->etscfg.willing = (unsigned char)1U;
      #line 5024 
      dcbcfg->etscfg.maxtcs = (unsigned char)0U;
      #line 5025 
      dcbcfg->etscfg.tcbwtable[0] = (unsigned char)100U;
      #line 5026 
      i = 1U;
      #line 5026 
      while (i <= 7U) {
        #line 5027 
        dcbcfg->etscfg.tcbwtable[i] = (unsigned char)0U;
        #line 5026 
        i ++;
      }
      #line 5028 
      i = 0U;
      #line 5028 
      while (i <= 7U) {
        #line 5029 
        dcbcfg->etscfg.prioritytable[i] = (unsigned char)0U;
        #line 5028 
        i ++;
      }
      #line 5030 
      dcbcfg->etscfg.tsatable[0] = (unsigned char)2U;
      #line 5031 
      dcbcfg->pfc.willing = (unsigned char)1U;
      #line 5032 
      dcbcfg->pfc.pfccap = (unsigned char)8U;
    }
    else {
      #line 5034 
      status = i40e_aq_start_lldp(& pf->hw,(_Bool)0,(struct i40e_asq_cmd_details *)0);
      #line 5035 
      if (status != I40E_SUCCESS) {
        #line 5036 
        adq_err = pf->hw.aq.asq_last_status;
        #line 5037 
        switch ((unsigned int)adq_err) {
          #line 5038 
          case (unsigned int)13: 
                                 #line 5038 
          ;
          #line 5039 
          _dev_warn(& (pf->pdev)->dev,(char *)"FW LLDP agent is already running\n");
          #line 5041 
          is_reset_needed = (_Bool)0;
          #line 5042 
          break;
          #line 5043 
          case (unsigned int)1: 
                                #line 5043 
          ;
          #line 5044 
          _dev_warn(& (pf->pdev)->dev,(char *)"Device configuration forbids SW from starting the LLDP agent.\n");
          #line 5046 
          return -22;
          #line 5047 
          default: 
                   #line 5047 
          ;
          #line 5048 
          ;
          #line 5048 
          _dev_warn(& (pf->pdev)->dev,(char *)"Starting FW LLDP agent failed: error: %s, %s\n",i40e_stat_str(& pf->hw,status),i40e_aq_str(& pf->hw,adq_err));
          #line 5054 
          return -22;
        }
      }
    }
  #line 5065 
  pf->flags = (unsigned int)new_flags;
  #line 5070 
  if ((int)is_reset_needed != 0) 
                                 #line 5071 
                                 i40e_do_reset(pf,8192U,(_Bool)1);
  #line 5073 
  return 0;
}

#line 5081  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_module_info(struct net_device *netdev, struct ethtool_modinfo *modinfo)
{
  #line 5091 
  i40e_status status;
  #line 5084 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 5085 
  struct i40e_vsi *vsi = np->vsi;
  #line 5086 
  struct i40e_pf *pf = vsi->back;
  #line 5087 
  struct i40e_hw *hw = & pf->hw;
  #line 5088 
  u32 sff8472_comp = 0U;
  #line 5089 
  u32 sff8472_swap = 0U;
  #line 5090 
  u32 sff8636_rev = 0U;
  #line 5092 
  u32 type = 0U;
  #line 5095 
  if ((hw->flags & 4ULL) == 0ULL) {
    #line 5096 
    netdev_err(vsi->netdev,(char *)"Module EEPROM memory read not supported. Please update the NVM image.\n");
    #line 5097 
    return -22;
  }
  #line 5100 
  status = i40e_update_link_info(hw);
  #line 5101 
  if (status != I40E_SUCCESS) 
                              #line 5102 
                              return -5;
  #line 5104 
  if (hw->phy.link_info.phy_type == (unsigned int)I40E_PHY_TYPE_EMPTY) {
    #line 5105 
    netdev_err(vsi->netdev,(char *)"Cannot read module EEPROM memory. No module connected.\n");
    #line 5106 
    return -22;
  }
  #line 5109 
  type = (unsigned int)hw->phy.link_info.module_type[0];
  #line 5111 
  switch (type) {
    #line 5112 
    case (u32)3: 
                 #line 5112 
    ;
    #line 5113 
    status = i40e_aq_get_phy_register_ext(hw,(unsigned char)2,(unsigned char)160,(_Bool)1,(_Bool)0,(unsigned char)0,94U,& sff8472_comp,(struct i40e_asq_cmd_details *)0);
    #line 5118 
    if (status != I40E_SUCCESS) 
                                #line 5119 
                                return -5;
    #line 5121 
    status = i40e_aq_get_phy_register_ext(hw,(unsigned char)2,(unsigned char)160,(_Bool)1,(_Bool)0,(unsigned char)0,92U,& sff8472_swap,(struct i40e_asq_cmd_details *)0);
    #line 5126 
    if (status != I40E_SUCCESS) 
                                #line 5127 
                                return -5;
    #line 5132 
    if ((sff8472_swap & 4U) != 0U) {
      #line 5133 
      netdev_warn(vsi->netdev,(char *)"Module address swap to access page 0xA2 is not supported.\n");
      #line 5134 
      modinfo->type = 1U;
      #line 5135 
      modinfo->eeprom_len = 256U;
    }
    else 
      #line 5136 
      if (sff8472_comp == 0U) {
        #line 5138 
        modinfo->type = 1U;
        #line 5139 
        modinfo->eeprom_len = 256U;
      }
      else 
        #line 5140 
        if ((sff8472_swap & 64U) == 0U) {
          #line 5144 
          modinfo->type = 1U;
          #line 5145 
          modinfo->eeprom_len = 256U;
        }
        else {
          #line 5147 
          modinfo->type = 2U;
          #line 5148 
          modinfo->eeprom_len = 512U;
        }
    #line 5150 
    break;
    #line 5151 
    case (u32)13: 
                  #line 5151 
    ;
    #line 5153 
    status = i40e_aq_get_phy_register_ext(hw,(unsigned char)2,(unsigned char)0,(_Bool)1,(_Bool)0,(unsigned char)0,1U,& sff8636_rev,(struct i40e_asq_cmd_details *)0);
    #line 5158 
    if (status != I40E_SUCCESS) 
                                #line 5159 
                                return -5;
    #line 5161 
    if (sff8636_rev > 2U) {
      #line 5163 
      modinfo->type = 3U;
      #line 5164 
      modinfo->eeprom_len = 640U;
    }
    else {
      #line 5166 
      modinfo->type = 4U;
      #line 5167 
      modinfo->eeprom_len = 640U;
    }
    #line 5169 
    break;
    #line 5170 
    case (u32)17: 
                  #line 5170 
    ;
    #line 5171 
    modinfo->type = 3U;
    #line 5172 
    modinfo->eeprom_len = 640U;
    #line 5173 
    break;
    #line 5174 
    default: 
             #line 5174 
    ;
    #line 5175 
    netdev_err(vsi->netdev,(char *)"Module type unrecognized\n");
    #line 5176 
    return -22;
  }
  #line 5178 
  return 0;
}

#line 5187  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_module_eeprom(struct net_device *netdev, struct ethtool_eeprom *ee, u8 *data)
{
  #line 5196 
  i40e_status status;
  #line 5198 
  int i;
  #line 5191 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 5192 
  struct i40e_vsi *vsi = np->vsi;
  #line 5193 
  struct i40e_pf *pf = vsi->back;
  #line 5194 
  struct i40e_hw *hw = & pf->hw;
  #line 5195 
  bool is_sfp = (_Bool)0;
  #line 5197 
  u32 value = 0U;
  #line 5200 
  if ((ee == (struct ethtool_eeprom *)0 || ee->len == 0U) || data == (u8 *)0U) 
    #line 5201 
    return -22;
  #line 5203 
  if ((unsigned int)hw->phy.link_info.module_type[0] == 3U) 
                                                            #line 5204 
                                                            is_sfp = (_Bool)1;
  #line 5206 
  i = 0;
  #line 5206 
  while (ee->len > (unsigned int)i) {
    {
      #line 5208 
      unsigned int tmp_0;
      #line 5207 
      u32 offset = ee->offset + (unsigned int)i;
      #line 5208 
      if ((int)is_sfp != 0) 
                            #line 5208 
                            tmp_0 = 160U; else 
                                               #line 5208 
                                               tmp_0 = 0U;
      #line 5208 
      u32 addr = tmp_0;
      #line 5211 
      if ((int)is_sfp != 0) {
        #line 5212 
        if (offset > 255U) {
          #line 5213 
          offset += 4294967040U;
          #line 5214 
          addr = 162U;
        }
      }
      else 
        #line 5217 
        while (offset > 255U) {
          #line 5219 
          offset += 4294967168U;
          #line 5220 
          addr ++;
        }
      #line 5224 
      status = i40e_aq_get_phy_register_ext(hw,(unsigned char)2,(unsigned char)1,(_Bool)(addr != 0U),(_Bool)0,(unsigned char)0,offset,& value,(struct i40e_asq_cmd_details *)0);
      #line 5227 
      if (status != I40E_SUCCESS) 
                                  #line 5228 
                                  return -5;
      #line 5229 
      *(data + (unsigned long)i) = (unsigned char)value;
    }
    #line 5206 
    i ++;
  }
  #line 5231 
  return 0;
}

#line 5234  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_get_eee(struct net_device *netdev, struct ethtool_eee *edata)
{
  #line 5236 
  return -95;
}

#line 5239  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static int i40e_set_eee(struct net_device *netdev, struct ethtool_eee *edata)
{
  #line 5241 
  return -95;
}

#line 5244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct ethtool_ops i40e_ethtool_recovery_mode_ops = {.get_drvinfo = & i40e_get_drvinfo, .get_eeprom_len = & i40e_get_eeprom_len, .get_eeprom = & i40e_get_eeprom, .set_eeprom = & i40e_set_eeprom};
#line 5251  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
static struct ethtool_ops i40e_ethtool_ops = {.get_drvinfo = & i40e_get_drvinfo, .get_regs_len = & i40e_get_regs_len, .get_regs = & i40e_get_regs, .get_wol = & i40e_get_wol, .set_wol = & i40e_set_wol, .get_msglevel = & i40e_get_msglevel, .set_msglevel = & i40e_set_msglevel, .nway_reset = & i40e_nway_reset, .get_link = & ethtool_op_get_link, .get_eeprom_len = & i40e_get_eeprom_len, .get_eeprom = & i40e_get_eeprom, .set_eeprom = & i40e_set_eeprom, .get_coalesce = & i40e_get_coalesce, .set_coalesce = & i40e_set_coalesce, .get_ringparam = & i40e_get_ringparam, .set_ringparam = & i40e_set_ringparam, .get_pauseparam = & i40e_get_pauseparam, .set_pauseparam = & i40e_set_pauseparam, .self_test = & i40e_diag_test, .get_strings = & i40e_get_strings, .set_phys_id = & i40e_set_phys_id, .get_ethtool_stats = & i40e_get_ethtool_stats, .get_priv_flags = & i40e_get_priv_flags, .set_priv_flags = & i40e_set_priv_flags, .get_sset_count = & i40e_get_sset_count, .get_rxnfc = & i40e_get_rxnfc, .set_rxnfc = & i40e_set_rxnfc, .flash_device = & i40e_ddp_flash, .get_rxfh_key_size = & i40e_get_rxfh_key_size, .get_rxfh_indir_size = & i40e_get_rxfh_indir_size, .get_rxfh = & i40e_get_rxfh, .set_rxfh = & i40e_set_rxfh, .get_channels = & i40e_get_channels, .set_channels = & i40e_set_channels, .get_ts_info = & i40e_get_ts_info, .get_module_info = & i40e_get_module_info, .get_module_eeprom = & i40e_get_module_eeprom, .get_eee = & i40e_get_eee, .set_eee = & i40e_set_eee, .get_per_queue_coalesce = & i40e_get_per_queue_coalesce, .set_per_queue_coalesce = & i40e_set_per_queue_coalesce, .get_link_ksettings = & i40e_get_link_ksettings, .set_link_ksettings = & i40e_set_link_ksettings, .get_fecparam = & i40e_get_fec_param, .set_fecparam = & i40e_set_fec_param};
#line 5299  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/ethernet/intel/i40e/i40e_ethtool.c"
void i40e_set_ethtool_ops(struct net_device *netdev)
{
  #line 5301 
  struct i40e_netdev_priv *np = netdev_priv(netdev);
  #line 5302 
  struct i40e_pf *pf = (np->vsi)->back;
  #line 5304 
  if (test_bit(34L,(unsigned long *)(& pf->state))) 
                                                    #line 5307 
                                                    netdev->ethtool_ops = & i40e_ethtool_recovery_mode_ops; else 
                                                                    #line 5305 
                                                                    netdev->ethtool_ops = & i40e_ethtool_ops;
  #line 5308 
  return;
}

#line 107  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
void emg_wrapper_i40e_diag_test(struct net_device *arg0, struct ethtool_test *arg1, unsigned long long *arg2)
{
  #line 108 
  i40e_diag_test(arg0,arg1,arg2);
  #line 109 
  return;
}

#line 112  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
void emg_wrapper_i40e_get_channels(struct net_device *arg0, struct ethtool_channels *arg1)
{
  #line 113 
  i40e_get_channels(arg0,arg1);
  #line 114 
  return;
}

#line 117  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_get_coalesce(struct net_device *arg0, struct ethtool_coalesce *arg1)
{
  #line 118 
  return i40e_get_coalesce(arg0,arg1);
}

#line 122  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
void emg_wrapper_i40e_get_drvinfo(struct net_device *arg0, struct ethtool_drvinfo *arg1)
{
  #line 123 
  i40e_get_drvinfo(arg0,arg1);
  #line 124 
  return;
}

#line 127  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_get_eee(struct net_device *arg0, struct ethtool_eee *arg1)
{
  #line 128 
  return i40e_get_eee(arg0,arg1);
}

#line 132  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_get_eeprom(struct net_device *arg0, struct ethtool_eeprom *arg1, unsigned char *arg2)
{
  #line 133 
  return i40e_get_eeprom(arg0,arg1,arg2);
}

#line 137  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_get_eeprom_len(struct net_device *arg0)
{
  #line 138 
  return i40e_get_eeprom_len(arg0);
}

#line 142  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
void emg_wrapper_i40e_get_ethtool_stats(struct net_device *arg0, struct ethtool_stats *arg1, unsigned long long *arg2)
{
  #line 143 
  i40e_get_ethtool_stats(arg0,arg1,arg2);
  #line 144 
  return;
}

#line 147  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_get_fec_param(struct net_device *arg0, struct ethtool_fecparam *arg1)
{
  #line 148 
  return i40e_get_fec_param(arg0,arg1);
}

#line 152  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_get_link_ksettings(struct net_device *arg0, struct ethtool_link_ksettings *arg1)
{
  #line 153 
  return i40e_get_link_ksettings(arg0,arg1);
}

#line 157  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_get_module_eeprom(struct net_device *arg0, struct ethtool_eeprom *arg1, unsigned char *arg2)
{
  #line 158 
  return i40e_get_module_eeprom(arg0,arg1,arg2);
}

#line 162  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_get_module_info(struct net_device *arg0, struct ethtool_modinfo *arg1)
{
  #line 163 
  return i40e_get_module_info(arg0,arg1);
}

#line 167  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
unsigned int emg_wrapper_i40e_get_msglevel(struct net_device *arg0)
{
  #line 168 
  return i40e_get_msglevel(arg0);
}

#line 172  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
void emg_wrapper_i40e_get_pauseparam(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  #line 173 
  i40e_get_pauseparam(arg0,arg1);
  #line 174 
  return;
}

#line 177  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_get_per_queue_coalesce(struct net_device *arg0, unsigned int arg1, struct ethtool_coalesce *arg2)
{
  #line 178 
  return i40e_get_per_queue_coalesce(arg0,arg1,arg2);
}

#line 182  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
unsigned int emg_wrapper_i40e_get_priv_flags(struct net_device *arg0)
{
  #line 183 
  return i40e_get_priv_flags(arg0);
}

#line 187  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
void emg_wrapper_i40e_get_regs(struct net_device *arg0, struct ethtool_regs *arg1, void *arg2)
{
  #line 188 
  i40e_get_regs(arg0,arg1,arg2);
  #line 189 
  return;
}

#line 192  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_get_regs_len(struct net_device *arg0)
{
  #line 193 
  return i40e_get_regs_len(arg0);
}

#line 197  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
void emg_wrapper_i40e_get_ringparam(struct net_device *arg0, struct ethtool_ringparam *arg1)
{
  #line 198 
  i40e_get_ringparam(arg0,arg1);
  #line 199 
  return;
}

#line 202  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_get_rxfh(struct net_device *arg0, unsigned int *arg1, unsigned char *arg2, unsigned char *arg3)
{
  #line 203 
  return i40e_get_rxfh(arg0,arg1,arg2,arg3);
}

#line 207  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
unsigned int emg_wrapper_i40e_get_rxfh_indir_size(struct net_device *arg0)
{
  #line 208 
  return i40e_get_rxfh_indir_size(arg0);
}

#line 212  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
unsigned int emg_wrapper_i40e_get_rxfh_key_size(struct net_device *arg0)
{
  #line 213 
  return i40e_get_rxfh_key_size(arg0);
}

#line 217  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_get_rxnfc(struct net_device *arg0, struct ethtool_rxnfc *arg1, unsigned int *arg2)
{
  #line 218 
  return i40e_get_rxnfc(arg0,arg1,arg2);
}

#line 222  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_get_sset_count(struct net_device *arg0, int arg1)
{
  #line 223 
  return i40e_get_sset_count(arg0,arg1);
}

#line 227  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
void emg_wrapper_i40e_get_strings(struct net_device *arg0, unsigned int arg1, unsigned char *arg2)
{
  #line 228 
  i40e_get_strings(arg0,arg1,arg2);
  #line 229 
  return;
}

#line 232  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_get_ts_info(struct net_device *arg0, struct ethtool_ts_info *arg1)
{
  #line 233 
  return i40e_get_ts_info(arg0,arg1);
}

#line 237  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
void emg_wrapper_i40e_get_wol(struct net_device *arg0, struct ethtool_wolinfo *arg1)
{
  #line 238 
  i40e_get_wol(arg0,arg1);
  #line 239 
  return;
}

#line 242  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_nway_reset(struct net_device *arg0)
{
  #line 243 
  return i40e_nway_reset(arg0);
}

#line 247  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_set_channels(struct net_device *arg0, struct ethtool_channels *arg1)
{
  #line 248 
  return i40e_set_channels(arg0,arg1);
}

#line 252  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_set_coalesce(struct net_device *arg0, struct ethtool_coalesce *arg1)
{
  #line 253 
  return i40e_set_coalesce(arg0,arg1);
}

#line 257  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_set_eee(struct net_device *arg0, struct ethtool_eee *arg1)
{
  #line 258 
  return i40e_set_eee(arg0,arg1);
}

#line 262  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_set_eeprom(struct net_device *arg0, struct ethtool_eeprom *arg1, unsigned char *arg2)
{
  #line 263 
  return i40e_set_eeprom(arg0,arg1,arg2);
}

#line 267  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_set_fec_param(struct net_device *arg0, struct ethtool_fecparam *arg1)
{
  #line 268 
  return i40e_set_fec_param(arg0,arg1);
}

#line 272  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_set_link_ksettings(struct net_device *arg0, struct ethtool_link_ksettings *arg1)
{
  #line 273 
  return i40e_set_link_ksettings(arg0,arg1);
}

#line 277  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
void emg_wrapper_i40e_set_msglevel(struct net_device *arg0, unsigned int arg1)
{
  #line 278 
  i40e_set_msglevel(arg0,arg1);
  #line 279 
  return;
}

#line 282  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_set_pauseparam(struct net_device *arg0, struct ethtool_pauseparam *arg1)
{
  #line 283 
  return i40e_set_pauseparam(arg0,arg1);
}

#line 287  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_set_per_queue_coalesce(struct net_device *arg0, unsigned int arg1, struct ethtool_coalesce *arg2)
{
  #line 288 
  return i40e_set_per_queue_coalesce(arg0,arg1,arg2);
}

#line 292  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_set_phys_id(struct net_device *arg0, enum ethtool_phys_id_state arg1)
{
  #line 293 
  return i40e_set_phys_id(arg0,arg1);
}

#line 297  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_set_priv_flags(struct net_device *arg0, unsigned int arg1)
{
  #line 298 
  return i40e_set_priv_flags(arg0,arg1);
}

#line 302  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_set_ringparam(struct net_device *arg0, struct ethtool_ringparam *arg1)
{
  #line 303 
  return i40e_set_ringparam(arg0,arg1);
}

#line 307  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_set_rxfh(struct net_device *arg0, unsigned int *arg1, unsigned char *arg2, unsigned char arg3)
{
  #line 308 
  return i40e_set_rxfh(arg0,arg1,arg2,(unsigned char)((int)arg3));
}

#line 312  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_set_rxnfc(struct net_device *arg0, struct ethtool_rxnfc *arg1)
{
  #line 313 
  return i40e_set_rxnfc(arg0,arg1);
}

#line 317  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
int emg_wrapper_i40e_set_wol(struct net_device *arg0, struct ethtool_wolinfo *arg1)
{
  #line 318 
  return i40e_set_wol(arg0,arg1);
}

#line 337  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static void cif_set_bit_4(long nr, unsigned long *addr)
{
  #line 340 
  ldv_set_bit(nr,addr);
  #line 341 
  return;
}

#line 344  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static void cif_clear_bit_4(long nr, unsigned long *addr)
{
  #line 347 
  ldv_clear_bit(nr,addr);
  #line 348 
  return;
}

#line 372  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static unsigned long cif_find_first_bit_1(unsigned long *addr, unsigned long size)
{
  #line 375 
  return ldv_find_first_bit(addr,size);
}

#line 414  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static void cif_bitmap_zero_0(unsigned long *dst, unsigned int nbits)
{
  #line 417 
  ldv_bitmap_zero(dst,nbits);
  #line 418 
  return;
}

#line 421  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static void *ERR_PTR_1(long error)
{
  #line 424 
  return ldv_err_ptr(error);
}

#line 428  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static long PTR_ERR_1(void *ptr)
{
  #line 431 
  return ldv_ptr_err(ptr);
}

#line 435  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static bool IS_ERR_1(void *ptr)
{
  #line 438 
  return ldv_is_err(ptr);
}

#line 624  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static void *kcalloc_1(size_t n, size_t size, gfp_t flags)
{
  #line 627 
  return ldv_kcalloc(n,size,flags);
}

#line 645  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/0/concurrency safety/weaver/i40e_ethtool.i.aux"
static void *kzalloc_5(size_t size, gfp_t flags)
{
  #line 648 
  return ldv_kzalloc(size,flags);
}

#line 20  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/common/inline_asm.c"
void ldv_inline_asm(void)
{
  #line 24 
  return;
}

#line 20  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  #line 22 
  v->counter += i;
  #line 23 
  return;
}

#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  #line 27 
  v->counter -= i;
  #line 28 
  return;
}

#line 30  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  #line 32 
  v->counter -= i;
  #line 33 
  if (v->counter != 0) 
                       #line 34 
                       return 0;
  #line 36 
  return 1;
}

#line 39  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  #line 41 
  (v->counter) ++;
  #line 42 
  return;
}

#line 44  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  #line 46 
  (v->counter) --;
  #line 47 
  return;
}

#line 49  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  #line 51 
  (v->counter) --;
  #line 52 
  if (v->counter != 0) 
                       #line 53 
                       return 0;
  #line 55 
  return 1;
}

#line 58  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  #line 60 
  (v->counter) ++;
  #line 61 
  if (v->counter != 0) 
                       #line 62 
                       return 0;
  #line 64 
  return 1;
}

#line 67  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  #line 69 
  v->counter += i;
  #line 70 
  return v->counter;
}

#line 73  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  #line 75 
  v->counter += i;
  #line 76 
  return v->counter < 0;
}

#line 79  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  #line 81 
  *v = (short)((unsigned int)*v + 1U);
  #line 82 
  return (int)*v;
}

#line 20  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/current.c"
static struct task_struct ldv_current;
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/current.c"
struct task_struct *ldv_get_current(void)
{
  #line 28 
  ldv_current.pid = 1;
  #line 29 
  return & ldv_current;
}

#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
void ldv_switch_to_interrupt_context(void);
#line 42  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 34  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
void ldv_switch_to_process_context(void);
#line 50  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 40  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
bool ldv_in_interrupt_context(void);
#line 112  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 55  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_post_init(int init_ret_val);
#line 132  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_post_probe(int probe_ret_val);
#line 133  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 133 
void ldv_check_return_value_probe(int);
#line 141 
#line 68  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_filter_err_code(int ret_val);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/common.h"
#line 23 
void __VERIFIER_assume(int);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;
#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
void ldv_switch_to_interrupt_context(void)
{
  #line 31 
  __ldv_in_interrupt_context = (_Bool)1;
  #line 32 
  return;
}

#line 34  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
void ldv_switch_to_process_context(void)
{
  #line 37 
  __ldv_in_interrupt_context = (_Bool)0;
  #line 38 
  return;
}

#line 40  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
bool ldv_in_interrupt_context(void)
{
  #line 42 
  return __ldv_in_interrupt_context;
}

#line 45  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
static int ldv_filter_positive_int(int val)
{
  #line 47 
  __VERIFIER_assume(val <= 0);
  #line 48 
  return val;
}

#line 55  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_post_init(int init_ret_val)
{
  #line 57 
  return ldv_filter_positive_int(init_ret_val);
}

#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_post_probe(int probe_ret_val)
{
  #line 63 
  ldv_check_return_value_probe(probe_ret_val);
  #line 64 
  return ldv_filter_positive_int(probe_ret_val);
}

#line 68  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_filter_err_code(int ret_val)
{
  #line 70 
  return ldv_filter_positive_int(ret_val);
}

#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/common/list.h"
#line 28 
void ldv_save_allocated_memory_to_list(void *);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/device.h"
#line 29  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device *dev);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/device.h"
#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data);
#line 57  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 57 
void *ldv_xzalloc(size_t size);
#line 29  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device *dev)
{
  #line 31 
  if (dev != (struct device *)0 && dev->p != (struct device_private *)0) 
    #line 32 
    return (dev->p)->driver_data;
  #line 34 
  return (void *)0;
}

#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  #line 45 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  #line 46 
  ldv_save_allocated_memory_to_list((void *)dev->p);
  #line 47 
  (dev->p)->driver_data = data;
  #line 49 
  return 0;
}

#line 156  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 156 
void ldv_check_alloc_flags(gfp_t);
#line 48  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 48 
void *ldv_malloc(size_t size);
#line 49 
#line 49 
void *ldv_calloc(size_t nmemb, size_t size);
#line 50 
#line 50 
void *ldv_zalloc(size_t size);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/devres.c"
void *ldv_devm_kmalloc(size_t size, gfp_t flags)
{
  #line 26 
  void *res;
  #line 28 
  ldv_check_alloc_flags(flags);
  #line 29 
  res = ldv_malloc(size);
  #line 30 
  ldv_save_allocated_memory_to_list(res);
  #line 32 
  return res;
}

#line 35  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/devres.c"
void *ldv_devm_kzalloc(size_t size, gfp_t flags)
{
  #line 37 
  void *res;
  #line 39 
  ldv_check_alloc_flags(flags);
  #line 40 
  res = ldv_zalloc(size);
  #line 41 
  ldv_save_allocated_memory_to_list(res);
  #line 43 
  return res;
}

#line 46  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/devres.c"
void *ldv_devm_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  #line 48 
  void *res;
  #line 50 
  ldv_check_alloc_flags(flags);
  #line 51 
  res = ldv_malloc(n * size);
  #line 52 
  ldv_save_allocated_memory_to_list(res);
  #line 54 
  return res;
}

#line 57  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/devres.c"
void *ldv_devm_kcalloc(size_t n, size_t size, gfp_t flags)
{
  #line 59 
  void *res;
  #line 61 
  ldv_check_alloc_flags(flags);
  #line 62 
  res = ldv_calloc(n,size);
  #line 63 
  ldv_save_allocated_memory_to_list(res);
  #line 65 
  return res;
}

#line 51  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 51 
void ldv_free(void *s);
#line 59 
#line 59 
void *ldv_malloc_unknown_size(void);
#line 31  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 31 
int ldv_undef_int_positive(void);
#line 40 
#line 40 
int ldv_undef_int_nonpositive(void);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/firmware_loader.c"
int ldv_request_firmware(struct firmware **fw)
{
  #line 27 
  int retval;
  #line 26 
  struct firmware *_fw = (struct firmware *)0;
  #line 29 
  retval = ldv_undef_int_nonpositive();
  #line 31 
  if (retval == 0) {
    #line 33 
    _fw = (struct firmware *)ldv_xzalloc(32UL);
    #line 34 
    _fw->data = (u8 *)ldv_malloc_unknown_size();
    #line 35 
    __VERIFIER_assume(_fw->data != (u8 *)0U);
    #line 36 
    _fw->size = (unsigned long)ldv_undef_int_positive();
  }
  #line 39 
  *fw = _fw;
  #line 41 
  return retval;
}

#line 44  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/firmware_loader.c"
void ldv_release_firmware(struct firmware *fw)
{
  #line 46 
  if (fw != (struct firmware *)0) {
    #line 48 
    ldv_free((void *)fw->data);
    #line 49 
    ldv_free((void *)fw);
  }
  #line 51 
  return;
}

#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/i2c.h"
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/i2c/i2c-core-smbus.c"
s32 ldv_i2c_smbus_read_block_data(u8 *values);
#line 55  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 55 
void *ldv_xmalloc(size_t size);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 23 
int ldv_undef_int(void);
#line 34 
#line 34 
int ldv_undef_int_negative(void);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/i2c/i2c-core-smbus.c"
s32 ldv_i2c_smbus_read_block_data(u8 *values)
{
  #line 27 
  __u8 size;
  #line 28 
  char *bytes;
  #line 30 
  if (ldv_undef_int() != 0) {
    #line 33 
    size = (unsigned char)ldv_undef_int_positive();
    #line 35 
    __VERIFIER_assume((unsigned int)size <= 32U);
    #line 37 
    bytes = (char *)ldv_xmalloc((unsigned long)size);
    #line 39 
    memcpy((void *)values,(void *)bytes,(unsigned long)size);
    #line 40 
    ldv_free((void *)bytes);
    #line 42 
    return (int)size;
  }
  else {
    #line 46 
    return ldv_undef_int_negative();
  }
}

#line 988  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
__inline static void v4l2_set_subdevdata(struct v4l2_subdev *sd, void *p)
{
  #line 990 
  sd->dev_priv = p;
  #line 991 
  return;
}

#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/media/v4l2-common.h"
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/media/v4l2-core/v4l2-i2c.c"
void ldv_v4l2_i2c_subdev_init(struct v4l2_subdev *sd, struct i2c_client *client, struct v4l2_subdev_ops *ops);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/media/v4l2-core/v4l2-i2c.c"
void ldv_v4l2_i2c_subdev_init(struct v4l2_subdev *sd, struct i2c_client *client, struct v4l2_subdev_ops *ops)
{
  #line 26 
  sd->ops = ops;
  #line 27 
  v4l2_set_subdevdata(sd,(void *)client);
  #line 28 
  ldv_dev_set_drvdata(& client->dev,(void *)sd);
  #line 29 
  return;
}

#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_controller *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  #line 25 
  struct spi_controller *master;
  #line 27 
  master = (struct spi_controller *)ldv_zalloc((unsigned long)size + 2936UL);
  #line 29 
  if (master == (struct spi_controller *)0) 
                                            #line 30 
                                            return (struct spi_controller *)0;
  #line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  #line 34 
  return master;
}

#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/fb.h"
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/video/fbdev/core/fbsysfs.c"
struct fb_info *ldv_framebuffer_alloc(size_t size);
#line 26  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/fb.h"
#line 38  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/video/fbdev/core/fbsysfs.c"
void ldv_framebuffer_release(struct fb_info *info);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/video/fbdev/core/fbsysfs.c"
struct fb_info *ldv_framebuffer_alloc(size_t size)
{
  #line 25 
  struct fb_info *info;
  #line 27 
  info = (struct fb_info *)ldv_zalloc(size + 1568UL);
  #line 29 
  if (info == (struct fb_info *)0) 
                                   #line 30 
                                   return (struct fb_info *)0;
  #line 32 
  if (size != 0UL) 
                   #line 33 
                   info->par = (void *)((char *)info + 1568UL);
  #line 35 
  return info;
}

#line 38  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/video/fbdev/core/fbsysfs.c"
void ldv_framebuffer_release(struct fb_info *info)
{
  #line 40 
  if (info == (struct fb_info *)0) 
                                   #line 41 
                                   return;
  #line 44 
  ldv_free((void *)info->apertures);
  #line 46 
  ldv_free((void *)info);
  #line 47 
  return;
}

#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/err.c"
bool ldv_is_err(void *ptr)
{
  #line 29 
  if ((unsigned long)ptr > 18446744073709547520UL) 
                                                   #line 30 
                                                   return (_Bool)1; else 
                                                                    #line 32 
                                                                    return (_Bool)0;
}

#line 35  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  #line 37 
  unsigned long result;
  #line 39 
  __VERIFIER_assume(error < 0L);
  #line 40 
  __VERIFIER_assume(error >= -4095L);
  #line 41 
  result = 18446744073709547520UL - (unsigned long)error;
  #line 42 
  __VERIFIER_assume(result > 18446744073709547520UL);
  #line 44 
  return (void *)result;
}

#line 47  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void *ptr)
{
  #line 49 
  long result;
  #line 51 
  __VERIFIER_assume((unsigned long)ptr > 18446744073709547520UL);
  #line 52 
  result = (long)(18446744073709547520UL - (unsigned long)ptr);
  #line 53 
  __VERIFIER_assume(result < 0L);
  #line 54 
  __VERIFIER_assume(result >= -4095L);
  #line 56 
  return result;
}

#line 59  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/err.c"
bool ldv_is_err_or_null(void *ptr)
{
  #line 61 
  int tmp_0;
  #line 61 
  if (ptr == (void *)0) 
                        #line 61 
                        tmp_0 = 1;
  else {
    #line 61 
    if ((int)ldv_is_err(ptr) != 0) 
                                   #line 61 
                                   tmp_0 = 1; else 
                                                   #line 61 
                                                   tmp_0 = 0;
  }
  #line 61 
  return (_Bool)(tmp_0 != 0);
}

#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/panic.h"
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  #line 23 
  __VERIFIER_assume(0);
  #line 24 
  return;
}

#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/bitmap.h"
#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_set(unsigned long *map, unsigned int start, int nbits);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/bitmap.h"
#line 52  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_clear(unsigned long *map, unsigned int start, int nbits);
#line 29  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/bitmap.h"
#line 78  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
unsigned long ldv_bitmap_find_next_zero_area(unsigned long *map, unsigned long size, unsigned long start, unsigned int nr, unsigned long align_mask);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/find_bit.h"
#line 23 
unsigned long ldv_find_next_zero_bit(unsigned long *addr, unsigned long size, unsigned long offset);
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_set_bit(long nr, unsigned long *addr)
{
  #line 24 
  *(addr + (unsigned long)nr / 64UL) |= 1UL << ((unsigned long)nr & 63UL);
  #line 25 
  return;
}

#line 27  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_clear_bit(long nr, unsigned long *addr)
{
  #line 29 
  *(addr + (unsigned long)nr / 64UL) &= ~ (1UL << ((unsigned long)nr & 63UL));
  #line 30 
  return;
}

#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_set(unsigned long *map, unsigned int start, int nbits)
{
  #line 34 
  unsigned long *p = map + (unsigned long)(start / 64U);
  #line 35 
  unsigned int size = start + (unsigned int)nbits;
  #line 36 
  int bits_to_set = (int)(64U - (start & 63U));
  #line 37 
  unsigned long mask_to_set = 18446744073709551615UL << ((unsigned long)start & 63UL);
  #line 39 
  while (nbits - bits_to_set >= 0) {
    #line 40 
    *p |= mask_to_set;
    #line 41 
    nbits -= bits_to_set;
    #line 42 
    bits_to_set = 64;
    #line 43 
    mask_to_set = 18446744073709551615UL;
    #line 44 
    p ++;
  }
  #line 46 
  if (nbits != 0) {
    #line 47 
    mask_to_set = (18446744073709551615UL >> ((unsigned long)(- size) & 63UL)) & mask_to_set;
    #line 48 
    *p |= mask_to_set;
  }
  #line 50 
  return;
}

#line 52  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_clear(unsigned long *map, unsigned int start, int nbits)
{
  #line 54 
  unsigned long *p = map + (unsigned long)(start / 64U);
  #line 55 
  unsigned int size = start + (unsigned int)nbits;
  #line 56 
  int bits_to_clear = (int)(64U - (start & 63U));
  #line 57 
  unsigned long mask_to_clear = 18446744073709551615UL << ((unsigned long)start & 63UL);
  #line 59 
  while (nbits - bits_to_clear >= 0) {
    #line 60 
    *p &= ~ mask_to_clear;
    #line 61 
    nbits -= bits_to_clear;
    #line 62 
    bits_to_clear = 64;
    #line 63 
    mask_to_clear = 18446744073709551615UL;
    #line 64 
    p ++;
  }
  #line 66 
  if (nbits != 0) {
    #line 67 
    mask_to_clear = (18446744073709551615UL >> ((unsigned long)(- size) & 63UL)) & mask_to_clear;
    #line 68 
    *p &= ~ mask_to_clear;
  }
  #line 70 
  return;
}

#line 72  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_zero(unsigned long *dst, unsigned int nbits)
{
  #line 74 
  unsigned int len = (unsigned int)(((unsigned long)nbits + 63UL) / 64UL) * 8U;
  #line 75 
  memset((void *)dst,0,(unsigned long)len);
  #line 76 
  return;
}

#line 78  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
unsigned long ldv_bitmap_find_next_zero_area(unsigned long *map, unsigned long size, unsigned long start, unsigned int nr, unsigned long align_mask)
{
  #line 80 
  unsigned long index;
  #line 80 
  unsigned long end;
  #line 80 
  unsigned long i;
  #line 82 
  again: 
         #line 82 
  ;
  #line 83 
  index = ldv_find_next_zero_bit(map,size,start);
  #line 84 
  index = (index + align_mask) & ~ align_mask;
  #line 85 
  end = (unsigned long)nr + index;
  #line 87 
  if (end > size) 
                  #line 88 
                  return end;
  #line 90 
  i = ldv_find_next_bit(map,end,index);
  #line 92 
  if (i < end) {
    #line 93 
    start = i + 1UL;
    #line 94 
    goto again;
  }
  #line 97 
  return index;
}

#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/find_bit.h"
#line 25 
void ldv_check_find_bit_offset(unsigned long, unsigned long);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
static unsigned long ldv_ffs(unsigned long word)
{
  #line 23 
  int num = 0;
  #line 25 
  if ((word & 4294967295UL) == 0UL) {
    #line 26 
    num += 32;
    #line 27 
    word >>= 32;
  }
  #line 29 
  if ((word & 65535UL) == 0UL) {
    #line 30 
    num += 16;
    #line 31 
    word >>= 16;
  }
  #line 33 
  if ((word & 255UL) == 0UL) {
    #line 34 
    num += 8;
    #line 35 
    word >>= 8;
  }
  #line 37 
  if ((word & 15UL) == 0UL) {
    #line 38 
    num += 4;
    #line 39 
    word >>= 4;
  }
  #line 41 
  if ((word & 3UL) == 0UL) {
    #line 42 
    num += 2;
    #line 43 
    word >>= 2;
  }
  #line 45 
  if ((word & 1UL) == 0UL) 
                           #line 46 
                           num ++;
  #line 48 
  return (unsigned long)num;
}

#line 51  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
static unsigned long ldv_min(unsigned long a, unsigned long b)
{
  #line 53 
  if (a < b) 
             #line 54 
             return a;
  #line 56 
  return b;
}

#line 59  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
static unsigned long ldv_restrict_find_bit_res(unsigned long res, unsigned long size)
{
  #line 62 
  __VERIFIER_assume(1);
  #line 63 
  __VERIFIER_assume(res <= size);
  #line 65 
  return res;
}

#line 68  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
unsigned long ldv_find_first_bit(unsigned long *addr, unsigned long size)
{
  #line 70 
  unsigned long i;
  #line 72 
  i = 0UL;
  #line 72 
  while (i * 64UL < size) {
    #line 73 
    if (*(addr + i) != 0UL) {
      #line 74 
      ;
      #line 74 
      ;
      #line 74 
      ;
      #line 74 
      return ldv_restrict_find_bit_res(ldv_min(i * 64UL + ldv_ffs(*(addr + i)),size),
                                  size);
    }
    #line 72 
    i ++;
  }
  #line 76 
  return size;
}

#line 79  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
unsigned long ldv_find_next_bit(unsigned long *addr, unsigned long size, unsigned long offset)
{
  #line 81 
  unsigned long tmp;
  #line 83 
  ldv_check_find_bit_offset(size,offset);
  #line 85 
  tmp = *(addr + offset / 64UL);
  #line 86 
  tmp = (unsigned long)((18446744073709551615ULL << (offset & 63UL)) & (unsigned long long)tmp);
  #line 87 
  offset &= 18446744073709551552UL;
  #line 89 
  while (tmp == 0UL) {
    #line 90 
    offset += 64UL;
    #line 91 
    if (offset >= size) 
                        #line 92 
                        return size;
    #line 94 
    tmp = *(addr + offset / 64UL);
  }
  #line 97 
  ;
  #line 97 
  ;
  #line 97 
  ;
  #line 97 
  return ldv_restrict_find_bit_res(ldv_min(ldv_ffs(tmp) + offset,size),size);
}

#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
unsigned long ldv_find_next_zero_bit(unsigned long *addr, unsigned long size, unsigned long offset)
{
  #line 102 
  unsigned long tmp;
  #line 104 
  ldv_check_find_bit_offset(size,offset);
  #line 106 
  tmp = *(addr + offset / 64UL);
  #line 107 
  tmp = ~ tmp;
  #line 108 
  tmp = (unsigned long)((18446744073709551615ULL << (offset & 63UL)) & (unsigned long long)tmp);
  #line 109 
  offset &= 18446744073709551552UL;
  #line 111 
  while (tmp == 0UL) {
    #line 112 
    offset += 64UL;
    #line 113 
    if (offset >= size) 
                        #line 114 
                        return size;
    #line 116 
    tmp = *(addr + offset / 64UL);
    #line 117 
    tmp = ~ tmp;
  }
  #line 120 
  ;
  #line 120 
  ;
  #line 120 
  ;
  #line 120 
  return ldv_restrict_find_bit_res(ldv_min(ldv_ffs(tmp) + offset,size),size);
}

#line 26  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/string.h"
#line 31  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
int ldv_strcmp(char *cs, char *ct);
#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/string.h"
#line 70  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
char *ldv_strstr(char *cs, char *ct);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
size_t ldv_strlen(char *s)
{
  #line 23 
  unsigned int len = 0U;
  #line 25 
  while ((int)*s != 0) {
    #line 26 
    len ++;
    #line 25 
    s ++;
  }
  #line 28 
  return (unsigned long)len;
}

#line 31  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
int ldv_strcmp(char *cs, char *ct)
{
  #line 33 
  while ((int)*cs != 0 && (int)*ct != 0) {
    #line 34 
    if ((int)*cs != (int)*ct) 
                              #line 35 
                              break;
    #line 33 
    cs ++;
    #line 33 
    ct ++;
  }
  #line 37 
  return (int)*cs - (int)*ct;
}

#line 40  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
int ldv_strncmp(char *cs, char *ct, __kernel_size_t count)
{
  #line 42 
  if (count == 0UL) 
                    #line 43 
                    return 0;
  #line 45 
  while ((int)*cs != 0 && (int)*ct != 0) {
    #line 46 
    if ((int)*cs != (int)*ct) 
                              #line 47 
                              break;
    #line 49 
    count --;
    #line 51 
    if (count == 0UL) 
                      #line 52 
                      break;
    #line 45 
    cs ++;
    #line 45 
    ct ++;
  }
  #line 55 
  return (int)*cs - (int)*ct;
}

#line 58  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
int ldv_memcmp(void *cs, void *ct, size_t count)
{
  #line 60 
  unsigned char *su1;
  #line 60 
  unsigned char *su2;
  #line 61 
  int res = 0;
  #line 63 
  su1 = (unsigned char *)cs;
  #line 63 
  su2 = (unsigned char *)ct;
  #line 63 
  while (count != 0UL) {
    #line 64 
    res = (int)*su1 - (int)*su2;
    #line 64 
    if (res != 0) 
                  #line 65 
                  break;
    #line 63 
    su1 ++;
    #line 63 
    su2 ++;
    #line 63 
    count --;
  }
  #line 67 
  return res;
}

#line 70  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
char *ldv_strstr(char *cs, char *ct)
{
  #line 72 
  size_t cs_len;
  #line 72 
  size_t ct_len;
  #line 74 
  cs_len = ldv_strlen(cs);
  #line 75 
  ct_len = ldv_strlen(ct);
  #line 77 
  while (cs_len >= ct_len) {
    #line 78 
    if (ldv_memcmp((void *)cs,(void *)ct,ct_len) == 0) 
                                                       #line 79 
                                                       return cs;
    #line 81 
    cs_len --;
    #line 82 
    cs ++;
  }
  #line 85 
  return (char *)0;
}

#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/list.c"
void ldv_init_list_head(struct list_head *list)
{
  #line 23 
  list->next = list;
  #line 24 
  list->prev = list;
  #line 25 
  return;
}

#line 26  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);
#line 30  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
struct kmem_cache *ldv_kmem_cache_create(char *name, unsigned int size);
#line 31  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags);
#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 90  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmem_cache_zalloc(struct kmem_cache *cachep, gfp_t flags);
#line 33  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 95  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void ldv_kmem_cache_free(struct kmem_cache *cachep, void *objp);
#line 34  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void ldv_kmem_cache_destroy(struct kmem_cache *cachep);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  #line 25 
  void *res;
  #line 27 
  ldv_check_alloc_flags(flags);
  #line 28 
  res = ldv_malloc(size);
  #line 30 
  return res;
}

#line 33  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  #line 35 
  void *res;
  #line 37 
  ldv_check_alloc_flags(flags);
  #line 38 
  res = ldv_zalloc(size);
  #line 40 
  return res;
}

#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  #line 45 
  void *res;
  #line 47 
  ldv_check_alloc_flags(flags);
  #line 48 
  res = ldv_malloc(n * size);
  #line 50 
  return res;
}

#line 53  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  #line 55 
  void *res;
  #line 57 
  ldv_check_alloc_flags(flags);
  #line 58 
  res = ldv_calloc(n,size);
  #line 60 
  return res;
}

#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
struct kmem_cache *ldv_kmem_cache_create(char *name, unsigned int size)
{
  #line 71 
  struct kmem_cache *res;
  #line 72 
  struct ldv_kmem_cache *ldv_res;
  #line 74 
  res = (struct kmem_cache *)ldv_zalloc(16UL);
  #line 76 
  if (res != (struct kmem_cache *)0) {
    #line 77 
    ldv_res = (struct ldv_kmem_cache *)res;
    #line 78 
    ldv_res->name = name;
    #line 79 
    ldv_res->size = size;
  }
  #line 82 
  return res;
}

#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)
{
  #line 87 
  return ldv_kmalloc((unsigned long)((struct ldv_kmem_cache *)cachep)->size,
                  flags);
}

#line 90  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmem_cache_zalloc(struct kmem_cache *cachep, gfp_t flags)
{
  #line 92 
  return ldv_kzalloc((unsigned long)((struct ldv_kmem_cache *)cachep)->size,
                  flags);
}

#line 95  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void ldv_kmem_cache_free(struct kmem_cache *cachep, void *objp)
{
  #line 97 
  ldv_free(objp);
  #line 98 
  return;
}

#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void ldv_kmem_cache_destroy(struct kmem_cache *cachep)
{
  #line 102 
  ldv_free((void *)cachep);
  #line 103 
  return;
}

#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/util.c"
void *ldv_kmemdup(void *src, size_t len, gfp_t gfp)
{
  #line 25 
  void *res;
  #line 27 
  ldv_check_alloc_flags(gfp);
  #line 28 
  res = ldv_malloc(len);
  #line 30 
  if (res != (void *)0) 
                        #line 31 
                        memcpy(res,src,len);
  #line 33 
  return res;
}

#line 162  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 162 
void ldv_check_alloc_nonatomic(void);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/vmalloc.h"
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void *ldv_vmalloc(unsigned long size);
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/vmalloc.h"
#line 33  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void *ldv_vzalloc(unsigned long size);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/vmalloc.h"
#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void ldv_vfree(void *addr);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void *ldv_vmalloc(unsigned long size)
{
  #line 25 
  void *res;
  #line 27 
  ldv_check_alloc_nonatomic();
  #line 28 
  res = ldv_malloc(size);
  #line 30 
  return res;
}

#line 33  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void *ldv_vzalloc(unsigned long size)
{
  #line 35 
  void *res;
  #line 37 
  ldv_check_alloc_nonatomic();
  #line 38 
  res = ldv_zalloc(size);
  #line 40 
  return res;
}

#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void ldv_vfree(void *addr)
{
  #line 45 
  ldv_free(addr);
  #line 46 
  return;
}

#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 28 
void *malloc(size_t);
#line 29 
#line 29 
void *calloc(size_t, size_t);
#line 30 
#line 30 
void free(void *);
#line 45 
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
unsigned int ldv_is_memory_alloc_failures;
#line 56  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 63  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xcalloc(size_t nmemb, size_t size);
#line 60  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 88  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void);
#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 97  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void);
#line 64  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size);
#line 65  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 37  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size);
#line 66  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 42  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size);
#line 67  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 47  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s);
#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 52  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size);
#line 71  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 80  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size);
#line 72  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 90  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xcalloc(size_t nmemb, size_t size);
#line 73  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size);
#line 75  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 110  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void);
#line 76  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 124  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void);
#line 77  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 139  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void);
#line 83  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 106  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size);
#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 144  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);
#line 87  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 87 
void *external_allocated_data(void);
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
unsigned int ldv_is_memory_alloc_failures = 1U;
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  #line 26 
  void *res;
  #line 28 
  if (ldv_is_memory_alloc_failures != 0U) {
    #line 28 
    if (ldv_undef_int() != 0) 
                              #line 29 
                              return (void *)0;
  }
  #line 32 
  res = malloc(size);
  #line 33 
  __VERIFIER_assume(res != (void *)0);
  #line 34 
  return res;
}

#line 37  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  #line 39 
  return calloc(nmemb,size);
}

#line 42  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  #line 44 
  return calloc(1UL,size);
}

#line 47  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  #line 49 
  free(s);
  #line 50 
  return;
}

#line 52  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  #line 54 
  void *res;
  #line 56 
  if (ptr != (void *)0 && size == 0UL) {
    #line 57 
    free(ptr);
    #line 58 
    return (void *)0;
  }
  #line 61 
  if (ptr == (void *)0) {
    #line 62 
    res = malloc(size);
    #line 63 
    return res;
  }
  #line 66 
  if (ldv_undef_int() != 0) {
    #line 68 
    res = malloc(size);
    #line 69 
    __VERIFIER_assume(res != (void *)0);
    #line 71 
    memcpy(res,ptr,size);
    #line 72 
    free(ptr);
    #line 74 
    return res;
  }
  else 
       #line 77 
       return (void *)0;
}

#line 80  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  #line 82 
  void *res;
  #line 84 
  res = malloc(size);
  #line 85 
  __VERIFIER_assume(res != (void *)0);
  #line 87 
  return res;
}

#line 90  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xcalloc(size_t nmemb, size_t size)
{
  #line 92 
  void *res;
  #line 94 
  res = calloc(nmemb,size);
  #line 95 
  __VERIFIER_assume(res != (void *)0);
  #line 97 
  return res;
}

#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  #line 102 
  void *res;
  #line 104 
  res = calloc(1UL,size);
  #line 105 
  __VERIFIER_assume(res != (void *)0);
  #line 107 
  return res;
}

#line 110  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  #line 112 
  void *res;
  #line 114 
  if (ldv_undef_int() != 0) {
    #line 116 
    res = external_allocated_data();
    #line 117 
    __VERIFIER_assume(res != (void *)0);
    #line 118 
    return res;
  }
  else 
       #line 121 
       return (void *)0;
}

#line 124  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  #line 126 
  void *res;
  #line 128 
  if (ldv_undef_int() != 0) {
    #line 130 
    res = external_allocated_data();
    #line 131 
    memset(res,0,8UL);
    #line 132 
    __VERIFIER_assume(res != (void *)0);
    #line 133 
    return res;
  }
  else 
       #line 136 
       return (void *)0;
}

#line 139  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  #line 141 
  return ldv_reference_calloc_unknown_size();
}

#line 144  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  #line 146 
  void *res;
  #line 149 
  res = external_allocated_data();
  #line 150 
  __VERIFIER_assume(res != (void *)0);
  #line 152 
  return res;
}

#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  #line 25 
  void *res;
  #line 26 
  res = ldv_reference_malloc(size);
  #line 27 
  if (res != (void *)0) {
    #line 28 
    int tmp_0;
    #line 28 
    if (ldv_is_err(res)) 
                         #line 28 
                         tmp_0 = 0; else 
                                         #line 28 
                                         tmp_0 = 1;
    #line 28 
    __VERIFIER_assume(tmp_0);
  }
  #line 29 
  return res;
}

#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  #line 34 
  void *res;
  #line 35 
  res = ldv_reference_calloc(nmemb,size);
  #line 36 
  if (res != (void *)0) {
    #line 37 
    int tmp_0;
    #line 37 
    if (ldv_is_err(res)) 
                         #line 37 
                         tmp_0 = 0; else 
                                         #line 37 
                                         tmp_0 = 1;
    #line 37 
    __VERIFIER_assume(tmp_0);
  }
  #line 38 
  return res;
}

#line 41  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  #line 43 
  void *res;
  #line 44 
  res = ldv_reference_zalloc(size);
  #line 45 
  if (res != (void *)0) {
    #line 46 
    int tmp_0;
    #line 46 
    if (ldv_is_err(res)) 
                         #line 46 
                         tmp_0 = 0; else 
                                         #line 46 
                                         tmp_0 = 1;
    #line 46 
    __VERIFIER_assume(tmp_0);
  }
  #line 47 
  return res;
}

#line 50  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  #line 52 
  ldv_reference_free(s);
  #line 53 
  return;
}

#line 55  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  #line 57 
  void *res;
  #line 59 
  int tmp_0;
  #line 58 
  res = ldv_reference_xmalloc(size);
  #line 59 
  if (ldv_is_err(res)) 
                       #line 59 
                       tmp_0 = 0; else 
                                       #line 59 
                                       tmp_0 = 1;
  #line 59 
  __VERIFIER_assume(tmp_0);
  #line 60 
  return res;
}

#line 63  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xcalloc(size_t nmemb, size_t size)
{
  #line 65 
  void *res;
  #line 67 
  int tmp_0;
  #line 66 
  res = ldv_reference_xcalloc(nmemb,size);
  #line 67 
  if (ldv_is_err(res)) 
                       #line 67 
                       tmp_0 = 0; else 
                                       #line 67 
                                       tmp_0 = 1;
  #line 67 
  __VERIFIER_assume(tmp_0);
  #line 68 
  return res;
}

#line 71  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  #line 73 
  void *res;
  #line 75 
  int tmp_0;
  #line 74 
  res = ldv_reference_xzalloc(size);
  #line 75 
  if (ldv_is_err(res)) 
                       #line 75 
                       tmp_0 = 0; else 
                                       #line 75 
                                       tmp_0 = 1;
  #line 75 
  __VERIFIER_assume(tmp_0);
  #line 76 
  return res;
}

#line 79  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  #line 81 
  void *res;
  #line 82 
  res = ldv_reference_malloc_unknown_size();
  #line 83 
  if (res != (void *)0) {
    #line 84 
    int tmp_0;
    #line 84 
    if (ldv_is_err(res)) 
                         #line 84 
                         tmp_0 = 0; else 
                                         #line 84 
                                         tmp_0 = 1;
    #line 84 
    __VERIFIER_assume(tmp_0);
  }
  #line 85 
  return res;
}

#line 88  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  #line 90 
  void *res;
  #line 91 
  res = ldv_reference_calloc_unknown_size();
  #line 92 
  if (res != (void *)0) {
    #line 93 
    int tmp_0;
    #line 93 
    if (ldv_is_err(res)) 
                         #line 93 
                         tmp_0 = 0; else 
                                         #line 93 
                                         tmp_0 = 1;
    #line 93 
    __VERIFIER_assume(tmp_0);
  }
  #line 94 
  return res;
}

#line 97  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  #line 99 
  void *res;
  #line 100 
  res = ldv_reference_zalloc_unknown_size();
  #line 101 
  if (res != (void *)0) {
    #line 102 
    int tmp_0;
    #line 102 
    if (ldv_is_err(res)) 
                         #line 102 
                         tmp_0 = 0; else 
                                         #line 102 
                                         tmp_0 = 1;
    #line 102 
    __VERIFIER_assume(tmp_0);
  }
  #line 103 
  return res;
}

#line 106  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  #line 108 
  void *res;
  #line 110 
  int tmp_0;
  #line 109 
  res = ldv_reference_xmalloc_unknown_size(size);
  #line 110 
  if (ldv_is_err(res)) 
                       #line 110 
                       tmp_0 = 0; else 
                                       #line 110 
                                       tmp_0 = 1;
  #line 110 
  __VERIFIER_assume(tmp_0);
  #line 111 
  return res;
}

/* compiler builtin: 
   long __builtin_expect(long exp, long c);   */
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/common.h"
#line 22 
void __VERIFIER_error(void);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/common.h"
long __builtin_expect(long exp, long c)
{
  #line 26 
  return exp;
}

#line 35  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  #line 37 
  __VERIFIER_error();
  #line 38 
  return;
}

#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 53  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
long ldv_undef_long(void);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void);
#line 26  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 77  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void);
#line 27  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void);
#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void);
#line 37  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 111  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonnegative(void);
#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 129  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void);
#line 54  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 139  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __ldv_undef_int_range(int begin, int end);
#line 56  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 151  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __ldv_undef_int_range2(int begin, int end);
#line 29 
#line 29 
int __VERIFIER_nondet_int(void);
#line 31 
#line 31 
long __VERIFIER_nondet_long(void);
#line 38 
#line 38 
unsigned int __VERIFIER_nondet_uint(void);
#line 41 
#line 41 
unsigned long __VERIFIER_nondet_ulong(void);
#line 42 
#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);
#line 43 
#line 43 
void *__VERIFIER_nondet_pointer(void);
#line 45  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  #line 48 
  int undef_int = __VERIFIER_nondet_int();
  #line 50 
  return undef_int;
}

#line 53  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
long ldv_undef_long(void)
{
  #line 56 
  long undef_long = __VERIFIER_nondet_long();
  #line 58 
  return undef_long;
}

#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  #line 64 
  unsigned int undef_uint = __VERIFIER_nondet_uint();
  #line 66 
  return undef_uint;
}

#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  #line 72 
  void *undef_ptr = __VERIFIER_nondet_pointer();
  #line 74 
  return undef_ptr;
}

#line 77  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  #line 80 
  unsigned long undef_ulong = __VERIFIER_nondet_ulong();
  #line 82 
  return undef_ulong;
}

#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  #line 88 
  unsigned long long undef_ulonglong = __VERIFIER_nondet_ulonglong();
  #line 90 
  return undef_ulonglong;
}

#line 93  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  #line 95 
  int ret = ldv_undef_int();
  #line 97 
  __VERIFIER_assume(ret > 0);
  #line 99 
  return ret;
}

#line 102  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  #line 104 
  int ret = ldv_undef_int();
  #line 106 
  __VERIFIER_assume(ret < 0);
  #line 108 
  return ret;
}

#line 111  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonnegative(void)
{
  #line 113 
  int ret = ldv_undef_int();
  #line 115 
  __VERIFIER_assume(ret >= 0);
  #line 117 
  return ret;
}

#line 120  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  #line 122 
  int ret = ldv_undef_int();
  #line 124 
  __VERIFIER_assume(ret <= 0);
  #line 126 
  return ret;
}

#line 129  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  #line 131 
  void *ret = ldv_undef_ptr();
  #line 133 
  __VERIFIER_assume(ret != (void *)0);
  #line 135 
  return ret;
}

#line 139  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __ldv_undef_int_range(int begin, int end)
{
  #line 141 
  int ret;
  #line 143 
  ret = ldv_undef_int();
  #line 144 
  __VERIFIER_assume(ret >= begin);
  #line 145 
  __VERIFIER_assume(ret <= end);
  #line 147 
  return ret;
}

#line 151  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __ldv_undef_int_range2(int begin, int end)
{
  #line 153 
  int ret;
  #line 155 
  ret = begin;
  #line 155 
  while (ret < end) {
    #line 156 
    if (ldv_undef_int() != 0) 
                              #line 157 
                              break;
    #line 155 
    ret ++;
  }
  #line 159 
  return ret;
}

#line 62  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 62 
void ldv_initialize(void);
#line 97 
#line 97 
void ldv_failed_register_netdev(void);
#line 123 
#line 123 
void ldv_pre_probe(void);
#line 35  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/thread.h"
#line 35 
int pthread_create(pthread_t *, pthread_attr_t *, void *(*)(void *), void *);
#line 39 
#line 39 
int pthread_join(pthread_t, void **);
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
__inline static void *ERR_PTR_2(long error)
{
  #line 26 
  return (void *)error;
}

#line 77  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
int emg_runtime_enabled = 0;
#line 78  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
int emg_runtime_lowpower = 1;
#line 163 
#line 261 
void emg_dispatch_deregister_10(struct pci_driver *arg0);
#line 164 
#line 295 
void emg_dispatch_deregister_14(struct net_device *arg0);
#line 165 
#line 232 
void emg_dispatch_instance_deregister_6(struct timer_list *arg0);
#line 166 
#line 250 
void emg_dispatch_instance_register_9(struct timer_list *arg0);
#line 167 
#line 241 
void emg_dispatch_irq_deregister_7(int arg0);
#line 168 
#line 281 
void emg_dispatch_irq_register_13(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3);
#line 169 
#line 270 
void emg_dispatch_register_12(struct net_device *arg0);
#line 170 
#line 201 
void emg_dispatch_register_2(struct pci_driver *arg0);
#line 171 
#line 212 
void emg_dispatch_register_5(struct file_operations *arg0);
#line 172 
#line 3387 
void *emg_entry_point_insmod(void *arg0);
#line 173 
#line 304 
void *emg_file_operations_character_driver_scenario_i40e_dbg_command_fops(void *arg0);
#line 174 
#line 467 
void *emg_file_operations_character_driver_scenario_i40e_dbg_netdev_ops_fops(void *arg0);
#line 177 
#line 630 
void *emg_interrupt_interrupt_scenario_i40e_intr(void *arg0);
#line 179 
#line 693 
void *emg_net_random_allocationless_scenario_i40e_ddp_flash(void *arg0);
#line 180 
#line 1833 
void *emg_pci_pci_scenario_i40e_driver(void *arg0);
#line 182 
#line 2010 
void *emg_pm_pm_ops_scenario_i40e_pm_ops(void *arg0);
#line 186 
#line 3005 
void *emg_timer_timer_scenario_6(void *arg0);
#line 188 
#line 3416 
int main(void);
#line 191  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_15;
#line 192  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_16;
#line 193  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_17;
#line 194  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_18;
#line 195  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_19;
#line 196  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_20;
#line 197  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_21;
#line 201  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_register_2(struct pci_driver *arg0)
{
  #line 202 
  int ret;
  #line 203 
  struct emg_struct_pci_scenario_i40e_driver_19 *cf_arg_19;
  #line 204 
  cf_arg_19 = (struct emg_struct_pci_scenario_i40e_driver_19 *)ldv_xmalloc(16UL);
  #line 205 
  cf_arg_19->arg0 = arg0;
  #line 206 
  ret = pthread_create(& emg_thread_19,(pthread_attr_t *)0,& emg_pci_pci_scenario_i40e_driver,(void *)cf_arg_19);
  #line 207 
  __VERIFIER_assume(ret == 0);
  #line 208 
  return;
}

#line 212  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_register_5(struct file_operations *arg0)
{
  #line 213 
  int ret;
  #line 214 
  struct emg_struct_character_driver_scenario_i40e_dbg_command_fops_15 *cf_arg_15;
  #line 215 
  struct emg_struct_character_driver_scenario_i40e_dbg_command_fops_15 *cf_arg_16;
  #line 216 
  if (ldv_undef_int() != 0) {
    #line 217 
    cf_arg_15 = (struct emg_struct_character_driver_scenario_i40e_dbg_command_fops_15 *)ldv_xmalloc(16UL);
    #line 218 
    cf_arg_15->arg0 = arg0;
    #line 219 
    ret = pthread_create(& emg_thread_15,(pthread_attr_t *)0,& emg_file_operations_character_driver_scenario_i40e_dbg_command_fops,(void *)cf_arg_15);
    #line 220 
    __VERIFIER_assume(ret == 0);
  }
  else {
    #line 223 
    cf_arg_16 = (struct emg_struct_character_driver_scenario_i40e_dbg_command_fops_15 *)ldv_xmalloc(16UL);
    #line 224 
    cf_arg_16->arg0 = arg0;
    #line 225 
    ret = pthread_create(& emg_thread_16,(pthread_attr_t *)0,& emg_file_operations_character_driver_scenario_i40e_dbg_netdev_ops_fops,(void *)cf_arg_16);
    #line 226 
    __VERIFIER_assume(ret == 0);
  }
  #line 228 
  return;
}

#line 232  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_instance_deregister_6(struct timer_list *arg0)
{
  #line 233 
  int ret;
  #line 234 
  struct emg_struct_timer_scenario_6_21 *cf_arg_21;
  #line 235 
  ret = pthread_join(emg_thread_21,(void **)0);
  #line 236 
  __VERIFIER_assume(ret == 0);
  #line 237 
  return;
}

#line 241  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_irq_deregister_7(int arg0)
{
  #line 242 
  int ret;
  #line 243 
  struct emg_struct_free_irq_7 *cf_arg_17;
  #line 244 
  ret = pthread_join(emg_thread_17,(void **)0);
  #line 245 
  __VERIFIER_assume(ret == 0);
  #line 246 
  return;
}

#line 250  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_instance_register_9(struct timer_list *arg0)
{
  #line 251 
  int ret;
  #line 252 
  struct emg_struct_timer_scenario_6_21 *cf_arg_21;
  #line 253 
  cf_arg_21 = (struct emg_struct_timer_scenario_6_21 *)ldv_xmalloc(16UL);
  #line 254 
  cf_arg_21->arg0 = arg0;
  #line 255 
  ret = pthread_create(& emg_thread_21,(pthread_attr_t *)0,& emg_timer_timer_scenario_6,(void *)cf_arg_21);
  #line 256 
  __VERIFIER_assume(ret == 0);
  #line 257 
  return;
}

#line 261  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_deregister_10(struct pci_driver *arg0)
{
  #line 262 
  int ret;
  #line 263 
  struct emg_struct_pci_scenario_i40e_driver_19 *cf_arg_19;
  #line 264 
  ret = pthread_join(emg_thread_19,(void **)0);
  #line 265 
  __VERIFIER_assume(ret == 0);
  #line 266 
  return;
}

#line 270  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_register_12(struct net_device *arg0)
{
  #line 271 
  int ret;
  #line 272 
  struct emg_struct_random_allocationless_scenario_i40e_ddp_flash_18 *cf_arg_18;
  #line 273 
  cf_arg_18 = (struct emg_struct_random_allocationless_scenario_i40e_ddp_flash_18 *)ldv_xmalloc(16UL);
  #line 274 
  cf_arg_18->arg0 = arg0;
  #line 275 
  ret = pthread_create(& emg_thread_18,(pthread_attr_t *)0,& emg_net_random_allocationless_scenario_i40e_ddp_flash,(void *)cf_arg_18);
  #line 276 
  __VERIFIER_assume(ret == 0);
  #line 277 
  return;
}

#line 281  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_irq_register_13(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3)
{
  #line 282 
  int ret;
  #line 283 
  struct emg_struct_interrupt_scenario_i40e_intr_17 *cf_arg_17;
  #line 284 
  cf_arg_17 = (struct emg_struct_interrupt_scenario_i40e_intr_17 *)ldv_xmalloc(40UL);
  #line 285 
  cf_arg_17->arg0 = arg0;
  #line 286 
  cf_arg_17->arg1 = arg1;
  #line 287 
  cf_arg_17->arg2 = arg2;
  #line 288 
  cf_arg_17->arg3 = arg3;
  #line 289 
  ret = pthread_create(& emg_thread_17,(pthread_attr_t *)0,& emg_interrupt_interrupt_scenario_i40e_intr,(void *)cf_arg_17);
  #line 290 
  __VERIFIER_assume(ret == 0);
  #line 291 
  return;
}

#line 295  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_deregister_14(struct net_device *arg0)
{
  #line 296 
  int ret;
  #line 297 
  struct emg_struct_random_allocationless_scenario_i40e_ddp_flash_18 *cf_arg_18;
  #line 298 
  ret = pthread_join(emg_thread_18,(void **)0);
  #line 299 
  __VERIFIER_assume(ret == 0);
  #line 300 
  return;
}

#line 304  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void *emg_file_operations_character_driver_scenario_i40e_dbg_command_fops(void *arg0)
{
  #line 307 
  struct file_operations *emg_15_container;
  #line 308 
  char *emg_15_emg_param_1_0;
  #line 309 
  char *emg_15_emg_param_1_2;
  #line 310 
  long long *emg_15_emg_param_3_1;
  #line 311 
  long long *emg_15_emg_param_3_3;
  #line 312 
  struct file *emg_15_resource_0;
  #line 313 
  struct inode *emg_15_resource_1;
  #line 314 
  int emg_15_ret;
  #line 315 
  unsigned long emg_15_size_cnt;
  #line 316 
  int emg_repeat_cnt_main_15_0 = 1;
  #line 317 
  int emg_repeat_cnt_call_15 = 1;
  #line 318 
  int emg_repeat_cnt_main_15_1 = 1;
  #line 320 
  struct emg_struct_character_driver_scenario_i40e_dbg_command_fops_15 *data = (struct emg_struct_character_driver_scenario_i40e_dbg_command_fops_15 *)arg0;
  #line 324 
  emg_15_ret = ldv_undef_int();
  #line 325 
  emg_15_container = emg_alias_i40e_dbg_command_fops;
  #line 326 
  emg_15_ret = ldv_undef_int();
  #line 328 
  __VERIFIER_assume(data->arg0 == emg_alias_i40e_dbg_command_fops);
  #line 330 
  if (data != (struct emg_struct_character_driver_scenario_i40e_dbg_command_fops_15 *)0) {
    #line 331 
    emg_15_container = data->arg0;
    #line 332 
    ldv_free((void *)data);
  }
  #line 337 
  emg_15_resource_0 = (struct file *)ldv_xmalloc(520UL);
  #line 338 
  emg_15_size_cnt = (unsigned long)ldv_undef_int();
  #line 342 
  goto emg_main_15;
  #line 346 
  return (void *)0;
  #line 349 
  emg_call_15: 
               #line 349 
  ;
  #line 350 
  if (ldv_undef_int() != 0) {
    #line 351 
    if (ldv_undef_int() != 0) {
      #line 353 
      emg_15_emg_param_1_0 = (char *)ldv_xmalloc_unknown_size(0UL);
      #line 353 
      emg_15_emg_param_1_0 = emg_15_emg_param_1_0;
      #line 354 
      emg_15_emg_param_3_1 = (long long *)ldv_xmalloc_unknown_size(0UL);
      #line 354 
      emg_15_emg_param_3_1 = emg_15_emg_param_3_1;
      #line 358 
      emg_wrapper_i40e_dbg_command_read(emg_15_resource_0,emg_15_emg_param_1_0,emg_15_size_cnt,emg_15_emg_param_3_1);
      #line 362 
      ldv_free((void *)emg_15_emg_param_1_0);
      #line 363 
      ldv_free((void *)emg_15_emg_param_3_1);
    }
    else {
      #line 372 
      __VERIFIER_assume(emg_15_size_cnt <= 2147479552UL);
      #line 373 
      emg_15_emg_param_1_2 = (char *)ldv_xmalloc_unknown_size(0UL);
      #line 373 
      emg_15_emg_param_1_2 = emg_15_emg_param_1_2;
      #line 374 
      emg_15_emg_param_3_3 = (long long *)ldv_xmalloc_unknown_size(0UL);
      #line 374 
      emg_15_emg_param_3_3 = emg_15_emg_param_3_3;
      #line 378 
      emg_wrapper_i40e_dbg_command_write(emg_15_resource_0,emg_15_emg_param_1_2,emg_15_size_cnt,emg_15_emg_param_3_3);
      #line 382 
      ldv_free((void *)emg_15_emg_param_1_2);
      #line 383 
      ldv_free((void *)emg_15_emg_param_3_3);
    }
    #line 387 
    if (emg_repeat_cnt_call_15 > 0) {
      #line 388 
      emg_repeat_cnt_call_15 --;
      #line 390 
      goto emg_call_15;
    }
    else 
         #line 392 
         __VERIFIER_assume(0);
  }
  else {
    #line 398 
    if (emg_15_container->release != (int (*)(struct inode *, struct file *))0) 
      #line 399 
      (*(emg_15_container->release))(emg_15_resource_1,emg_15_resource_0);
    #line 403 
    if (emg_repeat_cnt_main_15_0 > 0) {
      #line 404 
      emg_repeat_cnt_main_15_0 --;
      #line 406 
      goto emg_main_15;
    }
    else 
         #line 408 
         __VERIFIER_assume(0);
  }
  #line 414 
  return (void *)0;
  #line 417 
  emg_main_15: 
               #line 417 
  ;
  #line 418 
  if (ldv_undef_int() != 0) {
    #line 420 
    emg_15_ret = simple_open(emg_15_resource_1,emg_15_resource_0);
    #line 425 
    emg_15_ret = ldv_filter_err_code(emg_15_ret);
    #line 428 
    if (ldv_undef_int() != 0) {
      #line 430 
      __VERIFIER_assume(emg_15_ret == 0);
      #line 434 
      goto emg_call_15;
    }
    else {
      #line 439 
      __VERIFIER_assume(emg_15_ret != 0);
      #line 442 
      if (emg_repeat_cnt_main_15_1 > 0) {
        #line 443 
        emg_repeat_cnt_main_15_1 --;
        #line 445 
        goto emg_main_15;
      }
      else 
           #line 447 
           __VERIFIER_assume(0);
    }
  }
  else 
       #line 454 
       ldv_free((void *)emg_15_resource_0);
  #line 462 
  return (void *)0;
}

#line 467  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void *emg_file_operations_character_driver_scenario_i40e_dbg_netdev_ops_fops(void *arg0)
{
  #line 470 
  struct file_operations *emg_16_container;
  #line 471 
  char *emg_16_emg_param_1_0;
  #line 472 
  char *emg_16_emg_param_1_2;
  #line 473 
  long long *emg_16_emg_param_3_1;
  #line 474 
  long long *emg_16_emg_param_3_3;
  #line 475 
  struct file *emg_16_resource_0;
  #line 476 
  struct inode *emg_16_resource_1;
  #line 477 
  int emg_16_ret;
  #line 478 
  unsigned long emg_16_size_cnt;
  #line 479 
  int emg_repeat_cnt_main_16_1 = 1;
  #line 480 
  int emg_repeat_cnt_call_16 = 1;
  #line 481 
  int emg_repeat_cnt_main_16_0 = 1;
  #line 483 
  struct emg_struct_character_driver_scenario_i40e_dbg_command_fops_15 *data = (struct emg_struct_character_driver_scenario_i40e_dbg_command_fops_15 *)arg0;
  #line 487 
  emg_16_ret = ldv_undef_int();
  #line 488 
  emg_16_container = emg_alias_i40e_dbg_netdev_ops_fops;
  #line 489 
  emg_16_ret = ldv_undef_int();
  #line 491 
  __VERIFIER_assume(data->arg0 == emg_alias_i40e_dbg_netdev_ops_fops);
  #line 493 
  if (data != (struct emg_struct_character_driver_scenario_i40e_dbg_command_fops_15 *)0) {
    #line 494 
    emg_16_container = data->arg0;
    #line 495 
    ldv_free((void *)data);
  }
  #line 500 
  emg_16_resource_0 = (struct file *)ldv_xmalloc(520UL);
  #line 501 
  emg_16_size_cnt = (unsigned long)ldv_undef_int();
  #line 505 
  goto emg_main_16;
  #line 509 
  return (void *)0;
  #line 512 
  emg_call_16: 
               #line 512 
  ;
  #line 513 
  if (ldv_undef_int() != 0) {
    #line 514 
    if (ldv_undef_int() != 0) {
      #line 516 
      emg_16_emg_param_1_0 = (char *)ldv_xmalloc_unknown_size(0UL);
      #line 516 
      emg_16_emg_param_1_0 = emg_16_emg_param_1_0;
      #line 517 
      emg_16_emg_param_3_1 = (long long *)ldv_xmalloc_unknown_size(0UL);
      #line 517 
      emg_16_emg_param_3_1 = emg_16_emg_param_3_1;
      #line 521 
      emg_wrapper_i40e_dbg_netdev_ops_read(emg_16_resource_0,emg_16_emg_param_1_0,emg_16_size_cnt,emg_16_emg_param_3_1);
      #line 525 
      ldv_free((void *)emg_16_emg_param_1_0);
      #line 526 
      ldv_free((void *)emg_16_emg_param_3_1);
    }
    else {
      #line 535 
      __VERIFIER_assume(emg_16_size_cnt <= 2147479552UL);
      #line 536 
      emg_16_emg_param_1_2 = (char *)ldv_xmalloc_unknown_size(0UL);
      #line 536 
      emg_16_emg_param_1_2 = emg_16_emg_param_1_2;
      #line 537 
      emg_16_emg_param_3_3 = (long long *)ldv_xmalloc_unknown_size(0UL);
      #line 537 
      emg_16_emg_param_3_3 = emg_16_emg_param_3_3;
      #line 541 
      emg_wrapper_i40e_dbg_netdev_ops_write(emg_16_resource_0,emg_16_emg_param_1_2,emg_16_size_cnt,emg_16_emg_param_3_3);
      #line 545 
      ldv_free((void *)emg_16_emg_param_1_2);
      #line 546 
      ldv_free((void *)emg_16_emg_param_3_3);
    }
    #line 550 
    if (emg_repeat_cnt_call_16 > 0) {
      #line 551 
      emg_repeat_cnt_call_16 --;
      #line 553 
      goto emg_call_16;
    }
    else 
         #line 555 
         __VERIFIER_assume(0);
  }
  else {
    #line 561 
    if (emg_16_container->release != (int (*)(struct inode *, struct file *))0) 
      #line 562 
      (*(emg_16_container->release))(emg_16_resource_1,emg_16_resource_0);
    #line 566 
    if (emg_repeat_cnt_main_16_0 > 0) {
      #line 567 
      emg_repeat_cnt_main_16_0 --;
      #line 569 
      goto emg_main_16;
    }
    else 
         #line 571 
         __VERIFIER_assume(0);
  }
  #line 577 
  return (void *)0;
  #line 580 
  emg_main_16: 
               #line 580 
  ;
  #line 581 
  if (ldv_undef_int() != 0) {
    #line 583 
    emg_16_ret = simple_open(emg_16_resource_1,emg_16_resource_0);
    #line 588 
    emg_16_ret = ldv_filter_err_code(emg_16_ret);
    #line 591 
    if (ldv_undef_int() != 0) {
      #line 593 
      __VERIFIER_assume(emg_16_ret == 0);
      #line 597 
      goto emg_call_16;
    }
    else {
      #line 602 
      __VERIFIER_assume(emg_16_ret != 0);
      #line 605 
      if (emg_repeat_cnt_main_16_1 > 0) {
        #line 606 
        emg_repeat_cnt_main_16_1 --;
        #line 608 
        goto emg_main_16;
      }
      else 
           #line 610 
           __VERIFIER_assume(0);
    }
  }
  else 
       #line 617 
       ldv_free((void *)emg_16_resource_0);
  #line 625 
  return (void *)0;
}

#line 630  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void *emg_interrupt_interrupt_scenario_i40e_intr(void *arg0)
{
  #line 633 
  enum irqreturn (*emg_17_callback)(int , void *);
  #line 634 
  void *emg_17_data;
  #line 635 
  int emg_17_line;
  #line 636 
  enum irqreturn emg_17_ret_val;
  #line 637 
  enum irqreturn (*emg_17_thread)(int , void *);
  #line 639 
  struct emg_struct_interrupt_scenario_i40e_intr_17 *data = (struct emg_struct_interrupt_scenario_i40e_intr_17 *)arg0;
  #line 642 
  emg_17_callback = & emg_wrapper_i40e_intr;
  #line 645 
  if (data != (struct emg_struct_interrupt_scenario_i40e_intr_17 *)0) {
    #line 646 
    emg_17_line = data->arg0;
    #line 647 
    emg_17_callback = data->arg1;
    #line 648 
    emg_17_thread = data->arg2;
    #line 649 
    emg_17_data = data->arg3;
    #line 650 
    ldv_free((void *)data);
  }
  #line 656 
  ldv_switch_to_interrupt_context();
  #line 660 
  emg_17_ret_val = emg_wrapper_i40e_intr(emg_17_line,emg_17_data);
  #line 665 
  ldv_switch_to_process_context();
  #line 668 
  if (ldv_undef_int() != 0) {
    #line 670 
    __VERIFIER_assume(emg_17_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    #line 674 
    if (emg_17_thread != (enum irqreturn (*)(int , void *))0) 
                                                              #line 675 
                                                              (*emg_17_thread)(emg_17_line,emg_17_data);
  }
  else 
       #line 680 
       __VERIFIER_assume(emg_17_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  #line 688 
  return (void *)0;
}

#line 693  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void *emg_net_random_allocationless_scenario_i40e_ddp_flash(void *arg0)
{
  #line 696 
  struct net_device *emg_18_container;
  #line 697 
  struct sk_buff *emg_18_emg_param_0_36;
  #line 698 
  struct ndmsg *emg_18_emg_param_0_49;
  #line 699 
  struct sk_buff *emg_18_emg_param_0_55;
  #line 700 
  struct sk_buff *emg_18_emg_param_0_82;
  #line 701 
  struct ethtool_flash *emg_18_emg_param_1_0;
  #line 702 
  struct ethtool_eeprom *emg_18_emg_param_1_1;
  #line 703 
  struct ethtool_eeprom *emg_18_emg_param_1_10;
  #line 704 
  struct ethtool_fecparam *emg_18_emg_param_1_101;
  #line 705 
  struct ethtool_link_ksettings *emg_18_emg_param_1_102;
  #line 706 
  unsigned int emg_18_emg_param_1_103;
  #line 707 
  struct ethtool_pauseparam *emg_18_emg_param_1_104;
  #line 708 
  unsigned int emg_18_emg_param_1_105;
  #line 709 
  enum ethtool_phys_id_state *emg_18_emg_param_1_107;
  #line 710 
  unsigned int emg_18_emg_param_1_108;
  #line 711 
  struct ethtool_ringparam *emg_18_emg_param_1_109;
  #line 712 
  unsigned int *emg_18_emg_param_1_110;
  #line 713 
  struct ethtool_rxnfc *emg_18_emg_param_1_113;
  #line 714 
  struct ethtool_wolinfo *emg_18_emg_param_1_114;
  #line 715 
  struct ethtool_stats *emg_18_emg_param_1_12;
  #line 716 
  struct ethtool_fecparam *emg_18_emg_param_1_14;
  #line 717 
  struct ethtool_link_ksettings *emg_18_emg_param_1_15;
  #line 718 
  struct ethtool_eeprom *emg_18_emg_param_1_16;
  #line 719 
  struct ethtool_modinfo *emg_18_emg_param_1_18;
  #line 720 
  struct ethtool_pauseparam *emg_18_emg_param_1_19;
  #line 721 
  unsigned int emg_18_emg_param_1_20;
  #line 722 
  struct ethtool_regs *emg_18_emg_param_1_22;
  #line 723 
  struct ethtool_ringparam *emg_18_emg_param_1_24;
  #line 724 
  unsigned int *emg_18_emg_param_1_25;
  #line 725 
  struct ethtool_rxnfc *emg_18_emg_param_1_28;
  #line 726 
  struct ethtool_eeprom *emg_18_emg_param_1_3;
  #line 727 
  int emg_18_emg_param_1_30;
  #line 728 
  unsigned int emg_18_emg_param_1_31;
  #line 729 
  struct ethtool_ts_info *emg_18_emg_param_1_33;
  #line 730 
  struct ethtool_wolinfo *emg_18_emg_param_1_34;
  #line 731 
  struct netdev_bpf *emg_18_emg_param_1_35;
  #line 732 
  unsigned int emg_18_emg_param_1_37;
  #line 733 
  struct nlmsghdr *emg_18_emg_param_1_41;
  #line 734 
  int emg_18_emg_param_1_44;
  #line 735 
  struct net_device *emg_18_emg_param_1_45;
  #line 736 
  void *emg_18_emg_param_1_46;
  #line 737 
  struct ifreq *emg_18_emg_param_1_47;
  #line 738 
  struct ethtool_drvinfo *emg_18_emg_param_1_5;
  #line 739 
  struct nlattr **emg_18_emg_param_1_50;
  #line 740 
  struct netdev_phys_item_id *emg_18_emg_param_1_57;
  #line 741 
  struct rtnl_link_stats64 *emg_18_emg_param_1_58;
  #line 742 
  int emg_18_emg_param_1_59;
  #line 743 
  struct ethtool_channels *emg_18_emg_param_1_6;
  #line 744 
  int emg_18_emg_param_1_61;
  #line 745 
  unsigned long long emg_18_emg_param_1_63;
  #line 746 
  void *emg_18_emg_param_1_64;
  #line 747 
  int emg_18_emg_param_1_65;
  #line 748 
  int emg_18_emg_param_1_67;
  #line 749 
  int emg_18_emg_param_1_69;
  #line 750 
  struct ethtool_coalesce *emg_18_emg_param_1_7;
  #line 751 
  int emg_18_emg_param_1_72;
  #line 752 
  int emg_18_emg_param_1_74;
  #line 753 
  int emg_18_emg_param_1_76;
  #line 754 
  struct ethtool_drvinfo *emg_18_emg_param_1_8;
  #line 755 
  enum tc_setup_type *emg_18_emg_param_1_80;
  #line 756 
  struct udp_tunnel_info *emg_18_emg_param_1_83;
  #line 757 
  struct udp_tunnel_info *emg_18_emg_param_1_84;
  #line 758 
  unsigned short emg_18_emg_param_1_85;
  #line 759 
  unsigned short emg_18_emg_param_1_87;
  #line 760 
  int emg_18_emg_param_1_89;
  #line 761 
  struct ethtool_eee *emg_18_emg_param_1_9;
  #line 762 
  unsigned int emg_18_emg_param_1_92;
  #line 763 
  struct ethtool_test *emg_18_emg_param_1_94;
  #line 764 
  struct ethtool_channels *emg_18_emg_param_1_96;
  #line 765 
  struct ethtool_coalesce *emg_18_emg_param_1_97;
  #line 766 
  struct ethtool_eee *emg_18_emg_param_1_98;
  #line 767 
  struct ethtool_eeprom *emg_18_emg_param_1_99;
  #line 768 
  unsigned char *emg_18_emg_param_2_100;
  #line 769 
  struct ethtool_coalesce *emg_18_emg_param_2_106;
  #line 770 
  unsigned char *emg_18_emg_param_2_11;
  #line 771 
  unsigned char *emg_18_emg_param_2_111;
  #line 772 
  unsigned long long *emg_18_emg_param_2_13;
  #line 773 
  unsigned char *emg_18_emg_param_2_17;
  #line 774 
  unsigned char *emg_18_emg_param_2_2;
  #line 775 
  struct ethtool_coalesce *emg_18_emg_param_2_21;
  #line 776 
  void *emg_18_emg_param_2_23;
  #line 777 
  unsigned char *emg_18_emg_param_2_26;
  #line 778 
  unsigned int *emg_18_emg_param_2_29;
  #line 779 
  unsigned char *emg_18_emg_param_2_32;
  #line 780 
  unsigned int emg_18_emg_param_2_38;
  #line 781 
  unsigned char *emg_18_emg_param_2_4;
  #line 782 
  unsigned short emg_18_emg_param_2_42;
  #line 783 
  int emg_18_emg_param_2_48;
  #line 784 
  unsigned long long emg_18_emg_param_2_56;
  #line 785 
  struct ifla_vf_info *emg_18_emg_param_2_60;
  #line 786 
  struct ifla_vf_stats *emg_18_emg_param_2_62;
  #line 787 
  int emg_18_emg_param_2_66;
  #line 788 
  unsigned char *emg_18_emg_param_2_68;
  #line 789 
  int emg_18_emg_param_2_70;
  #line 790 
  _Bool emg_18_emg_param_2_73;
  #line 791 
  _Bool emg_18_emg_param_2_75;
  #line 792 
  unsigned short emg_18_emg_param_2_77;
  #line 793 
  void *emg_18_emg_param_2_81;
  #line 794 
  unsigned short emg_18_emg_param_2_86;
  #line 795 
  unsigned short emg_18_emg_param_2_88;
  #line 796 
  struct xdp_frame **emg_18_emg_param_2_90;
  #line 797 
  unsigned int emg_18_emg_param_2_93;
  #line 798 
  unsigned long long *emg_18_emg_param_2_95;
  #line 799 
  unsigned char emg_18_emg_param_3_112;
  #line 800 
  unsigned char *emg_18_emg_param_3_27;
  #line 801 
  struct netlink_ext_ack *emg_18_emg_param_3_43;
  #line 802 
  unsigned char *emg_18_emg_param_3_51;
  #line 803 
  int emg_18_emg_param_3_71;
  #line 804 
  unsigned char emg_18_emg_param_3_78;
  #line 805 
  unsigned int emg_18_emg_param_3_91;
  #line 806 
  unsigned int emg_18_emg_param_4_39;
  #line 807 
  unsigned short emg_18_emg_param_4_52;
  #line 808 
  unsigned short emg_18_emg_param_4_79;
  #line 809 
  int emg_18_emg_param_5_40;
  #line 810 
  unsigned short emg_18_emg_param_5_53;
  #line 811 
  struct netlink_ext_ack *emg_18_emg_param_6_54;
  #line 812 
  int emg_repeat_cnt_call_18 = 1;
  #line 814 
  struct emg_struct_random_allocationless_scenario_i40e_ddp_flash_18 *data = (struct emg_struct_random_allocationless_scenario_i40e_ddp_flash_18 *)arg0;
  #line 819 
  if (data != (struct emg_struct_random_allocationless_scenario_i40e_ddp_flash_18 *)0) {
    #line 820 
    emg_18_container = data->arg0;
    #line 821 
    ldv_free((void *)data);
  }
  #line 826 
  goto emg_call_18;
  #line 830 
  return (void *)0;
  #line 833 
  emg_call_18: 
               #line 833 
  ;
  #line 834 
  switch (ldv_undef_int()) {
    #line 835 
    case 0: 
            #line 835 
    ;
    #line 837 
    emg_18_emg_param_1_114 = (struct ethtool_wolinfo *)ldv_xmalloc_unknown_size(0UL);
    #line 837 
    emg_18_emg_param_1_114 = emg_18_emg_param_1_114;
    #line 841 
    emg_wrapper_i40e_set_wol(emg_18_container,emg_18_emg_param_1_114);
    #line 845 
    ldv_free((void *)emg_18_emg_param_1_114);
    #line 847 
    break;
    #line 849 
    case 1: 
            #line 849 
    ;
    #line 851 
    emg_18_emg_param_1_113 = (struct ethtool_rxnfc *)ldv_xmalloc_unknown_size(0UL);
    #line 851 
    emg_18_emg_param_1_113 = emg_18_emg_param_1_113;
    #line 855 
    emg_wrapper_i40e_set_rxnfc(emg_18_container,emg_18_emg_param_1_113);
    #line 859 
    ldv_free((void *)emg_18_emg_param_1_113);
    #line 861 
    break;
    #line 863 
    case 2: 
            #line 863 
    ;
    #line 865 
    emg_18_emg_param_1_110 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
    #line 865 
    emg_18_emg_param_1_110 = emg_18_emg_param_1_110;
    #line 866 
    emg_18_emg_param_2_111 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 866 
    emg_18_emg_param_2_111 = emg_18_emg_param_2_111;
    #line 870 
    emg_wrapper_i40e_set_rxfh(emg_18_container,emg_18_emg_param_1_110,emg_18_emg_param_2_111,(unsigned char)((int)emg_18_emg_param_3_112));
    #line 874 
    ldv_free((void *)emg_18_emg_param_1_110);
    #line 875 
    ldv_free((void *)emg_18_emg_param_2_111);
    #line 877 
    break;
    #line 879 
    case 3: 
            #line 879 
    ;
    #line 881 
    emg_18_emg_param_1_109 = (struct ethtool_ringparam *)ldv_xmalloc_unknown_size(0UL);
    #line 881 
    emg_18_emg_param_1_109 = emg_18_emg_param_1_109;
    #line 885 
    emg_wrapper_i40e_set_ringparam(emg_18_container,emg_18_emg_param_1_109);
    #line 889 
    ldv_free((void *)emg_18_emg_param_1_109);
    #line 891 
    break;
    #line 893 
    case 4: 
            #line 893 
    ;
    #line 895 
    emg_wrapper_i40e_set_priv_flags(emg_18_container,emg_18_emg_param_1_108);
    #line 897 
    break;
    #line 899 
    case 5: 
            #line 899 
    ;
    #line 901 
    emg_18_emg_param_1_107 = (enum ethtool_phys_id_state *)ldv_xmalloc_unknown_size(0UL);
    #line 901 
    emg_18_emg_param_1_107 = emg_18_emg_param_1_107;
    #line 905 
    emg_wrapper_i40e_set_phys_id(emg_18_container,*emg_18_emg_param_1_107);
    #line 909 
    ldv_free((void *)emg_18_emg_param_1_107);
    #line 911 
    break;
    #line 913 
    case 6: 
            #line 913 
    ;
    #line 915 
    emg_18_emg_param_2_106 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
    #line 915 
    emg_18_emg_param_2_106 = emg_18_emg_param_2_106;
    #line 919 
    emg_wrapper_i40e_set_per_queue_coalesce(emg_18_container,emg_18_emg_param_1_105,emg_18_emg_param_2_106);
    #line 923 
    ldv_free((void *)emg_18_emg_param_2_106);
    #line 925 
    break;
    #line 927 
    case 7: 
            #line 927 
    ;
    #line 929 
    emg_18_emg_param_1_104 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
    #line 929 
    emg_18_emg_param_1_104 = emg_18_emg_param_1_104;
    #line 933 
    emg_wrapper_i40e_set_pauseparam(emg_18_container,emg_18_emg_param_1_104);
    #line 937 
    ldv_free((void *)emg_18_emg_param_1_104);
    #line 939 
    break;
    #line 941 
    case 8: 
            #line 941 
    ;
    #line 943 
    emg_wrapper_i40e_set_msglevel(emg_18_container,emg_18_emg_param_1_103);
    #line 945 
    break;
    #line 947 
    case 9: 
            #line 947 
    ;
    #line 949 
    emg_18_emg_param_1_102 = (struct ethtool_link_ksettings *)ldv_xmalloc_unknown_size(0UL);
    #line 949 
    emg_18_emg_param_1_102 = emg_18_emg_param_1_102;
    #line 953 
    emg_wrapper_i40e_set_link_ksettings(emg_18_container,emg_18_emg_param_1_102);
    #line 957 
    ldv_free((void *)emg_18_emg_param_1_102);
    #line 959 
    break;
    #line 961 
    case 10: 
             #line 961 
    ;
    #line 963 
    emg_18_emg_param_1_101 = (struct ethtool_fecparam *)ldv_xmalloc_unknown_size(0UL);
    #line 963 
    emg_18_emg_param_1_101 = emg_18_emg_param_1_101;
    #line 967 
    emg_wrapper_i40e_set_fec_param(emg_18_container,emg_18_emg_param_1_101);
    #line 971 
    ldv_free((void *)emg_18_emg_param_1_101);
    #line 973 
    break;
    #line 975 
    case 11: 
             #line 975 
    ;
    #line 977 
    emg_18_emg_param_1_99 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
    #line 977 
    emg_18_emg_param_1_99 = emg_18_emg_param_1_99;
    #line 978 
    emg_18_emg_param_2_100 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 978 
    emg_18_emg_param_2_100 = emg_18_emg_param_2_100;
    #line 982 
    emg_wrapper_i40e_set_eeprom(emg_18_container,emg_18_emg_param_1_99,emg_18_emg_param_2_100);
    #line 986 
    ldv_free((void *)emg_18_emg_param_1_99);
    #line 987 
    ldv_free((void *)emg_18_emg_param_2_100);
    #line 989 
    break;
    #line 991 
    case 12: 
             #line 991 
    ;
    #line 993 
    emg_18_emg_param_1_98 = (struct ethtool_eee *)ldv_xmalloc_unknown_size(0UL);
    #line 993 
    emg_18_emg_param_1_98 = emg_18_emg_param_1_98;
    #line 997 
    emg_wrapper_i40e_set_eee(emg_18_container,emg_18_emg_param_1_98);
    #line 1001 
    ldv_free((void *)emg_18_emg_param_1_98);
    #line 1003 
    break;
    #line 1005 
    case 13: 
             #line 1005 
    ;
    #line 1007 
    emg_18_emg_param_1_97 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
    #line 1007 
    emg_18_emg_param_1_97 = emg_18_emg_param_1_97;
    #line 1011 
    emg_wrapper_i40e_set_coalesce(emg_18_container,emg_18_emg_param_1_97);
    #line 1015 
    ldv_free((void *)emg_18_emg_param_1_97);
    #line 1017 
    break;
    #line 1019 
    case 14: 
             #line 1019 
    ;
    #line 1021 
    emg_18_emg_param_1_96 = (struct ethtool_channels *)ldv_xmalloc_unknown_size(0UL);
    #line 1021 
    emg_18_emg_param_1_96 = emg_18_emg_param_1_96;
    #line 1025 
    emg_wrapper_i40e_set_channels(emg_18_container,emg_18_emg_param_1_96);
    #line 1029 
    ldv_free((void *)emg_18_emg_param_1_96);
    #line 1031 
    break;
    #line 1033 
    case 15: 
             #line 1033 
    ;
    #line 1035 
    emg_18_emg_param_1_94 = (struct ethtool_test *)ldv_xmalloc_unknown_size(0UL);
    #line 1035 
    emg_18_emg_param_1_94 = emg_18_emg_param_1_94;
    #line 1036 
    emg_18_emg_param_2_95 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
    #line 1036 
    emg_18_emg_param_2_95 = emg_18_emg_param_2_95;
    #line 1040 
    emg_wrapper_i40e_diag_test(emg_18_container,emg_18_emg_param_1_94,emg_18_emg_param_2_95);
    #line 1044 
    ldv_free((void *)emg_18_emg_param_1_94);
    #line 1045 
    ldv_free((void *)emg_18_emg_param_2_95);
    #line 1047 
    break;
    #line 1049 
    case 16: 
             #line 1049 
    ;
    #line 1051 
    emg_wrapper_i40e_nway_reset(emg_18_container);
    #line 1053 
    break;
    #line 1055 
    case 17: 
             #line 1055 
    ;
    #line 1057 
    i40e_xsk_wakeup(emg_18_container,emg_18_emg_param_1_92,emg_18_emg_param_2_93);
    #line 1059 
    break;
    #line 1061 
    case 18: 
             #line 1061 
    ;
    #line 1063 
    emg_18_emg_param_2_90 = (struct xdp_frame **)ldv_xmalloc_unknown_size(0UL);
    #line 1063 
    emg_18_emg_param_2_90 = emg_18_emg_param_2_90;
    #line 1067 
    i40e_xdp_xmit(emg_18_container,emg_18_emg_param_1_89,emg_18_emg_param_2_90,emg_18_emg_param_3_91);
    #line 1071 
    ldv_free((void *)emg_18_emg_param_2_90);
    #line 1073 
    break;
    #line 1075 
    case 19: 
             #line 1075 
    ;
    #line 1077 
    emg_wrapper_i40e_vlan_rx_kill_vid(emg_18_container,(unsigned short)((int)emg_18_emg_param_1_87),(unsigned short)((int)emg_18_emg_param_2_88));
    #line 1079 
    break;
    #line 1081 
    case 20: 
             #line 1081 
    ;
    #line 1083 
    emg_wrapper_i40e_vlan_rx_add_vid(emg_18_container,(unsigned short)((int)emg_18_emg_param_1_85),(unsigned short)((int)emg_18_emg_param_2_86));
    #line 1085 
    break;
    #line 1087 
    case 21: 
             #line 1087 
    ;
    #line 1089 
    (*emg_alias_eth_validate_addr)(emg_18_container);
    #line 1091 
    break;
    #line 1093 
    case 22: 
             #line 1093 
    ;
    #line 1095 
    emg_18_emg_param_1_84 = (struct udp_tunnel_info *)ldv_xmalloc_unknown_size(0UL);
    #line 1095 
    emg_18_emg_param_1_84 = emg_18_emg_param_1_84;
    #line 1099 
    emg_wrapper_i40e_udp_tunnel_del(emg_18_container,emg_18_emg_param_1_84);
    #line 1103 
    ldv_free((void *)emg_18_emg_param_1_84);
    #line 1105 
    break;
    #line 1107 
    case 23: 
             #line 1107 
    ;
    #line 1109 
    emg_18_emg_param_1_83 = (struct udp_tunnel_info *)ldv_xmalloc_unknown_size(0UL);
    #line 1109 
    emg_18_emg_param_1_83 = emg_18_emg_param_1_83;
    #line 1113 
    emg_wrapper_i40e_udp_tunnel_add(emg_18_container,emg_18_emg_param_1_83);
    #line 1117 
    ldv_free((void *)emg_18_emg_param_1_83);
    #line 1119 
    break;
    #line 1121 
    case 24: 
             #line 1121 
    ;
    #line 1123 
    emg_wrapper_i40e_tx_timeout(emg_18_container);
    #line 1125 
    break;
    #line 1127 
    case 25: 
             #line 1127 
    ;
    #line 1129 
    emg_18_emg_param_0_82 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
    #line 1129 
    emg_18_emg_param_0_82 = emg_18_emg_param_0_82;
    #line 1133 
    i40e_lan_xmit_frame(emg_18_emg_param_0_82,emg_18_container);
    #line 1137 
    ldv_free((void *)emg_18_emg_param_0_82);
    #line 1139 
    break;
    #line 1141 
    case 26: 
             #line 1141 
    ;
    #line 1143 
    emg_18_emg_param_1_80 = (enum tc_setup_type *)ldv_xmalloc_unknown_size(0UL);
    #line 1143 
    emg_18_emg_param_1_80 = emg_18_emg_param_1_80;
    #line 1144 
    emg_18_emg_param_2_81 = ldv_xmalloc_unknown_size(0UL);
    #line 1144 
    emg_18_emg_param_2_81 = emg_18_emg_param_2_81;
    #line 1148 
    emg_wrapper___i40e_setup_tc(emg_18_container,*emg_18_emg_param_1_80,emg_18_emg_param_2_81);
    #line 1152 
    ldv_free((void *)emg_18_emg_param_1_80);
    #line 1153 
    ldv_free(emg_18_emg_param_2_81);
    #line 1155 
    break;
    #line 1157 
    case 27: 
             #line 1157 
    ;
    #line 1159 
    i40e_ndo_set_vf_port_vlan(emg_18_container,emg_18_emg_param_1_76,(unsigned short)((int)emg_18_emg_param_2_77),(unsigned char)((int)emg_18_emg_param_3_78),(unsigned short)((int)emg_18_emg_param_4_79));
    #line 1161 
    break;
    #line 1163 
    case 28: 
             #line 1163 
    ;
    #line 1165 
    i40e_ndo_set_vf_trust(emg_18_container,emg_18_emg_param_1_74,(_Bool)((bool)((int)emg_18_emg_param_2_75) != 0));
    #line 1167 
    break;
    #line 1169 
    case 29: 
             #line 1169 
    ;
    #line 1171 
    i40e_ndo_set_vf_spoofchk(emg_18_container,emg_18_emg_param_1_72,(_Bool)((bool)((int)emg_18_emg_param_2_73) != 0));
    #line 1173 
    break;
    #line 1175 
    case 30: 
             #line 1175 
    ;
    #line 1177 
    i40e_ndo_set_vf_bw(emg_18_container,emg_18_emg_param_1_69,emg_18_emg_param_2_70,emg_18_emg_param_3_71);
    #line 1179 
    break;
    #line 1181 
    case 31: 
             #line 1181 
    ;
    #line 1183 
    emg_18_emg_param_2_68 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1183 
    emg_18_emg_param_2_68 = emg_18_emg_param_2_68;
    #line 1187 
    i40e_ndo_set_vf_mac(emg_18_container,emg_18_emg_param_1_67,emg_18_emg_param_2_68);
    #line 1191 
    ldv_free((void *)emg_18_emg_param_2_68);
    #line 1193 
    break;
    #line 1195 
    case 32: 
             #line 1195 
    ;
    #line 1197 
    i40e_ndo_set_vf_link_state(emg_18_container,emg_18_emg_param_1_65,emg_18_emg_param_2_66);
    #line 1199 
    break;
    #line 1201 
    case 33: 
             #line 1201 
    ;
    #line 1203 
    emg_wrapper_i40e_set_rx_mode(emg_18_container);
    #line 1205 
    break;
    #line 1207 
    case 34: 
             #line 1207 
    ;
    #line 1209 
    emg_18_emg_param_1_64 = ldv_xmalloc_unknown_size(0UL);
    #line 1209 
    emg_18_emg_param_1_64 = emg_18_emg_param_1_64;
    #line 1213 
    emg_wrapper_i40e_set_mac(emg_18_container,emg_18_emg_param_1_64);
    #line 1217 
    ldv_free(emg_18_emg_param_1_64);
    #line 1219 
    break;
    #line 1221 
    case 35: 
             #line 1221 
    ;
    #line 1223 
    emg_wrapper_i40e_set_features(emg_18_container,emg_18_emg_param_1_63);
    #line 1225 
    break;
    #line 1227 
    case 36: 
             #line 1227 
    ;
    #line 1229 
    emg_wrapper_i40e_netpoll(emg_18_container);
    #line 1231 
    break;
    #line 1233 
    case 37: 
             #line 1233 
    ;
    #line 1235 
    emg_18_emg_param_2_62 = (struct ifla_vf_stats *)ldv_xmalloc_unknown_size(0UL);
    #line 1235 
    emg_18_emg_param_2_62 = emg_18_emg_param_2_62;
    #line 1239 
    i40e_get_vf_stats(emg_18_container,emg_18_emg_param_1_61,emg_18_emg_param_2_62);
    #line 1243 
    ldv_free((void *)emg_18_emg_param_2_62);
    #line 1245 
    break;
    #line 1247 
    case 38: 
             #line 1247 
    ;
    #line 1249 
    emg_18_emg_param_2_60 = (struct ifla_vf_info *)ldv_xmalloc_unknown_size(0UL);
    #line 1249 
    emg_18_emg_param_2_60 = emg_18_emg_param_2_60;
    #line 1253 
    i40e_ndo_get_vf_config(emg_18_container,emg_18_emg_param_1_59,emg_18_emg_param_2_60);
    #line 1257 
    ldv_free((void *)emg_18_emg_param_2_60);
    #line 1259 
    break;
    #line 1261 
    case 39: 
             #line 1261 
    ;
    #line 1263 
    emg_18_emg_param_1_58 = (struct rtnl_link_stats64 *)ldv_xmalloc_unknown_size(0UL);
    #line 1263 
    emg_18_emg_param_1_58 = emg_18_emg_param_1_58;
    #line 1267 
    emg_wrapper_i40e_get_netdev_stats_struct(emg_18_container,emg_18_emg_param_1_58);
    #line 1271 
    ldv_free((void *)emg_18_emg_param_1_58);
    #line 1273 
    break;
    #line 1275 
    case 40: 
             #line 1275 
    ;
    #line 1277 
    emg_18_emg_param_1_57 = (struct netdev_phys_item_id *)ldv_xmalloc_unknown_size(0UL);
    #line 1277 
    emg_18_emg_param_1_57 = emg_18_emg_param_1_57;
    #line 1281 
    emg_wrapper_i40e_get_phys_port_id(emg_18_container,emg_18_emg_param_1_57);
    #line 1285 
    ldv_free((void *)emg_18_emg_param_1_57);
    #line 1287 
    break;
    #line 1289 
    case 41: 
             #line 1289 
    ;
    #line 1291 
    emg_18_emg_param_0_55 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
    #line 1291 
    emg_18_emg_param_0_55 = emg_18_emg_param_0_55;
    #line 1295 
    emg_wrapper_i40e_features_check(emg_18_emg_param_0_55,emg_18_container,emg_18_emg_param_2_56);
    #line 1299 
    ldv_free((void *)emg_18_emg_param_0_55);
    #line 1301 
    break;
    #line 1303 
    case 42: 
             #line 1303 
    ;
    #line 1305 
    emg_18_emg_param_0_49 = (struct ndmsg *)ldv_xmalloc_unknown_size(0UL);
    #line 1305 
    emg_18_emg_param_0_49 = emg_18_emg_param_0_49;
    #line 1306 
    emg_18_emg_param_1_50 = (struct nlattr **)ldv_xmalloc_unknown_size(0UL);
    #line 1306 
    emg_18_emg_param_1_50 = emg_18_emg_param_1_50;
    #line 1307 
    emg_18_emg_param_3_51 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1307 
    emg_18_emg_param_3_51 = emg_18_emg_param_3_51;
    #line 1308 
    emg_18_emg_param_6_54 = (struct netlink_ext_ack *)ldv_xmalloc_unknown_size(0UL);
    #line 1308 
    emg_18_emg_param_6_54 = emg_18_emg_param_6_54;
    #line 1312 
    emg_wrapper_i40e_ndo_fdb_add(emg_18_emg_param_0_49,emg_18_emg_param_1_50,emg_18_container,emg_18_emg_param_3_51,(unsigned short)((int)emg_18_emg_param_4_52),(unsigned short)((int)emg_18_emg_param_5_53),emg_18_emg_param_6_54);
    #line 1316 
    ldv_free((void *)emg_18_emg_param_0_49);
    #line 1317 
    ldv_free((void *)emg_18_emg_param_1_50);
    #line 1318 
    ldv_free((void *)emg_18_emg_param_3_51);
    #line 1319 
    ldv_free((void *)emg_18_emg_param_6_54);
    #line 1321 
    break;
    #line 1323 
    case 43: 
             #line 1323 
    ;
    #line 1325 
    emg_18_emg_param_1_47 = (struct ifreq *)ldv_xmalloc_unknown_size(0UL);
    #line 1325 
    emg_18_emg_param_1_47 = emg_18_emg_param_1_47;
    #line 1329 
    i40e_ioctl(emg_18_container,emg_18_emg_param_1_47,emg_18_emg_param_2_48);
    #line 1333 
    ldv_free((void *)emg_18_emg_param_1_47);
    #line 1335 
    break;
    #line 1337 
    case 44: 
             #line 1337 
    ;
    #line 1339 
    emg_18_emg_param_1_46 = ldv_xmalloc_unknown_size(0UL);
    #line 1339 
    emg_18_emg_param_1_46 = emg_18_emg_param_1_46;
    #line 1343 
    emg_wrapper_i40e_fwd_del(emg_18_container,emg_18_emg_param_1_46);
    #line 1347 
    ldv_free(emg_18_emg_param_1_46);
    #line 1349 
    break;
    #line 1351 
    case 45: 
             #line 1351 
    ;
    #line 1353 
    emg_18_emg_param_1_45 = (struct net_device *)ldv_xmalloc_unknown_size(0UL);
    #line 1353 
    emg_18_emg_param_1_45 = emg_18_emg_param_1_45;
    #line 1357 
    emg_wrapper_i40e_fwd_add(emg_18_container,emg_18_emg_param_1_45);
    #line 1361 
    ldv_free((void *)emg_18_emg_param_1_45);
    #line 1363 
    break;
    #line 1365 
    case 46: 
             #line 1365 
    ;
    #line 1367 
    emg_wrapper_i40e_change_mtu(emg_18_container,emg_18_emg_param_1_44);
    #line 1369 
    break;
    #line 1371 
    case 47: 
             #line 1371 
    ;
    #line 1373 
    emg_18_emg_param_1_41 = (struct nlmsghdr *)ldv_xmalloc_unknown_size(0UL);
    #line 1373 
    emg_18_emg_param_1_41 = emg_18_emg_param_1_41;
    #line 1374 
    emg_18_emg_param_3_43 = (struct netlink_ext_ack *)ldv_xmalloc_unknown_size(0UL);
    #line 1374 
    emg_18_emg_param_3_43 = emg_18_emg_param_3_43;
    #line 1378 
    emg_wrapper_i40e_ndo_bridge_setlink(emg_18_container,emg_18_emg_param_1_41,(unsigned short)((int)emg_18_emg_param_2_42),emg_18_emg_param_3_43);
    #line 1382 
    ldv_free((void *)emg_18_emg_param_1_41);
    #line 1383 
    ldv_free((void *)emg_18_emg_param_3_43);
    #line 1385 
    break;
    #line 1387 
    case 48: 
             #line 1387 
    ;
    #line 1389 
    emg_18_emg_param_0_36 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
    #line 1389 
    emg_18_emg_param_0_36 = emg_18_emg_param_0_36;
    #line 1393 
    emg_wrapper_i40e_ndo_bridge_getlink(emg_18_emg_param_0_36,emg_18_emg_param_1_37,emg_18_emg_param_2_38,emg_18_container,emg_18_emg_param_4_39,emg_18_emg_param_5_40);
    #line 1397 
    ldv_free((void *)emg_18_emg_param_0_36);
    #line 1399 
    break;
    #line 1401 
    case 49: 
             #line 1401 
    ;
    #line 1403 
    emg_18_emg_param_1_35 = (struct netdev_bpf *)ldv_xmalloc_unknown_size(0UL);
    #line 1403 
    emg_18_emg_param_1_35 = emg_18_emg_param_1_35;
    #line 1407 
    emg_wrapper_i40e_xdp(emg_18_container,emg_18_emg_param_1_35);
    #line 1411 
    ldv_free((void *)emg_18_emg_param_1_35);
    #line 1413 
    break;
    #line 1415 
    case 50: 
             #line 1415 
    ;
    #line 1417 
    emg_18_emg_param_1_34 = (struct ethtool_wolinfo *)ldv_xmalloc_unknown_size(0UL);
    #line 1417 
    emg_18_emg_param_1_34 = emg_18_emg_param_1_34;
    #line 1421 
    emg_wrapper_i40e_get_wol(emg_18_container,emg_18_emg_param_1_34);
    #line 1425 
    ldv_free((void *)emg_18_emg_param_1_34);
    #line 1427 
    break;
    #line 1429 
    case 51: 
             #line 1429 
    ;
    #line 1431 
    emg_18_emg_param_1_33 = (struct ethtool_ts_info *)ldv_xmalloc_unknown_size(0UL);
    #line 1431 
    emg_18_emg_param_1_33 = emg_18_emg_param_1_33;
    #line 1435 
    emg_wrapper_i40e_get_ts_info(emg_18_container,emg_18_emg_param_1_33);
    #line 1439 
    ldv_free((void *)emg_18_emg_param_1_33);
    #line 1441 
    break;
    #line 1443 
    case 52: 
             #line 1443 
    ;
    #line 1445 
    emg_18_emg_param_2_32 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1445 
    emg_18_emg_param_2_32 = emg_18_emg_param_2_32;
    #line 1449 
    emg_wrapper_i40e_get_strings(emg_18_container,emg_18_emg_param_1_31,emg_18_emg_param_2_32);
    #line 1453 
    ldv_free((void *)emg_18_emg_param_2_32);
    #line 1455 
    break;
    #line 1457 
    case 53: 
             #line 1457 
    ;
    #line 1459 
    emg_wrapper_i40e_get_sset_count(emg_18_container,emg_18_emg_param_1_30);
    #line 1461 
    break;
    #line 1463 
    case 54: 
             #line 1463 
    ;
    #line 1465 
    emg_18_emg_param_1_28 = (struct ethtool_rxnfc *)ldv_xmalloc_unknown_size(0UL);
    #line 1465 
    emg_18_emg_param_1_28 = emg_18_emg_param_1_28;
    #line 1466 
    emg_18_emg_param_2_29 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
    #line 1466 
    emg_18_emg_param_2_29 = emg_18_emg_param_2_29;
    #line 1470 
    emg_wrapper_i40e_get_rxnfc(emg_18_container,emg_18_emg_param_1_28,emg_18_emg_param_2_29);
    #line 1474 
    ldv_free((void *)emg_18_emg_param_1_28);
    #line 1475 
    ldv_free((void *)emg_18_emg_param_2_29);
    #line 1477 
    break;
    #line 1479 
    case 55: 
             #line 1479 
    ;
    #line 1481 
    emg_wrapper_i40e_get_rxfh_key_size(emg_18_container);
    #line 1483 
    break;
    #line 1485 
    case 56: 
             #line 1485 
    ;
    #line 1487 
    emg_wrapper_i40e_get_rxfh_indir_size(emg_18_container);
    #line 1489 
    break;
    #line 1491 
    case 57: 
             #line 1491 
    ;
    #line 1493 
    emg_18_emg_param_1_25 = (unsigned int *)ldv_xmalloc_unknown_size(0UL);
    #line 1493 
    emg_18_emg_param_1_25 = emg_18_emg_param_1_25;
    #line 1494 
    emg_18_emg_param_2_26 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1494 
    emg_18_emg_param_2_26 = emg_18_emg_param_2_26;
    #line 1495 
    emg_18_emg_param_3_27 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1495 
    emg_18_emg_param_3_27 = emg_18_emg_param_3_27;
    #line 1499 
    emg_wrapper_i40e_get_rxfh(emg_18_container,emg_18_emg_param_1_25,emg_18_emg_param_2_26,emg_18_emg_param_3_27);
    #line 1503 
    ldv_free((void *)emg_18_emg_param_1_25);
    #line 1504 
    ldv_free((void *)emg_18_emg_param_2_26);
    #line 1505 
    ldv_free((void *)emg_18_emg_param_3_27);
    #line 1507 
    break;
    #line 1509 
    case 58: 
             #line 1509 
    ;
    #line 1511 
    emg_18_emg_param_1_24 = (struct ethtool_ringparam *)ldv_xmalloc_unknown_size(0UL);
    #line 1511 
    emg_18_emg_param_1_24 = emg_18_emg_param_1_24;
    #line 1515 
    emg_wrapper_i40e_get_ringparam(emg_18_container,emg_18_emg_param_1_24);
    #line 1519 
    ldv_free((void *)emg_18_emg_param_1_24);
    #line 1521 
    break;
    #line 1523 
    case 59: 
             #line 1523 
    ;
    #line 1525 
    emg_wrapper_i40e_get_regs_len(emg_18_container);
    #line 1527 
    break;
    #line 1529 
    case 60: 
             #line 1529 
    ;
    #line 1531 
    emg_18_emg_param_1_22 = (struct ethtool_regs *)ldv_xmalloc_unknown_size(0UL);
    #line 1531 
    emg_18_emg_param_1_22 = emg_18_emg_param_1_22;
    #line 1532 
    emg_18_emg_param_2_23 = ldv_xmalloc_unknown_size(0UL);
    #line 1532 
    emg_18_emg_param_2_23 = emg_18_emg_param_2_23;
    #line 1536 
    emg_wrapper_i40e_get_regs(emg_18_container,emg_18_emg_param_1_22,emg_18_emg_param_2_23);
    #line 1540 
    ldv_free((void *)emg_18_emg_param_1_22);
    #line 1541 
    ldv_free(emg_18_emg_param_2_23);
    #line 1543 
    break;
    #line 1545 
    case 61: 
             #line 1545 
    ;
    #line 1547 
    emg_wrapper_i40e_get_priv_flags(emg_18_container);
    #line 1549 
    break;
    #line 1551 
    case 62: 
             #line 1551 
    ;
    #line 1553 
    emg_18_emg_param_2_21 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
    #line 1553 
    emg_18_emg_param_2_21 = emg_18_emg_param_2_21;
    #line 1557 
    emg_wrapper_i40e_get_per_queue_coalesce(emg_18_container,emg_18_emg_param_1_20,emg_18_emg_param_2_21);
    #line 1561 
    ldv_free((void *)emg_18_emg_param_2_21);
    #line 1563 
    break;
    #line 1565 
    case 63: 
             #line 1565 
    ;
    #line 1567 
    emg_18_emg_param_1_19 = (struct ethtool_pauseparam *)ldv_xmalloc_unknown_size(0UL);
    #line 1567 
    emg_18_emg_param_1_19 = emg_18_emg_param_1_19;
    #line 1571 
    emg_wrapper_i40e_get_pauseparam(emg_18_container,emg_18_emg_param_1_19);
    #line 1575 
    ldv_free((void *)emg_18_emg_param_1_19);
    #line 1577 
    break;
    #line 1579 
    case 64: 
             #line 1579 
    ;
    #line 1581 
    emg_wrapper_i40e_get_msglevel(emg_18_container);
    #line 1583 
    break;
    #line 1585 
    case 65: 
             #line 1585 
    ;
    #line 1587 
    emg_18_emg_param_1_18 = (struct ethtool_modinfo *)ldv_xmalloc_unknown_size(0UL);
    #line 1587 
    emg_18_emg_param_1_18 = emg_18_emg_param_1_18;
    #line 1591 
    emg_wrapper_i40e_get_module_info(emg_18_container,emg_18_emg_param_1_18);
    #line 1595 
    ldv_free((void *)emg_18_emg_param_1_18);
    #line 1597 
    break;
    #line 1599 
    case 66: 
             #line 1599 
    ;
    #line 1601 
    emg_18_emg_param_1_16 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
    #line 1601 
    emg_18_emg_param_1_16 = emg_18_emg_param_1_16;
    #line 1602 
    emg_18_emg_param_2_17 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1602 
    emg_18_emg_param_2_17 = emg_18_emg_param_2_17;
    #line 1606 
    emg_wrapper_i40e_get_module_eeprom(emg_18_container,emg_18_emg_param_1_16,emg_18_emg_param_2_17);
    #line 1610 
    ldv_free((void *)emg_18_emg_param_1_16);
    #line 1611 
    ldv_free((void *)emg_18_emg_param_2_17);
    #line 1613 
    break;
    #line 1615 
    case 67: 
             #line 1615 
    ;
    #line 1617 
    emg_18_emg_param_1_15 = (struct ethtool_link_ksettings *)ldv_xmalloc_unknown_size(0UL);
    #line 1617 
    emg_18_emg_param_1_15 = emg_18_emg_param_1_15;
    #line 1621 
    emg_wrapper_i40e_get_link_ksettings(emg_18_container,emg_18_emg_param_1_15);
    #line 1625 
    ldv_free((void *)emg_18_emg_param_1_15);
    #line 1627 
    break;
    #line 1629 
    case 68: 
             #line 1629 
    ;
    #line 1631 
    ethtool_op_get_link(emg_18_container);
    #line 1633 
    break;
    #line 1635 
    case 69: 
             #line 1635 
    ;
    #line 1637 
    emg_18_emg_param_1_14 = (struct ethtool_fecparam *)ldv_xmalloc_unknown_size(0UL);
    #line 1637 
    emg_18_emg_param_1_14 = emg_18_emg_param_1_14;
    #line 1641 
    emg_wrapper_i40e_get_fec_param(emg_18_container,emg_18_emg_param_1_14);
    #line 1645 
    ldv_free((void *)emg_18_emg_param_1_14);
    #line 1647 
    break;
    #line 1649 
    case 70: 
             #line 1649 
    ;
    #line 1651 
    emg_18_emg_param_1_12 = (struct ethtool_stats *)ldv_xmalloc_unknown_size(0UL);
    #line 1651 
    emg_18_emg_param_1_12 = emg_18_emg_param_1_12;
    #line 1652 
    emg_18_emg_param_2_13 = (unsigned long long *)ldv_xmalloc_unknown_size(0UL);
    #line 1652 
    emg_18_emg_param_2_13 = emg_18_emg_param_2_13;
    #line 1656 
    emg_wrapper_i40e_get_ethtool_stats(emg_18_container,emg_18_emg_param_1_12,emg_18_emg_param_2_13);
    #line 1660 
    ldv_free((void *)emg_18_emg_param_1_12);
    #line 1661 
    ldv_free((void *)emg_18_emg_param_2_13);
    #line 1663 
    break;
    #line 1665 
    case 71: 
             #line 1665 
    ;
    #line 1667 
    emg_wrapper_i40e_get_eeprom_len(emg_18_container);
    #line 1669 
    break;
    #line 1671 
    case 72: 
             #line 1671 
    ;
    #line 1673 
    emg_18_emg_param_1_10 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
    #line 1673 
    emg_18_emg_param_1_10 = emg_18_emg_param_1_10;
    #line 1674 
    emg_18_emg_param_2_11 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1674 
    emg_18_emg_param_2_11 = emg_18_emg_param_2_11;
    #line 1678 
    emg_wrapper_i40e_get_eeprom(emg_18_container,emg_18_emg_param_1_10,emg_18_emg_param_2_11);
    #line 1682 
    ldv_free((void *)emg_18_emg_param_1_10);
    #line 1683 
    ldv_free((void *)emg_18_emg_param_2_11);
    #line 1685 
    break;
    #line 1687 
    case 73: 
             #line 1687 
    ;
    #line 1689 
    emg_18_emg_param_1_9 = (struct ethtool_eee *)ldv_xmalloc_unknown_size(0UL);
    #line 1689 
    emg_18_emg_param_1_9 = emg_18_emg_param_1_9;
    #line 1693 
    emg_wrapper_i40e_get_eee(emg_18_container,emg_18_emg_param_1_9);
    #line 1697 
    ldv_free((void *)emg_18_emg_param_1_9);
    #line 1699 
    break;
    #line 1701 
    case 74: 
             #line 1701 
    ;
    #line 1703 
    emg_18_emg_param_1_8 = (struct ethtool_drvinfo *)ldv_xmalloc_unknown_size(0UL);
    #line 1703 
    emg_18_emg_param_1_8 = emg_18_emg_param_1_8;
    #line 1707 
    emg_wrapper_i40e_get_drvinfo(emg_18_container,emg_18_emg_param_1_8);
    #line 1711 
    ldv_free((void *)emg_18_emg_param_1_8);
    #line 1713 
    break;
    #line 1715 
    case 75: 
             #line 1715 
    ;
    #line 1717 
    emg_18_emg_param_1_7 = (struct ethtool_coalesce *)ldv_xmalloc_unknown_size(0UL);
    #line 1717 
    emg_18_emg_param_1_7 = emg_18_emg_param_1_7;
    #line 1721 
    emg_wrapper_i40e_get_coalesce(emg_18_container,emg_18_emg_param_1_7);
    #line 1725 
    ldv_free((void *)emg_18_emg_param_1_7);
    #line 1727 
    break;
    #line 1729 
    case 76: 
             #line 1729 
    ;
    #line 1731 
    emg_18_emg_param_1_6 = (struct ethtool_channels *)ldv_xmalloc_unknown_size(0UL);
    #line 1731 
    emg_18_emg_param_1_6 = emg_18_emg_param_1_6;
    #line 1735 
    emg_wrapper_i40e_get_channels(emg_18_container,emg_18_emg_param_1_6);
    #line 1739 
    ldv_free((void *)emg_18_emg_param_1_6);
    #line 1741 
    break;
    #line 1743 
    case 77: 
             #line 1743 
    ;
    #line 1745 
    emg_18_emg_param_1_5 = (struct ethtool_drvinfo *)ldv_xmalloc_unknown_size(0UL);
    #line 1745 
    emg_18_emg_param_1_5 = emg_18_emg_param_1_5;
    #line 1749 
    emg_wrapper_i40e_get_drvinfo(emg_18_container,emg_18_emg_param_1_5);
    #line 1753 
    ldv_free((void *)emg_18_emg_param_1_5);
    #line 1755 
    break;
    #line 1757 
    case 78: 
             #line 1757 
    ;
    #line 1759 
    emg_wrapper_i40e_get_eeprom_len(emg_18_container);
    #line 1761 
    break;
    #line 1763 
    case 79: 
             #line 1763 
    ;
    #line 1765 
    emg_18_emg_param_1_3 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
    #line 1765 
    emg_18_emg_param_1_3 = emg_18_emg_param_1_3;
    #line 1766 
    emg_18_emg_param_2_4 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1766 
    emg_18_emg_param_2_4 = emg_18_emg_param_2_4;
    #line 1770 
    emg_wrapper_i40e_get_eeprom(emg_18_container,emg_18_emg_param_1_3,emg_18_emg_param_2_4);
    #line 1774 
    ldv_free((void *)emg_18_emg_param_1_3);
    #line 1775 
    ldv_free((void *)emg_18_emg_param_2_4);
    #line 1777 
    break;
    #line 1779 
    case 80: 
             #line 1779 
    ;
    #line 1781 
    emg_18_emg_param_1_1 = (struct ethtool_eeprom *)ldv_xmalloc_unknown_size(0UL);
    #line 1781 
    emg_18_emg_param_1_1 = emg_18_emg_param_1_1;
    #line 1782 
    emg_18_emg_param_2_2 = (unsigned char *)ldv_xmalloc_unknown_size(0UL);
    #line 1782 
    emg_18_emg_param_2_2 = emg_18_emg_param_2_2;
    #line 1786 
    emg_wrapper_i40e_set_eeprom(emg_18_container,emg_18_emg_param_1_1,emg_18_emg_param_2_2);
    #line 1790 
    ldv_free((void *)emg_18_emg_param_1_1);
    #line 1791 
    ldv_free((void *)emg_18_emg_param_2_2);
    #line 1793 
    break;
    #line 1795 
    case 81: 
             #line 1795 
    ;
    #line 1797 
    emg_18_emg_param_1_0 = (struct ethtool_flash *)ldv_xmalloc_unknown_size(0UL);
    #line 1797 
    emg_18_emg_param_1_0 = emg_18_emg_param_1_0;
    #line 1801 
    i40e_ddp_flash(emg_18_container,emg_18_emg_param_1_0);
    #line 1805 
    ldv_free((void *)emg_18_emg_param_1_0);
    #line 1808 
    if (emg_repeat_cnt_call_18 > 0) {
      #line 1809 
      emg_repeat_cnt_call_18 --;
      #line 1811 
      goto emg_call_18;
    }
    else 
         #line 1813 
         __VERIFIER_assume(0);
    #line 1817 
    break;
    #line 1819 
    case 82: 
             #line 1819 
    ;
    #line 1823 
    break;
    #line 1825 
    default: 
             #line 1825 
    ;
    #line 1825 
    __VERIFIER_assume(0);
  }
  #line 1828 
  return (void *)0;
}

#line 1833  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void *emg_pci_pci_scenario_i40e_driver(void *arg0)
{
  #line 1836 
  int emg_19_choice;
  #line 1837 
  struct pci_driver *emg_19_container;
  #line 1838 
  struct pci_device_id *emg_19_device_id;
  #line 1839 
  int emg_19_emg_param_1_0;
  #line 1840 
  struct pci_dev *emg_19_resource_0;
  #line 1841 
  struct pm_message emg_19_resource_1;
  #line 1842 
  int emg_19_ret;
  #line 1843 
  int emg_repeat_cnt_main_19_0 = 1;
  #line 1844 
  int emg_repeat_cnt_call_19_1 = 1;
  #line 1845 
  int emg_repeat_cnt_call_19_0 = 1;
  #line 1846 
  int emg_repeat_cnt_main_19_1 = 1;
  #line 1848 
  struct emg_struct_pci_scenario_i40e_driver_19 *data = (struct emg_struct_pci_scenario_i40e_driver_19 *)arg0;
  #line 1852 
  emg_19_choice = 0;
  #line 1853 
  emg_19_ret = ldv_undef_int();
  #line 1854 
  emg_19_choice = 0;
  #line 1855 
  emg_19_container = emg_alias_i40e_driver;
  #line 1856 
  emg_19_ret = ldv_undef_int();
  #line 1858 
  __VERIFIER_assume(data->arg0 == emg_alias_i40e_driver);
  #line 1860 
  if (data != (struct emg_struct_pci_scenario_i40e_driver_19 *)0) {
    #line 1861 
    emg_19_container = data->arg0;
    #line 1862 
    ldv_free((void *)data);
  }
  #line 1867 
  emg_19_resource_0 = (struct pci_dev *)ldv_xmalloc(3312UL);
  #line 1868 
  emg_19_choice = __ldv_undef_int_range(0,24);
  #line 1869 
  emg_19_device_id = emg_19_container->id_table + (unsigned long)emg_19_choice;
  #line 1873 
  goto emg_main_19;
  #line 1877 
  return (void *)0;
  #line 1880 
  emg_call_19: 
               #line 1880 
  ;
  #line 1881 
  switch (ldv_undef_int()) {
    #line 1882 
    case 0: 
            #line 1882 
    ;
    #line 1884 
    i40e_pci_sriov_configure(emg_19_resource_0,emg_19_emg_param_1_0);
    #line 1887 
    if (emg_repeat_cnt_call_19_0 > 0) {
      #line 1888 
      emg_repeat_cnt_call_19_0 --;
      #line 1890 
      goto emg_call_19;
    }
    else 
         #line 1892 
         __VERIFIER_assume(0);
    #line 1896 
    break;
    #line 1898 
    case 1: 
            #line 1898 
    ;
    #line 1900 
    if (emg_19_container->suspend != (int (*)(struct pci_dev *, pm_message_t ))0) 
      #line 1901 
      emg_19_ret = (*(emg_19_container->suspend))(emg_19_resource_0,emg_19_resource_1); else 
                                                                    #line 1903 
                                                                    emg_19_ret = ldv_undef_int();
    #line 1909 
    emg_19_ret = ldv_filter_err_code(emg_19_ret);
    #line 1913 
    if (emg_19_container->resume != (int (*)(struct pci_dev *))0) 
                                                                  #line 1914 
                                                                  (*(emg_19_container->resume))(emg_19_resource_0);
    #line 1918 
    if (emg_repeat_cnt_call_19_1 > 0) {
      #line 1919 
      emg_repeat_cnt_call_19_1 --;
      #line 1921 
      goto emg_call_19;
    }
    else 
         #line 1923 
         __VERIFIER_assume(0);
    #line 1927 
    break;
    #line 1929 
    case 2: 
            #line 1929 
    ;
    #line 1931 
    emg_wrapper_i40e_shutdown(emg_19_resource_0);
    #line 1935 
    emg_wrapper_i40e_remove(emg_19_resource_0);
    #line 1938 
    if (emg_repeat_cnt_main_19_1 > 0) {
      #line 1939 
      emg_repeat_cnt_main_19_1 --;
      #line 1941 
      goto emg_main_19;
    }
    else 
         #line 1943 
         __VERIFIER_assume(0);
    #line 1947 
    break;
    #line 1949 
    default: 
             #line 1949 
    ;
    #line 1949 
    __VERIFIER_assume(0);
  }
  #line 1952 
  return (void *)0;
  #line 1955 
  emg_main_19: 
               #line 1955 
  ;
  #line 1956 
  if (ldv_undef_int() != 0) {
    #line 1959 
    ldv_pre_probe();
    #line 1963 
    emg_19_ret = emg_wrapper_i40e_probe(emg_19_resource_0,emg_19_device_id);
    #line 1968 
    emg_19_ret = ldv_post_probe(emg_19_ret);
    #line 1971 
    if (ldv_undef_int() != 0) {
      #line 1973 
      __VERIFIER_assume(emg_19_ret == 0);
      #line 1977 
      goto emg_call_19;
    }
    else 
         #line 1982 
         __VERIFIER_assume(emg_19_ret != 0);
    #line 1986 
    if (emg_repeat_cnt_main_19_0 > 0) {
      #line 1987 
      emg_repeat_cnt_main_19_0 --;
      #line 1989 
      goto emg_main_19;
    }
    else 
         #line 1991 
         __VERIFIER_assume(0);
  }
  else 
       #line 1997 
       ldv_free((void *)emg_19_resource_0);
  #line 2005 
  return (void *)0;
}

#line 2010  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void *emg_pm_pm_ops_scenario_i40e_pm_ops(void *arg0)
{
  #line 2013 
  struct device *emg_20_device;
  #line 2014 
  struct dev_pm_ops *emg_20_pm_ops;
  #line 2015 
  int emg_20_ret;
  #line 2016 
  int emg_repeat_cnt_sus_20 = 1;
  #line 2017 
  int emg_repeat_cnt_reslate_20 = 1;
  #line 2018 
  int emg_repeat_cnt_rest_20 = 1;
  #line 2019 
  int emg_repeat_cnt_th_20 = 1;
  #line 2020 
  int emg_repeat_cnt_resnoirq_20 = 1;
  #line 2021 
  int emg_repeat_cnt_fnoirq_20 = 1;
  #line 2022 
  int emg_repeat_cnt_plate_20 = 1;
  #line 2023 
  int emg_repeat_cnt_reste_20 = 1;
  #line 2024 
  int emg_repeat_cnt_restnoirq_20 = 1;
  #line 2025 
  int emg_repeat_cnt_poff_20 = 1;
  #line 2026 
  int emg_repeat_cnt_run_resume_20 = 1;
  #line 2027 
  int emg_repeat_cnt_no_irq_20 = 1;
  #line 2028 
  int emg_repeat_cnt_thlate_20 = 1;
  #line 2029 
  int emg_repeat_cnt_slate_20 = 1;
  #line 2030 
  int emg_repeat_cnt_pno_irq_20 = 1;
  #line 2031 
  int emg_repeat_cnt_flate_20 = 1;
  #line 2032 
  int emg_repeat_cnt_fr_20 = 1;
  #line 2033 
  int emg_repeat_cnt_tnoirq_20 = 1;
  #line 2034 
  int emg_repeat_cnt_res_20 = 1;
  #line 2037 
  emg_20_ret = ldv_undef_int();
  #line 2038 
  emg_20_pm_ops = emg_alias_i40e_pm_ops;
  #line 2039 
  emg_20_ret = ldv_undef_int();
  #line 2045 
  goto emg_do_20;
  #line 2049 
  return (void *)0;
  #line 2052 
  emg_compl_20: 
                #line 2052 
  ;
  #line 2054 
  if (emg_20_pm_ops->complete != (void (*)(struct device *))0) 
                                                               #line 2055 
                                                               (*(emg_20_pm_ops->complete))(emg_20_device);
  #line 2063 
  return (void *)0;
  #line 2066 
  emg_do_20: 
             #line 2066 
  ;
  #line 2067 
  switch (ldv_undef_int()) {
    #line 2068 
    case 0: 
            #line 2068 
    ;
    #line 2070 
    __VERIFIER_assume((emg_runtime_enabled == 1 && emg_runtime_lowpower == 1) != 0);
    #line 2074 
    goto emg_runt_20;
    #line 2079 
    case 1: 
            #line 2079 
    ;
    #line 2081 
    goto emg_normal_20;
    #line 2086 
    case 2: 
            #line 2086 
    ;
    #line 2090 
    break;
    #line 2092 
    default: 
             #line 2092 
    ;
    #line 2092 
    __VERIFIER_assume(0);
  }
  #line 2095 
  return (void *)0;
  #line 2098 
  emg_flate_20: 
                #line 2098 
  ;
  #line 2100 
  if (emg_20_pm_ops->freeze_late != (int (*)(struct device *))0) 
                                                                 #line 2101 
                                                                 emg_20_ret = (*(emg_20_pm_ops->freeze_late))(emg_20_device); else 
                                                                    #line 2103 
                                                                    emg_20_ret = ldv_undef_int();
  #line 2109 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2112 
  if (ldv_undef_int() != 0) {
    #line 2114 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2118 
    goto emg_thlate_20;
  }
  else 
       #line 2123 
       __VERIFIER_assume(emg_20_ret != 0);
  #line 2127 
  if (emg_repeat_cnt_flate_20 > 0) {
    #line 2128 
    emg_repeat_cnt_flate_20 --;
    #line 2130 
    goto emg_flate_20;
  }
  else 
       #line 2132 
       __VERIFIER_assume(0);
  #line 2137 
  return (void *)0;
  #line 2140 
  emg_fnoirq_20: 
                 #line 2140 
  ;
  #line 2142 
  if (emg_20_pm_ops->freeze_noirq != (int (*)(struct device *))0) 
                                                                  #line 2143 
                                                                  emg_20_ret = (*(emg_20_pm_ops->freeze_noirq))(emg_20_device); else 
                                                                    #line 2145 
                                                                    emg_20_ret = ldv_undef_int();
  #line 2151 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2154 
  if (ldv_undef_int() != 0) {
    #line 2156 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2160 
    goto emg_tnoirq_20;
  }
  else 
       #line 2165 
       __VERIFIER_assume(emg_20_ret != 0);
  #line 2169 
  if (emg_repeat_cnt_fnoirq_20 > 0) {
    #line 2170 
    emg_repeat_cnt_fnoirq_20 --;
    #line 2172 
    goto emg_fnoirq_20;
  }
  else 
       #line 2174 
       __VERIFIER_assume(0);
  #line 2179 
  return (void *)0;
  #line 2182 
  emg_fr_20: 
             #line 2182 
  ;
  #line 2184 
  emg_20_ret = emg_wrapper_i40e_suspend(emg_20_device);
  #line 2189 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2192 
  if (ldv_undef_int() != 0) {
    #line 2194 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2197 
    if (ldv_undef_int() != 0) 
                              #line 2199 
                              goto emg_fnoirq_20; else 
                                                       #line 2204 
                                                       goto emg_flate_20;
  }
  else {
    #line 2210 
    __VERIFIER_assume(emg_20_ret != 0);
    #line 2213 
    if (emg_repeat_cnt_fr_20 > 0) {
      #line 2214 
      emg_repeat_cnt_fr_20 --;
      #line 2216 
      goto emg_fr_20;
    }
    else 
         #line 2218 
         __VERIFIER_assume(0);
  }
  #line 2224 
  return (void *)0;
  #line 2227 
  emg_no_irq_20: 
                 #line 2227 
  ;
  #line 2229 
  if (emg_20_pm_ops->suspend_noirq != (int (*)(struct device *))0) 
                                                                   #line 2230 
                                                                   emg_20_ret = (*(emg_20_pm_ops->suspend_noirq))(emg_20_device); else 
                                                                    #line 2232 
                                                                    emg_20_ret = ldv_undef_int();
  #line 2238 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2241 
  if (ldv_undef_int() != 0) {
    #line 2243 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2247 
    goto emg_resnoirq_20;
  }
  else 
       #line 2252 
       __VERIFIER_assume(emg_20_ret != 0);
  #line 2256 
  if (emg_repeat_cnt_no_irq_20 > 0) {
    #line 2257 
    emg_repeat_cnt_no_irq_20 --;
    #line 2259 
    goto emg_no_irq_20;
  }
  else 
       #line 2261 
       __VERIFIER_assume(0);
  #line 2266 
  return (void *)0;
  #line 2269 
  emg_normal_20: 
                 #line 2269 
  ;
  #line 2271 
  if (emg_20_pm_ops->prepare != (int (*)(struct device *))0) 
                                                             #line 2272 
                                                             emg_20_ret = (*(emg_20_pm_ops->prepare))(emg_20_device); else 
                                                                    #line 2274 
                                                                    emg_20_ret = ldv_undef_int();
  #line 2280 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2283 
  if (ldv_undef_int() != 0) {
    #line 2285 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2288 
    switch (ldv_undef_int()) {
      #line 2289 
      case 0: 
              #line 2289 
      ;
      #line 2291 
      goto emg_sus_20;
      #line 2296 
      case 1: 
              #line 2296 
      ;
      #line 2298 
      goto emg_fr_20;
      #line 2303 
      case 2: 
              #line 2303 
      ;
      #line 2305 
      goto emg_poff_20;
      #line 2310 
      default: 
               #line 2310 
      ;
      #line 2310 
      __VERIFIER_assume(0);
    }
  }
  else 
       #line 2314 
       __VERIFIER_assume(emg_20_ret != 0);
  #line 2322 
  return (void *)0;
  #line 2325 
  emg_plate_20: 
                #line 2325 
  ;
  #line 2327 
  if (emg_20_pm_ops->poweroff_late != (int (*)(struct device *))0) 
                                                                   #line 2328 
                                                                   emg_20_ret = (*(emg_20_pm_ops->poweroff_late))(emg_20_device); else 
                                                                    #line 2330 
                                                                    emg_20_ret = ldv_undef_int();
  #line 2336 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2339 
  if (ldv_undef_int() != 0) {
    #line 2341 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2345 
    goto emg_reste_20;
  }
  else 
       #line 2350 
       __VERIFIER_assume(emg_20_ret != 0);
  #line 2354 
  if (emg_repeat_cnt_plate_20 > 0) {
    #line 2355 
    emg_repeat_cnt_plate_20 --;
    #line 2357 
    goto emg_plate_20;
  }
  else 
       #line 2359 
       __VERIFIER_assume(0);
  #line 2364 
  return (void *)0;
  #line 2367 
  emg_pno_irq_20: 
                  #line 2367 
  ;
  #line 2369 
  if (emg_20_pm_ops->poweroff_noirq != (int (*)(struct device *))0) 
                                                                    #line 2370 
                                                                    emg_20_ret = (*(emg_20_pm_ops->poweroff_noirq))(emg_20_device); else 
                                                                    #line 2372 
                                                                    emg_20_ret = ldv_undef_int();
  #line 2378 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2381 
  if (ldv_undef_int() != 0) {
    #line 2383 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2387 
    goto emg_restnoirq_20;
  }
  else 
       #line 2392 
       __VERIFIER_assume(emg_20_ret != 0);
  #line 2396 
  if (emg_repeat_cnt_pno_irq_20 > 0) {
    #line 2397 
    emg_repeat_cnt_pno_irq_20 --;
    #line 2399 
    goto emg_pno_irq_20;
  }
  else 
       #line 2401 
       __VERIFIER_assume(0);
  #line 2406 
  return (void *)0;
  #line 2409 
  emg_poff_20: 
               #line 2409 
  ;
  #line 2411 
  emg_20_ret = emg_wrapper_i40e_suspend(emg_20_device);
  #line 2416 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2419 
  if (ldv_undef_int() != 0) {
    #line 2421 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2424 
    if (ldv_undef_int() != 0) 
                              #line 2426 
                              goto emg_pno_irq_20; else 
                                                        #line 2431 
                                                        goto emg_plate_20;
  }
  else {
    #line 2437 
    __VERIFIER_assume(emg_20_ret != 0);
    #line 2440 
    if (emg_repeat_cnt_poff_20 > 0) {
      #line 2441 
      emg_repeat_cnt_poff_20 --;
      #line 2443 
      goto emg_poff_20;
    }
    else 
         #line 2445 
         __VERIFIER_assume(0);
  }
  #line 2451 
  return (void *)0;
  #line 2454 
  emg_res_20: 
              #line 2454 
  ;
  #line 2456 
  emg_20_ret = emg_wrapper_i40e_resume(emg_20_device);
  #line 2461 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2464 
  if (ldv_undef_int() != 0) {
    #line 2466 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2470 
    goto emg_compl_20;
  }
  else {
    #line 2475 
    __VERIFIER_assume(emg_20_ret != 0);
    #line 2478 
    if (emg_repeat_cnt_res_20 > 0) {
      #line 2479 
      emg_repeat_cnt_res_20 --;
      #line 2481 
      goto emg_res_20;
    }
    else 
         #line 2483 
         __VERIFIER_assume(0);
  }
  #line 2489 
  return (void *)0;
  #line 2492 
  emg_reslate_20: 
                  #line 2492 
  ;
  #line 2494 
  if (emg_20_pm_ops->resume_early != (int (*)(struct device *))0) 
                                                                  #line 2495 
                                                                  emg_20_ret = (*(emg_20_pm_ops->resume_early))(emg_20_device); else 
                                                                    #line 2497 
                                                                    emg_20_ret = ldv_undef_int();
  #line 2503 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2506 
  if (ldv_undef_int() != 0) {
    #line 2508 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2512 
    goto emg_res_20;
  }
  else 
       #line 2517 
       __VERIFIER_assume(emg_20_ret != 0);
  #line 2521 
  if (emg_repeat_cnt_reslate_20 > 0) {
    #line 2522 
    emg_repeat_cnt_reslate_20 --;
    #line 2524 
    goto emg_reslate_20;
  }
  else 
       #line 2526 
       __VERIFIER_assume(0);
  #line 2531 
  return (void *)0;
  #line 2534 
  emg_resnoirq_20: 
                   #line 2534 
  ;
  #line 2536 
  if (emg_20_pm_ops->resume_noirq != (int (*)(struct device *))0) 
                                                                  #line 2537 
                                                                  emg_20_ret = (*(emg_20_pm_ops->resume_noirq))(emg_20_device); else 
                                                                    #line 2539 
                                                                    emg_20_ret = ldv_undef_int();
  #line 2545 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2548 
  if (ldv_undef_int() != 0) {
    #line 2550 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2554 
    goto emg_res_20;
  }
  else 
       #line 2559 
       __VERIFIER_assume(emg_20_ret != 0);
  #line 2563 
  if (emg_repeat_cnt_resnoirq_20 > 0) {
    #line 2564 
    emg_repeat_cnt_resnoirq_20 --;
    #line 2566 
    goto emg_resnoirq_20;
  }
  else 
       #line 2568 
       __VERIFIER_assume(0);
  #line 2573 
  return (void *)0;
  #line 2576 
  emg_rest_20: 
               #line 2576 
  ;
  #line 2578 
  emg_20_ret = emg_wrapper_i40e_resume(emg_20_device);
  #line 2583 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2586 
  if (ldv_undef_int() != 0) {
    #line 2588 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2592 
    goto emg_compl_20;
  }
  else {
    #line 2597 
    __VERIFIER_assume(emg_20_ret != 0);
    #line 2600 
    if (emg_repeat_cnt_rest_20 > 0) {
      #line 2601 
      emg_repeat_cnt_rest_20 --;
      #line 2603 
      goto emg_rest_20;
    }
    else 
         #line 2605 
         __VERIFIER_assume(0);
  }
  #line 2611 
  return (void *)0;
  #line 2614 
  emg_reste_20: 
                #line 2614 
  ;
  #line 2616 
  if (emg_20_pm_ops->restore_early != (int (*)(struct device *))0) 
                                                                   #line 2617 
                                                                   emg_20_ret = (*(emg_20_pm_ops->restore_early))(emg_20_device); else 
                                                                    #line 2619 
                                                                    emg_20_ret = ldv_undef_int();
  #line 2625 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2628 
  if (ldv_undef_int() != 0) {
    #line 2630 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2634 
    goto emg_rest_20;
  }
  else 
       #line 2639 
       __VERIFIER_assume(emg_20_ret != 0);
  #line 2643 
  if (emg_repeat_cnt_reste_20 > 0) {
    #line 2644 
    emg_repeat_cnt_reste_20 --;
    #line 2646 
    goto emg_reste_20;
  }
  else 
       #line 2648 
       __VERIFIER_assume(0);
  #line 2653 
  return (void *)0;
  #line 2656 
  emg_restnoirq_20: 
                    #line 2656 
  ;
  #line 2658 
  if (emg_20_pm_ops->restore_noirq != (int (*)(struct device *))0) 
                                                                   #line 2659 
                                                                   emg_20_ret = (*(emg_20_pm_ops->restore_noirq))(emg_20_device); else 
                                                                    #line 2661 
                                                                    emg_20_ret = ldv_undef_int();
  #line 2667 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2670 
  if (ldv_undef_int() != 0) {
    #line 2672 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2676 
    goto emg_rest_20;
  }
  else 
       #line 2681 
       __VERIFIER_assume(emg_20_ret != 0);
  #line 2685 
  if (emg_repeat_cnt_restnoirq_20 > 0) {
    #line 2686 
    emg_repeat_cnt_restnoirq_20 --;
    #line 2688 
    goto emg_restnoirq_20;
  }
  else 
       #line 2690 
       __VERIFIER_assume(0);
  #line 2695 
  return (void *)0;
  #line 2698 
  emg_run_resume_20: 
                     #line 2698 
  ;
  #line 2700 
  if (emg_20_pm_ops->runtime_resume != (int (*)(struct device *))0) 
                                                                    #line 2701 
                                                                    emg_20_ret = (*(emg_20_pm_ops->runtime_resume))(emg_20_device); else 
                                                                    #line 2703 
                                                                    emg_20_ret = ldv_undef_int();
  #line 2709 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2710 
  if (emg_20_ret != 0) 
                       #line 2711 
                       emg_runtime_lowpower = 0;
  #line 2714 
  if (ldv_undef_int() != 0) 
                            #line 2716 
                            __VERIFIER_assume(emg_20_ret == 0);
  else {
    #line 2720 
    __VERIFIER_assume(emg_20_ret != 0);
    #line 2723 
    if (emg_repeat_cnt_run_resume_20 > 0) {
      #line 2724 
      emg_repeat_cnt_run_resume_20 --;
      #line 2726 
      goto emg_run_resume_20;
    }
    else 
         #line 2728 
         __VERIFIER_assume(0);
  }
  #line 2738 
  return (void *)0;
  #line 2741 
  emg_runt_20: 
               #line 2741 
  ;
  #line 2742 
  if (ldv_undef_int() != 0) {
    #line 2744 
    if (emg_20_pm_ops->runtime_idle != (int (*)(struct device *))0) 
                                                                    #line 2745 
                                                                    emg_20_ret = (*(emg_20_pm_ops->runtime_idle))(emg_20_device); else 
                                                                    #line 2747 
                                                                    emg_20_ret = ldv_undef_int();
    #line 2753 
    emg_20_ret = ldv_post_probe(emg_20_ret);
  }
  else {
    #line 2757 
    if (emg_20_pm_ops->runtime_suspend != (int (*)(struct device *))0) 
      #line 2758 
      emg_20_ret = (*(emg_20_pm_ops->runtime_suspend))(emg_20_device); else 
                                                                    #line 2760 
                                                                    emg_20_ret = ldv_undef_int();
    #line 2766 
    emg_20_ret = ldv_post_probe(emg_20_ret);
    #line 2767 
    if (emg_20_ret != 0) 
                         #line 2768 
                         emg_runtime_lowpower = 1;
    #line 2771 
    if (ldv_undef_int() != 0) {
      #line 2773 
      __VERIFIER_assume(emg_20_ret == 0);
      #line 2777 
      goto emg_run_resume_20;
    }
    else 
         #line 2782 
         __VERIFIER_assume(emg_20_ret != 0);
  }
  #line 2791 
  return (void *)0;
  #line 2794 
  emg_slate_20: 
                #line 2794 
  ;
  #line 2796 
  if (emg_20_pm_ops->suspend_late != (int (*)(struct device *))0) 
                                                                  #line 2797 
                                                                  emg_20_ret = (*(emg_20_pm_ops->suspend_late))(emg_20_device); else 
                                                                    #line 2799 
                                                                    emg_20_ret = ldv_undef_int();
  #line 2805 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2808 
  if (ldv_undef_int() != 0) {
    #line 2810 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2814 
    goto emg_reslate_20;
  }
  else 
       #line 2819 
       __VERIFIER_assume(emg_20_ret != 0);
  #line 2823 
  if (emg_repeat_cnt_slate_20 > 0) {
    #line 2824 
    emg_repeat_cnt_slate_20 --;
    #line 2826 
    goto emg_slate_20;
  }
  else 
       #line 2828 
       __VERIFIER_assume(0);
  #line 2833 
  return (void *)0;
  #line 2836 
  emg_sus_20: 
              #line 2836 
  ;
  #line 2838 
  emg_20_ret = emg_wrapper_i40e_suspend(emg_20_device);
  #line 2843 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2846 
  if (ldv_undef_int() != 0) {
    #line 2848 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2851 
    if (ldv_undef_int() != 0) 
                              #line 2853 
                              goto emg_no_irq_20; else 
                                                       #line 2858 
                                                       goto emg_slate_20;
  }
  else {
    #line 2864 
    __VERIFIER_assume(emg_20_ret != 0);
    #line 2867 
    if (emg_repeat_cnt_sus_20 > 0) {
      #line 2868 
      emg_repeat_cnt_sus_20 --;
      #line 2870 
      goto emg_sus_20;
    }
    else 
         #line 2872 
         __VERIFIER_assume(0);
  }
  #line 2878 
  return (void *)0;
  #line 2881 
  emg_th_20: 
             #line 2881 
  ;
  #line 2883 
  emg_20_ret = emg_wrapper_i40e_resume(emg_20_device);
  #line 2888 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2891 
  if (ldv_undef_int() != 0) {
    #line 2893 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2897 
    goto emg_compl_20;
  }
  else {
    #line 2902 
    __VERIFIER_assume(emg_20_ret != 0);
    #line 2905 
    if (emg_repeat_cnt_th_20 > 0) {
      #line 2906 
      emg_repeat_cnt_th_20 --;
      #line 2908 
      goto emg_th_20;
    }
    else 
         #line 2910 
         __VERIFIER_assume(0);
  }
  #line 2916 
  return (void *)0;
  #line 2919 
  emg_thlate_20: 
                 #line 2919 
  ;
  #line 2921 
  if (emg_20_pm_ops->thaw_early != (int (*)(struct device *))0) 
                                                                #line 2922 
                                                                emg_20_ret = (*(emg_20_pm_ops->thaw_early))(emg_20_device); else 
                                                                    #line 2924 
                                                                    emg_20_ret = ldv_undef_int();
  #line 2930 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2933 
  if (ldv_undef_int() != 0) {
    #line 2935 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2939 
    goto emg_th_20;
  }
  else 
       #line 2944 
       __VERIFIER_assume(emg_20_ret != 0);
  #line 2948 
  if (emg_repeat_cnt_thlate_20 > 0) {
    #line 2949 
    emg_repeat_cnt_thlate_20 --;
    #line 2951 
    goto emg_thlate_20;
  }
  else 
       #line 2953 
       __VERIFIER_assume(0);
  #line 2958 
  return (void *)0;
  #line 2961 
  emg_tnoirq_20: 
                 #line 2961 
  ;
  #line 2963 
  if (emg_20_pm_ops->thaw_noirq != (int (*)(struct device *))0) 
                                                                #line 2964 
                                                                emg_20_ret = (*(emg_20_pm_ops->thaw_noirq))(emg_20_device); else 
                                                                    #line 2966 
                                                                    emg_20_ret = ldv_undef_int();
  #line 2972 
  emg_20_ret = ldv_post_probe(emg_20_ret);
  #line 2975 
  if (ldv_undef_int() != 0) {
    #line 2977 
    __VERIFIER_assume(emg_20_ret == 0);
    #line 2981 
    goto emg_th_20;
  }
  else 
       #line 2986 
       __VERIFIER_assume(emg_20_ret != 0);
  #line 2990 
  if (emg_repeat_cnt_tnoirq_20 > 0) {
    #line 2991 
    emg_repeat_cnt_tnoirq_20 --;
    #line 2993 
    goto emg_tnoirq_20;
  }
  else 
       #line 2995 
       __VERIFIER_assume(0);
  #line 3000 
  return (void *)0;
}

#line 3005  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void *emg_timer_timer_scenario_6(void *arg0)
{
  #line 3008 
  struct timer_list *emg_21_container;
  #line 3009 
  unsigned long emg_21_emg_param_0_0;
  #line 3011 
  struct emg_struct_timer_scenario_6_21 *data = (struct emg_struct_timer_scenario_6_21 *)arg0;
  #line 3016 
  if (data != (struct emg_struct_timer_scenario_6_21 *)0) {
    #line 3017 
    emg_21_container = data->arg0;
    #line 3018 
    ldv_free((void *)data);
  }
  #line 3024 
  ldv_switch_to_interrupt_context();
  #line 3028 
  if (emg_21_container->function != (void (*)(struct timer_list *))0) 
    #line 3029 
    (*(emg_21_container->function))((struct timer_list *)emg_21_emg_param_0_0);
  #line 3035 
  ldv_switch_to_process_context();
  #line 3042 
  return (void *)0;
}

#line 3047  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
int emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2)
{
  #line 3050 
  struct pci_driver *emg_2_pci_driver;
  #line 3052 
  emg_2_pci_driver = emg_alias_i40e_driver;
  #line 3053 
  if (ldv_undef_int() != 0) {
    #line 3055 
    emg_2_pci_driver = arg0;
    #line 3059 
    emg_dispatch_register_2(emg_2_pci_driver);
    #line 3063 
    return 0;
  }
  else {
    #line 3067 
    return ldv_undef_int_negative();
  }
}

#line 3075  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
struct net_device *emg_alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2)
{
  #line 3078 
  struct net_device *emg_3_netdev;
  #line 3080 
  if (ldv_undef_int() != 0) {
    #line 3082 
    emg_3_netdev = (struct net_device *)ldv_xmalloc(3328UL);
    #line 3086 
    return emg_3_netdev;
  }
  else 
       #line 3090 
       return (struct net_device *)0;
}

#line 3098  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
struct dentry *emg_debugfs_create_dir(char *arg0, struct dentry *arg1)
{
  #line 3101 
  struct dentry *emg_4_dentry;
  #line 3102 
  struct inode *emg_4_inode;
  #line 3104 
  if (ldv_undef_int() != 0) {
    #line 3106 
    emg_4_dentry = (struct dentry *)ldv_xmalloc(320UL);
    #line 3107 
    emg_4_inode = (struct inode *)ldv_xmalloc(1072UL);
    #line 3108 
    emg_4_inode->i_mode = (unsigned short)16877U;
    #line 3109 
    emg_4_dentry->d_parent = arg1;
    #line 3110 
    emg_4_dentry->d_inode = emg_4_inode;
    #line 3111 
    return emg_4_dentry;
  }
  else {
    #line 3115 
    return (struct dentry *)ERR_PTR_2(-19L);
  }
}

#line 3123  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
struct dentry *emg_debugfs_create_file(char *arg0, unsigned short arg1, struct dentry *arg2, void *arg3, struct file_operations *arg4)
{
  #line 3126 
  struct dentry *emg_5_dentry;
  #line 3127 
  struct file_operations *emg_5_file_operations;
  #line 3128 
  struct inode *emg_5_inode;
  #line 3130 
  if (ldv_undef_int() != 0) {
    #line 3132 
    emg_5_dentry = (struct dentry *)ldv_xmalloc(320UL);
    #line 3133 
    emg_5_inode = (struct inode *)ldv_xmalloc(1072UL);
    #line 3134 
    emg_5_inode->i_mode = arg1;
    #line 3135 
    emg_5_dentry->d_parent = arg2;
    #line 3136 
    emg_5_inode->i_private = arg3;
    #line 3137 
    emg_5_file_operations = arg4;
    #line 3138 
    emg_5_dentry->d_inode = emg_5_inode;
    #line 3139 
    ldv_save_allocated_memory_to_list((void *)emg_5_dentry);
    #line 3143 
    emg_dispatch_register_5(emg_5_file_operations);
    #line 3147 
    return emg_5_dentry;
  }
  else {
    #line 3151 
    return (struct dentry *)ERR_PTR_2(-19L);
  }
}

#line 3159  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
int emg_del_timer_sync(struct timer_list *arg0)
{
  #line 3162 
  struct timer_list *emg_6_timer_list;
  #line 3165 
  emg_6_timer_list = arg0;
  #line 3169 
  emg_dispatch_instance_deregister_6(emg_6_timer_list);
  #line 3170 
  ;
  #line 3170 
  return 0;
}

#line 3176  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void *emg_free_irq(unsigned int arg0, void *arg1)
{
  #line 3179 
  int emg_7_line;
  #line 3182 
  emg_7_line = (int)arg0;
  #line 3186 
  emg_dispatch_irq_deregister_7(emg_7_line);
  #line 3187 
  ;
  #line 3187 
  return (void *)0;
}

#line 3193  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void emg_free_netdev(struct net_device *arg0)
{
  #line 3196 
  struct net_device *emg_8_netdev;
  #line 3199 
  emg_8_netdev = arg0;
  #line 3200 
  ldv_free((void *)emg_8_netdev);
  #line 3203 
  return;
}

#line 3208  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
int emg_mod_timer(struct timer_list *arg0, unsigned long arg1)
{
  #line 3211 
  struct timer_list *emg_9_timer_list;
  #line 3213 
  if (ldv_undef_int() != 0) {
    #line 3215 
    emg_9_timer_list = arg0;
    #line 3219 
    emg_dispatch_instance_register_9(emg_9_timer_list);
    #line 3223 
    return 1;
  }
  else 
       #line 3227 
       return 0;
}

#line 3235  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void emg_pci_unregister_driver(struct pci_driver *arg0)
{
  #line 3238 
  struct pci_driver *emg_10_pci_driver;
  #line 3240 
  emg_10_pci_driver = emg_alias_i40e_driver;
  #line 3242 
  emg_10_pci_driver = arg0;
  #line 3246 
  emg_dispatch_deregister_10(emg_10_pci_driver);
  #line 3249 
  return;
}

#line 3254  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
_Bool emg_queue_work(struct workqueue_struct *arg0, struct work_struct *arg1)
{
  #line 3257 
  struct work_struct *emg_11_work_struct;
  #line 3259 
  if (ldv_undef_int() != 0) {
    #line 3261 
    emg_11_work_struct = arg1;
    #line 3265 
    if (emg_11_work_struct->func != (void (*)(struct work_struct *))0) 
      #line 3266 
      (*(emg_11_work_struct->func))(emg_11_work_struct);
    #line 3271 
    return (_Bool)1;
  }
  else 
       #line 3275 
       return (_Bool)0;
}

#line 3283  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
int emg_register_netdev(struct net_device *arg0)
{
  #line 3286 
  struct net_device *emg_12_netdev;
  #line 3287 
  int emg_12_ret;
  #line 3290 
  emg_12_ret = ldv_undef_int();
  #line 3291 
  emg_12_ret = ldv_undef_int();
  #line 3292 
  if (ldv_undef_int() != 0) {
    #line 3294 
    emg_12_netdev = arg0;
    #line 3298 
    emg_12_ret = emg_wrapper_i40e_open(emg_12_netdev);
    #line 3301 
    if (ldv_undef_int() != 0) {
      #line 3303 
      __VERIFIER_assume(emg_12_ret == 0);
      #line 3307 
      emg_dispatch_register_12(emg_12_netdev);
      #line 3311 
      return 0;
    }
    else {
      #line 3315 
      __VERIFIER_assume(emg_12_ret != 0);
      #line 3316 
      ldv_failed_register_netdev();
      #line 3317 
      return ldv_undef_int_negative();
    }
  }
  else {
    #line 3322 
    ldv_failed_register_netdev();
    #line 3323 
    return ldv_undef_int_negative();
  }
}

#line 3331  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
int emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4)
{
  #line 3334 
  enum irqreturn (*emg_13_callback)(int , void *);
  #line 3335 
  void *emg_13_data;
  #line 3336 
  int emg_13_line;
  #line 3337 
  enum irqreturn (*emg_13_thread)(int , void *);
  #line 3339 
  emg_13_callback = & emg_wrapper_i40e_intr;
  #line 3340 
  if (ldv_undef_int() != 0) {
    #line 3342 
    emg_13_line = (int)arg0;
    #line 3343 
    emg_13_callback = arg1;
    #line 3344 
    emg_13_thread = (enum irqreturn (*)(int , void *))0;
    #line 3345 
    emg_13_data = arg4;
    #line 3349 
    emg_dispatch_irq_register_13(emg_13_line,emg_13_callback,emg_13_thread,emg_13_data);
    #line 3353 
    return 0;
  }
  else {
    #line 3357 
    return ldv_undef_int_negative();
  }
}

#line 3365  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void emg_unregister_netdev(struct net_device *arg0)
{
  #line 3368 
  struct net_device *emg_14_netdev;
  #line 3371 
  emg_14_netdev = arg0;
  #line 3375 
  emg_wrapper_i40e_close(emg_14_netdev);
  #line 3379 
  emg_dispatch_deregister_14(emg_14_netdev);
  #line 3382 
  return;
}

#line 3387  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
void *emg_entry_point_insmod(void *arg0)
{
  #line 3390 
  int emg_1_ret;
  #line 3393 
  emg_1_ret = emg_i40e_init_module();
  #line 3394 
  emg_1_ret = ldv_post_init(emg_1_ret);
  #line 3397 
  if (ldv_undef_int() != 0) {
    #line 3399 
    __VERIFIER_assume(emg_1_ret == 0);
    #line 3403 
    emg_i40e_exit_module();
  }
  else 
       #line 3407 
       __VERIFIER_assume(emg_1_ret != 0);
  #line 3411 
  return (void *)0;
}

#line 3416  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/ethernet/intel/i40e/i40e.ko/concurrency safety/emg/0/environment_model.c"
int main(void)
{
  #line 3418 
  ldv_initialize();
  #line 3420 
  emg_entry_point_insmod((void *)0);
  #line 3422 
  return 0;
}

