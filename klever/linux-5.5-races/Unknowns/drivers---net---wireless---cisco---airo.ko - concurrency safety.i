/* Generated by Frama-C */
#line 106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compiler_types.h"
typedef signed char __s8;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/int-ll64.h"
typedef __s8 s8;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __u8 u8;
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __s16 s16;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __u16 u16;
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __s32 s32;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __u32 u32;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __s64 s64;
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/int-ll64.h"
typedef __u64 u64;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/uapi/asm/posix_types_64.h"
typedef long __kernel_long_t;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 51  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_time64_t;
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 93  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 94  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/posix_types.h"
typedef __u16 __le16;
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u16 __be16;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u32 __le32;
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u32 __be32;
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef unsigned int __poll_t;
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/types.h"
typedef u32 __kernel_dev_t;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned short umode_t;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef _Bool bool;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 81  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned char u_char;
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef s32 int32_t;
#line 109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u32 uint32_t;
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u64 sector_t;
#line 131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u64 blkcnt_t;
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u64 dma_addr_t;
#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned int gfp_t;
#line 155  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned int fmode_t;
#line 156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef u64 phys_addr_t;
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 170  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 170  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   s64 counter ;
};
#line 174  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 181  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 185 
struct hlist_node;
#line 185  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 219  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head *) ;
} __attribute__((__aligned__(8)));
#line 14  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
struct task_struct;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/export.h"
struct module;
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/export.h"
struct kernel_symbol {
   int value_offset ;
   int name_offset ;
   int namespace_offset ;
};
#line 136  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 139 
struct file_system_type;
#line 83  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/printk.h"
struct ctl_table;
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
struct jump_entry;
#line 87 
struct static_key_mod;
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
union __anonunion_8 {
   unsigned long type ;
   struct jump_entry *entries ;
   struct static_key_mod *next ;
};
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
struct static_key {
   atomic_t enabled ;
   union __anonunion_8 __anonCompField_static_key_4 ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
struct jump_entry {
   s32 code ;
   s32 target ;
   long key ;
};
#line 350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jump_label.h"
struct static_key_false {
   struct static_key key ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_debug.h"
struct device;
#line 65 
struct net_device;
#line 476  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/printk.h"
struct file_operations;
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/div64.h"
struct completion;
#line 88 
struct pt_regs;
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_13 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_15 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 268  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
union __anonunion___u_17 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bug.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/math64.h"
typedef __s64 time64_t;
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/time_types.h"
struct __kernel_timespec {
   __kernel_time64_t tv_sec ;
   long long tv_nsec ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/time64.h"
struct timespec64 {
   time64_t tv_sec ;
   long tv_nsec ;
};
#line 165 
struct old_timespec32;
#line 167 
enum timespec_type {
    TT_NONE = 0,
    TT_NATIVE = 1,
    TT_COMPAT = 2
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
struct __anonstruct_futex_27 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
union __anonunion_29 {
   struct __kernel_timespec *rmtp ;
   struct old_timespec32 *compat_rmtp ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
struct __anonstruct_nanosleep_28 {
   clockid_t clockid ;
   enum timespec_type type ;
   union __anonunion_29 __anonCompField___anonstruct_nanosleep_28_5 ;
   u64 expires ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
struct __anonstruct_poll_30 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
union __anonunion_26 {
   struct __anonstruct_futex_27 futex ;
   struct __anonstruct_nanosleep_28 nanosleep ;
   struct __anonstruct_poll_30 poll ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/restart_block.h"
struct restart_block {
   long (*fn)(struct restart_block *) ;
   union __anonunion_26 __anonCompField_restart_block_6 ;
};
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/page_64.h"
struct page;
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/getorder.h"
struct mm_struct;
#line 49 
struct io_bitmap;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/ptrace.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/desc_defs.h"
struct desc_struct {
   u16 limit0 ;
   u16 base0 ;
   u16 base1 : 8 ;
   u16 type : 4 ;
   u16 s : 1 ;
   u16 dpl : 2 ;
   u16 p : 1 ;
   u16 limit1 : 4 ;
   u16 avl : 1 ;
   u16 l : 1 ;
   u16 d : 1 ;
   u16 g : 1 ;
   u16 base2 : 8 ;
} __attribute__((__packed__));
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/desc_defs.h"
typedef unsigned long pteval_t;
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pmdval_t;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pudval_t;
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_53 {
   pteval_t pte ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_53 pte_t;
#line 265  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 267  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_54 {
   pgdval_t pgd ;
};
#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_54 pgd_t;
#line 319  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pud_t_56 {
   pudval_t pud ;
};
#line 319  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pud_t_56 pud_t;
#line 345  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pmd_t_57 {
   pmdval_t pmd ;
};
#line 345  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pmd_t_57 pmd_t;
#line 505  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 519 
struct file;
#line 530 
struct seq_file;
#line 360  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/nospec-branch.h"
struct thread_struct;
#line 362 
struct cpumask;
#line 365 
struct vm_area_struct;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
struct __anonstruct_59 {
   u8 locked ;
   u8 pending ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
struct __anonstruct_60 {
   u16 locked_pending ;
   u16 tail ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
union __anonunion_58 {
   atomic_t val ;
   struct __anonstruct_59 __anonCompField___anonunion_58_7 ;
   struct __anonstruct_60 __anonCompField___anonunion_58_8 ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
struct qspinlock {
   union __anonunion_58 __anonCompField_qspinlock_9 ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qrwlock_types.h"
struct __anonstruct_62 {
   u8 wlocked ;
   u8 __lstate[3U] ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qrwlock_types.h"
union __anonunion_61 {
   atomic_t cnts ;
   struct __anonstruct_62 __anonCompField___anonunion_61_10 ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qrwlock_types.h"
struct qrwlock {
   union __anonunion_61 __anonCompField_qrwlock_11 ;
   arch_spinlock_t wait_lock ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/math_emu.h"
struct math_emu_info {
   long ___orig_eip ;
   struct pt_regs *regs ;
};
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
union __anonunion___u_67 {
   int __val ;
   char __c[1U] ;
};
#line 2288  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/atomic-fallback.h"
typedef atomic64_t atomic_long_t;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/tracepoint-defs.h"
struct tracepoint_func {
   void *func ;
   void *data ;
   int prio ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/tracepoint-defs.h"
struct tracepoint {
   char *name ;
   struct static_key key ;
   int (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/tracepoint-defs.h"
typedef int tracepoint_ptr_t;
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/tracepoint-defs.h"
struct bpf_raw_event_map {
   struct tracepoint *tp ;
   void *bpf_func ;
   u32 num_args ;
   u32 writable_size ;
} __attribute__((__aligned__(32)));
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_90 {
   u64 rip ;
   u64 rdp ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct __anonstruct_91 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
union __anonunion_89 {
   struct __anonstruct_90 __anonCompField___anonunion_89_17 ;
   struct __anonstruct_91 __anonCompField___anonunion_89_18 ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
union __anonunion_92 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_89 __anonCompField_fxregs_state_19 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_92 __anonCompField_fxregs_state_20 ;
} __attribute__((__aligned__(16)));
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
} __attribute__((__packed__));
#line 253  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 extended_state_area[0U] ;
} __attribute__((__packed__, __aligned__(64)));
#line 268  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
   u8 __padding[4096U] ;
};
#line 281  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/fpu/types.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned long avx512_timestamp ;
   union fpregs_state state ;
};
#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/orc_types.h"
struct orc_entry {
   s16 sp_offset ;
   s16 bp_offset ;
   unsigned int sp_reg : 4 ;
   unsigned int bp_reg : 4 ;
   unsigned int type : 2 ;
   unsigned int end : 1 ;
} __attribute__((__packed__));
#line 180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 478 
struct perf_event;
#line 479  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_95 {
   unsigned long seg ;
};
#line 479  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_95 mm_segment_t;
#line 485  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fsbase ;
   unsigned long gsbase ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct io_bitmap *io_bitmap ;
   unsigned long iopl_emul ;
   mm_segment_t addr_limit ;
   unsigned int sig_on_uaccess_err : 1 ;
   unsigned int uaccess_err : 1 ;
   struct fpu fpu ;
};
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/thread_info.h"
struct thread_info {
   unsigned long flags ;
   u32 status ;
};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bottom_half.h"
struct lockdep_map;
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__));
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
union __anonunion_96 {
   struct hlist_node hash_entry ;
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct lock_class_key {
   union __anonunion_96 __anonCompField_lock_class_key_23 ;
};
#line 68 
struct lock_trace;
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct lock_class {
   struct hlist_node hash_entry ;
   struct list_head lock_entry ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct lock_trace *usage_traces[9U] ;
   int name_version ;
   char *name ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char *name ;
   int cpu ;
   unsigned long ip ;
};
#line 226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int class_idx : 13 ;
   unsigned int irq_context : 2 ;
   unsigned int trylock : 1 ;
   unsigned int read : 2 ;
   unsigned int check : 1 ;
   unsigned int hardirqs_off : 1 ;
   unsigned int references : 12 ;
   unsigned int pin_count ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
struct __anonstruct_98 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
union __anonunion_97 {
   struct raw_spinlock rlock ;
   struct __anonstruct_98 __anonCompField___anonunion_97_24 ;
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_97 __anonCompField_spinlock_25 ;
};
#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
struct __anonstruct_rwlock_t_99 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_types.h"
typedef struct __anonstruct_rwlock_t_99 rwlock_t;
#line 57  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
struct mutex;
#line 27  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
struct kmem_cache;
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 403  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_112 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 403  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_112 seqlock_t;
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timex.h"
typedef s32 old_time32_t;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/time32.h"
struct old_timespec32 {
   old_time32_t tv_sec ;
   s32 tv_nsec ;
};
#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/highuid.h"
struct user_namespace;
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
struct __anonstruct_kuid_t_113 {
   uid_t val ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_113 kuid_t;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
struct __anonstruct_kgid_t_114 {
   gid_t val ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_114 kgid_t;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/stat.h"
struct kstat {
   u32 result_mask ;
   umode_t mode ;
   unsigned int nlink ;
   uint32_t blksize ;
   u64 attributes ;
   u64 attributes_mask ;
   u64 ino ;
   dev_t dev ;
   dev_t rdev ;
   kuid_t uid ;
   kgid_t gid ;
   loff_t size ;
   struct timespec64 atime ;
   struct timespec64 mtime ;
   struct timespec64 ctime ;
   struct timespec64 btime ;
   u64 blocks ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmdebug.h"
struct wait_queue_entry;
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmdebug.h"
typedef struct wait_queue_entry wait_queue_entry_t;
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/wait.h"
struct wait_queue_entry {
   unsigned int flags ;
   void *private ;
   int (*func)(struct wait_queue_entry *, unsigned int , int , void *) ;
   struct list_head entry ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/wait.h"
struct wait_queue_head {
   spinlock_t lock ;
   struct list_head head ;
};
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/wait.h"
typedef struct wait_queue_head wait_queue_head_t;
#line 1133  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/wait.h"
struct __anonstruct_nodemask_t_115 {
   unsigned long bits[16U] ;
};
#line 1133  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/wait.h"
typedef struct __anonstruct_nodemask_t_115 nodemask_t;
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/tlbbatch.h"
struct arch_tlbflush_unmap_batch {
   struct cpumask cpumask ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct vmacache {
   u64 seqnum ;
   struct vm_area_struct *vmas[4U] ;
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct task_rss_stat {
   int events ;
   int count[4U] ;
};
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct mm_rss_stat {
   atomic_long_t count[4U] ;
};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types_task.h"
struct tlbflush_unmap_batch {
   struct arch_tlbflush_unmap_batch arch ;
   bool flush_required ;
   bool writable ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rbtree.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(8)));
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 125  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rbtree.h"
struct rb_root_cached {
   struct rb_root rb_root ;
   struct rb_node *rb_leftmost ;
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rwsem.h"
struct rw_semaphore {
   atomic_long_t count ;
   atomic_long_t owner ;
   struct optimistic_spin_queue osq ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/completion.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 120 
struct inode;
#line 121 
struct notifier_block;
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct ww_acquire_ctx;
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mutex.h"
struct mutex {
   atomic_long_t owner ;
   spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct list_head wait_list ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   struct ww_acquire_ctx *ww_ctx ;
   void *magic ;
};
#line 461  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jiffies.h"
typedef s64 ktime_t;
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(struct timer_list *) ;
   u32 flags ;
   struct lockdep_map lockdep_map ;
};
#line 196 
struct hrtimer;
#line 197 
enum hrtimer_restart;
#line 221 
struct workqueue_struct;
#line 222 
struct work_struct;
#line 102  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *) ;
   struct lockdep_map lockdep_map ;
};
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 124  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/workqueue.h"
struct rcu_work {
   struct work_struct work ;
   struct callback_head rcu ;
   struct workqueue_struct *wq ;
};
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcu_segcblist.h"
struct rcu_segcblist {
   struct callback_head *head ;
   struct callback_head **tails[4U] ;
   unsigned long gp_seq[4U] ;
   atomic_long_t len ;
   long len_lazy ;
   u8 enabled ;
   u8 offloaded ;
};
#line 80 
struct srcu_struct;
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/srcu.h"
struct srcu_node;
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/srcutree.h"
struct srcu_data {
   unsigned long srcu_lock_count[2U] ;
   unsigned long srcu_unlock_count[2U] ;
   spinlock_t lock ;
   struct rcu_segcblist srcu_cblist ;
   unsigned long srcu_gp_seq_needed ;
   unsigned long srcu_gp_seq_needed_exp ;
   bool srcu_cblist_invoking ;
   struct timer_list delay_work ;
   struct work_struct work ;
   struct callback_head srcu_barrier_head ;
   struct srcu_node *mynode ;
   unsigned long grpmask ;
   int cpu ;
   struct srcu_struct *ssp ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/srcutree.h"
struct srcu_node {
   spinlock_t lock ;
   unsigned long srcu_have_cbs[4U] ;
   unsigned long srcu_data_have_cbs[4U] ;
   unsigned long srcu_gp_seq_needed_exp ;
   struct srcu_node *srcu_parent ;
   int grplo ;
   int grphi ;
};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/srcutree.h"
struct srcu_struct {
   struct srcu_node node[521U] ;
   struct srcu_node *level[4U] ;
   struct mutex srcu_cb_mutex ;
   spinlock_t lock ;
   struct mutex srcu_gp_mutex ;
   unsigned int srcu_idx ;
   unsigned long srcu_gp_seq ;
   unsigned long srcu_gp_seq_needed ;
   unsigned long srcu_gp_seq_needed_exp ;
   unsigned long srcu_last_gp_end ;
   struct srcu_data *sda ;
   unsigned long srcu_barrier_seq ;
   struct mutex srcu_barrier_mutex ;
   struct completion srcu_barrier_completion ;
   atomic_t srcu_barrier_cpu_cnt ;
   struct delayed_work work ;
   struct lockdep_map dep_map ;
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block *, unsigned long , void *) ;
   struct notifier_block *next ;
   int priority ;
};
#line 70  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/notifier.h"
struct raw_notifier_head {
   struct notifier_block *head ;
};
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 57 
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct __anonstruct_128 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct __anonstruct_129 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
union __anonunion_127 {
   struct __anonstruct_128 __anonCompField___anonunion_127_28 ;
   struct __anonstruct_129 __anonCompField___anonunion_127_29 ;
};
#line 61 
struct uprobe;
#line 61 
struct return_instance;
#line 61  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_127 __anonCompField_uprobe_task_30 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 83  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct return_instance {
   struct uprobe *uprobe ;
   unsigned long func ;
   unsigned long stack ;
   unsigned long orig_ret_vaddr ;
   bool chained ;
   struct return_instance *next ;
};
#line 98 
struct xol_area;
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 140 
struct ldt_struct;
#line 140 
struct vdso_image;
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
struct __anonstruct_mm_context_t_130 {
   u64 ctx_id ;
   atomic64_t tlb_gen ;
   struct rw_semaphore ldt_usr_sem ;
   struct ldt_struct *ldt ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   struct vdso_image *vdso_image ;
   atomic_t perf_rdpmc_allowed ;
   u16 pkey_allocation_map ;
   s16 execute_only_pkey ;
   void *bd_addr ;
};
#line 140  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uprobes.h"
typedef struct __anonstruct_mm_context_t_130 mm_context_t;
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct address_space;
#line 67 
struct mem_cgroup;
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_132 {
   struct list_head lru ;
   struct address_space *mapping ;
   unsigned long index ;
   unsigned long private ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_133 {
   dma_addr_t dma_addr ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_136 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_135 {
   struct list_head slab_list ;
   struct __anonstruct_136 __anonCompField___anonunion_135_33 ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_138 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_137 {
   void *s_mem ;
   unsigned long counters ;
   struct __anonstruct_138 __anonCompField___anonunion_137_35 ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_134 {
   union __anonunion_135 __anonCompField___anonstruct_134_34 ;
   struct kmem_cache *slab_cache ;
   void *freelist ;
   union __anonunion_137 __anonCompField___anonstruct_134_36 ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_139 {
   unsigned long compound_head ;
   unsigned char compound_dtor ;
   unsigned char compound_order ;
   atomic_t compound_mapcount ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_140 {
   unsigned long _compound_pad_1 ;
   unsigned long _compound_pad_2 ;
   struct list_head deferred_list ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_142 {
   struct mm_struct *pt_mm ;
   atomic_t pt_frag_refcount ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_141 {
   unsigned long _pt_pad_1 ;
   pgtable_t pmd_huge_pte ;
   unsigned long _pt_pad_2 ;
   union __anonunion_142 __anonCompField___anonstruct_141_40 ;
   spinlock_t *ptl ;
};
#line 68 
struct dev_pagemap;
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct __anonstruct_143 {
   struct dev_pagemap *pgmap ;
   void *zone_device_data ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_131 {
   struct __anonstruct_132 __anonCompField___anonunion_131_31 ;
   struct __anonstruct_133 __anonCompField___anonunion_131_32 ;
   struct __anonstruct_134 __anonCompField___anonunion_131_37 ;
   struct __anonstruct_139 __anonCompField___anonunion_131_38 ;
   struct __anonstruct_140 __anonCompField___anonunion_131_39 ;
   struct __anonstruct_141 __anonCompField___anonunion_131_41 ;
   struct __anonstruct_143 __anonCompField___anonunion_131_42 ;
   struct callback_head callback_head ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
union __anonunion_144 {
   atomic_t _mapcount ;
   unsigned int page_type ;
   unsigned int active ;
   int units ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/mmu.h"
struct page {
   unsigned long flags ;
   union __anonunion_131 __anonCompField_page_43 ;
   union __anonunion_144 __anonCompField_page_44 ;
   atomic_t _refcount ;
   struct mem_cgroup *mem_cgroup ;
} __attribute__((__aligned__(16)));
#line 278  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct userfaultfd_ctx;
#line 278  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct vm_userfaultfd_ctx {
   struct userfaultfd_ctx *ctx ;
};
#line 292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct __anonstruct_shared_145 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 292 
struct anon_vma;
#line 292 
struct vm_operations_struct;
#line 292 
struct mempolicy;
#line 292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_145 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   atomic_long_t swap_readahead_info ;
   struct mempolicy *vm_policy ;
   struct vm_userfaultfd_ctx vm_userfaultfd_ctx ;
} __attribute__((__designated_init__));
#line 358  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 363  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 368 
struct kioctx_table;
#line 370 
struct linux_binfmt;
#line 370 
struct mmu_notifier_mm;
#line 370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct __anonstruct_146 {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u64 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long mmap_compat_base ;
   unsigned long mmap_compat_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t membarrier_state ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t pgtables_bytes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   atomic64_t pinned_vm ;
   unsigned long data_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   spinlock_t arg_lock ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct user_namespace *user_ns ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   atomic_t tlb_flush_pending ;
   bool tlb_flush_batched ;
   struct uprobes_state uprobes_state ;
   atomic_long_t hugetlb_usage ;
   struct work_struct async_put_work ;
} __attribute__((__designated_init__));
#line 370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
struct mm_struct {
   struct __anonstruct_146 __anonCompField_mm_struct_45 ;
   unsigned long cpu_bitmap[] ;
};
#line 642 
struct vm_fault;
#line 643  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm_types.h"
typedef unsigned int vm_fault_t;
#line 316  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mmzone.h"
typedef unsigned int isolate_mode_t;
#line 824 
struct resource;
#line 825 
struct vmem_altmap;
#line 282  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 440  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/io.h"
struct fwnode_operations;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fwnode.h"
struct fwnode_handle {
   struct fwnode_handle *secondary ;
   struct fwnode_operations *ops ;
   struct device *dev ;
};
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fwnode.h"
struct fwnode_endpoint {
   unsigned int port ;
   unsigned int id ;
   struct fwnode_handle *local_fwnode ;
};
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fwnode.h"
struct fwnode_reference_args {
   struct fwnode_handle *fwnode ;
   unsigned int nargs ;
   u64 args[8U] ;
};
#line 110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fwnode.h"
struct fwnode_operations {
   struct fwnode_handle *(*get)(struct fwnode_handle *) ;
   void (*put)(struct fwnode_handle *) ;
   bool (*device_is_available)(struct fwnode_handle *) ;
   void *(*device_get_match_data)(struct fwnode_handle *, struct device *) ;
   bool (*property_present)(struct fwnode_handle *, char *) ;
   int (*property_read_int_array)(struct fwnode_handle *, char *, unsigned int , void *, size_t ) ;
   int (*property_read_string_array)(struct fwnode_handle *, char *, char **, size_t ) ;
   char *(*get_name)(struct fwnode_handle *) ;
   char *(*get_name_prefix)(struct fwnode_handle *) ;
   struct fwnode_handle *(*get_parent)(struct fwnode_handle *) ;
   struct fwnode_handle *(*get_next_child_node)(struct fwnode_handle *, struct fwnode_handle *) ;
   struct fwnode_handle *(*get_named_child_node)(struct fwnode_handle *, char *) ;
   int (*get_reference_args)(struct fwnode_handle *, char *, char *, unsigned int , unsigned int , struct fwnode_reference_args *) ;
   struct fwnode_handle *(*graph_get_next_endpoint)(struct fwnode_handle *, struct fwnode_handle *) ;
   struct fwnode_handle *(*graph_get_remote_endpoint)(struct fwnode_handle *) ;
   struct fwnode_handle *(*graph_get_port_parent)(struct fwnode_handle *) ;
   int (*graph_parse_endpoint)(struct fwnode_handle *, struct fwnode_endpoint *) ;
   int (*add_links)(struct fwnode_handle *, struct device *) ;
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/llist.h"
struct llist_node;
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/vmalloc.h"
struct vm_struct {
   struct vm_struct *next ;
   void *addr ;
   unsigned long size ;
   unsigned long flags ;
   struct page **pages ;
   unsigned int nr_pages ;
   phys_addr_t phys_addr ;
   void *caller ;
};
#line 822  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/sysctl.h"
struct nsproxy;
#line 823 
struct ctl_table_root;
#line 824 
struct ctl_table_header;
#line 825 
struct ctl_dir;
#line 46  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *, int , void *, size_t *, loff_t *);
#line 105  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table {
   char *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
} __attribute__((__designated_init__));
#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct __anonstruct_237 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
union __anonunion_236 {
   struct __anonstruct_237 __anonCompField___anonunion_236_47 ;
   struct callback_head rcu ;
};
#line 142 
struct ctl_table_set;
#line 142  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_236 __anonCompField_ctl_table_header_48 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
   struct hlist_head inodes ;
};
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 167  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set *) ;
   struct ctl_dir dir ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *) ;
   void (*set_ownership)(struct ctl_table_header *, struct ctl_table *, kuid_t *, kgid_t *) ;
   int (*permissions)(struct ctl_table_header *, struct ctl_table *) ;
};
#line 242 
struct cred;
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/vdso.h"
struct vdso_image {
   void *data ;
   unsigned long size ;
   unsigned long alt ;
   unsigned long alt_len ;
   long sym_vvar_start ;
   long sym_vvar_page ;
   long sym_pvclock_page ;
   long sym_hvclock_page ;
   long sym_VDSO32_NOTE_MASK ;
   long sym___kernel_sigreturn ;
   long sym___kernel_rt_sigreturn ;
   long sym___kernel_vsyscall ;
   long sym_int80_landing_pad ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u64 Elf64_Off;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 192  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 200  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 221  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
struct elf64_hdr {
   unsigned char e_ident[16U] ;
   Elf64_Half e_type ;
   Elf64_Half e_machine ;
   Elf64_Word e_version ;
   Elf64_Addr e_entry ;
   Elf64_Off e_phoff ;
   Elf64_Off e_shoff ;
   Elf64_Word e_flags ;
   Elf64_Half e_ehsize ;
   Elf64_Half e_phentsize ;
   Elf64_Half e_phnum ;
   Elf64_Half e_shentsize ;
   Elf64_Half e_shnum ;
   Elf64_Half e_shstrndx ;
};
#line 237  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef struct elf64_hdr Elf64_Ehdr;
#line 316  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
struct elf64_shdr {
   Elf64_Word sh_name ;
   Elf64_Word sh_type ;
   Elf64_Xword sh_flags ;
   Elf64_Addr sh_addr ;
   Elf64_Off sh_offset ;
   Elf64_Xword sh_size ;
   Elf64_Word sh_link ;
   Elf64_Word sh_info ;
   Elf64_Xword sh_addralign ;
   Elf64_Xword sh_entsize ;
};
#line 328  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/elf.h"
typedef struct elf64_shdr Elf64_Shdr;
#line 292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/xarray.h"
struct xarray {
   spinlock_t xa_lock ;
   gfp_t xa_flags ;
   void *xa_head ;
};
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/idr.h"
struct idr {
   struct xarray idr_rt ;
   unsigned int idr_base ;
   unsigned int idr_next ;
};
#line 322 
struct dentry;
#line 323 
struct iattr;
#line 324 
struct super_block;
#line 326 
struct fs_context;
#line 328 
struct kernfs_open_node;
#line 329 
struct kernfs_iattrs;
#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_root;
#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 96 
struct kernfs_node;
#line 96  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 100 
struct kernfs_ops;
#line 100  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
union __anonunion_256 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char *name ;
   struct rb_node rb ;
   void *ns ;
   unsigned int hash ;
   union __anonunion_256 __anonCompField_kernfs_node_51 ;
   void *priv ;
   u64 id ;
   unsigned short flags ;
   umode_t mode ;
   struct kernfs_iattrs *iattr ;
};
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*show_options)(struct seq_file *, struct kernfs_root *) ;
   int (*mkdir)(struct kernfs_node *, char *, umode_t ) ;
   int (*rmdir)(struct kernfs_node *) ;
   int (*rename)(struct kernfs_node *, struct kernfs_node *, char *) ;
   int (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *) ;
};
#line 173  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct idr ino_idr ;
   u32 last_id_lowbits ;
   u32 id_highbits ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   struct seq_file *seq_file ;
   void *priv ;
   struct mutex mutex ;
   struct mutex prealloc_mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped : 1 ;
   bool released : 1 ;
   struct vm_operations_struct *vm_ops ;
};
#line 210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernfs.h"
struct kernfs_ops {
   int (*open)(struct kernfs_open_file *) ;
   void (*release)(struct kernfs_open_file *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   ssize_t (*read)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   __poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *) ;
   int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *) ;
   struct lock_class_key lockdep_key ;
};
#line 595 
struct sock;
#line 596 
struct kobject;
#line 597 
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
};
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject_ns.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void *(*netlink_ns)(struct sock *) ;
   void *(*initial_ns)(void) ;
   void (*drop_ns)(void *) ;
};
#line 58 
struct bin_attribute;
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysfs.h"
struct attribute {
   char *name ;
   umode_t mode ;
   bool ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 84  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysfs.h"
struct attribute_group {
   char *name ;
   umode_t (*is_visible)(struct kobject *, struct attribute *, int ) ;
   umode_t (*is_bin_visible)(struct kobject *, struct bin_attribute *, int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t , size_t ) ;
   int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *) ;
};
#line 223  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject *, struct attribute *, char *) ;
   ssize_t (*store)(struct kobject *, struct attribute *, char *, size_t ) ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/refcount.h"
struct refcount_struct {
   atomic_t refs ;
};
#line 101  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/refcount.h"
typedef struct refcount_struct refcount_t;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kref.h"
struct kref {
   refcount_t refcount ;
};
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kset;
#line 65 
struct kobj_type;
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kobject {
   char *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
   struct attribute_group **default_groups ;
   struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *) ;
   void *(*namespace)(struct kobject *) ;
   void (*get_ownership)(struct kobject *, kuid_t *, kgid_t *) ;
};
#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kset_uevent_ops {
   int (*filter)(struct kset *, struct kobject *) ;
   char *(*name)(struct kset *, struct kobject *) ;
   int (*uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *) ;
};
#line 193  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
} __attribute__((__designated_init__));
#line 247 
struct kernel_param;
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char *, struct kernel_param *) ;
   int (*get)(char *, struct kernel_param *) ;
   void (*free)(void *) ;
};
#line 69 
struct kparam_string;
#line 69 
struct kparam_array;
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
union __anonunion_259 {
   void *arg ;
   struct kparam_string *str ;
   struct kparam_array *arr ;
};
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
struct kernel_param {
   char *name ;
   struct module *mod ;
   struct kernel_param_ops *ops ;
   u16 perm ;
   s8 level ;
   u8 flags ;
   union __anonunion_259 __anonCompField_kernel_param_52 ;
};
#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops *ops ;
   void *elem ;
};
#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rbtree_latch.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/error-injection.h"
struct error_injection_entry {
   unsigned long addr ;
   int etype ;
};
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/module.h"
struct mod_arch_specific {
   unsigned int num_orcs ;
   int *orc_unwind_ip ;
   struct orc_entry *orc_unwind ;
};
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct exception_table_entry;
#line 45 
struct module_param_attrs;
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
} __attribute__((__designated_init__));
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *) ;
   ssize_t (*store)(struct module_attribute *, struct module_kobject *, char *, size_t ) ;
   void (*setup)(struct module *, char *) ;
   int (*test)(struct module *) ;
   void (*free)(struct module *) ;
};
#line 297 
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
};
#line 305  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 310  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct module_layout {
   void *base ;
   unsigned int size ;
   unsigned int text_size ;
   unsigned int ro_size ;
   unsigned int ro_after_init_size ;
   struct mod_tree_node mtn ;
};
#line 334  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct mod_kallsyms {
   Elf64_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   char *typetab ;
};
#line 342  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct klp_modinfo {
   Elf64_Ehdr hdr ;
   Elf64_Shdr *sechdrs ;
   char *secstrings ;
   unsigned int symndx ;
};
#line 350 
struct module_sect_attrs;
#line 350 
struct module_notes_attrs;
#line 350 
struct trace_event_call;
#line 350 
struct trace_eval_map;
#line 350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char *version ;
   char *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol *syms ;
   s32 *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol *gpl_syms ;
   s32 *gpl_crcs ;
   struct kernel_symbol *unused_syms ;
   s32 *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol *unused_gpl_syms ;
   s32 *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol *gpl_future_syms ;
   s32 *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   struct module_layout core_layout ;
   struct module_layout init_layout ;
   struct mod_arch_specific arch ;
   unsigned long taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   struct mod_kallsyms *kallsyms ;
   struct mod_kallsyms core_kallsyms ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   tracepoint_ptr_t *tracepoints_ptrs ;
   unsigned int num_srcu_structs ;
   struct srcu_struct **srcu_struct_ptrs ;
   unsigned int num_bpf_raw_events ;
   struct bpf_raw_event_map *bpf_raw_events ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_eval_map **trace_evals ;
   unsigned int num_trace_evals ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp ;
   bool klp_alive ;
   struct klp_modinfo *klp_info ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t *ctors ;
   unsigned int num_ctors ;
   struct error_injection_entry *ei_funcs ;
   unsigned int num_ei_funcs ;
} __attribute__((__designated_init__, __aligned__(64)));
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_bl.h"
struct hlist_bl_node;
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_bl.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockref.h"
struct __anonstruct_315 {
   spinlock_t lock ;
   int count ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockref.h"
union __anonunion_314 {
   struct __anonstruct_315 __anonCompField___anonunion_314_53 ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockref.h"
struct lockref {
   union __anonunion_314 __anonCompField_lockref_54 ;
};
#line 78  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/stringhash.h"
struct path;
#line 79 
struct vfsmount;
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
struct __anonstruct_317 {
   u32 hash ;
   u32 len ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
union __anonunion_316 {
   struct __anonstruct_317 __anonCompField___anonunion_316_55 ;
   u64 hash_len ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
struct qstr {
   union __anonunion_316 __anonCompField_qstr_56 ;
   unsigned char *name ;
};
#line 89 
struct dentry_operations;
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
union __anonunion_318 {
   struct list_head d_lru ;
   wait_queue_head_t *d_wait ;
};
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
union __anonunion_d_u_319 {
   struct hlist_node d_alias ;
   struct hlist_bl_node d_in_lookup_hash ;
   struct callback_head d_rcu ;
};
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   union __anonunion_318 __anonCompField_dentry_57 ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_319 d_u ;
} __attribute__((__designated_init__));
#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry *, unsigned int ) ;
   int (*d_hash)(struct dentry *, struct qstr *) ;
   int (*d_compare)(struct dentry *, unsigned int , char *, struct qstr *) ;
   int (*d_delete)(struct dentry *) ;
   int (*d_init)(struct dentry *) ;
   void (*d_release)(struct dentry *) ;
   void (*d_prune)(struct dentry *) ;
   void (*d_iput)(struct dentry *, struct inode *) ;
   char *(*d_dname)(struct dentry *, char *, int ) ;
   struct vfsmount *(*d_automount)(struct path *) ;
   int (*d_manage)(struct path *, bool ) ;
   struct dentry *(*d_real)(struct dentry *, struct inode *) ;
} __attribute__((__aligned__(64)));
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/path.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
} __attribute__((__designated_init__));
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/shrinker.h"
struct shrink_control {
   gfp_t gfp_mask ;
   int nid ;
   unsigned long nr_to_scan ;
   unsigned long nr_scanned ;
   struct mem_cgroup *memcg ;
};
#line 60  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker *, struct shrink_control *) ;
   unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *) ;
   long batch ;
   int seeks ;
   unsigned int flags ;
   struct list_head list ;
   int id ;
   atomic_long_t *nr_deferred ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_lru.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_lru.h"
struct list_lru_memcg {
   struct callback_head rcu ;
   struct list_lru_one *lru[0U] ;
};
#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
   long nr_items ;
} __attribute__((__aligned__(64)));
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
   int shrinker_id ;
   bool memcg_aware ;
};
#line 222 
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_TGID = 1,
    PIDTYPE_PGID = 2,
    PIDTYPE_SID = 3,
    PIDTYPE_MAX = 4
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pid.h"
struct pid_namespace;
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pid.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pid.h"
struct pid {
   refcount_t count ;
   unsigned int level ;
   struct hlist_head tasks[4U] ;
   wait_queue_head_t wait_pidfd ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/semaphore.h"
struct semaphore {
   raw_spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fiemap.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 39 
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2,
    MIGRATE_SYNC_NO_COPY = 3
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcuwait.h"
struct rcuwait {
   struct task_struct *task ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rcu_sync.h"
struct rcu_sync {
   int gp_state ;
   int gp_count ;
   wait_queue_head_t gp_wait ;
   struct callback_head cb_head ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/percpu-rwsem.h"
struct percpu_rw_semaphore {
   struct rcu_sync rss ;
   unsigned int *read_count ;
   struct rw_semaphore rw_sem ;
   struct rcuwait writer ;
   int readers_block ;
};
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/delayed_call.h"
struct delayed_call {
   void (*fn)(void *) ;
   void *arg ;
};
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/uuid.h"
struct __anonstruct_uuid_t_327 {
   __u8 b[16U] ;
};
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/uuid.h"
typedef struct __anonstruct_uuid_t_327 uuid_t;
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uuid.h"
typedef u32 errseq_t;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rhashtable-types.h"
struct rhash_head {
   struct rhash_head *next ;
};
#line 25 
struct bucket_table;
#line 33 
struct rhashtable;
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rhashtable-types.h"
struct rhashtable_compare_arg {
   struct rhashtable *ht ;
   void *key ;
};
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rhashtable-types.h"
struct rhashtable_params {
   u16 nelem_hint ;
   u16 key_len ;
   u16 key_offset ;
   u16 head_offset ;
   unsigned int max_size ;
   u16 min_size ;
   bool automatic_shrinking ;
   u32 (*hashfn)(void *, u32 , u32 ) ;
   u32 (*obj_hashfn)(void *, u32 , u32 ) ;
   int (*obj_cmpfn)(struct rhashtable_compare_arg *, void *) ;
};
#line 81  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rhashtable-types.h"
struct rhashtable {
   struct bucket_table *tbl ;
   unsigned int key_len ;
   unsigned int max_elems ;
   struct rhashtable_params p ;
   bool rhlist ;
   struct work_struct run_work ;
   struct mutex mutex ;
   spinlock_t lock ;
   atomic_t nelems ;
};
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/sem.h"
struct sem_undo_list;
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 83  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timerqueue.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root_cached rb_root ;
};
#line 60 
struct hrtimer_clock_base;
#line 61 
struct hrtimer_cpu_base;
#line 80 
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
};
#line 117  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hrtimer.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer *) ;
   struct hrtimer_clock_base *base ;
   u8 state ;
   u8 is_rel ;
   u8 is_soft ;
   u8 is_hard ;
};
#line 158  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   unsigned int index ;
   clockid_t clockid ;
   seqcount_t seq ;
   struct hrtimer *running ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
} __attribute__((__aligned__(64)));
#line 213  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   unsigned int hres_active : 1 ;
   unsigned int in_hrtirq : 1 ;
   unsigned int hang_detected : 1 ;
   unsigned int softirq_activated : 1 ;
   unsigned int nr_events ;
   unsigned short nr_retries ;
   unsigned short nr_hangs ;
   unsigned int max_hang_time ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   ktime_t softirq_expires_next ;
   struct hrtimer *softirq_next_timer ;
   struct hrtimer_clock_base clock_base[8U] ;
} __attribute__((__aligned__(64)));
#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/seccomp.h"
struct seccomp_filter;
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/latencytop.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/types.h"
struct task_cputime {
   u64 stime ;
   u64 utime ;
   unsigned long long sum_exec_runtime ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_330 {
   unsigned long sig[1U] ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_330 sigset_t;
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/signal.h"
typedef void __signalfn_t(int );
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_331 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_332 {
   __kernel_timer_t _tid ;
   int _overrun ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_333 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_334 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_337 {
   char _dummy_bnd[8U] ;
   void *_lower ;
   void *_upper ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_pkey_338 {
   char _dummy_pkey[8U] ;
   __u32 _pkey ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
union __anonunion_336 {
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_337 _addr_bnd ;
   struct __anonstruct__addr_pkey_338 _addr_pkey ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_335 {
   void *_addr ;
   union __anonunion_336 __anonCompField___anonstruct__sigfault_335_58 ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_339 {
   long _band ;
   int _fd ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_340 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/siginfo.h"
union __sifields {
   struct __anonstruct__kill_331 _kill ;
   struct __anonstruct__timer_332 _timer ;
   struct __anonstruct__rt_333 _rt ;
   struct __anonstruct__sigchld_334 _sigchld ;
   struct __anonstruct__sigfault_335 _sigfault ;
   struct __anonstruct__sigpoll_339 _sigpoll ;
   struct __anonstruct__sigsys_340 _sigsys ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct __anonstruct_345 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __sifields _sifields ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct kernel_siginfo {
   struct __anonstruct_345 __anonCompField_kernel_siginfo_61 ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
typedef struct kernel_siginfo kernel_siginfo_t;
#line 20 
struct user_struct;
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/signal_types.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/task_io_accounting.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/posix-timers.h"
struct posix_cputimer_base {
   u64 nextevt ;
   struct timerqueue_head tqhead ;
};
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/posix-timers.h"
struct posix_cputimers {
   struct posix_cputimer_base bases[3U] ;
   unsigned int timers_active ;
   unsigned int expiry_active ;
};
#line 193 
struct signal_struct;
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/rseq.h"
union __anonunion_rseq_cs_350 {
   __u64 ptr64 ;
   __u64 ptr ;
};
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/rseq.h"
struct rseq {
   __u32 cpu_id_start ;
   __u32 cpu_id ;
   union __anonunion_rseq_cs_350 rseq_cs ;
   __u32 flags ;
} __attribute__((__aligned__(32)));
#line 146 
struct audit_context;
#line 147 
struct backing_dev_info;
#line 148 
struct bio_list;
#line 149 
struct blk_plug;
#line 150 
struct capture_control;
#line 151 
struct cfs_rq;
#line 152 
struct fs_struct;
#line 153 
struct futex_pi_state;
#line 154 
struct io_context;
#line 155 
struct nameidata;
#line 156 
struct perf_event_context;
#line 157 
struct pipe_inode_info;
#line 159 
struct reclaim_state;
#line 160 
struct robust_list_head;
#line 165 
struct sighand_struct;
#line 166 
struct task_delay_info;
#line 167 
struct task_group;
#line 242  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct prev_cputime {
   u64 utime ;
   u64 stime ;
   raw_spinlock_t lock ;
};
#line 290  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 352  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct util_est {
   unsigned int enqueued ;
   unsigned int ewma ;
} __attribute__((__aligned__(8)));
#line 401  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_avg {
   u64 last_update_time ;
   u64 load_sum ;
   u64 runnable_load_sum ;
   u32 util_sum ;
   u32 period_contrib ;
   unsigned long load_avg ;
   unsigned long runnable_load_avg ;
   unsigned long util_avg ;
   struct util_est util_est ;
} __attribute__((__aligned__(64)));
#line 413  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 449  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   unsigned long runnable_weight ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 486 
struct rt_rq;
#line 486  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   unsigned short on_rq ;
   unsigned short on_list ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
} __attribute__((__designated_init__));
#line 504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   u64 dl_density ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   unsigned int dl_throttled : 1 ;
   unsigned int dl_boosted : 1 ;
   unsigned int dl_yielded : 1 ;
   unsigned int dl_non_contending : 1 ;
   unsigned int dl_overrun : 1 ;
   struct hrtimer dl_timer ;
   struct hrtimer inactive_timer ;
};
#line 600  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct uclamp_se {
   unsigned int value : 11 ;
   unsigned int bucket_id : 3 ;
   unsigned int active : 1 ;
   unsigned int user_defined : 1 ;
};
#line 625  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 629 
struct sched_class;
#line 629 
struct key;
#line 629 
struct files_struct;
#line 629 
struct rt_mutex_waiter;
#line 629 
struct css_set;
#line 629 
struct compat_robust_list_head;
#line 629 
struct numa_group;
#line 629  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
union __anonunion_352 {
   refcount_t rcu_users ;
   struct callback_head rcu ;
};
#line 629 
struct ftrace_ret_stack;
#line 629 
struct kcov;
#line 629 
struct request_queue;
#line 629  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
struct task_struct {
   struct thread_info thread_info ;
   long state ;
   void *stack ;
   refcount_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   unsigned int cpu ;
   unsigned int wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   struct task_struct *last_wakee ;
   int recent_used_cpu ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct uclamp_se uclamp_req[2U] ;
   struct uclamp_se uclamp[2U] ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t *cpus_ptr ;
   cpumask_t cpus_mask ;
   unsigned long rcu_tasks_nvcsw ;
   u8 rcu_tasks_holdout ;
   u8 rcu_tasks_idx ;
   int rcu_tasks_idle_cpu ;
   struct list_head rcu_tasks_holdout_list ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct vmacache vmacache ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned int sched_reset_on_fork : 1 ;
   unsigned int sched_contributes_to_load : 1 ;
   unsigned int sched_migrated : 1 ;
   unsigned int sched_remote_wakeup : 1 ;
   unsigned int sched_psi_wake_requeue : 1 ;
   unsigned int  ;
   unsigned int in_execve : 1 ;
   unsigned int in_iowait : 1 ;
   unsigned int restore_sigmask : 1 ;
   unsigned int in_user_fault : 1 ;
   unsigned int brk_randomized : 1 ;
   unsigned int no_cgroup_migration : 1 ;
   unsigned int frozen : 1 ;
   unsigned int use_memdelay : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid *thread_pid ;
   struct hlist_node pid_links[4U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   u64 utime ;
   u64 stime ;
   u64 gtime ;
   struct prev_cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 start_boottime ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct posix_cputimers posix_cputimers ;
   struct cred *ptracer_cred ;
   struct cred *real_cred ;
   struct cred *cred ;
   struct key *cached_requested_key ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   unsigned long last_switch_time ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   unsigned int sas_ss_flags ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root_cached pi_waiters ;
   struct task_struct *pi_top_task ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   int non_block_count ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   unsigned int in_ubsan ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   struct capture_control *capture_control ;
   unsigned long ptrace_message ;
   kernel_siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   unsigned int psi_flags ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   u64 acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   u32 closid ;
   u32 rmid ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct mutex futex_exit_mutex ;
   unsigned int futex_state ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_prev ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct rseq *rseq ;
   u32 rseq_sig ;
   unsigned long rseq_event_mask ;
   struct tlbflush_unmap_batch tlb_ubc ;
   union __anonunion_352 __anonCompField_task_struct_63 ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   unsigned int fail_nth ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   u64 timer_slack_ns ;
   u64 default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   int curr_ret_depth ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   unsigned int kcov_mode ;
   unsigned int kcov_size ;
   void *kcov_area ;
   struct kcov *kcov ;
   u64 kcov_handle ;
   int kcov_sequence ;
   struct mem_cgroup *memcg_in_oom ;
   gfp_t memcg_oom_gfp_mask ;
   int memcg_oom_order ;
   unsigned int memcg_nr_pages_over_high ;
   struct mem_cgroup *active_memcg ;
   struct request_queue *throttle_queue ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
   struct task_struct *oom_reaper_list ;
   struct vm_struct *stack_vm_area ;
   refcount_t stack_refcount ;
   int patch_state ;
   void *security ;
   struct thread_struct thread ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iocontext.h"
union __anonunion_359 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iocontext.h"
union __anonunion_360 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iocontext.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion_359 __anonCompField_io_cq_64 ;
   union __anonunion_360 __anonCompField_io_cq_65 ;
   unsigned int flags ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct xarray icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 286  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fs.h"
struct bdi_writeback;
#line 288 
struct export_operations;
#line 290 
struct iovec;
#line 291 
struct kiocb;
#line 292 
struct kstatfs;
#line 293 
struct swap_info_struct;
#line 294 
struct iov_iter;
#line 295 
struct fscrypt_info;
#line 296 
struct fscrypt_operations;
#line 297 
struct fsverity_info;
#line 298 
struct fsverity_operations;
#line 299 
struct fs_parameter_description;
#line 224  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec64 ia_atime ;
   struct timespec64 ia_mtime ;
   struct timespec64 ia_ctime ;
   struct file *ia_file ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/percpu_counter.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 214  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 215 
struct kqid;
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/projid.h"
struct __anonstruct_kprojid_t_361 {
   projid_t val ;
};
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_361 kprojid_t;
#line 180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
typedef long long qsize_t;
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
union __anonunion_362 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 68  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct kqid {
   union __anonunion_362 __anonCompField_kqid_66 ;
   enum quota_type type ;
};
#line 205  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time64_t dqb_btime ;
   time64_t dqb_itime ;
};
#line 216 
struct quota_format_type;
#line 222  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 294  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   spinlock_t dq_dqb_lock ;
   atomic_t dq_count ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 310  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *, int ) ;
   int (*read_file_info)(struct super_block *, int ) ;
   int (*write_file_info)(struct super_block *, int ) ;
   int (*free_file_info)(struct super_block *, int ) ;
   int (*read_dqblk)(struct dquot *) ;
   int (*commit_dqblk)(struct dquot *) ;
   int (*release_dqblk)(struct dquot *) ;
   int (*get_next_id)(struct super_block *, struct kqid *) ;
};
#line 322  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot *) ;
   struct dquot *(*alloc_dquot)(struct super_block *, int ) ;
   void (*destroy_dquot)(struct dquot *) ;
   int (*acquire_dquot)(struct dquot *) ;
   int (*release_dquot)(struct dquot *) ;
   int (*mark_dirty)(struct dquot *) ;
   int (*write_info)(struct super_block *, int ) ;
   qsize_t *(*get_reserved_space)(struct inode *) ;
   int (*get_projid)(struct inode *, kprojid_t *) ;
   int (*get_inode_usage)(struct inode *, qsize_t *) ;
   int (*get_next_id)(struct super_block *, struct kqid *) ;
};
#line 343  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 395  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 409  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 415  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 428  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block *, int , int , struct path *) ;
   int (*quota_off)(struct super_block *, int ) ;
   int (*quota_enable)(struct super_block *, unsigned int ) ;
   int (*quota_disable)(struct super_block *, unsigned int ) ;
   int (*quota_sync)(struct super_block *, int ) ;
   int (*set_info)(struct super_block *, int , struct qc_info *) ;
   int (*get_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *) ;
   int (*set_dqblk)(struct super_block *, struct kqid , struct qc_dqblk *) ;
   int (*get_state)(struct super_block *, struct qc_state *) ;
   int (*rm_xquota)(struct super_block *, unsigned int ) ;
};
#line 443  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 518  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct rw_semaphore dqio_sem ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops *ops[3U] ;
};
#line 538 
struct writeback_control;
#line 539 
enum rw_hint {
    WRITE_LIFE_NOT_SET = 0,
    WRITE_LIFE_NONE = 1,
    WRITE_LIFE_SHORT = 2,
    WRITE_LIFE_MEDIUM = 3,
    WRITE_LIFE_LONG = 4,
    WRITE_LIFE_EXTREME = 5
};
#line 318  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb *, long , long ) ;
   void *private ;
   int ki_flags ;
   u16 ki_hint ;
   u16 ki_ioprio ;
   unsigned int ki_cookie ;
};
#line 339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_arg_364 {
   char *buf ;
   void *data ;
};
#line 339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_363 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_364 arg ;
   int error ;
};
#line 339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_363 read_descriptor_t;
#line 362  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *, struct writeback_control *) ;
   int (*readpage)(struct file *, struct page *) ;
   int (*writepages)(struct address_space *, struct writeback_control *) ;
   int (*set_page_dirty)(struct page *) ;
   int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int ) ;
   int (*write_begin)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page **, void **) ;
   int (*write_end)(struct file *, struct address_space *, loff_t , unsigned int , unsigned int , struct page *, void *) ;
   sector_t (*bmap)(struct address_space *, sector_t ) ;
   void (*invalidatepage)(struct page *, unsigned int , unsigned int ) ;
   int (*releasepage)(struct page *, gfp_t ) ;
   void (*freepage)(struct page *) ;
   ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *) ;
   int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode ) ;
   bool (*isolate_page)(struct page *, isolate_mode_t ) ;
   void (*putback_page)(struct page *) ;
   int (*launder_page)(struct page *) ;
   int (*is_partially_uptodate)(struct page *, unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page *, bool *, bool *) ;
   int (*error_remove_page)(struct address_space *, struct page *) ;
   int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *) ;
   void (*swap_deactivate)(struct file *) ;
};
#line 445  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct xarray i_pages ;
   gfp_t gfp_mask ;
   atomic_t i_mmap_writable ;
   atomic_t nr_thps ;
   struct rb_root_cached i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrexceptional ;
   unsigned long writeback_index ;
   struct address_space_operations *a_ops ;
   unsigned long flags ;
   errseq_t wb_err ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
} __attribute__((__designated_init__, __aligned__(8)));
#line 473 
struct hd_struct;
#line 473 
struct gendisk;
#line 473  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   u8 bd_partno ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct backing_dev_info *bd_bdi ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
} __attribute__((__designated_init__));
#line 587 
struct posix_acl;
#line 614 
struct fsnotify_mark_connector;
#line 628 
struct inode_operations;
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_367 {
   unsigned int i_nlink ;
   unsigned int __i_nlink ;
};
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_368 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_369 {
   struct file_operations *i_fop ;
   void (*free_inode)(struct inode *) ;
};
#line 628 
struct file_lock_context;
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_370 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
   unsigned int i_dir_seq ;
};
#line 628  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_367 __anonCompField_inode_67 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec64 i_atime ;
   struct timespec64 i_mtime ;
   struct timespec64 i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   u8 i_blkbits ;
   u8 i_write_hint ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct rw_semaphore i_rwsem ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_io_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   struct list_head i_wb_list ;
   union __anonunion_368 __anonCompField_inode_68 ;
   atomic64_t i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   union __anonunion_369 __anonCompField_inode_69 ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion_370 __anonCompField_inode_70 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct fsnotify_mark_connector *i_fsnotify_marks ;
   struct fscrypt_info *i_crypt_info ;
   struct fsverity_info *i_verity_info ;
   void *i_private ;
} __attribute__((__designated_init__));
#line 904  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 915  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 935  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_f_u_371 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 935  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file {
   union __anonunion_f_u_371 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations *f_op ;
   spinlock_t f_lock ;
   enum rw_hint f_write_hint ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   errseq_t f_wb_err ;
} __attribute__((__designated_init__, __aligned__(4)));
#line 988  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
typedef void *fl_owner_t;
#line 1026 
struct file_lock;
#line 1029  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock *, struct file_lock *) ;
   void (*fl_release_private)(struct file_lock *) ;
};
#line 1034  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct lock_manager_operations {
   fl_owner_t (*lm_get_owner)(fl_owner_t ) ;
   void (*lm_put_owner)(fl_owner_t ) ;
   void (*lm_notify)(struct file_lock *) ;
   int (*lm_grant)(struct file_lock *, int ) ;
   bool (*lm_break)(struct file_lock *) ;
   int (*lm_change)(struct file_lock *, int , struct list_head *) ;
   void (*lm_setup)(struct file_lock *, void **) ;
};
#line 1052 
struct net;
#line 1058 
struct nlm_lockowner;
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nfs_fs_i.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 15 
struct nfs4_lock_state;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 1079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct fasync_struct;
#line 1079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct __anonstruct_afs_373 {
   struct list_head link ;
   int state ;
   unsigned int debug_id ;
};
#line 1079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
union __anonunion_fl_u_372 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_373 afs ;
};
#line 1079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_lock {
   struct file_lock *fl_blocker ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_blocked_requests ;
   struct list_head fl_blocked_member ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_372 fl_u ;
} __attribute__((__designated_init__));
#line 1117  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1331  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct fasync_struct {
   rwlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1418  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct sb_writers {
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct percpu_rw_semaphore rw_sem[3U] ;
};
#line 1424 
struct super_operations;
#line 1424 
struct xattr_handler;
#line 1424 
struct mtd_info;
#line 1424  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct fscrypt_operations *s_cop ;
   struct key *s_master_keys ;
   struct fsverity_operations *s_vop ;
   struct hlist_bl_head s_roots ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   void *s_fs_info ;
   u32 s_time_gran ;
   time64_t s_time_min ;
   time64_t s_time_max ;
   __u32 s_fsnotify_mask ;
   struct fsnotify_mark_connector *s_fsnotify_marks ;
   char s_id[32U] ;
   uuid_t s_uuid ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   struct dentry_operations *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   atomic_long_t s_fsnotify_inode_refs ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct user_namespace *s_user_ns ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   struct work_struct destroy_work ;
   struct mutex s_sync_lock ;
   int s_stack_depth ;
   spinlock_t s_inode_list_lock ;
   struct list_head s_inodes ;
   spinlock_t s_inode_wblist_lock ;
   struct list_head s_inodes_wb ;
} __attribute__((__designated_init__));
#line 1746  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1756 
struct dir_context;
#line 1767  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context *, char *, int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};
#line 1821  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file *, loff_t , int ) ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*read_iter)(struct kiocb *, struct iov_iter *) ;
   ssize_t (*write_iter)(struct kiocb *, struct iov_iter *) ;
   int (*iopoll)(struct kiocb *, bool ) ;
   int (*iterate)(struct file *, struct dir_context *) ;
   int (*iterate_shared)(struct file *, struct dir_context *) ;
   __poll_t (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   unsigned long mmap_supported_flags ;
   int (*open)(struct inode *, struct file *) ;
   int (*flush)(struct file *, fl_owner_t ) ;
   int (*release)(struct inode *, struct file *) ;
   int (*fsync)(struct file *, loff_t , loff_t , int ) ;
   int (*fasync)(int , struct file *, int ) ;
   int (*lock)(struct file *, int , struct file_lock *) ;
   ssize_t (*sendpage)(struct file *, struct page *, int , size_t , loff_t *, int ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file *, int , struct file_lock *) ;
   ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t , unsigned int ) ;
   ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*setlease)(struct file *, long , struct file_lock **, void **) ;
   long (*fallocate)(struct file *, int , loff_t , loff_t ) ;
   void (*show_fdinfo)(struct seq_file *, struct file *) ;
   ssize_t (*copy_file_range)(struct file *, loff_t , struct file *, loff_t , size_t , unsigned int ) ;
   loff_t (*remap_file_range)(struct file *, loff_t , struct file *, loff_t , loff_t , unsigned int ) ;
   int (*fadvise)(struct file *, loff_t , loff_t , int ) ;
} __attribute__((__designated_init__));
#line 1863  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode *, struct dentry *, unsigned int ) ;
   char *(*get_link)(struct dentry *, struct inode *, struct delayed_call *) ;
   int (*permission)(struct inode *, int ) ;
   struct posix_acl *(*get_acl)(struct inode *, int ) ;
   int (*readlink)(struct dentry *, char *, int ) ;
   int (*create)(struct inode *, struct dentry *, umode_t , bool ) ;
   int (*link)(struct dentry *, struct inode *, struct dentry *) ;
   int (*unlink)(struct inode *, struct dentry *) ;
   int (*symlink)(struct inode *, struct dentry *, char *) ;
   int (*mkdir)(struct inode *, struct dentry *, umode_t ) ;
   int (*rmdir)(struct inode *, struct dentry *) ;
   int (*mknod)(struct inode *, struct dentry *, umode_t , dev_t ) ;
   int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int ) ;
   int (*setattr)(struct dentry *, struct iattr *) ;
   int (*getattr)(struct path *, struct kstat *, u32 , unsigned int ) ;
   ssize_t (*listxattr)(struct dentry *, char *, size_t ) ;
   int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 , u64 ) ;
   int (*update_time)(struct inode *, struct timespec64 *, int ) ;
   int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int , umode_t ) ;
   int (*tmpfile)(struct inode *, struct dentry *, umode_t ) ;
   int (*set_acl)(struct inode *, struct posix_acl *, int ) ;
} __attribute__((__aligned__(64)));
#line 1942  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *) ;
   void (*destroy_inode)(struct inode *) ;
   void (*free_inode)(struct inode *) ;
   void (*dirty_inode)(struct inode *, int ) ;
   int (*write_inode)(struct inode *, struct writeback_control *) ;
   int (*drop_inode)(struct inode *) ;
   void (*evict_inode)(struct inode *) ;
   void (*put_super)(struct super_block *) ;
   int (*sync_fs)(struct super_block *, int ) ;
   int (*freeze_super)(struct super_block *) ;
   int (*freeze_fs)(struct super_block *) ;
   int (*thaw_super)(struct super_block *) ;
   int (*unfreeze_fs)(struct super_block *) ;
   int (*statfs)(struct dentry *, struct kstatfs *) ;
   int (*remount_fs)(struct super_block *, int *, char *) ;
   void (*umount_begin)(struct super_block *) ;
   int (*show_options)(struct seq_file *, struct dentry *) ;
   int (*show_devname)(struct seq_file *, struct dentry *) ;
   int (*show_path)(struct seq_file *, struct dentry *) ;
   int (*show_stats)(struct seq_file *, struct dentry *) ;
   ssize_t (*quota_read)(struct super_block *, int , char *, size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block *, int , char *, size_t , loff_t ) ;
   struct dquot **(*get_dquots)(struct inode *) ;
   int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t ) ;
   long (*nr_cached_objects)(struct super_block *, struct shrink_control *) ;
   long (*free_cached_objects)(struct super_block *, struct shrink_control *) ;
};
#line 2217  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
struct file_system_type {
   char *name ;
   int fs_flags ;
   int (*init_fs_context)(struct fs_context *) ;
   struct fs_parameter_description *parameters ;
   struct dentry *(*mount)(struct file_system_type *, int , char *, void *) ;
   void (*kill_sb)(struct super_block *) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 3629 
struct proc_dir_entry;
#line 141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/proc_fs.h"
struct ns_common;
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/extable.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
   int handler ;
};
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/assoc_array.h"
struct assoc_array_ptr;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/assoc_array.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 83  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/assoc_array.h"
typedef int32_t key_serial_t;
#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 32 
struct key_type;
#line 34 
struct key_tag;
#line 85  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct key_tag {
   struct callback_head rcu ;
   refcount_t usage ;
   bool removed ;
};
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct __anonstruct_375 {
   u16 desc_len ;
   char desc[6U] ;
};
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_374 {
   struct __anonstruct_375 __anonCompField___anonunion_374_71 ;
   unsigned long x ;
};
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct keyring_index_key {
   unsigned long hash ;
   union __anonunion_374 __anonCompField_keyring_index_key_72 ;
   struct key_type *type ;
   struct key_tag *domain_tag ;
   char *description ;
};
#line 111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union key_payload {
   void *rcu_data0 ;
   void *data[4U] ;
};
#line 153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct key_restriction {
   int (*check)(struct key *, struct key_type *, union key_payload *, struct key *) ;
   struct key *key ;
   struct key_type *keytype ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_376 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 172 
struct key_user;
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_377 {
   time64_t expiry ;
   time64_t revoked_at ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct __anonstruct_379 {
   unsigned long hash ;
   unsigned long len_desc ;
   struct key_type *type ;
   struct key_tag *domain_tag ;
   char *description ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_378 {
   struct keyring_index_key index_key ;
   struct __anonstruct_379 __anonCompField___anonunion_378_75 ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct __anonstruct_381 {
   struct list_head name_link ;
   struct assoc_array keys ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
union __anonunion_380 {
   union key_payload payload ;
   struct __anonstruct_381 __anonCompField___anonunion_380_77 ;
};
#line 172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/key.h"
struct key {
   refcount_t usage ;
   key_serial_t serial ;
   union __anonunion_376 __anonCompField_key_73 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_377 __anonCompField_key_74 ;
   time64_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   short state ;
   unsigned long flags ;
   union __anonunion_378 __anonCompField_key_76 ;
   union __anonunion_380 __anonCompField_key_78 ;
   struct key_restriction *restrict_link ;
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ratelimit.h"
struct ratelimit_state {
   raw_spinlock_t lock ;
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
   unsigned long flags ;
};
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/user.h"
struct user_struct {
   refcount_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   unsigned long unix_inflight ;
   atomic_long_t pipe_bufs ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
   struct ratelimit_state ratelimit ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cred.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   kgid_t gid[0U] ;
} __attribute__((__designated_init__));
#line 111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cred.h"
union __anonunion_384 {
   int non_rcu ;
   struct callback_head rcu ;
};
#line 111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   kernel_cap_t cap_ambient ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   union __anonunion_384 __anonCompField_cred_79 ;
} __attribute__((__designated_init__));
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct sighand_struct {
   spinlock_t siglock ;
   refcount_t count ;
   wait_queue_head_t signalfd_wqh ;
   struct k_sigaction action[64U] ;
};
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   u64 ac_utime ;
   u64 ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct cpu_itimer {
   u64 expires ;
   u64 incr ;
};
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
};
#line 80 
struct tty_struct;
#line 80 
struct autogroup;
#line 80 
struct taskstats;
#line 80 
struct tty_audit_buf;
#line 80  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
struct signal_struct {
   refcount_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   struct hlist_head multiprocess ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int is_child_subreaper : 1 ;
   unsigned int has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct posix_cputimers posix_cputimers ;
   struct pid *pids[4U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   u64 utime ;
   u64 stime ;
   u64 cutime ;
   u64 cstime ;
   u64 gtime ;
   u64 cgtime ;
   struct prev_cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   bool oom_flag_origin ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mm_struct *oom_mm ;
   struct mutex cred_guard_mutex ;
} __attribute__((__designated_init__));
#line 705 
struct percpu_ref;
#line 706  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched/signal.h"
typedef void percpu_ref_func_t(struct percpu_ref *);
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic : 1 ;
   bool allow_reinit : 1 ;
   struct callback_head rcu ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ioport.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char *name ;
   unsigned long flags ;
   unsigned long desc ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memremap.h"
struct vmem_altmap {
   unsigned long base_pfn ;
   unsigned long end_pfn ;
   unsigned long reserve ;
   unsigned long free ;
   unsigned long align ;
   unsigned long alloc ;
};
#line 26 
enum memory_type {
    MEMORY_DEVICE_PRIVATE = 1,
    MEMORY_DEVICE_FS_DAX = 2,
    MEMORY_DEVICE_DEVDAX = 3,
    MEMORY_DEVICE_PCI_P2PDMA = 4
};
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memremap.h"
struct dev_pagemap_ops {
   void (*page_free)(struct page *) ;
   void (*kill)(struct dev_pagemap *) ;
   void (*cleanup)(struct dev_pagemap *) ;
   vm_fault_t (*migrate_to_ram)(struct vm_fault *) ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/memremap.h"
struct dev_pagemap {
   struct vmem_altmap altmap ;
   struct resource res ;
   struct percpu_ref *ref ;
   struct percpu_ref internal_ref ;
   struct completion done ;
   enum memory_type type ;
   unsigned int flags ;
   struct dev_pagemap_ops *ops ;
};
#line 417  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
struct vm_fault {
   struct vm_area_struct *vma ;
   unsigned int flags ;
   gfp_t gfp_mask ;
   unsigned long pgoff ;
   unsigned long address ;
   pmd_t *pmd ;
   pud_t *pud ;
   pte_t orig_pte ;
   struct page *cow_page ;
   struct mem_cgroup *memcg ;
   struct page *page ;
   pte_t *pte ;
   spinlock_t *ptl ;
   pgtable_t prealloc_pte ;
};
#line 448 
enum page_entry_size {
    PE_SIZE_PTE = 0,
    PE_SIZE_PMD = 1,
    PE_SIZE_PUD = 2
};
#line 467  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *) ;
   void (*close)(struct vm_area_struct *) ;
   int (*split)(struct vm_area_struct *, unsigned long ) ;
   int (*mremap)(struct vm_area_struct *) ;
   vm_fault_t (*fault)(struct vm_fault *) ;
   vm_fault_t (*huge_fault)(struct vm_fault *, enum page_entry_size ) ;
   void (*map_pages)(struct vm_fault *, unsigned long , unsigned long ) ;
   unsigned long (*pagesize)(struct vm_area_struct *) ;
   vm_fault_t (*page_mkwrite)(struct vm_fault *) ;
   vm_fault_t (*pfn_mkwrite)(struct vm_fault *) ;
   int (*access)(struct vm_area_struct *, unsigned long , void *, int , int ) ;
   char *(*name)(struct vm_area_struct *) ;
   int (*set_policy)(struct vm_area_struct *, struct mempolicy *) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *, unsigned long ) ;
   struct page *(*find_special_page)(struct vm_area_struct *, unsigned long ) ;
};
#line 1565 
struct kvec;
#line 2889 
struct mnt_namespace;
#line 2890 
struct uts_namespace;
#line 2891 
struct ipc_namespace;
#line 2892 
struct cgroup_namespace;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/nsproxy.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
   struct cgroup_namespace *cgroup_ns ;
};
#line 87 
struct proc_ns_operations;
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ns_common.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations *ops ;
   unsigned int inum ;
};
#line 12 
struct fs_pin;
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pid_namespace.h"
struct ucounts;
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pid_namespace.h"
struct pid_namespace {
   struct kref kref ;
   struct idr idr ;
   struct callback_head rcu ;
   unsigned int pid_allocated ;
   struct task_struct *child_reaper ;
   struct kmem_cache *pid_cachep ;
   unsigned int level ;
   struct pid_namespace *parent ;
   struct vfsmount *proc_mnt ;
   struct dentry *proc_self ;
   struct dentry *proc_thread_self ;
   struct fs_pin *bacct ;
   struct user_namespace *user_ns ;
   struct ucounts *ucounts ;
   struct work_struct proc_work ;
   kgid_t pid_gid ;
   int hide_pid ;
   int reboot ;
   struct ns_common ns ;
} __attribute__((__designated_init__));
#line 686  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
};
#line 692  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
typedef enum irqreturn irqreturn_t;
#line 757  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/interrupt.h"
struct scatterlist;
#line 758 
struct crypto_async_request;
#line 759 
struct crypto_tfm;
#line 760 
struct crypto_type;
#line 152  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
struct crypto_async_request {
   struct list_head list ;
   void (*complete)(struct crypto_async_request *, int ) ;
   void *data ;
   struct crypto_tfm *tfm ;
   u32 flags ;
};
#line 215  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
struct cipher_alg {
   unsigned int cia_min_keysize ;
   unsigned int cia_max_keysize ;
   int (*cia_setkey)(struct crypto_tfm *, u8 *, unsigned int ) ;
   void (*cia_encrypt)(struct crypto_tfm *, u8 *, u8 *) ;
   void (*cia_decrypt)(struct crypto_tfm *, u8 *, u8 *) ;
};
#line 235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
struct compress_alg {
   int (*coa_compress)(struct crypto_tfm *, u8 *, unsigned int , u8 *, unsigned int *) ;
   int (*coa_decompress)(struct crypto_tfm *, u8 *, unsigned int , u8 *, unsigned int *) ;
};
#line 251  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
struct crypto_istat_aead {
   atomic64_t encrypt_cnt ;
   atomic64_t encrypt_tlen ;
   atomic64_t decrypt_cnt ;
   atomic64_t decrypt_tlen ;
   atomic64_t err_cnt ;
};
#line 269  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
struct crypto_istat_akcipher {
   atomic64_t encrypt_cnt ;
   atomic64_t encrypt_tlen ;
   atomic64_t decrypt_cnt ;
   atomic64_t decrypt_tlen ;
   atomic64_t verify_cnt ;
   atomic64_t sign_cnt ;
   atomic64_t err_cnt ;
};
#line 287  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
struct crypto_istat_cipher {
   atomic64_t encrypt_cnt ;
   atomic64_t encrypt_tlen ;
   atomic64_t decrypt_cnt ;
   atomic64_t decrypt_tlen ;
   atomic64_t err_cnt ;
};
#line 303  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
struct crypto_istat_compress {
   atomic64_t compress_cnt ;
   atomic64_t compress_tlen ;
   atomic64_t decompress_cnt ;
   atomic64_t decompress_tlen ;
   atomic64_t err_cnt ;
};
#line 317  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
struct crypto_istat_hash {
   atomic64_t hash_cnt ;
   atomic64_t hash_tlen ;
   atomic64_t err_cnt ;
};
#line 330  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
struct crypto_istat_kpp {
   atomic64_t setsecret_cnt ;
   atomic64_t generate_public_key_cnt ;
   atomic64_t compute_shared_secret_cnt ;
   atomic64_t err_cnt ;
};
#line 344  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
struct crypto_istat_rng {
   atomic64_t generate_cnt ;
   atomic64_t generate_tlen ;
   atomic64_t seed_cnt ;
   atomic64_t err_cnt ;
};
#line 442  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
union __anonunion_cra_u_479 {
   struct cipher_alg cipher ;
   struct compress_alg compress ;
};
#line 442  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
union __anonunion_stats_480 {
   struct crypto_istat_aead aead ;
   struct crypto_istat_akcipher akcipher ;
   struct crypto_istat_cipher cipher ;
   struct crypto_istat_compress compress ;
   struct crypto_istat_hash hash ;
   struct crypto_istat_rng rng ;
   struct crypto_istat_kpp kpp ;
};
#line 442  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
struct crypto_alg {
   struct list_head cra_list ;
   struct list_head cra_users ;
   u32 cra_flags ;
   unsigned int cra_blocksize ;
   unsigned int cra_ctxsize ;
   unsigned int cra_alignmask ;
   int cra_priority ;
   refcount_t cra_refcnt ;
   char cra_name[128U] ;
   char cra_driver_name[128U] ;
   struct crypto_type *cra_type ;
   union __anonunion_cra_u_479 cra_u ;
   int (*cra_init)(struct crypto_tfm *) ;
   void (*cra_exit)(struct crypto_tfm *) ;
   void (*cra_destroy)(struct crypto_alg *) ;
   struct module *cra_module ;
   union __anonunion_stats_480 stats ;
} __attribute__((__aligned__(8)));
#line 602  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
struct cipher_tfm {
   int (*cit_setkey)(struct crypto_tfm *, u8 *, unsigned int ) ;
   void (*cit_encrypt_one)(struct crypto_tfm *, u8 *, u8 *) ;
   void (*cit_decrypt_one)(struct crypto_tfm *, u8 *, u8 *) ;
};
#line 609  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
struct compress_tfm {
   int (*cot_compress)(struct crypto_tfm *, u8 *, unsigned int , u8 *, unsigned int *) ;
   int (*cot_decompress)(struct crypto_tfm *, u8 *, unsigned int , u8 *, unsigned int *) ;
};
#line 621  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
union __anonunion_crt_u_481 {
   struct cipher_tfm cipher ;
   struct compress_tfm compress ;
};
#line 621  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
struct crypto_tfm {
   u32 crt_flags ;
   union __anonunion_crt_u_481 crt_u ;
   void (*exit)(struct crypto_tfm *) ;
   struct crypto_alg *__crt_alg ;
   void *__crt_ctx[] ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/uio.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 30 
struct bio_vec;
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
union __anonunion_482 {
   struct iovec *iov ;
   struct kvec *kvec ;
   struct bio_vec *bvec ;
   struct pipe_inode_info *pipe ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
struct __anonstruct_484 {
   unsigned int head ;
   unsigned int start_head ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
union __anonunion_483 {
   unsigned long nr_segs ;
   struct __anonstruct_484 __anonCompField___anonunion_483_82 ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
struct iov_iter {
   unsigned int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_482 __anonCompField_iov_iter_81 ;
   union __anonunion_483 __anonCompField_iov_iter_83 ;
};
#line 285  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uio.h"
typedef unsigned short __kernel_sa_family_t;
#line 28  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/socket.h"
struct socket;
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 49  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/scatterlist.h"
struct scatterlist {
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
struct __anonstruct_sync_serial_settings_491 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dynamic_queue_limits.h"
typedef struct __anonstruct_sync_serial_settings_491 sync_serial_settings;
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_492 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 45  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_492 te1_settings;
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_493 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_493 raw_hdlc_proto;
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_494 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_494 fr_proto;
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_495 {
   unsigned int dlci ;
};
#line 67  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_495 fr_proto_pvc;
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_496 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_496 fr_proto_pvc_info;
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_497 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_497 cisco_proto;
#line 195  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_498 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_498 ifs_ifsu ;
};
#line 232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_499 {
   char ifrn_name[16U] ;
};
#line 232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_500 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 232  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_499 ifr_ifrn ;
   union __anonunion_ifr_ifru_500 ifr_ifru ;
};
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/compat.h"
typedef s32 compat_long_t;
#line 22  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/compat.h"
typedef u32 compat_uptr_t;
#line 367  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 371  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 18  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bvec.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 201  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/random.h"
enum ldv_10545 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};
#line 209  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/random.h"
typedef enum ldv_10545 socket_state;
#line 94  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   unsigned long flags ;
   struct callback_head rcu ;
} __attribute__((__aligned__(64)));
#line 112 
struct proto_ops;
#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops *ops ;
   struct socket_wq wq ;
};
#line 125 
struct sk_buff;
#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *) ;
   int (*bind)(struct socket *, struct sockaddr *, int ) ;
   int (*connect)(struct socket *, struct sockaddr *, int , int ) ;
   int (*socketpair)(struct socket *, struct socket *) ;
   int (*accept)(struct socket *, struct socket *, int , bool ) ;
   int (*getname)(struct socket *, struct sockaddr *, int ) ;
   __poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *) ;
   int (*ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket *, unsigned int , unsigned long ) ;
   int (*gettstamp)(struct socket *, void *, bool , bool ) ;
   int (*listen)(struct socket *, int ) ;
   int (*shutdown)(struct socket *, int ) ;
   int (*setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*compat_setsockopt)(struct socket *, int , int , char *, unsigned int ) ;
   int (*compat_getsockopt)(struct socket *, int , int , char *, int *) ;
   int (*sendmsg)(struct socket *, struct msghdr *, size_t ) ;
   int (*recvmsg)(struct socket *, struct msghdr *, size_t , int ) ;
   int (*mmap)(struct file *, struct socket *, struct vm_area_struct *) ;
   ssize_t (*sendpage)(struct socket *, struct page *, int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock *, int ) ;
   int (*peek_len)(struct socket *) ;
   int (*read_sock)(struct sock *, read_descriptor_t *, int (*)(read_descriptor_t *, struct sk_buff *, unsigned int , size_t )) ;
   int (*sendpage_locked)(struct sock *, struct page *, int , size_t , int ) ;
   int (*sendmsg_locked)(struct sock *, struct msghdr *, size_t ) ;
   int (*set_rcvlowat)(struct sock *, int ) ;
};
#line 162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 53  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 278  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *) ;
   void (*complete)(struct device *) ;
   int (*suspend)(struct device *) ;
   int (*resume)(struct device *) ;
   int (*freeze)(struct device *) ;
   int (*thaw)(struct device *) ;
   int (*poweroff)(struct device *) ;
   int (*restore)(struct device *) ;
   int (*suspend_late)(struct device *) ;
   int (*resume_early)(struct device *) ;
   int (*freeze_late)(struct device *) ;
   int (*thaw_early)(struct device *) ;
   int (*poweroff_late)(struct device *) ;
   int (*restore_early)(struct device *) ;
   int (*suspend_noirq)(struct device *) ;
   int (*resume_noirq)(struct device *) ;
   int (*freeze_noirq)(struct device *) ;
   int (*thaw_noirq)(struct device *) ;
   int (*poweroff_noirq)(struct device *) ;
   int (*restore_noirq)(struct device *) ;
   int (*runtime_suspend)(struct device *) ;
   int (*runtime_resume)(struct device *) ;
   int (*runtime_idle)(struct device *) ;
};
#line 303 
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
};
#line 310 
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
};
#line 318 
struct wakeup_source;
#line 319 
struct wake_irq;
#line 320 
struct pm_domain_data;
#line 530  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
   struct pm_domain_data *domain_data ;
};
#line 573 
struct dev_pm_qos;
#line 573  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int async_suspend : 1 ;
   bool in_dpm_list : 1 ;
   bool is_prepared : 1 ;
   bool is_suspended : 1 ;
   bool is_noirq_suspended : 1 ;
   bool is_late_suspended : 1 ;
   bool no_pm : 1 ;
   bool early_init : 1 ;
   bool direct_complete : 1 ;
   u32 driver_flags ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path : 1 ;
   bool syscore : 1 ;
   bool no_pm_callbacks : 1 ;
   unsigned int must_resume : 1 ;
   unsigned int may_skip_resume : 1 ;
   struct hrtimer suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int disable_depth : 3 ;
   unsigned int idle_notification : 1 ;
   unsigned int request_pending : 1 ;
   unsigned int deferred_resume : 1 ;
   unsigned int runtime_auto : 1 ;
   bool ignore_children : 1 ;
   unsigned int no_callbacks : 1 ;
   unsigned int irq_safe : 1 ;
   unsigned int use_autosuspend : 1 ;
   unsigned int timer_autosuspends : 1 ;
   unsigned int memalloc_noio : 1 ;
   unsigned int links_count ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   u64 last_busy ;
   u64 active_time ;
   u64 suspended_time ;
   u64 accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device *, s32 ) ;
   struct dev_pm_qos *qos ;
};
#line 650  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   int (*start)(struct device *) ;
   void (*detach)(struct device *, bool ) ;
   int (*activate)(struct device *) ;
   void (*sync)(struct device *) ;
   void (*dismiss)(struct device *) ;
};
#line 5  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/device.h"
struct dev_archdata {
   void *iommu ;
};
#line 12 
struct dma_map_ops;
#line 23 
struct device_driver;
#line 24 
struct driver_private;
#line 25 
struct class;
#line 26 
struct subsys_private;
#line 27 
struct bus_type;
#line 28 
struct iommu_ops;
#line 29 
struct iommu_group;
#line 30 
struct iommu_fwspec;
#line 31 
struct dev_pin_info;
#line 32 
struct iommu_param;
#line 122  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct bus_type {
   char *name ;
   char *dev_name ;
   struct device *dev_root ;
   struct attribute_group **bus_groups ;
   struct attribute_group **dev_groups ;
   struct attribute_group **drv_groups ;
   int (*match)(struct device *, struct device_driver *) ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   int (*probe)(struct device *) ;
   void (*sync_state)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*online)(struct device *) ;
   int (*offline)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   int (*num_vf)(struct device *) ;
   int (*dma_configure)(struct device *) ;
   struct dev_pm_ops *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
   bool need_parent_lock ;
};
#line 164 
struct device_type;
#line 309 
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
};
#line 383 
struct of_device_id;
#line 383 
struct acpi_device_id;
#line 383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct device_driver {
   char *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id *of_match_table ;
   struct acpi_device_id *acpi_match_table ;
   int (*probe)(struct device *) ;
   void (*sync_state)(struct device *) ;
   int (*remove)(struct device *) ;
   void (*shutdown)(struct device *) ;
   int (*suspend)(struct device *, pm_message_t ) ;
   int (*resume)(struct device *) ;
   struct attribute_group **groups ;
   struct attribute_group **dev_groups ;
   struct dev_pm_ops *pm ;
   void (*coredump)(struct device *) ;
   struct driver_private *p ;
};
#line 589  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct class {
   char *name ;
   struct module *owner ;
   struct attribute_group **class_groups ;
   struct attribute_group **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *) ;
   void (*class_release)(struct class *) ;
   void (*dev_release)(struct device *) ;
   int (*shutdown_pre)(struct device *) ;
   struct kobj_ns_type_operations *ns_type ;
   void *(*namespace)(struct device *) ;
   void (*get_ownership)(struct device *, kuid_t *, kgid_t *) ;
   struct dev_pm_ops *pm ;
   struct subsys_private *p ;
};
#line 809  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct device_type {
   char *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *, struct kobj_uevent_env *) ;
   char *(*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *) ;
   void (*release)(struct device *) ;
   struct dev_pm_ops *pm ;
};
#line 1008  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 1139 
enum dl_dev_state {
    DL_DEV_NO_DRIVER = 0,
    DL_DEV_PROBING = 1,
    DL_DEV_DRIVER_BOUND = 2,
    DL_DEV_UNBINDING = 3
};
#line 1164  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct dev_links_info {
   struct list_head suppliers ;
   struct list_head consumers ;
   struct list_head needs_suppliers ;
   struct list_head defer_sync ;
   bool need_for_probe ;
   enum dl_dev_state status ;
};
#line 1259 
struct dma_coherent_mem;
#line 1259 
struct cma;
#line 1259  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
struct device {
   struct kobject kobj ;
   struct device *parent ;
   struct device_private *p ;
   char *init_name ;
   struct device_type *type ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct mutex lockdep_mutex ;
   struct mutex mutex ;
   struct dev_links_info links ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct irq_domain *msi_domain ;
   struct dev_pin_info *pins ;
   struct list_head msi_list ;
   struct dma_map_ops *dma_ops ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   u64 bus_dma_limit ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   int numa_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct class *class ;
   struct attribute_group **groups ;
   void (*release)(struct device *) ;
   struct iommu_group *iommu_group ;
   struct iommu_fwspec *iommu_fwspec ;
   struct iommu_param *iommu_param ;
   bool offline_disabled : 1 ;
   bool offline : 1 ;
   bool of_node_reused : 1 ;
   bool state_synced : 1 ;
};
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pm_wakeup.h"
struct wakeup_source {
   char *name ;
   int id ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   struct device *dev ;
   bool active : 1 ;
   bool autosleep_enabled : 1 ;
};
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-debug.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};
#line 76  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
struct dma_map_ops {
   void *(*alloc)(struct device *, size_t , dma_addr_t *, gfp_t , unsigned long ) ;
   void (*free)(struct device *, size_t , void *, dma_addr_t , unsigned long ) ;
   int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t , size_t , unsigned long ) ;
   int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t , size_t , unsigned long ) ;
   dma_addr_t (*map_page)(struct device *, struct page *, unsigned long , size_t , enum dma_data_direction , unsigned long ) ;
   void (*unmap_page)(struct device *, dma_addr_t , size_t , enum dma_data_direction , unsigned long ) ;
   int (*map_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , unsigned long ) ;
   void (*unmap_sg)(struct device *, struct scatterlist *, int , enum dma_data_direction , unsigned long ) ;
   dma_addr_t (*map_resource)(struct device *, phys_addr_t , size_t , enum dma_data_direction , unsigned long ) ;
   void (*unmap_resource)(struct device *, dma_addr_t , size_t , enum dma_data_direction , unsigned long ) ;
   void (*sync_single_for_cpu)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device *, dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device *, struct scatterlist *, int , enum dma_data_direction ) ;
   void (*cache_sync)(struct device *, void *, size_t , enum dma_data_direction ) ;
   int (*dma_supported)(struct device *, u64 ) ;
   u64 (*get_required_mask)(struct device *) ;
   size_t (*max_mapping_size)(struct device *) ;
   unsigned long (*get_merge_boundary)(struct device *) ;
};
#line 803  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
typedef u64 netdev_features_t;
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/in6.h"
union __anonunion_in6_u_535 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/in6.h"
struct in6_addr {
   union __anonunion_in6_u_535 in6_u ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/in6.h"
struct __anonstruct_siphash_key_t_536 {
   u64 key[2U] ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/in6.h"
typedef struct __anonstruct_siphash_key_t_536 siphash_key_t;
#line 163  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_ether.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
} __attribute__((__packed__));
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pipe_fs_i.h"
struct pipe_buf_operations;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pipe_fs_i.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int head ;
   unsigned int tail ;
   unsigned int max_usage ;
   unsigned int ring_size ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
   struct user_struct *user ;
};
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *) ;
   void (*release)(struct pipe_inode_info *, struct pipe_buffer *) ;
   int (*steal)(struct pipe_inode_info *, struct pipe_buffer *) ;
   bool (*get)(struct pipe_inode_info *, struct pipe_buffer *) ;
};
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netfilter/nf_conntrack_common.h"
struct ip_conntrack_stat {
   unsigned int found ;
   unsigned int invalid ;
   unsigned int ignore ;
   unsigned int insert ;
   unsigned int insert_failed ;
   unsigned int drop ;
   unsigned int early_drop ;
   unsigned int error ;
   unsigned int expect_new ;
   unsigned int expect_create ;
   unsigned int expect_delete ;
   unsigned int search_restart ;
};
#line 42 
struct bpf_prog;
#line 43 
union bpf_attr;
#line 44 
struct skb_ext;
#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 562  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_558 {
   struct net_device *dev ;
   unsigned long dev_scratch ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct __anonstruct_557 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_558 __anonCompField___anonstruct_557_99 ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_556 {
   struct __anonstruct_557 __anonCompField___anonunion_556_100 ;
   struct rb_node rbnode ;
   struct list_head list ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_559 {
   struct sock *sk ;
   int ip_defrag_offset ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_560 {
   ktime_t tstamp ;
   u64 skb_mstamp_ns ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct __anonstruct_562 {
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff *) ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_561 {
   struct __anonstruct_562 __anonCompField___anonunion_561_104 ;
   struct list_head tcp_tsorted_anchor ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct __anonstruct_564 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_563 {
   __wsum csum ;
   struct __anonstruct_564 __anonCompField___anonunion_563_106 ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_565 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_566 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
union __anonunion_567 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion_556 __anonCompField_sk_buff_101 ;
   union __anonunion_559 __anonCompField_sk_buff_102 ;
   union __anonunion_560 __anonCompField_sk_buff_103 ;
   char cb[48U] ;
   union __anonunion_561 __anonCompField_sk_buff_105 ;
   unsigned long _nfct ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   __u8 __cloned_offset[0U] ;
   __u8 cloned : 1 ;
   __u8 nohdr : 1 ;
   __u8 fclone : 2 ;
   __u8 peeked : 1 ;
   __u8 head_frag : 1 ;
   __u8 pfmemalloc : 1 ;
   __u8 active_extensions ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   __u8 pkt_type : 3 ;
   __u8 ignore_df : 1 ;
   __u8 nf_trace : 1 ;
   __u8 ip_summed : 2 ;
   __u8 ooo_okay : 1 ;
   __u8 l4_hash : 1 ;
   __u8 sw_hash : 1 ;
   __u8 wifi_acked_valid : 1 ;
   __u8 wifi_acked : 1 ;
   __u8 no_fcs : 1 ;
   __u8 encapsulation : 1 ;
   __u8 encap_hdr_csum : 1 ;
   __u8 csum_valid : 1 ;
   __u8 __pkt_vlan_present_offset[0U] ;
   __u8 vlan_present : 1 ;
   __u8 csum_complete_sw : 1 ;
   __u8 csum_level : 2 ;
   __u8 csum_not_inet : 1 ;
   __u8 dst_pending_confirm : 1 ;
   __u8 ndisc_nodetype : 2 ;
   __u8 ipvs_property : 1 ;
   __u8 inner_protocol_type : 1 ;
   __u8 remcsum_offload : 1 ;
   __u8 offload_fwd_mark : 1 ;
   __u8 offload_l3_fwd_mark : 1 ;
   __u8 tc_skip_classify : 1 ;
   __u8 tc_at_ingress : 1 ;
   __u8 tc_redirected : 1 ;
   __u8 tc_from_ingress : 1 ;
   __u8 decrypted : 1 ;
   __u16 tc_index ;
   union __anonunion_563 __anonCompField_sk_buff_107 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion_565 __anonCompField_sk_buff_108 ;
   __u32 secmark ;
   union __anonunion_566 __anonCompField_sk_buff_109 ;
   union __anonunion_567 __anonCompField_sk_buff_110 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   refcount_t users ;
   struct skb_ext *extensions ;
};
#line 920 
struct dst_entry;
#line 4108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
struct skb_ext {
   refcount_t refcnt ;
   u8 offset[3U] ;
   u8 chunks ;
   char data[0U] ;
};
#line 177  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 310  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 360  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 382  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 462  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 513  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 541  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 575  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 683  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 702  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 758  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 775  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 793  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 812  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_tcpip6_spec {
   __be32 ip6src[4U] ;
   __be32 ip6dst[4U] ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tclass ;
};
#line 829  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip6_spec {
   __be32 ip6src[4U] ;
   __be32 ip6dst[4U] ;
   __be32 spi ;
   __u8 tclass ;
};
#line 844  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_usrip6_spec {
   __be32 ip6src[4U] ;
   __be32 ip6dst[4U] ;
   __be32 l4_4_bytes ;
   __u8 tclass ;
   __u8 l4_proto ;
};
#line 852  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethtool_tcpip6_spec tcp_ip6_spec ;
   struct ethtool_tcpip6_spec udp_ip6_spec ;
   struct ethtool_tcpip6_spec sctp_ip6_spec ;
   struct ethtool_ah_espip6_spec ah_ip6_spec ;
   struct ethtool_ah_espip6_spec esp_ip6_spec ;
   struct ethtool_usrip6_spec usr_ip6_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 880  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 905  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 1001  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
union __anonunion_593 {
   __u32 rule_cnt ;
   __u32 rss_context ;
};
#line 1001  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   union __anonunion_593 __anonCompField_ethtool_rxnfc_112 ;
   __u32 rule_locs[0U] ;
};
#line 1130  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 1150  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1230  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 1302  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_fecparam {
   __u32 cmd ;
   __u32 active_fec ;
   __u32 fec ;
   __u32 reserved ;
};
#line 1876  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/ethtool.h"
struct ethtool_link_settings {
   __u32 cmd ;
   __u32 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __s8 link_mode_masks_nwords ;
   __u8 transceiver ;
   __u8 reserved1[3U] ;
   __u32 reserved[7U] ;
   __u32 link_mode_masks[0U] ;
};
#line 40  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
};
#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
struct __anonstruct_link_modes_596 {
   unsigned long supported[2U] ;
   unsigned long advertising[2U] ;
   unsigned long lp_advertising[2U] ;
};
#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
struct ethtool_link_ksettings {
   struct ethtool_link_settings base ;
   struct __anonstruct_link_modes_596 link_modes ;
};
#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ethtool.h"
struct ethtool_ops {
   void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *) ;
   int (*get_regs_len)(struct net_device *) ;
   void (*get_regs)(struct net_device *, struct ethtool_regs *, void *) ;
   void (*get_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   int (*set_wol)(struct net_device *, struct ethtool_wolinfo *) ;
   u32 (*get_msglevel)(struct net_device *) ;
   void (*set_msglevel)(struct net_device *, u32 ) ;
   int (*nway_reset)(struct net_device *) ;
   u32 (*get_link)(struct net_device *) ;
   int (*get_eeprom_len)(struct net_device *) ;
   int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *) ;
   void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *) ;
   void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *) ;
   void (*self_test)(struct net_device *, struct ethtool_test *, u64 *) ;
   void (*get_strings)(struct net_device *, u32 , u8 *) ;
   int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
   int (*begin)(struct net_device *) ;
   void (*complete)(struct net_device *) ;
   u32 (*get_priv_flags)(struct net_device *) ;
   int (*set_priv_flags)(struct net_device *, u32 ) ;
   int (*get_sset_count)(struct net_device *, int ) ;
   int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *) ;
   int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *) ;
   int (*flash_device)(struct net_device *, struct ethtool_flash *) ;
   int (*reset)(struct net_device *, u32 *) ;
   u32 (*get_rxfh_key_size)(struct net_device *) ;
   u32 (*get_rxfh_indir_size)(struct net_device *) ;
   int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *) ;
   int (*set_rxfh)(struct net_device *, u32 *, u8 *, u8 ) ;
   int (*get_rxfh_context)(struct net_device *, u32 *, u8 *, u8 *, u32 ) ;
   int (*set_rxfh_context)(struct net_device *, u32 *, u8 *, u8 , u32 *, bool ) ;
   void (*get_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*set_channels)(struct net_device *, struct ethtool_channels *) ;
   int (*get_dump_flag)(struct net_device *, struct ethtool_dump *) ;
   int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *) ;
   int (*set_dump)(struct net_device *, struct ethtool_dump *) ;
   int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *) ;
   int (*get_module_info)(struct net_device *, struct ethtool_modinfo *) ;
   int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *) ;
   int (*get_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*set_eee)(struct net_device *, struct ethtool_eee *) ;
   int (*get_tunable)(struct net_device *, struct ethtool_tunable *, void *) ;
   int (*set_tunable)(struct net_device *, struct ethtool_tunable *, void *) ;
   int (*get_per_queue_coalesce)(struct net_device *, u32 , struct ethtool_coalesce *) ;
   int (*set_per_queue_coalesce)(struct net_device *, u32 , struct ethtool_coalesce *) ;
   int (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *) ;
   int (*set_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *) ;
   int (*get_fecparam)(struct net_device *, struct ethtool_fecparam *) ;
   int (*set_fecparam)(struct net_device *, struct ethtool_fecparam *) ;
   void (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *) ;
};
#line 422 
struct prot_inuse;
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/core.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   int *sock_inuse ;
   struct prot_inuse *prot_inuse ;
};
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct u64_stats_sync {
   };
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct __anonstruct_local_t_597 {
   atomic_long_t a ;
};
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
typedef struct __anonstruct_local_t_597 local_t;
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/local.h"
struct __anonstruct_local64_t_598 {
   local_t a ;
};
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/local.h"
typedef struct __anonstruct_local64_t_598 local64_t;
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/local64.h"
struct __anonstruct_u64_stats_t_599 {
   local64_t v ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/local64.h"
typedef struct __anonstruct_u64_stats_t_599 u64_stats_t;
#line 51  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct ipstats_mib {
   u64 mibs[37U] ;
   struct u64_stats_sync syncp ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 71  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 81  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 92  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[120U] ;
};
#line 110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/snmp.h"
struct linux_tls_mib {
   unsigned long mibs[11U] ;
};
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/mib.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
   struct linux_tls_mib *tls_statistics ;
};
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/unix.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/packet.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct inet_frags;
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct fqdir {
   long high_thresh ;
   long low_thresh ;
   int timeout ;
   int max_dist ;
   struct inet_frags *f ;
   struct net *net ;
   bool dead ;
   struct rhashtable rhashtable ;
   atomic_long_t mem ;
   struct work_struct destroy_work ;
};
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct frag_v4_compare_key {
   __be32 saddr ;
   __be32 daddr ;
   u32 user ;
   u32 vif ;
   __be16 id ;
   u16 protocol ;
};
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct frag_v6_compare_key {
   struct in6_addr saddr ;
   struct in6_addr daddr ;
   u32 user ;
   __be32 id ;
   u32 iif ;
};
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
union __anonunion_key_600 {
   struct frag_v4_compare_key v4 ;
   struct frag_v6_compare_key v6 ;
};
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct inet_frag_queue {
   struct rhash_head node ;
   union __anonunion_key_600 key ;
   struct timer_list timer ;
   spinlock_t lock ;
   refcount_t refcnt ;
   struct rb_root rb_fragments ;
   struct sk_buff *fragments_tail ;
   struct sk_buff *last_run_head ;
   ktime_t stamp ;
   int len ;
   int meat ;
   __u8 flags ;
   u16 max_size ;
   struct fqdir *fqdir ;
   struct callback_head rcu ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/inet_frag.h"
struct inet_frags {
   unsigned int qsize ;
   void (*constructor)(struct inet_frag_queue *, void *) ;
   void (*destructor)(struct inet_frag_queue *) ;
   void (*frag_expire)(struct timer_list *) ;
   struct kmem_cache *frags_cachep ;
   char *frags_cache_name ;
   struct rhashtable_params rhash_params ;
   refcount_t refcnt ;
   struct completion completion ;
};
#line 177 
struct ipv4_devconf;
#line 178 
struct fib_rules_ops;
#line 179 
struct fib_table;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv4.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 31 
struct inet_hashinfo;
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv4.h"
struct inet_timewait_death_row {
   atomic_t tw_count ;
   struct inet_hashinfo *hashinfo ;
   int sysctl_max_tw_buckets ;
};
#line 40 
struct tcp_fastopen_context;
#line 43 
struct ip_ra_chain;
#line 43 
struct inet_peer_base;
#line 43 
struct xt_table;
#line 43 
struct tcp_congestion_ops;
#line 43 
struct fib_notifier_ops;
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct ip_ra_chain *ra_chain ;
   struct mutex ra_mutex ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   unsigned int fib_rules_require_fldissect ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   bool fib_has_custom_local_routes ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct fqdir *fqdir ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_default_ttl ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_fwd_update_priority ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_ip_dynaddr ;
   int sysctl_ip_early_demux ;
   int sysctl_raw_l3mdev_accept ;
   int sysctl_tcp_early_demux ;
   int sysctl_udp_early_demux ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_l3mdev_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_mtu_probe_floor ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_min_snd_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   int sysctl_tcp_keepalive_time ;
   int sysctl_tcp_keepalive_probes ;
   int sysctl_tcp_keepalive_intvl ;
   int sysctl_tcp_syn_retries ;
   int sysctl_tcp_synack_retries ;
   int sysctl_tcp_syncookies ;
   int sysctl_tcp_reordering ;
   int sysctl_tcp_retries1 ;
   int sysctl_tcp_retries2 ;
   int sysctl_tcp_orphan_retries ;
   int sysctl_tcp_fin_timeout ;
   unsigned int sysctl_tcp_notsent_lowat ;
   int sysctl_tcp_tw_reuse ;
   int sysctl_tcp_sack ;
   int sysctl_tcp_window_scaling ;
   int sysctl_tcp_timestamps ;
   int sysctl_tcp_early_retrans ;
   int sysctl_tcp_recovery ;
   int sysctl_tcp_thin_linear_timeouts ;
   int sysctl_tcp_slow_start_after_idle ;
   int sysctl_tcp_retrans_collapse ;
   int sysctl_tcp_stdurg ;
   int sysctl_tcp_rfc1337 ;
   int sysctl_tcp_abort_on_overflow ;
   int sysctl_tcp_fack ;
   int sysctl_tcp_max_reordering ;
   int sysctl_tcp_dsack ;
   int sysctl_tcp_app_win ;
   int sysctl_tcp_adv_win_scale ;
   int sysctl_tcp_frto ;
   int sysctl_tcp_nometrics_save ;
   int sysctl_tcp_moderate_rcvbuf ;
   int sysctl_tcp_tso_win_divisor ;
   int sysctl_tcp_workaround_signed_windows ;
   int sysctl_tcp_limit_output_bytes ;
   int sysctl_tcp_challenge_ack_limit ;
   int sysctl_tcp_min_tso_segs ;
   int sysctl_tcp_min_rtt_wlen ;
   int sysctl_tcp_autocorking ;
   int sysctl_tcp_invalid_ratelimit ;
   int sysctl_tcp_pacing_ss_ratio ;
   int sysctl_tcp_pacing_ca_ratio ;
   int sysctl_tcp_wmem[3U] ;
   int sysctl_tcp_rmem[3U] ;
   int sysctl_tcp_comp_sack_nr ;
   unsigned long sysctl_tcp_comp_sack_delay_ns ;
   struct inet_timewait_death_row tcp_death_row ;
   int sysctl_max_syn_backlog ;
   int sysctl_tcp_fastopen ;
   struct tcp_congestion_ops *tcp_congestion_control ;
   struct tcp_fastopen_context *tcp_fastopen_ctx ;
   spinlock_t tcp_fastopen_ctx_lock ;
   unsigned int sysctl_tcp_fastopen_blackhole_timeout ;
   atomic_t tfo_active_disable_times ;
   unsigned long tfo_active_disable_stamp ;
   int sysctl_udp_wmem_min ;
   int sysctl_udp_rmem_min ;
   int sysctl_udp_l3mdev_accept ;
   int sysctl_igmp_max_memberships ;
   int sysctl_igmp_max_msf ;
   int sysctl_igmp_llm_reports ;
   int sysctl_igmp_qrv ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   int sysctl_ip_prot_sock ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   int sysctl_fib_multipath_use_neigh ;
   int sysctl_fib_multipath_hash_policy ;
   struct fib_notifier_ops *notifier_ops ;
   unsigned int fib_seq ;
   struct fib_notifier_ops *ipmr_notifier_ops ;
   unsigned int ipmr_seq ;
   atomic_t rt_genid ;
   siphash_key_t ip_id_key ;
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dst_ops.h"
struct neighbour;
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dst_ops.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops *) ;
   struct dst_entry *(*check)(struct dst_entry *, __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry *) ;
   unsigned int (*mtu)(struct dst_entry *) ;
   u32 *(*cow_metrics)(struct dst_entry *, unsigned long ) ;
   void (*destroy)(struct dst_entry *) ;
   void (*ifdown)(struct dst_entry *, struct net_device *, int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry *) ;
   void (*link_failure)(struct sk_buff *) ;
   void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32 , bool ) ;
   void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *) ;
   int (*local_out)(struct net *, struct sock *, struct sk_buff *) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry *, struct sk_buff *, void *) ;
   void (*confirm_neigh)(struct dst_entry *, void *) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv6.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int multipath_hash_policy ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int icmpv6_echo_ignore_all ;
   int icmpv6_echo_ignore_multicast ;
   int icmpv6_echo_ignore_anycast ;
   unsigned long icmpv6_ratemask[4U] ;
   unsigned long *icmpv6_ratemask_ptr ;
   int anycast_src_echo_reply ;
   int ip_nonlocal_bind ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
   int flowlabel_reflect ;
   int max_dst_opts_cnt ;
   int max_hbh_opts_cnt ;
   int max_dst_opts_len ;
   int max_hbh_opts_len ;
   int seg6_flowlabel ;
   bool skip_notify_on_dev_down ;
};
#line 56 
struct ipv6_devconf;
#line 56 
struct fib6_info;
#line 56 
struct rt6_info;
#line 56 
struct rt6_statistics;
#line 56 
struct fib6_table;
#line 56 
struct seg6_pernet_data;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv6.h"
struct __anonstruct_ip6addrlbl_table_602 {
   struct hlist_head head ;
   spinlock_t lock ;
   u32 seq ;
};
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct fqdir *fqdir ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct fib6_info *fib6_null_entry ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct list_head fib6_walkers ;
   struct dst_ops ip6_dst_ops ;
   rwlock_t fib6_walker_lock ;
   spinlock_t fib6_gc_lock ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   unsigned int fib6_rules_require_fldissect ;
   bool fib6_has_custom_rules ;
   unsigned int fib6_routes_require_src ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
   struct seg6_pernet_data *seg6_data ;
   struct fib_notifier_ops *notifier_ops ;
   struct fib_notifier_ops *ip6mr_notifier_ops ;
   unsigned int ipmr_seq ;
   struct __anonstruct_ip6addrlbl_table_602 ip6addrlbl_table ;
};
#line 121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct fqdir *fqdir ;
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/nexthop.h"
struct netns_nexthop {
   struct rb_root rb_root ;
   struct hlist_head *devhash ;
   unsigned int seq ;
   u32 last_id_allocated ;
};
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ieee802154_6lowpan.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct fqdir *fqdir ;
};
#line 21 
struct sctp_mib;
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/sctp.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int ps_retrans ;
   int pf_enable ;
   int pf_expose ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int reconf_enable ;
   int auth_enable ;
   int intl_enable ;
   int ecn_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/dccp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/netfilter.h"
struct nf_logger;
#line 76 
struct nf_queue_handler;
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/netfilter.h"
struct nf_hook_entries;
#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_queue_handler *queue_handler ;
   struct nf_logger *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
   struct nf_hook_entries *hooks_ipv4[5U] ;
   struct nf_hook_entries *hooks_ipv6[5U] ;
   struct nf_hook_entries *hooks_arp[3U] ;
   struct nf_hook_entries *hooks_bridge[5U] ;
   struct nf_hook_entries *hooks_decnet[7U] ;
   bool defrag_ipv4 ;
   bool defrag_ipv6 ;
};
#line 37 
struct ebt_table;
#line 10  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/x_tables.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_nulls.h"
struct hlist_nulls_node;
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_nulls.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 21  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_generic_net {
   unsigned int timeout ;
};
#line 25  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_tcp_net {
   unsigned int timeouts[14U] ;
   int tcp_loose ;
   int tcp_be_liberal ;
   int tcp_max_retrans ;
};
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_udp_net {
   unsigned int timeouts[2U] ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_icmp_net {
   unsigned int timeout ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_dccp_net {
   int dccp_loose ;
   unsigned int dccp_timeout[10U] ;
};
#line 54  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_sctp_net {
   unsigned int timeouts[10U] ;
};
#line 66  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_gre_net {
   struct list_head keymap_list ;
   unsigned int timeouts[2U] ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct nf_dccp_net dccp ;
   struct nf_sctp_net sctp ;
   struct nf_gre_net gre ;
};
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
};
#line 95 
struct nf_ct_event_notifier;
#line 95 
struct nf_exp_event_notifier;
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   bool auto_assign_helper_warned ;
   struct ctl_table_header *sysctl_header ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
};
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/nftables.h"
struct netns_nftables {
   struct list_head tables ;
   struct list_head commit_list ;
   struct list_head module_list ;
   struct mutex commit_mutex ;
   unsigned int base_seq ;
   u8 gencursor ;
   u8 validate_state ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/xfrm.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct list_head inexact_bins ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   spinlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
};
#line 79 
struct mpls_route;
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/mpls.h"
struct netns_mpls {
   int ip_ttl_propagate ;
   int default_ttl ;
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
#line 20 
struct can_dev_rcv_lists;
#line 21 
struct can_pkg_stats;
#line 22 
struct can_rcv_lists_stats;
#line 15  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/can.h"
struct netns_can {
   struct proc_dir_entry *proc_dir ;
   struct proc_dir_entry *pde_version ;
   struct proc_dir_entry *pde_stats ;
   struct proc_dir_entry *pde_reset_stats ;
   struct proc_dir_entry *pde_rcvlist_all ;
   struct proc_dir_entry *pde_rcvlist_fil ;
   struct proc_dir_entry *pde_rcvlist_inv ;
   struct proc_dir_entry *pde_rcvlist_sff ;
   struct proc_dir_entry *pde_rcvlist_eff ;
   struct proc_dir_entry *pde_rcvlist_err ;
   struct proc_dir_entry *bcmproc_dir ;
   struct can_dev_rcv_lists *rx_alldev_list ;
   spinlock_t rcvlists_lock ;
   struct timer_list stattimer ;
   struct can_pkg_stats *pkg_stats ;
   struct can_rcv_lists_stats *rcv_lists_stats ;
   struct hlist_head cgw_list ;
};
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netns/xdp.h"
struct netns_xdp {
   struct mutex lock ;
   struct hlist_head list ;
};
#line 12 
struct net_generic;
#line 13 
struct uevent_sock;
#line 14 
struct netns_ipvs;
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/net_namespace.h"
struct net {
   refcount_t passive ;
   refcount_t count ;
   spinlock_t rules_mod_lock ;
   unsigned int dev_unreg_count ;
   unsigned int dev_base_seq ;
   int ifindex ;
   spinlock_t nsid_lock ;
   atomic_t fnhe_genid ;
   struct list_head list ;
   struct list_head exit_list ;
   struct llist_node cleanup_list ;
   struct key_tag *key_domain ;
   struct user_namespace *user_ns ;
   struct ucounts *ucounts ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct list_head dev_base_head ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct uevent_sock *uevent_sock ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   struct raw_notifier_head netdev_chain ;
   u32 hash_mix ;
   struct net_device *loopback_dev ;
   struct list_head rules_ops ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_nexthop nexthop ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct ctl_table_header *nf_frag_frags_hdr ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct list_head nfnl_acct_list ;
   struct list_head nfct_timeout_list ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct bpf_prog *flow_dissector_prog ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct netns_can can ;
   struct netns_xdp xdp ;
   struct sock *crypto_nlsk ;
   struct sock *diag_nlsk ;
} __attribute__((__designated_init__));
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seq_file.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations *op ;
   int poll_event ;
   struct file *file ;
   void *private ;
};
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file *, loff_t *) ;
   void (*stop)(struct seq_file *, void *) ;
   void *(*next)(struct seq_file *, void *, loff_t *) ;
   int (*show)(struct seq_file *, void *) ;
};
#line 275  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/net_namespace.h"
struct __anonstruct_possible_net_t_614 {
   struct net *net ;
};
#line 275  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_614 possible_net_t;
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 78  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
#line 141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 168  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct dcbnl_buffer {
   __u8 prio2buffer[8U] ;
   __u32 buffer_size[8U] ;
   __u32 total_size ;
};
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 207  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 259  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_setets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *) ;
   int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *) ;
   int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *) ;
   int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *) ;
   int (*ieee_getapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_setapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_delapp)(struct net_device *, struct dcb_app *) ;
   int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *) ;
   int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *) ;
   u8 (*getstate)(struct net_device *) ;
   u8 (*setstate)(struct net_device *, u8 ) ;
   void (*getpermhwaddr)(struct net_device *, u8 *) ;
   void (*setpgtccfgtx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device *, int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device *, int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device *, int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgtx)(struct net_device *, int , u8 *) ;
   void (*getpgtccfgrx)(struct net_device *, int , u8 *, u8 *, u8 *, u8 *) ;
   void (*getpgbwgcfgrx)(struct net_device *, int , u8 *) ;
   void (*setpfccfg)(struct net_device *, int , u8 ) ;
   void (*getpfccfg)(struct net_device *, int , u8 *) ;
   u8 (*setall)(struct net_device *) ;
   u8 (*getcap)(struct net_device *, int , u8 *) ;
   int (*getnumtcs)(struct net_device *, int , u8 *) ;
   int (*setnumtcs)(struct net_device *, int , u8 ) ;
   u8 (*getpfcstate)(struct net_device *) ;
   void (*setpfcstate)(struct net_device *, u8 ) ;
   void (*getbcncfg)(struct net_device *, int , u32 *) ;
   void (*setbcncfg)(struct net_device *, int , u32 ) ;
   void (*getbcnrp)(struct net_device *, int , u8 *) ;
   void (*setbcnrp)(struct net_device *, int , u8 ) ;
   int (*setapp)(struct net_device *, u8 , u16 , u8 ) ;
   int (*getapp)(struct net_device *, u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device *, int , u8 *) ;
   u8 (*setfeatcfg)(struct net_device *, int , u8 ) ;
   u8 (*getdcbx)(struct net_device *) ;
   u8 (*setdcbx)(struct net_device *, u8 ) ;
   int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *) ;
   int (*peer_getapptable)(struct net_device *, struct dcb_app *) ;
   int (*cee_peer_getpg)(struct net_device *, struct cee_pg *) ;
   int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *) ;
   int (*dcbnl_getbuffer)(struct net_device *, struct dcbnl_buffer *) ;
   int (*dcbnl_setbuffer)(struct net_device *, struct dcbnl_buffer *) ;
};
#line 41  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/taskstats.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
   __u64 thrashing_count ;
   __u64 thrashing_delay_total ;
};
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct uid_gid_extent {
   u32 first ;
   u32 lower_first ;
   u32 count ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct __anonstruct_616 {
   struct uid_gid_extent *forward ;
   struct uid_gid_extent *reverse ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
union __anonunion_615 {
   struct uid_gid_extent extent[5U] ;
   struct __anonstruct_616 __anonCompField___anonunion_615_113 ;
};
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct uid_gid_map {
   u32 nr_extents ;
   union __anonunion_615 __anonCompField_uid_gid_map_114 ;
};
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct user_namespace {
   struct uid_gid_map uid_map ;
   struct uid_gid_map gid_map ;
   struct uid_gid_map projid_map ;
   atomic_t count ;
   struct user_namespace *parent ;
   int level ;
   kuid_t owner ;
   kgid_t group ;
   struct ns_common ns ;
   unsigned long flags ;
   struct list_head keyring_name_list ;
   struct key *user_keyring_register ;
   struct rw_semaphore keyring_sem ;
   struct key *persistent_keyring_register ;
   struct work_struct work ;
   struct ctl_table_set set ;
   struct ctl_table_header *sysctls ;
   struct ucounts *ucounts ;
   int ucount_max[9U] ;
} __attribute__((__designated_init__));
#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/user_namespace.h"
struct ucounts {
   struct hlist_node node ;
   struct user_namespace *ns ;
   kuid_t uid ;
   int count ;
   atomic_t ucount[9U] ;
};
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct bpf_insn {
   __u8 code ;
   __u8 dst_reg : 4 ;
   __u8 src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct bpf_cgroup_storage_key {
   __u64 cgroup_inode_id ;
   __u32 attach_type ;
};
#line 110 
enum bpf_map_type {
    BPF_MAP_TYPE_UNSPEC = 0,
    BPF_MAP_TYPE_HASH = 1,
    BPF_MAP_TYPE_ARRAY = 2,
    BPF_MAP_TYPE_PROG_ARRAY = 3,
    BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
    BPF_MAP_TYPE_PERCPU_HASH = 5,
    BPF_MAP_TYPE_PERCPU_ARRAY = 6,
    BPF_MAP_TYPE_STACK_TRACE = 7,
    BPF_MAP_TYPE_CGROUP_ARRAY = 8,
    BPF_MAP_TYPE_LRU_HASH = 9,
    BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
    BPF_MAP_TYPE_LPM_TRIE = 11,
    BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
    BPF_MAP_TYPE_HASH_OF_MAPS = 13,
    BPF_MAP_TYPE_DEVMAP = 14,
    BPF_MAP_TYPE_SOCKMAP = 15,
    BPF_MAP_TYPE_CPUMAP = 16,
    BPF_MAP_TYPE_XSKMAP = 17,
    BPF_MAP_TYPE_SOCKHASH = 18,
    BPF_MAP_TYPE_CGROUP_STORAGE = 19,
    BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,
    BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
    BPF_MAP_TYPE_QUEUE = 22,
    BPF_MAP_TYPE_STACK = 23,
    BPF_MAP_TYPE_SK_STORAGE = 24,
    BPF_MAP_TYPE_DEVMAP_HASH = 25
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_618 {
   __u32 map_type ;
   __u32 key_size ;
   __u32 value_size ;
   __u32 max_entries ;
   __u32 map_flags ;
   __u32 inner_map_fd ;
   __u32 numa_node ;
   char map_name[16U] ;
   __u32 map_ifindex ;
   __u32 btf_fd ;
   __u32 btf_key_type_id ;
   __u32 btf_value_type_id ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
union __anonunion_620 {
   __u64 value ;
   __u64 next_key ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_619 {
   __u32 map_fd ;
   __u64 key ;
   union __anonunion_620 __anonCompField___anonstruct_619_117 ;
   __u64 flags ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_621 {
   __u32 prog_type ;
   __u32 insn_cnt ;
   __u64 insns ;
   __u64 license ;
   __u32 log_level ;
   __u32 log_size ;
   __u64 log_buf ;
   __u32 kern_version ;
   __u32 prog_flags ;
   char prog_name[16U] ;
   __u32 prog_ifindex ;
   __u32 expected_attach_type ;
   __u32 prog_btf_fd ;
   __u32 func_info_rec_size ;
   __u64 func_info ;
   __u32 func_info_cnt ;
   __u32 line_info_rec_size ;
   __u64 line_info ;
   __u32 line_info_cnt ;
   __u32 attach_btf_id ;
   __u32 attach_prog_fd ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_622 {
   __u64 pathname ;
   __u32 bpf_fd ;
   __u32 file_flags ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_623 {
   __u32 target_fd ;
   __u32 attach_bpf_fd ;
   __u32 attach_type ;
   __u32 attach_flags ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_test_624 {
   __u32 prog_fd ;
   __u32 retval ;
   __u32 data_size_in ;
   __u32 data_size_out ;
   __u64 data_in ;
   __u64 data_out ;
   __u32 repeat ;
   __u32 duration ;
   __u32 ctx_size_in ;
   __u32 ctx_size_out ;
   __u64 ctx_in ;
   __u64 ctx_out ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
union __anonunion_626 {
   __u32 start_id ;
   __u32 prog_id ;
   __u32 map_id ;
   __u32 btf_id ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_625 {
   union __anonunion_626 __anonCompField___anonstruct_625_122 ;
   __u32 next_id ;
   __u32 open_flags ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_info_627 {
   __u32 bpf_fd ;
   __u32 info_len ;
   __u64 info ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_query_628 {
   __u32 target_fd ;
   __u32 attach_type ;
   __u32 query_flags ;
   __u32 attach_flags ;
   __u64 prog_ids ;
   __u32 prog_cnt ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_raw_tracepoint_629 {
   __u64 name ;
   __u32 prog_fd ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_630 {
   __u64 btf ;
   __u64 btf_log_buf ;
   __u32 btf_size ;
   __u32 btf_log_size ;
   __u32 btf_log_level ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct __anonstruct_task_fd_query_631 {
   __u32 pid ;
   __u32 fd ;
   __u32 flags ;
   __u32 buf_len ;
   __u64 buf ;
   __u32 prog_id ;
   __u32 fd_type ;
   __u64 probe_offset ;
   __u64 probe_addr ;
};
#line 376  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
union bpf_attr {
   struct __anonstruct_618 __anonCompField_bpf_attr_116 ;
   struct __anonstruct_619 __anonCompField_bpf_attr_118 ;
   struct __anonstruct_621 __anonCompField_bpf_attr_119 ;
   struct __anonstruct_622 __anonCompField_bpf_attr_120 ;
   struct __anonstruct_623 __anonCompField_bpf_attr_121 ;
   struct __anonstruct_test_624 test ;
   struct __anonstruct_625 __anonCompField_bpf_attr_123 ;
   struct __anonstruct_info_627 info ;
   struct __anonstruct_query_628 query ;
   struct __anonstruct_raw_tracepoint_629 raw_tracepoint ;
   struct __anonstruct_630 __anonCompField_bpf_attr_124 ;
   struct __anonstruct_task_fd_query_631 task_fd_query ;
} __attribute__((__aligned__(8)));
#line 3653  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct bpf_func_info {
   __u32 insn_off ;
   __u32 type_id ;
};
#line 3661  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/bpf.h"
struct bpf_line_info {
   __u32 insn_off ;
   __u32 file_name_off ;
   __u32 line_off ;
   __u32 line_col ;
};
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/file.h"
struct bpf_prog_aux;
#line 96 
struct bpf_map;
#line 97 
struct btf;
#line 98 
struct btf_type;
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_map_ops {
   int (*map_alloc_check)(union bpf_attr *) ;
   struct bpf_map *(*map_alloc)(union bpf_attr *) ;
   void (*map_release)(struct bpf_map *, struct file *) ;
   void (*map_free)(struct bpf_map *) ;
   int (*map_get_next_key)(struct bpf_map *, void *, void *) ;
   void (*map_release_uref)(struct bpf_map *) ;
   void *(*map_lookup_elem_sys_only)(struct bpf_map *, void *) ;
   void *(*map_lookup_elem)(struct bpf_map *, void *) ;
   int (*map_update_elem)(struct bpf_map *, void *, void *, u64 ) ;
   int (*map_delete_elem)(struct bpf_map *, void *) ;
   int (*map_push_elem)(struct bpf_map *, void *, u64 ) ;
   int (*map_pop_elem)(struct bpf_map *, void *) ;
   int (*map_peek_elem)(struct bpf_map *, void *) ;
   void *(*map_fd_get_ptr)(struct bpf_map *, struct file *, int ) ;
   void (*map_fd_put_ptr)(void *) ;
   u32 (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *) ;
   u32 (*map_fd_sys_lookup_elem)(void *) ;
   void (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *) ;
   int (*map_check_btf)(struct bpf_map *, struct btf *, struct btf_type *, struct btf_type *) ;
   int (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *) ;
   void (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *) ;
   void (*map_poke_run)(struct bpf_map *, u32 , struct bpf_prog *, struct bpf_prog *) ;
   int (*map_direct_value_addr)(struct bpf_map *, u64 *, u32 ) ;
   int (*map_direct_value_meta)(struct bpf_map *, u64 , u32 *) ;
   int (*map_mmap)(struct bpf_map *, struct vm_area_struct *) ;
};
#line 82  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_map_memory {
   u32 pages ;
   struct user_struct *user ;
};
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_map {
   struct bpf_map_ops *ops ;
   struct bpf_map *inner_map_meta ;
   void *security ;
   enum bpf_map_type map_type ;
   u32 key_size ;
   u32 value_size ;
   u32 max_entries ;
   u32 map_flags ;
   int spin_lock_off ;
   u32 id ;
   int numa_node ;
   u32 btf_key_type_id ;
   u32 btf_value_type_id ;
   struct btf *btf ;
   struct bpf_map_memory memory ;
   char name[16U] ;
   bool unpriv_array ;
   bool frozen ;
   atomic64_t refcnt ;
   atomic64_t usercnt ;
   struct work_struct work ;
   struct mutex freeze_mutex ;
   u64 writecnt ;
};
#line 151 
struct bpf_offload_dev;
#line 152 
struct bpf_offloaded_map;
#line 156  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_map_dev_ops {
   int (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *) ;
   int (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *) ;
   int (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64 ) ;
   int (*map_delete_elem)(struct bpf_offloaded_map *, void *) ;
};
#line 166  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_offloaded_map {
   struct bpf_map map ;
   struct net_device *netdev ;
   struct bpf_map_dev_ops *dev_ops ;
   void *dev_priv ;
   struct list_head offloads ;
};
#line 327  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_ops {
   int (*test_run)(struct bpf_prog *, union bpf_attr *, union bpf_attr *) ;
};
#line 369  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_offload {
   struct bpf_prog *prog ;
   struct net_device *netdev ;
   struct bpf_offload_dev *offdev ;
   void *dev_priv ;
   struct list_head offloads ;
   bool dev_state ;
   bool opt_failed ;
   void *jited_image ;
   u32 jited_len ;
};
#line 394  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_stats {
   u64 cnt ;
   u64 nsecs ;
   struct u64_stats_sync syncp ;
} __attribute__((__aligned__(16)));
#line 400  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct btf_func_model {
   u8 ret_size ;
   u8 nr_args ;
   u8 arg_size[12U] ;
};
#line 447 
enum bpf_tramp_prog_type {
    BPF_TRAMP_FENTRY = 0,
    BPF_TRAMP_FEXIT = 1,
    BPF_TRAMP_MAX = 2
};
#line 454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct __anonstruct_func_658 {
   struct btf_func_model model ;
   void *addr ;
   bool ftrace_managed ;
};
#line 454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_trampoline {
   struct hlist_node hlist ;
   struct mutex mutex ;
   refcount_t refcnt ;
   u64 key ;
   struct __anonstruct_func_658 func ;
   struct hlist_head progs_hlist[2U] ;
   int progs_cnt[2U] ;
   void *image ;
   u64 selector ;
};
#line 495  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_func_info_aux {
   bool unreliable ;
};
#line 504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct __anonstruct_tail_call_660 {
   struct bpf_map *map ;
   u32 key ;
};
#line 504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
union __anonunion_659 {
   struct __anonstruct_tail_call_660 tail_call ;
};
#line 504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_jit_poke_descriptor {
   void *ip ;
   union __anonunion_659 __anonCompField_bpf_jit_poke_descriptor_149 ;
   bool ip_stable ;
   u8 adj_off ;
   u16 reason ;
};
#line 517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
union __anonunion_661 {
   struct work_struct work ;
   struct callback_head rcu ;
};
#line 517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_aux {
   atomic64_t refcnt ;
   u32 used_map_cnt ;
   u32 max_ctx_offset ;
   u32 max_pkt_offset ;
   u32 max_tp_access ;
   u32 stack_depth ;
   u32 id ;
   u32 func_cnt ;
   u32 func_idx ;
   u32 attach_btf_id ;
   struct bpf_prog *linked_prog ;
   bool verifier_zext ;
   bool offload_requested ;
   bool attach_btf_trace ;
   bool func_proto_unreliable ;
   enum bpf_tramp_prog_type trampoline_prog_type ;
   struct bpf_trampoline *trampoline ;
   struct hlist_node tramp_hlist ;
   struct btf_type *attach_func_proto ;
   char *attach_func_name ;
   struct bpf_prog **func ;
   void *jit_data ;
   struct bpf_jit_poke_descriptor *poke_tab ;
   u32 size_poke_tab ;
   struct latch_tree_node ksym_tnode ;
   struct list_head ksym_lnode ;
   struct bpf_prog_ops *ops ;
   struct bpf_map **used_maps ;
   struct bpf_prog *prog ;
   struct user_struct *user ;
   u64 load_time ;
   struct bpf_map *cgroup_storage[2U] ;
   char name[16U] ;
   void *security ;
   struct bpf_prog_offload *offload ;
   struct btf *btf ;
   struct bpf_func_info *func_info ;
   struct bpf_func_info_aux *func_info_aux ;
   struct bpf_line_info *linfo ;
   void **jited_linfo ;
   u32 func_info_cnt ;
   u32 nr_linfo ;
   u32 linfo_idx ;
   u32 num_exentries ;
   struct exception_table_entry *extable ;
   struct bpf_prog_stats *stats ;
   union __anonunion_661 __anonCompField_bpf_prog_aux_150 ;
};
#line 686 
struct bpf_cgroup_storage;
#line 686  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_array_item {
   struct bpf_prog *prog ;
   struct bpf_cgroup_storage *cgroup_storage[2U] ;
};
#line 691  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf.h"
struct bpf_prog_array {
   struct callback_head rcu ;
   struct bpf_prog_array_item items[0U] ;
};
#line 1335 
struct cgroup;
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
struct bpf_cgroup_storage_map;
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
struct bpf_storage_buffer {
   struct callback_head rcu ;
   char data[0U] ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
union __anonunion_663 {
   struct bpf_storage_buffer *buf ;
   void *percpu_buf ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
struct bpf_cgroup_storage {
   union __anonunion_663 __anonCompField_bpf_cgroup_storage_152 ;
   struct bpf_cgroup_storage_map *map ;
   struct bpf_cgroup_storage_key key ;
   struct list_head list ;
   struct rb_node node ;
   struct callback_head rcu ;
};
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/bpf-cgroup.h"
struct cgroup_bpf {
   struct bpf_prog_array *effective[26U] ;
   struct list_head progs[26U] ;
   u32 flags[26U] ;
   struct bpf_prog_array *inactive ;
   struct percpu_ref refcnt ;
   struct work_struct release_work ;
};
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kthread.h"
struct kthread_work;
#line 86  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kthread.h"
struct kthread_worker {
   unsigned int flags ;
   raw_spinlock_t lock ;
   struct list_head work_list ;
   struct list_head delayed_work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work *) ;
   struct kthread_worker *worker ;
   int canceling ;
};
#line 103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kthread.h"
struct kthread_delayed_work {
   struct kthread_work work ;
   struct timer_list timer ;
};
#line 199 
struct cgroup_subsys_state;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/psi_types.h"
struct psi_group_cpu {
   seqcount_t seq ;
   unsigned int tasks[3U] ;
   u32 state_mask ;
   u32 times[6U] ;
   u64 state_start ;
   u32 times_prev[2U][6U] ;
};
#line 96 
struct psi_group;
#line 128  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/psi_types.h"
struct psi_group {
   struct mutex avgs_lock ;
   struct psi_group_cpu *pcpu ;
   u64 avg_total[5U] ;
   u64 avg_last_update ;
   u64 avg_next_update ;
   struct delayed_work avgs_work ;
   u64 total[2U][5U] ;
   unsigned long avg[5U][3U] ;
   atomic_t poll_scheduled ;
   struct kthread_worker *poll_kworker ;
   struct kthread_delayed_work poll_work ;
   struct mutex trigger_lock ;
   struct list_head triggers ;
   u32 nr_triggers[5U] ;
   u32 poll_states ;
   u64 poll_min_period ;
   u64 polling_total[5U] ;
   u64 polling_next_update ;
   u64 polling_until ;
};
#line 166 
struct cgroup_root;
#line 167 
struct cgroup_subsys;
#line 168 
struct cgroup_taskset;
#line 119  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_file {
   struct kernfs_node *kn ;
   unsigned long notified_at ;
   struct timer_list notify_timer ;
};
#line 133  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct list_head sibling ;
   struct list_head children ;
   struct list_head rstat_css_node ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   atomic_t online_cnt ;
   struct work_struct destroy_work ;
   struct rcu_work destroy_rwork ;
   struct cgroup_subsys_state *parent ;
};
#line 190  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct css_set {
   struct cgroup_subsys_state *subsys[14U] ;
   refcount_t refcount ;
   struct css_set *dom_cset ;
   struct cgroup *dfl_cgrp ;
   int nr_tasks ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head dying_tasks ;
   struct list_head task_iters ;
   struct list_head e_cset_node[14U] ;
   struct list_head threaded_csets ;
   struct list_head threaded_csets_node ;
   struct hlist_node hlist ;
   struct list_head cgrp_links ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct cgroup *mg_dst_cgrp ;
   struct css_set *mg_dst_cset ;
   bool dead ;
   struct callback_head callback_head ;
};
#line 279  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_base_stat {
   struct task_cputime cputime ;
};
#line 303  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_rstat_cpu {
   struct u64_stats_sync bsync ;
   struct cgroup_base_stat bstat ;
   struct cgroup_base_stat last_bstat ;
   struct cgroup *updated_children ;
   struct cgroup *updated_next ;
};
#line 332  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_freezer_state {
   bool freeze ;
   int e_freeze ;
   int nr_frozen_descendants ;
   int nr_frozen_tasks ;
};
#line 351  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int level ;
   int max_depth ;
   int nr_descendants ;
   int nr_dying_descendants ;
   int max_descendants ;
   int nr_populated_csets ;
   int nr_populated_domain_children ;
   int nr_populated_threaded_children ;
   int nr_threaded_children ;
   struct kernfs_node *kn ;
   struct cgroup_file procs_file ;
   struct cgroup_file events_file ;
   u16 subtree_control ;
   u16 subtree_ss_mask ;
   u16 old_subtree_control ;
   u16 old_subtree_ss_mask ;
   struct cgroup_subsys_state *subsys[14U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[14U] ;
   struct cgroup *dom_cgrp ;
   struct cgroup *old_dom_cgrp ;
   struct cgroup_rstat_cpu *rstat_cpu ;
   struct list_head rstat_css_list ;
   struct cgroup_base_stat last_bstat ;
   struct cgroup_base_stat bstat ;
   struct prev_cputime prev_cputime ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
   struct psi_group psi ;
   struct cgroup_bpf bpf ;
   atomic_t congestion_count ;
   struct cgroup_freezer_state freezer ;
   u64 ancestor_ids[] ;
};
#line 489  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   u64 cgrp_ancestor_id_storage ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 527  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   unsigned long private ;
   size_t max_write_len ;
   unsigned int flags ;
   unsigned int file_offset ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   int (*open)(struct kernfs_open_file *) ;
   void (*release)(struct kernfs_open_file *) ;
   u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *) ;
   s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *) ;
   int (*seq_show)(struct seq_file *, void *) ;
   void *(*seq_start)(struct seq_file *, loff_t *) ;
   void *(*seq_next)(struct seq_file *, void *, loff_t *) ;
   void (*seq_stop)(struct seq_file *, void *) ;
   int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64 ) ;
   ssize_t (*write)(struct kernfs_open_file *, char *, size_t , loff_t ) ;
   __poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *) ;
   struct lock_class_key lockdep_key ;
};
#line 616  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *) ;
   int (*css_online)(struct cgroup_subsys_state *) ;
   void (*css_offline)(struct cgroup_subsys_state *) ;
   void (*css_released)(struct cgroup_subsys_state *) ;
   void (*css_free)(struct cgroup_subsys_state *) ;
   void (*css_reset)(struct cgroup_subsys_state *) ;
   void (*css_rstat_flush)(struct cgroup_subsys_state *, int ) ;
   int (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *) ;
   int (*can_attach)(struct cgroup_taskset *) ;
   void (*cancel_attach)(struct cgroup_taskset *) ;
   void (*attach)(struct cgroup_taskset *) ;
   void (*post_attach)(void) ;
   int (*can_fork)(struct task_struct *) ;
   void (*cancel_fork)(struct task_struct *) ;
   void (*fork)(struct task_struct *) ;
   void (*exit)(struct task_struct *) ;
   void (*release)(struct task_struct *) ;
   void (*bind)(struct cgroup_subsys_state *) ;
   bool early_init : 1 ;
   bool implicit_on_dfl : 1 ;
   bool threaded : 1 ;
   bool broken_hierarchy : 1 ;
   bool warned_broken_hierarchy : 1 ;
   int id ;
   char *name ;
   char *legacy_name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 848  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cgroup.h"
struct cgroup_namespace {
   refcount_t count ;
   struct ns_common ns ;
   struct user_namespace *user_ns ;
   struct ucounts *ucounts ;
   struct css_set *root_cset ;
};
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/netprio_cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
struct xdp_mem_info {
   u32 type ;
   u32 id ;
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
struct xdp_rxq_info {
   struct net_device *dev ;
   u32 queue_index ;
   u32 reg_state ;
   struct xdp_mem_info mem ;
} __attribute__((__aligned__(64)));
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/xdp.h"
struct xdp_frame {
   void *data ;
   u16 len ;
   u16 headroom ;
   u16 metasize ;
   struct xdp_mem_info mem ;
   struct net_device *dev_rx ;
};
#line 175 
struct netdev_bpf;
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/security.h"
struct xfrm_state;
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 211  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netlink.h"
struct netlink_ext_ack {
   char *_msg ;
   struct nlattr *bad_attr ;
   u8 cookie[20U] ;
   u8 cookie_len ;
};
#line 180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netlink.h"
union __anonunion_682 {
   u8 ctx[48U] ;
   long args[6U] ;
};
#line 180  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr *nlh ;
   int (*dump)(struct sk_buff *, struct netlink_callback *) ;
   int (*done)(struct netlink_callback *) ;
   void *data ;
   struct module *module ;
   struct netlink_ext_ack *extack ;
   u16 family ;
   u16 min_dump_alloc ;
   bool strict_check ;
   u16 answer_flags ;
   unsigned int prev_seq ;
   unsigned int seq ;
   union __anonunion_682 __anonCompField_netlink_callback_155 ;
};
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/neighbour.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
   __u64 rx_nohandler ;
};
#line 753  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/if_link.h"
struct ifla_vf_guid {
   __u32 vf ;
   __u64 guid ;
};
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
};
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
   __u32 trusted ;
   __be16 vlan_proto ;
};
#line 118  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/hashtable.h"
struct netpoll_info;
#line 119 
struct phy_device;
#line 120 
struct dsa_port;
#line 121 
struct sfp_bus;
#line 122 
struct wireless_dev;
#line 123 
struct wpan_dev;
#line 124 
struct mpls_dev;
#line 125 
struct udp_tunnel_info;
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = -2147483648,
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 195 
struct neigh_parms;
#line 217  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 237  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct hh_cache {
   unsigned int hh_len ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 263  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff *, struct net_device *, unsigned short , void *, void *, unsigned int ) ;
   int (*parse)(struct sk_buff *, unsigned char *) ;
   int (*cache)(struct neighbour *, struct hh_cache *, __be16 ) ;
   void (*cache_update)(struct hh_cache *, struct net_device *, unsigned char *) ;
   bool (*validate)(char *, unsigned int ) ;
   __be16 (*parse_protocol)(struct sk_buff *) ;
};
#line 372 
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
};
#line 379  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 421  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);
#line 589 
struct Qdisc;
#line 589 
struct xdp_umem;
#line 589  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   unsigned long tx_maxrate ;
   unsigned long trans_timeout ;
   struct net_device *sb_dev ;
   struct xdp_umem *umem ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long state ;
   struct dql dql ;
} __attribute__((__aligned__(64)));
#line 662  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 674  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 684  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 736  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
   struct xdp_rxq_info xdp_rxq ;
   struct xdp_umem *umem ;
} __attribute__((__aligned__(64)));
#line 764  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 777  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *attr_map[0U] ;
};
#line 793  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 803  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 820  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 833 
enum tc_setup_type {
    TC_SETUP_QDISC_MQPRIO = 0,
    TC_SETUP_CLSU32 = 1,
    TC_SETUP_CLSFLOWER = 2,
    TC_SETUP_CLSMATCHALL = 3,
    TC_SETUP_CLSBPF = 4,
    TC_SETUP_BLOCK = 5,
    TC_SETUP_QDISC_CBS = 6,
    TC_SETUP_QDISC_RED = 7,
    TC_SETUP_QDISC_PRIO = 8,
    TC_SETUP_QDISC_MQ = 9,
    TC_SETUP_QDISC_ETF = 10,
    TC_SETUP_ROOT_QDISC = 11,
    TC_SETUP_QDISC_GRED = 12,
    TC_SETUP_QDISC_TAPRIO = 13,
    TC_SETUP_FT = 14
};
#line 851 
enum bpf_netdev_command {
    XDP_SETUP_PROG = 0,
    XDP_SETUP_PROG_HW = 1,
    XDP_QUERY_PROG = 2,
    XDP_QUERY_PROG_HW = 3,
    BPF_OFFLOAD_MAP_ALLOC = 4,
    BPF_OFFLOAD_MAP_FREE = 5,
    XDP_SETUP_XSK_UMEM = 6
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_687 {
   u32 flags ;
   struct bpf_prog *prog ;
   struct netlink_ext_ack *extack ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_688 {
   u32 prog_id ;
   u32 prog_flags ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_689 {
   struct bpf_offloaded_map *offmap ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_xsk_690 {
   struct xdp_umem *umem ;
   u16 queue_id ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
union __anonunion_686 {
   struct __anonstruct_687 __anonCompField___anonunion_686_157 ;
   struct __anonstruct_688 __anonCompField___anonunion_686_158 ;
   struct __anonstruct_689 __anonCompField___anonunion_686_159 ;
   struct __anonstruct_xsk_690 xsk ;
};
#line 879  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_bpf {
   enum bpf_netdev_command command ;
   union __anonunion_686 __anonCompField_netdev_bpf_160 ;
};
#line 911  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct xfrmdev_ops {
   int (*xdo_dev_state_add)(struct xfrm_state *) ;
   void (*xdo_dev_state_delete)(struct xfrm_state *) ;
   void (*xdo_dev_state_free)(struct xfrm_state *) ;
   bool (*xdo_dev_offload_ok)(struct sk_buff *, struct xfrm_state *) ;
   void (*xdo_dev_state_advance_esn)(struct xfrm_state *) ;
};
#line 921  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct dev_ifalias {
   struct callback_head rcuhead ;
   char ifalias[] ;
};
#line 926 
struct tlsdev_ops;
#line 929  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct netdev_name_node {
   struct hlist_node hlist ;
   struct list_head list ;
   struct net_device *dev ;
   char *name ;
};
#line 1257 
struct devlink_port;
#line 1257  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device *) ;
   void (*ndo_uninit)(struct net_device *) ;
   int (*ndo_open)(struct net_device *) ;
   int (*ndo_stop)(struct net_device *) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t ) ;
   u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *) ;
   void (*ndo_change_rx_flags)(struct net_device *, int ) ;
   void (*ndo_set_rx_mode)(struct net_device *) ;
   int (*ndo_set_mac_address)(struct net_device *, void *) ;
   int (*ndo_validate_addr)(struct net_device *) ;
   int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int ) ;
   int (*ndo_set_config)(struct net_device *, struct ifmap *) ;
   int (*ndo_change_mtu)(struct net_device *, int ) ;
   int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *) ;
   void (*ndo_tx_timeout)(struct net_device *) ;
   void (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *) ;
   bool (*ndo_has_offload_stats)(struct net_device *, int ) ;
   int (*ndo_get_offload_stats)(int , struct net_device *, void *) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device *) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device *) ;
   int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *) ;
   void (*ndo_netpoll_cleanup)(struct net_device *) ;
   int (*ndo_set_vf_mac)(struct net_device *, int , u8 *) ;
   int (*ndo_set_vf_vlan)(struct net_device *, int , u16 , u8 , __be16 ) ;
   int (*ndo_set_vf_rate)(struct net_device *, int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device *, int , bool ) ;
   int (*ndo_set_vf_trust)(struct net_device *, int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device *, int , struct ifla_vf_info *) ;
   int (*ndo_set_vf_link_state)(struct net_device *, int , int ) ;
   int (*ndo_get_vf_stats)(struct net_device *, int , struct ifla_vf_stats *) ;
   int (*ndo_set_vf_port)(struct net_device *, int , struct nlattr **) ;
   int (*ndo_get_vf_port)(struct net_device *, int , struct sk_buff *) ;
   int (*ndo_get_vf_guid)(struct net_device *, int , struct ifla_vf_guid *, struct ifla_vf_guid *) ;
   int (*ndo_set_vf_guid)(struct net_device *, int , u64 , int ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device *, int , bool ) ;
   int (*ndo_setup_tc)(struct net_device *, enum tc_setup_type , void *) ;
   int (*ndo_fcoe_enable)(struct net_device *) ;
   int (*ndo_fcoe_disable)(struct net_device *) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device *, u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device *, u16 , struct scatterlist *, unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *) ;
   int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int ) ;
   int (*ndo_rx_flow_steer)(struct net_device *, struct sk_buff *, u16 , u32 ) ;
   int (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *) ;
   int (*ndo_del_slave)(struct net_device *, struct net_device *) ;
   netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device *, netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct net_device *, struct neighbour *) ;
   void (*ndo_neigh_destroy)(struct net_device *, struct neighbour *) ;
   int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char *, u16 , u16 , struct netlink_ext_ack *) ;
   int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, unsigned char *, u16 ) ;
   int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *) ;
   int (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, unsigned char *, u16 , u32 , u32 , struct netlink_ext_ack *) ;
   int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16 , struct netlink_ext_ack *) ;
   int (*ndo_bridge_getlink)(struct sk_buff *, u32 , u32 , struct net_device *, u32 , int ) ;
   int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16 ) ;
   int (*ndo_change_carrier)(struct net_device *, bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *) ;
   int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t ) ;
   void (*ndo_udp_tunnel_add)(struct net_device *, struct udp_tunnel_info *) ;
   void (*ndo_udp_tunnel_del)(struct net_device *, struct udp_tunnel_info *) ;
   void *(*ndo_dfwd_add_station)(struct net_device *, struct net_device *) ;
   void (*ndo_dfwd_del_station)(struct net_device *, void *) ;
   int (*ndo_set_tx_maxrate)(struct net_device *, int , u32 ) ;
   int (*ndo_get_iflink)(struct net_device *) ;
   int (*ndo_change_proto_down)(struct net_device *, bool ) ;
   int (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *) ;
   void (*ndo_set_rx_headroom)(struct net_device *, int ) ;
   int (*ndo_bpf)(struct net_device *, struct netdev_bpf *) ;
   int (*ndo_xdp_xmit)(struct net_device *, int , struct xdp_frame **, u32 ) ;
   int (*ndo_xsk_wakeup)(struct net_device *, u32 , u32 ) ;
   struct devlink_port *(*ndo_get_devlink_port)(struct net_device *) ;
};
#line 1492 
enum ldv_14843 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
};
#line 1501 
enum ldv_14844 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
};
#line 1795  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct __anonstruct_adj_list_691 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1795 
struct iw_handler_def;
#line 1795 
struct iw_public_data;
#line 1795 
struct l3mdev_ops;
#line 1795 
struct ndisc_ops;
#line 1795 
struct vlan_info;
#line 1795 
struct tipc_bearer;
#line 1795 
struct in_device;
#line 1795 
struct dn_dev;
#line 1795 
struct inet6_dev;
#line 1795 
struct mini_Qdisc;
#line 1795 
struct cpu_rmap;
#line 1795 
struct pcpu_lstats;
#line 1795 
struct pcpu_sw_netstats;
#line 1795 
struct pcpu_dstats;
#line 1795  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
union __anonunion_692 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
};
#line 1795 
struct garp_port;
#line 1795 
struct mrp_port;
#line 1795 
struct rtnl_link_ops;
#line 1795  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct netdev_name_node *name_node ;
   struct dev_ifalias *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_691 adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   netdev_features_t gso_partial_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   atomic_long_t rx_nohandler ;
   atomic_t carrier_up_count ;
   atomic_t carrier_down_count ;
   struct iw_handler_def *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops *netdev_ops ;
   struct ethtool_ops *ethtool_ops ;
   struct l3mdev_ops *l3mdev_ops ;
   struct ndisc_ops *ndisc_ops ;
   struct xfrmdev_ops *xfrmdev_ops ;
   struct tlsdev_ops *tlsdev_ops ;
   struct header_ops *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned int min_mtu ;
   unsigned int max_mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned char min_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned char upper_level ;
   unsigned char lower_level ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_port *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   struct bpf_prog *xdp_prog ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct mini_Qdisc *miniq_ingress ;
   struct netdev_queue *ingress_queue ;
   struct nf_hook_entries *nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   struct hlist_head qdisc_hash[16U] ;
   unsigned int tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_cpus_map ;
   struct xps_dev_maps *xps_rxqs_map ;
   struct mini_Qdisc *miniq_egress ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   enum ldv_14843 reg_state : 8 ;
   bool dismantle ;
   enum ldv_14844 rtnl_link_state : 16 ;
   bool needs_free_netdev ;
   void (*priv_destructor)(struct net_device *) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion_692 __anonCompField_net_device_161 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group *sysfs_groups[4U] ;
   struct attribute_group *sysfs_rx_queue_group ;
   struct rtnl_link_ops *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   struct dcbnl_rtnl_ops *dcbnl_ops ;
   s16 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct sfp_bus *sfp_bus ;
   struct lock_class_key qdisc_tx_busylock_key ;
   struct lock_class_key qdisc_running_key ;
   struct lock_class_key qdisc_xmit_lock_key ;
   struct lock_class_key addr_list_lock_key ;
   bool proto_down ;
   unsigned int wol_enabled : 1 ;
};
#line 2400  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
} __attribute__((__aligned__(32)));
#line 2408  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
struct pcpu_lstats {
   u64_stats_t packets ;
   u64_stats_t bytes ;
   struct u64_stats_sync syncp ;
} __attribute__((__aligned__(16)));
#line 3610 
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
};
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/if_arp.h"
typedef unsigned long kernel_ulong_t;
#line 38  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
   __u32 cls ;
   __u32 cls_msk ;
};
#line 260  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void *data ;
};
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct hotplug_slot;
#line 62  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 99  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef int pci_power_t;
#line 153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 162 
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
};
#line 181  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 207  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 282 
struct pcie_link_state;
#line 283 
struct pci_vpd;
#line 284 
struct pci_sriov;
#line 285 
struct pci_p2pdma;
#line 290 
struct aer_stats;
#line 290 
struct pci_driver;
#line 290  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
union __anonunion_704 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 290  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u16 aer_cap ;
   struct aer_stats *aer_stats ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   unsigned long *dma_alias_mask ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   unsigned int imm_ready : 1 ;
   u8 pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int pme_poll : 1 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   unsigned int no_d3cold : 1 ;
   unsigned int bridge_d3 : 1 ;
   unsigned int d3cold_allowed : 1 ;
   unsigned int mmio_always_on : 1 ;
   unsigned int wakeup_prepared : 1 ;
   unsigned int runtime_d3cold : 1 ;
   unsigned int skip_bus_pm : 1 ;
   unsigned int ignore_hotplug : 1 ;
   unsigned int hotplug_user_indicators : 1 ;
   unsigned int clear_retrain_link : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   unsigned int ltr_path : 1 ;
   unsigned int eetlp_prefix_path : 1 ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int transparent : 1 ;
   unsigned int io_window : 1 ;
   unsigned int pref_window : 1 ;
   unsigned int pref_64_window : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int no_64bit_msi : 1 ;
   unsigned int block_cfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int ats_enabled : 1 ;
   unsigned int pasid_enabled : 1 ;
   unsigned int pri_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int needs_freset : 1 ;
   unsigned int state_saved : 1 ;
   unsigned int is_physfn : 1 ;
   unsigned int is_virtfn : 1 ;
   unsigned int reset_fn : 1 ;
   unsigned int is_hotplug_bridge : 1 ;
   unsigned int shpc_managed : 1 ;
   unsigned int is_thunderbolt : 1 ;
   unsigned int untrusted : 1 ;
   unsigned int __aer_firmware_first_valid : 1 ;
   unsigned int __aer_firmware_first : 1 ;
   unsigned int broken_intx_masking : 1 ;
   unsigned int io_window_1k : 1 ;
   unsigned int irq_managed : 1 ;
   unsigned int non_compliant_bars : 1 ;
   unsigned int is_probed : 1 ;
   unsigned int link_active_reporting : 1 ;
   unsigned int no_vf_scan : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   unsigned int broken_cmd_compl : 1 ;
   unsigned int ptm_root : 1 ;
   unsigned int ptm_enabled : 1 ;
   u8 ptm_granularity ;
   struct attribute_group **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion_704 __anonCompField_pci_dev_162 ;
   u16 ats_cap ;
   u8 ats_stu ;
   u16 pri_cap ;
   u32 pri_reqs_alloc ;
   unsigned int pasid_required : 1 ;
   u16 pasid_cap ;
   u16 pasid_features ;
   struct pci_p2pdma *p2pdma ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
   unsigned long priv_flags ;
};
#line 493 
struct pci_ops;
#line 493 
struct msi_controller;
#line 571  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
#line 697  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_ops {
   int (*add_bus)(struct pci_bus *) ;
   void (*remove_bus)(struct pci_bus *) ;
   void *(*map_bus)(struct pci_bus *, unsigned int , int ) ;
   int (*read)(struct pci_bus *, unsigned int , int , int , u32 *) ;
   int (*write)(struct pci_bus *, unsigned int , int , int , u32 ) ;
};
#line 725  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 729  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 761  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *, enum pci_channel_state ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *) ;
   void (*reset_prepare)(struct pci_dev *) ;
   void (*reset_done)(struct pci_dev *) ;
   void (*resume)(struct pci_dev *) ;
};
#line 824  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char *name ;
   struct pci_device_id *id_table ;
   int (*probe)(struct pci_dev *, struct pci_device_id *) ;
   void (*remove)(struct pci_dev *) ;
   int (*suspend)(struct pci_dev *, pm_message_t ) ;
   int (*resume)(struct pci_dev *) ;
   void (*shutdown)(struct pci_dev *) ;
   int (*sriov_configure)(struct pci_dev *, int ) ;
   struct pci_error_handlers *err_handler ;
   struct attribute_group **groups ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/crypto/skcipher.h"
struct skcipher_request {
   unsigned int cryptlen ;
   u8 *iv ;
   struct scatterlist *src ;
   struct scatterlist *dst ;
   struct crypto_async_request base ;
   void *__ctx[] ;
};
#line 37  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/crypto/skcipher.h"
struct crypto_skcipher {
   int (*setkey)(struct crypto_skcipher *, u8 *, unsigned int ) ;
   int (*encrypt)(struct skcipher_request *) ;
   int (*decrypt)(struct skcipher_request *) ;
   unsigned int ivsize ;
   unsigned int reqsize ;
   unsigned int keysize ;
   struct crypto_tfm base ;
};
#line 50  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/crypto/skcipher.h"
struct crypto_sync_skcipher {
   struct crypto_skcipher base ;
};
#line 811  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/debugfs.h"
enum nl80211_iftype {
    NL80211_IFTYPE_UNSPECIFIED = 0,
    NL80211_IFTYPE_ADHOC = 1,
    NL80211_IFTYPE_STATION = 2,
    NL80211_IFTYPE_AP = 3,
    NL80211_IFTYPE_AP_VLAN = 4,
    NL80211_IFTYPE_WDS = 5,
    NL80211_IFTYPE_MONITOR = 6,
    NL80211_IFTYPE_MESH_POINT = 7,
    NL80211_IFTYPE_P2P_CLIENT = 8,
    NL80211_IFTYPE_P2P_GO = 9,
    NL80211_IFTYPE_P2P_DEVICE = 10,
    NL80211_IFTYPE_OCB = 11,
    NL80211_IFTYPE_NAN = 12,
    NUM_NL80211_IFTYPES = 13,
    NL80211_IFTYPE_MAX = 12
};
#line 3263  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/nl80211.h"
enum nl80211_reg_initiator {
    NL80211_REGDOM_SET_BY_CORE = 0,
    NL80211_REGDOM_SET_BY_USER = 1,
    NL80211_REGDOM_SET_BY_DRIVER = 2,
    NL80211_REGDOM_SET_BY_COUNTRY_IE = 3
};
#line 3320 
enum nl80211_dfs_regions {
    NL80211_DFS_UNSET = 0,
    NL80211_DFS_FCC = 1,
    NL80211_DFS_ETSI = 2,
    NL80211_DFS_JP = 3
};
#line 3327 
enum nl80211_user_reg_hint_type {
    NL80211_USER_REG_HINT_USER = 0,
    NL80211_USER_REG_HINT_CELL_BASE = 1,
    NL80211_USER_REG_HINT_INDOOR = 2
};
#line 3446 
enum nl80211_key_mode {
    NL80211_KEY_RX_TX = 0,
    NL80211_KEY_NO_TX = 1,
    NL80211_KEY_SET_TX = 2
};
#line 3452 
enum nl80211_chan_width {
    NL80211_CHAN_WIDTH_20_NOHT = 0,
    NL80211_CHAN_WIDTH_20 = 1,
    NL80211_CHAN_WIDTH_40 = 2,
    NL80211_CHAN_WIDTH_80 = 3,
    NL80211_CHAN_WIDTH_80P80 = 4,
    NL80211_CHAN_WIDTH_160 = 5,
    NL80211_CHAN_WIDTH_5 = 6,
    NL80211_CHAN_WIDTH_10 = 7
};
#line 3463 
enum nl80211_bss_scan_width {
    NL80211_BSS_CHAN_WIDTH_20 = 0,
    NL80211_BSS_CHAN_WIDTH_10 = 1,
    NL80211_BSS_CHAN_WIDTH_5 = 2
};
#line 3500 
enum nl80211_auth_type {
    NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
    NL80211_AUTHTYPE_SHARED_KEY = 1,
    NL80211_AUTHTYPE_FT = 2,
    NL80211_AUTHTYPE_NETWORK_EAP = 3,
    NL80211_AUTHTYPE_SAE = 4,
    NL80211_AUTHTYPE_FILS_SK = 5,
    NL80211_AUTHTYPE_FILS_SK_PFS = 6,
    NL80211_AUTHTYPE_FILS_PK = 7,
    __NL80211_AUTHTYPE_NUM = 8,
    NL80211_AUTHTYPE_MAX = 7,
    NL80211_AUTHTYPE_AUTOMATIC = 8
};
#line 3521 
enum nl80211_mfp {
    NL80211_MFP_NO = 0,
    NL80211_MFP_REQUIRED = 1,
    NL80211_MFP_OPTIONAL = 2
};
#line 4599 
enum nl80211_band {
    NL80211_BAND_2GHZ = 0,
    NL80211_BAND_5GHZ = 1,
    NL80211_BAND_60GHZ = 2,
    NL80211_BAND_6GHZ = 3,
    NUM_NL80211_BANDS = 4
};
#line 4914  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_seq {
   __u32 start ;
   __u32 offset ;
   __u32 len ;
};
#line 4925  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token {
   __u32 offset ;
   __u32 len ;
   __u8 token_stream[] ;
};
#line 4936  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token_feature {
   __u32 min_len ;
   __u32 max_len ;
   __u32 bufsize ;
};
#line 5237 
enum nl80211_dfs_state {
    NL80211_DFS_USABLE = 0,
    NL80211_DFS_UNAVAILABLE = 1,
    NL80211_DFS_AVAILABLE = 2
};
#line 5847  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/nl80211.h"
struct nl80211_vendor_cmd_info {
   __u32 vendor_id ;
   __u32 subcmd ;
};
#line 5903 
enum nl80211_bss_select_attr {
    __NL80211_BSS_SELECT_ATTR_INVALID = 0,
    NL80211_BSS_SELECT_ATTR_RSSI = 1,
    NL80211_BSS_SELECT_ATTR_BAND_PREF = 2,
    NL80211_BSS_SELECT_ATTR_RSSI_ADJUST = 3,
    __NL80211_BSS_SELECT_ATTR_AFTER_LAST = 4,
    NL80211_BSS_SELECT_ATTR_MAX = 3
};
#line 1276  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ieee80211.h"
struct ieee80211_mcs_info {
   u8 rx_mask[10U] ;
   __le16 rx_highest ;
   u8 tx_params ;
   u8 reserved[3U] ;
} __attribute__((__packed__));
#line 1310  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ieee80211.h"
struct ieee80211_ht_cap {
   __le16 cap_info ;
   u8 ampdu_params_info ;
   struct ieee80211_mcs_info mcs ;
   __le16 extended_ht_cap_info ;
   __le32 tx_BF_cap_info ;
   u8 antenna_selection_info ;
} __attribute__((__packed__));
#line 1483  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ieee80211.h"
struct ieee80211_vht_mcs_info {
   __le16 rx_mcs_map ;
   __le16 rx_highest ;
   __le16 tx_mcs_map ;
   __le16 tx_highest ;
} __attribute__((__packed__));
#line 1526  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ieee80211.h"
struct ieee80211_vht_cap {
   __le32 vht_cap_info ;
   struct ieee80211_vht_mcs_info supp_mcs ;
} __attribute__((__packed__));
#line 1569  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ieee80211.h"
struct ieee80211_he_cap_elem {
   u8 mac_cap_info[6U] ;
   u8 phy_cap_info[11U] ;
} __attribute__((__packed__));
#line 1616  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ieee80211.h"
struct ieee80211_he_mcs_nss_supp {
   __le16 rx_mcs_80 ;
   __le16 tx_mcs_80 ;
   __le16 rx_mcs_160 ;
   __le16 tx_mcs_160 ;
   __le16 rx_mcs_80p80 ;
   __le16 tx_mcs_80p80 ;
} __attribute__((__packed__));
#line 3414 
enum environment_cap {
    ENVIRON_ANY = 0,
    ENVIRON_INDOOR = 1,
    ENVIRON_OUTDOOR = 2
};
#line 77  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/regulatory.h"
struct regulatory_request {
   struct callback_head callback_head ;
   int wiphy_idx ;
   enum nl80211_reg_initiator initiator ;
   enum nl80211_user_reg_hint_type user_reg_hint_type ;
   char alpha2[3U] ;
   enum nl80211_dfs_regions dfs_region ;
   bool intersect ;
   bool processed ;
   enum environment_cap country_ie_env ;
   struct list_head list ;
};
#line 181  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/regulatory.h"
struct ieee80211_freq_range {
   u32 start_freq_khz ;
   u32 end_freq_khz ;
   u32 max_bandwidth_khz ;
};
#line 187  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/regulatory.h"
struct ieee80211_power_rule {
   u32 max_antenna_gain ;
   u32 max_eirp ;
};
#line 205  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/regulatory.h"
struct ieee80211_wmm_ac {
   u16 cw_min ;
   u16 cw_max ;
   u16 cot ;
   u8 aifsn ;
};
#line 212  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/regulatory.h"
struct ieee80211_wmm_rule {
   struct ieee80211_wmm_ac client[4U] ;
   struct ieee80211_wmm_ac ap[4U] ;
};
#line 217  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/regulatory.h"
struct ieee80211_reg_rule {
   struct ieee80211_freq_range freq_range ;
   struct ieee80211_power_rule power_rule ;
   struct ieee80211_wmm_rule wmm_rule ;
   u32 flags ;
   u32 dfs_cac_ms ;
   bool has_wmm ;
};
#line 226  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/regulatory.h"
struct ieee80211_regdomain {
   struct callback_head callback_head ;
   u32 n_reg_rules ;
   char alpha2[3U] ;
   enum nl80211_dfs_regions dfs_region ;
   struct ieee80211_reg_rule reg_rules[] ;
};
#line 233 
struct wiphy;
#line 147  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct ieee80211_channel {
   enum nl80211_band band ;
   u32 center_freq ;
   u16 hw_value ;
   u32 flags ;
   int max_antenna_gain ;
   int max_power ;
   int max_reg_power ;
   bool beacon_found ;
   u32 orig_flags ;
   int orig_mag ;
   int orig_mpwr ;
   enum nl80211_dfs_state dfs_state ;
   unsigned long dfs_state_entered ;
   unsigned int dfs_cac_ms ;
};
#line 172 
enum ieee80211_bss_type {
    IEEE80211_BSS_TYPE_ESS = 0,
    IEEE80211_BSS_TYPE_PBSS = 1,
    IEEE80211_BSS_TYPE_IBSS = 2,
    IEEE80211_BSS_TYPE_MBSS = 3,
    IEEE80211_BSS_TYPE_ANY = 4
};
#line 243  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct ieee80211_rate {
   u32 flags ;
   u16 bitrate ;
   u16 hw_value ;
   u16 hw_value_short ;
};
#line 274  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct ieee80211_sta_ht_cap {
   u16 cap ;
   bool ht_supported ;
   u8 ampdu_factor ;
   u8 ampdu_density ;
   struct ieee80211_mcs_info mcs ;
};
#line 292  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct ieee80211_sta_vht_cap {
   bool vht_supported ;
   u32 cap ;
   struct ieee80211_vht_mcs_info vht_mcs ;
};
#line 311  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct ieee80211_sta_he_cap {
   bool has_he ;
   struct ieee80211_he_cap_elem he_cap_elem ;
   struct ieee80211_he_mcs_nss_supp he_mcs_nss_supp ;
   u8 ppe_thres[25U] ;
};
#line 328  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct ieee80211_sband_iftype_data {
   u16 types_mask ;
   struct ieee80211_sta_he_cap he_cap ;
};
#line 332 
enum ieee80211_edmg_bw_config {
    IEEE80211_EDMG_BW_CONFIG_4 = 4,
    IEEE80211_EDMG_BW_CONFIG_5 = 5,
    IEEE80211_EDMG_BW_CONFIG_6 = 6,
    IEEE80211_EDMG_BW_CONFIG_7 = 7,
    IEEE80211_EDMG_BW_CONFIG_8 = 8,
    IEEE80211_EDMG_BW_CONFIG_9 = 9,
    IEEE80211_EDMG_BW_CONFIG_10 = 10,
    IEEE80211_EDMG_BW_CONFIG_11 = 11,
    IEEE80211_EDMG_BW_CONFIG_12 = 12,
    IEEE80211_EDMG_BW_CONFIG_13 = 13,
    IEEE80211_EDMG_BW_CONFIG_14 = 14,
    IEEE80211_EDMG_BW_CONFIG_15 = 15
};
#line 382  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct ieee80211_edmg {
   u8 channels ;
   enum ieee80211_edmg_bw_config bw_config ;
};
#line 410  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct ieee80211_supported_band {
   struct ieee80211_channel *channels ;
   struct ieee80211_rate *bitrates ;
   enum nl80211_band band ;
   int n_channels ;
   int n_bitrates ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
   struct ieee80211_edmg edmg_cap ;
   u16 n_iftype_data ;
   struct ieee80211_sband_iftype_data *iftype_data ;
};
#line 571  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct key_params {
   u8 *key ;
   u8 *seq ;
   int key_len ;
   int seq_len ;
   u16 vlan_id ;
   u32 cipher ;
   enum nl80211_key_mode mode ;
};
#line 593  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct cfg80211_chan_def {
   struct ieee80211_channel *chan ;
   enum nl80211_chan_width width ;
   u32 center_freq1 ;
   u32 center_freq2 ;
   struct ieee80211_edmg edmg ;
};
#line 853  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct cfg80211_crypto_settings {
   u32 wpa_versions ;
   u32 cipher_group ;
   int n_ciphers_pairwise ;
   u32 ciphers_pairwise[5U] ;
   int n_akm_suites ;
   u32 akm_suites[2U] ;
   bool control_port ;
   __be16 control_port_ethertype ;
   bool control_port_no_encrypt ;
   bool control_port_over_nl80211 ;
   struct key_params *wep_keys ;
   int wep_tx_key ;
   u8 *psk ;
   u8 *sae_pwd ;
   u8 sae_pwd_len ;
};
#line 917  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct mac_address {
   u8 addr[6U] ;
};
#line 1885  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct cfg80211_ssid {
   u8 ssid[32U] ;
   u8 ssid_len ;
};
#line 1991  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct cfg80211_match_set {
   struct cfg80211_ssid ssid ;
   u8 bssid[6U] ;
   s32 rssi_thold ;
   s32 per_band_rssi_thold[4U] ;
};
#line 2007  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct cfg80211_sched_scan_plan {
   u32 interval ;
   u32 iterations ;
};
#line 2018  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct cfg80211_bss_select_adjust {
   enum nl80211_band band ;
   s8 delta ;
};
#line 2073  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct cfg80211_sched_scan_request {
   u64 reqid ;
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u8 *ie ;
   size_t ie_len ;
   u32 flags ;
   struct cfg80211_match_set *match_sets ;
   int n_match_sets ;
   s32 min_rssi_thold ;
   u32 delay ;
   struct cfg80211_sched_scan_plan *scan_plans ;
   int n_scan_plans ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   bool relative_rssi_set ;
   s8 relative_rssi ;
   struct cfg80211_bss_select_adjust rssi_adjust ;
   struct wiphy *wiphy ;
   struct net_device *dev ;
   unsigned long scan_start ;
   bool report_results ;
   struct callback_head callback_head ;
   u32 owner_nlportid ;
   bool nl_owner_dead ;
   struct list_head list ;
   struct ieee80211_channel *channels[0U] ;
};
#line 2109 
enum cfg80211_signal_type {
    CFG80211_SIGNAL_TYPE_NONE = 0,
    CFG80211_SIGNAL_TYPE_MBM = 1,
    CFG80211_SIGNAL_TYPE_UNSPEC = 2
};
#line 2432  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct cfg80211_ibss_params {
   u8 *ssid ;
   u8 *bssid ;
   struct cfg80211_chan_def chandef ;
   u8 *ie ;
   u8 ssid_len ;
   u8 ie_len ;
   u16 beacon_interval ;
   u32 basic_rates ;
   bool channel_fixed ;
   bool privacy ;
   bool control_port ;
   bool control_port_over_nl80211 ;
   bool userspace_handles_dfs ;
   int mcast_rate[4U] ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct key_params *wep_keys ;
   int wep_tx_key ;
};
#line 2460  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
union __anonunion_param_747 {
   enum nl80211_band band_pref ;
   struct cfg80211_bss_select_adjust adjust ;
};
#line 2460  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct cfg80211_bss_selection {
   enum nl80211_bss_select_attr behaviour ;
   union __anonunion_param_747 param ;
};
#line 2531  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct cfg80211_connect_params {
   struct ieee80211_channel *channel ;
   struct ieee80211_channel *channel_hint ;
   u8 *bssid ;
   u8 *bssid_hint ;
   u8 *ssid ;
   size_t ssid_len ;
   enum nl80211_auth_type auth_type ;
   u8 *ie ;
   size_t ie_len ;
   bool privacy ;
   enum nl80211_mfp mfp ;
   struct cfg80211_crypto_settings crypto ;
   u8 *key ;
   u8 key_len ;
   u8 key_idx ;
   u32 flags ;
   int bg_scan_period ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
   bool pbss ;
   struct cfg80211_bss_selection bss_select ;
   u8 *prev_bssid ;
   u8 *fils_erp_username ;
   size_t fils_erp_username_len ;
   u8 *fils_erp_realm ;
   size_t fils_erp_realm_len ;
   u16 fils_erp_next_seq_num ;
   u8 *fils_erp_rrk ;
   size_t fils_erp_rrk_len ;
   bool want_1x ;
   struct ieee80211_edmg edmg ;
};
#line 2656  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct cfg80211_pkt_pattern {
   u8 *mask ;
   u8 *pattern ;
   int pattern_len ;
   int pkt_offset ;
};
#line 2681  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct cfg80211_wowlan_tcp {
   struct socket *sock ;
   __be32 src ;
   __be32 dst ;
   u16 src_port ;
   u16 dst_port ;
   u8 dst_mac[6U] ;
   int payload_len ;
   u8 *payload ;
   struct nl80211_wowlan_tcp_data_seq payload_seq ;
   u32 data_interval ;
   u32 wake_len ;
   u8 *wake_data ;
   u8 *wake_mask ;
   u32 tokens_size ;
   struct nl80211_wowlan_tcp_data_token payload_tok ;
};
#line 2715  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct cfg80211_wowlan {
   bool any ;
   bool disconnect ;
   bool magic_pkt ;
   bool gtk_rekey_failure ;
   bool eap_identity_req ;
   bool four_way_handshake ;
   bool rfkill_release ;
   struct cfg80211_pkt_pattern *patterns ;
   struct cfg80211_wowlan_tcp *tcp ;
   int n_patterns ;
   struct cfg80211_sched_scan_request *nd_config ;
};
#line 4043  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct ieee80211_iface_limit {
   u16 max ;
   u16 types ;
};
#line 4107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct ieee80211_iface_combination {
   struct ieee80211_iface_limit *limits ;
   u32 num_different_channels ;
   u16 max_interfaces ;
   u8 n_limits ;
   bool beacon_int_infra_match ;
   u8 radar_detect_widths ;
   u8 radar_detect_regions ;
   u32 beacon_int_min_gcd ;
};
#line 4165  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct ieee80211_txrx_stypes {
   u16 tx ;
   u16 rx ;
};
#line 4198  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct wiphy_wowlan_tcp_support {
   struct nl80211_wowlan_tcp_data_token_feature *tok ;
   u32 data_payload_max ;
   u32 data_interval_max ;
   u32 wake_payload_max ;
   bool seq ;
};
#line 4221  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct wiphy_wowlan_support {
   u32 flags ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
   int max_nd_match_sets ;
   struct wiphy_wowlan_tcp_support *tcp ;
};
#line 4241  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct wiphy_coalesce_support {
   int n_rules ;
   int max_delay ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
};
#line 4312 
struct nla_policy;
#line 4312  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct wiphy_vendor_command {
   struct nl80211_vendor_cmd_info info ;
   u32 flags ;
   int (*doit)(struct wiphy *, struct wireless_dev *, void *, int ) ;
   int (*dumpit)(struct wiphy *, struct wireless_dev *, struct sk_buff *, void *, int , unsigned long *) ;
   struct nla_policy *policy ;
   unsigned int maxattr ;
};
#line 4335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct wiphy_iftype_ext_capab {
   enum nl80211_iftype iftype ;
   u8 *extended_capabilities ;
   u8 *extended_capabilities_mask ;
   u8 extended_capabilities_len ;
};
#line 4360  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct __anonstruct_ftm_749 {
   u32 preambles ;
   u32 bandwidths ;
   s8 max_bursts_exponent ;
   u8 max_ftms_per_burst ;
   u8 supported : 1 ;
   u8 asap : 1 ;
   u8 non_asap : 1 ;
   u8 request_lci : 1 ;
   u8 request_civicloc : 1 ;
};
#line 4360  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct cfg80211_pmsr_capabilities {
   unsigned int max_peers ;
   u8 report_ap_tsf : 1 ;
   u8 randomize_mac_addr : 1 ;
   struct __anonstruct_ftm_749 ftm ;
};
#line 4552  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct wiphy {
   u8 perm_addr[6U] ;
   u8 addr_mask[6U] ;
   struct mac_address *addresses ;
   struct ieee80211_txrx_stypes *mgmt_stypes ;
   struct ieee80211_iface_combination *iface_combinations ;
   int n_iface_combinations ;
   u16 software_iftypes ;
   u16 n_addresses ;
   u16 interface_modes ;
   u16 max_acl_mac_addrs ;
   u32 flags ;
   u32 regulatory_flags ;
   u32 features ;
   u8 ext_features[6U] ;
   u32 ap_sme_capa ;
   enum cfg80211_signal_type signal_type ;
   int bss_priv_size ;
   u8 max_scan_ssids ;
   u8 max_sched_scan_reqs ;
   u8 max_sched_scan_ssids ;
   u8 max_match_sets ;
   u16 max_scan_ie_len ;
   u16 max_sched_scan_ie_len ;
   u32 max_sched_scan_plans ;
   u32 max_sched_scan_plan_interval ;
   u32 max_sched_scan_plan_iterations ;
   int n_cipher_suites ;
   u32 *cipher_suites ;
   int n_akm_suites ;
   u32 *akm_suites ;
   u8 retry_short ;
   u8 retry_long ;
   u32 frag_threshold ;
   u32 rts_threshold ;
   u8 coverage_class ;
   char fw_version[32U] ;
   u32 hw_version ;
   struct wiphy_wowlan_support *wowlan ;
   struct cfg80211_wowlan *wowlan_config ;
   u16 max_remain_on_channel_duration ;
   u8 max_num_pmkids ;
   u32 available_antennas_tx ;
   u32 available_antennas_rx ;
   u32 probe_resp_offload ;
   u8 *extended_capabilities ;
   u8 *extended_capabilities_mask ;
   u8 extended_capabilities_len ;
   struct wiphy_iftype_ext_capab *iftype_ext_capab ;
   unsigned int num_iftype_ext_capab ;
   void *privid ;
   struct ieee80211_supported_band *bands[4U] ;
   void (*reg_notifier)(struct wiphy *, struct regulatory_request *) ;
   struct ieee80211_regdomain *regd ;
   struct device dev ;
   bool registered ;
   struct dentry *debugfsdir ;
   struct ieee80211_ht_cap *ht_capa_mod_mask ;
   struct ieee80211_vht_cap *vht_capa_mod_mask ;
   struct list_head wdev_list ;
   possible_net_t _net ;
   struct iw_handler_def *wext ;
   struct wiphy_coalesce_support *coalesce ;
   struct wiphy_vendor_command *vendor_commands ;
   struct nl80211_vendor_cmd_info *vendor_events ;
   int n_vendor_commands ;
   int n_vendor_events ;
   u16 max_ap_assoc_sta ;
   u8 max_num_csa_counters ;
   u8 max_adj_channel_rssi_comp ;
   u32 bss_select_support ;
   u8 nan_supported_bands ;
   u32 txq_limit ;
   u32 txq_memory_limit ;
   u32 txq_quantum ;
   u8 support_mbssid : 1 ;
   u8 support_only_he_mbssid : 1 ;
   struct cfg80211_pmsr_capabilities *pmsr_capa ;
   char priv[0U] ;
};
#line 4826 
struct cfg80211_conn;
#line 4827 
struct cfg80211_internal_bss;
#line 4828 
struct cfg80211_cached_keys;
#line 4829 
struct cfg80211_cqm_config;
#line 4912  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct __anonstruct_wext_750 {
   struct cfg80211_ibss_params ibss ;
   struct cfg80211_connect_params connect ;
   struct cfg80211_cached_keys *keys ;
   u8 *ie ;
   size_t ie_len ;
   u8 bssid[6U] ;
   u8 prev_bssid[6U] ;
   u8 ssid[32U] ;
   s8 default_key ;
   s8 default_mgmt_key ;
   bool prev_bssid_valid ;
};
#line 4912  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
struct wireless_dev {
   struct wiphy *wiphy ;
   enum nl80211_iftype iftype ;
   struct list_head list ;
   struct net_device *netdev ;
   u32 identifier ;
   struct list_head mgmt_registrations ;
   spinlock_t mgmt_registrations_lock ;
   struct mutex mtx ;
   bool use_4addr ;
   bool is_running ;
   u8 address[6U] ;
   u8 ssid[32U] ;
   u8 ssid_len ;
   u8 mesh_id_len ;
   u8 mesh_id_up_len ;
   struct cfg80211_conn *conn ;
   struct cfg80211_cached_keys *connect_keys ;
   enum ieee80211_bss_type conn_bss_type ;
   u32 conn_owner_nlportid ;
   struct work_struct disconnect_wk ;
   u8 disconnect_bssid[6U] ;
   struct list_head event_list ;
   spinlock_t event_lock ;
   struct cfg80211_internal_bss *current_bss ;
   struct cfg80211_chan_def preset_chandef ;
   struct cfg80211_chan_def chandef ;
   bool ibss_fixed ;
   bool ibss_dfs_possible ;
   bool ps ;
   int ps_timeout ;
   int beacon_interval ;
   u32 ap_unexpected_nlportid ;
   u32 owner_nlportid ;
   bool nl_owner_dead ;
   bool cac_started ;
   unsigned long cac_start_time ;
   unsigned int cac_time_ms ;
   struct __anonstruct_wext_750 wext ;
   struct cfg80211_cqm_config *cqm_config ;
   struct list_head pmsr_list ;
   spinlock_t pmsr_lock ;
   struct work_struct pmsr_free_wk ;
};
#line 674  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/wireless.h"
struct iw_param {
   __s32 value ;
   __u8 fixed ;
   __u8 disabled ;
   __u16 flags ;
};
#line 685  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/wireless.h"
struct iw_point {
   void *pointer ;
   __u16 length ;
   __u16 flags ;
};
#line 700  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/wireless.h"
struct iw_freq {
   __s32 m ;
   __s16 e ;
   __u8 i ;
   __u8 flags ;
};
#line 710  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/wireless.h"
struct iw_quality {
   __u8 qual ;
   __u8 level ;
   __u8 noise ;
   __u8 updated ;
};
#line 725  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/wireless.h"
struct iw_discarded {
   __u32 nwid ;
   __u32 code ;
   __u32 fragment ;
   __u32 retries ;
   __u32 misc ;
};
#line 737  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/wireless.h"
struct iw_missed {
   __u32 beacon ;
};
#line 823  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/wireless.h"
struct iw_encode_ext {
   __u32 ext_flags ;
   __u8 tx_seq[8U] ;
   __u8 rx_seq[8U] ;
   struct sockaddr addr ;
   __u16 alg ;
   __u16 key_len ;
   __u8 key[0U] ;
};
#line 875  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/wireless.h"
struct iw_statistics {
   __u16 status ;
   struct iw_quality qual ;
   struct iw_discarded discard ;
   struct iw_missed miss ;
};
#line 896  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/wireless.h"
union iwreq_data {
   char name[16U] ;
   struct iw_point essid ;
   struct iw_param nwid ;
   struct iw_freq freq ;
   struct iw_param sens ;
   struct iw_param bitrate ;
   struct iw_param txpower ;
   struct iw_param rts ;
   struct iw_param frag ;
   __u32 mode ;
   struct iw_param retry ;
   struct iw_point encoding ;
   struct iw_param power ;
   struct iw_quality qual ;
   struct sockaddr ap_addr ;
   struct sockaddr addr ;
   struct iw_param param ;
   struct iw_point data ;
};
#line 953  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/wireless.h"
struct iw_range {
   __u32 throughput ;
   __u32 min_nwid ;
   __u32 max_nwid ;
   __u16 old_num_channels ;
   __u8 old_num_frequency ;
   __u8 scan_capa ;
   __u32 event_capa[6U] ;
   __s32 sensitivity ;
   struct iw_quality max_qual ;
   struct iw_quality avg_qual ;
   __u8 num_bitrates ;
   __s32 bitrate[32U] ;
   __s32 min_rts ;
   __s32 max_rts ;
   __s32 min_frag ;
   __s32 max_frag ;
   __s32 min_pmp ;
   __s32 max_pmp ;
   __s32 min_pmt ;
   __s32 max_pmt ;
   __u16 pmp_flags ;
   __u16 pmt_flags ;
   __u16 pm_capa ;
   __u16 encoding_size[8U] ;
   __u8 num_encoding_sizes ;
   __u8 max_encoding_tokens ;
   __u8 encoding_login_index ;
   __u16 txpower_capa ;
   __u8 num_txpower ;
   __s32 txpower[8U] ;
   __u8 we_version_compiled ;
   __u8 we_version_source ;
   __u16 retry_capa ;
   __u16 retry_flags ;
   __u16 r_time_flags ;
   __s32 min_retry ;
   __s32 max_retry ;
   __s32 min_r_time ;
   __s32 max_r_time ;
   __u16 num_channels ;
   __u8 num_frequency ;
   struct iw_freq freq[32U] ;
   __u32 enc_capa ;
};
#line 1057  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/wireless.h"
struct iw_priv_args {
   __u32 cmd ;
   __u16 set_args ;
   __u16 get_args ;
   char name[16U] ;
};
#line 1074  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/wireless.h"
struct iw_event {
   __u16 len ;
   __u16 cmd ;
   union iwreq_data u ;
};
#line 304  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/iw_handler.h"
struct iw_request_info {
   __u16 cmd ;
   __u16 flags ;
};
#line 308  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/iw_handler.h"
typedef int (*iw_handler)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *);
#line 324  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/iw_handler.h"
struct iw_handler_def {
   iw_handler *standard ;
   __u16 num_standard ;
   __u16 num_private ;
   __u16 num_private_args ;
   iw_handler *private ;
   struct iw_priv_args *private_args ;
   struct iw_statistics *(*get_wireless_stats)(struct net_device *) ;
};
#line 396  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/iw_handler.h"
struct iw_spy_data {
   int spy_number ;
   u_char spy_address[8U][6U] ;
   struct iw_quality spy_stat[8U] ;
   struct iw_quality spy_thr_low ;
   struct iw_quality spy_thr_high ;
   u_char spy_thr_under[8U] ;
};
#line 406 
struct libipw_device;
#line 420  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/iw_handler.h"
struct iw_public_data {
   struct iw_spy_data *spy_data ;
   struct libipw_device *libipw ;
};
#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_Cmd_752 {
   u16 cmd ;
   u16 parm0 ;
   u16 parm1 ;
   u16 parm2 ;
};
#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_Cmd_752 Cmd;
#line 488  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_Resp_753 {
   u16 status ;
   u16 rsp0 ;
   u16 rsp1 ;
   u16 rsp2 ;
};
#line 488  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_Resp_753 Resp;
#line 495 
struct WepKeyRid;
#line 495  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct WepKeyRid WepKeyRid;
#line 505  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct WepKeyRid {
   __le16 len ;
   __le16 kindex ;
   u8 mac[6U] ;
   __le16 klen ;
   u8 key[16U] ;
} __attribute__((__packed__));
#line 512 
struct Ssid;
#line 512  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct Ssid Ssid;
#line 515  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct Ssid {
   __le16 len ;
   u8 ssid[32U] ;
} __attribute__((__packed__));
#line 519 
struct SsidRid;
#line 519  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct SsidRid SsidRid;
#line 521  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct SsidRid {
   __le16 len ;
   Ssid ssids[3U] ;
} __attribute__((__packed__));
#line 531 
struct ConfigRid;
#line 531  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct ConfigRid ConfigRid;
#line 536  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct ConfigRid {
   __le16 len ;
   __le16 opmode ;
   __le16 rmode ;
   __le16 fragThresh ;
   __le16 rtsThres ;
   u8 macAddr[6U] ;
   u8 rates[8U] ;
   __le16 shortRetryLimit ;
   __le16 longRetryLimit ;
   __le16 txLifetime ;
   __le16 rxLifetime ;
   __le16 stationary ;
   __le16 ordering ;
   __le16 u16deviceType ;
   __le16 cfpRate ;
   __le16 cfpDuration ;
   __le16 _reserved1[3U] ;
   __le16 scanMode ;
   __le16 probeDelay ;
   __le16 probeEnergyTimeout ;
   __le16 probeResponseTimeout ;
   __le16 beaconListenTimeout ;
   __le16 joinNetTimeout ;
   __le16 authTimeout ;
   __le16 authType ;
   __le16 associationTimeout ;
   __le16 specifiedApTimeout ;
   __le16 offlineScanInterval ;
   __le16 offlineScanDuration ;
   __le16 linkLossDelay ;
   __le16 maxBeaconLostTime ;
   __le16 refreshInterval ;
   __le16 _reserved1a[1U] ;
   __le16 powerSaveMode ;
   __le16 sleepForDtims ;
   __le16 listenInterval ;
   __le16 fastListenInterval ;
   __le16 listenDecay ;
   __le16 fastListenDelay ;
   __le16 _reserved2[2U] ;
   __le16 beaconPeriod ;
   __le16 atimDuration ;
   __le16 hopPeriod ;
   __le16 channelSet ;
   __le16 channel ;
   __le16 dtimPeriod ;
   __le16 bridgeDistance ;
   __le16 radioID ;
   __le16 radioType ;
   u8 rxDiversity ;
   u8 txDiversity ;
   __le16 txPower ;
   __le16 rssiThreshold ;
   __le16 modulation ;
   __le16 preamble ;
   __le16 homeProduct ;
   __le16 radioSpecific ;
   u8 nodeName[16U] ;
   __le16 arlThreshold ;
   __le16 arlDecay ;
   __le16 arlDelay ;
   __le16 _reserved4[1U] ;
   u8 magicAction ;
   u8 magicControl ;
   __le16 autoWake ;
} __attribute__((__packed__));
#line 658 
struct StatusRid;
#line 658  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct StatusRid StatusRid;
#line 660  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct StatusRid {
   __le16 len ;
   u8 mac[6U] ;
   __le16 mode ;
   __le16 errorCode ;
   __le16 sigQuality ;
   __le16 SSIDlen ;
   char SSID[32U] ;
   char apName[16U] ;
   u8 bssid[4U][6U] ;
   __le16 beaconPeriod ;
   __le16 dimPeriod ;
   __le16 atimDuration ;
   __le16 hopPeriod ;
   __le16 channelSet ;
   __le16 channel ;
   __le16 hopsToBackbone ;
   __le16 apTotalLoad ;
   __le16 generatedLoad ;
   __le16 accumulatedArl ;
   __le16 signalQuality ;
   __le16 currentXmitRate ;
   __le16 apDevExtensions ;
   __le16 normalizedSignalStrength ;
   __le16 shortPreamble ;
   u8 apIP[4U] ;
   u8 noisePercent ;
   u8 noisedBm ;
   u8 noiseAvePercent ;
   u8 noiseAvedBm ;
   u8 noiseMaxPercent ;
   u8 noiseMaxdBm ;
   __le16 load ;
   u8 carrier[4U] ;
   __le16 assocStatus ;
} __attribute__((__packed__));
#line 696 
struct StatsRid;
#line 696  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct StatsRid StatsRid;
#line 719  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct StatsRid {
   __le16 len ;
   __le16 spacer ;
   __le32 vals[100U] ;
} __attribute__((__packed__));
#line 724 
struct APListRid;
#line 724  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct APListRid APListRid;
#line 726  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct APListRid {
   __le16 len ;
   u8 ap[4U][6U] ;
} __attribute__((__packed__));
#line 730 
struct CapabilityRid;
#line 730  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct CapabilityRid CapabilityRid;
#line 732  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct CapabilityRid {
   __le16 len ;
   char oui[3U] ;
   char zero ;
   __le16 prodNum ;
   char manName[32U] ;
   char prodName[16U] ;
   char prodVer[8U] ;
   char factoryAddr[6U] ;
   char aironetAddr[6U] ;
   __le16 radioType ;
   __le16 country ;
   char callid[6U] ;
   char supportedRates[8U] ;
   char rxDiversity ;
   char txDiversity ;
   __le16 txPowerLevels[8U] ;
   __le16 hardVer ;
   __le16 hardCap ;
   __le16 tempRange ;
   __le16 softVer ;
   __le16 softSubVer ;
   __le16 interfaceVer ;
   __le16 softCap ;
   __le16 bootBlockVer ;
   __le16 requiredHard ;
   __le16 extSoftCap ;
} __attribute__((__packed__));
#line 760 
struct BSSListRidExtra;
#line 760  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct BSSListRidExtra BSSListRidExtra;
#line 763  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct BSSListRidExtra {
   __le16 unknown[4U] ;
   u8 fixed[12U] ;
   u8 iep[624U] ;
} __attribute__((__packed__));
#line 768 
struct BSSListRid;
#line 768  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct BSSListRid BSSListRid;
#line 770  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_fh_754 {
   __le16 dwell ;
   u8 hopSet ;
   u8 hopPattern ;
   u8 hopIndex ;
   u8 fill ;
};
#line 770  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct BSSListRid {
   __le16 len ;
   __le16 index ;
   __le16 radioType ;
   u8 bssid[6U] ;
   u8 zero ;
   u8 ssidLen ;
   u8 ssid[32U] ;
   __le16 dBm ;
   __le16 cap ;
   __le16 beaconInterval ;
   u8 rates[8U] ;
   struct __anonstruct_fh_754 fh ;
   __le16 dsChannel ;
   __le16 atimWindow ;
   BSSListRidExtra extra ;
} __attribute__((__packed__));
#line 802  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_BSSListElement_755 {
   BSSListRid bss ;
   struct list_head list ;
};
#line 802  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_BSSListElement_755 BSSListElement;
#line 807 
struct tdsRssiEntry;
#line 807  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct tdsRssiEntry tdsRssiEntry;
#line 809  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct tdsRssiEntry {
   u8 rssipct ;
   u8 rssidBm ;
} __attribute__((__packed__));
#line 813 
struct tdsRssiRid;
#line 813  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct tdsRssiRid tdsRssiRid;
#line 815  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct tdsRssiRid {
   u16 len ;
   tdsRssiEntry x[256U] ;
} __attribute__((__packed__));
#line 819 
struct MICRid;
#line 819  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct MICRid MICRid;
#line 821  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct MICRid {
   __le16 len ;
   __le16 state ;
   __le16 multicastValid ;
   u8 multicast[16U] ;
   __le16 unicastValid ;
   u8 unicast[16U] ;
} __attribute__((__packed__));
#line 829 
struct MICBuffer;
#line 829  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct MICBuffer MICBuffer;
#line 831  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_llc_757 {
   u8 dsap ;
   u8 ssap ;
   u8 control ;
   u8 orgcode[3U] ;
   u8 fieldtype[2U] ;
};
#line 831  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
union __anonunion_u_756 {
   u8 snap[8U] ;
   struct __anonstruct_llc_757 llc ;
};
#line 831  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct MICBuffer {
   __be16 typelen ;
   union __anonunion_u_756 u ;
   __be32 mic ;
   __be32 seq ;
} __attribute__((__packed__));
#line 847  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_etherHead_758 {
   u8 da[6U] ;
   u8 sa[6U] ;
};
#line 847  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_etherHead_758 etherHead;
#line 930  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct aironet_ioctl {
   unsigned short command ;
   unsigned short len ;
   unsigned short ridnum ;
   unsigned char *data ;
};
#line 936  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct aironet_ioctl aironet_ioctl;
#line 938  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_mic_statistics_759 {
   u32 size ;
   u8 enabled ;
   u32 rxSuccess ;
   u32 rxIncorrectMIC ;
   u32 rxNotMICed ;
   u32 rxMICPlummed ;
   u32 rxWrongSequence ;
   u32 reserve[32U] ;
};
#line 938  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_mic_statistics_759 mic_statistics;
#line 955  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
union __anonunion_part_761 {
   u8 d8[4U] ;
   __be32 d32 ;
};
#line 955  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_emmh32_context_760 {
   __be32 coeff[600U] ;
   u64 accum ;
   int position ;
   union __anonunion_part_761 part ;
};
#line 955  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_emmh32_context_760 emmh32_context;
#line 965  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_miccntx_762 {
   emmh32_context seed ;
   u32 rx ;
   u32 tx ;
   u32 window ;
   u8 valid ;
   u8 key[16U] ;
};
#line 965  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_miccntx_762 miccntx;
#line 974  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_mic_module_763 {
   miccntx mCtx ;
   miccntx uCtx ;
};
#line 974  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_mic_module_763 mic_module;
#line 979  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_Rid_764 {
   unsigned int rid : 16 ;
   unsigned int len : 15 ;
   unsigned int valid : 1 ;
   dma_addr_t host_addr ;
};
#line 979  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_Rid_764 Rid;
#line 986  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_TxFid_765 {
   unsigned int offset : 15 ;
   unsigned int eoc : 1 ;
   unsigned int len : 15 ;
   unsigned int valid : 1 ;
   dma_addr_t host_addr ;
};
#line 986  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_TxFid_765 TxFid;
#line 995  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct rx_hdr {
   __le16 status ;
   __le16 len ;
   u8 rssi[2U] ;
   u8 rate ;
   u8 freq ;
   __le16 tmp[4U] ;
} __attribute__((__packed__));
#line 1002  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_RxFid_766 {
   unsigned int ctl : 15 ;
   unsigned int rdy : 1 ;
   unsigned int len : 15 ;
   unsigned int valid : 1 ;
   dma_addr_t host_addr ;
};
#line 1002  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_RxFid_766 RxFid;
#line 1010  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_HostRxDesc_767 {
   unsigned char *card_ram_off ;
   RxFid rx_desc ;
   char *virtual_host_addr ;
   int pending ;
};
#line 1010  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_HostRxDesc_767 HostRxDesc;
#line 1022  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_HostTxDesc_768 {
   unsigned char *card_ram_off ;
   TxFid tx_desc ;
   char *virtual_host_addr ;
   int pending ;
};
#line 1022  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_HostTxDesc_768 HostTxDesc;
#line 1034  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_HostRidDesc_769 {
   unsigned char *card_ram_off ;
   Rid rid_desc ;
   char *virtual_host_addr ;
};
#line 1034  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_HostRidDesc_769 HostRidDesc;
#line 1045  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_TxCtlHdr_770 {
   u16 sw0 ;
   u16 sw1 ;
   u16 status ;
   u16 len ;
   u16 ctl ;
   u16 aid ;
   u16 retries ;
   u16 fill ;
};
#line 1045  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_TxCtlHdr_770 TxCtlHdr;
#line 1065  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_WifiHdr_771 {
   u16 ctl ;
   u16 duration ;
   char addr1[6U] ;
   char addr2[6U] ;
   char addr3[6U] ;
   u16 seq ;
   char addr4[6U] ;
};
#line 1065  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_WifiHdr_771 WifiHdr;
#line 1075  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_WifiCtlHdr_772 {
   TxCtlHdr ctlhdr ;
   u16 fill1 ;
   u16 fill2 ;
   WifiHdr wifihdr ;
   u16 gaplen ;
   u16 status ;
};
#line 1075  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct __anonstruct_WifiCtlHdr_772 WifiCtlHdr;
#line 1095  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct wep_key_t {
   u16 len ;
   u8 key[16U] ;
};
#line 1099  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef struct wep_key_t wep_key_t;
#line 1104 
struct airo_info;
#line 1160  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_xmit_773 {
   struct sk_buff *skb ;
   int fid ;
};
#line 1160  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct __anonstruct_xmit11_774 {
   struct sk_buff *skb ;
   int fid ;
};
#line 1160  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct airo_info {
   struct net_device *dev ;
   struct list_head dev_list ;
   u32 fids[6U] ;
   ConfigRid config ;
   char keyindex ;
   char defindex ;
   struct proc_dir_entry *proc_entry ;
   spinlock_t aux_lock ;
   unsigned long flags ;
   unsigned long jobs ;
   int (*bap_read)(struct airo_info *, __le16 *, int , int ) ;
   unsigned short *flash ;
   tdsRssiEntry *rssi ;
   struct task_struct *list_bss_task ;
   struct task_struct *airo_thread_task ;
   struct semaphore sem ;
   wait_queue_head_t thr_wait ;
   unsigned long expires ;
   struct __anonstruct_xmit_773 xmit ;
   struct __anonstruct_xmit11_774 xmit11 ;
   struct net_device *wifidev ;
   struct iw_statistics wstats ;
   unsigned long scan_timeout ;
   struct iw_spy_data spy_data ;
   struct iw_public_data wireless_data ;
   struct crypto_sync_skcipher *tfm ;
   mic_module mod[2U] ;
   mic_statistics micstats ;
   HostRxDesc rxfids[1U] ;
   HostTxDesc txfids[1U] ;
   HostRidDesc config_desc ;
   unsigned long ridbus ;
   struct sk_buff_head txq ;
   struct pci_dev *pci ;
   unsigned char *pcimem ;
   unsigned char *pciaux ;
   unsigned char *shared ;
   dma_addr_t shared_dma ;
   pm_message_t power ;
   SsidRid *SSID ;
   APListRid APList ;
   char proc_name[16U] ;
   int wep_capable ;
   int max_wep_idx ;
   int last_auth ;
   unsigned int bssListFirst ;
   unsigned int bssListNext ;
   unsigned int bssListRidLen ;
   struct list_head network_list ;
   struct list_head network_free_list ;
   BSSListElement *networks ;
};
#line 1432 
enum ldv_17576 {
    NONE = 0,
    NOMIC = 1,
    NOMICPLUMMED = 2,
    SEQUENCE = 3,
    INCORRECTMIC = 4
};
#line 1440  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
typedef enum ldv_17576 mic_error;
#line 4494  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct proc_data {
   int release_buffer ;
   int readlen ;
   char *rbuffer ;
   int writelen ;
   int maxwritelen ;
   char *wbuffer ;
   void (*on_close)(struct inode *, struct file *) ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 197 
enum hrtimer_restart;
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
struct device_private {
   void *driver_data ;
};
#line 12  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/firmware.h"
struct firmware {
   size_t size ;
   u8 *data ;
   struct page **pages ;
   void *priv ;
};
#line 164  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/types.h"
typedef unsigned long irq_hw_number_t;
#line 303  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ioport.h"
struct irq_data;
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 244  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/idr.h"
struct ida {
   struct xarray xa ;
};
#line 439  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/property.h"
typedef u32 phandle;
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   struct bin_attribute attr ;
};
#line 51  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/of.h"
struct device_node {
   char *name ;
   phandle phandle ;
   char *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/irqdomain.h"
struct irq_fwspec {
   struct fwnode_handle *fwnode ;
   int param_count ;
   u32 param[16U] ;
};
#line 68 
enum irq_domain_bus_token {
    DOMAIN_BUS_ANY = 0,
    DOMAIN_BUS_WIRED = 1,
    DOMAIN_BUS_GENERIC_MSI = 2,
    DOMAIN_BUS_PCI_MSI = 3,
    DOMAIN_BUS_PLATFORM_MSI = 4,
    DOMAIN_BUS_NEXUS = 5,
    DOMAIN_BUS_IPI = 6,
    DOMAIN_BUS_FSL_MC_MSI = 7,
    DOMAIN_BUS_TI_SCI_INTA_MSI = 8,
    DOMAIN_BUS_WAKEUP = 9
};
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/irqdomain.h"
struct irq_domain_ops {
   int (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token ) ;
   int (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token ) ;
   int (*map)(struct irq_domain *, unsigned int , irq_hw_number_t ) ;
   void (*unmap)(struct irq_domain *, unsigned int ) ;
   int (*xlate)(struct irq_domain *, struct device_node *, u32 *, unsigned int , unsigned long *, unsigned int *) ;
   int (*alloc)(struct irq_domain *, unsigned int , unsigned int , void *) ;
   void (*free)(struct irq_domain *, unsigned int , unsigned int ) ;
   int (*activate)(struct irq_domain *, struct irq_data *, bool ) ;
   void (*deactivate)(struct irq_domain *, struct irq_data *) ;
   int (*translate)(struct irq_domain *, struct irq_fwspec *, unsigned long *, unsigned int *) ;
   void (*debug_show)(struct seq_file *, struct irq_domain *, struct irq_data *, int ) ;
};
#line 132 
struct irq_domain_chip_generic;
#line 161  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/irqdomain.h"
struct irq_domain {
   struct list_head link ;
   char *name ;
   struct irq_domain_ops *ops ;
   void *host_data ;
   unsigned int flags ;
   unsigned int mapcount ;
   struct fwnode_handle *fwnode ;
   enum irq_domain_bus_token bus_token ;
   struct irq_domain_chip_generic *gc ;
   struct irq_domain *parent ;
   struct dentry *debugfs_file ;
   irq_hw_number_t hwirq_max ;
   unsigned int revmap_direct_max_irq ;
   unsigned int revmap_size ;
   struct xarray revmap_tree ;
   struct mutex revmap_tree_mutex ;
   unsigned int linear_revmap[] ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/rtmutex.h"
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct rb_root_cached waiters ;
   struct task_struct *owner ;
   int save_state ;
   char *name ;
   char *file ;
   int line ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 69  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/i2c.h"
struct i2c_msg {
   __u16 addr ;
   __u16 flags ;
   __u16 len ;
   __u8 *buf ;
};
#line 135  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/i2c.h"
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34U] ;
};
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_algorithm;
#line 28 
struct i2c_adapter;
#line 29 
struct i2c_client;
#line 33 
enum i2c_slave_event;
#line 33 
enum i2c_slave_event;
#line 314  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_client {
   unsigned short flags ;
   unsigned short addr ;
   char name[20U] ;
   struct i2c_adapter *adapter ;
   struct device dev ;
   int init_irq ;
   int irq ;
   struct list_head detected ;
   int (*slave_cb)(struct i2c_client *, enum i2c_slave_event , u8 *) ;
};
#line 360 
enum i2c_slave_event {
    I2C_SLAVE_READ_REQUESTED = 0,
    I2C_SLAVE_WRITE_REQUESTED = 1,
    I2C_SLAVE_READ_PROCESSED = 2,
    I2C_SLAVE_WRITE_RECEIVED = 3,
    I2C_SLAVE_STOP = 4
};
#line 527  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_algorithm {
   int (*master_xfer)(struct i2c_adapter *, struct i2c_msg *, int ) ;
   int (*master_xfer_atomic)(struct i2c_adapter *, struct i2c_msg *, int ) ;
   int (*smbus_xfer)(struct i2c_adapter *, u16 , unsigned short , char , u8 , int , union i2c_smbus_data *) ;
   int (*smbus_xfer_atomic)(struct i2c_adapter *, u16 , unsigned short , char , u8 , int , union i2c_smbus_data *) ;
   u32 (*functionality)(struct i2c_adapter *) ;
   int (*reg_slave)(struct i2c_client *) ;
   int (*unreg_slave)(struct i2c_client *) ;
};
#line 565  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_lock_operations {
   void (*lock_bus)(struct i2c_adapter *, unsigned int ) ;
   int (*trylock_bus)(struct i2c_adapter *, unsigned int ) ;
   void (*unlock_bus)(struct i2c_adapter *, unsigned int ) ;
};
#line 618 
struct gpio_desc;
#line 618  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_bus_recovery_info {
   int (*recover_bus)(struct i2c_adapter *) ;
   int (*get_scl)(struct i2c_adapter *) ;
   void (*set_scl)(struct i2c_adapter *, int ) ;
   int (*get_sda)(struct i2c_adapter *) ;
   void (*set_sda)(struct i2c_adapter *, int ) ;
   int (*get_bus_free)(struct i2c_adapter *) ;
   void (*prepare_recovery)(struct i2c_adapter *) ;
   void (*unprepare_recovery)(struct i2c_adapter *) ;
   struct gpio_desc *scl_gpiod ;
   struct gpio_desc *sda_gpiod ;
};
#line 661  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_adapter_quirks {
   u64 flags ;
   int max_num_msgs ;
   u16 max_write_len ;
   u16 max_read_len ;
   u16 max_comb_1st_msg_len ;
   u16 max_comb_2nd_msg_len ;
};
#line 692  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/i2c.h"
struct i2c_adapter {
   struct module *owner ;
   unsigned int class ;
   struct i2c_algorithm *algo ;
   void *algo_data ;
   struct i2c_lock_operations *lock_ops ;
   struct rt_mutex bus_lock ;
   struct rt_mutex mux_lock ;
   int timeout ;
   int retries ;
   struct device dev ;
   unsigned long locked_flags ;
   int nr ;
   char name[48U] ;
   struct completion dev_released ;
   struct mutex userspace_clients_lock ;
   struct list_head userspace_clients ;
   struct i2c_bus_recovery_info *bus_recovery_info ;
   struct i2c_adapter_quirks *quirks ;
   struct irq_domain *host_notify_domain ;
};
#line 36  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/asm-generic/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file *, wait_queue_head_t *, struct poll_table_struct *) ;
   __poll_t _key ;
};
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/cdev.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
} __attribute__((__designated_init__));
#line 87  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-common.h"
struct v4l2_edid {
   __u32 pad ;
   __u32 start_block ;
   __u32 blocks ;
   __u32 reserved[5U] ;
   __u8 *edid ;
};
#line 754 
enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
    V4L2_PRIORITY_DEFAULT = 2
};
#line 413  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_rect {
   __s32 left ;
   __s32 top ;
   __u32 width ;
   __u32 height ;
};
#line 420  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_fract {
   __u32 numerator ;
   __u32 denominator ;
};
#line 1212  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
typedef __u64 v4l2_std_id;
#line 1394  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_bt_timings {
   __u32 width ;
   __u32 height ;
   __u32 interlaced ;
   __u32 polarities ;
   __u64 pixelclock ;
   __u32 hfrontporch ;
   __u32 hsync ;
   __u32 hbackporch ;
   __u32 vfrontporch ;
   __u32 vsync ;
   __u32 vbackporch ;
   __u32 il_vfrontporch ;
   __u32 il_vsync ;
   __u32 il_vbackporch ;
   __u32 standards ;
   __u32 flags ;
   struct v4l2_fract picture_aspect ;
   __u8 cea861_vic ;
   __u8 hdmi_vic ;
   __u8 reserved[46U] ;
} __attribute__((__packed__));
#line 1517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
union __anonunion_2554 {
   struct v4l2_bt_timings bt ;
   __u32 reserved[32U] ;
};
#line 1517  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_dv_timings {
   __u32 type ;
   union __anonunion_2554 __anonCompField_v4l2_dv_timings_77 ;
} __attribute__((__packed__));
#line 1536  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_enum_dv_timings {
   __u32 index ;
   __u32 pad ;
   __u32 reserved[2U] ;
   struct v4l2_dv_timings timings ;
};
#line 1554  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_bt_timings_cap {
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u64 min_pixelclock ;
   __u64 max_pixelclock ;
   __u32 standards ;
   __u32 capabilities ;
   __u32 reserved[16U] ;
} __attribute__((__packed__));
#line 1581  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
union __anonunion_2555 {
   struct v4l2_bt_timings_cap bt ;
   __u32 raw_data[32U] ;
};
#line 1581  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_dv_timings_cap {
   __u32 type ;
   __u32 pad ;
   __u32 reserved[2U] ;
   union __anonunion_2555 __anonCompField_v4l2_dv_timings_cap_78 ;
};
#line 1803  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_tuner {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 rxsubchans ;
   __u32 audmode ;
   __s32 signal ;
   __s32 afc ;
   __u32 reserved[4U] ;
};
#line 1817  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_modulator {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 txsubchans ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 1860  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_frequency {
   __u32 tuner ;
   __u32 type ;
   __u32 frequency ;
   __u32 reserved[8U] ;
};
#line 1871  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_frequency_band {
   __u32 tuner ;
   __u32 type ;
   __u32 index ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 modulation ;
   __u32 reserved[9U] ;
};
#line 2043  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_vbi_format {
   __u32 sampling_rate ;
   __u32 offset ;
   __u32 samples_per_line ;
   __u32 sample_format ;
   __s32 start[2U] ;
   __u32 count[2U] ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 2071  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_format {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 io_size ;
   __u32 reserved[2U] ;
};
#line 2095  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_cap {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 2106  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_data {
   __u32 id ;
   __u32 field ;
   __u32 line ;
   __u32 reserved ;
   __u8 data[48U] ;
};
#line 2350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_event_subscription {
   __u32 type ;
   __u32 id ;
   __u32 flags ;
   __u32 reserved[5U] ;
};
#line 2375  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
union __anonunion_2571 {
   __u32 addr ;
   char name[32U] ;
};
#line 2375  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_dbg_match {
   __u32 type ;
   union __anonunion_2571 __anonCompField_v4l2_dbg_match_87 ;
} __attribute__((__packed__));
#line 2383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/videodev2.h"
struct v4l2_dbg_register {
   struct v4l2_dbg_match match ;
   __u32 size ;
   __u64 reg ;
   __u64 val ;
} __attribute__((__packed__));
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_device;
#line 57  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_gobj {
   struct media_device *mdev ;
   u32 id ;
   struct list_head list ;
};
#line 72  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_entity_enum {
   unsigned long *bmap ;
   int idx_max ;
};
#line 88 
struct media_entity;
#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct __anonstruct_stack_2575 {
   struct media_entity *entity ;
   struct list_head *link ;
};
#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_graph {
   struct __anonstruct_stack_2575 stack[16U] ;
   struct media_entity_enum ent_enum ;
   int top ;
};
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_pipeline {
   int streaming_count ;
   struct media_graph graph ;
};
#line 132 
struct media_pad;
#line 132 
struct media_interface;
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
union __anonunion_2576 {
   struct media_gobj *gobj0 ;
   struct media_pad *source ;
   struct media_interface *intf ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
union __anonunion_2577 {
   struct media_gobj *gobj1 ;
   struct media_pad *sink ;
   struct media_entity *entity ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_link {
   struct media_gobj graph_obj ;
   struct list_head list ;
   union __anonunion_2576 __anonCompField_media_link_90 ;
   union __anonunion_2577 __anonCompField_media_link_91 ;
   struct media_link *reverse ;
   unsigned long flags ;
   bool is_backlink ;
};
#line 149 
enum media_pad_signal_type {
    PAD_SIGNAL_DEFAULT = 0,
    PAD_SIGNAL_ANALOG = 1,
    PAD_SIGNAL_DV = 2,
    PAD_SIGNAL_AUDIO = 3
};
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_pad {
   struct media_gobj graph_obj ;
   struct media_entity *entity ;
   u16 index ;
   enum media_pad_signal_type sig_type ;
   unsigned long flags ;
};
#line 214  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_entity_operations {
   int (*get_fwnode_pad)(struct fwnode_endpoint *) ;
   int (*link_setup)(struct media_entity *, struct media_pad *, struct media_pad *, u32 ) ;
   int (*link_validate)(struct media_link *) ;
};
#line 221 
enum media_entity_type {
    MEDIA_ENTITY_TYPE_BASE = 0,
    MEDIA_ENTITY_TYPE_VIDEO_DEVICE = 1,
    MEDIA_ENTITY_TYPE_V4L2_SUBDEV = 2
};
#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct __anonstruct_dev_2579 {
   u32 major ;
   u32 minor ;
};
#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
union __anonunion_info_2578 {
   struct __anonstruct_dev_2579 dev ;
};
#line 289  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_entity {
   struct media_gobj graph_obj ;
   char *name ;
   enum media_entity_type obj_type ;
   u32 function ;
   unsigned long flags ;
   u16 num_pads ;
   u16 num_links ;
   u16 num_backlinks ;
   int internal_idx ;
   struct media_pad *pads ;
   struct list_head links ;
   struct media_entity_operations *ops ;
   int stream_count ;
   int use_count ;
   struct media_pipeline *pipe ;
   union __anonunion_info_2578 info ;
};
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_interface {
   struct media_gobj graph_obj ;
   struct list_head links ;
   u32 type ;
   u32 flags ;
};
#line 349  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-entity.h"
struct media_intf_devnode {
   struct media_interface intf ;
   u32 major ;
   u32 minor ;
};
#line 1087 
enum vfl_devnode_type {
    VFL_TYPE_GRABBER = 0,
    VFL_TYPE_VBI = 1,
    VFL_TYPE_RADIO = 2,
    VFL_TYPE_SUBDEV = 3,
    VFL_TYPE_SDR = 4,
    VFL_TYPE_TOUCH = 5,
    VFL_TYPE_MAX = 6
};
#line 1097 
enum vfl_devnode_direction {
    VFL_DIR_RX = 0,
    VFL_DIR_TX = 1,
    VFL_DIR_M2M = 2
};
#line 1104 
struct video_device;
#line 1105 
struct v4l2_device;
#line 1106 
struct v4l2_ctrl_handler;
#line 104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-dev.h"
struct v4l2_prio_state {
   atomic_t prios[4U] ;
};
#line 193  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-dev.h"
struct v4l2_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char *, size_t , loff_t *) ;
   __poll_t (*poll)(struct file *, struct poll_table_struct *) ;
   long (*unlocked_ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl32)(struct file *, unsigned int , unsigned long ) ;
   unsigned long (*get_unmapped_area)(struct file *, unsigned long , unsigned long , unsigned long , unsigned long ) ;
   int (*mmap)(struct file *, struct vm_area_struct *) ;
   int (*open)(struct file *) ;
   int (*release)(struct file *) ;
};
#line 256 
struct vb2_queue;
#line 256 
struct v4l2_ioctl_ops;
#line 256  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-dev.h"
struct video_device {
   struct media_entity entity ;
   struct media_intf_devnode *intf_devnode ;
   struct media_pipeline pipe ;
   struct v4l2_file_operations *fops ;
   u32 device_caps ;
   struct device dev ;
   struct cdev *cdev ;
   struct v4l2_device *v4l2_dev ;
   struct device *dev_parent ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct vb2_queue *queue ;
   struct v4l2_prio_state *prio ;
   char name[32U] ;
   enum vfl_devnode_type vfl_type ;
   enum vfl_devnode_direction vfl_dir ;
   int minor ;
   u16 num ;
   unsigned long flags ;
   int index ;
   spinlock_t fh_lock ;
   struct list_head fh_list ;
   int dev_debug ;
   v4l2_std_id tvnorms ;
   void (*release)(struct video_device *) ;
   struct v4l2_ioctl_ops *ioctl_ops ;
   unsigned long valid_ioctls[3U] ;
   struct mutex *lock ;
};
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-common.h"
struct v4l2_subdev;
#line 96 
struct v4l2_subdev_ops;
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-common.h"
struct v4l2_priv_tun_config {
   int tuner ;
   void *priv ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-devnode.h"
struct media_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file *, char *, size_t , loff_t *) ;
   ssize_t (*write)(struct file *, char *, size_t , loff_t *) ;
   __poll_t (*poll)(struct file *, struct poll_table_struct *) ;
   long (*ioctl)(struct file *, unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file *, unsigned int , unsigned long ) ;
   int (*open)(struct file *) ;
   int (*release)(struct file *) ;
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-devnode.h"
struct media_devnode {
   struct media_device *media_dev ;
   struct media_file_operations *fops ;
   struct device dev ;
   struct cdev cdev ;
   struct device *parent ;
   int minor ;
   unsigned long flags ;
   void (*release)(struct media_devnode *) ;
};
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-device.h"
struct media_request;
#line 65  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-device.h"
struct media_device_ops {
   int (*link_notify)(struct media_link *, u32 , unsigned int ) ;
   struct media_request *(*req_alloc)(struct media_device *) ;
   void (*req_free)(struct media_request *) ;
   int (*req_validate)(struct media_request *) ;
   void (*req_queue)(struct media_request *) ;
};
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/media-device.h"
struct media_device {
   struct device *dev ;
   struct media_devnode *devnode ;
   char model[32U] ;
   char driver_name[32U] ;
   char serial[40U] ;
   char bus_info[32U] ;
   u32 hw_revision ;
   u64 topology_version ;
   u32 id ;
   struct ida entity_internal_idx ;
   int entity_internal_idx_max ;
   struct list_head entities ;
   struct list_head interfaces ;
   struct list_head pads ;
   struct list_head links ;
   struct list_head entity_notify ;
   struct mutex graph_mutex ;
   struct media_graph pm_count_walk ;
   void *source_priv ;
   int (*enable_source)(struct media_entity *, struct media_pipeline *) ;
   void (*disable_source)(struct media_entity *) ;
   struct media_device_ops *ops ;
   struct mutex req_queue_mutex ;
   atomic_t request_id ;
};
#line 30  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-mediabus.h"
struct v4l2_mbus_framefmt {
   __u32 width ;
   __u32 height ;
   __u32 code ;
   __u32 field ;
   __u32 colorspace ;
   __u16 ycbcr_enc ;
   __u16 quantization ;
   __u16 xfer_func ;
   __u16 reserved[11U] ;
};
#line 48  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_format {
   __u32 which ;
   __u32 pad ;
   struct v4l2_mbus_framefmt format ;
   __u32 reserved[8U] ;
};
#line 75  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_mbus_code_enum {
   __u32 pad ;
   __u32 index ;
   __u32 code ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 90  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_size_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval {
   __u32 pad ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 width ;
   __u32 height ;
   struct v4l2_fract interval ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_selection {
   __u32 which ;
   __u32 pad ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[8U] ;
};
#line 157 
struct v4l2_async_notifier;
#line 158 
enum v4l2_async_match_type {
    V4L2_ASYNC_MATCH_CUSTOM = 0,
    V4L2_ASYNC_MATCH_DEVNAME = 1,
    V4L2_ASYNC_MATCH_I2C = 2,
    V4L2_ASYNC_MATCH_FWNODE = 3
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct __anonstruct_i2c_2593 {
   int adapter_id ;
   unsigned short address ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct __anonstruct_custom_2594 {
   bool (*match)(struct device *, struct v4l2_async_subdev *) ;
   void *priv ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
union __anonunion_match_2592 {
   struct fwnode_handle *fwnode ;
   char *device_name ;
   struct __anonstruct_i2c_2593 i2c ;
   struct __anonstruct_custom_2594 custom ;
};
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct v4l2_async_subdev {
   enum v4l2_async_match_type match_type ;
   union __anonunion_match_2592 match ;
   struct list_head list ;
   struct list_head asd_list ;
};
#line 107  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct v4l2_async_notifier_operations {
   int (*bound)(struct v4l2_async_notifier *, struct v4l2_subdev *, struct v4l2_async_subdev *) ;
   int (*complete)(struct v4l2_async_notifier *) ;
   void (*unbind)(struct v4l2_async_notifier *, struct v4l2_subdev *, struct v4l2_async_subdev *) ;
};
#line 129  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-async.h"
struct v4l2_async_notifier {
   struct v4l2_async_notifier_operations *ops ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev *sd ;
   struct v4l2_async_notifier *parent ;
   struct list_head asd_list ;
   struct list_head waiting ;
   struct list_head done ;
   struct list_head list ;
};
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-fh.h"
struct v4l2_m2m_ctx;
#line 42  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-fh.h"
struct v4l2_fh {
   struct list_head list ;
   struct video_device *vdev ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   enum v4l2_priority prio ;
   wait_queue_head_t wait ;
   struct mutex subscribe_lock ;
   struct list_head subscribed ;
   struct list_head available ;
   unsigned int navailable ;
   u32 sequence ;
   struct v4l2_m2m_ctx *m2m_ctx ;
};
#line 162 
enum v4l2_mbus_type {
    V4L2_MBUS_UNKNOWN = 0,
    V4L2_MBUS_PARALLEL = 1,
    V4L2_MBUS_BT656 = 2,
    V4L2_MBUS_CSI1 = 3,
    V4L2_MBUS_CCP2 = 4,
    V4L2_MBUS_CSI2_DPHY = 5,
    V4L2_MBUS_CSI2_CPHY = 6
};
#line 97  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-mediabus.h"
struct v4l2_mbus_config {
   enum v4l2_mbus_type type ;
   unsigned int flags ;
};
#line 184 
struct v4l2_subdev_fh;
#line 185 
struct tuner_setup;
#line 186 
struct v4l2_mbus_frame_desc;
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_decode_vbi_line {
   u32 is_second_field ;
   u8 *p ;
   u32 line ;
   u32 type ;
};
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_io_pin_config {
   u32 flags ;
   u8 pin ;
   u8 function ;
   u8 value ;
   u8 strength ;
};
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_core_ops {
   int (*log_status)(struct v4l2_subdev *) ;
   int (*s_io_pin_config)(struct v4l2_subdev *, size_t , struct v4l2_subdev_io_pin_config *) ;
   int (*init)(struct v4l2_subdev *, u32 ) ;
   int (*load_fw)(struct v4l2_subdev *) ;
   int (*reset)(struct v4l2_subdev *, u32 ) ;
   int (*s_gpio)(struct v4l2_subdev *, u32 ) ;
   long (*ioctl)(struct v4l2_subdev *, unsigned int , void *) ;
   long (*compat_ioctl32)(struct v4l2_subdev *, unsigned int , unsigned long ) ;
   int (*g_register)(struct v4l2_subdev *, struct v4l2_dbg_register *) ;
   int (*s_register)(struct v4l2_subdev *, struct v4l2_dbg_register *) ;
   int (*s_power)(struct v4l2_subdev *, int ) ;
   int (*interrupt_service_routine)(struct v4l2_subdev *, u32 , bool *) ;
   int (*subscribe_event)(struct v4l2_subdev *, struct v4l2_fh *, struct v4l2_event_subscription *) ;
   int (*unsubscribe_event)(struct v4l2_subdev *, struct v4l2_fh *, struct v4l2_event_subscription *) ;
};
#line 264  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_tuner_ops {
   int (*standby)(struct v4l2_subdev *) ;
   int (*s_radio)(struct v4l2_subdev *) ;
   int (*s_frequency)(struct v4l2_subdev *, struct v4l2_frequency *) ;
   int (*g_frequency)(struct v4l2_subdev *, struct v4l2_frequency *) ;
   int (*enum_freq_bands)(struct v4l2_subdev *, struct v4l2_frequency_band *) ;
   int (*g_tuner)(struct v4l2_subdev *, struct v4l2_tuner *) ;
   int (*s_tuner)(struct v4l2_subdev *, struct v4l2_tuner *) ;
   int (*g_modulator)(struct v4l2_subdev *, struct v4l2_modulator *) ;
   int (*s_modulator)(struct v4l2_subdev *, struct v4l2_modulator *) ;
   int (*s_type_addr)(struct v4l2_subdev *, struct tuner_setup *) ;
   int (*s_config)(struct v4l2_subdev *, struct v4l2_priv_tun_config *) ;
};
#line 304  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_audio_ops {
   int (*s_clock_freq)(struct v4l2_subdev *, u32 ) ;
   int (*s_i2s_clock_freq)(struct v4l2_subdev *, u32 ) ;
   int (*s_routing)(struct v4l2_subdev *, u32 , u32 , u32 ) ;
   int (*s_stream)(struct v4l2_subdev *, int ) ;
};
#line 310 
enum v4l2_mbus_frame_desc_flags {
    V4L2_MBUS_FRAME_DESC_FL_LEN_MAX = 1,
    V4L2_MBUS_FRAME_DESC_FL_BLOB = 2
};
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc_entry {
   enum v4l2_mbus_frame_desc_flags flags ;
   u32 pixelcode ;
   u32 length ;
};
#line 348  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc {
   struct v4l2_mbus_frame_desc_entry entry[4U] ;
   unsigned short num_entries ;
};
#line 415  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_video_ops {
   int (*s_routing)(struct v4l2_subdev *, u32 , u32 , u32 ) ;
   int (*s_crystal_freq)(struct v4l2_subdev *, u32 , u32 ) ;
   int (*g_std)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*s_std)(struct v4l2_subdev *, v4l2_std_id ) ;
   int (*s_std_output)(struct v4l2_subdev *, v4l2_std_id ) ;
   int (*g_std_output)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*querystd)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*g_tvnorms)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*g_tvnorms_output)(struct v4l2_subdev *, v4l2_std_id *) ;
   int (*g_input_status)(struct v4l2_subdev *, u32 *) ;
   int (*s_stream)(struct v4l2_subdev *, int ) ;
   int (*g_pixelaspect)(struct v4l2_subdev *, struct v4l2_fract *) ;
   int (*g_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_frame_interval *) ;
   int (*s_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_frame_interval *) ;
   int (*s_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *) ;
   int (*g_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *) ;
   int (*query_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *) ;
   int (*g_mbus_config)(struct v4l2_subdev *, struct v4l2_mbus_config *) ;
   int (*s_mbus_config)(struct v4l2_subdev *, struct v4l2_mbus_config *) ;
   int (*s_rx_buffer)(struct v4l2_subdev *, void *, unsigned int *) ;
};
#line 481  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_vbi_ops {
   int (*decode_vbi_line)(struct v4l2_subdev *, struct v4l2_decode_vbi_line *) ;
   int (*s_vbi_data)(struct v4l2_subdev *, struct v4l2_sliced_vbi_data *) ;
   int (*g_vbi_data)(struct v4l2_subdev *, struct v4l2_sliced_vbi_data *) ;
   int (*g_sliced_vbi_cap)(struct v4l2_subdev *, struct v4l2_sliced_vbi_cap *) ;
   int (*s_raw_fmt)(struct v4l2_subdev *, struct v4l2_vbi_format *) ;
   int (*g_sliced_fmt)(struct v4l2_subdev *, struct v4l2_sliced_vbi_format *) ;
   int (*s_sliced_fmt)(struct v4l2_subdev *, struct v4l2_sliced_vbi_format *) ;
};
#line 501  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_sensor_ops {
   int (*g_skip_top_lines)(struct v4l2_subdev *, u32 *) ;
   int (*g_skip_frames)(struct v4l2_subdev *, u32 *) ;
};
#line 505 
enum v4l2_subdev_ir_mode {
    V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0
};
#line 540  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_parameters {
   unsigned int bytes_per_data_element ;
   enum v4l2_subdev_ir_mode mode ;
   bool enable ;
   bool interrupt_enable ;
   bool shutdown ;
   bool modulation ;
   u32 max_pulse_width ;
   unsigned int carrier_freq ;
   unsigned int duty_cycle ;
   bool invert_level ;
   bool invert_carrier_sense ;
   u32 noise_filter_min_width ;
   unsigned int carrier_range_lower ;
   unsigned int carrier_range_upper ;
   u32 resolution ;
};
#line 599  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_ops {
   int (*rx_read)(struct v4l2_subdev *, u8 *, size_t , ssize_t *) ;
   int (*rx_g_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *) ;
   int (*rx_s_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *) ;
   int (*tx_write)(struct v4l2_subdev *, u8 *, size_t , ssize_t *) ;
   int (*tx_g_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *) ;
   int (*tx_s_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *) ;
};
#line 630  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_config {
   struct v4l2_mbus_framefmt try_fmt ;
   struct v4l2_rect try_crop ;
   struct v4l2_rect try_compose ;
};
#line 674  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_ops {
   int (*init_cfg)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *) ;
   int (*enum_mbus_code)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_mbus_code_enum *) ;
   int (*enum_frame_size)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_frame_size_enum *) ;
   int (*enum_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_frame_interval_enum *) ;
   int (*get_fmt)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_format *) ;
   int (*set_fmt)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_format *) ;
   int (*get_selection)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_selection *) ;
   int (*set_selection)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_selection *) ;
   int (*get_edid)(struct v4l2_subdev *, struct v4l2_edid *) ;
   int (*set_edid)(struct v4l2_subdev *, struct v4l2_edid *) ;
   int (*dv_timings_cap)(struct v4l2_subdev *, struct v4l2_dv_timings_cap *) ;
   int (*enum_dv_timings)(struct v4l2_subdev *, struct v4l2_enum_dv_timings *) ;
   int (*link_validate)(struct v4l2_subdev *, struct media_link *, struct v4l2_subdev_format *, struct v4l2_subdev_format *) ;
   int (*get_frame_desc)(struct v4l2_subdev *, unsigned int , struct v4l2_mbus_frame_desc *) ;
   int (*set_frame_desc)(struct v4l2_subdev *, unsigned int , struct v4l2_mbus_frame_desc *) ;
};
#line 727  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_ops {
   struct v4l2_subdev_core_ops *core ;
   struct v4l2_subdev_tuner_ops *tuner ;
   struct v4l2_subdev_audio_ops *audio ;
   struct v4l2_subdev_video_ops *video ;
   struct v4l2_subdev_vbi_ops *vbi ;
   struct v4l2_subdev_ir_ops *ir ;
   struct v4l2_subdev_sensor_ops *sensor ;
   struct v4l2_subdev_pad_ops *pad ;
};
#line 765  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_internal_ops {
   int (*registered)(struct v4l2_subdev *) ;
   void (*unregistered)(struct v4l2_subdev *) ;
   int (*open)(struct v4l2_subdev *, struct v4l2_subdev_fh *) ;
   int (*close)(struct v4l2_subdev *, struct v4l2_subdev_fh *) ;
   void (*release)(struct v4l2_subdev *) ;
};
#line 772 
struct regulator_bulk_data;
#line 797  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_platform_data {
   struct regulator_bulk_data *regulators ;
   int num_regulators ;
   void *host_priv ;
};
#line 848  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev {
   struct media_entity entity ;
   struct list_head list ;
   struct module *owner ;
   bool owner_v4l2_dev ;
   u32 flags ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev_ops *ops ;
   struct v4l2_subdev_internal_ops *internal_ops ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   char name[32U] ;
   u32 grp_id ;
   void *dev_priv ;
   void *host_priv ;
   struct video_device *devnode ;
   struct device *dev ;
   struct fwnode_handle *fwnode ;
   struct list_head async_list ;
   struct v4l2_async_subdev *asd ;
   struct v4l2_async_notifier *notifier ;
   struct v4l2_async_notifier *subdev_notifier ;
   struct v4l2_subdev_platform_data *pdata ;
};
#line 906  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
struct v4l2_subdev_fh {
   struct v4l2_fh vfh ;
   struct module *owner ;
   struct v4l2_subdev_pad_config *pad ;
};
#line 47  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-device.h"
struct v4l2_device {
   struct device *dev ;
   struct media_device *mdev ;
   struct list_head subdevs ;
   spinlock_t lock ;
   char name[36U] ;
   void (*notify)(struct v4l2_subdev *, unsigned int , void *) ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct v4l2_prio_state prio ;
   struct kref ref ;
   void (*release)(struct v4l2_device *) ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ptp_clock_kernel.h"
struct ptp_system_timestamp {
   struct timespec64 pre_ts ;
   struct timespec64 post_ts ;
};
#line 277 
struct dma_chan;
#line 279 
struct spi_controller;
#line 280 
struct spi_transfer;
#line 281 
struct spi_controller_mem_ops;
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_statistics {
   spinlock_t lock ;
   unsigned long messages ;
   unsigned long transfers ;
   unsigned long errors ;
   unsigned long timedout ;
   unsigned long spi_sync ;
   unsigned long spi_sync_immediate ;
   unsigned long spi_async ;
   unsigned long long bytes ;
   unsigned long long bytes_rx ;
   unsigned long long bytes_tx ;
   unsigned long transfer_bytes_histo[17U] ;
   unsigned long transfers_split_maxsize ;
};
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_delay {
   u16 value ;
   u8 unit ;
};
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_controller *controller ;
   struct spi_controller *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   bool rt ;
   u32 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   char *driver_override ;
   int cs_gpio ;
   struct gpio_desc *cs_gpiod ;
   struct spi_delay word_delay ;
   struct spi_statistics statistics ;
};
#line 247 
struct spi_message;
#line 452  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_controller {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u32 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   bool slave ;
   size_t (*max_transfer_size)(struct spi_device *) ;
   size_t (*max_message_size)(struct spi_device *) ;
   struct mutex io_mutex ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device *) ;
   int (*set_cs_timing)(struct spi_device *, struct spi_delay *, struct spi_delay *, struct spi_delay *) ;
   int (*transfer)(struct spi_device *, struct spi_message *) ;
   void (*cleanup)(struct spi_device *) ;
   bool (*can_dma)(struct spi_controller *, struct spi_device *, struct spi_transfer *) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_controller *) ;
   int (*transfer_one_message)(struct spi_controller *, struct spi_message *) ;
   int (*unprepare_transfer_hardware)(struct spi_controller *) ;
   int (*prepare_message)(struct spi_controller *, struct spi_message *) ;
   int (*unprepare_message)(struct spi_controller *, struct spi_message *) ;
   int (*slave_abort)(struct spi_controller *) ;
   void (*set_cs)(struct spi_device *, bool ) ;
   int (*transfer_one)(struct spi_controller *, struct spi_device *, struct spi_transfer *) ;
   void (*handle_err)(struct spi_controller *, struct spi_message *) ;
   struct spi_controller_mem_ops *mem_ops ;
   struct spi_delay cs_setup ;
   struct spi_delay cs_hold ;
   struct spi_delay cs_inactive ;
   int *cs_gpios ;
   struct gpio_desc **cs_gpiods ;
   bool use_gpio_descriptors ;
   struct spi_statistics statistics ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
   int (*fw_translate_cs)(struct spi_controller *, unsigned int ) ;
   bool ptp_sts_supported ;
   unsigned long irq_flags ;
};
#line 890  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_transfer {
   void *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned int cs_change : 1 ;
   unsigned int tx_nbits : 3 ;
   unsigned int rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   struct spi_delay delay ;
   struct spi_delay cs_change_delay ;
   struct spi_delay word_delay ;
   u32 speed_hz ;
   u32 effective_speed_hz ;
   unsigned int ptp_sts_word_pre ;
   unsigned int ptp_sts_word_post ;
   struct ptp_system_timestamp *ptp_sts ;
   bool timestamped_pre ;
   bool timestamped_post ;
   struct list_head transfer_list ;
};
#line 961  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int is_dma_mapped : 1 ;
   void (*complete)(void *) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
   struct list_head resources ;
};
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 157  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_fix_screeninfo {
   char id[16U] ;
   unsigned long smem_start ;
   __u32 smem_len ;
   __u32 type ;
   __u32 type_aux ;
   __u32 visual ;
   __u16 xpanstep ;
   __u16 ypanstep ;
   __u16 ywrapstep ;
   __u32 line_length ;
   unsigned long mmio_start ;
   __u32 mmio_len ;
   __u32 accel ;
   __u16 capabilities ;
   __u16 reserved[2U] ;
};
#line 188  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_bitfield {
   __u32 offset ;
   __u32 length ;
   __u32 msb_right ;
};
#line 241  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_var_screeninfo {
   __u32 xres ;
   __u32 yres ;
   __u32 xres_virtual ;
   __u32 yres_virtual ;
   __u32 xoffset ;
   __u32 yoffset ;
   __u32 bits_per_pixel ;
   __u32 grayscale ;
   struct fb_bitfield red ;
   struct fb_bitfield green ;
   struct fb_bitfield blue ;
   struct fb_bitfield transp ;
   __u32 nonstd ;
   __u32 activate ;
   __u32 height ;
   __u32 width ;
   __u32 accel_flags ;
   __u32 pixclock ;
   __u32 left_margin ;
   __u32 right_margin ;
   __u32 upper_margin ;
   __u32 lower_margin ;
   __u32 hsync_len ;
   __u32 vsync_len ;
   __u32 sync ;
   __u32 vmode ;
   __u32 rotate ;
   __u32 colorspace ;
   __u32 reserved[4U] ;
};
#line 281  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_cmap {
   __u32 start ;
   __u32 len ;
   __u16 *red ;
   __u16 *green ;
   __u16 *blue ;
   __u16 *transp ;
};
#line 341  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_copyarea {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 sx ;
   __u32 sy ;
};
#line 350  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_fillrect {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 color ;
   __u32 rop ;
};
#line 359  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_image {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 fg_color ;
   __u32 bg_color ;
   __u8 depth ;
   char *data ;
   struct fb_cmap cmap ;
};
#line 383  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fbcurpos {
   __u16 x ;
   __u16 y ;
};
#line 387  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/fb.h"
struct fb_cursor {
   __u16 set ;
   __u16 enable ;
   __u16 rop ;
   char *mask ;
   struct fbcurpos hot ;
   struct fb_image image ;
};
#line 400 
enum backlight_type {
    BACKLIGHT_RAW = 1,
    BACKLIGHT_PLATFORM = 2,
    BACKLIGHT_FIRMWARE = 3,
    BACKLIGHT_TYPE_MAX = 4
};
#line 412 
enum backlight_scale {
    BACKLIGHT_SCALE_UNKNOWN = 0,
    BACKLIGHT_SCALE_LINEAR = 1,
    BACKLIGHT_SCALE_NON_LINEAR = 2
};
#line 418 
struct backlight_device;
#line 419 
struct fb_info;
#line 58  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backlight.h"
struct backlight_ops {
   unsigned int options ;
   int (*update_status)(struct backlight_device *) ;
   int (*get_brightness)(struct backlight_device *) ;
   int (*check_fb)(struct backlight_device *, struct fb_info *) ;
};
#line 74  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backlight.h"
struct backlight_properties {
   int brightness ;
   int max_brightness ;
   int power ;
   int fb_blank ;
   enum backlight_type type ;
   unsigned int state ;
   enum backlight_scale scale ;
};
#line 97  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/backlight.h"
struct backlight_device {
   struct backlight_properties props ;
   struct mutex update_lock ;
   struct mutex ops_lock ;
   struct backlight_ops *ops ;
   struct notifier_block fb_notif ;
   struct list_head entry ;
   struct device dev ;
   bool fb_bl_on[32U] ;
   int use_count ;
};
#line 52  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_chroma {
   __u32 redx ;
   __u32 greenx ;
   __u32 bluex ;
   __u32 whitex ;
   __u32 redy ;
   __u32 greeny ;
   __u32 bluey ;
   __u32 whitey ;
};
#line 63 
struct fb_videomode;
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_monspecs {
   struct fb_chroma chroma ;
   struct fb_videomode *modedb ;
   __u8 manufacturer[4U] ;
   __u8 monitor[14U] ;
   __u8 serial_no[14U] ;
   __u8 ascii[14U] ;
   __u32 modedb_len ;
   __u32 model ;
   __u32 serial ;
   __u32 year ;
   __u32 week ;
   __u32 hfmin ;
   __u32 hfmax ;
   __u32 dclkmin ;
   __u32 dclkmax ;
   __u16 input ;
   __u16 dpms ;
   __u16 signal ;
   __u16 vfmin ;
   __u16 vfmax ;
   __u16 gamma ;
   __u16 gtf : 1 ;
   __u16 misc ;
   __u8 version ;
   __u8 revision ;
   __u8 max_x ;
   __u8 max_y ;
};
#line 144  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_blit_caps {
   u32 x ;
   u32 y ;
   u32 len ;
   u32 flags ;
};
#line 185  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_pixmap {
   u8 *addr ;
   u32 size ;
   u32 offset ;
   u32 buf_align ;
   u32 scan_align ;
   u32 access_align ;
   u32 flags ;
   u32 blit_x ;
   u32 blit_y ;
   void (*writeio)(struct fb_info *, void *, void *, unsigned int ) ;
   void (*readio)(struct fb_info *, void *, void *, unsigned int ) ;
};
#line 203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_deferred_io {
   unsigned long delay ;
   struct mutex lock ;
   struct list_head pagelist ;
   void (*first_io)(struct fb_info *) ;
   void (*deferred_io)(struct fb_info *, struct list_head *) ;
};
#line 228  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_ops {
   struct module *owner ;
   int (*fb_open)(struct fb_info *, int ) ;
   int (*fb_release)(struct fb_info *, int ) ;
   ssize_t (*fb_read)(struct fb_info *, char *, size_t , loff_t *) ;
   ssize_t (*fb_write)(struct fb_info *, char *, size_t , loff_t *) ;
   int (*fb_check_var)(struct fb_var_screeninfo *, struct fb_info *) ;
   int (*fb_set_par)(struct fb_info *) ;
   int (*fb_setcolreg)(unsigned int , unsigned int , unsigned int , unsigned int , unsigned int , struct fb_info *) ;
   int (*fb_setcmap)(struct fb_cmap *, struct fb_info *) ;
   int (*fb_blank)(int , struct fb_info *) ;
   int (*fb_pan_display)(struct fb_var_screeninfo *, struct fb_info *) ;
   void (*fb_fillrect)(struct fb_info *, struct fb_fillrect *) ;
   void (*fb_copyarea)(struct fb_info *, struct fb_copyarea *) ;
   void (*fb_imageblit)(struct fb_info *, struct fb_image *) ;
   int (*fb_cursor)(struct fb_info *, struct fb_cursor *) ;
   int (*fb_sync)(struct fb_info *) ;
   int (*fb_ioctl)(struct fb_info *, unsigned int , unsigned long ) ;
   int (*fb_compat_ioctl)(struct fb_info *, unsigned int , unsigned long ) ;
   int (*fb_mmap)(struct fb_info *, struct vm_area_struct *) ;
   void (*fb_get_caps)(struct fb_info *, struct fb_blit_caps *, struct fb_var_screeninfo *) ;
   void (*fb_destroy)(struct fb_info *) ;
   int (*fb_debug_enter)(struct fb_info *) ;
   int (*fb_debug_leave)(struct fb_info *) ;
};
#line 306  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tilemap {
   __u32 width ;
   __u32 height ;
   __u32 depth ;
   __u32 length ;
   __u8 *data ;
};
#line 315  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tilerect {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 index ;
   __u32 fg ;
   __u32 bg ;
   __u32 rop ;
};
#line 326  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tilearea {
   __u32 sx ;
   __u32 sy ;
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
};
#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tileblit {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 fg ;
   __u32 bg ;
   __u32 length ;
   __u32 *indices ;
};
#line 346  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tilecursor {
   __u32 sx ;
   __u32 sy ;
   __u32 mode ;
   __u32 shape ;
   __u32 fg ;
   __u32 bg ;
};
#line 355  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_tile_ops {
   void (*fb_settile)(struct fb_info *, struct fb_tilemap *) ;
   void (*fb_tilecopy)(struct fb_info *, struct fb_tilearea *) ;
   void (*fb_tilefill)(struct fb_info *, struct fb_tilerect *) ;
   void (*fb_tileblit)(struct fb_info *, struct fb_tileblit *) ;
   void (*fb_tilecursor)(struct fb_info *, struct fb_tilecursor *) ;
   int (*fb_get_tilemax)(struct fb_info *) ;
};
#line 499  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct aperture {
   resource_size_t base ;
   resource_size_t size ;
};
#line 497  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct apertures_struct {
   unsigned int count ;
   struct aperture ranges[0U] ;
};
#line 439  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
union __anonunion_3495 {
   char *screen_base ;
   char *screen_buffer ;
};
#line 439  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_info {
   atomic_t count ;
   int node ;
   int flags ;
   int fbcon_rotate_hint ;
   struct mutex lock ;
   struct mutex mm_lock ;
   struct fb_var_screeninfo var ;
   struct fb_fix_screeninfo fix ;
   struct fb_monspecs monspecs ;
   struct work_struct queue ;
   struct fb_pixmap pixmap ;
   struct fb_pixmap sprite ;
   struct fb_cmap cmap ;
   struct list_head modelist ;
   struct fb_videomode *mode ;
   struct backlight_device *bl_dev ;
   struct mutex bl_curve_mutex ;
   u8 bl_curve[128U] ;
   struct delayed_work deferred_work ;
   struct fb_deferred_io *fbdefio ;
   struct fb_ops *fbops ;
   struct device *device ;
   struct device *dev ;
   int class_flag ;
   struct fb_tile_ops *tileops ;
   union __anonunion_3495 __anonCompField_fb_info_73 ;
   unsigned long screen_size ;
   void *pseudo_palette ;
   u32 state ;
   void *fbcon_par ;
   void *par ;
   struct apertures_struct *apertures ;
   bool skip_vt_switch ;
};
#line 767  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fb.h"
struct fb_videomode {
   char *name ;
   u32 refresh ;
   u32 xres ;
   u32 yres ;
   u32 pixclock ;
   u32 left_margin ;
   u32 right_margin ;
   u32 upper_margin ;
   u32 lower_margin ;
   u32 hsync_len ;
   u32 vsync_len ;
   u32 sync ;
   u32 vmode ;
   u32 flag ;
};
#line 63  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
struct ldv_kmem_cache {
   char *name ;
   unsigned int size ;
};
#line 88  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
typedef unsigned long pthread_t;
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/thread.h"
union pthread_attr_t {
   char __size[56U] ;
   long __align ;
};
#line 30  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/thread.h"
typedef union pthread_attr_t pthread_attr_t;
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/timer.h"
enum hrtimer_restart;
#line 13  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_free_irq_4 {
   int arg0 ;
   int signal_pending ;
};
#line 18  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_interrupt_scenario_airo_interrupt_11 {
   int arg0 ;
   enum irqreturn (*arg1)(int , void *) ;
   enum irqreturn (*arg2)(int , void *) ;
   void *arg3 ;
   int signal_pending ;
};
#line 26  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_random_allocationless_scenario_airo_get_stats_12 {
   struct net_device *arg0 ;
   int signal_pending ;
};
#line 31  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
struct emg_struct_pci_scenario_airo_driver_13 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};
/* compiler builtin: 
   unsigned short __builtin_bswap16(unsigned short);   */
/* compiler builtin: 
   unsigned int __builtin_bswap32(unsigned int);   */
/* compiler builtin: 
   void *__builtin_memcpy(void *, void const *, unsigned long);   */
/* compiler builtin: 
   unsigned long __builtin_object_size(void *, int);   */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list);   */
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/common/inline_asm.h"
#line 22 
void ldv_inline_asm(void);
#line 16  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
#line 16 
struct task_struct *ldv_get_current(void);
#line 16  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/export.h"
#line 16 
extern struct module __this_module;
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compiler.h"
__inline static void __read_once_size(void *p, void *res, int size)
{
  #line 199 
  switch (size) {
    #line 199 
    case 1: 
            #line 199 
    ;
    #line 199 
    *((__u8 *)res) = *((__u8 *)p);
    #line 199 
    break;
    #line 199 
    case 2: 
            #line 199 
    ;
    #line 199 
    *((__u16 *)res) = *((__u16 *)p);
    #line 199 
    break;
    #line 199 
    case 4: 
            #line 199 
    ;
    #line 199 
    *((__u32 *)res) = *((__u32 *)p);
    #line 199 
    break;
    #line 199 
    case 8: 
            #line 199 
    ;
    #line 199 
    *((__u64 *)res) = *((__u64 *)p);
    #line 199 
    break;
    #line 199 
    default: 
             #line 199 
    ;
    #line 200 
    ldv_inline_asm();
    #line 199 
    __builtin_memcpy(res,(void const *)p,(unsigned long)size);
    #line 200 
    ldv_inline_asm();
  }
  #line 203 
  return;
}

#line 220  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/compiler.h"
__inline static void __write_once_size(void *p, void *res, int size)
{
  #line 222 
  switch (size) {
    #line 223 
    case 1: 
            #line 223 
    ;
    #line 223 
    *((__u8 *)p) = *((__u8 *)res);
    #line 223 
    break;
    #line 224 
    case 2: 
            #line 224 
    ;
    #line 224 
    *((__u16 *)p) = *((__u16 *)res);
    #line 224 
    break;
    #line 225 
    case 4: 
            #line 225 
    ;
    #line 225 
    *((__u32 *)p) = *((__u32 *)res);
    #line 225 
    break;
    #line 226 
    case 8: 
            #line 226 
    ;
    #line 226 
    *((__u64 *)p) = *((__u64 *)res);
    #line 226 
    break;
    #line 227 
    default: 
             #line 227 
    ;
    #line 228 
    ldv_inline_asm();
    #line 229 
    __builtin_memcpy(p,(void const *)res,(unsigned long)size);
    #line 230 
    ldv_inline_asm();
  }
  #line 232 
  return;
}

#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kasan-checks.h"
__inline static bool kasan_check_read(void *p, unsigned int size)
{
  #line 36 
  return (_Bool)1;
}

#line 123  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static void arch_change_bit(long nr, unsigned long *addr)
{
  #line 125 
  if (0 != 0) 
              #line 127 
              ldv_inline_asm(); else 
                                     #line 130 
                                     ldv_inline_asm();
  #line 131 
  return;
}

#line 204  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static bool constant_test_bit(long nr, unsigned long *addr)
{
  #line 207 
  return (_Bool)(((*(addr + (unsigned long)(nr >> 6)) >> (nr & 63L)) & 1UL) != 0UL);
}

#line 210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/bitops.h"
__inline static bool variable_test_bit(long nr, unsigned long *addr)
{
  #line 212 
  bool oldbit;
  #line 213 
  ldv_inline_asm();
  #line 219 
  return oldbit;
}

#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 207  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void cif_set_bit(long nr, unsigned long *addr);
#line 44  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
#line 214  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void cif_clear_bit(long nr, unsigned long *addr);
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-atomic.h"
__inline static void change_bit(long nr, unsigned long *addr)
{
  #line 57 
  kasan_check_read((void *)(addr + (unsigned long)(nr / 64L)),8U);
  #line 58 
  arch_change_bit(nr,addr);
  #line 59 
  return;
}

#line 108  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bitops/instrumented-non-atomic.h"
__inline static bool test_bit(long nr, unsigned long *addr)
{
  #line 111 
  int tmp_1;
  #line 110 
  kasan_check_read((void *)(addr + (unsigned long)(nr / 64L)),8U);
  #line 111 
  if (0 != 0) {
    #line 111 
    tmp_1 = (int)constant_test_bit(nr,addr) != 0;
  }
  else {
    #line 111 
    tmp_1 = (int)variable_test_bit(nr,addr) != 0;
  }
  #line 111 
  return (_Bool)(tmp_1 != 0);
}

#line 64  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/uapi/linux/byteorder/little_endian.h"
__inline static __u16 __le16_to_cpup(__le16 *p)
{
  #line 66 
  return *p;
}

#line 171  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/printk.h"
#line 171 
int printk(char * , ...);
#line 23  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/jump_label.h"
__inline static bool arch_static_branch(struct static_key *key, bool branch)
{
  #line 27 
  ldv_inline_asm();
  #line 28 
  ldv_inline_asm();
  #line 34 
  return (_Bool)0;
  #line 35 
  l_yes: 
         #line 35 
  ;
  #line 36 
  return (_Bool)1;
}

#line 204  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kernel.h"
#line 204 
void __might_sleep(char *, int, int);
#line 469 
#line 469 
int sprintf(char *, char * , ...);
#line 623 
#line 623 
int hex_to_bin(char);
#line 627 
#line 627 
bool mac_pton(char *, u8 *);
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
#line 221  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void INIT_LIST_HEAD(struct list_head *list);
#line 33  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
#line 33 
bool __list_add_valid(struct list_head *, struct list_head *, struct list_head *);
#line 36 
#line 36 
bool __list_del_entry_valid(struct list_head *);
#line 56  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next)
{
  #line 60 
  if (! __list_add_valid(new,prev,next)) 
                                         #line 61 
                                         return;
  #line 63 
  next->prev = new;
  #line 64 
  new->next = next;
  #line 65 
  new->prev = prev;
  {
    #line 67 
    union __anonunion___u_13 __u = {.__val = new};
    #line 66 
    __write_once_size((void *)(& prev->next),(void *)(& __u.__c),8);
    #line 66 
    struct list_head *tmp_2 = __u.__val;
  }
  #line 68 
  return;
}

#line 91  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new, struct list_head *head)
{
  #line 93 
  __list_add(new,head->prev,head);
  #line 94 
  return;
}

#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_del(struct list_head *prev, struct list_head *next)
{
  #line 97 
  next->prev = prev;
  {
    #line 107 
    union __anonunion___u_15 __u = {.__val = next};
    #line 106 
    __write_once_size((void *)(& prev->next),(void *)(& __u.__c),8);
    #line 106 
    struct list_head *tmp = __u.__val;
  }
  #line 108 
  return;
}

#line 129  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void __list_del_entry(struct list_head *entry)
{
  #line 131 
  if (! __list_del_entry_valid(entry)) 
                                       #line 132 
                                       return;
  #line 134 
  __list_del(entry->prev,entry->next);
  #line 135 
  return;
}

#line 137  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void list_del(struct list_head *entry)
{
  #line 139 
  __list_del_entry(entry);
  #line 140 
  entry->next = (struct list_head *)(-2401263026318606080);
  #line 141 
  entry->prev = (struct list_head *)(-2401263026318606046);
  #line 142 
  return;
}

#line 210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static void list_move_tail(struct list_head *list, struct list_head *head)
{
  #line 213 
  __list_del_entry(list);
  #line 214 
  list_add_tail(list,head);
  #line 215 
  return;
}

#line 266  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/list.h"
__inline static int list_empty(struct list_head *head)
{
  #line 269 
  union __anonunion___u_17 __u;
  #line 268 
  __read_once_size((void *)(& head->next),(void *)(& __u.__c),8);
  #line 268 
  ;
  #line 268 
  return (__u.__val) == head;
}

#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/percpu.h"
#line 88 
void __bad_percpu_size(void);
#line 89  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/bug.h"
#line 89 
void __warn_printk(char * , ...);
#line 14  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/string_64.h"
#line 14 
void *memcpy(void *, void *, size_t);
#line 18 
#line 18 
void *memset(void *, int, size_t);
#line 61 
#line 61 
int memcmp(void *, void *, size_t);
#line 63 
#line 63 
char *strcpy(char *, char *);
#line 26  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/string.h"
#line 26 
char *strncpy(char *, char *, __kernel_size_t);
#line 52 
#line 228  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static int cif_strncmp(char *cs, char *ct, __kernel_size_t count);
#line 88  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/string.h"
#line 235  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static size_t cif_strlen(char *s);
#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/cmpxchg.h"
#line 13 
void __xchg_wrong_size(void);
#line 9  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/cmpxchg_64.h"
__inline static int arch_atomic_read(atomic_t *v)
{
  #line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/atomic.h"
  union __anonunion___u_67 __u;
  #line 31 
  __read_once_size((void *)(& v->counter),(void *)(& __u.__c),4);
  #line 31 
  return (__u.__val);
}

#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/atomic-instrumented.h"
__inline static int atomic_read(atomic_t *v)
{
  #line 26 
  kasan_check_read((void *)v,4U);
  #line 27 
  return arch_atomic_read(v);
}

#line 29  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 298  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static long PTR_ERR(void *ptr);
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/err.h"
#line 305  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static bool IS_ERR(void *ptr);
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/irqflags.h"
#line 20 
unsigned long native_save_fl(void);
#line 20  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/irqflags.h"
unsigned long native_save_fl(void)
{
  #line 22 
  unsigned long flags;
  #line 23 
  ldv_inline_asm();
  #line 35 
  return flags;
}

#line 38 
#line 39 
void native_restore_fl(unsigned long flags);
#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/irqflags.h"
void native_restore_fl(unsigned long flags)
{
  #line 41 
  ldv_inline_asm();
  #line 42 
  return;
}

#line 112  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/thread_info.h"
#line 112 
void __check_object_size(void *, unsigned long, bool);
#line 115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/thread_info.h"
__inline static void check_object_size(void *ptr, unsigned long n, bool to_user)
{
  #line 118 
  if (0 == 0) 
              #line 119 
              __check_object_size(ptr,n,(_Bool)((bool)((int)to_user) != 0));
  #line 120 
  return;
}

#line 128 
#line 128 
void __bad_copy_from(void);
#line 130 
#line 130 
void __bad_copy_to(void);
#line 132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/thread_info.h"
__inline static void copy_overflow(int size, unsigned long count)
{
  #line 134 
  int __ret_warn_on = 1;
  #line 134 
  if ((long)(__ret_warn_on != 0) != 0L) {
    #line 134 
    __warn_printk((char *)"Buffer overflow detected (%d < %lu)!\n",size,count);
    #line 135 
    ldv_inline_asm();
    #line 136 
    ldv_inline_asm();
  }
  #line 134 
  long tmp = (long)(__ret_warn_on != 0);
  #line 136 
  return;
}

#line 138  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/thread_info.h"
__inline static bool check_copy_size(void *addr, size_t bytes, bool is_source)
{
  #line 150 
  int __ret_warn_on;
  #line 140 
  int sz = (int)__builtin_object_size(addr,0);
  #line 141 
  if ((long)(sz >= 0) != 0L && (long)((unsigned long)sz < bytes) != 0L) {
    #line 142 
    if (0 == 0) 
                #line 143 
                copy_overflow(sz,bytes);
    else 
      #line 144 
      if ((int)is_source != 0) 
                               #line 145 
                               __bad_copy_from(); else 
                                                       #line 147 
                                                       __bad_copy_to();
    #line 148 
    return (_Bool)0;
  }
  #line 150 
  __ret_warn_on = bytes > 2147483647UL;
  #line 150 
  if ((long)(__ret_warn_on != 0) != 0L) {
    #line 151 
    ldv_inline_asm();
    #line 152 
    ldv_inline_asm();
  }
  #line 150 
  if ((long)((long)(__ret_warn_on != 0)) != 0L) 
                                                #line 151 
                                                return (_Bool)0;
  #line 152 
  check_object_size(addr,bytes,(_Bool)((bool)((int)is_source) != 0));
  #line 153 
  return (_Bool)1;
}

#line 24  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void)
{
  #line 26 
  int pfo_ret__;
  #line 26 
  switch (4UL) {
    #line 26 
    case (unsigned long)1: 
                           #line 26 
    ;
    #line 27 
    ldv_inline_asm();
    #line 26 
    break;
    #line 26 
    case (unsigned long)2: 
                           #line 26 
    ;
    #line 27 
    ldv_inline_asm();
    #line 26 
    break;
    #line 26 
    case (unsigned long)4: 
                           #line 26 
    ;
    #line 27 
    ldv_inline_asm();
    #line 26 
    break;
    #line 26 
    case (unsigned long)8: 
                           #line 26 
    ;
    #line 27 
    ldv_inline_asm();
    #line 26 
    break;
    #line 26 
    default: 
             #line 26 
    ;
    #line 26 
    __bad_percpu_size();
  }
  #line 26 
  return pfo_ret__ & 2147483647;
}

#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/debug_locks.h"
#line 55 
void debug_check_no_locks_held(void);
#line 302  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/lockdep.h"
#line 302 
void lockdep_init_map(struct lockdep_map *, char *, struct lock_class_key *, int);
#line 95  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
#line 95 
void __raw_spin_lock_init(raw_spinlock_t *, char *, struct lock_class_key *);
#line 43  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock_api_smp.h"
#line 43 
void _raw_spin_unlock_irqrestore(raw_spinlock_t *, unsigned long);
#line 325  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
  #line 327 
  return & lock->__anonCompField_spinlock_25.rlock;
}

#line 391  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/spinlock.h"
static void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
  {
    #line 393 
    unsigned long __dummy;
    #line 393 
    unsigned long __dummy2;
    }
  #line 393 
  _raw_spin_unlock_irqrestore(& lock->__anonCompField_spinlock_25.rlock,flags);
  #line 395 
  return;
}

#line 395 
#line 765  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void cif_spin_unlock_irqrestore_aux_lock_of_airo_info(spinlock_t *lock, unsigned long flags);
#line 33 
#line 33 
void __ldv_spin_lock(spinlock_t *);
#line 35 
#line 756 
static void cif___ldv_spin_lock_aux_lock_of_airo_info(spinlock_t *lock);
#line 40 
#line 40 
void ldv_spin_model_lock(char *);
#line 41 
#line 41 
void ldv_spin_model_unlock(char *);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/err.h"
#line 23 
bool ldv_is_err(void *ptr);
#line 26 
#line 26 
long ldv_ptr_err(void *ptr);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/bitmap.h"
#line 21 
void ldv_set_bit(long nr, unsigned long *addr);
#line 22 
#line 22 
void ldv_clear_bit(long nr, unsigned long *addr);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/string.h"
#line 25 
size_t ldv_strlen(char *s);
#line 27 
#line 27 
int ldv_strncmp(char *cs, char *ct, __kernel_size_t count);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/list.h"
#line 23 
void ldv_init_list_head(struct list_head *list);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 23 
void *ldv_kzalloc(size_t size, gfp_t flags);
#line 24 
#line 24 
void *ldv_kmalloc(size_t size, gfp_t flags);
#line 25 
#line 25 
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags);
#line 26 
#line 26 
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags);
#line 19  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
#line 19 
extern struct user_namespace init_user_ns;
#line 34  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
__inline static uid_t __kuid_val(kuid_t uid)
{
  #line 36 
  return uid.val;
}

#line 39  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
__inline static gid_t __kgid_val(kgid_t gid)
{
  #line 41 
  return gid.val;
}

#line 111  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
__inline static bool uid_valid(kuid_t uid)
{
  #line 113 
  return (_Bool)(__kuid_val(uid) != 4294967295U);
}

#line 116  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uidgid.h"
__inline static bool gid_valid(kgid_t gid)
{
  #line 118 
  return (_Bool)(__kgid_val(gid) != 4294967295U);
}

#line 123 
#line 123 
kuid_t make_kuid(struct user_namespace *, uid_t);
#line 124 
#line 124 
kgid_t make_kgid(struct user_namespace *, gid_t);
#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/wait.h"
#line 17 
int default_wake_function(struct wait_queue_entry *, unsigned int, int, void *);
#line 61 
#line 61 
void __init_waitqueue_head(struct wait_queue_head *, char *, struct lock_class_key *);
#line 79  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/wait.h"
__inline static void init_waitqueue_entry(struct wait_queue_entry *wq_entry, struct task_struct *p)
{
  #line 81 
  wq_entry->flags = 0U;
  #line 82 
  wq_entry->private = (void *)p;
  #line 83 
  wq_entry->func = & default_wake_function;
  #line 84 
  return;
}

#line 163 
#line 163 
void add_wait_queue(struct wait_queue_head *, struct wait_queue_entry *);
#line 165 
#line 165 
void remove_wait_queue(struct wait_queue_head *, struct wait_queue_entry *);
#line 200 
#line 200 
void __wake_up(struct wait_queue_head *, unsigned int, int, void *);
#line 81  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/jiffies.h"
#line 81 
extern unsigned long jiffies;
#line 206  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
#line 206 
void *ioremap(resource_size_t, unsigned long);
#line 209 
#line 209 
void iounmap(void *);
#line 216 
#line 216 
void memcpy_fromio(void *, void *, size_t);
#line 217 
#line 217 
void memcpy_toio(void *, void *, size_t);
#line 262 
#line 262 
extern struct static_key_false sev_enable_key;
#line 263  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static bool sev_key_active(void)
{
  #line 265 
  bool branch;
  #line 265 
  branch = arch_static_branch(& sev_enable_key.key,(_Bool)0);
  #line 265 
  return (_Bool)((long)((long)((int)branch != 0)) != 0L);
}

#line 334  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static void outb(unsigned char value, int port)
{
  #line 336 
  ldv_inline_asm();
  #line 337 
  return;
}

#line 334  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static unsigned char inb(int port)
{
  #line 334 
  unsigned char value;
  #line 335 
  ldv_inline_asm();
  #line 334 
  return value;
}

#line 334  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static void outsb(int port, void *addr, unsigned long count)
{
  #line 334 
  if ((int)sev_key_active() != 0) {
    #line 334 
    unsigned char *value = (unsigned char *)addr;
    #line 334 
    while (count != 0UL) {
      #line 334 
      outb((unsigned char)((int)*value),port);
      #line 334 
      value ++;
      #line 334 
      count --;
    }
  }
  else 
       #line 338 
       ldv_inline_asm();
  #line 339 
  return;
}

#line 334  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static void insb(int port, void *addr, unsigned long count)
{
  #line 334 
  if ((int)sev_key_active() != 0) {
    #line 334 
    unsigned char *value = (unsigned char *)addr;
    #line 334 
    while (count != 0UL) {
      #line 334 
      *value = inb(port);
      #line 334 
      value ++;
      #line 334 
      count --;
    }
  }
  else 
       #line 338 
       ldv_inline_asm();
  #line 339 
  return;
}

#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static void outw(unsigned short value, int port)
{
  #line 337 
  ldv_inline_asm();
  #line 338 
  return;
}

#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static unsigned short inw(int port)
{
  #line 335 
  unsigned short value;
  #line 336 
  ldv_inline_asm();
  #line 335 
  return value;
}

#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static void outsw(int port, void *addr, unsigned long count)
{
  #line 335 
  if ((int)sev_key_active() != 0) {
    #line 335 
    unsigned short *value = (unsigned short *)addr;
    #line 335 
    while (count != 0UL) {
      #line 335 
      outw((unsigned short)((int)*value),port);
      #line 335 
      value ++;
      #line 335 
      count --;
    }
  }
  else 
       #line 339 
       ldv_inline_asm();
  #line 340 
  return;
}

#line 335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/arch/x86/include/asm/io.h"
__inline static void insw(int port, void *addr, unsigned long count)
{
  #line 335 
  if ((int)sev_key_active() != 0) {
    #line 335 
    unsigned short *value = (unsigned short *)addr;
    #line 335 
    while (count != 0UL) {
      #line 335 
      *value = inw(port);
      #line 335 
      value ++;
      #line 335 
      count --;
    }
  }
  else 
       #line 339 
       ldv_inline_asm();
  #line 340 
  return;
}

#line 210  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/capability.h"
#line 210 
bool capable(int);
#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/semaphore.h"
__inline static void sema_init(struct semaphore *sem, int val)
{
  #line 33 
  struct lock_class_key __key;
  #line 34 
  struct semaphore __constr_expr_18 = {.lock = {.raw_lock = {.__anonCompField_qspinlock_9 = {.val = {.counter = 0}}}, .magic = 3735899821U, .owner_cpu = 4294967295U, .owner = (void *)(-1), .dep_map = {.key = (struct lock_class_key *)0, .class_cache = {(struct lock_class *)0, (struct lock_class *)0}, .name = (char *)"(*sem).lock", .cpu = 0, .ip = 0UL}}, .count = (unsigned int)val, .wait_list = {.next = & sem->wait_list, .prev = & sem->wait_list}};
  #line 34 
  *sem = __constr_expr_18;
  #line 35 
  lockdep_init_map(& sem->lock.dep_map,(char *)"semaphore->lock",& __key,0);
  #line 36 
  return;
}

#line 39 
#line 39 
int down_interruptible(struct semaphore *);
#line 41 
#line 41 
int down_trylock(struct semaphore *);
#line 43 
#line 43 
void up(struct semaphore *);
#line 219  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/sched.h"
#line 219 
long schedule_timeout(long);
#line 222 
#line 222 
long schedule_timeout_uninterruptible(long);
#line 224 
#line 224 
void schedule(void);
#line 1688 
#line 1688 
int wake_up_process(struct task_struct *);
#line 3013  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/fs.h"
#line 3013 
loff_t default_llseek(struct file *, loff_t, int);
#line 3337 
#line 3337 
ssize_t simple_read_from_buffer(void *, size_t, loff_t *, void *, size_t);
#line 3339 
#line 3339 
ssize_t simple_write_to_buffer(void *, size_t, loff_t *, void *, size_t);
#line 27  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/proc_fs.h"
#line 27 
struct proc_dir_entry *proc_mkdir_mode(char *, umode_t, struct proc_dir_entry *);
#line 44 
#line 44 
struct proc_dir_entry *proc_create_data(char *, umode_t, struct proc_dir_entry *, struct file_operations *, void *);
#line 51 
#line 51 
void proc_set_user(struct proc_dir_entry *, kuid_t, kgid_t);
#line 52 
#line 52 
void *PDE_DATA(struct inode *);
#line 55 
#line 55 
void remove_proc_entry(char *, struct proc_dir_entry *);
#line 56 
#line 56 
int remove_proc_subtree(char *, struct proc_dir_entry *);
#line 121  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uaccess.h"
#line 121 
unsigned long _copy_from_user(void *, void *, unsigned long);
#line 137 
#line 137 
unsigned long _copy_to_user(void *, void *, unsigned long);
#line 141  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uaccess.h"
__inline static unsigned long copy_from_user(void *to, void *from, unsigned long n)
{
  #line 143 
  if ((long)((int)check_copy_size(to,n,(_Bool)0) != 0) != 0L) 
                                                              #line 144 
                                                              n = _copy_from_user(to,from,n);
  #line 145 
  return n;
}

#line 149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/uaccess.h"
__inline static unsigned long copy_to_user(void *to, void *from, unsigned long n)
{
  #line 151 
  if ((long)((int)check_copy_size(from,n,(_Bool)1) != 0) != 0L) 
                                                                #line 152 
                                                                n = _copy_to_user(to,from,n);
  #line 153 
  return n;
}

#line 179  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/ioport.h"
#line 179 
extern struct resource ioport_resource;
#line 180 
#line 180 
extern struct resource iomem_resource;
#line 238 
#line 238 
struct resource *__request_region(struct resource *, resource_size_t, resource_size_t, char *, int);
#line 247 
#line 247 
void __release_region(struct resource *, resource_size_t, resource_size_t);
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 189 
void kfree(void *);
#line 542 
#line 517  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void *kmalloc(size_t size, gfp_t flags);
#line 590  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 524  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void *kmalloc_array(size_t n, size_t size, gfp_t flags);
#line 607  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 531  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void *kcalloc(size_t n, size_t size, gfp_t flags);
#line 668  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/slab.h"
#line 552  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void *kzalloc(size_t size, gfp_t flags);
#line 162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/interrupt.h"
#line 748  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static int cif_request_irq(unsigned int irq_0, irqreturn_t (*handler)(int , void *), unsigned long flags, char *name, void *dev);
#line 189  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/interrupt.h"
#line 774  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void *cif_free_irq(unsigned int ldv_func_arg1, void *ldv_func_arg2);
#line 676  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/crypto.h"
#line 676 
void crypto_destroy_tfm(void *, struct crypto_tfm *);
#line 259  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/scatterlist.h"
#line 259 
void sg_init_one(struct scatterlist *, void *, unsigned int);
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/unaligned/access_ok.h"
__inline static u16 get_unaligned_le16(void *p)
{
  #line 10 
  return __le16_to_cpup((__le16 *)p);
}

#line 11  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/asm-generic/delay.h"
#line 11 
void __const_udelay(unsigned long);
#line 59  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/delay.h"
#line 59 
void msleep(unsigned int);
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/delay.h"
__inline static void ssleep(unsigned int seconds)
{
  #line 65 
  msleep(seconds * 1000U);
  #line 66 
  return;
}

#line 1417  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device *dev)
{
  #line 1419 
  return dev->driver_data;
}

#line 1422  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev, void *data)
{
  #line 1424 
  dev->driver_data = data;
  #line 1425 
  return;
}

#line 442  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
#line 442 
void *dma_alloc_attrs(struct device *, size_t, dma_addr_t *, gfp_t, unsigned long);
#line 444 
#line 444 
void dma_free_attrs(struct device *, size_t, void *, dma_addr_t, unsigned long);
#line 641  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void *dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t gfp)
{
  #line 645 
  return dma_alloc_attrs(dev,size,dma_handle,gfp,
                      (unsigned long)(gfp >> 5) & 256UL);
}

#line 649  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/dma-mapping.h"
__inline static void dma_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t dma_handle)
{
  #line 652 
  dma_free_attrs(dev,size,cpu_addr,dma_handle,0UL);
  #line 653 
  return;
}

#line 1023  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
#line 1023 
void consume_skb(struct sk_buff *);
#line 1493  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static int skb_queue_empty(struct sk_buff_head *list)
{
  #line 1495 
  return list->next == (struct sk_buff *)list;
}

#line 1812  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static __u32 skb_queue_len(struct sk_buff_head *list_)
{
  #line 1814 
  return list_->qlen;
}

#line 1827  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void __skb_queue_head_init(struct sk_buff_head *list)
{
  #line 1829 
  list->next = ((struct sk_buff *)list);
  #line 1829 
  list->prev = ((struct sk_buff *)list);
  #line 1830 
  list->qlen = 0U;
  #line 1831 
  return;
}

#line 1841  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_queue_head_init(struct sk_buff_head *list)
{
  #line 1843 
  spinlock_check(& list->lock);
  {
    #line 1843 
    struct lock_class_key __key;
    #line 1843 
    __raw_spin_lock_init(& list->lock.__anonCompField_spinlock_25.rlock,(char *)"&(&list->lock)->rlock",& __key);
  }
  #line 1844 
  __skb_queue_head_init(list);
  #line 1845 
  return;
}

#line 2011 
#line 2011 
void skb_queue_tail(struct sk_buff_head *, struct sk_buff *);
#line 2045 
#line 2045 
struct sk_buff *skb_dequeue(struct sk_buff_head *);
#line 2189 
#line 2189 
void *skb_put(struct sk_buff *, unsigned int);
#line 2338  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_reserve(struct sk_buff *skb, int len)
{
  #line 2340 
  skb->data += (unsigned long)len;
  #line 2341 
  skb->tail += (unsigned int)len;
  #line 2342 
  return;
}

#line 2491  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static unsigned char *skb_mac_header(struct sk_buff *skb)
{
  #line 2493 
  return skb->head + (unsigned long)skb->mac_header;
}

#line 2511  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static void skb_reset_mac_header(struct sk_buff *skb)
{
  #line 2513 
  skb->mac_header = (unsigned short)(skb->data - skb->head);
  #line 2514 
  return;
}

#line 2652 
#line 2652 
void skb_trim(struct sk_buff *, unsigned int);
#line 2762 
#line 2762 
struct sk_buff *__netdev_alloc_skb(struct net_device *, unsigned int, gfp_t);
#line 2778  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct sk_buff *netdev_alloc_skb(struct net_device *dev, unsigned int length)
{
  #line 2781 
  return __netdev_alloc_skb(dev,length,2592U);
}

#line 2792  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/skbuff.h"
__inline static struct sk_buff *dev_alloc_skb(unsigned int length)
{
  #line 2794 
  return netdev_alloc_skb((struct net_device *)0,length);
}

#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kthread.h"
#line 737  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static struct task_struct *cif_kthread_create_on_node(int (*threadfn)(void *), void *data, int node, char *namefmt , ...);
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/kthread.h"
#line 55 
int kthread_stop(struct task_struct *);
#line 56 
#line 56 
bool kthread_should_stop(void);
#line 2132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device *dev, unsigned int index)
{
  #line 2135 
  return dev->_tx + (unsigned long)index;
}

#line 2203  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device *dev)
{
  #line 2205 
  return (void *)((char *)dev + 3328UL);
}

#line 2679 
#line 790  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void cif_free_netdev(struct net_device *dev);
#line 3104  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue)
{
  #line 3106 
  cif_clear_bit(0L,& dev_queue->state);
  #line 3107 
  return;
}

#line 3115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_start_queue(struct net_device *dev)
{
  #line 3117 
  netif_tx_start_queue(netdev_get_tx_queue(dev,0U));
  #line 3118 
  return;
}

#line 3130 
#line 3130 
void netif_tx_wake_queue(struct netdev_queue *);
#line 3139  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_wake_queue(struct net_device *dev)
{
  #line 3141 
  netif_tx_wake_queue(netdev_get_tx_queue(dev,0U));
  #line 3142 
  return;
}

#line 3154  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue)
{
  #line 3156 
  cif_set_bit(0L,& dev_queue->state);
  #line 3157 
  return;
}

#line 3166  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_stop_queue(struct net_device *dev)
{
  #line 3168 
  netif_tx_stop_queue(netdev_get_tx_queue(dev,0U));
  #line 3169 
  return;
}

#line 3616 
#line 3616 
void __dev_kfree_skb_irq(struct sk_buff *, enum skb_free_reason);
#line 3617 
#line 3617 
void __dev_kfree_skb_any(struct sk_buff *, enum skb_free_reason);
#line 3638  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void dev_kfree_skb_irq(struct sk_buff *skb)
{
  #line 3640 
  __dev_kfree_skb_irq(skb,(enum skb_free_reason)SKB_REASON_DROPPED);
  #line 3641 
  return;
}

#line 3648  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb)
{
  #line 3650 
  __dev_kfree_skb_any(skb,(enum skb_free_reason)SKB_REASON_DROPPED);
  #line 3651 
  return;
}

#line 3660 
#line 3660 
int netif_rx(struct sk_buff *);
#line 3812 
#line 3812 
void netif_carrier_on(struct net_device *);
#line 3814 
#line 3814 
void netif_carrier_off(struct net_device *);
#line 3876  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static bool netif_device_present(struct net_device *dev)
{
  #line 3878 
  return test_bit(1L,& dev->state);
}

#line 3881 
#line 3881 
void netif_device_detach(struct net_device *);
#line 3883 
#line 3883 
void netif_device_attach(struct net_device *);
#line 3984  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
__inline static void netif_trans_update(struct net_device *dev)
{
  #line 3986 
  struct netdev_queue *txq = netdev_get_tx_queue(dev,0U);
  #line 3988 
  if (txq->trans_start != jiffies) 
                                   #line 3989 
                                   txq->trans_start = jiffies;
  #line 3990 
  return;
}

#line 4116 
#line 4116 
void ether_setup(struct net_device *);
#line 4123 
#line 798  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static struct net_device *cif_alloc_netdev_mqs(int sizeof_priv, char *name, unsigned char name_assign_type, void (*setup)(struct net_device *), unsigned int txqs, unsigned int rxqs);
#line 4131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
#line 806  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static int cif_register_netdev(struct net_device *dev);
#line 4132  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/netdevice.h"
#line 782  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void cif_unregister_netdev(struct net_device *dev);
#line 32  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
#line 32 
__be16 eth_type_trans(struct sk_buff *, struct net_device *);
#line 47 
#line 47 
int eth_validate_addr(struct net_device *);
#line 98  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 *addr)
{
  #line 101 
  return (_Bool)((*((u32 *)addr) | (unsigned int)*((u16 *)(addr + 4U))) == 0U);
}

#line 162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static bool is_broadcast_ether_addr(u8 *addr)
{
  #line 166 
  return (_Bool)((unsigned int)(((int)*((u16 *)addr) & (int)*((u16 *)(addr + 2U))) & (int)*((u16 *)(addr + 4U))) == 65535U);
}

#line 238  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static void eth_broadcast_addr(u8 *addr)
{
  #line 240 
  memset((void *)addr,255,6UL);
  #line 241 
  return;
}

#line 249  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static void eth_zero_addr(u8 *addr)
{
  #line 251 
  memset((void *)addr,0,6UL);
  #line 252 
  return;
}

#line 276  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static void ether_addr_copy(u8 *dst, u8 *src)
{
  #line 279 
  *((u32 *)dst) = *((u32 *)src);
  #line 280 
  *((u16 *)(dst + 4U)) = *((u16 *)(src + 4U));
  #line 281 
  return;
}

#line 299  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/etherdevice.h"
__inline static void eth_hw_addr_inherit(struct net_device *dst, struct net_device *src)
{
  #line 302 
  dst->addr_assign_type = src->addr_assign_type;
  #line 303 
  ether_addr_copy(dst->dev_addr,src->dev_addr);
  #line 304 
  return;
}

#line 1131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
#line 1131 
int pci_enable_device(struct pci_dev *);
#line 1157 
#line 1157 
void pci_disable_device(struct pci_dev *);
#line 1160 
#line 1160 
void pci_set_master(struct pci_dev *);
#line 1219 
#line 1219 
int pci_save_state(struct pci_dev *);
#line 1220 
#line 1220 
void pci_restore_state(struct pci_dev *);
#line 1233 
#line 1233 
int pci_set_power_state(struct pci_dev *, pci_power_t);
#line 1234 
#line 1234 
pci_power_t pci_choose_state(struct pci_dev *, pm_message_t);
#line 1237 
#line 1237 
int pci_enable_wake(struct pci_dev *, pci_power_t, bool);
#line 1346 
#line 814  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static int cif___pci_register_driver(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char *mod_name);
#line 1352  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
#line 822  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void cif_pci_unregister_driver(struct pci_driver *dev);
#line 1833  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev)
{
  #line 1835 
  return dev_get_drvdata(& pdev->dev);
}

#line 1838  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev, void *data)
{
  #line 1840 
  dev_set_drvdata(& pdev->dev,data);
  #line 1841 
  return;
}

#line 17  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci-dma-compat.h"
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev, size_t size, dma_addr_t *dma_handle)
{
  #line 20 
  return dma_alloc_coherent(& hwdev->dev,size,dma_handle,2592U);
}

#line 31  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/pci-dma-compat.h"
__inline static void pci_free_consistent(struct pci_dev *hwdev, size_t size, void *vaddr, dma_addr_t dma_handle)
{
  #line 34 
  dma_free_coherent(& hwdev->dev,size,vaddr,dma_handle);
  #line 35 
  return;
}

#line 13  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/freezer.h"
#line 13 
extern atomic_t system_freezing_cnt;
#line 30 
#line 30 
bool freezing_slow_path(struct task_struct *);
#line 35  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/freezer.h"
__inline static bool freezing(struct task_struct *p)
{
  #line 37 
  if ((long)(atomic_read(& system_freezing_cnt) == 0) != 0L) 
                                                             #line 38 
                                                             return (_Bool)0;
  #line 39 
  return freezing_slow_path(p);
}

#line 45 
#line 45 
bool __refrigerator(bool);
#line 55  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/freezer.h"
__inline static bool try_to_freeze_unsafe(void)
{
  #line 58 
  int tmp_1;
  #line 57 
  __might_sleep((char *)"./include/linux/freezer.h",57,0);
  #line 58 
  if (freezing(ldv_get_current())) 
                                   #line 58 
                                   tmp_1 = 0; else 
                                                   #line 58 
                                                   tmp_1 = 1;
  #line 58 
  if ((long)tmp_1 != 0L) 
                         #line 59 
                         return (_Bool)0;
  #line 60 
  return __refrigerator((_Bool)0);
}

#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/linux/freezer.h"
__inline static bool try_to_freeze(void)
{
  #line 65 
  ;
  #line 65 
  if ((ldv_get_current()->flags & 32768U) == 0U) 
                                                 #line 66 
                                                 debug_check_no_locks_held();
  #line 67 
  return try_to_freeze_unsafe();
}

#line 71 
#line 71 
bool set_freezable(void);
#line 194  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/crypto/skcipher.h"
#line 194 
struct crypto_sync_skcipher *crypto_alloc_sync_skcipher(char *, u32, u32);
#line 197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/crypto/skcipher.h"
__inline static struct crypto_tfm *crypto_skcipher_tfm(struct crypto_skcipher *tfm)
{
  #line 200 
  return & tfm->base;
}

#line 207  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/crypto/skcipher.h"
__inline static void crypto_free_skcipher(struct crypto_skcipher *tfm)
{
  #line 209 
  ;
  #line 209 
  crypto_destroy_tfm((void *)tfm,crypto_skcipher_tfm(tfm));
  #line 210 
  return;
}

#line 212  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/crypto/skcipher.h"
__inline static void crypto_free_sync_skcipher(struct crypto_sync_skcipher *tfm)
{
  #line 214 
  crypto_free_skcipher(& tfm->base);
  #line 215 
  return;
}

#line 369  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/crypto/skcipher.h"
__inline static int crypto_skcipher_setkey(struct crypto_skcipher *tfm, u8 *key, unsigned int keylen)
{
  #line 372 
  return (*(tfm->setkey))(tfm,key,keylen);
}

#line 375  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/crypto/skcipher.h"
__inline static int crypto_sync_skcipher_setkey(struct crypto_sync_skcipher *tfm, u8 *key, unsigned int keylen)
{
  #line 378 
  return crypto_skcipher_setkey(& tfm->base,key,keylen);
}

#line 421 
#line 421 
int crypto_skcipher_encrypt(struct skcipher_request *);
#line 466  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/crypto/skcipher.h"
__inline static void skcipher_request_set_tfm(struct skcipher_request *req, struct crypto_skcipher *tfm)
{
  #line 469 
  req->base.tfm = crypto_skcipher_tfm(tfm);
  #line 470 
  return;
}

#line 472  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/crypto/skcipher.h"
__inline static void skcipher_request_set_sync_tfm(struct skcipher_request *req, struct crypto_sync_skcipher *tfm)
{
  #line 475 
  skcipher_request_set_tfm(req,& tfm->base);
  #line 476 
  return;
}

#line 550  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/crypto/skcipher.h"
__inline static void skcipher_request_set_callback(struct skcipher_request *req, u32 flags, void (*compl)(struct crypto_async_request *, int ), void *data)
{
  #line 555 
  req->base.complete = compl;
  #line 556 
  req->base.data = data;
  #line 557 
  req->base.flags = flags;
  #line 558 
  return;
}

#line 576  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/crypto/skcipher.h"
__inline static void skcipher_request_set_crypt(struct skcipher_request *req, struct scatterlist *src, struct scatterlist *dst, unsigned int cryptlen, void *iv)
{
  #line 581 
  req->src = src;
  #line 582 
  req->dst = dst;
  #line 583 
  req->cryptlen = cryptlen;
  #line 584 
  req->iv = (u8 *)iv;
  #line 585 
  return;
}

#line 5027  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/cfg80211.h"
#line 5027 
int ieee80211_channel_to_frequency(int, enum nl80211_band);
#line 5034 
#line 5034 
int ieee80211_frequency_to_channel(int);
#line 441  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/iw_handler.h"
#line 441 
void wireless_send_event(struct net_device *, unsigned int, union iwreq_data *, char *);
#line 454 
#line 454 
int iw_handler_set_spy(struct net_device *, struct iw_request_info *, union iwreq_data *, char *);
#line 457 
#line 457 
int iw_handler_get_spy(struct net_device *, struct iw_request_info *, union iwreq_data *, char *);
#line 460 
#line 460 
int iw_handler_set_thrspy(struct net_device *, struct iw_request_info *, union iwreq_data *, char *);
#line 463 
#line 463 
int iw_handler_get_thrspy(struct net_device *, struct iw_request_info *, union iwreq_data *, char *);
#line 466 
#line 466 
void wireless_spy_update(struct net_device *, unsigned char *, struct iw_quality *);
#line 474  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/net/iw_handler.h"
__inline static int iwe_stream_lcp_len(struct iw_request_info *info)
{
  #line 477 
  if (((int)info->flags & 1) != 0) 
                                   #line 478 
                                   return 4;
  #line 480 
  return 8;
}

#line 509 
#line 509 
char *iwe_stream_add_event(struct iw_request_info *, char *, char *, struct iw_event *, int);
#line 528 
#line 528 
char *iwe_stream_add_point(struct iw_request_info *, char *, char *, struct iw_event *, char *);
#line 548 
#line 548 
char *iwe_stream_add_value(struct iw_request_info *, char *, char *, char *, struct iw_event *, int);
#line 5  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.h"
#line 2926  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct net_device *init_airo_card(unsigned short irq_0, int port, int is_pcmcia, struct device *dmdev);
#line 7  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.h"
#line 2944  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
int reset_airo_card(struct net_device *dev);
#line 8  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.h"
#line 2370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
void stop_airo_card(struct net_device *dev, int freeres);
#line 63  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct pci_device_id card_ids[8U] = {{.vendor = 5305U, .device = 1U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 5305U, .device = 17664U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 5305U, .device = 18432U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 5305U, .device = 832U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 5305U, .device = 848U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 5305U, .device = 20480U, .subvendor = 4294967295U, .subdevice = 4294967295U}, {.vendor = 5305U, .device = 42244U, .subvendor = 4294967295U, .subdevice = 4294967295U}};
#line 73  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct pci_device_id __mod_pci__card_ids_device_table[8U];
#line 75 
#line 5541 
static int airo_pci_probe(struct pci_dev *pdev, struct pci_device_id *pent);
#line 76 
#line 5563 
static void airo_pci_remove(struct pci_dev *pdev);
#line 77 
#line 5572 
static int airo_pci_suspend(struct pci_dev *pdev, pm_message_t state);
#line 78 
#line 5600 
static int airo_pci_resume(struct pci_dev *pdev);
#line 80  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct pci_driver airo_driver = {.name = (char *)"airo", .id_table = (struct pci_device_id *)(& card_ids), .probe = & airo_pci_probe, .remove = & airo_pci_remove, .suspend = & airo_pci_suspend, .resume = & airo_pci_resume};
#line 109  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static char *statsLabels[101U] = {(char *)"RxOverrun", [4] = (char *)"RxMacCrcErr", (char *)"RxMacCrcOk", (char *)"RxWepErr", (char *)"RxWepOk", (char *)"RetryLong", (char *)"RetryShort", (char *)"MaxRetries", (char *)"NoAck", (char *)"NoCts", (char *)"RxAck", (char *)"RxCts", (char *)"TxAck", (char *)"TxRts", (char *)"TxCts", (char *)"TxMc", (char *)"TxBc", (char *)"TxUcFrags", (char *)"TxUcPackets", (char *)"TxBeacon", (char *)"RxBeacon", (char *)"TxSinColl", (char *)"TxMulColl", (char *)"DefersNo", (char *)"DefersProt", (char *)"DefersEngy", (char *)"DupFram", (char *)"RxFragDisc", (char *)"TxAged", (char *)"RxAged", (char *)"LostSync-MaxRetry", (char *)"LostSync-MissedBeacons", (char *)"LostSync-ArlExceeded", (char *)"LostSync-Deauth", (char *)"LostSync-Disassoced", (char *)"LostSync-TsfTiming", (char *)"HostTxMc", (char *)"HostTxBc", (char *)"HostTxUc", (char *)"HostTxFail", (char *)"HostRxMc", (char *)"HostRxBc", (char *)"HostRxUc", (char *)"HostRxDiscard", [56] = (char *)"SsidMismatch", (char *)"ApMismatch", (char *)"RatesMismatch", (char *)"AuthReject", (char *)"AuthTimeout", (char *)"AssocReject", (char *)"AssocTimeout", [83] = (char *)"RxMan", (char *)"TxMan", (char *)"RxRefresh", (char *)"TxRefresh", (char *)"RxPoll", (char *)"TxPoll", (char *)"HostRetries", (char *)"LostSync-HostReq", (char *)"HostTxBytes", (char *)"HostRxBytes", (char *)"ElapsedUsec", (char *)"ElapsedSec", (char *)"LostSyncBetterAP", (char *)"PrivacyMismatch", (char *)"Jammed", (char *)"DiscRxNotWepped", (char *)"PhyEleMismatch", (char *)(-1)};
#line 220  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int rates[8U];
#line 221  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static char *ssids[3U];
#line 223  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int io[4U];
#line 224  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int irq[4U];
#line 227  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int maxencrypt;
#line 230  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int auto_wep;
#line 231  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int aux_bap;
#line 233  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int adhoc;
#line 235  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int probe = 1;
#line 237  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static kuid_t proc_kuid;
#line 238  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int proc_uid;
#line 240  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static kgid_t proc_kgid;
#line 241  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int proc_gid;
#line 243  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_perm = 365;
#line 245  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int proc_perm = 420;
#line 288  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int do8bitIO;
#line 937  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static char swversion[4U] = {(char)'2', (char)'.', (char)'1'};
#line 1086  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static WifiCtlHdr wifictlhdr8023 = {.ctlhdr = {.ctl = (unsigned short)32U}};
#line 1101 
#line 7594 
static struct iw_handler_def airo_handler_def;
#line 1103  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static char version[40U] = {(char)'a', (char)'i', (char)'r', (char)'o', (char)'.', (char)'c', (char)' ', (char)'0', (char)'.', (char)'6', (char)' ', (char)'(', (char)'B', (char)'e', (char)'n', (char)' ', (char)'R', (char)'e', (char)'e', (char)'d', (char)' ', (char)'&', (char)' ', (char)'J', (char)'a', (char)'v', (char)'i', (char)'e', (char)'r', (char)' ', (char)'A', (char)'c', (char)'h', (char)'i', (char)'r', (char)'i', (char)'c', (char)'a', (char)')'};
#line 1107 
#line 4755 
static int get_dec_u16(char *buffer, int *start, int limit);
#line 1108 
#line 3535 
static void OUT4500(struct airo_info *ai, u16 reg, u16 val);
#line 1109 
#line 3546 
static unsigned short IN4500(struct airo_info *ai, u16 reg);
#line 1110 
#line 3793 
static u16 setup_card(struct airo_info *ai, u8 *mac, int lock);
#line 1111 
#line 3560 
static int enable_MAC(struct airo_info *ai, int lock);
#line 1112 
#line 3599 
static void disable_MAC(struct airo_info *ai, int lock);
#line 1113 
#line 3618 
static void enable_interrupts(struct airo_info *ai);
#line 1114 
#line 3623 
static void disable_interrupts(struct airo_info *ai);
#line 1115 
#line 3934 
static u16 issuecommand(struct airo_info *ai, Cmd *pCmd, Resp *pRsp);
#line 1116 
#line 3986 
static int bap_setup(struct airo_info *ai, u16 rid, u16 offset, int whichbap);
#line 1117 
#line 4038 
static int aux_bap_read(struct airo_info *ai, __le16 *pu16Dst, int bytelen, int whichbap);
#line 1119 
#line 4075 
static int fast_bap_read(struct airo_info *ai, __le16 *pu16Dst, int bytelen, int whichbap);
#line 1121 
#line 4087 
static int bap_write(struct airo_info *ai, __le16 *pu16Src, int bytelen, int whichbap);
#line 1123 
#line 4099 
static int PC4500_accessrid(struct airo_info *ai, u16 rid, u16 accmd);
#line 1124 
#line 4118 
static int PC4500_readrid(struct airo_info *ai, u16 rid, void *pBuf, int len, int lock);
#line 1125 
#line 4183 
static int PC4500_writerid(struct airo_info *ai, u16 rid, void *pBuf, int len, int lock);
#line 1127 
#line 5136 
static int do_writerid(struct airo_info *ai, u16 rid, void *rid_data, int len, int dummy);
#line 1129 
#line 4257 
static u16 transmit_allocate(struct airo_info *ai, int lenPayload, int raw);
#line 1130 
#line 4315 
static int transmit_802_3_packet(struct airo_info *ai, int len, char *pPacket);
#line 1131 
#line 4358 
static int transmit_802_11_packet(struct airo_info *ai, int len, char *pPacket);
#line 1133 
#line 1960 
static int mpi_send_packet(struct net_device *dev);
#line 1134 
#line 2428 
static void mpi_unmap_card(struct pci_dev *pci);
#line 1135 
#line 3627 
static void mpi_receive_802_3(struct airo_info *ai);
#line 1136 
#line 3697 
static void mpi_receive_802_11(struct airo_info *ai);
#line 1137 
#line 2934 
static int waitbusy(struct airo_info *ai);
#line 1139 
#line 3469 
static irqreturn_t airo_interrupt(int irq_0, void *dev_id);
#line 1140 
#line 3050 
static int airo_thread(void *data);
#line 1141 
#line 5504 
static void timer_func(struct net_device *dev);
#line 1142 
#line 7618 
static int airo_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
#line 1143 
#line 7747 
static struct iw_statistics *airo_get_wireless_stats(struct net_device *dev);
#line 1144 
#line 7692 
static void airo_read_wireless_stats(struct airo_info *local);
#line 1146 
#line 7770 
static int readrids(struct net_device *dev, aironet_ioctl *comp);
#line 1147 
#line 7836 
static int writerids(struct net_device *dev, aironet_ioctl *comp);
#line 1148 
#line 7950 
static int flashcard(struct net_device *dev, aironet_ioctl *comp);
#line 1150 
#line 1328 
static void micinit(struct airo_info *ai);
#line 1151 
#line 1361 
static int micsetup(struct airo_info *ai);
#line 1152 
#line 1398 
static int encapsulate(struct airo_info *ai, etherHead *frame, MICBuffer *mic, int payLen);
#line 1153 
#line 1454 
static int decapsulate(struct airo_info *ai, MICBuffer *mic, etherHead *eth, u16 payLen);
#line 1155 
#line 5704 
static u8 airo_rssi_to_dbm(tdsRssiEntry *rssi_rid, u8 rssi);
#line 1156 
#line 5712 
static u8 airo_dbm_to_pct(tdsRssiEntry *rssi_rid, u8 dbm);
#line 1158 
#line 2722 
static void airo_networks_free(struct airo_info *ai);
#line 1255  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
__inline static int bap_read(struct airo_info *ai, __le16 *pu16Dst, int bytelen, int whichbap)
{
  #line 1258 
  return (*(ai->bap_read))(ai,pu16Dst,bytelen,whichbap);
}

#line 1261 
#line 4504 
static int setup_proc_entry(struct net_device *dev, struct airo_info *apriv);
#line 1263 
#line 4578 
static int takedown_proc_entry(struct net_device *dev, struct airo_info *apriv);
#line 1266 
#line 8009 
static int cmdreset(struct airo_info *ai);
#line 1267 
#line 8033 
static int setflashmode(struct airo_info *ai);
#line 1268 
#line 8100 
static int flashgchar(struct airo_info *ai, int matchbyte, int dwelltime);
#line 1269 
#line 8131 
static int flashputbuf(struct airo_info *ai);
#line 1270 
#line 8153 
static int flashrestart(struct airo_info *ai, struct net_device *dev);
#line 1294 
#line 1558 
static int RxSeqValid(struct airo_info *ai, miccntx *context, int mcast, u32 micSeq);
#line 1295 
#line 1606 
static void MoveWindow(miccntx *context, u32 micSeq);
#line 1296 
#line 1633 
static void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen, struct crypto_sync_skcipher *tfm);
#line 1298 
#line 1658 
static void emmh32_init(emmh32_context *context);
#line 1299 
#line 1666 
static void emmh32_update(emmh32_context *context, u8 *pOctets, int len);
#line 1300 
#line 1708 
static void emmh32_final(emmh32_context *context, u8 *digest);
#line 1301 
#line 8060 
static int flashpchar(struct airo_info *ai, int byte, int dwelltime);
#line 1303  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void age_mic_context(miccntx *cur, miccntx *old, u8 *key, int key_len, struct crypto_sync_skcipher *tfm)
{
  #line 1309 
  if ((unsigned int)cur->valid != 0U) {
    #line 1309 
    if (memcmp((void *)(& cur->key),(void *)key,(unsigned long)key_len) == 0) 
      #line 1310 
      return;
  }
  #line 1313 
  memcpy((void *)old,(void *)cur,2448UL);
  #line 1316 
  memcpy((void *)(& cur->key),(void *)key,(unsigned long)key_len);
  #line 1317 
  cur->window = 33U;
  #line 1318 
  cur->rx = 0U;
  #line 1319 
  cur->tx = 0U;
  #line 1320 
  cur->valid = (unsigned char)1U;
  #line 1323 
  emmh32_setseed(& cur->seed,key,key_len,tfm);
  #line 1324 
  return;
}

#line 1328  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void micinit(struct airo_info *ai)
{
  #line 1330 
  MICRid mic_rid;
  #line 1332 
  cif_clear_bit(5L,& ai->jobs);
  #line 1333 
  PC4500_readrid(ai,(unsigned short)65367,(void *)(& mic_rid),40,0);
  #line 1334 
  up(& ai->sem);
  #line 1336 
  ai->micstats.enabled = (unsigned char)(((int)mic_rid.state & 255) != 0);
  #line 1337 
  if ((unsigned int)ai->micstats.enabled == 0U) {
    #line 1341 
    ai->mod[0].uCtx.valid = (unsigned char)0U;
    #line 1342 
    ai->mod[0].mCtx.valid = (unsigned char)0U;
    #line 1343 
    return;
  }
  #line 1346 
  if ((unsigned int)mic_rid.multicastValid != 0U) 
                                                  #line 1347 
                                                  age_mic_context(& ai->mod[0].mCtx,& ai->mod[1].mCtx,(u8 *)(& mic_rid.multicast),16,ai->tfm);
  #line 1352 
  if ((unsigned int)mic_rid.unicastValid != 0U) 
                                                #line 1353 
                                                age_mic_context(& ai->mod[0].uCtx,& ai->mod[1].uCtx,(u8 *)(& mic_rid.unicast),16,ai->tfm);
  #line 1356 
  return;
}

#line 1361  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int micsetup(struct airo_info *ai)
{
  #line 1362 
  int i;
  #line 1364 
  if (ai->tfm == (struct crypto_sync_skcipher *)0) 
                                                   #line 1365 
                                                   ai->tfm = crypto_alloc_sync_skcipher((char *)"ctr(aes)",0U,0U);
  #line 1367 
  if ((int)IS_ERR((void *)ai->tfm) != 0) {
    #line 1368 
    printk((char *)"\001",(char *)(& (ai->dev)->name));
    #line 1369 
    ai->tfm = (struct crypto_sync_skcipher *)0;
    #line 1370 
    return -1;
  }
  #line 1373 
  i = 0;
  #line 1373 
  while (i <= 1) {
    #line 1374 
    memset((void *)(& ai->mod[i].mCtx),0,2448UL);
    #line 1375 
    memset((void *)(& ai->mod[i].uCtx),0,2448UL);
    #line 1373 
    i ++;
  }
  #line 1377 
  return 0;
}

#line 1380  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static u8 micsnap[8U] = {(unsigned char)170U, (unsigned char)170U, (unsigned char)3U, [4] = (unsigned char)64U, (unsigned char)150U, [7] = (unsigned char)2U};
#line 1398  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int encapsulate(struct airo_info *ai, etherHead *frame, MICBuffer *mic, int payLen)
{
  #line 1400 
  miccntx *context;
  #line 1405 
  if ((int)test_bit(3L,& ai->flags) != 0) 
    #line 1405 
    if (((int)frame->da[0] & 1) != 0) 
                                      #line 1406 
                                      context = & ai->mod[0].mCtx; else 
                                                                    #line 1408 
                                                                    context = & ai->mod[0].uCtx;
  else 
       #line 1408 
       context = & ai->mod[0].uCtx;
  #line 1410 
  if ((unsigned int)context->valid == 0U) 
                                          #line 1411 
                                          return -1;
  #line 1413 
  mic->typelen = __builtin_bswap16((unsigned short)((int)((unsigned int)((unsigned short)payLen) + 16U)));
  #line 1415 
  memcpy((void *)(& mic->u.snap),(void *)(& micsnap),8UL);
  #line 1418 
  mic->seq = __builtin_bswap32(context->tx);
  #line 1419 
  context->tx += 2U;
  #line 1421 
  emmh32_init(& context->seed);
  #line 1422 
  emmh32_update(& context->seed,(u8 *)(& frame->da),12);
  #line 1423 
  emmh32_update(& context->seed,(u8 *)(& mic->typelen),10);
  #line 1424 
  emmh32_update(& context->seed,(u8 *)(& mic->seq),4);
  #line 1425 
  emmh32_update(& context->seed,(u8 *)(frame + 1U),payLen);
  #line 1426 
  emmh32_final(& context->seed,(u8 *)(& mic->mic));
  #line 1429 
  mic->typelen = (unsigned short)0U;
  #line 1430 
  return 0;
}

#line 1454  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int decapsulate(struct airo_info *ai, MICBuffer *mic, etherHead *eth, u16 payLen)
{
  #line 1456 
  int i;
  #line 1457 
  u32 micSEQ;
  #line 1458 
  miccntx *context;
  #line 1459 
  u8 digest[4U];
  #line 1460 
  mic_error micError = NONE;
  #line 1464 
  if ((unsigned int)ai->micstats.enabled == 0U) {
    #line 1466 
    if (memcmp((void *)((u8 *)eth + 14U),(void *)(& micsnap),8UL) == 0) {
      #line 1467 
      (ai->micstats.rxMICPlummed) ++;
      #line 1468 
      return -1;
    }
    #line 1470 
    return 0;
  }
  #line 1473 
  if ((unsigned int)__builtin_bswap16((unsigned short)((int)mic->typelen)) == 34958U) 
    #line 1474 
    return 0;
  #line 1476 
  if (memcmp((void *)(& mic->u.snap),(void *)(& micsnap),8UL) != 0) {
    #line 1478 
    (ai->micstats.rxMICPlummed) ++;
    #line 1479 
    return -1;
  }
  #line 1482 
  micSEQ = __builtin_bswap32(mic->seq);
  #line 1488 
  if ((micSEQ & 1U) == 0U) {
    #line 1489 
    (ai->micstats.rxWrongSequence) ++;
    #line 1490 
    return -1;
  }
  #line 1493 
  i = 0;
  #line 1493 
  while (i <= 1) {
    {
      #line 1494 
      int mcast = (int)eth->da[0] & 1;
      #line 1496 
      if (mcast != 0) 
                      #line 1496 
                      context = & ai->mod[i].mCtx; else 
                                                        #line 1496 
                                                        context = & ai->mod[i].uCtx;
      #line 1499 
      if ((unsigned int)context->valid == 0U) {
        #line 1500 
        if (i == 0) 
                    #line 1501 
                    micError = NOMICPLUMMED;
        #line 1502 
        goto __Cont;
      }
      #line 1506 
      if ((unsigned int)mic->typelen == 0U) 
                                            #line 1507 
                                            mic->typelen = __builtin_bswap16((unsigned short)((int)((unsigned int)payLen + 16U)));
      #line 1509 
      emmh32_init(& context->seed);
      #line 1510 
      emmh32_update(& context->seed,(u8 *)(& eth->da),12);
      #line 1511 
      emmh32_update(& context->seed,(u8 *)(& mic->typelen),10);
      #line 1512 
      emmh32_update(& context->seed,(u8 *)(& mic->seq),4);
      #line 1513 
      emmh32_update(& context->seed,(u8 *)(eth + 1U),(int)payLen);
      #line 1515 
      emmh32_final(& context->seed,(u8 *)(& digest));
      #line 1517 
      if (memcmp((void *)(& digest),(void *)(& mic->mic),4UL) != 0) {
        #line 1519 
        if (i == 0) 
                    #line 1520 
                    micError = INCORRECTMIC;
        #line 1521 
        goto __Cont;
      }
      #line 1525 
      if (RxSeqValid(ai,context,mcast,micSEQ) == 0) {
        #line 1526 
        (ai->micstats.rxSuccess) ++;
        #line 1527 
        return 0;
      }
      #line 1529 
      if (i == 0) 
                  #line 1530 
                  micError = SEQUENCE;
    }
    #line 1493 
    __Cont: 
            #line 1493 
    i ++;
  }
  #line 1534 
  switch ((unsigned int)micError) {
    #line 1535 
    case (unsigned int)2: 
                          #line 1535 
    ;
    #line 1535 
    (ai->micstats.rxMICPlummed) ++;
    #line 1535 
    break;
    #line 1536 
    case (unsigned int)3: 
                          #line 1536 
    ;
    #line 1536 
    (ai->micstats.rxWrongSequence) ++;
    #line 1536 
    break;
    #line 1537 
    case (unsigned int)4: 
                          #line 1537 
    ;
    #line 1537 
    (ai->micstats.rxIncorrectMIC) ++;
    #line 1537 
    break;
    #line 1538 
    case (unsigned int)0: 
                          #line 1538 
    ;
    #line 1538 
    break;
    #line 1539 
    case (unsigned int)1: 
                          #line 1539 
    ;
    #line 1539 
    break;
  }
  #line 1541 
  return -1;
}

#line 1558  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int RxSeqValid(struct airo_info *ai, miccntx *context, int mcast, u32 micSeq)
{
  #line 1560 
  u32 seq;
  #line 1560 
  u32 index;
  #line 1565 
  if (mcast != 0) {
    #line 1566 
    if ((int)test_bit(5L,& ai->flags) != 0) {
      #line 1567 
      cif_clear_bit(5L,& ai->flags);
      #line 1568 
      if (33U > micSeq) 
                        #line 1568 
                        context->window = 33U; else 
                                                    #line 1568 
                                                    context->window = micSeq;
      #line 1569 
      context->rx = 0U;
    }
  }
  else {
    #line 1571 
    if ((int)test_bit(6L,& ai->flags) != 0) {
      #line 1572 
      cif_clear_bit(6L,& ai->flags);
      #line 1573 
      if (33U > micSeq) 
                        #line 1573 
                        context->window = 33U; else 
                                                    #line 1573 
                                                    context->window = micSeq;
      #line 1574 
      context->rx = 0U;
    }
  }
  #line 1578 
  seq = (micSeq - context->window) + 33U;
  #line 1581 
  if ((int)seq < 0) 
                    #line 1582 
                    return -1;
  #line 1584 
  if (seq > 64U) {
    #line 1586 
    MoveWindow(context,micSeq);
    #line 1587 
    return 0;
  }
  #line 1591 
  seq >>= 1;
  #line 1592 
  index = (unsigned int)(1 << seq);
  #line 1594 
  if ((context->rx & index) == 0U) {
    #line 1597 
    context->rx |= index;
    #line 1599 
    MoveWindow(context,micSeq);
    #line 1601 
    return 0;
  }
  #line 1603 
  return -1;
}

#line 1606  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void MoveWindow(miccntx *context, u32 micSeq)
{
  #line 1608 
  u32 shift;
  #line 1611 
  if (context->window < micSeq) {
    #line 1612 
    shift = (micSeq - context->window) >> 1;
    #line 1615 
    if (shift <= 31U) 
                      #line 1616 
                      context->rx >>= shift; else 
                                                  #line 1618 
                                                  context->rx = 0U;
    #line 1620 
    context->window = micSeq;
  }
  #line 1622 
  return;
}

#line 1633  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen, struct crypto_sync_skcipher *tfm)
{
  #line 1639 
  char __req_desc[464U];
  #line 1640 
  struct scatterlist sg;
  #line 1642 
  int ret;
  #line 1639 
  struct skcipher_request *req = (struct skcipher_request *)(& __req_desc);
  #line 1641 
  u8 iv[16U] = {};
  #line 1644 
  crypto_sync_skcipher_setkey(tfm,pkey,16U);
  #line 1646 
  memset((void *)(& context->coeff),0,2400UL);
  #line 1647 
  sg_init_one(& sg,(void *)(& context->coeff),2400U);
  #line 1649 
  skcipher_request_set_sync_tfm(req,tfm);
  #line 1650 
  skcipher_request_set_callback(req,0U,(void (*)(struct crypto_async_request *, int ))0,(void *)0);
  #line 1651 
  skcipher_request_set_crypt(req,& sg,& sg,2400U,(void *)(& iv));
  #line 1653 
  ret = crypto_skcipher_encrypt(req);
  {
    #line 1654 
    int __ret_warn_on = ret != 0;
    #line 1654 
    if ((long)(__ret_warn_on != 0) != 0L) {
      #line 1655 
      ldv_inline_asm();
      #line 1656 
      ldv_inline_asm();
    }
    #line 1654 
    long tmp = (long)(__ret_warn_on != 0);
  }
  #line 1656 
  return;
}

#line 1658  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void emmh32_init(emmh32_context *context)
{
  #line 1661 
  context->accum = 0ULL;
  #line 1662 
  context->position = 0;
  #line 1663 
  return;
}

#line 1666  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void emmh32_update(emmh32_context *context, u8 *pOctets, int len)
{
  #line 1668 
  int coeff_position;
  #line 1668 
  int byte_position;
  #line 1670 
  if (len == 0) 
                #line 1670 
                return;
  #line 1672 
  coeff_position = context->position >> 2;
  #line 1675 
  byte_position = context->position & 3;
  #line 1676 
  if (byte_position != 0) {
    #line 1684 
    unsigned int tmp_1;
    #line 1684 
    int tmp_2;
    #line 1678 
    while (1) {
      {
        #line 1680 
        int tmp;
        #line 1680 
        u8 *tmp_0;
        #line 1679 
        if (len == 0) 
                      #line 1679 
                      return;
        #line 1680 
        tmp = byte_position;
        #line 1680 
        byte_position ++;
        #line 1680 
        tmp_0 = pOctets;
        #line 1680 
        pOctets ++;
        #line 1680 
        context->part.d8[tmp] = *tmp_0;
        #line 1681 
        (context->position) ++;
        #line 1682 
        len --;
      }
      #line 1683 
      if (! (byte_position <= 3)) 
                                  #line 1678 
                                  break;
    }
    #line 1684 
    tmp_1 = __builtin_bswap32(context->part.d32);
    #line 1684 
    tmp_2 = coeff_position;
    #line 1684 
    coeff_position ++;
    #line 1684 
    ;
    #line 1684 
    context->accum += (unsigned long long)tmp_1 * (unsigned long long)__builtin_bswap32(context->coeff[tmp_2]);
  }
  #line 1688 
  while (len > 3) {
    #line 1689 
    unsigned int tmp_4;
    #line 1689 
    int tmp_5;
    #line 1689 
    tmp_4 = __builtin_bswap32(*((__be32 *)pOctets));
    #line 1689 
    tmp_5 = coeff_position;
    #line 1689 
    coeff_position ++;
    #line 1689 
    ;
    #line 1689 
    context->accum += (unsigned long long)tmp_4 * (unsigned long long)__builtin_bswap32(context->coeff[tmp_5]);
    #line 1690 
    context->position += 4;
    #line 1691 
    pOctets += 4U;
    #line 1692 
    len += -4;
  }
  #line 1696 
  byte_position = 0;
  #line 1697 
  while (len > 0) {
    #line 1698 
    int tmp_7;
    #line 1698 
    u8 *tmp_8;
    #line 1698 
    tmp_7 = byte_position;
    #line 1698 
    byte_position ++;
    #line 1698 
    tmp_8 = pOctets;
    #line 1698 
    pOctets ++;
    #line 1698 
    context->part.d8[tmp_7] = *tmp_8;
    #line 1699 
    (context->position) ++;
    #line 1700 
    len --;
  }
  #line 1702 
  return;
}

#line 1705  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static u32 mask32[4U] = {[1] = 4278190080U, 4294901760U, 4294967040U};
#line 1708  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void emmh32_final(emmh32_context *context, u8 *digest)
{
  #line 1710 
  int coeff_position;
  #line 1710 
  int byte_position;
  #line 1711 
  u32 val;
  #line 1713 
  u64 sum;
  #line 1713 
  u64 utmp;
  #line 1714 
  s64 stmp;
  #line 1716 
  coeff_position = context->position >> 2;
  #line 1719 
  byte_position = context->position & 3;
  #line 1720 
  if (byte_position != 0) {
    #line 1723 
    int tmp;
    #line 1722 
    val = __builtin_bswap32(context->part.d32);
    #line 1723 
    tmp = coeff_position;
    #line 1723 
    coeff_position ++;
    #line 1723 
    ;
    #line 1723 
    context->accum += (unsigned long long)(mask32[byte_position] & val) * (unsigned long long)__builtin_bswap32(context->coeff[tmp]);
  }
  #line 1727 
  sum = context->accum;
  #line 1728 
  stmp = (long long)((sum & 4294967295ULL) - (sum >> 32) * 15ULL);
  #line 1729 
  utmp = (unsigned long long)((stmp & 4294967295LL) + (stmp >> 32) * -15LL);
  #line 1730 
  sum = utmp & 4294967295ULL;
  #line 1731 
  if (utmp > 4294967311ULL) 
                            #line 1732 
                            sum += 18446744073709551601ULL;
  #line 1734 
  val = (unsigned int)sum;
  #line 1735 
  *digest = (unsigned char)(val >> 24);
  #line 1736 
  *(digest + 1U) = (unsigned char)(val >> 16);
  #line 1737 
  *(digest + 2U) = (unsigned char)(val >> 8);
  #line 1738 
  *(digest + 3U) = (unsigned char)val;
  #line 1739 
  return;
}

#line 1741  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int readBSSListRid(struct airo_info *ai, int first, BSSListRid *list)
{
  #line 1744 
  Cmd cmd;
  #line 1745 
  Resp rsp;
  #line 1760 
  int tmp_0;
  #line 1747 
  if (first == 1) {
    #line 1748 
    if ((ai->flags & 3UL) != 0UL) 
                                  #line 1748 
                                  return -100;
    #line 1749 
    memset((void *)(& cmd),0,8UL);
    #line 1750 
    cmd.cmd = (unsigned short)259U;
    #line 1751 
    if (down_interruptible(& ai->sem) != 0) 
                                            #line 1752 
                                            return -512;
    #line 1753 
    ai->list_bss_task = ldv_get_current();
    #line 1754 
    issuecommand(ai,& cmd,& rsp);
    #line 1755 
    up(& ai->sem);
    #line 1757 
    schedule_timeout_uninterruptible(750L);
    #line 1758 
    ai->list_bss_task = (struct task_struct *)0;
  }
  #line 1760 
  ;
  #line 1760 
  ;
  #line 1760 
  if (first != 0) 
                  #line 1760 
                  tmp_0 = (int)((unsigned short)ai->bssListFirst); else 
                                                                    #line 1760 
                                                                    tmp_0 = (int)((unsigned short)ai->bssListNext);
  #line 1760 
  ;
  #line 1760 
  return PC4500_readrid(ai,(unsigned short)tmp_0,(void *)list,
                       (int)ai->bssListRidLen,1);
}

#line 1764  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int readWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int temp, int lock)
{
  #line 1766 
  int tmp;
  #line 1766 
  ;
  #line 1766 
  ;
  #line 1766 
  if (temp != 0) 
                 #line 1766 
                 tmp = 65301; else 
                                   #line 1766 
                                   tmp = 65302;
  #line 1766 
  ;
  #line 1766 
  return PC4500_readrid(ai,(unsigned short)tmp,(void *)wkr,28,lock);
}

#line 1770  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int writeWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int perm, int lock)
{
  #line 1772 
  int rc;
  #line 1773 
  rc = PC4500_writerid(ai,(unsigned short)65301,(void *)wkr,28,lock);
  #line 1774 
  if (rc != 0) 
               #line 1775 
               printk((char *)"\001",(char *)(& (ai->dev)->name),rc);
  #line 1776 
  if (perm != 0) {
    #line 1777 
    rc = PC4500_writerid(ai,(unsigned short)65302,(void *)wkr,28,lock);
    #line 1778 
    if (rc != 0) 
                 #line 1779 
                 printk((char *)"\001",(char *)(& (ai->dev)->name),rc);
  }
  #line 1781 
  return rc;
}

#line 1784  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int readSsidRid(struct airo_info *ai, SsidRid *ssidr)
{
  #line 1786 
  return PC4500_readrid(ai,(unsigned short)65297,(void *)ssidr,104,1);
}

#line 1789  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int writeSsidRid(struct airo_info *ai, SsidRid *pssidr, int lock)
{
  #line 1791 
  return PC4500_writerid(ai,(unsigned short)65297,(void *)pssidr,104,lock);
}

#line 1794  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int readConfigRid(struct airo_info *ai, int lock)
{
  #line 1796 
  int rc;
  #line 1797 
  ConfigRid cfg;
  #line 1799 
  if ((unsigned int)ai->config.len != 0U) 
                                          #line 1800 
                                          return 0;
  #line 1802 
  rc = PC4500_readrid(ai,(unsigned short)65312,(void *)(& cfg),156,lock);
  #line 1803 
  if (rc != 0) 
               #line 1804 
               return rc;
  #line 1806 
  ai->config = cfg;
  #line 1807 
  return 0;
}

#line 1810  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
__inline static void checkThrottle(struct airo_info *ai)
{
  #line 1812 
  int i;
  #line 1814 
  if ((unsigned int)ai->config.authType != 1U && maxencrypt != 0) {
    #line 1815 
    i = 0;
    #line 1815 
    while (i <= 7) {
      #line 1816 
      if ((int)ai->config.rates[i] > maxencrypt) 
                                                 #line 1817 
                                                 ai->config.rates[i] = (unsigned char)0U;
      #line 1815 
      i ++;
    }
  }
  #line 1819 
  return;
}

#line 1823  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int writeConfigRid(struct airo_info *ai, int lock)
{
  #line 1825 
  ConfigRid cfgr;
  #line 1827 
  if (! test_bit(13L,& ai->flags)) 
                                   #line 1828 
                                   return 0;
  #line 1830 
  cif_clear_bit(13L,& ai->flags);
  #line 1831 
  cif_clear_bit(14L,& ai->flags);
  #line 1832 
  checkThrottle(ai);
  #line 1833 
  cfgr = ai->config;
  #line 1835 
  if (((int)cfgr.opmode & 255) == 0) 
                                     #line 1836 
                                     cif_set_bit(3L,& ai->flags); else 
                                                                    #line 1838 
                                                                    cif_clear_bit(3L,& ai->flags);
  #line 1840 
  return PC4500_writerid(ai,(unsigned short)65296,(void *)(& cfgr),156,lock);
}

#line 1843  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int readStatusRid(struct airo_info *ai, StatusRid *statr, int lock)
{
  #line 1845 
  return PC4500_readrid(ai,(unsigned short)65360,(void *)statr,136,lock);
}

#line 1848  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int writeAPListRid(struct airo_info *ai, APListRid *aplr, int lock)
{
  #line 1850 
  return PC4500_writerid(ai,(unsigned short)65298,(void *)aplr,26,lock);
}

#line 1853  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int readCapabilityRid(struct airo_info *ai, CapabilityRid *capr, int lock)
{
  #line 1855 
  return PC4500_readrid(ai,(unsigned short)65280,(void *)capr,132,lock);
}

#line 1858  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int readStatsRid(struct airo_info *ai, StatsRid *sr, int rid, int lock)
{
  #line 1860 
  return PC4500_readrid(ai,(unsigned short)((int)((unsigned short)rid)),
                     (void *)sr,404,lock);
}

#line 1863  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void try_auto_wep(struct airo_info *ai)
{
  #line 1865 
  if (auto_wep != 0) {
    #line 1865 
    if (! test_bit(1L,& ai->flags)) {
      #line 1866 
      ai->expires = jiffies + 750UL;
      #line 1867 
      __wake_up(& ai->thr_wait,1U,1,(void *)0);
    }
  }
  #line 1869 
  return;
}

#line 1871  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_open(struct net_device *dev)
{
  #line 1872 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 1873 
  int rc = 0;
  #line 1875 
  if ((int)test_bit(15L,& ai->flags) != 0) 
                                           #line 1876 
                                           return -5;
  #line 1882 
  if ((int)test_bit(13L,& ai->flags) != 0) {
    #line 1883 
    disable_MAC(ai,1);
    #line 1884 
    writeConfigRid(ai,1);
  }
  #line 1887 
  if (ai->wifidev != dev) {
    #line 1889 
    struct task_struct *__k;
    #line 1888 
    cif_clear_bit(0L,& ai->jobs);
    #line 1889 
    __k = cif_kthread_create_on_node(& airo_thread,(void *)dev,-1,(char *)"%s",(char *)(& dev->name));
    {
      #line 1889 
      if (! IS_ERR((void *)__k)) 
                                 #line 1889 
                                 wake_up_process(__k);
    }
    #line 1889 
    ai->airo_thread_task = __k;
    #line 1891 
    if ((int)IS_ERR((void *)ai->airo_thread_task) != 0) {
      #line 1892 
      return (int)PTR_ERR((void *)ai->airo_thread_task);
    }
    #line 1894 
    rc = cif_request_irq((unsigned int)dev->irq,& airo_interrupt,128UL,(char *)(& dev->name),(void *)dev);
    #line 1896 
    if (rc != 0) {
      #line 1897 
      printk((char *)"\001",(char *)(& dev->name),dev->irq,rc);
      #line 1900 
      cif_set_bit(0L,& ai->jobs);
      #line 1901 
      kthread_stop(ai->airo_thread_task);
      #line 1902 
      return rc;
    }
    #line 1906 
    cif_clear_bit(1L,& ai->flags);
    #line 1907 
    enable_interrupts(ai);
    #line 1909 
    try_auto_wep(ai);
  }
  #line 1911 
  enable_MAC(ai,1);
  #line 1913 
  netif_start_queue(dev);
  #line 1914 
  return 0;
}

#line 1917  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static netdev_tx_t mpi_start_xmit(struct sk_buff *skb, struct net_device *dev)
{
  #line 1920 
  int npacks;
  #line 1920 
  int pending;
  #line 1921 
  unsigned long flags;
  #line 1922 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 1924 
  if (skb == (struct sk_buff *)0) {
    #line 1925 
    printk((char *)"\001",(char *)(& dev->name),(char *)"mpi_start_xmit");
    #line 1926 
    return NETDEV_TX_OK;
  }
  #line 1928 
  npacks = (int)skb_queue_len(& ai->txq);
  #line 1930 
  if (npacks > 62) {
    #line 1931 
    netif_stop_queue(dev);
    #line 1932 
    if (npacks > 64) {
      #line 1933 
      (dev->stats.tx_fifo_errors) ++;
      #line 1934 
      return NETDEV_TX_BUSY;
    }
    #line 1936 
    skb_queue_tail(& ai->txq,skb);
    #line 1937 
    return NETDEV_TX_OK;
  }
  #line 1940 
  cif___ldv_spin_lock_aux_lock_of_airo_info(& ai->aux_lock);
  #line 1941 
  skb_queue_tail(& ai->txq,skb);
  #line 1942 
  pending = (int)test_bit(9L,& ai->flags);
  #line 1943 
  cif_spin_unlock_irqrestore_aux_lock_of_airo_info(& ai->aux_lock,flags);
  #line 1944 
  netif_wake_queue(dev);
  #line 1946 
  if (pending == 0) {
    #line 1947 
    cif_set_bit(9L,& ai->flags);
    #line 1948 
    mpi_send_packet(dev);
  }
  #line 1950 
  return NETDEV_TX_OK;
}

#line 1960  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int mpi_send_packet(struct net_device *dev)
{
  #line 1962 
  struct sk_buff *skb;
  #line 1963 
  unsigned char *buffer;
  #line 1964 
  s16 len;
  #line 1965 
  __le16 *payloadLen;
  #line 1967 
  u8 *sendbuf;
  #line 1979 
  unsigned int tmp;
  #line 1966 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 1971 
  skb = skb_dequeue(& ai->txq);
  #line 1971 
  if (skb == (struct sk_buff *)0) {
    #line 1972 
    printk((char *)"\001",(char *)(& dev->name),(char *)"mpi_send_packet");
    #line 1975 
    return 0;
  }
  #line 1979 
  if (60U > skb->len) 
                      #line 1979 
                      tmp = 60U; else 
                                      #line 1979 
                                      tmp = skb->len;
  #line 1979 
  len = (short)tmp;
  #line 1980 
  buffer = skb->data;
  #line 1982 
  ai->txfids[0].tx_desc.offset = (unsigned int)0U;
  #line 1983 
  ai->txfids[0].tx_desc.valid = (unsigned int)1U;
  #line 1984 
  ai->txfids[0].tx_desc.eoc = (unsigned int)1U;
  #line 1985 
  ai->txfids[0].tx_desc.len = (unsigned int)((unsigned int)((unsigned short)len) + 30U);
  #line 1995 
  memcpy((void *)ai->txfids[0].virtual_host_addr,(void *)(& wifictlhdr8023),54UL);
  #line 1998 
  payloadLen = (__le16 *)(ai->txfids[0].virtual_host_addr + 54UL);
  #line 2000 
  sendbuf = (u8 *)(ai->txfids[0].virtual_host_addr + 56UL);
  #line 2007 
  if ((int)test_bit(4L,& ai->flags) != 0) {
    #line 2007 
    if ((unsigned int)ai->micstats.enabled != 0U) {
      #line 2007 
      if ((unsigned int)__builtin_bswap16((unsigned short)((int)*((__be16 *)buffer + 6U))) != 34958U) {
        #line 2009 
        MICBuffer pMic;
        #line 2011 
        if (encapsulate(ai,(etherHead *)buffer,& pMic,
                    (int)((unsigned int)len + 4294967284U)) != 0) 
          #line 2012 
          return -1;
        #line 2014 
        *payloadLen = (unsigned short)((unsigned int)((unsigned short)len) + 6U);
        #line 2015 
        ai->txfids[0].tx_desc.len = (unsigned int)((unsigned int)((unsigned short)ai->txfids[0].tx_desc.len) + 18U);
        #line 2017 
        memcpy((void *)sendbuf,(void *)buffer,12UL);
        #line 2018 
        buffer += 12UL;
        #line 2019 
        sendbuf += 12UL;
        #line 2020 
        memcpy((void *)sendbuf,(void *)(& pMic),18UL);
        #line 2021 
        sendbuf += 18UL;
        #line 2022 
        memcpy((void *)sendbuf,(void *)buffer,(unsigned long)len + 18446744073709551604UL);
      }
      else 
           #line 2007 
           goto _LAND_0;
    }
    else 
         #line 2007 
         goto _LAND_0;
  }
  else {
    #line 2007 
    _LAND_0: {
               #line 2024 
               *payloadLen = (unsigned short)((unsigned int)((unsigned short)len) + 65524U);
               #line 2026 
               netif_trans_update(dev);
               #line 2029 
               memcpy((void *)sendbuf,(void *)buffer,(unsigned long)len);
             }
  }
  #line 2032 
  memcpy_toio((void *)ai->txfids[0].card_ram_off,(void *)(& ai->txfids[0].tx_desc),16UL);
  #line 2035 
  OUT4500(ai,(unsigned short)52,(unsigned short)8);
  #line 2037 
  dev_kfree_skb_any(skb);
  #line 2038 
  return 1;
}

#line 2041  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void get_tx_error(struct airo_info *ai, s32 fid)
{
  #line 2043 
  __le16 status;
  #line 2045 
  if (fid < 0) 
               #line 2046 
               status = ((WifiCtlHdr *)ai->txfids[0].virtual_host_addr)->ctlhdr.status;
  else {
    #line 2048 
    if (bap_setup(ai,(unsigned short)((int)((unsigned short)ai->fids[fid])),
                (unsigned short)4,0) != 0) 
      #line 2049 
      return;
    #line 2050 
    bap_read(ai,& status,2,0);
  }
  #line 2052 
  if (((int)status & 2) != 0) 
                              #line 2053 
                              ((ai->dev)->stats.tx_aborted_errors) ++;
  #line 2054 
  if (((int)status & 4) != 0) 
                              #line 2055 
                              ((ai->dev)->stats.tx_heartbeat_errors) ++;
  #line 2056 
  if (((int)status & 8) != 0) ;
  #line 2058 
  if (((int)status & 16) != 0) 
                               #line 2059 
                               ((ai->dev)->stats.tx_carrier_errors) ++;
  #line 2060 
  if (((int)status & 32) != 0) ;
  #line 2066 
  if (((int)status & 2) != 0 || ((int)status & 4) != 0) {
    #line 2068 
    union iwreq_data wrqu;
    #line 2069 
    char junk[24U];
    #line 2074 
    bap_read(ai,(__le16 *)(& junk),24,0);
    #line 2084 
    memcpy((void *)(& wrqu.addr.sa_data),(void *)((char *)(& junk) + 18U),6UL);
    #line 2085 
    wrqu.addr.sa_family = (unsigned short)1U;
    #line 2088 
    wireless_send_event(ai->dev,35840U,& wrqu,(char *)0);
  }
  #line 2090 
  return;
}

#line 2092  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_end_xmit(struct net_device *dev)
{
  #line 2093 
  u16 status;
  #line 2094 
  int i;
  #line 2095 
  struct airo_info *priv = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 2096 
  struct sk_buff *skb = priv->xmit.skb;
  #line 2097 
  int fid = priv->xmit.fid;
  #line 2098 
  u32 *fids = (u32 *)(& priv->fids);
  #line 2100 
  cif_clear_bit(1L,& priv->jobs);
  #line 2101 
  cif_clear_bit(9L,& priv->flags);
  #line 2102 
  status = (unsigned short)transmit_802_3_packet(priv,(int)*(fids + (unsigned long)fid),
                            (char *)skb->data);
  #line 2103 
  up(& priv->sem);
  #line 2105 
  i = 0;
  #line 2106 
  if ((unsigned int)status == 0U) {
    #line 2107 
    netif_trans_update(dev);
    #line 2108 
    while (i <= 2 && (priv->fids[i] & 4294901760U) != 0U) 
                                                          #line 2108 
                                                          i ++;
  }
  else {
    #line 2110 
    priv->fids[fid] &= 65535U;
    #line 2111 
    (dev->stats.tx_window_errors) ++;
  }
  #line 2113 
  if (i <= 2) 
              #line 2114 
              netif_wake_queue(dev);
  #line 2115 
  consume_skb(skb);
  #line 2116 
  return;
}

#line 2118  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static netdev_tx_t airo_start_xmit(struct sk_buff *skb, struct net_device *dev)
{
  #line 2121 
  s16 len;
  #line 2122 
  int i;
  #line 2122 
  int j;
  #line 2144 
  unsigned int tmp;
  #line 2123 
  struct airo_info *priv = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 2124 
  u32 *fids = (u32 *)(& priv->fids);
  #line 2126 
  if (skb == (struct sk_buff *)0) {
    #line 2127 
    printk((char *)"\001",(char *)(& dev->name),(char *)"airo_start_xmit");
    #line 2128 
    return NETDEV_TX_OK;
  }
  #line 2132 
  i = 0;
  #line 2132 
  while (i <= 2 && (*(fids + (unsigned long)i) & 4294901760U) != 0U) 
    #line 2132 
    i ++;
  #line 2133 
  j = i + 1;
  #line 2133 
  while (j <= 2 && (*(fids + (unsigned long)j) & 4294901760U) != 0U) 
    #line 2133 
    j ++;
  #line 2135 
  if (j > 2) {
    #line 2136 
    netif_stop_queue(dev);
    #line 2138 
    if (i == 3) {
      #line 2139 
      (dev->stats.tx_fifo_errors) ++;
      #line 2140 
      return NETDEV_TX_BUSY;
    }
  }
  #line 2144 
  if (60U > skb->len) 
                      #line 2144 
                      tmp = 60U; else 
                                      #line 2144 
                                      tmp = skb->len;
  #line 2144 
  len = (short)tmp;
  #line 2146 
  *(fids + (unsigned long)i) |= (unsigned int)((int)len << 16);
  #line 2147 
  priv->xmit.skb = skb;
  #line 2148 
  priv->xmit.fid = i;
  #line 2149 
  if (down_trylock(& priv->sem) != 0) {
    #line 2150 
    cif_set_bit(9L,& priv->flags);
    #line 2151 
    netif_stop_queue(dev);
    #line 2152 
    cif_set_bit(1L,& priv->jobs);
    #line 2153 
    __wake_up(& priv->thr_wait,1U,1,(void *)0);
  }
  else 
       #line 2155 
       airo_end_xmit(dev);
  #line 2156 
  return NETDEV_TX_OK;
}

#line 2159  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_end_xmit11(struct net_device *dev)
{
  #line 2160 
  u16 status;
  #line 2161 
  int i;
  #line 2162 
  struct airo_info *priv = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 2163 
  struct sk_buff *skb = priv->xmit11.skb;
  #line 2164 
  int fid = priv->xmit11.fid;
  #line 2165 
  u32 *fids = (u32 *)(& priv->fids);
  #line 2167 
  cif_clear_bit(2L,& priv->jobs);
  #line 2168 
  cif_clear_bit(10L,& priv->flags);
  #line 2169 
  status = (unsigned short)transmit_802_11_packet(priv,(int)*(fids + (unsigned long)fid),
                             (char *)skb->data);
  #line 2170 
  up(& priv->sem);
  #line 2172 
  i = 3;
  #line 2173 
  if ((unsigned int)status == 0U) {
    #line 2174 
    netif_trans_update(dev);
    #line 2175 
    while (i <= 5 && (priv->fids[i] & 4294901760U) != 0U) 
                                                          #line 2175 
                                                          i ++;
  }
  else {
    #line 2177 
    priv->fids[fid] &= 65535U;
    #line 2178 
    (dev->stats.tx_window_errors) ++;
  }
  #line 2180 
  if (i <= 5) 
              #line 2181 
              netif_wake_queue(dev);
  #line 2182 
  consume_skb(skb);
  #line 2183 
  return;
}

#line 2185  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static netdev_tx_t airo_start_xmit11(struct sk_buff *skb, struct net_device *dev)
{
  #line 2188 
  s16 len;
  #line 2189 
  int i;
  #line 2189 
  int j;
  #line 2218 
  unsigned int tmp_0;
  #line 2190 
  struct airo_info *priv = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 2191 
  u32 *fids = (u32 *)(& priv->fids);
  #line 2193 
  if ((int)test_bit(11L,& priv->flags) != 0) {
    #line 2195 
    netif_stop_queue(dev);
    #line 2196 
    dev_kfree_skb_any(skb);
    #line 2197 
    return NETDEV_TX_OK;
  }
  #line 2200 
  if (skb == (struct sk_buff *)0) {
    #line 2201 
    printk((char *)"\001",(char *)(& dev->name),(char *)"airo_start_xmit11");
    #line 2202 
    return NETDEV_TX_OK;
  }
  #line 2206 
  i = 3;
  #line 2206 
  while (i <= 5 && (*(fids + (unsigned long)i) & 4294901760U) != 0U) 
    #line 2206 
    i ++;
  #line 2207 
  j = i + 1;
  #line 2207 
  while (j <= 5 && (*(fids + (unsigned long)j) & 4294901760U) != 0U) 
    #line 2207 
    j ++;
  #line 2209 
  if (j > 5) {
    #line 2210 
    netif_stop_queue(dev);
    #line 2212 
    if (i == 6) {
      #line 2213 
      (dev->stats.tx_fifo_errors) ++;
      #line 2214 
      return NETDEV_TX_BUSY;
    }
  }
  #line 2218 
  if (60U > skb->len) 
                      #line 2218 
                      tmp_0 = 60U; else 
                                        #line 2218 
                                        tmp_0 = skb->len;
  #line 2218 
  len = (short)tmp_0;
  #line 2220 
  *(fids + (unsigned long)i) |= (unsigned int)((int)len << 16);
  #line 2221 
  priv->xmit11.skb = skb;
  #line 2222 
  priv->xmit11.fid = i;
  #line 2223 
  if (down_trylock(& priv->sem) != 0) {
    #line 2224 
    cif_set_bit(10L,& priv->flags);
    #line 2225 
    netif_stop_queue(dev);
    #line 2226 
    cif_set_bit(2L,& priv->jobs);
    #line 2227 
    __wake_up(& priv->thr_wait,1U,1,(void *)0);
  }
  else 
       #line 2229 
       airo_end_xmit11(dev);
  #line 2230 
  return NETDEV_TX_OK;
}

#line 2233  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_read_stats(struct net_device *dev)
{
  #line 2236 
  StatsRid stats_rid;
  #line 2235 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 2237 
  __le32 *vals = (__le32 *)(& stats_rid.vals);
  #line 2239 
  cif_clear_bit(3L,& ai->jobs);
  #line 2240 
  if (ai->power.event != 0) {
    #line 2241 
    up(& ai->sem);
    #line 2242 
    return;
  }
  #line 2244 
  readStatsRid(ai,& stats_rid,65384,0);
  #line 2245 
  up(& ai->sem);
  #line 2247 
  dev->stats.rx_packets = (unsigned long)((*(vals + 43U) + *(vals + 44U)) + *(vals + 45U));
  #line 2249 
  dev->stats.tx_packets = (unsigned long)((*(vals + 39U) + *(vals + 40U)) + *(vals + 41U));
  #line 2251 
  dev->stats.rx_bytes = (unsigned long)*(vals + 92U);
  #line 2252 
  dev->stats.tx_bytes = (unsigned long)*(vals + 91U);
  #line 2253 
  dev->stats.rx_errors = (unsigned long)(((*vals + *(vals + 2U)) + *(vals + 3U)) + *(vals + 4U));
  #line 2255 
  dev->stats.tx_errors = (unsigned long)*(vals + 42U) + dev->stats.tx_fifo_errors;
  #line 2257 
  dev->stats.multicast = (unsigned long)*(vals + 43U);
  #line 2258 
  dev->stats.collisions = (unsigned long)*(vals + 89U);
  #line 2261 
  dev->stats.rx_length_errors = (unsigned long)*(vals + 3U);
  #line 2262 
  dev->stats.rx_crc_errors = (unsigned long)*(vals + 4U);
  #line 2263 
  dev->stats.rx_frame_errors = (unsigned long)*(vals + 2U);
  #line 2264 
  dev->stats.rx_fifo_errors = (unsigned long)*vals;
  #line 2265 
  return;
}

#line 2267  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct net_device_stats *airo_get_stats(struct net_device *dev)
{
  #line 2269 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 2271 
  if (! test_bit(3L,& local->jobs)) {
    #line 2273 
    if (down_trylock(& local->sem) != 0) {
      #line 2274 
      cif_set_bit(3L,& local->jobs);
      #line 2275 
      __wake_up(& local->thr_wait,1U,1,(void *)0);
    }
    else 
         #line 2277 
         airo_read_stats(dev);
  }
  #line 2280 
  return & dev->stats;
}

#line 2283  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_set_promisc(struct airo_info *ai)
{
  #line 2284 
  Cmd cmd;
  #line 2285 
  Resp rsp;
  #line 2287 
  memset((void *)(& cmd),0,8UL);
  #line 2288 
  cmd.cmd = (unsigned short)9U;
  #line 2289 
  cif_clear_bit(4L,& ai->jobs);
  #line 2290 
  if ((ai->flags & 256UL) != 0UL) 
                                  #line 2290 
                                  cmd.parm0 = (unsigned short)65535U; else 
                                                                    #line 2290 
                                                                    cmd.parm0 = (unsigned short)0U;
  #line 2291 
  issuecommand(ai,& cmd,& rsp);
  #line 2292 
  up(& ai->sem);
  #line 2293 
  return;
}

#line 2295  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_set_multicast_list(struct net_device *dev)
{
  #line 2296 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 2298 
  if ((((unsigned long)dev->flags ^ ai->flags) & 256UL) != 0UL) {
    #line 2299 
    change_bit(8L,& ai->flags);
    #line 2300 
    if (down_trylock(& ai->sem) != 0) {
      #line 2301 
      cif_set_bit(4L,& ai->jobs);
      #line 2302 
      __wake_up(& ai->thr_wait,1U,1,(void *)0);
    }
    else 
         #line 2304 
         airo_set_promisc(ai);
  }
  #line 2307 
  if ((dev->flags & 512U) != 0U || dev->mc.count != 0) ;
  #line 2310 
  return;
}

#line 2312  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_mac_address(struct net_device *dev, void *p)
{
  #line 2314 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 2315 
  struct sockaddr *addr = (struct sockaddr *)p;
  #line 2317 
  readConfigRid(ai,1);
  #line 2318 
  memcpy((void *)(& ai->config.macAddr),(void *)(& addr->sa_data),(unsigned long)dev->addr_len);
  #line 2319 
  cif_set_bit(13L,& ai->flags);
  #line 2320 
  disable_MAC(ai,1);
  #line 2321 
  writeConfigRid(ai,1);
  #line 2322 
  enable_MAC(ai,1);
  #line 2323 
  memcpy((void *)(ai->dev)->dev_addr,(void *)(& addr->sa_data),(unsigned long)dev->addr_len);
  #line 2324 
  if (ai->wifidev != (struct net_device *)0) 
                                             #line 2325 
                                             memcpy((void *)(ai->wifidev)->dev_addr,(void *)(& addr->sa_data),(unsigned long)dev->addr_len);
  #line 2326 
  return 0;
}

#line 2329  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct list_head airo_devices = {.next = & airo_devices, .prev = & airo_devices};
#line 2331  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void add_airo_dev(struct airo_info *ai)
{
  #line 2335 
  if (ai->pci == (struct pci_dev *)0) 
                                      #line 2336 
                                      list_add_tail(& ai->dev_list,& airo_devices);
  #line 2337 
  return;
}

#line 2339  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void del_airo_dev(struct airo_info *ai)
{
  #line 2341 
  if (ai->pci == (struct pci_dev *)0) 
                                      #line 2342 
                                      list_del(& ai->dev_list);
  #line 2343 
  return;
}

#line 2345  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_close(struct net_device *dev)
{
  #line 2346 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 2348 
  netif_stop_queue(dev);
  #line 2350 
  if (ai->wifidev != dev) {
    #line 2357 
    cif_set_bit(1L,& ai->flags);
    #line 2358 
    disable_MAC(ai,1);
    #line 2360 
    disable_interrupts(ai);
    #line 2362 
    cif_free_irq((unsigned int)dev->irq,(void *)dev);
    #line 2364 
    cif_set_bit(0L,& ai->jobs);
    #line 2365 
    kthread_stop(ai->airo_thread_task);
  }
  #line 2367 
  return 0;
}

#line 2370  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
void stop_airo_card(struct net_device *dev, int freeres)
{
  #line 2372 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 2374 
  cif_set_bit(1L,& ai->flags);
  #line 2375 
  disable_MAC(ai,1);
  #line 2376 
  disable_interrupts(ai);
  #line 2377 
  takedown_proc_entry(dev,ai);
  #line 2378 
  if ((int)test_bit(12L,& ai->flags) != 0) {
    #line 2379 
    cif_unregister_netdev(dev);
    #line 2380 
    if (ai->wifidev != (struct net_device *)0) {
      #line 2381 
      cif_unregister_netdev(ai->wifidev);
      #line 2382 
      cif_free_netdev(ai->wifidev);
      #line 2383 
      ai->wifidev = (struct net_device *)0;
    }
    #line 2385 
    cif_clear_bit(12L,& ai->flags);
  }
  #line 2390 
  if ((int)test_bit(11L,& ai->flags) != 0) {
    #line 2390 
    if (skb_queue_empty(& ai->txq) == 0) {
      #line 2391 
      struct sk_buff *skb = (struct sk_buff *)0;
      #line 2392 
      while (1) {
        #line 2392 
        skb = skb_dequeue(& ai->txq);
        #line 2392 
        if (! (skb != (struct sk_buff *)0)) 
                                            #line 2392 
                                            break;
        #line 2393 
        consume_skb(skb);
      }
    }
  }
  #line 2396 
  airo_networks_free(ai);
  #line 2398 
  kfree((void *)ai->flash);
  #line 2399 
  kfree((void *)ai->rssi);
  #line 2400 
  kfree((void *)ai->SSID);
  #line 2401 
  if (freeres != 0) {
    #line 2403 
    __release_region(& ioport_resource,(unsigned long long)dev->base_addr,64ULL);
    #line 2404 
    if ((int)test_bit(11L,& ai->flags) != 0) {
      #line 2405 
      if (ai->pci != (struct pci_dev *)0) 
                                          #line 2406 
                                          mpi_unmap_card(ai->pci);
      #line 2407 
      if (ai->pcimem != (unsigned char *)0U) 
                                             #line 2408 
                                             iounmap((void *)ai->pcimem);
      #line 2409 
      if (ai->pciaux != (unsigned char *)0U) 
                                             #line 2410 
                                             iounmap((void *)ai->pciaux);
      #line 2411 
      pci_free_consistent(ai->pci,5728UL,(void *)ai->shared,ai->shared_dma);
    }
  }
  #line 2415 
  crypto_free_sync_skcipher(ai->tfm);
  #line 2416 
  del_airo_dev(ai);
  #line 2417 
  cif_free_netdev(dev);
  #line 2418 
  return;
}

#line 2422  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int wll_header_parse(struct sk_buff *skb, unsigned char *haddr)
{
  #line 2424 
  ;
  #line 2424 
  memcpy((void *)haddr,(void *)(skb_mac_header(skb) + 10U),6UL);
  #line 2425 
  return 6;
}

#line 2428  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void mpi_unmap_card(struct pci_dev *pci)
{
  #line 2431 
  unsigned long tmp;
  #line 2430 
  unsigned long mem_start = (unsigned long)pci->resource[1].start;
  #line 2431 
  if (pci->resource[1].start != 0ULL || pci->resource[1].end != pci->resource[1].start) 
    #line 2431 
    tmp = (unsigned long)((pci->resource[1].end - pci->resource[1].start) + 1ULL); else 
                                                                    #line 2431 
                                                                    tmp = 0UL;
  #line 2431 
  unsigned long mem_len = tmp;
  #line 2432 
  unsigned long aux_start = (unsigned long)pci->resource[2].start;
  #line 2433 
  unsigned long aux_len = 262144UL;
  #line 2435 
  __release_region(& iomem_resource,(unsigned long long)aux_start,(unsigned long long)aux_len);
  #line 2436 
  __release_region(& iomem_resource,(unsigned long long)mem_start,(unsigned long long)mem_len);
  #line 2437 
  return;
}

#line 2446  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int mpi_init_descriptors(struct airo_info *ai)
{
  #line 2448 
  Cmd cmd;
  #line 2449 
  Resp rsp;
  #line 2450 
  int i;
  #line 2451 
  int rc = 0;
  #line 2454 
  netif_stop_queue(ai->dev);
  #line 2456 
  memset((void *)(& rsp),0,8UL);
  #line 2457 
  memset((void *)(& cmd),0,8UL);
  #line 2459 
  cmd.cmd = (unsigned short)32U;
  #line 2460 
  cmd.parm0 = (unsigned short)2U;
  #line 2461 
  cmd.parm1 = (unsigned short)(ai->rxfids[0].card_ram_off - ai->pciaux);
  #line 2462 
  cmd.parm2 = (unsigned short)1U;
  #line 2463 
  rc = (int)issuecommand(ai,& cmd,& rsp);
  #line 2464 
  if (rc != 0) {
    #line 2465 
    printk((char *)"\001",(char *)(& (ai->dev)->name));
    #line 2466 
    return rc;
  }
  #line 2469 
  i = 0;
  #line 2469 
  while (i <= 0) {
    #line 2470 
    memcpy_toio((void *)ai->rxfids[i].card_ram_off,(void *)(& ai->rxfids[i].rx_desc),16UL);
    #line 2469 
    i ++;
  }
  #line 2476 
  memset((void *)(& rsp),0,8UL);
  #line 2477 
  memset((void *)(& cmd),0,8UL);
  #line 2479 
  cmd.cmd = (unsigned short)32U;
  #line 2480 
  cmd.parm0 = (unsigned short)1U;
  #line 2481 
  cmd.parm1 = (unsigned short)(ai->txfids[0].card_ram_off - ai->pciaux);
  #line 2482 
  cmd.parm2 = (unsigned short)1U;
  #line 2484 
  i = 0;
  #line 2484 
  while (i <= 0) {
    #line 2485 
    ai->txfids[i].tx_desc.valid = (unsigned int)1U;
    #line 2486 
    memcpy_toio((void *)ai->txfids[i].card_ram_off,(void *)(& ai->txfids[i].tx_desc),16UL);
    #line 2484 
    i ++;
  }
  #line 2489 
  ai->txfids[i + -1].tx_desc.eoc = (unsigned int)1U;
  #line 2491 
  rc = (int)issuecommand(ai,& cmd,& rsp);
  #line 2492 
  if (rc != 0) {
    #line 2493 
    printk((char *)"\001",(char *)(& (ai->dev)->name));
    #line 2494 
    return rc;
  }
  #line 2498 
  memset((void *)(& rsp),0,8UL);
  #line 2499 
  memset((void *)(& cmd),0,8UL);
  #line 2501 
  cmd.cmd = (unsigned short)32U;
  #line 2502 
  cmd.parm0 = (unsigned short)32U;
  #line 2503 
  cmd.parm1 = (unsigned short)(ai->config_desc.card_ram_off - ai->pciaux);
  #line 2504 
  cmd.parm2 = (unsigned short)1U;
  #line 2505 
  rc = (int)issuecommand(ai,& cmd,& rsp);
  #line 2506 
  if (rc != 0) {
    #line 2507 
    printk((char *)"\001",(char *)(& (ai->dev)->name));
    #line 2508 
    return rc;
  }
  #line 2511 
  memcpy_toio((void *)ai->config_desc.card_ram_off,(void *)(& ai->config_desc.rid_desc),16UL);
  #line 2514 
  return rc;
}

#line 2523  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int mpi_map_card(struct airo_info *ai, struct pci_dev *pci)
{
  #line 2525 
  unsigned long mem_start;
  #line 2525 
  unsigned long mem_len;
  #line 2525 
  unsigned long aux_start;
  #line 2525 
  unsigned long aux_len;
  #line 2527 
  int i;
  #line 2528 
  dma_addr_t busaddroff;
  #line 2529 
  unsigned char *vpackoff;
  #line 2530 
  unsigned char *pciaddroff;
  #line 2526 
  int rc = -1;
  #line 2532 
  mem_start = (unsigned long)pci->resource[1].start;
  #line 2533 
  if (pci->resource[1].start != 0ULL || pci->resource[1].end != pci->resource[1].start) 
    #line 2533 
    mem_len = (unsigned long)((pci->resource[1].end - pci->resource[1].start) + 1ULL); else 
                                                                    #line 2533 
                                                                    mem_len = 0UL;
  #line 2534 
  aux_start = (unsigned long)pci->resource[2].start;
  #line 2535 
  aux_len = 262144UL;
  #line 2537 
  if (__request_region(& iomem_resource,(unsigned long long)mem_start,
                       (unsigned long long)mem_len,(char *)"airo",0) == (struct resource *)0) {
    #line 2538 
    printk((char *)"\001",(char *)"",(int)mem_start,(int)mem_len);
    #line 2540 
    goto out;
  }
  #line 2542 
  if (__request_region(& iomem_resource,(unsigned long long)aux_start,
                         (unsigned long long)aux_len,(char *)"airo",0) == (struct resource *)0) {
    #line 2543 
    printk((char *)"\001",(char *)"",(int)aux_start,(int)aux_len);
    #line 2545 
    goto free_region1;
  }
  #line 2548 
  ai->pcimem = (unsigned char *)ioremap((unsigned long long)mem_start,mem_len);
  #line 2549 
  if (ai->pcimem == (unsigned char *)0U) {
    #line 2550 
    printk((char *)"\001",(char *)"",(int)mem_start,(int)mem_len);
    #line 2552 
    goto free_region2;
  }
  #line 2554 
  ai->pciaux = (unsigned char *)ioremap((unsigned long long)aux_start,aux_len);
  #line 2555 
  if (ai->pciaux == (unsigned char *)0U) {
    #line 2556 
    printk((char *)"\001",(char *)"",(int)aux_start,(int)aux_len);
    #line 2558 
    goto free_memmap;
  }
  #line 2562 
  ai->shared = (unsigned char *)pci_alloc_consistent(pci,5728UL,& ai->shared_dma);
  #line 2563 
  if (ai->shared == (unsigned char *)0U) {
    #line 2564 
    printk((char *)"\001",(char *)"",5728);
    #line 2566 
    goto free_auxmap;
  }
  #line 2572 
  busaddroff = ai->shared_dma;
  #line 2573 
  pciaddroff = ai->pciaux + 2048U;
  #line 2574 
  vpackoff = ai->shared;
  #line 2577 
  i = 0;
  #line 2577 
  while (i <= 0) {
    #line 2578 
    ai->rxfids[i].pending = 0;
    #line 2579 
    ai->rxfids[i].card_ram_off = pciaddroff;
    #line 2580 
    ai->rxfids[i].virtual_host_addr = (char *)vpackoff;
    #line 2581 
    ai->rxfids[i].rx_desc.host_addr = busaddroff;
    #line 2582 
    ai->rxfids[i].rx_desc.valid = (unsigned int)1U;
    #line 2583 
    ai->rxfids[i].rx_desc.len = (unsigned int)1840U;
    #line 2584 
    ai->rxfids[i].rx_desc.rdy = (unsigned int)0U;
    #line 2586 
    pciaddroff += 16UL;
    #line 2587 
    busaddroff += 1840ULL;
    #line 2588 
    vpackoff += 1840U;
    #line 2577 
    i ++;
  }
  #line 2592 
  i = 0;
  #line 2592 
  while (i <= 0) {
    #line 2593 
    ai->txfids[i].card_ram_off = pciaddroff;
    #line 2594 
    ai->txfids[i].virtual_host_addr = (char *)vpackoff;
    #line 2595 
    ai->txfids[i].tx_desc.valid = (unsigned int)1U;
    #line 2596 
    ai->txfids[i].tx_desc.host_addr = busaddroff;
    #line 2597 
    memcpy((void *)ai->txfids[i].virtual_host_addr,(void *)(& wifictlhdr8023),54UL);
    #line 2600 
    pciaddroff += 16UL;
    #line 2601 
    busaddroff += 1840ULL;
    #line 2602 
    vpackoff += 1840U;
    #line 2592 
    i ++;
  }
  #line 2604 
  ai->txfids[i + -1].tx_desc.eoc = (unsigned int)1U;
  #line 2607 
  ai->config_desc.card_ram_off = pciaddroff;
  #line 2608 
  ai->config_desc.virtual_host_addr = (char *)vpackoff;
  #line 2609 
  ai->config_desc.rid_desc.host_addr = busaddroff;
  #line 2610 
  ai->ridbus = (unsigned long)busaddroff;
  #line 2611 
  ai->config_desc.rid_desc.rid = (unsigned int)0U;
  #line 2612 
  ai->config_desc.rid_desc.len = (unsigned int)2048U;
  #line 2613 
  ai->config_desc.rid_desc.valid = (unsigned int)1U;
  #line 2614 
  pciaddroff += 16UL;
  #line 2615 
  busaddroff += 2048ULL;
  #line 2616 
  vpackoff += 2048U;
  #line 2619 
  if (mpi_init_descriptors(ai) != 0) 
                                     #line 2620 
                                     goto free_shared;
  #line 2622 
  return 0;
  #line 2623 
  free_shared: 
               #line 2623 
  ;
  #line 2624 
  pci_free_consistent(pci,5728UL,(void *)ai->shared,ai->shared_dma);
  #line 2625 
  free_auxmap: 
               #line 2625 
  ;
  #line 2626 
  iounmap((void *)ai->pciaux);
  #line 2627 
  free_memmap: 
               #line 2627 
  ;
  #line 2628 
  iounmap((void *)ai->pcimem);
  #line 2629 
  free_region2: 
                #line 2629 
  ;
  #line 2630 
  __release_region(& iomem_resource,(unsigned long long)aux_start,(unsigned long long)aux_len);
  #line 2631 
  free_region1: 
                #line 2631 
  ;
  #line 2632 
  __release_region(& iomem_resource,(unsigned long long)mem_start,(unsigned long long)mem_len);
  #line 2633 
  out: 
       #line 2633 
  ;
  #line 2634 
  return rc;
}

#line 2637  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct header_ops airo_header_ops = {.parse = & wll_header_parse};
#line 2641  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct net_device_ops airo11_netdev_ops = {.ndo_open = & airo_open, .ndo_stop = & airo_close, .ndo_start_xmit = & airo_start_xmit11, .ndo_set_mac_address = & airo_set_mac_address, .ndo_do_ioctl = & airo_ioctl, .ndo_get_stats = & airo_get_stats};
#line 2650  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void wifi_setup(struct net_device *dev)
{
  #line 2652 
  dev->netdev_ops = & airo11_netdev_ops;
  #line 2653 
  dev->header_ops = & airo_header_ops;
  #line 2654 
  dev->wireless_handlers = & airo_handler_def;
  #line 2656 
  dev->type = (unsigned short)801U;
  #line 2657 
  dev->hard_header_len = (unsigned short)14U;
  #line 2658 
  dev->mtu = 2312U;
  #line 2659 
  dev->min_mtu = 68U;
  #line 2660 
  dev->max_mtu = 2400U;
  #line 2661 
  dev->addr_len = (unsigned char)6U;
  #line 2662 
  dev->tx_queue_len = 100U;
  #line 2664 
  eth_broadcast_addr((u8 *)(& dev->broadcast));
  #line 2666 
  dev->flags = 4098U;
  #line 2667 
  return;
}

#line 2669  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct net_device *init_wifidev(struct airo_info *ai, struct net_device *ethdev)
{
  #line 2672 
  int err;
  #line 2673 
  struct net_device *dev = cif_alloc_netdev_mqs(0,(char *)"wifi%d",(unsigned char)0,& wifi_setup,1U,1U);
  #line 2675 
  if (dev == (struct net_device *)0) 
                                     #line 2676 
                                     return (struct net_device *)0;
  #line 2677 
  dev->__anonCompField_net_device_161.ml_priv = ethdev->__anonCompField_net_device_161.ml_priv;
  #line 2678 
  dev->irq = ethdev->irq;
  #line 2679 
  dev->base_addr = ethdev->base_addr;
  #line 2680 
  dev->wireless_data = ethdev->wireless_data;
  #line 2681 
  dev->dev.parent = ethdev->dev.parent;
  #line 2682 
  eth_hw_addr_inherit(dev,ethdev);
  #line 2683 
  err = cif_register_netdev(dev);
  #line 2684 
  if (err < 0) {
    #line 2685 
    cif_free_netdev(dev);
    #line 2686 
    return (struct net_device *)0;
  }
  #line 2688 
  return dev;
}

#line 2691  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int reset_card(struct net_device *dev, int lock)
{
  #line 2692 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 2694 
  if (lock != 0) {
    #line 2694 
    if (down_interruptible(& ai->sem) != 0) 
                                            #line 2695 
                                            return -1;
  }
  #line 2696 
  waitbusy(ai);
  #line 2697 
  OUT4500(ai,(unsigned short)0,(unsigned short)4);
  #line 2698 
  msleep(200U);
  #line 2699 
  waitbusy(ai);
  #line 2700 
  msleep(200U);
  #line 2701 
  if (lock != 0) 
                 #line 2702 
                 up(& ai->sem);
  #line 2703 
  return 0;
}

#line 2707  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_networks_allocate(struct airo_info *ai)
{
  #line 2709 
  if (ai->networks != (BSSListElement *)0) 
                                           #line 2710 
                                           return 0;
  #line 2712 
  ai->networks = (BSSListElement *)kcalloc(64UL,736UL,3264U);
  #line 2714 
  if (ai->networks == (BSSListElement *)0) {
    #line 2715 
    printk((char *)"\001",(char *)"");
    #line 2716 
    return -12;
  }
  #line 2719 
  return 0;
}

#line 2722  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_networks_free(struct airo_info *ai)
{
  #line 2724 
  kfree((void *)ai->networks);
  #line 2725 
  ai->networks = (BSSListElement *)0;
  #line 2726 
  return;
}

#line 2728  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_networks_initialize(struct airo_info *ai)
{
  #line 2730 
  int i;
  #line 2732 
  INIT_LIST_HEAD(& ai->network_free_list);
  #line 2733 
  INIT_LIST_HEAD(& ai->network_list);
  #line 2734 
  i = 0;
  #line 2734 
  while (i <= 63) {
    #line 2735 
    list_add_tail(& (ai->networks + (unsigned long)i)->list,& ai->network_free_list);
    #line 2734 
    i ++;
  }
  #line 2737 
  return;
}

#line 2739  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct net_device_ops airo_netdev_ops = {.ndo_open = & airo_open, .ndo_stop = & airo_close, .ndo_start_xmit = & airo_start_xmit, .ndo_set_rx_mode = & airo_set_multicast_list, .ndo_set_mac_address = & airo_set_mac_address, .ndo_validate_addr = & eth_validate_addr, .ndo_do_ioctl = & airo_ioctl, .ndo_get_stats = & airo_get_stats};
#line 2750  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct net_device_ops mpi_netdev_ops = {.ndo_open = & airo_open, .ndo_stop = & airo_close, .ndo_start_xmit = & mpi_start_xmit, .ndo_set_rx_mode = & airo_set_multicast_list, .ndo_set_mac_address = & airo_set_mac_address, .ndo_validate_addr = & eth_validate_addr, .ndo_do_ioctl = & airo_ioctl, .ndo_get_stats = & airo_get_stats};
#line 2762  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct net_device *_init_airo_card(unsigned short irq_0, int port, int is_pcmcia, struct pci_dev *pci, struct device *dmdev)
{
  #line 2766 
  struct net_device *dev;
  #line 2767 
  struct airo_info *ai;
  #line 2768 
  int i;
  #line 2768 
  int rc;
  #line 2769 
  CapabilityRid cap_rid;
  #line 2772 
  dev = cif_alloc_netdev_mqs(11080,(char *)"",(unsigned char)0,& ether_setup,1U,1U);
  #line 2773 
  if (dev == (struct net_device *)0) {
    #line 2774 
    printk((char *)"\001",(char *)"");
    #line 2775 
    return (struct net_device *)0;
  }
  #line 2778 
  dev->__anonCompField_net_device_161.ml_priv = netdev_priv(dev);
  #line 2778 
  ai = (struct airo_info *)netdev_priv(dev);
  #line 2779 
  ai->wifidev = (struct net_device *)0;
  #line 2780 
  ai->flags = 2UL;
  #line 2781 
  ai->jobs = 0UL;
  #line 2782 
  ai->dev = dev;
  #line 2783 
  if (pci != (struct pci_dev *)0 && ((unsigned int)pci->device == 20480U || (unsigned int)pci->device == 42244U)) {
    #line 2784 
    printk((char *)"\001",(char *)"");
    #line 2785 
    cif_set_bit(11L,& ai->flags);
  }
  #line 2787 
  spinlock_check(& ai->aux_lock);
  {
    #line 2787 
    struct lock_class_key __key;
    #line 2787 
    __raw_spin_lock_init(& ai->aux_lock.__anonCompField_spinlock_25.rlock,(char *)"&(&ai->aux_lock)->rlock",& __key);
  }
  #line 2788 
  sema_init(& ai->sem,1);
  #line 2789 
  ai->config.len = (unsigned short)0U;
  #line 2790 
  ai->pci = pci;
  {
    #line 2791 
    struct lock_class_key __key_0;
    #line 2791 
    __init_waitqueue_head(& ai->thr_wait,(char *)"&ai->thr_wait",& __key_0);
  }
  #line 2792 
  ai->tfm = (struct crypto_sync_skcipher *)0;
  #line 2793 
  add_airo_dev(ai);
  #line 2794 
  ai->APList.len = (unsigned short)26U;
  #line 2796 
  if (airo_networks_allocate(ai) != 0) 
                                       #line 2797 
                                       goto err_out_free;
  #line 2798 
  airo_networks_initialize(ai);
  #line 2800 
  skb_queue_head_init(& ai->txq);
  #line 2803 
  if ((int)test_bit(11L,& ai->flags) != 0) 
                                           #line 2804 
                                           dev->netdev_ops = & mpi_netdev_ops; else 
                                                                    #line 2806 
                                                                    dev->netdev_ops = & airo_netdev_ops;
  #line 2807 
  dev->wireless_handlers = & airo_handler_def;
  #line 2808 
  ai->wireless_data.spy_data = & ai->spy_data;
  #line 2809 
  dev->wireless_data = & ai->wireless_data;
  #line 2810 
  dev->irq = (int)irq_0;
  #line 2811 
  dev->base_addr = (unsigned long)port;
  #line 2812 
  dev->priv_flags &= 4294965247U;
  #line 2813 
  dev->max_mtu = 2400U;
  #line 2815 
  dev->dev.parent = dmdev;
  #line 2817 
  reset_card(dev,1);
  #line 2818 
  msleep(400U);
  #line 2820 
  if (is_pcmcia == 0) {
    #line 2821 
    if (__request_region(& ioport_resource,
                         (unsigned long long)dev->base_addr,64ULL,
                         (char *)"airo",0) == (struct resource *)0) {
      #line 2822 
      rc = -16;
      #line 2823 
      printk((char *)"\001",(char *)(& dev->name));
      #line 2824 
      goto err_out_nets;
    }
  }
  #line 2828 
  if ((int)test_bit(11L,& ai->flags) != 0) {
    #line 2829 
    if (mpi_map_card(ai,pci) != 0) {
      #line 2830 
      printk((char *)"\001",(char *)"");
      #line 2831 
      goto err_out_res;
    }
  }
  #line 2835 
  if (probe != 0) {
    #line 2836 
    if ((unsigned int)setup_card(ai,dev->dev_addr,1) != 0U) {
      #line 2837 
      printk((char *)"\001",(char *)(& dev->name));
      #line 2838 
      rc = -5;
      #line 2839 
      goto err_out_map;
    }
  }
  else {
    #line 2841 
    if (! test_bit(11L,& ai->flags)) {
      #line 2842 
      ai->bap_read = & fast_bap_read;
      #line 2843 
      cif_set_bit(15L,& ai->flags);
    }
  }
  #line 2846 
  strcpy((char *)(& dev->name),(char *)"eth%d");
  #line 2847 
  rc = cif_register_netdev(dev);
  #line 2848 
  if (rc != 0) {
    #line 2849 
    printk((char *)"\001",(char *)(& dev->name));
    #line 2850 
    goto err_out_map;
  }
  #line 2852 
  ai->wifidev = init_wifidev(ai,dev);
  #line 2853 
  if (ai->wifidev == (struct net_device *)0) 
                                             #line 2854 
                                             goto err_out_reg;
  #line 2856 
  rc = readCapabilityRid(ai,& cap_rid,1);
  #line 2857 
  if (rc != 0) {
    #line 2858 
    rc = -5;
    #line 2859 
    goto err_out_wifi;
  }
  #line 2862 
  ai->wep_capable = ((int)cap_rid.softCap >> 1) & 1;
  #line 2863 
  if (((int)cap_rid.softCap & 128) != 0) 
                                         #line 2863 
                                         ai->max_wep_idx = 3; else 
                                                                   #line 2863 
                                                                   ai->max_wep_idx = 0;
  #line 2865 
  printk((char *)"\001",(char *)(& dev->name),((int)cap_rid.softVer >> 8) & 15,(int)cap_rid.softVer & 255,(int)cap_rid.softSubVer);
  #line 2872 
  if ((unsigned int)cap_rid.softVer > 1328U || (unsigned int)cap_rid.softVer == 1328U && (unsigned int)cap_rid.softSubVer > 16U) {
    #line 2875 
    printk((char *)"\001",(char *)(& (ai->dev)->name));
    #line 2877 
    cif_set_bit(16L,& ai->flags);
    #line 2878 
    ai->bssListFirst = 65396U;
    #line 2879 
    ai->bssListNext = 65397U;
    #line 2880 
    ai->bssListRidLen = 714U;
  }
  else {
    #line 2882 
    printk((char *)"\001",(char *)(& (ai->dev)->name));
    #line 2885 
    ai->bssListFirst = 65394U;
    #line 2886 
    ai->bssListNext = 65395U;
    #line 2887 
    ai->bssListRidLen = 70U;
  }
  #line 2890 
  cif_set_bit(12L,& ai->flags);
  #line 2891 
  printk((char *)"\001",(char *)(& dev->name),dev->dev_addr);
  #line 2894 
  if (probe != 0) {
    #line 2894 
    if (! test_bit(11L,& ai->flags)) {
      #line 2895 
      i = 0;
      #line 2895 
      while (i <= 5) {
        #line 2896 
        ai->fids[i] = (unsigned int)transmit_allocate(ai,2312,i > 2);
        #line 2895 
        i ++;
      }
    }
  }
  #line 2898 
  if (setup_proc_entry(dev,
                         (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv) < 0) 
    #line 2899 
    goto err_out_wifi;
  #line 2901 
  return dev;
  #line 2903 
  err_out_wifi: 
                #line 2903 
  ;
  #line 2904 
  cif_unregister_netdev(ai->wifidev);
  #line 2905 
  cif_free_netdev(ai->wifidev);
  #line 2906 
  err_out_reg: 
               #line 2906 
  ;
  #line 2907 
  cif_unregister_netdev(dev);
  #line 2908 
  err_out_map: 
               #line 2908 
  ;
  #line 2909 
  if ((int)test_bit(11L,& ai->flags) != 0) 
    #line 2909 
    if (pci != (struct pci_dev *)0) {
      #line 2910 
      pci_free_consistent(pci,5728UL,(void *)ai->shared,ai->shared_dma);
      #line 2911 
      iounmap((void *)ai->pciaux);
      #line 2912 
      iounmap((void *)ai->pcimem);
      #line 2913 
      mpi_unmap_card(ai->pci);
    }
  #line 2915 
  err_out_res: 
               #line 2915 
  ;
  #line 2916 
  if (is_pcmcia == 0) 
                      #line 2917 
                      __release_region(& ioport_resource,(unsigned long long)dev->base_addr,64ULL);
  #line 2918 
  err_out_nets: 
                #line 2918 
  ;
  #line 2919 
  airo_networks_free(ai);
  #line 2920 
  err_out_free: 
                #line 2920 
  ;
  #line 2921 
  del_airo_dev(ai);
  #line 2922 
  cif_free_netdev(dev);
  #line 2923 
  return (struct net_device *)0;
}

#line 2926  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
struct net_device *init_airo_card(unsigned short irq_0, int port, int is_pcmcia, struct device *dmdev)
{
  #line 2929 
  return _init_airo_card((unsigned short)((int)irq_0),port,is_pcmcia,
                      (struct pci_dev *)0,dmdev);
}

#line 2934  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int waitbusy(struct airo_info *ai)
{
  #line 2935 
  int delay = 0;
  #line 2936 
  while (1) {
    #line 2936 
    if (((int)IN4500(ai,(unsigned short)0) & 32768) != 0) {
      #line 2936 
      if (! (delay <= 9999)) 
                             #line 2936 
                             break;
    }
    else 
         #line 2936 
         break;
    #line 2937 
    __const_udelay(42950UL);
    #line 2938 
    delay ++;
    #line 2938 
    if (delay % 20 == 0) 
                         #line 2939 
                         OUT4500(ai,(unsigned short)52,(unsigned short)16384);
  }
  #line 2941 
  return delay <= 9999;
}

#line 2944  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
int reset_airo_card(struct net_device *dev)
{
  #line 2946 
  int i;
  #line 2947 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 2949 
  if (reset_card(dev,1) != 0) 
                              #line 2950 
                              return -1;
  #line 2952 
  if ((unsigned int)setup_card(ai,dev->dev_addr,1) != 0U) {
    #line 2953 
    printk((char *)"\001",(char *)(& dev->name));
    #line 2954 
    return -1;
  }
  #line 2956 
  printk((char *)"\001",(char *)(& dev->name),dev->dev_addr);
  #line 2958 
  if (! test_bit(11L,& ai->flags)) {
    #line 2959 
    i = 0;
    #line 2959 
    while (i <= 5) {
      #line 2960 
      ai->fids[i] = (unsigned int)transmit_allocate(ai,2312,i > 2);
      #line 2959 
      i ++;
    }
  }
  #line 2962 
  enable_interrupts(ai);
  #line 2963 
  netif_wake_queue(dev);
  #line 2964 
  return 0;
}

#line 2969  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_send_event(struct net_device *dev)
{
  #line 2971 
  union iwreq_data wrqu;
  #line 2972 
  StatusRid status_rid;
  #line 2970 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 2974 
  cif_clear_bit(6L,& ai->jobs);
  #line 2975 
  PC4500_readrid(ai,(unsigned short)65360,(void *)(& status_rid),136,0);
  #line 2976 
  up(& ai->sem);
  #line 2977 
  wrqu.data.length = (unsigned short)0U;
  #line 2978 
  wrqu.data.flags = (unsigned short)0U;
  #line 2979 
  memcpy((void *)(& wrqu.ap_addr.sa_data),(void *)(& status_rid.bssid[0]),6UL);
  #line 2980 
  wrqu.ap_addr.sa_family = (unsigned short)1U;
  #line 2983 
  wireless_send_event(dev,35605U,& wrqu,(char *)0);
  #line 2984 
  return;
}

#line 2986  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_process_scan_results(struct airo_info *ai)
{
  #line 2994 
  void *__mptr_0;
  #line 2994 
  void *__mptr;
  #line 2987 
  union iwreq_data wrqu;
  #line 2988 
  BSSListRid bss;
  #line 2989 
  int rc;
  #line 2990 
  BSSListElement *loop_net;
  #line 2991 
  BSSListElement *tmp_net;
  #line 2994 
  __mptr = (void *)ai->network_list.next;
  #line 2994 
  loop_net = ((BSSListElement *)(__mptr + 18446744073709550896U));
  #line 2994 
  __mptr_0 = (void *)loop_net->list.next;
  #line 2995 
  tmp_net = ((BSSListElement *)(__mptr_0 + 18446744073709550896U));
  #line 2994 
  while (& loop_net->list != & ai->network_list) {
    #line 2994 
    void *__mptr_1;
    #line 2995 
    list_move_tail(& loop_net->list,& ai->network_free_list);
    #line 2997 
    memset((void *)loop_net,0,714UL);
    #line 2994 
    loop_net = tmp_net;
    #line 2994 
    __mptr_1 = (void *)tmp_net->list.next;
    #line 2994 
    tmp_net = ((BSSListElement *)(__mptr_1 + 18446744073709550896U));
  }
  #line 3001 
  rc = PC4500_readrid(ai,(unsigned short)((int)((unsigned short)ai->bssListFirst)),(void *)(& bss),(int)ai->bssListRidLen,0);
  #line 3002 
  if (rc != 0 || (unsigned int)bss.index == 65535U) 
                                                    #line 3004 
                                                    goto out;
  #line 3008 
  tmp_net = (BSSListElement *)0;
  #line 3009 
  while (rc == 0 && (unsigned int)bss.index != 65535U) {
    #line 3011 
    if (list_empty(& ai->network_free_list) == 0) {
      #line 3012 
      void *__mptr_2;
      #line 3012 
      __mptr_2 = (void *)ai->network_free_list.next;
      #line 3012 
      tmp_net = ((BSSListElement *)(__mptr_2 + 18446744073709550896U));
      #line 3014 
      list_del(ai->network_free_list.next);
    }
    #line 3017 
    if (tmp_net != (BSSListElement *)0) {
      #line 3018 
      memcpy((void *)tmp_net,(void *)(& bss),714UL);
      #line 3019 
      list_add_tail(& tmp_net->list,& ai->network_list);
      #line 3020 
      tmp_net = (BSSListElement *)0;
    }
    #line 3024 
    rc = PC4500_readrid(ai,(unsigned short)((int)((unsigned short)ai->bssListNext)),(void *)(& bss),(int)ai->bssListRidLen,0);
  }
  #line 3028 
  out: 
       #line 3028 
  ;
  #line 3030 
  disable_MAC(ai,2);
  #line 3031 
  writeAPListRid(ai,& ai->APList,0);
  #line 3032 
  enable_MAC(ai,0);
  #line 3034 
  ai->scan_timeout = 0UL;
  #line 3035 
  cif_clear_bit(9L,& ai->jobs);
  #line 3036 
  up(& ai->sem);
  #line 3045 
  wrqu.data.length = (unsigned short)0U;
  #line 3046 
  wrqu.data.flags = (unsigned short)0U;
  #line 3047 
  wireless_send_event(ai->dev,35609U,& wrqu,(char *)0);
  #line 3048 
  return;
}

#line 3050  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_thread(void *data)
{
  #line 3053 
  int locked;
  #line 3051 
  struct net_device *dev = (struct net_device *)data;
  #line 3052 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 3055 
  set_freezable();
  #line 3056 
  while (1) {
    {
      #line 3058 
      try_to_freeze();
      #line 3060 
      if ((int)test_bit(0L,& ai->jobs) != 0) 
                                             #line 3061 
                                             break;
      #line 3063 
      if (ai->jobs != 0UL) 
                           #line 3064 
                           locked = down_interruptible(& ai->sem);
      else {
        #line 3066 
        wait_queue_entry_t wait;
        #line 3068 
        init_waitqueue_entry(& wait,ldv_get_current());
        #line 3069 
        add_wait_queue(& ai->thr_wait,& wait);
        #line 3070 
        while (1) {
          {
            {
              #line 3071 
              int __ret_warn_on = 0;
              #line 3071 
              if ((long)(__ret_warn_on != 0) != 0L) {
                #line 3072 
                ldv_inline_asm();
                #line 3073 
                ldv_inline_asm();
              }
              #line 3071 
              long tmp_2 = (long)(__ret_warn_on != 0);
            }
            #line 3071 
            __here_0: 
                      #line 3071 
            ;
            #line 3071 
            ldv_get_current()->task_state_change = (unsigned long)((void *)0);
            {
              #line 3071 
              long *__ai_ptr = & ldv_get_current()->state;
              #line 3071 
              kasan_check_read((void *)__ai_ptr,8U);
              {
                #line 3071 
                long __ret = 1L;
                #line 3071 
                switch (8UL) {
                  #line 3071 
                  case (unsigned long)1: 
                                         #line 3071 
                  ;
                  #line 3072 
                  ldv_inline_asm();
                  #line 3071 
                  break;
                  #line 3071 
                  case (unsigned long)2: 
                                         #line 3071 
                  ;
                  #line 3072 
                  ldv_inline_asm();
                  #line 3071 
                  break;
                  #line 3071 
                  case (unsigned long)4: 
                                         #line 3071 
                  ;
                  #line 3072 
                  ldv_inline_asm();
                  #line 3071 
                  break;
                  #line 3071 
                  case (unsigned long)8: 
                                         #line 3071 
                  ;
                  #line 3072 
                  ldv_inline_asm();
                  #line 3071 
                  break;
                  #line 3071 
                  default: 
                           #line 3071 
                  ;
                  #line 3071 
                  __xchg_wrong_size();
                }
                #line 3071 
                long tmp_4 = __ret;
              }
            }
          }
          #line 3072 
          if (ai->jobs != 0UL) 
                               #line 3073 
                               break;
          #line 3074 
          if (ai->expires != 0UL || ai->scan_timeout != 0UL) {
            {
              #line 3076 
              unsigned long __dummy_1;
              #line 3076 
              unsigned long __dummy2_1;
              }
            #line 3075 
            if (1 != 0) {
              {
                #line 3076 
                unsigned long __dummy_2;
                #line 3076 
                unsigned long __dummy2_2;
                }
              #line 3076 
              if (1 != 0) {
                #line 3076 
                if ((long)(jiffies - ai->scan_timeout) >= 0L) {
                  #line 3075 
                  if (ai->scan_timeout != 0UL) {
                    #line 3077 
                    cif_set_bit(9L,& ai->jobs);
                    #line 3078 
                    break;
                  }
                  else 
                       #line 3075 
                       goto _LAND_1;
                }
                else 
                     #line 3075 
                     goto _LAND_1;
              }
              else 
                   #line 3075 
                   goto _LAND_1;
            }
            else {
              #line 3075 
              _LAND_1: {
                         #line 3080 
                         unsigned long __dummy;
                         #line 3080 
                         unsigned long __dummy2;
                         }
              #line 3079 
              if (1 != 0) {
                {
                  #line 3080 
                  unsigned long __dummy_0;
                  #line 3080 
                  unsigned long __dummy2_0;
                  }
                #line 3080 
                if (1 != 0) 
                  #line 3080 
                  if ((long)(jiffies - ai->expires) >= 0L) 
                    #line 3079 
                    if (ai->expires != 0UL) {
                      #line 3081 
                      cif_set_bit(7L,& ai->jobs);
                      #line 3082 
                      break;
                    }
              }
            }
            #line 3084 
            if (! kthread_should_stop()) {
              #line 3085 
              if (! freezing(ldv_get_current())) {
                #line 3086 
                unsigned long wake_at;
                #line 3087 
                if (ai->expires == 0UL || ai->scan_timeout == 0UL) {
                  #line 3088 
                  unsigned long __UNIQUE_ID___x475;
                  #line 3088 
                  unsigned long tmp_7;
                  {
                    #line 3088 
                    __UNIQUE_ID___x475 = ai->expires;
                    #line 3088 
                    unsigned long __UNIQUE_ID___y476 = ai->scan_timeout;
                    #line 3088 
                    if (__UNIQUE_ID___x475 > __UNIQUE_ID___y476) 
                                                                 #line 3088 
                                                                 tmp_7 = __UNIQUE_ID___x475; else 
                                                                    #line 3088 
                                                                    tmp_7 = __UNIQUE_ID___y476;
                    }
                  #line 3088 
                  wake_at = tmp_7;
                }
                else {
                  #line 3091 
                  unsigned long __UNIQUE_ID___x477;
                  #line 3091 
                  unsigned long tmp_9;
                  {
                    #line 3091 
                    __UNIQUE_ID___x477 = ai->expires;
                    #line 3091 
                    unsigned long __UNIQUE_ID___y478 = ai->scan_timeout;
                    #line 3091 
                    if (__UNIQUE_ID___x477 < __UNIQUE_ID___y478) 
                                                                 #line 3091 
                                                                 tmp_9 = __UNIQUE_ID___x477; else 
                                                                    #line 3091 
                                                                    tmp_9 = __UNIQUE_ID___y478;
                    }
                  #line 3091 
                  wake_at = tmp_9;
                }
                #line 3094 
                schedule_timeout((long)(wake_at - jiffies));
                #line 3095 
                goto __Cont;
              }
            }
          }
          else {
            #line 3097 
            if (! kthread_should_stop()) {
              #line 3098 
              if (! freezing(ldv_get_current())) {
                #line 3099 
                schedule();
                #line 3100 
                goto __Cont;
              }
            }
          }
          #line 3102 
          break;
          #line 3070 
          __Cont: 
                  #line 3070 
          ;
        }
        #line 3104 
        ldv_get_current()->state = 0L;
        #line 3105 
        remove_wait_queue(& ai->thr_wait,& wait);
        #line 3106 
        locked = 1;
      }
      #line 3109 
      if (locked != 0) 
                       #line 3110 
                       continue;
      #line 3112 
      if ((int)test_bit(0L,& ai->jobs) != 0) {
        #line 3113 
        up(& ai->sem);
        #line 3114 
        break;
      }
      #line 3117 
      if (ai->power.event != 0) 
                                #line 3117 
                                goto _LOR;
      else {
        #line 3117 
        if ((int)test_bit(15L,& ai->flags) != 0) {
          #line 3117 
          _LOR: {
                  #line 3118 
                  up(& ai->sem);
                  #line 3119 
                  continue;
                }
        }
      }
      #line 3122 
      if ((int)test_bit(1L,& ai->jobs) != 0) 
                                             #line 3123 
                                             airo_end_xmit(dev);
      else {
        #line 3124 
        if ((int)test_bit(2L,& ai->jobs) != 0) 
                                               #line 3125 
                                               airo_end_xmit11(dev);
        else {
          #line 3126 
          if ((int)test_bit(3L,& ai->jobs) != 0) 
                                                 #line 3127 
                                                 airo_read_stats(dev);
          else {
            #line 3128 
            if ((int)test_bit(8L,& ai->jobs) != 0) 
                                                   #line 3129 
                                                   airo_read_wireless_stats(ai);
            else {
              #line 3130 
              if ((int)test_bit(4L,& ai->jobs) != 0) 
                                                     #line 3131 
                                                     airo_set_promisc(ai);
              else {
                #line 3132 
                if ((int)test_bit(5L,& ai->jobs) != 0) 
                                                       #line 3133 
                                                       micinit(ai);
                else {
                  #line 3134 
                  if ((int)test_bit(6L,& ai->jobs) != 0) 
                                                         #line 3135 
                                                         airo_send_event(dev);
                  else {
                    #line 3136 
                    if ((int)test_bit(7L,& ai->jobs) != 0) 
                                                           #line 3137 
                                                           timer_func(dev);
                    else {
                      #line 3138 
                      if ((int)test_bit(9L,& ai->jobs) != 0) 
                                                             #line 3139 
                                                             airo_process_scan_results(ai); else 
                                                                    #line 3141 
                                                                    up(& ai->sem);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  #line 3144 
  return 0;
}

#line 3147  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int header_len(__le16 ctl)
{
  #line 3149 
  u16 fc = ctl;
  #line 3150 
  switch ((int)fc & 12) {
    #line 3151 
    case 4: 
            #line 3151 
    ;
    #line 3152 
    if (((int)fc & 224) == 192) 
                                #line 3153 
                                return 10;
    #line 3154 
    return 16;
    #line 3155 
    case 8: 
            #line 3155 
    ;
    #line 3156 
    if (((int)fc & 768) == 768) 
                                #line 3157 
                                return 30;
  }
  #line 3159 
  return 24;
}

#line 3162  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_handle_cisco_mic(struct airo_info *ai)
{
  #line 3164 
  if ((int)test_bit(4L,& ai->flags) != 0) {
    #line 3165 
    cif_set_bit(5L,& ai->jobs);
    #line 3166 
    __wake_up(& ai->thr_wait,1U,1,(void *)0);
  }
  #line 3168 
  return;
}

#line 3183  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_print_status(char *devname, u16 status)
{
  #line 3185 
  u8 reason = (unsigned char)status;
  #line 3187 
  switch ((int)status & 65280) {
    #line 3188 
    case 32768: 
                #line 3188 
    ;
    #line 3189 
    switch ((int)status) {
      #line 3190 
      case 32768: 
                  #line 3190 
      ;
      #line 3191 
      printk((char *)"\001",devname);
      #line 3192 
      break;
      #line 3193 
      case 32769: 
                  #line 3193 
      ;
      #line 3194 
      case 32770: 
                  #line 3194 
      ;
      #line 3195 
      printk((char *)"\001",devname);
      #line 3196 
      break;
      #line 3197 
      case 32771: 
                  #line 3197 
      ;
      #line 3198 
      printk((char *)"\001",devname);
      #line 3199 
      break;
      #line 3200 
      case 32772: 
                  #line 3200 
      ;
      #line 3201 
      printk((char *)"\001",devname);
      #line 3202 
      break;
      #line 3203 
      default: 
               #line 3203 
      ;
      #line 3204 
      printk((char *)"\001",devname,(int)status);
      #line 3205 
      break;
    }
    #line 3207 
    break;
    #line 3208 
    case 33024: 
                #line 3208 
    ;
    #line 3209 
    printk((char *)"\001",devname,(int)reason);
    #line 3210 
    break;
    #line 3211 
    case 33280: 
                #line 3211 
    ;
    #line 3212 
    printk((char *)"\001",devname,(int)reason);
    #line 3213 
    break;
    #line 3214 
    case 33792: 
                #line 3214 
    ;
    #line 3215 
    printk((char *)"\001",devname,(int)reason);
    #line 3217 
    break;
    #line 3218 
    case 768: 
              #line 3218 
    ;
    #line 3219 
    printk((char *)"\001",devname,(int)reason);
    #line 3221 
    break;
    #line 3222 
    case 1024: 
               #line 3222 
    ;
    #line 3223 
    case 1536: 
               #line 3223 
    ;
    #line 3224 
    break;
    #line 3225 
    default: 
             #line 3225 
    ;
    #line 3226 
    printk((char *)"\001",devname,(int)status);
    #line 3227 
    break;
  }
  #line 3229 
  return;
}

#line 3231  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_handle_link(struct airo_info *ai)
{
  #line 3233 
  union iwreq_data wrqu;
  #line 3235 
  u16 status;
  #line 3234 
  int scan_forceloss = 0;
  #line 3238 
  status = IN4500(ai,(unsigned short)16);
  #line 3239 
  OUT4500(ai,(unsigned short)52,(unsigned short)128);
  #line 3241 
  if ((unsigned int)status == 32771U && ai->scan_timeout != 0UL) 
                                                                 #line 3242 
                                                                 scan_forceloss = 1;
  #line 3244 
  airo_print_status((char *)(& (ai->dev)->name),(unsigned short)((int)status));
  #line 3246 
  if ((unsigned int)status == 1024U || (unsigned int)status == 1536U) {
    #line 3247 
    if (auto_wep != 0) 
                       #line 3248 
                       ai->expires = 0UL;
    #line 3249 
    if (ai->list_bss_task != (struct task_struct *)0) 
                                                      #line 3250 
                                                      wake_up_process(ai->list_bss_task);
    #line 3251 
    cif_set_bit(6L,& ai->flags);
    #line 3252 
    cif_set_bit(5L,& ai->flags);
    #line 3254 
    if (down_trylock(& ai->sem) != 0) {
      #line 3255 
      cif_set_bit(6L,& ai->jobs);
      #line 3256 
      __wake_up(& ai->thr_wait,1U,1,(void *)0);
    }
    else 
         #line 3258 
         airo_send_event(ai->dev);
    #line 3259 
    netif_carrier_on(ai->dev);
  }
  else 
    #line 3260 
    if (scan_forceloss == 0) {
      #line 3261 
      if (auto_wep != 0 && ai->expires == 0UL) {
        #line 3262 
        ai->expires = jiffies + 750UL;
        #line 3263 
        __wake_up(& ai->thr_wait,1U,1,(void *)0);
      }
      #line 3267 
      eth_zero_addr((u8 *)(& wrqu.ap_addr.sa_data));
      #line 3268 
      wrqu.ap_addr.sa_family = (unsigned short)1U;
      #line 3269 
      wireless_send_event(ai->dev,35605U,& wrqu,(char *)0);
      #line 3270 
      netif_carrier_off(ai->dev);
    }
    else 
         #line 3272 
         netif_carrier_off(ai->dev);
  #line 3273 
  return;
}

#line 3276  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_handle_rx(struct airo_info *ai)
{
  #line 3279 
  __le16 fc;
  #line 3279 
  __le16 v;
  #line 3279 
  __le16 *buffer;
  #line 3279 
  __le16 tmpbuf[4U];
  #line 3280 
  u16 len;
  #line 3280 
  u16 gap;
  #line 3280 
  u16 fid;
  #line 3281 
  struct rx_hdr hdr;
  #line 3278 
  struct sk_buff *skb = (struct sk_buff *)0;
  #line 3280 
  u16 hdrlen = (unsigned short)0U;
  #line 3282 
  int success = 0;
  #line 3284 
  if ((int)test_bit(11L,& ai->flags) != 0) {
    #line 3285 
    if ((int)test_bit(7L,& ai->flags) != 0) 
                                            #line 3286 
                                            mpi_receive_802_11(ai); else 
                                                                    #line 3288 
                                                                    mpi_receive_802_3(ai);
    #line 3289 
    OUT4500(ai,(unsigned short)52,(unsigned short)1);
    #line 3290 
    return;
  }
  #line 3293 
  fid = IN4500(ai,(unsigned short)32);
  #line 3296 
  if ((int)test_bit(7L,& ai->flags) != 0) {
    #line 3297 
    bap_setup(ai,(unsigned short)((int)fid),(unsigned short)4,0);
    #line 3298 
    bap_read(ai,(__le16 *)(& hdr),16,0);
    #line 3300 
    if (((int)hdr.status & 2) != 0) 
                                    #line 3301 
                                    hdr.len = (unsigned short)0U;
    #line 3302 
    if (ai->wifidev == (struct net_device *)0) 
                                               #line 3303 
                                               hdr.len = (unsigned short)0U;
  }
  else {
    #line 3305 
    bap_setup(ai,(unsigned short)((int)fid),(unsigned short)54,0);
    #line 3306 
    bap_read(ai,& hdr.len,2,0);
  }
  #line 3308 
  len = hdr.len;
  #line 3310 
  if ((unsigned int)len > 2312U) {
    #line 3311 
    printk((char *)"\001",(char *)(& (ai->dev)->name),(int)len);
    #line 3312 
    goto done;
  }
  #line 3314 
  if ((unsigned int)len == 0U) 
                               #line 3315 
                               goto done;
  #line 3317 
  if ((int)test_bit(7L,& ai->flags) != 0) {
    #line 3318 
    bap_read(ai,& fc,2,0);
    #line 3319 
    hdrlen = (unsigned short)header_len((unsigned short)((int)fc));
  }
  else 
       #line 3321 
       hdrlen = (unsigned short)12U;
  #line 3323 
  skb = dev_alloc_skb((unsigned int)(((int)len + (int)hdrlen) + 4));
  #line 3324 
  if (skb == (struct sk_buff *)0) {
    #line 3325 
    ((ai->dev)->stats.rx_dropped) ++;
    #line 3326 
    goto done;
  }
  #line 3329 
  skb_reserve(skb,2);
  #line 3330 
  buffer = (__le16 *)skb_put(skb,(unsigned int)((int)len + (int)hdrlen));
  #line 3331 
  if ((int)test_bit(7L,& ai->flags) != 0) {
    #line 3332 
    *buffer = fc;
    #line 3333 
    bap_read(ai,buffer + 1U,(int)hdrlen + -2,0);
    #line 3334 
    if ((unsigned int)hdrlen == 24U) 
                                     #line 3335 
                                     bap_read(ai,(__le16 *)(& tmpbuf),6,0);
    #line 3337 
    bap_read(ai,& v,2,0);
    #line 3338 
    gap = v;
    #line 3339 
    if ((unsigned int)gap != 0U) 
      #line 3340 
      if ((unsigned int)gap <= 8U) 
                                   #line 3341 
                                   bap_read(ai,(__le16 *)(& tmpbuf),(int)gap,0); else 
                                                                    #line 3343 
                                                                    printk((char *)"\001",(char *)(& (ai->dev)->name));
    #line 3347 
    bap_read(ai,buffer + (unsigned long)((unsigned int)hdrlen / 2U),(int)len,0);
  }
  else {
    #line 3349 
    MICBuffer micbuf;
    #line 3351 
    bap_read(ai,buffer,12,0);
    #line 3352 
    if ((unsigned int)ai->micstats.enabled != 0U) {
      #line 3353 
      bap_read(ai,(__le16 *)(& micbuf),18,0);
      #line 3354 
      if ((unsigned int)__builtin_bswap16((unsigned short)((int)micbuf.typelen)) > 1500U) 
        #line 3355 
        bap_setup(ai,(unsigned short)((int)fid),(unsigned short)68,0);
      else {
        #line 3357 
        if ((unsigned int)len <= 18U) {
          #line 3358 
          dev_kfree_skb_irq(skb);
          #line 3359 
          goto done;
        }
        #line 3362 
        len = (unsigned short)((unsigned int)len + 65518U);
        #line 3363 
        skb_trim(skb,(unsigned int)((int)len + (int)hdrlen));
      }
    }
    #line 3367 
    bap_read(ai,buffer + 6U,(int)len,0);
    #line 3368 
    if (decapsulate(ai,& micbuf,(etherHead *)buffer,
                    (unsigned short)((int)len)) != 0) 
      #line 3369 
      dev_kfree_skb_irq(skb); else 
                                   #line 3371 
                                   success = 1;
  }
  #line 3375 
  if (success != 0 && ai->spy_data.spy_number > 0) {
    #line 3376 
    char *sa;
    #line 3377 
    struct iw_quality wstats;
    #line 3380 
    if (test_bit(7L,& ai->flags)) 
                                  #line 3385 
                                  sa = (char *)buffer + 10U;
    else {
      #line 3381 
      sa = (char *)buffer + 6U;
      #line 3382 
      bap_setup(ai,(unsigned short)((int)fid),(unsigned short)8,0);
      #line 3383 
      bap_read(ai,(__le16 *)(& hdr.rssi),2,0);
    }
    #line 3386 
    wstats.qual = hdr.rssi[0];
    #line 3387 
    if (ai->rssi != (tdsRssiEntry *)0) 
                                       #line 3388 
                                       wstats.level = (unsigned char)(- ((int)(ai->rssi + (unsigned long)hdr.rssi[1])->rssidBm)); else 
                                                                    #line 3390 
                                                                    wstats.level = (unsigned char)(((int)hdr.rssi[1] + 321) / 2);
    #line 3391 
    wstats.noise = ai->wstats.qual.noise;
    #line 3392 
    wstats.updated = (unsigned char)11U;
    #line 3396 
    wireless_spy_update(ai->dev,(unsigned char *)sa,& wstats);
  }
  #line 3400 
  done: 
        #line 3400 
  ;
  #line 3401 
  OUT4500(ai,(unsigned short)52,(unsigned short)1);
  #line 3403 
  if (success != 0) {
    #line 3404 
    if ((int)test_bit(7L,& ai->flags) != 0) {
      #line 3405 
      skb_reset_mac_header(skb);
      #line 3406 
      skb->pkt_type = (unsigned char)3U;
      #line 3407 
      skb->__anonCompField_sk_buff_101.__anonCompField___anonunion_556_100.__anonCompField___anonstruct_557_99.dev = ai->wifidev;
      #line 3408 
      skb->protocol = (unsigned short)1024U;
    }
    else 
         #line 3410 
         skb->protocol = eth_type_trans(skb,ai->dev);
    #line 3411 
    skb->ip_summed = (unsigned char)0U;
    #line 3413 
    netif_rx(skb);
  }
  #line 3415 
  return;
}

#line 3417  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_handle_tx(struct airo_info *ai, u16 status)
{
  #line 3419 
  int i;
  #line 3420 
  u16 fid;
  #line 3419 
  int index = -1;
  #line 3422 
  if ((int)test_bit(11L,& ai->flags) != 0) {
    #line 3423 
    unsigned long flags;
    #line 3425 
    if (((int)status & 4) != 0) 
                                #line 3426 
                                get_tx_error(ai,-1);
    #line 3428 
    cif___ldv_spin_lock_aux_lock_of_airo_info(& ai->aux_lock);
    #line 3429 
    if (skb_queue_empty(& ai->txq) == 0) {
      #line 3430 
      cif_spin_unlock_irqrestore_aux_lock_of_airo_info(& ai->aux_lock,flags);
      #line 3431 
      mpi_send_packet(ai->dev);
    }
    else {
      #line 3433 
      cif_clear_bit(9L,& ai->flags);
      #line 3434 
      cif_spin_unlock_irqrestore_aux_lock_of_airo_info(& ai->aux_lock,flags);
      #line 3435 
      netif_wake_queue(ai->dev);
    }
    #line 3437 
    OUT4500(ai,(unsigned short)52,(unsigned short)((int)status & 1030));
    #line 3438 
    return;
  }
  #line 3441 
  fid = IN4500(ai,(unsigned short)36);
  #line 3443 
  i = 0;
  #line 3443 
  while (i <= 5) {
    #line 3444 
    if ((ai->fids[i] & 65535U) == (unsigned int)fid) 
                                                     #line 3445 
                                                     index = i;
    #line 3443 
    i ++;
  }
  #line 3448 
  if (index != -1) {
    #line 3449 
    if (((int)status & 4) != 0) 
                                #line 3450 
                                get_tx_error(ai,index);
    #line 3452 
    OUT4500(ai,(unsigned short)52,(unsigned short)((int)status & 6));
    #line 3455 
    ai->fids[index] &= 65535U;
    #line 3456 
    if (index <= 2) {
      #line 3457 
      if (! test_bit(9L,& ai->flags)) 
                                      #line 3458 
                                      netif_wake_queue(ai->dev);
    }
    else {
      #line 3460 
      if (! test_bit(10L,& ai->flags)) 
                                       #line 3461 
                                       netif_wake_queue(ai->wifidev);
    }
  }
  else {
    #line 3464 
    OUT4500(ai,(unsigned short)52,(unsigned short)((int)status & 1030));
    #line 3465 
    printk((char *)"\001",(char *)(& (ai->dev)->name));
  }
  #line 3467 
  return;
}

#line 3469  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static irqreturn_t airo_interrupt(int irq_0, void *dev_id)
{
  #line 3472 
  u16 status;
  #line 3471 
  struct net_device *dev = (struct net_device *)dev_id;
  #line 3472 
  u16 savedInterrupts = (unsigned short)0U;
  #line 3473 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 3474 
  int handled = 0;
  #line 3476 
  if (! netif_device_present(dev)) 
                                   #line 3477 
                                   return IRQ_NONE;
  #line 3479 
  while (1) {
    #line 3480 
    status = IN4500(ai,(unsigned short)48);
    #line 3481 
    if (((int)status & 5511) == 0 || (unsigned int)status == 65535U) 
      #line 3482 
      break;
    #line 3484 
    handled = 1;
    #line 3486 
    if (((int)status & 256) != 0) {
      #line 3487 
      OUT4500(ai,(unsigned short)52,(unsigned short)256);
      #line 3488 
      OUT4500(ai,(unsigned short)52,(unsigned short)256);
    }
    #line 3491 
    if ((unsigned int)savedInterrupts == 0U) {
      #line 3492 
      savedInterrupts = IN4500(ai,(unsigned short)50);
      #line 3493 
      OUT4500(ai,(unsigned short)50,(unsigned short)0);
    }
    #line 3496 
    if (((int)status & 4096) != 0) {
      #line 3497 
      OUT4500(ai,(unsigned short)52,(unsigned short)4096);
      #line 3498 
      airo_handle_cisco_mic(ai);
    }
    #line 3501 
    if (((int)status & 128) != 0) 
                                  #line 3503 
                                  airo_handle_link(ai);
    #line 3507 
    if (((int)status & 1) != 0) 
                                #line 3508 
                                airo_handle_rx(ai);
    #line 3511 
    if (((int)status & 1030) != 0) 
                                   #line 3512 
                                   airo_handle_tx(ai,(unsigned short)((int)status));
  }
  #line 3520 
  if ((unsigned int)savedInterrupts != 0U) 
                                           #line 3521 
                                           OUT4500(ai,(unsigned short)50,(unsigned short)((int)savedInterrupts));
  #line 3523 
  return (enum irqreturn)(handled != 0);
}

#line 3535  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void OUT4500(struct airo_info *ai, u16 reg, u16 val)
{
  #line 3536 
  if ((int)test_bit(11L,& ai->flags) != 0) 
                                           #line 3537 
                                           reg = (unsigned short)((int)reg << 1U);
  #line 3538 
  if (do8bitIO == 0) 
                     #line 3539 
                     outw((unsigned short)((int)val),(int)((ai->dev)->base_addr + (unsigned long)reg));
  else {
    #line 3541 
    outb((unsigned char)((int)((unsigned char)val)),(int)((ai->dev)->base_addr + (unsigned long)reg));
    #line 3542 
    outb((unsigned char)((int)((unsigned char)((int)val >> 8))),(int)(((ai->dev)->base_addr + (unsigned long)reg) + (unsigned long)1U));
  }
  #line 3544 
  return;
}

#line 3546  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static unsigned short IN4500(struct airo_info *ai, u16 reg)
{
  #line 3547 
  unsigned short rc;
  #line 3549 
  if ((int)test_bit(11L,& ai->flags) != 0) 
                                           #line 3550 
                                           reg = (unsigned short)((int)reg << 1U);
  #line 3551 
  if (do8bitIO == 0) 
                     #line 3552 
                     rc = inw((int)((ai->dev)->base_addr + (unsigned long)reg));
  else {
    #line 3554 
    rc = (unsigned short)inb((int)((ai->dev)->base_addr + (unsigned long)reg));
    #line 3555 
    rc = (unsigned short)((int)((unsigned short)((int)inb((int)(((ai->dev)->base_addr + (unsigned long)reg) + (unsigned long)1U)) << 8)) + (int)rc);
  }
  #line 3557 
  return rc;
}

#line 3560  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int enable_MAC(struct airo_info *ai, int lock)
{
  #line 3562 
  int rc;
  #line 3563 
  Cmd cmd;
  #line 3564 
  Resp rsp;
  #line 3572 
  if ((ai->flags & 3UL) != 0UL) 
                                #line 3572 
                                return 0;
  #line 3574 
  if (lock != 0) {
    #line 3574 
    if (down_interruptible(& ai->sem) != 0) 
                                            #line 3575 
                                            return -512;
  }
  #line 3577 
  if (test_bit(2L,& ai->flags)) 
                                #line 3584 
                                rc = 0;
  else {
    #line 3578 
    memset((void *)(& cmd),0,8UL);
    #line 3579 
    cmd.cmd = (unsigned short)1U;
    #line 3580 
    rc = (int)issuecommand(ai,& cmd,& rsp);
    #line 3581 
    if (rc == 0) 
                 #line 3582 
                 cif_set_bit(2L,& ai->flags);
  }
  #line 3586 
  if (lock != 0) 
                 #line 3587 
                 up(& ai->sem);
  #line 3589 
  if (rc != 0) 
               #line 3590 
               printk((char *)"\001",(char *)(& (ai->dev)->name));
  else 
    #line 3591 
    if (((int)rsp.status & 65280) != 0) {
      #line 3592 
      printk((char *)"\001",(char *)(& (ai->dev)->name),(int)rsp.rsp0,(int)rsp.rsp1,(int)rsp.rsp2);
      #line 3594 
      rc = -1;
    }
  #line 3596 
  return rc;
}

#line 3599  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void disable_MAC(struct airo_info *ai, int lock)
{
  #line 3600 
  Cmd cmd;
  #line 3601 
  Resp rsp;
  #line 3603 
  if (lock == 1) {
    #line 3603 
    if (down_interruptible(& ai->sem) != 0) 
                                            #line 3604 
                                            return;
  }
  #line 3606 
  if ((int)test_bit(2L,& ai->flags) != 0) {
    #line 3607 
    if (lock != 2) 
                   #line 3608 
                   netif_carrier_off(ai->dev);
    #line 3609 
    memset((void *)(& cmd),0,8UL);
    #line 3610 
    cmd.cmd = (unsigned short)2U;
    #line 3611 
    issuecommand(ai,& cmd,& rsp);
    #line 3612 
    cif_clear_bit(2L,& ai->flags);
  }
  #line 3614 
  if (lock == 1) 
                 #line 3615 
                 up(& ai->sem);
  #line 3616 
  return;
}

#line 3618  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void enable_interrupts(struct airo_info *ai)
{
  #line 3620 
  OUT4500(ai,(unsigned short)50,(unsigned short)5511);
  #line 3621 
  return;
}

#line 3623  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void disable_interrupts(struct airo_info *ai)
{
  #line 3624 
  OUT4500(ai,(unsigned short)50,(unsigned short)0);
  #line 3625 
  return;
}

#line 3627  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void mpi_receive_802_3(struct airo_info *ai)
{
  #line 3629 
  RxFid rxd;
  #line 3631 
  struct sk_buff *skb;
  #line 3632 
  char *buffer;
  #line 3634 
  MICBuffer micbuf;
  #line 3630 
  int len = 0;
  #line 3633 
  int off = 0;
  #line 3636 
  memcpy_fromio((void *)(& rxd),(void *)ai->rxfids[0].card_ram_off,16UL);
  #line 3638 
  if ((unsigned int)rxd.rdy != 0U && (unsigned int)rxd.valid == 0U) {
    #line 3639 
    len = (int)rxd.len + 12;
    #line 3640 
    if ((unsigned int)len + 4294967284U > 2036U) 
                                                 #line 3641 
                                                 goto badrx;
    #line 3643 
    skb = dev_alloc_skb((unsigned int)len);
    #line 3644 
    if (skb == (struct sk_buff *)0) {
      #line 3645 
      ((ai->dev)->stats.rx_dropped) ++;
      #line 3646 
      goto badrx;
    }
    #line 3648 
    buffer = (char *)skb_put(skb,(unsigned int)len);
    #line 3649 
    memcpy((void *)buffer,(void *)ai->rxfids[0].virtual_host_addr,12UL);
    #line 3650 
    if ((unsigned int)ai->micstats.enabled != 0U) {
      #line 3651 
      memcpy((void *)(& micbuf),(void *)(ai->rxfids[0].virtual_host_addr + 12U),18UL);
      #line 3654 
      if ((unsigned int)__builtin_bswap16((unsigned short)((int)micbuf.typelen)) <= 1500U) {
        #line 3655 
        if ((unsigned int)len <= 30U) 
                                      #line 3656 
                                      goto badmic;
        #line 3658 
        off = 18;
        #line 3659 
        skb_trim(skb,(unsigned int)(len - off));
      }
    }
    #line 3662 
    memcpy((void *)(buffer + 12U),(void *)(ai->rxfids[0].virtual_host_addr + ((unsigned long)off + (unsigned long)12U)),(unsigned long)((len + -12) - off));
    #line 3665 
    if (decapsulate(ai,& micbuf,(etherHead *)buffer,
                    (unsigned short)((int)((unsigned int)((int)((unsigned short)len) - (int)((unsigned short)off)) + 65524U))) != 0) {
      #line 3666 
      badmic: 
              #line 3666 
      ;
      #line 3667 
      dev_kfree_skb_irq(skb);
      #line 3668 
      goto badrx;
    }
    #line 3671 
    if (ai->spy_data.spy_number > 0) {
      #line 3672 
      char *sa;
      #line 3673 
      struct iw_quality wstats;
      #line 3675 
      sa = buffer + 6U;
      #line 3676 
      wstats.qual = (unsigned char)0U;
      #line 3677 
      wstats.level = (unsigned char)0U;
      #line 3678 
      wstats.updated = (unsigned char)0U;
      #line 3680 
      wireless_spy_update(ai->dev,(unsigned char *)sa,& wstats);
    }
    #line 3684 
    skb->ip_summed = (unsigned char)0U;
    #line 3685 
    skb->protocol = eth_type_trans(skb,ai->dev);
    #line 3686 
    netif_rx(skb);
  }
  #line 3688 
  badrx: 
         #line 3688 
  ;
  #line 3689 
  if ((unsigned int)rxd.valid == 0U) {
    #line 3690 
    rxd.valid = (unsigned int)1U;
    #line 3691 
    rxd.rdy = (unsigned int)0U;
    #line 3692 
    rxd.len = (unsigned int)1840U;
    #line 3693 
    memcpy_toio((void *)ai->rxfids[0].card_ram_off,(void *)(& rxd),16UL);
  }
  #line 3695 
  return;
}

#line 3697  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void mpi_receive_802_11(struct airo_info *ai)
{
  #line 3699 
  RxFid rxd;
  #line 3701 
  u16 len;
  #line 3702 
  __le16 fc;
  #line 3703 
  struct rx_hdr hdr;
  #line 3704 
  u16 gap;
  #line 3705 
  u16 *buffer;
  #line 3700 
  struct sk_buff *skb = (struct sk_buff *)0;
  #line 3701 
  u16 hdrlen = (unsigned short)0U;
  #line 3706 
  char *ptr = ai->rxfids[0].virtual_host_addr + 4U;
  #line 3708 
  memcpy_fromio((void *)(& rxd),(void *)ai->rxfids[0].card_ram_off,16UL);
  #line 3709 
  memcpy((void *)(& hdr),(void *)ptr,16UL);
  #line 3710 
  ptr += 16UL;
  #line 3712 
  if (((int)hdr.status & 2) != 0) 
                                  #line 3713 
                                  hdr.len = (unsigned short)0U;
  #line 3714 
  if (ai->wifidev == (struct net_device *)0) 
                                             #line 3715 
                                             hdr.len = (unsigned short)0U;
  #line 3716 
  len = hdr.len;
  #line 3717 
  if ((unsigned int)len > 2312U) {
    #line 3718 
    printk((char *)"\001",(char *)(& (ai->dev)->name),(int)len);
    #line 3719 
    goto badrx;
  }
  #line 3721 
  if ((unsigned int)len == 0U) 
                               #line 3722 
                               goto badrx;
  #line 3724 
  fc = get_unaligned_le16((void *)ptr);
  #line 3725 
  hdrlen = (unsigned short)header_len((unsigned short)((int)fc));
  #line 3727 
  skb = dev_alloc_skb((unsigned int)(((int)len + (int)hdrlen) + 2));
  #line 3728 
  if (skb == (struct sk_buff *)0) {
    #line 3729 
    ((ai->dev)->stats.rx_dropped) ++;
    #line 3730 
    goto badrx;
  }
  #line 3732 
  buffer = (u16 *)skb_put(skb,(unsigned int)((int)len + (int)hdrlen));
  #line 3733 
  memcpy((void *)buffer,(void *)ptr,(unsigned long)hdrlen);
  #line 3734 
  ptr += (unsigned long)hdrlen;
  #line 3735 
  if ((unsigned int)hdrlen == 24U) 
                                   #line 3736 
                                   ptr += 6U;
  #line 3737 
  gap = get_unaligned_le16((void *)ptr);
  #line 3738 
  ptr += 2UL;
  #line 3739 
  if ((unsigned int)gap != 0U) 
    #line 3740 
    if ((unsigned int)gap <= 8U) 
                                 #line 3741 
                                 ptr += (unsigned long)gap; else 
                                                                 #line 3743 
                                                                 printk((char *)"\001",(char *)(& (ai->dev)->name));
  #line 3746 
  memcpy((void *)((char *)buffer + (unsigned long)hdrlen),(void *)ptr,(unsigned long)len);
  #line 3747 
  ptr += (unsigned long)len;
  #line 3749 
  if (ai->spy_data.spy_number > 0) {
    #line 3750 
    char *sa;
    #line 3751 
    struct iw_quality wstats;
    #line 3753 
    sa = (char *)buffer + 10U;
    #line 3754 
    wstats.qual = hdr.rssi[0];
    #line 3755 
    if (ai->rssi != (tdsRssiEntry *)0) 
                                       #line 3756 
                                       wstats.level = (unsigned char)(- ((int)(ai->rssi + (unsigned long)hdr.rssi[1])->rssidBm)); else 
                                                                    #line 3758 
                                                                    wstats.level = (unsigned char)(((int)hdr.rssi[1] + 321) / 2);
    #line 3759 
    wstats.noise = ai->wstats.qual.noise;
    #line 3760 
    wstats.updated = (unsigned char)11U;
    #line 3764 
    wireless_spy_update(ai->dev,(unsigned char *)sa,& wstats);
  }
  #line 3767 
  skb_reset_mac_header(skb);
  #line 3768 
  skb->pkt_type = (unsigned char)3U;
  #line 3769 
  skb->__anonCompField_sk_buff_101.__anonCompField___anonunion_556_100.__anonCompField___anonstruct_557_99.dev = ai->wifidev;
  #line 3770 
  skb->protocol = (unsigned short)1024U;
  #line 3771 
  skb->ip_summed = (unsigned char)0U;
  #line 3772 
  netif_rx(skb);
  #line 3774 
  badrx: 
         #line 3774 
  ;
  #line 3775 
  if ((unsigned int)rxd.valid == 0U) {
    #line 3776 
    rxd.valid = (unsigned int)1U;
    #line 3777 
    rxd.rdy = (unsigned int)0U;
    #line 3778 
    rxd.len = (unsigned int)1840U;
    #line 3779 
    memcpy_toio((void *)ai->rxfids[0].card_ram_off,(void *)(& rxd),16UL);
  }
  #line 3781 
  return;
}

#line 3783  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
__inline static void set_auth_type(struct airo_info *local, int auth_type)
{
  #line 3785 
  local->config.authType = (unsigned short)auth_type;
  #line 3789 
  if (auth_type == 1 || auth_type == 257) 
                                          #line 3790 
                                          local->last_auth = auth_type;
  #line 3791 
  return;
}

#line 3793  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static u16 setup_card(struct airo_info *ai, u8 *mac, int lock)
{
  #line 3795 
  Cmd cmd;
  #line 3796 
  Resp rsp;
  #line 3797 
  int status;
  #line 3798 
  SsidRid mySsid;
  #line 3799 
  __le16 lastindex;
  #line 3800 
  WepKeyRid wkr;
  #line 3801 
  int rc;
  #line 3803 
  memset((void *)(& mySsid),0,104UL);
  #line 3804 
  kfree((void *)ai->flash);
  #line 3805 
  ai->flash = (unsigned short *)0U;
  #line 3808 
  cmd.cmd = (unsigned short)16U;
  #line 3809 
  cmd.parm2 = (unsigned short)0U;
  #line 3809 
  cmd.parm1 = cmd.parm2;
  #line 3809 
  cmd.parm0 = cmd.parm1;
  #line 3810 
  if (lock != 0) {
    #line 3810 
    if (down_interruptible(& ai->sem) != 0) 
                                            #line 3811 
                                            return (unsigned short)65535U;
  }
  #line 3812 
  if ((unsigned int)issuecommand(ai,& cmd,& rsp) != 0U) {
    #line 3813 
    if (lock != 0) 
                   #line 3814 
                   up(& ai->sem);
    #line 3815 
    return (unsigned short)65535U;
  }
  #line 3817 
  disable_MAC(ai,0);
  #line 3820 
  if (! test_bit(11L,& ai->flags)) {
    #line 3821 
    cmd.cmd = (unsigned short)273U;
    #line 3822 
    if ((unsigned int)issuecommand(ai,& cmd,& rsp) != 0U) {
      #line 3823 
      if (lock != 0) 
                     #line 3824 
                     up(& ai->sem);
      #line 3825 
      printk((char *)"\001",(char *)(& (ai->dev)->name));
      #line 3826 
      return (unsigned short)65535U;
    }
    #line 3828 
    if (aux_bap == 0 || ((int)rsp.status & 65280) != 0) {
      #line 3829 
      ai->bap_read = & fast_bap_read;
      #line 3830 
      printk((char *)"\001",(char *)(& (ai->dev)->name));
    }
    else {
      #line 3832 
      ai->bap_read = & aux_bap_read;
      #line 3833 
      printk((char *)"\001",(char *)(& (ai->dev)->name));
    }
  }
  #line 3836 
  if (lock != 0) 
                 #line 3837 
                 up(& ai->sem);
  #line 3838 
  if ((unsigned int)ai->config.len == 0U) {
    #line 3839 
    int i;
    #line 3840 
    tdsRssiRid rssi_rid;
    #line 3841 
    CapabilityRid cap_rid;
    #line 3843 
    kfree((void *)ai->SSID);
    #line 3844 
    ai->SSID = (SsidRid *)0;
    #line 3846 
    status = readConfigRid(ai,lock);
    #line 3847 
    if (status != 0) 
                     #line 3847 
                     return (unsigned short)65535U;
    #line 3849 
    status = readCapabilityRid(ai,& cap_rid,lock);
    #line 3850 
    if (status != 0) 
                     #line 3850 
                     return (unsigned short)65535U;
    #line 3852 
    status = PC4500_readrid(ai,(unsigned short)65284,(void *)(& rssi_rid),514,lock);
    #line 3853 
    if (status == 0) 
      #line 3854 
      if (ai->rssi != (tdsRssiEntry *)0) 
                                         #line 3855 
                                         memcpy((void *)ai->rssi,(void *)((u8 *)(& rssi_rid) + 2U),512UL);
      else {
        #line 3854 
        ai->rssi = (tdsRssiEntry *)kmalloc(512UL,3264U);
        #line 3854 
        if ((tdsRssiEntry *)kmalloc(512UL,3264U) != (tdsRssiEntry *)0) 
          #line 3855 
          memcpy((void *)ai->rssi,(void *)((u8 *)(& rssi_rid) + 2U),512UL);
      }
    else {
      #line 3858 
      kfree((void *)ai->rssi);
      #line 3859 
      ai->rssi = (tdsRssiEntry *)0;
      #line 3860 
      if (((int)cap_rid.softCap & 8) != 0) 
                                           #line 3861 
                                           ai->config.rmode = (unsigned short)((unsigned int)ai->config.rmode | 512U); else 
                                                                    #line 3863 
                                                                    printk((char *)"\001",(char *)(& (ai->dev)->name));
    }
    #line 3866 
    ai->config.opmode = (unsigned short)(adhoc == 0);
    #line 3867 
    set_auth_type(ai,1);
    #line 3868 
    ai->config.modulation = (unsigned short)1U;
    #line 3870 
    if ((unsigned int)cap_rid.len > 131U && ((int)cap_rid.extSoftCap & 1) != 0) {
      #line 3871 
      if (micsetup(ai) == 0) {
        #line 3873 
        ai->config.opmode = (unsigned short)((unsigned int)ai->config.opmode | 32768U);
        #line 3874 
        cif_set_bit(4L,& ai->flags);
      }
    }
    #line 3878 
    i = 0;
    #line 3878 
    while (i <= 5) {
      #line 3879 
      *(mac + (unsigned long)i) = ai->config.macAddr[i];
      #line 3878 
      i ++;
    }
    #line 3884 
    if (rates[0] != 0) {
      #line 3885 
      memset((void *)(& ai->config.rates),0,8UL);
      #line 3886 
      i = 0;
      #line 3886 
      while (i <= 7 && rates[i] != 0) {
        #line 3887 
        ai->config.rates[i] = (unsigned char)rates[i];
        #line 3886 
        i ++;
      }
    }
    #line 3890 
    cif_set_bit(13L,& ai->flags);
  }
  #line 3894 
  if (ssids[0] != (char *)0) {
    #line 3895 
    int i_0;
    #line 3896 
    i_0 = 0;
    #line 3896 
    while (i_0 <= 2 && ssids[i_0] != (char *)0) {
      {
        #line 3897 
        size_t len = cif_strlen(ssids[i_0]);
        #line 3898 
        if (len > 32UL) 
                        #line 3899 
                        len = 32UL;
        #line 3900 
        mySsid.ssids[i_0].len = (unsigned short)len;
        #line 3901 
        memcpy((void *)(& mySsid.ssids[i_0].ssid),(void *)ssids[i_0],len);
      }
      #line 3896 
      i_0 ++;
    }
    #line 3903 
    mySsid.len = (unsigned short)104U;
  }
  #line 3906 
  status = writeConfigRid(ai,lock);
  #line 3907 
  if (status != 0) 
                   #line 3907 
                   return (unsigned short)65535U;
  #line 3910 
  if (ssids[0] != (char *)0) {
    #line 3911 
    status = writeSsidRid(ai,& mySsid,lock);
    #line 3912 
    if (status != 0) 
                     #line 3912 
                     return (unsigned short)65535U;
  }
  #line 3915 
  status = enable_MAC(ai,lock);
  #line 3916 
  if (status != 0) 
                   #line 3917 
                   return (unsigned short)65535U;
  #line 3920 
  rc = readWepKeyRid(ai,& wkr,1,lock);
  #line 3921 
  if (rc == 0) 
    #line 3921 
    while (1) {
      #line 3922 
      lastindex = wkr.kindex;
      #line 3923 
      if ((unsigned int)wkr.kindex == 65535U) 
                                              #line 3924 
                                              ai->defindex = (char)wkr.mac[0];
      #line 3926 
      rc = readWepKeyRid(ai,& wkr,0,lock);
      #line 3927 
      if (! ((int)wkr.kindex != (int)lastindex)) 
                                                 #line 3921 
                                                 break;
    }
  #line 3929 
  try_auto_wep(ai);
  #line 3931 
  return (unsigned short)0U;
}

#line 3934  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static u16 issuecommand(struct airo_info *ai, Cmd *pCmd, Resp *pRsp)
{
  #line 3936 
  int max_tries = 600000;
  #line 3938 
  if (((int)IN4500(ai,(unsigned short)48) & 16) != 0) 
                                                      #line 3939 
                                                      OUT4500(ai,(unsigned short)52,(unsigned short)16);
  #line 3941 
  OUT4500(ai,(unsigned short)2,(unsigned short)((int)pCmd->parm0));
  #line 3942 
  OUT4500(ai,(unsigned short)4,(unsigned short)((int)pCmd->parm1));
  #line 3943 
  OUT4500(ai,(unsigned short)6,(unsigned short)((int)pCmd->parm2));
  #line 3944 
  OUT4500(ai,(unsigned short)0,(unsigned short)((int)pCmd->cmd));
  #line 3946 
  while (1) {
    #line 3946 
    int tmp_2;
    #line 3946 
    tmp_2 = max_tries;
    #line 3946 
    max_tries --;
    #line 3946 
    ;
    #line 3946 
    if (tmp_2 != 0) {
      #line 3946 
      if (! (((int)IN4500(ai,(unsigned short)48) & 16) == 0)) 
                                                              #line 3946 
                                                              break;
    }
    else 
         #line 3946 
         break;
    {
      #line 3947 
      ;
      #line 3947 
      if ((int)IN4500(ai,(unsigned short)0) == (int)pCmd->cmd) 
                                                               #line 3949 
                                                               OUT4500(ai,(unsigned short)0,(unsigned short)((int)pCmd->cmd));
      #line 3950 
      if (preempt_count() == 0) 
        #line 3950 
        if ((max_tries & 255) == 0) 
                                    #line 3951 
                                    schedule();
    }
  }
  #line 3954 
  if (max_tries == -1) {
    #line 3955 
    printk((char *)"\001",(char *)(& (ai->dev)->name));
    #line 3957 
    if (((int)IN4500(ai,(unsigned short)0) & 32768) != 0) 
                                                          #line 3958 
                                                          OUT4500(ai,(unsigned short)52,(unsigned short)16384);
    #line 3959 
    return (unsigned short)65535U;
  }
  #line 3963 
  pRsp->status = IN4500(ai,(unsigned short)8);
  #line 3964 
  pRsp->rsp0 = IN4500(ai,(unsigned short)10);
  #line 3965 
  pRsp->rsp1 = IN4500(ai,(unsigned short)12);
  #line 3966 
  pRsp->rsp2 = IN4500(ai,(unsigned short)14);
  #line 3967 
  if (((int)pRsp->status & 65280) != 0 && (unsigned int)pCmd->cmd != 4U) 
    #line 3968 
    printk((char *)"\001",(char *)(& (ai->dev)->name),(int)pCmd->cmd,(int)pRsp->status,(int)pRsp->rsp0,(int)pRsp->rsp1,(int)pRsp->rsp2);
  #line 3974 
  if (((int)IN4500(ai,(unsigned short)0) & 32768) != 0) 
                                                        #line 3975 
                                                        OUT4500(ai,(unsigned short)52,(unsigned short)16384);
  #line 3978 
  OUT4500(ai,(unsigned short)52,(unsigned short)16);
  #line 3980 
  return (unsigned short)0U;
}

#line 3986  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int bap_setup(struct airo_info *ai, u16 rid, u16 offset, int whichbap)
{
  #line 3988 
  int timeout = 50;
  #line 3989 
  int max_tries = 3;
  #line 3991 
  OUT4500(ai,(unsigned short)((int)((unsigned int)((unsigned short)whichbap) + 24U)),(unsigned short)((int)rid));
  #line 3992 
  OUT4500(ai,(unsigned short)((int)((unsigned int)((unsigned short)whichbap) + 28U)),(unsigned short)((int)offset));
  #line 3993 
  while (1) {
    {
      #line 4009 
      int tmp_1;
      #line 3994 
      int status = (int)IN4500(ai,
             (unsigned short)((int)((unsigned int)((unsigned short)whichbap) + 28U)));
      #line 3995 
      if ((status & 32768) != 0) {
        #line 3998 
        int tmp_0;
        #line 3998 
        tmp_0 = timeout;
        #line 3998 
        timeout --;
        #line 3998 
        ;
        #line 3998 
        if (tmp_0 != 0) 
                        #line 3999 
                        continue;
      }
      else 
        #line 4001 
        if ((status & 16384) != 0) {
          #line 4003 
          printk((char *)"\001",(char *)(& (ai->dev)->name),status,whichbap);
          #line 4005 
          return -1;
        }
        else 
          #line 4006 
          if ((status & 8192) != 0) 
                                    #line 4007 
                                    return 0;
      #line 4009 
      tmp_1 = max_tries;
      #line 4009 
      max_tries --;
      #line 4009 
      ;
      #line 4009 
      if (tmp_1 == 0) {
        #line 4010 
        printk((char *)"\001",(char *)(& (ai->dev)->name));
        #line 4012 
        return -1;
      }
      #line 4015 
      OUT4500(ai,(unsigned short)((int)((unsigned int)((unsigned short)whichbap) + 24U)),(unsigned short)((int)rid));
      #line 4016 
      OUT4500(ai,(unsigned short)((int)((unsigned int)((unsigned short)whichbap) + 28U)),(unsigned short)((int)offset));
      #line 4017 
      timeout = 50;
    }
  }
}

#line 4024  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static u16 aux_setup(struct airo_info *ai, u16 page, u16 offset, u16 *len)
{
  #line 4027 
  u16 next;
  #line 4029 
  OUT4500(ai,(unsigned short)58,(unsigned short)((int)page));
  #line 4030 
  OUT4500(ai,(unsigned short)60,(unsigned short)0);
  #line 4031 
  next = IN4500(ai,(unsigned short)62);
  #line 4032 
  *len = (unsigned short)((unsigned int)IN4500(ai,(unsigned short)62) & 255U);
  #line 4033 
  if ((unsigned int)offset != 4U) 
                                  #line 4033 
                                  OUT4500(ai,(unsigned short)60,(unsigned short)((int)offset));
  #line 4034 
  return next;
}

#line 4038  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int aux_bap_read(struct airo_info *ai, __le16 *pu16Dst, int bytelen, int whichbap)
{
  #line 4041 
  u16 len;
  #line 4042 
  u16 page;
  #line 4043 
  u16 offset;
  #line 4044 
  u16 next;
  #line 4045 
  int words;
  #line 4046 
  int i;
  #line 4047 
  unsigned long flags;
  #line 4049 
  cif___ldv_spin_lock_aux_lock_of_airo_info(& ai->aux_lock);
  #line 4050 
  page = IN4500(ai,(unsigned short)((int)((unsigned int)((unsigned short)whichbap) + 40U)));
  #line 4051 
  offset = IN4500(ai,(unsigned short)((int)((unsigned int)((unsigned short)whichbap) + 44U)));
  #line 4052 
  next = aux_setup(ai,(unsigned short)((int)page),(unsigned short)((int)offset),& len);
  #line 4053 
  words = (bytelen + 1) >> 1;
  #line 4055 
  i = 0;
  #line 4055 
  while (i < words) {
    #line 4056 
    int count;
    #line 4057 
    if ((int)len >> 1 < words - i) 
                                   #line 4057 
                                   count = (int)len >> 1; else 
                                                               #line 4057 
                                                               count = words - i;
    #line 4058 
    if (do8bitIO == 0) 
                       #line 4059 
                       insw((int)(((ai->dev)->base_addr + (unsigned long)whichbap) + (unsigned long)54U),(void *)(pu16Dst + (unsigned long)i),(unsigned long)count); else 
                                                                    #line 4062 
                                                                    insb((int)(((ai->dev)->base_addr + (unsigned long)whichbap) + (unsigned long)54U),(void *)(pu16Dst + (unsigned long)i),(unsigned long)(count << 1));
    #line 4064 
    i += count;
    #line 4065 
    if (i < words) 
                   #line 4066 
                   next = aux_setup(ai,(unsigned short)((int)next),(unsigned short)4,& len);
  }
  #line 4069 
  cif_spin_unlock_irqrestore_aux_lock_of_airo_info(& ai->aux_lock,flags);
  #line 4070 
  return 0;
}

#line 4075  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int fast_bap_read(struct airo_info *ai, __le16 *pu16Dst, int bytelen, int whichbap)
{
  #line 4078 
  bytelen = (bytelen + 1) & -2;
  #line 4079 
  if (do8bitIO == 0) 
                     #line 4080 
                     insw((int)(((ai->dev)->base_addr + (unsigned long)whichbap) + (unsigned long)54U),(void *)pu16Dst,(unsigned long)(bytelen >> 1)); else 
                                                                    #line 4082 
                                                                    insb((int)(((ai->dev)->base_addr + (unsigned long)whichbap) + (unsigned long)54U),(void *)pu16Dst,(unsigned long)bytelen);
  #line 4083 
  return 0;
}

#line 4087  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int bap_write(struct airo_info *ai, __le16 *pu16Src, int bytelen, int whichbap)
{
  #line 4090 
  bytelen = (bytelen + 1) & -2;
  #line 4091 
  if (do8bitIO == 0) 
                     #line 4092 
                     outsw((int)(((ai->dev)->base_addr + (unsigned long)whichbap) + (unsigned long)54U),(void *)pu16Src,(unsigned long)(bytelen >> 1)); else 
                                                                    #line 4095 
                                                                    outsb((int)(((ai->dev)->base_addr + (unsigned long)whichbap) + (unsigned long)54U),(void *)pu16Src,(unsigned long)bytelen);
  #line 4096 
  return 0;
}

#line 4099  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int PC4500_accessrid(struct airo_info *ai, u16 rid, u16 accmd)
{
  #line 4101 
  Cmd cmd;
  #line 4102 
  Resp rsp;
  #line 4103 
  u16 status;
  #line 4105 
  memset((void *)(& cmd),0,8UL);
  #line 4106 
  cmd.cmd = accmd;
  #line 4107 
  cmd.parm0 = rid;
  #line 4108 
  status = issuecommand(ai,& cmd,& rsp);
  #line 4109 
  if ((unsigned int)status != 0U) 
                                  #line 4109 
                                  return (int)status;
  #line 4110 
  if (((int)rsp.status & 32512) != 0) 
                                      #line 4111 
                                      return ((int)accmd << 8) + ((int)rsp.rsp0 & 255);
  #line 4113 
  return 0;
}

#line 4118  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int PC4500_readrid(struct airo_info *ai, u16 rid, void *pBuf, int len, int lock)
{
  #line 4120 
  u16 status;
  #line 4121 
  int rc = 0;
  #line 4123 
  if (lock != 0) {
    #line 4124 
    if (down_interruptible(& ai->sem) != 0) 
                                            #line 4125 
                                            return -1;
  }
  #line 4127 
  if ((int)test_bit(11L,& ai->flags) != 0) {
    #line 4128 
    Cmd cmd;
    #line 4129 
    Resp rsp;
    #line 4131 
    memset((void *)(& cmd),0,8UL);
    #line 4132 
    memset((void *)(& rsp),0,8UL);
    #line 4133 
    ai->config_desc.rid_desc.valid = (unsigned int)1U;
    #line 4134 
    ai->config_desc.rid_desc.len = (unsigned int)2048U;
    #line 4135 
    ai->config_desc.rid_desc.rid = (unsigned int)0U;
    #line 4136 
    ai->config_desc.rid_desc.host_addr = (unsigned long long)ai->ridbus;
    #line 4138 
    cmd.cmd = (unsigned short)33U;
    #line 4139 
    cmd.parm0 = rid;
    #line 4141 
    memcpy_toio((void *)ai->config_desc.card_ram_off,(void *)(& ai->config_desc.rid_desc),16UL);
    #line 4144 
    rc = (int)issuecommand(ai,& cmd,& rsp);
    #line 4146 
    if (((int)rsp.status & 32512) != 0) 
                                        #line 4147 
                                        rc = (int)rsp.rsp0;
    #line 4148 
    if (rc == 0) 
                 #line 4149 
                 memcpy(pBuf,(void *)ai->config_desc.virtual_host_addr,(unsigned long)len);
    #line 4150 
    goto done;
  }
  else {
    #line 4163 
    int __UNIQUE_ID___x479;
    #line 4163 
    int tmp_3;
    #line 4152 
    status = (unsigned short)PC4500_accessrid(ai,(unsigned short)((int)rid),(unsigned short)33);
    #line 4152 
    if ((unsigned int)status != 0U) {
      #line 4153 
      rc = (int)status;
      #line 4154 
      goto done;
    }
    #line 4156 
    if (bap_setup(ai,(unsigned short)((int)rid),(unsigned short)0,2) != 0) {
      #line 4157 
      rc = -1;
      #line 4158 
      goto done;
    }
    #line 4161 
    bap_read(ai,(__le16 *)pBuf,2,2);
    {
      #line 4163 
      __UNIQUE_ID___x479 = len;
      #line 4163 
      int __UNIQUE_ID___y480 = (int)*((__le16 *)pBuf);
      #line 4163 
      if (__UNIQUE_ID___x479 < __UNIQUE_ID___y480) 
                                                   #line 4163 
                                                   tmp_3 = __UNIQUE_ID___x479; else 
                                                                    #line 4163 
                                                                    tmp_3 = __UNIQUE_ID___y480;
      }
    #line 4163 
    len = tmp_3 + -2;
    #line 4165 
    if (len <= 2) {
      #line 4166 
      printk((char *)"\001",(char *)(& (ai->dev)->name),(int)rid,len);
      #line 4169 
      rc = -1;
      #line 4170 
      goto done;
    }
    #line 4173 
    rc = bap_read(ai,(__le16 *)pBuf + 1U,len,2);
  }
  #line 4175 
  done: 
        #line 4175 
  ;
  #line 4176 
  if (lock != 0) 
                 #line 4177 
                 up(& ai->sem);
  #line 4178 
  return rc;
}

#line 4183  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int PC4500_writerid(struct airo_info *ai, u16 rid, void *pBuf, int len, int lock)
{
  #line 4186 
  u16 status;
  #line 4187 
  int rc = 0;
  #line 4189 
  *((__le16 *)pBuf) = (unsigned short)len;
  #line 4191 
  if (lock != 0) {
    #line 4192 
    if (down_interruptible(& ai->sem) != 0) 
                                            #line 4193 
                                            return -1;
  }
  #line 4195 
  if ((int)test_bit(11L,& ai->flags) != 0) {
    #line 4196 
    Cmd cmd;
    #line 4197 
    Resp rsp;
    #line 4199 
    if ((int)test_bit(2L,& ai->flags) != 0) 
      #line 4199 
      if ((unsigned int)rid != 65301U) 
                                       #line 4200 
                                       printk((char *)"\001",(char *)(& (ai->dev)->name),(char *)"PC4500_writerid",(int)rid);
    #line 4203 
    memset((void *)(& cmd),0,8UL);
    #line 4204 
    memset((void *)(& rsp),0,8UL);
    #line 4206 
    ai->config_desc.rid_desc.valid = (unsigned int)1U;
    #line 4207 
    ai->config_desc.rid_desc.len = (unsigned int)*((u16 *)pBuf);
    #line 4208 
    ai->config_desc.rid_desc.rid = (unsigned int)0U;
    #line 4210 
    cmd.cmd = (unsigned short)289U;
    #line 4211 
    cmd.parm0 = rid;
    #line 4213 
    memcpy_toio((void *)ai->config_desc.card_ram_off,(void *)(& ai->config_desc.rid_desc),16UL);
    #line 4216 
    if ((unsigned int)len + 4294967292U > 2043U) {
      #line 4217 
      printk((char *)"\001",(char *)(& (ai->dev)->name),(char *)"PC4500_writerid",len);
      #line 4218 
      rc = -1;
    }
    else {
      #line 4220 
      memcpy((void *)ai->config_desc.virtual_host_addr,pBuf,(unsigned long)len);
      #line 4223 
      rc = (int)issuecommand(ai,& cmd,& rsp);
      #line 4224 
      if ((rc & 65280) != 0) {
        #line 4225 
        printk((char *)"\001",(char *)(& (ai->dev)->name),(char *)"PC4500_writerid",rc);
        #line 4227 
        printk((char *)"\001",(char *)(& (ai->dev)->name),(char *)"PC4500_writerid",(int)cmd.cmd);
      }
      #line 4231 
      if (((int)rsp.status & 32512) != 0) 
                                          #line 4232 
                                          rc = (int)rsp.rsp0;
    }
  }
  else {
    #line 4236 
    status = (unsigned short)PC4500_accessrid(ai,(unsigned short)((int)rid),(unsigned short)33);
    #line 4236 
    if ((unsigned int)status != 0U) {
      #line 4237 
      rc = (int)status;
      #line 4238 
      goto done;
    }
    #line 4241 
    if (bap_setup(ai,(unsigned short)((int)rid),(unsigned short)0,2) != 0) {
      #line 4242 
      rc = -1;
      #line 4243 
      goto done;
    }
    #line 4245 
    bap_write(ai,(__le16 *)pBuf,len,2);
    #line 4247 
    rc = PC4500_accessrid(ai,(unsigned short)((int)rid),(unsigned short)289);
  }
  #line 4249 
  done: 
        #line 4249 
  ;
  #line 4250 
  if (lock != 0) 
                 #line 4251 
                 up(& ai->sem);
  #line 4252 
  return rc;
}

#line 4257  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static u16 transmit_allocate(struct airo_info *ai, int lenPayload, int raw)
{
  #line 4260 
  Cmd cmd;
  #line 4261 
  Resp rsp;
  #line 4262 
  u16 txFid;
  #line 4263 
  __le16 txControl;
  #line 4259 
  unsigned int loop = 3000U;
  #line 4265 
  cmd.cmd = (unsigned short)10U;
  #line 4266 
  cmd.parm0 = (unsigned short)lenPayload;
  #line 4267 
  if (down_interruptible(& ai->sem) != 0) 
                                          #line 4268 
                                          return (unsigned short)65535U;
  #line 4269 
  if ((unsigned int)issuecommand(ai,& cmd,& rsp) != 0U) {
    #line 4270 
    txFid = (unsigned short)65535U;
    #line 4271 
    goto done;
  }
  #line 4273 
  if (((int)rsp.status & 65280) != 0) {
    #line 4274 
    txFid = (unsigned short)65535U;
    #line 4275 
    goto done;
  }
  #line 4280 
  while (1) {
    #line 4280 
    if (((int)IN4500(ai,(unsigned short)48) & 8) == 0) {
      #line 4280 
      loop --;
      #line 4280 
      if (! (loop != 0U)) 
                          #line 4280 
                          break;
    }
    else 
         #line 4280 
         break;
  }
  #line 4281 
  if (loop == 0U) {
    #line 4282 
    txFid = (unsigned short)65535U;
    #line 4283 
    goto done;
  }
  #line 4287 
  txFid = IN4500(ai,(unsigned short)34);
  #line 4288 
  OUT4500(ai,(unsigned short)52,(unsigned short)8);
  #line 4295 
  if (raw != 0) 
                #line 4296 
                txControl = (unsigned short)46U; else 
                                                      #line 4299 
                                                      txControl = (unsigned short)38U;
  #line 4301 
  if (bap_setup(ai,(unsigned short)((int)txFid),(unsigned short)8,2) != 0) 
    #line 4302 
    txFid = (unsigned short)65535U; else 
                                         #line 4304 
                                         bap_write(ai,& txControl,2,2);
  #line 4306 
  done: 
        #line 4306 
  ;
  #line 4307 
  up(& ai->sem);
  #line 4309 
  return txFid;
}

#line 4315  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int transmit_802_3_packet(struct airo_info *ai, int len, char *pPacket)
{
  #line 4317 
  __le16 payloadLen;
  #line 4318 
  Cmd cmd;
  #line 4319 
  Resp rsp;
  #line 4322 
  MICBuffer pMic;
  #line 4320 
  int miclen = 0;
  #line 4321 
  u16 txFid = (unsigned short)len;
  #line 4324 
  len >>= 16;
  #line 4326 
  if (len <= 12) {
    #line 4327 
    printk((char *)"\001",(char *)(& (ai->dev)->name),len);
    #line 4328 
    return -1;
  }
  #line 4330 
  len += -12;
  #line 4332 
  if ((int)test_bit(4L,& ai->flags) != 0) 
    #line 4332 
    if ((unsigned int)ai->micstats.enabled != 0U) {
      #line 4332 
      if ((unsigned int)__builtin_bswap16((unsigned short)((int)*((__be16 *)pPacket + 6U))) != 34958U) {
        #line 4334 
        if (encapsulate(ai,(etherHead *)pPacket,& pMic,len) != 0) 
                                                                  #line 4335 
                                                                  return -1;
        #line 4336 
        miclen = 18;
      }
    }
  #line 4340 
  if (bap_setup(ai,(unsigned short)((int)txFid),(unsigned short)54,2) != 0) 
    #line 4340 
    return -1;
  #line 4343 
  payloadLen = (unsigned short)((int)((unsigned short)len) + (int)((unsigned short)miclen));
  #line 4344 
  bap_write(ai,& payloadLen,2,2);
  #line 4345 
  bap_write(ai,(__le16 *)pPacket,12,2);
  #line 4346 
  if (miclen != 0) 
                   #line 4347 
                   bap_write(ai,(__le16 *)(& pMic),miclen,2);
  #line 4348 
  bap_write(ai,(__le16 *)(pPacket + 12UL),len,2);
  #line 4350 
  memset((void *)(& cmd),0,8UL);
  #line 4351 
  cmd.cmd = (unsigned short)11U;
  #line 4352 
  cmd.parm0 = txFid;
  #line 4353 
  if ((unsigned int)issuecommand(ai,& cmd,& rsp) != 0U) 
                                                        #line 4353 
                                                        return -1;
  #line 4354 
  if (((int)rsp.status & 65280) != 0) 
                                      #line 4354 
                                      return -1;
  #line 4355 
  return 0;
}

#line 4358  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int transmit_802_11_packet(struct airo_info *ai, int len, char *pPacket)
{
  #line 4360 
  __le16 fc;
  #line 4360 
  __le16 payloadLen;
  #line 4361 
  Cmd cmd;
  #line 4362 
  Resp rsp;
  #line 4363 
  int hdrlen;
  #line 4364 
  u8 tail[28U] = {[20] = (unsigned char)6U};
  #line 4366 
  u16 txFid = (unsigned short)len;
  #line 4367 
  len >>= 16;
  #line 4369 
  fc = *((__le16 *)pPacket);
  #line 4370 
  hdrlen = header_len((unsigned short)((int)fc));
  #line 4372 
  if (len < hdrlen) {
    #line 4373 
    printk((char *)"\001",(char *)(& (ai->dev)->name),len);
    #line 4374 
    return -1;
  }
  #line 4379 
  if (bap_setup(ai,(unsigned short)((int)txFid),(unsigned short)6,2) != 0) 
    #line 4379 
    return -1;
  #line 4382 
  payloadLen = (unsigned short)((int)((unsigned short)len) - (int)((unsigned short)hdrlen));
  #line 4383 
  bap_write(ai,& payloadLen,2,2);
  #line 4384 
  if (bap_setup(ai,(unsigned short)((int)txFid),(unsigned short)20,2) != 0) 
    #line 4384 
    return -1;
  #line 4385 
  bap_write(ai,(__le16 *)pPacket,hdrlen,2);
  #line 4386 
  bap_write(ai,(__le16 *)((u8 *)(& tail) + ((unsigned long)hdrlen + 18446744073709551606U)),38 - hdrlen,2);
  #line 4388 
  bap_write(ai,(__le16 *)(pPacket + (unsigned long)hdrlen),len - hdrlen,2);
  #line 4390 
  memset((void *)(& cmd),0,8UL);
  #line 4391 
  cmd.cmd = (unsigned short)11U;
  #line 4392 
  cmd.parm0 = txFid;
  #line 4393 
  if ((unsigned int)issuecommand(ai,& cmd,& rsp) != 0U) 
                                                        #line 4393 
                                                        return -1;
  #line 4394 
  if (((int)rsp.status & 65280) != 0) 
                                      #line 4394 
                                      return -1;
  #line 4395 
  return 0;
}

#line 4403 
#line 4597 
static ssize_t proc_read(struct file *file, char *buffer, size_t len, loff_t *offset);
#line 4408 
#line 4615 
static ssize_t proc_write(struct file *file, char *buffer, size_t len, loff_t *offset);
#line 4412 
#line 5487 
static int proc_close(struct inode *inode, struct file *file);
#line 4414 
#line 4710 
static int proc_stats_open(struct inode *inode, struct file *file);
#line 4415 
#line 4702 
static int proc_statsdelta_open(struct inode *inode, struct file *file);
#line 4416 
#line 4634 
static int proc_status_open(struct inode *inode, struct file *file);
#line 4417 
#line 5335 
static int proc_SSID_open(struct inode *inode, struct file *file);
#line 4418 
#line 5379 
static int proc_APList_open(struct inode *inode, struct file *file);
#line 4419 
#line 5417 
static int proc_BSSList_open(struct inode *inode, struct file *file);
#line 4420 
#line 4989 
static int proc_config_open(struct inode *inode, struct file *file);
#line 4421 
#line 5287 
static int proc_wepkey_open(struct inode *inode, struct file *file);
#line 4423  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct file_operations proc_statsdelta_ops = {.owner = & __this_module, .llseek = & default_llseek, .read = & proc_read, .open = & proc_statsdelta_open, .release = & proc_close};
#line 4431  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct file_operations proc_stats_ops = {.owner = & __this_module, .llseek = & default_llseek, .read = & proc_read, .open = & proc_stats_open, .release = & proc_close};
#line 4439  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct file_operations proc_status_ops = {.owner = & __this_module, .llseek = & default_llseek, .read = & proc_read, .open = & proc_status_open, .release = & proc_close};
#line 4447  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct file_operations proc_SSID_ops = {.owner = & __this_module, .llseek = & default_llseek, .read = & proc_read, .write = & proc_write, .open = & proc_SSID_open, .release = & proc_close};
#line 4456  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct file_operations proc_BSSList_ops = {.owner = & __this_module, .llseek = & default_llseek, .read = & proc_read, .write = & proc_write, .open = & proc_BSSList_open, .release = & proc_close};
#line 4465  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct file_operations proc_APList_ops = {.owner = & __this_module, .llseek = & default_llseek, .read = & proc_read, .write = & proc_write, .open = & proc_APList_open, .release = & proc_close};
#line 4474  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct file_operations proc_config_ops = {.owner = & __this_module, .llseek = & default_llseek, .read = & proc_read, .write = & proc_write, .open = & proc_config_open, .release = & proc_close};
#line 4483  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct file_operations proc_wepkey_ops = {.owner = & __this_module, .llseek = & default_llseek, .read = & proc_read, .write = & proc_write, .open = & proc_wepkey_open, .release = & proc_close};
#line 4492  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct proc_dir_entry *airo_entry;
#line 4504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int setup_proc_entry(struct net_device *dev, struct airo_info *apriv)
{
  #line 4506 
  struct proc_dir_entry *entry;
  #line 4509 
  strcpy((char *)(& apriv->proc_name),(char *)(& dev->name));
  #line 4510 
  apriv->proc_entry = proc_mkdir_mode((char *)(& apriv->proc_name),(unsigned short)((int)((unsigned short)airo_perm)),airo_entry);
  #line 4512 
  if (apriv->proc_entry == (struct proc_dir_entry *)0) 
                                                       #line 4513 
                                                       return -12;
  #line 4514 
  proc_set_user(apriv->proc_entry,proc_kuid,proc_kgid);
  #line 4517 
  entry = proc_create_data((char *)"StatsDelta",(unsigned short)((int)((unsigned short)proc_perm) & 292),apriv->proc_entry,& proc_statsdelta_ops,(void *)dev);
  #line 4519 
  if (entry == (struct proc_dir_entry *)0) 
                                           #line 4520 
                                           goto fail;
  #line 4521 
  proc_set_user(entry,proc_kuid,proc_kgid);
  #line 4524 
  entry = proc_create_data((char *)"Stats",(unsigned short)((int)((unsigned short)proc_perm) & 292),apriv->proc_entry,& proc_stats_ops,(void *)dev);
  #line 4526 
  if (entry == (struct proc_dir_entry *)0) 
                                           #line 4527 
                                           goto fail;
  #line 4528 
  proc_set_user(entry,proc_kuid,proc_kgid);
  #line 4531 
  entry = proc_create_data((char *)"Status",(unsigned short)((int)((unsigned short)proc_perm) & 292),apriv->proc_entry,& proc_status_ops,(void *)dev);
  #line 4533 
  if (entry == (struct proc_dir_entry *)0) 
                                           #line 4534 
                                           goto fail;
  #line 4535 
  proc_set_user(entry,proc_kuid,proc_kgid);
  #line 4538 
  entry = proc_create_data((char *)"Config",(unsigned short)((int)((unsigned short)proc_perm)),apriv->proc_entry,& proc_config_ops,(void *)dev);
  #line 4540 
  if (entry == (struct proc_dir_entry *)0) 
                                           #line 4541 
                                           goto fail;
  #line 4542 
  proc_set_user(entry,proc_kuid,proc_kgid);
  #line 4545 
  entry = proc_create_data((char *)"SSID",(unsigned short)((int)((unsigned short)proc_perm)),apriv->proc_entry,& proc_SSID_ops,(void *)dev);
  #line 4547 
  if (entry == (struct proc_dir_entry *)0) 
                                           #line 4548 
                                           goto fail;
  #line 4549 
  proc_set_user(entry,proc_kuid,proc_kgid);
  #line 4552 
  entry = proc_create_data((char *)"APList",(unsigned short)((int)((unsigned short)proc_perm)),apriv->proc_entry,& proc_APList_ops,(void *)dev);
  #line 4554 
  if (entry == (struct proc_dir_entry *)0) 
                                           #line 4555 
                                           goto fail;
  #line 4556 
  proc_set_user(entry,proc_kuid,proc_kgid);
  #line 4559 
  entry = proc_create_data((char *)"BSSList",(unsigned short)((int)((unsigned short)proc_perm)),apriv->proc_entry,& proc_BSSList_ops,(void *)dev);
  #line 4561 
  if (entry == (struct proc_dir_entry *)0) 
                                           #line 4562 
                                           goto fail;
  #line 4563 
  proc_set_user(entry,proc_kuid,proc_kgid);
  #line 4566 
  entry = proc_create_data((char *)"WepKey",(unsigned short)((int)((unsigned short)proc_perm)),apriv->proc_entry,& proc_wepkey_ops,(void *)dev);
  #line 4568 
  if (entry == (struct proc_dir_entry *)0) 
                                           #line 4569 
                                           goto fail;
  #line 4570 
  proc_set_user(entry,proc_kuid,proc_kgid);
  #line 4571 
  return 0;
  #line 4573 
  fail: 
        #line 4573 
  ;
  #line 4574 
  remove_proc_subtree((char *)(& apriv->proc_name),airo_entry);
  #line 4575 
  return -12;
}

#line 4578  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int takedown_proc_entry(struct net_device *dev, struct airo_info *apriv)
{
  #line 4581 
  remove_proc_subtree((char *)(& apriv->proc_name),airo_entry);
  #line 4582 
  return 0;
}

#line 4597  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static ssize_t proc_read(struct file *file, char *buffer, size_t len, loff_t *offset)
{
  #line 4602 
  struct proc_data *priv = (struct proc_data *)file->private_data;
  #line 4604 
  if (priv->rbuffer == (char *)0) 
                                  #line 4605 
                                  return -22L;
  #line 4607 
  return simple_read_from_buffer((void *)buffer,len,offset,
                              (void *)priv->rbuffer,
                              (unsigned long)priv->readlen);
}

#line 4615  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static ssize_t proc_write(struct file *file, char *buffer, size_t len, loff_t *offset)
{
  #line 4620 
  ssize_t ret;
  #line 4621 
  struct proc_data *priv = (struct proc_data *)file->private_data;
  #line 4623 
  if (priv->wbuffer == (char *)0) 
                                  #line 4624 
                                  return -22L;
  #line 4626 
  ret = simple_write_to_buffer((void *)priv->wbuffer,(unsigned long)priv->maxwritelen,offset,(void *)buffer,len);
  #line 4628 
  if (ret > 0L) {
    #line 4629 
    int tmp;
    #line 4629 
    int __UNIQUE_ID___x481;
    {
      #line 4629 
      __UNIQUE_ID___x481 = priv->writelen;
      #line 4629 
      int __UNIQUE_ID___y482 = (int)*offset;
      #line 4629 
      if (__UNIQUE_ID___x481 > __UNIQUE_ID___y482) 
                                                   #line 4629 
                                                   tmp = __UNIQUE_ID___x481; else 
                                                                    #line 4629 
                                                                    tmp = __UNIQUE_ID___y482;
      }
    #line 4629 
    priv->writelen = tmp;
  }
  #line 4631 
  return ret;
}

#line 4634  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int proc_status_open(struct inode *inode, struct file *file)
{
  #line 4636 
  struct proc_data *data;
  #line 4639 
  CapabilityRid cap_rid;
  #line 4640 
  StatusRid status_rid;
  #line 4641 
  u16 mode;
  #line 4642 
  int i;
  #line 4665 
  char *tmp_3;
  #line 4664 
  char *tmp_4;
  #line 4663 
  char *tmp_5;
  #line 4662 
  char *tmp_6;
  #line 4661 
  char *tmp_7;
  #line 4660 
  char *tmp_8;
  #line 4659 
  char *tmp_9;
  #line 4658 
  char *tmp_10;
  #line 4657 
  char *tmp_11;
  #line 4637 
  struct net_device *dev = PDE_DATA(inode);
  #line 4638 
  struct airo_info *apriv = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 4644 
  file->private_data = kzalloc(40UL,3264U);
  #line 4644 
  if (kzalloc(40UL,3264U) == (void *)0) 
                                        #line 4645 
                                        return -12;
  #line 4646 
  data = (struct proc_data *)file->private_data;
  #line 4647 
  data->rbuffer = (char *)kmalloc(2048UL,3264U);
  #line 4647 
  if ((char *)kmalloc(2048UL,3264U) == (char *)0) {
    #line 4648 
    kfree(file->private_data);
    #line 4649 
    return -12;
  }
  #line 4652 
  readStatusRid(apriv,& status_rid,1);
  #line 4653 
  readCapabilityRid(apriv,& cap_rid,1);
  #line 4655 
  mode = status_rid.mode;
  #line 4665 
  if (((int)mode & 32768) != 0) 
                                #line 4665 
                                tmp_3 = (char *)"ERR "; else 
                                                             #line 4665 
                                                             tmp_3 = (char *)"";
  #line 4664 
  if (((int)mode & 512) != 0) 
                              #line 4664 
                              tmp_4 = (char *)"WEP "; else 
                                                           #line 4664 
                                                           tmp_4 = (char *)"";
  #line 4663 
  if (((int)mode & 256) != 0) 
                              #line 4663 
                              tmp_5 = (char *)"KEY "; else 
                                                           #line 4663 
                                                           tmp_5 = (char *)"";
  #line 4662 
  if (((int)mode & 128) != 0) 
                              #line 4662 
                              tmp_6 = (char *)"PRIV "; else 
                                                            #line 4662 
                                                            tmp_6 = (char *)"";
  #line 4661 
  if (((int)mode & 64) != 0) 
                             #line 4661 
                             tmp_7 = (char *)"LEAP "; else 
                                                           #line 4661 
                                                           tmp_7 = (char *)"";
  #line 4660 
  if (((int)mode & 32) != 0) 
                             #line 4660 
                             tmp_8 = (char *)"LNK "; else 
                                                          #line 4660 
                                                          tmp_8 = (char *)"";
  #line 4659 
  if (((int)mode & 16) != 0) 
                             #line 4659 
                             tmp_9 = (char *)"SYN "; else 
                                                          #line 4659 
                                                          tmp_9 = (char *)"";
  #line 4658 
  if (((int)mode & 2) != 0) 
                            #line 4658 
                            tmp_10 = (char *)"ACT "; else 
                                                          #line 4658 
                                                          tmp_10 = (char *)"";
  #line 4657 
  if (((int)mode & 1) != 0) 
                            #line 4657 
                            tmp_11 = (char *)"CFG "; else 
                                                          #line 4657 
                                                          tmp_11 = (char *)"";
  #line 4657 
  ;
  #line 4657 
  i = sprintf(data->rbuffer,(char *)"Status: %s%s%s%s%s%s%s%s%s\n",tmp_11,tmp_10,tmp_9,tmp_8,tmp_7,tmp_6,tmp_5,tmp_4,tmp_3);
  #line 4667 
  sprintf(data->rbuffer + (unsigned long)i,(char *)"Mode: %x\n",(int)status_rid.mode,(int)status_rid.normalizedSignalStrength,(int)status_rid.signalQuality,(int)status_rid.SSIDlen,(char *)(& status_rid.SSID),(char *)(& status_rid.apName),(int)status_rid.channel,(int)((unsigned int)status_rid.currentXmitRate / 2U),(char *)(& version),(char *)(& cap_rid.prodName),(char *)(& cap_rid.manName),(char *)(& cap_rid.prodVer),(int)cap_rid.radioType,(int)cap_rid.country,(int)cap_rid.hardVer,(int)cap_rid.softVer,(int)cap_rid.softSubVer,(int)cap_rid.bootBlockVer);
  #line 4697 
  data->readlen = (int)cif_strlen(data->rbuffer);
  #line 4698 
  return 0;
}

#line 4701 
#line 4714 
static int proc_stats_rid_open(struct inode *inode, struct file *file, u16 rid);
#line 4702  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int proc_statsdelta_open(struct inode *inode, struct file *file)
{
  #line 4704 
  if ((file->f_mode & 2U) != 0U) {
    #line 4705 
    return proc_stats_rid_open(inode,file,(unsigned short)65386);
  }
  #line 4707 
  return proc_stats_rid_open(inode,file,(unsigned short)65385);
}

#line 4710  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int proc_stats_open(struct inode *inode, struct file *file)
{
  #line 4711 
  return proc_stats_rid_open(inode,file,(unsigned short)65384);
}

#line 4714  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int proc_stats_rid_open(struct inode *inode, struct file *file, u16 rid)
{
  #line 4718 
  struct proc_data *data;
  #line 4721 
  StatsRid stats;
  #line 4722 
  int i;
  #line 4722 
  int j;
  #line 4724 
  int len;
  #line 4719 
  struct net_device *dev = PDE_DATA(inode);
  #line 4720 
  struct airo_info *apriv = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 4723 
  __le32 *vals = (__le32 *)(& stats.vals);
  #line 4726 
  file->private_data = kzalloc(40UL,3264U);
  #line 4726 
  if (kzalloc(40UL,3264U) == (void *)0) 
                                        #line 4727 
                                        return -12;
  #line 4728 
  data = (struct proc_data *)file->private_data;
  #line 4729 
  data->rbuffer = (char *)kmalloc(4096UL,3264U);
  #line 4729 
  if ((char *)kmalloc(4096UL,3264U) == (char *)0) {
    #line 4730 
    kfree(file->private_data);
    #line 4731 
    return -12;
  }
  #line 4734 
  readStatsRid(apriv,& stats,(int)rid,1);
  #line 4735 
  len = (int)stats.len;
  #line 4737 
  j = 0;
  #line 4738 
  i = 0;
  #line 4738 
  while (statsLabels[i] != (char *)(-1) && i * 4 < len) {
    {
      #line 4739 
      if (statsLabels[i] == (char *)0) 
                                       #line 4739 
                                       goto __Cont;
      #line 4740 
      ;
      #line 4740 
      if (((unsigned long)j + cif_strlen(statsLabels[i])) + 16UL > 4096UL) {
        #line 4741 
        printk((char *)"\001",(char *)(& (apriv->dev)->name));
        #line 4743 
        break;
      }
      #line 4746 
      j = sprintf(data->rbuffer + (unsigned long)j,(char *)"%s: %u\n",
                statsLabels[i],*(vals + (unsigned long)i)) + j;
    }
    #line 4738 
    __Cont: 
            #line 4738 
    i ++;
  }
  #line 4748 
  if (i * 4 >= len) 
                    #line 4749 
                    printk((char *)"\001",(char *)(& (apriv->dev)->name));
  #line 4751 
  data->readlen = j;
  #line 4752 
  return 0;
}

#line 4755  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int get_dec_u16(char *buffer, int *start, int limit)
{
  #line 4756 
  u16 value;
  #line 4757 
  int valid = 0;
  #line 4758 
  value = (unsigned short)0U;
  #line 4758 
  while ((*start < limit && (int)*(buffer + (unsigned long)*start) > 47) && (int)*(buffer + (unsigned long)*start) <= 57) {
    #line 4760 
    valid = 1;
    #line 4761 
    value = (unsigned short)((unsigned int)value * 10U);
    #line 4762 
    value = (unsigned short)((unsigned int)((int)((unsigned short)*(buffer + (unsigned long)*start)) + (int)value) + 65488U);
    #line 4759 
    (*start) ++;
  }
  #line 4764 
  if (valid == 0) 
                  #line 4764 
                  return -1;
  #line 4765 
  return (int)value;
}

#line 4768 
#line 7473 
static int airo_config_commit(struct net_device *dev, struct iw_request_info *info, void *zwrq, char *extra);
#line 4772  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
__inline static int sniffing_mode(struct airo_info *ai)
{
  #line 4774 
  return ((int)ai->config.rmode & 255) > 2;
}

#line 4778  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void proc_config_on_close(struct inode *inode, struct file *file)
{
  #line 4783 
  char *line;
  #line 4780 
  struct proc_data *data = (struct proc_data *)file->private_data;
  #line 4781 
  struct net_device *dev = PDE_DATA(inode);
  #line 4782 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 4785 
  if (data->writelen == 0) 
                           #line 4785 
                           return;
  #line 4787 
  readConfigRid(ai,1);
  #line 4788 
  cif_set_bit(13L,& ai->flags);
  #line 4790 
  line = data->wbuffer;
  #line 4791 
  while ((int)*line != 0) {
    #line 4793 
    if (cif_strncmp(line,(char *)"Mode: ",6UL) == 0) {
      #line 4794 
      line += 6U;
      #line 4795 
      if (sniffing_mode(ai) != 0) 
                                  #line 4796 
                                  cif_set_bit(14L,& ai->flags);
      #line 4797 
      ai->config.rmode = (unsigned short)((unsigned int)ai->config.rmode & 65024U);
      #line 4798 
      cif_clear_bit(7L,& ai->flags);
      #line 4799 
      ai->config.opmode = (unsigned short)((unsigned int)ai->config.opmode & 65280U);
      #line 4800 
      ai->config.scanMode = (unsigned short)0U;
      #line 4801 
      if ((int)*line == 97) 
                            #line 4802 
                            ai->config.opmode = ai->config.opmode;
      else {
        #line 4804 
        ai->config.opmode = (unsigned short)((unsigned int)ai->config.opmode | 1U);
        #line 4805 
        if ((int)*line == 114) {
          #line 4806 
          ai->config.rmode = (unsigned short)((unsigned int)ai->config.rmode | 259U);
          #line 4807 
          ai->config.scanMode = (unsigned short)1U;
          #line 4808 
          cif_set_bit(7L,& ai->flags);
        }
        else 
          #line 4809 
          if ((int)*line == 121) {
            #line 4810 
            ai->config.rmode = (unsigned short)((unsigned int)ai->config.rmode | 260U);
            #line 4811 
            ai->config.scanMode = (unsigned short)1U;
            #line 4812 
            cif_set_bit(7L,& ai->flags);
          }
          else 
            #line 4813 
            if ((int)*line == 108) 
                                   #line 4814 
                                   ai->config.rmode = (unsigned short)((unsigned int)ai->config.rmode | 5U);
      }
      #line 4816 
      cif_set_bit(13L,& ai->flags);
    }
    else {
      #line 4820 
      if (cif_strncmp(line,(char *)"Radio: ",7UL) == 0) {
        #line 4821 
        line += 7U;
        #line 4822 
        if (cif_strncmp(line,(char *)"off",3UL) == 0) 
                                                      #line 4823 
                                                      cif_set_bit(0L,& ai->flags); else 
                                                                    #line 4825 
                                                                    cif_clear_bit(0L,& ai->flags);
      }
      else {
        #line 4829 
        if (cif_strncmp(line,(char *)"NodeName: ",10UL) == 0) {
          #line 4830 
          int j;
          #line 4832 
          line += 10U;
          #line 4833 
          memset((void *)(& ai->config.nodeName),0,16UL);
          #line 4835 
          j = 0;
          #line 4835 
          while (j <= 15 && (int)*(line + (unsigned long)j) != 10) {
            #line 4836 
            ai->config.nodeName[j] = (unsigned char)*(line + (unsigned long)j);
            #line 4835 
            j ++;
          }
          #line 4838 
          cif_set_bit(13L,& ai->flags);
        }
        else {
          #line 4842 
          if (cif_strncmp(line,(char *)"PowerMode: ",11UL) == 0) {
            #line 4843 
            line += 11U;
            #line 4844 
            if (cif_strncmp(line,(char *)"PSPCAM",6UL) == 0) {
              #line 4845 
              ai->config.powerSaveMode = (unsigned short)2U;
              #line 4846 
              cif_set_bit(13L,& ai->flags);
            }
            else {
              #line 4847 
              if (cif_strncmp(line,(char *)"PSP",3UL) == 0) {
                #line 4848 
                ai->config.powerSaveMode = (unsigned short)1U;
                #line 4849 
                cif_set_bit(13L,& ai->flags);
              }
              else {
                #line 4851 
                ai->config.powerSaveMode = (unsigned short)0U;
                #line 4852 
                cif_set_bit(13L,& ai->flags);
              }
            }
          }
          else {
            #line 4854 
            if (cif_strncmp(line,(char *)"DataRates: ",11UL) == 0) {
              #line 4855 
              int v;
              #line 4855 
              int i = 0;
              #line 4855 
              int k = 0;
              #line 4858 
              line += 11U;
              #line 4859 
              while (1) {
                #line 4859 
                v = get_dec_u16(line,& i,3);
                #line 4859 
                if (! (v != -1)) 
                                 #line 4859 
                                 break;
                {
                  #line 4860 
                  int tmp_4;
                  #line 4860 
                  tmp_4 = k;
                  #line 4860 
                  k ++;
                  #line 4860 
                  ai->config.rates[tmp_4] = (unsigned char)v;
                  #line 4861 
                  line += (unsigned long)i + (unsigned long)1U;
                  #line 4862 
                  i = 0;
                }
              }
              #line 4864 
              cif_set_bit(13L,& ai->flags);
            }
            else {
              #line 4865 
              if (cif_strncmp(line,(char *)"Channel: ",9UL) == 0) {
                #line 4866 
                int v_0;
                #line 4866 
                int i_0 = 0;
                #line 4867 
                line += 9U;
                #line 4868 
                v_0 = get_dec_u16(line,& i_0,i_0 + 3);
                #line 4869 
                if (v_0 != -1) {
                  #line 4870 
                  ai->config.channelSet = (unsigned short)v_0;
                  #line 4871 
                  cif_set_bit(13L,& ai->flags);
                }
              }
              else {
                #line 4873 
                if (cif_strncmp(line,(char *)"XmitPower: ",11UL) == 0) {
                  #line 4874 
                  int v_1;
                  #line 4874 
                  int i_1 = 0;
                  #line 4875 
                  line += 11U;
                  #line 4876 
                  v_1 = get_dec_u16(line,& i_1,i_1 + 3);
                  #line 4877 
                  if (v_1 != -1) {
                    #line 4878 
                    ai->config.txPower = (unsigned short)v_1;
                    #line 4879 
                    cif_set_bit(13L,& ai->flags);
                  }
                }
                else {
                  #line 4881 
                  if (cif_strncmp(line,(char *)"WEP: ",5UL) == 0) {
                    #line 4882 
                    line += 5U;
                    #line 4883 
                    switch ((int)*line) {
                      #line 4884 
                      case 115: 
                                #line 4884 
                      ;
                      #line 4885 
                      set_auth_type(ai,258);
                      #line 4886 
                      break;
                      #line 4887 
                      case 101: 
                                #line 4887 
                      ;
                      #line 4888 
                      set_auth_type(ai,257);
                      #line 4889 
                      break;
                      #line 4890 
                      default: 
                               #line 4890 
                      ;
                      #line 4891 
                      set_auth_type(ai,1);
                      #line 4892 
                      break;
                    }
                    #line 4894 
                    cif_set_bit(13L,& ai->flags);
                  }
                  else {
                    #line 4895 
                    if (cif_strncmp(line,(char *)"LongRetryLimit: ",16UL) == 0) {
                      #line 4896 
                      int v_2;
                      #line 4896 
                      int i_2 = 0;
                      #line 4898 
                      line += 16U;
                      #line 4899 
                      v_2 = get_dec_u16(line,& i_2,3);
                      #line 4900 
                      if (v_2 >= 0) {
                        #line 4900 
                        int tmp_5;
                        #line 4900 
                        if (255 < v_2) 
                                       #line 4900 
                                       tmp_5 = 255; else 
                                                         #line 4900 
                                                         tmp_5 = v_2;
                        #line 4900 
                        v_2 = tmp_5;
                      }
                      else 
                           #line 4900 
                           v_2 = 0;
                      #line 4901 
                      ai->config.longRetryLimit = (unsigned short)v_2;
                      #line 4902 
                      cif_set_bit(13L,& ai->flags);
                    }
                    else {
                      #line 4903 
                      if (cif_strncmp(line,(char *)"ShortRetryLimit: ",17UL) == 0) {
                        #line 4904 
                        int v_3;
                        #line 4904 
                        int i_3 = 0;
                        #line 4906 
                        line += 17U;
                        #line 4907 
                        v_3 = get_dec_u16(line,& i_3,3);
                        #line 4908 
                        if (v_3 >= 0) {
                          #line 4908 
                          int tmp_6;
                          #line 4908 
                          if (255 < v_3) 
                                         #line 4908 
                                         tmp_6 = 255; else 
                                                           #line 4908 
                                                           tmp_6 = v_3;
                          #line 4908 
                          v_3 = tmp_6;
                        }
                        else 
                             #line 4908 
                             v_3 = 0;
                        #line 4909 
                        ai->config.shortRetryLimit = (unsigned short)v_3;
                        #line 4910 
                        cif_set_bit(13L,& ai->flags);
                      }
                      else {
                        #line 4911 
                        if (cif_strncmp(line,(char *)"RTSThreshold: ",14UL) == 0) {
                          #line 4912 
                          int v_4;
                          #line 4912 
                          int i_4 = 0;
                          #line 4914 
                          line += 14U;
                          #line 4915 
                          v_4 = get_dec_u16(line,& i_4,4);
                          #line 4916 
                          if (v_4 >= 0) {
                            #line 4916 
                            int tmp_7;
                            #line 4916 
                            if (2312 < v_4) 
                                            #line 4916 
                                            tmp_7 = 2312; else 
                                                               #line 4916 
                                                               tmp_7 = v_4;
                            #line 4916 
                            v_4 = tmp_7;
                          }
                          else 
                               #line 4916 
                               v_4 = 0;
                          #line 4917 
                          ai->config.rtsThres = (unsigned short)v_4;
                          #line 4918 
                          cif_set_bit(13L,& ai->flags);
                        }
                        else {
                          #line 4919 
                          if (cif_strncmp(line,(char *)"TXMSDULifetime: ",16UL) == 0) {
                            #line 4920 
                            int v_5;
                            #line 4920 
                            int i_5 = 0;
                            #line 4922 
                            line += 16U;
                            #line 4923 
                            v_5 = get_dec_u16(line,& i_5,5);
                            #line 4924 
                            if (0 > v_5) 
                                         #line 4924 
                                         v_5 = 0; else 
                                                       #line 4924 
                                                       v_5 = v_5;
                            #line 4925 
                            ai->config.txLifetime = (unsigned short)v_5;
                            #line 4926 
                            cif_set_bit(13L,& ai->flags);
                          }
                          else {
                            #line 4927 
                            if (cif_strncmp(line,(char *)"RXMSDULifetime: ",16UL) == 0) {
                              #line 4928 
                              int v_6;
                              #line 4928 
                              int i_6 = 0;
                              #line 4930 
                              line += 16U;
                              #line 4931 
                              v_6 = get_dec_u16(line,& i_6,5);
                              #line 4932 
                              if (0 > v_6) 
                                           #line 4932 
                                           v_6 = 0; else 
                                                         #line 4932 
                                                         v_6 = v_6;
                              #line 4933 
                              ai->config.rxLifetime = (unsigned short)v_6;
                              #line 4934 
                              cif_set_bit(13L,& ai->flags);
                            }
                            else {
                              #line 4935 
                              if (cif_strncmp(line,(char *)"TXDiversity: ",13UL) == 0) {
                                #line 4937 
                                if ((int)*(line + 13U) != 108) {
                                  #line 4938 
                                  unsigned int tmp_8;
                                  #line 4938 
                                  if ((int)*(line + 13U) == 114) 
                                                                 #line 4938 
                                                                 tmp_8 = 2U; else 
                                                                    #line 4938 
                                                                    tmp_8 = 3U;
                                  #line 4937 
                                  ai->config.txDiversity = (unsigned char)tmp_8;
                                }
                                else 
                                     #line 4937 
                                     ai->config.txDiversity = (unsigned char)1U;
                                #line 4939 
                                cif_set_bit(13L,& ai->flags);
                              }
                              else {
                                #line 4940 
                                if (cif_strncmp(line,(char *)"RXDiversity: ",13UL) == 0) {
                                  #line 4942 
                                  if ((int)*(line + 13U) != 108) {
                                    #line 4943 
                                    unsigned int tmp_9;
                                    #line 4943 
                                    if ((int)*(line + 13U) == 114) 
                                                                   #line 4943 
                                                                   tmp_9 = 2U; else 
                                                                    #line 4943 
                                                                    tmp_9 = 3U;
                                    #line 4942 
                                    ai->config.rxDiversity = (unsigned char)tmp_9;
                                  }
                                  else 
                                       #line 4942 
                                       ai->config.rxDiversity = (unsigned char)1U;
                                  #line 4944 
                                  cif_set_bit(13L,& ai->flags);
                                }
                                else {
                                  #line 4945 
                                  if (cif_strncmp(line,(char *)"FragThreshold: ",15UL) == 0) {
                                    #line 4946 
                                    int v_7;
                                    #line 4946 
                                    int i_7 = 0;
                                    #line 4948 
                                    line += 15U;
                                    #line 4949 
                                    v_7 = get_dec_u16(line,& i_7,4);
                                    #line 4950 
                                    if (v_7 > 255) {
                                      #line 4950 
                                      int tmp_10;
                                      #line 4950 
                                      if (2312 < v_7) 
                                                      #line 4950 
                                                      tmp_10 = 2312; else 
                                                                    #line 4950 
                                                                    tmp_10 = v_7;
                                      #line 4950 
                                      v_7 = tmp_10;
                                    }
                                    else 
                                         #line 4950 
                                         v_7 = 256;
                                    #line 4951 
                                    v_7 &= 65534;
                                    #line 4952 
                                    ai->config.fragThresh = (unsigned short)v_7;
                                    #line 4953 
                                    cif_set_bit(13L,& ai->flags);
                                  }
                                  else {
                                    #line 4954 
                                    if (cif_strncmp(line,(char *)"Modulation: ",12UL) == 0) {
                                      #line 4955 
                                      line += 12U;
                                      #line 4956 
                                      switch ((int)*line) {
                                        #line 4957 
                                        case 100: 
                                                  #line 4957 
                                        ;
                                        #line 4957 
                                        ai->config.modulation = (unsigned short)0U;
                                        #line 4957 
                                        cif_set_bit(13L,& ai->flags);
                                        #line 4957 
                                        break;
                                        #line 4958 
                                        case 99: 
                                                 #line 4958 
                                        ;
                                        #line 4958 
                                        ai->config.modulation = (unsigned short)1U;
                                        #line 4958 
                                        cif_set_bit(13L,& ai->flags);
                                        #line 4958 
                                        break;
                                        #line 4959 
                                        case 109: 
                                                  #line 4959 
                                        ;
                                        #line 4959 
                                        ai->config.modulation = (unsigned short)2U;
                                        #line 4959 
                                        cif_set_bit(13L,& ai->flags);
                                        #line 4959 
                                        break;
                                        #line 4960 
                                        default: 
                                                 #line 4960 
                                        ;
                                        #line 4960 
                                        printk((char *)"\001",(char *)(& (ai->dev)->name));
                                      }
                                    }
                                    else {
                                      #line 4962 
                                      if (cif_strncmp(line,(char *)"Preamble: ",10UL) == 0) {
                                        #line 4963 
                                        line += 10U;
                                        #line 4964 
                                        switch ((int)*line) {
                                          #line 4965 
                                          case 97: 
                                                   #line 4965 
                                          ;
                                          #line 4965 
                                          ai->config.preamble = (unsigned short)0U;
                                          #line 4965 
                                          cif_set_bit(13L,& ai->flags);
                                          #line 4965 
                                          break;
                                          #line 4966 
                                          case 108: 
                                                    #line 4966 
                                          ;
                                          #line 4966 
                                          ai->config.preamble = (unsigned short)1U;
                                          #line 4966 
                                          cif_set_bit(13L,& ai->flags);
                                          #line 4966 
                                          break;
                                          #line 4967 
                                          case 115: 
                                                    #line 4967 
                                          ;
                                          #line 4967 
                                          ai->config.preamble = (unsigned short)2U;
                                          #line 4967 
                                          cif_set_bit(13L,& ai->flags);
                                          #line 4967 
                                          break;
                                          #line 4968 
                                          default: 
                                                   #line 4968 
                                          ;
                                          #line 4968 
                                          printk((char *)"\001",(char *)(& (ai->dev)->name));
                                        }
                                      }
                                      else 
                                           #line 4971 
                                           printk((char *)"\001",(char *)(& (ai->dev)->name),line);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    #line 4973 
    while ((int)*line != 0 && (int)*line != 10) 
                                                #line 4973 
                                                line ++;
    #line 4974 
    if ((int)*line != 0) 
                         #line 4974 
                         line ++;
  }
  #line 4976 
  airo_config_commit(dev,(struct iw_request_info *)0,(void *)0,(char *)0);
  #line 4977 
  return;
}

#line 4979  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static char *get_rmode(__le16 mode)
{
  #line 4981 
  switch ((int)mode & 255) {
    #line 4982 
    case 3: 
            #line 4982 
    ;
    #line 4982 
    return (char *)"rfmon";
    #line 4983 
    case 4: 
            #line 4983 
    ;
    #line 4983 
    return (char *)"yna (any) bss rfmon";
    #line 4984 
    case 5: 
            #line 4984 
    ;
    #line 4984 
    return (char *)"lanmon";
  }
  #line 4986 
  return (char *)"ESS";
}

#line 4989  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int proc_config_open(struct inode *inode, struct file *file)
{
  #line 5029 
  char *tmp_6;
  #line 5063 
  char *tmp_23;
  #line 5061 
  char *tmp_25;
  #line 5023 
  char *tmp_13;
  #line 5072 
  char *tmp_15;
  #line 5071 
  char *tmp_16;
  #line 5069 
  char *tmp_18;
  #line 5068 
  char *tmp_19;
  #line 5066 
  char *tmp_21;
  #line 5030 
  char *tmp_5;
  #line 4991 
  struct proc_data *data;
  #line 4994 
  int i;
  #line 4995 
  __le16 mode;
  #line 5028 
  char *tmp_7;
  #line 5023 
  char *tmp_9;
  #line 5016 
  char *tmp_14;
  #line 5068 
  char *tmp_17;
  #line 5066 
  char *tmp_20;
  #line 5065 
  char *tmp_22;
  #line 5061 
  char *tmp_24;
  #line 5060 
  char *tmp_26;
  #line 4992 
  struct net_device *dev = PDE_DATA(inode);
  #line 4993 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 4997 
  file->private_data = kzalloc(40UL,3264U);
  #line 4997 
  if (kzalloc(40UL,3264U) == (void *)0) 
                                        #line 4998 
                                        return -12;
  #line 4999 
  data = (struct proc_data *)file->private_data;
  #line 5000 
  data->rbuffer = (char *)kmalloc(2048UL,3264U);
  #line 5000 
  if ((char *)kmalloc(2048UL,3264U) == (char *)0) {
    #line 5001 
    kfree(file->private_data);
    #line 5002 
    return -12;
  }
  #line 5004 
  data->wbuffer = (char *)kzalloc(2048UL,3264U);
  #line 5004 
  if ((char *)kzalloc(2048UL,3264U) == (char *)0) {
    #line 5005 
    kfree((void *)data->rbuffer);
    #line 5006 
    kfree(file->private_data);
    #line 5007 
    return -12;
  }
  #line 5009 
  data->maxwritelen = 2048;
  #line 5010 
  data->on_close = & proc_config_on_close;
  #line 5012 
  readConfigRid(ai,1);
  #line 5014 
  mode = (unsigned short)((unsigned int)ai->config.opmode & 255U);
  #line 5015 
  ;
  #line 5015 
  ;
  #line 5015 
  ;
  #line 5015 
  ;
  #line 5015 
  ;
  #line 5015 
  ;
  #line 5015 
  ;
  #line 5015 
  ;
  #line 5015 
  ;
  #line 5015 
  ;
  #line 5028 
  if ((unsigned int)ai->config.powerSaveMode != 0U) {
    #line 5029 
    if ((unsigned int)ai->config.powerSaveMode != 1U) {
      #line 5030 
      if ((unsigned int)ai->config.powerSaveMode == 2U) 
                                                        #line 5030 
                                                        tmp_5 = (char *)"PSPCAM"; else 
                                                                    #line 5030 
                                                                    tmp_5 = (char *)"Error";
      #line 5029 
      tmp_6 = tmp_5;
    }
    else 
         #line 5029 
         tmp_6 = (char *)"PSP";
    #line 5028 
    tmp_7 = tmp_6;
  }
  else 
       #line 5028 
       tmp_7 = (char *)"CAM";
  #line 5015 
  ;
  #line 5023 
  if ((int)test_bit(0L,& ai->flags) != 0) 
                                          #line 5023 
                                          tmp_9 = (char *)"off"; else 
                                                                   #line 5023 
                                                                   tmp_9 = (char *)"on";
  #line 5016 
  if ((unsigned int)mode != 0U) {
    #line 5023 
    if ((unsigned int)mode == 1U) 
                                  #line 5024 
                                  tmp_13 = get_rmode((unsigned short)((int)ai->config.rmode));
    else {
      #line 5025 
      char *tmp_11;
      #line 5024 
      char *tmp_12;
      #line 5024 
      if ((unsigned int)mode != 2U) {
        #line 5025 
        if ((unsigned int)mode == 3U) 
                                      #line 5025 
                                      tmp_11 = (char *)"AP RPTR"; else 
                                                                    #line 5025 
                                                                    tmp_11 = (char *)"Error";
        #line 5024 
        tmp_12 = tmp_11;
      }
      else 
           #line 5024 
           tmp_12 = (char *)"AP";
      #line 5023 
      tmp_13 = tmp_12;
    }
    #line 5016 
    tmp_14 = tmp_13;
  }
  else 
       #line 5016 
       tmp_14 = (char *)"adhoc";
  #line 5015 
  ;
  #line 5015 
  i = sprintf(data->rbuffer,(char *)"Mode: %s\n",tmp_14,tmp_9,(u8 *)(& ai->config.nodeName),tmp_7,(int)ai->config.rates[0],(int)ai->config.rates[1],(int)ai->config.rates[2],(int)ai->config.rates[3],(int)ai->config.rates[4],(int)ai->config.rates[5],(int)ai->config.rates[6],(int)ai->config.rates[7],(int)ai->config.channelSet,(int)ai->config.txPower);
  #line 5068 
  if ((unsigned int)ai->config.preamble != 0U) {
    #line 5071 
    if ((unsigned int)ai->config.preamble != 1U) {
      #line 5072 
      if ((unsigned int)ai->config.preamble == 2U) 
                                                   #line 5072 
                                                   tmp_15 = (char *)"short"; else 
                                                                    #line 5072 
                                                                    tmp_15 = (char *)"error";
      #line 5071 
      tmp_16 = tmp_15;
    }
    else 
         #line 5071 
         tmp_16 = (char *)"long";
    #line 5068 
    tmp_17 = tmp_16;
  }
  else 
       #line 5068 
       tmp_17 = (char *)"auto";
  #line 5066 
  if ((unsigned int)ai->config.modulation != 0U) {
    #line 5068 
    if ((unsigned int)ai->config.modulation != 1U) {
      #line 5069 
      if ((unsigned int)ai->config.modulation == 2U) 
                                                     #line 5069 
                                                     tmp_18 = (char *)"mok"; else 
                                                                    #line 5069 
                                                                    tmp_18 = (char *)"error";
      #line 5068 
      tmp_19 = tmp_18;
    }
    else 
         #line 5068 
         tmp_19 = (char *)"cck";
    #line 5066 
    tmp_20 = tmp_19;
  }
  else 
       #line 5066 
       tmp_20 = (char *)"default";
  #line 5065 
  if ((unsigned int)ai->config.authType != 257U) {
    #line 5066 
    if ((unsigned int)ai->config.authType == 258U) 
                                                   #line 5066 
                                                   tmp_21 = (char *)"shared"; else 
                                                                    #line 5066 
                                                                    tmp_21 = (char *)"open";
    #line 5065 
    tmp_22 = tmp_21;
  }
  else 
       #line 5065 
       tmp_22 = (char *)"encrypt";
  #line 5044 
  ;
  #line 5061 
  if ((unsigned int)ai->config.rxDiversity != 1U) {
    #line 5063 
    if ((unsigned int)ai->config.rxDiversity == 2U) 
                                                    #line 5063 
                                                    tmp_23 = (char *)"right"; else 
                                                                    #line 5063 
                                                                    tmp_23 = (char *)"both";
    #line 5061 
    tmp_24 = tmp_23;
  }
  else 
       #line 5061 
       tmp_24 = (char *)"left";
  #line 5060 
  if ((unsigned int)ai->config.txDiversity != 1U) {
    #line 5061 
    if ((unsigned int)ai->config.txDiversity == 2U) 
                                                    #line 5061 
                                                    tmp_25 = (char *)"right"; else 
                                                                    #line 5061 
                                                                    tmp_25 = (char *)"both";
    #line 5060 
    tmp_26 = tmp_25;
  }
  else 
       #line 5060 
       tmp_26 = (char *)"left";
  #line 5044 
  ;
  #line 5044 
  ;
  #line 5044 
  ;
  #line 5044 
  ;
  #line 5044 
  ;
  #line 5044 
  ;
  #line 5044 
  sprintf(data->rbuffer + (unsigned long)i,(char *)"LongRetryLimit: %d\n",(int)ai->config.longRetryLimit,(int)ai->config.shortRetryLimit,(int)ai->config.rtsThres,(int)ai->config.txLifetime,(int)ai->config.rxLifetime,tmp_26,tmp_24,(int)ai->config.fragThresh,tmp_22,tmp_20,tmp_17);
  #line 5075 
  data->readlen = (int)cif_strlen(data->rbuffer);
  #line 5076 
  return 0;
}

#line 5079  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void proc_SSID_on_close(struct inode *inode, struct file *file)
{
  #line 5084 
  SsidRid SSID_rid;
  #line 5085 
  int i;
  #line 5081 
  struct proc_data *data = (struct proc_data *)file->private_data;
  #line 5082 
  struct net_device *dev = PDE_DATA(inode);
  #line 5083 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5086 
  char *p = data->wbuffer;
  #line 5087 
  char *end = p + (unsigned long)data->writelen;
  #line 5089 
  if (data->writelen == 0) 
                           #line 5090 
                           return;
  #line 5092 
  *end = (char)10;
  #line 5094 
  memset((void *)(& SSID_rid),0,104UL);
  #line 5096 
  i = 0;
  #line 5096 
  while (i <= 2 && p < end) {
    {
      #line 5097 
      int j = 0;
      #line 5099 
      while ((int)*p != 10 && j <= 31) {
        #line 5100 
        int tmp_0;
        #line 5100 
        char *tmp_1;
        #line 5100 
        tmp_0 = j;
        #line 5100 
        j ++;
        #line 5100 
        tmp_1 = p;
        #line 5100 
        p ++;
        #line 5100 
        SSID_rid.ssids[i].ssid[tmp_0] = (unsigned char)*tmp_1;
      }
      #line 5101 
      if (j == 0) 
                  #line 5102 
                  break;
      #line 5103 
      SSID_rid.ssids[i].len = (unsigned short)j;
      #line 5105 
      while (1) {
        #line 5105 
        char *tmp_2;
        #line 5105 
        tmp_2 = p;
        #line 5105 
        p ++;
        #line 5105 
        ;
        #line 5105 
        if (! ((int)*tmp_2 != 10)) 
                                   #line 5105 
                                   break;
      }
    }
    #line 5096 
    i ++;
  }
  #line 5108 
  if (i != 0) 
              #line 5109 
              SSID_rid.len = (unsigned short)104U;
  #line 5110 
  disable_MAC(ai,1);
  #line 5111 
  writeSsidRid(ai,& SSID_rid,1);
  #line 5112 
  enable_MAC(ai,1);
  #line 5113 
  return;
}

#line 5115  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void proc_APList_on_close(struct inode *inode, struct file *file)
{
  #line 5120 
  int i;
  #line 5116 
  struct proc_data *data = (struct proc_data *)file->private_data;
  #line 5117 
  struct net_device *dev = PDE_DATA(inode);
  #line 5118 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5119 
  APListRid *APList_rid = & ai->APList;
  #line 5122 
  if (data->writelen == 0) 
                           #line 5122 
                           return;
  #line 5124 
  memset((void *)APList_rid,0,26UL);
  #line 5125 
  APList_rid->len = (unsigned short)26U;
  #line 5127 
  i = 0;
  #line 5127 
  while (i <= 3 && data->writelen >= (i + 1) * 18) {
    #line 5128 
    mac_pton(data->wbuffer + (unsigned long)(i * 18),(u8 *)(& APList_rid->ap[i]));
    #line 5127 
    i ++;
  }
  #line 5130 
  disable_MAC(ai,1);
  #line 5131 
  writeAPListRid(ai,APList_rid,1);
  #line 5132 
  enable_MAC(ai,1);
  #line 5133 
  return;
}

#line 5136  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int do_writerid(struct airo_info *ai, u16 rid, void *rid_data, int len, int dummy)
{
  #line 5138 
  int rc;
  #line 5140 
  disable_MAC(ai,1);
  #line 5141 
  rc = PC4500_writerid(ai,(unsigned short)((int)rid),rid_data,len,1);
  #line 5142 
  enable_MAC(ai,1);
  #line 5143 
  return rc;
}

#line 5149  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int get_wep_key(struct airo_info *ai, u16 index, char *buf, u16 buflen)
{
  #line 5151 
  WepKeyRid wkr;
  #line 5152 
  int rc;
  #line 5153 
  __le16 lastindex;
  #line 5155 
  rc = readWepKeyRid(ai,& wkr,1,1);
  #line 5156 
  if (rc != 0) 
               #line 5157 
               return -1;
  #line 5158 
  while (1) {
    #line 5159 
    lastindex = wkr.kindex;
    #line 5160 
    if ((int)wkr.kindex == (int)index) {
      #line 5161 
      int __UNIQUE_ID___x483;
      #line 5161 
      int tmp;
      {
        #line 5161 
        __UNIQUE_ID___x483 = (int)buflen;
        #line 5161 
        int __UNIQUE_ID___y484 = (int)wkr.klen;
        #line 5161 
        if (__UNIQUE_ID___x483 < __UNIQUE_ID___y484) 
                                                     #line 5161 
                                                     tmp = __UNIQUE_ID___x483; else 
                                                                    #line 5161 
                                                                    tmp = __UNIQUE_ID___y484;
        }
      #line 5161 
      int klen = tmp;
      #line 5162 
      memcpy((void *)buf,(void *)(& wkr.key),(unsigned long)klen);
      #line 5163 
      return klen;
    }
    #line 5165 
    rc = readWepKeyRid(ai,& wkr,0,1);
    #line 5166 
    if (rc != 0) 
                 #line 5167 
                 return -1;
    #line 5168 
    if (! ((int)wkr.kindex != (int)lastindex)) 
                                               #line 5158 
                                               break;
  }
  #line 5169 
  return -1;
}

#line 5172  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int get_wep_tx_idx(struct airo_info *ai)
{
  #line 5174 
  WepKeyRid wkr;
  #line 5175 
  int rc;
  #line 5176 
  __le16 lastindex;
  #line 5178 
  rc = readWepKeyRid(ai,& wkr,1,1);
  #line 5179 
  if (rc != 0) 
               #line 5180 
               return -1;
  #line 5181 
  while (1) {
    #line 5182 
    lastindex = wkr.kindex;
    #line 5183 
    if ((unsigned int)wkr.kindex == 65535U) 
                                            #line 5184 
                                            return (int)wkr.mac[0];
    #line 5185 
    rc = readWepKeyRid(ai,& wkr,0,1);
    #line 5186 
    if (rc != 0) 
                 #line 5187 
                 return -1;
    #line 5188 
    if (! ((int)wkr.kindex != (int)lastindex)) 
                                               #line 5181 
                                               break;
  }
  #line 5189 
  return -1;
}

#line 5192  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int set_wep_key(struct airo_info *ai, u16 index, char *key, u16 keylen, int perm, int lock)
{
  #line 5199 
  int __ret_warn_on;
  #line 5196 
  WepKeyRid wkr;
  #line 5197 
  int rc;
  #line 5195 
  unsigned char macaddr[6U] = {(unsigned char)1U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U, (unsigned char)0U};
  #line 5199 
  __ret_warn_on = (unsigned int)keylen == 0U;
  #line 5199 
  if ((long)(__ret_warn_on != 0) != 0L) {
    #line 5200 
    ldv_inline_asm();
    #line 5201 
    ldv_inline_asm();
  }
  #line 5199 
  if ((long)((long)(__ret_warn_on != 0)) != 0L) 
                                                #line 5200 
                                                return -1;
  #line 5202 
  memset((void *)(& wkr),0,28UL);
  #line 5203 
  wkr.len = (unsigned short)28U;
  #line 5204 
  wkr.kindex = index;
  #line 5205 
  wkr.klen = keylen;
  #line 5206 
  memcpy((void *)(& wkr.key),(void *)key,(unsigned long)keylen);
  #line 5207 
  memcpy((void *)(& wkr.mac),(void *)(& macaddr),6UL);
  #line 5209 
  if (perm != 0) 
                 #line 5209 
                 disable_MAC(ai,lock);
  #line 5210 
  rc = writeWepKeyRid(ai,& wkr,perm,lock);
  #line 5211 
  if (perm != 0) 
                 #line 5211 
                 enable_MAC(ai,lock);
  #line 5212 
  return rc;
}

#line 5215  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int set_wep_tx_idx(struct airo_info *ai, u16 index, int perm, int lock)
{
  #line 5217 
  WepKeyRid wkr;
  #line 5218 
  int rc;
  #line 5220 
  memset((void *)(& wkr),0,28UL);
  #line 5221 
  wkr.len = (unsigned short)28U;
  #line 5222 
  wkr.kindex = (unsigned short)65535U;
  #line 5223 
  wkr.mac[0] = (unsigned char)index;
  #line 5225 
  if (perm != 0) {
    #line 5226 
    ai->defindex = (char)index;
    #line 5227 
    disable_MAC(ai,lock);
  }
  #line 5230 
  rc = writeWepKeyRid(ai,& wkr,perm,lock);
  #line 5232 
  if (perm != 0) 
                 #line 5233 
                 enable_MAC(ai,lock);
  #line 5234 
  return rc;
}

#line 5237  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void proc_wepkey_on_close(struct inode *inode, struct file *file)
{
  #line 5238 
  struct proc_data *data;
  #line 5241 
  int i;
  #line 5241 
  int rc;
  #line 5242 
  char key[16U];
  #line 5239 
  struct net_device *dev = PDE_DATA(inode);
  #line 5240 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5243 
  u16 index = (unsigned short)0U;
  #line 5244 
  int j = 0;
  #line 5246 
  memset((void *)(& key),0,16UL);
  #line 5248 
  data = (struct proc_data *)file->private_data;
  #line 5249 
  if (data->writelen == 0) 
                           #line 5249 
                           return;
  #line 5251 
  if ((unsigned int)*(data->wbuffer) + 208U <= 3U && ((int)*(data->wbuffer + 1U) == 32 || (int)*(data->wbuffer + 1U) == 10)) {
    #line 5253 
    index = (unsigned short)((unsigned int)((unsigned short)*(data->wbuffer)) + 65488U);
    #line 5254 
    if ((int)*(data->wbuffer + 1U) == 10) {
      #line 5255 
      rc = set_wep_tx_idx(ai,(unsigned short)((int)index),1,1);
      #line 5256 
      if (rc < 0) 
                  #line 5257 
                  printk((char *)"\001",(char *)(& (ai->dev)->name),(int)index,rc);
      #line 5261 
      return;
    }
    #line 5263 
    j = 2;
  }
  else {
    #line 5265 
    printk((char *)"\001",(char *)(& (ai->dev)->name));
    #line 5266 
    return;
  }
  #line 5269 
  i = 0;
  #line 5269 
  while (i <= 47 && (int)*(data->wbuffer + (unsigned long)(i + j)) != 0) {
    #line 5270 
    switch (i % 3) {
      #line 5271 
      case 0: 
              #line 5271 
      ;
      #line 5272 
      key[i / 3] = (char)(hex_to_bin((char)((int)*(data->wbuffer + (unsigned long)(i + j)))) << 4);
      #line 5273 
      break;
      #line 5274 
      case 1: 
              #line 5274 
      ;
      #line 5275 
      key[i / 3] = (char)((int)key[i / 3] | (int)((char)hex_to_bin((char)((int)*(data->wbuffer + (unsigned long)(i + j))))));
      #line 5276 
      break;
    }
    #line 5269 
    i ++;
  }
  #line 5280 
  rc = set_wep_key(ai,(unsigned short)((int)index),(char *)(& key),(unsigned short)((int)((unsigned short)(i / 3))),1,1);
  #line 5281 
  if (rc < 0) 
              #line 5282 
              printk((char *)"\001",(char *)(& (ai->dev)->name),(int)index,rc);
  #line 5283 
  return;
}

#line 5287  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int proc_wepkey_open(struct inode *inode, struct file *file)
{
  #line 5289 
  struct proc_data *data;
  #line 5292 
  char *ptr;
  #line 5293 
  WepKeyRid wkr;
  #line 5294 
  __le16 lastindex;
  #line 5296 
  int rc;
  #line 5290 
  struct net_device *dev = PDE_DATA(inode);
  #line 5291 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5295 
  int j = 0;
  #line 5298 
  file->private_data = kzalloc(40UL,3264U);
  #line 5298 
  if (kzalloc(40UL,3264U) == (void *)0) 
                                        #line 5299 
                                        return -12;
  #line 5300 
  memset((void *)(& wkr),0,28UL);
  #line 5301 
  data = (struct proc_data *)file->private_data;
  #line 5302 
  data->rbuffer = (char *)kzalloc(180UL,3264U);
  #line 5302 
  if ((char *)kzalloc(180UL,3264U) == (char *)0) {
    #line 5303 
    kfree(file->private_data);
    #line 5304 
    return -12;
  }
  #line 5306 
  data->writelen = 0;
  #line 5307 
  data->maxwritelen = 80;
  #line 5308 
  data->wbuffer = (char *)kzalloc(80UL,3264U);
  #line 5308 
  if ((char *)kzalloc(80UL,3264U) == (char *)0) {
    #line 5309 
    kfree((void *)data->rbuffer);
    #line 5310 
    kfree(file->private_data);
    #line 5311 
    return -12;
  }
  #line 5313 
  data->on_close = & proc_wepkey_on_close;
  #line 5315 
  ptr = data->rbuffer;
  #line 5316 
  strcpy(ptr,(char *)"No wep keys\n");
  #line 5317 
  rc = readWepKeyRid(ai,& wkr,1,1);
  #line 5318 
  if (rc == 0) 
    #line 5318 
    while (1) {
      #line 5319 
      lastindex = wkr.kindex;
      #line 5320 
      if ((unsigned int)wkr.kindex == 65535U) {
        #line 5322 
        j = sprintf(ptr + (unsigned long)j,(char *)"Tx key = %d\n",
                (int)wkr.mac[0]) + j;
      }
      else {
        #line 5326 
        j = sprintf(ptr + (unsigned long)j,
                (char *)"Key %d set with length = %d\n",(int)wkr.kindex,
                (int)wkr.klen) + j;
      }
      #line 5328 
      readWepKeyRid(ai,& wkr,0,1);
      #line 5329 
      if (! ((int)wkr.kindex != (int)lastindex && j <= 149)) 
                                                             #line 5318 
                                                             break;
    }
  #line 5331 
  data->readlen = (int)cif_strlen(data->rbuffer);
  #line 5332 
  return 0;
}

#line 5335  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int proc_SSID_open(struct inode *inode, struct file *file)
{
  #line 5337 
  struct proc_data *data;
  #line 5340 
  int i;
  #line 5341 
  char *ptr;
  #line 5342 
  SsidRid SSID_rid;
  #line 5338 
  struct net_device *dev = PDE_DATA(inode);
  #line 5339 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5344 
  file->private_data = kzalloc(40UL,3264U);
  #line 5344 
  if (kzalloc(40UL,3264U) == (void *)0) 
                                        #line 5345 
                                        return -12;
  #line 5346 
  data = (struct proc_data *)file->private_data;
  #line 5347 
  data->rbuffer = (char *)kmalloc(104UL,3264U);
  #line 5347 
  if ((char *)kmalloc(104UL,3264U) == (char *)0) {
    #line 5348 
    kfree(file->private_data);
    #line 5349 
    return -12;
  }
  #line 5351 
  data->writelen = 0;
  #line 5352 
  data->maxwritelen = 99;
  #line 5354 
  data->wbuffer = (char *)kzalloc(100UL,3264U);
  #line 5354 
  if ((char *)kzalloc(100UL,3264U) == (char *)0) {
    #line 5355 
    kfree((void *)data->rbuffer);
    #line 5356 
    kfree(file->private_data);
    #line 5357 
    return -12;
  }
  #line 5359 
  data->on_close = & proc_SSID_on_close;
  #line 5361 
  readSsidRid(ai,& SSID_rid);
  #line 5362 
  ptr = data->rbuffer;
  #line 5363 
  i = 0;
  #line 5363 
  while (i <= 2) {
    {
      #line 5364 
      int j;
      #line 5372 
      char *tmp_6;
      #line 5365 
      size_t len = (unsigned long)SSID_rid.ssids[i].len;
      #line 5366 
      if (len == 0UL) 
                      #line 5367 
                      break;
      #line 5368 
      if (len > 32UL) 
                      #line 5369 
                      len = 32UL;
      #line 5370 
      j = 0;
      #line 5370 
      while ((unsigned long)j < len && (unsigned int)SSID_rid.ssids[i].ssid[j] != 0U) {
        #line 5371 
        char *tmp_5;
        #line 5371 
        tmp_5 = ptr;
        #line 5371 
        ptr ++;
        #line 5371 
        *tmp_5 = (char)SSID_rid.ssids[i].ssid[j];
        #line 5370 
        j ++;
      }
      #line 5372 
      tmp_6 = ptr;
      #line 5372 
      ptr ++;
      #line 5372 
      *tmp_6 = (char)10;
    }
    #line 5363 
    i ++;
  }
  #line 5374 
  *ptr = (char)0;
  #line 5375 
  data->readlen = (int)cif_strlen(data->rbuffer);
  #line 5376 
  return 0;
}

#line 5379  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int proc_APList_open(struct inode *inode, struct file *file)
{
  #line 5380 
  struct proc_data *data;
  #line 5383 
  int i;
  #line 5384 
  char *ptr;
  #line 5381 
  struct net_device *dev = PDE_DATA(inode);
  #line 5382 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5385 
  APListRid *APList_rid = & ai->APList;
  #line 5387 
  file->private_data = kzalloc(40UL,3264U);
  #line 5387 
  if (kzalloc(40UL,3264U) == (void *)0) 
                                        #line 5388 
                                        return -12;
  #line 5389 
  data = (struct proc_data *)file->private_data;
  #line 5390 
  data->rbuffer = (char *)kmalloc(104UL,3264U);
  #line 5390 
  if ((char *)kmalloc(104UL,3264U) == (char *)0) {
    #line 5391 
    kfree(file->private_data);
    #line 5392 
    return -12;
  }
  #line 5394 
  data->writelen = 0;
  #line 5395 
  data->maxwritelen = 72;
  #line 5396 
  data->wbuffer = (char *)kzalloc((unsigned long)data->maxwritelen,3264U);
  #line 5396 
  if ((char *)kzalloc((unsigned long)data->maxwritelen,3264U) == (char *)0) {
    #line 5397 
    kfree((void *)data->rbuffer);
    #line 5398 
    kfree(file->private_data);
    #line 5399 
    return -12;
  }
  #line 5401 
  data->on_close = & proc_APList_on_close;
  #line 5403 
  ptr = data->rbuffer;
  #line 5404 
  i = 0;
  #line 5404 
  while (i <= 3) {
    {
      #line 5406 
      if (*((int *)(& APList_rid->ap[i])) == 0 && *((int *)(& APList_rid->ap[i][2])) == 0) 
        #line 5407 
        break;
      #line 5408 
      ptr += (unsigned long)sprintf(ptr,(char *)"%pM\n",(u8 *)(& APList_rid->ap[i]));
    }
    #line 5404 
    i ++;
  }
  #line 5410 
  if (i == 0) {
    #line 5410 
    ptr += (unsigned long)sprintf(ptr,(char *)"Not using specific APs\n");
  }
  #line 5412 
  *ptr = (char)0;
  #line 5413 
  data->readlen = (int)cif_strlen(data->rbuffer);
  #line 5414 
  return 0;
}

#line 5417  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int proc_BSSList_open(struct inode *inode, struct file *file)
{
  #line 5418 
  struct proc_data *data;
  #line 5421 
  char *ptr;
  #line 5422 
  BSSListRid BSSList_rid;
  #line 5423 
  int rc;
  #line 5419 
  struct net_device *dev = PDE_DATA(inode);
  #line 5420 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5425 
  int doLoseSync = -1;
  #line 5427 
  file->private_data = kzalloc(40UL,3264U);
  #line 5427 
  if (kzalloc(40UL,3264U) == (void *)0) 
                                        #line 5428 
                                        return -12;
  #line 5429 
  data = (struct proc_data *)file->private_data;
  #line 5430 
  data->rbuffer = (char *)kmalloc(1024UL,3264U);
  #line 5430 
  if ((char *)kmalloc(1024UL,3264U) == (char *)0) {
    #line 5431 
    kfree(file->private_data);
    #line 5432 
    return -12;
  }
  #line 5434 
  data->writelen = 0;
  #line 5435 
  data->maxwritelen = 0;
  #line 5436 
  data->wbuffer = (char *)0;
  #line 5437 
  data->on_close = (void (*)(struct inode *, struct file *))0;
  #line 5439 
  if ((file->f_mode & 2U) != 0U) {
    #line 5440 
    if ((file->f_mode & 1U) == 0U) {
      #line 5441 
      Cmd cmd;
      #line 5442 
      Resp rsp;
      #line 5444 
      if ((ai->flags & 3UL) != 0UL) {
        #line 5445 
        kfree((void *)data->rbuffer);
        #line 5446 
        kfree(file->private_data);
        #line 5447 
        return -100;
      }
      #line 5449 
      memset((void *)(& cmd),0,8UL);
      #line 5450 
      cmd.cmd = (unsigned short)259U;
      #line 5451 
      if (down_interruptible(& ai->sem) != 0) {
        #line 5452 
        kfree((void *)data->rbuffer);
        #line 5453 
        kfree(file->private_data);
        #line 5454 
        return -512;
      }
      #line 5456 
      issuecommand(ai,& cmd,& rsp);
      #line 5457 
      up(& ai->sem);
      #line 5458 
      data->readlen = 0;
      #line 5459 
      return 0;
    }
    #line 5461 
    doLoseSync = 1;
  }
  #line 5463 
  ptr = data->rbuffer;
  #line 5467 
  rc = readBSSListRid(ai,doLoseSync,& BSSList_rid);
  #line 5468 
  while (rc == 0 && (unsigned int)BSSList_rid.index != 65535U) {
    #line 5478 
    char *tmp_5;
    #line 5477 
    char *tmp_6;
    #line 5476 
    char *tmp_7;
    #line 5475 
    char *tmp_8;
    #line 5473 
    ptr += (unsigned long)sprintf(ptr,(char *)"%pM %.*s rssi = %d",(u8 *)(& BSSList_rid.bssid),
                (int)BSSList_rid.ssidLen,(u8 *)(& BSSList_rid.ssid),
                (int)BSSList_rid.dBm);
    #line 5478 
    if (((int)BSSList_rid.cap & 32) != 0) 
                                          #line 5478 
                                          tmp_5 = (char *)"shorthdr"; else 
                                                                    #line 5478 
                                                                    tmp_5 = (char *)"";
    #line 5477 
    if (((int)BSSList_rid.cap & 16) != 0) 
                                          #line 5477 
                                          tmp_6 = (char *)"wep"; else 
                                                                   #line 5477 
                                                                   tmp_6 = (char *)"";
    #line 5476 
    if (((int)BSSList_rid.cap & 2) != 0) 
                                         #line 5476 
                                         tmp_7 = (char *)"adhoc"; else 
                                                                    #line 5476 
                                                                    tmp_7 = (char *)"";
    #line 5475 
    if (((int)BSSList_rid.cap & 1) != 0) 
                                         #line 5475 
                                         tmp_8 = (char *)"ESS"; else 
                                                                  #line 5475 
                                                                  tmp_8 = (char *)"";
    #line 5474 
    ;
    #line 5479 
    ptr += (unsigned long)sprintf(ptr,(char *)" channel = %d %s %s %s %s\n",
                (int)BSSList_rid.dsChannel,tmp_8,tmp_7,tmp_6,tmp_5);
    #line 5480 
    rc = readBSSListRid(ai,0,& BSSList_rid);
  }
  #line 5482 
  *ptr = (char)0;
  #line 5483 
  data->readlen = (int)cif_strlen(data->rbuffer);
  #line 5484 
  return 0;
}

#line 5487  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int proc_close(struct inode *inode, struct file *file)
{
  #line 5489 
  struct proc_data *data = (struct proc_data *)file->private_data;
  #line 5491 
  if (data->on_close != (void (*)(struct inode *, struct file *))0) 
                                                                    #line 5492 
                                                                    (*(data->on_close))(inode,file);
  #line 5493 
  kfree((void *)data->rbuffer);
  #line 5494 
  kfree((void *)data->wbuffer);
  #line 5495 
  kfree((void *)data);
  #line 5496 
  return 0;
}

#line 5504  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void timer_func(struct net_device *dev)
{
  #line 5505 
  struct airo_info *apriv = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5508 
  readConfigRid(apriv,0);
  #line 5509 
  disable_MAC(apriv,0);
  #line 5510 
  switch ((int)apriv->config.authType) {
    #line 5511 
    case 257: 
              #line 5511 
    ;
    #line 5513 
    apriv->config.authType = (unsigned short)1U;
    #line 5514 
    break;
    #line 5515 
    case 258: 
              #line 5515 
    ;
    #line 5516 
    if ((int)apriv->keyindex < auto_wep) {
      #line 5517 
      set_wep_tx_idx(apriv,(unsigned short)((int)((unsigned short)apriv->keyindex)),0,0);
      #line 5518 
      apriv->config.authType = (unsigned short)258U;
      #line 5519 
      apriv->keyindex = (char)((int)apriv->keyindex + 1);
    }
    else {
      #line 5522 
      apriv->keyindex = (char)0;
      #line 5523 
      set_wep_tx_idx(apriv,(unsigned short)((int)((unsigned short)apriv->defindex)),0,0);
      #line 5524 
      apriv->config.authType = (unsigned short)257U;
    }
    #line 5526 
    break;
    #line 5527 
    default: 
             #line 5527 
    ;
    #line 5528 
    apriv->config.authType = (unsigned short)258U;
  }
  #line 5530 
  cif_set_bit(13L,& apriv->flags);
  #line 5531 
  writeConfigRid(apriv,0);
  #line 5532 
  enable_MAC(apriv,0);
  #line 5533 
  up(& apriv->sem);
  #line 5536 
  cif_clear_bit(7L,& apriv->jobs);
  #line 5537 
  apriv->expires = jiffies + 750UL;
  #line 5538 
  return;
}

#line 5541  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_pci_probe(struct pci_dev *pdev, struct pci_device_id *pent)
{
  #line 5544 
  struct net_device *dev;
  #line 5546 
  if (pci_enable_device(pdev) != 0) 
                                    #line 5547 
                                    return -19;
  #line 5548 
  pci_set_master(pdev);
  #line 5550 
  if ((unsigned int)pdev->device == 20480U || (unsigned int)pdev->device == 42244U) 
    #line 5551 
    dev = _init_airo_card((unsigned short)((int)((unsigned short)pdev->irq)),(int)pdev->resource[0].start,0,pdev,& pdev->dev); else 
                                                                    #line 5553 
                                                                    dev = _init_airo_card((unsigned short)((int)((unsigned short)pdev->irq)),(int)pdev->resource[2].start,0,pdev,& pdev->dev);
  #line 5554 
  if (dev == (struct net_device *)0) {
    #line 5555 
    pci_disable_device(pdev);
    #line 5556 
    return -19;
  }
  #line 5559 
  pci_set_drvdata(pdev,(void *)dev);
  #line 5560 
  return 0;
}

#line 5563  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_pci_remove(struct pci_dev *pdev)
{
  #line 5565 
  struct net_device *dev = pci_get_drvdata(pdev);
  #line 5567 
  printk((char *)"\001",(char *)(& dev->name));
  #line 5568 
  stop_airo_card(dev,1);
  #line 5569 
  pci_disable_device(pdev);
  #line 5570 
  return;
}

#line 5572  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_pci_suspend(struct pci_dev *pdev, pm_message_t state)
{
  #line 5576 
  Cmd cmd;
  #line 5577 
  Resp rsp;
  #line 5574 
  struct net_device *dev = pci_get_drvdata(pdev);
  #line 5575 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5579 
  if (ai->SSID == (SsidRid *)0) 
                                #line 5580 
                                ai->SSID = (SsidRid *)kmalloc(104UL,3264U);
  #line 5581 
  if (ai->SSID == (SsidRid *)0) 
                                #line 5582 
                                return -12;
  #line 5583 
  readSsidRid(ai,ai->SSID);
  #line 5584 
  memset((void *)(& cmd),0,8UL);
  #line 5586 
  if (down_interruptible(& ai->sem) != 0) 
                                          #line 5587 
                                          return -11;
  #line 5588 
  disable_MAC(ai,0);
  #line 5589 
  netif_device_detach(dev);
  #line 5590 
  ai->power = state;
  #line 5591 
  cmd.cmd = (unsigned short)5U;
  #line 5592 
  issuecommand(ai,& cmd,& rsp);
  #line 5594 
  ;
  #line 5594 
  pci_enable_wake(pdev,pci_choose_state(pdev,state),(_Bool)1);
  #line 5595 
  pci_save_state(pdev);
  #line 5596 
  ;
  #line 5596 
  pci_set_power_state(pdev,pci_choose_state(pdev,state));
  #line 5597 
  return 0;
}

#line 5600  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_pci_resume(struct pci_dev *pdev)
{
  #line 5602 
  struct net_device *dev = pci_get_drvdata(pdev);
  #line 5603 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5604 
  pci_power_t prev_state = pdev->current_state;
  #line 5606 
  pci_set_power_state(pdev,0);
  #line 5607 
  pci_restore_state(pdev);
  #line 5608 
  pci_enable_wake(pdev,0,(_Bool)0);
  #line 5610 
  if (prev_state != 1) {
    #line 5611 
    reset_card(dev,0);
    #line 5612 
    mpi_init_descriptors(ai);
    #line 5613 
    setup_card(ai,dev->dev_addr,0);
    #line 5614 
    cif_clear_bit(0L,& ai->flags);
    #line 5615 
    cif_clear_bit(9L,& ai->flags);
  }
  else {
    #line 5617 
    OUT4500(ai,(unsigned short)52,(unsigned short)8192);
    #line 5618 
    OUT4500(ai,(unsigned short)52,(unsigned short)8192);
    #line 5619 
    msleep(100U);
  }
  #line 5622 
  cif_set_bit(13L,& ai->flags);
  #line 5623 
  disable_MAC(ai,0);
  #line 5624 
  msleep(200U);
  #line 5625 
  if (ai->SSID != (SsidRid *)0) {
    #line 5626 
    writeSsidRid(ai,ai->SSID,0);
    #line 5627 
    kfree((void *)ai->SSID);
    #line 5628 
    ai->SSID = (SsidRid *)0;
  }
  #line 5630 
  writeAPListRid(ai,& ai->APList,0);
  #line 5631 
  writeConfigRid(ai,0);
  #line 5632 
  enable_MAC(ai,0);
  #line 5633 
  struct pm_message __constr_expr_34 = {.event = 0};
  #line 5633 
  ai->power = __constr_expr_34;
  #line 5634 
  netif_device_attach(dev);
  #line 5635 
  netif_wake_queue(dev);
  #line 5636 
  enable_interrupts(ai);
  #line 5637 
  up(& ai->sem);
  #line 5638 
  return 0;
}

#line 5642  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_init_module(void)
{
  #line 5644 
  int i;
  #line 5646 
  proc_kuid = make_kuid(& init_user_ns,(unsigned int)proc_uid);
  #line 5647 
  proc_kgid = make_kgid(& init_user_ns,(unsigned int)proc_gid);
  #line 5648 
  if (uid_valid(proc_kuid)) {
    #line 5648 
    if (! gid_valid(proc_kgid)) 
                                #line 5649 
                                return -22;
  }
  else 
       #line 5649 
       return -22;
  #line 5651 
  airo_entry = proc_mkdir_mode((char *)"driver/aironet",(unsigned short)((int)((unsigned short)airo_perm)),(struct proc_dir_entry *)0);
  #line 5653 
  if (airo_entry != (struct proc_dir_entry *)0) 
                                                #line 5654 
                                                proc_set_user(airo_entry,proc_kuid,proc_kgid);
  #line 5656 
  i = 0;
  #line 5656 
  while ((i <= 3 && io[i] != 0) && irq[i] != 0) {
    {
      #line 5659 
      struct net_device *tmp_1;
      #line 5657 
      printk((char *)"\001",(char *)"",irq[i],io[i]);
      #line 5659 
      tmp_1 = init_airo_card((unsigned short)((int)((unsigned short)irq[i])),io[i],0,(struct device *)0);
    }
    #line 5656 
    i ++;
  }
  #line 5664 
  printk((char *)"\001",(char *)"");
  #line 5665 
  i = cif___pci_register_driver(& airo_driver,& __this_module,(char *)"airo");
  #line 5666 
  printk((char *)"\001",(char *)"");
  #line 5668 
  if (i != 0) {
    #line 5669 
    remove_proc_entry((char *)"driver/aironet",(struct proc_dir_entry *)0);
    #line 5670 
    return i;
  }
  #line 5677 
  return 0;
}

#line 5680  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_cleanup_module(void)
{
  #line 5682 
  struct airo_info *ai;
  #line 5683 
  while (1) {
    #line 5683 
    if (! (list_empty(& airo_devices) == 0)) 
                                             #line 5683 
                                             break;
    {
      #line 5684 
      void *__mptr;
      #line 5684 
      __mptr = (void *)airo_devices.next;
      #line 5684 
      ai = ((struct airo_info *)(__mptr + 18446744073709551608U));
      #line 5685 
      printk((char *)"\001",(char *)(& (ai->dev)->name));
      #line 5686 
      stop_airo_card(ai->dev,1);
    }
  }
  #line 5689 
  cif_pci_unregister_driver(& airo_driver);
  #line 5691 
  remove_proc_entry((char *)"driver/aironet",(struct proc_dir_entry *)0);
  #line 5692 
  return;
}

#line 5704  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static u8 airo_rssi_to_dbm(tdsRssiEntry *rssi_rid, u8 rssi)
{
  #line 5706 
  if (rssi_rid == (tdsRssiEntry *)0) 
                                     #line 5707 
                                     return (unsigned char)0U;
  #line 5709 
  return (unsigned char)(- ((int)(rssi_rid + (unsigned long)rssi)->rssidBm));
}

#line 5712  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static u8 airo_dbm_to_pct(tdsRssiEntry *rssi_rid, u8 dbm)
{
  #line 5714 
  int i;
  #line 5716 
  if (rssi_rid == (tdsRssiEntry *)0) 
                                     #line 5717 
                                     return (unsigned char)0U;
  #line 5719 
  i = 0;
  #line 5719 
  while (i <= 255) {
    #line 5720 
    if ((int)(rssi_rid + (unsigned long)i)->rssidBm == (int)dbm) 
                                                                 #line 5721 
                                                                 return (rssi_rid + (unsigned long)i)->rssipct;
    #line 5719 
    i ++;
  }
  #line 5723 
  return (unsigned char)0U;
}

#line 5727  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_quality(StatusRid *status_rid, CapabilityRid *cap_rid)
{
  #line 5730 
  u16 sq;
  #line 5729 
  int quality = 0;
  #line 5732 
  if (((int)status_rid->mode & 63) != 63) 
                                          #line 5733 
                                          return 0;
  #line 5735 
  if (((int)cap_rid->hardCap & 8) == 0) 
                                        #line 5736 
                                        return 0;
  #line 5738 
  sq = status_rid->signalQuality;
  #line 5739 
  if (memcmp((void *)(& cap_rid->prodName),(void *)"350",3UL) != 0) 
    #line 5740 
    if ((unsigned int)sq > 32U) 
                                #line 5741 
                                quality = 0; else 
                                                  #line 5743 
                                                  quality = 32 - (int)sq;
  else 
    #line 5745 
    if ((unsigned int)sq > 176U) 
                                 #line 5746 
                                 quality = 0;
    else 
      #line 5747 
      if ((unsigned int)sq <= 15U) 
                                   #line 5748 
                                   quality = 160; else 
                                                       #line 5750 
                                                       quality = 176 - (int)sq;
  #line 5751 
  return quality;
}

#line 5761  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_name(struct net_device *dev, struct iw_request_info *info, char *cwrq, char *extra)
{
  #line 5766 
  strcpy(cwrq,(char *)"IEEE 802.11-DS");
  #line 5767 
  return 0;
}

#line 5774  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_freq(struct net_device *dev, struct iw_request_info *info, struct iw_freq *fwrq, char *extra)
{
  #line 5779 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5780 
  int rc = -115;
  #line 5783 
  if ((int)fwrq->e == 1) {
    #line 5784 
    int f = fwrq->m / 100000;
    #line 5787 
    fwrq->e = (short)0;
    #line 5788 
    fwrq->m = ieee80211_frequency_to_channel(f);
  }
  #line 5791 
  if ((unsigned int)fwrq->m > 1000U || (int)fwrq->e > 0) 
                                                         #line 5792 
                                                         rc = -95;
  else {
    #line 5794 
    int channel = fwrq->m;
    #line 5797 
    if ((unsigned int)channel + 4294967295U > 13U) {
      #line 5798 
      printk((char *)"\001",(char *)(& dev->name),fwrq->m);
      #line 5800 
      rc = -22;
    }
    else {
      #line 5802 
      readConfigRid(local,1);
      #line 5804 
      local->config.channelSet = (unsigned short)channel;
      #line 5805 
      cif_set_bit(13L,& local->flags);
    }
  }
  #line 5808 
  return rc;
}

#line 5815  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_freq(struct net_device *dev, struct iw_request_info *info, struct iw_freq *fwrq, char *extra)
{
  #line 5821 
  StatusRid status_rid;
  #line 5822 
  int ch;
  #line 5820 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5824 
  readConfigRid(local,1);
  #line 5825 
  if (((int)local->config.opmode & 255) == 1) 
                                              #line 5826 
                                              status_rid.channel = local->config.channelSet; else 
                                                                    #line 5828 
                                                                    readStatusRid(local,& status_rid,1);
  #line 5830 
  ch = (int)status_rid.channel;
  #line 5831 
  if ((unsigned int)ch + 4294967295U <= 13U) {
    #line 5832 
    fwrq->m = ieee80211_channel_to_frequency(ch,(enum nl80211_band)NL80211_BAND_2GHZ) * 100000;
    #line 5834 
    fwrq->e = (short)1;
  }
  else {
    #line 5836 
    fwrq->m = ch;
    #line 5837 
    fwrq->e = (short)0;
  }
  #line 5840 
  return 0;
}

#line 5847  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_essid(struct net_device *dev, struct iw_request_info *info, struct iw_point *dwrq, char *extra)
{
  #line 5853 
  SsidRid SSID_rid;
  #line 5852 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5856 
  readSsidRid(local,& SSID_rid);
  #line 5859 
  if ((unsigned int)dwrq->flags == 0U) 
                                       #line 5861 
                                       memset((void *)(& SSID_rid),0,104UL);
  else {
    #line 5863 
    unsigned int index = (unsigned int)(((int)dwrq->flags & 255) + -1);
    #line 5866 
    if ((unsigned int)dwrq->length > 32U) 
                                          #line 5867 
                                          return -7;
    #line 5870 
    if (index > 2U) 
                    #line 5871 
                    return -22;
    #line 5874 
    memset((void *)(& SSID_rid.ssids[index].ssid),0,32UL);
    #line 5876 
    memcpy((void *)(& SSID_rid.ssids[index].ssid),(void *)extra,(unsigned long)dwrq->length);
    #line 5877 
    SSID_rid.ssids[index].len = dwrq->length;
  }
  #line 5879 
  SSID_rid.len = (unsigned short)104U;
  #line 5881 
  disable_MAC(local,1);
  #line 5882 
  writeSsidRid(local,& SSID_rid,1);
  #line 5883 
  enable_MAC(local,1);
  #line 5885 
  return 0;
}

#line 5892  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_essid(struct net_device *dev, struct iw_request_info *info, struct iw_point *dwrq, char *extra)
{
  #line 5898 
  StatusRid status_rid;
  #line 5897 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5900 
  readStatusRid(local,& status_rid,1);
  #line 5906 
  memcpy((void *)extra,(void *)(& status_rid.SSID),(unsigned long)status_rid.SSIDlen);
  #line 5910 
  dwrq->length = status_rid.SSIDlen;
  #line 5911 
  dwrq->flags = (unsigned short)1U;
  #line 5913 
  return 0;
}

#line 5920  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_wap(struct net_device *dev, struct iw_request_info *info, struct sockaddr *awrq, char *extra)
{
  #line 5926 
  Cmd cmd;
  #line 5927 
  Resp rsp;
  #line 5925 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5928 
  APListRid *APList_rid = & local->APList;
  #line 5930 
  if ((unsigned int)awrq->sa_family != 1U) 
                                           #line 5931 
                                           return -22;
  else {
    #line 5932 
    if ((int)is_broadcast_ether_addr((u8 *)(& awrq->sa_data)) != 0) 
                                                                    #line 5932 
                                                                    goto _LOR;
    else {
      #line 5932 
      if ((int)is_zero_ether_addr((u8 *)(& awrq->sa_data)) != 0) {
        #line 5932 
        _LOR: {
                #line 5934 
                memset((void *)(& cmd),0,8UL);
                #line 5935 
                cmd.cmd = (unsigned short)3U;
                #line 5936 
                if (down_interruptible(& local->sem) != 0) 
                                                           #line 5937 
                                                           return -512;
                #line 5938 
                issuecommand(local,& cmd,& rsp);
                #line 5939 
                up(& local->sem);
              }
      }
      else {
        #line 5941 
        memset((void *)APList_rid,0,26UL);
        #line 5942 
        APList_rid->len = (unsigned short)26U;
        #line 5943 
        memcpy((void *)(& APList_rid->ap[0]),(void *)(& awrq->sa_data),6UL);
        #line 5944 
        disable_MAC(local,1);
        #line 5945 
        writeAPListRid(local,APList_rid,1);
        #line 5946 
        enable_MAC(local,1);
      }
    }
  }
  #line 5948 
  return 0;
}

#line 5955  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_wap(struct net_device *dev, struct iw_request_info *info, struct sockaddr *awrq, char *extra)
{
  #line 5961 
  StatusRid status_rid;
  #line 5960 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5963 
  readStatusRid(local,& status_rid,1);
  #line 5966 
  memcpy((void *)(& awrq->sa_data),(void *)(& status_rid.bssid[0]),6UL);
  #line 5967 
  awrq->sa_family = (unsigned short)1U;
  #line 5969 
  return 0;
}

#line 5976  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_nick(struct net_device *dev, struct iw_request_info *info, struct iw_point *dwrq, char *extra)
{
  #line 5981 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 5984 
  if ((unsigned int)dwrq->length > 16U) 
                                        #line 5985 
                                        return -7;
  #line 5987 
  readConfigRid(local,1);
  #line 5988 
  memset((void *)(& local->config.nodeName),0,16UL);
  #line 5989 
  memcpy((void *)(& local->config.nodeName),(void *)extra,(unsigned long)dwrq->length);
  #line 5990 
  cif_set_bit(13L,& local->flags);
  #line 5992 
  return -115;
}

#line 5999  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_nick(struct net_device *dev, struct iw_request_info *info, struct iw_point *dwrq, char *extra)
{
  #line 6004 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6006 
  readConfigRid(local,1);
  #line 6007 
  strncpy(extra,(char *)(& local->config.nodeName),16UL);
  #line 6008 
  *(extra + 16U) = (char)0;
  #line 6009 
  dwrq->length = (unsigned short)cif_strlen(extra);
  #line 6011 
  return 0;
}

#line 6018  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_rate(struct net_device *dev, struct iw_request_info *info, struct iw_param *vwrq, char *extra)
{
  #line 6024 
  CapabilityRid cap_rid;
  #line 6026 
  int i;
  #line 6023 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6025 
  u8 brate = (unsigned char)0U;
  #line 6029 
  readCapabilityRid(local,& cap_rid,1);
  #line 6032 
  if ((unsigned int)vwrq->value <= 7U) 
                                       #line 6035 
                                       brate = (unsigned char)cap_rid.supportedRates[vwrq->value];
  else {
    #line 6038 
    u8 normvalue = (unsigned char)(vwrq->value / 500000);
    #line 6041 
    i = 0;
    #line 6041 
    while (i <= 7) {
      #line 6042 
      if ((int)normvalue == (int)cap_rid.supportedRates[i]) {
        #line 6043 
        brate = normvalue;
        #line 6044 
        break;
      }
      #line 6041 
      i ++;
    }
  }
  #line 6049 
  if (vwrq->value == -1) {
    #line 6051 
    i = 0;
    #line 6051 
    while (i <= 7) {
      #line 6052 
      if ((int)cap_rid.supportedRates[i] == 0) 
                                               #line 6053 
                                               break;
      #line 6051 
      i ++;
    }
    #line 6055 
    if (i != 0) 
                #line 6056 
                brate = (unsigned char)cap_rid.supportedRates[i + -1];
  }
  #line 6059 
  if ((unsigned int)brate == 0U) 
                                 #line 6060 
                                 return -22;
  #line 6063 
  readConfigRid(local,1);
  #line 6065 
  if ((unsigned int)vwrq->fixed == 0U) {
    #line 6067 
    memset((void *)(& local->config.rates),0,8UL);
    #line 6068 
    i = 0;
    #line 6068 
    while (i <= 7) {
      #line 6069 
      local->config.rates[i] = (unsigned char)cap_rid.supportedRates[i];
      #line 6070 
      if ((int)local->config.rates[i] == (int)brate) 
                                                     #line 6071 
                                                     break;
      #line 6068 
      i ++;
    }
  }
  else {
    #line 6076 
    memset((void *)(& local->config.rates),0,8UL);
    #line 6077 
    local->config.rates[0] = brate;
  }
  #line 6079 
  cif_set_bit(13L,& local->flags);
  #line 6081 
  return -115;
}

#line 6088  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_rate(struct net_device *dev, struct iw_request_info *info, struct iw_param *vwrq, char *extra)
{
  #line 6094 
  StatusRid status_rid;
  #line 6093 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6096 
  readStatusRid(local,& status_rid,1);
  #line 6098 
  vwrq->value = (int)status_rid.currentXmitRate * 500000;
  #line 6100 
  readConfigRid(local,1);
  #line 6101 
  vwrq->fixed = (unsigned char)((unsigned int)local->config.rates[1] == 0U);
  #line 6103 
  return 0;
}

#line 6110  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_rts(struct net_device *dev, struct iw_request_info *info, struct iw_param *vwrq, char *extra)
{
  #line 6115 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6116 
  int rthr = vwrq->value;
  #line 6118 
  if ((unsigned int)vwrq->disabled != 0U) 
                                          #line 6119 
                                          rthr = 2312;
  #line 6120 
  if ((unsigned int)rthr > 2312U) 
                                  #line 6121 
                                  return -22;
  #line 6123 
  readConfigRid(local,1);
  #line 6124 
  local->config.rtsThres = (unsigned short)rthr;
  #line 6125 
  cif_set_bit(13L,& local->flags);
  #line 6127 
  return -115;
}

#line 6134  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_rts(struct net_device *dev, struct iw_request_info *info, struct iw_param *vwrq, char *extra)
{
  #line 6139 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6141 
  readConfigRid(local,1);
  #line 6142 
  vwrq->value = (int)local->config.rtsThres;
  #line 6143 
  vwrq->disabled = (unsigned char)(vwrq->value > 2311);
  #line 6144 
  vwrq->fixed = (unsigned char)1U;
  #line 6146 
  return 0;
}

#line 6153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_frag(struct net_device *dev, struct iw_request_info *info, struct iw_param *vwrq, char *extra)
{
  #line 6158 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6159 
  int fthr = vwrq->value;
  #line 6161 
  if ((unsigned int)vwrq->disabled != 0U) 
                                          #line 6162 
                                          fthr = 2312;
  #line 6163 
  if ((unsigned int)fthr + 4294967040U > 2056U) 
                                                #line 6164 
                                                return -22;
  #line 6166 
  fthr &= -2;
  #line 6167 
  readConfigRid(local,1);
  #line 6168 
  local->config.fragThresh = (unsigned short)fthr;
  #line 6169 
  cif_set_bit(13L,& local->flags);
  #line 6171 
  return -115;
}

#line 6178  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_frag(struct net_device *dev, struct iw_request_info *info, struct iw_param *vwrq, char *extra)
{
  #line 6183 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6185 
  readConfigRid(local,1);
  #line 6186 
  vwrq->value = (int)local->config.fragThresh;
  #line 6187 
  vwrq->disabled = (unsigned char)(vwrq->value > 2311);
  #line 6188 
  vwrq->fixed = (unsigned char)1U;
  #line 6190 
  return 0;
}

#line 6197  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_mode(struct net_device *dev, struct iw_request_info *info, __u32 *uwrq, char *extra)
{
  #line 6202 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6203 
  int reset = 0;
  #line 6205 
  readConfigRid(local,1);
  #line 6206 
  if (sniffing_mode(local) != 0) 
                                 #line 6207 
                                 reset = 1;
  #line 6209 
  switch (*uwrq) {
    #line 6210 
    case (__u32)1: 
                   #line 6210 
    ;
    #line 6211 
    local->config.opmode = (unsigned short)((unsigned int)local->config.opmode & 65280U);
    #line 6212 
    local->config.opmode = local->config.opmode;
    #line 6213 
    local->config.rmode = (unsigned short)((unsigned int)local->config.rmode & 65024U);
    #line 6214 
    local->config.scanMode = (unsigned short)0U;
    #line 6215 
    cif_clear_bit(7L,& local->flags);
    #line 6216 
    break;
    #line 6217 
    case (__u32)2: 
                   #line 6217 
    ;
    #line 6218 
    local->config.opmode = (unsigned short)((unsigned int)local->config.opmode & 65280U);
    #line 6219 
    local->config.opmode = (unsigned short)((unsigned int)local->config.opmode | 1U);
    #line 6220 
    local->config.rmode = (unsigned short)((unsigned int)local->config.rmode & 65024U);
    #line 6221 
    local->config.scanMode = (unsigned short)0U;
    #line 6222 
    cif_clear_bit(7L,& local->flags);
    #line 6223 
    break;
    #line 6224 
    case (__u32)3: 
                   #line 6224 
    ;
    #line 6225 
    local->config.opmode = (unsigned short)((unsigned int)local->config.opmode & 65280U);
    #line 6226 
    local->config.opmode = (unsigned short)((unsigned int)local->config.opmode | 2U);
    #line 6227 
    local->config.rmode = (unsigned short)((unsigned int)local->config.rmode & 65024U);
    #line 6228 
    local->config.scanMode = (unsigned short)0U;
    #line 6229 
    cif_clear_bit(7L,& local->flags);
    #line 6230 
    break;
    #line 6231 
    case (__u32)4: 
                   #line 6231 
    ;
    #line 6232 
    local->config.opmode = (unsigned short)((unsigned int)local->config.opmode & 65280U);
    #line 6233 
    local->config.opmode = (unsigned short)((unsigned int)local->config.opmode | 3U);
    #line 6234 
    local->config.rmode = (unsigned short)((unsigned int)local->config.rmode & 65024U);
    #line 6235 
    local->config.scanMode = (unsigned short)0U;
    #line 6236 
    cif_clear_bit(7L,& local->flags);
    #line 6237 
    break;
    #line 6238 
    case (__u32)6: 
                   #line 6238 
    ;
    #line 6239 
    local->config.opmode = (unsigned short)((unsigned int)local->config.opmode & 65280U);
    #line 6240 
    local->config.opmode = (unsigned short)((unsigned int)local->config.opmode | 1U);
    #line 6241 
    local->config.rmode = (unsigned short)((unsigned int)local->config.rmode & 65024U);
    #line 6242 
    local->config.rmode = (unsigned short)((unsigned int)local->config.rmode | 259U);
    #line 6243 
    local->config.scanMode = (unsigned short)1U;
    #line 6244 
    cif_set_bit(7L,& local->flags);
    #line 6245 
    break;
    #line 6246 
    default: 
             #line 6246 
    ;
    #line 6247 
    return -22;
  }
  #line 6249 
  if (reset != 0) 
                  #line 6250 
                  cif_set_bit(14L,& local->flags);
  #line 6251 
  cif_set_bit(13L,& local->flags);
  #line 6253 
  return -115;
}

#line 6260  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_mode(struct net_device *dev, struct iw_request_info *info, __u32 *uwrq, char *extra)
{
  #line 6265 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6267 
  readConfigRid(local,1);
  #line 6269 
  switch ((int)local->config.opmode & 255) {
    #line 6270 
    case 1: 
            #line 6270 
    ;
    #line 6271 
    *uwrq = 2U;
    #line 6272 
    break;
    #line 6273 
    case 2: 
            #line 6273 
    ;
    #line 6274 
    *uwrq = 3U;
    #line 6275 
    break;
    #line 6276 
    case 3: 
            #line 6276 
    ;
    #line 6277 
    *uwrq = 4U;
    #line 6278 
    break;
    #line 6279 
    default: 
             #line 6279 
    ;
    #line 6280 
    *uwrq = 1U;
  }
  #line 6283 
  return 0;
}

#line 6286  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
__inline static int valid_index(struct airo_info *ai, int index)
{
  #line 6288 
  return (index >= 0 && ai->max_wep_idx >= index) != 0;
}

#line 6295  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_encode(struct net_device *dev, struct iw_request_info *info, struct iw_point *dwrq, char *extra)
{
  #line 6300 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6301 
  int perm = ((int)dwrq->flags & 1024) == 0;
  #line 6302 
  __le16 currentAuthType = local->config.authType;
  #line 6303 
  int rc = 0;
  #line 6305 
  if (local->wep_capable == 0) 
                               #line 6306 
                               return -95;
  #line 6308 
  readConfigRid(local,1);
  #line 6316 
  if ((unsigned int)dwrq->length != 0U) {
    #line 6317 
    wep_key_t key;
    #line 6319 
    int current_index;
    #line 6318 
    int index = ((int)dwrq->flags & 255) + -1;
    #line 6322 
    if ((unsigned int)dwrq->length > 13U) 
                                          #line 6323 
                                          return -22;
    #line 6326 
    current_index = get_wep_tx_idx(local);
    #line 6327 
    if (current_index < 0) 
                           #line 6328 
                           current_index = 0;
    #line 6331 
    if (valid_index(local,index) == 0) 
                                       #line 6332 
                                       index = current_index;
    #line 6335 
    if ((unsigned int)dwrq->length > 5U) 
                                         #line 6336 
                                         key.len = (unsigned short)13U; else 
                                                                    #line 6338 
                                                                    key.len = (unsigned short)5U;
    #line 6340 
    if (((int)dwrq->flags & 2048) == 0) {
      #line 6342 
      memset((void *)(& key.key),0,13UL);
      #line 6344 
      memcpy((void *)(& key.key),(void *)extra,(unsigned long)dwrq->length);
      #line 6346 
      rc = set_wep_key(local,(unsigned short)((int)((unsigned short)index)),(char *)(& key.key),(unsigned short)((int)key.len),perm,1);
      #line 6347 
      if (rc < 0) {
        #line 6348 
        printk((char *)"\001",(char *)(& (local->dev)->name),index,rc);
        #line 6351 
        return rc;
      }
    }
    #line 6357 
    if ((index == current_index && (unsigned int)key.len != 0U) && (unsigned int)local->config.authType == 1U) 
      #line 6359 
      set_auth_type(local,257);
  }
  else {
    #line 6362 
    int index_0 = ((int)dwrq->flags & 255) + -1;
    #line 6363 
    if (valid_index(local,index_0) != 0) {
      #line 6364 
      rc = set_wep_tx_idx(local,(unsigned short)((int)((unsigned short)index_0)),perm,1);
      #line 6365 
      if (rc < 0) {
        #line 6366 
        printk((char *)"\001",(char *)(& (local->dev)->name),index_0,rc);
        #line 6369 
        return rc;
      }
    }
    else 
      #line 6373 
      if (((int)dwrq->flags & 61440) == 0) 
                                           #line 6374 
                                           return -22;
  }
  #line 6378 
  if (((int)dwrq->flags & 32768) != 0) 
                                       #line 6379 
                                       set_auth_type(local,1);
  #line 6380 
  if (((int)dwrq->flags & 16384) != 0) 
                                       #line 6381 
                                       set_auth_type(local,258);
  #line 6382 
  if (((int)dwrq->flags & 8192) != 0) 
                                      #line 6383 
                                      set_auth_type(local,257);
  #line 6385 
  if ((int)local->config.authType != (int)currentAuthType) 
                                                           #line 6386 
                                                           cif_set_bit(13L,& local->flags);
  #line 6387 
  return -115;
}

#line 6394  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_encode(struct net_device *dev, struct iw_request_info *info, struct iw_point *dwrq, char *extra)
{
  #line 6401 
  int wep_key_len;
  #line 6402 
  u8 buf[16U];
  #line 6399 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6400 
  int index = ((int)dwrq->flags & 255) + -1;
  #line 6404 
  if (local->wep_capable == 0) 
                               #line 6405 
                               return -95;
  #line 6407 
  readConfigRid(local,1);
  #line 6410 
  switch ((int)local->config.authType) {
    #line 6411 
    case 257: 
              #line 6411 
    ;
    #line 6412 
    dwrq->flags = (unsigned short)8192U;
    #line 6413 
    break;
    #line 6414 
    case 258: 
              #line 6414 
    ;
    #line 6415 
    dwrq->flags = (unsigned short)16384U;
    #line 6416 
    break;
    #line 6417 
    default: 
             #line 6417 
    ;
    #line 6418 
    case 1: 
            #line 6418 
    ;
    #line 6419 
    dwrq->flags = (unsigned short)32768U;
    #line 6420 
    break;
  }
  #line 6423 
  dwrq->flags = (unsigned short)((unsigned int)dwrq->flags | 2048U);
  #line 6424 
  memset((void *)extra,0,16UL);
  #line 6427 
  if (valid_index(local,index) == 0) {
    #line 6428 
    index = get_wep_tx_idx(local);
    #line 6429 
    if (index < 0) 
                   #line 6430 
                   index = 0;
  }
  #line 6432 
  dwrq->flags = (unsigned short)((unsigned int)dwrq->flags | ((unsigned int)index + 1U));
  #line 6435 
  wep_key_len = get_wep_key(local,(unsigned short)((int)((unsigned short)index)),(char *)(buf),(unsigned short)16);
  #line 6436 
  if (wep_key_len < 0) 
                       #line 6437 
                       dwrq->length = (unsigned short)0U;
  else {
    #line 6439 
    dwrq->length = (unsigned short)wep_key_len;
    #line 6440 
    memcpy((void *)extra,(void *)(& buf),(unsigned long)dwrq->length);
  }
  #line 6443 
  return 0;
}

#line 6450  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_encodeext(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
{
  #line 6460 
  int idx;
  #line 6460 
  int key_len;
  #line 6460 
  int rc;
  #line 6461 
  wep_key_t key;
  #line 6455 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6456 
  struct iw_point *encoding = & wrqu->encoding;
  #line 6457 
  struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
  #line 6458 
  int perm = ((int)encoding->flags & 1024) == 0;
  #line 6459 
  __le16 currentAuthType = local->config.authType;
  #line 6460 
  int alg = (int)ext->alg;
  #line 6460 
  int set_key = 1;
  #line 6463 
  if (local->wep_capable == 0) 
                               #line 6464 
                               return -95;
  #line 6466 
  readConfigRid(local,1);
  #line 6469 
  idx = (int)encoding->flags & 255;
  #line 6470 
  if (idx != 0) {
    #line 6471 
    if (valid_index(local,idx + -1) == 0) 
                                          #line 6472 
                                          return -22;
    #line 6473 
    idx --;
  }
  else {
    #line 6475 
    idx = get_wep_tx_idx(local);
    #line 6476 
    if (idx < 0) 
                 #line 6477 
                 idx = 0;
  }
  #line 6480 
  if (((int)encoding->flags & 32768) != 0) 
                                           #line 6481 
                                           alg = 0;
  #line 6483 
  if ((ext->ext_flags & 8U) != 0U) {
    #line 6487 
    rc = set_wep_tx_idx(local,(unsigned short)((int)((unsigned short)idx)),perm,1);
    #line 6488 
    if (rc < 0) {
      #line 6489 
      printk((char *)"\001",(char *)(& (local->dev)->name),idx,rc);
      #line 6492 
      return rc;
    }
    #line 6494 
    set_key = (unsigned int)ext->key_len != 0U;
  }
  #line 6497 
  if (set_key != 0) {
    #line 6499 
    memset((void *)(& key.key),0,13UL);
    #line 6500 
    switch (alg) {
      #line 6512 
      __u16 __UNIQUE_ID___x486;
      #line 6512 
      int tmp_0;
      #line 6501 
      case 0: 
              #line 6501 
      ;
      #line 6502 
      key.len = (unsigned short)0U;
      #line 6503 
      break;
      #line 6504 
      case 1: 
              #line 6504 
      ;
      #line 6505 
      if ((unsigned int)ext->key_len > 5U) 
                                           #line 6506 
                                           key.len = (unsigned short)13U;
      else 
        #line 6507 
        if ((unsigned int)ext->key_len != 0U) 
                                              #line 6508 
                                              key.len = (unsigned short)5U; else 
                                                                    #line 6510 
                                                                    return -22;
      {
        #line 6512 
        __UNIQUE_ID___x486 = ext->key_len;
        #line 6512 
        u16 __UNIQUE_ID___y487 = key.len;
        #line 6512 
        if ((int)__UNIQUE_ID___x486 < (int)__UNIQUE_ID___y487) 
                                                               #line 6512 
                                                               tmp_0 = (int)__UNIQUE_ID___x486; else 
                                                                    #line 6512 
                                                                    tmp_0 = (int)__UNIQUE_ID___y487;
        }
      #line 6512 
      key_len = tmp_0;
      #line 6513 
      memcpy((void *)(& key.key),(void *)(& ext->key),(unsigned long)key_len);
      #line 6514 
      break;
      #line 6515 
      default: 
               #line 6515 
      ;
      #line 6516 
      return -22;
    }
    #line 6518 
    if ((unsigned int)key.len == 0U) {
      #line 6519 
      rc = set_wep_tx_idx(local,(unsigned short)((int)((unsigned short)idx)),perm,1);
      #line 6520 
      if (rc < 0) {
        #line 6521 
        printk((char *)"\001",(char *)(& (local->dev)->name),idx,rc);
        #line 6524 
        return rc;
      }
    }
    else {
      #line 6527 
      rc = set_wep_key(local,(unsigned short)((int)((unsigned short)idx)),(char *)(& key.key),(unsigned short)((int)key.len),perm,1);
      #line 6528 
      if (rc < 0) {
        #line 6529 
        printk((char *)"\001",(char *)(& (local->dev)->name),idx,rc);
        #line 6532 
        return rc;
      }
    }
  }
  #line 6538 
  if (((int)encoding->flags & 32768) != 0) 
                                           #line 6539 
                                           set_auth_type(local,1);
  #line 6540 
  if (((int)encoding->flags & 16384) != 0) 
                                           #line 6541 
                                           set_auth_type(local,258);
  #line 6542 
  if (((int)encoding->flags & 8192) != 0) 
                                          #line 6543 
                                          set_auth_type(local,257);
  #line 6545 
  if ((int)local->config.authType != (int)currentAuthType) 
                                                           #line 6546 
                                                           cif_set_bit(13L,& local->flags);
  #line 6548 
  return -115;
}

#line 6556  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_encodeext(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
{
  #line 6564 
  int idx;
  #line 6564 
  int max_key_len;
  #line 6564 
  int wep_key_len;
  #line 6565 
  u8 buf[16U];
  #line 6561 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6562 
  struct iw_point *encoding = & wrqu->encoding;
  #line 6563 
  struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
  #line 6567 
  if (local->wep_capable == 0) 
                               #line 6568 
                               return -95;
  #line 6570 
  readConfigRid(local,1);
  #line 6572 
  max_key_len = (int)((unsigned int)encoding->length + 4294967256U);
  #line 6573 
  if (max_key_len < 0) 
                       #line 6574 
                       return -22;
  #line 6576 
  idx = (int)encoding->flags & 255;
  #line 6577 
  if (idx != 0) {
    #line 6578 
    if (valid_index(local,idx + -1) == 0) 
                                          #line 6579 
                                          return -22;
    #line 6580 
    idx --;
  }
  else {
    #line 6582 
    idx = get_wep_tx_idx(local);
    #line 6583 
    if (idx < 0) 
                 #line 6584 
                 idx = 0;
  }
  #line 6587 
  encoding->flags = (unsigned short)((unsigned int)((unsigned short)idx) + 1U);
  #line 6588 
  memset((void *)ext,0,40UL);
  #line 6591 
  switch ((int)local->config.authType) {
    #line 6592 
    case 257: 
              #line 6592 
    ;
    #line 6593 
    encoding->flags = (unsigned short)1U;
    #line 6594 
    break;
    #line 6595 
    case 258: 
              #line 6595 
    ;
    #line 6596 
    encoding->flags = (unsigned short)1U;
    #line 6597 
    break;
    #line 6598 
    default: 
             #line 6598 
    ;
    #line 6599 
    case 1: 
            #line 6599 
    ;
    #line 6600 
    encoding->flags = (unsigned short)32768U;
    #line 6601 
    break;
  }
  #line 6604 
  encoding->flags = (unsigned short)((unsigned int)encoding->flags | 2048U);
  #line 6605 
  memset((void *)extra,0,16UL);
  #line 6608 
  wep_key_len = get_wep_key(local,(unsigned short)((int)((unsigned short)idx)),(char *)(buf),(unsigned short)16);
  #line 6609 
  if (wep_key_len < 0) 
                       #line 6610 
                       ext->key_len = (unsigned short)0U;
  else {
    #line 6612 
    ext->key_len = (unsigned short)wep_key_len;
    #line 6613 
    memcpy((void *)extra,(void *)(& buf),(unsigned long)ext->key_len);
  }
  #line 6616 
  return 0;
}

#line 6624  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_auth(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
{
  #line 6628 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6629 
  struct iw_param *param = & wrqu->param;
  #line 6630 
  __le16 currentAuthType = local->config.authType;
  #line 6632 
  switch ((int)param->flags & 4095) {
    #line 6633 
    case 0: 
            #line 6633 
    ;
    #line 6634 
    case 1: 
            #line 6634 
    ;
    #line 6635 
    case 2: 
            #line 6635 
    ;
    #line 6636 
    case 3: 
            #line 6636 
    ;
    #line 6637 
    case 8: 
            #line 6637 
    ;
    #line 6638 
    case 10: 
             #line 6638 
    ;
    #line 6642 
    break;
    #line 6644 
    case 5: 
            #line 6644 
    ;
    #line 6645 
    if (param->value != 0) {
      #line 6647 
      if ((unsigned int)currentAuthType == 1U) 
                                               #line 6648 
                                               set_auth_type(local,257);
    }
    else 
         #line 6650 
         set_auth_type(local,1);
    #line 6654 
    if ((int)local->config.authType != (int)currentAuthType) 
                                                             #line 6655 
                                                             cif_set_bit(13L,& local->flags);
    #line 6656 
    break;
    #line 6658 
    case 6: 
            #line 6658 
    ;
    #line 6659 
    if ((param->value & 2) != 0) 
                                 #line 6660 
                                 set_auth_type(local,258);
    else 
      #line 6661 
      if ((param->value & 1) != 0) 
                                   #line 6666 
                                   set_auth_type(local,local->last_auth); else 
                                                                    #line 6668 
                                                                    return -22;
    #line 6671 
    if ((int)local->config.authType != (int)currentAuthType) 
                                                             #line 6672 
                                                             cif_set_bit(13L,& local->flags);
    #line 6673 
    break;
    #line 6676 
    case 7: 
            #line 6676 
    ;
    #line 6678 
    if (param->value > 0) 
                          #line 6679 
                          return -95;
    #line 6680 
    break;
    #line 6682 
    default: 
             #line 6682 
    ;
    #line 6683 
    return -95;
  }
  #line 6685 
  return -115;
}

#line 6693  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_auth(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
{
  #line 6697 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6698 
  struct iw_param *param = & wrqu->param;
  #line 6699 
  __le16 currentAuthType = local->config.authType;
  #line 6701 
  switch ((int)param->flags & 4095) {
    #line 6702 
    case 5: 
            #line 6702 
    ;
    #line 6703 
    switch ((int)currentAuthType) {
      #line 6704 
      case 258: 
                #line 6704 
      ;
      #line 6705 
      case 257: 
                #line 6705 
      ;
      #line 6706 
      param->value = 1;
      #line 6707 
      break;
      #line 6708 
      default: 
               #line 6708 
      ;
      #line 6709 
      param->value = 0;
      #line 6710 
      break;
    }
    #line 6712 
    break;
    #line 6714 
    case 6: 
            #line 6714 
    ;
    #line 6715 
    switch ((int)currentAuthType) {
      #line 6716 
      case 258: 
                #line 6716 
      ;
      #line 6717 
      param->value = 2;
      #line 6718 
      break;
      #line 6719 
      case 257: 
                #line 6719 
      ;
      #line 6720 
      default: 
               #line 6720 
      ;
      #line 6721 
      param->value = 1;
      #line 6722 
      break;
    }
    #line 6724 
    break;
    #line 6726 
    case 7: 
            #line 6726 
    ;
    #line 6727 
    param->value = 0;
    #line 6728 
    break;
    #line 6730 
    default: 
             #line 6730 
    ;
    #line 6731 
    return -95;
  }
  #line 6733 
  return 0;
}

#line 6741  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_txpow(struct net_device *dev, struct iw_request_info *info, struct iw_param *vwrq, char *extra)
{
  #line 6747 
  CapabilityRid cap_rid;
  #line 6748 
  int i;
  #line 6746 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6749 
  int rc = -22;
  #line 6750 
  __le16 v = (unsigned short)vwrq->value;
  #line 6752 
  readCapabilityRid(local,& cap_rid,1);
  #line 6754 
  if ((unsigned int)vwrq->disabled != 0U) {
    #line 6755 
    cif_set_bit(0L,& local->flags);
    #line 6756 
    cif_set_bit(13L,& local->flags);
    #line 6757 
    return -115;
  }
  #line 6759 
  if ((unsigned int)vwrq->flags != 1U) 
                                       #line 6760 
                                       return -22;
  #line 6762 
  cif_clear_bit(0L,& local->flags);
  #line 6763 
  i = 0;
  #line 6763 
  while (i <= 7 && (unsigned int)cap_rid.txPowerLevels[i] != 0U) {
    #line 6764 
    if ((int)cap_rid.txPowerLevels[i] == (int)v) {
      #line 6765 
      readConfigRid(local,1);
      #line 6766 
      local->config.txPower = v;
      #line 6767 
      cif_set_bit(13L,& local->flags);
      #line 6768 
      rc = -115;
      #line 6769 
      break;
    }
    #line 6763 
    i ++;
  }
  #line 6771 
  return rc;
}

#line 6778  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_txpow(struct net_device *dev, struct iw_request_info *info, struct iw_param *vwrq, char *extra)
{
  #line 6783 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6785 
  readConfigRid(local,1);
  #line 6786 
  vwrq->value = (int)local->config.txPower;
  #line 6787 
  vwrq->fixed = (unsigned char)1U;
  #line 6788 
  vwrq->disabled = (__u8)test_bit(0L,& local->flags);
  #line 6789 
  vwrq->flags = (unsigned short)1U;
  #line 6791 
  return 0;
}

#line 6798  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_retry(struct net_device *dev, struct iw_request_info *info, struct iw_param *vwrq, char *extra)
{
  #line 6803 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6804 
  int rc = -22;
  #line 6806 
  if ((unsigned int)vwrq->disabled != 0U) 
                                          #line 6807 
                                          return -22;
  #line 6809 
  readConfigRid(local,1);
  #line 6810 
  if (((int)vwrq->flags & 4096) != 0) {
    #line 6811 
    __le16 v = (unsigned short)vwrq->value;
    #line 6812 
    if (((int)vwrq->flags & 32) != 0) 
                                      #line 6813 
                                      local->config.longRetryLimit = v;
    else 
      #line 6814 
      if (((int)vwrq->flags & 16) != 0) 
                                        #line 6815 
                                        local->config.shortRetryLimit = v;
      else {
        #line 6818 
        local->config.longRetryLimit = v;
        #line 6819 
        local->config.shortRetryLimit = v;
      }
    #line 6821 
    cif_set_bit(13L,& local->flags);
    #line 6822 
    rc = -115;
  }
  #line 6824 
  if (((int)vwrq->flags & 8192) != 0) {
    #line 6825 
    local->config.txLifetime = (unsigned short)(vwrq->value / 1024);
    #line 6826 
    cif_set_bit(13L,& local->flags);
    #line 6827 
    rc = -115;
  }
  #line 6829 
  return rc;
}

#line 6836  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_retry(struct net_device *dev, struct iw_request_info *info, struct iw_param *vwrq, char *extra)
{
  #line 6841 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6843 
  vwrq->disabled = (unsigned char)0U;
  #line 6845 
  readConfigRid(local,1);
  #line 6847 
  if (((int)vwrq->flags & 61440) == 8192) {
    #line 6848 
    vwrq->flags = (unsigned short)8192U;
    #line 6849 
    vwrq->value = (int)local->config.txLifetime * 1024;
  }
  else 
    #line 6850 
    if (((int)vwrq->flags & 32) != 0) {
      #line 6851 
      vwrq->flags = (unsigned short)4128U;
      #line 6852 
      vwrq->value = (int)local->config.longRetryLimit;
    }
    else {
      #line 6854 
      vwrq->flags = (unsigned short)4096U;
      #line 6855 
      vwrq->value = (int)local->config.shortRetryLimit;
      #line 6856 
      if ((int)local->config.shortRetryLimit != (int)local->config.longRetryLimit) 
        #line 6857 
        vwrq->flags = (unsigned short)((unsigned int)vwrq->flags | 16U);
    }
  #line 6860 
  return 0;
}

#line 6867  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_range(struct net_device *dev, struct iw_request_info *info, struct iw_point *dwrq, char *extra)
{
  #line 6874 
  CapabilityRid cap_rid;
  #line 6875 
  int i;
  #line 6876 
  int k;
  #line 6872 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 6873 
  struct iw_range *range = (struct iw_range *)extra;
  #line 6878 
  readCapabilityRid(local,& cap_rid,1);
  #line 6880 
  dwrq->length = (unsigned short)568U;
  #line 6881 
  memset((void *)range,0,568UL);
  #line 6882 
  range->min_nwid = 0U;
  #line 6883 
  range->max_nwid = 0U;
  #line 6884 
  range->num_channels = (unsigned short)14U;
  #line 6887 
  k = 0;
  #line 6888 
  i = 0;
  #line 6888 
  while (i <= 13) {
    {
      #line 6892 
      int tmp_0;
      #line 6889 
      range->freq[k].i = (unsigned char)((unsigned int)((unsigned char)i) + 1U);
      #line 6890 
      range->freq[k].m = ieee80211_channel_to_frequency(i + 1,
                                     (enum nl80211_band)NL80211_BAND_2GHZ) * 100000;
      #line 6892 
      tmp_0 = k;
      #line 6892 
      k ++;
      #line 6892 
      range->freq[tmp_0].e = (short)1;
    }
    #line 6888 
    i ++;
  }
  #line 6894 
  range->num_frequency = (unsigned char)k;
  #line 6896 
  range->sensitivity = 65535;
  #line 6899 
  if (local->rssi != (tdsRssiEntry *)0) 
                                        #line 6900 
                                        range->max_qual.qual = (unsigned char)100U;
  else {
    #line 6902 
    if (memcmp((void *)(& cap_rid.prodName),(void *)"350",3UL) != 0) 
      #line 6902 
      range->max_qual.qual = (unsigned char)32U; else 
                                                      #line 6902 
                                                      range->max_qual.qual = (unsigned char)160U;
  }
  #line 6903 
  range->max_qual.level = (unsigned char)136U;
  #line 6904 
  range->max_qual.noise = (unsigned char)136U;
  #line 6909 
  if (local->rssi != (tdsRssiEntry *)0) {
    #line 6910 
    range->avg_qual.qual = (unsigned char)50U;
    #line 6911 
    range->avg_qual.level = (unsigned char)186U;
  }
  else {
    #line 6913 
    if (memcmp((void *)(& cap_rid.prodName),(void *)"350",3UL) != 0) 
      #line 6913 
      range->avg_qual.qual = (unsigned char)16U; else 
                                                      #line 6913 
                                                      range->avg_qual.qual = (unsigned char)80U;
    #line 6914 
    range->avg_qual.level = (unsigned char)176U;
  }
  #line 6916 
  range->avg_qual.noise = (unsigned char)171U;
  #line 6918 
  i = 0;
  #line 6918 
  while (i <= 7) {
    #line 6919 
    range->bitrate[i] = (int)cap_rid.supportedRates[i] * 500000;
    #line 6920 
    if (range->bitrate[i] == 0) 
                                #line 6921 
                                break;
    #line 6918 
    i ++;
  }
  #line 6923 
  range->num_bitrates = (unsigned char)i;
  #line 6928 
  if (i > 2) 
             #line 6929 
             range->throughput = 5000000U; else 
                                                #line 6931 
                                                range->throughput = 1500000U;
  #line 6933 
  range->min_rts = 0;
  #line 6934 
  range->max_rts = 2312;
  #line 6935 
  range->min_frag = 256;
  #line 6936 
  range->max_frag = 2312;
  #line 6938 
  if (((int)cap_rid.softCap & 2) != 0) {
    #line 6940 
    range->encoding_size[0] = (unsigned short)5U;
    #line 6942 
    if (((int)cap_rid.softCap & 256) != 0) {
      #line 6943 
      range->encoding_size[1] = (unsigned short)13U;
      #line 6944 
      range->num_encoding_sizes = (unsigned char)2U;
    }
    else 
         #line 6946 
         range->num_encoding_sizes = (unsigned char)1U;
    #line 6947 
    if (((int)cap_rid.softCap & 128) != 0) 
                                           #line 6947 
                                           range->max_encoding_tokens = (unsigned char)4U; else 
                                                                    #line 6947 
                                                                    range->max_encoding_tokens = (unsigned char)1U;
  }
  else {
    #line 6950 
    range->num_encoding_sizes = (unsigned char)0U;
    #line 6951 
    range->max_encoding_tokens = (unsigned char)0U;
  }
  #line 6953 
  range->min_pmp = 0;
  #line 6954 
  range->max_pmp = 5000000;
  #line 6955 
  range->min_pmt = 0;
  #line 6956 
  range->max_pmt = 67107840;
  #line 6957 
  range->pmp_flags = (unsigned short)4096U;
  #line 6958 
  range->pmt_flags = (unsigned short)8192U;
  #line 6959 
  range->pm_capa = (unsigned short)13056U;
  #line 6962 
  i = 0;
  #line 6962 
  while (i <= 7) {
    #line 6963 
    range->txpower[i] = (int)cap_rid.txPowerLevels[i];
    #line 6964 
    if (range->txpower[i] == 0) 
                                #line 6965 
                                break;
    #line 6962 
    i ++;
  }
  #line 6967 
  range->num_txpower = (unsigned char)i;
  #line 6968 
  range->txpower_capa = (unsigned short)1U;
  #line 6969 
  range->we_version_source = (unsigned char)19U;
  #line 6970 
  range->we_version_compiled = (unsigned char)22U;
  #line 6971 
  range->retry_capa = (unsigned short)12288U;
  #line 6972 
  range->retry_flags = (unsigned short)4096U;
  #line 6973 
  range->r_time_flags = (unsigned short)8192U;
  #line 6974 
  range->min_retry = 1;
  #line 6975 
  range->max_retry = 65535;
  #line 6976 
  range->min_r_time = 1024;
  #line 6977 
  range->max_r_time = 67107840;
  #line 6980 
  range->event_capa[0] = 103284816U;
  #line 6984 
  range->event_capa[1] = 1024U;
  #line 6985 
  range->event_capa[4] = 1U;
  #line 6986 
  return 0;
}

#line 6993  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_power(struct net_device *dev, struct iw_request_info *info, struct iw_param *vwrq, char *extra)
{
  #line 6998 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 7000 
  readConfigRid(local,1);
  #line 7001 
  if ((unsigned int)vwrq->disabled != 0U) {
    #line 7002 
    if (sniffing_mode(local) != 0) 
                                   #line 7003 
                                   return -22;
    #line 7004 
    local->config.powerSaveMode = (unsigned short)0U;
    #line 7005 
    local->config.rmode = (unsigned short)((unsigned int)local->config.rmode & 65280U);
    #line 7006 
    local->config.rmode = local->config.rmode;
    #line 7007 
    cif_set_bit(13L,& local->flags);
    #line 7008 
    return -115;
  }
  #line 7010 
  if (((int)vwrq->flags & 61440) == 8192) {
    #line 7011 
    local->config.fastListenDelay = (unsigned short)((vwrq->value + 500) / 1024);
    #line 7012 
    local->config.powerSaveMode = (unsigned short)2U;
    #line 7013 
    cif_set_bit(13L,& local->flags);
  }
  else 
    #line 7014 
    if (((int)vwrq->flags & 61440) == 4096) {
      #line 7015 
      local->config.listenInterval = ((unsigned short)((vwrq->value + 500) / 1024));
      #line 7015 
      local->config.fastListenInterval = ((unsigned short)((vwrq->value + 500) / 1024));
      #line 7018 
      local->config.powerSaveMode = (unsigned short)2U;
      #line 7019 
      cif_set_bit(13L,& local->flags);
    }
  #line 7021 
  switch ((int)vwrq->flags & 3840) {
    #line 7022 
    case 256: 
              #line 7022 
    ;
    #line 7023 
    if (sniffing_mode(local) != 0) 
                                   #line 7024 
                                   return -22;
    #line 7025 
    local->config.rmode = (unsigned short)((unsigned int)local->config.rmode & 65280U);
    #line 7026 
    local->config.rmode = (unsigned short)((unsigned int)local->config.rmode | 2U);
    #line 7027 
    cif_set_bit(13L,& local->flags);
    #line 7028 
    break;
    #line 7029 
    case 768: 
              #line 7029 
    ;
    #line 7030 
    if (sniffing_mode(local) != 0) 
                                   #line 7031 
                                   return -22;
    #line 7032 
    local->config.rmode = (unsigned short)((unsigned int)local->config.rmode & 65280U);
    #line 7033 
    local->config.rmode = local->config.rmode;
    #line 7034 
    cif_set_bit(13L,& local->flags);
    #line 7035 
    case 0: 
            #line 7035 
    ;
    #line 7037 
    break;
    #line 7038 
    default: 
             #line 7038 
    ;
    #line 7039 
    return -22;
  }
  #line 7043 
  return -115;
}

#line 7050  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_power(struct net_device *dev, struct iw_request_info *info, struct iw_param *vwrq, char *extra)
{
  #line 7056 
  __le16 mode;
  #line 7055 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 7058 
  readConfigRid(local,1);
  #line 7059 
  mode = local->config.powerSaveMode;
  #line 7060 
  vwrq->disabled = ((unsigned char)((unsigned int)mode == 0U));
  #line 7060 
  if ((unsigned int)((unsigned char)((unsigned int)mode == 0U)) != 0U) 
    #line 7061 
    return 0;
  #line 7062 
  if (((int)vwrq->flags & 61440) == 8192) {
    #line 7063 
    vwrq->value = (int)local->config.fastListenDelay * 1024;
    #line 7064 
    vwrq->flags = (unsigned short)8192U;
  }
  else {
    #line 7066 
    vwrq->value = (int)local->config.fastListenInterval * 1024;
    #line 7067 
    vwrq->flags = (unsigned short)4096U;
  }
  #line 7069 
  if (((int)local->config.rmode & 255) == 2) 
                                             #line 7070 
                                             vwrq->flags = (unsigned short)((unsigned int)vwrq->flags | 256U); else 
                                                                    #line 7072 
                                                                    vwrq->flags = (unsigned short)((unsigned int)vwrq->flags | 768U);
  #line 7074 
  return 0;
}

#line 7081  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_sens(struct net_device *dev, struct iw_request_info *info, struct iw_param *vwrq, char *extra)
{
  #line 7086 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 7088 
  readConfigRid(local,1);
  #line 7089 
  if ((unsigned int)vwrq->disabled == 0U) 
                                          #line 7089 
                                          local->config.rssiThreshold = (unsigned short)vwrq->value; else 
                                                                    #line 7089 
                                                                    local->config.rssiThreshold = (unsigned short)0U;
  #line 7091 
  cif_set_bit(13L,& local->flags);
  #line 7093 
  return -115;
}

#line 7100  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_sens(struct net_device *dev, struct iw_request_info *info, struct iw_param *vwrq, char *extra)
{
  #line 7105 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 7107 
  readConfigRid(local,1);
  #line 7108 
  vwrq->value = (int)local->config.rssiThreshold;
  #line 7109 
  vwrq->disabled = (unsigned char)(vwrq->value == 0);
  #line 7110 
  vwrq->fixed = (unsigned char)1U;
  #line 7112 
  return 0;
}

#line 7120  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_aplist(struct net_device *dev, struct iw_request_info *info, struct iw_point *dwrq, char *extra)
{
  #line 7127 
  struct iw_quality *qual;
  #line 7128 
  BSSListRid BSSList;
  #line 7129 
  int i;
  #line 7130 
  int tmp_0;
  #line 7125 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 7126 
  struct sockaddr *address = (struct sockaddr *)extra;
  #line 7130 
  if ((int)capable(12) != 0) 
                             #line 7130 
                             tmp_0 = 1; else 
                                             #line 7130 
                                             tmp_0 = -1;
  #line 7130 
  int loseSync = tmp_0;
  #line 7132 
  qual = (struct iw_quality *)kmalloc_array(64UL,4UL,3264U);
  #line 7133 
  if (qual == (struct iw_quality *)0) 
                                      #line 7134 
                                      return -12;
  #line 7136 
  i = 0;
  #line 7136 
  while (i <= 63) {
    {
      #line 7137 
      u16 dBm;
      #line 7138 
      if (readBSSListRid(local,loseSync,& BSSList) != 0) 
                                                         #line 7139 
                                                         break;
      #line 7140 
      loseSync = 0;
      #line 7141 
      memcpy((void *)(& (address + (unsigned long)i)->sa_data),(void *)(& BSSList.bssid),6UL);
      #line 7142 
      (address + (unsigned long)i)->sa_family = (unsigned short)1U;
      #line 7143 
      dBm = BSSList.dBm;
      #line 7144 
      if (local->rssi != (tdsRssiEntry *)0) {
        #line 7145 
        (qual + (unsigned long)i)->level = (unsigned char)(- ((int)((unsigned char)dBm)));
        #line 7146 
        (qual + (unsigned long)i)->qual = airo_dbm_to_pct(local->rssi,(unsigned char)((int)((unsigned char)dBm)));
        #line 7147 
        (qual + (unsigned long)i)->updated = (unsigned char)11U;
      }
      else {
        #line 7151 
        (qual + (unsigned long)i)->level = (unsigned char)(((int)dBm + 321) / 2);
        #line 7152 
        (qual + (unsigned long)i)->qual = (unsigned char)0U;
        #line 7153 
        (qual + (unsigned long)i)->updated = (unsigned char)26U;
      }
      #line 7157 
      (qual + (unsigned long)i)->noise = local->wstats.qual.noise;
      #line 7158 
      if ((unsigned int)BSSList.index == 65535U) 
                                                 #line 7159 
                                                 break;
    }
    #line 7136 
    i ++;
  }
  #line 7161 
  if (i == 0) {
    #line 7162 
    StatusRid status_rid;
    #line 7163 
    readStatusRid(local,& status_rid,1);
    #line 7164 
    i = 0;
    #line 7164 
    while ((i <= 3 && (unsigned int)((((((int)status_rid.bssid[i][0] & (int)status_rid.bssid[i][1]) & (int)status_rid.bssid[i][2]) & (int)status_rid.bssid[i][3]) & (int)status_rid.bssid[i][4]) & (int)status_rid.bssid[i][5]) != 255U) && (unsigned int)((((((int)status_rid.bssid[i][0] | (int)status_rid.bssid[i][1]) | (int)status_rid.bssid[i][2]) | (int)status_rid.bssid[i][3]) | (int)status_rid.bssid[i][4]) | (int)status_rid.bssid[i][5]) != 0U) {
      #line 7179 
      memcpy((void *)(& (address + (unsigned long)i)->sa_data),(void *)(& status_rid.bssid[i]),6UL);
      #line 7181 
      (address + (unsigned long)i)->sa_family = (unsigned short)1U;
      #line 7171 
      i ++;
    }
  }
  else {
    #line 7184 
    dwrq->flags = (unsigned short)1U;
    #line 7185 
    memcpy((void *)(extra + (unsigned long)i * 16UL),(void *)qual,(unsigned long)i * 4UL);
  }
  #line 7188 
  dwrq->length = (unsigned short)i;
  #line 7190 
  kfree((void *)qual);
  #line 7191 
  return 0;
}

#line 7198  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_set_scan(struct net_device *dev, struct iw_request_info *info, struct iw_point *dwrq, char *extra)
{
  #line 7204 
  Cmd cmd;
  #line 7205 
  Resp rsp;
  #line 7207 
  APListRid APList_rid_empty;
  #line 7203 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 7206 
  int wake = 0;
  #line 7215 
  if ((ai->flags & 3UL) != 0UL) 
                                #line 7215 
                                return -100;
  #line 7217 
  if (down_interruptible(& ai->sem) != 0) 
                                          #line 7218 
                                          return -512;
  #line 7222 
  if (ai->scan_timeout != 0UL) 
                               #line 7223 
                               goto out;
  #line 7226 
  memset((void *)(& APList_rid_empty),0,26UL);
  #line 7227 
  APList_rid_empty.len = (unsigned short)26U;
  #line 7228 
  disable_MAC(ai,2);
  #line 7229 
  writeAPListRid(ai,& APList_rid_empty,0);
  #line 7230 
  enable_MAC(ai,0);
  #line 7233 
  ai->scan_timeout = jiffies + 750UL;
  #line 7234 
  memset((void *)(& cmd),0,8UL);
  #line 7235 
  cmd.cmd = (unsigned short)259U;
  #line 7236 
  issuecommand(ai,& cmd,& rsp);
  #line 7237 
  wake = 1;
  #line 7239 
  out: 
       #line 7239 
  ;
  #line 7240 
  up(& ai->sem);
  #line 7241 
  if (wake != 0) 
                 #line 7242 
                 __wake_up(& ai->thr_wait,1U,1,(void *)0);
  #line 7243 
  return 0;
}

#line 7251  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
__inline static char *airo_translate_scan(struct net_device *dev, struct iw_request_info *info, char *current_ev, char *end_buf, BSSListRid *bss)
{
  #line 7258 
  struct iw_event iwe;
  #line 7259 
  __le16 capabilities;
  #line 7260 
  char *current_val;
  #line 7261 
  int i;
  #line 7262 
  char *buf;
  #line 7263 
  u16 dBm;
  #line 7257 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 7266 
  iwe.cmd = (unsigned short)35605U;
  #line 7267 
  iwe.u.ap_addr.sa_family = (unsigned short)1U;
  #line 7268 
  memcpy((void *)(& iwe.u.ap_addr.sa_data),(void *)(& bss->bssid),6UL);
  #line 7269 
  current_ev = iwe_stream_add_event(info,current_ev,end_buf,& iwe,24);
  #line 7275 
  iwe.u.data.length = (unsigned short)bss->ssidLen;
  #line 7276 
  if ((unsigned int)iwe.u.data.length > 32U) 
                                             #line 7277 
                                             iwe.u.data.length = (unsigned short)32U;
  #line 7278 
  iwe.cmd = (unsigned short)35611U;
  #line 7279 
  iwe.u.data.flags = (unsigned short)1U;
  #line 7280 
  current_ev = iwe_stream_add_point(info,current_ev,end_buf,& iwe,(char *)(& bss->ssid));
  #line 7284 
  iwe.cmd = (unsigned short)35591U;
  #line 7285 
  capabilities = bss->cap;
  #line 7286 
  if (((int)capabilities & 3) != 0) {
    #line 7287 
    if (((int)capabilities & 1) != 0) 
                                      #line 7288 
                                      iwe.u.mode = 3U; else 
                                                            #line 7290 
                                                            iwe.u.mode = 1U;
    #line 7291 
    current_ev = iwe_stream_add_event(info,current_ev,end_buf,& iwe,12);
  }
  #line 7296 
  iwe.cmd = (unsigned short)35589U;
  #line 7297 
  iwe.u.freq.m = (int)bss->dsChannel;
  #line 7298 
  iwe.u.freq.m = ieee80211_channel_to_frequency(iwe.u.freq.m,
                                     (enum nl80211_band)NL80211_BAND_2GHZ) * 100000;
  #line 7300 
  iwe.u.freq.e = (short)1;
  #line 7301 
  current_ev = iwe_stream_add_event(info,current_ev,end_buf,& iwe,16);
  #line 7304 
  dBm = bss->dBm;
  #line 7307 
  iwe.cmd = (unsigned short)35841U;
  #line 7308 
  if (ai->rssi != (tdsRssiEntry *)0) {
    #line 7309 
    iwe.u.qual.level = (unsigned char)(- ((int)((unsigned char)dBm)));
    #line 7310 
    iwe.u.qual.qual = airo_dbm_to_pct(ai->rssi,(unsigned char)((int)((unsigned char)dBm)));
    #line 7311 
    iwe.u.qual.updated = (unsigned char)11U;
  }
  else {
    #line 7315 
    iwe.u.qual.level = (unsigned char)(((int)dBm + 321) / 2);
    #line 7316 
    iwe.u.qual.qual = (unsigned char)0U;
    #line 7317 
    iwe.u.qual.updated = (unsigned char)26U;
  }
  #line 7321 
  iwe.u.qual.noise = ai->wstats.qual.noise;
  #line 7322 
  current_ev = iwe_stream_add_event(info,current_ev,end_buf,& iwe,12);
  #line 7326 
  iwe.cmd = (unsigned short)35627U;
  #line 7327 
  if (((int)capabilities & 16) != 0) 
                                     #line 7328 
                                     iwe.u.data.flags = (unsigned short)2048U; else 
                                                                    #line 7330 
                                                                    iwe.u.data.flags = (unsigned short)32768U;
  #line 7331 
  iwe.u.data.length = (unsigned short)0U;
  #line 7332 
  current_ev = iwe_stream_add_point(info,current_ev,end_buf,& iwe,(char *)(& bss->ssid));
  #line 7337 
  current_val = current_ev + (unsigned long)iwe_stream_lcp_len(info);
  #line 7339 
  iwe.cmd = (unsigned short)35617U;
  #line 7341 
  iwe.u.bitrate.disabled = (unsigned char)0U;
  #line 7341 
  iwe.u.bitrate.fixed = iwe.u.bitrate.disabled;
  #line 7343 
  i = 0;
  #line 7343 
  while (i <= 7) {
    #line 7345 
    if ((unsigned int)bss->rates[i] == 0U) 
                                           #line 7346 
                                           break;
    #line 7348 
    iwe.u.bitrate.value = ((int)bss->rates[i] & 127) * 500000;
    #line 7350 
    current_val = iwe_stream_add_value(info,current_ev,current_val,end_buf,& iwe,16);
    #line 7343 
    i ++;
  }
  #line 7355 
  ;
  #line 7355 
  if (current_val - current_ev > (long)iwe_stream_lcp_len(info)) 
                                                                 #line 7356 
                                                                 current_ev = current_val;
  #line 7359 
  buf = (char *)kmalloc(30UL,3264U);
  #line 7360 
  if (buf != (char *)0) {
    #line 7361 
    iwe.cmd = (unsigned short)35842U;
    #line 7362 
    sprintf(buf,(char *)"bcn_int=%d",(int)bss->beaconInterval);
    #line 7363 
    iwe.u.data.length = (unsigned short)cif_strlen(buf);
    #line 7364 
    current_ev = iwe_stream_add_point(info,current_ev,end_buf,& iwe,buf);
    #line 7366 
    kfree((void *)buf);
  }
  #line 7370 
  if ((int)test_bit(16L,& ai->flags) != 0) {
    #line 7371 
    unsigned int num_null_ies = 0U;
    #line 7372 
    u16 length = (unsigned short)624U;
    #line 7373 
    u8 *ie = (u8 *)(& bss->extra.iep);
    #line 7375 
    while ((unsigned int)length > 1U && num_null_ies <= 1U) {
      #line 7376 
      if ((int)*(ie + 1U) + 1 >= (int)length) 
                                              #line 7378 
                                              break;
      #line 7381 
      switch ((int)*ie) {
        #line 7408 
        int __UNIQUE_ID___x492;
        #line 7408 
        int tmp_6;
        #line 7382 
        case 0: 
                #line 7382 
        ;
        #line 7385 
        if ((unsigned int)*(ie + 1U) == 0U) 
                                            #line 7386 
                                            num_null_ies ++;
        #line 7387 
        break;
        #line 7389 
        case 221: 
                  #line 7389 
        ;
        #line 7390 
        if (((((unsigned int)*(ie + 1U) > 3U && (unsigned int)*(ie + 2U) == 0U) && (unsigned int)*(ie + 3U) == 80U) && (unsigned int)*(ie + 4U) == 242U) && (unsigned int)*(ie + 5U) == 1U) {
          #line 7397 
          int __UNIQUE_ID___x490;
          #line 7397 
          int tmp_4;
          #line 7395 
          iwe.cmd = (unsigned short)35845U;
          {
            #line 7397 
            __UNIQUE_ID___x490 = (int)*(ie + 1U) + 2;
            #line 7397 
            int __UNIQUE_ID___y491 = 64;
            #line 7397 
            if (__UNIQUE_ID___x490 < __UNIQUE_ID___y491) 
                                                         #line 7397 
                                                         tmp_4 = __UNIQUE_ID___x490; else 
                                                                    #line 7397 
                                                                    tmp_4 = __UNIQUE_ID___y491;
            }
          #line 7397 
          iwe.u.data.length = (unsigned short)tmp_4;
          #line 7399 
          current_ev = iwe_stream_add_point(info,current_ev,end_buf,& iwe,(char *)ie);
        }
        #line 7403 
        break;
        #line 7405 
        case 48: 
                 #line 7405 
        ;
        #line 7406 
        iwe.cmd = (unsigned short)35845U;
        {
          #line 7408 
          __UNIQUE_ID___x492 = (int)*(ie + 1U) + 2;
          #line 7408 
          int __UNIQUE_ID___y493 = 64;
          #line 7408 
          if (__UNIQUE_ID___x492 < __UNIQUE_ID___y493) 
                                                       #line 7408 
                                                       tmp_6 = __UNIQUE_ID___x492; else 
                                                                    #line 7408 
                                                                    tmp_6 = __UNIQUE_ID___y493;
          }
        #line 7408 
        iwe.u.data.length = (unsigned short)tmp_6;
        #line 7409 
        current_ev = iwe_stream_add_point(info,current_ev,end_buf,& iwe,(char *)ie);
        #line 7412 
        break;
        #line 7414 
        default: 
                 #line 7414 
        ;
        #line 7415 
        break;
      }
      #line 7418 
      length = (unsigned short)((unsigned int)((int)length - (int)((unsigned short)*(ie + 1U))) + 65534U);
      #line 7419 
      ie += (unsigned long)((int)*(ie + 1U) + 2);
    }
  }
  #line 7422 
  return current_ev;
}

#line 7429  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_get_scan(struct net_device *dev, struct iw_request_info *info, struct iw_point *dwrq, char *extra)
{
  #line 7446 
  void *__mptr;
  #line 7435 
  BSSListElement *net;
  #line 7434 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 7436 
  int err = 0;
  #line 7437 
  char *current_ev = extra;
  #line 7440 
  if (ai->scan_timeout != 0UL) 
                               #line 7441 
                               return -11;
  #line 7443 
  if (down_interruptible(& ai->sem) != 0) 
                                          #line 7444 
                                          return -11;
  #line 7446 
  __mptr = (void *)ai->network_list.next;
  #line 7446 
  net = ((BSSListElement *)(__mptr + 18446744073709550896U));
  #line 7446 
  while (& net->list != & ai->network_list) {
    #line 7446 
    void *__mptr_0;
    #line 7448 
    current_ev = airo_translate_scan(dev,info,current_ev,extra + (unsigned long)dwrq->length,& net->bss);
    #line 7453 
    if ((unsigned long)((extra + (unsigned long)dwrq->length) - current_ev) <= 24UL) {
      #line 7455 
      err = -7;
      #line 7456 
      goto out;
    }
    #line 7446 
    __mptr_0 = (void *)net->list.next;
    #line 7446 
    net = ((BSSListElement *)(__mptr_0 + 18446744073709550896U));
  }
  #line 7461 
  dwrq->length = (unsigned short)(current_ev - extra);
  #line 7462 
  dwrq->flags = (unsigned short)0U;
  #line 7464 
  out: 
       #line 7464 
  ;
  #line 7465 
  up(& ai->sem);
  #line 7466 
  return err;
}

#line 7473  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_config_commit(struct net_device *dev, struct iw_request_info *info, void *zwrq, char *extra)
{
  #line 7478 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 7480 
  if (! test_bit(13L,& local->flags)) 
                                      #line 7481 
                                      return 0;
  #line 7485 
  disable_MAC(local,1);
  #line 7486 
  if ((int)test_bit(14L,& local->flags) != 0) {
    #line 7487 
    SsidRid SSID_rid;
    #line 7489 
    readSsidRid(local,& SSID_rid);
    #line 7490 
    if ((int)test_bit(11L,& local->flags) != 0) 
                                                #line 7491 
                                                setup_card(local,dev->dev_addr,1); else 
                                                                    #line 7493 
                                                                    reset_airo_card(dev);
    #line 7494 
    disable_MAC(local,1);
    #line 7495 
    writeSsidRid(local,& SSID_rid,1);
    #line 7496 
    writeAPListRid(local,& local->APList,1);
  }
  #line 7498 
  if (down_interruptible(& local->sem) != 0) 
                                             #line 7499 
                                             return -512;
  #line 7500 
  writeConfigRid(local,0);
  #line 7501 
  enable_MAC(local,0);
  #line 7502 
  if ((int)test_bit(14L,& local->flags) != 0) 
                                              #line 7503 
                                              airo_set_promisc(local); else 
                                                                    #line 7505 
                                                                    up(& local->sem);
  #line 7507 
  return 0;
}

#line 7515  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct iw_priv_args airo_private_args[2U] = {{.cmd = 35808U, .set_args = (unsigned short)6160U, .get_args = (unsigned short)6143U, .name = {(char)'a', (char)'i', (char)'r', (char)'o', (char)'i', (char)'o', (char)'c', (char)'t', (char)'l'}}, {.cmd = 35809U, .set_args = (unsigned short)6160U, .get_args = (unsigned short)18433U, .name = {(char)'a', (char)'i', (char)'r', (char)'o', (char)'i', (char)'d', (char)'i', (char)'f', (char)'c'}}};
#line 7523  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static iw_handler airo_handler[55U] = {(int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_config_commit), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_name), [4] = (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_set_freq), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_freq), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_set_mode), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_mode), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_set_sens), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_sens), [11] = (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_range), [16] = & iw_handler_set_spy, & iw_handler_get_spy, & iw_handler_set_thrspy, & iw_handler_get_thrspy, (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_set_wap), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_wap), [23] = (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_aplist), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_set_scan), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_scan), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_set_essid), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_essid), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_set_nick), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_nick), [32] = (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_set_rate), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_rate), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_set_rts), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_rts), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_set_frag), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_frag), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_set_txpow), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_txpow), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_set_retry), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_retry), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_set_encode), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_encode), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_set_power), (int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))(& airo_get_power), [50] = & airo_set_auth, & airo_get_auth, & airo_set_encodeext, & airo_get_encodeext};
#line 7589  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static iw_handler airo_private_handler[1U] = {(int (*)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *))0};
#line 7594  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct iw_handler_def airo_handler_def = {.standard = (iw_handler *)(& airo_handler), .num_standard = (unsigned short)55U, .num_private = (unsigned short)1U, .num_private_args = (unsigned short)2U, .private = (iw_handler *)(& airo_private_handler), .private_args = (struct iw_priv_args *)(& airo_private_args), .get_wireless_stats = & airo_get_wireless_stats};
#line 7618  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int airo_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
  #line 7620 
  int rc = 0;
  #line 7621 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 7623 
  if (ai->power.event != 0) 
                            #line 7624 
                            return 0;
  #line 7626 
  switch (cmd) {
    #line 7628 
    case 35809: 
                #line 7628 
    ;
    #line 7630 
    case 35313: 
                #line 7630 
    ;
    {
      #line 7634 
      aironet_ioctl com;
      #line 7633 
      int val = 42330;
      #line 7635 
      if (copy_from_user((void *)(& com),rq->ifr_ifru.ifru_data,16UL) != 0UL) 
        #line 7636 
        rc = -14;
      else {
        #line 7637 
        if (copy_to_user((void *)com.data,(void *)(& val),4UL) != 0UL) 
          #line 7638 
          rc = -14;
      }
    }
    #line 7640 
    break;
    #line 7642 
    case 35808: 
                #line 7642 
    ;
    #line 7644 
    case 35312: 
                #line 7644 
    ;
    {
      #line 7650 
      aironet_ioctl com_0;
      #line 7651 
      if (copy_from_user((void *)(& com_0),rq->ifr_ifru.ifru_data,16UL) != 0UL) {
        #line 7652 
        rc = -14;
        #line 7653 
        break;
      }
      #line 7658 
      if ((unsigned int)com_0.command == 17U) {
        #line 7659 
        if (copy_to_user((void *)com_0.data,(void *)(& swversion),4UL) != 0UL) 
          #line 7660 
          rc = -14; else 
                         #line 7662 
                         rc = 0;
      }
      else 
        #line 7664 
        if ((unsigned int)com_0.command <= 15U) 
                                                #line 7665 
                                                rc = readrids(dev,& com_0);
        else 
          #line 7666 
          if ((unsigned int)com_0.command + 65486U <= 14U) 
                                                           #line 7667 
                                                           rc = writerids(dev,& com_0);
          else 
            #line 7668 
            if ((unsigned int)com_0.command + 65436U <= 5U) 
                                                            #line 7669 
                                                            rc = flashcard(dev,& com_0); else 
                                                                    #line 7671 
                                                                    rc = -22;
    }
    #line 7673 
    break;
    #line 7677 
    default: 
             #line 7677 
    ;
    #line 7678 
    rc = -95;
  }
  #line 7680 
  return rc;
}

#line 7692  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static void airo_read_wireless_stats(struct airo_info *local)
{
  #line 7694 
  StatusRid status_rid;
  #line 7695 
  StatsRid stats_rid;
  #line 7696 
  CapabilityRid cap_rid;
  #line 7697 
  __le32 *vals = (__le32 *)(& stats_rid.vals);
  #line 7700 
  cif_clear_bit(8L,& local->jobs);
  #line 7701 
  if (local->power.event != 0) {
    #line 7702 
    up(& local->sem);
    #line 7703 
    return;
  }
  #line 7705 
  readCapabilityRid(local,& cap_rid,0);
  #line 7706 
  readStatusRid(local,& status_rid,0);
  #line 7707 
  readStatsRid(local,& stats_rid,65384,0);
  #line 7708 
  up(& local->sem);
  #line 7711 
  local->wstats.status = status_rid.mode;
  #line 7714 
  if (local->rssi != (tdsRssiEntry *)0) {
    #line 7715 
    local->wstats.qual.level = airo_rssi_to_dbm(local->rssi,(unsigned char)((int)((unsigned char)status_rid.sigQuality)));
    #line 7719 
    local->wstats.qual.qual = (unsigned char)status_rid.normalizedSignalStrength;
  }
  else {
    #line 7722 
    local->wstats.qual.level = (unsigned char)(((int)status_rid.normalizedSignalStrength + 321) / 2);
    #line 7724 
    local->wstats.qual.qual = (unsigned char)airo_get_quality(& status_rid,& cap_rid);
  }
  #line 7726 
  if ((unsigned int)status_rid.len > 123U) {
    #line 7727 
    local->wstats.qual.noise = (unsigned char)(- ((int)status_rid.noisedBm));
    #line 7728 
    local->wstats.qual.updated = (unsigned char)15U;
  }
  else {
    #line 7730 
    local->wstats.qual.noise = (unsigned char)0U;
    #line 7731 
    local->wstats.qual.updated = (unsigned char)75U;
  }
  #line 7736 
  local->wstats.discard.nwid = (*(vals + 56U) + *(vals + 57U)) + *(vals + 58U);
  #line 7739 
  local->wstats.discard.code = *(vals + 6U);
  #line 7740 
  local->wstats.discard.fragment = *(vals + 30U);
  #line 7741 
  local->wstats.discard.retries = *(vals + 10U);
  #line 7742 
  local->wstats.discard.misc = *(vals + 1U) + *(vals + 32U);
  #line 7744 
  local->wstats.miss.beacon = *(vals + 34U);
  #line 7745 
  return;
}

#line 7747  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static struct iw_statistics *airo_get_wireless_stats(struct net_device *dev)
{
  #line 7749 
  struct airo_info *local = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 7751 
  if (! test_bit(8L,& local->jobs)) {
    #line 7753 
    if (down_trylock(& local->sem) != 0) {
      #line 7754 
      cif_set_bit(8L,& local->jobs);
      #line 7755 
      __wake_up(& local->thr_wait,1U,1,(void *)0);
    }
    else 
         #line 7757 
         airo_read_wireless_stats(local);
  }
  #line 7760 
  return & local->wstats;
}

#line 7770  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int readrids(struct net_device *dev, aironet_ioctl *comp)
{
  #line 7824 
  int __UNIQUE_ID___x496;
  #line 7824 
  int tmp_6;
  #line 7771 
  unsigned short ridcode;
  #line 7772 
  unsigned char *iobuf;
  #line 7773 
  int len;
  #line 7774 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 7776 
  if ((int)test_bit(15L,& ai->flags) != 0) 
                                           #line 7777 
                                           return -5;
  #line 7779 
  switch ((int)comp->command) {
    #line 7800 
    int __UNIQUE_ID___x494;
    #line 7800 
    int tmp_1;
    #line 7781 
    case 0: 
            #line 7781 
    ;
    #line 7781 
    ridcode = (unsigned short)65280U;
    #line 7781 
    break;
    #line 7782 
    case 1: 
            #line 7782 
    ;
    #line 7782 
    ridcode = (unsigned short)65296U;
    #line 7783 
    if ((int)test_bit(13L,& ai->flags) != 0) {
      #line 7784 
      disable_MAC(ai,1);
      #line 7785 
      writeConfigRid(ai,1);
      #line 7786 
      enable_MAC(ai,1);
    }
    #line 7788 
    break;
    #line 7789 
    case 2: 
            #line 7789 
    ;
    #line 7789 
    ridcode = (unsigned short)65297U;
    #line 7789 
    break;
    #line 7790 
    case 3: 
            #line 7790 
    ;
    #line 7790 
    ridcode = (unsigned short)65298U;
    #line 7790 
    break;
    #line 7791 
    case 4: 
            #line 7791 
    ;
    #line 7791 
    ridcode = (unsigned short)65299U;
    #line 7791 
    break;
    #line 7792 
    case 5: 
            #line 7792 
    ;
    #line 7792 
    ridcode = (unsigned short)65300U;
    #line 7792 
    break;
    #line 7793 
    case 6: 
            #line 7793 
    ;
    #line 7793 
    ridcode = (unsigned short)65301U;
    #line 7793 
    break;
    #line 7794 
    case 7: 
            #line 7794 
    ;
    #line 7794 
    ridcode = (unsigned short)65302U;
    #line 7794 
    break;
    #line 7795 
    case 8: 
            #line 7795 
    ;
    #line 7795 
    ridcode = (unsigned short)65360U;
    #line 7795 
    break;
    #line 7796 
    case 10: 
             #line 7796 
    ;
    #line 7796 
    ridcode = (unsigned short)65385U;
    #line 7796 
    break;
    #line 7797 
    case 9: 
            #line 7797 
    ;
    #line 7797 
    ridcode = (unsigned short)65384U;
    #line 7797 
    break;
    #line 7798 
    case 12: 
             #line 7798 
    ;
    {
      #line 7800 
      __UNIQUE_ID___x494 = (int)comp->len;
      #line 7800 
      int __UNIQUE_ID___y495 = 156;
      #line 7800 
      if (__UNIQUE_ID___x494 < __UNIQUE_ID___y495) 
                                                   #line 7800 
                                                   tmp_1 = __UNIQUE_ID___x494; else 
                                                                    #line 7800 
                                                                    tmp_1 = __UNIQUE_ID___y495;
      }
    #line 7799 
    ;
    #line 7799 
    ;
    #line 7799 
    if (copy_to_user((void *)comp->data,(void *)(& ai->micstats),
                     (unsigned long)tmp_1) != 0UL) 
      #line 7801 
      return -14;
    #line 7802 
    return 0;
    #line 7803 
    case 15: 
             #line 7803 
    ;
    #line 7803 
    ridcode = comp->ridnum;
    #line 7803 
    break;
    #line 7804 
    default: 
             #line 7804 
    ;
    #line 7805 
    return -22;
  }
  #line 7808 
  if ((unsigned int)ridcode + 235U <= 1U) {
    #line 7810 
    if (! capable(12)) 
                       #line 7811 
                       return -1;
  }
  #line 7814 
  iobuf = (unsigned char *)kzalloc(2048UL,3264U);
  #line 7814 
  if (iobuf == (unsigned char *)0U) 
                                    #line 7815 
                                    return -12;
  #line 7817 
  PC4500_readrid(ai,(unsigned short)((int)ridcode),(void *)iobuf,2048,1);
  #line 7822 
  len = (int)comp->len;
  {
    #line 7824 
    __UNIQUE_ID___x496 = len;
    #line 7824 
    int __UNIQUE_ID___y497 = 2048;
    #line 7824 
    if (__UNIQUE_ID___x496 < __UNIQUE_ID___y497) 
                                                 #line 7824 
                                                 tmp_6 = __UNIQUE_ID___x496; else 
                                                                    #line 7824 
                                                                    tmp_6 = __UNIQUE_ID___y497;
    }
  #line 7824 
  ;
  #line 7824 
  ;
  #line 7824 
  if (copy_to_user((void *)comp->data,(void *)iobuf,(unsigned long)tmp_6) != 0UL) {
    #line 7825 
    kfree((void *)iobuf);
    #line 7826 
    return -14;
  }
  #line 7828 
  kfree((void *)iobuf);
  #line 7829 
  return 0;
}

#line 7836  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int writerids(struct net_device *dev, aironet_ioctl *comp)
{
  #line 7838 
  int ridcode;
  #line 7839 
  int enabled;
  #line 7840 
  int (*writer)(struct airo_info *, u16 , void *, int , int );
  #line 7841 
  unsigned char *iobuf;
  #line 7837 
  struct airo_info *ai = (struct airo_info *)dev->__anonCompField_net_device_161.ml_priv;
  #line 7844 
  if (! capable(12)) 
                     #line 7845 
                     return -1;
  #line 7847 
  if ((int)test_bit(15L,& ai->flags) != 0) 
                                           #line 7848 
                                           return -5;
  #line 7850 
  ridcode = 0;
  #line 7851 
  writer = & do_writerid;
  #line 7853 
  switch ((int)comp->command) {
    #line 7900 
    int __UNIQUE_ID___x498;
    #line 7900 
    int tmp_3;
    #line 7855 
    case 54: 
             #line 7855 
    ;
    #line 7855 
    ridcode = 65297;
    #line 7855 
    break;
    #line 7856 
    case 50: 
             #line 7856 
    ;
    #line 7856 
    ridcode = 65280;
    #line 7856 
    break;
    #line 7857 
    case 55: 
             #line 7857 
    ;
    #line 7857 
    ridcode = 65298;
    #line 7857 
    break;
    #line 7858 
    case 53: 
             #line 7858 
    ;
    #line 7858 
    ai->config.len = (unsigned short)0U;
    #line 7859 
    cif_clear_bit(13L,& ai->flags);
    #line 7860 
    ridcode = 65296;
    #line 7860 
    break;
    #line 7861 
    case 60: 
             #line 7861 
    ;
    #line 7861 
    ridcode = 65302;
    #line 7861 
    break;
    #line 7862 
    case 62: 
             #line 7862 
    ;
    #line 7862 
    ridcode = 65315;
    #line 7862 
    break;
    #line 7863 
    case 61: 
             #line 7863 
    ;
    #line 7863 
    ridcode = 65316;
    #line 7863 
    break;
    #line 7864 
    case 59: 
             #line 7864 
    ;
    #line 7864 
    ridcode = 65301;
    #line 7864 
    writer = & PC4500_writerid;
    #line 7865 
    break;
    #line 7866 
    case 63: 
             #line 7866 
    ;
    #line 7866 
    ridcode = 65322;
    #line 7866 
    break;
    #line 7867 
    case 64: 
             #line 7867 
    ;
    #line 7867 
    ridcode = 65323;
    #line 7867 
    break;
    #line 7872 
    case 56: 
             #line 7872 
    ;
    #line 7873 
    if (enable_MAC(ai,1) != 0) 
                               #line 7874 
                               return -5;
    #line 7875 
    return 0;
    #line 7881 
    case 57: 
             #line 7881 
    ;
    #line 7882 
    disable_MAC(ai,1);
    #line 7883 
    return 0;
    #line 7889 
    case 58: 
             #line 7889 
    ;
    #line 7890 
    iobuf = (unsigned char *)kmalloc(2048UL,3264U);
    #line 7890 
    if (iobuf == (unsigned char *)0U) 
                                      #line 7891 
                                      return -12;
    #line 7893 
    PC4500_readrid(ai,(unsigned short)65386,(void *)iobuf,2048,1);
    #line 7895 
    enabled = (int)ai->micstats.enabled;
    #line 7896 
    memset((void *)(& ai->micstats),0,156UL);
    #line 7897 
    ai->micstats.enabled = (unsigned char)enabled;
    {
      #line 7900 
      __UNIQUE_ID___x498 = (int)comp->len;
      #line 7900 
      int __UNIQUE_ID___y499 = 2048;
      #line 7900 
      if (__UNIQUE_ID___x498 < __UNIQUE_ID___y499) 
                                                   #line 7900 
                                                   tmp_3 = __UNIQUE_ID___x498; else 
                                                                    #line 7900 
                                                                    tmp_3 = __UNIQUE_ID___y499;
      }
    #line 7899 
    ;
    #line 7899 
    ;
    #line 7899 
    if (copy_to_user((void *)comp->data,(void *)iobuf,(unsigned long)tmp_3) != 0UL) {
      #line 7901 
      kfree((void *)iobuf);
      #line 7902 
      return -14;
    }
    #line 7904 
    kfree((void *)iobuf);
    #line 7905 
    return 0;
    #line 7907 
    default: 
             #line 7907 
    ;
    #line 7908 
    return -95;
  }
  #line 7910 
  if ((unsigned int)comp->len > 2048U) 
                                       #line 7911 
                                       return -22;
  #line 7913 
  iobuf = (unsigned char *)kmalloc(2048UL,3264U);
  #line 7913 
  if (iobuf == (unsigned char *)0U) 
                                    #line 7914 
                                    return -12;
  #line 7916 
  if (copy_from_user((void *)iobuf,(void *)comp->data,
                       (unsigned long)comp->len) != 0UL) {
    #line 7917 
    kfree((void *)iobuf);
    #line 7918 
    return -14;
  }
  #line 7921 
  if ((unsigned int)comp->command == 53U) {
    #line 7922 
    ConfigRid *cfg = (ConfigRid *)iobuf;
    #line 7924 
    if ((int)test_bit(4L,& ai->flags) != 0) 
                                            #line 7925 
                                            cfg->opmode = (unsigned short)((unsigned int)cfg->opmode | 32768U);
    #line 7927 
    if (((int)cfg->opmode & 255) == 0) 
                                       #line 7928 
                                       cif_set_bit(3L,& ai->flags); else 
                                                                    #line 7930 
                                                                    cif_clear_bit(3L,& ai->flags);
  }
  #line 7933 
  if ((*writer)(ai,(unsigned short)((int)((unsigned short)ridcode)),
                  (void *)iobuf,(int)comp->len,1) != 0) {
    #line 7934 
    kfree((void *)iobuf);
    #line 7935 
    return -5;
  }
  #line 7937 
  kfree((void *)iobuf);
  #line 7938 
  return 0;
}

#line 7950  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int flashcard(struct net_device *dev, aironet_ioctl *comp)
{
  #line 7951 
  int z;
  #line 7954 
  if (! capable(12)) 
                     #line 7955 
                     return -1;
  #line 7957 
  switch ((int)comp->command) {
    #line 7959 
    case 100: 
              #line 7959 
    ;
    #line 7960 
    return cmdreset((struct airo_info *)dev->__anonCompField_net_device_161.ml_priv);
    #line 7962 
    case 102: 
              #line 7962 
    ;
    #line 7963 
    if (((struct airo_info *)dev->__anonCompField_net_device_161.ml_priv)->flash == (unsigned short *)0U) {
      #line 7963 
      ((struct airo_info *)dev->__anonCompField_net_device_161.ml_priv)->flash = (unsigned short *)kmalloc(32768UL,3264U);
      #line 7963 
      if ((unsigned short *)kmalloc(32768UL,3264U) == (unsigned short *)0U) 
        #line 7965 
        return -12;
    }
    #line 7966 
    return setflashmode((struct airo_info *)dev->__anonCompField_net_device_161.ml_priv);
    #line 7968 
    case 101: 
              #line 7968 
    ;
    #line 7969 
    if ((unsigned int)comp->len != 4U) 
                                       #line 7970 
                                       return -22;
    #line 7971 
    if (copy_from_user((void *)(& z),(void *)comp->data,
                       (unsigned long)comp->len) != 0UL) 
      #line 7972 
      return -14;
    #line 7973 
    return flashgchar((struct airo_info *)dev->__anonCompField_net_device_161.ml_priv,
                   z,8000);
    #line 7975 
    case 103: 
              #line 7975 
    ;
    #line 7976 
    if ((unsigned int)comp->len != 4U) 
                                       #line 7977 
                                       return -22;
    #line 7978 
    if (copy_from_user((void *)(& z),(void *)comp->data,
                       (unsigned long)comp->len) != 0UL) 
      #line 7979 
      return -14;
    #line 7980 
    return flashpchar((struct airo_info *)dev->__anonCompField_net_device_161.ml_priv,
                   z,8000);
    #line 7982 
    case 104: 
              #line 7982 
    ;
    #line 7983 
    if (((struct airo_info *)dev->__anonCompField_net_device_161.ml_priv)->flash == (unsigned short *)0U) 
      #line 7984 
      return -12;
    #line 7985 
    if ((unsigned int)comp->len > 32768U) 
                                          #line 7986 
                                          return -22;
    #line 7987 
    if (copy_from_user((void *)((struct airo_info *)dev->__anonCompField_net_device_161.ml_priv)->flash,
                       (void *)comp->data,(unsigned long)comp->len) != 0UL) 
      #line 7988 
      return -14;
    #line 7990 
    flashputbuf((struct airo_info *)dev->__anonCompField_net_device_161.ml_priv);
    #line 7991 
    return 0;
    #line 7993 
    case 105: 
              #line 7993 
    ;
    #line 7994 
    if (flashrestart((struct airo_info *)dev->__anonCompField_net_device_161.ml_priv,
                     dev) != 0) 
      #line 7995 
      return -5;
    #line 7996 
    return 0;
  }
  #line 7998 
  return -22;
}

#line 8009  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int cmdreset(struct airo_info *ai)
{
  #line 8010 
  disable_MAC(ai,1);
  #line 8012 
  if (waitbusy(ai) == 0) {
    #line 8013 
    printk((char *)"\001",(char *)(& (ai->dev)->name));
    #line 8014 
    return -16;
  }
  #line 8017 
  OUT4500(ai,(unsigned short)0,(unsigned short)4);
  #line 8019 
  ssleep(1U);
  #line 8021 
  if (waitbusy(ai) == 0) {
    #line 8022 
    printk((char *)"\001",(char *)(& (ai->dev)->name));
    #line 8023 
    return -16;
  }
  #line 8025 
  return 0;
}

#line 8033  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int setflashmode(struct airo_info *ai)
{
  #line 8034 
  cif_set_bit(15L,& ai->flags);
  #line 8036 
  OUT4500(ai,(unsigned short)40,(unsigned short)32382);
  #line 8037 
  OUT4500(ai,(unsigned short)42,(unsigned short)32382);
  #line 8038 
  if (probe != 0) {
    #line 8039 
    OUT4500(ai,(unsigned short)40,(unsigned short)32382);
    #line 8040 
    OUT4500(ai,(unsigned short)0,(unsigned short)16);
  }
  else {
    #line 8042 
    OUT4500(ai,(unsigned short)44,(unsigned short)32382);
    #line 8043 
    OUT4500(ai,(unsigned short)46,(unsigned short)32382);
    #line 8044 
    OUT4500(ai,(unsigned short)0,(unsigned short)0);
  }
  #line 8046 
  msleep(500U);
  #line 8048 
  if (waitbusy(ai) == 0) {
    #line 8049 
    cif_clear_bit(15L,& ai->flags);
    #line 8050 
    printk((char *)"\001",(char *)(& (ai->dev)->name));
    #line 8051 
    return -5;
  }
  #line 8053 
  return 0;
}

#line 8060  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int flashpchar(struct airo_info *ai, int byte, int dwelltime)
{
  #line 8061 
  int echo;
  #line 8062 
  int waittime;
  #line 8093 
  int tmp_1;
  #line 8064 
  byte |= 32768;
  #line 8066 
  if (dwelltime == 0) 
                      #line 8067 
                      dwelltime = 200;
  #line 8069 
  waittime = dwelltime;
  #line 8072 
  while (1) {
    #line 8072 
    if (((int)IN4500(ai,(unsigned short)40) & 32768) != 0) {
      #line 8072 
      if (! (waittime > 0)) 
                            #line 8072 
                            break;
    }
    else 
         #line 8072 
         break;
    #line 8073 
    __const_udelay(214750UL);
    #line 8074 
    waittime += -50;
  }
  #line 8078 
  if (waittime <= 0) {
    #line 8079 
    printk((char *)"\001",(char *)(& (ai->dev)->name));
    #line 8080 
    return -16;
  }
  #line 8084 
  while (1) {
    {
      #line 8085 
      OUT4500(ai,(unsigned short)40,(unsigned short)((int)((unsigned short)byte)));
      #line 8086 
      __const_udelay(214750UL);
      #line 8087 
      dwelltime += -50;
      #line 8088 
      echo = (int)IN4500(ai,(unsigned short)42);
    }
    #line 8089 
    if (! (dwelltime >= 0 && echo != byte)) 
                                            #line 8084 
                                            break;
  }
  #line 8091 
  OUT4500(ai,(unsigned short)42,(unsigned short)0);
  #line 8093 
  if (echo == byte) 
                    #line 8093 
                    tmp_1 = 0; else 
                                    #line 8093 
                                    tmp_1 = -5;
  #line 8093 
  return tmp_1;
}

#line 8100  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int flashgchar(struct airo_info *ai, int matchbyte, int dwelltime)
{
  #line 8101 
  int rchar;
  #line 8102 
  unsigned char rbyte = (unsigned char)0U;
  #line 8104 
  while (1) {
    {
      #line 8105 
      rchar = (int)IN4500(ai,(unsigned short)42);
      #line 8107 
      if (dwelltime != 0 && (rchar & 32768) == 0) {
        #line 8108 
        dwelltime += -10;
        {
          #line 8109 
          unsigned long __ms = 10UL;
          #line 8109 
          while (1) {
            #line 8109 
            unsigned long tmp_0;
            #line 8109 
            tmp_0 = __ms;
            #line 8109 
            __ms --;
            #line 8109 
            ;
            #line 8109 
            if (! (tmp_0 != 0UL)) 
                                  #line 8109 
                                  break;
            #line 8109 
            __const_udelay(4295000UL);
          }
        }
        #line 8110 
        goto __Cont;
      }
      #line 8112 
      rbyte = (unsigned char)rchar;
      #line 8114 
      if ((int)rbyte == matchbyte && (rchar & 32768) != 0) {
        #line 8115 
        OUT4500(ai,(unsigned short)42,(unsigned short)0);
        #line 8116 
        return 0;
      }
      #line 8118 
      if (((unsigned int)rbyte + 127U <= 2U || (unsigned int)rbyte == 26U) || rchar == 65535) 
        #line 8119 
        break;
      #line 8120 
      OUT4500(ai,(unsigned short)42,(unsigned short)0);
    }
    #line 8104 
    __Cont: 
            #line 8121 
    ;
    #line 8121 
    if (! (dwelltime > 0)) 
                           #line 8104 
                           break;
  }
  #line 8123 
  return -5;
}

#line 8131  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int flashputbuf(struct airo_info *ai)
{
  #line 8132 
  int nwords;
  #line 8135 
  if ((int)test_bit(11L,& ai->flags) != 0) 
                                           #line 8136 
                                           memcpy_toio((void *)(ai->pciaux + 32768U),(void *)ai->flash,32768UL);
  else {
    #line 8138 
    OUT4500(ai,(unsigned short)58,(unsigned short)256);
    #line 8139 
    OUT4500(ai,(unsigned short)60,(unsigned short)0);
    #line 8141 
    nwords = 0;
    #line 8141 
    while (nwords != 16384) {
      #line 8142 
      OUT4500(ai,(unsigned short)62,(unsigned short)((int)*(ai->flash + (unsigned long)nwords)));
      #line 8141 
      nwords ++;
    }
  }
  #line 8145 
  OUT4500(ai,(unsigned short)40,(unsigned short)32768);
  #line 8147 
  return 0;
}

#line 8153  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/drivers/net/wireless/cisco/airo.c"
static int flashrestart(struct airo_info *ai, struct net_device *dev)
{
  #line 8154 
  int i;
  #line 8154 
  int status;
  #line 8156 
  ssleep(1U);
  #line 8157 
  cif_clear_bit(15L,& ai->flags);
  #line 8158 
  if ((int)test_bit(11L,& ai->flags) != 0) {
    #line 8159 
    status = mpi_init_descriptors(ai);
    #line 8160 
    if (status != 0) 
                     #line 8161 
                     return status;
  }
  #line 8163 
  status = (int)setup_card(ai,dev->dev_addr,1);
  #line 8165 
  if (! test_bit(11L,& ai->flags)) {
    #line 8166 
    i = 0;
    #line 8166 
    while (i <= 5) {
      #line 8167 
      ai->fids[i] = (unsigned int)transmit_allocate(ai,2312,i > 2);
      #line 8166 
      i ++;
    }
  }
  #line 8171 
  ssleep(1U);
  #line 8172 
  return status;
}

#line 93  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
struct pci_driver *emg_alias_airo_driver = & airo_driver;
#line 94  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
struct pci_device_id (*emg_alias_card_ids)[8U] = & card_ids;
#line 97 
#line 97 
int emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2);
#line 98 
#line 98 
struct net_device *emg_alloc_netdev_mqs(int arg0, char *arg1, unsigned char arg2, void (*arg3)(struct net_device *), unsigned int arg4, unsigned int arg5);
#line 99 
#line 99 
void *emg_free_irq(unsigned int arg0, void *arg1);
#line 100 
#line 100 
void emg_free_netdev(struct net_device *arg0);
#line 101 
#line 101 
struct task_struct *emg_kthread_create_on_node(int (*arg0)(void *), void *arg1, int arg2, char *arg3 , ...);
#line 102 
#line 102 
void emg_pci_unregister_driver(struct pci_driver *arg0);
#line 103 
#line 103 
int emg_register_netdev(struct net_device *arg0);
#line 104 
#line 104 
int emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4);
#line 105 
#line 105 
void emg_unregister_netdev(struct net_device *arg0);
#line 109  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
void emg_airo_cleanup_module(void)
{
  #line 110 
  airo_cleanup_module();
  #line 111 
  return;
}

#line 113  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
int emg_airo_init_module(void)
{
  #line 114 
  return airo_init_module();
}

#line 117  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
int emg_wrapper_airo_close(struct net_device *arg0)
{
  #line 118 
  return airo_close(arg0);
}

#line 122  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
struct net_device_stats *emg_wrapper_airo_get_stats(struct net_device *arg0)
{
  #line 123 
  return airo_get_stats(arg0);
}

#line 127  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
enum irqreturn emg_wrapper_airo_interrupt(int arg0, void *arg1)
{
  #line 128 
  return airo_interrupt(arg0,arg1);
}

#line 132  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
int emg_wrapper_airo_ioctl(struct net_device *arg0, struct ifreq *arg1, int arg2)
{
  #line 133 
  return airo_ioctl(arg0,arg1,arg2);
}

#line 137  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
int emg_wrapper_airo_open(struct net_device *arg0)
{
  #line 138 
  return airo_open(arg0);
}

#line 142  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
int emg_wrapper_airo_pci_probe(struct pci_dev *arg0, struct pci_device_id *arg1)
{
  #line 143 
  return airo_pci_probe(arg0,arg1);
}

#line 147  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
void emg_wrapper_airo_pci_remove(struct pci_dev *arg0)
{
  #line 148 
  airo_pci_remove(arg0);
  #line 149 
  return;
}

#line 152  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
int emg_wrapper_airo_pci_resume(struct pci_dev *arg0)
{
  #line 153 
  return airo_pci_resume(arg0);
}

#line 157  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
int emg_wrapper_airo_pci_suspend(struct pci_dev *arg0, struct pm_message arg1)
{
  #line 158 
  return airo_pci_suspend(arg0,arg1);
}

#line 162  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
int emg_wrapper_airo_set_mac_address(struct net_device *arg0, void *arg1)
{
  #line 163 
  return airo_set_mac_address(arg0,arg1);
}

#line 167  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
void emg_wrapper_airo_set_multicast_list(struct net_device *arg0)
{
  #line 168 
  airo_set_multicast_list(arg0);
  #line 169 
  return;
}

#line 172  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
enum netdev_tx emg_wrapper_airo_start_xmit(struct sk_buff *arg0, struct net_device *arg1)
{
  #line 173 
  return airo_start_xmit(arg0,arg1);
}

#line 177  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
enum netdev_tx emg_wrapper_airo_start_xmit11(struct sk_buff *arg0, struct net_device *arg1)
{
  #line 178 
  return airo_start_xmit11(arg0,arg1);
}

#line 182  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
int emg_wrapper_airo_thread(void *arg0)
{
  #line 183 
  return airo_thread(arg0);
}

#line 187  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
enum netdev_tx emg_wrapper_mpi_start_xmit(struct sk_buff *arg0, struct net_device *arg1)
{
  #line 188 
  return mpi_start_xmit(arg0,arg1);
}

#line 207  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void cif_set_bit(long nr, unsigned long *addr)
{
  #line 210 
  ldv_set_bit(nr,addr);
  #line 211 
  return;
}

#line 214  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void cif_clear_bit(long nr, unsigned long *addr)
{
  #line 217 
  ldv_clear_bit(nr,addr);
  #line 218 
  return;
}

#line 221  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void INIT_LIST_HEAD(struct list_head *list)
{
  #line 224 
  ldv_init_list_head(list);
  #line 225 
  return;
}

#line 228  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static int cif_strncmp(char *cs, char *ct, __kernel_size_t count)
{
  #line 231 
  return ldv_strncmp(cs,ct,count);
}

#line 235  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static size_t cif_strlen(char *s)
{
  #line 238 
  return ldv_strlen(s);
}

#line 298  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static long PTR_ERR(void *ptr)
{
  #line 301 
  return ldv_ptr_err(ptr);
}

#line 305  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static bool IS_ERR(void *ptr)
{
  #line 308 
  return ldv_is_err(ptr);
}

#line 517  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void *kmalloc(size_t size, gfp_t flags)
{
  #line 520 
  return ldv_kmalloc(size,flags);
}

#line 524  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void *kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  #line 527 
  return ldv_kmalloc_array(n,size,flags);
}

#line 531  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void *kcalloc(size_t n, size_t size, gfp_t flags)
{
  #line 534 
  return ldv_kcalloc(n,size,flags);
}

#line 552  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void *kzalloc(size_t size, gfp_t flags)
{
  #line 555 
  return ldv_kzalloc(size,flags);
}

#line 737  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static struct task_struct *cif_kthread_create_on_node(int (*threadfn)(void *), void *data, int node, char *namefmt , ...)
{
  #line 740 
  __builtin_va_list ldv_func_arg5;
  #line 741 
  #line 741 
  __builtin_va_start(ldv_func_arg5,namefmt);
  #line 744 
  return emg_kthread_create_on_node(threadfn,data,node,namefmt);
}

#line 748  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static int cif_request_irq(unsigned int irq_0, irqreturn_t (*handler)(int , void *), unsigned long flags, char *name, void *dev)
{
  #line 752 
  return emg_request_irq(irq_0,handler,flags,name,dev);
}

#line 756  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void cif___ldv_spin_lock_aux_lock_of_airo_info(spinlock_t *lock)
{
  #line 759 
  ldv_spin_model_lock((char *)"aux_lock_of_airo_info");
  #line 761 
  __ldv_spin_lock(lock);
  #line 762 
  return;
}

#line 765  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void cif_spin_unlock_irqrestore_aux_lock_of_airo_info(spinlock_t *lock, unsigned long flags)
{
  #line 768 
  ldv_spin_model_unlock((char *)"aux_lock_of_airo_info");
  #line 770 
  spin_unlock_irqrestore(lock,flags);
  #line 771 
  return;
}

#line 774  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void *cif_free_irq(unsigned int ldv_func_arg1, void *ldv_func_arg2)
{
  #line 778 
  return emg_free_irq(ldv_func_arg1,ldv_func_arg2);
}

#line 782  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void cif_unregister_netdev(struct net_device *dev)
{
  #line 786 
  emg_unregister_netdev(dev);
  #line 787 
  return;
}

#line 790  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void cif_free_netdev(struct net_device *dev)
{
  #line 794 
  emg_free_netdev(dev);
  #line 795 
  return;
}

#line 798  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static struct net_device *cif_alloc_netdev_mqs(int sizeof_priv, char *name, unsigned char name_assign_type, void (*setup)(struct net_device *), unsigned int txqs, unsigned int rxqs)
{
  #line 802 
  return emg_alloc_netdev_mqs(sizeof_priv,name,
                           (unsigned char)((int)name_assign_type),setup,txqs,
                           rxqs);
}

#line 806  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static int cif_register_netdev(struct net_device *dev)
{
  #line 810 
  return emg_register_netdev(dev);
}

#line 814  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static int cif___pci_register_driver(struct pci_driver *ldv_func_arg1, struct module *ldv_func_arg2, char *mod_name)
{
  #line 818 
  return emg___pci_register_driver(ldv_func_arg1,ldv_func_arg2,mod_name);
}

#line 822  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/0/concurrency safety/weaver/airo.i.aux"
static void cif_pci_unregister_driver(struct pci_driver *dev)
{
  #line 826 
  emg_pci_unregister_driver(dev);
  #line 827 
  return;
}

#line 20  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/common/inline_asm.c"
void ldv_inline_asm(void)
{
  #line 24 
  return;
}

#line 20  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
void ldv_atomic_add(int i, atomic_t *v)
{
  #line 22 
  v->counter += i;
  #line 23 
  return;
}

#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
void ldv_atomic_sub(int i, atomic_t *v)
{
  #line 27 
  v->counter -= i;
  #line 28 
  return;
}

#line 30  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_sub_and_test(int i, atomic_t *v)
{
  #line 32 
  v->counter -= i;
  #line 33 
  if (v->counter != 0) 
                       #line 34 
                       return 0;
  #line 36 
  return 1;
}

#line 39  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
void ldv_atomic_inc(atomic_t *v)
{
  #line 41 
  (v->counter) ++;
  #line 42 
  return;
}

#line 44  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
void ldv_atomic_dec(atomic_t *v)
{
  #line 46 
  (v->counter) --;
  #line 47 
  return;
}

#line 49  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v)
{
  #line 51 
  (v->counter) --;
  #line 52 
  if (v->counter != 0) 
                       #line 53 
                       return 0;
  #line 55 
  return 1;
}

#line 58  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v)
{
  #line 60 
  (v->counter) ++;
  #line 61 
  if (v->counter != 0) 
                       #line 62 
                       return 0;
  #line 64 
  return 1;
}

#line 67  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_add_return(int i, atomic_t *v)
{
  #line 69 
  v->counter += i;
  #line 70 
  return v->counter;
}

#line 73  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_add_negative(int i, atomic_t *v)
{
  #line 75 
  v->counter += i;
  #line 76 
  return v->counter < 0;
}

#line 79  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/atomic.c"
int ldv_atomic_inc_short(short *v)
{
  #line 81 
  *v = (short)((unsigned int)*v + 1U);
  #line 82 
  return (int)*v;
}

#line 20  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/current.c"
static struct task_struct ldv_current;
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/arch/asm/current.c"
struct task_struct *ldv_get_current(void)
{
  #line 28 
  ldv_current.pid = 1;
  #line 29 
  return & ldv_current;
}

#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
void ldv_switch_to_interrupt_context(void);
#line 42  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 34  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
void ldv_switch_to_process_context(void);
#line 50  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 40  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
bool ldv_in_interrupt_context(void);
#line 112  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 55  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_post_init(int init_ret_val);
#line 132  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_post_probe(int probe_ret_val);
#line 133  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 133 
void ldv_check_return_value_probe(int);
#line 141 
#line 68  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_filter_err_code(int ret_val);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/common.h"
#line 23 
void __VERIFIER_assume(int);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
static bool __ldv_in_interrupt_context = (_Bool)0;
#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
void ldv_switch_to_interrupt_context(void)
{
  #line 31 
  __ldv_in_interrupt_context = (_Bool)1;
  #line 32 
  return;
}

#line 34  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
void ldv_switch_to_process_context(void)
{
  #line 37 
  __ldv_in_interrupt_context = (_Bool)0;
  #line 38 
  return;
}

#line 40  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
bool ldv_in_interrupt_context(void)
{
  #line 42 
  return __ldv_in_interrupt_context;
}

#line 45  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
static int ldv_filter_positive_int(int val)
{
  #line 47 
  __VERIFIER_assume(val <= 0);
  #line 48 
  return val;
}

#line 55  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_post_init(int init_ret_val)
{
  #line 57 
  return ldv_filter_positive_int(init_ret_val);
}

#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_post_probe(int probe_ret_val)
{
  #line 63 
  ldv_check_return_value_probe(probe_ret_val);
  #line 64 
  return ldv_filter_positive_int(probe_ret_val);
}

#line 68  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/common.c"
int ldv_filter_err_code(int ret_val)
{
  #line 70 
  return ldv_filter_positive_int(ret_val);
}

#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/common/list.h"
#line 28 
void ldv_save_allocated_memory_to_list(void *);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/device.h"
#line 29  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device *dev);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/device.h"
#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data);
#line 57  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 57 
void *ldv_xzalloc(size_t size);
#line 29  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device *dev)
{
  #line 31 
  if (dev != (struct device *)0 && dev->p != (struct device_private *)0) 
    #line 32 
    return (dev->p)->driver_data;
  #line 34 
  return (void *)0;
}

#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev, void *data)
{
  #line 45 
  dev->p = (struct device_private *)ldv_xzalloc(8UL);
  #line 46 
  ldv_save_allocated_memory_to_list((void *)dev->p);
  #line 47 
  (dev->p)->driver_data = data;
  #line 49 
  return 0;
}

#line 156  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 156 
void ldv_check_alloc_flags(gfp_t);
#line 48  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 48 
void *ldv_malloc(size_t size);
#line 49 
#line 49 
void *ldv_calloc(size_t nmemb, size_t size);
#line 50 
#line 50 
void *ldv_zalloc(size_t size);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/devres.c"
void *ldv_devm_kmalloc(size_t size, gfp_t flags)
{
  #line 26 
  void *res;
  #line 28 
  ldv_check_alloc_flags(flags);
  #line 29 
  res = ldv_malloc(size);
  #line 30 
  ldv_save_allocated_memory_to_list(res);
  #line 32 
  return res;
}

#line 35  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/devres.c"
void *ldv_devm_kzalloc(size_t size, gfp_t flags)
{
  #line 37 
  void *res;
  #line 39 
  ldv_check_alloc_flags(flags);
  #line 40 
  res = ldv_zalloc(size);
  #line 41 
  ldv_save_allocated_memory_to_list(res);
  #line 43 
  return res;
}

#line 46  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/devres.c"
void *ldv_devm_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  #line 48 
  void *res;
  #line 50 
  ldv_check_alloc_flags(flags);
  #line 51 
  res = ldv_malloc(n * size);
  #line 52 
  ldv_save_allocated_memory_to_list(res);
  #line 54 
  return res;
}

#line 57  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/devres.c"
void *ldv_devm_kcalloc(size_t n, size_t size, gfp_t flags)
{
  #line 59 
  void *res;
  #line 61 
  ldv_check_alloc_flags(flags);
  #line 62 
  res = ldv_calloc(n,size);
  #line 63 
  ldv_save_allocated_memory_to_list(res);
  #line 65 
  return res;
}

#line 51  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 51 
void ldv_free(void *s);
#line 59 
#line 59 
void *ldv_malloc_unknown_size(void);
#line 31  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 31 
int ldv_undef_int_positive(void);
#line 40 
#line 40 
int ldv_undef_int_nonpositive(void);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/firmware_loader.c"
int ldv_request_firmware(struct firmware **fw)
{
  #line 27 
  int retval;
  #line 26 
  struct firmware *_fw = (struct firmware *)0;
  #line 29 
  retval = ldv_undef_int_nonpositive();
  #line 31 
  if (retval == 0) {
    #line 33 
    _fw = (struct firmware *)ldv_xzalloc(32UL);
    #line 34 
    _fw->data = (u8 *)ldv_malloc_unknown_size();
    #line 35 
    __VERIFIER_assume(_fw->data != (u8 *)0U);
    #line 36 
    _fw->size = (unsigned long)ldv_undef_int_positive();
  }
  #line 39 
  *fw = _fw;
  #line 41 
  return retval;
}

#line 44  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/base/firmware_loader.c"
void ldv_release_firmware(struct firmware *fw)
{
  #line 46 
  if (fw != (struct firmware *)0) {
    #line 48 
    ldv_free((void *)fw->data);
    #line 49 
    ldv_free((void *)fw);
  }
  #line 51 
  return;
}

#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/i2c.h"
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/i2c/i2c-core-smbus.c"
s32 ldv_i2c_smbus_read_block_data(u8 *values);
#line 55  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 55 
void *ldv_xmalloc(size_t size);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 23 
int ldv_undef_int(void);
#line 34 
#line 34 
int ldv_undef_int_negative(void);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/i2c/i2c-core-smbus.c"
s32 ldv_i2c_smbus_read_block_data(u8 *values)
{
  #line 27 
  __u8 size;
  #line 28 
  char *bytes;
  #line 30 
  if (ldv_undef_int() != 0) {
    #line 33 
    size = (unsigned char)ldv_undef_int_positive();
    #line 35 
    __VERIFIER_assume((unsigned int)size <= 32U);
    #line 37 
    bytes = (char *)ldv_xmalloc((unsigned long)size);
    #line 39 
    memcpy((void *)values,(void *)bytes,(unsigned long)size);
    #line 40 
    ldv_free((void *)bytes);
    #line 42 
    return (int)size;
  }
  else {
    #line 46 
    return ldv_undef_int_negative();
  }
}

#line 988  "/mnt/klever/build_bases/build-base-linux-5.5-x86_64-allmodconfig/Storage/var/lib/klever/workspace/Branches-and-Tags-Processing/linux-5.5/include/media/v4l2-subdev.h"
__inline static void v4l2_set_subdevdata(struct v4l2_subdev *sd, void *p)
{
  #line 990 
  sd->dev_priv = p;
  #line 991 
  return;
}

#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/media/v4l2-common.h"
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/media/v4l2-core/v4l2-i2c.c"
void ldv_v4l2_i2c_subdev_init(struct v4l2_subdev *sd, struct i2c_client *client, struct v4l2_subdev_ops *ops);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/media/v4l2-core/v4l2-i2c.c"
void ldv_v4l2_i2c_subdev_init(struct v4l2_subdev *sd, struct i2c_client *client, struct v4l2_subdev_ops *ops)
{
  #line 26 
  sd->ops = ops;
  #line 27 
  v4l2_set_subdevdata(sd,(void *)client);
  #line 28 
  ldv_dev_set_drvdata(& client->dev,(void *)sd);
  #line 29 
  return;
}

#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/spi.c"
struct spi_controller *ldv_spi_alloc_master(struct device *host, unsigned int size)
{
  #line 25 
  struct spi_controller *master;
  #line 27 
  master = (struct spi_controller *)ldv_zalloc((unsigned long)size + 2936UL);
  #line 29 
  if (master == (struct spi_controller *)0) 
                                            #line 30 
                                            return (struct spi_controller *)0;
  #line 32 
  ldv_dev_set_drvdata(& master->dev,(void *)(master + 1U));
  #line 34 
  return master;
}

#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/fb.h"
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/video/fbdev/core/fbsysfs.c"
struct fb_info *ldv_framebuffer_alloc(size_t size);
#line 26  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/fb.h"
#line 38  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/video/fbdev/core/fbsysfs.c"
void ldv_framebuffer_release(struct fb_info *info);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/video/fbdev/core/fbsysfs.c"
struct fb_info *ldv_framebuffer_alloc(size_t size)
{
  #line 25 
  struct fb_info *info;
  #line 27 
  info = (struct fb_info *)ldv_zalloc(size + 1568UL);
  #line 29 
  if (info == (struct fb_info *)0) 
                                   #line 30 
                                   return (struct fb_info *)0;
  #line 32 
  if (size != 0UL) 
                   #line 33 
                   info->par = (void *)((char *)info + 1568UL);
  #line 35 
  return info;
}

#line 38  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/drivers/video/fbdev/core/fbsysfs.c"
void ldv_framebuffer_release(struct fb_info *info)
{
  #line 40 
  if (info == (struct fb_info *)0) 
                                   #line 41 
                                   return;
  #line 44 
  ldv_free((void *)info->apertures);
  #line 46 
  ldv_free((void *)info);
  #line 47 
  return;
}

#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/err.h"
#line 59  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/err.c"
bool ldv_is_err_or_null(void *ptr);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/err.h"
#line 35  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/err.c"
bool ldv_is_err(void *ptr)
{
  #line 29 
  if ((unsigned long)ptr > 18446744073709547520UL) 
                                                   #line 30 
                                                   return (_Bool)1; else 
                                                                    #line 32 
                                                                    return (_Bool)0;
}

#line 35  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/err.c"
void *ldv_err_ptr(long error)
{
  #line 37 
  unsigned long result;
  #line 39 
  __VERIFIER_assume(error < 0L);
  #line 40 
  __VERIFIER_assume(error >= -4095L);
  #line 41 
  result = 18446744073709547520UL - (unsigned long)error;
  #line 42 
  __VERIFIER_assume(result > 18446744073709547520UL);
  #line 44 
  return (void *)result;
}

#line 47  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/err.c"
long ldv_ptr_err(void *ptr)
{
  #line 49 
  long result;
  #line 51 
  __VERIFIER_assume((unsigned long)ptr > 18446744073709547520UL);
  #line 52 
  result = (long)(18446744073709547520UL - (unsigned long)ptr);
  #line 53 
  __VERIFIER_assume(result < 0L);
  #line 54 
  __VERIFIER_assume(result >= -4095L);
  #line 56 
  return result;
}

#line 59  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/err.c"
bool ldv_is_err_or_null(void *ptr)
{
  #line 61 
  int tmp_0;
  #line 61 
  if (ptr == (void *)0) 
                        #line 61 
                        tmp_0 = 1;
  else {
    #line 61 
    if ((int)ldv_is_err(ptr) != 0) 
                                   #line 61 
                                   tmp_0 = 1; else 
                                                   #line 61 
                                                   tmp_0 = 0;
  }
  #line 61 
  return (_Bool)(tmp_0 != 0);
}

#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/panic.h"
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/kernel/panic.c"
void ldv_panic(void)
{
  #line 23 
  __VERIFIER_assume(0);
  #line 24 
  return;
}

#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/bitmap.h"
#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_set(unsigned long *map, unsigned int start, int nbits);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/bitmap.h"
#line 52  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_clear(unsigned long *map, unsigned int start, int nbits);
#line 27  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/bitmap.h"
#line 72  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_zero(unsigned long *dst, unsigned int nbits);
#line 29  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/bitmap.h"
#line 78  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
unsigned long ldv_bitmap_find_next_zero_area(unsigned long *map, unsigned long size, unsigned long start, unsigned int nr, unsigned long align_mask);
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/find_bit.h"
#line 22 
unsigned long ldv_find_next_bit(unsigned long *addr, unsigned long size, unsigned long offset);
#line 23 
#line 23 
unsigned long ldv_find_next_zero_bit(unsigned long *addr, unsigned long size, unsigned long offset);
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_set_bit(long nr, unsigned long *addr)
{
  #line 24 
  *(addr + (unsigned long)nr / 64UL) |= 1UL << ((unsigned long)nr & 63UL);
  #line 25 
  return;
}

#line 27  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_clear_bit(long nr, unsigned long *addr)
{
  #line 29 
  *(addr + (unsigned long)nr / 64UL) &= ~ (1UL << ((unsigned long)nr & 63UL));
  #line 30 
  return;
}

#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_set(unsigned long *map, unsigned int start, int nbits)
{
  #line 34 
  unsigned long *p = map + (unsigned long)(start / 64U);
  #line 35 
  unsigned int size = start + (unsigned int)nbits;
  #line 36 
  int bits_to_set = (int)(64U - (start & 63U));
  #line 37 
  unsigned long mask_to_set = 18446744073709551615UL << ((unsigned long)start & 63UL);
  #line 39 
  while (nbits - bits_to_set >= 0) {
    #line 40 
    *p |= mask_to_set;
    #line 41 
    nbits -= bits_to_set;
    #line 42 
    bits_to_set = 64;
    #line 43 
    mask_to_set = 18446744073709551615UL;
    #line 44 
    p ++;
  }
  #line 46 
  if (nbits != 0) {
    #line 47 
    mask_to_set = (18446744073709551615UL >> ((unsigned long)(- size) & 63UL)) & mask_to_set;
    #line 48 
    *p |= mask_to_set;
  }
  #line 50 
  return;
}

#line 52  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_clear(unsigned long *map, unsigned int start, int nbits)
{
  #line 54 
  unsigned long *p = map + (unsigned long)(start / 64U);
  #line 55 
  unsigned int size = start + (unsigned int)nbits;
  #line 56 
  int bits_to_clear = (int)(64U - (start & 63U));
  #line 57 
  unsigned long mask_to_clear = 18446744073709551615UL << ((unsigned long)start & 63UL);
  #line 59 
  while (nbits - bits_to_clear >= 0) {
    #line 60 
    *p &= ~ mask_to_clear;
    #line 61 
    nbits -= bits_to_clear;
    #line 62 
    bits_to_clear = 64;
    #line 63 
    mask_to_clear = 18446744073709551615UL;
    #line 64 
    p ++;
  }
  #line 66 
  if (nbits != 0) {
    #line 67 
    mask_to_clear = (18446744073709551615UL >> ((unsigned long)(- size) & 63UL)) & mask_to_clear;
    #line 68 
    *p &= ~ mask_to_clear;
  }
  #line 70 
  return;
}

#line 72  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
void ldv_bitmap_zero(unsigned long *dst, unsigned int nbits)
{
  #line 74 
  unsigned int len = (unsigned int)(((unsigned long)nbits + 63UL) / 64UL) * 8U;
  #line 75 
  memset((void *)dst,0,(unsigned long)len);
  #line 76 
  return;
}

#line 78  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/bitmap.c"
unsigned long ldv_bitmap_find_next_zero_area(unsigned long *map, unsigned long size, unsigned long start, unsigned int nr, unsigned long align_mask)
{
  #line 80 
  unsigned long index;
  #line 80 
  unsigned long end;
  #line 80 
  unsigned long i;
  #line 82 
  again: 
         #line 82 
  ;
  #line 83 
  index = ldv_find_next_zero_bit(map,size,start);
  #line 84 
  index = (index + align_mask) & ~ align_mask;
  #line 85 
  end = (unsigned long)nr + index;
  #line 87 
  if (end > size) 
                  #line 88 
                  return end;
  #line 90 
  i = ldv_find_next_bit(map,end,index);
  #line 92 
  if (i < end) {
    #line 93 
    start = i + 1UL;
    #line 94 
    goto again;
  }
  #line 97 
  return index;
}

#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/find_bit.h"
#line 68  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
unsigned long ldv_find_first_bit(unsigned long *addr, unsigned long size);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/find_bit.h"
#line 25 
void ldv_check_find_bit_offset(unsigned long, unsigned long);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
static unsigned long ldv_ffs(unsigned long word)
{
  #line 23 
  int num = 0;
  #line 25 
  if ((word & 4294967295UL) == 0UL) {
    #line 26 
    num += 32;
    #line 27 
    word >>= 32;
  }
  #line 29 
  if ((word & 65535UL) == 0UL) {
    #line 30 
    num += 16;
    #line 31 
    word >>= 16;
  }
  #line 33 
  if ((word & 255UL) == 0UL) {
    #line 34 
    num += 8;
    #line 35 
    word >>= 8;
  }
  #line 37 
  if ((word & 15UL) == 0UL) {
    #line 38 
    num += 4;
    #line 39 
    word >>= 4;
  }
  #line 41 
  if ((word & 3UL) == 0UL) {
    #line 42 
    num += 2;
    #line 43 
    word >>= 2;
  }
  #line 45 
  if ((word & 1UL) == 0UL) 
                           #line 46 
                           num ++;
  #line 48 
  return (unsigned long)num;
}

#line 51  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
static unsigned long ldv_min(unsigned long a, unsigned long b)
{
  #line 53 
  if (a < b) 
             #line 54 
             return a;
  #line 56 
  return b;
}

#line 59  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
static unsigned long ldv_restrict_find_bit_res(unsigned long res, unsigned long size)
{
  #line 62 
  __VERIFIER_assume(1);
  #line 63 
  __VERIFIER_assume(res <= size);
  #line 65 
  return res;
}

#line 68  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
unsigned long ldv_find_first_bit(unsigned long *addr, unsigned long size)
{
  #line 70 
  unsigned long i;
  #line 72 
  i = 0UL;
  #line 72 
  while (i * 64UL < size) {
    #line 73 
    if (*(addr + i) != 0UL) {
      #line 74 
      ;
      #line 74 
      ;
      #line 74 
      ;
      #line 74 
      return ldv_restrict_find_bit_res(ldv_min(i * 64UL + ldv_ffs(*(addr + i)),size),
                                  size);
    }
    #line 72 
    i ++;
  }
  #line 76 
  return size;
}

#line 79  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
unsigned long ldv_find_next_bit(unsigned long *addr, unsigned long size, unsigned long offset)
{
  #line 81 
  unsigned long tmp;
  #line 83 
  ldv_check_find_bit_offset(size,offset);
  #line 85 
  tmp = *(addr + offset / 64UL);
  #line 86 
  tmp = (unsigned long)((18446744073709551615ULL << (offset & 63UL)) & (unsigned long long)tmp);
  #line 87 
  offset &= 18446744073709551552UL;
  #line 89 
  while (tmp == 0UL) {
    #line 90 
    offset += 64UL;
    #line 91 
    if (offset >= size) 
                        #line 92 
                        return size;
    #line 94 
    tmp = *(addr + offset / 64UL);
  }
  #line 97 
  ;
  #line 97 
  ;
  #line 97 
  ;
  #line 97 
  return ldv_restrict_find_bit_res(ldv_min(ldv_ffs(tmp) + offset,size),size);
}

#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/find_bit.common.c"
unsigned long ldv_find_next_zero_bit(unsigned long *addr, unsigned long size, unsigned long offset)
{
  #line 102 
  unsigned long tmp;
  #line 104 
  ldv_check_find_bit_offset(size,offset);
  #line 106 
  tmp = *(addr + offset / 64UL);
  #line 107 
  tmp = ~ tmp;
  #line 108 
  tmp = (unsigned long)((18446744073709551615ULL << (offset & 63UL)) & (unsigned long long)tmp);
  #line 109 
  offset &= 18446744073709551552UL;
  #line 111 
  while (tmp == 0UL) {
    #line 112 
    offset += 64UL;
    #line 113 
    if (offset >= size) 
                        #line 114 
                        return size;
    #line 116 
    tmp = *(addr + offset / 64UL);
    #line 117 
    tmp = ~ tmp;
  }
  #line 120 
  ;
  #line 120 
  ;
  #line 120 
  ;
  #line 120 
  return ldv_restrict_find_bit_res(ldv_min(ldv_ffs(tmp) + offset,size),size);
}

#line 26  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/string.h"
#line 31  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
int ldv_strcmp(char *cs, char *ct);
#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/string.h"
#line 70  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
char *ldv_strstr(char *cs, char *ct);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
size_t ldv_strlen(char *s)
{
  #line 23 
  unsigned int len = 0U;
  #line 25 
  while ((int)*s != 0) {
    #line 26 
    len ++;
    #line 25 
    s ++;
  }
  #line 28 
  return (unsigned long)len;
}

#line 31  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
int ldv_strcmp(char *cs, char *ct)
{
  #line 33 
  while ((int)*cs != 0 && (int)*ct != 0) {
    #line 34 
    if ((int)*cs != (int)*ct) 
                              #line 35 
                              break;
    #line 33 
    cs ++;
    #line 33 
    ct ++;
  }
  #line 37 
  return (int)*cs - (int)*ct;
}

#line 40  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
int ldv_strncmp(char *cs, char *ct, __kernel_size_t count)
{
  #line 42 
  if (count == 0UL) 
                    #line 43 
                    return 0;
  #line 45 
  while ((int)*cs != 0 && (int)*ct != 0) {
    #line 46 
    if ((int)*cs != (int)*ct) 
                              #line 47 
                              break;
    #line 49 
    count --;
    #line 51 
    if (count == 0UL) 
                      #line 52 
                      break;
    #line 45 
    cs ++;
    #line 45 
    ct ++;
  }
  #line 55 
  return (int)*cs - (int)*ct;
}

#line 58  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
int ldv_memcmp(void *cs, void *ct, size_t count)
{
  #line 60 
  unsigned char *su1;
  #line 60 
  unsigned char *su2;
  #line 61 
  int res = 0;
  #line 63 
  su1 = (unsigned char *)cs;
  #line 63 
  su2 = (unsigned char *)ct;
  #line 63 
  while (count != 0UL) {
    #line 64 
    res = (int)*su1 - (int)*su2;
    #line 64 
    if (res != 0) 
                  #line 65 
                  break;
    #line 63 
    su1 ++;
    #line 63 
    su2 ++;
    #line 63 
    count --;
  }
  #line 67 
  return res;
}

#line 70  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/lib/string.c"
char *ldv_strstr(char *cs, char *ct)
{
  #line 72 
  size_t cs_len;
  #line 72 
  size_t ct_len;
  #line 74 
  cs_len = ldv_strlen(cs);
  #line 75 
  ct_len = ldv_strlen(ct);
  #line 77 
  while (cs_len >= ct_len) {
    #line 78 
    if (ldv_memcmp((void *)cs,(void *)ct,ct_len) == 0) 
                                                       #line 79 
                                                       return cs;
    #line 81 
    cs_len --;
    #line 82 
    cs ++;
  }
  #line 85 
  return (char *)0;
}

#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/list.c"
void ldv_init_list_head(struct list_head *list)
{
  #line 23 
  list->next = list;
  #line 24 
  list->prev = list;
  #line 25 
  return;
}

#line 30  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
struct kmem_cache *ldv_kmem_cache_create(char *name, unsigned int size);
#line 31  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags);
#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 90  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmem_cache_zalloc(struct kmem_cache *cachep, gfp_t flags);
#line 33  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 95  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void ldv_kmem_cache_free(struct kmem_cache *cachep, void *objp);
#line 34  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/slab.h"
#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void ldv_kmem_cache_destroy(struct kmem_cache *cachep);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc(size_t size, gfp_t flags)
{
  #line 25 
  void *res;
  #line 27 
  ldv_check_alloc_flags(flags);
  #line 28 
  res = ldv_malloc(size);
  #line 30 
  return res;
}

#line 33  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kzalloc(size_t size, gfp_t flags)
{
  #line 35 
  void *res;
  #line 37 
  ldv_check_alloc_flags(flags);
  #line 38 
  res = ldv_zalloc(size);
  #line 40 
  return res;
}

#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n, size_t size, gfp_t flags)
{
  #line 45 
  void *res;
  #line 47 
  ldv_check_alloc_flags(flags);
  #line 48 
  res = ldv_malloc(n * size);
  #line 50 
  return res;
}

#line 53  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kcalloc(size_t n, size_t size, gfp_t flags)
{
  #line 55 
  void *res;
  #line 57 
  ldv_check_alloc_flags(flags);
  #line 58 
  res = ldv_calloc(n,size);
  #line 60 
  return res;
}

#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
struct kmem_cache *ldv_kmem_cache_create(char *name, unsigned int size)
{
  #line 71 
  struct kmem_cache *res;
  #line 72 
  struct ldv_kmem_cache *ldv_res;
  #line 74 
  res = (struct kmem_cache *)ldv_zalloc(16UL);
  #line 76 
  if (res != (struct kmem_cache *)0) {
    #line 77 
    ldv_res = (struct ldv_kmem_cache *)res;
    #line 78 
    ldv_res->name = name;
    #line 79 
    ldv_res->size = size;
  }
  #line 82 
  return res;
}

#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)
{
  #line 87 
  return ldv_kmalloc((unsigned long)((struct ldv_kmem_cache *)cachep)->size,
                  flags);
}

#line 90  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void *ldv_kmem_cache_zalloc(struct kmem_cache *cachep, gfp_t flags)
{
  #line 92 
  return ldv_kzalloc((unsigned long)((struct ldv_kmem_cache *)cachep)->size,
                  flags);
}

#line 95  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void ldv_kmem_cache_free(struct kmem_cache *cachep, void *objp)
{
  #line 97 
  ldv_free(objp);
  #line 98 
  return;
}

#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/slab.c"
void ldv_kmem_cache_destroy(struct kmem_cache *cachep)
{
  #line 102 
  ldv_free((void *)cachep);
  #line 103 
  return;
}

#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/string.h"
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/util.c"
void *ldv_kmemdup(void *src, size_t len, gfp_t gfp);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/util.c"
void *ldv_kmemdup(void *src, size_t len, gfp_t gfp)
{
  #line 25 
  void *res;
  #line 27 
  ldv_check_alloc_flags(gfp);
  #line 28 
  res = ldv_malloc(len);
  #line 30 
  if (res != (void *)0) 
                        #line 31 
                        memcpy(res,src,len);
  #line 33 
  return res;
}

#line 162  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 162 
void ldv_check_alloc_nonatomic(void);
#line 21  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/vmalloc.h"
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void *ldv_vmalloc(unsigned long size);
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/vmalloc.h"
#line 33  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void *ldv_vzalloc(unsigned long size);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/vmalloc.h"
#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void ldv_vfree(void *addr);
#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void *ldv_vmalloc(unsigned long size)
{
  #line 25 
  void *res;
  #line 27 
  ldv_check_alloc_nonatomic();
  #line 28 
  res = ldv_malloc(size);
  #line 30 
  return res;
}

#line 33  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void *ldv_vzalloc(unsigned long size)
{
  #line 35 
  void *res;
  #line 37 
  ldv_check_alloc_nonatomic();
  #line 38 
  res = ldv_zalloc(size);
  #line 40 
  return res;
}

#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/mm/vmalloc.c"
void ldv_vfree(void *addr)
{
  #line 45 
  ldv_free(addr);
  #line 46 
  return;
}

#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 28 
void *malloc(size_t);
#line 29 
#line 29 
void *calloc(size_t, size_t);
#line 30 
#line 30 
void free(void *);
#line 45 
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
unsigned int ldv_is_memory_alloc_failures;
#line 56  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 63  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xcalloc(size_t nmemb, size_t size);
#line 60  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 88  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void);
#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 97  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void);
#line 64  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size);
#line 65  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 37  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size);
#line 66  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 42  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size);
#line 67  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 47  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s);
#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 52  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size);
#line 71  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 80  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size);
#line 72  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 90  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xcalloc(size_t nmemb, size_t size);
#line 73  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size);
#line 75  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 110  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void);
#line 76  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 124  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void);
#line 77  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 139  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void);
#line 83  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 106  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size);
#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 144  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size);
#line 87  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/memory.h"
#line 87 
void *external_allocated_data(void);
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
unsigned int ldv_is_memory_alloc_failures = 1U;
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc(size_t size)
{
  #line 26 
  void *res;
  #line 28 
  if (ldv_is_memory_alloc_failures != 0U) {
    #line 28 
    if (ldv_undef_int() != 0) 
                              #line 29 
                              return (void *)0;
  }
  #line 32 
  res = malloc(size);
  #line 33 
  __VERIFIER_assume(res != (void *)0);
  #line 34 
  return res;
}

#line 37  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc(size_t nmemb, size_t size)
{
  #line 39 
  return calloc(nmemb,size);
}

#line 42  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc(size_t size)
{
  #line 44 
  return calloc(1UL,size);
}

#line 47  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void ldv_reference_free(void *s)
{
  #line 49 
  free(s);
  #line 50 
  return;
}

#line 52  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_realloc(void *ptr, size_t size)
{
  #line 54 
  void *res;
  #line 56 
  if (ptr != (void *)0 && size == 0UL) {
    #line 57 
    free(ptr);
    #line 58 
    return (void *)0;
  }
  #line 61 
  if (ptr == (void *)0) {
    #line 62 
    res = malloc(size);
    #line 63 
    return res;
  }
  #line 66 
  if (ldv_undef_int() != 0) {
    #line 68 
    res = malloc(size);
    #line 69 
    __VERIFIER_assume(res != (void *)0);
    #line 71 
    memcpy(res,ptr,size);
    #line 72 
    free(ptr);
    #line 74 
    return res;
  }
  else 
       #line 77 
       return (void *)0;
}

#line 80  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc(size_t size)
{
  #line 82 
  void *res;
  #line 84 
  res = malloc(size);
  #line 85 
  __VERIFIER_assume(res != (void *)0);
  #line 87 
  return res;
}

#line 90  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xcalloc(size_t nmemb, size_t size)
{
  #line 92 
  void *res;
  #line 94 
  res = calloc(nmemb,size);
  #line 95 
  __VERIFIER_assume(res != (void *)0);
  #line 97 
  return res;
}

#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xzalloc(size_t size)
{
  #line 102 
  void *res;
  #line 104 
  res = calloc(1UL,size);
  #line 105 
  __VERIFIER_assume(res != (void *)0);
  #line 107 
  return res;
}

#line 110  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_malloc_unknown_size(void)
{
  #line 112 
  void *res;
  #line 114 
  if (ldv_undef_int() != 0) {
    #line 116 
    res = external_allocated_data();
    #line 117 
    __VERIFIER_assume(res != (void *)0);
    #line 118 
    return res;
  }
  else 
       #line 121 
       return (void *)0;
}

#line 124  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_calloc_unknown_size(void)
{
  #line 126 
  void *res;
  #line 128 
  if (ldv_undef_int() != 0) {
    #line 130 
    res = external_allocated_data();
    #line 131 
    memset(res,0,8UL);
    #line 132 
    __VERIFIER_assume(res != (void *)0);
    #line 133 
    return res;
  }
  else 
       #line 136 
       return (void *)0;
}

#line 139  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_zalloc_unknown_size(void)
{
  #line 141 
  return ldv_reference_calloc_unknown_size();
}

#line 144  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/reference memory.c"
void *ldv_reference_xmalloc_unknown_size(size_t size)
{
  #line 146 
  void *res;
  #line 149 
  res = external_allocated_data();
  #line 150 
  __VERIFIER_assume(res != (void *)0);
  #line 152 
  return res;
}

#line 23  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc(size_t size)
{
  #line 25 
  void *res;
  #line 26 
  res = ldv_reference_malloc(size);
  #line 27 
  if (res != (void *)0) {
    #line 28 
    int tmp_0;
    #line 28 
    if (ldv_is_err(res)) 
                         #line 28 
                         tmp_0 = 0; else 
                                         #line 28 
                                         tmp_0 = 1;
    #line 28 
    __VERIFIER_assume(tmp_0);
  }
  #line 29 
  return res;
}

#line 32  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc(size_t nmemb, size_t size)
{
  #line 34 
  void *res;
  #line 35 
  res = ldv_reference_calloc(nmemb,size);
  #line 36 
  if (res != (void *)0) {
    #line 37 
    int tmp_0;
    #line 37 
    if (ldv_is_err(res)) 
                         #line 37 
                         tmp_0 = 0; else 
                                         #line 37 
                                         tmp_0 = 1;
    #line 37 
    __VERIFIER_assume(tmp_0);
  }
  #line 38 
  return res;
}

#line 41  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc(size_t size)
{
  #line 43 
  void *res;
  #line 44 
  res = ldv_reference_zalloc(size);
  #line 45 
  if (res != (void *)0) {
    #line 46 
    int tmp_0;
    #line 46 
    if (ldv_is_err(res)) 
                         #line 46 
                         tmp_0 = 0; else 
                                         #line 46 
                                         tmp_0 = 1;
    #line 46 
    __VERIFIER_assume(tmp_0);
  }
  #line 47 
  return res;
}

#line 50  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void ldv_free(void *s)
{
  #line 52 
  ldv_reference_free(s);
  #line 53 
  return;
}

#line 55  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc(size_t size)
{
  #line 57 
  void *res;
  #line 59 
  int tmp_0;
  #line 58 
  res = ldv_reference_xmalloc(size);
  #line 59 
  if (ldv_is_err(res)) 
                       #line 59 
                       tmp_0 = 0; else 
                                       #line 59 
                                       tmp_0 = 1;
  #line 59 
  __VERIFIER_assume(tmp_0);
  #line 60 
  return res;
}

#line 63  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xcalloc(size_t nmemb, size_t size)
{
  #line 65 
  void *res;
  #line 67 
  int tmp_0;
  #line 66 
  res = ldv_reference_xcalloc(nmemb,size);
  #line 67 
  if (ldv_is_err(res)) 
                       #line 67 
                       tmp_0 = 0; else 
                                       #line 67 
                                       tmp_0 = 1;
  #line 67 
  __VERIFIER_assume(tmp_0);
  #line 68 
  return res;
}

#line 71  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xzalloc(size_t size)
{
  #line 73 
  void *res;
  #line 75 
  int tmp_0;
  #line 74 
  res = ldv_reference_xzalloc(size);
  #line 75 
  if (ldv_is_err(res)) 
                       #line 75 
                       tmp_0 = 0; else 
                                       #line 75 
                                       tmp_0 = 1;
  #line 75 
  __VERIFIER_assume(tmp_0);
  #line 76 
  return res;
}

#line 79  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_malloc_unknown_size(void)
{
  #line 81 
  void *res;
  #line 82 
  res = ldv_reference_malloc_unknown_size();
  #line 83 
  if (res != (void *)0) {
    #line 84 
    int tmp_0;
    #line 84 
    if (ldv_is_err(res)) 
                         #line 84 
                         tmp_0 = 0; else 
                                         #line 84 
                                         tmp_0 = 1;
    #line 84 
    __VERIFIER_assume(tmp_0);
  }
  #line 85 
  return res;
}

#line 88  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_calloc_unknown_size(void)
{
  #line 90 
  void *res;
  #line 91 
  res = ldv_reference_calloc_unknown_size();
  #line 92 
  if (res != (void *)0) {
    #line 93 
    int tmp_0;
    #line 93 
    if (ldv_is_err(res)) 
                         #line 93 
                         tmp_0 = 0; else 
                                         #line 93 
                                         tmp_0 = 1;
    #line 93 
    __VERIFIER_assume(tmp_0);
  }
  #line 94 
  return res;
}

#line 97  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_zalloc_unknown_size(void)
{
  #line 99 
  void *res;
  #line 100 
  res = ldv_reference_zalloc_unknown_size();
  #line 101 
  if (res != (void *)0) {
    #line 102 
    int tmp_0;
    #line 102 
    if (ldv_is_err(res)) 
                         #line 102 
                         tmp_0 = 0; else 
                                         #line 102 
                                         tmp_0 = 1;
    #line 102 
    __VERIFIER_assume(tmp_0);
  }
  #line 103 
  return res;
}

#line 106  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/linux/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size)
{
  #line 108 
  void *res;
  #line 110 
  int tmp_0;
  #line 109 
  res = ldv_reference_xmalloc_unknown_size(size);
  #line 110 
  if (ldv_is_err(res)) 
                       #line 110 
                       tmp_0 = 0; else 
                                       #line 110 
                                       tmp_0 = 1;
  #line 110 
  __VERIFIER_assume(tmp_0);
  #line 111 
  return res;
}

/* compiler builtin: 
   long __builtin_expect(long exp, long c);   */
#line 22  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/common.h"
#line 22 
void __VERIFIER_error(void);
#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/common.h"
long __builtin_expect(long exp, long c)
{
  #line 26 
  return exp;
}

#line 35  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/gcc.c"
void __builtin_trap(void)
{
  #line 37 
  __VERIFIER_error();
  #line 38 
  return;
}

#line 24  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 53  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
long ldv_undef_long(void);
#line 25  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void);
#line 26  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 77  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void);
#line 27  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void);
#line 28  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void);
#line 37  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 111  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonnegative(void);
#line 43  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 129  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void);
#line 54  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 139  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __ldv_undef_int_range(int begin, int end);
#line 56  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/nondet.h"
#line 151  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __ldv_undef_int_range2(int begin, int end);
#line 29 
#line 29 
int __VERIFIER_nondet_int(void);
#line 31 
#line 31 
long __VERIFIER_nondet_long(void);
#line 38 
#line 38 
unsigned int __VERIFIER_nondet_uint(void);
#line 41 
#line 41 
unsigned long __VERIFIER_nondet_ulong(void);
#line 42 
#line 42 
unsigned long long __VERIFIER_nondet_ulonglong(void);
#line 43 
#line 43 
void *__VERIFIER_nondet_pointer(void);
#line 45  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int(void)
{
  #line 48 
  int undef_int = __VERIFIER_nondet_int();
  #line 50 
  return undef_int;
}

#line 53  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
long ldv_undef_long(void)
{
  #line 56 
  long undef_long = __VERIFIER_nondet_long();
  #line 58 
  return undef_long;
}

#line 61  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned int ldv_undef_uint(void)
{
  #line 64 
  unsigned int undef_uint = __VERIFIER_nondet_uint();
  #line 66 
  return undef_uint;
}

#line 69  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr(void)
{
  #line 72 
  void *undef_ptr = __VERIFIER_nondet_pointer();
  #line 74 
  return undef_ptr;
}

#line 77  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long ldv_undef_ulong(void)
{
  #line 80 
  unsigned long undef_ulong = __VERIFIER_nondet_ulong();
  #line 82 
  return undef_ulong;
}

#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void)
{
  #line 88 
  unsigned long long undef_ulonglong = __VERIFIER_nondet_ulonglong();
  #line 90 
  return undef_ulonglong;
}

#line 93  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_positive(void)
{
  #line 95 
  int ret = ldv_undef_int();
  #line 97 
  __VERIFIER_assume(ret > 0);
  #line 99 
  return ret;
}

#line 102  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_negative(void)
{
  #line 104 
  int ret = ldv_undef_int();
  #line 106 
  __VERIFIER_assume(ret < 0);
  #line 108 
  return ret;
}

#line 111  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonnegative(void)
{
  #line 113 
  int ret = ldv_undef_int();
  #line 115 
  __VERIFIER_assume(ret >= 0);
  #line 117 
  return ret;
}

#line 120  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int ldv_undef_int_nonpositive(void)
{
  #line 122 
  int ret = ldv_undef_int();
  #line 124 
  __VERIFIER_assume(ret <= 0);
  #line 126 
  return ret;
}

#line 129  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void)
{
  #line 131 
  void *ret = ldv_undef_ptr();
  #line 133 
  __VERIFIER_assume(ret != (void *)0);
  #line 135 
  return ret;
}

#line 139  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __ldv_undef_int_range(int begin, int end)
{
  #line 141 
  int ret;
  #line 143 
  ret = ldv_undef_int();
  #line 144 
  __VERIFIER_assume(ret >= begin);
  #line 145 
  __VERIFIER_assume(ret <= end);
  #line 147 
  return ret;
}

#line 151  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/verifier/nondet.c"
int __ldv_undef_int_range2(int begin, int end)
{
  #line 153 
  int ret;
  #line 155 
  ret = begin;
  #line 155 
  while (ret < end) {
    #line 156 
    if (ldv_undef_int() != 0) 
                              #line 157 
                              break;
    #line 155 
    ret ++;
  }
  #line 159 
  return ret;
}

#line 62  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/linux/common.h"
#line 62 
void ldv_initialize(void);
#line 97 
#line 97 
void ldv_failed_register_netdev(void);
#line 123 
#line 123 
void ldv_pre_probe(void);
#line 35  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/root/specifications/include/ldv/verifier/thread.h"
#line 35 
int pthread_create(pthread_t *, pthread_attr_t *, void *(*)(void *), void *);
#line 39 
#line 39 
int pthread_join(pthread_t, void **);
#line 63  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
#line 143 
void emg_dispatch_deregister_10(struct net_device *arg0);
#line 64 
#line 109 
void emg_dispatch_deregister_7(struct pci_driver *arg0);
#line 65 
#line 100 
void emg_dispatch_irq_deregister_4(int arg0);
#line 66 
#line 129 
void emg_dispatch_irq_register_9(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3);
#line 67 
#line 89 
void emg_dispatch_register_2(struct pci_driver *arg0);
#line 68 
#line 118 
void emg_dispatch_register_8(struct net_device *arg0);
#line 69 
#line 852 
void *emg_entry_point_insmod(void *arg0);
#line 72 
#line 152 
void *emg_interrupt_interrupt_scenario_airo_interrupt(void *arg0);
#line 74 
#line 215 
void *emg_net_random_allocationless_scenario_airo_get_stats(void *arg0);
#line 75 
#line 440 
void *emg_pci_pci_scenario_airo_driver(void *arg0);
#line 80 
#line 881 
int main(void);
#line 83  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_11;
#line 84  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_12;
#line 85  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
pthread_t emg_thread_13;
#line 89  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_register_2(struct pci_driver *arg0)
{
  #line 90 
  int ret;
  #line 91 
  struct emg_struct_pci_scenario_airo_driver_13 *cf_arg_13;
  #line 92 
  cf_arg_13 = (struct emg_struct_pci_scenario_airo_driver_13 *)ldv_xmalloc(16UL);
  #line 93 
  cf_arg_13->arg0 = arg0;
  #line 94 
  ret = pthread_create(& emg_thread_13,(pthread_attr_t *)0,& emg_pci_pci_scenario_airo_driver,(void *)cf_arg_13);
  #line 95 
  __VERIFIER_assume(ret == 0);
  #line 96 
  return;
}

#line 100  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_irq_deregister_4(int arg0)
{
  #line 101 
  int ret;
  #line 102 
  struct emg_struct_free_irq_4 *cf_arg_11;
  #line 103 
  ret = pthread_join(emg_thread_11,(void **)0);
  #line 104 
  __VERIFIER_assume(ret == 0);
  #line 105 
  return;
}

#line 109  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_deregister_7(struct pci_driver *arg0)
{
  #line 110 
  int ret;
  #line 111 
  struct emg_struct_pci_scenario_airo_driver_13 *cf_arg_13;
  #line 112 
  ret = pthread_join(emg_thread_13,(void **)0);
  #line 113 
  __VERIFIER_assume(ret == 0);
  #line 114 
  return;
}

#line 118  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_register_8(struct net_device *arg0)
{
  #line 119 
  int ret;
  #line 120 
  struct emg_struct_random_allocationless_scenario_airo_get_stats_12 *cf_arg_12;
  #line 121 
  cf_arg_12 = (struct emg_struct_random_allocationless_scenario_airo_get_stats_12 *)ldv_xmalloc(16UL);
  #line 122 
  cf_arg_12->arg0 = arg0;
  #line 123 
  ret = pthread_create(& emg_thread_12,(pthread_attr_t *)0,& emg_net_random_allocationless_scenario_airo_get_stats,(void *)cf_arg_12);
  #line 124 
  __VERIFIER_assume(ret == 0);
  #line 125 
  return;
}

#line 129  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_irq_register_9(int arg0, enum irqreturn (*arg1)(int , void *), enum irqreturn (*arg2)(int , void *), void *arg3)
{
  #line 130 
  int ret;
  #line 131 
  struct emg_struct_interrupt_scenario_airo_interrupt_11 *cf_arg_11;
  #line 132 
  cf_arg_11 = (struct emg_struct_interrupt_scenario_airo_interrupt_11 *)ldv_xmalloc(40UL);
  #line 133 
  cf_arg_11->arg0 = arg0;
  #line 134 
  cf_arg_11->arg1 = arg1;
  #line 135 
  cf_arg_11->arg2 = arg2;
  #line 136 
  cf_arg_11->arg3 = arg3;
  #line 137 
  ret = pthread_create(& emg_thread_11,(pthread_attr_t *)0,& emg_interrupt_interrupt_scenario_airo_interrupt,(void *)cf_arg_11);
  #line 138 
  __VERIFIER_assume(ret == 0);
  #line 139 
  return;
}

#line 143  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
void emg_dispatch_deregister_10(struct net_device *arg0)
{
  #line 144 
  int ret;
  #line 145 
  struct emg_struct_random_allocationless_scenario_airo_get_stats_12 *cf_arg_12;
  #line 146 
  ret = pthread_join(emg_thread_12,(void **)0);
  #line 147 
  __VERIFIER_assume(ret == 0);
  #line 148 
  return;
}

#line 152  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
void *emg_interrupt_interrupt_scenario_airo_interrupt(void *arg0)
{
  #line 155 
  enum irqreturn (*emg_11_callback)(int , void *);
  #line 156 
  void *emg_11_data;
  #line 157 
  int emg_11_line;
  #line 158 
  enum irqreturn emg_11_ret_val;
  #line 159 
  enum irqreturn (*emg_11_thread)(int , void *);
  #line 161 
  struct emg_struct_interrupt_scenario_airo_interrupt_11 *data = (struct emg_struct_interrupt_scenario_airo_interrupt_11 *)arg0;
  #line 164 
  emg_11_callback = & emg_wrapper_airo_interrupt;
  #line 167 
  if (data != (struct emg_struct_interrupt_scenario_airo_interrupt_11 *)0) {
    #line 168 
    emg_11_line = data->arg0;
    #line 169 
    emg_11_callback = data->arg1;
    #line 170 
    emg_11_thread = data->arg2;
    #line 171 
    emg_11_data = data->arg3;
    #line 172 
    ldv_free((void *)data);
  }
  #line 178 
  ldv_switch_to_interrupt_context();
  #line 182 
  emg_11_ret_val = emg_wrapper_airo_interrupt(emg_11_line,emg_11_data);
  #line 187 
  ldv_switch_to_process_context();
  #line 190 
  if (ldv_undef_int() != 0) {
    #line 192 
    __VERIFIER_assume(emg_11_ret_val == (unsigned int)IRQ_WAKE_THREAD);
    #line 196 
    if (emg_11_thread != (enum irqreturn (*)(int , void *))0) 
                                                              #line 197 
                                                              (*emg_11_thread)(emg_11_line,emg_11_data);
  }
  else 
       #line 202 
       __VERIFIER_assume(emg_11_ret_val != (unsigned int)IRQ_WAKE_THREAD);
  #line 210 
  return (void *)0;
}

#line 215  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
void *emg_net_random_allocationless_scenario_airo_get_stats(void *arg0)
{
  #line 218 
  struct net_device *emg_12_container;
  #line 219 
  struct sk_buff *emg_12_emg_param_0_11;
  #line 220 
  struct sk_buff *emg_12_emg_param_0_3;
  #line 221 
  struct sk_buff *emg_12_emg_param_0_7;
  #line 222 
  struct ifreq *emg_12_emg_param_1_0;
  #line 223 
  void *emg_12_emg_param_1_10;
  #line 224 
  void *emg_12_emg_param_1_2;
  #line 225 
  struct ifreq *emg_12_emg_param_1_4;
  #line 226 
  void *emg_12_emg_param_1_6;
  #line 227 
  struct ifreq *emg_12_emg_param_1_8;
  #line 228 
  int emg_12_emg_param_2_1;
  #line 229 
  int emg_12_emg_param_2_5;
  #line 230 
  int emg_12_emg_param_2_9;
  #line 231 
  int emg_repeat_cnt_call_12 = 1;
  #line 233 
  struct emg_struct_random_allocationless_scenario_airo_get_stats_12 *data = (struct emg_struct_random_allocationless_scenario_airo_get_stats_12 *)arg0;
  #line 238 
  if (data != (struct emg_struct_random_allocationless_scenario_airo_get_stats_12 *)0) {
    #line 239 
    emg_12_container = data->arg0;
    #line 240 
    ldv_free((void *)data);
  }
  #line 245 
  goto emg_call_12;
  #line 249 
  return (void *)0;
  #line 252 
  emg_call_12: 
               #line 252 
  ;
  #line 253 
  switch (ldv_undef_int()) {
    #line 254 
    case 0: 
            #line 254 
    ;
    #line 256 
    eth_validate_addr(emg_12_container);
    #line 258 
    break;
    #line 260 
    case 1: 
            #line 260 
    ;
    #line 262 
    emg_12_emg_param_0_11 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
    #line 262 
    emg_12_emg_param_0_11 = emg_12_emg_param_0_11;
    #line 266 
    emg_wrapper_mpi_start_xmit(emg_12_emg_param_0_11,emg_12_container);
    #line 270 
    ldv_free((void *)emg_12_emg_param_0_11);
    #line 272 
    break;
    #line 274 
    case 2: 
            #line 274 
    ;
    #line 276 
    emg_wrapper_airo_set_multicast_list(emg_12_container);
    #line 278 
    break;
    #line 280 
    case 3: 
            #line 280 
    ;
    #line 282 
    emg_12_emg_param_1_10 = ldv_xmalloc_unknown_size(0UL);
    #line 282 
    emg_12_emg_param_1_10 = emg_12_emg_param_1_10;
    #line 286 
    emg_wrapper_airo_set_mac_address(emg_12_container,emg_12_emg_param_1_10);
    #line 290 
    ldv_free(emg_12_emg_param_1_10);
    #line 292 
    break;
    #line 294 
    case 4: 
            #line 294 
    ;
    #line 296 
    emg_wrapper_airo_get_stats(emg_12_container);
    #line 298 
    break;
    #line 300 
    case 5: 
            #line 300 
    ;
    #line 302 
    emg_12_emg_param_1_8 = (struct ifreq *)ldv_xmalloc_unknown_size(0UL);
    #line 302 
    emg_12_emg_param_1_8 = emg_12_emg_param_1_8;
    #line 306 
    emg_wrapper_airo_ioctl(emg_12_container,emg_12_emg_param_1_8,emg_12_emg_param_2_9);
    #line 310 
    ldv_free((void *)emg_12_emg_param_1_8);
    #line 312 
    break;
    #line 314 
    case 6: 
            #line 314 
    ;
    #line 316 
    emg_12_emg_param_0_7 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
    #line 316 
    emg_12_emg_param_0_7 = emg_12_emg_param_0_7;
    #line 320 
    emg_wrapper_airo_start_xmit11(emg_12_emg_param_0_7,emg_12_container);
    #line 324 
    ldv_free((void *)emg_12_emg_param_0_7);
    #line 326 
    break;
    #line 328 
    case 7: 
            #line 328 
    ;
    #line 330 
    emg_12_emg_param_1_6 = ldv_xmalloc_unknown_size(0UL);
    #line 330 
    emg_12_emg_param_1_6 = emg_12_emg_param_1_6;
    #line 334 
    emg_wrapper_airo_set_mac_address(emg_12_container,emg_12_emg_param_1_6);
    #line 338 
    ldv_free(emg_12_emg_param_1_6);
    #line 340 
    break;
    #line 342 
    case 8: 
            #line 342 
    ;
    #line 344 
    emg_12_emg_param_1_4 = (struct ifreq *)ldv_xmalloc_unknown_size(0UL);
    #line 344 
    emg_12_emg_param_1_4 = emg_12_emg_param_1_4;
    #line 348 
    emg_wrapper_airo_ioctl(emg_12_container,emg_12_emg_param_1_4,emg_12_emg_param_2_5);
    #line 352 
    ldv_free((void *)emg_12_emg_param_1_4);
    #line 354 
    break;
    #line 356 
    case 9: 
            #line 356 
    ;
    #line 358 
    emg_wrapper_airo_get_stats(emg_12_container);
    #line 360 
    break;
    #line 362 
    case 10: 
             #line 362 
    ;
    #line 364 
    emg_12_emg_param_0_3 = (struct sk_buff *)ldv_xmalloc_unknown_size(0UL);
    #line 364 
    emg_12_emg_param_0_3 = emg_12_emg_param_0_3;
    #line 368 
    emg_wrapper_airo_start_xmit(emg_12_emg_param_0_3,emg_12_container);
    #line 372 
    ldv_free((void *)emg_12_emg_param_0_3);
    #line 374 
    break;
    #line 376 
    case 11: 
             #line 376 
    ;
    #line 378 
    emg_wrapper_airo_set_multicast_list(emg_12_container);
    #line 380 
    break;
    #line 382 
    case 12: 
             #line 382 
    ;
    #line 384 
    emg_12_emg_param_1_2 = ldv_xmalloc_unknown_size(0UL);
    #line 384 
    emg_12_emg_param_1_2 = emg_12_emg_param_1_2;
    #line 388 
    emg_wrapper_airo_set_mac_address(emg_12_container,emg_12_emg_param_1_2);
    #line 392 
    ldv_free(emg_12_emg_param_1_2);
    #line 394 
    break;
    #line 396 
    case 13: 
             #line 396 
    ;
    #line 398 
    emg_12_emg_param_1_0 = (struct ifreq *)ldv_xmalloc_unknown_size(0UL);
    #line 398 
    emg_12_emg_param_1_0 = emg_12_emg_param_1_0;
    #line 402 
    emg_wrapper_airo_ioctl(emg_12_container,emg_12_emg_param_1_0,emg_12_emg_param_2_1);
    #line 406 
    ldv_free((void *)emg_12_emg_param_1_0);
    #line 408 
    break;
    #line 410 
    case 14: 
             #line 410 
    ;
    #line 412 
    emg_wrapper_airo_get_stats(emg_12_container);
    #line 415 
    if (emg_repeat_cnt_call_12 > 0) {
      #line 416 
      emg_repeat_cnt_call_12 --;
      #line 418 
      goto emg_call_12;
    }
    else 
         #line 420 
         __VERIFIER_assume(0);
    #line 424 
    break;
    #line 426 
    case 15: 
             #line 426 
    ;
    #line 430 
    break;
    #line 432 
    default: 
             #line 432 
    ;
    #line 432 
    __VERIFIER_assume(0);
  }
  #line 435 
  return (void *)0;
}

#line 440  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
void *emg_pci_pci_scenario_airo_driver(void *arg0)
{
  #line 443 
  int emg_13_choice;
  #line 444 
  struct pci_driver *emg_13_container;
  #line 445 
  struct pci_device_id *emg_13_device_id;
  #line 446 
  struct pci_dev *emg_13_resource_0;
  #line 447 
  struct pm_message emg_13_resource_1;
  #line 448 
  int emg_13_ret;
  #line 449 
  int emg_repeat_cnt_call_13_1 = 1;
  #line 450 
  int emg_repeat_cnt_main_13_1 = 1;
  #line 451 
  int emg_repeat_cnt_call_13_0 = 1;
  #line 452 
  int emg_repeat_cnt_main_13_0 = 1;
  #line 454 
  struct emg_struct_pci_scenario_airo_driver_13 *data = (struct emg_struct_pci_scenario_airo_driver_13 *)arg0;
  #line 458 
  emg_13_choice = 0;
  #line 459 
  emg_13_ret = ldv_undef_int();
  #line 460 
  emg_13_choice = 0;
  #line 461 
  emg_13_container = emg_alias_airo_driver;
  #line 462 
  emg_13_ret = ldv_undef_int();
  #line 464 
  __VERIFIER_assume(data->arg0 == emg_alias_airo_driver);
  #line 466 
  if (data != (struct emg_struct_pci_scenario_airo_driver_13 *)0) {
    #line 467 
    emg_13_container = data->arg0;
    #line 468 
    ldv_free((void *)data);
  }
  #line 473 
  emg_13_resource_0 = (struct pci_dev *)ldv_xmalloc(3312UL);
  #line 474 
  emg_13_choice = __ldv_undef_int_range(0,7);
  #line 475 
  emg_13_device_id = emg_13_container->id_table + (unsigned long)emg_13_choice;
  #line 479 
  goto emg_main_13;
  #line 483 
  return (void *)0;
  #line 486 
  emg_call_13: 
               #line 486 
  ;
  #line 487 
  switch (ldv_undef_int()) {
    #line 488 
    case 0: 
            #line 488 
    ;
    #line 493 
    if (emg_repeat_cnt_call_13_0 > 0) {
      #line 494 
      emg_repeat_cnt_call_13_0 --;
      #line 496 
      goto emg_call_13;
    }
    else 
         #line 498 
         __VERIFIER_assume(0);
    #line 502 
    break;
    #line 504 
    case 1: 
            #line 504 
    ;
    #line 506 
    emg_13_ret = emg_wrapper_airo_pci_suspend(emg_13_resource_0,emg_13_resource_1);
    #line 511 
    emg_13_ret = ldv_filter_err_code(emg_13_ret);
    #line 515 
    emg_wrapper_airo_pci_resume(emg_13_resource_0);
    #line 518 
    if (emg_repeat_cnt_call_13_1 > 0) {
      #line 519 
      emg_repeat_cnt_call_13_1 --;
      #line 521 
      goto emg_call_13;
    }
    else 
         #line 523 
         __VERIFIER_assume(0);
    #line 527 
    break;
    #line 529 
    case 2: 
            #line 529 
    ;
    #line 531 
    if (emg_13_container->shutdown != (void (*)(struct pci_dev *))0) 
      #line 532 
      (*(emg_13_container->shutdown))(emg_13_resource_0);
    #line 537 
    emg_wrapper_airo_pci_remove(emg_13_resource_0);
    #line 540 
    if (emg_repeat_cnt_main_13_1 > 0) {
      #line 541 
      emg_repeat_cnt_main_13_1 --;
      #line 543 
      goto emg_main_13;
    }
    else 
         #line 545 
         __VERIFIER_assume(0);
    #line 549 
    break;
    #line 551 
    default: 
             #line 551 
    ;
    #line 551 
    __VERIFIER_assume(0);
  }
  #line 554 
  return (void *)0;
  #line 557 
  emg_main_13: 
               #line 557 
  ;
  #line 558 
  if (ldv_undef_int() != 0) {
    #line 561 
    ldv_pre_probe();
    #line 565 
    emg_13_ret = emg_wrapper_airo_pci_probe(emg_13_resource_0,emg_13_device_id);
    #line 570 
    emg_13_ret = ldv_post_probe(emg_13_ret);
    #line 573 
    if (ldv_undef_int() != 0) {
      #line 575 
      __VERIFIER_assume(emg_13_ret == 0);
      #line 579 
      goto emg_call_13;
    }
    else 
         #line 584 
         __VERIFIER_assume(emg_13_ret != 0);
    #line 588 
    if (emg_repeat_cnt_main_13_0 > 0) {
      #line 589 
      emg_repeat_cnt_main_13_0 --;
      #line 591 
      goto emg_main_13;
    }
    else 
         #line 593 
         __VERIFIER_assume(0);
  }
  else 
       #line 599 
       ldv_free((void *)emg_13_resource_0);
  #line 607 
  return (void *)0;
}

#line 612  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
int emg___pci_register_driver(struct pci_driver *arg0, struct module *arg1, char *arg2)
{
  #line 615 
  struct pci_driver *emg_2_pci_driver;
  #line 617 
  emg_2_pci_driver = emg_alias_airo_driver;
  #line 618 
  if (ldv_undef_int() != 0) {
    #line 620 
    emg_2_pci_driver = arg0;
    #line 624 
    emg_dispatch_register_2(emg_2_pci_driver);
    #line 628 
    return 0;
  }
  else {
    #line 632 
    return ldv_undef_int_negative();
  }
}

#line 640  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
struct net_device *emg_alloc_netdev_mqs(int arg0, char *arg1, unsigned char arg2, void (*arg3)(struct net_device *), unsigned int arg4, unsigned int arg5)
{
  #line 643 
  struct net_device *emg_3_netdev;
  #line 644 
  void (*emg_3_setup)(struct net_device *);
  #line 646 
  emg_3_setup = & ether_setup;
  #line 647 
  if (ldv_undef_int() != 0) {
    #line 649 
    emg_3_netdev = (struct net_device *)ldv_xmalloc(3328UL);
    #line 650 
    emg_3_setup = arg3;
    #line 654 
    ether_setup(emg_3_netdev);
    #line 658 
    return emg_3_netdev;
  }
  else 
       #line 662 
       return (struct net_device *)0;
}

#line 670  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
void *emg_free_irq(unsigned int arg0, void *arg1)
{
  #line 673 
  int emg_4_line;
  #line 676 
  emg_4_line = (int)arg0;
  #line 680 
  emg_dispatch_irq_deregister_4(emg_4_line);
  #line 681 
  ;
  #line 681 
  return (void *)0;
}

#line 687  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
void emg_free_netdev(struct net_device *arg0)
{
  #line 690 
  struct net_device *emg_5_netdev;
  #line 693 
  emg_5_netdev = arg0;
  #line 694 
  ldv_free((void *)emg_5_netdev);
  #line 697 
  return;
}

#line 702  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
struct task_struct *emg_kthread_create_on_node(int (*arg0)(void *), void *arg1, int arg2, char *arg3 , ...)
{
  #line 705 
  void *emg_6_data;
  #line 706 
  void *emg_6_ptr;
  #line 707 
  int (*emg_6_threadfn)(void *);
  #line 709 
  emg_6_threadfn = & emg_wrapper_airo_thread;
  #line 711 
  emg_6_data = arg1;
  #line 712 
  emg_6_threadfn = arg0;
  #line 716 
  emg_wrapper_airo_thread(emg_6_data);
  #line 720 
  emg_6_ptr = ldv_undef_ptr();
  #line 721 
  __VERIFIER_assume((int)ldv_is_err(emg_6_ptr));
  #line 722 
  return (struct task_struct *)emg_6_ptr;
}

#line 729  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
void emg_pci_unregister_driver(struct pci_driver *arg0)
{
  #line 732 
  struct pci_driver *emg_7_pci_driver;
  #line 734 
  emg_7_pci_driver = emg_alias_airo_driver;
  #line 736 
  emg_7_pci_driver = arg0;
  #line 740 
  emg_dispatch_deregister_7(emg_7_pci_driver);
  #line 743 
  return;
}

#line 748  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
int emg_register_netdev(struct net_device *arg0)
{
  #line 751 
  struct net_device *emg_8_netdev;
  #line 752 
  int emg_8_ret;
  #line 755 
  emg_8_ret = ldv_undef_int();
  #line 756 
  emg_8_ret = ldv_undef_int();
  #line 757 
  if (ldv_undef_int() != 0) {
    #line 759 
    emg_8_netdev = arg0;
    #line 763 
    emg_8_ret = emg_wrapper_airo_open(emg_8_netdev);
    #line 766 
    if (ldv_undef_int() != 0) {
      #line 768 
      __VERIFIER_assume(emg_8_ret == 0);
      #line 772 
      emg_dispatch_register_8(emg_8_netdev);
      #line 776 
      return 0;
    }
    else {
      #line 780 
      __VERIFIER_assume(emg_8_ret != 0);
      #line 781 
      ldv_failed_register_netdev();
      #line 782 
      return ldv_undef_int_negative();
    }
  }
  else {
    #line 787 
    ldv_failed_register_netdev();
    #line 788 
    return ldv_undef_int_negative();
  }
}

#line 796  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
int emg_request_irq(unsigned int arg0, enum irqreturn (*arg1)(int , void *), unsigned long arg2, char *arg3, void *arg4)
{
  #line 799 
  enum irqreturn (*emg_9_callback)(int , void *);
  #line 800 
  void *emg_9_data;
  #line 801 
  int emg_9_line;
  #line 802 
  enum irqreturn (*emg_9_thread)(int , void *);
  #line 804 
  emg_9_callback = & emg_wrapper_airo_interrupt;
  #line 805 
  if (ldv_undef_int() != 0) {
    #line 807 
    emg_9_line = (int)arg0;
    #line 808 
    emg_9_callback = arg1;
    #line 809 
    emg_9_thread = (enum irqreturn (*)(int , void *))0;
    #line 810 
    emg_9_data = arg4;
    #line 814 
    emg_dispatch_irq_register_9(emg_9_line,emg_9_callback,emg_9_thread,emg_9_data);
    #line 818 
    return 0;
  }
  else {
    #line 822 
    return ldv_undef_int_negative();
  }
}

#line 830  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
void emg_unregister_netdev(struct net_device *arg0)
{
  #line 833 
  struct net_device *emg_10_netdev;
  #line 836 
  emg_10_netdev = arg0;
  #line 840 
  emg_wrapper_airo_close(emg_10_netdev);
  #line 844 
  emg_dispatch_deregister_10(emg_10_netdev);
  #line 847 
  return;
}

#line 852  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
void *emg_entry_point_insmod(void *arg0)
{
  #line 855 
  int emg_1_ret;
  #line 858 
  emg_1_ret = emg_airo_init_module();
  #line 859 
  emg_1_ret = ldv_post_init(emg_1_ret);
  #line 862 
  if (ldv_undef_int() != 0) {
    #line 864 
    __VERIFIER_assume(emg_1_ret == 0);
    #line 868 
    emg_airo_cleanup_module();
  }
  else 
       #line 872 
       __VERIFIER_assume(emg_1_ret != 0);
  #line 876 
  return (void *)0;
}

#line 881  "/mnt/klever/klever_deploy/klever-work/native-scheduler/scheduler/jobs/6c8e294c-3e5c-4a94-b0f9-6aa4d6dc1c3b/klever-core-work-dir/job/vtg/drivers/net/wireless/cisco/airo.ko/concurrency safety/emg/0/environment_model.c"
int main(void)
{
  #line 883 
  ldv_initialize();
  #line 885 
  emg_entry_point_insmod((void *)0);
  #line 887 
  return 0;
}

