/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef long __off_t;
typedef long __off64_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
enum __anonenum_QRencodeMode_707716630 {
    QR_MODE_NUL = -1,
    QR_MODE_NUM = 0,
    QR_MODE_AN = 1,
    QR_MODE_8 = 2,
    QR_MODE_KANJI = 3,
    QR_MODE_STRUCTURE = 4,
    QR_MODE_ECI = 5,
    QR_MODE_FNC1FIRST = 6,
    QR_MODE_FNC1SECOND = 7
} ;
typedef enum __anonenum_QRencodeMode_707716630 QRencodeMode;
enum __anonenum_QRecLevel_598008851 {
    QR_ECLEVEL_L = 0,
    QR_ECLEVEL_M = 1,
    QR_ECLEVEL_Q = 2,
    QR_ECLEVEL_H = 3
} ;
typedef enum __anonenum_QRecLevel_598008851 QRecLevel;
struct __anonstruct_QRcode_929122250 {
   int version ;
   int width ;
   unsigned char *data ;
};
typedef struct __anonstruct_QRcode_929122250 QRcode;
struct _QRcode_List {
   QRcode *code ;
   struct _QRcode_List *next ;
};
typedef struct _QRcode_List QRcode_List;
enum imageType {
    PNG_TYPE = 0,
    PNG32_TYPE = 1,
    EPS_TYPE = 2,
    SVG_TYPE = 3,
    XPM_TYPE = 4,
    ANSI_TYPE = 5,
    ANSI256_TYPE = 6,
    ASCII_TYPE = 7,
    ASCIIi_TYPE = 8,
    UTF8_TYPE = 9,
    ANSIUTF8_TYPE = 10,
    ANSI256UTF8_TYPE = 11,
    UTF8i_TYPE = 12,
    ANSIUTF8i_TYPE = 13
} ;
struct _QRinput ;
typedef struct _QRinput QRinput;
struct _QRinput_Struct ;
typedef struct _QRinput_Struct QRinput_Struct;
struct __anonstruct_BitStream_209270119 {
   size_t length ;
   size_t datasize ;
   unsigned char *data ;
};
typedef struct __anonstruct_BitStream_209270119 BitStream;
struct _QRinput_List ;
typedef struct _QRinput_List QRinput_List;
struct _QRinput_List {
   QRencodeMode mode ;
   int size ;
   unsigned char *data ;
   BitStream *bstream ;
   QRinput_List *next ;
};
struct _QRinput {
   int version ;
   QRecLevel level ;
   QRinput_List *head ;
   QRinput_List *tail ;
   int mqr ;
   int fnc1 ;
   unsigned char appid ;
};
struct _QRinput_InputList ;
typedef struct _QRinput_InputList QRinput_InputList;
struct _QRinput_InputList {
   QRinput *input ;
   QRinput_InputList *next ;
};
struct _QRinput_Struct {
   int size ;
   int parity ;
   QRinput_InputList *head ;
   QRinput_InputList *tail ;
};
struct __anonstruct_RSblock_1044616699 {
   int dataLength ;
   int eccLength ;
   unsigned char *data ;
   unsigned char *ecc ;
};
typedef struct __anonstruct_RSblock_1044616699 RSblock;
struct __anonstruct_QRRawCode_1053786244 {
   int version ;
   int dataLength ;
   int eccLength ;
   unsigned char *datacode ;
   unsigned char *ecccode ;
   int b1 ;
   int blocks ;
   RSblock *rsblock ;
   int count ;
};
typedef struct __anonstruct_QRRawCode_1053786244 QRRawCode;
struct __anonstruct_MQRRawCode_892681476 {
   int version ;
   int dataLength ;
   int eccLength ;
   unsigned char *datacode ;
   unsigned char *ecccode ;
   RSblock *rsblock ;
   int oddbits ;
   int count ;
};
typedef struct __anonstruct_MQRRawCode_892681476 MQRRawCode;
struct __anonstruct_FrameFiller_528872232 {
   int width ;
   unsigned char *frame ;
   int x ;
   int y ;
   int dir ;
   int bit ;
   int mqr ;
};
typedef struct __anonstruct_FrameFiller_528872232 FrameFiller;
struct __anonstruct_QRspec_Capacity_897426155 {
   int width ;
   int words ;
   int remainder ;
   int ec[4] ;
};
typedef struct __anonstruct_QRspec_Capacity_897426155 QRspec_Capacity;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef int MaskMaker(int  , unsigned char const   * , unsigned char * );
struct __anonstruct_MQRspec_Capacity_991265789 {
   int width ;
   int ec[4] ;
};
typedef struct __anonstruct_MQRspec_Capacity_991265789 MQRspec_Capacity;
typedef void MaskMaker___0(int  , unsigned char const   * , unsigned char * );
#pragma merger("0","/tmp/cil-BKAMGS7R.i","-pthread")
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern int fputc(int __c , FILE *__stream ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
extern char *optarg ;
extern int optind ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc ,
                                                                                          char * const  *___argv ,
                                                                                          char const   *__shortopts ,
                                                                                          struct option  const  *__longopts ,
                                                                                          int *__longind ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
QRcode *QRcode_encodeString(char const   *string , int version___0 , QRecLevel level___0 ,
                            QRencodeMode hint___0 , int casesensitive___0 ) ;
QRcode *QRcode_encodeStringMQR(char const   *string , int version___0 , QRecLevel level___0 ,
                               QRencodeMode hint___0 , int casesensitive___0 ) ;
QRcode *QRcode_encodeData(int size___0 , unsigned char const   *data , int version___0 ,
                          QRecLevel level___0 ) ;
QRcode *QRcode_encodeDataMQR(int size___0 , unsigned char const   *data , int version___0 ,
                             QRecLevel level___0 ) ;
void QRcode_free(QRcode *qrcode ) ;
QRcode_List *QRcode_encodeStringStructured(char const   *string , int version___0 ,
                                           QRecLevel level___0 , QRencodeMode hint___0 ,
                                           int casesensitive___0 ) ;
QRcode_List *QRcode_encodeDataStructured(int size___0 , unsigned char const   *data ,
                                         int version___0 , QRecLevel level___0 ) ;
void QRcode_List_free(QRcode_List *qrlist ) ;
char *QRcode_APIVersionString(void) ;
static int casesensitive  =    1;
static int eightbit  =    0;
static int version  =    0;
static int size  =    3;
static int margin  =    -1;
static int dpi  =    72;
static int structured  =    0;
static int rle  =    0;
static int svg_path  =    0;
static int micro  =    0;
static int inline_svg  =    0;
static int strict_versioning  =    0;
static QRecLevel level  =    (QRecLevel )0;
static QRencodeMode hint  =    (QRencodeMode )2;
static unsigned char fg_color[4]  = {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)255};
static unsigned char bg_color[4]  = {      (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)255};
static int verbose  =    0;
static enum imageType image_type  =    (enum imageType )0;
static struct option  const  options[24]  = 
  {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"output", 1, (int *)((void *)0), 'o'}, 
        {"read-from", 1, (int *)((void *)0), 'r'}, 
        {"level", 1, (int *)((void *)0), 'l'}, 
        {"size", 1, (int *)((void *)0), 's'}, 
        {"symversion", 1, (int *)((void *)0), 'v'}, 
        {"margin", 1, (int *)((void *)0), 'm'}, 
        {"dpi", 1, (int *)((void *)0), 'd'}, 
        {"type", 1, (int *)((void *)0), 't'}, 
        {"structured", 0, (int *)((void *)0), 'S'}, 
        {"kanji", 0, (int *)((void *)0), 'k'}, 
        {"casesensitive", 0, (int *)((void *)0), 'c'}, 
        {"ignorecase", 0, (int *)((void *)0), 'i'}, 
        {"8bit", 0, (int *)((void *)0), '8'}, 
        {"micro", 0, (int *)((void *)0), 'M'}, 
        {"rle", 0, & rle, 1}, 
        {"svg-path", 0, & svg_path, 1}, 
        {"inline", 0, & inline_svg, 1}, 
        {"strict-version", 0, & strict_versioning, 1}, 
        {"foreground", 1, (int *)((void *)0), 'f'}, 
        {"background", 1, (int *)((void *)0), 'b'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"verbose", 0, & verbose, 1}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
static char *optstring  =    (char *)"ho:r:l:s:v:m:d:t:Skci8MV";
static void usage(int help , int longopt , int status ) 
{ 
  FILE *out ;
  FILE *tmp ;
  char *tmp___0 ;

  {
  if (status) {
    tmp = stderr;
  } else {
    tmp = stdout;
  }
  out = tmp;
  tmp___0 = QRcode_APIVersionString();
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"qrencode version %s\nCopyright (C) 2006-2017 Kentaro Fukuchi\n",
          tmp___0);
  if (help) {
    if (longopt) {
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"Usage: qrencode [-o FILENAME] [OPTION]... [STRING]\nEncode input data in a QR Code and save as a PNG or EPS image.\n\n  -h, --help   display the help message. -h displays only the help of short\n               options.\n\n  -o FILENAME, --output=FILENAME\n               write image to FILENAME. If \'-\' is specified, the result\n               will be output to standard output. If -S is given, structured\n               symbols are written to FILENAME-01.png, FILENAME-02.png, ...\n               (suffix is removed from FILENAME, if specified)\n\n  -r FILENAME, --read-from=FILENAME\n               read input data from FILENAME.\n\n  -s NUMBER, --size=NUMBER\n               specify module size in dots (pixels). (default=3)\n\n  -l {LMQH}, --level={LMQH}\n               specify error correction level from L (lowest) to H (highest).\n               (default=L)\n\n  -v NUMBER, --symversion=NUMBER\n               specify the minimum version of the symbol. See SYMBOL VERSIONS\n               for more information. (default=auto)\n\n  -m NUMBER, --margin=NUMBER\n               specify the width of the margins. (default=4 (2 for Micro QR)))\n\n  -d NUMBER, --dpi=NUMBER\n               specify the DPI of the generated PNG. (default=72)\n\n  -t {PNG,PNG32,EPS,SVG,XPM,ANSI,ANSI256,ASCII,ASCIIi,UTF8,UTF8i,ANSIUTF8,ANSIUTF8i,ANSI256UTF8},\n  --type={PNG,PNG32,EPS,SVG,XPM,ANSI,ANSI256,ASCII,ASCIIi,UTF8,UTF8i,ANSIUTF8,ANSIUTF8i,ANSI256UTF8}\n               specify the type of the generated image. (default=PNG)\n\n  -S, --structured\n               make structured symbols. Version must be specified with \'-v\'.\n\n  -k, --kanji  assume that the input text contains kanji (shift-jis).\n\n  -c, --casesensitive\n               encode lower-case alphabet characters in 8-bit mode. (default)\n\n  -i, --ignorecase\n               ignore case distinctions and use only upper-case characters.\n\n  -8, --8bit   encode entire data in 8-bit mode. -k, -c and -i will be ignored.\n\n  -M, --micro  encode in a Micro QR Code.\n\n      --rle    enable run-length encoding for SVG.\n\n      --svg-path\n               use single path to draw modules for SVG.\n\n      --inline only useful for SVG output, generates an SVG without the XML tag.\n\n      --foreground=RRGGBB[AA]\n      --background=RRGGBB[AA]\n               specify foreground/background color in hexadecimal notation.\n               6-digit (RGB) or 8-digit (RGBA) form are supported.\n               Color output support available only in PNG, EPS and SVG.\n\n      --strict-version\n               disable automatic version number adjustment. If the input data is\n               too large for the specified version, the program exits with the\n               code of 1.\n\n  -V, --version\n               display the version number and copyrights of the qrencode.\n\n      --verbose\n               display verbose information to stderr.\n\n  [STRING]     input data. If it is not specified, data will be taken from\n               standard input.\n\nSYMBOL VERSIONS\n               The symbol versions of QR Code range from Version 1 to Version\n               40. Each version has a different module configuration or number\n               of modules, ranging from Version 1 (21 x 21 modules) up to\n               Version 40 (177 x 177 modules). Each higher version number\n               comprises 4 additional modules per side by default. See\n               http://www.qrcode.com/en/about/version.html for a detailed\n               version list.\n");
    } else {
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"Usage: qrencode [-o FILENAME] [OPTION]... [STRING]\nEncode input data in a QR Code and save as a PNG or EPS image.\n\n  -h           display this message.\n  --help       display the usage of long options.\n  -o FILENAME  write image to FILENAME. If \'-\' is specified, the result\n               will be output to standard output. If -S is given, structured\n               symbols are written to FILENAME-01.png, FILENAME-02.png, ...\n               (suffix is removed from FILENAME, if specified)\n  -r FILENAME  read input data from FILENAME.\n  -s NUMBER    specify module size in dots (pixels). (default=3)\n  -l {LMQH}    specify error correction level from L (lowest) to H (highest).\n               (default=L)\n  -v NUMBER    specify the minimum version of the symbol. (default=auto)\n  -m NUMBER    specify the width of the margins. (default=4 (2 for Micro))\n  -d NUMBER    specify the DPI of the generated PNG. (default=72)\n  -t {PNG,PNG32,EPS,SVG,XPM,ANSI,ANSI256,ASCII,ASCIIi,UTF8,UTF8i,ANSIUTF8,ANSIUTF8i,ANSI256UTF8}\n               specify the type of the generated image. (default=PNG)\n  -S           make structured symbols. Version number must be specified with \'-v\'.\n  -k           assume that the input text contains kanji (shift-jis).\n  -c           encode lower-case alphabet characters in 8-bit mode. (default)\n  -i           ignore case distinctions and use only upper-case characters.\n  -8           encode entire data in 8-bit mode. -k, -c and -i will be ignored.\n  -M           encode in a Micro QR Code.\n  -V           display the version number and copyrights of the qrencode.\n  [STRING]     input data. If it is not specified, data will be taken from\n               standard input.\n\n  Try \"qrencode --help\" for more options.\n");
    }
  }
  return;
}
}
static int color_set(unsigned char *color , char const   *value ) 
{ 
  int len ;
  size_t tmp ;
  int i ;
  int count ;
  unsigned int col[4] ;

  {
  tmp = strlen(value);
  len = (int )tmp;
  if (len == 6) {
    count = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%02x%02x%02x%n",
                   & col[0], & col[1], & col[2], & len);
    if (count < 3) {
      return (-1);
    } else
    if (len != 6) {
      return (-1);
    }
    i = 0;
    while (i < 3) {
      *(color + i) = (unsigned char )col[i];
      i ++;
    }
    *(color + 3) = (unsigned char)255;
  } else
  if (len == 8) {
    count = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%02x%02x%02x%02x%n",
                   & col[0], & col[1], & col[2], & col[3], & len);
    if (count < 4) {
      return (-1);
    } else
    if (len != 8) {
      return (-1);
    }
    i = 0;
    while (i < 4) {
      *(color + i) = (unsigned char )col[i];
      i ++;
    }
  } else {
    return (-1);
  }
  return (0);
}
}
static unsigned char data_buffer[14180]  ;
static unsigned char *readFile(FILE *fp , int *length ) 
{ 
  int ret ;
  size_t tmp ;
  int tmp___0 ;

  {
  tmp = fread((void * __restrict  )(data_buffer), (size_t )1, (size_t )14180, (FILE * __restrict  )fp);
  ret = (int )tmp;
  if (ret == 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No input data.\n");
    exit(1);
  }
  tmp___0 = feof(fp);
  if (tmp___0 == 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Input data is too large.\n");
    exit(1);
  }
  data_buffer[ret] = (unsigned char )'\000';
  *length = ret;
  return (data_buffer);
}
}
static FILE *openFile(char const   *outfile ) 
{ 
  FILE *fp ;

  {
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
    fp = stdout;
  } else
  if ((int const   )*(outfile + 0) == 45) {
    if ((int const   )*(outfile + 1) == 0) {
      fp = stdout;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    fp = fopen((char const   * __restrict  )outfile, (char const   * __restrict  )"wb");
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to create file: %s\n",
              outfile);
      perror((char const   *)((void *)0));
      exit(1);
    }
  }
  return (fp);
}
}
static int writePNG(QRcode const   *qrcode , char const   *outfile , enum imageType type ) 
{ 


  {
  fputs((char const   * __restrict  )"PNG output is disabled at compile time. No output generated.\n",
        (FILE * __restrict  )stderr);
  return (0);
}
}
static int writeEPS(QRcode const   *qrcode , char const   *outfile ) 
{ 
  FILE *fp ;
  unsigned char *row ;
  unsigned char *p ;
  int x ;
  int y ;
  int yy ;
  int realwidth ;

  {
  fp = openFile(outfile);
  realwidth = (int )((qrcode->width + (int const   )(margin * 2)) * (int const   )size);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%%!PS-Adobe-2.0 EPSF-1.2\n%%%%BoundingBox: 0 0 %d %d\n%%%%Pages: 1 1\n%%%%EndComments\n",
          realwidth, realwidth);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"/p { moveto 0 1 rlineto 1 0 rlineto 0 -1 rlineto fill } bind def\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"gsave\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%f %f %f setrgbcolor\n",
          (double )((float )bg_color[0] / (float )255), (double )((float )bg_color[1] / (float )255),
          (double )((float )bg_color[2] / (float )255));
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d %d scale\n", realwidth,
          realwidth);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"0 0 p\ngrestore\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%f %f %f setrgbcolor\n",
          (double )((float )fg_color[0] / (float )255), (double )((float )fg_color[1] / (float )255),
          (double )((float )fg_color[2] / (float )255));
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d %d scale\n", size,
          size);
  p = (unsigned char *)qrcode->data;
  y = 0;
  while (y < (int )qrcode->width) {
    row = p + y * (int )qrcode->width;
    yy = ((margin + (int )qrcode->width) - y) - 1;
    x = 0;
    while (x < (int )qrcode->width) {
      if ((int )*(row + x) & 1) {
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d %d p ",
                margin + x, yy);
      }
      x ++;
    }
    y ++;
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n%%%%EOF\n");
  fclose(fp);
  return (0);
}
}
static void writeSVG_drawModules(FILE *fp , int x , int y , int width , char const   *col ,
                                 float opacity ) 
{ 


  {
  if (svg_path) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"M%d,%dh%d", x,
            y, width);
  } else
  if ((int )fg_color[3] != 255) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t\t\t<rect x=\"%d\" y=\"%d\" width=\"%d\" height=\"1\" fill=\"#%s\" fill-opacity=\"%f\"/>\n",
            x, y, width, col, (double )opacity);
  } else {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t\t\t<rect x=\"%d\" y=\"%d\" width=\"%d\" height=\"1\" fill=\"#%s\"/>\n",
            x, y, width, col);
  }
  return;
}
}
static int writeSVG(QRcode const   *qrcode , char const   *outfile ) 
{ 
  FILE *fp ;
  unsigned char *row ;
  unsigned char *p ;
  int x ;
  int y ;
  int x0 ;
  int pen ;
  int symwidth ;
  int realwidth ;
  float scale ;
  char fg[7] ;
  char bg[7] ;
  float fg_opacity ;
  float bg_opacity ;
  char *tmp ;

  {
  fp = openFile(outfile);
  scale = (float )(((double )dpi * (100.0 / 2.54)) / 100.0);
  symwidth = (int )(qrcode->width + (int const   )(margin * 2));
  realwidth = symwidth * size;
  snprintf((char * __restrict  )(fg), (size_t )7, (char const   * __restrict  )"%02x%02x%02x",
           (int )fg_color[0], (int )fg_color[1], (int )fg_color[2]);
  snprintf((char * __restrict  )(bg), (size_t )7, (char const   * __restrict  )"%02x%02x%02x",
           (int )bg_color[0], (int )bg_color[1], (int )bg_color[2]);
  fg_opacity = (float )fg_color[3] / (float )255;
  bg_opacity = (float )bg_color[3] / (float )255;
  if (! inline_svg) {
    fputs((char const   * __restrict  )"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n",
          (FILE * __restrict  )fp);
  }
  tmp = QRcode_APIVersionString();
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"<!-- Created with qrencode %s (https://fukuchi.org/works/qrencode/index.html) -->\n",
          tmp);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"<svg width=\"%.2fcm\" height=\"%.2fcm\" viewBox=\"0 0 %d %d\" preserveAspectRatio=\"none\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n",
          (double )((float )realwidth / scale), (double )((float )realwidth / scale),
          symwidth, symwidth);
  fputs((char const   * __restrict  )"\t<g id=\"QRcode\">\n", (FILE * __restrict  )fp);
  if ((int )bg_color[3] != 255) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t\t<rect x=\"0\" y=\"0\" width=\"%d\" height=\"%d\" fill=\"#%s\" fill-opacity=\"%f\"/>\n",
            symwidth, symwidth, bg, (double )bg_opacity);
  } else {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t\t<rect x=\"0\" y=\"0\" width=\"%d\" height=\"%d\" fill=\"#%s\"/>\n",
            symwidth, symwidth, bg);
  }
  if (svg_path) {
    if ((int )fg_color[3] != 255) {
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t\t<path style=\"stroke:#%s;stroke-opacity:%f\" transform=\"translate(%d,%d.5)\" d=\"",
              fg, (double )fg_opacity, margin, margin);
    } else {
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t\t<path style=\"stroke:#%s\" transform=\"translate(%d,%d.5)\" d=\"",
              fg, margin, margin);
    }
  } else {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t\t<g id=\"Pattern\" transform=\"translate(%d,%d)\">\n",
            margin, margin);
  }
  p = (unsigned char *)qrcode->data;
  y = 0;
  while (y < (int )qrcode->width) {
    row = p + y * (int )qrcode->width;
    if (! rle) {
      x = 0;
      while (x < (int )qrcode->width) {
        if ((int )*(row + x) & 1) {
          writeSVG_drawModules(fp, x, y, 1, (char const   *)(fg), fg_opacity);
        }
        x ++;
      }
    } else {
      pen = 0;
      x0 = 0;
      x = 0;
      while (x < (int )qrcode->width) {
        if (! pen) {
          pen = (int )*(row + x) & 1;
          x0 = x;
        } else
        if (! ((int )*(row + x) & 1)) {
          writeSVG_drawModules(fp, x0, y, x - x0, (char const   *)(fg), fg_opacity);
          pen = 0;
        }
        x ++;
      }
      if (pen) {
        writeSVG_drawModules(fp, x0, y, (int )(qrcode->width - (int const   )x0),
                             (char const   *)(fg), fg_opacity);
      }
    }
    y ++;
  }
  if (svg_path) {
    fputs((char const   * __restrict  )"\"/>\n", (FILE * __restrict  )fp);
  } else {
    fputs((char const   * __restrict  )"\t\t</g>\n", (FILE * __restrict  )fp);
  }
  fputs((char const   * __restrict  )"\t</g>\n", (FILE * __restrict  )fp);
  fputs((char const   * __restrict  )"</svg>\n", (FILE * __restrict  )fp);
  fclose(fp);
  return (0);
}
}
static int writeXPM(QRcode const   *qrcode , char const   *outfile ) 
{ 
  FILE *fp ;
  int x ;
  int xx ;
  int y ;
  int yy ;
  int realwidth ;
  int realmargin ;
  char *row ;
  char fg[7] ;
  char bg[7] ;
  unsigned char *p ;
  void *tmp ;
  char const   *tmp___0 ;

  {
  fp = openFile(outfile);
  realwidth = (int )((qrcode->width + (int const   )(margin * 2)) * (int const   )size);
  realmargin = margin * size;
  tmp = malloc((size_t )realwidth + 1UL);
  row = (char *)tmp;
  if (! row) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to allocate memory.\n");
    exit(1);
  }
  snprintf((char * __restrict  )(fg), (size_t )7, (char const   * __restrict  )"%02x%02x%02x",
           (int )fg_color[0], (int )fg_color[1], (int )fg_color[2]);
  snprintf((char * __restrict  )(bg), (size_t )7, (char const   * __restrict  )"%02x%02x%02x",
           (int )bg_color[0], (int )bg_color[1], (int )bg_color[2]);
  fputs((char const   * __restrict  )"/* XPM */\n", (FILE * __restrict  )fp);
  fputs((char const   * __restrict  )"static const char *const qrcode_xpm[] = {\n",
        (FILE * __restrict  )fp);
  fputs((char const   * __restrict  )"/* width height ncolors chars_per_pixel */\n",
        (FILE * __restrict  )fp);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\"%d %d 2 1\",\n",
          realwidth, realwidth);
  fputs((char const   * __restrict  )"/* colors */\n", (FILE * __restrict  )fp);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\"F c #%s\",\n",
          fg);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\"B c #%s\",\n",
          bg);
  fputs((char const   * __restrict  )"/* pixels */\n", (FILE * __restrict  )fp);
  memset((void *)row, 'B', (size_t )realwidth);
  *(row + realwidth) = (char )'\000';
  y = 0;
  while (y < realmargin) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\"%s\",\n", row);
    y ++;
  }
  p = (unsigned char *)qrcode->data;
  y = 0;
  while (y < (int )qrcode->width) {
    yy = 0;
    while (yy < size) {
      fputs((char const   * __restrict  )"\"", (FILE * __restrict  )fp);
      x = 0;
      while (x < margin) {
        xx = 0;
        while (xx < size) {
          fputs((char const   * __restrict  )"B", (FILE * __restrict  )fp);
          xx ++;
        }
        x ++;
      }
      x = 0;
      while (x < (int )qrcode->width) {
        xx = 0;
        while (xx < size) {
          if ((int )*(p + (y * (int )qrcode->width + x)) & 1) {
            fputs((char const   * __restrict  )"F", (FILE * __restrict  )fp);
          } else {
            fputs((char const   * __restrict  )"B", (FILE * __restrict  )fp);
          }
          xx ++;
        }
        x ++;
      }
      x = 0;
      while (x < margin) {
        xx = 0;
        while (xx < size) {
          fputs((char const   * __restrict  )"B", (FILE * __restrict  )fp);
          xx ++;
        }
        x ++;
      }
      fputs((char const   * __restrict  )"\",\n", (FILE * __restrict  )fp);
      yy ++;
    }
    y ++;
  }
  y = 0;
  while (y < realmargin) {
    if (y < size - 1) {
      tmp___0 = ",";
    } else {
      tmp___0 = "};";
    }
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\"%s\"%s\n", row,
            tmp___0);
    y ++;
  }
  free((void *)row);
  fclose(fp);
  return (0);
}
}
static void writeANSI_margin(FILE *fp , int realwidth , char *buffer , char const   *white ,
                             int white_s ) 
{ 
  int y ;

  {
  strncpy((char * __restrict  )buffer, (char const   * __restrict  )white, (size_t )white_s);
  memset((void *)(buffer + white_s), ' ', (size_t )realwidth * 2UL);
  strcpy((char * __restrict  )((buffer + white_s) + realwidth * 2), (char const   * __restrict  )"\033[0m\n");
  y = 0;
  while (y < margin) {
    fputs((char const   * __restrict  )buffer, (FILE * __restrict  )fp);
    y ++;
  }
  return;
}
}
static int writeANSI(QRcode const   *qrcode , char const   *outfile ) 
{ 
  FILE *fp ;
  unsigned char *row ;
  unsigned char *p ;
  int x ;
  int y ;
  int realwidth ;
  int last ;
  char const   *white ;
  char const   *black ;
  char *buffer ;
  int white_s ;
  int black_s ;
  int buffer_s ;
  void *tmp ;

  {
  if ((unsigned int )image_type == 6U) {
    white = "\033[48;5;231m";
    white_s = 11;
    black = "\033[48;5;16m";
    black_s = 10;
  } else {
    white = "\033[47m";
    white_s = 5;
    black = "\033[40m";
    black_s = 5;
  }
  size = 1;
  fp = openFile(outfile);
  realwidth = (int )((qrcode->width + (int const   )(margin * 2)) * (int const   )size);
  buffer_s = (realwidth * white_s) * 2;
  tmp = malloc((size_t )buffer_s);
  buffer = (char *)tmp;
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to allocate memory.\n");
    exit(1);
  }
  writeANSI_margin(fp, realwidth, buffer, white, white_s);
  p = (unsigned char *)qrcode->data;
  y = 0;
  while (y < (int )qrcode->width) {
    row = p + y * (int )qrcode->width;
    memset((void *)buffer, 0, (size_t )buffer_s);
    strncpy((char * __restrict  )buffer, (char const   * __restrict  )white, (size_t )white_s);
    x = 0;
    while (x < margin) {
      strncat((char * __restrict  )buffer, (char const   * __restrict  )"  ", (size_t )2);
      x ++;
    }
    last = 0;
    x = 0;
    while (x < (int )qrcode->width) {
      if ((int )*(row + x) & 1) {
        if (last != 1) {
          strncat((char * __restrict  )buffer, (char const   * __restrict  )black,
                  (size_t )black_s);
          last = 1;
        }
      } else
      if (last != 0) {
        strncat((char * __restrict  )buffer, (char const   * __restrict  )white, (size_t )white_s);
        last = 0;
      }
      strncat((char * __restrict  )buffer, (char const   * __restrict  )"  ", (size_t )2);
      x ++;
    }
    if (last != 0) {
      strncat((char * __restrict  )buffer, (char const   * __restrict  )white, (size_t )white_s);
    }
    x = 0;
    while (x < margin) {
      strncat((char * __restrict  )buffer, (char const   * __restrict  )"  ", (size_t )2);
      x ++;
    }
    strncat((char * __restrict  )buffer, (char const   * __restrict  )"\033[0m\n",
            (size_t )5);
    fputs((char const   * __restrict  )buffer, (FILE * __restrict  )fp);
    y ++;
  }
  writeANSI_margin(fp, realwidth, buffer, white, white_s);
  fclose(fp);
  free((void *)buffer);
  return (0);
}
}
static void writeUTF8_margin(FILE *fp , int realwidth , char const   *white , char const   *reset ,
                             char const   *full ) 
{ 
  int x ;
  int y ;

  {
  y = 0;
  while (y < margin / 2) {
    fputs((char const   * __restrict  )white, (FILE * __restrict  )fp);
    x = 0;
    while (x < realwidth) {
      fputs((char const   * __restrict  )full, (FILE * __restrict  )fp);
      x ++;
    }
    fputs((char const   * __restrict  )reset, (FILE * __restrict  )fp);
    fputc('\n', fp);
    y ++;
  }
  return;
}
}
static int writeUTF8(QRcode const   *qrcode , char const   *outfile , int use_ansi ,
                     int invert ) 
{ 
  FILE *fp ;
  int x ;
  int y ;
  int realwidth ;
  char const   *white ;
  char const   *reset ;
  char const   *empty ;
  char const   *lowhalf ;
  char const   *uphalf ;
  char const   *full ;
  char const   *tmp ;
  unsigned char *row1 ;
  unsigned char *row2 ;

  {
  empty = " ";
  lowhalf = "\342\226\204";
  uphalf = "\342\226\200";
  full = "\342\226\210";
  if (invert) {
    tmp = empty;
    empty = full;
    full = tmp;
    tmp = lowhalf;
    lowhalf = uphalf;
    uphalf = tmp;
  }
  if (use_ansi) {
    if (use_ansi == 2) {
      white = "\033[38;5;231m\033[48;5;16m";
    } else {
      white = "\033[40;37;1m";
    }
    reset = "\033[0m";
  } else {
    white = "";
    reset = "";
  }
  fp = openFile(outfile);
  realwidth = (int )(qrcode->width + (int const   )(margin * 2));
  writeUTF8_margin(fp, realwidth, white, reset, full);
  y = 0;
  while (y < (int )qrcode->width) {
    row1 = (unsigned char *)(qrcode->data + y * (int )qrcode->width);
    row2 = row1 + qrcode->width;
    fputs((char const   * __restrict  )white, (FILE * __restrict  )fp);
    x = 0;
    while (x < margin) {
      fputs((char const   * __restrict  )full, (FILE * __restrict  )fp);
      x ++;
    }
    x = 0;
    while (x < (int )qrcode->width) {
      if ((int )*(row1 + x) & 1) {
        if (y < (int )(qrcode->width - 1)) {
          if ((int )*(row2 + x) & 1) {
            fputs((char const   * __restrict  )empty, (FILE * __restrict  )fp);
          } else {
            fputs((char const   * __restrict  )lowhalf, (FILE * __restrict  )fp);
          }
        } else {
          fputs((char const   * __restrict  )lowhalf, (FILE * __restrict  )fp);
        }
      } else
      if (y < (int )(qrcode->width - 1)) {
        if ((int )*(row2 + x) & 1) {
          fputs((char const   * __restrict  )uphalf, (FILE * __restrict  )fp);
        } else {
          fputs((char const   * __restrict  )full, (FILE * __restrict  )fp);
        }
      } else {
        fputs((char const   * __restrict  )full, (FILE * __restrict  )fp);
      }
      x ++;
    }
    x = 0;
    while (x < margin) {
      fputs((char const   * __restrict  )full, (FILE * __restrict  )fp);
      x ++;
    }
    fputs((char const   * __restrict  )reset, (FILE * __restrict  )fp);
    fputc('\n', fp);
    y += 2;
  }
  writeUTF8_margin(fp, realwidth, white, reset, full);
  fclose(fp);
  return (0);
}
}
static void writeASCII_margin(FILE *fp , int realwidth , char *buffer , int invert ) 
{ 
  int y ;
  int h ;
  int tmp ;

  {
  h = margin;
  if (invert) {
    tmp = '#';
  } else {
    tmp = ' ';
  }
  memset((void *)buffer, tmp, (size_t )realwidth);
  *(buffer + realwidth) = (char )'\n';
  *(buffer + (realwidth + 1)) = (char )'\000';
  y = 0;
  while (y < h) {
    fputs((char const   * __restrict  )buffer, (FILE * __restrict  )fp);
    y ++;
  }
  return;
}
}
static int writeASCII(QRcode const   *qrcode , char const   *outfile , int invert ) 
{ 
  FILE *fp ;
  unsigned char *row ;
  int x ;
  int y ;
  int realwidth ;
  char *buffer ;
  char *p ;
  int buffer_s ;
  char black ;
  char white ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  black = (char )'#';
  white = (char )' ';
  if (invert) {
    black = (char )' ';
    white = (char )'#';
  }
  size = 1;
  fp = openFile(outfile);
  realwidth = (int )((qrcode->width + (int const   )(margin * 2)) * 2);
  buffer_s = realwidth + 2;
  tmp = malloc((size_t )buffer_s);
  buffer = (char *)tmp;
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to allocate memory.\n");
    exit(1);
  }
  writeASCII_margin(fp, realwidth, buffer, invert);
  y = 0;
  while (y < (int )qrcode->width) {
    row = (unsigned char *)(qrcode->data + y * (int )qrcode->width);
    p = buffer;
    memset((void *)p, (int )white, (size_t )margin * 2UL);
    p += margin * 2;
    x = 0;
    while (x < (int )qrcode->width) {
      if ((int )*(row + x) & 1) {
        tmp___0 = p;
        p ++;
        *tmp___0 = black;
        tmp___1 = p;
        p ++;
        *tmp___1 = black;
      } else {
        tmp___2 = p;
        p ++;
        *tmp___2 = white;
        tmp___3 = p;
        p ++;
        *tmp___3 = white;
      }
      x ++;
    }
    memset((void *)p, (int )white, (size_t )margin * 2UL);
    p += margin * 2;
    tmp___4 = p;
    p ++;
    *tmp___4 = (char )'\n';
    tmp___5 = p;
    p ++;
    *tmp___5 = (char )'\000';
    fputs((char const   * __restrict  )buffer, (FILE * __restrict  )fp);
    y ++;
  }
  writeASCII_margin(fp, realwidth, buffer, invert);
  fclose(fp);
  free((void *)buffer);
  return (0);
}
}
static QRcode *encode(unsigned char const   *intext , int length ) 
{ 
  QRcode *code ;

  {
  if (micro) {
    if (eightbit) {
      code = QRcode_encodeDataMQR(length, intext, version, level);
    } else {
      code = QRcode_encodeStringMQR((char const   *)((char *)intext), version, level,
                                    hint, casesensitive);
    }
  } else
  if (eightbit) {
    code = QRcode_encodeData(length, intext, version, level);
  } else {
    code = QRcode_encodeString((char const   *)((char *)intext), version, level, hint,
                               casesensitive);
  }
  return (code);
}
}
static void qrencode(unsigned char const   *intext , int length , char const   *outfile ) 
{ 
  QRcode *qrcode ;
  int *tmp ;
  char const   *tmp___0 ;

  {
  qrcode = encode(intext, length);
  if ((unsigned long )qrcode == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    if (*tmp == 34) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to encode the input data: Input data too large\n");
    } else {
      perror("Failed to encode the input data");
    }
    exit(1);
  }
  if (strict_versioning) {
    if (version > 0) {
      if (qrcode->version != version) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to encode the input data: Input data too large\n");
        exit(1);
      }
    }
  }
  if (verbose) {
    if ((unsigned long )outfile != (unsigned long )((void *)0)) {
      tmp___0 = outfile;
    } else {
      tmp___0 = "(stdout)";
    }
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"File: %s, Version: %d\n",
            tmp___0, qrcode->version);
  }
  switch ((unsigned int )image_type) {
  case 1U: 
  case 0U: 
  writePNG((QRcode const   *)qrcode, outfile, image_type);
  break;
  case 2U: 
  writeEPS((QRcode const   *)qrcode, outfile);
  break;
  case 3U: 
  writeSVG((QRcode const   *)qrcode, outfile);
  break;
  case 4U: 
  writeXPM((QRcode const   *)qrcode, outfile);
  break;
  case 6U: 
  case 5U: 
  writeANSI((QRcode const   *)qrcode, outfile);
  break;
  case 8U: 
  writeASCII((QRcode const   *)qrcode, outfile, 1);
  break;
  case 7U: 
  writeASCII((QRcode const   *)qrcode, outfile, 0);
  break;
  case 9U: 
  writeUTF8((QRcode const   *)qrcode, outfile, 0, 0);
  break;
  case 10U: 
  writeUTF8((QRcode const   *)qrcode, outfile, 1, 0);
  break;
  case 11U: 
  writeUTF8((QRcode const   *)qrcode, outfile, 2, 0);
  break;
  case 12U: 
  writeUTF8((QRcode const   *)qrcode, outfile, 0, 1);
  break;
  case 13U: 
  writeUTF8((QRcode const   *)qrcode, outfile, 1, 1);
  break;
  default: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unknown image type.\n");
  exit(1);
  }
  QRcode_free(qrcode);
  return;
}
}
static QRcode_List *encodeStructured(unsigned char const   *intext , int length ) 
{ 
  QRcode_List *list ;

  {
  if (eightbit) {
    list = QRcode_encodeDataStructured(length, intext, version, level);
  } else {
    list = QRcode_encodeStringStructured((char const   *)((char *)intext), version,
                                         level, hint, casesensitive);
  }
  return (list);
}
}
static void qrencodeStructured(unsigned char const   *intext , int length , char const   *outfile ) 
{ 
  QRcode_List *qrlist ;
  QRcode_List *p ;
  char filename[4096] ;
  char *base ;
  char *q ;
  char *suffix ;
  char const   *type_suffix ;
  int i ;
  size_t suffix_size ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
  suffix = (char *)((void *)0);
  i = 1;
  switch ((unsigned int )image_type) {
  case 0U: 
  type_suffix = ".png";
  break;
  case 2U: 
  type_suffix = ".eps";
  break;
  case 3U: 
  type_suffix = ".svg";
  break;
  case 4U: 
  type_suffix = ".xpm";
  break;
  case 13U: 
  case 12U: 
  case 10U: 
  case 9U: 
  case 7U: 
  case 6U: 
  case 5U: 
  type_suffix = ".txt";
  break;
  default: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unknown image type.\n");
  exit(1);
  }
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"An output filename must be specified to store the structured images.\n");
    exit(1);
  }
  base = strdup(outfile);
  if ((unsigned long )base == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to allocate memory.\n");
    exit(1);
  }
  suffix_size = strlen(type_suffix);
  tmp___1 = strlen((char const   *)base);
  if (tmp___1 > suffix_size) {
    tmp = strlen((char const   *)base);
    q = (base + tmp) - suffix_size;
    tmp___0 = strcasecmp(type_suffix, (char const   *)q);
    if (tmp___0 == 0) {
      suffix = strdup((char const   *)q);
      *q = (char )'\000';
    }
  }
  qrlist = encodeStructured(intext, length);
  if ((unsigned long )qrlist == (unsigned long )((void *)0)) {
    tmp___2 = __errno_location();
    if (*tmp___2 == 34) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to encode the input data: Input data too large\n");
    } else {
      perror("Failed to encode the input data");
    }
    exit(1);
  }
  p = qrlist;
  while ((unsigned long )p != (unsigned long )((void *)0)) {
    if ((unsigned long )p->code == (unsigned long )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to encode the input data.\n");
      exit(1);
    }
    if (suffix) {
      snprintf((char * __restrict  )(filename), (size_t )4096, (char const   * __restrict  )"%s-%02d%s",
               base, i, suffix);
    } else {
      snprintf((char * __restrict  )(filename), (size_t )4096, (char const   * __restrict  )"%s-%02d",
               base, i);
    }
    if (verbose) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"File: %s, Version: %d\n",
              filename, (p->code)->version);
    }
    switch ((unsigned int )image_type) {
    case 1U: 
    case 0U: 
    writePNG((QRcode const   *)p->code, (char const   *)(filename), image_type);
    break;
    case 2U: 
    writeEPS((QRcode const   *)p->code, (char const   *)(filename));
    break;
    case 3U: 
    writeSVG((QRcode const   *)p->code, (char const   *)(filename));
    break;
    case 4U: 
    writeXPM((QRcode const   *)p->code, (char const   *)(filename));
    break;
    case 6U: 
    case 5U: 
    writeANSI((QRcode const   *)p->code, (char const   *)(filename));
    break;
    case 8U: 
    writeASCII((QRcode const   *)p->code, (char const   *)(filename), 1);
    break;
    case 7U: 
    writeASCII((QRcode const   *)p->code, (char const   *)(filename), 0);
    break;
    case 9U: 
    writeUTF8((QRcode const   *)p->code, (char const   *)(filename), 0, 0);
    break;
    case 10U: 
    writeUTF8((QRcode const   *)p->code, (char const   *)(filename), 0, 0);
    break;
    case 11U: 
    writeUTF8((QRcode const   *)p->code, (char const   *)(filename), 0, 0);
    break;
    case 12U: 
    writeUTF8((QRcode const   *)p->code, (char const   *)(filename), 0, 1);
    break;
    case 13U: 
    writeUTF8((QRcode const   *)p->code, (char const   *)(filename), 0, 1);
    break;
    default: 
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unknown image type.\n");
    exit(1);
    }
    i ++;
    p = p->next;
  }
  free((void *)base);
  if (suffix) {
    free((void *)suffix);
  }
  QRcode_List_free(qrlist);
  return;
}
}
int main(int argc , char **argv ) 
{ 
  int opt ;
  int lindex ;
  char *outfile ;
  char *infile ;
  unsigned char *intext ;
  int length ;
  FILE *fp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  FILE *tmp___16 ;

  {
  lindex = -1;
  outfile = (char *)((void *)0);
  infile = (char *)((void *)0);
  intext = (unsigned char *)((void *)0);
  length = 0;
  while (1) {
    opt = getopt_long(argc, (char * const  *)argv, (char const   *)optstring, options,
                      & lindex);
    if (! (opt != -1)) {
      break;
    }
    switch (opt) {
    case 104: 
    if (lindex == 0) {
      usage(1, 1, 0);
    } else {
      usage(1, 0, 0);
    }
    exit(0);
    case 111: 
    outfile = optarg;
    break;
    case 114: 
    infile = optarg;
    break;
    case 115: 
    size = atoi((char const   *)optarg);
    if (size <= 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid size: %d\n",
              size);
      exit(1);
    }
    break;
    case 118: 
    version = atoi((char const   *)optarg);
    if (version < 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid version: %d\n",
              version);
      exit(1);
    }
    break;
    case 108: 
    switch ((int )*optarg) {
    case 76: 
    case 108: 
    level = (QRecLevel )0;
    break;
    case 77: 
    case 109: 
    level = (QRecLevel )1;
    break;
    case 81: 
    case 113: 
    level = (QRecLevel )2;
    break;
    case 72: 
    case 104: 
    level = (QRecLevel )3;
    break;
    default: 
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid level: %s\n",
            optarg);
    exit(1);
    }
    break;
    case 109: 
    margin = atoi((char const   *)optarg);
    if (margin < 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid margin: %d\n",
              margin);
      exit(1);
    }
    break;
    case 100: 
    dpi = atoi((char const   *)optarg);
    if (dpi < 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid DPI: %d\n",
              dpi);
      exit(1);
    }
    break;
    case 116: 
    tmp___12 = strcasecmp((char const   *)optarg, "png32");
    if (tmp___12 == 0) {
      image_type = (enum imageType )1;
    } else {
      tmp___11 = strcasecmp((char const   *)optarg, "png");
      if (tmp___11 == 0) {
        image_type = (enum imageType )0;
      } else {
        tmp___10 = strcasecmp((char const   *)optarg, "eps");
        if (tmp___10 == 0) {
          image_type = (enum imageType )2;
        } else {
          tmp___9 = strcasecmp((char const   *)optarg, "svg");
          if (tmp___9 == 0) {
            image_type = (enum imageType )3;
          } else {
            tmp___8 = strcasecmp((char const   *)optarg, "xpm");
            if (tmp___8 == 0) {
              image_type = (enum imageType )4;
            } else {
              tmp___7 = strcasecmp((char const   *)optarg, "ansi");
              if (tmp___7 == 0) {
                image_type = (enum imageType )5;
              } else {
                tmp___6 = strcasecmp((char const   *)optarg, "ansi256");
                if (tmp___6 == 0) {
                  image_type = (enum imageType )6;
                } else {
                  tmp___5 = strcasecmp((char const   *)optarg, "asciii");
                  if (tmp___5 == 0) {
                    image_type = (enum imageType )8;
                  } else {
                    tmp___4 = strcasecmp((char const   *)optarg, "ascii");
                    if (tmp___4 == 0) {
                      image_type = (enum imageType )7;
                    } else {
                      tmp___3 = strcasecmp((char const   *)optarg, "utf8");
                      if (tmp___3 == 0) {
                        image_type = (enum imageType )9;
                      } else {
                        tmp___2 = strcasecmp((char const   *)optarg, "ansiutf8");
                        if (tmp___2 == 0) {
                          image_type = (enum imageType )10;
                        } else {
                          tmp___1 = strcasecmp((char const   *)optarg, "ansi256utf8");
                          if (tmp___1 == 0) {
                            image_type = (enum imageType )11;
                          } else {
                            tmp___0 = strcasecmp((char const   *)optarg, "utf8i");
                            if (tmp___0 == 0) {
                              image_type = (enum imageType )12;
                            } else {
                              tmp = strcasecmp((char const   *)optarg, "ansiutf8i");
                              if (tmp == 0) {
                                image_type = (enum imageType )13;
                              } else {
                                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid image type: %s\n",
                                        optarg);
                                exit(1);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    break;
    case 83: 
    structured = 1;
    break;
    case 107: 
    hint = (QRencodeMode )3;
    break;
    case 99: 
    casesensitive = 1;
    break;
    case 105: 
    casesensitive = 0;
    break;
    case 56: 
    eightbit = 1;
    break;
    case 77: 
    micro = 1;
    break;
    case 102: 
    tmp___13 = color_set((unsigned char *)(fg_color), (char const   *)optarg);
    if (tmp___13) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid foreground color value.\n");
      exit(1);
    }
    break;
    case 98: 
    tmp___14 = color_set((unsigned char *)(bg_color), (char const   *)optarg);
    if (tmp___14) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid background color value.\n");
      exit(1);
    }
    break;
    case 86: 
    usage(0, 0, 0);
    exit(0);
    case 0: 
    break;
    default: 
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Try \"qrencode --help\" for more information.\n");
    exit(1);
    }
  }
  if (argc == 1) {
    usage(1, 0, 1);
    exit(1);
  }
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
    if ((unsigned int )image_type == 0U) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No output filename is given.\n");
      exit(1);
    }
  }
  if (optind < argc) {
    intext = (unsigned char *)*(argv + optind);
    tmp___15 = strlen((char const   *)((char *)intext));
    length = (int )tmp___15;
  }
  if ((unsigned long )intext == (unsigned long )((void *)0)) {
    if ((unsigned long )infile == (unsigned long )((void *)0)) {
      fp = stdin;
    } else {
      tmp___16 = fopen((char const   * __restrict  )infile, (char const   * __restrict  )"r");
      fp = tmp___16;
    }
    if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Cannot read input file %s.\n",
              infile);
      exit(1);
    }
    intext = readFile(fp, & length);
  }
  if (micro) {
    if (version > 4) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Version number should be less or equal to %d.\n",
              4);
      exit(1);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (! micro) {
    if (version > 40) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Version number should be less or equal to %d.\n",
              40);
      exit(1);
    }
  }
  if (margin < 0) {
    if (micro) {
      margin = 2;
    } else {
      margin = 4;
    }
  }
  if (micro) {
    if (structured) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Micro QR Code does not support structured symbols.\n");
      exit(1);
    }
  }
  if (structured) {
    if (version == 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Version number must be specified to encode structured symbols.\n");
      exit(1);
    }
    qrencodeStructured((unsigned char const   *)intext, length, (char const   *)outfile);
  } else {
    qrencode((unsigned char const   *)intext, length, (char const   *)outfile);
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-WWXLWrdN.i","-pthread")
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
QRinput *QRinput_new2(int version___0 , QRecLevel level___0 ) ;
QRinput *QRinput_newMQR(int version___0 , QRecLevel level___0 ) ;
int QRinput_append(QRinput *input , QRencodeMode mode , int size___0 , unsigned char const   *data ) ;
void QRinput_free(QRinput *input ) ;
void QRinput_Struct_free(QRinput_Struct *s ) ;
QRinput_Struct *QRinput_splitQRinputToStruct(QRinput *input ) ;
QRcode *QRcode_encodeInput(QRinput *input ) ;
QRcode *QRcode_encodeString8bit(char const   *string , int version___0 , QRecLevel level___0 ) ;
QRcode *QRcode_encodeString8bitMQR(char const   *string , int version___0 , QRecLevel level___0 ) ;
QRcode_List *QRcode_encodeInputStructured(QRinput_Struct *s ) ;
QRcode_List *QRcode_encodeString8bitStructured(char const   *string , int version___0 ,
                                               QRecLevel level___0 ) ;
int QRcode_List_size(QRcode_List *qrlist ) ;
void QRcode_APIVersion(int *major_version , int *minor_version , int *micro_version ) ;
void QRcode_clearCache(void)  __attribute__((__deprecated__)) ;
int QRspec_getWidth(int version___0 ) ;
int QRspec_getRemainder(int version___0 ) ;
void QRspec_getEccSpec(int version___0 , QRecLevel level___0 , int *spec ) ;
unsigned char *QRspec_newFrame(int version___0 ) ;
int MQRspec_getDataLengthBit(int version___0 , QRecLevel level___0 ) ;
int MQRspec_getDataLength(int version___0 , QRecLevel level___0 ) ;
int MQRspec_getECCLength(int version___0 , QRecLevel level___0 ) ;
int MQRspec_getWidth(int version___0 ) ;
unsigned char *MQRspec_newFrame(int version___0 ) ;
unsigned char *QRinput_getByteStream(QRinput *input ) ;
int RSECC_encode(size_t data_length , size_t ecc_length , unsigned char const   *data ,
                 unsigned char *ecc ) ;
int Split_splitStringToQRinput(char const   *string , QRinput *input , QRencodeMode hint___0 ,
                               int casesensitive___0 ) ;
unsigned char *Mask_makeMask(int width , unsigned char *frame , int mask , QRecLevel level___0 ) ;
unsigned char *Mask_mask(int width , unsigned char *frame , QRecLevel level___0 ) ;
unsigned char *MMask_makeMask(int version___0 , unsigned char *frame , int mask ,
                              QRecLevel level___0 ) ;
unsigned char *MMask_mask(int version___0 , unsigned char *frame , QRecLevel level___0 ) ;
static void RSblock_initBlock(RSblock *block , int dl , unsigned char *data , int el ,
                              unsigned char *ecc ) 
{ 


  {
  block->dataLength = dl;
  block->data = data;
  block->eccLength = el;
  block->ecc = ecc;
  RSECC_encode((size_t )dl, (size_t )el, (unsigned char const   *)data, ecc);
  return;
}
}
static int RSblock_init(RSblock *blocks , int *spec , unsigned char *data , unsigned char *ecc ) 
{ 
  int i ;
  RSblock *block ;
  unsigned char *dp ;
  unsigned char *ep ;
  int el ;
  int dl ;

  {
  dl = *(spec + 1);
  el = *(spec + 2);
  block = blocks;
  dp = data;
  ep = ecc;
  i = 0;
  while (i < *(spec + 0)) {
    RSblock_initBlock(block, dl, dp, el, ep);
    dp += dl;
    ep += el;
    block ++;
    i ++;
  }
  if (*(spec + 3) == 0) {
    return (0);
  }
  dl = *(spec + 4);
  el = *(spec + 2);
  i = 0;
  while (i < *(spec + 3)) {
    RSblock_initBlock(block, dl, dp, el, ep);
    dp += dl;
    ep += el;
    block ++;
    i ++;
  }
  return (0);
}
}
static void QRraw_free(QRRawCode *raw ) ;
static QRRawCode *QRraw_new(QRinput *input ) 
{ 
  QRRawCode *raw ;
  int spec[5] ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = malloc(sizeof(QRRawCode ));
  raw = (QRRawCode *)tmp;
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
    return ((QRRawCode *)((void *)0));
  }
  raw->datacode = QRinput_getByteStream(input);
  if ((unsigned long )raw->datacode == (unsigned long )((void *)0)) {
    free((void *)raw);
    return ((QRRawCode *)((void *)0));
  }
  QRspec_getEccSpec(input->version, input->level, (int *)(spec));
  raw->version = input->version;
  raw->b1 = spec[0];
  raw->dataLength = spec[0] * spec[1] + spec[3] * spec[4];
  raw->eccLength = (spec[0] + spec[3]) * spec[2];
  tmp___0 = malloc((size_t )raw->eccLength);
  raw->ecccode = (unsigned char *)tmp___0;
  if ((unsigned long )raw->ecccode == (unsigned long )((void *)0)) {
    free((void *)raw->datacode);
    free((void *)raw);
    return ((QRRawCode *)((void *)0));
  }
  raw->blocks = spec[0] + spec[3];
  tmp___1 = calloc((size_t )raw->blocks, sizeof(RSblock ));
  raw->rsblock = (RSblock *)tmp___1;
  if ((unsigned long )raw->rsblock == (unsigned long )((void *)0)) {
    QRraw_free(raw);
    return ((QRRawCode *)((void *)0));
  }
  ret = RSblock_init(raw->rsblock, (int *)(spec), raw->datacode, raw->ecccode);
  if (ret < 0) {
    QRraw_free(raw);
    return ((QRRawCode *)((void *)0));
  }
  raw->count = 0;
  return (raw);
}
}
static unsigned char QRraw_getCode(QRRawCode *raw ) 
{ 
  int col ;
  int row ;
  unsigned char ret ;

  {
  if (raw->count < raw->dataLength) {
    row = raw->count % raw->blocks;
    col = raw->count / raw->blocks;
    if (col >= (raw->rsblock + 0)->dataLength) {
      row += raw->b1;
    }
    ret = *((raw->rsblock + row)->data + col);
  } else
  if (raw->count < raw->dataLength + raw->eccLength) {
    row = (raw->count - raw->dataLength) % raw->blocks;
    col = (raw->count - raw->dataLength) / raw->blocks;
    ret = *((raw->rsblock + row)->ecc + col);
  } else {
    return ((unsigned char)0);
  }
  (raw->count) ++;
  return (ret);
}
}
static void QRraw_free(QRRawCode *raw ) 
{ 


  {
  if ((unsigned long )raw != (unsigned long )((void *)0)) {
    free((void *)raw->datacode);
    free((void *)raw->ecccode);
    free((void *)raw->rsblock);
    free((void *)raw);
  }
  return;
}
}
static void MQRraw_free(MQRRawCode *raw ) ;
static MQRRawCode *MQRraw_new(QRinput *input ) 
{ 
  MQRRawCode *raw ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  tmp = malloc(sizeof(MQRRawCode ));
  raw = (MQRRawCode *)tmp;
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
    return ((MQRRawCode *)((void *)0));
  }
  raw->version = input->version;
  raw->dataLength = MQRspec_getDataLength(input->version, input->level);
  raw->eccLength = MQRspec_getECCLength(input->version, input->level);
  tmp___0 = MQRspec_getDataLengthBit(input->version, input->level);
  raw->oddbits = raw->dataLength * 8 - tmp___0;
  raw->datacode = QRinput_getByteStream(input);
  if ((unsigned long )raw->datacode == (unsigned long )((void *)0)) {
    free((void *)raw);
    return ((MQRRawCode *)((void *)0));
  }
  tmp___1 = malloc((size_t )raw->eccLength);
  raw->ecccode = (unsigned char *)tmp___1;
  if ((unsigned long )raw->ecccode == (unsigned long )((void *)0)) {
    free((void *)raw->datacode);
    free((void *)raw);
    return ((MQRRawCode *)((void *)0));
  }
  tmp___2 = calloc((size_t )1, sizeof(RSblock ));
  raw->rsblock = (RSblock *)tmp___2;
  if ((unsigned long )raw->rsblock == (unsigned long )((void *)0)) {
    MQRraw_free(raw);
    return ((MQRRawCode *)((void *)0));
  }
  RSblock_initBlock(raw->rsblock, raw->dataLength, raw->datacode, raw->eccLength,
                    raw->ecccode);
  raw->count = 0;
  return (raw);
}
}
static unsigned char MQRraw_getCode(MQRRawCode *raw ) 
{ 
  unsigned char ret ;

  {
  if (raw->count < raw->dataLength) {
    ret = *(raw->datacode + raw->count);
  } else
  if (raw->count < raw->dataLength + raw->eccLength) {
    ret = *(raw->ecccode + (raw->count - raw->dataLength));
  } else {
    return ((unsigned char)0);
  }
  (raw->count) ++;
  return (ret);
}
}
static void MQRraw_free(MQRRawCode *raw ) 
{ 


  {
  if ((unsigned long )raw != (unsigned long )((void *)0)) {
    free((void *)raw->datacode);
    free((void *)raw->ecccode);
    free((void *)raw->rsblock);
    free((void *)raw);
  }
  return;
}
}
static void FrameFiller_set(FrameFiller *filler , int width , unsigned char *frame ,
                            int mqr ) 
{ 


  {
  filler->width = width;
  filler->frame = frame;
  filler->x = width - 1;
  filler->y = width - 1;
  filler->dir = -1;
  filler->bit = -1;
  filler->mqr = mqr;
  return;
}
}
static unsigned char *FrameFiller_next(FrameFiller *filler ) 
{ 
  unsigned char *p ;
  int x ;
  int y ;
  int w ;
  unsigned char *tmp ;

  {
  if (filler->bit == -1) {
    filler->bit = 0;
    return ((filler->frame + filler->y * filler->width) + filler->x);
  }
  x = filler->x;
  y = filler->y;
  p = filler->frame;
  w = filler->width;
  if (filler->bit == 0) {
    x --;
    (filler->bit) ++;
  } else {
    x ++;
    y += filler->dir;
    (filler->bit) --;
  }
  if (filler->dir < 0) {
    if (y < 0) {
      y = 0;
      x -= 2;
      filler->dir = 1;
      if (! filler->mqr) {
        if (x == 6) {
          x --;
          y = 9;
        }
      }
    }
  } else
  if (y == w) {
    y = w - 1;
    x -= 2;
    filler->dir = -1;
    if (! filler->mqr) {
      if (x == 6) {
        x --;
        y -= 8;
      }
    }
  }
  if (x < 0) {
    return ((unsigned char *)((void *)0));
  } else
  if (y < 0) {
    return ((unsigned char *)((void *)0));
  }
  filler->x = x;
  filler->y = y;
  if ((int )*(p + (y * w + x)) & 128) {
    tmp = FrameFiller_next(filler);
    return (tmp);
  }
  return (p + (y * w + x));
}
}
static QRcode *QRcode_new(int version___0 , int width , unsigned char *data ) 
{ 
  QRcode *qrcode ;
  void *tmp ;

  {
  tmp = malloc(sizeof(QRcode ));
  qrcode = (QRcode *)tmp;
  if ((unsigned long )qrcode == (unsigned long )((void *)0)) {
    return ((QRcode *)((void *)0));
  }
  qrcode->version = version___0;
  qrcode->width = width;
  qrcode->data = data;
  return (qrcode);
}
}
void QRcode_free(QRcode *qrcode ) 
{ 


  {
  if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
    free((void *)qrcode->data);
    free((void *)qrcode);
  }
  return;
}
}
static QRcode *QRcode_encodeMask(QRinput *input , int mask ) 
{ 
  int width ;
  int version___0 ;
  QRRawCode *raw ;
  unsigned char *frame ;
  unsigned char *masked ;
  unsigned char *p ;
  unsigned char code ;
  unsigned char bit ;
  int i ;
  int j ;
  QRcode *qrcode ;
  FrameFiller filler ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;

  {
  qrcode = (QRcode *)((void *)0);
  if (input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode *)((void *)0));
  }
  if (input->version < 0) {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return ((QRcode *)((void *)0));
  } else
  if (input->version > 40) {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return ((QRcode *)((void *)0));
  }
  if ((unsigned int )input->level >= 0U) {
    if (! ((unsigned int )input->level <= 3U)) {
      tmp___1 = __errno_location();
      *tmp___1 = 22;
      return ((QRcode *)((void *)0));
    }
  } else {
    tmp___1 = __errno_location();
    *tmp___1 = 22;
    return ((QRcode *)((void *)0));
  }
  raw = QRraw_new(input);
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
    return ((QRcode *)((void *)0));
  }
  version___0 = raw->version;
  width = QRspec_getWidth(version___0);
  frame = QRspec_newFrame(version___0);
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
    QRraw_free(raw);
    return ((QRcode *)((void *)0));
  }
  FrameFiller_set(& filler, width, frame, 0);
  i = 0;
  while (i < raw->dataLength) {
    code = QRraw_getCode(raw);
    bit = (unsigned char)128;
    j = 0;
    while (j < 8) {
      p = FrameFiller_next(& filler);
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        goto EXIT;
      }
      *p = (unsigned char )(((int )bit & (int )code) != 0);
      bit = (unsigned char )((int )bit >> 1);
      j ++;
    }
    i ++;
  }
  i = 0;
  while (i < raw->eccLength) {
    code = QRraw_getCode(raw);
    bit = (unsigned char)128;
    j = 0;
    while (j < 8) {
      p = FrameFiller_next(& filler);
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        goto EXIT;
      }
      *p = (unsigned char )(2 | (((int )bit & (int )code) != 0));
      bit = (unsigned char )((int )bit >> 1);
      j ++;
    }
    i ++;
  }
  QRraw_free(raw);
  raw = (QRRawCode *)((void *)0);
  j = QRspec_getRemainder(version___0);
  i = 0;
  while (i < j) {
    p = FrameFiller_next(& filler);
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      goto EXIT;
    }
    *p = (unsigned char)2;
    i ++;
  }
  if (mask == -2) {
    tmp___2 = malloc((size_t )(width * width));
    masked = (unsigned char *)tmp___2;
    memcpy((void * __restrict  )masked, (void const   * __restrict  )frame, (size_t )(width * width));
  } else
  if (mask < 0) {
    masked = Mask_mask(width, frame, input->level);
  } else {
    masked = Mask_makeMask(width, frame, mask, input->level);
  }
  if ((unsigned long )masked == (unsigned long )((void *)0)) {
    goto EXIT;
  }
  qrcode = QRcode_new(version___0, width, masked);
  if ((unsigned long )qrcode == (unsigned long )((void *)0)) {
    free((void *)masked);
  }
  EXIT: 
  QRraw_free(raw);
  free((void *)frame);
  return (qrcode);
}
}
static QRcode *QRcode_encodeMaskMQR(QRinput *input , int mask ) 
{ 
  int width ;
  int version___0 ;
  MQRRawCode *raw ;
  unsigned char *frame ;
  unsigned char *masked ;
  unsigned char *p ;
  unsigned char code ;
  unsigned char bit ;
  int i ;
  int j ;
  int length ;
  QRcode *qrcode ;
  FrameFiller filler ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;

  {
  qrcode = (QRcode *)((void *)0);
  if (! input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode *)((void *)0));
  }
  if (input->version <= 0) {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return ((QRcode *)((void *)0));
  } else
  if (input->version > 4) {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return ((QRcode *)((void *)0));
  }
  if ((unsigned int )input->level >= 0U) {
    if (! ((unsigned int )input->level <= 2U)) {
      tmp___1 = __errno_location();
      *tmp___1 = 22;
      return ((QRcode *)((void *)0));
    }
  } else {
    tmp___1 = __errno_location();
    *tmp___1 = 22;
    return ((QRcode *)((void *)0));
  }
  raw = MQRraw_new(input);
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
    return ((QRcode *)((void *)0));
  }
  version___0 = raw->version;
  width = MQRspec_getWidth(version___0);
  frame = MQRspec_newFrame(version___0);
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
    MQRraw_free(raw);
    return ((QRcode *)((void *)0));
  }
  FrameFiller_set(& filler, width, frame, 1);
  i = 0;
  while (i < raw->dataLength) {
    code = MQRraw_getCode(raw);
    bit = (unsigned char)128;
    if (raw->oddbits) {
      if (i == raw->dataLength - 1) {
        length = raw->oddbits;
      } else {
        length = 8;
      }
    } else {
      length = 8;
    }
    j = 0;
    while (j < length) {
      p = FrameFiller_next(& filler);
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        goto EXIT;
      }
      *p = (unsigned char )(((int )bit & (int )code) != 0);
      bit = (unsigned char )((int )bit >> 1);
      j ++;
    }
    i ++;
  }
  i = 0;
  while (i < raw->eccLength) {
    code = MQRraw_getCode(raw);
    bit = (unsigned char)128;
    length = 8;
    j = 0;
    while (j < length) {
      p = FrameFiller_next(& filler);
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        goto EXIT;
      }
      *p = (unsigned char )(2 | (((int )bit & (int )code) != 0));
      bit = (unsigned char )((int )bit >> 1);
      j ++;
    }
    i ++;
  }
  MQRraw_free(raw);
  raw = (MQRRawCode *)((void *)0);
  if (mask == -2) {
    tmp___2 = malloc((size_t )(width * width));
    masked = (unsigned char *)tmp___2;
    memcpy((void * __restrict  )masked, (void const   * __restrict  )frame, (size_t )(width * width));
  } else
  if (mask < 0) {
    masked = MMask_mask(version___0, frame, input->level);
  } else {
    masked = MMask_makeMask(version___0, frame, mask, input->level);
  }
  if ((unsigned long )masked == (unsigned long )((void *)0)) {
    goto EXIT;
  }
  qrcode = QRcode_new(version___0, width, masked);
  if ((unsigned long )qrcode == (unsigned long )((void *)0)) {
    free((void *)masked);
  }
  EXIT: 
  MQRraw_free(raw);
  free((void *)frame);
  return (qrcode);
}
}
QRcode *QRcode_encodeInput(QRinput *input ) 
{ 
  QRcode *tmp ;
  QRcode *tmp___0 ;

  {
  if (input->mqr) {
    tmp = QRcode_encodeMaskMQR(input, -1);
    return (tmp);
  } else {
    tmp___0 = QRcode_encodeMask(input, -1);
    return (tmp___0);
  }
}
}
static QRcode *QRcode_encodeStringReal(char const   *string , int version___0 , QRecLevel level___0 ,
                                       int mqr , QRencodeMode hint___0 , int casesensitive___0 ) 
{ 
  QRinput *input ;
  QRcode *code ;
  int ret ;
  int *tmp ;
  int *tmp___0 ;

  {
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode *)((void *)0));
  }
  if ((int )hint___0 != 2) {
    if ((int )hint___0 != 3) {
      tmp___0 = __errno_location();
      *tmp___0 = 22;
      return ((QRcode *)((void *)0));
    }
  }
  if (mqr) {
    input = QRinput_newMQR(version___0, level___0);
  } else {
    input = QRinput_new2(version___0, level___0);
  }
  if ((unsigned long )input == (unsigned long )((void *)0)) {
    return ((QRcode *)((void *)0));
  }
  ret = Split_splitStringToQRinput(string, input, hint___0, casesensitive___0);
  if (ret < 0) {
    QRinput_free(input);
    return ((QRcode *)((void *)0));
  }
  code = QRcode_encodeInput(input);
  QRinput_free(input);
  return (code);
}
}
QRcode *QRcode_encodeString(char const   *string , int version___0 , QRecLevel level___0 ,
                            QRencodeMode hint___0 , int casesensitive___0 ) 
{ 
  QRcode *tmp ;

  {
  tmp = QRcode_encodeStringReal(string, version___0, level___0, 0, hint___0, casesensitive___0);
  return (tmp);
}
}
QRcode *QRcode_encodeStringMQR(char const   *string , int version___0 , QRecLevel level___0 ,
                               QRencodeMode hint___0 , int casesensitive___0 ) 
{ 
  int i ;
  QRcode *code ;
  QRcode *tmp ;

  {
  if (version___0 == 0) {
    version___0 = 1;
  }
  i = version___0;
  while (i <= 4) {
    tmp = QRcode_encodeStringReal(string, i, level___0, 1, hint___0, casesensitive___0);
    code = tmp;
    if ((unsigned long )code != (unsigned long )((void *)0)) {
      return (code);
    }
    i ++;
  }
  return ((QRcode *)((void *)0));
}
}
static QRcode *QRcode_encodeDataReal(unsigned char const   *data , int length , int version___0 ,
                                     QRecLevel level___0 , int mqr ) 
{ 
  QRinput *input ;
  QRcode *code ;
  int ret ;
  int *tmp ;

  {
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode *)((void *)0));
  } else
  if (length == 0) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode *)((void *)0));
  }
  if (mqr) {
    input = QRinput_newMQR(version___0, level___0);
  } else {
    input = QRinput_new2(version___0, level___0);
  }
  if ((unsigned long )input == (unsigned long )((void *)0)) {
    return ((QRcode *)((void *)0));
  }
  ret = QRinput_append(input, (QRencodeMode )2, length, data);
  if (ret < 0) {
    QRinput_free(input);
    return ((QRcode *)((void *)0));
  }
  code = QRcode_encodeInput(input);
  QRinput_free(input);
  return (code);
}
}
QRcode *QRcode_encodeData(int size___0 , unsigned char const   *data , int version___0 ,
                          QRecLevel level___0 ) 
{ 
  QRcode *tmp ;

  {
  tmp = QRcode_encodeDataReal(data, size___0, version___0, level___0, 0);
  return (tmp);
}
}
QRcode *QRcode_encodeString8bit(char const   *string , int version___0 , QRecLevel level___0 ) 
{ 
  int *tmp ;
  size_t tmp___0 ;
  QRcode *tmp___1 ;

  {
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode *)((void *)0));
  }
  tmp___0 = strlen(string);
  tmp___1 = QRcode_encodeDataReal((unsigned char const   *)((unsigned char *)string),
                                  (int )tmp___0, version___0, level___0, 0);
  return (tmp___1);
}
}
QRcode *QRcode_encodeDataMQR(int size___0 , unsigned char const   *data , int version___0 ,
                             QRecLevel level___0 ) 
{ 
  int i ;
  QRcode *code ;
  QRcode *tmp ;

  {
  if (version___0 == 0) {
    version___0 = 1;
  }
  i = version___0;
  while (i <= 4) {
    tmp = QRcode_encodeDataReal(data, size___0, i, level___0, 1);
    code = tmp;
    if ((unsigned long )code != (unsigned long )((void *)0)) {
      return (code);
    }
    i ++;
  }
  return ((QRcode *)((void *)0));
}
}
QRcode *QRcode_encodeString8bitMQR(char const   *string , int version___0 , QRecLevel level___0 ) 
{ 
  int i ;
  int *tmp ;
  QRcode *code ;
  size_t tmp___0 ;
  QRcode *tmp___1 ;

  {
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode *)((void *)0));
  }
  if (version___0 == 0) {
    version___0 = 1;
  }
  i = version___0;
  while (i <= 4) {
    tmp___0 = strlen(string);
    tmp___1 = QRcode_encodeDataReal((unsigned char const   *)((unsigned char *)string),
                                    (int )tmp___0, i, level___0, 1);
    code = tmp___1;
    if ((unsigned long )code != (unsigned long )((void *)0)) {
      return (code);
    }
    i ++;
  }
  return ((QRcode *)((void *)0));
}
}
static QRcode_List *QRcode_List_newEntry(void) 
{ 
  QRcode_List *entry ;
  void *tmp ;

  {
  tmp = malloc(sizeof(QRcode_List ));
  entry = (QRcode_List *)tmp;
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    return ((QRcode_List *)((void *)0));
  }
  entry->next = (struct _QRcode_List *)((void *)0);
  entry->code = (QRcode *)((void *)0);
  return (entry);
}
}
static void QRcode_List_freeEntry(QRcode_List *entry ) 
{ 


  {
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
    QRcode_free(entry->code);
    free((void *)entry);
  }
  return;
}
}
void QRcode_List_free(QRcode_List *qrlist ) 
{ 
  QRcode_List *list ;
  QRcode_List *next ;

  {
  list = qrlist;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    next = list->next;
    QRcode_List_freeEntry(list);
    list = next;
  }
  return;
}
}
int QRcode_List_size(QRcode_List *qrlist ) 
{ 
  QRcode_List *list ;
  int size___0 ;

  {
  list = qrlist;
  size___0 = 0;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    size___0 ++;
    list = list->next;
  }
  return (size___0);
}
}
QRcode_List *QRcode_encodeInputStructured(QRinput_Struct *s ) 
{ 
  QRcode_List *head ;
  QRcode_List *tail ;
  QRcode_List *entry ;
  QRinput_InputList *list ;

  {
  head = (QRcode_List *)((void *)0);
  tail = (QRcode_List *)((void *)0);
  list = s->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    if ((unsigned long )head == (unsigned long )((void *)0)) {
      entry = QRcode_List_newEntry();
      if ((unsigned long )entry == (unsigned long )((void *)0)) {
        goto ABORT;
      }
      head = entry;
      tail = head;
    } else {
      entry = QRcode_List_newEntry();
      if ((unsigned long )entry == (unsigned long )((void *)0)) {
        goto ABORT;
      }
      tail->next = entry;
      tail = tail->next;
    }
    tail->code = QRcode_encodeInput(list->input);
    if ((unsigned long )tail->code == (unsigned long )((void *)0)) {
      goto ABORT;
    }
    list = list->next;
  }
  return (head);
  ABORT: 
  QRcode_List_free(head);
  return ((QRcode_List *)((void *)0));
}
}
static QRcode_List *QRcode_encodeInputToStructured(QRinput *input ) 
{ 
  QRinput_Struct *s ;
  QRcode_List *codes ;

  {
  s = QRinput_splitQRinputToStruct(input);
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return ((QRcode_List *)((void *)0));
  }
  codes = QRcode_encodeInputStructured(s);
  QRinput_Struct_free(s);
  return (codes);
}
}
static QRcode_List *QRcode_encodeDataStructuredReal(int size___0 , unsigned char const   *data ,
                                                    int version___0 , QRecLevel level___0 ,
                                                    int eightbit___0 , QRencodeMode hint___0 ,
                                                    int casesensitive___0 ) 
{ 
  QRinput *input ;
  QRcode_List *codes ;
  int ret ;
  int *tmp ;
  int *tmp___0 ;

  {
  if (version___0 <= 0) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode_List *)((void *)0));
  }
  if (! eightbit___0) {
    if ((int )hint___0 != 2) {
      if ((int )hint___0 != 3) {
        tmp___0 = __errno_location();
        *tmp___0 = 22;
        return ((QRcode_List *)((void *)0));
      }
    }
  }
  input = QRinput_new2(version___0, level___0);
  if ((unsigned long )input == (unsigned long )((void *)0)) {
    return ((QRcode_List *)((void *)0));
  }
  if (eightbit___0) {
    ret = QRinput_append(input, (QRencodeMode )2, size___0, data);
  } else {
    ret = Split_splitStringToQRinput((char const   *)((char *)data), input, hint___0,
                                     casesensitive___0);
  }
  if (ret < 0) {
    QRinput_free(input);
    return ((QRcode_List *)((void *)0));
  }
  codes = QRcode_encodeInputToStructured(input);
  QRinput_free(input);
  return (codes);
}
}
QRcode_List *QRcode_encodeDataStructured(int size___0 , unsigned char const   *data ,
                                         int version___0 , QRecLevel level___0 ) 
{ 
  QRcode_List *tmp ;

  {
  tmp = QRcode_encodeDataStructuredReal(size___0, data, version___0, level___0, 1,
                                        (QRencodeMode )-1, 0);
  return (tmp);
}
}
QRcode_List *QRcode_encodeString8bitStructured(char const   *string , int version___0 ,
                                               QRecLevel level___0 ) 
{ 
  int *tmp ;
  size_t tmp___0 ;
  QRcode_List *tmp___1 ;

  {
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode_List *)((void *)0));
  }
  tmp___0 = strlen(string);
  tmp___1 = QRcode_encodeDataStructured((int )tmp___0, (unsigned char const   *)((unsigned char *)string),
                                        version___0, level___0);
  return (tmp___1);
}
}
QRcode_List *QRcode_encodeStringStructured(char const   *string , int version___0 ,
                                           QRecLevel level___0 , QRencodeMode hint___0 ,
                                           int casesensitive___0 ) 
{ 
  int *tmp ;
  size_t tmp___0 ;
  QRcode_List *tmp___1 ;

  {
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode_List *)((void *)0));
  }
  tmp___0 = strlen(string);
  tmp___1 = QRcode_encodeDataStructuredReal((int )tmp___0, (unsigned char const   *)((unsigned char *)string),
                                            version___0, level___0, 0, hint___0, casesensitive___0);
  return (tmp___1);
}
}
void QRcode_APIVersion(int *major_version , int *minor_version , int *micro_version ) 
{ 


  {
  if ((unsigned long )major_version != (unsigned long )((void *)0)) {
    *major_version = 4;
  }
  if ((unsigned long )minor_version != (unsigned long )((void *)0)) {
    *minor_version = 1;
  }
  if ((unsigned long )micro_version != (unsigned long )((void *)0)) {
    *micro_version = 1;
  }
  return;
}
}
char *QRcode_APIVersionString(void) 
{ 


  {
  return ((char *)"4.1.1");
}
}
void QRcode_clearCache(void)  __attribute__((__deprecated__)) ;
void QRcode_clearCache(void) 
{ 


  {
  return;
}
}
#pragma merger("0","/tmp/cil-10pikxoZ.i","-pthread")
QRinput *QRinput_new(void) ;
int QRinput_appendECIheader(QRinput *input , unsigned int ecinum ) ;
int QRinput_getVersion(QRinput *input ) ;
int QRinput_setVersion(QRinput *input , int version___0 ) ;
QRecLevel QRinput_getErrorCorrectionLevel(QRinput *input ) ;
int QRinput_setErrorCorrectionLevel(QRinput *input , QRecLevel level___0 ) ;
int QRinput_setVersionAndErrorCorrectionLevel(QRinput *input , int version___0 , QRecLevel level___0 ) ;
int QRinput_check(QRencodeMode mode , int size___0 , unsigned char const   *data ) ;
QRinput_Struct *QRinput_Struct_new(void) ;
void QRinput_Struct_setParity(QRinput_Struct *s , unsigned char parity ) ;
int QRinput_Struct_appendInput(QRinput_Struct *s , QRinput *input ) ;
int QRinput_Struct_insertStructuredAppendHeaders(QRinput_Struct *s ) ;
int QRinput_setFNC1First(QRinput *input ) ;
int QRinput_setFNC1Second(QRinput *input , unsigned char appid ) ;
int QRspec_getDataLength(int version___0 , QRecLevel level___0 ) ;
int QRspec_getMinimumVersion(int size___0 , QRecLevel level___0 ) ;
int QRspec_lengthIndicator(QRencodeMode mode , int version___0 ) ;
int QRspec_maximumWords(QRencodeMode mode , int version___0 ) ;
int MQRspec_lengthIndicator(QRencodeMode mode , int version___0 ) ;
int MQRspec_maximumWords(QRencodeMode mode , int version___0 ) ;
BitStream *BitStream_new(void) ;
int BitStream_appendNum(BitStream *bstream , size_t bits , unsigned int num ) ;
int BitStream_appendBytes(BitStream *bstream , size_t size___0 , unsigned char *data ) ;
unsigned char *BitStream_toByte(BitStream *bstream ) ;
void BitStream_free(BitStream *bstream ) ;
int QRinput_isSplittableMode(QRencodeMode mode ) ;
int QRinput_estimateBitsModeNum(int size___0 ) ;
int QRinput_estimateBitsModeAn(int size___0 ) ;
int QRinput_estimateBitsMode8(int size___0 ) ;
int QRinput_estimateBitsModeKanji(int size___0 ) ;
QRinput *QRinput_dup(QRinput *input ) ;
signed char const   QRinput_anTable[128] ;
int QRinput_isSplittableMode(QRencodeMode mode ) 
{ 
  int tmp ;

  {
  if ((int )mode >= 0) {
    if ((int )mode <= 3) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static QRinput_List *QRinput_List_newEntry(QRencodeMode mode , int size___0 , unsigned char const   *data ) 
{ 
  QRinput_List *entry ;
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  tmp___0 = QRinput_check(mode, size___0, data);
  if (tmp___0) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRinput_List *)((void *)0));
  }
  tmp___1 = malloc(sizeof(QRinput_List ));
  entry = (QRinput_List *)tmp___1;
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    return ((QRinput_List *)((void *)0));
  }
  entry->mode = mode;
  entry->size = size___0;
  entry->data = (unsigned char *)((void *)0);
  if (size___0 > 0) {
    tmp___2 = malloc((size_t )size___0);
    entry->data = (unsigned char *)tmp___2;
    if ((unsigned long )entry->data == (unsigned long )((void *)0)) {
      free((void *)entry);
      return ((QRinput_List *)((void *)0));
    }
    memcpy((void * __restrict  )entry->data, (void const   * __restrict  )data, (size_t )size___0);
  }
  entry->bstream = (BitStream *)((void *)0);
  entry->next = (QRinput_List *)((void *)0);
  return (entry);
}
}
static void QRinput_List_freeEntry(QRinput_List *entry ) 
{ 


  {
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
    free((void *)entry->data);
    BitStream_free(entry->bstream);
    free((void *)entry);
  }
  return;
}
}
static QRinput_List *QRinput_List_dup(QRinput_List *entry ) 
{ 
  QRinput_List *n ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = malloc(sizeof(QRinput_List ));
  n = (QRinput_List *)tmp;
  if ((unsigned long )n == (unsigned long )((void *)0)) {
    return ((QRinput_List *)((void *)0));
  }
  n->mode = entry->mode;
  n->size = entry->size;
  tmp___0 = malloc((size_t )n->size);
  n->data = (unsigned char *)tmp___0;
  if ((unsigned long )n->data == (unsigned long )((void *)0)) {
    free((void *)n);
    return ((QRinput_List *)((void *)0));
  }
  memcpy((void * __restrict  )n->data, (void const   * __restrict  )entry->data, (size_t )entry->size);
  n->bstream = (BitStream *)((void *)0);
  n->next = (QRinput_List *)((void *)0);
  return (n);
}
}
QRinput *QRinput_new(void) 
{ 
  QRinput *tmp ;

  {
  tmp = QRinput_new2(0, (QRecLevel )0);
  return (tmp);
}
}
QRinput *QRinput_new2(int version___0 , QRecLevel level___0 ) 
{ 
  QRinput *input ;
  int *tmp ;
  void *tmp___0 ;

  {
  if (version___0 < 0) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRinput *)((void *)0));
  } else
  if (version___0 > 40) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRinput *)((void *)0));
  } else
  if ((unsigned int )level___0 < 0U) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRinput *)((void *)0));
  } else
  if ((unsigned int )level___0 > 3U) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRinput *)((void *)0));
  }
  tmp___0 = malloc(sizeof(QRinput ));
  input = (QRinput *)tmp___0;
  if ((unsigned long )input == (unsigned long )((void *)0)) {
    return ((QRinput *)((void *)0));
  }
  input->head = (QRinput_List *)((void *)0);
  input->tail = (QRinput_List *)((void *)0);
  input->version = version___0;
  input->level = level___0;
  input->mqr = 0;
  input->fnc1 = 0;
  return (input);
}
}
QRinput *QRinput_newMQR(int version___0 , QRecLevel level___0 ) 
{ 
  QRinput *input ;
  int tmp ;
  int *tmp___0 ;

  {
  if (version___0 <= 0) {
    goto INVALID;
  } else
  if (version___0 > 4) {
    goto INVALID;
  }
  tmp = MQRspec_getECCLength(version___0, level___0);
  if (tmp == 0) {
    goto INVALID;
  }
  input = QRinput_new2(version___0, level___0);
  if ((unsigned long )input == (unsigned long )((void *)0)) {
    return ((QRinput *)((void *)0));
  }
  input->mqr = 1;
  return (input);
  INVALID: 
  tmp___0 = __errno_location();
  *tmp___0 = 22;
  return ((QRinput *)((void *)0));
}
}
int QRinput_getVersion(QRinput *input ) 
{ 


  {
  return (input->version);
}
}
int QRinput_setVersion(QRinput *input , int version___0 ) 
{ 
  int *tmp ;

  {
  if (input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  } else
  if (version___0 < 0) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  } else
  if (version___0 > 40) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  input->version = version___0;
  return (0);
}
}
QRecLevel QRinput_getErrorCorrectionLevel(QRinput *input ) 
{ 


  {
  return (input->level);
}
}
int QRinput_setErrorCorrectionLevel(QRinput *input , QRecLevel level___0 ) 
{ 
  int *tmp ;

  {
  if (input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  } else
  if ((unsigned int )level___0 > 3U) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  input->level = level___0;
  return (0);
}
}
int QRinput_setVersionAndErrorCorrectionLevel(QRinput *input , int version___0 , QRecLevel level___0 ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
  if (input->mqr) {
    if (version___0 <= 0) {
      goto INVALID;
    } else
    if (version___0 > 4) {
      goto INVALID;
    }
    tmp = MQRspec_getECCLength(version___0, level___0);
    if (tmp == 0) {
      goto INVALID;
    }
  } else {
    if (version___0 < 0) {
      goto INVALID;
    } else
    if (version___0 > 40) {
      goto INVALID;
    }
    if ((unsigned int )level___0 > 3U) {
      goto INVALID;
    }
  }
  input->version = version___0;
  input->level = level___0;
  return (0);
  INVALID: 
  tmp___0 = __errno_location();
  *tmp___0 = 22;
  return (-1);
}
}
static void QRinput_appendEntry(QRinput *input , QRinput_List *entry ) 
{ 


  {
  if ((unsigned long )input->tail == (unsigned long )((void *)0)) {
    input->head = entry;
    input->tail = entry;
  } else {
    (input->tail)->next = entry;
    input->tail = entry;
  }
  entry->next = (QRinput_List *)((void *)0);
  return;
}
}
int QRinput_append(QRinput *input , QRencodeMode mode , int size___0 , unsigned char const   *data ) 
{ 
  QRinput_List *entry ;

  {
  entry = QRinput_List_newEntry(mode, size___0, data);
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    return (-1);
  }
  QRinput_appendEntry(input, entry);
  return (0);
}
}
static int QRinput_insertStructuredAppendHeader(QRinput *input , int size___0 , int number ,
                                                unsigned char parity ) 
{ 
  QRinput_List *entry ;
  unsigned char buf[3] ;
  int *tmp ;
  int *tmp___0 ;

  {
  if (size___0 > 16) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  if (number <= 0) {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return (-1);
  } else
  if (number > size___0) {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return (-1);
  }
  buf[0] = (unsigned char )size___0;
  buf[1] = (unsigned char )number;
  buf[2] = parity;
  entry = QRinput_List_newEntry((QRencodeMode )4, 3, (unsigned char const   *)(buf));
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    return (-1);
  }
  entry->next = input->head;
  input->head = entry;
  return (0);
}
}
int QRinput_appendECIheader(QRinput *input , unsigned int ecinum ) 
{ 
  unsigned char data[4] ;
  int *tmp ;
  int tmp___0 ;

  {
  if (ecinum > 999999U) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  data[0] = (unsigned char )(ecinum & 255U);
  data[1] = (unsigned char )((ecinum >> 8) & 255U);
  data[2] = (unsigned char )((ecinum >> 16) & 255U);
  data[3] = (unsigned char )((ecinum >> 24) & 255U);
  tmp___0 = QRinput_append(input, (QRencodeMode )5, 4, (unsigned char const   *)(data));
  return (tmp___0);
}
}
void QRinput_free(QRinput *input ) 
{ 
  QRinput_List *list ;
  QRinput_List *next ;

  {
  if ((unsigned long )input != (unsigned long )((void *)0)) {
    list = input->head;
    while ((unsigned long )list != (unsigned long )((void *)0)) {
      next = list->next;
      QRinput_List_freeEntry(list);
      list = next;
    }
    free((void *)input);
  }
  return;
}
}
static unsigned char QRinput_calcParity(QRinput *input ) 
{ 
  unsigned char parity ;
  QRinput_List *list ;
  int i ;

  {
  parity = (unsigned char)0;
  list = input->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    if ((int )list->mode != 4) {
      i = list->size - 1;
      while (i >= 0) {
        parity = (unsigned char )((int )parity ^ (int )*(list->data + i));
        i --;
      }
    }
    list = list->next;
  }
  return (parity);
}
}
QRinput *QRinput_dup(QRinput *input ) 
{ 
  QRinput *n ;
  QRinput_List *list ;
  QRinput_List *e ;

  {
  if (input->mqr) {
    n = QRinput_newMQR(input->version, input->level);
  } else {
    n = QRinput_new2(input->version, input->level);
  }
  if ((unsigned long )n == (unsigned long )((void *)0)) {
    return ((QRinput *)((void *)0));
  }
  list = input->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    e = QRinput_List_dup(list);
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      QRinput_free(n);
      return ((QRinput *)((void *)0));
    }
    QRinput_appendEntry(n, e);
    list = list->next;
  }
  return (n);
}
}
static int QRinput_checkModeNum(int size___0 , char const   *data ) 
{ 
  int i ;

  {
  i = 0;
  while (i < size___0) {
    if ((int const   )*(data + i) < 48) {
      return (-1);
    } else
    if ((int const   )*(data + i) > 57) {
      return (-1);
    }
    i ++;
  }
  return (0);
}
}
int QRinput_estimateBitsModeNum(int size___0 ) 
{ 
  int w ;
  int bits ;

  {
  w = size___0 / 3;
  bits = w * 10;
  switch (size___0 - w * 3) {
  case 1: 
  bits += 4;
  break;
  case 2: 
  bits += 7;
  break;
  default: 
  break;
  }
  return (bits);
}
}
static int QRinput_encodeModeNum(QRinput_List *entry , BitStream *bstream , int version___0 ,
                                 int mqr ) 
{ 
  int words ;
  int i ;
  int ret ;
  unsigned int val ;
  int tmp ;
  int tmp___0 ;

  {
  if (mqr) {
    if (version___0 > 1) {
      ret = BitStream_appendNum(bstream, (size_t )(version___0 - 1), 0U);
      if (ret < 0) {
        return (-1);
      }
    }
    tmp = MQRspec_lengthIndicator((QRencodeMode )0, version___0);
    ret = BitStream_appendNum(bstream, (size_t )tmp, (unsigned int )entry->size);
    if (ret < 0) {
      return (-1);
    }
  } else {
    ret = BitStream_appendNum(bstream, (size_t )4, 1U);
    if (ret < 0) {
      return (-1);
    }
    tmp___0 = QRspec_lengthIndicator((QRencodeMode )0, version___0);
    ret = BitStream_appendNum(bstream, (size_t )tmp___0, (unsigned int )entry->size);
    if (ret < 0) {
      return (-1);
    }
  }
  words = entry->size / 3;
  i = 0;
  while (i < words) {
    val = (unsigned int )((int )*(entry->data + i * 3) - 48) * 100U;
    val += (unsigned int )((int )*(entry->data + (i * 3 + 1)) - 48) * 10U;
    val += (unsigned int )((int )*(entry->data + (i * 3 + 2)) - 48);
    ret = BitStream_appendNum(bstream, (size_t )10, val);
    if (ret < 0) {
      return (-1);
    }
    i ++;
  }
  if (entry->size - words * 3 == 1) {
    val = (unsigned int )((int )*(entry->data + words * 3) - 48);
    ret = BitStream_appendNum(bstream, (size_t )4, val);
    if (ret < 0) {
      return (-1);
    }
  } else
  if (entry->size - words * 3 == 2) {
    val = (unsigned int )((int )*(entry->data + words * 3) - 48) * 10U;
    val += (unsigned int )((int )*(entry->data + (words * 3 + 1)) - 48);
    ret = BitStream_appendNum(bstream, (size_t )7, val);
    if (ret < 0) {
      return (-1);
    }
  }
  return (0);
}
}
signed char const   QRinput_anTable[128]  = 
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )36,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )37,      (signed char const   )38,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )39,      (signed char const   )40, 
        (signed char const   )-1,      (signed char const   )41,      (signed char const   )42,      (signed char const   )43, 
        (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )44,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )10,      (signed char const   )11,      (signed char const   )12, 
        (signed char const   )13,      (signed char const   )14,      (signed char const   )15,      (signed char const   )16, 
        (signed char const   )17,      (signed char const   )18,      (signed char const   )19,      (signed char const   )20, 
        (signed char const   )21,      (signed char const   )22,      (signed char const   )23,      (signed char const   )24, 
        (signed char const   )25,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )29,      (signed char const   )30,      (signed char const   )31,      (signed char const   )32, 
        (signed char const   )33,      (signed char const   )34,      (signed char const   )35,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
static int QRinput_checkModeAn(int size___0 , char const   *data ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < size___0) {
    if ((int const   )*(data + i) & 128) {
      tmp = -1;
    } else {
      tmp = (int )QRinput_anTable[(int )*(data + i)];
    }
    if (tmp < 0) {
      return (-1);
    }
    i ++;
  }
  return (0);
}
}
int QRinput_estimateBitsModeAn(int size___0 ) 
{ 
  int w ;
  int bits ;

  {
  w = size___0 / 2;
  bits = w * 11;
  if (size___0 & 1) {
    bits += 6;
  }
  return (bits);
}
}
static int QRinput_encodeModeAn(QRinput_List *entry , BitStream *bstream , int version___0 ,
                                int mqr ) 
{ 
  int words ;
  int i ;
  int ret ;
  unsigned int val ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (mqr) {
    if (version___0 < 2) {
      tmp = __errno_location();
      *tmp = 34;
      return (-1);
    }
    ret = BitStream_appendNum(bstream, (size_t )(version___0 - 1), 1U);
    if (ret < 0) {
      return (-1);
    }
    tmp___0 = MQRspec_lengthIndicator((QRencodeMode )1, version___0);
    ret = BitStream_appendNum(bstream, (size_t )tmp___0, (unsigned int )entry->size);
    if (ret < 0) {
      return (-1);
    }
  } else {
    ret = BitStream_appendNum(bstream, (size_t )4, 2U);
    if (ret < 0) {
      return (-1);
    }
    tmp___1 = QRspec_lengthIndicator((QRencodeMode )1, version___0);
    ret = BitStream_appendNum(bstream, (size_t )tmp___1, (unsigned int )entry->size);
    if (ret < 0) {
      return (-1);
    }
  }
  words = entry->size / 2;
  i = 0;
  while (i < words) {
    if ((int )*(entry->data + i * 2) & 128) {
      tmp___2 = -1;
    } else {
      tmp___2 = (int )QRinput_anTable[(int )*(entry->data + i * 2)];
    }
    val = (unsigned int )tmp___2 * 45U;
    if ((int )*(entry->data + (i * 2 + 1)) & 128) {
      tmp___3 = -1;
    } else {
      tmp___3 = (int )QRinput_anTable[(int )*(entry->data + (i * 2 + 1))];
    }
    val += (unsigned int )tmp___3;
    ret = BitStream_appendNum(bstream, (size_t )11, val);
    if (ret < 0) {
      return (-1);
    }
    i ++;
  }
  if (entry->size & 1) {
    if ((int )*(entry->data + words * 2) & 128) {
      tmp___4 = -1;
    } else {
      tmp___4 = (int )QRinput_anTable[(int )*(entry->data + words * 2)];
    }
    val = (unsigned int )tmp___4;
    ret = BitStream_appendNum(bstream, (size_t )6, val);
    if (ret < 0) {
      return (-1);
    }
  }
  return (0);
}
}
int QRinput_estimateBitsMode8(int size___0 ) 
{ 


  {
  return (size___0 * 8);
}
}
static int QRinput_encodeMode8(QRinput_List *entry , BitStream *bstream , int version___0 ,
                               int mqr ) 
{ 
  int ret ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (mqr) {
    if (version___0 < 3) {
      tmp = __errno_location();
      *tmp = 34;
      return (-1);
    }
    ret = BitStream_appendNum(bstream, (size_t )(version___0 - 1), 2U);
    if (ret < 0) {
      return (-1);
    }
    tmp___0 = MQRspec_lengthIndicator((QRencodeMode )2, version___0);
    ret = BitStream_appendNum(bstream, (size_t )tmp___0, (unsigned int )entry->size);
    if (ret < 0) {
      return (-1);
    }
  } else {
    ret = BitStream_appendNum(bstream, (size_t )4, 4U);
    if (ret < 0) {
      return (-1);
    }
    tmp___1 = QRspec_lengthIndicator((QRencodeMode )2, version___0);
    ret = BitStream_appendNum(bstream, (size_t )tmp___1, (unsigned int )entry->size);
    if (ret < 0) {
      return (-1);
    }
  }
  ret = BitStream_appendBytes(bstream, (size_t )entry->size, entry->data);
  if (ret < 0) {
    return (-1);
  }
  return (0);
}
}
int QRinput_estimateBitsModeKanji(int size___0 ) 
{ 


  {
  return ((size___0 / 2) * 13);
}
}
static int QRinput_checkModeKanji(int size___0 , unsigned char const   *data ) 
{ 
  int i ;
  unsigned int val ;

  {
  if (size___0 & 1) {
    return (-1);
  }
  i = 0;
  while (i < size___0) {
    val = ((unsigned int )*(data + i) << 8) | (unsigned int )*(data + (i + 1));
    if (val < 33088U) {
      return (-1);
    } else
    if (val > 40956U) {
      if (val < 57408U) {
        return (-1);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (val > 60351U) {
      return (-1);
    }
    i += 2;
  }
  return (0);
}
}
static int QRinput_encodeModeKanji(QRinput_List *entry , BitStream *bstream , int version___0 ,
                                   int mqr ) 
{ 
  int ret ;
  int i ;
  unsigned int val ;
  unsigned int h ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (mqr) {
    if (version___0 < 2) {
      tmp = __errno_location();
      *tmp = 34;
      return (-1);
    }
    ret = BitStream_appendNum(bstream, (size_t )(version___0 - 1), 3U);
    if (ret < 0) {
      return (-1);
    }
    tmp___0 = MQRspec_lengthIndicator((QRencodeMode )3, version___0);
    ret = BitStream_appendNum(bstream, (size_t )tmp___0, (unsigned int )entry->size / 2U);
    if (ret < 0) {
      return (-1);
    }
  } else {
    ret = BitStream_appendNum(bstream, (size_t )4, 8U);
    if (ret < 0) {
      return (-1);
    }
    tmp___1 = QRspec_lengthIndicator((QRencodeMode )3, version___0);
    ret = BitStream_appendNum(bstream, (size_t )tmp___1, (unsigned int )entry->size / 2U);
    if (ret < 0) {
      return (-1);
    }
  }
  i = 0;
  while (i < entry->size) {
    val = ((unsigned int )*(entry->data + i) << 8) | (unsigned int )*(entry->data + (i + 1));
    if (val <= 40956U) {
      val -= 33088U;
    } else {
      val -= 49472U;
    }
    h = (val >> 8) * 192U;
    val = (val & 255U) + h;
    ret = BitStream_appendNum(bstream, (size_t )13, val);
    if (ret < 0) {
      return (-1);
    }
    i += 2;
  }
  return (0);
}
}
static int QRinput_encodeModeStructure(QRinput_List *entry , BitStream *bstream ,
                                       int mqr ) 
{ 
  int ret ;
  int *tmp ;

  {
  if (mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  ret = BitStream_appendNum(bstream, (size_t )4, 3U);
  if (ret < 0) {
    return (-1);
  }
  ret = BitStream_appendNum(bstream, (size_t )4, (unsigned int )*(entry->data + 1) - 1U);
  if (ret < 0) {
    return (-1);
  }
  ret = BitStream_appendNum(bstream, (size_t )4, (unsigned int )*(entry->data + 0) - 1U);
  if (ret < 0) {
    return (-1);
  }
  ret = BitStream_appendNum(bstream, (size_t )8, (unsigned int )*(entry->data + 2));
  if (ret < 0) {
    return (-1);
  }
  return (0);
}
}
static int QRinput_checkModeFNC1Second(int size___0 ) 
{ 


  {
  if (size___0 != 1) {
    return (-1);
  }
  return (0);
}
}
static int QRinput_encodeModeFNC1Second(QRinput_List *entry , BitStream *bstream ) 
{ 
  int ret ;

  {
  ret = BitStream_appendNum(bstream, (size_t )4, 9U);
  if (ret < 0) {
    return (-1);
  }
  ret = BitStream_appendBytes(bstream, (size_t )1, entry->data);
  if (ret < 0) {
    return (-1);
  }
  return (0);
}
}
static unsigned int QRinput_decodeECIfromByteArray(unsigned char *data ) 
{ 
  int i ;
  unsigned int ecinum ;

  {
  ecinum = 0U;
  i = 0;
  while (i < 4) {
    ecinum <<= 8;
    ecinum |= (unsigned int )*(data + (3 - i));
    i ++;
  }
  return (ecinum);
}
}
static int QRinput_estimateBitsModeECI(unsigned char *data ) 
{ 
  unsigned int ecinum ;

  {
  ecinum = QRinput_decodeECIfromByteArray(data);
  if (ecinum < 128U) {
    return (12);
  } else
  if (ecinum < 16384U) {
    return (20);
  } else {
    return (28);
  }
}
}
static int QRinput_encodeModeECI(QRinput_List *entry , BitStream *bstream ) 
{ 
  int ret ;
  int words ;
  unsigned int ecinum ;
  unsigned int code ;

  {
  ecinum = QRinput_decodeECIfromByteArray(entry->data);
  if (ecinum < 128U) {
    words = 1;
    code = ecinum;
  } else
  if (ecinum < 16384U) {
    words = 2;
    code = 32768U + ecinum;
  } else {
    words = 3;
    code = 786432U + ecinum;
  }
  ret = BitStream_appendNum(bstream, (size_t )4, 7U);
  if (ret < 0) {
    return (-1);
  }
  ret = BitStream_appendNum(bstream, (size_t )words * 8UL, code);
  if (ret < 0) {
    return (-1);
  }
  return (0);
}
}
int QRinput_check(QRencodeMode mode , int size___0 , unsigned char const   *data ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((int )mode == 6) {
    if (size___0 < 0) {
      return (-1);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (size___0 <= 0) {
    return (-1);
  }
  switch ((int )mode) {
  case 0: 
  tmp = QRinput_checkModeNum(size___0, (char const   *)data);
  return (tmp);
  case 1: 
  tmp___0 = QRinput_checkModeAn(size___0, (char const   *)data);
  return (tmp___0);
  case 3: 
  tmp___1 = QRinput_checkModeKanji(size___0, data);
  return (tmp___1);
  case 2: 
  return (0);
  case 4: 
  return (0);
  case 5: 
  return (0);
  case 6: 
  return (0);
  case 7: 
  tmp___2 = QRinput_checkModeFNC1Second(size___0);
  return (tmp___2);
  case -1: 
  break;
  }
  return (-1);
}
}
static int QRinput_estimateBitStreamSizeOfEntry(QRinput_List *entry , int version___0 ,
                                                int mqr ) 
{ 
  int bits ;
  int l ;
  int m ;
  int num ;

  {
  bits = 0;
  if (version___0 == 0) {
    version___0 = 1;
  }
  switch ((int )entry->mode) {
  case 0: 
  bits = QRinput_estimateBitsModeNum(entry->size);
  break;
  case 1: 
  bits = QRinput_estimateBitsModeAn(entry->size);
  break;
  case 2: 
  bits = QRinput_estimateBitsMode8(entry->size);
  break;
  case 3: 
  bits = QRinput_estimateBitsModeKanji(entry->size);
  break;
  case 4: 
  return (20);
  case 5: 
  bits = QRinput_estimateBitsModeECI(entry->data);
  break;
  case 6: 
  return (4);
  case 7: 
  return (12);
  default: 
  return (0);
  }
  if (mqr) {
    l = MQRspec_lengthIndicator(entry->mode, version___0);
    m = version___0 - 1;
    bits += l + m;
  } else {
    l = QRspec_lengthIndicator(entry->mode, version___0);
    m = 1 << l;
    if ((int )entry->mode == 3) {
      num = ((entry->size / 2 + m) - 1) / m;
    } else {
      num = ((entry->size + m) - 1) / m;
    }
    bits += num * (4 + l);
  }
  return (bits);
}
}
static int QRinput_estimateBitStreamSize(QRinput *input , int version___0 ) 
{ 
  QRinput_List *list ;
  int bits ;
  int tmp ;

  {
  bits = 0;
  list = input->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    tmp = QRinput_estimateBitStreamSizeOfEntry(list, version___0, input->mqr);
    bits += tmp;
    list = list->next;
  }
  return (bits);
}
}
static int QRinput_estimateVersion(QRinput *input ) 
{ 
  int bits ;
  int version___0 ;
  int prev ;

  {
  version___0 = 0;
  while (1) {
    prev = version___0;
    bits = QRinput_estimateBitStreamSize(input, prev);
    version___0 = QRspec_getMinimumVersion((bits + 7) / 8, input->level);
    if (prev == 0) {
      if (version___0 > 1) {
        version___0 --;
      }
    }
    if (! (version___0 > prev)) {
      break;
    }
  }
  return (version___0);
}
}
static int QRinput_lengthOfCode(QRencodeMode mode , int version___0 , int bits ) 
{ 
  int payload ;
  int size___0 ;
  int chunks ;
  int remain ;
  int maxsize ;
  int tmp ;

  {
  tmp = QRspec_lengthIndicator(mode, version___0);
  payload = (bits - 4) - tmp;
  switch ((int )mode) {
  case 0: 
  chunks = payload / 10;
  remain = payload - chunks * 10;
  size___0 = chunks * 3;
  if (remain >= 7) {
    size___0 += 2;
  } else
  if (remain >= 4) {
    size___0 ++;
  }
  break;
  case 1: 
  chunks = payload / 11;
  remain = payload - chunks * 11;
  size___0 = chunks * 2;
  if (remain >= 6) {
    size___0 ++;
  }
  break;
  case 2: 
  size___0 = payload / 8;
  break;
  case 3: 
  size___0 = (payload / 13) * 2;
  break;
  case 4: 
  size___0 = payload / 8;
  break;
  default: 
  size___0 = 0;
  break;
  }
  maxsize = QRspec_maximumWords(mode, version___0);
  if (size___0 < 0) {
    size___0 = 0;
  }
  if (maxsize > 0) {
    if (size___0 > maxsize) {
      size___0 = maxsize;
    }
  }
  return (size___0);
}
}
static int QRinput_encodeBitStream(QRinput_List *entry , BitStream *bstream , int version___0 ,
                                   int mqr ) 
{ 
  int words ;
  int ret ;
  QRinput_List *st1 ;
  QRinput_List *st2 ;
  int prevsize ;

  {
  st1 = (QRinput_List *)((void *)0);
  st2 = (QRinput_List *)((void *)0);
  prevsize = (int )bstream->length;
  if (mqr) {
    words = MQRspec_maximumWords(entry->mode, version___0);
  } else {
    words = QRspec_maximumWords(entry->mode, version___0);
  }
  if (words != 0) {
    if (entry->size > words) {
      st1 = QRinput_List_newEntry(entry->mode, words, (unsigned char const   *)entry->data);
      if ((unsigned long )st1 == (unsigned long )((void *)0)) {
        goto ABORT;
      }
      st2 = QRinput_List_newEntry(entry->mode, entry->size - words, (unsigned char const   *)(entry->data + words));
      if ((unsigned long )st2 == (unsigned long )((void *)0)) {
        goto ABORT;
      }
      ret = QRinput_encodeBitStream(st1, bstream, version___0, mqr);
      if (ret < 0) {
        goto ABORT;
      }
      ret = QRinput_encodeBitStream(st2, bstream, version___0, mqr);
      if (ret < 0) {
        goto ABORT;
      }
      QRinput_List_freeEntry(st1);
      QRinput_List_freeEntry(st2);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    ret = 0;
    switch ((int )entry->mode) {
    case 0: 
    ret = QRinput_encodeModeNum(entry, bstream, version___0, mqr);
    break;
    case 1: 
    ret = QRinput_encodeModeAn(entry, bstream, version___0, mqr);
    break;
    case 2: 
    ret = QRinput_encodeMode8(entry, bstream, version___0, mqr);
    break;
    case 3: 
    ret = QRinput_encodeModeKanji(entry, bstream, version___0, mqr);
    break;
    case 4: 
    ret = QRinput_encodeModeStructure(entry, bstream, mqr);
    break;
    case 5: 
    ret = QRinput_encodeModeECI(entry, bstream);
    break;
    case 7: 
    ret = QRinput_encodeModeFNC1Second(entry, bstream);
    break;
    default: 
    break;
    }
    if (ret < 0) {
      return (-1);
    }
  }
  return ((int )bstream->length - prevsize);
  ABORT: 
  QRinput_List_freeEntry(st1);
  QRinput_List_freeEntry(st2);
  return (-1);
}
}
static int QRinput_createBitStream(QRinput *input , BitStream *bstream ) 
{ 
  QRinput_List *list ;
  int bits ;
  int total ;

  {
  total = 0;
  list = input->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    bits = QRinput_encodeBitStream(list, bstream, input->version, input->mqr);
    if (bits < 0) {
      return (-1);
    }
    total += bits;
    list = list->next;
  }
  return (total);
}
}
static int QRinput_convertData(QRinput *input , BitStream *bstream ) 
{ 
  int bits ;
  int ver ;
  int tmp ;
  int tmp___0 ;

  {
  ver = QRinput_estimateVersion(input);
  tmp = QRinput_getVersion(input);
  if (ver > tmp) {
    QRinput_setVersion(input, ver);
  }
  while (1) {
    bstream->length = (size_t )0;
    bits = QRinput_createBitStream(input, bstream);
    if (bits < 0) {
      return (-1);
    }
    ver = QRspec_getMinimumVersion((bits + 7) / 8, input->level);
    tmp___0 = QRinput_getVersion(input);
    if (ver > tmp___0) {
      QRinput_setVersion(input, ver);
    } else {
      break;
    }
  }
  return (0);
}
}
static int QRinput_appendPaddingBit(BitStream *bstream , QRinput *input ) 
{ 
  int bits ;
  int maxbits ;
  int words ;
  int maxwords ;
  int i ;
  int ret ;
  int padlen ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  bits = (int )bstream->length;
  maxwords = QRspec_getDataLength(input->version, input->level);
  maxbits = maxwords * 8;
  if (maxbits < bits) {
    tmp = __errno_location();
    *tmp = 34;
    return (-1);
  }
  if (maxbits == bits) {
    return (0);
  }
  if (maxbits - bits <= 4) {
    tmp___0 = BitStream_appendNum(bstream, (size_t )(maxbits - bits), 0U);
    return (tmp___0);
  }
  words = ((bits + 4) + 7) / 8;
  tmp___1 = BitStream_appendNum(bstream, (size_t )(words * 8 - bits), 0U);
  ret = tmp___1;
  if (ret < 0) {
    return (ret);
  }
  padlen = maxwords - words;
  if (padlen > 0) {
    i = 0;
    while (i < padlen) {
      if (i & 1) {
        tmp___2 = 17;
      } else {
        tmp___2 = 236;
      }
      tmp___3 = BitStream_appendNum(bstream, (size_t )8, (unsigned int )tmp___2);
      ret = tmp___3;
      if (ret < 0) {
        return (ret);
      }
      i ++;
    }
  }
  return (0);
}
}
static int QRinput_appendPaddingBitMQR(BitStream *bstream , QRinput *input ) 
{ 
  int bits ;
  int maxbits ;
  int words ;
  int maxwords ;
  int i ;
  int ret ;
  int termbits ;
  int padlen ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  bits = (int )bstream->length;
  maxbits = MQRspec_getDataLengthBit(input->version, input->level);
  maxwords = maxbits / 8;
  if (maxbits < bits) {
    tmp = __errno_location();
    *tmp = 34;
    return (-1);
  }
  if (maxbits == bits) {
    return (0);
  }
  termbits = input->version * 2 + 1;
  if (maxbits - bits <= termbits) {
    tmp___0 = BitStream_appendNum(bstream, (size_t )(maxbits - bits), 0U);
    return (tmp___0);
  }
  bits += termbits;
  words = (bits + 7) / 8;
  if (maxbits - words * 8 > 0) {
    termbits += words * 8 - bits;
    if (words == maxwords) {
      termbits += maxbits - words * 8;
    }
  } else {
    termbits += words * 8 - bits;
  }
  tmp___1 = BitStream_appendNum(bstream, (size_t )termbits, 0U);
  ret = tmp___1;
  if (ret < 0) {
    return (ret);
  }
  padlen = maxwords - words;
  if (padlen > 0) {
    i = 0;
    while (i < padlen) {
      if (i & 1) {
        tmp___2 = 17;
      } else {
        tmp___2 = 236;
      }
      tmp___3 = BitStream_appendNum(bstream, (size_t )8, (unsigned int )tmp___2);
      ret = tmp___3;
      if (ret < 0) {
        return (ret);
      }
      i ++;
    }
    termbits = maxbits - maxwords * 8;
    if (termbits > 0) {
      tmp___4 = BitStream_appendNum(bstream, (size_t )termbits, 0U);
      ret = tmp___4;
      if (ret < 0) {
        return (ret);
      }
    }
  }
  return (0);
}
}
static int QRinput_insertFNC1Header(QRinput *input ) 
{ 
  QRinput_List *entry ;

  {
  entry = (QRinput_List *)((void *)0);
  if (input->fnc1 == 1) {
    entry = QRinput_List_newEntry((QRencodeMode )6, 0, (unsigned char const   *)((void *)0));
  } else
  if (input->fnc1 == 2) {
    entry = QRinput_List_newEntry((QRencodeMode )7, 1, (unsigned char const   *)(& input->appid));
  }
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    return (-1);
  }
  if ((int )(input->head)->mode != 4) {
    if ((int )(input->head)->mode != 5) {
      entry->next = input->head;
      input->head = entry;
    } else {
      entry->next = (input->head)->next;
      (input->head)->next = entry;
    }
  } else {
    entry->next = (input->head)->next;
    (input->head)->next = entry;
  }
  return (0);
}
}
static int QRinput_mergeBitStream(QRinput *input , BitStream *bstream ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (input->mqr) {
    tmp = QRinput_createBitStream(input, bstream);
    if (tmp < 0) {
      return (-1);
    }
  } else {
    if (input->fnc1) {
      tmp___0 = QRinput_insertFNC1Header(input);
      if (tmp___0 < 0) {
        return (-1);
      }
    }
    tmp___1 = QRinput_convertData(input, bstream);
    if (tmp___1 < 0) {
      return (-1);
    }
  }
  return (0);
}
}
static int QRinput_getBitStream(QRinput *input , BitStream *bstream ) 
{ 
  int ret ;

  {
  ret = QRinput_mergeBitStream(input, bstream);
  if (ret < 0) {
    return (-1);
  }
  if (input->mqr) {
    ret = QRinput_appendPaddingBitMQR(bstream, input);
  } else {
    ret = QRinput_appendPaddingBit(bstream, input);
  }
  if (ret < 0) {
    return (-1);
  }
  return (0);
}
}
unsigned char *QRinput_getByteStream(QRinput *input ) 
{ 
  BitStream *bstream ;
  unsigned char *array ;
  int ret ;

  {
  bstream = BitStream_new();
  if ((unsigned long )bstream == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  ret = QRinput_getBitStream(input, bstream);
  if (ret < 0) {
    BitStream_free(bstream);
    return ((unsigned char *)((void *)0));
  }
  array = BitStream_toByte(bstream);
  BitStream_free(bstream);
  return (array);
}
}
static QRinput_InputList *QRinput_InputList_newEntry(QRinput *input ) 
{ 
  QRinput_InputList *entry ;
  void *tmp ;

  {
  tmp = malloc(sizeof(QRinput_InputList ));
  entry = (QRinput_InputList *)tmp;
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    return ((QRinput_InputList *)((void *)0));
  }
  entry->input = input;
  entry->next = (QRinput_InputList *)((void *)0);
  return (entry);
}
}
static void QRinput_InputList_freeEntry(QRinput_InputList *entry ) 
{ 


  {
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
    QRinput_free(entry->input);
    free((void *)entry);
  }
  return;
}
}
QRinput_Struct *QRinput_Struct_new(void) 
{ 
  QRinput_Struct *s ;
  void *tmp ;

  {
  tmp = malloc(sizeof(QRinput_Struct ));
  s = (QRinput_Struct *)tmp;
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return ((QRinput_Struct *)((void *)0));
  }
  s->size = 0;
  s->parity = -1;
  s->head = (QRinput_InputList *)((void *)0);
  s->tail = (QRinput_InputList *)((void *)0);
  return (s);
}
}
void QRinput_Struct_setParity(QRinput_Struct *s , unsigned char parity ) 
{ 


  {
  s->parity = (int )parity;
  return;
}
}
int QRinput_Struct_appendInput(QRinput_Struct *s , QRinput *input ) 
{ 
  QRinput_InputList *e ;
  int *tmp ;

  {
  if (input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  e = QRinput_InputList_newEntry(input);
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    return (-1);
  }
  (s->size) ++;
  if ((unsigned long )s->tail == (unsigned long )((void *)0)) {
    s->head = e;
    s->tail = e;
  } else {
    (s->tail)->next = e;
    s->tail = e;
  }
  return (s->size);
}
}
void QRinput_Struct_free(QRinput_Struct *s ) 
{ 
  QRinput_InputList *list ;
  QRinput_InputList *next ;

  {
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    list = s->head;
    while ((unsigned long )list != (unsigned long )((void *)0)) {
      next = list->next;
      QRinput_InputList_freeEntry(list);
      list = next;
    }
    free((void *)s);
  }
  return;
}
}
static unsigned char QRinput_Struct_calcParity(QRinput_Struct *s ) 
{ 
  QRinput_InputList *list ;
  unsigned char parity ;
  unsigned char tmp ;

  {
  parity = (unsigned char)0;
  list = s->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    tmp = QRinput_calcParity(list->input);
    parity = (unsigned char )((int )parity ^ (int )tmp);
    list = list->next;
  }
  QRinput_Struct_setParity(s, parity);
  return (parity);
}
}
static int QRinput_List_shrinkEntry(QRinput_List *entry , int bytes ) 
{ 
  unsigned char *data ;
  void *tmp ;

  {
  tmp = malloc((size_t )bytes);
  data = (unsigned char *)tmp;
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    return (-1);
  }
  memcpy((void * __restrict  )data, (void const   * __restrict  )entry->data, (size_t )bytes);
  free((void *)entry->data);
  entry->data = data;
  entry->size = bytes;
  return (0);
}
}
static int QRinput_splitEntry(QRinput_List *entry , int bytes ) 
{ 
  QRinput_List *e ;
  int ret ;

  {
  e = QRinput_List_newEntry(entry->mode, entry->size - bytes, (unsigned char const   *)(entry->data + bytes));
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    return (-1);
  }
  ret = QRinput_List_shrinkEntry(entry, bytes);
  if (ret < 0) {
    QRinput_List_freeEntry(e);
    return (-1);
  }
  e->next = entry->next;
  entry->next = e;
  return (0);
}
}
QRinput_Struct *QRinput_splitQRinputToStruct(QRinput *input ) 
{ 
  QRinput *p ;
  QRinput_Struct *s ;
  int bits ;
  int maxbits ;
  int nextbits ;
  int bytes ;
  int ret ;
  QRinput_List *list ;
  QRinput_List *next ;
  QRinput_List *prev ;
  BitStream *bstream ;
  int *tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  p = (QRinput *)((void *)0);
  s = (QRinput_Struct *)((void *)0);
  bstream = (BitStream *)((void *)0);
  if (input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRinput_Struct *)((void *)0));
  }
  s = QRinput_Struct_new();
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return ((QRinput_Struct *)((void *)0));
  }
  input = QRinput_dup(input);
  if ((unsigned long )input == (unsigned long )((void *)0)) {
    QRinput_Struct_free(s);
    return ((QRinput_Struct *)((void *)0));
  }
  tmp___0 = QRinput_calcParity(input);
  QRinput_Struct_setParity(s, tmp___0);
  tmp___1 = QRspec_getDataLength(input->version, input->level);
  maxbits = tmp___1 * 8 - 20;
  if (maxbits <= 0) {
    goto ABORT;
  }
  bstream = BitStream_new();
  if ((unsigned long )bstream == (unsigned long )((void *)0)) {
    goto ABORT;
  }
  bits = 0;
  list = input->head;
  prev = (QRinput_List *)((void *)0);
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    nextbits = QRinput_estimateBitStreamSizeOfEntry(list, input->version, input->mqr);
    if (bits + nextbits <= maxbits) {
      bstream->length = (size_t )0;
      ret = QRinput_encodeBitStream(list, bstream, input->version, input->mqr);
      if (ret < 0) {
        goto ABORT;
      }
      bits += ret;
      prev = list;
      list = list->next;
    } else {
      bytes = QRinput_lengthOfCode(list->mode, input->version, maxbits - bits);
      p = QRinput_new2(input->version, input->level);
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        goto ABORT;
      }
      if (bytes > 0) {
        ret = QRinput_splitEntry(list, bytes);
        if (ret < 0) {
          QRinput_free(p);
          goto ABORT;
        }
        next = list->next;
        list->next = (QRinput_List *)((void *)0);
        p->head = next;
        p->tail = input->tail;
        input->tail = list;
        prev = list;
        list = next;
      } else {
        prev->next = (QRinput_List *)((void *)0);
        p->head = list;
        p->tail = input->tail;
        input->tail = prev;
      }
      ret = QRinput_Struct_appendInput(s, input);
      if (ret < 0) {
        QRinput_free(p);
        goto ABORT;
      }
      input = p;
      bits = 0;
    }
  }
  ret = QRinput_Struct_appendInput(s, input);
  if (ret < 0) {
    goto ABORT;
  }
  if (s->size > 16) {
    tmp___2 = __errno_location();
    *tmp___2 = 34;
    QRinput_Struct_free(s);
    BitStream_free(bstream);
    return ((QRinput_Struct *)((void *)0));
  }
  ret = QRinput_Struct_insertStructuredAppendHeaders(s);
  if (ret < 0) {
    QRinput_Struct_free(s);
    BitStream_free(bstream);
    return ((QRinput_Struct *)((void *)0));
  }
  BitStream_free(bstream);
  return (s);
  ABORT: 
  BitStream_free(bstream);
  QRinput_free(input);
  QRinput_Struct_free(s);
  return ((QRinput_Struct *)((void *)0));
}
}
int QRinput_Struct_insertStructuredAppendHeaders(QRinput_Struct *s ) 
{ 
  int i ;
  QRinput_InputList *list ;
  int tmp ;

  {
  if (s->size == 1) {
    return (0);
  }
  if (s->parity < 0) {
    QRinput_Struct_calcParity(s);
  }
  i = 1;
  list = s->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    tmp = QRinput_insertStructuredAppendHeader(list->input, s->size, i, (unsigned char )s->parity);
    if (tmp) {
      return (-1);
    }
    i ++;
    list = list->next;
  }
  return (0);
}
}
int QRinput_setFNC1First(QRinput *input ) 
{ 
  int *tmp ;

  {
  if (input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  input->fnc1 = 1;
  return (0);
}
}
int QRinput_setFNC1Second(QRinput *input , unsigned char appid ) 
{ 
  int *tmp ;

  {
  if (input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  input->fnc1 = 2;
  input->appid = appid;
  return (0);
}
}
#pragma merger("0","/tmp/cil-v4r6r5X8.i","-pthread")
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
int BitStream_append(BitStream *bstream , BitStream *arg ) ;
BitStream *BitStream_new(void) 
{ 
  BitStream *bstream ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = malloc(sizeof(BitStream ));
  bstream = (BitStream *)tmp;
  if ((unsigned long )bstream == (unsigned long )((void *)0)) {
    return ((BitStream *)((void *)0));
  }
  bstream->length = (size_t )0;
  tmp___0 = malloc((size_t )128);
  bstream->data = (unsigned char *)tmp___0;
  if ((unsigned long )bstream->data == (unsigned long )((void *)0)) {
    free((void *)bstream);
    return ((BitStream *)((void *)0));
  }
  bstream->datasize = (size_t )128;
  return (bstream);
}
}
static int BitStream_expand(BitStream *bstream ) 
{ 
  unsigned char *data ;
  void *tmp ;

  {
  tmp = realloc((void *)bstream->data, bstream->datasize * 2UL);
  data = (unsigned char *)tmp;
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    return (-1);
  }
  bstream->data = data;
  bstream->datasize *= 2UL;
  return (0);
}
}
static void BitStream_writeNum(unsigned char *dest , size_t bits , unsigned int num ) 
{ 
  unsigned int mask ;
  size_t i ;
  unsigned char *p ;

  {
  p = dest;
  mask = 1U << (bits - 1UL);
  i = (size_t )0;
  while (i < bits) {
    if (num & mask) {
      *p = (unsigned char)1;
    } else {
      *p = (unsigned char)0;
    }
    p ++;
    mask >>= 1;
    i ++;
  }
  return;
}
}
static void BitStream_writeBytes(unsigned char *dest , size_t size___0 , unsigned char *data ) 
{ 
  unsigned char mask ;
  size_t i ;
  size_t j ;
  unsigned char *p ;

  {
  p = dest;
  i = (size_t )0;
  while (i < size___0) {
    mask = (unsigned char)128;
    j = (size_t )0;
    while (j < 8UL) {
      if ((int )*(data + i) & (int )mask) {
        *p = (unsigned char)1;
      } else {
        *p = (unsigned char)0;
      }
      p ++;
      mask = (unsigned char )((int )mask >> 1);
      j ++;
    }
    i ++;
  }
  return;
}
}
int BitStream_append(BitStream *bstream , BitStream *arg ) 
{ 
  int ret ;

  {
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    return (-1);
  }
  if (arg->length == 0UL) {
    return (0);
  }
  while (bstream->length + arg->length > bstream->datasize) {
    ret = BitStream_expand(bstream);
    if (ret < 0) {
      return (ret);
    }
  }
  memcpy((void * __restrict  )(bstream->data + bstream->length), (void const   * __restrict  )arg->data,
         arg->length);
  bstream->length += arg->length;
  return (0);
}
}
int BitStream_appendNum(BitStream *bstream , size_t bits , unsigned int num ) 
{ 
  int ret ;

  {
  if (bits == 0UL) {
    return (0);
  }
  while (bstream->datasize - bstream->length < bits) {
    ret = BitStream_expand(bstream);
    if (ret < 0) {
      return (ret);
    }
  }
  BitStream_writeNum(bstream->data + bstream->length, bits, num);
  bstream->length += bits;
  return (0);
}
}
int BitStream_appendBytes(BitStream *bstream , size_t size___0 , unsigned char *data ) 
{ 
  int ret ;

  {
  if (size___0 == 0UL) {
    return (0);
  }
  while (bstream->datasize - bstream->length < size___0 * 8UL) {
    ret = BitStream_expand(bstream);
    if (ret < 0) {
      return (ret);
    }
  }
  BitStream_writeBytes(bstream->data + bstream->length, size___0, data);
  bstream->length += size___0 * 8UL;
  return (0);
}
}
unsigned char *BitStream_toByte(BitStream *bstream ) 
{ 
  size_t i ;
  size_t j ;
  size_t size___0 ;
  size_t bytes ;
  size_t oddbits ;
  unsigned char *data ;
  unsigned char v ;
  unsigned char *p ;
  void *tmp ;

  {
  size___0 = bstream->length;
  if (size___0 == 0UL) {
    return ((unsigned char *)((void *)0));
  }
  tmp = malloc((size___0 + 7UL) / 8UL);
  data = (unsigned char *)tmp;
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  bytes = size___0 / 8UL;
  p = bstream->data;
  i = (size_t )0;
  while (i < bytes) {
    v = (unsigned char)0;
    j = (size_t )0;
    while (j < 8UL) {
      v = (unsigned char )((int )v << 1);
      v = (unsigned char )((int )v | (int )*p);
      p ++;
      j ++;
    }
    *(data + i) = v;
    i ++;
  }
  oddbits = size___0 & 7UL;
  if (oddbits > 0UL) {
    v = (unsigned char)0;
    j = (size_t )0;
    while (j < oddbits) {
      v = (unsigned char )((int )v << 1);
      v = (unsigned char )((int )v | (int )*p);
      p ++;
      j ++;
    }
    *(data + bytes) = (unsigned char )((int )v << (8UL - oddbits));
  }
  return (data);
}
}
void BitStream_free(BitStream *bstream ) 
{ 


  {
  if ((unsigned long )bstream != (unsigned long )((void *)0)) {
    free((void *)bstream->data);
    free((void *)bstream);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-ZgUbhVAf.i","-pthread")
int QRspec_getECCLength(int version___0 , QRecLevel level___0 ) ;
unsigned int QRspec_getVersionPattern(int version___0 ) ;
unsigned int QRspec_getFormatInfo(int mask , QRecLevel level___0 ) ;
static QRspec_Capacity const   qrspecCapacity[41]  = 
  {      {0, 0, 0, {0, 0, 0, 0}}, 
        {21, 26, 0, {7, 10, 13, 17}}, 
        {25, 44, 7, {10, 16, 22, 28}}, 
        {29, 70, 7, {15, 26, 36, 44}}, 
        {33, 100, 7, {20, 36, 52, 64}}, 
        {37, 134, 7, {26, 48, 72, 88}}, 
        {41, 172, 7, {36, 64, 96, 112}}, 
        {45, 196, 0, {40, 72, 108, 130}}, 
        {49, 242, 0, {48, 88, 132, 156}}, 
        {53, 292, 0, {60, 110, 160, 192}}, 
        {57, 346, 0, {72, 130, 192, 224}}, 
        {61, 404, 0, {80, 150, 224, 264}}, 
        {65, 466, 0, {96, 176, 260, 308}}, 
        {69, 532, 0, {104, 198, 288, 352}}, 
        {73, 581, 3, {120, 216, 320, 384}}, 
        {77, 655, 3, {132, 240, 360, 432}}, 
        {81, 733, 3, {144, 280, 408, 480}}, 
        {85, 815, 3, {168, 308, 448, 532}}, 
        {89, 901, 3, {180, 338, 504, 588}}, 
        {93, 991, 3, {196, 364, 546, 650}}, 
        {97, 1085, 3, {224, 416, 600, 700}}, 
        {101, 1156, 4, {224, 442, 644, 750}}, 
        {105, 1258, 4, {252, 476, 690, 816}}, 
        {109, 1364, 4, {270, 504, 750, 900}}, 
        {113, 1474, 4, {300, 560, 810, 960}}, 
        {117, 1588, 4, {312, 588, 870, 1050}}, 
        {121, 1706, 4, {336, 644, 952, 1110}}, 
        {125, 1828, 4, {360, 700, 1020, 1200}}, 
        {129, 1921, 3, {390, 728, 1050, 1260}}, 
        {133, 2051, 3, {420, 784, 1140, 1350}}, 
        {137, 2185, 3, {450, 812, 1200, 1440}}, 
        {141, 2323, 3, {480, 868, 1290, 1530}}, 
        {145, 2465, 3, {510, 924, 1350, 1620}}, 
        {149, 2611, 3, {540, 980, 1440, 1710}}, 
        {153, 2761, 3, {570, 1036, 1530, 1800}}, 
        {157, 2876, 0, {570, 1064, 1590, 1890}}, 
        {161, 3034, 0, {600, 1120, 1680, 1980}}, 
        {165, 3196, 0, {630, 1204, 1770, 2100}}, 
        {169, 3362, 0, {660, 1260, 1860, 2220}}, 
        {173, 3532, 0, {720, 1316, 1950, 2310}}, 
        {177, 3706, 0, {750, 1372, 2040, 2430}}};
int QRspec_getDataLength(int version___0 , QRecLevel level___0 ) 
{ 


  {
  return ((int )(qrspecCapacity[version___0].words - (int const   )qrspecCapacity[version___0].ec[level___0]));
}
}
int QRspec_getECCLength(int version___0 , QRecLevel level___0 ) 
{ 


  {
  return (qrspecCapacity[version___0].ec[level___0]);
}
}
int QRspec_getMinimumVersion(int size___0 , QRecLevel level___0 ) 
{ 
  int i ;
  int words ;

  {
  i = 1;
  while (i <= 40) {
    words = (int )(qrspecCapacity[i].words - (int const   )qrspecCapacity[i].ec[level___0]);
    if (words >= size___0) {
      return (i);
    }
    i ++;
  }
  return (40);
}
}
int QRspec_getWidth(int version___0 ) 
{ 


  {
  return ((int )qrspecCapacity[version___0].width);
}
}
int QRspec_getRemainder(int version___0 ) 
{ 


  {
  return ((int )qrspecCapacity[version___0].remainder);
}
}
static int const   lengthTableBits[4][3]  = { {        (int const   )10,        (int const   )12,        (int const   )14}, 
   {        (int const   )9,        (int const   )11,        (int const   )13}, 
   {        (int const   )8,        (int const   )16,        (int const   )16}, 
   {        (int const   )8,        (int const   )10,        (int const   )12}};
int QRspec_lengthIndicator(QRencodeMode mode , int version___0 ) 
{ 
  int l ;
  int tmp ;

  {
  tmp = QRinput_isSplittableMode(mode);
  if (! tmp) {
    return (0);
  }
  if (version___0 <= 9) {
    l = 0;
  } else
  if (version___0 <= 26) {
    l = 1;
  } else {
    l = 2;
  }
  return ((int )lengthTableBits[mode][l]);
}
}
int QRspec_maximumWords(QRencodeMode mode , int version___0 ) 
{ 
  int l ;
  int bits ;
  int words ;
  int tmp ;

  {
  tmp = QRinput_isSplittableMode(mode);
  if (! tmp) {
    return (0);
  }
  if (version___0 <= 9) {
    l = 0;
  } else
  if (version___0 <= 26) {
    l = 1;
  } else {
    l = 2;
  }
  bits = (int )lengthTableBits[mode][l];
  words = (1 << bits) - 1;
  if ((int )mode == 3) {
    words *= 2;
  }
  return (words);
}
}
static int const   eccTable[41][4][2]  = 
  { { {          (int const   )0,          (int const   )0}, 
     {          (int const   )0,          (int const   )0}, 
     {          (int const   )0,          (int const   )0}, 
     {          (int const   )0,          (int const   )0}}, 
   { {          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )0}}, 
   { {          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )0}}, 
   { {          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )0}, 
     {          (int const   )2,          (int const   )0}, 
     {          (int const   )2,          (int const   )0}}, 
   { {          (int const   )1,          (int const   )0}, 
     {          (int const   )2,          (int const   )0}, 
     {          (int const   )2,          (int const   )0}, 
     {          (int const   )4,          (int const   )0}}, 
   { {          (int const   )1,          (int const   )0}, 
     {          (int const   )2,          (int const   )0}, 
     {          (int const   )2,          (int const   )2}, 
     {          (int const   )2,          (int const   )2}}, 
   { {          (int const   )2,          (int const   )0}, 
     {          (int const   )4,          (int const   )0}, 
     {          (int const   )4,          (int const   )0}, 
     {          (int const   )4,          (int const   )0}}, 
   { {          (int const   )2,          (int const   )0}, 
     {          (int const   )4,          (int const   )0}, 
     {          (int const   )2,          (int const   )4}, 
     {          (int const   )4,          (int const   )1}}, 
   { {          (int const   )2,          (int const   )0}, 
     {          (int const   )2,          (int const   )2}, 
     {          (int const   )4,          (int const   )2}, 
     {          (int const   )4,          (int const   )2}}, 
   { {          (int const   )2,          (int const   )0}, 
     {          (int const   )3,          (int const   )2}, 
     {          (int const   )4,          (int const   )4}, 
     {          (int const   )4,          (int const   )4}}, 
   { {          (int const   )2,          (int const   )2}, 
     {          (int const   )4,          (int const   )1}, 
     {          (int const   )6,          (int const   )2}, 
     {          (int const   )6,          (int const   )2}}, 
   { {          (int const   )4,          (int const   )0}, 
     {          (int const   )1,          (int const   )4}, 
     {          (int const   )4,          (int const   )4}, 
     {          (int const   )3,          (int const   )8}}, 
   { {          (int const   )2,          (int const   )2}, 
     {          (int const   )6,          (int const   )2}, 
     {          (int const   )4,          (int const   )6}, 
     {          (int const   )7,          (int const   )4}}, 
   { {          (int const   )4,          (int const   )0}, 
     {          (int const   )8,          (int const   )1}, 
     {          (int const   )8,          (int const   )4}, 
     {          (int const   )12,          (int const   )4}}, 
   { {          (int const   )3,          (int const   )1}, 
     {          (int const   )4,          (int const   )5}, 
     {          (int const   )11,          (int const   )5}, 
     {          (int const   )11,          (int const   )5}}, 
   { {          (int const   )5,          (int const   )1}, 
     {          (int const   )5,          (int const   )5}, 
     {          (int const   )5,          (int const   )7}, 
     {          (int const   )11,          (int const   )7}}, 
   { {          (int const   )5,          (int const   )1}, 
     {          (int const   )7,          (int const   )3}, 
     {          (int const   )15,          (int const   )2}, 
     {          (int const   )3,          (int const   )13}}, 
   { {          (int const   )1,          (int const   )5}, 
     {          (int const   )10,          (int const   )1}, 
     {          (int const   )1,          (int const   )15}, 
     {          (int const   )2,          (int const   )17}}, 
   { {          (int const   )5,          (int const   )1}, 
     {          (int const   )9,          (int const   )4}, 
     {          (int const   )17,          (int const   )1}, 
     {          (int const   )2,          (int const   )19}}, 
   { {          (int const   )3,          (int const   )4}, 
     {          (int const   )3,          (int const   )11}, 
     {          (int const   )17,          (int const   )4}, 
     {          (int const   )9,          (int const   )16}}, 
   { {          (int const   )3,          (int const   )5}, 
     {          (int const   )3,          (int const   )13}, 
     {          (int const   )15,          (int const   )5}, 
     {          (int const   )15,          (int const   )10}}, 
   { {          (int const   )4,          (int const   )4}, 
     {          (int const   )17,          (int const   )0}, 
     {          (int const   )17,          (int const   )6}, 
     {          (int const   )19,          (int const   )6}}, 
   { {          (int const   )2,          (int const   )7}, 
     {          (int const   )17,          (int const   )0}, 
     {          (int const   )7,          (int const   )16}, 
     {          (int const   )34,          (int const   )0}}, 
   { {          (int const   )4,          (int const   )5}, 
     {          (int const   )4,          (int const   )14}, 
     {          (int const   )11,          (int const   )14}, 
     {          (int const   )16,          (int const   )14}}, 
   { {          (int const   )6,          (int const   )4}, 
     {          (int const   )6,          (int const   )14}, 
     {          (int const   )11,          (int const   )16}, 
     {          (int const   )30,          (int const   )2}}, 
   { {          (int const   )8,          (int const   )4}, 
     {          (int const   )8,          (int const   )13}, 
     {          (int const   )7,          (int const   )22}, 
     {          (int const   )22,          (int const   )13}}, 
   { {          (int const   )10,          (int const   )2}, 
     {          (int const   )19,          (int const   )4}, 
     {          (int const   )28,          (int const   )6}, 
     {          (int const   )33,          (int const   )4}}, 
   { {          (int const   )8,          (int const   )4}, 
     {          (int const   )22,          (int const   )3}, 
     {          (int const   )8,          (int const   )26}, 
     {          (int const   )12,          (int const   )28}}, 
   { {          (int const   )3,          (int const   )10}, 
     {          (int const   )3,          (int const   )23}, 
     {          (int const   )4,          (int const   )31}, 
     {          (int const   )11,          (int const   )31}}, 
   { {          (int const   )7,          (int const   )7}, 
     {          (int const   )21,          (int const   )7}, 
     {          (int const   )1,          (int const   )37}, 
     {          (int const   )19,          (int const   )26}}, 
   { {          (int const   )5,          (int const   )10}, 
     {          (int const   )19,          (int const   )10}, 
     {          (int const   )15,          (int const   )25}, 
     {          (int const   )23,          (int const   )25}}, 
   { {          (int const   )13,          (int const   )3}, 
     {          (int const   )2,          (int const   )29}, 
     {          (int const   )42,          (int const   )1}, 
     {          (int const   )23,          (int const   )28}}, 
   { {          (int const   )17,          (int const   )0}, 
     {          (int const   )10,          (int const   )23}, 
     {          (int const   )10,          (int const   )35}, 
     {          (int const   )19,          (int const   )35}}, 
   { {          (int const   )17,          (int const   )1}, 
     {          (int const   )14,          (int const   )21}, 
     {          (int const   )29,          (int const   )19}, 
     {          (int const   )11,          (int const   )46}}, 
   { {          (int const   )13,          (int const   )6}, 
     {          (int const   )14,          (int const   )23}, 
     {          (int const   )44,          (int const   )7}, 
     {          (int const   )59,          (int const   )1}}, 
   { {          (int const   )12,          (int const   )7}, 
     {          (int const   )12,          (int const   )26}, 
     {          (int const   )39,          (int const   )14}, 
     {          (int const   )22,          (int const   )41}}, 
   { {          (int const   )6,          (int const   )14}, 
     {          (int const   )6,          (int const   )34}, 
     {          (int const   )46,          (int const   )10}, 
     {          (int const   )2,          (int const   )64}}, 
   { {          (int const   )17,          (int const   )4}, 
     {          (int const   )29,          (int const   )14}, 
     {          (int const   )49,          (int const   )10}, 
     {          (int const   )24,          (int const   )46}}, 
   { {          (int const   )4,          (int const   )18}, 
     {          (int const   )13,          (int const   )32}, 
     {          (int const   )48,          (int const   )14}, 
     {          (int const   )42,          (int const   )32}}, 
   { {          (int const   )20,          (int const   )4}, 
     {          (int const   )40,          (int const   )7}, 
     {          (int const   )43,          (int const   )22}, 
     {          (int const   )10,          (int const   )67}}, 
   { {          (int const   )19,          (int const   )6}, 
     {          (int const   )18,          (int const   )31}, 
     {          (int const   )34,          (int const   )34}, 
     {          (int const   )20,          (int const   )61}}};
void QRspec_getEccSpec(int version___0 , QRecLevel level___0 , int *spec ) 
{ 
  int b1 ;
  int b2 ;
  int data ;
  int ecc ;
  int tmp ;

  {
  b1 = (int )eccTable[version___0][level___0][0];
  b2 = (int )eccTable[version___0][level___0][1];
  data = QRspec_getDataLength(version___0, level___0);
  ecc = QRspec_getECCLength(version___0, level___0);
  if (b2 == 0) {
    *(spec + 0) = b1;
    *(spec + 1) = data / b1;
    *(spec + 2) = ecc / b1;
    tmp = 0;
    *(spec + 4) = tmp;
    *(spec + 3) = tmp;
  } else {
    *(spec + 0) = b1;
    *(spec + 1) = data / (b1 + b2);
    *(spec + 2) = ecc / (b1 + b2);
    *(spec + 3) = b2;
    *(spec + 4) = *(spec + 1) + 1;
  }
  return;
}
}
static int const   alignmentPattern[41][2]  = 
  { {        (int const   )0,        (int const   )0}, 
   {        (int const   )0,        (int const   )0}, 
   {        (int const   )18,        (int const   )0}, 
   {        (int const   )22,        (int const   )0}, 
   {        (int const   )26,        (int const   )0}, 
   {        (int const   )30,        (int const   )0}, 
   {        (int const   )34,        (int const   )0}, 
   {        (int const   )22,        (int const   )38}, 
   {        (int const   )24,        (int const   )42}, 
   {        (int const   )26,        (int const   )46}, 
   {        (int const   )28,        (int const   )50}, 
   {        (int const   )30,        (int const   )54}, 
   {        (int const   )32,        (int const   )58}, 
   {        (int const   )34,        (int const   )62}, 
   {        (int const   )26,        (int const   )46}, 
   {        (int const   )26,        (int const   )48}, 
   {        (int const   )26,        (int const   )50}, 
   {        (int const   )30,        (int const   )54}, 
   {        (int const   )30,        (int const   )56}, 
   {        (int const   )30,        (int const   )58}, 
   {        (int const   )34,        (int const   )62}, 
   {        (int const   )28,        (int const   )50}, 
   {        (int const   )26,        (int const   )50}, 
   {        (int const   )30,        (int const   )54}, 
   {        (int const   )28,        (int const   )54}, 
   {        (int const   )32,        (int const   )58}, 
   {        (int const   )30,        (int const   )58}, 
   {        (int const   )34,        (int const   )62}, 
   {        (int const   )26,        (int const   )50}, 
   {        (int const   )30,        (int const   )54}, 
   {        (int const   )26,        (int const   )52}, 
   {        (int const   )30,        (int const   )56}, 
   {        (int const   )34,        (int const   )60}, 
   {        (int const   )30,        (int const   )58}, 
   {        (int const   )34,        (int const   )62}, 
   {        (int const   )30,        (int const   )54}, 
   {        (int const   )24,        (int const   )50}, 
   {        (int const   )28,        (int const   )54}, 
   {        (int const   )32,        (int const   )58}, 
   {        (int const   )26,        (int const   )54}, 
   {        (int const   )30,        (int const   )58}};
static void QRspec_putAlignmentMarker(unsigned char *frame , int width , int ox ,
                                      int oy ) ;
static unsigned char const   finder[25]  = 
  {      (unsigned char const   )161,      (unsigned char const   )161,      (unsigned char const   )161,      (unsigned char const   )161, 
        (unsigned char const   )161,      (unsigned char const   )161,      (unsigned char const   )160,      (unsigned char const   )160, 
        (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )161,      (unsigned char const   )160, 
        (unsigned char const   )161,      (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )161, 
        (unsigned char const   )160,      (unsigned char const   )160,      (unsigned char const   )160,      (unsigned char const   )161, 
        (unsigned char const   )161,      (unsigned char const   )161,      (unsigned char const   )161,      (unsigned char const   )161, 
        (unsigned char const   )161};
static void QRspec_putAlignmentMarker(unsigned char *frame , int width , int ox ,
                                      int oy ) 
{ 
  int x ;
  int y ;
  unsigned char const   *s ;

  {
  frame += ((oy - 2) * width + ox) - 2;
  s = finder;
  y = 0;
  while (y < 5) {
    x = 0;
    while (x < 5) {
      *(frame + x) = (unsigned char )*(s + x);
      x ++;
    }
    frame += width;
    s += 5;
    y ++;
  }
  return;
}
}
static void QRspec_putAlignmentPattern(int version___0 , unsigned char *frame , int width ) 
{ 
  int d ;
  int w ;
  int x ;
  int y ;
  int cx ;
  int cy ;

  {
  if (version___0 < 2) {
    return;
  }
  d = (int )(alignmentPattern[version___0][1] - alignmentPattern[version___0][0]);
  if (d < 0) {
    w = 2;
  } else {
    w = (width - (int )alignmentPattern[version___0][0]) / d + 2;
  }
  if (w * w - 3 == 1) {
    x = (int )alignmentPattern[version___0][0];
    y = (int )alignmentPattern[version___0][0];
    QRspec_putAlignmentMarker(frame, width, x, y);
    return;
  }
  cx = (int )alignmentPattern[version___0][0];
  x = 1;
  while (x < w - 1) {
    QRspec_putAlignmentMarker(frame, width, 6, cx);
    QRspec_putAlignmentMarker(frame, width, cx, 6);
    cx += d;
    x ++;
  }
  cy = (int )alignmentPattern[version___0][0];
  y = 0;
  while (y < w - 1) {
    cx = (int )alignmentPattern[version___0][0];
    x = 0;
    while (x < w - 1) {
      QRspec_putAlignmentMarker(frame, width, cx, cy);
      cx += d;
      x ++;
    }
    cy += d;
    y ++;
  }
  return;
}
}
static unsigned int const   versionPattern[34]  = 
  {      (unsigned int const   )31892,      (unsigned int const   )34236,      (unsigned int const   )39577,      (unsigned int const   )42195, 
        (unsigned int const   )48118,      (unsigned int const   )51042,      (unsigned int const   )55367,      (unsigned int const   )58893, 
        (unsigned int const   )63784,      (unsigned int const   )68472,      (unsigned int const   )70749,      (unsigned int const   )76311, 
        (unsigned int const   )79154,      (unsigned int const   )84390,      (unsigned int const   )87683,      (unsigned int const   )92361, 
        (unsigned int const   )96236,      (unsigned int const   )102084,      (unsigned int const   )102881,      (unsigned int const   )110507, 
        (unsigned int const   )110734,      (unsigned int const   )117786,      (unsigned int const   )119615,      (unsigned int const   )126325, 
        (unsigned int const   )127568,      (unsigned int const   )133589,      (unsigned int const   )136944,      (unsigned int const   )141498, 
        (unsigned int const   )145311,      (unsigned int const   )150283,      (unsigned int const   )152622,      (unsigned int const   )158308, 
        (unsigned int const   )161089,      (unsigned int const   )167017};
unsigned int QRspec_getVersionPattern(int version___0 ) 
{ 


  {
  if (version___0 < 7) {
    return (0U);
  } else
  if (version___0 > 40) {
    return (0U);
  }
  return ((unsigned int )versionPattern[version___0 - 7]);
}
}
static unsigned int const   formatInfo[4][8]  = { {        (unsigned int const   )30660,        (unsigned int const   )29427,        (unsigned int const   )32170,        (unsigned int const   )30877, 
            (unsigned int const   )26159,        (unsigned int const   )25368,        (unsigned int const   )27713,        (unsigned int const   )26998}, 
   {        (unsigned int const   )21522,        (unsigned int const   )20773,        (unsigned int const   )24188,        (unsigned int const   )23371, 
            (unsigned int const   )17913,        (unsigned int const   )16590,        (unsigned int const   )20375,        (unsigned int const   )19104}, 
   {        (unsigned int const   )13663,        (unsigned int const   )12392,        (unsigned int const   )16177,        (unsigned int const   )14854, 
            (unsigned int const   )9396,        (unsigned int const   )8579,        (unsigned int const   )11994,        (unsigned int const   )11245}, 
   {        (unsigned int const   )5769,        (unsigned int const   )5054,        (unsigned int const   )7399,        (unsigned int const   )6608, 
            (unsigned int const   )1890,        (unsigned int const   )597,        (unsigned int const   )3340,        (unsigned int const   )2107}};
unsigned int QRspec_getFormatInfo(int mask , QRecLevel level___0 ) 
{ 


  {
  if (mask < 0) {
    return (0U);
  } else
  if (mask > 7) {
    return (0U);
  }
  return ((unsigned int )formatInfo[level___0][mask]);
}
}
static void putFinderPattern(unsigned char *frame , int width , int ox , int oy ) ;
static unsigned char const   finder___0[49]  = 
  {      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193};
static void putFinderPattern(unsigned char *frame , int width , int ox , int oy ) 
{ 
  int x ;
  int y ;
  unsigned char const   *s ;

  {
  frame += oy * width + ox;
  s = finder___0;
  y = 0;
  while (y < 7) {
    x = 0;
    while (x < 7) {
      *(frame + x) = (unsigned char )*(s + x);
      x ++;
    }
    frame += width;
    s += 7;
    y ++;
  }
  return;
}
}
static unsigned char *QRspec_createFrame(int version___0 ) 
{ 
  unsigned char *frame ;
  unsigned char *p ;
  unsigned char *q ;
  int width ;
  int x ;
  int y ;
  unsigned int verinfo ;
  unsigned int v ;
  void *tmp ;

  {
  width = (int )qrspecCapacity[version___0].width;
  tmp = malloc((size_t )(width * width));
  frame = (unsigned char *)tmp;
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  memset((void *)frame, 0, (size_t )(width * width));
  putFinderPattern(frame, width, 0, 0);
  putFinderPattern(frame, width, width - 7, 0);
  putFinderPattern(frame, width, 0, width - 7);
  p = frame;
  q = frame + width * (width - 7);
  y = 0;
  while (y < 7) {
    *(p + 7) = (unsigned char)192;
    *(p + (width - 8)) = (unsigned char)192;
    *(q + 7) = (unsigned char)192;
    p += width;
    q += width;
    y ++;
  }
  memset((void *)(frame + width * 7), 192, (size_t )8);
  memset((void *)((frame + width * 8) - 8), 192, (size_t )8);
  memset((void *)(frame + width * (width - 8)), 192, (size_t )8);
  memset((void *)(frame + width * 8), 132, (size_t )9);
  memset((void *)((frame + width * 9) - 8), 132, (size_t )8);
  p = frame + 8;
  y = 0;
  while (y < 8) {
    *p = (unsigned char)132;
    p += width;
    y ++;
  }
  p = (frame + width * (width - 7)) + 8;
  y = 0;
  while (y < 7) {
    *p = (unsigned char)132;
    p += width;
    y ++;
  }
  p = (frame + width * 6) + 8;
  q = (frame + width * 8) + 6;
  x = 1;
  while (x < width - 15) {
    *p = (unsigned char )(144 | (x & 1));
    *q = (unsigned char )(144 | (x & 1));
    p ++;
    q += width;
    x ++;
  }
  QRspec_putAlignmentPattern(version___0, frame, width);
  if (version___0 >= 7) {
    verinfo = QRspec_getVersionPattern(version___0);
    p = frame + width * (width - 11);
    v = verinfo;
    x = 0;
    while (x < 6) {
      y = 0;
      while (y < 3) {
        *(p + (width * y + x)) = (unsigned char )(136U | (v & 1U));
        v >>= 1;
        y ++;
      }
      x ++;
    }
    p = (frame + width) - 11;
    v = verinfo;
    y = 0;
    while (y < 6) {
      x = 0;
      while (x < 3) {
        *(p + x) = (unsigned char )(136U | (v & 1U));
        v >>= 1;
        x ++;
      }
      p += width;
      y ++;
    }
  }
  *(frame + (width * (width - 8) + 8)) = (unsigned char)129;
  return (frame);
}
}
unsigned char *QRspec_newFrame(int version___0 ) 
{ 
  unsigned char *tmp ;

  {
  if (version___0 < 1) {
    return ((unsigned char *)((void *)0));
  } else
  if (version___0 > 40) {
    return ((unsigned char *)((void *)0));
  }
  tmp = QRspec_createFrame(version___0);
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-Q_eY7zA1.i","-pthread")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
static pthread_mutex_t RSECC_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static int initialized  =    0;
static unsigned int const   proot  =    (unsigned int const   )285;
static unsigned char alpha[((1U << 8) - 1U) + 1U]  ;
static unsigned char aindex[((1U << 8) - 1U) + 1U]  ;
static unsigned char generator[29][31]  ;
static unsigned char generatorInitialized[29]  ;
static void RSECC_initLookupTable(void) 
{ 
  unsigned int i ;
  unsigned int b ;

  {
  alpha[(1U << 8) - 1U] = (unsigned char)0;
  aindex[0] = (unsigned char )((1U << 8) - 1U);
  b = 1U;
  i = 0U;
  while (i < (1U << 8) - 1U) {
    alpha[i] = (unsigned char )b;
    aindex[b] = (unsigned char )i;
    b <<= 1;
    if (b & (((1U << 8) - 1U) + 1U)) {
      b ^= (unsigned int )proot;
    }
    b &= (1U << 8) - 1U;
    i ++;
  }
  return;
}
}
static void RSECC_init(void) 
{ 


  {
  RSECC_initLookupTable();
  memset((void *)(generatorInitialized), 0, (size_t )29);
  initialized = 1;
  return;
}
}
static void generator_init(size_t length ) 
{ 
  size_t i ;
  size_t j ;
  int g[31] ;

  {
  g[0] = 1;
  i = (size_t )0;
  while (i < length) {
    g[i + 1UL] = 1;
    j = i;
    while (j > 0UL) {
      g[j] = g[j - 1UL] ^ (int )alpha[((size_t )aindex[g[j]] + i) % (unsigned long )((1U << 8) - 1U)];
      j --;
    }
    g[0] = (int )alpha[((size_t )aindex[g[0]] + i) % (unsigned long )((1U << 8) - 1U)];
    i ++;
  }
  i = (size_t )0;
  while (i <= length) {
    generator[length - 2UL][i] = aindex[g[i]];
    i ++;
  }
  generatorInitialized[length - 2UL] = (unsigned char)1;
  return;
}
}
int RSECC_encode(size_t data_length , size_t ecc_length , unsigned char const   *data ,
                 unsigned char *ecc ) 
{ 
  size_t i ;
  size_t j ;
  unsigned char feedback ;
  unsigned char *gen ;

  {
  pthread_mutex_lock(& RSECC_mutex);
  if (! initialized) {
    RSECC_init();
  }
  pthread_mutex_unlock(& RSECC_mutex);
  if (ecc_length > 30UL) {
    return (-1);
  }
  memset((void *)ecc, 0, ecc_length);
  pthread_mutex_lock(& RSECC_mutex);
  if (! generatorInitialized[ecc_length - 2UL]) {
    generator_init(ecc_length);
  }
  pthread_mutex_unlock(& RSECC_mutex);
  gen = generator[ecc_length - 2UL];
  i = (size_t )0;
  while (i < data_length) {
    feedback = aindex[(int const   )*(data + i) ^ (int const   )*(ecc + 0)];
    if ((unsigned int )feedback != (1U << 8) - 1U) {
      j = (size_t )1;
      while (j < ecc_length) {
        *(ecc + j) = (unsigned char )((int )*(ecc + j) ^ (int )alpha[(unsigned int )((int )feedback + (int )*(gen + (ecc_length - j))) % ((1U << 8) - 1U)]);
        j ++;
      }
    }
    memmove((void *)(ecc + 0), (void const   *)(ecc + 1), ecc_length - 1UL);
    if ((unsigned int )feedback != (1U << 8) - 1U) {
      *(ecc + (ecc_length - 1UL)) = alpha[(unsigned int )((int )feedback + (int )*(gen + 0)) % ((1U << 8) - 1U)];
    } else {
      *(ecc + (ecc_length - 1UL)) = (unsigned char)0;
    }
    i ++;
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-swkK9Yw7.i","-pthread")
static QRencodeMode Split_identifyMode(char const   *string , QRencodeMode hint___0 ) 
{ 
  unsigned char c ;
  unsigned char d ;
  unsigned int word ;
  int tmp ;

  {
  c = (unsigned char )*(string + 0);
  if ((int )c == 0) {
    return ((QRencodeMode )-1);
  }
  if ((int )((unsigned char )((int )((signed char )c) - 48)) < 10) {
    return ((QRencodeMode )0);
  } else {
    if ((int )c & 128) {
      tmp = -1;
    } else {
      tmp = (int )QRinput_anTable[(int )c];
    }
    if (tmp >= 0) {
      return ((QRencodeMode )1);
    } else
    if ((int )hint___0 == 3) {
      d = (unsigned char )*(string + 1);
      if ((int )d != 0) {
        word = ((unsigned int )c << 8) | (unsigned int )d;
        if (word >= 33088U) {
          if (word <= 40956U) {
            return ((QRencodeMode )3);
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (word >= 57408U) {
          if (word <= 60351U) {
            return ((QRencodeMode )3);
          }
        }
      }
    }
  }
  return ((QRencodeMode )2);
}
}
static int Split_eatAn(char const   *string , QRinput *input , QRencodeMode hint___0 ) ;
static int Split_eat8(char const   *string , QRinput *input , QRencodeMode hint___0 ) ;
static int Split_eatNum(char const   *string , QRinput *input , QRencodeMode hint___0 ) 
{ 
  char const   *p ;
  int ret ;
  int run ;
  int dif ;
  int ln ;
  QRencodeMode mode ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  ln = QRspec_lengthIndicator((QRencodeMode )0, input->version);
  p = string;
  while ((int )((unsigned char )((int )((signed char )*p) - 48)) < 10) {
    p ++;
  }
  run = (int )(p - string);
  mode = Split_identifyMode(p, hint___0);
  if ((int )mode == 2) {
    tmp = QRinput_estimateBitsModeNum(run);
    tmp___0 = QRinput_estimateBitsMode8(1);
    tmp___1 = QRinput_estimateBitsMode8(run + 1);
    dif = (((tmp + 4) + ln) + tmp___0) - tmp___1;
    if (dif > 0) {
      tmp___2 = Split_eat8(string, input, hint___0);
      return (tmp___2);
    }
  }
  if ((int )mode == 1) {
    tmp___3 = QRinput_estimateBitsModeNum(run);
    tmp___4 = QRinput_estimateBitsModeAn(1);
    tmp___5 = QRinput_estimateBitsModeAn(run + 1);
    dif = (((tmp___3 + 4) + ln) + tmp___4) - tmp___5;
    if (dif > 0) {
      tmp___6 = Split_eatAn(string, input, hint___0);
      return (tmp___6);
    }
  }
  ret = QRinput_append(input, (QRencodeMode )0, run, (unsigned char const   *)((unsigned char *)string));
  if (ret < 0) {
    return (-1);
  }
  return (run);
}
}
static int Split_eatAn(char const   *string , QRinput *input , QRencodeMode hint___0 ) 
{ 
  char const   *p ;
  char const   *q ;
  int ret ;
  int run ;
  int dif ;
  int la ;
  int ln ;
  int tmp ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  la = QRspec_lengthIndicator((QRencodeMode )1, input->version);
  ln = QRspec_lengthIndicator((QRencodeMode )0, input->version);
  p = string;
  while (1) {
    if ((int const   )*p & 128) {
      tmp___5 = -1;
    } else {
      tmp___5 = (int )QRinput_anTable[(int )*p];
    }
    if (! (tmp___5 >= 0)) {
      break;
    }
    if ((int )((unsigned char )((int )((signed char )*p) - 48)) < 10) {
      q = p;
      while ((int )((unsigned char )((int )((signed char )*q) - 48)) < 10) {
        q ++;
      }
      tmp = QRinput_estimateBitsModeAn((int )(p - string));
      tmp___0 = QRinput_estimateBitsModeNum((int )(q - p));
      if ((int const   )*q & 128) {
        tmp___3 = -1;
      } else {
        tmp___3 = (int )QRinput_anTable[(int )*q];
      }
      if (tmp___3 >= 0) {
        tmp___2 = 4 + ln;
      } else {
        tmp___2 = 0;
      }
      tmp___4 = QRinput_estimateBitsModeAn((int )(q - string));
      dif = ((((tmp + tmp___0) + 4) + ln) + tmp___2) - tmp___4;
      if (dif < 0) {
        break;
      }
      p = q;
    } else {
      p ++;
    }
  }
  run = (int )(p - string);
  if (*p) {
    if ((int const   )*p & 128) {
      tmp___10 = -1;
    } else {
      tmp___10 = (int )QRinput_anTable[(int )*p];
    }
    if (! (tmp___10 >= 0)) {
      tmp___6 = QRinput_estimateBitsModeAn(run);
      tmp___7 = QRinput_estimateBitsMode8(1);
      tmp___8 = QRinput_estimateBitsMode8(run + 1);
      dif = (((tmp___6 + 4) + la) + tmp___7) - tmp___8;
      if (dif > 0) {
        tmp___9 = Split_eat8(string, input, hint___0);
        return (tmp___9);
      }
    }
  }
  ret = QRinput_append(input, (QRencodeMode )1, run, (unsigned char const   *)((unsigned char *)string));
  if (ret < 0) {
    return (-1);
  }
  return (run);
}
}
static int Split_eatKanji(char const   *string , QRinput *input , QRencodeMode hint___0 ) 
{ 
  char const   *p ;
  int ret ;
  int run ;
  QRencodeMode tmp ;

  {
  p = string;
  while (1) {
    tmp = Split_identifyMode(p, hint___0);
    if (! ((int )tmp == 3)) {
      break;
    }
    p += 2;
  }
  run = (int )(p - string);
  ret = QRinput_append(input, (QRencodeMode )3, run, (unsigned char const   *)((unsigned char *)string));
  if (ret < 0) {
    return (-1);
  }
  return (run);
}
}
static int Split_eat8(char const   *string , QRinput *input , QRencodeMode hint___0 ) 
{ 
  char const   *p ;
  char const   *q ;
  QRencodeMode mode ;
  int ret ;
  int run ;
  int dif ;
  int la ;
  int ln ;
  int l8 ;
  int swcost ;
  QRencodeMode tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  QRencodeMode tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  la = QRspec_lengthIndicator((QRencodeMode )1, input->version);
  ln = QRspec_lengthIndicator((QRencodeMode )0, input->version);
  l8 = QRspec_lengthIndicator((QRencodeMode )2, input->version);
  p = string + 1;
  while ((int const   )*p != 0) {
    mode = Split_identifyMode(p, hint___0);
    if ((int )mode == 3) {
      break;
    }
    if ((int )mode == 0) {
      q = p;
      while ((int )((unsigned char )((int )((signed char )*q) - 48)) < 10) {
        q ++;
      }
      tmp = Split_identifyMode(q, hint___0);
      if ((int )tmp == 2) {
        swcost = 4 + l8;
      } else {
        swcost = 0;
      }
      tmp___0 = QRinput_estimateBitsMode8((int )(p - string));
      tmp___1 = QRinput_estimateBitsModeNum((int )(q - p));
      tmp___2 = QRinput_estimateBitsMode8((int )(q - string));
      dif = ((((tmp___0 + tmp___1) + 4) + ln) + swcost) - tmp___2;
      if (dif < 0) {
        break;
      }
      p = q;
    } else
    if ((int )mode == 1) {
      q = p;
      while (1) {
        if ((int const   )*q & 128) {
          tmp___3 = -1;
        } else {
          tmp___3 = (int )QRinput_anTable[(int )*q];
        }
        if (! (tmp___3 >= 0)) {
          break;
        }
        q ++;
      }
      tmp___4 = Split_identifyMode(q, hint___0);
      if ((int )tmp___4 == 2) {
        swcost = 4 + l8;
      } else {
        swcost = 0;
      }
      tmp___5 = QRinput_estimateBitsMode8((int )(p - string));
      tmp___6 = QRinput_estimateBitsModeAn((int )(q - p));
      tmp___7 = QRinput_estimateBitsMode8((int )(q - string));
      dif = ((((tmp___5 + tmp___6) + 4) + la) + swcost) - tmp___7;
      if (dif < 0) {
        break;
      }
      p = q;
    } else {
      p ++;
    }
  }
  run = (int )(p - string);
  ret = QRinput_append(input, (QRencodeMode )2, run, (unsigned char const   *)((unsigned char *)string));
  if (ret < 0) {
    return (-1);
  }
  return (run);
}
}
static int Split_splitString(char const   *string , QRinput *input , QRencodeMode hint___0 ) 
{ 
  int length ;
  QRencodeMode mode ;

  {
  while ((int const   )*string != 0) {
    mode = Split_identifyMode(string, hint___0);
    if ((int )mode == 0) {
      length = Split_eatNum(string, input, hint___0);
    } else
    if ((int )mode == 1) {
      length = Split_eatAn(string, input, hint___0);
    } else
    if ((int )mode == 3) {
      if ((int )hint___0 == 3) {
        length = Split_eatKanji(string, input, hint___0);
      } else {
        length = Split_eat8(string, input, hint___0);
      }
    } else {
      length = Split_eat8(string, input, hint___0);
    }
    if (length == 0) {
      break;
    }
    if (length < 0) {
      return (-1);
    }
    string += length;
  }
  return (0);
}
}
static char *dupAndToUpper(char const   *str , QRencodeMode hint___0 ) 
{ 
  char *newstr ;
  char *p ;
  QRencodeMode mode ;

  {
  newstr = strdup(str);
  if ((unsigned long )newstr == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  p = newstr;
  while ((int )*p != 0) {
    mode = Split_identifyMode((char const   *)p, hint___0);
    if ((int )mode == 3) {
      p += 2;
    } else {
      if ((int )*p >= 97) {
        if ((int )*p <= 122) {
          *p = (char )((int )*p - 32);
        }
      }
      p ++;
    }
  }
  return (newstr);
}
}
int Split_splitStringToQRinput(char const   *string , QRinput *input , QRencodeMode hint___0 ,
                               int casesensitive___0 ) 
{ 
  char *newstr ;
  int ret ;
  int *tmp ;

  {
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  } else
  if ((int const   )*string == 0) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  if (! casesensitive___0) {
    newstr = dupAndToUpper(string, hint___0);
    if ((unsigned long )newstr == (unsigned long )((void *)0)) {
      return (-1);
    }
    ret = Split_splitString((char const   *)newstr, input, hint___0);
    free((void *)newstr);
  } else {
    ret = Split_splitString(string, input, hint___0);
  }
  return (ret);
}
}
#pragma merger("0","/tmp/cil-6f3pD_g5.i","-pthread")
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
static int Mask_writeFormatInformation(int width , unsigned char *frame , int mask ,
                                       QRecLevel level___0 ) 
{ 
  unsigned int format ;
  unsigned char v ;
  int i ;
  int blacks ;

  {
  blacks = 0;
  format = QRspec_getFormatInfo(mask, level___0);
  i = 0;
  while (i < 8) {
    if (format & 1U) {
      blacks += 2;
      v = (unsigned char)133;
    } else {
      v = (unsigned char)132;
    }
    *(frame + (((width * 8 + width) - 1) - i)) = v;
    if (i < 6) {
      *(frame + (width * i + 8)) = v;
    } else {
      *(frame + (width * (i + 1) + 8)) = v;
    }
    format >>= 1;
    i ++;
  }
  i = 0;
  while (i < 7) {
    if (format & 1U) {
      blacks += 2;
      v = (unsigned char)133;
    } else {
      v = (unsigned char)132;
    }
    *(frame + (width * ((width - 7) + i) + 8)) = v;
    if (i == 0) {
      *(frame + (width * 8 + 7)) = v;
    } else {
      *(frame + ((width * 8 + 6) - i)) = v;
    }
    format >>= 1;
    i ++;
  }
  return (blacks);
}
}
static int Mask_mask0(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )(((x + y) & 1) == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static int Mask_mask1(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )((y & 1) == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static int Mask_mask2(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )(x % 3 == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static int Mask_mask3(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )((x + y) % 3 == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static int Mask_mask4(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )(((y / 2 + x / 3) & 1) == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static int Mask_mask5(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )((x * y & 1) + (x * y) % 3 == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static int Mask_mask6(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )((((x * y & 1) + (x * y) % 3) & 1) == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static int Mask_mask7(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )((((x * y) % 3 + ((x + y) & 1)) & 1) == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static MaskMaker *maskMakers[8]  = 
  {      & Mask_mask0,      & Mask_mask1,      & Mask_mask2,      & Mask_mask3, 
        & Mask_mask4,      & Mask_mask5,      & Mask_mask6,      & Mask_mask7};
unsigned char *Mask_makeMask(int width , unsigned char *frame , int mask , QRecLevel level___0 ) 
{ 
  unsigned char *masked ;
  int *tmp ;
  void *tmp___0 ;

  {
  if (mask < 0) {
    tmp = __errno_location();
    *tmp = 22;
    return ((unsigned char *)((void *)0));
  } else
  if (mask >= 8) {
    tmp = __errno_location();
    *tmp = 22;
    return ((unsigned char *)((void *)0));
  }
  tmp___0 = malloc((size_t )(width * width));
  masked = (unsigned char *)tmp___0;
  if ((unsigned long )masked == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  (*(maskMakers[mask]))(width, (unsigned char const   *)frame, masked);
  Mask_writeFormatInformation(width, masked, mask, level___0);
  return (masked);
}
}
static int Mask_calcN1N3(int length , int *runLength ) 
{ 
  int i ;
  int demerit ;
  int fact ;

  {
  demerit = 0;
  i = 0;
  while (i < length) {
    if (*(runLength + i) >= 5) {
      demerit += 3 + (*(runLength + i) - 5);
    }
    if (i & 1) {
      if (i >= 3) {
        if (i < length - 2) {
          if (*(runLength + i) % 3 == 0) {
            fact = *(runLength + i) / 3;
            if (*(runLength + (i - 2)) == fact) {
              if (*(runLength + (i - 1)) == fact) {
                if (*(runLength + (i + 1)) == fact) {
                  if (*(runLength + (i + 2)) == fact) {
                    if (i == 3) {
                      demerit += 40;
                    } else
                    if (*(runLength + (i - 3)) >= 4 * fact) {
                      demerit += 40;
                    } else
                    if (i + 4 >= length) {
                      demerit += 40;
                    } else
                    if (*(runLength + (i + 3)) >= 4 * fact) {
                      demerit += 40;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    i ++;
  }
  return (demerit);
}
}
static int Mask_calcN2(int width , unsigned char *frame ) 
{ 
  int x ;
  int y ;
  unsigned char *p ;
  unsigned char b22 ;
  unsigned char w22 ;
  int demerit ;

  {
  demerit = 0;
  p = (frame + width) + 1;
  y = 1;
  while (y < width) {
    x = 1;
    while (x < width) {
      b22 = (unsigned char )((((int )*(p + 0) & (int )*(p + -1)) & (int )*(p + - width)) & (int )*(p + (- width - 1)));
      w22 = (unsigned char )((((int )*(p + 0) | (int )*(p + -1)) | (int )*(p + - width)) | (int )*(p + (- width - 1)));
      if (((int )b22 | ((int )w22 ^ 1)) & 1) {
        demerit += 3;
      }
      p ++;
      x ++;
    }
    p ++;
    y ++;
  }
  return (demerit);
}
}
static int Mask_calcRunLengthH(int width , unsigned char *frame , int *runLength ) 
{ 
  int head ;
  int i ;
  unsigned char prev ;

  {
  if ((int )*(frame + 0) & 1) {
    *(runLength + 0) = -1;
    head = 1;
  } else {
    head = 0;
  }
  *(runLength + head) = 1;
  prev = *(frame + 0);
  i = 1;
  while (i < width) {
    if (((int )*(frame + i) ^ (int )prev) & 1) {
      head ++;
      *(runLength + head) = 1;
      prev = *(frame + i);
    } else {
      (*(runLength + head)) ++;
    }
    i ++;
  }
  return (head + 1);
}
}
static int Mask_calcRunLengthV(int width , unsigned char *frame , int *runLength ) 
{ 
  int head ;
  int i ;
  unsigned char prev ;

  {
  if ((int )*(frame + 0) & 1) {
    *(runLength + 0) = -1;
    head = 1;
  } else {
    head = 0;
  }
  *(runLength + head) = 1;
  prev = *(frame + 0);
  i = 1;
  while (i < width) {
    if (((int )*(frame + i * width) ^ (int )prev) & 1) {
      head ++;
      *(runLength + head) = 1;
      prev = *(frame + i * width);
    } else {
      (*(runLength + head)) ++;
    }
    i ++;
  }
  return (head + 1);
}
}
static int Mask_evaluateSymbol(int width , unsigned char *frame ) 
{ 
  int x ;
  int y ;
  int demerit ;
  int runLength[178] ;
  int length ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  demerit = 0;
  tmp = Mask_calcN2(width, frame);
  demerit += tmp;
  y = 0;
  while (y < width) {
    length = Mask_calcRunLengthH(width, frame + y * width, runLength);
    tmp___0 = Mask_calcN1N3(length, runLength);
    demerit += tmp___0;
    y ++;
  }
  x = 0;
  while (x < width) {
    length = Mask_calcRunLengthV(width, frame + x, runLength);
    tmp___1 = Mask_calcN1N3(length, runLength);
    demerit += tmp___1;
    x ++;
  }
  return (demerit);
}
}
unsigned char *Mask_mask(int width , unsigned char *frame , QRecLevel level___0 ) 
{ 
  int i ;
  unsigned char *mask ;
  unsigned char *bestMask ;
  int minDemerit ;
  int blacks ;
  int bratio ;
  int demerit ;
  int w2 ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  minDemerit = 2147483647;
  w2 = width * width;
  tmp = malloc((size_t )w2);
  mask = (unsigned char *)tmp;
  if ((unsigned long )mask == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  tmp___0 = malloc((size_t )w2);
  bestMask = (unsigned char *)tmp___0;
  if ((unsigned long )bestMask == (unsigned long )((void *)0)) {
    free((void *)mask);
    return ((unsigned char *)((void *)0));
  }
  i = 0;
  while (i < 8) {
    demerit = 0;
    blacks = (*(maskMakers[i]))(width, (unsigned char const   *)frame, mask);
    tmp___1 = Mask_writeFormatInformation(width, mask, i, level___0);
    blacks += tmp___1;
    bratio = ((200 * blacks + w2) / w2) / 2;
    tmp___2 = abs(bratio - 50);
    demerit = (tmp___2 / 5) * 10;
    tmp___3 = Mask_evaluateSymbol(width, mask);
    demerit += tmp___3;
    if (demerit < minDemerit) {
      minDemerit = demerit;
      memcpy((void * __restrict  )bestMask, (void const   * __restrict  )mask, (size_t )w2);
    }
    i ++;
  }
  free((void *)mask);
  return (bestMask);
}
}
#pragma merger("0","/tmp/cil-hTS__pqm.i","-pthread")
unsigned int MQRspec_getFormatInfo(int mask , int version___0 , QRecLevel level___0 ) ;
static MQRspec_Capacity const   mqrspecCapacity[5]  = {      {0, {0, 0, 0, 0}}, 
        {11, {2, 0, 0, 0}}, 
        {13, {5, 6, 0, 0}}, 
        {15, {6, 8, 0, 0}}, 
        {17, {8, 10, 14, 0}}};
int MQRspec_getDataLengthBit(int version___0 , QRecLevel level___0 ) 
{ 
  int w ;
  int ecc ;

  {
  w = (int )(mqrspecCapacity[version___0].width - 1);
  ecc = mqrspecCapacity[version___0].ec[level___0];
  if (ecc == 0) {
    return (0);
  }
  return ((w * w - 64) - ecc * 8);
}
}
int MQRspec_getDataLength(int version___0 , QRecLevel level___0 ) 
{ 
  int tmp ;

  {
  tmp = MQRspec_getDataLengthBit(version___0, level___0);
  return ((tmp + 4) / 8);
}
}
int MQRspec_getECCLength(int version___0 , QRecLevel level___0 ) 
{ 


  {
  return (mqrspecCapacity[version___0].ec[level___0]);
}
}
int MQRspec_getWidth(int version___0 ) 
{ 


  {
  return ((int )mqrspecCapacity[version___0].width);
}
}
static int const   lengthTableBits___0[4][4]  = { {        (int const   )3,        (int const   )4,        (int const   )5,        (int const   )6}, 
   {        (int const   )0,        (int const   )3,        (int const   )4,        (int const   )5}, 
   {        (int const   )0,        (int const   )0,        (int const   )4,        (int const   )5}, 
   {        (int const   )0,        (int const   )0,        (int const   )3,        (int const   )4}};
int MQRspec_lengthIndicator(QRencodeMode mode , int version___0 ) 
{ 


  {
  return ((int )lengthTableBits___0[mode][version___0 - 1]);
}
}
int MQRspec_maximumWords(QRencodeMode mode , int version___0 ) 
{ 
  int bits ;
  int words ;

  {
  bits = (int )lengthTableBits___0[mode][version___0 - 1];
  words = (1 << bits) - 1;
  if ((int )mode == 3) {
    words *= 2;
  }
  return (words);
}
}
static unsigned int const   formatInfo___0[4][8]  = { {        (unsigned int const   )17477,        (unsigned int const   )21934,        (unsigned int const   )26515,        (unsigned int const   )30328, 
            (unsigned int const   )1758,        (unsigned int const   )5941,        (unsigned int const   )9480,        (unsigned int const   )13539}, 
   {        (unsigned int const   )16754,        (unsigned int const   )20633,        (unsigned int const   )25252,        (unsigned int const   )29519, 
            (unsigned int const   )1001,        (unsigned int const   )4610,        (unsigned int const   )8255,        (unsigned int const   )12756}, 
   {        (unsigned int const   )20011,        (unsigned int const   )24512,        (unsigned int const   )28157,        (unsigned int const   )31766, 
            (unsigned int const   )3248,        (unsigned int const   )7515,        (unsigned int const   )12134,        (unsigned int const   )16013}, 
   {        (unsigned int const   )19228,        (unsigned int const   )23287,        (unsigned int const   )26826,        (unsigned int const   )31009, 
            (unsigned int const   )2439,        (unsigned int const   )6252,        (unsigned int const   )10833,        (unsigned int const   )15290}};
static int const   typeTable[5][3]  = { {        (int const   )-1,        (int const   )-1,        (int const   )-1}, 
   {        (int const   )0,        (int const   )-1,        (int const   )-1}, 
   {        (int const   )1,        (int const   )2,        (int const   )-1}, 
   {        (int const   )3,        (int const   )4,        (int const   )-1}, 
   {        (int const   )5,        (int const   )6,        (int const   )7}};
unsigned int MQRspec_getFormatInfo(int mask , int version___0 , QRecLevel level___0 ) 
{ 
  int type ;

  {
  if (mask < 0) {
    return (0U);
  } else
  if (mask > 3) {
    return (0U);
  }
  if (version___0 <= 0) {
    return (0U);
  } else
  if (version___0 > 4) {
    return (0U);
  }
  if ((unsigned int )level___0 == 3U) {
    return (0U);
  }
  type = (int )typeTable[version___0][level___0];
  if (type < 0) {
    return (0U);
  }
  return ((unsigned int )formatInfo___0[mask][type]);
}
}
static void putFinderPattern___0(unsigned char *frame , int width , int ox , int oy ) ;
static unsigned char const   finder___1[49]  = 
  {      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193};
static void putFinderPattern___0(unsigned char *frame , int width , int ox , int oy ) 
{ 
  int x ;
  int y ;
  unsigned char const   *s ;

  {
  frame += oy * width + ox;
  s = finder___1;
  y = 0;
  while (y < 7) {
    x = 0;
    while (x < 7) {
      *(frame + x) = (unsigned char )*(s + x);
      x ++;
    }
    frame += width;
    s += 7;
    y ++;
  }
  return;
}
}
static unsigned char *MQRspec_createFrame(int version___0 ) 
{ 
  unsigned char *frame ;
  unsigned char *p ;
  unsigned char *q ;
  int width ;
  int x ;
  int y ;
  void *tmp ;

  {
  width = (int )mqrspecCapacity[version___0].width;
  tmp = malloc((size_t )(width * width));
  frame = (unsigned char *)tmp;
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  memset((void *)frame, 0, (size_t )(width * width));
  putFinderPattern___0(frame, width, 0, 0);
  p = frame;
  y = 0;
  while (y < 7) {
    *(p + 7) = (unsigned char)192;
    p += width;
    y ++;
  }
  memset((void *)(frame + width * 7), 192, (size_t )8);
  memset((void *)((frame + width * 8) + 1), 132, (size_t )8);
  p = (frame + width) + 8;
  y = 0;
  while (y < 7) {
    *p = (unsigned char)132;
    p += width;
    y ++;
  }
  p = frame + 8;
  q = frame + width * 8;
  x = 1;
  while (x < width - 7) {
    *p = (unsigned char )(144 | (x & 1));
    *q = (unsigned char )(144 | (x & 1));
    p ++;
    q += width;
    x ++;
  }
  return (frame);
}
}
unsigned char *MQRspec_newFrame(int version___0 ) 
{ 
  unsigned char *tmp ;

  {
  if (version___0 < 1) {
    return ((unsigned char *)((void *)0));
  } else
  if (version___0 > 4) {
    return ((unsigned char *)((void *)0));
  }
  tmp = MQRspec_createFrame(version___0);
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-R2jdVhFP.i","-pthread")
static void MMask_writeFormatInformation(int version___0 , int width , unsigned char *frame ,
                                         int mask , QRecLevel level___0 ) 
{ 
  unsigned int format ;
  unsigned char v ;
  int i ;

  {
  format = MQRspec_getFormatInfo(mask, version___0, level___0);
  i = 0;
  while (i < 8) {
    v = (unsigned char )(132U | (format & 1U));
    *(frame + (width * (i + 1) + 8)) = v;
    format >>= 1;
    i ++;
  }
  i = 0;
  while (i < 7) {
    v = (unsigned char )(132U | (format & 1U));
    *(frame + ((width * 8 + 7) - i)) = v;
    format >>= 1;
    i ++;
  }
  return;
}
}
static void Mask_mask0___0(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;

  {
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )((y & 1) == 0));
      }
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return;
}
}
static void Mask_mask1___0(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;

  {
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )(((y / 2 + x / 3) & 1) == 0));
      }
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return;
}
}
static void Mask_mask2___0(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;

  {
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )((((x * y & 1) + (x * y) % 3) & 1) == 0));
      }
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return;
}
}
static void Mask_mask3___0(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;

  {
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )(((((x + y) & 1) + (x * y) % 3) & 1) == 0));
      }
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return;
}
}
static MaskMaker___0 *maskMakers___0[4]  = {      & Mask_mask0___0,      & Mask_mask1___0,      & Mask_mask2___0,      & Mask_mask3___0};
unsigned char *MMask_makeMask(int version___0 , unsigned char *frame , int mask ,
                              QRecLevel level___0 ) 
{ 
  unsigned char *masked ;
  int width ;
  int *tmp ;
  void *tmp___0 ;

  {
  if (mask < 0) {
    tmp = __errno_location();
    *tmp = 22;
    return ((unsigned char *)((void *)0));
  } else
  if (mask >= 4) {
    tmp = __errno_location();
    *tmp = 22;
    return ((unsigned char *)((void *)0));
  }
  width = MQRspec_getWidth(version___0);
  tmp___0 = malloc((size_t )(width * width));
  masked = (unsigned char *)tmp___0;
  if ((unsigned long )masked == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  (*(maskMakers___0[mask]))(width, (unsigned char const   *)frame, masked);
  MMask_writeFormatInformation(version___0, width, masked, mask, level___0);
  return (masked);
}
}
static int MMask_evaluateSymbol(int width , unsigned char *frame ) 
{ 
  int x ;
  int y ;
  unsigned char *p ;
  int sum1 ;
  int sum2 ;
  int tmp ;

  {
  sum1 = 0;
  sum2 = 0;
  p = frame + width * (width - 1);
  x = 1;
  while (x < width) {
    sum1 += (int )*(p + x) & 1;
    x ++;
  }
  p = (frame + width * 2) - 1;
  y = 1;
  while (y < width) {
    sum2 += (int )*p & 1;
    p += width;
    y ++;
  }
  if (sum1 <= sum2) {
    tmp = sum1 * 16 + sum2;
  } else {
    tmp = sum2 * 16 + sum1;
  }
  return (tmp);
}
}
unsigned char *MMask_mask(int version___0 , unsigned char *frame , QRecLevel level___0 ) 
{ 
  int i ;
  unsigned char *mask ;
  unsigned char *bestMask ;
  int maxScore ;
  int score ;
  int width ;
  void *tmp ;
  void *tmp___0 ;

  {
  maxScore = 0;
  width = MQRspec_getWidth(version___0);
  tmp = malloc((size_t )(width * width));
  mask = (unsigned char *)tmp;
  if ((unsigned long )mask == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  bestMask = (unsigned char *)((void *)0);
  i = 0;
  while (i < 4) {
    score = 0;
    (*(maskMakers___0[i]))(width, (unsigned char const   *)frame, mask);
    MMask_writeFormatInformation(version___0, width, mask, i, level___0);
    score = MMask_evaluateSymbol(width, mask);
    if (score > maxScore) {
      maxScore = score;
      free((void *)bestMask);
      bestMask = mask;
      tmp___0 = malloc((size_t )(width * width));
      mask = (unsigned char *)tmp___0;
      if ((unsigned long )mask == (unsigned long )((void *)0)) {
        break;
      }
    }
    i ++;
  }
  free((void *)mask);
  return (bestMask);
}
}
