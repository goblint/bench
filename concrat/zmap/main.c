/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef int wchar_t;
typedef unsigned char __uint8_t;
typedef unsigned int __uint32_t;
typedef unsigned long __uint64_t;
typedef long __off_t;
typedef long __off64_t;
typedef __uint8_t uint8_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __builtin_va_list __gnuc_va_list;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef unsigned char u8;
typedef unsigned int u32;
struct aesrand ;
typedef struct aesrand aesrand_t;
struct aesrand {
   uint32_t input[4] ;
   uint32_t sched[44] ;
   uint8_t output[16] ;
};
typedef long __ssize_t;
typedef unsigned int __socklen_t;
struct cyclic_group {
   uint64_t prime ;
   uint64_t known_primroot ;
   size_t num_prime_factors ;
   uint64_t prime_factors[10] ;
};
typedef struct cyclic_group cyclic_group_t;
struct cycle {
   cyclic_group_t const   *group ;
   uint64_t generator ;
   uint64_t order ;
   uint32_t offset ;
};
typedef struct cycle cycle_t;
typedef __ssize_t ssize_t;
typedef unsigned long mp_limb_t;
typedef unsigned long mp_bitcnt_t;
struct __anonstruct___mpz_struct_688629798 {
   int _mp_alloc ;
   int _mp_size ;
   mp_limb_t *_mp_d ;
};
typedef struct __anonstruct___mpz_struct_688629798 __mpz_struct;
typedef __mpz_struct mpz_t[1];
typedef mp_limb_t *mp_ptr;
typedef mp_limb_t const   *mp_srcptr;
typedef long mp_size_t;
struct __anonstruct___mpq_struct_447598393 {
   __mpz_struct _mp_num ;
   __mpz_struct _mp_den ;
};
typedef struct __anonstruct___mpq_struct_447598393 __mpq_struct;
typedef __mpz_struct const   *mpz_srcptr;
typedef __mpz_struct *mpz_ptr;
typedef __mpq_struct const   *mpq_srcptr;
typedef __mpq_struct *mpq_ptr;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
struct field_def {
   char const   *name ;
   char const   *type ;
   char const   *desc ;
};
typedef struct field_def fielddef_t;
struct fielddef_set {
   fielddef_t fielddefs[128] ;
   int len ;
};
typedef struct fielddef_set fielddefset_t;
union field_val {
   void *ptr ;
   uint64_t num ;
};
typedef union field_val field_val_t;
struct field {
   char const   *name ;
   int type ;
   int free_ ;
   size_t len ;
   field_val_t value ;
};
typedef struct field field_t;
struct fieldset {
   int len ;
   field_t fields[128] ;
   fielddefset_t *fds ;
   int inner_type ;
   int type ;
   int free_ ;
};
typedef struct fieldset fieldset_t;
enum operation {
    GT = 0,
    LT = 1,
    EQ = 2,
    NEQ = 3,
    AND = 4,
    OR = 5,
    LT_EQ = 6,
    GT_EQ = 7
} ;
enum node_type {
    OP = 0,
    FIELD = 1,
    STRING = 2,
    INT = 3
} ;
struct field_id {
   int index ;
   char *fieldname ;
};
union node_value {
   struct field_id field ;
   char *string_literal ;
   uint64_t int_literal ;
   enum operation op ;
};
struct node_st {
   struct node_st *left_child ;
   struct node_st *right_child ;
   enum node_type type ;
   union node_value value ;
};
typedef struct node_st node_t;
struct translation {
   int len ;
   int translation[128] ;
};
typedef struct translation translation_t;
typedef unsigned short __uint16_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned int __gid_t;
typedef __uint16_t uint16_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef uint16_t port_h_t;
typedef unsigned char macaddr_t;
struct output_filter {
   node_t *expression ;
};
typedef uint32_t in_addr_t;
struct probe_module ;
struct output_module ;
struct fieldset_conf {
   fielddefset_t defs ;
   fielddefset_t outdefs ;
   translation_t translation ;
   int success_index ;
   int app_success_index ;
   int classification_index ;
};
struct state_conf {
   int log_level ;
   port_h_t target_port ;
   port_h_t source_port_first ;
   port_h_t source_port_last ;
   uint32_t max_targets ;
   uint32_t max_runtime ;
   uint32_t max_results ;
   char *iface ;
   int rate ;
   uint64_t bandwidth ;
   int cooldown_secs ;
   uint8_t senders ;
   uint8_t batch ;
   uint32_t pin_cores_len ;
   uint32_t *pin_cores ;
   int seed_provided ;
   uint64_t seed ;
   aesrand_t *aes ;
   uint32_t generator ;
   uint16_t shard_num ;
   uint16_t total_shards ;
   int packet_streams ;
   struct probe_module *probe_module ;
   char *output_module_name ;
   struct output_module *output_module ;
   char *probe_args ;
   uint8_t probe_ttl ;
   char *output_args ;
   macaddr_t gw_mac[6] ;
   macaddr_t hw_mac[6] ;
   uint32_t gw_ip ;
   int gw_mac_set ;
   int hw_mac_set ;
   in_addr_t source_ip_addresses[256] ;
   uint32_t number_source_ips ;
   int send_ip_pkts ;
   char *output_filename ;
   char *blocklist_filename ;
   char *allowlist_filename ;
   char *list_of_ips_filename ;
   uint32_t list_of_ips_count ;
   char *metadata_filename ;
   FILE *metadata_file ;
   char *notes ;
   char *custom_metadata_str ;
   char **destination_cidrs ;
   int destination_cidrs_len ;
   char const   *raw_output_fields ;
   char const   **output_fields ;
   struct output_filter filter ;
   char *output_filter_str ;
   struct fieldset_conf fsconf ;
   int output_fields_len ;
   char *log_file ;
   char *log_directory ;
   char *status_updates_file ;
   int dryrun ;
   int quiet ;
   int ignore_invalid_hosts ;
   int syslog ;
   int recv_ready ;
   int num_retries ;
   uint64_t total_allowed ;
   uint64_t total_disallowed ;
   int max_sendto_failures ;
   float min_hitrate ;
   int data_link_size ;
   int default_mode ;
   int no_header_row ;
};
typedef int __gwchar_t;
struct yy_buffer_state ;
typedef struct yy_buffer_state *YY_BUFFER_STATE;
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   int yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
typedef int __pid_t;
typedef char *__caddr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
typedef unsigned char __u8;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
union __anonunion_ifr_ifrn_352126815 {
   char ifrn_name[16] ;
};
union __anonunion_ifr_ifru_537349870 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
struct ifreq {
   union __anonunion_ifr_ifrn_352126815 ifr_ifrn ;
   union __anonunion_ifr_ifru_537349870 ifr_ifru ;
};
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
struct rtattr {
   unsigned short rta_len ;
   unsigned short rta_type ;
};
struct rtmsg {
   unsigned char rtm_family ;
   unsigned char rtm_dst_len ;
   unsigned char rtm_src_len ;
   unsigned char rtm_tos ;
   unsigned char rtm_table ;
   unsigned char rtm_protocol ;
   unsigned char rtm_scope ;
   unsigned char rtm_type ;
   unsigned int rtm_flags ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
struct shard_state {
   uint64_t packets_sent ;
   uint32_t hosts_scanned ;
   uint32_t max_hosts ;
   uint32_t max_packets ;
   uint32_t hosts_blocklisted ;
   uint32_t hosts_allowlisted ;
   uint32_t packets_failed ;
   uint32_t first_scanned ;
};
struct shard_params {
   uint64_t first ;
   uint64_t last ;
   uint64_t factor ;
   uint64_t modulus ;
};
struct shard {
   struct shard_state state ;
   struct shard_params params ;
   uint64_t current ;
   uint64_t iterations ;
   uint8_t thread_id ;
   void (*cb)(uint8_t id , void *arg ) ;
   void *arg ;
};
typedef struct shard shard_t;
struct iterator ;
typedef struct iterator iterator_t;
struct state_send {
   double start ;
   double finish ;
   uint64_t packets_sent ;
   uint64_t hosts_scanned ;
   uint64_t blocklisted ;
   uint64_t allowlisted ;
   int warmup ;
   int complete ;
   uint32_t first_scanned ;
   uint32_t max_targets ;
   uint32_t sendto_failures ;
   uint32_t max_index ;
   uint8_t **list_of_ips_pbm ;
};
struct iterator {
   cycle_t cycle ;
   uint8_t num_threads ;
   shard_t *thread_shards ;
   uint8_t *complete ;
   pthread_mutex_t mutex ;
   uint32_t curr_threads ;
};
typedef long __time_t;
typedef long __suseconds_t;
typedef __time_t time_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct state_recv {
   uint32_t success_total ;
   uint32_t success_unique ;
   uint32_t app_success_total ;
   uint32_t app_success_unique ;
   uint32_t cooldown_total ;
   uint32_t cooldown_unique ;
   uint32_t failure_total ;
   uint64_t filter_success ;
   uint32_t ip_fragments ;
   uint32_t validation_passed ;
   uint32_t validation_failed ;
   int complete ;
   double start ;
   double finish ;
   uint32_t pcap_recv ;
   uint32_t pcap_drop ;
   uint32_t pcap_ifdrop ;
};
struct internal_scan_status {
   double last_now ;
   uint64_t last_sent ;
   uint64_t last_tried_sent ;
   uint32_t last_send_failures ;
   uint32_t last_recv_net_success ;
   uint32_t last_recv_app_success ;
   uint32_t last_recv_total ;
   uint32_t last_pcap_drop ;
   double min_hitrate_start ;
};
typedef struct internal_scan_status int_status_t;
struct export_scan_status {
   uint64_t total_sent ;
   uint64_t total_tried_sent ;
   uint32_t recv_success_unique ;
   uint32_t app_recv_success_unique ;
   uint64_t total_recv ;
   uint32_t complete ;
   uint32_t send_threads ;
   double percent_complete ;
   double hitrate ;
   double app_hitrate ;
   double send_rate ;
   char send_rate_str[20] ;
   double send_rate_avg ;
   char send_rate_avg_str[20] ;
   double recv_rate ;
   char recv_rate_str[20] ;
   double recv_avg ;
   char recv_avg_str[20] ;
   double recv_total_rate ;
   double recv_total_avg ;
   double app_success_rate ;
   char app_success_rate_str[20] ;
   double app_success_avg ;
   char app_success_avg_str[20] ;
   uint32_t pcap_drop ;
   uint32_t pcap_ifdrop ;
   uint32_t pcap_drop_total ;
   char pcap_drop_total_str[20] ;
   double pcap_drop_last ;
   char pcap_drop_last_str[20] ;
   double pcap_drop_avg ;
   char pcap_drop_avg_str[20] ;
   uint32_t time_remaining ;
   char time_remaining_str[20] ;
   uint32_t time_past ;
   char time_past_str[20] ;
   uint32_t fail_total ;
   double fail_avg ;
   double fail_last ;
   float seconds_under_min_hitrate ;
};
typedef struct export_scan_status export_status_t;
typedef unsigned char __u_char;
typedef long __syscall_slong_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef __u_char u_char;
struct ip {
   unsigned int ip_hl : 4 ;
   unsigned int ip_v : 4 ;
   uint8_t ip_tos ;
   unsigned short ip_len ;
   unsigned short ip_id ;
   unsigned short ip_off ;
   uint8_t ip_ttl ;
   uint8_t ip_p ;
   unsigned short ip_sum ;
   struct in_addr ip_src ;
   struct in_addr ip_dst ;
};
struct ether_header {
   uint8_t ether_dhost[6] ;
   uint8_t ether_shost[6] ;
   uint16_t ether_type ;
} __attribute__((__packed__)) ;
typedef uint32_t ipaddr_n_t;
typedef uint16_t port_n_t;
struct probe_module {
   char const   *name ;
   size_t max_packet_length ;
   char const   *pcap_filter ;
   size_t pcap_snaplen ;
   uint8_t port_args ;
   int (*global_initialize)(struct state_conf * ) ;
   int (*thread_initialize)(void *packetbuf , macaddr_t *src_mac , macaddr_t *gw_mac ,
                            port_n_t src_port , void **arg_ptr ) ;
   int (*make_packet)(void *packetbuf , size_t *buf_len , ipaddr_n_t src_ip , ipaddr_n_t dst_ip ,
                      uint8_t ttl , uint32_t *validation , int probe_num , void *arg ) ;
   void (*print_packet)(FILE * , void *packetbuf ) ;
   int (*validate_packet)(struct ip  const  *ip_hdr , uint32_t len , uint32_t *src_ip ,
                          uint32_t *validation ) ;
   void (*process_packet)(u_char const   *packetbuf , uint32_t len , fieldset_t * ,
                          uint32_t *validation , struct timespec  const  ts ) ;
   int (*close)(struct state_conf * , struct state_send * , struct state_recv * ) ;
   int output_type ;
   fielddef_t *fields ;
   int numfields ;
   char const   *helptext ;
};
struct output_module {
   char const   *name ;
   int supports_dynamic_output ;
   unsigned int update_interval ;
   int (*init)(struct state_conf * , char const   **fields , int fieldslen ) ;
   int (*start)(struct state_conf * , struct state_send * , struct state_recv * ) ;
   int (*update)(struct state_conf * , struct state_send * , struct state_recv * ) ;
   int (*close)(struct state_conf * , struct state_send * , struct state_recv * ) ;
   int (*process_ip)(fieldset_t *fs ) ;
   char const   *helptext ;
};
struct __anonstruct_sock_t_1072026035 {
   int sock ;
};
typedef struct __anonstruct_sock_t_1072026035 sock_t;
typedef void (*__sighandler_t)(int  );
struct sockaddr_ll {
   unsigned short sll_family ;
   unsigned short sll_protocol ;
   int sll_ifindex ;
   unsigned short sll_hatype ;
   unsigned char sll_pkttype ;
   unsigned char sll_halen ;
   unsigned char sll_addr[8] ;
};
typedef int __int32_t;
typedef long __int64_t;
typedef unsigned int uint;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
struct bl_cidr_node {
   uint32_t ip_address ;
   int prefix_len ;
   struct bl_cidr_node *next ;
};
typedef struct bl_cidr_node bl_cidr_node_t;
struct json_object ;
typedef struct json_object json_object;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
struct obstack ;
struct sockaddr_at ;
struct sockaddr_ax25 ;
struct sockaddr_dl ;
struct sockaddr_eon ;
struct sockaddr_in6 ;
struct sockaddr_inarp ;
struct sockaddr_ipx ;
struct sockaddr_iso ;
struct sockaddr_ns ;
struct sockaddr_un ;
struct sockaddr_x25 ;
union __anonunion___SOCKADDR_ARG_627422263 {
   struct sockaddr * __restrict  __sockaddr__ ;
   struct sockaddr_at * __restrict  __sockaddr_at__ ;
   struct sockaddr_ax25 * __restrict  __sockaddr_ax25__ ;
   struct sockaddr_dl * __restrict  __sockaddr_dl__ ;
   struct sockaddr_eon * __restrict  __sockaddr_eon__ ;
   struct sockaddr_in * __restrict  __sockaddr_in__ ;
   struct sockaddr_in6 * __restrict  __sockaddr_in6__ ;
   struct sockaddr_inarp * __restrict  __sockaddr_inarp__ ;
   struct sockaddr_ipx * __restrict  __sockaddr_ipx__ ;
   struct sockaddr_iso * __restrict  __sockaddr_iso__ ;
   struct sockaddr_ns * __restrict  __sockaddr_ns__ ;
   struct sockaddr_un * __restrict  __sockaddr_un__ ;
   struct sockaddr_x25 * __restrict  __sockaddr_x25__ ;
};
typedef union __anonunion___SOCKADDR_ARG_627422263  __attribute__((__transparent_union__)) __SOCKADDR_ARG;
union __anonunion___in6_u_979734923 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion___in6_u_979734923 __in6_u ;
};
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
enum LogLevel {
    ZLOG_FATAL = 0,
    ZLOG_ERROR = 1,
    ZLOG_WARN = 2,
    ZLOG_INFO = 3,
    ZLOG_DEBUG = 4,
    ZLOG_TRACE = 5,
    ZNUM_LOGLEVELS = 6
} ;
struct gengetopt_args_info {
   int target_port_arg ;
   char *target_port_orig ;
   char const   *target_port_help ;
   char *output_file_arg ;
   char *output_file_orig ;
   char const   *output_file_help ;
   char *blocklist_file_arg ;
   char *blocklist_file_orig ;
   char const   *blocklist_file_help ;
   char *allowlist_file_arg ;
   char *allowlist_file_orig ;
   char const   *allowlist_file_help ;
   char *list_of_ips_file_arg ;
   char *list_of_ips_file_orig ;
   char const   *list_of_ips_file_help ;
   int rate_arg ;
   char *rate_orig ;
   char const   *rate_help ;
   char *bandwidth_arg ;
   char *bandwidth_orig ;
   char const   *bandwidth_help ;
   int batch_arg ;
   char *batch_orig ;
   char const   *batch_help ;
   char *max_targets_arg ;
   char *max_targets_orig ;
   char const   *max_targets_help ;
   int max_runtime_arg ;
   char *max_runtime_orig ;
   char const   *max_runtime_help ;
   int max_results_arg ;
   char *max_results_orig ;
   char const   *max_results_help ;
   int probes_arg ;
   char *probes_orig ;
   char const   *probes_help ;
   int cooldown_time_arg ;
   char *cooldown_time_orig ;
   char const   *cooldown_time_help ;
   long seed_arg ;
   char *seed_orig ;
   char const   *seed_help ;
   int retries_arg ;
   char *retries_orig ;
   char const   *retries_help ;
   char const   *dryrun_help ;
   int shards_arg ;
   char *shards_orig ;
   char const   *shards_help ;
   int shard_arg ;
   char *shard_orig ;
   char const   *shard_help ;
   char *source_port_arg ;
   char *source_port_orig ;
   char const   *source_port_help ;
   char *source_ip_arg ;
   char *source_ip_orig ;
   char const   *source_ip_help ;
   char *gateway_mac_arg ;
   char *gateway_mac_orig ;
   char const   *gateway_mac_help ;
   char *source_mac_arg ;
   char *source_mac_orig ;
   char const   *source_mac_help ;
   char *interface_arg ;
   char *interface_orig ;
   char const   *interface_help ;
   char const   *iplayer_help ;
   char *probe_module_arg ;
   char *probe_module_orig ;
   char const   *probe_module_help ;
   char *probe_args_arg ;
   char *probe_args_orig ;
   char const   *probe_args_help ;
   int probe_ttl_arg ;
   char *probe_ttl_orig ;
   char const   *probe_ttl_help ;
   char const   *list_probe_modules_help ;
   char *output_fields_arg ;
   char *output_fields_orig ;
   char const   *output_fields_help ;
   char *output_module_arg ;
   char *output_module_orig ;
   char const   *output_module_help ;
   char *output_args_arg ;
   char *output_args_orig ;
   char const   *output_args_help ;
   char *output_filter_arg ;
   char *output_filter_orig ;
   char const   *output_filter_help ;
   char const   *list_output_modules_help ;
   char const   *list_output_fields_help ;
   char const   *no_header_row_help ;
   int verbosity_arg ;
   char *verbosity_orig ;
   char const   *verbosity_help ;
   char *log_file_arg ;
   char *log_file_orig ;
   char const   *log_file_help ;
   char *log_directory_arg ;
   char *log_directory_orig ;
   char const   *log_directory_help ;
   char *metadata_file_arg ;
   char *metadata_file_orig ;
   char const   *metadata_file_help ;
   char *status_updates_file_arg ;
   char *status_updates_file_orig ;
   char const   *status_updates_file_help ;
   char const   *quiet_help ;
   char const   *disable_syslog_help ;
   char *notes_arg ;
   char *notes_orig ;
   char const   *notes_help ;
   char *user_metadata_arg ;
   char *user_metadata_orig ;
   char const   *user_metadata_help ;
   char *config_arg ;
   char *config_orig ;
   char const   *config_help ;
   int max_sendto_failures_arg ;
   char *max_sendto_failures_orig ;
   char const   *max_sendto_failures_help ;
   float min_hitrate_arg ;
   char *min_hitrate_orig ;
   char const   *min_hitrate_help ;
   int sender_threads_arg ;
   char *sender_threads_orig ;
   char const   *sender_threads_help ;
   char *cores_arg ;
   char *cores_orig ;
   char const   *cores_help ;
   char const   *ignore_blocklist_errors_help ;
   char const   *help_help ;
   char const   *version_help ;
   unsigned int target_port_given ;
   unsigned int output_file_given ;
   unsigned int blocklist_file_given ;
   unsigned int allowlist_file_given ;
   unsigned int list_of_ips_file_given ;
   unsigned int rate_given ;
   unsigned int bandwidth_given ;
   unsigned int batch_given ;
   unsigned int max_targets_given ;
   unsigned int max_runtime_given ;
   unsigned int max_results_given ;
   unsigned int probes_given ;
   unsigned int cooldown_time_given ;
   unsigned int seed_given ;
   unsigned int retries_given ;
   unsigned int dryrun_given ;
   unsigned int shards_given ;
   unsigned int shard_given ;
   unsigned int source_port_given ;
   unsigned int source_ip_given ;
   unsigned int gateway_mac_given ;
   unsigned int source_mac_given ;
   unsigned int interface_given ;
   unsigned int iplayer_given ;
   unsigned int probe_module_given ;
   unsigned int probe_args_given ;
   unsigned int probe_ttl_given ;
   unsigned int list_probe_modules_given ;
   unsigned int output_fields_given ;
   unsigned int output_module_given ;
   unsigned int output_args_given ;
   unsigned int output_filter_given ;
   unsigned int list_output_modules_given ;
   unsigned int list_output_fields_given ;
   unsigned int no_header_row_given ;
   unsigned int verbosity_given ;
   unsigned int log_file_given ;
   unsigned int log_directory_given ;
   unsigned int metadata_file_given ;
   unsigned int status_updates_file_given ;
   unsigned int quiet_given ;
   unsigned int disable_syslog_given ;
   unsigned int notes_given ;
   unsigned int user_metadata_given ;
   unsigned int config_given ;
   unsigned int max_sendto_failures_given ;
   unsigned int min_hitrate_given ;
   unsigned int sender_threads_given ;
   unsigned int cores_given ;
   unsigned int ignore_blocklist_errors_given ;
   unsigned int help_given ;
   unsigned int version_given ;
   char **inputs ;
   unsigned int inputs_num ;
};
struct cmdline_parser_params {
   int override ;
   int initialize ;
   int check_required ;
   int check_ambiguity ;
   int print_errors ;
};
typedef struct output_module output_module_t;
typedef struct probe_module probe_module_t;
struct send_arg {
   uint32_t cpu ;
   sock_t sock ;
   shard_t *shard ;
};
typedef struct send_arg send_arg_t;
struct recv_arg {
   uint32_t cpu ;
};
typedef struct recv_arg recv_arg_t;
struct mon_start_arg {
   uint32_t cpu ;
   iterator_t *it ;
   pthread_mutex_t *recv_ready_mutex ;
};
typedef struct mon_start_arg mon_start_arg_t;
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
enum __anonenum_cmdline_parser_arg_type_225089629 {
    ARG_NO = 0,
    ARG_STRING = 1,
    ARG_INT = 2,
    ARG_FLOAT = 3,
    ARG_LONGLONG = 4
} ;
typedef enum __anonenum_cmdline_parser_arg_type_225089629 cmdline_parser_arg_type;
struct line_list {
   char *string_arg ;
   struct line_list *next ;
};
typedef short __int16_t;
typedef __int16_t int16_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef size_t yy_size_t;
typedef flex_uint8_t YY_CHAR;
typedef int yy_state_type;
union __anonunion_YYSTYPE_714356573 {
   int int_literal ;
   char *string_literal ;
   struct node_st *expr ;
};
typedef union __anonunion_YYSTYPE_714356573 YYSTYPE;
typedef short YYINT;
struct __anonstruct_YYSTACKDATA_590319461 {
   unsigned int stacksize ;
   YYINT *s_base ;
   YYINT *s_mark ;
   YYINT *s_last ;
   YYSTYPE *l_base ;
   YYSTYPE *l_mark ;
};
typedef struct __anonstruct_YYSTACKDATA_590319461 YYSTACKDATA;
struct icmp_ra_addr {
   uint32_t ira_addr ;
   uint32_t ira_preference ;
};
struct ih_idseq {
   uint16_t icd_id ;
   uint16_t icd_seq ;
};
struct ih_pmtu {
   uint16_t ipm_void ;
   uint16_t ipm_nextmtu ;
};
struct ih_rtradv {
   uint8_t irt_num_addrs ;
   uint8_t irt_wpa ;
   uint16_t irt_lifetime ;
};
union __anonunion_icmp_hun_562310239 {
   unsigned char ih_pptr ;
   struct in_addr ih_gwaddr ;
   struct ih_idseq ih_idseq ;
   uint32_t ih_void ;
   struct ih_pmtu ih_pmtu ;
   struct ih_rtradv ih_rtradv ;
};
struct __anonstruct_id_ts_669259541 {
   uint32_t its_otime ;
   uint32_t its_rtime ;
   uint32_t its_ttime ;
};
struct __anonstruct_id_ip_706470303 {
   struct ip idi_ip ;
};
union __anonunion_icmp_dun_1026239311 {
   struct __anonstruct_id_ts_669259541 id_ts ;
   struct __anonstruct_id_ip_706470303 id_ip ;
   struct icmp_ra_addr id_radv ;
   uint32_t id_mask ;
   uint8_t id_data[1] ;
};
struct icmp {
   uint8_t icmp_type ;
   uint8_t icmp_code ;
   uint16_t icmp_cksum ;
   union __anonunion_icmp_hun_562310239 icmp_hun ;
   union __anonunion_icmp_dun_1026239311 icmp_dun ;
};
struct icmp_payload_for_rtt {
   uint32_t sent_tv_sec ;
   uint32_t sent_tv_usec ;
   ipaddr_n_t dst ;
};
typedef uint32_t tcp_seq;
struct __anonstruct____missing_field_name_112923541 {
   uint16_t th_sport ;
   uint16_t th_dport ;
   tcp_seq th_seq ;
   tcp_seq th_ack ;
   uint8_t th_x2 : 4 ;
   uint8_t th_off : 4 ;
   uint8_t th_flags ;
   uint16_t th_win ;
   uint16_t th_sum ;
   uint16_t th_urp ;
};
struct __anonstruct____missing_field_name_1013361302 {
   uint16_t source ;
   uint16_t dest ;
   uint32_t seq ;
   uint32_t ack_seq ;
   uint16_t res1 : 4 ;
   uint16_t doff : 4 ;
   uint16_t fin : 1 ;
   uint16_t syn : 1 ;
   uint16_t rst : 1 ;
   uint16_t psh : 1 ;
   uint16_t ack : 1 ;
   uint16_t urg : 1 ;
   uint16_t res2 : 2 ;
   uint16_t window ;
   uint16_t check ;
   uint16_t urg_ptr ;
};
union __anonunion____missing_field_name_588722493 {
   struct __anonstruct____missing_field_name_112923541 __annonCompField6 ;
   struct __anonstruct____missing_field_name_1013361302 __annonCompField7 ;
};
struct tcphdr {
   union __anonunion____missing_field_name_588722493 __annonCompField8 ;
};
typedef unsigned short __attribute__((__may_alias__))  alias_unsigned_short;
struct __anonstruct____missing_field_name_518125691 {
   uint16_t uh_sport ;
   uint16_t uh_dport ;
   uint16_t uh_ulen ;
   uint16_t uh_sum ;
};
struct __anonstruct____missing_field_name_518125692 {
   uint16_t source ;
   uint16_t dest ;
   uint16_t len ;
   uint16_t check ;
};
union __anonunion____missing_field_name_539173916 {
   struct __anonstruct____missing_field_name_518125691 __annonCompField3 ;
   struct __anonstruct____missing_field_name_518125692 __annonCompField4 ;
};
struct udphdr {
   union __anonunion____missing_field_name_539173916 __annonCompField5 ;
};
enum udp_payload_field_type {
    UDP_DATA = 0,
    UDP_SADDR_N = 1,
    UDP_SADDR_A = 2,
    UDP_DADDR_N = 3,
    UDP_DADDR_A = 4,
    UDP_SPORT_N = 5,
    UDP_SPORT_A = 6,
    UDP_DPORT_N = 7,
    UDP_DPORT_A = 8,
    UDP_RAND_BYTE = 9,
    UDP_RAND_DIGIT = 10,
    UDP_RAND_ALPHA = 11,
    UDP_RAND_ALPHANUM = 12
} ;
typedef enum udp_payload_field_type udp_payload_field_type_t;
struct udp_payload_field_type_def {
   char const   *name ;
   char const   *desc ;
   size_t max_length ;
   udp_payload_field_type_t ftype ;
};
typedef struct udp_payload_field_type_def udp_payload_field_type_def_t;
struct udp_payload_field {
   enum udp_payload_field_type ftype ;
   size_t length ;
   char *data ;
};
typedef struct udp_payload_field udp_payload_field_t;
struct udp_payload_template {
   unsigned int fcount ;
   struct udp_payload_field **fields ;
};
typedef struct udp_payload_template udp_payload_template_t;
struct ntphdr {
   uint8_t LI_VN_MODE ;
   uint8_t stratum ;
   uint8_t poll ;
   uint8_t precision ;
   uint32_t root_delay ;
   uint32_t root_dispersion ;
   uint32_t ref_ID ;
   uint64_t reference_timestamp ;
   uint64_t origin_timestamp ;
   uint64_t receive_timestamp ;
   uint64_t transmit_timestamp ;
} __attribute__((__packed__)) ;
typedef signed char __int8_t;
typedef __int8_t int8_t;
struct __anonstruct_dns_header_753342901 {
   uint16_t id ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int z : 1 ;
   unsigned int ra : 1 ;
   uint16_t qdcount ;
   uint16_t ancount ;
   uint16_t nscount ;
   uint16_t arcount ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_dns_header_753342901 dns_header;
struct __anonstruct_dns_question_tail_753912357 {
   uint16_t qtype ;
   uint16_t qclass ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_dns_question_tail_753912357 dns_question_tail;
struct __anonstruct_dns_answer_tail_215550957 {
   uint16_t type ;
   uint16_t class ;
   uint32_t ttl ;
   uint16_t rdlength ;
   char rdata[] ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_dns_answer_tail_215550957 dns_answer_tail;
enum __anonenum_dns_qtype_632227127 {
    DNS_QTYPE_A = 1,
    DNS_QTYPE_NS = 2,
    DNS_QTYPE_CNAME = 5,
    DNS_QTYPE_SOA = 6,
    DNS_QTYPE_PTR = 12,
    DNS_QTYPE_MX = 15,
    DNS_QTYPE_TXT = 16,
    DNS_QTYPE_AAAA = 28,
    DNS_QTYPE_RRSIG = 46,
    DNS_QTYPE_ALL = 255
} ;
typedef enum __anonenum_dns_qtype_632227127 dns_qtype;
typedef uint8_t bool;
struct bacnet_vlc {
   uint8_t type ;
   uint8_t function ;
   uint16_t length ;
} __attribute__((__packed__)) ;
struct bacnet_npdu {
   uint8_t version ;
   uint8_t control ;
} __attribute__((__packed__)) ;
struct bacnet_apdu {
   uint8_t type_flags ;
   uint8_t max_segments_apdu ;
   uint8_t invoke_id ;
   uint8_t server_choice ;
} __attribute__((__packed__)) ;
struct bacnet_probe {
   struct bacnet_vlc vlc ;
   struct bacnet_npdu npdu ;
   struct bacnet_apdu apdu ;
} __attribute__((__packed__)) ;
typedef int json_bool;
typedef unsigned short __u_short;
typedef unsigned int __u_int;
typedef unsigned int __useconds_t;
typedef __u_short u_short;
typedef __u_int u_int;
typedef u_int bpf_u_int32;
struct bpf_insn ;
struct bpf_program {
   u_int bf_len ;
   struct bpf_insn *bf_insns ;
};
struct bpf_insn {
   u_short code ;
   u_char jt ;
   u_char jf ;
   bpf_u_int32 k ;
};
struct pcap ;
typedef struct pcap pcap_t;
struct pcap_pkthdr {
   struct timeval ts ;
   bpf_u_int32 caplen ;
   bpf_u_int32 len ;
};
struct pcap_stat {
   u_int ps_recv ;
   u_int ps_drop ;
   u_int ps_ifdrop ;
};
/* compiler builtin:
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin:
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin:
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin:
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin:
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin:
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-eQ8Pt2WR.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr )
{
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr )
{
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )
{
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                              char * __restrict  __resolved ) ;
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) )
{
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr )
{
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__)) __realpath_chk)(char const   * __restrict  __name ,
                                                                                                     char * __restrict  __resolved ,
                                                                                                     size_t __resolvedlen ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__)) __realpath_alias)(char const   * __restrict  __name ,
                                                                                                       char * __restrict  __resolved )  __asm__("realpath")  ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                              char * __restrict  __resolved ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                                                             char * __restrict  __resolved )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__resolved, 1);
    tmp___0 = __realpath_chk(__name, __resolved, tmp);
    return (tmp___0);
  }
  tmp___2 = __realpath_alias(__name, __resolved);
  return (tmp___2);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ptsname_r_chk)(int __fd ,
                                                                                            char *__buf ,
                                                                                            size_t __buflen ,
                                                                                            size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ptsname_r_alias)(int __fd ,
                                                                                              char *__buf ,
                                                                                              size_t __buflen )  __asm__("ptsname_r")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ptsname_r_chk_warn)(int __fd ,
                                                                                                 char *__buf ,
                                                                                                 size_t __buflen ,
                                                                                                 size_t __nreal )  __asm__("__ptsname_r_chk")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__, __always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                                    char *__buf ,
                                                                                                    size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) __wctomb_chk)(char *__s ,
                                                                                                 wchar_t __wchar ,
                                                                                                 size_t __buflen ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) __wctomb_alias)(char *__s ,
                                                                                                   wchar_t __wchar )  __asm__("wctomb")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) wctomb)(char *__s ,
                                                                                                         wchar_t __wchar )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = __builtin_object_size((void *)__s, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp___2 = __builtin_object_size((void *)__s, 1);
    if (16UL > tmp___2) {
      tmp = __builtin_object_size((void *)__s, 1);
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
      return (tmp___0);
    }
  }
  tmp___3 = __wctomb_alias(__s, __wchar);
  return (tmp___3);
}
}
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t * __restrict  __dst ,
                                                           char const   * __restrict  __src ,
                                                           size_t __len , size_t __dstlen ) ;
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t * __restrict  __dst ,
                                                             char const   * __restrict  __src ,
                                                             size_t __len )  __asm__("mbstowcs")  ;
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t * __restrict  __dst ,
                                                                char const   * __restrict  __src ,
                                                                size_t __len , size_t __dstlen )  __asm__("__mbstowcs_chk")  ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
__inline extern size_t ( __attribute__((__gnu_inline__, __always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                      char const   * __restrict  __src ,
                                                                                      size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __mbstowcs_chk(__dst, __src, __len, tmp / sizeof(wchar_t ));
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    if (__len > tmp___3 / sizeof(wchar_t )) {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __mbstowcs_chk_warn(__dst, __src, __len, tmp___1 / sizeof(wchar_t ));
      return (tmp___2);
    }
  }
  tmp___5 = __mbstowcs_alias(__dst, __src, __len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char * __restrict  __dst ,
                                                           wchar_t const   * __restrict  __src ,
                                                           size_t __len , size_t __dstlen ) ;
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char * __restrict  __dst ,
                                                             wchar_t const   * __restrict  __src ,
                                                             size_t __len )  __asm__("wcstombs")  ;
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char * __restrict  __dst ,
                                                                wchar_t const   * __restrict  __src ,
                                                                size_t __len , size_t __dstlen )  __asm__("__wcstombs_chk")  ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
__inline extern size_t ( __attribute__((__gnu_inline__, __always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                      wchar_t const   * __restrict  __src ,
                                                                                      size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __wcstombs_chk(__dst, __src, __len, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    if (__len > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __wcstombs_chk_warn(__dst, __src, __len, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __wcstombs_alias(__dst, __src, __len);
  return (tmp___5);
}
}
extern FILE *stdin ;
extern FILE *stdout ;
__inline extern int ( __attribute__((__gnu_inline__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__gnu_inline__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__gnu_inline__,
__always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt ,
                               __gnuc_va_list __ap ) ;
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void)
{
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp )
{
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void)
{
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c )
{
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream )
{
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c )
{
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __gnu_inline__)) feof_unlocked)(FILE *__stream )
{


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __gnu_inline__)) ferror_unlocked)(FILE *__stream )
{


  {
  return ((__stream->_flags & 32) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__gnu_inline__, __always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap )
{
  unsigned long tmp ;
  int tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__s, 1);
  tmp___0 = __builtin___vsprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __ap);
  return (tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__gnu_inline__,
__always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt ,
                               __gnuc_va_list __ap ) ;
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __always_inline__)) vsnprintf)(char * __restrict  __s ,
                                                                                                           size_t __n ,
                                                                                                           char const   * __restrict  __fmt ,
                                                                                                           __gnuc_va_list __ap )
{
  unsigned long tmp ;
  int tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__s, 1);
  tmp___0 = __builtin___vsnprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                      __ap);
  return (tmp___0);
}
}
extern int __vfprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format ,
                          __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__gnu_inline__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap )
{
  int tmp ;

  {
  tmp = __vfprintf_chk((FILE * __restrict  )stdout, 1, __fmt, __ap);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap )
{
  int tmp ;

  {
  tmp = __vfprintf_chk(__stream, 1, __fmt, __ap);
  return (tmp);
}
}
extern int ( /* format attribute */  __vdprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt ,
                                                     __gnuc_va_list __arg ) ;
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap )
{
  int tmp ;

  {
  tmp = __vdprintf_chk(__fd, 1, __fmt, __ap);
  return (tmp);
}
}
extern char *( __attribute__((__warn_unused_result__)) __gets_chk)(char *__str , size_t  ) ;
extern char *( __attribute__((__warn_unused_result__)) __gets_warn)(char *__str )  __asm__("gets")  ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) gets)(char *__str )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__str, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__str, 1);
    tmp___0 = __gets_chk(__str, tmp);
    return (tmp___0);
  }
  tmp___2 = __gets_warn(__str);
  return (tmp___2);
}
}
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk)(char * __restrict  __s ,
                                                                    size_t __size ,
                                                                    int __n , FILE * __restrict  __stream ) ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char * __restrict  __s ,
                                                                      int __n , FILE * __restrict  __stream )  __asm__("fgets")  ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char * __restrict  __s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE * __restrict  __stream )  __asm__("__fgets_chk")  ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__s, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __fgets_chk(__s, tmp, __n, __stream);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__s, 1);
    if ((size_t )__n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__s, 1);
      tmp___2 = __fgets_chk_warn(__s, tmp___1, __n, __stream);
      return (tmp___2);
    }
  }
  tmp___5 = __fgets_alias(__s, __n, __stream);
  return (tmp___5);
}
}
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk)(void * __restrict  __ptr ,
                                                                     size_t __ptrlen ,
                                                                     size_t __size ,
                                                                     size_t __n ,
                                                                     FILE * __restrict  __stream ) ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void * __restrict  __ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE * __restrict  __stream )  __asm__("fread")  ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void * __restrict  __ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE * __restrict  __stream )  __asm__("__fread_chk")  ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__ptr, 0);
    tmp___0 = __fread_chk(__ptr, tmp, __size, __n, __stream);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
    if (__size * __n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
      tmp___2 = __fread_chk_warn(__ptr, tmp___1, __size, __n, __stream);
      return (tmp___2);
    }
  }
  tmp___5 = __fread_alias(__ptr, __size, __n, __stream);
  return (tmp___5);
}
}
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk)(void * __restrict  __ptr ,
                                                                              size_t __ptrlen ,
                                                                              size_t __size ,
                                                                              size_t __n ,
                                                                              FILE * __restrict  __stream ) ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void * __restrict  __ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE * __restrict  __stream )  __asm__("fread_unlocked")  ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void * __restrict  __ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE * __restrict  __stream )  __asm__("__fread_unlocked_chk")  ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___7 ;

  {
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__ptr, 0);
    tmp___0 = __fread_unlocked_chk(__ptr, tmp, __size, __n, __stream);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
    if (__size * __n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
      tmp___2 = __fread_unlocked_chk_warn(__ptr, tmp___1, __size, __n, __stream);
      return (tmp___2);
    }
  }
  tmp___7 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  return (tmp___7);
}
}
__inline extern void ( /* format attribute */ __attribute__((__gnu_inline__, __always_inline__)) vsyslog)(int __pri ,
                                                                                                          char const   *__fmt ,
                                                                                                          __gnuc_va_list __ap ) ;
extern void ( /* format attribute */  __vsyslog_chk)(int __pri , int __flag , char const   *__fmt ,
                                                     __gnuc_va_list __ap ) ;
__inline extern void ( /* format attribute */ __attribute__((__gnu_inline__, __always_inline__)) vsyslog)(int __pri ,
                                                                                                          char const   *__fmt ,
                                                                                                          __gnuc_va_list __ap )
{


  {
  __vsyslog_chk(__pri, 1, __fmt, __ap);
  return;
}
}
extern  __attribute__((__noreturn__)) int log_fatal(char const   *loggerName , char const   *logMessage
                                                    , ...) ;
extern int rijndaelKeySetupEnc(u32 *rk , u8 const   *cipherKey , int keyBits ) ;
extern void rijndaelEncrypt(u32 const   *rk , int Nr , u8 const   *pt , u8 *ct ) ;
extern int random_bytes(void *dst , size_t n ) ;
extern void *xmalloc(size_t size ) ;
aesrand_t *aesrand_init_from_random(void) ;
aesrand_t *aesrand_init_from_seed(uint64_t seed ) ;
uint64_t aesrand_getword(aesrand_t *aes ) ;
static aesrand_t *_aesrand_init(uint8_t *key )
{
  aesrand_t *aes ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = xmalloc(sizeof(aesrand_t ));
  aes = (aesrand_t *)tmp;
  memset((void *)(& aes->input), 0, (size_t )16);
  tmp___0 = rijndaelKeySetupEnc(aes->sched, (u8 const   *)key, 128);
  if (tmp___0 != 10) {
    log_fatal("aesrand", "could not initialize AES key");
  }
  memset((void *)(aes->output), 0, (size_t )16);
  return (aes);
}
}
aesrand_t *aesrand_init_from_seed(uint64_t seed )
{
  uint8_t key[16] ;
  uint8_t i ;
  aesrand_t *tmp ;

  {
  memset((void *)(key), 0, (size_t )16);
  i = (uint8_t )0;
  while ((unsigned long )i < sizeof(seed)) {
    key[i] = (uint8_t )((seed >> 8 * (int )i) & 255UL);
    i = (uint8_t )((int )i + 1);
  }
  tmp = _aesrand_init(key);
  return (tmp);
}
}
aesrand_t *aesrand_init_from_random(void)
{
  uint8_t key[16] ;
  int tmp ;
  aesrand_t *tmp___0 ;

  {
  tmp = random_bytes((void *)(key), (size_t )16);
  if (! tmp) {
    log_fatal("aesrand", "Couldn\'t get random bytes");
  }
  tmp___0 = _aesrand_init(key);
  return (tmp___0);
}
}
uint64_t aesrand_getword(aesrand_t *aes )
{
  uint64_t retval ;

  {
  memcpy((void * __restrict  )(aes->input), (void const   * __restrict  )(aes->output),
         sizeof(aes->input));
  rijndaelEncrypt((u32 const   *)(aes->sched), 10, (u8 const   *)((uint8_t *)(aes->input)),
                  (u8 *)(aes->output));
  memcpy((void * __restrict  )(& retval), (void const   * __restrict  )(aes->output),
         sizeof(retval));
  return (retval);
}
}
#pragma merger("0","/tmp/cil-0eLoF4B0.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
cyclic_group_t const   *get_group(uint64_t min_size ) ;
cycle_t make_cycle(cyclic_group_t const   *group , aesrand_t *aes ) ;
uint64_t isomorphism(uint64_t additive_elt , cyclic_group_t const   *mult_group ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
__inline extern void ( __attribute__((__gnu_inline__)) __gmpz_abs)(mpz_ptr __gmp_w ,
                                                                   mpz_srcptr __gmp_u ) ;
extern void __gmpz_clear(mpz_ptr  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) __gmpz_fits_uint_p)(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) __gmpz_fits_ulong_p)(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) __gmpz_fits_ushort_p)(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
__inline extern unsigned long ( __attribute__((__gnu_inline__)) __gmpz_get_ui)(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
__inline extern mp_limb_t ( __attribute__((__gnu_inline__)) __gmpz_getlimbn)(mpz_srcptr __gmp_z ,
                                                                             mp_size_t __gmp_n )  __attribute__((__pure__)) ;
extern void __gmpz_init(mpz_ptr  ) ;
extern void __gmpz_init_set_ui(mpz_ptr  , unsigned long  ) ;
__inline extern void ( __attribute__((__gnu_inline__)) __gmpz_neg)(mpz_ptr __gmp_w ,
                                                                   mpz_srcptr __gmp_u ) ;
__inline extern int ( __attribute__((__gnu_inline__)) __gmpz_perfect_square_p)(mpz_srcptr __gmp_a )  __attribute__((__pure__)) ;
__inline extern mp_bitcnt_t ( __attribute__((__gnu_inline__)) __gmpz_popcount)(mpz_srcptr __gmp_u )  __attribute__((__pure__)) ;
extern void __gmpz_powm(mpz_ptr  , mpz_srcptr  , mpz_srcptr  , mpz_srcptr  ) ;
extern void __gmpz_set(mpz_ptr  , mpz_srcptr  ) ;
__inline extern void ( __attribute__((__gnu_inline__)) __gmpz_set_q)(mpz_ptr __gmp_w ,
                                                                     mpq_srcptr __gmp_u ) ;
__inline extern size_t ( __attribute__((__gnu_inline__)) __gmpz_size)(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
extern void __gmpz_tdiv_q(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
__inline extern void ( __attribute__((__gnu_inline__)) __gmpq_abs)(mpq_ptr __gmp_w ,
                                                                   mpq_srcptr __gmp_u ) ;
__inline extern void ( __attribute__((__gnu_inline__)) __gmpq_neg)(mpq_ptr __gmp_w ,
                                                                   mpq_srcptr __gmp_u ) ;
extern void __gmpq_set(mpq_ptr  , mpq_srcptr  ) ;
__inline extern mp_limb_t ( __attribute__((__gnu_inline__)) __gmpn_add)(mp_ptr __gmp_wp ,
                                                                        mp_srcptr __gmp_xp ,
                                                                        mp_size_t __gmp_xsize ,
                                                                        mp_srcptr __gmp_yp ,
                                                                        mp_size_t __gmp_ysize ) ;
__inline extern mp_limb_t ( __attribute__((__gnu_inline__)) __gmpn_add_1)(mp_ptr __gmp_dst ,
                                                                          mp_srcptr __gmp_src ,
                                                                          mp_size_t __gmp_size ,
                                                                          mp_limb_t __gmp_n ) ;
extern mp_limb_t __gmpn_add_n(mp_ptr  , mp_srcptr  , mp_srcptr  , mp_size_t  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) __gmpn_cmp)(mp_srcptr __gmp_xp ,
                                                                  mp_srcptr __gmp_yp ,
                                                                  mp_size_t __gmp_size )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) __gmpn_zero_p)(mp_srcptr __gmp_p ,
                                                                     mp_size_t __gmp_n )  __attribute__((__pure__)) ;
__inline extern mp_limb_t ( __attribute__((__gnu_inline__)) __gmpn_neg)(mp_ptr __gmp_rp ,
                                                                        mp_srcptr __gmp_up ,
                                                                        mp_size_t __gmp_n ) ;
extern void __gmpn_com(mp_ptr  , mp_srcptr  , mp_size_t  ) ;
extern int __gmpn_perfect_square_p(mp_srcptr  , mp_size_t  )  __attribute__((__pure__)) ;
extern mp_bitcnt_t __gmpn_popcount(mp_srcptr  , mp_size_t  )  __attribute__((__pure__)) ;
__inline extern mp_limb_t ( __attribute__((__gnu_inline__)) __gmpn_sub)(mp_ptr __gmp_wp ,
                                                                        mp_srcptr __gmp_xp ,
                                                                        mp_size_t __gmp_xsize ,
                                                                        mp_srcptr __gmp_yp ,
                                                                        mp_size_t __gmp_ysize ) ;
__inline extern mp_limb_t ( __attribute__((__gnu_inline__)) __gmpn_sub_1)(mp_ptr __gmp_dst ,
                                                                          mp_srcptr __gmp_src ,
                                                                          mp_size_t __gmp_size ,
                                                                          mp_limb_t __gmp_n ) ;
extern mp_limb_t __gmpn_sub_n(mp_ptr  , mp_srcptr  , mp_srcptr  , mp_size_t  ) ;
__inline extern void ( __attribute__((__gnu_inline__)) __gmpz_abs)(mpz_ptr __gmp_w ,
                                                                   mpz_srcptr __gmp_u )
{


  {
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    __gmpz_set(__gmp_w, __gmp_u);
  }
  if (__gmp_w->_mp_size >= 0) {
    __gmp_w->_mp_size = __gmp_w->_mp_size;
  } else {
    __gmp_w->_mp_size = - __gmp_w->_mp_size;
  }
  return;
}
}
__inline extern int ( __attribute__((__gnu_inline__)) __gmpz_fits_uint_p)(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) __gmpz_fits_uint_p)(mpz_srcptr __gmp_z )
{
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
  if (__gmp_n == 0L) {
    tmp = 1;
  } else
  if (__gmp_n == 1L) {
    if (*(__gmp_p + 0) <= 4294967295UL) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) __gmpz_fits_ulong_p)(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) __gmpz_fits_ulong_p)(mpz_srcptr __gmp_z )
{
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
  if (__gmp_n == 0L) {
    tmp = 1;
  } else
  if (__gmp_n == 1L) {
    if (*(__gmp_p + 0) <= 18446744073709551615) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) __gmpz_fits_ushort_p)(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) __gmpz_fits_ushort_p)(mpz_srcptr __gmp_z )
{
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp ;

  {
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
  if (__gmp_n == 0L) {
    tmp = 1;
  } else
  if (__gmp_n == 1L) {
    if (*(__gmp_p + 0) <= 65535UL) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
__inline extern unsigned long ( __attribute__((__gnu_inline__)) __gmpz_get_ui)(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
__inline extern unsigned long ( __attribute__((__gnu_inline__)) __gmpz_get_ui)(mpz_srcptr __gmp_z )
{
  mp_ptr __gmp_p ;
  mp_size_t __gmp_n ;
  mp_limb_t __gmp_l ;
  mp_limb_t tmp ;

  {
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
  __gmp_l = *(__gmp_p + 0);
  if (__gmp_n != 0L) {
    tmp = __gmp_l;
  } else {
    tmp = (mp_limb_t )0;
  }
  return (tmp);
}
}
__inline extern mp_limb_t ( __attribute__((__gnu_inline__)) __gmpz_getlimbn)(mpz_srcptr __gmp_z ,
                                                                             mp_size_t __gmp_n )  __attribute__((__pure__)) ;
__inline extern mp_limb_t ( __attribute__((__gnu_inline__)) __gmpz_getlimbn)(mpz_srcptr __gmp_z ,
                                                                             mp_size_t __gmp_n )
{
  mp_limb_t __gmp_result ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  __gmp_result = (mp_limb_t )0;
  if (__gmp_n >= 0L) {
    if (__gmp_z->_mp_size >= 0) {
      tmp = __gmp_z->_mp_size;
    } else {
      tmp = - __gmp_z->_mp_size;
    }
    if (__gmp_n < (mp_size_t )tmp) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )(tmp___0 != 0), 1L);
  if (tmp___1) {
    __gmp_result = *(__gmp_z->_mp_d + __gmp_n);
  }
  return (__gmp_result);
}
}
__inline extern void ( __attribute__((__gnu_inline__)) __gmpz_neg)(mpz_ptr __gmp_w ,
                                                                   mpz_srcptr __gmp_u )
{


  {
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    __gmpz_set(__gmp_w, __gmp_u);
  }
  __gmp_w->_mp_size = - __gmp_w->_mp_size;
  return;
}
}
__inline extern int ( __attribute__((__gnu_inline__)) __gmpz_perfect_square_p)(mpz_srcptr __gmp_a )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) __gmpz_perfect_square_p)(mpz_srcptr __gmp_a )
{
  mp_size_t __gmp_asize ;
  int __gmp_result ;
  long tmp ;

  {
  __gmp_asize = (mp_size_t )__gmp_a->_mp_size;
  __gmp_result = __gmp_asize >= 0L;
  tmp = __builtin_expect((long )((__gmp_asize > 0L) != 0), 1L);
  if (tmp) {
    __gmp_result = __gmpn_perfect_square_p((mp_srcptr )__gmp_a->_mp_d, __gmp_asize);
  }
  return (__gmp_result);
}
}
__inline extern mp_bitcnt_t ( __attribute__((__gnu_inline__)) __gmpz_popcount)(mpz_srcptr __gmp_u )  __attribute__((__pure__)) ;
__inline extern mp_bitcnt_t ( __attribute__((__gnu_inline__)) __gmpz_popcount)(mpz_srcptr __gmp_u )
{
  mp_size_t __gmp_usize ;
  mp_bitcnt_t __gmp_result ;
  long tmp ;

  {
  __gmp_usize = (mp_size_t )__gmp_u->_mp_size;
  if (__gmp_usize < 0L) {
    __gmp_result = ~ ((mp_bitcnt_t )0);
  } else {
    __gmp_result = (mp_bitcnt_t )0;
  }
  tmp = __builtin_expect((long )((__gmp_usize > 0L) != 0), 1L);
  if (tmp) {
    __gmp_result = __gmpn_popcount((mp_srcptr )__gmp_u->_mp_d, __gmp_usize);
  }
  return (__gmp_result);
}
}
__inline extern void ( __attribute__((__gnu_inline__)) __gmpz_set_q)(mpz_ptr __gmp_w ,
                                                                     mpq_srcptr __gmp_u )
{


  {
  __gmpz_tdiv_q(__gmp_w, & __gmp_u->_mp_num, & __gmp_u->_mp_den);
  return;
}
}
__inline extern size_t ( __attribute__((__gnu_inline__)) __gmpz_size)(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
__inline extern size_t ( __attribute__((__gnu_inline__)) __gmpz_size)(mpz_srcptr __gmp_z )
{
  int tmp ;

  {
  if (__gmp_z->_mp_size >= 0) {
    tmp = __gmp_z->_mp_size;
  } else {
    tmp = - __gmp_z->_mp_size;
  }
  return ((size_t )tmp);
}
}
__inline extern void ( __attribute__((__gnu_inline__)) __gmpq_abs)(mpq_ptr __gmp_w ,
                                                                   mpq_srcptr __gmp_u )
{


  {
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    __gmpq_set(__gmp_w, __gmp_u);
  }
  if (__gmp_w->_mp_num._mp_size >= 0) {
    __gmp_w->_mp_num._mp_size = __gmp_w->_mp_num._mp_size;
  } else {
    __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
  }
  return;
}
}
__inline extern void ( __attribute__((__gnu_inline__)) __gmpq_neg)(mpq_ptr __gmp_w ,
                                                                   mpq_srcptr __gmp_u )
{


  {
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    __gmpq_set(__gmp_w, __gmp_u);
  }
  __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
  return;
}
}
__inline extern mp_limb_t ( __attribute__((__gnu_inline__)) __gmpn_add)(mp_ptr __gmp_wp ,
                                                                        mp_srcptr __gmp_xp ,
                                                                        mp_size_t __gmp_xsize ,
                                                                        mp_srcptr __gmp_yp ,
                                                                        mp_size_t __gmp_ysize )
{
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_size_t tmp ;
  mp_limb_t tmp___0 ;
  mp_limb_t tmp___1 ;
  mp_size_t __gmp_j ;

  {
  while (1) {
    __gmp_i = __gmp_ysize;
    if (__gmp_i != 0L) {
      tmp___1 = __gmpn_add_n(__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i);
      if (tmp___1) {
        while (1) {
          if (__gmp_i >= __gmp_xsize) {
            __gmp_c = (mp_limb_t )1;
            goto __gmp_done;
          }
          __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
          tmp = __gmp_i;
          __gmp_i ++;
          tmp___0 = (__gmp_x + 1UL) & 18446744073709551615;
          *(__gmp_wp + tmp) = tmp___0;
          if (! (tmp___0 == 0UL)) {
            break;
          }
        }
      }
    }
    if ((unsigned long )__gmp_wp != (unsigned long )__gmp_xp) {
      while (1) {
        __gmp_j = __gmp_i;
        while (__gmp_j < __gmp_xsize) {
          *(__gmp_wp + __gmp_j) = (mp_limb_t )*(__gmp_xp + __gmp_j);
          __gmp_j ++;
        }
        break;
      }
    }
    __gmp_c = (mp_limb_t )0;
    __gmp_done: ;
    break;
  }
  return (__gmp_c);
}
}
__inline extern mp_limb_t ( __attribute__((__gnu_inline__)) __gmpn_add_1)(mp_ptr __gmp_dst ,
                                                                          mp_srcptr __gmp_src ,
                                                                          mp_size_t __gmp_size ,
                                                                          mp_limb_t __gmp_n )
{
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_r ;
  mp_size_t __gmp_j ;
  mp_size_t __gmp_j___0 ;

  {
  while (1) {
    __gmp_x = (mp_limb_t )*(__gmp_src + 0);
    __gmp_r = __gmp_x + __gmp_n;
    *(__gmp_dst + 0) = __gmp_r;
    if (__gmp_r < __gmp_n) {
      __gmp_c = (mp_limb_t )1;
      __gmp_i = (mp_size_t )1;
      while (__gmp_i < __gmp_size) {
        __gmp_x = (mp_limb_t )*(__gmp_src + __gmp_i);
        __gmp_r = __gmp_x + 1UL;
        *(__gmp_dst + __gmp_i) = __gmp_r;
        __gmp_i ++;
        if (! (__gmp_r < 1UL)) {
          if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
            while (1) {
              __gmp_j = __gmp_i;
              while (__gmp_j < __gmp_size) {
                *(__gmp_dst + __gmp_j) = (mp_limb_t )*(__gmp_src + __gmp_j);
                __gmp_j ++;
              }
              break;
            }
          }
          __gmp_c = (mp_limb_t )0;
          break;
        }
      }
    } else {
      if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
        while (1) {
          __gmp_j___0 = (mp_size_t )1;
          while (__gmp_j___0 < __gmp_size) {
            *(__gmp_dst + __gmp_j___0) = (mp_limb_t )*(__gmp_src + __gmp_j___0);
            __gmp_j___0 ++;
          }
          break;
        }
      }
      __gmp_c = (mp_limb_t )0;
    }
    break;
  }
  return (__gmp_c);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) __gmpn_cmp)(mp_srcptr __gmp_xp ,
                                                                  mp_srcptr __gmp_yp ,
                                                                  mp_size_t __gmp_size )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) __gmpn_cmp)(mp_srcptr __gmp_xp ,
                                                                  mp_srcptr __gmp_yp ,
                                                                  mp_size_t __gmp_size )
{
  int __gmp_result ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_y ;

  {
  while (1) {
    __gmp_result = 0;
    __gmp_i = __gmp_size;
    while (1) {
      __gmp_i --;
      if (! (__gmp_i >= 0L)) {
        break;
      }
      __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
      __gmp_y = (mp_limb_t )*(__gmp_yp + __gmp_i);
      if (__gmp_x != __gmp_y) {
        if (__gmp_x > __gmp_y) {
          __gmp_result = 1;
        } else {
          __gmp_result = -1;
        }
        break;
      }
    }
    break;
  }
  return (__gmp_result);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) __gmpn_zero_p)(mp_srcptr __gmp_p ,
                                                                     mp_size_t __gmp_n )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) __gmpn_zero_p)(mp_srcptr __gmp_p ,
                                                                     mp_size_t __gmp_n )
{


  {
  while (1) {
    __gmp_n --;
    if (*(__gmp_p + __gmp_n) != 0UL) {
      return (0);
    }
    if (! (__gmp_n != 0L)) {
      break;
    }
  }
  return (1);
}
}
__inline extern mp_limb_t ( __attribute__((__gnu_inline__)) __gmpn_sub)(mp_ptr __gmp_wp ,
                                                                        mp_srcptr __gmp_xp ,
                                                                        mp_size_t __gmp_xsize ,
                                                                        mp_srcptr __gmp_yp ,
                                                                        mp_size_t __gmp_ysize )
{
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_size_t tmp ;
  mp_limb_t tmp___0 ;
  mp_size_t __gmp_j ;

  {
  while (1) {
    __gmp_i = __gmp_ysize;
    if (__gmp_i != 0L) {
      tmp___0 = __gmpn_sub_n(__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i);
      if (tmp___0) {
        while (1) {
          if (__gmp_i >= __gmp_xsize) {
            __gmp_c = (mp_limb_t )1;
            goto __gmp_done;
          }
          __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
          tmp = __gmp_i;
          __gmp_i ++;
          *(__gmp_wp + tmp) = (__gmp_x - 1UL) & 18446744073709551615;
          if (! (__gmp_x == 0UL)) {
            break;
          }
        }
      }
    }
    if ((unsigned long )__gmp_wp != (unsigned long )__gmp_xp) {
      while (1) {
        __gmp_j = __gmp_i;
        while (__gmp_j < __gmp_xsize) {
          *(__gmp_wp + __gmp_j) = (mp_limb_t )*(__gmp_xp + __gmp_j);
          __gmp_j ++;
        }
        break;
      }
    }
    __gmp_c = (mp_limb_t )0;
    __gmp_done: ;
    break;
  }
  return (__gmp_c);
}
}
__inline extern mp_limb_t ( __attribute__((__gnu_inline__)) __gmpn_sub_1)(mp_ptr __gmp_dst ,
                                                                          mp_srcptr __gmp_src ,
                                                                          mp_size_t __gmp_size ,
                                                                          mp_limb_t __gmp_n )
{
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_r ;
  mp_size_t __gmp_j ;
  mp_size_t __gmp_j___0 ;

  {
  while (1) {
    __gmp_x = (mp_limb_t )*(__gmp_src + 0);
    __gmp_r = __gmp_x - __gmp_n;
    *(__gmp_dst + 0) = __gmp_r;
    if (__gmp_x < __gmp_n) {
      __gmp_c = (mp_limb_t )1;
      __gmp_i = (mp_size_t )1;
      while (__gmp_i < __gmp_size) {
        __gmp_x = (mp_limb_t )*(__gmp_src + __gmp_i);
        __gmp_r = __gmp_x - 1UL;
        *(__gmp_dst + __gmp_i) = __gmp_r;
        __gmp_i ++;
        if (! (__gmp_x < 1UL)) {
          if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
            while (1) {
              __gmp_j = __gmp_i;
              while (__gmp_j < __gmp_size) {
                *(__gmp_dst + __gmp_j) = (mp_limb_t )*(__gmp_src + __gmp_j);
                __gmp_j ++;
              }
              break;
            }
          }
          __gmp_c = (mp_limb_t )0;
          break;
        }
      }
    } else {
      if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
        while (1) {
          __gmp_j___0 = (mp_size_t )1;
          while (__gmp_j___0 < __gmp_size) {
            *(__gmp_dst + __gmp_j___0) = (mp_limb_t )*(__gmp_src + __gmp_j___0);
            __gmp_j___0 ++;
          }
          break;
        }
      }
      __gmp_c = (mp_limb_t )0;
    }
    break;
  }
  return (__gmp_c);
}
}
__inline extern mp_limb_t ( __attribute__((__gnu_inline__)) __gmpn_neg)(mp_ptr __gmp_rp ,
                                                                        mp_srcptr __gmp_up ,
                                                                        mp_size_t __gmp_n )
{


  {
  while (*__gmp_up == 0UL) {
    *__gmp_rp = (mp_limb_t )0;
    __gmp_n --;
    if (! __gmp_n) {
      return ((mp_limb_t )0);
    }
    __gmp_up ++;
    __gmp_rp ++;
  }
  *__gmp_rp = (mp_limb_t )(- *__gmp_up & 0xffffffffffffffffUL);
  __gmp_n --;
  if (__gmp_n) {
    __gmp_up ++;
    __gmp_rp ++;
    __gmpn_com(__gmp_rp, __gmp_up, __gmp_n);
  }
  return ((mp_limb_t )1);
}
}
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg )
{


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
__inline extern ssize_t ( __attribute__((__gnu_inline__, __always_inline__)) recv)(int __fd ,
                                                                                   void *__buf ,
                                                                                   size_t __n ,
                                                                                   int __flags ) ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __always_inline__)) recvfrom)(int __fd ,
                                                                                       void * __restrict  __buf ,
                                                                                       size_t __n ,
                                                                                       int __flags ,
                                                                                       struct sockaddr * __restrict  __cil_tmp14 ,
                                                                                       socklen_t * __restrict  __addr_len ) ;
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags )  __asm__("recv")  ;
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags )  __asm__("__recv_chk")  ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __always_inline__)) recv)(int __fd ,
                                                                                   void *__buf ,
                                                                                   size_t __n ,
                                                                                   int __flags )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size(__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __recv_chk(__fd, __buf, __n, tmp, __flags);
    return (tmp___0);
    tmp___3 = __builtin_object_size(__buf, 0);
    if (__n > tmp___3) {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __recv_chk_warn(__fd, __buf, __n, tmp___1, __flags);
      return (tmp___2);
    }
  }
  tmp___5 = __recv_alias(__fd, __buf, __n, __flags);
  return (tmp___5);
}
}
extern ssize_t __recvfrom_chk(int __fd , void * __restrict  __buf , size_t __n , size_t __buflen ,
                              int __flags , struct sockaddr * __restrict  __addr ,
                              socklen_t * __restrict  __addr_len ) ;
extern ssize_t __recvfrom_alias(int __fd , void * __restrict  __buf , size_t __n ,
                                int __flags , struct sockaddr * __restrict  __addr ,
                                socklen_t * __restrict  __addr_len )  __asm__("recvfrom")  ;
extern ssize_t __recvfrom_chk_warn(int __fd , void * __restrict  __buf , size_t __n ,
                                   size_t __buflen , int __flags , struct sockaddr * __restrict  __addr ,
                                   socklen_t * __restrict  __addr_len )  __asm__("__recvfrom_chk")  ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __always_inline__)) recvfrom)(int __fd ,
                                                                                       void * __restrict  __buf ,
                                                                                       size_t __n ,
                                                                                       int __flags ,
                                                                                       struct sockaddr * __restrict  __cil_tmp14 ,
                                                                                       socklen_t * __restrict  __addr_len )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 0);
    tmp___0 = __recvfrom_chk(__fd, __buf, __n, tmp, __flags, __addr, __addr_len);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 0);
    if (__n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 0);
      tmp___2 = __recvfrom_chk_warn(__fd, __buf, __n, tmp___1, __flags, __addr, __addr_len);
      return (tmp___2);
    }
  }
  tmp___5 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr, __addr_len);
  return (tmp___5);
}
}
extern int log_debug(char const   *loggerName , char const   *logMessage  , ...) ;
static cyclic_group_t groups[5]  = {      {(uint64_t )257, (uint64_t )3, (size_t )1, {(uint64_t )2}},
        {(uint64_t )65537, (uint64_t )3, (size_t )1, {(uint64_t )2}},
        {(uint64_t )16777259, (uint64_t )2, (size_t )4, {(uint64_t )2, (uint64_t )23,
                                                      (uint64_t )103, (uint64_t )3541}},
        {(uint64_t )268435459,
      (uint64_t )2, (size_t )4, {(uint64_t )2, (uint64_t )3, (uint64_t )19, (uint64_t )87211}},
        {(uint64_t )4294967311L,
      (uint64_t )3, (size_t )5, {(uint64_t )2, (uint64_t )3, (uint64_t )5, (uint64_t )131,
                                 (uint64_t )364289}}};
static int check_coprime(uint64_t check , cyclic_group_t const   *group )
{
  unsigned int i ;

  {
  if (check == 0UL) {
    return (0);
  } else
  if (check == 1UL) {
    return (0);
  }
  i = 0U;
  while ((size_t const   )i < group->num_prime_factors) {
    if (group->prime_factors[i] > check) {
      if (! (group->prime_factors[i] % check)) {
        return (0);
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */
    if (group->prime_factors[i] < check) {
      if (! (check % group->prime_factors[i])) {
        return (0);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */
    if (group->prime_factors[i] == check) {
      return (0);
    }
    i ++;
  }
  return (1);
}
}
static uint32_t find_primroot(cyclic_group_t const   *group , aesrand_t *aes )
{
  uint32_t candidate ;
  uint64_t tmp ;
  uint64_t retv ;
  uint64_t max_root ;
  int tmp___0 ;

  {
  tmp = aesrand_getword(aes);
  candidate = (uint32_t )((tmp & 4294967295UL) % (unsigned long )group->prime);
  retv = (uint64_t )0;
  max_root = (1UL << 32) - 14UL;
  while (1) {
    while (1) {
      tmp___0 = check_coprime((uint64_t )candidate, group);
      if (! (tmp___0 != 1)) {
        break;
      }
      candidate ++;
      candidate = (uint32_t )((unsigned long const   )candidate % group->prime);
    }
    retv = isomorphism((uint64_t )candidate, group);
    if (! (retv > max_root)) {
      break;
    }
  }
  return ((uint32_t )retv);
}
}
cyclic_group_t const   *get_group(uint64_t min_size )
{
  unsigned int i ;

  {
  i = 0U;
  while ((unsigned long )i < sizeof(groups)) {
    if (groups[i].prime > min_size) {
      return ((cyclic_group_t const   *)(& groups[i]));
    }
    i ++;
  }
  __assert_fail("0", "src/cyclic.c", 142U, "get_group");
}
}
cycle_t make_cycle(cyclic_group_t const   *group , aesrand_t *aes )
{
  cycle_t cycle ;
  uint32_t tmp ;
  uint64_t tmp___0 ;

  {
  cycle.group = group;
  tmp = find_primroot(group, aes);
  cycle.generator = (uint64_t )tmp;
  tmp___0 = aesrand_getword(aes);
  cycle.offset = (uint32_t )(tmp___0 & 4294967295UL);
  cycle.offset = (uint32_t )((unsigned long const   )cycle.offset % group->prime);
  cycle.order = (uint64_t )(group->prime - 1UL);
  return (cycle);
}
}
uint64_t isomorphism(uint64_t additive_elt , cyclic_group_t const   *mult_group )
{
  mpz_t base ;
  mpz_t power ;
  mpz_t prime ;
  mpz_t primroot ;
  uint64_t retv ;
  unsigned long tmp___0 ;

  {
  if (! (additive_elt < (uint64_t )mult_group->prime)) {
    __assert_fail("additive_elt < mult_group->prime", "src/cyclic.c", 158U, "isomorphism");
  }
  __gmpz_init_set_ui(base, (unsigned long )mult_group->known_primroot);
  __gmpz_init_set_ui(power, additive_elt);
  __gmpz_init_set_ui(prime, (unsigned long )mult_group->prime);
  __gmpz_init(primroot);
  __gmpz_powm(primroot, (mpz_srcptr )(base), (mpz_srcptr )(power), (mpz_srcptr )(prime));
  tmp___0 = __gmpz_get_ui((mpz_srcptr )(primroot));
  retv = tmp___0;
  log_debug("zmap", "Isomorphism: %llu", retv);
  __gmpz_clear(base);
  __gmpz_clear(power);
  __gmpz_clear(prime);
  __gmpz_clear(primroot);
  return (retv);
}
}
#pragma merger("0","/tmp/cil-Nx7Y0RVB.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
char *fs_get_string_by_index(fieldset_t *fs , int index___0 ) ;
uint64_t fs_get_uint64_by_index(fieldset_t *fs , int index___0 ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern int __printf_chk(int __flag , char const   * __restrict  __format  , ...) ;
node_t *make_op_node(enum operation op ) ;
node_t *make_field_node(char *fieldname ) ;
node_t *make_string_node(char *literal ) ;
node_t *make_int_node(int literal ) ;
int evaluate_expression(node_t *root , fieldset_t *fields___8 ) ;
void print_expression(node_t *root ) ;
static node_t *alloc_node(void) ;
static int eval_gt_node(node_t *node , fieldset_t *fields___8 ) ;
static int eval_lt_node(node_t *node , fieldset_t *fields___8 ) ;
static int eval_eq_node(node_t *node , fieldset_t *fields___8 ) ;
static int eval_lt_eq_node(node_t *node , fieldset_t *fields___8 ) ;
static int eval_gt_eq_node(node_t *node , fieldset_t *fields___8 ) ;
static node_t *alloc_node(void)
{
  node_t *node ;
  void *tmp ;

  {
  tmp = xmalloc(sizeof(node_t ));
  node = (node_t *)tmp;
  return (node);
}
}
static int eval_gt_node(node_t *node , fieldset_t *fields___8 )
{
  int index___0 ;
  uint64_t expected ;
  uint64_t actual ;
  uint64_t tmp ;

  {
  index___0 = (node->left_child)->value.field.index;
  expected = (node->right_child)->value.int_literal;
  tmp = fs_get_uint64_by_index(fields___8, index___0);
  actual = tmp;
  return (actual > expected);
}
}
static int eval_lt_node(node_t *node , fieldset_t *fields___8 )
{
  int index___0 ;
  uint64_t expected ;
  uint64_t actual ;
  uint64_t tmp ;

  {
  index___0 = (node->left_child)->value.field.index;
  expected = (node->right_child)->value.int_literal;
  tmp = fs_get_uint64_by_index(fields___8, index___0);
  actual = tmp;
  return (actual < expected);
}
}
static int eval_eq_node(node_t *node , fieldset_t *fields___8 )
{
  node_t *literal ;
  int index___0 ;
  char *expected ;
  char *actual ;
  int tmp ;
  uint64_t tmp___0 ;

  {
  literal = node->right_child;
  index___0 = (node->left_child)->value.field.index;
  switch ((unsigned int )literal->type) {
  case 2U:
  expected = literal->value.string_literal;
  actual = fs_get_string_by_index(fields___8, index___0);
  tmp = strcmp((char const   *)expected, (char const   *)actual);
  return (tmp == 0);
  break;
  case 3U:
  tmp___0 = fs_get_uint64_by_index(fields___8, index___0);
  return (tmp___0 == literal->value.int_literal);
  break;
  default:
  __printf_chk(1, (char const   * __restrict  )"wat\n");
  break;
  }
  return (0);
}
}
static int eval_lt_eq_node(node_t *node , fieldset_t *fields___8 )
{
  int tmp ;
  int tmp___0 ;

  {
  tmp = eval_gt_node(node, fields___8);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return (tmp___0);
}
}
static int eval_gt_eq_node(node_t *node , fieldset_t *fields___8 )
{
  int tmp ;
  int tmp___0 ;

  {
  tmp = eval_lt_node(node, fields___8);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return (tmp___0);
}
}
node_t *make_op_node(enum operation op )
{
  node_t *node ;
  node_t *tmp ;

  {
  tmp = alloc_node();
  node = tmp;
  node->type = (enum node_type )0;
  node->value.op = op;
  return (node);
}
}
node_t *make_field_node(char *fieldname )
{
  node_t *node ;
  node_t *tmp ;

  {
  tmp = alloc_node();
  node = tmp;
  node->type = (enum node_type )1;
  node->value.field.fieldname = fieldname;
  return (node);
}
}
node_t *make_string_node(char *literal )
{
  node_t *node ;
  node_t *tmp ;

  {
  tmp = alloc_node();
  node = tmp;
  node->type = (enum node_type )2;
  node->value.string_literal = literal;
  return (node);
}
}
node_t *make_int_node(int literal )
{
  node_t *node ;
  node_t *tmp ;

  {
  tmp = alloc_node();
  node = tmp;
  node->type = (enum node_type )3;
  node->value.int_literal = (uint64_t )literal;
  return (node);
}
}
int evaluate_expression(node_t *root , fieldset_t *fields___8 )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  if (! root) {
    return (1);
  }
  switch ((unsigned int )root->type) {
  case 3U:
  case 2U:
  case 1U:
  return (1);
  case 0U:
  break;
  }
  switch ((unsigned int )root->value.op) {
  case 0U:
  tmp = eval_gt_node(root, fields___8);
  return (tmp);
  case 1U:
  tmp___0 = eval_lt_node(root, fields___8);
  return (tmp___0);
  case 2U:
  tmp___1 = eval_eq_node(root, fields___8);
  return (tmp___1);
  case 3U:
  tmp___2 = eval_eq_node(root, fields___8);
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  return (tmp___3);
  case 6U:
  tmp___4 = eval_lt_eq_node(root, fields___8);
  return (tmp___4);
  case 7U:
  tmp___5 = eval_gt_eq_node(root, fields___8);
  return (tmp___5);
  case 4U:
  tmp___6 = evaluate_expression(root->left_child, fields___8);
  if (tmp___6) {
    tmp___7 = evaluate_expression(root->right_child, fields___8);
    if (tmp___7) {
      tmp___8 = 1;
    } else {
      tmp___8 = 0;
    }
  } else {
    tmp___8 = 0;
  }
  return (tmp___8);
  case 5U:
  tmp___9 = evaluate_expression(root->left_child, fields___8);
  if (tmp___9) {
    tmp___11 = 1;
  } else {
    tmp___10 = evaluate_expression(root->right_child, fields___8);
    if (tmp___10) {
      tmp___11 = 1;
    } else {
      tmp___11 = 0;
    }
  }
  return (tmp___11);
  }
  return (0);
}
}
void print_expression(node_t *root )
{


  {
  if (! root) {
    return;
  }
  __printf_chk(1, (char const   * __restrict  )"%s", "( ");
  print_expression(root->left_child);
  switch ((unsigned int )root->type) {
  case 0U:
  __printf_chk(1, (char const   * __restrict  )" %i ", (unsigned int )root->value.op);
  break;
  case 1U:
  __printf_chk(1, (char const   * __restrict  )" (%s", root->value.field.fieldname);
  break;
  case 2U:
  __printf_chk(1, (char const   * __restrict  )"%s) ", root->value.string_literal);
  break;
  case 3U:
  __printf_chk(1, (char const   * __restrict  )" %llu) ", (unsigned long long )root->value.int_literal);
  break;
  default:
  break;
  }
  print_expression(root->right_child);
  __printf_chk(1, (char const   * __restrict  )"%s", " )");
  return;
}
}
#pragma merger("0","/tmp/cil-NIha7k2o.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
fieldset_t *fs_new_fieldset(fielddefset_t *fds ) ;
fieldset_t *fs_new_repeated_field(int type , int free_ ) ;
fieldset_t *fs_new_repeated_uint64(void) ;
fieldset_t *fs_new_repeated_bool(void) ;
fieldset_t *fs_new_repeated_string(int free_ ) ;
fieldset_t *fs_new_repeated_binary(int free_ ) ;
fieldset_t *fs_new_repeated_fieldset(void) ;
int fds_get_index_by_name(fielddefset_t *fds , char const   *name ) ;
void gen_fielddef_set(fielddefset_t *fds , fielddef_t *fs , int len ) ;
void fs_add_null(fieldset_t *fs , char const   *name ) ;
void fs_add_uint64(fieldset_t *fs , char const   *name , uint64_t value ) ;
void fs_add_bool(fieldset_t *fs , char const   *name , int value ) ;
void fs_add_string(fieldset_t *fs , char const   *name , char *value , int free_ ) ;
void fs_add_unsafe_string(fieldset_t *fs , char const   *name , char *value , int free_ ) ;
void fs_chkadd_string(fieldset_t *fs , char const   *name , char *value , int free_ ) ;
void fs_chkadd_unsafe_string(fieldset_t *fs , char const   *name , char *value , int free_ ) ;
void fs_add_constchar(fieldset_t *fs , char const   *name , char const   *value ) ;
void fs_add_binary(fieldset_t *fs , char const   *name , size_t len , void *value ,
                   int free_ ) ;
void fs_add_fieldset(fieldset_t *fs , char const   *name , fieldset_t *child ) ;
void fs_add_repeated(fieldset_t *fs , char const   *name , fieldset_t *child ) ;
void fs_modify_null(fieldset_t *fs , char const   *name ) ;
void fs_modify_uint64(fieldset_t *fs , char const   *name , uint64_t value ) ;
void fs_modify_bool(fieldset_t *fs , char const   *name , int value ) ;
void fs_modify_string(fieldset_t *fs , char const   *name , char *value , int free_ ) ;
void fs_modify_binary(fieldset_t *fs , char const   *name , size_t len , void *value ,
                      int free_ ) ;
void fs_free(fieldset_t *fs ) ;
void fs_generate_fieldset_translation(translation_t *t , fielddefset_t *avail , char const   **req ,
                                      int reqlen ) ;
fieldset_t *translate_fieldset(fieldset_t *fs , translation_t *t ) ;
void fs_generate_full_fieldset_translation(translation_t *t , fielddefset_t *avail ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wundef"
extern uint8_t const   *u8_check(uint8_t const   *s , size_t n )  __attribute__((__pure__)) ;
#pragma GCC diagnostic pop
extern int log_warn(char const   *loggerName , char const   *logMessage  , ...) ;
extern void *xcalloc(size_t count , size_t size ) ;
void gen_fielddef_set(fielddefset_t *fds , fielddef_t *fs , int len )
{
  fielddef_t *open ;

  {
  if (fds->len + len > 128) {
    log_fatal("fieldset", "out of room in field def set");
  }
  open = & fds->fielddefs[fds->len];
  memcpy((void * __restrict  )open, (void const   * __restrict  )fs, (unsigned long )len * sizeof(fielddef_t ));
  fds->len += len;
  return;
}
}
fieldset_t *fs_new_fieldset(fielddefset_t *fds )
{
  fieldset_t *f ;
  void *tmp ;

  {
  tmp = xcalloc((size_t )1, sizeof(fieldset_t ));
  f = (fieldset_t *)tmp;
  f->len = 0;
  f->type = 5;
  f->fds = fds;
  return (f);
}
}
fieldset_t *fs_new_repeated_field(int type , int free_ )
{
  fieldset_t *f ;
  void *tmp ;

  {
  tmp = xcalloc((size_t )1, sizeof(fieldset_t ));
  f = (fieldset_t *)tmp;
  f->len = 0;
  f->type = 6;
  f->inner_type = type;
  f->free_ = free_;
  return (f);
}
}
fieldset_t *fs_new_repeated_uint64(void)
{
  fieldset_t *tmp ;

  {
  tmp = fs_new_repeated_field(2, 0);
  return (tmp);
}
}
fieldset_t *fs_new_repeated_bool(void)
{
  fieldset_t *tmp ;

  {
  tmp = fs_new_repeated_field(7, 0);
  return (tmp);
}
}
fieldset_t *fs_new_repeated_string(int free_ )
{
  fieldset_t *tmp ;

  {
  tmp = fs_new_repeated_field(1, free_);
  return (tmp);
}
}
fieldset_t *fs_new_repeated_binary(int free_ )
{
  fieldset_t *tmp ;

  {
  tmp = fs_new_repeated_field(3, free_);
  return (tmp);
}
}
fieldset_t *fs_new_repeated_fieldset(void)
{
  fieldset_t *tmp ;

  {
  tmp = fs_new_repeated_field(5, 0);
  return (tmp);
}
}
__inline static void fs_add_word(fieldset_t *fs , char const   *name , int type ,
                                 int free_ , size_t len , field_val_t value )
{
  field_t *f ;
  int tmp ;

  {
  if (fs->len + 1 >= 128) {
    log_fatal("fieldset", "out of room in fieldset");
  }
  if (fs->type == 6) {
    if (fs->inner_type != type) {
      log_fatal("fieldset", "object added to repeated field does not match type of repeated field.");
    }
  }
  f = & fs->fields[fs->len];
  if (fs->fds) {
    tmp = strcmp((fs->fds)->fielddefs[fs->len].name, name);
    if (tmp) {
      log_fatal("fieldset", "added field (%s) is not next expected field (%s).", name,
                (fs->fds)->fielddefs[fs->len].name);
    }
  }
  (fs->len) ++;
  f->type = type;
  f->name = name;
  f->len = len;
  f->value = value;
  f->free_ = free_;
  return;
}
}
static void fs_modify_word(fieldset_t *fs , char const   *name , int type , int free_ ,
                           size_t len , field_val_t value )
{
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < fs->len) {
    tmp = strcmp(fs->fields[i].name, name);
    if (! tmp) {
      if (fs->fields[i].free_) {
        free(fs->fields[i].value.ptr);
        fs->fields[i].value.ptr = (void *)0;
      }
      fs->fields[i].type = type;
      fs->fields[i].free_ = free_;
      fs->fields[i].len = len;
      fs->fields[i].value = value;
      return;
    }
    i ++;
  }
  log_fatal("fs", "attempting to modify non-existent field");
}
}
static char *sanitize_utf8(char const   *buf )
{
  char const   *ptr ;
  uint32_t i ;
  size_t tmp ;
  uint8_t const   *tmp___0 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *safe_buf ;
  size_t tmp___8 ;
  void *tmp___9 ;
  char *safe_ptr ;
  size_t tmp___10 ;
  uint32_t j ;
  size_t tmp___11 ;
  uint8_t const   *tmp___12 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___25 ;
  uint8_t const   *tmp___26 ;
  size_t tmp___30 ;
  size_t tmp___36 ;
  size_t tmp___37 ;

  {
  ptr = buf;
  i = (uint32_t )0;
  while (1) {
    tmp___6 = strlen(buf);
    if ((size_t )i < tmp___6) {
      tmp___7 = strlen(buf);
      if (! ((unsigned long )ptr < (unsigned long )(buf + tmp___7))) {
        break;
      }
    } else {
      break;
    }
    tmp = strlen(ptr);
    tmp___0 = u8_check((uint8_t const   *)((uint8_t *)ptr), tmp);
    ptr = (char const   *)((char *)tmp___0);
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      break;
    }
    if (! ((unsigned long )ptr >= (unsigned long )buf)) {
      __assert_fail("ptr >= buf", "src/fieldset.c", 140U, "sanitize_utf8");
    }
    tmp___5 = strlen(buf);
    if (! ((unsigned long )ptr < (unsigned long )(buf + tmp___5))) {
      __assert_fail("ptr < buf + strlen(buf)", "src/fieldset.c", 141U, "sanitize_utf8");
    }
    ptr ++;
    i ++;
  }
  tmp___8 = strlen(buf);
  tmp___9 = xmalloc((tmp___8 + (size_t )(i * 2U)) + 1UL);
  safe_buf = (char *)tmp___9;
  safe_ptr = (char *)((void *)0);
  tmp___10 = strlen(buf);
  memcpy((void * __restrict  )safe_buf, (void const   * __restrict  )buf, tmp___10);
  j = (uint32_t )0;
  while (j < i) {
    tmp___11 = strlen((char const   *)safe_buf);
    tmp___12 = u8_check((uint8_t const   *)((uint8_t *)safe_buf), tmp___11);
    safe_ptr = (char *)tmp___12;
    if ((unsigned long )safe_ptr == (unsigned long )((void *)0)) {
      log_warn("fieldset", "UTF8 Sanitization issue. %u errors, fell through iter %u. Orig: %s new: %s",
               i, j, buf, safe_buf);
      i = j;
      break;
    }
    if (! ((unsigned long )safe_ptr >= (unsigned long )safe_buf)) {
      __assert_fail("safe_ptr >= safe_buf", "src/fieldset.c", 171U, "sanitize_utf8");
    }
    tmp___17 = strlen((char const   *)safe_buf);
    if (! ((unsigned long )safe_ptr < (unsigned long )(safe_buf + tmp___17))) {
      __assert_fail("safe_ptr < safe_buf + strlen(safe_buf)", "src/fieldset.c", 172U,
                    "sanitize_utf8");
    }
    tmp___19 = strlen((char const   *)safe_ptr);
    if (tmp___19 > 1UL) {
      tmp___18 = strlen((char const   *)(safe_ptr + 1));
      memcpy((void * __restrict  )(safe_ptr + 3), (void const   * __restrict  )(safe_ptr + 1),
             tmp___18);
    }
    *(safe_ptr + 0) = (char)-17;
    *(safe_ptr + 1) = (char)-65;
    *(safe_ptr + 2) = (char)-67;
    j ++;
  }
  tmp___25 = strlen((char const   *)safe_buf);
  tmp___26 = u8_check((uint8_t const   *)((uint8_t *)safe_buf), tmp___25);
  if (! ((unsigned long )tmp___26 == (unsigned long )((void *)0))) {
    __assert_fail("u8_check((uint8_t *)safe_buf, strlen(safe_buf)) == NULL", "src/fieldset.c",
                  187U, "sanitize_utf8");
  }
  tmp___30 = strlen(buf);
  if (! ((int )*(safe_buf + (tmp___30 + (size_t )(i * 2U))) == 0)) {
    __assert_fail("safe_buf[strlen(buf) + i * 2] == \'\\0\'", "src/fieldset.c", 189U,
                  "sanitize_utf8");
  }
  tmp___36 = strlen((char const   *)safe_buf);
  tmp___37 = strlen(buf);
  if (! (tmp___36 == tmp___37 + (size_t )(i * 2U))) {
    __assert_fail("strlen(safe_buf) == (strlen(buf) + i * 2)", "src/fieldset.c", 191U,
                  "sanitize_utf8");
  }
  return (safe_buf);
}
}
void fs_add_null(fieldset_t *fs , char const   *name )
{
  field_val_t val ;

  {
  val.ptr = (void *)0;
  fs_add_word(fs, name, 4, 0, (size_t )0, val);
  return;
}
}
void fs_add_string(fieldset_t *fs , char const   *name , char *value , int free_ )
{
  field_val_t val ;
  size_t tmp ;

  {
  val.ptr = (void *)value;
  tmp = strlen((char const   *)value);
  fs_add_word(fs, name, 1, free_, tmp, val);
  return;
}
}
void fs_add_unsafe_string(fieldset_t *fs , char const   *name , char *value , int free_ )
{
  field_val_t val ;
  size_t tmp ;
  char *safe_value ;
  char *tmp___0 ;
  field_val_t val___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  uint8_t const   *tmp___3 ;

  {
  tmp___2 = strlen((char const   *)value);
  tmp___3 = u8_check((uint8_t const   *)((uint8_t *)value), tmp___2);
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    val.ptr = (void *)value;
    tmp = strlen((char const   *)value);
    fs_add_word(fs, name, 1, free_, tmp, val);
  } else {
    tmp___0 = sanitize_utf8((char const   *)value);
    safe_value = tmp___0;
    if (free_) {
      free((void *)value);
    }
    val___0.ptr = (void *)safe_value;
    tmp___1 = strlen((char const   *)safe_value);
    fs_add_word(fs, name, 1, 1, tmp___1, val___0);
  }
  return;
}
}
void fs_chkadd_string(fieldset_t *fs , char const   *name , char *value , int free_ )
{


  {
  if (value) {
    fs_add_string(fs, name, value, free_);
  } else {
    fs_add_null(fs, name);
  }
  return;
}
}
void fs_chkadd_unsafe_string(fieldset_t *fs , char const   *name , char *value , int free_ )
{


  {
  if (value) {
    fs_add_unsafe_string(fs, name, value, free_);
  } else {
    fs_add_null(fs, name);
  }
  return;
}
}
void fs_add_constchar(fieldset_t *fs , char const   *name , char const   *value )
{
  field_val_t val ;
  size_t tmp ;

  {
  val.ptr = (void *)((char *)value);
  tmp = strlen(value);
  fs_add_word(fs, name, 1, 0, tmp, val);
  return;
}
}
void fs_add_uint64(fieldset_t *fs , char const   *name , uint64_t value )
{
  field_val_t val ;

  {
  val.num = value;
  fs_add_word(fs, name, 2, 0, sizeof(uint64_t ), val);
  return;
}
}
void fs_add_bool(fieldset_t *fs , char const   *name , int value )
{
  field_val_t val ;

  {
  val.num = (uint64_t )value;
  fs_add_word(fs, name, 7, 0, sizeof(int ), val);
  return;
}
}
void fs_add_binary(fieldset_t *fs , char const   *name , size_t len , void *value ,
                   int free_ )
{
  field_val_t val ;

  {
  val.ptr = value;
  fs_add_word(fs, name, 3, free_, len, val);
  return;
}
}
void fs_add_fieldset(fieldset_t *fs , char const   *name , fieldset_t *child )
{
  field_val_t val ;

  {
  val.ptr = (void *)child;
  fs_add_word(fs, name, 5, 1, sizeof(void *), val);
  return;
}
}
void fs_add_repeated(fieldset_t *fs , char const   *name , fieldset_t *child )
{
  field_val_t val ;

  {
  val.ptr = (void *)child;
  fs_add_word(fs, name, 6, 1, sizeof(void *), val);
  return;
}
}
void fs_modify_null(fieldset_t *fs , char const   *name )
{
  field_val_t val ;

  {
  val.ptr = (void *)0;
  fs_modify_word(fs, name, 4, 0, (size_t )0, val);
  return;
}
}
void fs_modify_string(fieldset_t *fs , char const   *name , char *value , int free_ )
{
  field_val_t val ;
  size_t tmp ;

  {
  val.ptr = (void *)value;
  tmp = strlen((char const   *)value);
  fs_modify_word(fs, name, 1, free_, tmp, val);
  return;
}
}
void fs_modify_constchar(fieldset_t *fs , char const   *name , char const   *value )
{
  field_val_t val ;
  size_t tmp ;

  {
  val.ptr = (void *)((char *)value);
  tmp = strlen(value);
  fs_modify_word(fs, name, 1, 0, tmp, val);
  return;
}
}
void fs_modify_uint64(fieldset_t *fs , char const   *name , uint64_t value )
{
  field_val_t val ;

  {
  val.num = value;
  fs_modify_word(fs, name, 2, 0, sizeof(uint64_t ), val);
  return;
}
}
void fs_modify_bool(fieldset_t *fs , char const   *name , int value )
{
  field_val_t val ;

  {
  val.num = (uint64_t )value;
  fs_modify_word(fs, name, 7, 0, sizeof(int ), val);
  return;
}
}
void fs_modify_binary(fieldset_t *fs , char const   *name , size_t len , void *value ,
                      int free_ )
{
  field_val_t val ;

  {
  val.ptr = value;
  fs_modify_word(fs, name, 3, free_, len, val);
  return;
}
}
uint64_t fs_get_uint64_by_index(fieldset_t *fs , int index___0 )
{


  {
  return (fs->fields[index___0].value.num);
}
}
char *fs_get_string_by_index(fieldset_t *fs , int index___0 )
{


  {
  return ((char *)fs->fields[index___0].value.ptr);
}
}
int fds_get_index_by_name(fielddefset_t *fds , char const   *name )
{
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < fds->len) {
    tmp = strcmp(fds->fielddefs[i].name, name);
    if (! tmp) {
      return (i);
    }
    i ++;
  }
  return (-1);
}
}
void field_free(field_t *f )
{


  {
  if (f->type == 5) {
    fs_free((fieldset_t *)f->value.ptr);
  } else
  if (f->type == 6) {
    fs_free((fieldset_t *)f->value.ptr);
  } else
  if (f->free_) {
    free(f->value.ptr);
  }
  return;
}
}
void fs_free(fieldset_t *fs )
{
  int i ;
  field_t *f ;

  {
  if (! fs) {
    return;
  }
  i = 0;
  while (i < fs->len) {
    f = & fs->fields[i];
    field_free(f);
    i ++;
  }
  free((void *)fs);
  return;
}
}
void fs_generate_fieldset_translation(translation_t *t , fielddefset_t *avail , char const   **req ,
                                      int reqlen )
{
  int i ;
  int l ;
  int tmp ;
  int tmp___0 ;

  {
  memset((void *)t, 0, sizeof(translation_t ));
  if (! t) {
    log_fatal("fieldset", "unable to allocate memory for translation");
  }
  i = 0;
  while (i < reqlen) {
    tmp = fds_get_index_by_name(avail, *(req + i));
    l = tmp;
    if (l < 0) {
      log_fatal("fieldset", "specified field (%s) not available in selected probe module.",
                *(req + i));
    }
    tmp___0 = t->len;
    (t->len) ++;
    t->translation[tmp___0] = l;
    i ++;
  }
  return;
}
}
void fs_generate_full_fieldset_translation(translation_t *t , fielddefset_t *avail )
{
  int i ;

  {
  memset((void *)t, 0, sizeof(translation_t ));
  if (! t) {
    log_fatal("fieldset", "unable to allocate memory for translation");
  }
  t->len = avail->len;
  i = 0;
  while (i < avail->len) {
    t->translation[i] = i;
    i ++;
  }
  return;
}
}
fieldset_t *translate_fieldset(fieldset_t *fs , translation_t *t )
{
  fieldset_t *retv ;
  fieldset_t *tmp ;
  int i ;
  int o ;

  {
  tmp = fs_new_fieldset((fielddefset_t *)((void *)0));
  retv = tmp;
  if (! retv) {
    log_fatal("fieldset", "unable to allocate space for translated field set");
  }
  i = 0;
  while (i < t->len) {
    o = t->translation[i];
    memcpy((void * __restrict  )(& retv->fields[i]), (void const   * __restrict  )(& fs->fields[o]),
           sizeof(field_t ));
    i ++;
  }
  retv->len = t->len;
  return (retv);
}
}
#pragma merger("0","/tmp/cil-53gPEEIt.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern FILE *stderr ;
extern int __fprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format
                         , ...) ;
int parse_filter_string(char *filter ) ;
int validate_filter(node_t *root , fielddefset_t *fields___8 ) ;
struct state_conf zconf ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1))) __strtol_internal)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                    int __base , int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                      char ** __restrict  endptr ,
                                                                      int base )
{
  long tmp ;

  {
  tmp = __strtol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__warn_unused_result__,
__nonnull__(1))) __strtoul_internal)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                     int __base , int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                       char ** __restrict  endptr ,
                                                                       int base )
{
  unsigned long tmp ;

  {
  tmp = __strtoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1))) __wcstol_internal)(__gwchar_t const   * __restrict  __nptr , __gwchar_t ** __restrict  __endptr ,
                                    int __base , int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                      __gwchar_t ** __restrict  endptr ,
                                                                      int base )
{
  long tmp ;

  {
  tmp = __wcstol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__warn_unused_result__,
__nonnull__(1))) __wcstoul_internal)(__gwchar_t const   * __restrict  __nptr , __gwchar_t ** __restrict  __endptr ,
                                     int __base , int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                       __gwchar_t ** __restrict  endptr ,
                                                                       int base )
{
  unsigned long tmp ;

  {
  tmp = __wcstoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes ) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __gnu_inline__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen ) ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __gnu_inline__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                char * __restrict  __buf ,
                                                                size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __gnu_inline__, __always_inline__)) readlinkat)(int __fd , char const   * __restrict  __path ,
                                                                  char * __restrict  __buf ,
                                                                  size_t __len ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk)(int __fd , void *__buf ,
                                                                     size_t __nbytes ,
                                                                     size_t __buflen ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_alias)(int __fd ,
                                                                       void *__buf ,
                                                                       size_t __nbytes )  __asm__("read")  ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk_warn)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          size_t __buflen )  __asm__("__read_chk")  ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size(__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __read_chk(__fd, __buf, __nbytes, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size(__buf, 0);
    if (__nbytes > tmp___3) {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __read_chk_warn(__fd, __buf, __nbytes, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __read_alias(__fd, __buf, __nbytes);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2))) __readlink_chk)(char const   * __restrict  __path , char * __restrict  __buf ,
                                   size_t __len , size_t __buflen ) ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2))) __readlink_alias)(char const   * __restrict  __path , char * __restrict  __buf ,
                                     size_t __len )  __asm__("readlink")  ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2))) __readlink_chk_warn)(char const   * __restrict  __path , char * __restrict  __buf ,
                                        size_t __len , size_t __buflen )  __asm__("__readlink_chk")  ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __gnu_inline__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                char * __restrict  __buf ,
                                                                size_t __len ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__gnu_inline__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                              char * __restrict  __buf , size_t __len )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __readlink_chk(__path, __buf, __len, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__len > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __readlink_chk_warn(__path, __buf, __len, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __readlink_alias(__path, __buf, __len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3))) __readlinkat_chk)(int __fd , char const   * __restrict  __path ,
                                     char * __restrict  __buf , size_t __len , size_t __buflen ) ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3))) __readlinkat_alias)(int __fd , char const   * __restrict  __path ,
                                       char * __restrict  __buf , size_t __len )  __asm__("readlinkat")  ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3))) __readlinkat_chk_warn)(int __fd , char const   * __restrict  __path ,
                                          char * __restrict  __buf , size_t __len ,
                                          size_t __buflen )  __asm__("__readlinkat_chk")  ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __gnu_inline__, __always_inline__)) readlinkat)(int __fd , char const   * __restrict  __path ,
                                                                  char * __restrict  __buf ,
                                                                  size_t __len ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__gnu_inline__, __always_inline__)) readlinkat)(int __fd , char const   * __restrict  __path ,
                                                char * __restrict  __buf , size_t __len )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __readlinkat_chk(__fd, __path, __buf, __len, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__len > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __readlinkat_chk_warn(__fd, __path, __buf, __len, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __readlinkat_alias(__fd, __path, __buf, __len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__)) __getcwd_chk)(char *__buf ,
                                                                                                   size_t __size ,
                                                                                                   size_t __buflen ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__)) __getcwd_alias)(char *__buf ,
                                                                                                     size_t __size )  __asm__("getcwd")  ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__)) __getcwd_chk_warn)(char *__buf ,
                                                                                                        size_t __size ,
                                                                                                        size_t __buflen )  __asm__("__getcwd_chk")  ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) getcwd)(char *__buf ,
                                                                                                           size_t __size )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getcwd_chk(__buf, __size, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__size > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getcwd_chk_warn(__buf, __size, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __getcwd_alias(__buf, __size);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getwd_chk)(char *__buf , size_t buflen ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getwd_warn)(char *__buf )  __asm__("getwd")  ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__, __always_inline__)) getwd)(char *__buf )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__buf, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getwd_chk(__buf, tmp);
    return ((char __attribute__((__deprecated__))  *)tmp___0);
  }
  tmp___2 = __getwd_warn(__buf);
  return ((char __attribute__((__deprecated__))  *)tmp___2);
}
}
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len )  __asm__("confstr")  ;
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen )  __asm__("__confstr_chk")  ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
__inline extern size_t ( __attribute__((__gnu_inline__, __always_inline__)) confstr)(int __name ,
                                                                                     char *__buf ,
                                                                                     size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __confstr_chk(__name, __buf, __len, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (tmp___3 < __len) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __confstr_chk_warn(__name, __buf, __len, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __confstr_alias(__name, __buf, __len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) __getgroups_chk)(int __size ,
                                                                                                    __gid_t *__list ,
                                                                                                    size_t __listlen ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) __getgroups_alias)(int __size ,
                                                                                                      __gid_t *__list )  __asm__("getgroups")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) __getgroups_chk_warn)(int __size ,
                                                                                                         __gid_t *__list ,
                                                                                                         size_t __listlen )  __asm__("__getgroups_chk")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) getgroups)(int __size ,
                                                                                                            __gid_t *__list )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__list, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__list, 1);
    tmp___0 = __getgroups_chk(__size, __list, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__list, 1);
    if ((unsigned long )__size * sizeof(__gid_t ) > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__list, 1);
      tmp___2 = __getgroups_chk_warn(__size, __list, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __getgroups_alias(__size, __list);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ttyname_r_chk)(int __fd ,
                                                                                            char *__buf ,
                                                                                            size_t __buflen ,
                                                                                            size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ttyname_r_alias)(int __fd ,
                                                                                              char *__buf ,
                                                                                              size_t __buflen )  __asm__("ttyname_r")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ttyname_r_chk_warn)(int __fd ,
                                                                                                 char *__buf ,
                                                                                                 size_t __buflen ,
                                                                                                 size_t __nreal )  __asm__("__ttyname_r_chk")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __gnu_inline__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __gnu_inline__,
__always_inline__)) ttyname_r)(int __fd , char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __ttyname_r_chk(__fd, __buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __ttyname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __ttyname_r_alias(__fd, __buf, __buflen);
  return (tmp___5);
}
}
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk)(char *__buf , size_t __buflen ,
                                                               size_t __nreal ) ;
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_alias)(char *__buf , size_t __buflen )  __asm__("getlogin_r")  ;
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk_warn)(char *__buf ,
                                                                    size_t __buflen ,
                                                                    size_t __nreal )  __asm__("__getlogin_r_chk")  ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getlogin_r_chk(__buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getlogin_r_chk_warn(__buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __getlogin_r_alias(__buf, __buflen);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) __gethostname_chk)(char *__buf ,
                                                                                              size_t __buflen ,
                                                                                              size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) __gethostname_alias)(char *__buf ,
                                                                                                size_t __buflen )  __asm__("gethostname")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) __gethostname_chk_warn)(char *__buf ,
                                                                                                   size_t __buflen ,
                                                                                                   size_t __nreal )  __asm__("__gethostname_chk")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __always_inline__)) gethostname)(char *__buf ,
                                                                                                      size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __gethostname_chk(__buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __gethostname_chk_warn(__buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __gethostname_alias(__buf, __buflen);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getdomainname_chk)(char *__buf , size_t __buflen , size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getdomainname_alias)(char *__buf , size_t __buflen )  __asm__("getdomainname")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getdomainname_chk_warn)(char *__buf , size_t __buflen , size_t __nreal )  __asm__("__getdomainname_chk")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __gnu_inline__,
__always_inline__)) getdomainname)(char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getdomainname_chk(__buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getdomainname_chk_warn(__buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __getdomainname_alias(__buf, __buflen);
  return (tmp___5);
}
}
extern int log_error(char const   *loggerName , char const   *logMessage  , ...) ;
int yyparse(void) ;
node_t *zfilter  ;
static int validate_node(node_t *node , fielddefset_t *fields___8 )
{
  int index___0 ;
  int found ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  found = 0;
  if ((unsigned int )node->type == 0U) {
    if ((unsigned int )node->value.op == 4U) {
      return (1);
    } else
    if ((unsigned int )node->value.op == 5U) {
      return (1);
    }
    index___0 = 0;
    while (index___0 < fields___8->len) {
      if (fields___8->fielddefs[index___0].name) {
        tmp = strcmp(fields___8->fielddefs[index___0].name, (char const   *)(node->left_child)->value.field.fieldname);
        if (tmp == 0) {
          (node->left_child)->value.field.index = index___0;
          found = 1;
          break;
        }
      }
      index___0 ++;
    }
    if (! found) {
      __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"Field \'%s\' does not exist\n",
                    (node->left_child)->value.field.fieldname);
      return (0);
    }
    switch ((unsigned int )(node->right_child)->type) {
    case 2U:
    tmp___0 = strcmp(fields___8->fielddefs[index___0].type, "string");
    if (tmp___0 == 0) {
      return (1);
    } else {
      __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"Field \'%s\' is not of type \'string\'\n",
                    fields___8->fielddefs[index___0].name);
      return (0);
    }
    case 3U:
    tmp___1 = strcmp(fields___8->fielddefs[index___0].type, "int");
    if (tmp___1 == 0) {
      return (1);
    } else {
      tmp___2 = strcmp(fields___8->fielddefs[index___0].type, "bool");
      if (tmp___2 == 0) {
        return (1);
      } else {
        __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"Field \'%s\' is not of type \'int\'\n",
                      fields___8->fielddefs[index___0].name);
        return (0);
      }
    }
    default:
    return (0);
    }
  } else {
    return (1);
  }
  return (0);
}
}
int parse_filter_string(char *filter )
{
  YY_BUFFER_STATE buffer_state ;
  YY_BUFFER_STATE tmp ;
  int status ;
  int tmp___0 ;

  {
  tmp = yy_scan_string((char const   *)filter);
  buffer_state = tmp;
  tmp___0 = yyparse();
  status = tmp___0;
  yy_delete_buffer(buffer_state);
  if (status) {
    log_error("zmap", "Unable to parse filter string: \'%s\'", filter);
    return (0);
  }
  zconf.filter.expression = zfilter;
  return (1);
}
}
int validate_filter(node_t *root , fielddefset_t *fields___8 )
{
  int valid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! root) {
    return (1);
  }
  valid = validate_node(root, fields___8);
  if (! valid) {
    return (0);
  }
  tmp = validate_filter(root->left_child, fields___8);
  if (tmp) {
    tmp___0 = validate_filter(root->right_child, fields___8);
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
#pragma merger("0","/tmp/cil-HBUqLQmk.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern int close(int __fd ) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
extern char *pcap_lookupdev(char * )  __attribute__((__deprecated__("use \'pcap_findalldevs\' and use the first device"))) ;
extern  __attribute__((__nothrow__)) unsigned int if_nametoindex(char const   *__ifname ) ;
extern  __attribute__((__nothrow__)) char *if_indextoname(unsigned int __ifindex ,
                                                          char *__ifname ) ;
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request
                                               , ...) ;
char *get_default_iface(void)
{
  char errbuf[256] ;
  char *iface ;
  char *tmp ;

  {
  tmp = pcap_lookupdev(errbuf);
  iface = tmp;
  if ((unsigned long )iface == (unsigned long )((void *)0)) {
    log_fatal("send", "ZMap could not detect your default network interface. You likely do not privileges to open a raw packet socket. Are you running as root or with the CAP_NET_RAW capability? If you are, you may need to manually set interface using the \"-i\" flag.");
  }
  return (iface);
}
}
int read_nl_sock(int sock , char *buf , int buf_len )
{
  int msg_len ;
  char *pbuf ;
  int len ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  struct nlmsghdr *nlhdr ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  msg_len = 0;
  pbuf = buf;
  while (1) {
    tmp = recv(sock, (void *)pbuf, (size_t )(buf_len - msg_len), 0);
    len = (int )tmp;
    if (len <= 0) {
      tmp___0 = __errno_location();
      tmp___1 = strerror(*tmp___0);
      log_debug("get-gw", "recv failed: %s", tmp___1);
      return (-1);
    }
    nlhdr = (struct nlmsghdr *)pbuf;
    if ((unsigned int )len >= (unsigned int )((int )sizeof(struct nlmsghdr ))) {
      if ((unsigned long )nlhdr->nlmsg_len >= sizeof(struct nlmsghdr )) {
        if (nlhdr->nlmsg_len <= (unsigned int )len) {
          tmp___4 = 1;
        } else {
          tmp___4 = 0;
        }
      } else {
        tmp___4 = 0;
      }
    } else {
      tmp___4 = 0;
    }
    if (tmp___4 == 0) {
      tmp___2 = __errno_location();
      tmp___3 = strerror(*tmp___2);
      log_debug("get-gw", "recv failed: %s", tmp___3);
      return (-1);
    } else
    if ((int )nlhdr->nlmsg_type == 2) {
      tmp___2 = __errno_location();
      tmp___3 = strerror(*tmp___2);
      log_debug("get-gw", "recv failed: %s", tmp___3);
      return (-1);
    }
    if ((int )nlhdr->nlmsg_type == 3) {
      break;
    } else {
      msg_len += len;
      pbuf += len;
    }
    if (((int )nlhdr->nlmsg_flags & 2) == 0) {
      break;
    }
  }
  return (msg_len);
}
}
int send_nl_req(uint16_t msg_type , uint32_t seq , void *payload , uint32_t payload_len )
{
  int sock ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  struct nlmsghdr *nlmsg ;
  void *tmp___2 ;
  __pid_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  ssize_t tmp___6 ;

  {
  tmp = socket(16, 2, 0);
  sock = tmp;
  if (sock < 0) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    log_error("get-gw", "unable to get socket: %s", tmp___1);
    return (-1);
  }
  if (((((payload_len + (uint32_t )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))) + 4U) - 1U) & 4294967292U) < payload_len) {
    close(sock);
    return (-1);
  }
  tmp___2 = xmalloc((size_t )((((payload_len + (uint32_t )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))) + 4U) - 1U) & 4294967292U));
  nlmsg = (struct nlmsghdr *)tmp___2;
  memset((void *)nlmsg, 0, (size_t )((((payload_len + (uint32_t )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))) + 4U) - 1U) & 4294967292U));
  memcpy((void * __restrict  )((void *)((char *)nlmsg + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))),
         (void const   * __restrict  )payload, (size_t )payload_len);
  nlmsg->nlmsg_type = msg_type;
  nlmsg->nlmsg_len = payload_len + (uint32_t )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL));
  nlmsg->nlmsg_flags = (__u16 )769;
  nlmsg->nlmsg_seq = seq;
  tmp___3 = getpid();
  nlmsg->nlmsg_pid = (__u32 )tmp___3;
  tmp___6 = send(sock, (void const   *)nlmsg, (size_t )nlmsg->nlmsg_len, 0);
  if (tmp___6 < 0L) {
    tmp___4 = __errno_location();
    tmp___5 = strerror(*tmp___4);
    log_error("get-gw", "failure sending: %s", tmp___5);
    return (-1);
  }
  free((void *)nlmsg);
  return (sock);
}
}
int get_hw_addr(struct in_addr *gw_ip , char *iface , unsigned char *hw_mac )
{
  struct ndmsg req ;
  unsigned int tmp ;
  int sock ;
  int tmp___0 ;
  char *buf ;
  void *tmp___1 ;
  int nl_len ;
  int tmp___2 ;
  struct nlmsghdr *nlhdr ;
  struct rtattr *rt_attr ;
  struct rtmsg *rt_msg ;
  int rt_len ;
  unsigned char mac[6] ;
  struct in_addr dst_ip ;
  int correct_ip ;
  int tmp___3 ;

  {
  memset((void *)(& req), 0, sizeof(struct ndmsg ));
  if (! gw_ip) {
    return (-1);
  } else
  if (! hw_mac) {
    return (-1);
  }
  req.ndm_family = (__u8 )2;
  tmp = if_nametoindex((char const   *)iface);
  req.ndm_ifindex = (__s32 )tmp;
  req.ndm_state = (__u16 )2;
  req.ndm_type = (__u8 )2;
  tmp___0 = send_nl_req((uint16_t )30, (uint32_t )1, (void *)(& req), (uint32_t )sizeof(req));
  sock = tmp___0;
  tmp___1 = xmalloc((size_t )64000);
  buf = (char *)tmp___1;
  tmp___2 = read_nl_sock(sock, buf, 64000);
  nl_len = tmp___2;
  if (nl_len <= 0) {
    free((void *)buf);
    return (-1);
  }
  nlhdr = (struct nlmsghdr *)buf;
  while (1) {
    if (nl_len >= (int )sizeof(struct nlmsghdr )) {
      if ((unsigned long )nlhdr->nlmsg_len >= sizeof(struct nlmsghdr )) {
        if (! (nlhdr->nlmsg_len <= (__u32 )nl_len)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    correct_ip = 0;
    rt_msg = (struct rtmsg *)((void *)((char *)nlhdr + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
    if ((int )rt_msg->rtm_family != 2) {
      free((void *)buf);
      return (-1);
    }
    rt_attr = (struct rtattr *)((char *)rt_msg + (((sizeof(struct rtmsg ) + 4UL) - 1UL) & 4294967292UL));
    rt_len = (int )((unsigned long )nlhdr->nlmsg_len - ((((sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))) + 4UL) - 1UL) & 4294967292UL));
    while (1) {
      if (rt_len >= (int )sizeof(struct rtattr )) {
        if ((unsigned long )rt_attr->rta_len >= sizeof(struct rtattr )) {
          if (! ((int )rt_attr->rta_len <= rt_len)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      switch ((int )rt_attr->rta_type) {
      case 2:
      if ((unsigned long )((int )rt_attr->rta_len) - (((sizeof(struct rtattr ) + 4UL) - 1UL) & 4294967292UL) != 6UL) {
        log_fatal("get_gateway", "Unexpected hardware address length (%d). If you are using a VPN, supply the --iplayer flag (and provide an interface via -i)",
                  (unsigned long )((int )rt_attr->rta_len) - (((sizeof(struct rtattr ) + 4UL) - 1UL) & 4294967292UL));
      }
      memcpy((void * __restrict  )(mac), (void const   * __restrict  )((void *)((char *)rt_attr + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 4294967292UL))),
             (size_t )6);
      break;
      case 1:
      if ((unsigned long )((int )rt_attr->rta_len) - (((sizeof(struct rtattr ) + 4UL) - 1UL) & 4294967292UL) != sizeof(dst_ip)) {
        log_fatal("get_gateway", "Unexpected IP address length (%d). If you are using a VPN, supply the --iplayer flag (and provide an interface via -i)",
                  (unsigned long )((int )rt_attr->rta_len) - (((sizeof(struct rtattr ) + 4UL) - 1UL) & 4294967292UL));
      }
      memcpy((void * __restrict  )(& dst_ip), (void const   * __restrict  )((void *)((char *)rt_attr + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 4294967292UL))),
             sizeof(dst_ip));
      tmp___3 = memcmp((void const   *)(& dst_ip), (void const   *)gw_ip, sizeof(dst_ip));
      if (tmp___3 == 0) {
        correct_ip = 1;
      }
      break;
      }
      rt_len = (int )((unsigned int )rt_len - ((((unsigned int )rt_attr->rta_len + 4U) - 1U) & 4294967292U));
      rt_attr = (struct rtattr *)((char *)rt_attr + ((((unsigned int )rt_attr->rta_len + 4U) - 1U) & 4294967292U));
    }
    if (correct_ip) {
      memcpy((void * __restrict  )hw_mac, (void const   * __restrict  )(mac), (size_t )6);
      free((void *)buf);
      return (0);
    }
    nl_len = (int )((unsigned int )nl_len - (((nlhdr->nlmsg_len + 4U) - 1U) & 4294967292U));
    nlhdr = (struct nlmsghdr *)((char *)nlhdr + (((nlhdr->nlmsg_len + 4U) - 1U) & 4294967292U));
  }
  free((void *)buf);
  return (-1);
}
}
int _get_default_gw(struct in_addr *gw , char *iface )
{
  struct rtmsg req ;
  unsigned int nl_len ;
  char buf[8192] ;
  struct nlmsghdr *nlhdr ;
  int sock ;
  int tmp ;
  int tmp___0 ;
  struct rtattr *rt_attr ;
  struct rtmsg *rt_msg ;
  int rt_len ;
  int has_gw ;

  {
  if (! gw) {
    return (-1);
  } else
  if (! iface) {
    return (-1);
  }
  memset((void *)(& req), 0, sizeof(req));
  tmp = send_nl_req((uint16_t )26, (uint32_t )0, (void *)(& req), (uint32_t )sizeof(req));
  sock = tmp;
  tmp___0 = read_nl_sock(sock, buf, (int )sizeof(buf));
  nl_len = (unsigned int )tmp___0;
  if (nl_len <= 0U) {
    return (-1);
  }
  nlhdr = (struct nlmsghdr *)(buf);
  while (1) {
    if (nl_len >= (unsigned int )((int )sizeof(struct nlmsghdr ))) {
      if ((unsigned long )nlhdr->nlmsg_len >= sizeof(struct nlmsghdr )) {
        if (! (nlhdr->nlmsg_len <= nl_len)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    has_gw = 0;
    rt_msg = (struct rtmsg *)((void *)((char *)nlhdr + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
    if ((int )rt_msg->rtm_family != 2) {
      nl_len -= ((nlhdr->nlmsg_len + 4U) - 1U) & 4294967292U;
      nlhdr = (struct nlmsghdr *)((char *)nlhdr + (((nlhdr->nlmsg_len + 4U) - 1U) & 4294967292U));
      continue;
    } else
    if ((int )rt_msg->rtm_table != 254) {
      nl_len -= ((nlhdr->nlmsg_len + 4U) - 1U) & 4294967292U;
      nlhdr = (struct nlmsghdr *)((char *)nlhdr + (((nlhdr->nlmsg_len + 4U) - 1U) & 4294967292U));
      continue;
    }
    rt_attr = (struct rtattr *)((char *)rt_msg + (((sizeof(struct rtmsg ) + 4UL) - 1UL) & 4294967292UL));
    rt_len = (int )((unsigned long )nlhdr->nlmsg_len - ((((sizeof(struct rtmsg ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))) + 4UL) - 1UL) & 4294967292UL));
    while (1) {
      if (rt_len >= (int )sizeof(struct rtattr )) {
        if ((unsigned long )rt_attr->rta_len >= sizeof(struct rtattr )) {
          if (! ((int )rt_attr->rta_len <= rt_len)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      switch ((int )rt_attr->rta_type) {
      case 4:
      if_indextoname((unsigned int )*((int *)((void *)((char *)rt_attr + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 4294967292UL)))),
                     iface);
      break;
      case 5:
      gw->s_addr = *((unsigned int *)((void *)((char *)rt_attr + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 4294967292UL))));
      has_gw = 1;
      break;
      }
      rt_len = (int )((unsigned int )rt_len - ((((unsigned int )rt_attr->rta_len + 4U) - 1U) & 4294967292U));
      rt_attr = (struct rtattr *)((char *)rt_attr + ((((unsigned int )rt_attr->rta_len + 4U) - 1U) & 4294967292U));
    }
    if (has_gw) {
      return (0);
    }
    nl_len -= ((nlhdr->nlmsg_len + 4U) - 1U) & 4294967292U;
    nlhdr = (struct nlmsghdr *)((char *)nlhdr + (((nlhdr->nlmsg_len + 4U) - 1U) & 4294967292U));
  }
  return (-1);
}
}
int get_default_gw(struct in_addr *gw , char *iface )
{
  char _iface[16] ;
  int tmp ;

  {
  memset((void *)(_iface), 0, (size_t )16);
  _get_default_gw(gw, _iface);
  tmp = strcmp((char const   *)iface, (char const   *)(_iface));
  if (tmp) {
    log_fatal("get-gateway", "The specified network (\"%s\") does not match the interface associated with the default gateway (%s). You will need to manually specify the MAC address of your gateway using the \"--gateway-mac\" flag.",
              iface, _iface);
  }
  return (0);
}
}
int get_iface_ip(char *iface , struct in_addr *ip )
{
  int sock ;
  struct ifreq ifr ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  memset((void *)(& ifr), 0, sizeof(struct ifreq ));
  sock = socket(2, 2, 0);
  if (sock < 0) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    log_fatal("get-iface-ip", "failure opening socket: %s", tmp___0);
  }
  ifr.ifr_ifru.ifru_addr.sa_family = (sa_family_t )2;
  strncpy((char * __restrict  )(ifr.ifr_ifrn.ifrn_name), (char const   * __restrict  )iface,
          (size_t )15);
  tmp___3 = ioctl(sock, 35093UL, & ifr);
  if (tmp___3 < 0) {
    close(sock);
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    log_fatal("get-iface-ip", "Unable to automatically identify the correct source address for %s interface. ioctl failure: %s. If this is the unexpected interface, you can manually specify the correct interface with \"-i\" flag. If this is the correct interface, you likely need to manually specify the source IP address to use with the \"-S\" flag.",
              iface, tmp___2);
  }
  ip->s_addr = ((struct sockaddr_in *)(& ifr.ifr_ifru.ifru_addr))->sin_addr.s_addr;
  close(sock);
  return (0);
}
}
int get_iface_hw_addr(char *iface , unsigned char *hw_mac )
{
  int s ;
  struct ifreq buffer ;
  int *tmp ;
  char *tmp___0 ;

  {
  s = socket(2, 2, 0);
  if (s < 0) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    log_error("get_iface_hw_addr", "Unable to open socket: %s", tmp___0);
    return (1);
  }
  memset((void *)(& buffer), 0, sizeof(buffer));
  strncpy((char * __restrict  )(buffer.ifr_ifrn.ifrn_name), (char const   * __restrict  )iface,
          (size_t )16);
  ioctl(s, 35111UL, & buffer);
  close(s);
  memcpy((void * __restrict  )hw_mac, (void const   * __restrict  )(buffer.ifr_ifru.ifru_hwaddr.sa_data),
         (size_t )6);
  return (0);
}
}
#pragma merger("0","/tmp/cil-svk8VCnn.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 )
{


  {
  return (__thread1 == __thread2);
}
}
extern uint64_t blocklist_count_allowed() ;
extern double now() ;
void shard_init(shard_t *shard , uint16_t shard_idx , uint16_t num_shards , uint8_t thread_idx ,
                uint8_t num_threads , uint32_t max_total_targets , cycle_t const   *cycle ,
                void (*cb)(uint8_t id , void *arg ) , void *arg ) ;
iterator_t *iterator_init(uint8_t num_threads , uint16_t shard , uint16_t num_shards ) ;
uint64_t iterator_get_sent(iterator_t *it ) ;
uint64_t iterator_get_iterations(iterator_t *it ) ;
uint32_t iterator_get_fail(iterator_t *it ) ;
uint32_t iterator_get_curr_send_threads(iterator_t *it ) ;
shard_t *get_shard(iterator_t *it , uint8_t thread_id ) ;
struct state_send zsend ;
void shard_complete(uint8_t thread_id , void *arg )
{
  iterator_t *it ;
  shard_t *s ;
  uint8_t done ;
  uint8_t i ;
  int tmp___0 ;

  {
  it = (iterator_t *)arg;
  if (! ((int )thread_id < (int )it->num_threads)) {
    __assert_fail("thread_id < it->num_threads", "src/iterator.c", 37U, "shard_complete");
  }
  pthread_mutex_lock(& it->mutex);
  *(it->complete + thread_id) = (uint8_t )1;
  (it->curr_threads) --;
  s = it->thread_shards + thread_id;
  zsend.packets_sent += s->state.packets_sent;
  zsend.hosts_scanned += (uint64_t )s->state.hosts_scanned;
  zsend.blocklisted += (uint64_t )s->state.hosts_blocklisted;
  zsend.allowlisted += (uint64_t )s->state.hosts_allowlisted;
  zsend.sendto_failures += s->state.packets_failed;
  done = (uint8_t )1;
  i = (uint8_t )0;
  while (1) {
    if (done) {
      if (! ((int )i < (int )it->num_threads)) {
        break;
      }
    } else {
      break;
    }
    if (done) {
      if (*(it->complete + i)) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
    done = (uint8_t )tmp___0;
    i = (uint8_t )((int )i + 1);
  }
  if (done) {
    zsend.finish = now();
    zsend.complete = 1;
    zsend.first_scanned = (it->thread_shards + 0)->state.first_scanned;
  }
  pthread_mutex_unlock(& it->mutex);
  return;
}
}
iterator_t *iterator_init(uint8_t num_threads , uint16_t shard , uint16_t num_shards )
{
  uint64_t num_addrs ;
  uint64_t tmp ;
  uint64_t group_min_size ;
  iterator_t *it ;
  void *tmp___0 ;
  cyclic_group_t const   *group ;
  cyclic_group_t const   *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  uint8_t i ;

  {
  tmp = blocklist_count_allowed();
  num_addrs = tmp;
  group_min_size = num_addrs;
  if (zconf.list_of_ips_filename) {
    log_debug("send", "forcing max group size for compatibility with -I");
    group_min_size = (uint64_t )4294967295U;
  }
  tmp___0 = xmalloc(sizeof(struct iterator ));
  it = (iterator_t *)tmp___0;
  tmp___1 = get_group(group_min_size);
  group = tmp___1;
  if ((unsigned long long )num_addrs > (unsigned long long )(1LL << 32)) {
    zsend.max_index = 4294967295U;
  } else {
    zsend.max_index = (uint32_t )num_addrs;
  }
  log_debug("iterator", "max index %u", zsend.max_index);
  it->cycle = make_cycle(group, zconf.aes);
  it->num_threads = num_threads;
  it->curr_threads = (uint32_t )num_threads;
  tmp___2 = xcalloc((size_t )num_threads, sizeof(shard_t ));
  it->thread_shards = (shard_t *)tmp___2;
  tmp___3 = xcalloc((size_t )it->num_threads, sizeof(uint8_t ));
  it->complete = (uint8_t *)tmp___3;
  pthread_mutex_init(& it->mutex, (pthread_mutexattr_t const   *)((void *)0));
  i = (uint8_t )0;
  while ((int )i < (int )num_threads) {
    shard_init(it->thread_shards + i, shard, num_shards, i, num_threads, zsend.max_targets,
               (cycle_t const   *)(& it->cycle), & shard_complete, (void *)it);
    i = (uint8_t )((int )i + 1);
  }
  zconf.generator = (uint32_t )it->cycle.generator;
  return (it);
}
}
uint64_t iterator_get_sent(iterator_t *it )
{
  uint64_t sent ;
  uint8_t i ;

  {
  sent = (uint64_t )0;
  i = (uint8_t )0;
  while ((int )i < (int )it->num_threads) {
    sent += (it->thread_shards + i)->state.packets_sent;
    i = (uint8_t )((int )i + 1);
  }
  return (sent);
}
}
uint64_t iterator_get_iterations(iterator_t *it )
{
  uint64_t iterations ;
  uint8_t i ;

  {
  iterations = (uint64_t )0;
  i = (uint8_t )0;
  while ((int )i < (int )it->num_threads) {
    iterations += (it->thread_shards + i)->iterations;
    i = (uint8_t )((int )i + 1);
  }
  return (iterations);
}
}
uint32_t iterator_get_fail(iterator_t *it )
{
  uint32_t fails ;
  uint8_t i ;

  {
  fails = (uint32_t )0;
  i = (uint8_t )0;
  while ((int )i < (int )it->num_threads) {
    fails += (it->thread_shards + i)->state.packets_failed;
    i = (uint8_t )((int )i + 1);
  }
  return (fails);
}
}
shard_t *get_shard(iterator_t *it , uint8_t thread_id )
{


  {
  if (! ((int )thread_id < (int )it->num_threads)) {
    __assert_fail("thread_id < it->num_threads", "src/iterator.c", 120U, "get_shard");
  }
  return (it->thread_shards + thread_id);
}
}
uint32_t iterator_get_curr_send_threads(iterator_t *it )
{


  {
  if (! it) {
    __assert_fail("it", "src/iterator.c", 126U, "iterator_get_curr_send_threads");
  }
  return (it->curr_threads);
}
}
/* compiler builtin:
   float __builtin_inff(void) ;  */
/* compiler builtin:
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
#pragma merger("0","/tmp/cil-zzcpgAnm.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
void monitor_run(iterator_t *it , pthread_mutex_t *lock ) ;
void monitor_init(void) ;
extern  __attribute__((__nothrow__)) double ceil(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
extern int fclose(FILE *__stream ) ;
extern int fflush(FILE *__stream ) ;
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const   * __restrict  __filename ,
                                                              char const   * __restrict  __modes ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
extern unsigned int sleep(unsigned int __seconds ) ;
int recv_update_stats(void) ;
struct state_recv zrecv ;
extern int lock_file(FILE *f ) ;
extern int unlock_file(FILE *f ) ;
extern void time_string(uint32_t time , int est , char *buf , size_t len ) ;
extern void number_string(uint32_t n , char *buf , size_t len ) ;
static FILE *status_fd  =    (FILE *)((void *)0);
static double min_d(double *array , int n )
{
  double value ;
  float tmp ;
  int i ;

  {
  tmp = __builtin_inff();
  value = (double )tmp;
  i = 0;
  while (i < n) {
    if (*(array + i) < value) {
      value = *(array + i);
    }
    i ++;
  }
  return (value);
}
}
double compute_remaining_time(double age , uint64_t packets_sent , uint64_t iterations )
{
  double remaining[5] ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  double done ;
  double done___0 ;
  double done___1 ;
  double done___2 ;
  double tmp___4 ;
  double tmp___5 ;

  {
  if (! zsend.complete) {
    tmp = __builtin_inff();
    tmp___0 = __builtin_inff();
    tmp___1 = __builtin_inff();
    tmp___2 = __builtin_inff();
    tmp___3 = __builtin_inff();
    remaining[0] = (double )tmp;
    remaining[1] = (double )tmp___0;
    remaining[2] = (double )tmp___1;
    remaining[3] = (double )tmp___2;
    remaining[4] = (double )tmp___3;
    if (zsend.list_of_ips_pbm) {
      done = (double )iterations / (double )(4294967295UL / (uint64_t )zconf.total_shards);
      remaining[0] = (1. - done) * (age / done) + (double )zconf.cooldown_secs;
    }
    if (zsend.max_targets) {
      done___0 = (double )packets_sent / (double )(((uint64_t )zsend.max_targets * (uint64_t )zconf.packet_streams) / (uint64_t )zconf.total_shards);
      remaining[1] = (1. - done___0) * (age / done___0) + (double )zconf.cooldown_secs;
    }
    if (zconf.max_runtime) {
      remaining[2] = ((double )zconf.max_runtime - age) + (double )zconf.cooldown_secs;
    }
    if (zconf.max_results) {
      done___1 = (double )zrecv.filter_success / (double )zconf.max_results;
      remaining[3] = (1. - done___1) * (age / done___1);
    }
    if (zsend.max_index) {
      done___2 = (double )packets_sent / (double )((zsend.max_index * (uint32_t )zconf.packet_streams) / (uint32_t )zconf.total_shards);
      remaining[4] = (1. - done___2) * (age / done___2) + (double )zconf.cooldown_secs;
    }
    tmp___4 = min_d(remaining, (int )(sizeof(remaining) / sizeof(double )));
    return (tmp___4);
  } else {
    tmp___5 = now();
    return ((double )zconf.cooldown_secs - (tmp___5 - zsend.finish));
  }
}
}
static void update_pcap_stats(pthread_mutex_t *recv_ready_mutex___0 )
{


  {
  pthread_mutex_lock(recv_ready_mutex___0);
  recv_update_stats();
  pthread_mutex_unlock(recv_ready_mutex___0);
  return;
}
}
static void export_stats(int_status_t *intrnl , export_status_t *exp___0 , iterator_t *it )
{
  uint64_t total_sent ;
  uint64_t tmp ;
  uint64_t total_iterations ;
  uint64_t tmp___0 ;
  uint32_t total_fail ;
  uint32_t tmp___1 ;
  uint64_t total_recv ;
  uint64_t recv_success ;
  uint32_t app_success ;
  double cur_time ;
  double tmp___2 ;
  double age ;
  double delta ;
  double remaining_secs ;
  double tmp___3 ;
  char buf[20] ;
  double tmp___4 ;
  unsigned long tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;

  {
  tmp = iterator_get_sent(it);
  total_sent = tmp;
  tmp___0 = iterator_get_iterations(it);
  total_iterations = tmp___0;
  tmp___1 = iterator_get_fail(it);
  total_fail = tmp___1;
  total_recv = (uint64_t )zrecv.pcap_recv;
  recv_success = zrecv.filter_success;
  app_success = zrecv.app_success_unique;
  tmp___2 = now();
  cur_time = tmp___2;
  age = cur_time - zsend.start;
  delta = cur_time - intrnl->last_now;
  tmp___3 = compute_remaining_time(age, total_sent, total_iterations);
  remaining_secs = tmp___3;
  if (age < (double )5) {
    exp___0->time_remaining_str[0] = (char )'\000';
  } else {
    tmp___4 = ceil(remaining_secs);
    time_string((uint32_t )tmp___4, 1, buf, sizeof(buf));
    tmp___5 = __builtin_object_size((void *)(exp___0->time_remaining_str), 1);
    __builtin___snprintf_chk(exp___0->time_remaining_str, 20UL, 1, tmp___5, " (%s left)",
                             buf);
  }
  exp___0->time_past = (uint32_t )age;
  exp___0->time_remaining = (uint32_t )remaining_secs;
  time_string((uint32_t )((int )age), 0, exp___0->time_past_str, (size_t )20);
  exp___0->recv_rate = ceil((double )(recv_success - (uint64_t )intrnl->last_recv_net_success) / delta);
  number_string((uint32_t )exp___0->recv_rate, exp___0->recv_rate_str, (size_t )20);
  exp___0->recv_avg = (double )recv_success / age;
  number_string((uint32_t )exp___0->recv_avg, exp___0->recv_avg_str, (size_t )20);
  exp___0->recv_total_rate = (double )(total_recv - (uint64_t )intrnl->last_recv_total) / delta;
  exp___0->recv_total_avg = (double )total_recv / age;
  if (zconf.fsconf.app_success_index >= 0) {
    exp___0->app_success_rate = (double )(app_success - intrnl->last_recv_app_success) / delta;
    number_string((uint32_t )exp___0->app_success_rate, exp___0->app_success_rate_str,
                  (size_t )20);
    exp___0->app_success_avg = (double )app_success / age;
    number_string((uint32_t )exp___0->app_success_avg, exp___0->app_success_avg_str,
                  (size_t )20);
  }
  if (! total_sent) {
    exp___0->hitrate = (double )0;
    exp___0->app_hitrate = (double )0;
  } else {
    exp___0->hitrate = ((double )recv_success * 100.0) / (double )total_sent;
    exp___0->app_hitrate = ((double )app_success * 100.0) / (double )total_sent;
  }
  if (age > (double )5) {
    if (exp___0->hitrate < (double )zconf.min_hitrate) {
      tmp___6 = fabs(intrnl->min_hitrate_start);
      if (tmp___6 < .00001) {
        intrnl->min_hitrate_start = cur_time;
      }
    } else {
      intrnl->min_hitrate_start = 0.0;
    }
  } else {
    intrnl->min_hitrate_start = 0.0;
  }
  tmp___7 = fabs(intrnl->min_hitrate_start);
  if (tmp___7 < .00001) {
    exp___0->seconds_under_min_hitrate = (float )0;
  } else {
    exp___0->seconds_under_min_hitrate = (float )(cur_time - intrnl->min_hitrate_start);
  }
  if (! zsend.complete) {
    exp___0->send_rate = ceil((double )(total_sent - intrnl->last_sent) / delta);
    number_string((uint32_t )exp___0->send_rate, exp___0->send_rate_str, (size_t )20);
    exp___0->send_rate_avg = (double )total_sent / age;
    number_string((uint32_t )exp___0->send_rate_avg, exp___0->send_rate_avg_str, (size_t )20);
  } else {
    exp___0->send_rate_avg = (double )total_sent / (zsend.finish - zsend.start);
    number_string((uint32_t )exp___0->send_rate_avg, exp___0->send_rate_avg_str, (size_t )20);
  }
  exp___0->total_sent = total_sent;
  exp___0->total_tried_sent = total_iterations;
  exp___0->percent_complete = (100. * age) / (age + remaining_secs);
  exp___0->recv_success_unique = (uint32_t )recv_success;
  exp___0->app_recv_success_unique = app_success;
  exp___0->total_recv = total_recv;
  exp___0->complete = (uint32_t )zsend.complete;
  exp___0->pcap_drop = zrecv.pcap_drop;
  exp___0->pcap_ifdrop = zrecv.pcap_ifdrop;
  exp___0->pcap_drop_total = exp___0->pcap_drop + exp___0->pcap_ifdrop;
  exp___0->pcap_drop_last = (double )(exp___0->pcap_drop_total - intrnl->last_pcap_drop) / delta;
  exp___0->pcap_drop_avg = (double )exp___0->pcap_drop_total / age;
  number_string(exp___0->pcap_drop_total, exp___0->pcap_drop_total_str, (size_t )20);
  number_string((uint32_t )exp___0->pcap_drop_last, exp___0->pcap_drop_last_str, (size_t )20);
  number_string((uint32_t )exp___0->pcap_drop_avg, exp___0->pcap_drop_avg_str, (size_t )20);
  zsend.sendto_failures = total_fail;
  exp___0->fail_total = zsend.sendto_failures;
  exp___0->fail_last = (double )(exp___0->fail_total - intrnl->last_send_failures) / delta;
  exp___0->fail_avg = (double )exp___0->fail_total / age;
  exp___0->send_threads = iterator_get_curr_send_threads(it);
  intrnl->last_now = cur_time;
  intrnl->last_sent = exp___0->total_sent;
  intrnl->last_recv_net_success = exp___0->recv_success_unique;
  intrnl->last_recv_app_success = exp___0->app_recv_success_unique;
  intrnl->last_pcap_drop = exp___0->pcap_drop_total;
  intrnl->last_send_failures = exp___0->fail_total;
  intrnl->last_recv_total = (uint32_t )exp___0->total_recv;
  return;
}
}
static void log_drop_warnings(export_status_t *exp___0 )
{


  {
  if (exp___0->pcap_drop_last / exp___0->recv_rate > 0.05) {
    log_warn("monitor", "Dropped %.0f packets in the last second, (%u total dropped (pcap: %u + iface: %u))",
             exp___0->pcap_drop_last, exp___0->pcap_drop_total, exp___0->pcap_drop,
             exp___0->pcap_ifdrop);
  }
  if (exp___0->fail_last / exp___0->send_rate > 0.01) {
    log_warn("monitor", "Failed to send %.0f packets/sec (%u total failures)", exp___0->fail_last,
             exp___0->fail_total);
  }
  return;
}
}
static void onscreen_appsuccess(export_status_t *exp___0 )
{


  {
  if (! exp___0->complete) {
    __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%5s %0.0f%%%s; sent: %lu %sp/s (%sp/s avg); recv: %u %sp/s (%sp/s avg); app success: %u %sp/s (%sp/s avg); drops: %sp/s (%sp/s avg); hitrate: %0.2f%% app hitrate: %0.2f%%\n",
                  exp___0->time_past_str, exp___0->percent_complete, exp___0->time_remaining_str,
                  exp___0->total_sent, exp___0->send_rate_str, exp___0->send_rate_avg_str,
                  exp___0->recv_success_unique, exp___0->recv_rate_str, exp___0->recv_avg_str,
                  exp___0->app_recv_success_unique, exp___0->app_success_rate_str,
                  exp___0->app_success_avg_str, exp___0->pcap_drop_last_str, exp___0->pcap_drop_avg_str,
                  exp___0->hitrate, exp___0->app_hitrate);
  } else {
    __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%5s %0.0f%%%s; sent: %lu done (%sp/s avg); recv: %u %sp/s (%sp/s avg); app success: %u %sp/s (%sp/s avg); drops: %sp/s (%sp/s avg); hitrate: %0.2f%% app hitrate: %0.2f%%\n",
                  exp___0->time_past_str, exp___0->percent_complete, exp___0->time_remaining_str,
                  exp___0->total_sent, exp___0->send_rate_avg_str, exp___0->recv_success_unique,
                  exp___0->recv_rate_str, exp___0->recv_avg_str, exp___0->app_recv_success_unique,
                  exp___0->app_success_rate_str, exp___0->app_success_avg_str, exp___0->pcap_drop_last_str,
                  exp___0->pcap_drop_avg_str, exp___0->hitrate, exp___0->app_hitrate);
  }
  return;
}
}
static void onscreen_generic(export_status_t *exp___0 )
{


  {
  if (! exp___0->complete) {
    __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%5s %0.0f%%%s; send: %lu %sp/s (%sp/s avg); recv: %u %sp/s (%sp/s avg); drops: %sp/s (%sp/s avg); hitrate: %0.2f%%\n",
                  exp___0->time_past_str, exp___0->percent_complete, exp___0->time_remaining_str,
                  exp___0->total_sent, exp___0->send_rate_str, exp___0->send_rate_avg_str,
                  exp___0->recv_success_unique, exp___0->recv_rate_str, exp___0->recv_avg_str,
                  exp___0->pcap_drop_last_str, exp___0->pcap_drop_avg_str, exp___0->hitrate);
  } else {
    __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%5s %0.0f%%%s; send: %lu done (%sp/s avg); recv: %u %sp/s (%sp/s avg); drops: %sp/s (%sp/s avg); hitrate: %0.2f%%\n",
                  exp___0->time_past_str, exp___0->percent_complete, exp___0->time_remaining_str,
                  exp___0->total_sent, exp___0->send_rate_avg_str, exp___0->recv_success_unique,
                  exp___0->recv_rate_str, exp___0->recv_avg_str, exp___0->pcap_drop_last_str,
                  exp___0->pcap_drop_avg_str, exp___0->hitrate);
  }
  fflush(stderr);
  return;
}
}
static FILE *init_status_update_file(char *path )
{
  FILE *f ;
  FILE *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  tmp = fopen((char const   * __restrict  )path, (char const   * __restrict  )"w");
  f = tmp;
  if (! f) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    log_fatal("csv", "could not open status updates file (%s): %s", zconf.status_updates_file,
              tmp___1);
  }
  log_debug("monitor", "status updates CSV will be saved to %s", zconf.status_updates_file);
  __fprintf_chk((FILE * __restrict  )f, 1, (char const   * __restrict  )"real-time,time-elapsed,time-remaining,percent-complete,hit-rate,active-send-threads,sent-total,sent-last-one-sec,sent-avg-per-sec,recv-success-total,recv-success-last-one-sec,recv-success-avg-per-sec,recv-total,recv-total-last-one-sec,recv-total-avg-per-sec,pcap-drop-total,drop-last-one-sec,drop-avg-per-sec,sendto-fail-total,sendto-fail-last-one-sec,sendto-fail-avg-per-sec\n");
  fflush(f);
  return (f);
}
}
static void update_status_updates_file(export_status_t *exp___0 , FILE *f )
{
  struct timeval now___0 ;
  char timestamp[256] ;
  time_t sec ;
  struct tm *ptm ;
  struct tm *tmp ;

  {
  gettimeofday((struct timeval * __restrict  )(& now___0), (void * __restrict  )((void *)0));
  sec = now___0.tv_sec;
  tmp = localtime((time_t const   *)(& sec));
  ptm = tmp;
  strftime((char * __restrict  )(timestamp), (size_t )20, (char const   * __restrict  )"%Y-%m-%d %H:%M:%S",
           (struct tm  const  * __restrict  )ptm);
  __fprintf_chk((FILE * __restrict  )f, 1, (char const   * __restrict  )"%s,%u,%u,%f,%f,%u,%lu,%.0f,%.0f,%u,%.0f,%.0f,%lu,%.0f,%.0f,%u,%.0f,%.0f,%u,%.0f,%.0f\n",
                timestamp, exp___0->time_past, exp___0->time_remaining, exp___0->percent_complete,
                exp___0->hitrate, exp___0->send_threads, exp___0->total_sent, exp___0->send_rate,
                exp___0->send_rate_avg, exp___0->recv_success_unique, exp___0->recv_rate,
                exp___0->recv_avg, exp___0->total_recv, exp___0->recv_total_rate,
                exp___0->recv_total_avg, exp___0->pcap_drop_total, exp___0->pcap_drop_last,
                exp___0->pcap_drop_avg, exp___0->fail_total, exp___0->fail_last, exp___0->fail_avg);
  fflush(f);
  return;
}
}
__inline static void check_min_hitrate(export_status_t *exp___0 )
{


  {
  if (exp___0->seconds_under_min_hitrate >= (float )5) {
    log_fatal("monitor", "hitrate below %.0f for %.0f seconds. aborting scan.", (double )zconf.min_hitrate,
              (double )exp___0->seconds_under_min_hitrate);
  }
  return;
}
}
__inline static void check_max_sendto_failures(export_status_t *exp___0 )
{


  {
  if (zconf.max_sendto_failures >= 0) {
    if (exp___0->fail_total > (uint32_t )zconf.max_sendto_failures) {
      log_fatal("monitor", "maximum number of sendto failures (%i) exceeded", zconf.max_sendto_failures);
    }
  }
  return;
}
}
void monitor_init(void)
{


  {
  if (zconf.status_updates_file) {
    status_fd = init_status_update_file(zconf.status_updates_file);
    if (! status_fd) {
      __assert_fail("status_fd", "src/monitor.c", 449U, "monitor_init");
    }
  }
  return;
}
}
void monitor_run(iterator_t *it , pthread_mutex_t *lock )
{
  int_status_t *internal_status ;
  void *tmp ;
  export_status_t *export_status ;
  void *tmp___0 ;

  {
  tmp = xmalloc(sizeof(int_status_t ));
  internal_status = (int_status_t *)tmp;
  tmp___0 = xmalloc(sizeof(export_status_t ));
  export_status = (export_status_t *)tmp___0;
  while (1) {
    if (zsend.complete) {
      if (zrecv.complete) {
        break;
      }
    }
    update_pcap_stats(lock);
    export_stats(internal_status, export_status, it);
    log_drop_warnings(export_status);
    check_min_hitrate(export_status);
    check_max_sendto_failures(export_status);
    if (! zconf.quiet) {
      lock_file(stderr);
      if (zconf.fsconf.app_success_index >= 0) {
        onscreen_appsuccess(export_status);
      } else {
        onscreen_generic(export_status);
      }
      unlock_file(stderr);
    }
    if (status_fd) {
      update_status_updates_file(export_status, status_fd);
    }
    sleep(1U);
  }
  if (! zconf.quiet) {
    lock_file(stderr);
    fflush(stderr);
    unlock_file(stderr);
  }
  if (status_fd) {
    fflush(status_fd);
    fclose(status_fd);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-npa5v3bz.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
int recv_run(pthread_mutex_t *recv_ready_mutex___0 ) ;
__inline static __uint16_t __bswap_16(__uint16_t __bsx )
{


  {
  return ((__uint16_t )((((int )__bsx >> 8) & 255) | (((int )__bsx & 255) << 8)));
}
}
__inline static __uint32_t __bswap_32(__uint32_t __bsx )
{


  {
  return (((((__bsx & 4278190080U) >> 24) | ((__bsx & 16711680U) >> 8)) | ((__bsx & 65280U) << 8)) | ((__bsx & 255U) << 24));
}
}
extern int log_info(char const   *loggerName , char const   *logMessage  , ...) ;
extern uint8_t **pbm_init(void) ;
extern int pbm_check(uint8_t **b , uint32_t v ) ;
extern void pbm_set(uint8_t **b , uint32_t v ) ;
void handle_packet(uint32_t buflen , unsigned char const   *bytes , struct timespec  const  ts ) ;
void recv_init(void) ;
void recv_packets(void) ;
void recv_cleanup(void) ;
void validate_gen(uint32_t const   src , uint32_t const   dst , uint8_t *output ) ;
void fs_add_ip_fields(fieldset_t *fs , struct ip *ip ) ;
void fs_add_system_fields(fieldset_t *fs , int is_repeat , int in_cooldown ) ;
static u_char fake_eth_hdr[65535]  ;
static uint8_t **seen  =    (uint8_t **)((void *)0);
void handle_packet(uint32_t buflen , unsigned char const   *bytes , struct timespec  const  ts )
{
  struct ip *ip_hdr ;
  uint32_t src_ip ;
  uint32_t validation[16UL / sizeof(uint8_t )] ;
  unsigned long tmp ;
  int tmp___0 ;
  int is_repeat ;
  __uint32_t tmp___1 ;
  int tmp___2 ;
  fieldset_t *fs ;
  fieldset_t *tmp___3 ;
  int success_index ;
  int is_success ;
  uint64_t tmp___5 ;
  __uint32_t tmp___6 ;
  int is_app_success ;
  uint64_t tmp___7 ;
  fieldset_t *o ;
  int tmp___8 ;

  {
  if (sizeof(struct ip ) + (unsigned long )zconf.data_link_size > (unsigned long )buflen) {
    return;
  }
  ip_hdr = (struct ip *)(bytes + zconf.data_link_size);
  src_ip = ip_hdr->ip_src.s_addr;
  validate_gen((uint32_t const   )ip_hdr->ip_dst.s_addr, (uint32_t const   )ip_hdr->ip_src.s_addr,
               (uint8_t *)((uint8_t *)(validation)));
  if (zconf.send_ip_pkts) {
    tmp = 0UL;
  } else {
    tmp = sizeof(struct ether_header );
  }
  tmp___0 = (*((zconf.probe_module)->validate_packet))((struct ip  const  *)ip_hdr,
                                                       (uint32_t )((unsigned long )buflen - tmp),
                                                       & src_ip, validation);
  if (tmp___0) {
    (zrecv.validation_passed) ++;
  } else {
    (zrecv.validation_failed) ++;
    return;
  }
  tmp___1 = __bswap_32(src_ip);
  tmp___2 = pbm_check(seen, tmp___1);
  is_repeat = tmp___2;
  if ((int )ip_hdr->ip_off & 8192) {
    (zrecv.ip_fragments) ++;
  }
  tmp___3 = fs_new_fieldset(& zconf.fsconf.defs);
  fs = tmp___3;
  fs_add_ip_fields(fs, ip_hdr);
  if (zconf.send_ip_pkts) {
    if ((unsigned long )buflen > sizeof(fake_eth_hdr)) {
      buflen = (uint32_t )sizeof(fake_eth_hdr);
    }
    memcpy((void * __restrict  )(& fake_eth_hdr[sizeof(struct ether_header )]), (void const   * __restrict  )(bytes + zconf.data_link_size),
           (size_t )buflen);
    bytes = (unsigned char const   *)(fake_eth_hdr);
  }
  (*((zconf.probe_module)->process_packet))(bytes, buflen, fs, validation, ts);
  fs_add_system_fields(fs, is_repeat, zsend.complete);
  success_index = zconf.fsconf.success_index;
  if (! (success_index < fs->len)) {
    __assert_fail("success_index < fs->len", "src/recv.c", 84U, "handle_packet");
  }
  tmp___5 = fs_get_uint64_by_index(fs, success_index);
  is_success = (int )tmp___5;
  if (is_success) {
    (zrecv.success_total) ++;
    if (! is_repeat) {
      (zrecv.success_unique) ++;
      tmp___6 = __bswap_32(src_ip);
      pbm_set(seen, tmp___6);
    }
    if (zsend.complete) {
      (zrecv.cooldown_total) ++;
      if (! is_repeat) {
        (zrecv.cooldown_unique) ++;
      }
    }
  } else {
    (zrecv.failure_total) ++;
  }
  if (zconf.fsconf.app_success_index >= 0) {
    tmp___7 = fs_get_uint64_by_index(fs, zconf.fsconf.app_success_index);
    is_app_success = (int )tmp___7;
    if (is_app_success) {
      (zrecv.app_success_total) ++;
      if (! is_repeat) {
        (zrecv.app_success_unique) ++;
      }
    }
  }
  o = (fieldset_t *)((void *)0);
  if (! is_success) {
    if (zconf.default_mode) {
      goto cleanup;
    }
  }
  if (is_repeat) {
    if (zconf.default_mode) {
      goto cleanup;
    }
  }
  tmp___8 = evaluate_expression(zconf.filter.expression, fs);
  if (! tmp___8) {
    goto cleanup;
  }
  (zrecv.filter_success) ++;
  o = translate_fieldset(fs, & zconf.fsconf.translation);
  if (zconf.output_module) {
    if ((zconf.output_module)->process_ip) {
      (*((zconf.output_module)->process_ip))(o);
    }
  }
  cleanup:
  fs_free(fs);
  free((void *)o);
  if (zconf.output_module) {
    if ((zconf.output_module)->update) {
      if (! (zrecv.success_unique % (zconf.output_module)->update_interval)) {
        (*((zconf.output_module)->update))(& zconf, & zsend, & zrecv);
      }
    }
  }
  return;
}
}
int recv_run(pthread_mutex_t *recv_ready_mutex___0 )
{
  struct ether_header *eth ;
  double tmp ;

  {
  log_debug("recv", "capturing responses on %s", zconf.iface);
  if (! zconf.dryrun) {
    recv_init();
  }
  if (zconf.send_ip_pkts) {
    eth = (struct ether_header *)(fake_eth_hdr);
    memset((void *)(fake_eth_hdr), 0, sizeof(fake_eth_hdr));
    eth->ether_type = __bswap_16((__uint16_t )2048);
  }
  seen = pbm_init();
  if (zconf.default_mode) {
    log_info("recv", "duplicate responses will be excluded from output");
    log_info("recv", "unsuccessful responses will be excluded from output");
  } else {
    log_info("recv", "duplicate responses will be passed to the output module");
    log_info("recv", "unsuccessful responses will be passed to the output module");
  }
  pthread_mutex_lock(recv_ready_mutex___0);
  zconf.recv_ready = 1;
  pthread_mutex_unlock(recv_ready_mutex___0);
  zrecv.start = now();
  if (zconf.max_results == 0U) {
    zconf.max_results = (uint32_t )-1;
  }
  while (1) {
    if (zconf.dryrun) {
      sleep(1U);
    } else {
      recv_packets();
      if (zconf.max_results) {
        if (zrecv.filter_success >= (uint64_t )zconf.max_results) {
          break;
        }
      }
    }
    if (zsend.complete) {
      tmp = now();
      if (tmp - zsend.finish > (double )zconf.cooldown_secs) {
        break;
      }
    }
  }
  zrecv.finish = now();
  recv_update_stats();
  if (! zconf.dryrun) {
    pthread_mutex_lock(recv_ready_mutex___0);
    recv_cleanup();
    pthread_mutex_unlock(recv_ready_mutex___0);
  }
  zrecv.complete = 1;
  log_debug("recv", "thread finished");
  return (0);
}
}
#pragma merger("0","/tmp/cil-zk8147pF.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   * __restrict  __cp ,
                                                             char * __restrict  __buf ,
                                                             socklen_t __len ) ;
uint32_t shard_get_cur_ip(shard_t *shard ) ;
uint32_t shard_get_next_ip(shard_t *shard ) ;
iterator_t *send_init(void) ;
int send_run(sock_t st , shard_t *s ) ;
extern void perror(char const   *__s ) ;
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
void validate_init(void) ;
static int send_packet(sock_t sock , void *buf , int len , uint32_t idx  __attribute__((__unused__)) ) ;
static int send_run_init(sock_t s ) ;
static struct sockaddr_ll sockaddr  ;
static int send_run_init(sock_t s )
{
  int sock ;
  struct ifreq if_idx ;
  size_t tmp ;
  int tmp___0 ;
  int ifindex ;

  {
  sock = s.sock;
  memset((void *)(& if_idx), 0, sizeof(struct ifreq ));
  tmp = strlen((char const   *)zconf.iface);
  if (tmp >= 16UL) {
    log_error("send", "device interface name (%s) too long\n", zconf.iface);
    return (1);
  }
  strncpy((char * __restrict  )(if_idx.ifr_ifrn.ifrn_name), (char const   * __restrict  )zconf.iface,
          (size_t )15);
  tmp___0 = ioctl(sock, 35123UL, & if_idx);
  if (tmp___0 < 0) {
    perror("SIOCGIFINDEX");
    return (1);
  }
  ifindex = if_idx.ifr_ifru.ifru_ivalue;
  memset((void *)(& sockaddr), 0, sizeof(struct sockaddr_ll ));
  sockaddr.sll_ifindex = ifindex;
  sockaddr.sll_halen = (unsigned char)6;
  if (zconf.send_ip_pkts) {
    sockaddr.sll_protocol = __bswap_16((__uint16_t )2048);
  }
  memcpy((void * __restrict  )(sockaddr.sll_addr), (void const   * __restrict  )(zconf.gw_mac),
         (size_t )6);
  return (0);
}
}
static int send_packet(sock_t sock , void *buf , int len , uint32_t idx  __attribute__((__unused__)) )
{
  ssize_t tmp ;

  {
  tmp = sendto(sock.sock, (void const   *)buf, (size_t )len, 0, (struct sockaddr  const  *)((struct sockaddr *)(& sockaddr)),
               (socklen_t )sizeof(struct sockaddr_ll ));
  return ((int )tmp);
}
}
static pthread_mutex_t send_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static uint16_t num_src_ports  ;
void sig_handler_increase_speed(int signal___0  __attribute__((__unused__)) )
{
  int old_rate ;

  {
  old_rate = zconf.rate;
  zconf.rate = (int )((double )zconf.rate + (double )zconf.rate * 0.05);
  log_info("send", "send rate increased from %i to %i pps.", old_rate, zconf.rate);
  return;
}
}
void sig_handler_decrease_speed(int signal___0  __attribute__((__unused__)) )
{
  int old_rate ;

  {
  old_rate = zconf.rate;
  zconf.rate = (int )((double )zconf.rate - (double )zconf.rate * 0.05);
  log_info("send", "send rate decreased from %i to %i pps.", old_rate, zconf.rate);
  return;
}
}
iterator_t *send_init(void)
{
  iterator_t *it ;
  uint32_t num_subshards ;
  uint64_t tmp ;
  struct in_addr temp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___4 ;
  size_t pkt_len ;
  int tmp___5 ;

  {
  num_subshards = (uint32_t )zconf.senders * (uint32_t )zconf.total_shards;
  tmp = blocklist_count_allowed();
  if ((uint64_t )num_subshards > tmp) {
    log_fatal("send", "senders * shards > allowed probes");
  }
  if (zsend.max_targets) {
    if (num_subshards > zsend.max_targets) {
      log_fatal("send", "senders * shards > max targets");
    }
  }
  it = iterator_init(zconf.senders, zconf.shard_num, zconf.total_shards);
  temp.s_addr = zconf.source_ip_addresses[0];
  tmp___0 = inet_ntoa(temp);
  log_debug("send", "srcip_first: %s", tmp___0);
  temp.s_addr = zconf.source_ip_addresses[zconf.number_source_ips - 1U];
  tmp___1 = inet_ntoa(temp);
  log_debug("send", "srcip_last: %s", tmp___1);
  num_src_ports = (uint16_t )(((int )zconf.source_port_last - (int )zconf.source_port_first) + 1);
  if (zconf.number_source_ips == 1U) {
    tmp___2 = "";
  } else {
    tmp___2 = "es";
  }
  log_debug("send", "will send from %u address%s on %hu source ports", zconf.number_source_ips,
            tmp___2, (int )num_src_ports);
  if (! zconf.probe_module) {
    __assert_fail("zconf.probe_module", "src/send.c", 103U, "send_init");
  }
  if ((zconf.probe_module)->global_initialize) {
    tmp___4 = (*((zconf.probe_module)->global_initialize))(& zconf);
    if (tmp___4) {
      log_fatal("send", "global initialization for probe module failed.");
    }
  }
  if (zconf.bandwidth > 0UL) {
    if (zconf.rate > 0) {
      log_fatal("send", "must specify rate or bandwidth, or neither, not both.");
    }
  }
  if (zconf.bandwidth > 0UL) {
    pkt_len = (zconf.probe_module)->max_packet_length;
    pkt_len *= 8UL;
    pkt_len += 192UL;
    if (pkt_len < 672UL) {
      pkt_len = (size_t )672;
    }
    if (zconf.bandwidth / pkt_len > 4294967295UL) {
      zconf.rate = 0;
    } else {
      zconf.rate = (int )(zconf.bandwidth / pkt_len);
      if (zconf.rate == 0) {
        log_warn("send", "bandwidth %lu bit/s is slower than 1 pkt/s, setting rate to 1 pkt/s",
                 zconf.bandwidth);
        zconf.rate = 1;
      }
    }
    log_debug("send", "using bandwidth %lu bits/s for %zu byte probe, rate set to %d pkt/s",
              zconf.bandwidth, pkt_len / 8UL, zconf.rate);
  }
  if (zconf.rate == -1) {
    zconf.rate = 10000;
  }
  if (zconf.rate < 0) {
    log_fatal("send", "rate impossibly slow");
  }
  if (zconf.rate > 0) {
    if (zconf.bandwidth <= 0UL) {
      log_debug("send", "rate set to %d pkt/s", zconf.rate);
    }
  }
  if (! zconf.hw_mac_set) {
    tmp___5 = get_iface_hw_addr(zconf.iface, zconf.hw_mac);
    if (tmp___5) {
      log_fatal("send", "ZMap could not retrieve the hardware (MAC) address for the interface \"%s\". You likely do not privileges to open a raw packet socket. Are you running as root or with the CAP_NET_RAW capability? If you are, you may need to manually set the source MAC address with the \"--source-mac\" flag.",
                zconf.iface);
      return ((iterator_t *)((void *)0));
    }
    log_debug("send", "no source MAC provided. automatically detected %02x:%02x:%02x:%02x:%02x:%02x as hw interface for %s",
              (int )zconf.hw_mac[0], (int )zconf.hw_mac[1], (int )zconf.hw_mac[2],
              (int )zconf.hw_mac[3], (int )zconf.hw_mac[4], (int )zconf.hw_mac[5],
              zconf.iface);
  }
  log_debug("send", "source MAC address %02x:%02x:%02x:%02x:%02x:%02x", (int )zconf.hw_mac[0],
            (int )zconf.hw_mac[1], (int )zconf.hw_mac[2], (int )zconf.hw_mac[3], (int )zconf.hw_mac[4],
            (int )zconf.hw_mac[5]);
  if (zconf.dryrun) {
    log_info("send", "dryrun mode -- won\'t actually send packets");
  }
  validate_init();
  signal(10, & sig_handler_increase_speed);
  signal(12, & sig_handler_decrease_speed);
  zsend.start = now();
  return (it);
}
}
__inline static ipaddr_n_t get_src_ip(ipaddr_n_t dst , int local_offset )
{
  __uint32_t tmp ;

  {
  if (zconf.number_source_ips == 1U) {
    return (zconf.source_ip_addresses[0]);
  }
  tmp = __bswap_32(dst);
  return (zconf.source_ip_addresses[(tmp + (__uint32_t )local_offset) % zconf.number_source_ips]);
}
}
int send_run(sock_t st , shard_t *s )
{
  char buf[4096] ;
  int tmp ;
  char mac_buf[18] ;
  char *p ;
  int i ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  void *probe_data ;
  uint64_t count ;
  uint64_t last_count ;
  double last_time ;
  double tmp___2 ;
  uint32_t delay ;
  int interval ;
  int volatile   vi ;
  struct timespec ts ;
  struct timespec rem ;
  double send_rate ;
  double slow_rate ;
  long nsec_per_sec ;
  long long sleep_time ;
  double tmp___3 ;
  int volatile   tmp___4 ;
  double tmp___5 ;
  uint32_t current_ip ;
  uint32_t tmp___6 ;
  int tmp___7 ;
  int attempts ;
  uint32_t idx ;
  double t ;
  double tmp___8 ;
  double last_rate ;
  int tmp___9 ;
  int volatile   tmp___10 ;
  double t___0 ;
  double tmp___11 ;
  double multiplier ;
  uint32_t old_delay ;
  double tmp___14 ;
  int b ;
  int i___0 ;
  uint32_t src_ip ;
  ipaddr_n_t tmp___15 ;
  uint32_t validation[16UL / sizeof(uint32_t )] ;
  uint8_t ttl ;
  size_t length ;
  void *contents ;
  int any_sends_successful ;
  int i___1 ;
  int rc ;
  int tmp___16 ;
  struct in_addr addr ;
  char addr_str_buf[16] ;
  char const   *addr_str ;
  char const   *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;

  {
  log_debug("send", "send thread started");
  pthread_mutex_lock(& send_mutex);
  memset((void *)(buf), 0, (size_t )4096);
  tmp = send_run_init(st);
  if (tmp) {
    pthread_mutex_unlock(& send_mutex);
    return (-1);
  }
  p = mac_buf;
  i = 0;
  while (i < 6) {
    if (i == 5) {
      tmp___0 = __builtin_object_size((void *)p, 1);
      __builtin___snprintf_chk(p, 3UL, 1, tmp___0, "%.2x", (int )zconf.hw_mac[i]);
      p += 2;
    } else {
      tmp___1 = __builtin_object_size((void *)p, 1);
      __builtin___snprintf_chk(p, 4UL, 1, tmp___1, "%.2x:", (int )zconf.hw_mac[i]);
      p += 3;
    }
    i ++;
  }
  log_debug("send", "source MAC address %s", mac_buf);
  if ((zconf.probe_module)->thread_initialize) {
    (*((zconf.probe_module)->thread_initialize))((void *)(buf), zconf.hw_mac, zconf.gw_mac,
                                                 zconf.target_port, & probe_data);
  }
  pthread_mutex_unlock(& send_mutex);
  count = (uint64_t )0;
  last_count = count;
  tmp___2 = now();
  last_time = tmp___2;
  delay = (uint32_t )0;
  interval = 0;
  send_rate = (double )zconf.rate / (((double )zconf.senders * (double )zconf.batch) * (double )zconf.packet_streams);
  slow_rate = (double )50;
  nsec_per_sec = 1000000000L;
  sleep_time = (long long )nsec_per_sec;
  if (zconf.rate > 0) {
    delay = (uint32_t )10000;
    if (send_rate < slow_rate) {
      sleep_time = (long long )((double )nsec_per_sec / send_rate);
      tmp___3 = now();
      last_time = tmp___3 - 1.0 / send_rate;
    } else {
      vi = (int volatile   )delay;
      while (1) {
        tmp___4 = vi;
        vi -= (int volatile   )1;
        if (! tmp___4) {
          break;
        }
      }
      tmp___5 = now();
      delay = (uint32_t )((double )delay * (((double )1 / (tmp___5 - last_time)) / ((double )zconf.rate / ((double )zconf.senders * (double )zconf.batch))));
      interval = (int )(((double )zconf.rate / ((double )zconf.senders * (double )zconf.batch)) / (double )20);
      last_time = now();
    }
  }
  tmp___6 = shard_get_cur_ip(s);
  current_ip = tmp___6;
  if (zconf.list_of_ips_filename) {
    while (1) {
      tmp___7 = pbm_check(zsend.list_of_ips_pbm, current_ip);
      if (tmp___7) {
        break;
      }
      current_ip = shard_get_next_ip(s);
      if (current_ip == 0U) {
        log_debug("send", "never made it to send loop in send thread %i", (int )s->thread_id);
        goto cleanup;
      }
    }
  }
  attempts = zconf.num_retries + 1;
  idx = (uint32_t )0;
  while (1) {
    if (count) {
      if (delay > 0U) {
        if (send_rate < slow_rate) {
          tmp___8 = now();
          t = tmp___8;
          last_rate = 1.0 / (t - last_time);
          sleep_time = (long long )((double )sleep_time * ((last_rate / send_rate + (double )1) / (double )2));
          ts.tv_sec = (__time_t )(sleep_time / (long long )nsec_per_sec);
          ts.tv_nsec = (__syscall_slong_t )(sleep_time % (long long )nsec_per_sec);
          log_debug("sleep", "sleep for %d sec, %ld nanoseconds", ts.tv_sec, ts.tv_nsec);
          while (1) {
            tmp___9 = nanosleep((struct timespec  const  *)(& ts), & rem);
            if (! (tmp___9 == -1)) {
              break;
            }
          }
          last_time = t;
        } else {
          vi = (int volatile   )delay;
          while (1) {
            tmp___10 = vi;
            vi -= (int volatile   )1;
            if (! tmp___10) {
              break;
            }
          }
          if (! interval) {
            goto _L;
          } else
          if (count % (unsigned long )interval == 0UL) {
            _L: /* CIL Label */
            tmp___11 = now();
            t___0 = tmp___11;
            if (! (count > last_count)) {
              __assert_fail("count > last_count", "src/send.c", 320U, "send_run");
            }
            if (! (t___0 > last_time)) {
              __assert_fail("t > last_time", "src/send.c", 321U, "send_run");
            }
            multiplier = ((double )(count - last_count) / (t___0 - last_time)) / (double )(zconf.rate / (int )zconf.senders);
            old_delay = delay;
            delay = (uint32_t )((double )delay * multiplier);
            if (delay == old_delay) {
              if (multiplier > 1.0) {
                delay *= 2U;
              } else
              if (multiplier < 1.0) {
                delay = (uint32_t )((double )delay * 0.5);
              }
            }
            last_count = count;
            last_time = t___0;
          }
        }
      }
    }
    if (zrecv.complete) {
      goto cleanup;
    }
    if (zconf.max_runtime) {
      tmp___14 = now();
      if ((double )zconf.max_runtime <= tmp___14 - zsend.start) {
        goto cleanup;
      }
    }
    b = 0;
    while (b < (int )zconf.batch) {
      if (s->state.max_hosts) {
        if (s->state.hosts_scanned >= s->state.max_hosts) {
          log_debug("send", "send thread %hhu finished (max targets of %u reached)",
                    (int )s->thread_id, s->state.max_hosts);
          goto cleanup;
        }
      }
      if (s->state.max_packets) {
        if (s->state.packets_sent >= (uint64_t )s->state.max_packets) {
          log_debug("send", "send thread %hhu finished (max packets of %u reached)",
                    (int )s->thread_id, s->state.max_packets);
          goto cleanup;
        }
      }
      if (current_ip == 0U) {
        log_debug("send", "send thread %hhu finished, shard depleted", (int )s->thread_id);
        goto cleanup;
      }
      i___0 = 0;
      while (i___0 < zconf.packet_streams) {
        count ++;
        tmp___15 = get_src_ip(current_ip, i___0);
        src_ip = tmp___15;
        validate_gen((uint32_t const   )src_ip, (uint32_t const   )current_ip, (uint8_t *)((uint8_t *)(validation)));
        ttl = zconf.probe_ttl;
        length = (size_t )0;
        (*((zconf.probe_module)->make_packet))((void *)(buf), & length, src_ip, current_ip,
                                               ttl, validation, i___0, probe_data);
        if (length > 4096UL) {
          log_fatal("send", "send thread %hhu set length (%zu) larger than MAX (%zu)",
                    (int )s->thread_id, length, 4096);
        }
        if (zconf.dryrun) {
          lock_file(stdout);
          (*((zconf.probe_module)->print_packet))(stdout, (void *)(buf));
          unlock_file(stdout);
        } else {
          contents = (void *)(buf + (unsigned long )zconf.send_ip_pkts * sizeof(struct ether_header ));
          length -= (unsigned long )zconf.send_ip_pkts * sizeof(struct ether_header );
          any_sends_successful = 0;
          i___1 = 0;
          while (i___1 < attempts) {
            tmp___16 = send_packet(st, contents, (int )length, idx);
            rc = tmp___16;
            if (rc < 0) {
              addr.s_addr = current_ip;
              tmp___17 = inet_ntop(2, (void const   * __restrict  )(& addr), (char * __restrict  )(addr_str_buf),
                                   (socklen_t )16);
              addr_str = tmp___17;
              if ((unsigned long )addr_str != (unsigned long )((void *)0)) {
                tmp___18 = __errno_location();
                tmp___19 = strerror(*tmp___18);
                log_debug("send", "send_packet failed for %s. %s", addr_str, tmp___19);
              }
            } else {
              any_sends_successful = 1;
              break;
            }
            i___1 ++;
          }
          if (! any_sends_successful) {
            (s->state.packets_failed) ++;
          }
          idx ++;
          idx &= 255U;
        }
        (s->state.packets_sent) ++;
        i___0 ++;
      }
      (s->state.hosts_scanned) ++;
      current_ip = shard_get_next_ip(s);
      if (zconf.list_of_ips_filename) {
        if (current_ip != 0U) {
          while (1) {
            tmp___20 = pbm_check(zsend.list_of_ips_pbm, current_ip);
            if (tmp___20) {
              break;
            }
            current_ip = shard_get_next_ip(s);
            if (current_ip == 0U) {
              log_debug("send", "send thread %hhu shard finished in get_next_ip_loop depleted",
                        (int )s->thread_id);
              goto cleanup;
            }
          }
        }
      }
      b ++;
    }
  }
  cleanup:
  (*(s->cb))(s->thread_id, s->arg);
  if (zconf.dryrun) {
    lock_file(stdout);
    fflush(stdout);
    unlock_file(stdout);
  }
  log_debug("send", "thread %hu cleanly finished", (int )s->thread_id);
  return (0);
}
}
#pragma merger("0","/tmp/cil-LkQAgilM.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__)) __realpath_chk_warn)(char const   * __restrict  __name ,
                                                                                                          char * __restrict  __resolved ,
                                                                                                          size_t __resolvedlen )  __asm__("__realpath_chk")  ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                              char * __restrict  __resolved ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                                                             char * __restrict  __resolved )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__resolved, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)__resolved, 1);
    if (tmp___1 < 4096UL) {
      tmp = __builtin_object_size((void *)__resolved, 1);
      tmp___0 = __realpath_chk_warn(__name, __resolved, tmp);
      return (tmp___0);
    }
    tmp___2 = __builtin_object_size((void *)__resolved, 1);
    tmp___3 = __realpath_chk(__name, __resolved, tmp___2);
    return (tmp___3);
  }
  tmp___5 = __realpath_alias(__name, __resolved);
  return (tmp___5);
}
}
extern uint32_t blocklist_lookup_index(uint64_t index ) ;
static uint32_t shard_roll_to_valid(shard_t *s )
{
  uint32_t tmp ;

  {
  if (s->current - 1UL < (uint64_t )zsend.max_index) {
    return ((uint32_t )s->current);
  }
  tmp = shard_get_next_ip(s);
  return (tmp);
}
}
void shard_init(shard_t *shard , uint16_t shard_idx , uint16_t num_shards , uint8_t thread_idx ,
                uint8_t num_threads , uint32_t max_total_targets , cycle_t const   *cycle ,
                void (*cb)(uint8_t id , void *arg ) , void *arg )
{
  uint32_t num_subshards ;
  uint64_t num_elts ;
  uint32_t sub_idx ;
  uint64_t exponent_begin ;
  uint64_t exponent_end ;
  mpz_t generator_m ;
  mpz_t exponent_begin_m ;
  mpz_t exponent_end_m ;
  mpz_t prime_m ;
  mpz_t start_m ;
  mpz_t stop_m ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  uint32_t max_targets_this_shard ;

  {
  if (! ((int )num_shards > 0)) {
    __assert_fail("num_shards > 0", "src/shard.c", 38U, "shard_init");
  }
  if (! ((int )num_threads > 0)) {
    __assert_fail("num_threads > 0", "src/shard.c", 39U, "shard_init");
  }
  if (! ((int )shard_idx < (int )num_shards)) {
    __assert_fail("shard_idx < num_shards", "src/shard.c", 40U, "shard_init");
  }
  if (! ((int )thread_idx < (int )num_threads)) {
    __assert_fail("thread_idx < num_threads", "src/shard.c", 41U, "shard_init");
  }
  num_subshards = (uint32_t )num_shards * (uint32_t )num_threads;
  num_elts = (uint64_t )cycle->order;
  if (! ((uint64_t )num_subshards < num_elts)) {
    __assert_fail("num_subshards < num_elts", "src/shard.c", 44U, "shard_init");
  }
  if (! (! max_total_targets)) {
    if (! (num_subshards <= max_total_targets)) {
      __assert_fail("!max_total_targets || (num_subshards <= max_total_targets)",
                    "src/shard.c", 45U, "shard_init");
    }
  }
  sub_idx = (uint32_t )((int )shard_idx * (int )num_threads + (int )thread_idx);
  exponent_begin = (num_elts / (uint64_t )num_subshards) * (uint64_t )sub_idx;
  exponent_end = (num_elts / (uint64_t )num_subshards) * (uint64_t )((sub_idx + 1U) % num_subshards);
  exponent_begin = (exponent_begin + (uint64_t )cycle->offset) % num_elts;
  exponent_end = (exponent_end + (uint64_t )cycle->offset) % num_elts;
  __gmpz_init_set_ui(generator_m, (unsigned long )cycle->generator);
  __gmpz_init_set_ui(exponent_begin_m, exponent_begin);
  __gmpz_init_set_ui(exponent_end_m, exponent_end);
  __gmpz_init_set_ui(prime_m, (unsigned long )(cycle->group)->prime);
  __gmpz_init(start_m);
  __gmpz_init(stop_m);
  __gmpz_powm(start_m, (mpz_srcptr )(generator_m), (mpz_srcptr )(exponent_begin_m),
              (mpz_srcptr )(prime_m));
  __gmpz_powm(stop_m, (mpz_srcptr )(generator_m), (mpz_srcptr )(exponent_end_m), (mpz_srcptr )(prime_m));
  tmp___5 = __gmpz_get_ui((mpz_srcptr )(start_m));
  shard->params.first = tmp___5;
  tmp___6 = __gmpz_get_ui((mpz_srcptr )(stop_m));
  shard->params.last = tmp___6;
  shard->params.factor = (uint64_t )cycle->generator;
  shard->params.modulus = (uint64_t )(cycle->group)->prime;
  shard->current = shard->params.first;
  shard->thread_id = thread_idx;
  if (max_total_targets > 0U) {
    max_targets_this_shard = max_total_targets / num_subshards;
    if (sub_idx < max_total_targets % num_subshards) {
      max_targets_this_shard ++;
    }
    shard->state.max_hosts = max_targets_this_shard;
  }
  shard->cb = cb;
  shard->arg = arg;
  shard_roll_to_valid(shard);
  __gmpz_clear(generator_m);
  __gmpz_clear(exponent_begin_m);
  __gmpz_clear(exponent_end_m);
  __gmpz_clear(prime_m);
  __gmpz_clear(start_m);
  __gmpz_clear(stop_m);
  return;
}
}
uint32_t shard_get_cur_ip(shard_t *shard )
{
  uint32_t tmp ;

  {
  tmp = blocklist_lookup_index(shard->current - 1UL);
  return (tmp);
}
}
__inline static uint32_t shard_get_next_elem(shard_t *shard )
{


  {
  while (1) {
    shard->current *= shard->params.factor;
    shard->current %= shard->params.modulus;
    if (! ((unsigned long long )shard->current >= (unsigned long long )(1LL << 32))) {
      break;
    }
  }
  return ((uint32_t )shard->current);
}
}
uint32_t shard_get_next_ip(shard_t *shard )
{
  uint32_t candidate ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  if (shard->current == 0UL) {
    return ((uint32_t )0);
  }
  while (1) {
    tmp = shard_get_next_elem(shard);
    candidate = tmp;
    if ((uint64_t )candidate == shard->params.last) {
      shard->current = (uint64_t )0;
      (shard->iterations) ++;
      return ((uint32_t )0);
    }
    if (candidate - 1U < zsend.max_index) {
      (shard->state.hosts_allowlisted) ++;
      (shard->iterations) ++;
      tmp___0 = blocklist_lookup_index((uint64_t )(candidate - 1U));
      return (tmp___0);
    }
    (shard->state.hosts_blocklisted) ++;
  }
}
}
#pragma merger("0","/tmp/cil-UBUyuMIa.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
sock_t get_dryrun_socket(void) ;
sock_t get_dryrun_socket(void)
{
  int sock ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  sock_t s ;

  {
  tmp = socket(2, 1, 0);
  sock = tmp;
  if (sock <= 0) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    log_fatal("send", "couldn\'t create socket. Error: %s\n", tmp___1);
  }
  s.sock = sock;
  return (s);
}
}
#pragma merger("0","/tmp/cil-F1NNSN1X.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
void init_empty_global_configuration(struct state_conf *c ) ;
struct state_conf zconf  =
     {6, (port_h_t )0, (port_h_t )32768, (port_h_t )61000, 4294967295U, (uint32_t )0,
    (uint32_t )0, (char *)((void *)0), -1, (uint64_t )0, 0, (uint8_t )1, (uint8_t )1,
    0U, (uint32_t *)0, 0, (uint64_t )0, (aesrand_t *)0, 0U, (unsigned short)0, (unsigned short)0,
    1, (struct probe_module *)((void *)0), (char *)0, (struct output_module *)((void *)0),
    (char *)((void *)0), (uint8_t )255, (char *)((void *)0), {(macaddr_t )0}, {(macaddr_t )0},
    (uint32_t )0, 0, 0, {0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,
                         0U}, (uint32_t )0, 0, (char *)((void *)0), (char *)((void *)0),
    (char *)((void *)0), (char *)((void *)0), (uint32_t )0, (char *)((void *)0), (FILE *)((void *)0),
    (char *)((void *)0), (char *)((void *)0), (char **)0, 0, (char const   *)((void *)0),
    (char const   **)((void *)0), {(node_t *)0}, (char *)((void *)0), {{{{(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0},
                                                                         {(char const   *)0,
                                                                          (char const   *)0,
                                                                          (char const   *)0}},
                                                                        0}, {{{(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0},
                                                                              {(char const   *)0,
                                                                               (char const   *)0,
                                                                               (char const   *)0}},
                                                                             0}, {0,
                                                                                  {0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0}},
                                                                       0, 0, 0}, 0,
    (char *)((void *)0), (char *)((void *)0), (char *)((void *)0), 0, 0, 0, 1, 0,
    0, 0UL, 0UL, -1, (float )0.0, 0, 0, 0};
void init_empty_global_configuration(struct state_conf *c )
{


  {
  memset((void *)(c->source_ip_addresses), 0, sizeof(c->source_ip_addresses));
  return;
}
}
struct state_send zsend  =
     {0.0, 0.0, (uint64_t )0, (uint64_t )0, (uint64_t )0, (uint64_t )0, 1, 0, 0U, (uint32_t )0,
    (uint32_t )0, 0U, (uint8_t **)((void *)0)};
struct state_recv zrecv  =
     {(uint32_t )0, (uint32_t )0, (uint32_t )0, (uint32_t )0, (uint32_t )0, (uint32_t )0,
    (uint32_t )0, (uint64_t )0, (uint32_t )0, (uint32_t )0, (uint32_t )0, 0, 0., 0.,
    (uint32_t )0, (uint32_t )0, (uint32_t )0};
/* compiler builtin:
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
#pragma merger("0","/tmp/cil-G2rwtN4f.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
void json_metadata(FILE *file___1 ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern struct hostent *gethostbyname(char const   *__name ) ;
extern size_t dstrftime(char * , size_t  , char const   * , double  ) ;
extern bl_cidr_node_t *get_blocklisted_cidrs(void) ;
extern bl_cidr_node_t *get_allowlisted_cidrs(void) ;
extern int json_object_put(struct json_object *obj ) ;
extern char const   *json_object_to_json_string(struct json_object *obj ) ;
extern struct json_object *json_object_new_object(void) ;
extern int json_object_object_add(struct json_object *obj , char const   *key , struct json_object *val ) ;
extern struct json_object *json_object_new_array(void) ;
extern int json_object_array_add(struct json_object *obj , struct json_object *val ) ;
extern struct json_object *json_object_new_int(int32_t i ) ;
extern struct json_object *json_object_new_int64(int64_t i ) ;
extern struct json_object *json_object_new_double(double d ) ;
extern struct json_object *json_object_new_string(char const   *s ) ;
extern struct json_object *json_tokener_parse(char const   *str ) ;
void json_metadata(FILE *file___1 )
{
  char send_start_time[1025] ;
  size_t tmp___2 ;
  char send_end_time[1025] ;
  size_t tmp___6 ;
  char recv_start_time[1025] ;
  size_t tmp___10 ;
  char recv_end_time[1025] ;
  size_t tmp___14 ;
  double hitrate ;
  json_object *obj ;
  struct json_object *tmp___15 ;
  char hostname[1024] ;
  struct json_object *tmp___16 ;
  struct hostent *h ;
  struct hostent *tmp___17 ;
  struct json_object *tmp___18 ;
  int tmp___19 ;
  struct json_object *tmp___20 ;
  struct json_object *tmp___21 ;
  struct json_object *tmp___22 ;
  struct json_object *tmp___23 ;
  struct json_object *tmp___24 ;
  struct json_object *tmp___25 ;
  struct json_object *tmp___26 ;
  struct json_object *tmp___27 ;
  struct json_object *tmp___28 ;
  struct json_object *tmp___29 ;
  struct json_object *tmp___30 ;
  struct json_object *tmp___31 ;
  struct json_object *tmp___32 ;
  struct json_object *tmp___33 ;
  struct json_object *tmp___34 ;
  struct json_object *tmp___35 ;
  struct json_object *tmp___36 ;
  struct json_object *tmp___37 ;
  struct json_object *tmp___38 ;
  struct json_object *tmp___39 ;
  struct json_object *tmp___40 ;
  struct json_object *tmp___41 ;
  struct json_object *tmp___42 ;
  struct json_object *tmp___43 ;
  struct json_object *tmp___44 ;
  struct json_object *tmp___45 ;
  struct json_object *tmp___46 ;
  struct json_object *tmp___47 ;
  struct json_object *tmp___48 ;
  struct json_object *tmp___49 ;
  struct json_object *tmp___50 ;
  struct json_object *tmp___51 ;
  struct json_object *tmp___52 ;
  struct json_object *tmp___53 ;
  struct json_object *tmp___54 ;
  struct json_object *tmp___55 ;
  struct json_object *tmp___56 ;
  struct json_object *tmp___57 ;
  struct json_object *tmp___58 ;
  struct json_object *tmp___59 ;
  struct json_object *tmp___60 ;
  struct json_object *tmp___61 ;
  struct json_object *tmp___62 ;
  struct json_object *tmp___63 ;
  struct json_object *tmp___64 ;
  struct json_object *tmp___65 ;
  struct json_object *tmp___66 ;
  struct json_object *tmp___67 ;
  struct json_object *tmp___68 ;
  struct json_object *tmp___69 ;
  struct json_object *tmp___70 ;
  json_object *cli_dest_cidrs ;
  struct json_object *tmp___71 ;
  int i ;
  struct json_object *tmp___72 ;
  struct json_object *tmp___73 ;
  struct json_object *tmp___74 ;
  struct json_object *tmp___75 ;
  char mac_buf[18] ;
  char *p ;
  int i___0 ;
  unsigned long tmp___76 ;
  unsigned long tmp___77 ;
  struct json_object *tmp___78 ;
  struct in_addr addr ;
  char *tmp___79 ;
  struct json_object *tmp___80 ;
  char mac_buf___0[18] ;
  char *p___0 ;
  int i___1 ;
  unsigned long tmp___81 ;
  unsigned long tmp___82 ;
  struct json_object *tmp___83 ;
  json_object *source_ips ;
  struct json_object *tmp___84 ;
  uint i___2 ;
  struct in_addr temp ;
  char *tmp___85 ;
  char *tmp___86 ;
  struct json_object *tmp___87 ;
  struct json_object *tmp___88 ;
  struct json_object *tmp___89 ;
  struct json_object *tmp___90 ;
  struct json_object *tmp___91 ;
  struct json_object *tmp___92 ;
  struct json_object *tmp___93 ;
  struct json_object *tmp___94 ;
  struct json_object *tmp___95 ;
  json_object *user ;
  struct json_object *tmp___96 ;
  struct json_object *tmp___97 ;
  bl_cidr_node_t *b ;
  bl_cidr_node_t *tmp___98 ;
  json_object *blocklisted_cidrs ;
  struct json_object *tmp___99 ;
  char cidr[50] ;
  struct in_addr addr___0 ;
  char *tmp___100 ;
  unsigned long tmp___101 ;
  struct json_object *tmp___102 ;
  json_object *allowlisted_cidrs ;
  struct json_object *tmp___103 ;
  char cidr___0[50] ;
  struct in_addr addr___1 ;
  char *tmp___104 ;
  unsigned long tmp___105 ;
  struct json_object *tmp___106 ;
  char const   *tmp___107 ;

  {
  tmp___2 = dstrftime(send_start_time, (size_t )1024, "%Y-%m-%dT%H:%M:%S%z", zsend.start);
  if (! tmp___2) {
    __assert_fail("dstrftime(send_start_time, STRTIME_LEN, \"%Y-%m-%dT%H:%M:%S%z\", zsend.start)",
                  "src/summary.c", 34U, "json_metadata");
  }
  tmp___6 = dstrftime(send_end_time, (size_t )1024, "%Y-%m-%dT%H:%M:%S%z", zsend.finish);
  if (! tmp___6) {
    __assert_fail("dstrftime(send_end_time, STRTIME_LEN, \"%Y-%m-%dT%H:%M:%S%z\", zsend.finish)",
                  "src/summary.c", 37U, "json_metadata");
  }
  tmp___10 = dstrftime(recv_start_time, (size_t )1024, "%Y-%m-%dT%H:%M:%S%z", zrecv.start);
  if (! tmp___10) {
    __assert_fail("dstrftime(recv_start_time, STRTIME_LEN, \"%Y-%m-%dT%H:%M:%S%z\", zrecv.start)",
                  "src/summary.c", 40U, "json_metadata");
  }
  tmp___14 = dstrftime(recv_end_time, (size_t )1024, "%Y-%m-%dT%H:%M:%S%z", zrecv.finish);
  if (! tmp___14) {
    __assert_fail("dstrftime(recv_end_time, STRTIME_LEN, \"%Y-%m-%dT%H:%M:%S%z\", zrecv.finish)",
                  "src/summary.c", 43U, "json_metadata");
  }
  hitrate = ((double )100 * (double )zrecv.success_unique) / (double )zsend.hosts_scanned;
  tmp___15 = json_object_new_object();
  obj = tmp___15;
  tmp___19 = gethostname(hostname, (size_t )1023);
  if (tmp___19 < 0) {
    log_error("json_metadata", "unable to retrieve local hostname");
  } else {
    hostname[1023] = (char )'\000';
    tmp___16 = json_object_new_string((char const   *)(hostname));
    json_object_object_add(obj, "local_hostname", tmp___16);
    tmp___17 = gethostbyname((char const   *)(hostname));
    h = tmp___17;
    if (h) {
      tmp___18 = json_object_new_string((char const   *)h->h_name);
      json_object_object_add(obj, "full_hostname", tmp___18);
    } else {
      log_error("json_metadata", "unable to retrieve complete hostname");
    }
  }
  tmp___20 = json_object_new_int((int32_t )zconf.target_port);
  json_object_object_add(obj, "target_port", tmp___20);
  tmp___21 = json_object_new_int((int32_t )zconf.source_port_first);
  json_object_object_add(obj, "source_port_first", tmp___21);
  tmp___22 = json_object_new_int((int32_t )zconf.source_port_last);
  json_object_object_add(obj, "source_port_last", tmp___22);
  tmp___23 = json_object_new_int((int32_t )zconf.max_targets);
  json_object_object_add(obj, "max_targets", tmp___23);
  tmp___24 = json_object_new_int((int32_t )zconf.max_runtime);
  json_object_object_add(obj, "max_runtime", tmp___24);
  tmp___25 = json_object_new_int((int32_t )zconf.max_results);
  json_object_object_add(obj, "max_results", tmp___25);
  tmp___26 = json_object_new_int((int32_t )zrecv.filter_success);
  json_object_object_add(obj, "output_results", tmp___26);
  if (zconf.iface) {
    tmp___27 = json_object_new_string((char const   *)zconf.iface);
    json_object_object_add(obj, "iface", tmp___27);
  }
  tmp___28 = json_object_new_int(zconf.rate);
  json_object_object_add(obj, "rate", tmp___28);
  tmp___29 = json_object_new_int((int32_t )zconf.bandwidth);
  json_object_object_add(obj, "bandwidth", tmp___29);
  tmp___30 = json_object_new_int(zconf.cooldown_secs);
  json_object_object_add(obj, "cooldown_secs", tmp___30);
  tmp___31 = json_object_new_int((int32_t )zconf.senders);
  json_object_object_add(obj, "senders", tmp___31);
  tmp___32 = json_object_new_int64((int64_t )zconf.seed);
  json_object_object_add(obj, "seed", tmp___32);
  tmp___33 = json_object_new_int64((int64_t )zconf.seed_provided);
  json_object_object_add(obj, "seed_provided", tmp___33);
  tmp___34 = json_object_new_int64((int64_t )zconf.generator);
  json_object_object_add(obj, "generator", tmp___34);
  tmp___35 = json_object_new_double(hitrate);
  json_object_object_add(obj, "hitrate", tmp___35);
  tmp___36 = json_object_new_int((int32_t )zconf.shard_num);
  json_object_object_add(obj, "shard_num", tmp___36);
  tmp___37 = json_object_new_int((int32_t )zconf.total_shards);
  json_object_object_add(obj, "total_shards", tmp___37);
  tmp___38 = json_object_new_double((double )zconf.min_hitrate);
  json_object_object_add(obj, "min_hitrate", tmp___38);
  tmp___39 = json_object_new_int(zconf.max_sendto_failures);
  json_object_object_add(obj, "max_sendto_failures", tmp___39);
  tmp___40 = json_object_new_int(zconf.syslog);
  json_object_object_add(obj, "syslog", tmp___40);
  tmp___41 = json_object_new_int(zconf.default_mode);
  json_object_object_add(obj, "default_mode", tmp___41);
  tmp___42 = json_object_new_int((int32_t )zrecv.pcap_recv);
  json_object_object_add(obj, "pcap_recv", tmp___42);
  tmp___43 = json_object_new_int((int32_t )zrecv.pcap_drop);
  json_object_object_add(obj, "pcap_drop", tmp___43);
  tmp___44 = json_object_new_int((int32_t )zrecv.pcap_ifdrop);
  json_object_object_add(obj, "pcap_ifdrop", tmp___44);
  tmp___45 = json_object_new_int((int32_t )zrecv.ip_fragments);
  json_object_object_add(obj, "ip_fragments", tmp___45);
  tmp___46 = json_object_new_int64((int64_t )zconf.total_allowed);
  json_object_object_add(obj, "blocklist_total_allowed", tmp___46);
  tmp___47 = json_object_new_int64((int64_t )zconf.total_disallowed);
  json_object_object_add(obj, "blocklist_total_not_allowed", tmp___47);
  tmp___48 = json_object_new_int((int32_t )zrecv.validation_passed);
  json_object_object_add(obj, "validation_passed", tmp___48);
  tmp___49 = json_object_new_int((int32_t )zrecv.validation_failed);
  json_object_object_add(obj, "validation_failed", tmp___49);
  tmp___50 = json_object_new_int64((int64_t )zsend.first_scanned);
  json_object_object_add(obj, "first_scanned", tmp___50);
  tmp___51 = json_object_new_int64((int64_t )zsend.sendto_failures);
  json_object_object_add(obj, "send_to_failures", tmp___51);
  tmp___52 = json_object_new_int64((int64_t )zsend.packets_sent);
  json_object_object_add(obj, "packets_sent", tmp___52);
  tmp___53 = json_object_new_int64((int64_t )zsend.hosts_scanned);
  json_object_object_add(obj, "hosts_scanned", tmp___53);
  tmp___54 = json_object_new_int64((int64_t )zrecv.success_total);
  json_object_object_add(obj, "success_total", tmp___54);
  tmp___55 = json_object_new_int64((int64_t )zrecv.success_unique);
  json_object_object_add(obj, "success_unique", tmp___55);
  if (zconf.fsconf.app_success_index >= 0) {
    tmp___56 = json_object_new_int64((int64_t )zrecv.app_success_total);
    json_object_object_add(obj, "app_success_total", tmp___56);
    tmp___57 = json_object_new_int64((int64_t )zrecv.app_success_unique);
    json_object_object_add(obj, "app_success_unique", tmp___57);
  }
  tmp___58 = json_object_new_int64((int64_t )zrecv.cooldown_total);
  json_object_object_add(obj, "success_cooldown_total", tmp___58);
  tmp___59 = json_object_new_int64((int64_t )zrecv.cooldown_unique);
  json_object_object_add(obj, "success_cooldown_unique", tmp___59);
  tmp___60 = json_object_new_int64((int64_t )zrecv.failure_total);
  json_object_object_add(obj, "failure_total", tmp___60);
  tmp___61 = json_object_new_int(zconf.packet_streams);
  json_object_object_add(obj, "packet_streams", tmp___61);
  tmp___62 = json_object_new_string((zconf.probe_module)->name);
  json_object_object_add(obj, "probe_module", tmp___62);
  tmp___63 = json_object_new_string((zconf.output_module)->name);
  json_object_object_add(obj, "output_module", tmp___63);
  tmp___64 = json_object_new_string((char const   *)(send_start_time));
  json_object_object_add(obj, "send_start_time", tmp___64);
  tmp___65 = json_object_new_string((char const   *)(send_end_time));
  json_object_object_add(obj, "send_end_time", tmp___65);
  tmp___66 = json_object_new_string((char const   *)(recv_start_time));
  json_object_object_add(obj, "recv_start_time", tmp___66);
  tmp___67 = json_object_new_string((char const   *)(recv_end_time));
  json_object_object_add(obj, "recv_end_time", tmp___67);
  if (zconf.output_filter_str) {
    tmp___68 = json_object_new_string((char const   *)zconf.output_filter_str);
    json_object_object_add(obj, "output_filter", tmp___68);
  }
  if (zconf.log_file) {
    tmp___69 = json_object_new_string((char const   *)zconf.log_file);
    json_object_object_add(obj, "log_file", tmp___69);
  }
  if (zconf.log_directory) {
    tmp___70 = json_object_new_string((char const   *)zconf.log_directory);
    json_object_object_add(obj, "log_directory", tmp___70);
  }
  if (zconf.destination_cidrs_len) {
    tmp___71 = json_object_new_array();
    cli_dest_cidrs = tmp___71;
    i = 0;
    while (i < zconf.destination_cidrs_len) {
      tmp___72 = json_object_new_string((char const   *)*(zconf.destination_cidrs + i));
      json_object_array_add(cli_dest_cidrs, tmp___72);
      i ++;
    }
    json_object_object_add(obj, "cli_cidr_destinations", cli_dest_cidrs);
  }
  if (zconf.probe_args) {
    tmp___73 = json_object_new_string((char const   *)zconf.probe_args);
    json_object_object_add(obj, "probe_args", tmp___73);
  }
  if (zconf.probe_ttl) {
    tmp___74 = json_object_new_int((int32_t )zconf.probe_ttl);
    json_object_object_add(obj, "probe_ttl", tmp___74);
  }
  if (zconf.output_args) {
    tmp___75 = json_object_new_string((char const   *)zconf.output_args);
    json_object_object_add(obj, "output_args", tmp___75);
  }
  memset((void *)(mac_buf), 0, sizeof(mac_buf));
  p = mac_buf;
  i___0 = 0;
  while (i___0 < 6) {
    if (i___0 == 5) {
      tmp___76 = __builtin_object_size((void *)p, 1);
      __builtin___snprintf_chk(p, 3UL, 1, tmp___76, "%.2x", (int )zconf.gw_mac[i___0]);
      p += 2;
    } else {
      tmp___77 = __builtin_object_size((void *)p, 1);
      __builtin___snprintf_chk(p, 4UL, 1, tmp___77, "%.2x:", (int )zconf.gw_mac[i___0]);
      p += 3;
    }
    i___0 ++;
  }
  tmp___78 = json_object_new_string((char const   *)(mac_buf));
  json_object_object_add(obj, "gateway_mac", tmp___78);
  if (zconf.gw_ip) {
    addr.s_addr = zconf.gw_ip;
    tmp___79 = inet_ntoa(addr);
    tmp___80 = json_object_new_string((char const   *)tmp___79);
    json_object_object_add(obj, "gateway_ip", tmp___80);
  }
  p___0 = mac_buf___0;
  i___1 = 0;
  while (i___1 < 6) {
    if (i___1 == 5) {
      tmp___81 = __builtin_object_size((void *)p___0, 1);
      __builtin___snprintf_chk(p___0, 3UL, 1, tmp___81, "%.2x", (int )zconf.hw_mac[i___1]);
      p___0 += 2;
    } else {
      tmp___82 = __builtin_object_size((void *)p___0, 1);
      __builtin___snprintf_chk(p___0, 4UL, 1, tmp___82, "%.2x:", (int )zconf.hw_mac[i___1]);
      p___0 += 3;
    }
    i___1 ++;
  }
  tmp___83 = json_object_new_string((char const   *)(mac_buf___0));
  json_object_object_add(obj, "source_mac", tmp___83);
  tmp___84 = json_object_new_array();
  source_ips = tmp___84;
  i___2 = (uint )0;
  while (i___2 < zconf.number_source_ips) {
    temp.s_addr = zconf.source_ip_addresses[i___2];
    tmp___85 = inet_ntoa(temp);
    tmp___86 = strdup((char const   *)tmp___85);
    tmp___87 = json_object_new_string((char const   *)tmp___86);
    json_object_array_add(source_ips, tmp___87);
    i___2 ++;
  }
  json_object_object_add(obj, "source_ips", source_ips);
  if (zconf.output_filename) {
    tmp___88 = json_object_new_string((char const   *)zconf.output_filename);
    json_object_object_add(obj, "output_filename", tmp___88);
  }
  if (zconf.blocklist_filename) {
    tmp___89 = json_object_new_string((char const   *)zconf.blocklist_filename);
    json_object_object_add(obj, "blocklist_filename", tmp___89);
  }
  if (zconf.allowlist_filename) {
    tmp___90 = json_object_new_string((char const   *)zconf.allowlist_filename);
    json_object_object_add(obj, "allowlist_filename", tmp___90);
  }
  if (zconf.list_of_ips_filename) {
    tmp___91 = json_object_new_string((char const   *)zconf.list_of_ips_filename);
    json_object_object_add(obj, "list_of_ips_filename", tmp___91);
    tmp___92 = json_object_new_int((int32_t )zconf.list_of_ips_count);
    json_object_object_add(obj, "list_of_ips_count", tmp___92);
  }
  tmp___93 = json_object_new_int(zconf.dryrun);
  json_object_object_add(obj, "dryrun", tmp___93);
  tmp___94 = json_object_new_int(zconf.quiet);
  json_object_object_add(obj, "quiet", tmp___94);
  tmp___95 = json_object_new_int(zconf.log_level);
  json_object_object_add(obj, "log_level", tmp___95);
  if (zconf.custom_metadata_str) {
    tmp___96 = json_tokener_parse((char const   *)zconf.custom_metadata_str);
    user = tmp___96;
    if (! user) {
      log_error("json-metadata", "unable to parse user metadata");
    } else {
      json_object_object_add(obj, "user-metadata", user);
    }
  }
  if (zconf.notes) {
    tmp___97 = json_object_new_string((char const   *)zconf.notes);
    json_object_object_add(obj, "notes", tmp___97);
  }
  tmp___98 = get_blocklisted_cidrs();
  b = tmp___98;
  if (b) {
    tmp___99 = json_object_new_array();
    blocklisted_cidrs = tmp___99;
    while (1) {
      addr___0.s_addr = b->ip_address;
      tmp___100 = inet_ntoa(addr___0);
      tmp___101 = __builtin_object_size((void *)(cidr), 1);
      __builtin___sprintf_chk(cidr, 1, tmp___101, "%s/%i", tmp___100, b->prefix_len);
      tmp___102 = json_object_new_string((char const   *)(cidr));
      json_object_array_add(blocklisted_cidrs, tmp___102);
      if (b) {
        b = b->next;
        if (! b) {
          break;
        }
      } else {
        break;
      }
    }
    json_object_object_add(obj, "blocklisted_networks", blocklisted_cidrs);
  }
  b = get_allowlisted_cidrs();
  if (b) {
    tmp___103 = json_object_new_array();
    allowlisted_cidrs = tmp___103;
    while (1) {
      addr___1.s_addr = b->ip_address;
      tmp___104 = inet_ntoa(addr___1);
      tmp___105 = __builtin_object_size((void *)(cidr___0), 1);
      __builtin___sprintf_chk(cidr___0, 1, tmp___105, "%s/%i", tmp___104, b->prefix_len);
      tmp___106 = json_object_new_string((char const   *)(cidr___0));
      json_object_array_add(allowlisted_cidrs, tmp___106);
      if (b) {
        b = b->next;
        if (! b) {
          break;
        }
      } else {
        break;
      }
    }
    json_object_object_add(obj, "allowlisted_networks", allowlisted_cidrs);
  }
  tmp___107 = json_object_to_json_string(obj);
  __fprintf_chk((FILE * __restrict  )file___1, 1, (char const   * __restrict  )"%s\n",
                tmp___107);
  json_object_put(obj);
  return;
}
}
#pragma merger("0","/tmp/cil-wSKB7iS0.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
void parse_source_ip_addresses(char *given_string ) ;
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
in_addr_t string_to_ip_address(char *t )
{
  in_addr_t r ;
  in_addr_t tmp ;

  {
  tmp = inet_addr((char const   *)t);
  r = tmp;
  if (r == 4294967295U) {
    log_fatal("send", "invalid ip address: `%s\'", t);
  }
  return (r);
}
}
void add_to_array(char *to_add )
{


  {
  if (zconf.number_source_ips >= 256U) {
    log_fatal("parse", "over 256 source IP addresses provided");
  }
  log_debug("SEND", "ipaddress: %s\n", to_add);
  zconf.source_ip_addresses[zconf.number_source_ips] = string_to_ip_address(to_add);
  (zconf.number_source_ips) ++;
  return;
}
}
void parse_source_ip_addresses(char *given_string )
{
  char *dash ;
  char *tmp ;
  char *comma ;
  char *tmp___0 ;
  in_addr_t start ;
  in_addr_t tmp___1 ;
  __uint32_t tmp___2 ;
  in_addr_t end ;
  in_addr_t tmp___3 ;
  __uint32_t tmp___4 ;
  struct in_addr temp ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  tmp = strchr((char const   *)given_string, '-');
  dash = tmp;
  tmp___0 = strchr((char const   *)given_string, ',');
  comma = tmp___0;
  if (dash) {
    if (comma) {
      *comma = (char )'\000';
      parse_source_ip_addresses(given_string);
      parse_source_ip_addresses(comma + 1);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */
  if (comma) {
    while (comma) {
      *comma = (char )'\000';
      add_to_array(given_string);
      given_string = comma + 1;
      comma = strchr((char const   *)given_string, ',');
      if (! comma) {
        add_to_array(given_string);
      }
    }
  } else
  if (dash) {
    *dash = (char )'\000';
    log_debug("SEND", "address: %s\n", given_string);
    log_debug("SEND", "address: %s\n", dash + 1);
    tmp___1 = string_to_ip_address(given_string);
    tmp___2 = __bswap_32(tmp___1);
    start = tmp___2;
    tmp___3 = string_to_ip_address(dash + 1);
    tmp___4 = __bswap_32(tmp___3);
    end = tmp___4 + 1U;
    while (start != end) {
      temp.s_addr = __bswap_32(start);
      tmp___5 = inet_ntoa(temp);
      tmp___6 = strdup((char const   *)tmp___5);
      add_to_array(tmp___6);
      start ++;
    }
  } else {
    add_to_array(given_string);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-Lzz7G7AU.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
void validate_gen_ex(uint32_t const   input0 , uint32_t const   input1 , uint32_t const   input2 ,
                     uint32_t const   input3 , uint8_t *output ) ;
static int inited  =    0;
static uint32_t aes_sched[44]  ;
void validate_init(void)
{
  uint8_t key[16] ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = random_bytes((void *)(key), (size_t )16);
  if (! tmp) {
    log_fatal("validate", "couldn\'t get random bytes");
  }
  tmp___0 = rijndaelKeySetupEnc(aes_sched, (u8 const   *)(key), 128);
  if (tmp___0 != 10) {
    log_fatal("validate", "couldn\'t initialize AES key");
  }
  inited = 1;
  return;
}
}
void validate_gen(uint32_t const   src , uint32_t const   dst , uint8_t *output )
{


  {
  validate_gen_ex(src, dst, (uint32_t const   )0, (uint32_t const   )0, output);
  return;
}
}
void validate_gen_ex(uint32_t const   input0 , uint32_t const   input1 , uint32_t const   input2 ,
                     uint32_t const   input3 , uint8_t *output )
{
  uint32_t aes_input[4] ;

  {
  if (! inited) {
    __assert_fail("inited", "src/validate.c", 45U, "validate_gen_ex");
  }
  aes_input[0] = (uint32_t )input0;
  aes_input[1] = (uint32_t )input1;
  aes_input[2] = (uint32_t )input2;
  aes_input[3] = (uint32_t )input3;
  rijndaelEncrypt((u32 const   *)(aes_sched), 10, (u8 const   *)((uint8_t *)(aes_input)),
                  output);
  return;
}
}
/* compiler builtin:
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-3ST6hNJ1.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) vasprintf)(char ** __restrict  __ptr , char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fgets_unlocked)(char * __restrict  __s ,
                                                                                                                   int __n ,
                                                                                                                   FILE * __restrict  __stream ) ;
extern __ssize_t ( __attribute__((__warn_unused_result__)) __getdelim)(char ** __restrict  __lineptr ,
                                                                       size_t * __restrict  __n ,
                                                                       int __delimiter ,
                                                                       FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                                             size_t * __restrict  __n ,
                                                                                             FILE * __restrict  __stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__gnu_inline__,
__always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack , char const   * __restrict  __fmt ,
                                     __gnuc_va_list __ap ) ;
__inline extern __ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                                             size_t * __restrict  __n ,
                                                                                             FILE * __restrict  __stream )
{
  __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__warn_unused_result__)) __vasprintf_chk)(char ** __restrict  __ptr ,
                                                                                                                           int __flag ,
                                                                                                                           char const   * __restrict  __fmt ,
                                                                                                                           __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  __obstack_vprintf_chk)(struct obstack * __restrict  __obstack ,
                                                                                          int __flag ,
                                                                                          char const   * __restrict  __format ,
                                                                                          __gnuc_va_list __args ) ;
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) vasprintf)(char ** __restrict  __ptr , char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) vasprintf)(char ** __restrict  __ptr , char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap )
{
  int tmp ;

  {
  tmp = __vasprintf_chk(__ptr, 1, __fmt, __ap);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__gnu_inline__,
__always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack , char const   * __restrict  __fmt ,
                                     __gnuc_va_list __ap ) ;
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack ,
                                                                                                                 char const   * __restrict  __fmt ,
                                                                                                                 __gnuc_va_list __ap )
{
  int tmp ;

  {
  tmp = __obstack_vprintf_chk(__obstack, 1, __fmt, __ap);
  return (tmp);
}
}
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_chk)(char * __restrict  __s ,
                                                                             size_t __size ,
                                                                             int __n ,
                                                                             FILE * __restrict  __stream ) ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_alias)(char * __restrict  __s ,
                                                                               int __n ,
                                                                               FILE * __restrict  __stream )  __asm__("fgets_unlocked")  ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_chk_warn)(char * __restrict  __s ,
                                                                                  size_t __size ,
                                                                                  int __n ,
                                                                                  FILE * __restrict  __stream )  __asm__("__fgets_unlocked_chk")  ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fgets_unlocked)(char * __restrict  __s ,
                                                                                                                   int __n ,
                                                                                                                   FILE * __restrict  __stream )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__s, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __fgets_unlocked_chk(__s, tmp, __n, __stream);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__s, 1);
    if ((size_t )__n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__s, 1);
      tmp___2 = __fgets_unlocked_chk_warn(__s, tmp___1, __n, __stream);
      return (tmp___2);
    }
  }
  tmp___5 = __fgets_unlocked_alias(__s, __n, __stream);
  return (tmp___5);
}
}
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__gnu_inline__, __always_inline__)) mempcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                                             size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__gnu_inline__, __always_inline__)) stpcpy)(char * __restrict  __dest , char const   * __restrict  __src ) ;
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__gnu_inline__, __always_inline__)) mempcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                                             size_t __len ) ;
__inline extern void *( __attribute__((__nonnull__(1,2), __gnu_inline__, __always_inline__)) mempcpy)(void * __restrict  __dest ,
                                                                                                      void const   * __restrict  __src ,
                                                                                                      size_t __len )
{
  unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 0);
  tmp___0 = __builtin___mempcpy_chk((void *)__dest, (void const   *)__src, __len,
                                    tmp);
  return (tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__gnu_inline__, __always_inline__)) stpcpy)(char * __restrict  __dest , char const   * __restrict  __src ) ;
__inline extern char *( __attribute__((__nonnull__(1,2), __gnu_inline__, __always_inline__)) stpcpy)(char * __restrict  __dest ,
                                                                                                     char const   * __restrict  __src )
{
  unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___stpcpy_chk((char *)__dest, (char const   *)__src, tmp);
  return (tmp___0);
}
}
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) pread)(int __fd ,
                                                                                                            void *__buf ,
                                                                                                            size_t __nbytes ,
                                                                                                            __off_t __offset ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) pread64)(int __fd ,
                                                                                                              void *__buf ,
                                                                                                              size_t __nbytes ,
                                                                                                              __off64_t __offset ) ;
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_chk)(int __fd , void *__buf ,
                                                                      size_t __nbytes ,
                                                                      __off_t __offset ,
                                                                      size_t __bufsize ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_chk)(int __fd ,
                                                                        void *__buf ,
                                                                        size_t __nbytes ,
                                                                        __off64_t __offset ,
                                                                        size_t __bufsize ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_alias)(int __fd ,
                                                                        void *__buf ,
                                                                        size_t __nbytes ,
                                                                        __off_t __offset )  __asm__("pread")  ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_alias)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          __off64_t __offset )  __asm__("pread64")  ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_chk_warn)(int __fd ,
                                                                           void *__buf ,
                                                                           size_t __nbytes ,
                                                                           __off_t __offset ,
                                                                           size_t __bufsize )  __asm__("__pread_chk")  ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_chk_warn)(int __fd ,
                                                                             void *__buf ,
                                                                             size_t __nbytes ,
                                                                             __off64_t __offset ,
                                                                             size_t __bufsize )  __asm__("__pread64_chk")  ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) pread)(int __fd ,
                                                                                                            void *__buf ,
                                                                                                            size_t __nbytes ,
                                                                                                            __off_t __offset )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size(__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __pread_chk(__fd, __buf, __nbytes, __offset, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size(__buf, 0);
    if (__nbytes > tmp___3) {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __pread_alias(__fd, __buf, __nbytes, __offset);
  return (tmp___5);
}
}
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) pread64)(int __fd ,
                                                                                                              void *__buf ,
                                                                                                              size_t __nbytes ,
                                                                                                              __off64_t __offset )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size(__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __pread64_chk(__fd, __buf, __nbytes, __offset, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size(__buf, 0);
    if (__nbytes > tmp___3) {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __pread64_alias(__fd, __buf, __nbytes, __offset);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __always_inline__)) recvfrom)(int __fd ,
                                                                                       void * __restrict  __buf ,
                                                                                       size_t __n ,
                                                                                       int __flags ,
                                                                                       struct sockaddr * __restrict  __cil_tmp14 ,
                                                                                       socklen_t * __restrict  __addr_len )
{
  __SOCKADDR_ARG __addr ;
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  __addr.__sockaddr__ = __cil_tmp14;
  tmp___4 = __builtin_object_size((void *)__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 0);
    tmp___0 = __recvfrom_chk(__fd, __buf, __n, tmp, __flags, __addr.__sockaddr__,
                             __addr_len);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 0);
    if (__n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 0);
      tmp___2 = __recvfrom_chk_warn(__fd, __buf, __n, tmp___1, __flags, __addr.__sockaddr__,
                                    __addr_len);
      return (tmp___2);
    }
  }
  tmp___5 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr.__sockaddr__, __addr_len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern int blocklist_init(char *allowlist , char *blocklist , char **allowlist_entries ,
                          size_t allowlist_entries_len , char **blocklist_entries ,
                          size_t blocklist_entries_len , int ignore_invalid_hosts ) ;
extern uint64_t blocklist_count_not_allowed() ;
extern int log_init(FILE *stream , enum LogLevel level , int syslog_enabled , char const   *syslog_app ) ;
extern uint32_t parse_max_hosts(char *max_targets ) ;
extern void enforce_range(char const   *name , int v , int min , int max ) ;
extern void split_string(char const   *in , int *len , char const   ***results ) ;
extern void fprintw(FILE *f , char const   *s , size_t w ) ;
extern int parse_mac(macaddr_t *out , char *in ) ;
extern int file_exists(char *name ) ;
extern int drop_privs() ;
extern int set_cpu(uint32_t core ) ;
extern uint32_t pbm_load_from_file(uint8_t **b , char *file ) ;
int cmdline_parser_ext(int argc , char **argv , struct gengetopt_args_info *args_info ,
                       struct cmdline_parser_params *params ) ;
void cmdline_parser_print_help(void) ;
void cmdline_parser_print_version(void) ;
struct cmdline_parser_params *cmdline_parser_params_create(void) ;
void cmdline_parser_free(struct gengetopt_args_info *args_info ) ;
int cmdline_parser_config_file(char const   *filename , struct gengetopt_args_info *args_info ,
                               struct cmdline_parser_params *params ) ;
int cmdline_parser_required(struct gengetopt_args_info *args_info , char const   *prog_name ) ;
sock_t get_socket(uint32_t id  __attribute__((__unused__)) ) ;
output_module_t *get_output_module_by_name(char const   *name ) ;
void print_output_modules(void) ;
probe_module_t *get_probe_module_by_name(char const   *name ) ;
void print_probe_modules(void) ;
int ip_fields_len ;
int sys_fields_len ;
fielddef_t ip_fields[6] ;
fielddef_t sys_fields[5] ;
pthread_mutex_t recv_ready_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
char const   *default_help_text  =    "By default, ZMap prints out unique, successful IP addresses (e.g., SYN-ACK from a TCP SYN scan) in ASCII form (e.g., 192.168.1.5) to stdout or the specified output file. Internally this is handled by the \"csv\" output module and is equivalent to running zmap --output-module=csv --output-fields=saddr --output-filter=\"success = 1 && repeat = 0\" --no-header-row.";
static void *start_send(void *arg )
{
  send_arg_t *s ;

  {
  s = (send_arg_t *)arg;
  log_debug("zmap", "Pinning a send thread to core %u", s->cpu);
  set_cpu(s->cpu);
  send_run(s->sock, s->shard);
  free((void *)s);
  return ((void *)0);
}
}
static void *start_recv(void *arg )
{
  recv_arg_t *r ;

  {
  r = (recv_arg_t *)arg;
  log_debug("zmap", "Pinning receive thread to core %u", r->cpu);
  set_cpu(r->cpu);
  recv_run(& recv_ready_mutex);
  return ((void *)0);
}
}
static void *start_mon(void *arg )
{
  mon_start_arg_t *mon_arg ;

  {
  mon_arg = (mon_start_arg_t *)arg;
  log_debug("zmap", "Pinning monitor thread to core %u", mon_arg->cpu);
  set_cpu(mon_arg->cpu);
  monitor_run(mon_arg->it, mon_arg->recv_ready_mutex);
  free((void *)mon_arg);
  return ((void *)0);
}
}
static void start_zmap(void)
{
  struct in_addr default_ip ;
  int tmp___0 ;
  char *tmp___1 ;
  struct in_addr gw_ip ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  iterator_t *it ;
  iterator_t *tmp___8 ;
  uint32_t cpu ;
  pthread_t *tsend ;
  pthread_t trecv ;
  pthread_t tmon ;
  int r ;
  recv_arg_t *recv_arg ;
  void *tmp___9 ;
  void *tmp___10 ;
  uint8_t i ;
  sock_t sock ;
  send_arg_t *arg ;
  void *tmp___11 ;
  int r___0 ;
  int tmp___12 ;
  mon_start_arg_t *mon_arg ;
  void *tmp___13 ;
  int r___1 ;
  int tmp___14 ;
  uint8_t i___0 ;
  int r___2 ;
  int tmp___15 ;

  {
  if ((unsigned long )zconf.iface == (unsigned long )((void *)0)) {
    zconf.iface = get_default_iface();
    if (! zconf.iface) {
      __assert_fail("zconf.iface", "src/zmap.c", 119U, "start_zmap");
    }
    log_debug("zmap", "no interface provided. will use default interface (%s).", zconf.iface);
  }
  if (zconf.number_source_ips == 0U) {
    tmp___0 = get_iface_ip(zconf.iface, & default_ip);
    if (tmp___0 < 0) {
      log_fatal("zmap", "could not detect default IP address for %s. Try specifying a source address (-S).",
                zconf.iface);
    }
    zconf.source_ip_addresses[0] = default_ip.s_addr;
    (zconf.number_source_ips) ++;
    tmp___1 = inet_ntoa(default_ip);
    log_debug("zmap", "no source IP address given. will use default address: %s.",
              tmp___1);
  }
  if (! zconf.gw_mac_set) {
    memset((void *)(& gw_ip), 0, sizeof(struct in_addr ));
    tmp___2 = get_default_gw(& gw_ip, zconf.iface);
    if (tmp___2 < 0) {
      log_fatal("zmap", "could not detect default gateway address for %s. Try setting default gateway mac address (-G). If this is a newly launched machine, try completing an outgoing network connection (e.g. curl https://zmap.io), and trying again.",
                zconf.iface);
    }
    tmp___3 = inet_ntoa(gw_ip);
    log_debug("zmap", "found gateway IP %s on %s", tmp___3, zconf.iface);
    zconf.gw_ip = gw_ip.s_addr;
    memset((void *)(& zconf.gw_mac), 0, (size_t )6);
    tmp___5 = get_hw_addr(& gw_ip, zconf.iface, zconf.gw_mac);
    if (tmp___5) {
      tmp___4 = inet_ntoa(gw_ip);
      log_fatal("zmap", "could not detect GW MAC address for %s on %s. Try setting default gateway mac address (-G), or run \"arp <gateway_ip>\" in terminal. If this is a newly launched machine, try completing an outgoing network connection (e.g. curl https://zmap.io), and trying again.",
                tmp___4, zconf.iface);
    }
    zconf.gw_mac_set = 1;
  }
  log_debug("send", "gateway MAC address %02x:%02x:%02x:%02x:%02x:%02x", (int )zconf.gw_mac[0],
            (int )zconf.gw_mac[1], (int )zconf.gw_mac[2], (int )zconf.gw_mac[3], (int )zconf.gw_mac[4],
            (int )zconf.gw_mac[5]);
  if (zconf.output_module) {
    if (! "no output module set") {
      __assert_fail("zconf.output_module && \"no output module set\"", "src/zmap.c",
                    170U, "start_zmap");
    }
  } else {
    __assert_fail("zconf.output_module && \"no output module set\"", "src/zmap.c",
                  170U, "start_zmap");
  }
  log_debug("zmap", "output module: %s", (zconf.output_module)->name);
  if (zconf.output_module) {
    if ((zconf.output_module)->init) {
      tmp___7 = (*((zconf.output_module)->init))(& zconf, zconf.output_fields, zconf.output_fields_len);
      if (tmp___7) {
        log_fatal("zmap", "output module did not initialize successfully.");
      }
    }
  }
  tmp___8 = send_init();
  it = tmp___8;
  if (! it) {
    log_fatal("zmap", "unable to initialize sending component");
  }
  if (zconf.output_module) {
    if ((zconf.output_module)->start) {
      (*((zconf.output_module)->start))(& zconf, & zsend, & zrecv);
    }
  }
  cpu = (uint32_t )0;
  if (! zconf.dryrun) {
    tmp___9 = xmalloc(sizeof(recv_arg_t ));
    recv_arg = (recv_arg_t *)tmp___9;
    recv_arg->cpu = *(zconf.pin_cores + cpu % zconf.pin_cores_len);
    cpu ++;
    r = pthread_create((pthread_t * __restrict  )(& trecv), (pthread_attr_t const   * __restrict  )((void *)0),
                       & start_recv, (void * __restrict  )recv_arg);
    if (r != 0) {
      log_fatal("zmap", "unable to create recv thread");
    }
    while (1) {
      pthread_mutex_lock(& recv_ready_mutex);
      if (zconf.recv_ready) {
        pthread_mutex_unlock(& recv_ready_mutex);
        break;
      }
      pthread_mutex_unlock(& recv_ready_mutex);
    }
  }
  tmp___10 = xmalloc((unsigned long )zconf.senders * sizeof(pthread_t ));
  tsend = (pthread_t *)tmp___10;
  i = (uint8_t )0;
  while ((int )i < (int )zconf.senders) {
    if (zconf.dryrun) {
      sock = get_dryrun_socket();
    } else {
      sock = get_socket((uint32_t )i);
    }
    tmp___11 = xmalloc(sizeof(send_arg_t ));
    arg = (send_arg_t *)tmp___11;
    arg->sock = sock;
    arg->shard = get_shard(it, i);
    arg->cpu = *(zconf.pin_cores + cpu % zconf.pin_cores_len);
    cpu ++;
    tmp___12 = pthread_create((pthread_t * __restrict  )(tsend + i), (pthread_attr_t const   * __restrict  )((void *)0),
                              & start_send, (void * __restrict  )arg);
    r___0 = tmp___12;
    if (r___0 != 0) {
      log_fatal("zmap", "unable to create send thread");
      exit(1);
    }
    i = (uint8_t )((int )i + 1);
  }
  log_debug("zmap", "%d sender threads spawned", (int )zconf.senders);
  if (! zconf.dryrun) {
    monitor_init();
    tmp___13 = xmalloc(sizeof(mon_start_arg_t ));
    mon_arg = (mon_start_arg_t *)tmp___13;
    mon_arg->it = it;
    mon_arg->recv_ready_mutex = & recv_ready_mutex;
    mon_arg->cpu = *(zconf.pin_cores + cpu % zconf.pin_cores_len);
    tmp___14 = pthread_create((pthread_t * __restrict  )(& tmon), (pthread_attr_t const   * __restrict  )((void *)0),
                              & start_mon, (void * __restrict  )mon_arg);
    r___1 = tmp___14;
    if (r___1 != 0) {
      log_fatal("zmap", "unable to create monitor thread");
      exit(1);
    }
  }
  drop_privs();
  i___0 = (uint8_t )0;
  while ((int )i___0 < (int )zconf.senders) {
    tmp___15 = pthread_join(*(tsend + i___0), (void **)((void *)0));
    r___2 = tmp___15;
    if (r___2 != 0) {
      log_fatal("zmap", "unable to join send thread");
      exit(1);
    }
    i___0 = (uint8_t )((int )i___0 + 1);
  }
  log_debug("zmap", "senders finished");
  if (! zconf.dryrun) {
    r = pthread_join(trecv, (void **)((void *)0));
    if (r != 0) {
      log_fatal("zmap", "unable to join recv thread");
      exit(1);
    }
    if (! zconf.quiet) {
      goto _L;
    } else
    if (zconf.status_updates_file) {
      _L: /* CIL Label */
      pthread_join(tmon, (void **)((void *)0));
      if (r != 0) {
        log_fatal("zmap", "unable to join monitor thread");
        exit(1);
      }
    }
  }
  if (zconf.metadata_filename) {
    json_metadata(zconf.metadata_file);
  }
  if (zconf.output_module) {
    if ((zconf.output_module)->close) {
      (*((zconf.output_module)->close))(& zconf, & zsend, & zrecv);
    }
  }
  if (zconf.probe_module) {
    if ((zconf.probe_module)->close) {
      (*((zconf.probe_module)->close))(& zconf, & zsend, & zrecv);
    }
  }
  log_info("zmap", "completed");
  return;
}
}
int main(int argc , char **argv )
{
  struct gengetopt_args_info args ;
  struct cmdline_parser_params *params ;
  int config_loaded ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  FILE *log_location ;
  time_t now___0 ;
  struct tm *local ;
  struct tm *tmp___2 ;
  char path[100] ;
  char *fullpath ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  unsigned long tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char const   *module_name ;
  char const   *tmp___11 ;
  int tmp___12 ;
  fielddefset_t *fds ;
  int i ;
  void *tmp___13 ;
  int i___0 ;
  int i___1 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  struct json_object *tmp___21 ;
  int tmp___22 ;
  char *dash ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int port ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  char *suffix ;
  int tmp___31 ;
  uint64_t allowed ;
  uint64_t tmp___32 ;
  char const   **core_list ;
  int len ;
  void *tmp___34 ;
  uint32_t i___2 ;
  int tmp___35 ;
  int num_cores ;
  long tmp___36 ;
  void *tmp___37 ;
  uint32_t i___3 ;

  {
  params = cmdline_parser_params_create();
  params->initialize = 1;
  params->override = 0;
  params->check_required = 0;
  config_loaded = 0;
  tmp = cmdline_parser_ext(argc, argv, & args, params);
  if (tmp != 0) {
    exit(0);
  }
  if (args.config_given) {
    goto _L;
  } else {
    tmp___1 = file_exists(args.config_arg);
    if (tmp___1) {
      _L: /* CIL Label */
      params->initialize = 0;
      params->override = 0;
      tmp___0 = cmdline_parser_config_file((char const   *)args.config_arg, & args,
                                           params);
      if (tmp___0 != 0) {
        exit(1);
      }
      config_loaded = 1;
    }
  }
  init_empty_global_configuration(& zconf);
  zconf.log_level = args.verbosity_arg;
  zconf.log_file = args.log_file_arg;
  zconf.log_directory = args.log_directory_arg;
  if (args.disable_syslog_given) {
    zconf.syslog = 0;
  } else {
    zconf.syslog = 1;
  }
  if (zconf.log_file) {
    if (zconf.log_directory) {
      log_init(stderr, (enum LogLevel )zconf.log_level, zconf.syslog, "zmap");
      log_fatal("zmap", "log-file and log-directory cannot specified simultaneously.");
    }
  }
  log_location = (FILE *)((void *)0);
  if (zconf.log_file) {
    log_location = fopen((char const   * __restrict  )zconf.log_file, (char const   * __restrict  )"w");
  } else
  if (zconf.log_directory) {
    time(& now___0);
    tmp___2 = localtime((time_t const   *)(& now___0));
    local = tmp___2;
    strftime((char * __restrict  )(path), (size_t )100, (char const   * __restrict  )"zmap-%Y-%m-%dT%H%M%S%z.log",
             (struct tm  const  * __restrict  )local);
    tmp___3 = strlen((char const   *)zconf.log_directory);
    tmp___4 = strlen((char const   *)(path));
    tmp___5 = xmalloc((tmp___3 + tmp___4) + 2UL);
    fullpath = (char *)tmp___5;
    tmp___6 = __builtin_object_size((void *)fullpath, 1);
    __builtin___sprintf_chk(fullpath, 1, tmp___6, "%s/%s", zconf.log_directory, path);
    log_location = fopen((char const   * __restrict  )fullpath, (char const   * __restrict  )"w");
    free((void *)fullpath);
  } else {
    log_location = stderr;
  }
  if (! log_location) {
    log_init(stderr, (enum LogLevel )zconf.log_level, zconf.syslog, "zmap");
    tmp___7 = __errno_location();
    tmp___8 = strerror(*tmp___7);
    log_fatal("zmap", "unable to open specified log file: %s", tmp___8);
  }
  log_init(log_location, (enum LogLevel )zconf.log_level, zconf.syslog, "zmap");
  log_debug("zmap", "zmap main thread started");
  if (config_loaded) {
    log_debug("zmap", "Loaded configuration file %s", args.config_arg);
  }
  if (zconf.syslog) {
    log_debug("zmap", "syslog support enabled");
  } else {
    log_info("zmap", "syslog support disabled");
  }
  log_debug("zmap", "requested ouput-module: %s", args.output_module_arg);
  if (args.output_module_given) {
    tmp___9 = 0;
  } else
  if (args.output_filter_given) {
    tmp___9 = 0;
  } else
  if (args.output_fields_given) {
    tmp___9 = 0;
  } else {
    tmp___9 = 1;
  }
  zconf.default_mode = tmp___9;
  if (zconf.default_mode) {
    log_info("zmap", "By default, ZMap will output the unique IP addresses of hosts that respond successfully (e.g., SYN-ACK packet). This is equivalent to running ZMap with the following flags: --output-module=csv --output-fields=saddr --output-filter=\'success=1 && repeat=0\' --no-header-row. If you want all responses, explicitly set an output module or set --output-filter=\"\".");
    zconf.output_module = get_output_module_by_name("csv");
    zconf.output_module_name = strdup("csv");
    zconf.no_header_row = 1;
  } else
  if (! args.output_module_given) {
    log_debug("zmap", "No output module provided. Will use csv.");
    zconf.output_module = get_output_module_by_name("csv");
    zconf.output_module_name = strdup("csv");
  } else {
    zconf.output_module = get_output_module_by_name((char const   *)args.output_module_arg);
    if (! zconf.output_module) {
      log_fatal("zmap", "specified output module (%s) does not exist\n", args.output_module_arg);
    }
    zconf.output_module_name = strdup((char const   *)args.output_module_arg);
  }
  zconf.probe_module = get_probe_module_by_name((char const   *)args.probe_module_arg);
  if (! zconf.probe_module) {
    log_fatal("zmap", "specified probe module (%s) does not exist\n", args.probe_module_arg);
    exit(1);
  }
  if ((zconf.probe_module)->output_type == 2) {
    if (! (zconf.output_module)->supports_dynamic_output) {
      log_fatal("zmap", "specified probe module (%s) requires dynamic output support, which output module (%s) does not support. Most likely you want to use JSON output.",
                args.probe_module_arg, args.output_module_arg);
    }
  }
  if (args.help_given) {
    cmdline_parser_print_help();
    __printf_chk(1, (char const   * __restrict  )"\nProbe Module (%s) Help:\n", (zconf.probe_module)->name);
    if ((zconf.probe_module)->helptext) {
      fprintw(stdout, (zconf.probe_module)->helptext, (size_t )80);
    } else {
      __printf_chk(1, (char const   * __restrict  )"no help text available\n");
    }
    if (zconf.output_module) {
      if (! "no output module set") {
        __assert_fail("zconf.output_module && \"no output module set\"", "src/zmap.c",
                      452U, "main");
      }
    } else {
      __assert_fail("zconf.output_module && \"no output module set\"", "src/zmap.c",
                    452U, "main");
    }
    if (zconf.default_mode) {
      tmp___11 = "Default";
    } else {
      tmp___11 = (zconf.output_module)->name;
    }
    module_name = tmp___11;
    __printf_chk(1, (char const   * __restrict  )"\nOutput Module (%s) Help:\n", module_name);
    if (zconf.default_mode) {
      fprintw(stdout, default_help_text, (size_t )80);
    } else
    if ((zconf.output_module)->helptext) {
      fprintw(stdout, (zconf.output_module)->helptext, (size_t )80);
    } else {
      __printf_chk(1, (char const   * __restrict  )"no help text available\n");
    }
    exit(0);
  }
  if (args.version_given) {
    cmdline_parser_print_version();
    exit(0);
  }
  if (args.list_output_modules_given) {
    print_output_modules();
    exit(0);
  }
  if (args.list_probe_modules_given) {
    print_probe_modules();
    exit(0);
  }
  if (args.iplayer_given) {
    zconf.send_ip_pkts = 1;
    zconf.gw_mac_set = 1;
    memset((void *)(zconf.gw_mac), 0, (size_t )6);
  }
  tmp___12 = cmdline_parser_required(& args, "zmap");
  if (tmp___12 != 0) {
    exit(1);
  }
  memset((void *)(& zconf.fsconf), 0, sizeof(struct fieldset_conf ));
  fds = & zconf.fsconf.defs;
  gen_fielddef_set(fds, (fielddef_t *)(& ip_fields), ip_fields_len);
  gen_fielddef_set(fds, (zconf.probe_module)->fields, (zconf.probe_module)->numfields);
  gen_fielddef_set(fds, (fielddef_t *)(& sys_fields), sys_fields_len);
  if (args.list_output_fields_given) {
    i = 0;
    while (i < fds->len) {
      __printf_chk(1, (char const   * __restrict  )"%-15s %6s: %s\n", fds->fielddefs[i].name,
                   fds->fielddefs[i].type, fds->fielddefs[i].desc);
      i ++;
    }
    exit(0);
  }
  zconf.fsconf.success_index = fds_get_index_by_name(fds, "success");
  if (zconf.fsconf.success_index < 0) {
    log_fatal("fieldset", "probe module does not supply required success field.");
  }
  zconf.fsconf.app_success_index = fds_get_index_by_name(fds, "app_success");
  if (zconf.fsconf.app_success_index < 0) {
    log_debug("fieldset", "probe module does not supply application success field.");
  } else {
    log_debug("fieldset", "probe module supplies app_success output field. It will be included in monitor output");
  }
  zconf.fsconf.classification_index = fds_get_index_by_name(fds, "classification");
  if (zconf.fsconf.classification_index < 0) {
    log_fatal("fieldset", "probe module does not supply required packet classification field.");
  }
  if (args.output_fields_given) {
    zconf.raw_output_fields = (char const   *)args.output_fields_arg;
  } else {
    zconf.raw_output_fields = "saddr";
  }
  tmp___14 = strcmp(zconf.raw_output_fields, "*");
  if (tmp___14) {
    split_string(zconf.raw_output_fields, & zconf.output_fields_len, & zconf.output_fields);
    i___1 = 0;
    while (i___1 < zconf.output_fields_len) {
      log_debug("zmap", "requested output field (%i): %s", i___1, *(zconf.output_fields + i___1));
      i___1 ++;
    }
    fs_generate_fieldset_translation(& zconf.fsconf.translation, & zconf.fsconf.defs,
                                     zconf.output_fields, zconf.output_fields_len);
  } else {
    zconf.output_fields_len = zconf.fsconf.defs.len;
    tmp___13 = xcalloc((size_t )zconf.fsconf.defs.len, sizeof(char const   *));
    zconf.output_fields = (char const   **)tmp___13;
    i___0 = 0;
    while (i___0 < zconf.fsconf.defs.len) {
      *(zconf.output_fields + i___0) = zconf.fsconf.defs.fielddefs[i___0].name;
      i___0 ++;
    }
    fs_generate_full_fieldset_translation(& zconf.fsconf.translation, & zconf.fsconf.defs);
  }
  if (zconf.default_mode) {
    log_debug("filter", "No output filter specified. Will use default: exclude duplicates and unssuccessful");
  } else
  if (args.output_filter_given) {
    tmp___17 = strcmp((char const   *)args.output_filter_arg, "");
    if (tmp___17) {
      tmp___15 = parse_filter_string(args.output_filter_arg);
      if (! tmp___15) {
        log_fatal("zmap", "Unable to parse filter expression");
      }
      tmp___16 = validate_filter(zconf.filter.expression, & zconf.fsconf.defs);
      if (! tmp___16) {
        log_fatal("zmap", "Invalid filter");
      }
      zconf.output_filter_str = args.output_filter_arg;
      log_debug("filter", "will use output filter %s", args.output_filter_arg);
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */
  if (args.output_filter_given) {
    log_debug("filter", "Empty output filter provided. ZMap will output all results, including duplicate and non-successful responses.");
  } else {
    log_info("filter", "No output filter provided. ZMap will output all results, including duplicate and non-successful responses (e.g., RST and ICMP packets). If you want a filter similar to ZMap\'s default behavior, you can set an output filter similar to the following: --output-filter=\"success=1 && repeat=0\".");
  }
  zconf.ignore_invalid_hosts = (int )args.ignore_blocklist_errors_given;
  if (args.dryrun_given) {
    zconf.dryrun = 1;
  }
  if (args.quiet_given) {
    zconf.quiet = 1;
  }
  if (args.no_header_row_given) {
    zconf.no_header_row = 1;
  }
  zconf.cooldown_secs = args.cooldown_time_arg;
  if (args.output_file_given) {
    zconf.output_filename = args.output_file_arg;
  }
  if (args.blocklist_file_given) {
    zconf.blocklist_filename = args.blocklist_file_arg;
  }
  if (args.list_of_ips_file_given) {
    zconf.list_of_ips_filename = args.list_of_ips_file_arg;
  }
  if (args.probe_args_given) {
    zconf.probe_args = args.probe_args_arg;
  }
  if (args.probe_ttl_given) {
    zconf.probe_ttl = (uint8_t )args.probe_ttl_arg;
  }
  if (args.output_args_given) {
    zconf.output_args = args.output_args_arg;
  }
  if (args.interface_given) {
    zconf.iface = args.interface_arg;
  }
  if (args.max_runtime_given) {
    zconf.max_runtime = (uint32_t )args.max_runtime_arg;
  }
  if (args.max_results_given) {
    zconf.max_results = (uint32_t )args.max_results_arg;
  }
  if (args.rate_given) {
    zconf.rate = args.rate_arg;
  }
  if (args.probes_given) {
    zconf.packet_streams = args.probes_arg;
  }
  if (args.status_updates_file_given) {
    zconf.status_updates_file = args.status_updates_file_arg;
  }
  if (args.retries_given) {
    zconf.num_retries = args.retries_arg;
  }
  if (args.max_sendto_failures_given) {
    zconf.max_sendto_failures = args.max_sendto_failures_arg;
  }
  if (args.min_hitrate_given) {
    zconf.min_hitrate = args.min_hitrate_arg;
  }
  if (zconf.num_retries < 0) {
    log_fatal("zmap", "Invalid retry count");
  }
  if (zconf.max_sendto_failures >= 0) {
    log_debug("zmap", "scan will abort if more than %i sendto failures occur", zconf.max_sendto_failures);
  }
  if ((double )zconf.min_hitrate > 0.0) {
    log_debug("zmap", "scan will abort if hitrate falls below %f", (double )zconf.min_hitrate);
  }
  if (args.metadata_file_arg) {
    zconf.metadata_filename = args.metadata_file_arg;
    tmp___18 = strcmp((char const   *)zconf.metadata_filename, "-");
    if (tmp___18) {
      zconf.metadata_file = fopen((char const   * __restrict  )zconf.metadata_filename,
                                  (char const   * __restrict  )"w");
    } else {
      zconf.metadata_file = stdout;
    }
    if (! zconf.metadata_file) {
      tmp___19 = __errno_location();
      tmp___20 = strerror(*tmp___19);
      log_fatal("metadata", "unable to open metadata file (%s): %s", zconf.metadata_filename,
                tmp___20);
    }
    log_debug("metadata", "metdata will be saved to %s", zconf.metadata_filename);
  }
  if (args.user_metadata_given) {
    zconf.custom_metadata_str = args.user_metadata_arg;
    tmp___21 = json_tokener_parse((char const   *)zconf.custom_metadata_str);
    if (tmp___21) {
      log_debug("metadata", "user metadata validated successfully");
    } else {
      log_fatal("metadata", "unable to parse custom user metadata");
    }
  }
  if (args.notes_given) {
    zconf.notes = args.notes_arg;
  }
  zconf.destination_cidrs = args.inputs;
  zconf.destination_cidrs_len = (int )args.inputs_num;
  if (zconf.destination_cidrs) {
    if (zconf.blocklist_filename) {
      tmp___22 = strcmp((char const   *)zconf.blocklist_filename, "/etc/zmap/blocklist.conf");
      if (! tmp___22) {
        log_warn("blocklist", "ZMap is currently using the default blocklist located at /etc/zmap/blocklist.conf. By default, this blocklist excludes locally scoped networks (e.g. 10.0.0.0/8, 127.0.0.1/8, and 192.168.0.0/16). If you are trying to scan local networks, you can change the default blocklist by editing the default ZMap configuration at /etc/zmap/zmap.conf.");
      }
    }
  }
  if (args.allowlist_file_given) {
    zconf.allowlist_filename = args.allowlist_file_arg;
  }
  if ((zconf.probe_module)->port_args) {
    if (args.source_port_given) {
      tmp___23 = strchr((char const   *)args.source_port_arg, '-');
      dash = tmp___23;
      if (dash) {
        *dash = (char )'\000';
        tmp___24 = atoi((char const   *)args.source_port_arg);
        zconf.source_port_first = (port_h_t )tmp___24;
        enforce_range("starting source-port", (int )zconf.source_port_first, 0, 65535);
        tmp___25 = atoi((char const   *)(dash + 1));
        zconf.source_port_last = (port_h_t )tmp___25;
        enforce_range("ending source-port", (int )zconf.source_port_last, 0, 65535);
        if ((int )zconf.source_port_first > (int )zconf.source_port_last) {
          __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s: invalid source port range: last port is less than first port\n",
                        "zmap");
          exit(1);
        }
      } else {
        tmp___26 = atoi((char const   *)args.source_port_arg);
        port = tmp___26;
        enforce_range("source-port", port, 0, 65535);
        zconf.source_port_first = (port_h_t )port;
        zconf.source_port_last = (port_h_t )port;
      }
    }
    if (! args.target_port_given) {
      log_fatal("zmap", "target port (-p) is required for this type of probe");
    }
    enforce_range("target-port", args.target_port_arg, 0, 65535);
    zconf.target_port = (port_h_t )args.target_port_arg;
  }
  if (args.source_ip_given) {
    parse_source_ip_addresses(args.source_ip_arg);
  }
  if (args.gateway_mac_given) {
    tmp___27 = parse_mac(zconf.gw_mac, args.gateway_mac_arg);
    if (! tmp___27) {
      __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s: invalid MAC address `%s\'\n",
                    "zmap", args.gateway_mac_arg);
      exit(1);
    }
    zconf.gw_mac_set = 1;
  }
  if (args.source_mac_given) {
    tmp___28 = parse_mac(zconf.hw_mac, args.source_mac_arg);
    if (! tmp___28) {
      __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s: invalid MAC address `%s\'\n",
                    "zmap", args.gateway_mac_arg);
      exit(1);
    }
    log_debug("send", "source MAC address specified on CLI: %02x:%02x:%02x:%02x:%02x:%02x",
              (int )zconf.hw_mac[0], (int )zconf.hw_mac[1], (int )zconf.hw_mac[2],
              (int )zconf.hw_mac[3], (int )zconf.hw_mac[4], (int )zconf.hw_mac[5]);
    zconf.hw_mac_set = 1;
  }
  if (args.seed_given) {
    zconf.seed = (uint64_t )args.seed_arg;
    zconf.seed_provided = 1;
  } else {
    tmp___29 = random_bytes((void *)(& zconf.seed), sizeof(uint64_t ));
    if (! tmp___29) {
      log_fatal("zmap", "unable to generate random bytes needed for seed");
    }
    zconf.seed_provided = 0;
  }
  zconf.aes = aesrand_init_from_seed(zconf.seed);
  zconf.shard_num = (uint16_t )0;
  zconf.total_shards = (uint16_t )1;
  if (args.shard_given) {
    goto _L___1;
  } else
  if (args.shards_given) {
    _L___1: /* CIL Label */
    if (! args.seed_given) {
      log_fatal("zmap", "Need to specify seed if sharding a scan");
    }
  }
  if (args.shard_given ^ args.shards_given) {
    log_fatal("zmap", "Need to specify both shard number and total number of shards");
  }
  if (args.shard_given) {
    enforce_range("shard", args.shard_arg, 0, 65534);
  }
  if (args.shards_given) {
    enforce_range("shards", args.shards_arg, 1, 65535);
  }
  if (args.shard_given) {
    zconf.shard_num = (uint16_t )args.shard_arg;
  }
  if (args.shards_given) {
    zconf.total_shards = (uint16_t )args.shards_arg;
  }
  if ((int )zconf.shard_num >= (int )zconf.total_shards) {
    log_fatal("zmap", "With %hhu total shards, shard number (%hhu) must be in range [0, %hhu)",
              (int )zconf.total_shards, (int )zconf.shard_num, (int )zconf.total_shards);
  }
  if (args.bandwidth_given) {
    tmp___30 = atoi((char const   *)args.bandwidth_arg);
    zconf.bandwidth = (uint64_t )tmp___30;
    suffix = args.bandwidth_arg;
    while (1) {
      if ((int )*suffix >= 48) {
        if (! ((int )*suffix <= 57)) {
          break;
        }
      } else {
        break;
      }
      suffix ++;
    }
    if (*suffix) {
      switch ((int )*suffix) {
      case 103:
      case 71:
      zconf.bandwidth *= 1000000000UL;
      break;
      case 109:
      case 77:
      zconf.bandwidth *= 1000000UL;
      break;
      case 107:
      case 75:
      zconf.bandwidth *= 1000UL;
      break;
      default:
      __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s: unknown bandwidth suffix \'%s\' (supported suffixes are G, M and K)\n",
                    "zmap", suffix);
      exit(1);
      }
    }
  }
  if (args.batch_given) {
    zconf.batch = (uint8_t )args.batch_arg;
  }
  if (args.max_targets_given) {
    zconf.max_targets = parse_max_hosts(args.max_targets_arg);
  }
  tmp___31 = blocklist_init(zconf.allowlist_filename, zconf.blocklist_filename, zconf.destination_cidrs,
                            (size_t )zconf.destination_cidrs_len, (char **)((void *)0),
                            (size_t )0, zconf.ignore_invalid_hosts);
  if (tmp___31) {
    log_fatal("zmap", "unable to initialize blocklist / allowlist");
  }
  if (zconf.list_of_ips_filename) {
    zsend.list_of_ips_pbm = pbm_init();
    zconf.list_of_ips_count = pbm_load_from_file(zsend.list_of_ips_pbm, zconf.list_of_ips_filename);
  }
  tmp___32 = blocklist_count_allowed();
  allowed = tmp___32;
  zconf.total_allowed = allowed;
  zconf.total_disallowed = blocklist_count_not_allowed();
  if (! ((unsigned long long )allowed <= (unsigned long long )(1LL << 32))) {
    __assert_fail("allowed <= (1LL << 32)", "src/zmap.c", 826U, "main");
  }
  if (! zconf.total_allowed) {
    log_fatal("zmap", "zero eligible addresses to scan");
  }
  if (zconf.list_of_ips_count > 0U) {
    if (4294967295U / zconf.list_of_ips_count > 100000U) {
      log_warn("zmap", "list of IPs is small compared to address space. Performance will suffer, consider using an allowlist instead");
    }
  }
  if (zconf.max_targets) {
    zsend.max_targets = zconf.max_targets;
  }
  if (args.sender_threads_given) {
    zconf.senders = (uint8_t )args.sender_threads_arg;
  } else {
    zconf.senders = (uint8_t )1;
  }
  if ((uint32_t )(2 * (int )zconf.senders) >= zsend.max_targets) {
    log_warn("zmap", "too few targets relative to senders, dropping to one sender");
    zconf.senders = (uint8_t )1;
  }
  if (args.cores_given) {
    core_list = (char const   **)((void *)0);
    len = 0;
    split_string((char const   *)args.cores_arg, & len, & core_list);
    zconf.pin_cores_len = (uint32_t )len;
    tmp___34 = xcalloc((size_t )zconf.pin_cores_len, sizeof(uint32_t ));
    zconf.pin_cores = (uint32_t *)tmp___34;
    i___2 = (uint32_t )0;
    while (i___2 < zconf.pin_cores_len) {
      tmp___35 = atoi(*(core_list + i___2));
      *(zconf.pin_cores + i___2) = (uint32_t )tmp___35;
      i___2 ++;
    }
  } else {
    tmp___36 = sysconf(84);
    num_cores = (int )tmp___36;
    zconf.pin_cores_len = (uint32_t )num_cores;
    tmp___37 = xcalloc((size_t )zconf.pin_cores_len, sizeof(uint32_t ));
    zconf.pin_cores = (uint32_t *)tmp___37;
    i___3 = (uint32_t )0;
    while (i___3 < zconf.pin_cores_len) {
      *(zconf.pin_cores + i___3) = i___3;
      i___3 ++;
    }
  }
  start_zmap();
  fclose(log_location);
  cmdline_parser_free(& args);
  free((void *)params);
  return (0);
}
}
#pragma merger("0","/tmp/cil-9vkxir0B.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
extern char *optarg ;
extern int optind ;
extern int opterr ;
extern int optopt ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc ,
                                                                                          char * const  *___argv ,
                                                                                          char const   *__shortopts ,
                                                                                          struct option  const  *__longopts ,
                                                                                          int *__longind ) ;
char const   *gengetopt_args_info_purpose ;
char const   *gengetopt_args_info_usage ;
char const   *gengetopt_args_info_description ;
char const   *gengetopt_args_info_help[62] ;
int cmdline_parser(int argc , char **argv , struct gengetopt_args_info *args_info ) ;
int cmdline_parser2(int argc , char **argv , struct gengetopt_args_info *args_info ,
                    int override , int initialize , int check_required ) ;
int cmdline_parser_dump(FILE *outfile , struct gengetopt_args_info *args_info ) ;
int cmdline_parser_file_save(char const   *filename , struct gengetopt_args_info *args_info ) ;
void cmdline_parser_params_init(struct cmdline_parser_params *params ) ;
void cmdline_parser_init(struct gengetopt_args_info *args_info ) ;
int cmdline_parser_configfile(char const   *filename , struct gengetopt_args_info *args_info ,
                              int override , int initialize , int check_required ) ;
char const   *gengetopt_args_info_purpose  =    "A fast Internet-wide scanner.";
char const   *gengetopt_args_info_usage  =    "Usage: zmap [OPTION]... [SUBNETS]...";
char const   *gengetopt_args_info_versiontext  =    "";
char const   *gengetopt_args_info_description  =    "";
char const   *gengetopt_args_info_help[62]  =
  {      "Basic Arguments:",      "  -p, --target-port=port        port number to scan (for TCP and UDP scans)",      "  -o, --output-file=name        Output file",      "  -b, --blocklist-file=path     File of subnets to exclude, in CIDR notation,\n                                  e.g. 192.168.0.0/16",
        "  -w, --allowlist-file=path     File of subnets to constrain scan to, in CIDR\n                                  notation, e.g. 192.168.0.0/16",      "  -I, --list-of-ips-file=path   List of individual addresses to scan in random\n                                  order. Use --white-list file unless >1\n                                  million IPs",      "\nScan Options:",      "  -r, --rate=pps                Set send rate in packets/sec",
        "  -B, --bandwidth=bps           Set send rate in bits/second (supports suffixes\n                                  G, M and K)",      "      --batch=pps               Set the number of packets to send per iteration",      "  -n, --max-targets=n           Cap number of targets to probe (as a number or\n                                  a percentage of the address space)",      "  -t, --max-runtime=secs        Cap length of time for sending packets",
        "  -N, --max-results=n           Cap number of results to return",      "  -P, --probes=n                Number of probes to send to each IP\n                                  (default=`1\')",      "  -c, --cooldown-time=secs      How long to continue receiving after sending\n                                  last probe  (default=`8\')",      "  -e, --seed=n                  Seed used to select address permutation",
        "      --retries=n               Max number of times to try to send packet if\n                                  send fails  (default=`10\')",      "  -d, --dryrun                  Don\'t actually send packets",      "\nScan Sharding:",      "      --shards=N                Set the total number of shards  (default=`1\')",
        "      --shard=n                 Set which shard this scan is (0 indexed)\n                                  (default=`0\')",      "\nNetwork Options:",      "  -s, --source-port=port|range  Source port(s) for scan packets",      "  -S, --source-ip=ip|range      Source address(es) for scan packets",
        "  -G, --gateway-mac=addr        Specify gateway MAC address",      "      --source-mac=addr         Source MAC address",      "  -i, --interface=name          Specify network interface to use",      "  -X, --iplayer                 Sends IP packets instead of Ethernet (for VPNs)",
        "\nProbe Modules:",      "  -M, --probe-module=name       Select probe module  (default=`tcp_synscan\')",      "      --probe-args=args         Arguments to pass to probe module",      "      --probe-ttl=n             Set TTL value for probe IP packets\n                                  (default=`255\')",
        "      --list-probe-modules      List available probe modules",      "\nResults Output:",      "  -f, --output-fields=fields    Fields that should be output in result set",      "  -O, --output-module=name      Select output module",
        "      --output-args=args        Arguments to pass to output module",      "      --output-filter=filter    Specify a filter over the response fields to\n                                  limit what responses get sent to the output\n                                  module",      "      --list-output-modules     List available output modules",      "      --list-output-fields      List all fields that can be output by selected\n                                  probe module",
        "      --no-header-row           Precludes outputting any header rows in data\n                                  (e.g., CSV headers)",      "\nLogging and Metadata:",      "  -v, --verbosity=n             Level of log detail (0-5)  (default=`3\')",      "  -l, --log-file=name           Write log entries to file",
        "  -L, --log-directory=directory Write log entries to a timestamped file in this\n                                  directory",      "  -m, --metadata-file=name      Output file for scan metadata (JSON)",      "  -u, --status-updates-file=name\n                                Write scan progress updates to CSV file",      "  -q, --quiet                   Do not print status updates",
        "      --disable-syslog          Disables logging messages to syslog",      "      --notes=notes             Inject user-specified notes into scan metadata",      "      --user-metadata=json      Inject user-specified JSON metadata into scan\n                                  metadata",      "\nAdditional Options:",
        "  -C, --config=filename         Read a configuration file, which can specify\n                                  any of these options\n                                  (default=`/etc/zmap/zmap.conf\')",      "      --max-sendto-failures=n   Maximum NIC sendto failures before scan is\n                                  aborted  (default=`-1\')",      "      --min-hitrate=n           Minimum hitrate that scan can hit before scan\n                                  is aborted  (default=`0.0\')",      "  -T, --sender-threads=n        Threads used to send packets  (default=`1\')",
        "      --cores=STRING            Comma-separated list of cores to pin to",      "      --ignore-blocklist-errors Ignore invalid entries in allowlist/blocklist\n                                  file.",      "  -h, --help                    Print help and exit",      "  -V, --version                 Print version and exit",
        "\nExamples:\n    zmap -p 80 (scan full IPv4 address space for hosts on TCP/80)\n    zmap -N 5 -B 10M -p 80 (find 5 HTTP servers, scanning at 10 Mb/s)\n    zmap -p 80 10.0.0.0/8 192.168.0.0/16 (scan both subnets on TCP/80)\n    zmap -p 80 1.2.3.4 10.0.0.3 (scan 1.2.3.4, 10.0.0.3 on TCP/80)",      (char const   *)0};
static void clear_given(struct gengetopt_args_info *args_info ) ;
static void clear_args(struct gengetopt_args_info *args_info ) ;
static int cmdline_parser_internal(int argc , char **argv , struct gengetopt_args_info *args_info ,
                                   struct cmdline_parser_params *params , char const   *additional_error ) ;
static struct line_list *cmd_line_list  =    (struct line_list *)0;
static struct line_list *cmd_line_list_tmp  =    (struct line_list *)0;
static void free_cmd_list(void)
{


  {
  if (cmd_line_list) {
    while (cmd_line_list) {
      cmd_line_list_tmp = cmd_line_list;
      cmd_line_list = cmd_line_list->next;
      free((void *)cmd_line_list_tmp->string_arg);
      free((void *)cmd_line_list_tmp);
    }
  }
  return;
}
}
static char *gengetopt_strdup(char const   *s ) ;
static void clear_given(struct gengetopt_args_info *args_info )
{


  {
  args_info->target_port_given = 0U;
  args_info->output_file_given = 0U;
  args_info->blocklist_file_given = 0U;
  args_info->allowlist_file_given = 0U;
  args_info->list_of_ips_file_given = 0U;
  args_info->rate_given = 0U;
  args_info->bandwidth_given = 0U;
  args_info->batch_given = 0U;
  args_info->max_targets_given = 0U;
  args_info->max_runtime_given = 0U;
  args_info->max_results_given = 0U;
  args_info->probes_given = 0U;
  args_info->cooldown_time_given = 0U;
  args_info->seed_given = 0U;
  args_info->retries_given = 0U;
  args_info->dryrun_given = 0U;
  args_info->shards_given = 0U;
  args_info->shard_given = 0U;
  args_info->source_port_given = 0U;
  args_info->source_ip_given = 0U;
  args_info->gateway_mac_given = 0U;
  args_info->source_mac_given = 0U;
  args_info->interface_given = 0U;
  args_info->iplayer_given = 0U;
  args_info->probe_module_given = 0U;
  args_info->probe_args_given = 0U;
  args_info->probe_ttl_given = 0U;
  args_info->list_probe_modules_given = 0U;
  args_info->output_fields_given = 0U;
  args_info->output_module_given = 0U;
  args_info->output_args_given = 0U;
  args_info->output_filter_given = 0U;
  args_info->list_output_modules_given = 0U;
  args_info->list_output_fields_given = 0U;
  args_info->no_header_row_given = 0U;
  args_info->verbosity_given = 0U;
  args_info->log_file_given = 0U;
  args_info->log_directory_given = 0U;
  args_info->metadata_file_given = 0U;
  args_info->status_updates_file_given = 0U;
  args_info->quiet_given = 0U;
  args_info->disable_syslog_given = 0U;
  args_info->notes_given = 0U;
  args_info->user_metadata_given = 0U;
  args_info->config_given = 0U;
  args_info->max_sendto_failures_given = 0U;
  args_info->min_hitrate_given = 0U;
  args_info->sender_threads_given = 0U;
  args_info->cores_given = 0U;
  args_info->ignore_blocklist_errors_given = 0U;
  args_info->help_given = 0U;
  args_info->version_given = 0U;
  return;
}
}
static void clear_args(struct gengetopt_args_info *args_info )
{


  {
  args_info->target_port_orig = (char *)((void *)0);
  args_info->output_file_arg = (char *)((void *)0);
  args_info->output_file_orig = (char *)((void *)0);
  args_info->blocklist_file_arg = (char *)((void *)0);
  args_info->blocklist_file_orig = (char *)((void *)0);
  args_info->allowlist_file_arg = (char *)((void *)0);
  args_info->allowlist_file_orig = (char *)((void *)0);
  args_info->list_of_ips_file_arg = (char *)((void *)0);
  args_info->list_of_ips_file_orig = (char *)((void *)0);
  args_info->rate_orig = (char *)((void *)0);
  args_info->bandwidth_arg = (char *)((void *)0);
  args_info->bandwidth_orig = (char *)((void *)0);
  args_info->batch_orig = (char *)((void *)0);
  args_info->max_targets_arg = (char *)((void *)0);
  args_info->max_targets_orig = (char *)((void *)0);
  args_info->max_runtime_orig = (char *)((void *)0);
  args_info->max_results_orig = (char *)((void *)0);
  args_info->probes_arg = 1;
  args_info->probes_orig = (char *)((void *)0);
  args_info->cooldown_time_arg = 8;
  args_info->cooldown_time_orig = (char *)((void *)0);
  args_info->seed_orig = (char *)((void *)0);
  args_info->retries_arg = 10;
  args_info->retries_orig = (char *)((void *)0);
  args_info->shards_arg = 1;
  args_info->shards_orig = (char *)((void *)0);
  args_info->shard_arg = 0;
  args_info->shard_orig = (char *)((void *)0);
  args_info->source_port_arg = (char *)((void *)0);
  args_info->source_port_orig = (char *)((void *)0);
  args_info->source_ip_arg = (char *)((void *)0);
  args_info->source_ip_orig = (char *)((void *)0);
  args_info->gateway_mac_arg = (char *)((void *)0);
  args_info->gateway_mac_orig = (char *)((void *)0);
  args_info->source_mac_arg = (char *)((void *)0);
  args_info->source_mac_orig = (char *)((void *)0);
  args_info->interface_arg = (char *)((void *)0);
  args_info->interface_orig = (char *)((void *)0);
  args_info->probe_module_arg = gengetopt_strdup("tcp_synscan");
  args_info->probe_module_orig = (char *)((void *)0);
  args_info->probe_args_arg = (char *)((void *)0);
  args_info->probe_args_orig = (char *)((void *)0);
  args_info->probe_ttl_arg = 255;
  args_info->probe_ttl_orig = (char *)((void *)0);
  args_info->output_fields_arg = (char *)((void *)0);
  args_info->output_fields_orig = (char *)((void *)0);
  args_info->output_module_arg = (char *)((void *)0);
  args_info->output_module_orig = (char *)((void *)0);
  args_info->output_args_arg = (char *)((void *)0);
  args_info->output_args_orig = (char *)((void *)0);
  args_info->output_filter_arg = (char *)((void *)0);
  args_info->output_filter_orig = (char *)((void *)0);
  args_info->verbosity_arg = 3;
  args_info->verbosity_orig = (char *)((void *)0);
  args_info->log_file_arg = (char *)((void *)0);
  args_info->log_file_orig = (char *)((void *)0);
  args_info->log_directory_arg = (char *)((void *)0);
  args_info->log_directory_orig = (char *)((void *)0);
  args_info->metadata_file_arg = (char *)((void *)0);
  args_info->metadata_file_orig = (char *)((void *)0);
  args_info->status_updates_file_arg = (char *)((void *)0);
  args_info->status_updates_file_orig = (char *)((void *)0);
  args_info->notes_arg = (char *)((void *)0);
  args_info->notes_orig = (char *)((void *)0);
  args_info->user_metadata_arg = (char *)((void *)0);
  args_info->user_metadata_orig = (char *)((void *)0);
  args_info->config_arg = gengetopt_strdup("/etc/zmap/zmap.conf");
  args_info->config_orig = (char *)((void *)0);
  args_info->max_sendto_failures_arg = -1;
  args_info->max_sendto_failures_orig = (char *)((void *)0);
  args_info->min_hitrate_arg = (float )0.0;
  args_info->min_hitrate_orig = (char *)((void *)0);
  args_info->sender_threads_arg = 1;
  args_info->sender_threads_orig = (char *)((void *)0);
  args_info->cores_arg = (char *)((void *)0);
  args_info->cores_orig = (char *)((void *)0);
  return;
}
}
static void init_args_info(struct gengetopt_args_info *args_info )
{


  {
  args_info->target_port_help = gengetopt_args_info_help[1];
  args_info->output_file_help = gengetopt_args_info_help[2];
  args_info->blocklist_file_help = gengetopt_args_info_help[3];
  args_info->allowlist_file_help = gengetopt_args_info_help[4];
  args_info->list_of_ips_file_help = gengetopt_args_info_help[5];
  args_info->rate_help = gengetopt_args_info_help[7];
  args_info->bandwidth_help = gengetopt_args_info_help[8];
  args_info->batch_help = gengetopt_args_info_help[9];
  args_info->max_targets_help = gengetopt_args_info_help[10];
  args_info->max_runtime_help = gengetopt_args_info_help[11];
  args_info->max_results_help = gengetopt_args_info_help[12];
  args_info->probes_help = gengetopt_args_info_help[13];
  args_info->cooldown_time_help = gengetopt_args_info_help[14];
  args_info->seed_help = gengetopt_args_info_help[15];
  args_info->retries_help = gengetopt_args_info_help[16];
  args_info->dryrun_help = gengetopt_args_info_help[17];
  args_info->shards_help = gengetopt_args_info_help[19];
  args_info->shard_help = gengetopt_args_info_help[20];
  args_info->source_port_help = gengetopt_args_info_help[22];
  args_info->source_ip_help = gengetopt_args_info_help[23];
  args_info->gateway_mac_help = gengetopt_args_info_help[24];
  args_info->source_mac_help = gengetopt_args_info_help[25];
  args_info->interface_help = gengetopt_args_info_help[26];
  args_info->iplayer_help = gengetopt_args_info_help[27];
  args_info->probe_module_help = gengetopt_args_info_help[29];
  args_info->probe_args_help = gengetopt_args_info_help[30];
  args_info->probe_ttl_help = gengetopt_args_info_help[31];
  args_info->list_probe_modules_help = gengetopt_args_info_help[32];
  args_info->output_fields_help = gengetopt_args_info_help[34];
  args_info->output_module_help = gengetopt_args_info_help[35];
  args_info->output_args_help = gengetopt_args_info_help[36];
  args_info->output_filter_help = gengetopt_args_info_help[37];
  args_info->list_output_modules_help = gengetopt_args_info_help[38];
  args_info->list_output_fields_help = gengetopt_args_info_help[39];
  args_info->no_header_row_help = gengetopt_args_info_help[40];
  args_info->verbosity_help = gengetopt_args_info_help[42];
  args_info->log_file_help = gengetopt_args_info_help[43];
  args_info->log_directory_help = gengetopt_args_info_help[44];
  args_info->metadata_file_help = gengetopt_args_info_help[45];
  args_info->status_updates_file_help = gengetopt_args_info_help[46];
  args_info->quiet_help = gengetopt_args_info_help[47];
  args_info->disable_syslog_help = gengetopt_args_info_help[48];
  args_info->notes_help = gengetopt_args_info_help[49];
  args_info->user_metadata_help = gengetopt_args_info_help[50];
  args_info->config_help = gengetopt_args_info_help[52];
  args_info->max_sendto_failures_help = gengetopt_args_info_help[53];
  args_info->min_hitrate_help = gengetopt_args_info_help[54];
  args_info->sender_threads_help = gengetopt_args_info_help[55];
  args_info->cores_help = gengetopt_args_info_help[56];
  args_info->ignore_blocklist_errors_help = gengetopt_args_info_help[57];
  args_info->help_help = gengetopt_args_info_help[58];
  args_info->version_help = gengetopt_args_info_help[59];
  return;
}
}
void cmdline_parser_print_version(void)
{
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  tmp___1 = strlen("zmap");
  if (tmp___1) {
    tmp___0 = "zmap";
  } else {
    tmp___0 = "zmap";
  }
  __printf_chk(1, (char const   * __restrict  )"%s %s\n", tmp___0, "DEVELOPMENT");
  tmp___2 = strlen(gengetopt_args_info_versiontext);
  if (tmp___2 > 0UL) {
    __printf_chk(1, (char const   * __restrict  )"\n%s\n", gengetopt_args_info_versiontext);
  }
  return;
}
}
static void print_help_common(void)
{
  size_t len_purpose ;
  size_t tmp ;
  size_t len_usage ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  tmp = strlen(gengetopt_args_info_purpose);
  len_purpose = tmp;
  tmp___0 = strlen(gengetopt_args_info_usage);
  len_usage = tmp___0;
  if (len_usage > 0UL) {
    __printf_chk(1, (char const   * __restrict  )"%s\n", gengetopt_args_info_usage);
  }
  if (len_purpose > 0UL) {
    __printf_chk(1, (char const   * __restrict  )"%s\n", gengetopt_args_info_purpose);
  }
  if (len_usage) {
    __printf_chk(1, (char const   * __restrict  )"\n");
  } else
  if (len_purpose) {
    __printf_chk(1, (char const   * __restrict  )"\n");
  }
  tmp___1 = strlen(gengetopt_args_info_description);
  if (tmp___1 > 0UL) {
    __printf_chk(1, (char const   * __restrict  )"%s\n\n", gengetopt_args_info_description);
  }
  return;
}
}
void cmdline_parser_print_help(void)
{
  int i ;
  int tmp ;

  {
  i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i]) {
    tmp = i;
    i ++;
    __printf_chk(1, (char const   * __restrict  )"%s\n", gengetopt_args_info_help[tmp]);
  }
  return;
}
}
void cmdline_parser_init(struct gengetopt_args_info *args_info )
{


  {
  clear_given(args_info);
  clear_args(args_info);
  init_args_info(args_info);
  args_info->inputs = (char **)0;
  args_info->inputs_num = 0U;
  return;
}
}
void cmdline_parser_params_init(struct cmdline_parser_params *params )
{


  {
  if (params) {
    params->override = 0;
    params->initialize = 1;
    params->check_required = 1;
    params->check_ambiguity = 0;
    params->print_errors = 1;
  }
  return;
}
}
struct cmdline_parser_params *cmdline_parser_params_create(void)
{
  struct cmdline_parser_params *params ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct cmdline_parser_params ));
  params = (struct cmdline_parser_params *)tmp;
  cmdline_parser_params_init(params);
  return (params);
}
}
static void free_string_field(char **s )
{


  {
  if (*s) {
    free((void *)*s);
    *s = (char *)0;
  }
  return;
}
}
static void cmdline_parser_release(struct gengetopt_args_info *args_info )
{
  unsigned int i ;

  {
  free_string_field(& args_info->target_port_orig);
  free_string_field(& args_info->output_file_arg);
  free_string_field(& args_info->output_file_orig);
  free_string_field(& args_info->blocklist_file_arg);
  free_string_field(& args_info->blocklist_file_orig);
  free_string_field(& args_info->allowlist_file_arg);
  free_string_field(& args_info->allowlist_file_orig);
  free_string_field(& args_info->list_of_ips_file_arg);
  free_string_field(& args_info->list_of_ips_file_orig);
  free_string_field(& args_info->rate_orig);
  free_string_field(& args_info->bandwidth_arg);
  free_string_field(& args_info->bandwidth_orig);
  free_string_field(& args_info->batch_orig);
  free_string_field(& args_info->max_targets_arg);
  free_string_field(& args_info->max_targets_orig);
  free_string_field(& args_info->max_runtime_orig);
  free_string_field(& args_info->max_results_orig);
  free_string_field(& args_info->probes_orig);
  free_string_field(& args_info->cooldown_time_orig);
  free_string_field(& args_info->seed_orig);
  free_string_field(& args_info->retries_orig);
  free_string_field(& args_info->shards_orig);
  free_string_field(& args_info->shard_orig);
  free_string_field(& args_info->source_port_arg);
  free_string_field(& args_info->source_port_orig);
  free_string_field(& args_info->source_ip_arg);
  free_string_field(& args_info->source_ip_orig);
  free_string_field(& args_info->gateway_mac_arg);
  free_string_field(& args_info->gateway_mac_orig);
  free_string_field(& args_info->source_mac_arg);
  free_string_field(& args_info->source_mac_orig);
  free_string_field(& args_info->interface_arg);
  free_string_field(& args_info->interface_orig);
  free_string_field(& args_info->probe_module_arg);
  free_string_field(& args_info->probe_module_orig);
  free_string_field(& args_info->probe_args_arg);
  free_string_field(& args_info->probe_args_orig);
  free_string_field(& args_info->probe_ttl_orig);
  free_string_field(& args_info->output_fields_arg);
  free_string_field(& args_info->output_fields_orig);
  free_string_field(& args_info->output_module_arg);
  free_string_field(& args_info->output_module_orig);
  free_string_field(& args_info->output_args_arg);
  free_string_field(& args_info->output_args_orig);
  free_string_field(& args_info->output_filter_arg);
  free_string_field(& args_info->output_filter_orig);
  free_string_field(& args_info->verbosity_orig);
  free_string_field(& args_info->log_file_arg);
  free_string_field(& args_info->log_file_orig);
  free_string_field(& args_info->log_directory_arg);
  free_string_field(& args_info->log_directory_orig);
  free_string_field(& args_info->metadata_file_arg);
  free_string_field(& args_info->metadata_file_orig);
  free_string_field(& args_info->status_updates_file_arg);
  free_string_field(& args_info->status_updates_file_orig);
  free_string_field(& args_info->notes_arg);
  free_string_field(& args_info->notes_orig);
  free_string_field(& args_info->user_metadata_arg);
  free_string_field(& args_info->user_metadata_orig);
  free_string_field(& args_info->config_arg);
  free_string_field(& args_info->config_orig);
  free_string_field(& args_info->max_sendto_failures_orig);
  free_string_field(& args_info->min_hitrate_orig);
  free_string_field(& args_info->sender_threads_orig);
  free_string_field(& args_info->cores_arg);
  free_string_field(& args_info->cores_orig);
  i = 0U;
  while (i < args_info->inputs_num) {
    free((void *)*(args_info->inputs + i));
    i ++;
  }
  if (args_info->inputs_num) {
    free((void *)args_info->inputs);
  }
  clear_given(args_info);
  return;
}
}
static void write_into_file(FILE *outfile , char const   *opt , char const   *arg ,
                            char const   **values )
{


  {
  if (arg) {
    __fprintf_chk((FILE * __restrict  )outfile, 1, (char const   * __restrict  )"%s=\"%s\"\n",
                  opt, arg);
  } else {
    __fprintf_chk((FILE * __restrict  )outfile, 1, (char const   * __restrict  )"%s\n",
                  opt);
  }
  return;
}
}
int cmdline_parser_dump(FILE *outfile , struct gengetopt_args_info *args_info )
{
  int i ;

  {
  i = 0;
  if (! outfile) {
    __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s: cannot dump options to stream\n",
                  "zmap");
    return (1);
  }
  if (args_info->target_port_given) {
    write_into_file(outfile, "target-port", (char const   *)args_info->target_port_orig,
                    (char const   **)0);
  }
  if (args_info->output_file_given) {
    write_into_file(outfile, "output-file", (char const   *)args_info->output_file_orig,
                    (char const   **)0);
  }
  if (args_info->blocklist_file_given) {
    write_into_file(outfile, "blocklist-file", (char const   *)args_info->blocklist_file_orig,
                    (char const   **)0);
  }
  if (args_info->allowlist_file_given) {
    write_into_file(outfile, "allowlist-file", (char const   *)args_info->allowlist_file_orig,
                    (char const   **)0);
  }
  if (args_info->list_of_ips_file_given) {
    write_into_file(outfile, "list-of-ips-file", (char const   *)args_info->list_of_ips_file_orig,
                    (char const   **)0);
  }
  if (args_info->rate_given) {
    write_into_file(outfile, "rate", (char const   *)args_info->rate_orig, (char const   **)0);
  }
  if (args_info->bandwidth_given) {
    write_into_file(outfile, "bandwidth", (char const   *)args_info->bandwidth_orig,
                    (char const   **)0);
  }
  if (args_info->batch_given) {
    write_into_file(outfile, "batch", (char const   *)args_info->batch_orig, (char const   **)0);
  }
  if (args_info->max_targets_given) {
    write_into_file(outfile, "max-targets", (char const   *)args_info->max_targets_orig,
                    (char const   **)0);
  }
  if (args_info->max_runtime_given) {
    write_into_file(outfile, "max-runtime", (char const   *)args_info->max_runtime_orig,
                    (char const   **)0);
  }
  if (args_info->max_results_given) {
    write_into_file(outfile, "max-results", (char const   *)args_info->max_results_orig,
                    (char const   **)0);
  }
  if (args_info->probes_given) {
    write_into_file(outfile, "probes", (char const   *)args_info->probes_orig, (char const   **)0);
  }
  if (args_info->cooldown_time_given) {
    write_into_file(outfile, "cooldown-time", (char const   *)args_info->cooldown_time_orig,
                    (char const   **)0);
  }
  if (args_info->seed_given) {
    write_into_file(outfile, "seed", (char const   *)args_info->seed_orig, (char const   **)0);
  }
  if (args_info->retries_given) {
    write_into_file(outfile, "retries", (char const   *)args_info->retries_orig, (char const   **)0);
  }
  if (args_info->dryrun_given) {
    write_into_file(outfile, "dryrun", (char const   *)0, (char const   **)0);
  }
  if (args_info->shards_given) {
    write_into_file(outfile, "shards", (char const   *)args_info->shards_orig, (char const   **)0);
  }
  if (args_info->shard_given) {
    write_into_file(outfile, "shard", (char const   *)args_info->shard_orig, (char const   **)0);
  }
  if (args_info->source_port_given) {
    write_into_file(outfile, "source-port", (char const   *)args_info->source_port_orig,
                    (char const   **)0);
  }
  if (args_info->source_ip_given) {
    write_into_file(outfile, "source-ip", (char const   *)args_info->source_ip_orig,
                    (char const   **)0);
  }
  if (args_info->gateway_mac_given) {
    write_into_file(outfile, "gateway-mac", (char const   *)args_info->gateway_mac_orig,
                    (char const   **)0);
  }
  if (args_info->source_mac_given) {
    write_into_file(outfile, "source-mac", (char const   *)args_info->source_mac_orig,
                    (char const   **)0);
  }
  if (args_info->interface_given) {
    write_into_file(outfile, "interface", (char const   *)args_info->interface_orig,
                    (char const   **)0);
  }
  if (args_info->iplayer_given) {
    write_into_file(outfile, "iplayer", (char const   *)0, (char const   **)0);
  }
  if (args_info->probe_module_given) {
    write_into_file(outfile, "probe-module", (char const   *)args_info->probe_module_orig,
                    (char const   **)0);
  }
  if (args_info->probe_args_given) {
    write_into_file(outfile, "probe-args", (char const   *)args_info->probe_args_orig,
                    (char const   **)0);
  }
  if (args_info->probe_ttl_given) {
    write_into_file(outfile, "probe-ttl", (char const   *)args_info->probe_ttl_orig,
                    (char const   **)0);
  }
  if (args_info->list_probe_modules_given) {
    write_into_file(outfile, "list-probe-modules", (char const   *)0, (char const   **)0);
  }
  if (args_info->output_fields_given) {
    write_into_file(outfile, "output-fields", (char const   *)args_info->output_fields_orig,
                    (char const   **)0);
  }
  if (args_info->output_module_given) {
    write_into_file(outfile, "output-module", (char const   *)args_info->output_module_orig,
                    (char const   **)0);
  }
  if (args_info->output_args_given) {
    write_into_file(outfile, "output-args", (char const   *)args_info->output_args_orig,
                    (char const   **)0);
  }
  if (args_info->output_filter_given) {
    write_into_file(outfile, "output-filter", (char const   *)args_info->output_filter_orig,
                    (char const   **)0);
  }
  if (args_info->list_output_modules_given) {
    write_into_file(outfile, "list-output-modules", (char const   *)0, (char const   **)0);
  }
  if (args_info->list_output_fields_given) {
    write_into_file(outfile, "list-output-fields", (char const   *)0, (char const   **)0);
  }
  if (args_info->no_header_row_given) {
    write_into_file(outfile, "no-header-row", (char const   *)0, (char const   **)0);
  }
  if (args_info->verbosity_given) {
    write_into_file(outfile, "verbosity", (char const   *)args_info->verbosity_orig,
                    (char const   **)0);
  }
  if (args_info->log_file_given) {
    write_into_file(outfile, "log-file", (char const   *)args_info->log_file_orig,
                    (char const   **)0);
  }
  if (args_info->log_directory_given) {
    write_into_file(outfile, "log-directory", (char const   *)args_info->log_directory_orig,
                    (char const   **)0);
  }
  if (args_info->metadata_file_given) {
    write_into_file(outfile, "metadata-file", (char const   *)args_info->metadata_file_orig,
                    (char const   **)0);
  }
  if (args_info->status_updates_file_given) {
    write_into_file(outfile, "status-updates-file", (char const   *)args_info->status_updates_file_orig,
                    (char const   **)0);
  }
  if (args_info->quiet_given) {
    write_into_file(outfile, "quiet", (char const   *)0, (char const   **)0);
  }
  if (args_info->disable_syslog_given) {
    write_into_file(outfile, "disable-syslog", (char const   *)0, (char const   **)0);
  }
  if (args_info->notes_given) {
    write_into_file(outfile, "notes", (char const   *)args_info->notes_orig, (char const   **)0);
  }
  if (args_info->user_metadata_given) {
    write_into_file(outfile, "user-metadata", (char const   *)args_info->user_metadata_orig,
                    (char const   **)0);
  }
  if (args_info->config_given) {
    write_into_file(outfile, "config", (char const   *)args_info->config_orig, (char const   **)0);
  }
  if (args_info->max_sendto_failures_given) {
    write_into_file(outfile, "max-sendto-failures", (char const   *)args_info->max_sendto_failures_orig,
                    (char const   **)0);
  }
  if (args_info->min_hitrate_given) {
    write_into_file(outfile, "min-hitrate", (char const   *)args_info->min_hitrate_orig,
                    (char const   **)0);
  }
  if (args_info->sender_threads_given) {
    write_into_file(outfile, "sender-threads", (char const   *)args_info->sender_threads_orig,
                    (char const   **)0);
  }
  if (args_info->cores_given) {
    write_into_file(outfile, "cores", (char const   *)args_info->cores_orig, (char const   **)0);
  }
  if (args_info->ignore_blocklist_errors_given) {
    write_into_file(outfile, "ignore-blocklist-errors", (char const   *)0, (char const   **)0);
  }
  if (args_info->help_given) {
    write_into_file(outfile, "help", (char const   *)0, (char const   **)0);
  }
  if (args_info->version_given) {
    write_into_file(outfile, "version", (char const   *)0, (char const   **)0);
  }
  i = 0;
  return (i);
}
}
int cmdline_parser_file_save(char const   *filename , struct gengetopt_args_info *args_info )
{
  FILE *outfile ;
  int i ;

  {
  i = 0;
  outfile = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"w");
  if (! outfile) {
    __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s: cannot open file for writing: %s\n",
                  "zmap", filename);
    return (1);
  }
  i = cmdline_parser_dump(outfile, args_info);
  fclose(outfile);
  return (i);
}
}
void cmdline_parser_free(struct gengetopt_args_info *args_info )
{


  {
  cmdline_parser_release(args_info);
  return;
}
}
static char *gengetopt_strdup(char const   *s )
{
  char *result ;
  size_t tmp ;
  void *tmp___0 ;

  {
  result = (char *)0;
  if (! s) {
    return (result);
  }
  tmp = strlen(s);
  tmp___0 = malloc(tmp + 1UL);
  result = (char *)tmp___0;
  if ((unsigned long )result == (unsigned long )((char *)0)) {
    return ((char *)0);
  }
  strcpy((char * __restrict  )result, (char const   * __restrict  )s);
  return (result);
}
}
int cmdline_parser(int argc , char **argv , struct gengetopt_args_info *args_info )
{
  int tmp ;

  {
  tmp = cmdline_parser2(argc, argv, args_info, 0, 1, 1);
  return (tmp);
}
}
int cmdline_parser_ext(int argc , char **argv , struct gengetopt_args_info *args_info ,
                       struct cmdline_parser_params *params )
{
  int result ;

  {
  result = cmdline_parser_internal(argc, argv, args_info, params, (char const   *)0);
  if (result == 1) {
    cmdline_parser_free(args_info);
    exit(1);
  }
  return (result);
}
}
int cmdline_parser2(int argc , char **argv , struct gengetopt_args_info *args_info ,
                    int override , int initialize , int check_required )
{
  int result ;
  struct cmdline_parser_params params ;

  {
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;
  result = cmdline_parser_internal(argc, argv, args_info, & params, (char const   *)0);
  if (result == 1) {
    cmdline_parser_free(args_info);
    exit(1);
  }
  return (result);
}
}
int cmdline_parser_required(struct gengetopt_args_info *args_info , char const   *prog_name )
{


  {
  return (0);
}
}
static char *package_name  =    (char *)0;
static int update_arg(void *field , char **orig_field , unsigned int *field_given ,
                      unsigned int *prev_given , char *value , char const   **possible_values ,
                      char const   *default_value , cmdline_parser_arg_type arg_type ,
                      int check_ambiguity , int override , int no_free , int multiple_option ,
                      char const   *long_opt , char short_opt , char const   *additional_error )
{
  char *stop_char ;
  char const   *val ;
  int found ;
  char **string_field ;
  char const   *tmp ;
  char const   *tmp___0 ;
  long tmp___1 ;
  double tmp___2 ;
  long tmp___3 ;

  {
  stop_char = (char *)0;
  val = (char const   *)value;
  stop_char = (char *)0;
  found = 0;
  if (! multiple_option) {
    if (prev_given) {
      if (*prev_given) {
        goto _L;
      } else
      if (check_ambiguity) {
        if (*field_given) {
          _L: /* CIL Label */
          if ((int )short_opt != 45) {
            if (additional_error) {
              tmp = additional_error;
            } else {
              tmp = "";
            }
            __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s: `--%s\' (`-%c\') option given more than once%s\n",
                          package_name, long_opt, (int )short_opt, tmp);
          } else {
            if (additional_error) {
              tmp___0 = additional_error;
            } else {
              tmp___0 = "";
            }
            __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s: `--%s\' option given more than once%s\n",
                          package_name, long_opt, tmp___0);
          }
          return (1);
        }
      }
    }
  }
  if (field_given) {
    if (*field_given) {
      if (! override) {
        return (0);
      }
    }
  }
  if (prev_given) {
    (*prev_given) ++;
  }
  if (field_given) {
    (*field_given) ++;
  }
  if (possible_values) {
    val = *(possible_values + found);
  }
  switch ((unsigned int )arg_type) {
  case 2U:
  if (val) {
    tmp___1 = strtol((char const   * __restrict  )val, (char ** __restrict  )(& stop_char),
                     0);
    *((int *)field) = (int )tmp___1;
  }
  break;
  case 3U:
  if (val) {
    tmp___2 = strtod((char const   * __restrict  )val, (char ** __restrict  )(& stop_char));
    *((float *)field) = (float )tmp___2;
  }
  break;
  case 4U:
  if (val) {
    tmp___3 = strtol((char const   * __restrict  )val, (char ** __restrict  )(& stop_char),
                     0);
    *((long *)field) = tmp___3;
  }
  break;
  case 1U:
  if (val) {
    string_field = (char **)field;
    if (! no_free) {
      if (*string_field) {
        free((void *)*string_field);
      }
    }
    *string_field = gengetopt_strdup(val);
  }
  break;
  default:
  break;
  }
  switch ((unsigned int )arg_type) {
  case 4U:
  case 3U:
  case 2U:
  if (val) {
    if (stop_char) {
      if (! ((int )*stop_char == 0)) {
        __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s: invalid numeric value: %s\n",
                      package_name, val);
        return (1);
      }
    } else {
      __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s: invalid numeric value: %s\n",
                    package_name, val);
      return (1);
    }
  }
  break;
  default: ;
  }
  switch ((unsigned int )arg_type) {
  case 0U:
  break;
  default:
  if (value) {
    if (orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field) {
          free((void *)*orig_field);
        }
        *orig_field = gengetopt_strdup((char const   *)value);
      }
    }
  }
  }
  return (0);
}
}
static struct option long_options[53]  =
  {      {"target-port", 1, (int *)((void *)0), 'p'},
        {"output-file", 1, (int *)((void *)0), 'o'},
        {"blocklist-file", 1, (int *)((void *)0), 'b'},
        {"allowlist-file", 1, (int *)((void *)0), 'w'},
        {"list-of-ips-file", 1, (int *)((void *)0), 'I'},
        {"rate", 1, (int *)((void *)0), 'r'},
        {"bandwidth", 1, (int *)((void *)0), 'B'},
        {"batch", 1, (int *)((void *)0), 0},
        {"max-targets", 1, (int *)((void *)0), 'n'},
        {"max-runtime", 1, (int *)((void *)0), 't'},
        {"max-results", 1, (int *)((void *)0), 'N'},
        {"probes", 1, (int *)((void *)0), 'P'},
        {"cooldown-time", 1, (int *)((void *)0), 'c'},
        {"seed", 1, (int *)((void *)0), 'e'},
        {"retries", 1, (int *)((void *)0), 0},
        {"dryrun", 0, (int *)((void *)0), 'd'},
        {"shards", 1, (int *)((void *)0), 0},
        {"shard", 1, (int *)((void *)0), 0},
        {"source-port", 1, (int *)((void *)0), 's'},
        {"source-ip", 1, (int *)((void *)0), 'S'},
        {"gateway-mac", 1, (int *)((void *)0), 'G'},
        {"source-mac", 1, (int *)((void *)0), 0},
        {"interface", 1, (int *)((void *)0), 'i'},
        {"iplayer", 0, (int *)((void *)0), 'X'},
        {"probe-module", 1, (int *)((void *)0), 'M'},
        {"probe-args", 1, (int *)((void *)0), 0},
        {"probe-ttl", 1, (int *)((void *)0), 0},
        {"list-probe-modules", 0, (int *)((void *)0), 0},
        {"output-fields", 1, (int *)((void *)0), 'f'},
        {"output-module", 1, (int *)((void *)0), 'O'},
        {"output-args", 1, (int *)((void *)0), 0},
        {"output-filter", 1, (int *)((void *)0), 0},
        {"list-output-modules", 0, (int *)((void *)0), 0},
        {"list-output-fields", 0, (int *)((void *)0), 0},
        {"no-header-row", 0, (int *)((void *)0), 0},
        {"verbosity", 1, (int *)((void *)0), 'v'},
        {"log-file", 1, (int *)((void *)0), 'l'},
        {"log-directory", 1, (int *)((void *)0), 'L'},
        {"metadata-file", 1, (int *)((void *)0), 'm'},
        {"status-updates-file", 1, (int *)((void *)0), 'u'},
        {"quiet", 0, (int *)((void *)0), 'q'},
        {"disable-syslog", 0, (int *)((void *)0), 0},
        {"notes", 1, (int *)((void *)0), 0},
        {"user-metadata", 1, (int *)((void *)0), 0},
        {"config", 1, (int *)((void *)0), 'C'},
        {"max-sendto-failures", 1, (int *)((void *)0), 0},
        {"min-hitrate", 1, (int *)((void *)0), 0},
        {"sender-threads", 1, (int *)((void *)0), 'T'},
        {"cores", 1, (int *)((void *)0), 0},
        {"ignore-blocklist-errors", 0, (int *)((void *)0), 0},
        {"help", 0, (int *)((void *)0), 'h'},
        {"version", 0, (int *)((void *)0), 'V'},
        {(char const   *)0, 0, (int *)0, 0}};
static int cmdline_parser_internal(int argc , char **argv , struct gengetopt_args_info *args_info ,
                                   struct cmdline_parser_params *params , char const   *additional_error )
{
  int c ;
  int error_occurred ;
  struct gengetopt_args_info local_args_info ;
  int override ;
  int initialize ;
  int check_required ;
  int check_ambiguity ;
  int option_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  char const   *tmp___71 ;
  int i ;
  int found_prog_name ;
  int tmp___72 ;
  void *tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;

  {
  error_occurred = 0;
  package_name = *(argv + 0);
  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;
  if (initialize) {
    cmdline_parser_init(args_info);
  }
  cmdline_parser_init(& local_args_info);
  optarg = (char *)0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';
  while (1) {
    option_index = 0;
    c = getopt_long(argc, (char * const  *)argv, "p:o:b:w:I:r:B:n:t:N:P:c:e:ds:S:G:i:XM:f:O:v:l:L:m:u:qC:T:hV",
                    (struct option  const  *)(long_options), & option_index);
    if (c == -1) {
      break;
    }
    switch (c) {
    case 112:
    tmp = update_arg((void *)(& args_info->target_port_arg), & args_info->target_port_orig,
                     & args_info->target_port_given, & local_args_info.target_port_given,
                     optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )2,
                     check_ambiguity, override, 0, 0, "target-port", (char )'p', additional_error);
    if (tmp) {
      goto failure;
    }
    break;
    case 111:
    tmp___0 = update_arg((void *)(& args_info->output_file_arg), & args_info->output_file_orig,
                         & args_info->output_file_given, & local_args_info.output_file_given,
                         optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                         check_ambiguity, override, 0, 0, "output-file", (char )'o',
                         additional_error);
    if (tmp___0) {
      goto failure;
    }
    break;
    case 98:
    tmp___1 = update_arg((void *)(& args_info->blocklist_file_arg), & args_info->blocklist_file_orig,
                         & args_info->blocklist_file_given, & local_args_info.blocklist_file_given,
                         optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                         check_ambiguity, override, 0, 0, "blocklist-file", (char )'b',
                         additional_error);
    if (tmp___1) {
      goto failure;
    }
    break;
    case 119:
    tmp___2 = update_arg((void *)(& args_info->allowlist_file_arg), & args_info->allowlist_file_orig,
                         & args_info->allowlist_file_given, & local_args_info.allowlist_file_given,
                         optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                         check_ambiguity, override, 0, 0, "allowlist-file", (char )'w',
                         additional_error);
    if (tmp___2) {
      goto failure;
    }
    break;
    case 73:
    tmp___3 = update_arg((void *)(& args_info->list_of_ips_file_arg), & args_info->list_of_ips_file_orig,
                         & args_info->list_of_ips_file_given, & local_args_info.list_of_ips_file_given,
                         optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                         check_ambiguity, override, 0, 0, "list-of-ips-file", (char )'I',
                         additional_error);
    if (tmp___3) {
      goto failure;
    }
    break;
    case 114:
    tmp___4 = update_arg((void *)(& args_info->rate_arg), & args_info->rate_orig,
                         & args_info->rate_given, & local_args_info.rate_given, optarg,
                         (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )2,
                         check_ambiguity, override, 0, 0, "rate", (char )'r', additional_error);
    if (tmp___4) {
      goto failure;
    }
    break;
    case 66:
    tmp___5 = update_arg((void *)(& args_info->bandwidth_arg), & args_info->bandwidth_orig,
                         & args_info->bandwidth_given, & local_args_info.bandwidth_given,
                         optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                         check_ambiguity, override, 0, 0, "bandwidth", (char )'B',
                         additional_error);
    if (tmp___5) {
      goto failure;
    }
    break;
    case 110:
    tmp___6 = update_arg((void *)(& args_info->max_targets_arg), & args_info->max_targets_orig,
                         & args_info->max_targets_given, & local_args_info.max_targets_given,
                         optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                         check_ambiguity, override, 0, 0, "max-targets", (char )'n',
                         additional_error);
    if (tmp___6) {
      goto failure;
    }
    break;
    case 116:
    tmp___7 = update_arg((void *)(& args_info->max_runtime_arg), & args_info->max_runtime_orig,
                         & args_info->max_runtime_given, & local_args_info.max_runtime_given,
                         optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )2,
                         check_ambiguity, override, 0, 0, "max-runtime", (char )'t',
                         additional_error);
    if (tmp___7) {
      goto failure;
    }
    break;
    case 78:
    tmp___8 = update_arg((void *)(& args_info->max_results_arg), & args_info->max_results_orig,
                         & args_info->max_results_given, & local_args_info.max_results_given,
                         optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )2,
                         check_ambiguity, override, 0, 0, "max-results", (char )'N',
                         additional_error);
    if (tmp___8) {
      goto failure;
    }
    break;
    case 80:
    tmp___9 = update_arg((void *)(& args_info->probes_arg), & args_info->probes_orig,
                         & args_info->probes_given, & local_args_info.probes_given,
                         optarg, (char const   **)0, "1", (cmdline_parser_arg_type )2,
                         check_ambiguity, override, 0, 0, "probes", (char )'P', additional_error);
    if (tmp___9) {
      goto failure;
    }
    break;
    case 99:
    tmp___10 = update_arg((void *)(& args_info->cooldown_time_arg), & args_info->cooldown_time_orig,
                          & args_info->cooldown_time_given, & local_args_info.cooldown_time_given,
                          optarg, (char const   **)0, "8", (cmdline_parser_arg_type )2,
                          check_ambiguity, override, 0, 0, "cooldown-time", (char )'c',
                          additional_error);
    if (tmp___10) {
      goto failure;
    }
    break;
    case 101:
    tmp___11 = update_arg((void *)(& args_info->seed_arg), & args_info->seed_orig,
                          & args_info->seed_given, & local_args_info.seed_given, optarg,
                          (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )4,
                          check_ambiguity, override, 0, 0, "seed", (char )'e', additional_error);
    if (tmp___11) {
      goto failure;
    }
    break;
    case 100:
    tmp___12 = update_arg((void *)0, (char **)0, & args_info->dryrun_given, & local_args_info.dryrun_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )0,
                          check_ambiguity, override, 0, 0, "dryrun", (char )'d', additional_error);
    if (tmp___12) {
      goto failure;
    }
    break;
    case 115:
    tmp___13 = update_arg((void *)(& args_info->source_port_arg), & args_info->source_port_orig,
                          & args_info->source_port_given, & local_args_info.source_port_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                          check_ambiguity, override, 0, 0, "source-port", (char )'s',
                          additional_error);
    if (tmp___13) {
      goto failure;
    }
    break;
    case 83:
    tmp___14 = update_arg((void *)(& args_info->source_ip_arg), & args_info->source_ip_orig,
                          & args_info->source_ip_given, & local_args_info.source_ip_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                          check_ambiguity, override, 0, 0, "source-ip", (char )'S',
                          additional_error);
    if (tmp___14) {
      goto failure;
    }
    break;
    case 71:
    tmp___15 = update_arg((void *)(& args_info->gateway_mac_arg), & args_info->gateway_mac_orig,
                          & args_info->gateway_mac_given, & local_args_info.gateway_mac_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                          check_ambiguity, override, 0, 0, "gateway-mac", (char )'G',
                          additional_error);
    if (tmp___15) {
      goto failure;
    }
    break;
    case 105:
    tmp___16 = update_arg((void *)(& args_info->interface_arg), & args_info->interface_orig,
                          & args_info->interface_given, & local_args_info.interface_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                          check_ambiguity, override, 0, 0, "interface", (char )'i',
                          additional_error);
    if (tmp___16) {
      goto failure;
    }
    break;
    case 88:
    tmp___17 = update_arg((void *)0, (char **)0, & args_info->iplayer_given, & local_args_info.iplayer_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )0,
                          check_ambiguity, override, 0, 0, "iplayer", (char )'X',
                          additional_error);
    if (tmp___17) {
      goto failure;
    }
    break;
    case 77:
    tmp___18 = update_arg((void *)(& args_info->probe_module_arg), & args_info->probe_module_orig,
                          & args_info->probe_module_given, & local_args_info.probe_module_given,
                          optarg, (char const   **)0, "tcp_synscan", (cmdline_parser_arg_type )1,
                          check_ambiguity, override, 0, 0, "probe-module", (char )'M',
                          additional_error);
    if (tmp___18) {
      goto failure;
    }
    break;
    case 102:
    tmp___19 = update_arg((void *)(& args_info->output_fields_arg), & args_info->output_fields_orig,
                          & args_info->output_fields_given, & local_args_info.output_fields_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                          check_ambiguity, override, 0, 0, "output-fields", (char )'f',
                          additional_error);
    if (tmp___19) {
      goto failure;
    }
    break;
    case 79:
    tmp___20 = update_arg((void *)(& args_info->output_module_arg), & args_info->output_module_orig,
                          & args_info->output_module_given, & local_args_info.output_module_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                          check_ambiguity, override, 0, 0, "output-module", (char )'O',
                          additional_error);
    if (tmp___20) {
      goto failure;
    }
    break;
    case 118:
    tmp___21 = update_arg((void *)(& args_info->verbosity_arg), & args_info->verbosity_orig,
                          & args_info->verbosity_given, & local_args_info.verbosity_given,
                          optarg, (char const   **)0, "3", (cmdline_parser_arg_type )2,
                          check_ambiguity, override, 0, 0, "verbosity", (char )'v',
                          additional_error);
    if (tmp___21) {
      goto failure;
    }
    break;
    case 108:
    tmp___22 = update_arg((void *)(& args_info->log_file_arg), & args_info->log_file_orig,
                          & args_info->log_file_given, & local_args_info.log_file_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                          check_ambiguity, override, 0, 0, "log-file", (char )'l',
                          additional_error);
    if (tmp___22) {
      goto failure;
    }
    break;
    case 76:
    tmp___23 = update_arg((void *)(& args_info->log_directory_arg), & args_info->log_directory_orig,
                          & args_info->log_directory_given, & local_args_info.log_directory_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                          check_ambiguity, override, 0, 0, "log-directory", (char )'L',
                          additional_error);
    if (tmp___23) {
      goto failure;
    }
    break;
    case 109:
    tmp___24 = update_arg((void *)(& args_info->metadata_file_arg), & args_info->metadata_file_orig,
                          & args_info->metadata_file_given, & local_args_info.metadata_file_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                          check_ambiguity, override, 0, 0, "metadata-file", (char )'m',
                          additional_error);
    if (tmp___24) {
      goto failure;
    }
    break;
    case 117:
    tmp___25 = update_arg((void *)(& args_info->status_updates_file_arg), & args_info->status_updates_file_orig,
                          & args_info->status_updates_file_given, & local_args_info.status_updates_file_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )1,
                          check_ambiguity, override, 0, 0, "status-updates-file",
                          (char )'u', additional_error);
    if (tmp___25) {
      goto failure;
    }
    break;
    case 113:
    tmp___26 = update_arg((void *)0, (char **)0, & args_info->quiet_given, & local_args_info.quiet_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )0,
                          check_ambiguity, override, 0, 0, "quiet", (char )'q', additional_error);
    if (tmp___26) {
      goto failure;
    }
    break;
    case 67:
    tmp___27 = update_arg((void *)(& args_info->config_arg), & args_info->config_orig,
                          & args_info->config_given, & local_args_info.config_given,
                          optarg, (char const   **)0, "/etc/zmap/zmap.conf", (cmdline_parser_arg_type )1,
                          check_ambiguity, override, 0, 0, "config", (char )'C', additional_error);
    if (tmp___27) {
      goto failure;
    }
    break;
    case 84:
    tmp___28 = update_arg((void *)(& args_info->sender_threads_arg), & args_info->sender_threads_orig,
                          & args_info->sender_threads_given, & local_args_info.sender_threads_given,
                          optarg, (char const   **)0, "1", (cmdline_parser_arg_type )2,
                          check_ambiguity, override, 0, 0, "sender-threads", (char )'T',
                          additional_error);
    if (tmp___28) {
      goto failure;
    }
    break;
    case 104:
    tmp___29 = update_arg((void *)0, (char **)0, & args_info->help_given, & local_args_info.help_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )0,
                          check_ambiguity, override, 0, 0, "help", (char )'h', additional_error);
    if (tmp___29) {
      goto failure;
    }
    break;
    case 86:
    tmp___30 = update_arg((void *)0, (char **)0, & args_info->version_given, & local_args_info.version_given,
                          optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )0,
                          check_ambiguity, override, 0, 0, "version", (char )'V',
                          additional_error);
    if (tmp___30) {
      goto failure;
    }
    break;
    case 0:
    tmp___70 = strcmp(long_options[option_index].name, "batch");
    if (tmp___70 == 0) {
      tmp___31 = update_arg((void *)(& args_info->batch_arg), & args_info->batch_orig,
                            & args_info->batch_given, & local_args_info.batch_given,
                            optarg, (char const   **)0, (char const   *)0, (cmdline_parser_arg_type )2,
                            check_ambiguity, override, 0, 0, "batch", (char )'-',
                            additional_error);
      if (tmp___31) {
        goto failure;
      }
    } else {
      tmp___69 = strcmp(long_options[option_index].name, "retries");
      if (tmp___69 == 0) {
        tmp___32 = update_arg((void *)(& args_info->retries_arg), & args_info->retries_orig,
                              & args_info->retries_given, & local_args_info.retries_given,
                              optarg, (char const   **)0, "10", (cmdline_parser_arg_type )2,
                              check_ambiguity, override, 0, 0, "retries", (char )'-',
                              additional_error);
        if (tmp___32) {
          goto failure;
        }
      } else {
        tmp___68 = strcmp(long_options[option_index].name, "shards");
        if (tmp___68 == 0) {
          tmp___33 = update_arg((void *)(& args_info->shards_arg), & args_info->shards_orig,
                                & args_info->shards_given, & local_args_info.shards_given,
                                optarg, (char const   **)0, "1", (cmdline_parser_arg_type )2,
                                check_ambiguity, override, 0, 0, "shards", (char )'-',
                                additional_error);
          if (tmp___33) {
            goto failure;
          }
        } else {
          tmp___67 = strcmp(long_options[option_index].name, "shard");
          if (tmp___67 == 0) {
            tmp___34 = update_arg((void *)(& args_info->shard_arg), & args_info->shard_orig,
                                  & args_info->shard_given, & local_args_info.shard_given,
                                  optarg, (char const   **)0, "0", (cmdline_parser_arg_type )2,
                                  check_ambiguity, override, 0, 0, "shard", (char )'-',
                                  additional_error);
            if (tmp___34) {
              goto failure;
            }
          } else {
            tmp___66 = strcmp(long_options[option_index].name, "source-mac");
            if (tmp___66 == 0) {
              tmp___35 = update_arg((void *)(& args_info->source_mac_arg), & args_info->source_mac_orig,
                                    & args_info->source_mac_given, & local_args_info.source_mac_given,
                                    optarg, (char const   **)0, (char const   *)0,
                                    (cmdline_parser_arg_type )1, check_ambiguity,
                                    override, 0, 0, "source-mac", (char )'-', additional_error);
              if (tmp___35) {
                goto failure;
              }
            } else {
              tmp___65 = strcmp(long_options[option_index].name, "probe-args");
              if (tmp___65 == 0) {
                tmp___36 = update_arg((void *)(& args_info->probe_args_arg), & args_info->probe_args_orig,
                                      & args_info->probe_args_given, & local_args_info.probe_args_given,
                                      optarg, (char const   **)0, (char const   *)0,
                                      (cmdline_parser_arg_type )1, check_ambiguity,
                                      override, 0, 0, "probe-args", (char )'-', additional_error);
                if (tmp___36) {
                  goto failure;
                }
              } else {
                tmp___64 = strcmp(long_options[option_index].name, "probe-ttl");
                if (tmp___64 == 0) {
                  tmp___37 = update_arg((void *)(& args_info->probe_ttl_arg), & args_info->probe_ttl_orig,
                                        & args_info->probe_ttl_given, & local_args_info.probe_ttl_given,
                                        optarg, (char const   **)0, "255", (cmdline_parser_arg_type )2,
                                        check_ambiguity, override, 0, 0, "probe-ttl",
                                        (char )'-', additional_error);
                  if (tmp___37) {
                    goto failure;
                  }
                } else {
                  tmp___63 = strcmp(long_options[option_index].name, "list-probe-modules");
                  if (tmp___63 == 0) {
                    tmp___38 = update_arg((void *)0, (char **)0, & args_info->list_probe_modules_given,
                                          & local_args_info.list_probe_modules_given,
                                          optarg, (char const   **)0, (char const   *)0,
                                          (cmdline_parser_arg_type )0, check_ambiguity,
                                          override, 0, 0, "list-probe-modules", (char )'-',
                                          additional_error);
                    if (tmp___38) {
                      goto failure;
                    }
                  } else {
                    tmp___62 = strcmp(long_options[option_index].name, "output-args");
                    if (tmp___62 == 0) {
                      tmp___39 = update_arg((void *)(& args_info->output_args_arg),
                                            & args_info->output_args_orig, & args_info->output_args_given,
                                            & local_args_info.output_args_given, optarg,
                                            (char const   **)0, (char const   *)0,
                                            (cmdline_parser_arg_type )1, check_ambiguity,
                                            override, 0, 0, "output-args", (char )'-',
                                            additional_error);
                      if (tmp___39) {
                        goto failure;
                      }
                    } else {
                      tmp___61 = strcmp(long_options[option_index].name, "output-filter");
                      if (tmp___61 == 0) {
                        tmp___40 = update_arg((void *)(& args_info->output_filter_arg),
                                              & args_info->output_filter_orig, & args_info->output_filter_given,
                                              & local_args_info.output_filter_given,
                                              optarg, (char const   **)0, (char const   *)0,
                                              (cmdline_parser_arg_type )1, check_ambiguity,
                                              override, 0, 0, "output-filter", (char )'-',
                                              additional_error);
                        if (tmp___40) {
                          goto failure;
                        }
                      } else {
                        tmp___60 = strcmp(long_options[option_index].name, "list-output-modules");
                        if (tmp___60 == 0) {
                          tmp___41 = update_arg((void *)0, (char **)0, & args_info->list_output_modules_given,
                                                & local_args_info.list_output_modules_given,
                                                optarg, (char const   **)0, (char const   *)0,
                                                (cmdline_parser_arg_type )0, check_ambiguity,
                                                override, 0, 0, "list-output-modules",
                                                (char )'-', additional_error);
                          if (tmp___41) {
                            goto failure;
                          }
                        } else {
                          tmp___59 = strcmp(long_options[option_index].name, "list-output-fields");
                          if (tmp___59 == 0) {
                            tmp___42 = update_arg((void *)0, (char **)0, & args_info->list_output_fields_given,
                                                  & local_args_info.list_output_fields_given,
                                                  optarg, (char const   **)0, (char const   *)0,
                                                  (cmdline_parser_arg_type )0, check_ambiguity,
                                                  override, 0, 0, "list-output-fields",
                                                  (char )'-', additional_error);
                            if (tmp___42) {
                              goto failure;
                            }
                          } else {
                            tmp___58 = strcmp(long_options[option_index].name, "no-header-row");
                            if (tmp___58 == 0) {
                              tmp___43 = update_arg((void *)0, (char **)0, & args_info->no_header_row_given,
                                                    & local_args_info.no_header_row_given,
                                                    optarg, (char const   **)0, (char const   *)0,
                                                    (cmdline_parser_arg_type )0, check_ambiguity,
                                                    override, 0, 0, "no-header-row",
                                                    (char )'-', additional_error);
                              if (tmp___43) {
                                goto failure;
                              }
                            } else {
                              tmp___57 = strcmp(long_options[option_index].name, "disable-syslog");
                              if (tmp___57 == 0) {
                                tmp___44 = update_arg((void *)0, (char **)0, & args_info->disable_syslog_given,
                                                      & local_args_info.disable_syslog_given,
                                                      optarg, (char const   **)0,
                                                      (char const   *)0, (cmdline_parser_arg_type )0,
                                                      check_ambiguity, override, 0,
                                                      0, "disable-syslog", (char )'-',
                                                      additional_error);
                                if (tmp___44) {
                                  goto failure;
                                }
                              } else {
                                tmp___56 = strcmp(long_options[option_index].name,
                                                  "notes");
                                if (tmp___56 == 0) {
                                  tmp___45 = update_arg((void *)(& args_info->notes_arg),
                                                        & args_info->notes_orig, & args_info->notes_given,
                                                        & local_args_info.notes_given,
                                                        optarg, (char const   **)0,
                                                        (char const   *)0, (cmdline_parser_arg_type )1,
                                                        check_ambiguity, override,
                                                        0, 0, "notes", (char )'-',
                                                        additional_error);
                                  if (tmp___45) {
                                    goto failure;
                                  }
                                } else {
                                  tmp___55 = strcmp(long_options[option_index].name,
                                                    "user-metadata");
                                  if (tmp___55 == 0) {
                                    tmp___46 = update_arg((void *)(& args_info->user_metadata_arg),
                                                          & args_info->user_metadata_orig,
                                                          & args_info->user_metadata_given,
                                                          & local_args_info.user_metadata_given,
                                                          optarg, (char const   **)0,
                                                          (char const   *)0, (cmdline_parser_arg_type )1,
                                                          check_ambiguity, override,
                                                          0, 0, "user-metadata", (char )'-',
                                                          additional_error);
                                    if (tmp___46) {
                                      goto failure;
                                    }
                                  } else {
                                    tmp___54 = strcmp(long_options[option_index].name,
                                                      "max-sendto-failures");
                                    if (tmp___54 == 0) {
                                      tmp___47 = update_arg((void *)(& args_info->max_sendto_failures_arg),
                                                            & args_info->max_sendto_failures_orig,
                                                            & args_info->max_sendto_failures_given,
                                                            & local_args_info.max_sendto_failures_given,
                                                            optarg, (char const   **)0,
                                                            "-1", (cmdline_parser_arg_type )2,
                                                            check_ambiguity, override,
                                                            0, 0, "max-sendto-failures",
                                                            (char )'-', additional_error);
                                      if (tmp___47) {
                                        goto failure;
                                      }
                                    } else {
                                      tmp___53 = strcmp(long_options[option_index].name,
                                                        "min-hitrate");
                                      if (tmp___53 == 0) {
                                        tmp___48 = update_arg((void *)(& args_info->min_hitrate_arg),
                                                              & args_info->min_hitrate_orig,
                                                              & args_info->min_hitrate_given,
                                                              & local_args_info.min_hitrate_given,
                                                              optarg, (char const   **)0,
                                                              "0.0", (cmdline_parser_arg_type )3,
                                                              check_ambiguity, override,
                                                              0, 0, "min-hitrate",
                                                              (char )'-', additional_error);
                                        if (tmp___48) {
                                          goto failure;
                                        }
                                      } else {
                                        tmp___52 = strcmp(long_options[option_index].name,
                                                          "cores");
                                        if (tmp___52 == 0) {
                                          tmp___49 = update_arg((void *)(& args_info->cores_arg),
                                                                & args_info->cores_orig,
                                                                & args_info->cores_given,
                                                                & local_args_info.cores_given,
                                                                optarg, (char const   **)0,
                                                                (char const   *)0,
                                                                (cmdline_parser_arg_type )1,
                                                                check_ambiguity, override,
                                                                0, 0, "cores", (char )'-',
                                                                additional_error);
                                          if (tmp___49) {
                                            goto failure;
                                          }
                                        } else {
                                          tmp___51 = strcmp(long_options[option_index].name,
                                                            "ignore-blocklist-errors");
                                          if (tmp___51 == 0) {
                                            tmp___50 = update_arg((void *)0, (char **)0,
                                                                  & args_info->ignore_blocklist_errors_given,
                                                                  & local_args_info.ignore_blocklist_errors_given,
                                                                  optarg, (char const   **)0,
                                                                  (char const   *)0,
                                                                  (cmdline_parser_arg_type )0,
                                                                  check_ambiguity,
                                                                  override, 0, 0,
                                                                  "ignore-blocklist-errors",
                                                                  (char )'-', additional_error);
                                            if (tmp___50) {
                                              goto failure;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    break;
    case 63:
    goto failure;
    default:
    if (additional_error) {
      tmp___71 = additional_error;
    } else {
      tmp___71 = "";
    }
    __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s: option unknown: %c%s\n",
                  "zmap", c, tmp___71);
    abort();
    }
  }
  cmdline_parser_release(& local_args_info);
  if (error_occurred) {
    return (1);
  }
  if (optind < argc) {
    i = 0;
    found_prog_name = 0;
    i = optind;
    while (i < argc) {
      tmp___72 = i;
      i ++;
      if ((unsigned long )*(argv + tmp___72) == (unsigned long )*(argv + 0)) {
        found_prog_name = 1;
        break;
      }
    }
    i = 0;
    args_info->inputs_num = (unsigned int )((argc - optind) - found_prog_name);
    tmp___73 = malloc((unsigned long )args_info->inputs_num * sizeof(char *));
    args_info->inputs = (char **)tmp___73;
    while (optind < argc) {
      tmp___75 = optind;
      optind ++;
      if ((unsigned long )*(argv + tmp___75) != (unsigned long )*(argv + 0)) {
        tmp___74 = i;
        i ++;
        *(args_info->inputs + tmp___74) = gengetopt_strdup((char const   *)*(argv + (optind - 1)));
      }
    }
  }
  return (0);
  failure:
  cmdline_parser_release(& local_args_info);
  return (1);
}
}
static int _cmdline_parser_configfile(char const   *filename , int *my_argc )
{
  FILE *file___1 ;
  char my_argv[2052] ;
  char linebuf[2048] ;
  int line_num ;
  int result ;
  int equal ;
  char *fopt ;
  char *farg ;
  char *str_index ;
  size_t len ;
  size_t next_token ;
  char delimiter ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;

  {
  line_num = 0;
  result = 0;
  file___1 = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
  if ((unsigned long )file___1 == (unsigned long )((FILE *)0)) {
    __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s: Error opening configuration file \'%s\'\n",
                  "zmap", filename);
    return (1);
  }
  while (1) {
    tmp___7 = fgets((char * __restrict  )(linebuf), 2048, (FILE * __restrict  )file___1);
    if (! ((unsigned long )tmp___7 != (unsigned long )((char *)0))) {
      break;
    }
    line_num ++;
    my_argv[0] = (char )'\000';
    len = strlen((char const   *)(linebuf));
    if (len > 2050UL) {
      __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s:%s:%d: Line too long in configuration file\n",
                    "zmap", filename, line_num);
      result = 1;
      break;
    }
    next_token = strspn((char const   *)(linebuf), " \t\r\n");
    str_index = linebuf + next_token;
    if ((int )*(str_index + 0) == 0) {
      continue;
    } else
    if ((int )*(str_index + 0) == 35) {
      continue;
    }
    fopt = str_index;
    next_token = strcspn((char const   *)fopt, " \t\r\n=");
    if ((int )*(fopt + next_token) == 0) {
      farg = (char *)0;
      equal = 0;
      goto noarg;
    }
    equal = (int )*(fopt + next_token) == 61;
    tmp = next_token;
    next_token ++;
    *(fopt + tmp) = (char )'\000';
    tmp___0 = strspn((char const   *)(fopt + next_token), " \t\r\n");
    next_token += tmp___0;
    if (! equal) {
      equal = (int )*(fopt + next_token) == 61;
      if (equal) {
        next_token ++;
        tmp___1 = strspn((char const   *)(fopt + next_token), " \t\r\n");
        next_token += tmp___1;
      }
    }
    str_index += next_token;
    farg = str_index;
    if ((int )*(farg + 0) == 34) {
      goto _L;
    } else
    if ((int )*(farg + 0) == 39) {
      _L: /* CIL Label */
      farg ++;
      str_index = strchr((char const   *)farg, (int )*(str_index + 0));
      if (! str_index) {
        __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s:%s:%d: unterminated string in configuration file\n",
                      "zmap", filename, line_num);
        result = 1;
        break;
      }
    } else {
      next_token = strcspn((char const   *)farg, " \t\r\n#\'\"");
      str_index += next_token;
    }
    delimiter = *str_index;
    tmp___2 = str_index;
    str_index ++;
    *tmp___2 = (char )'\000';
    if ((int )delimiter != 0) {
      if ((int )delimiter != 35) {
        tmp___3 = strspn((char const   *)str_index, " \t\r\n");
        str_index += tmp___3;
        if ((int )*str_index != 0) {
          if ((int )*str_index != 35) {
            __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s:%s:%d: malformed string in configuration file\n",
                          "zmap", filename, line_num);
            result = 1;
            break;
          }
        }
      }
    }
    noarg:
    tmp___4 = strcmp((char const   *)fopt, "include");
    if (! tmp___4) {
      if (farg) {
        if (*farg) {
          result = _cmdline_parser_configfile((char const   *)farg, my_argc);
        } else {
          __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s:%s:%d: include requires a filename argument.\n",
                        "zmap", filename, line_num);
        }
      } else {
        __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s:%s:%d: include requires a filename argument.\n",
                      "zmap", filename, line_num);
      }
      continue;
    }
    len = strlen((char const   *)fopt);
    if (len > 1UL) {
      tmp___5 = "--";
    } else {
      tmp___5 = "-";
    }
    strcat((char * __restrict  )(my_argv), (char const   * __restrict  )tmp___5);
    strcat((char * __restrict  )(my_argv), (char const   * __restrict  )fopt);
    if (len > 1UL) {
      if (farg) {
        if (*farg) {
          strcat((char * __restrict  )(my_argv), (char const   * __restrict  )"=");
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */
      if (equal) {
        strcat((char * __restrict  )(my_argv), (char const   * __restrict  )"=");
      }
    }
    if (farg) {
      if (*farg) {
        strcat((char * __restrict  )(my_argv), (char const   * __restrict  )farg);
      }
    }
    (*my_argc) ++;
    tmp___6 = malloc(sizeof(struct line_list ));
    cmd_line_list_tmp = (struct line_list *)tmp___6;
    cmd_line_list_tmp->next = cmd_line_list;
    cmd_line_list = cmd_line_list_tmp;
    cmd_line_list->string_arg = gengetopt_strdup((char const   *)(my_argv));
  }
  if (file___1) {
    fclose(file___1);
  }
  return (result);
}
}
int cmdline_parser_configfile(char const   *filename , struct gengetopt_args_info *args_info ,
                              int override , int initialize , int check_required )
{
  struct cmdline_parser_params params ;
  int tmp ;

  {
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;
  tmp = cmdline_parser_config_file(filename, args_info, & params);
  return (tmp);
}
}
int cmdline_parser_config_file(char const   *filename , struct gengetopt_args_info *args_info ,
                               struct cmdline_parser_params *params )
{
  int i ;
  int result ;
  int my_argc ;
  char **my_argv_arg ;
  char *additional_error ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  my_argc = 1;
  tmp = malloc(sizeof(struct line_list ));
  cmd_line_list_tmp = (struct line_list *)tmp;
  cmd_line_list_tmp->next = cmd_line_list;
  cmd_line_list = cmd_line_list_tmp;
  cmd_line_list->string_arg = gengetopt_strdup("zmap");
  result = _cmdline_parser_configfile(filename, & my_argc);
  if (result != 1) {
    tmp___0 = malloc((unsigned long )(my_argc + 1) * sizeof(char *));
    my_argv_arg = (char **)tmp___0;
    cmd_line_list_tmp = cmd_line_list;
    i = my_argc - 1;
    while (i >= 0) {
      *(my_argv_arg + i) = cmd_line_list_tmp->string_arg;
      cmd_line_list_tmp = cmd_line_list_tmp->next;
      i --;
    }
    *(my_argv_arg + my_argc) = (char *)0;
    tmp___1 = strlen(filename);
    tmp___2 = strlen(" in configuration file ");
    tmp___3 = malloc((tmp___1 + tmp___2) + 1UL);
    additional_error = (char *)tmp___3;
    strcpy((char * __restrict  )additional_error, (char const   * __restrict  )" in configuration file ");
    strcat((char * __restrict  )additional_error, (char const   * __restrict  )filename);
    result = cmdline_parser_internal(my_argc, my_argv_arg, args_info, params, (char const   *)additional_error);
    free((void *)additional_error);
    free((void *)my_argv_arg);
  }
  free_cmd_list();
  if (result == 1) {
    cmdline_parser_free(args_info);
    exit(1);
  }
  return (result);
}
}
#pragma merger("0","/tmp/cil-Keu1mCVq.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) ferror)(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) fileno)(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
int yyleng  ;
FILE *yyin ;
FILE *yyout ;
static size_t yy_buffer_stack_top  =    (size_t )0;
static size_t yy_buffer_stack_max  =    (size_t )0;
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)((void *)0);
static char yy_hold_char  ;
static int yy_n_chars  ;
static char *yy_c_buf_p  =    (char *)((void *)0);
static int yy_init  =    0;
static int yy_start  =    0;
static int yy_did_buffer_switch_on_eof  ;
void yyrestart(FILE *input_file ) ;
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
YY_BUFFER_STATE yy_create_buffer(FILE *file___1 , int size ) ;
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
void yypop_buffer_state(void) ;
static void yyensure_buffer_stack(void) ;
static void yy_load_buffer_state(void) ;
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file___1 ) ;
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
void *yyalloc(yy_size_t size ) ;
void *yyrealloc(void *ptr , yy_size_t size ) ;
void yyfree(void *ptr ) ;
FILE *yyin  =    (FILE *)((void *)0);
FILE *yyout  =    (FILE *)((void *)0);
int yylineno ;
int yylineno  =    1;
char *yytext  ;
static yy_state_type yy_get_previous_state(void) ;
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
static int yy_get_next_buffer(void) ;
static  __attribute__((__noreturn__)) void yy_fatal_error(char const   *msg ) ;
static flex_int16_t const   yy_accept[26]  =
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )16,
        (flex_int16_t const   )15,      (flex_int16_t const   )3,      (flex_int16_t const   )2,      (flex_int16_t const   )15,
        (flex_int16_t const   )15,      (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )1,
        (flex_int16_t const   )11,      (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )15,
        (flex_int16_t const   )15,      (flex_int16_t const   )3,      (flex_int16_t const   )4,      (flex_int16_t const   )7,
        (flex_int16_t const   )1,      (flex_int16_t const   )6,      (flex_int16_t const   )5,      (flex_int16_t const   )14,
        (flex_int16_t const   )8,      (flex_int16_t const   )0};
static YY_CHAR const   yy_ec[256]  =
  {      (YY_CHAR const   )0,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )2,      (YY_CHAR const   )3,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )2,      (YY_CHAR const   )4,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )5,      (YY_CHAR const   )1,
        (YY_CHAR const   )6,      (YY_CHAR const   )7,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )8,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )9,      (YY_CHAR const   )9,      (YY_CHAR const   )9,      (YY_CHAR const   )9,
        (YY_CHAR const   )9,      (YY_CHAR const   )9,      (YY_CHAR const   )9,      (YY_CHAR const   )9,
        (YY_CHAR const   )9,      (YY_CHAR const   )9,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )10,      (YY_CHAR const   )11,      (YY_CHAR const   )12,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,
        (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,
        (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,
        (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,
        (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,
        (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,
        (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )8,
        (YY_CHAR const   )1,      (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,
        (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,
        (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,
        (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,
        (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,
        (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,
        (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )13,      (YY_CHAR const   )1,
        (YY_CHAR const   )14,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1};
static YY_CHAR const   yy_meta[15]  =
  {      (YY_CHAR const   )0,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )2,      (YY_CHAR const   )2,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )2,      (YY_CHAR const   )1};
static flex_int16_t const   yy_base[27]  =
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )25,
        (flex_int16_t const   )26,      (flex_int16_t const   )22,      (flex_int16_t const   )26,      (flex_int16_t const   )12,
        (flex_int16_t const   )17,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )12,
        (flex_int16_t const   )9,      (flex_int16_t const   )26,      (flex_int16_t const   )8,      (flex_int16_t const   )0,
        (flex_int16_t const   )4,      (flex_int16_t const   )15,      (flex_int16_t const   )26,      (flex_int16_t const   )26,
        (flex_int16_t const   )7,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )0,
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )13};
static flex_int16_t const   yy_def[27]  =
  {      (flex_int16_t const   )0,      (flex_int16_t const   )25,      (flex_int16_t const   )1,      (flex_int16_t const   )25,
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )26,
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )26,
        (flex_int16_t const   )25,      (flex_int16_t const   )0,      (flex_int16_t const   )25};
static flex_int16_t const   yy_nxt[41]  =
  {      (flex_int16_t const   )0,      (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6,
        (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )9,      (flex_int16_t const   )10,
        (flex_int16_t const   )4,      (flex_int16_t const   )11,      (flex_int16_t const   )12,      (flex_int16_t const   )13,
        (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )23,
        (flex_int16_t const   )20,      (flex_int16_t const   )17,      (flex_int16_t const   )24,      (flex_int16_t const   )22,
        (flex_int16_t const   )21,      (flex_int16_t const   )20,      (flex_int16_t const   )19,      (flex_int16_t const   )18,
        (flex_int16_t const   )17,      (flex_int16_t const   )25,      (flex_int16_t const   )3,      (flex_int16_t const   )25,
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,
        (flex_int16_t const   )25};
static flex_int16_t const   yy_chk[41]  =
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )26,
        (flex_int16_t const   )20,      (flex_int16_t const   )17,      (flex_int16_t const   )16,      (flex_int16_t const   )14,
        (flex_int16_t const   )12,      (flex_int16_t const   )11,      (flex_int16_t const   )8,      (flex_int16_t const   )7,
        (flex_int16_t const   )5,      (flex_int16_t const   )3,      (flex_int16_t const   )25,      (flex_int16_t const   )25,
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,
        (flex_int16_t const   )25};
static yy_state_type yy_last_accepting_state  ;
static char *yy_last_accepting_cpos  ;
int yy_flex_debug ;
int yy_flex_debug  =    0;
#pragma GCC diagnostic ignored "-Wredundant-decls"
#pragma GCC diagnostic ignored "-Wmissing-noreturn"
YYSTYPE yylval ;
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
static int yy_init_globals(void) ;
int yylex_destroy(void) ;
int yyget_debug(void) ;
void yyset_debug(int _bdebug ) ;
FILE *yyget_in(void) ;
void yyset_in(FILE *_in_str ) ;
FILE *yyget_out(void) ;
void yyset_out(FILE *_out_str ) ;
int yyget_leng(void) ;
char *yyget_text(void) ;
int yyget_lineno(void) ;
void yyset_lineno(int _line_number ) ;
int yywrap(void) ;
int yylex(void) ;
int yylex(void)
{
  yy_state_type yy_current_state ;
  char *yy_cp ;
  char *yy_bp ;
  int yy_act ;
  YY_BUFFER_STATE tmp ;
  YY_CHAR yy_c ;
  long long tmp___0 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! yy_init) {
    yy_init = 1;
    if (! yy_start) {
      yy_start = 1;
    }
    if (! yyin) {
      yyin = stdin;
    }
    if (! yyout) {
      yyout = stdout;
    }
    if (yy_buffer_stack) {
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    if (! tmp) {
      yyensure_buffer_stack();
      *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
    }
    yy_load_buffer_state();
  }
  while (1) {
    yy_cp = yy_c_buf_p;
    *yy_cp = yy_hold_char;
    yy_bp = yy_cp;
    yy_current_state = yy_start;
    yy_match:
    while (1) {
      yy_c = (YY_CHAR )yy_ec[(YY_CHAR )*yy_cp];
      if (yy_accept[yy_current_state]) {
        yy_last_accepting_state = yy_current_state;
        yy_last_accepting_cpos = yy_cp;
      }
      while ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
        yy_current_state = (int )yy_def[yy_current_state];
        if (yy_current_state >= 26) {
          yy_c = (YY_CHAR )yy_meta[yy_c];
        }
      }
      yy_current_state = (yy_state_type )yy_nxt[(int const   )yy_base[yy_current_state] + (int const   )yy_c];
      yy_cp ++;
      if (! ((int const   )yy_base[yy_current_state] != 26)) {
        break;
      }
    }
    yy_find_action:
    yy_act = (int )yy_accept[yy_current_state];
    if (yy_act == 0) {
      yy_cp = yy_last_accepting_cpos;
      yy_current_state = yy_last_accepting_state;
      yy_act = (int )yy_accept[yy_current_state];
    }
    yytext = yy_bp;
    yyleng = (int )(yy_cp - yy_bp);
    yy_hold_char = *yy_cp;
    *yy_cp = (char )'\000';
    yy_c_buf_p = yy_cp;
    do_action:
    switch (yy_act) {
    case 0:
    *yy_cp = yy_hold_char;
    yy_cp = yy_last_accepting_cpos;
    yy_current_state = yy_last_accepting_state;
    goto yy_find_action;
    case 1:
    tmp___0 = atoll((char const   *)yytext);
    yylval.int_literal = (int )((uint64_t )tmp___0);
    return (259);
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    return (261);
    break;
    case 5:
    return (262);
    break;
    case 6:
    return (263);
    break;
    case 7:
    return (257);
    break;
    case 8:
    return (258);
    break;
    case 9:
    return ('=');
    break;
    case 10:
    return ('>');
    break;
    case 11:
    return ('<');
    break;
    case 12:
    return ('(');
    break;
    case 13:
    return (')');
    break;
    case 14:
    yylval.string_literal = strdup((char const   *)yytext);
    return (260);
    break;
    case 15:
    while (1) {
      fwrite((void const   * __restrict  )yytext, (size_t )yyleng, (size_t )1, (FILE * __restrict  )yyout);
      break;
    }
    break;
    case 17:
    return (0);
    case 16:
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
    *yy_cp = yy_hold_char;
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = yyin;
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
      yy_current_state = yy_get_previous_state();
      yy_next_state = yy_try_NUL_trans(yy_current_state);
      yy_bp = yytext + 0;
      if (yy_next_state) {
        yy_c_buf_p ++;
        yy_cp = yy_c_buf_p;
        yy_current_state = yy_next_state;
        goto yy_match;
      } else {
        yy_cp = yy_c_buf_p;
        goto yy_find_action;
      }
    } else {
      tmp___1 = yy_get_next_buffer();
      switch (tmp___1) {
      case 1:
      yy_did_buffer_switch_on_eof = 0;
      tmp___2 = yywrap();
      if (tmp___2) {
        yy_c_buf_p = yytext + 0;
        yy_act = (16 + (yy_start - 1) / 2) + 1;
        goto do_action;
      } else
      if (! yy_did_buffer_switch_on_eof) {
        yyrestart(yyin);
      }
      break;
      case 0:
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
      yy_current_state = yy_get_previous_state();
      yy_cp = yy_c_buf_p;
      yy_bp = yytext + 0;
      goto yy_match;
      case 2:
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
      yy_current_state = yy_get_previous_state();
      yy_cp = yy_c_buf_p;
      yy_bp = yytext + 0;
      goto yy_find_action;
      }
    }
    break;
    default:
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
  }
}
}
static int yy_get_next_buffer(void)
{
  char *dest ;
  char *source ;
  int number_to_move ;
  int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___1 ;
  int c ;
  int n ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int new_size___0 ;
  void *tmp___9 ;

  {
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
  source = yytext;
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
  }
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
    if (yy_c_buf_p - yytext == 1L) {
      return (1);
    } else {
      return (2);
    }
  }
  number_to_move = (int )((yy_c_buf_p - yytext) - 1L);
  i = 0;
  while (i < number_to_move) {
    tmp = dest;
    dest ++;
    tmp___0 = source;
    source ++;
    *tmp = *tmp___0;
    i ++;
  }
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
    yy_n_chars = 0;
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
    num_to_read = ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - number_to_move) - 1;
    while (num_to_read <= 0) {
      b = *(yy_buffer_stack + yy_buffer_stack_top);
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
      if (b->yy_is_our_buffer) {
        new_size = b->yy_buf_size * 2;
        if (new_size <= 0) {
          b->yy_buf_size += b->yy_buf_size / 8;
        } else {
          b->yy_buf_size *= 2;
        }
        tmp___1 = yyrealloc((void *)b->yy_ch_buf, (yy_size_t )(b->yy_buf_size + 2));
        b->yy_ch_buf = (char *)tmp___1;
      } else {
        b->yy_ch_buf = (char *)((void *)0);
      }
      if (! b->yy_ch_buf) {
        yy_fatal_error("fatal error - scanner input buffer overflow");
      }
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
      num_to_read = ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - number_to_move) - 1;
    }
    if (num_to_read > 8192) {
      num_to_read = 8192;
    }
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
      c = '*';
      n = 0;
      while (1) {
        if (n < num_to_read) {
          c = getc(yyin);
          if (c != -1) {
            if (! (c != 10)) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
        n ++;
      }
      if (c == 10) {
        tmp___2 = n;
        n ++;
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___2) = (char )c;
      }
      if (c == -1) {
        tmp___3 = ferror(yyin);
        if (tmp___3) {
          yy_fatal_error("input in flex scanner failed");
        }
      }
      yy_n_chars = n;
    } else {
      tmp___4 = __errno_location();
      *tmp___4 = 0;
      while (1) {
        tmp___7 = fread((void * __restrict  )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (yy_size_t )num_to_read, (FILE * __restrict  )yyin);
        yy_n_chars = (int )tmp___7;
        if (yy_n_chars == 0) {
          tmp___8 = ferror(yyin);
          if (! tmp___8) {
            break;
          }
        } else {
          break;
        }
        tmp___5 = __errno_location();
        if (*tmp___5 != 4) {
          yy_fatal_error("input in flex scanner failed");
          break;
        }
        tmp___6 = __errno_location();
        *tmp___6 = 0;
        clearerr(yyin);
      }
    }
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  if (yy_n_chars == 0) {
    if (number_to_move == 0) {
      ret_val = 1;
      yyrestart(yyin);
    } else {
      ret_val = 2;
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
    ret_val = 0;
  }
  if (yy_n_chars + number_to_move > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size) {
    new_size___0 = (yy_n_chars + number_to_move) + (yy_n_chars >> 1);
    tmp___9 = yyrealloc((void *)(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf,
                        (yy_size_t )new_size___0);
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___9;
    if (! (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf) {
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()");
    }
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size = new_size___0 - 2;
  }
  yy_n_chars += number_to_move;
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
  yytext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
  return (ret_val);
}
}
static yy_state_type yy_get_previous_state(void)
{
  yy_state_type yy_current_state ;
  char *yy_cp ;
  YY_CHAR yy_c ;
  int tmp ;

  {
  yy_current_state = yy_start;
  yy_cp = yytext + 0;
  while ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p) {
    if (*yy_cp) {
      tmp = (int const   )yy_ec[(YY_CHAR )*yy_cp];
    } else {
      tmp = (int const   )1;
    }
    yy_c = (YY_CHAR )tmp;
    if (yy_accept[yy_current_state]) {
      yy_last_accepting_state = yy_current_state;
      yy_last_accepting_cpos = yy_cp;
    }
    while ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
      yy_current_state = (int )yy_def[yy_current_state];
      if (yy_current_state >= 26) {
        yy_c = (YY_CHAR )yy_meta[yy_c];
      }
    }
    yy_current_state = (yy_state_type )yy_nxt[(int const   )yy_base[yy_current_state] + (int const   )yy_c];
    yy_cp ++;
  }
  return (yy_current_state);
}
}
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state )
{
  int yy_is_jam ;
  char *yy_cp ;
  YY_CHAR yy_c ;
  int tmp ;

  {
  yy_cp = yy_c_buf_p;
  yy_c = (YY_CHAR )1;
  if (yy_accept[yy_current_state]) {
    yy_last_accepting_state = yy_current_state;
    yy_last_accepting_cpos = yy_cp;
  }
  while ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
    yy_current_state = (int )yy_def[yy_current_state];
    if (yy_current_state >= 26) {
      yy_c = (YY_CHAR )yy_meta[yy_c];
    }
  }
  yy_current_state = (yy_state_type )yy_nxt[(int const   )yy_base[yy_current_state] + (int const   )yy_c];
  yy_is_jam = yy_current_state == 25;
  if (yy_is_jam) {
    tmp = 0;
  } else {
    tmp = yy_current_state;
  }
  return (tmp);
}
}
void yyrestart(FILE *input_file )
{
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  if (yy_buffer_stack) {
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  if (! tmp) {
    yyensure_buffer_stack();
    *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
  }
  if (yy_buffer_stack) {
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  yy_init_buffer(tmp___0, input_file);
  yy_load_buffer_state();
  return;
}
}
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer )
{
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  yyensure_buffer_stack();
  if (yy_buffer_stack) {
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
    return;
  }
  if (yy_buffer_stack) {
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  if (tmp___0) {
    *yy_c_buf_p = yy_hold_char;
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
  yy_load_buffer_state();
  yy_did_buffer_switch_on_eof = 1;
  return;
}
}
static void yy_load_buffer_state(void)
{


  {
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
  yytext = yy_c_buf_p;
  yyin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
  yy_hold_char = *yy_c_buf_p;
  return;
}
}
YY_BUFFER_STATE yy_create_buffer(FILE *file___1 , int size )
{
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = yyalloc(sizeof(struct yy_buffer_state ));
  b = (YY_BUFFER_STATE )tmp;
  if (! b) {
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
  }
  b->yy_buf_size = size;
  tmp___0 = yyalloc((yy_size_t )(b->yy_buf_size + 2));
  b->yy_ch_buf = (char *)tmp___0;
  if (! b->yy_ch_buf) {
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
  }
  b->yy_is_our_buffer = 1;
  yy_init_buffer(b, file___1);
  return (b);
}
}
void yy_delete_buffer(YY_BUFFER_STATE b )
{
  YY_BUFFER_STATE tmp ;

  {
  if (! b) {
    return;
  }
  if (yy_buffer_stack) {
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  if ((unsigned long )b == (unsigned long )tmp) {
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
  if (b->yy_is_our_buffer) {
    yyfree((void *)b->yy_ch_buf);
  }
  yyfree((void *)b);
  return;
}
}
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file___1 )
{
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  tmp = __errno_location();
  oerrno = *tmp;
  yy_flush_buffer(b);
  b->yy_input_file = file___1;
  b->yy_fill_buffer = 1;
  if (yy_buffer_stack) {
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  if ((unsigned long )b != (unsigned long )tmp___0) {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }
  if (file___1) {
    tmp___1 = fileno(file___1);
    tmp___2 = isatty(tmp___1);
    b->yy_is_interactive = tmp___2 > 0;
  } else {
    b->yy_is_interactive = 0;
  }
  tmp___3 = __errno_location();
  *tmp___3 = oerrno;
  return;
}
}
void yy_flush_buffer(YY_BUFFER_STATE b )
{
  YY_BUFFER_STATE tmp ;

  {
  if (! b) {
    return;
  }
  b->yy_n_chars = 0;
  *(b->yy_ch_buf + 0) = (char)0;
  *(b->yy_ch_buf + 1) = (char)0;
  b->yy_buf_pos = b->yy_ch_buf + 0;
  b->yy_at_bol = 1;
  b->yy_buffer_status = 0;
  if (yy_buffer_stack) {
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  if ((unsigned long )b == (unsigned long )tmp) {
    yy_load_buffer_state();
  }
  return;
}
}
void yypush_buffer_state(YY_BUFFER_STATE new_buffer )
{
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
    return;
  }
  yyensure_buffer_stack();
  if (yy_buffer_stack) {
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  if (tmp) {
    *yy_c_buf_p = yy_hold_char;
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  if (yy_buffer_stack) {
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  if (tmp___0) {
    yy_buffer_stack_top ++;
  }
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
  yy_load_buffer_state();
  yy_did_buffer_switch_on_eof = 1;
  return;
}
}
void yypop_buffer_state(void)
{
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
  if (yy_buffer_stack) {
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  if (! tmp) {
    return;
  }
  if (yy_buffer_stack) {
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  yy_delete_buffer(tmp___0);
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  if (yy_buffer_stack_top > 0UL) {
    yy_buffer_stack_top --;
  }
  if (yy_buffer_stack) {
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
  if (tmp___1) {
    yy_load_buffer_state();
    yy_did_buffer_switch_on_eof = 1;
  }
  return;
}
}
static void yyensure_buffer_stack(void)
{
  yy_size_t num_to_alloc ;
  void *tmp ;
  yy_size_t grow_size ;
  void *tmp___0 ;

  {
  if (! yy_buffer_stack) {
    num_to_alloc = (yy_size_t )1;
    tmp = yyalloc(num_to_alloc * sizeof(struct yy_buffer_state *));
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
    if (! yy_buffer_stack) {
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()");
    }
    memset((void *)yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state *));
    yy_buffer_stack_max = num_to_alloc;
    yy_buffer_stack_top = (size_t )0;
    return;
  }
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    grow_size = (yy_size_t )8;
    num_to_alloc = yy_buffer_stack_max + grow_size;
    tmp___0 = yyrealloc((void *)yy_buffer_stack, num_to_alloc * sizeof(struct yy_buffer_state *));
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    if (! yy_buffer_stack) {
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()");
    }
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state *));
    yy_buffer_stack_max = num_to_alloc;
  }
  return;
}
}
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size )
{
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
  if (size < 2UL) {
    return ((YY_BUFFER_STATE )((void *)0));
  } else
  if ((int )*(base + (size - 2UL)) != 0) {
    return ((YY_BUFFER_STATE )((void *)0));
  } else
  if ((int )*(base + (size - 1UL)) != 0) {
    return ((YY_BUFFER_STATE )((void *)0));
  }
  tmp = yyalloc(sizeof(struct yy_buffer_state ));
  b = (YY_BUFFER_STATE )tmp;
  if (! b) {
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
  }
  b->yy_buf_size = (int )(size - 2UL);
  tmp___0 = base;
  b->yy_ch_buf = tmp___0;
  b->yy_buf_pos = tmp___0;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = (FILE *)((void *)0);
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = 0;
  yy_switch_to_buffer(b);
  return (b);
}
}
YY_BUFFER_STATE yy_scan_string(char const   *yystr )
{
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  tmp = strlen(yystr);
  tmp___0 = yy_scan_bytes(yystr, (int )tmp);
  return (tmp___0);
}
}
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len )
{
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  n = (yy_size_t )(_yybytes_len + 2);
  tmp = yyalloc(n);
  buf = (char *)tmp;
  if (! buf) {
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
  }
  i = 0;
  while (i < _yybytes_len) {
    *(buf + i) = (char )*(yybytes + i);
    i ++;
  }
  tmp___0 = (char)0;
  *(buf + (_yybytes_len + 1)) = tmp___0;
  *(buf + _yybytes_len) = tmp___0;
  b = yy_scan_buffer(buf, n);
  if (! b) {
    yy_fatal_error("bad buffer in yy_scan_bytes()");
  }
  b->yy_is_our_buffer = 1;
  return (b);
}
}
static  __attribute__((__noreturn__)) void yy_fatal_error(char const   *msg ) ;
static void yy_fatal_error(char const   *msg )
{


  {
  __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s\n",
                msg);
  exit(2);
}
}
int yyget_lineno(void)
{


  {
  return (yylineno);
}
}
FILE *yyget_in(void)
{


  {
  return (yyin);
}
}
FILE *yyget_out(void)
{


  {
  return (yyout);
}
}
int yyget_leng(void)
{


  {
  return (yyleng);
}
}
char *yyget_text(void)
{


  {
  return (yytext);
}
}
void yyset_lineno(int _line_number )
{


  {
  yylineno = _line_number;
  return;
}
}
void yyset_in(FILE *_in_str )
{


  {
  yyin = _in_str;
  return;
}
}
void yyset_out(FILE *_out_str )
{


  {
  yyout = _out_str;
  return;
}
}
int yyget_debug(void)
{


  {
  return (yy_flex_debug);
}
}
void yyset_debug(int _bdebug )
{


  {
  yy_flex_debug = _bdebug;
  return;
}
}
static int yy_init_globals(void)
{


  {
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
  yy_buffer_stack_top = (size_t )0;
  yy_buffer_stack_max = (size_t )0;
  yy_c_buf_p = (char *)((void *)0);
  yy_init = 0;
  yy_start = 0;
  yyin = (FILE *)((void *)0);
  yyout = (FILE *)((void *)0);
  return (0);
}
}
int yylex_destroy(void)
{
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  while (1) {
    if (yy_buffer_stack) {
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
    if (! tmp___0) {
      break;
    }
    if (yy_buffer_stack) {
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    yy_delete_buffer(tmp);
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
    yypop_buffer_state();
  }
  yyfree((void *)yy_buffer_stack);
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
  yy_init_globals();
  return (0);
}
}
void *yyalloc(yy_size_t size )
{
  void *tmp ;

  {
  tmp = malloc(size);
  return (tmp);
}
}
void *yyrealloc(void *ptr , yy_size_t size )
{
  void *tmp ;

  {
  tmp = realloc(ptr, size);
  return (tmp);
}
}
void yyfree(void *ptr )
{


  {
  free((void *)((char *)ptr));
  return;
}
}
#pragma merger("0","/tmp/cil-gRO6ACsF.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
void yyerror(char const   *str )
{


  {
  __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"Parse error: %s\n",
                str);
  return;
}
}
int yywrap(void)
{


  {
  return (1);
}
}
static YYINT const   yylhs[16]  =
  {      (YYINT const   )-1,      (YYINT const   )0,      (YYINT const   )4,      (YYINT const   )4,
        (YYINT const   )4,      (YYINT const   )4,      (YYINT const   )1,      (YYINT const   )1,
        (YYINT const   )2,      (YYINT const   )2,      (YYINT const   )2,      (YYINT const   )2,
        (YYINT const   )2,      (YYINT const   )2,      (YYINT const   )3,      (YYINT const   )3};
static YYINT const   yylen[16]  =
  {      (YYINT const   )2,      (YYINT const   )1,      (YYINT const   )3,      (YYINT const   )3,
        (YYINT const   )3,      (YYINT const   )1,      (YYINT const   )1,      (YYINT const   )1,
        (YYINT const   )3,      (YYINT const   )3,      (YYINT const   )3,      (YYINT const   )3,
        (YYINT const   )3,      (YYINT const   )3,      (YYINT const   )3,      (YYINT const   )3};
static YYINT const   yydefred[28]  =
  {      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )5,      (YYINT const   )6,      (YYINT const   )7,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )4,      (YYINT const   )11,      (YYINT const   )15,
        (YYINT const   )12,      (YYINT const   )9,      (YYINT const   )10,      (YYINT const   )8,
        (YYINT const   )14,      (YYINT const   )13,      (YYINT const   )3,      (YYINT const   )0};
static YYINT const   yydgoto[5]  = {      (YYINT const   )3,      (YYINT const   )4,      (YYINT const   )5,      (YYINT const   )6,
        (YYINT const   )7};
static YYINT const   yysindex[28]  =
  {      (YYINT const   )-40,      (YYINT const   )-40,      (YYINT const   )-57,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )-250,
        (YYINT const   )-39,      (YYINT const   )-249,      (YYINT const   )-245,      (YYINT const   )-244,
        (YYINT const   )-243,      (YYINT const   )-247,      (YYINT const   )-242,      (YYINT const   )-40,
        (YYINT const   )-40,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )-248};
static YYINT const   yyrindex[28]  =
  {      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )18,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )1};
static YYINT const   yygindex[5]  = {      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )5};
static YYINT const   yytable[260]  =
  {      (YYINT const   )1,      (YYINT const   )2,      (YYINT const   )17,      (YYINT const   )12,
        (YYINT const   )13,      (YYINT const   )11,      (YYINT const   )8,      (YYINT const   )15,
        (YYINT const   )16,      (YYINT const   )15,      (YYINT const   )18,      (YYINT const   )19,
        (YYINT const   )23,      (YYINT const   )24,      (YYINT const   )20,      (YYINT const   )21,
        (YYINT const   )22,      (YYINT const   )25,      (YYINT const   )1,      (YYINT const   )0,
        (YYINT const   )26,      (YYINT const   )27,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )2,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )9,      (YYINT const   )10,      (YYINT const   )14,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )15,      (YYINT const   )16,
        (YYINT const   )2,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,
        (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )0,      (YYINT const   )2};
static YYINT const   yycheck[260]  =
  {      (YYINT const   )40,      (YYINT const   )0,      (YYINT const   )41,      (YYINT const   )60,
        (YYINT const   )61,      (YYINT const   )62,      (YYINT const   )1,      (YYINT const   )257,
        (YYINT const   )258,      (YYINT const   )257,      (YYINT const   )259,      (YYINT const   )260,
        (YYINT const   )259,      (YYINT const   )260,      (YYINT const   )259,      (YYINT const   )259,
        (YYINT const   )259,      (YYINT const   )259,      (YYINT const   )0,      (YYINT const   )-1,
        (YYINT const   )15,      (YYINT const   )16,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )41,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )261,      (YYINT const   )262,      (YYINT const   )263,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )257,      (YYINT const   )258,
        (YYINT const   )260,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,
        (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )-1,      (YYINT const   )258};
int yydebug  ;
int yynerrs  ;
int yyerrflag  ;
int yychar  ;
YYSTYPE yyval  ;
YYSTYPE yylval  ;
static YYSTACKDATA yystack  ;
static int yygrowstack(YYSTACKDATA *data )
{
  int i ;
  unsigned int newsize ;
  YYINT *newss ;
  YYSTYPE *newvs ;
  void *tmp ;
  void *tmp___0 ;

  {
  newsize = data->stacksize;
  if (newsize == 0U) {
    newsize = 200U;
  } else
  if (newsize >= 10000U) {
    return (-2);
  } else {
    newsize *= 2U;
    if (newsize > 10000U) {
      newsize = 10000U;
    }
  }
  i = (int )(data->s_mark - data->s_base);
  tmp = realloc((void *)data->s_base, (unsigned long )newsize * sizeof(*newss));
  newss = (YYINT *)tmp;
  if ((unsigned long )newss == (unsigned long )((YYINT *)0)) {
    return (-2);
  }
  data->s_base = newss;
  data->s_mark = newss + i;
  tmp___0 = realloc((void *)data->l_base, (unsigned long )newsize * sizeof(*newvs));
  newvs = (YYSTYPE *)tmp___0;
  if ((unsigned long )newvs == (unsigned long )((YYSTYPE *)0)) {
    return (-2);
  }
  data->l_base = newvs;
  data->l_mark = newvs + i;
  data->stacksize = newsize;
  data->s_last = (data->s_base + newsize) - 1;
  return (0);
}
}
int yyparse(void)
{
  int yym ;
  int yyn ;
  int yystate ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  yynerrs = 0;
  yyerrflag = 0;
  yychar = -1;
  yystate = 0;
  if ((unsigned long )yystack.s_base == (unsigned long )((void *)0)) {
    tmp = yygrowstack(& yystack);
    if (tmp == -2) {
      goto yyoverflow;
    }
  }
  yystack.s_mark = yystack.s_base;
  yystack.l_mark = yystack.l_base;
  yystate = 0;
  *(yystack.s_mark) = (YYINT )0;
  yyloop:
  yyn = (int )yydefred[yystate];
  if (yyn != 0) {
    goto yyreduce;
  }
  if (yychar < 0) {
    yychar = yylex();
    if (yychar < 0) {
      yychar = 0;
    }
  }
  yyn = (int )yysindex[yystate];
  if (yyn) {
    yyn += yychar;
    if (yyn >= 0) {
      if (yyn <= 259) {
        if ((int const   )yycheck[yyn] == (int const   )yychar) {
          if ((unsigned long )yystack.s_mark >= (unsigned long )yystack.s_last) {
            tmp___0 = yygrowstack(& yystack);
            if (tmp___0 == -2) {
              goto yyoverflow;
            }
          }
          yystate = (int )yytable[yyn];
          (yystack.s_mark) ++;
          *(yystack.s_mark) = (YYINT )yytable[yyn];
          (yystack.l_mark) ++;
          *(yystack.l_mark) = yylval;
          yychar = -1;
          if (yyerrflag > 0) {
            yyerrflag --;
          }
          goto yyloop;
        }
      }
    }
  }
  yyn = (int )yyrindex[yystate];
  if (yyn) {
    yyn += yychar;
    if (yyn >= 0) {
      if (yyn <= 259) {
        if ((int const   )yycheck[yyn] == (int const   )yychar) {
          yyn = (int )yytable[yyn];
          goto yyreduce;
        }
      }
    }
  }
  if (yyerrflag) {
    goto yyinrecovery;
  }
  yyerror("syntax error");
  goto yyerrlab;
  yyerrlab:
  yynerrs ++;
  yyinrecovery:
  if (yyerrflag < 3) {
    yyerrflag = 3;
    while (1) {
      yyn = (int )yysindex[*(yystack.s_mark)];
      if (yyn) {
        yyn += 256;
        if (yyn >= 0) {
          if (yyn <= 259) {
            if ((int const   )yycheck[yyn] == 256) {
              if ((unsigned long )yystack.s_mark >= (unsigned long )yystack.s_last) {
                tmp___1 = yygrowstack(& yystack);
                if (tmp___1 == -2) {
                  goto yyoverflow;
                }
              }
              yystate = (int )yytable[yyn];
              (yystack.s_mark) ++;
              *(yystack.s_mark) = (YYINT )yytable[yyn];
              (yystack.l_mark) ++;
              *(yystack.l_mark) = yylval;
              goto yyloop;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */
        if ((unsigned long )yystack.s_mark <= (unsigned long )yystack.s_base) {
          goto yyabort;
        }
        (yystack.s_mark) --;
        (yystack.l_mark) --;
      }
    }
  } else {
    if (yychar == 0) {
      goto yyabort;
    }
    yychar = -1;
    goto yyloop;
  }
  yyreduce:
  yym = (int )yylen[yyn];
  if (yym) {
    yyval = *(yystack.l_mark + (1 - yym));
  } else {
    memset((void *)(& yyval), 0, sizeof(yyval));
  }
  switch (yyn) {
  case 1:
  zfilter = (yystack.l_mark + 0)->expr;
  break;
  case 2:
  yyval.expr = make_op_node((enum operation )5);
  (yyval.expr)->left_child = (yystack.l_mark + -2)->expr;
  (yyval.expr)->right_child = (yystack.l_mark + 0)->expr;
  break;
  case 3:
  yyval.expr = make_op_node((enum operation )4);
  (yyval.expr)->left_child = (yystack.l_mark + -2)->expr;
  (yyval.expr)->right_child = (yystack.l_mark + 0)->expr;
  break;
  case 4:
  yyval.expr = (yystack.l_mark + -1)->expr;
  break;
  case 5:
  yyval.expr = (yystack.l_mark + 0)->expr;
  break;
  case 6:
  yyval.expr = (yystack.l_mark + 0)->expr;
  break;
  case 7:
  yyval.expr = (yystack.l_mark + 0)->expr;
  break;
  case 8:
  yyval.expr = make_op_node((enum operation )2);
  (yyval.expr)->left_child = make_field_node((yystack.l_mark + -2)->string_literal);
  (yyval.expr)->right_child = make_int_node((yystack.l_mark + 0)->int_literal);
  break;
  case 9:
  yyval.expr = make_op_node((enum operation )0);
  (yyval.expr)->left_child = make_field_node((yystack.l_mark + -2)->string_literal);
  (yyval.expr)->right_child = make_int_node((yystack.l_mark + 0)->int_literal);
  break;
  case 10:
  yyval.expr = make_op_node((enum operation )1);
  (yyval.expr)->left_child = make_field_node((yystack.l_mark + -2)->string_literal);
  (yyval.expr)->right_child = make_int_node((yystack.l_mark + 0)->int_literal);
  break;
  case 11:
  yyval.expr = make_op_node((enum operation )3);
  (yyval.expr)->left_child = make_field_node((yystack.l_mark + -2)->string_literal);
  (yyval.expr)->right_child = make_int_node((yystack.l_mark + 0)->int_literal);
  break;
  case 12:
  yyval.expr = make_op_node((enum operation )7);
  (yyval.expr)->left_child = make_field_node((yystack.l_mark + -2)->string_literal);
  (yyval.expr)->right_child = make_int_node((yystack.l_mark + 0)->int_literal);
  break;
  case 13:
  yyval.expr = make_op_node((enum operation )6);
  (yyval.expr)->left_child = make_field_node((yystack.l_mark + -2)->string_literal);
  (yyval.expr)->right_child = make_int_node((yystack.l_mark + 0)->int_literal);
  break;
  case 14:
  yyval.expr = make_op_node((enum operation )2);
  (yyval.expr)->left_child = make_field_node((yystack.l_mark + -2)->string_literal);
  (yyval.expr)->right_child = make_string_node((yystack.l_mark + 0)->string_literal);
  break;
  case 15:
  yyval.expr = make_op_node((enum operation )3);
  (yyval.expr)->left_child = make_field_node((yystack.l_mark + -2)->string_literal);
  (yyval.expr)->right_child = make_string_node((yystack.l_mark + 0)->string_literal);
  break;
  }
  yystack.s_mark -= yym;
  yystate = (int )*(yystack.s_mark);
  yystack.l_mark -= yym;
  yym = (int )yylhs[yyn];
  if (yystate == 0) {
    if (yym == 0) {
      yystate = 3;
      (yystack.s_mark) ++;
      *(yystack.s_mark) = (YYINT )3;
      (yystack.l_mark) ++;
      *(yystack.l_mark) = yyval;
      if (yychar < 0) {
        yychar = yylex();
        if (yychar < 0) {
          yychar = 0;
        }
      }
      if (yychar == 0) {
        goto yyaccept;
      }
      goto yyloop;
    }
  }
  yyn = (int )yygindex[yym];
  if (yyn) {
    yyn += yystate;
    if (yyn >= 0) {
      if (yyn <= 259) {
        if ((int const   )yycheck[yyn] == (int const   )yystate) {
          yystate = (int )yytable[yyn];
        } else {
          yystate = (int )yydgoto[yym];
        }
      } else {
        yystate = (int )yydgoto[yym];
      }
    } else {
      yystate = (int )yydgoto[yym];
    }
  } else {
    yystate = (int )yydgoto[yym];
  }
  if ((unsigned long )yystack.s_mark >= (unsigned long )yystack.s_last) {
    tmp___2 = yygrowstack(& yystack);
    if (tmp___2 == -2) {
      goto yyoverflow;
    }
  }
  (yystack.s_mark) ++;
  *(yystack.s_mark) = (YYINT )yystate;
  (yystack.l_mark) ++;
  *(yystack.l_mark) = yyval;
  goto yyloop;
  yyoverflow:
  yyerror("yacc stack overflow");
  yyabort: ;
  return (1);
  yyaccept: ;
  return (0);
}
}
#pragma merger("0","/tmp/cil-ce4AH_OU.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern long ( __attribute__((__warn_unused_result__)) ftell)(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
void make_eth_header(struct ether_header *ethh , macaddr_t *src , macaddr_t *dst ) ;
void make_ip_header(struct ip *iph , uint8_t protocol , uint16_t len ) ;
void make_icmp_header(struct icmp *buf ) ;
void fprintf_ip_header(FILE *fp , struct ip *iph ) ;
void fprintf_eth_header(FILE *fp , struct ether_header *ethh ) ;
__inline static unsigned short in_checksum(unsigned short *ip_pkt , int len )
{
  unsigned long sum ;
  int nwords ;
  unsigned short *tmp ;

  {
  sum = 0UL;
  nwords = len / 2;
  while (nwords > 0) {
    tmp = ip_pkt;
    ip_pkt ++;
    sum += (unsigned long )*tmp;
    nwords --;
  }
  if (len % 2 == 1) {
    sum += (unsigned long )*((unsigned char *)ip_pkt);
  }
  sum = (sum >> 16) + (sum & 65535UL);
  return ((unsigned short )(~ sum));
}
}
__inline static unsigned short zmap_ip_checksum(unsigned short *buf )
{
  unsigned short tmp ;

  {
  tmp = in_checksum(buf, (int )sizeof(struct ip ));
  return (tmp);
}
}
__inline static unsigned short icmp_checksum(unsigned short *buf , size_t buflen )
{
  unsigned short tmp ;

  {
  tmp = in_checksum(buf, (int )buflen);
  return (tmp);
}
}
__inline static struct icmp *get_icmp_header(struct ip  const  *ip_hdr , uint32_t len )
{


  {
  if ((unsigned long )(4U * ip_hdr->ip_hl) + sizeof(struct icmp ) > (unsigned long )len) {
    return ((struct icmp *)((void *)0));
  }
  return ((struct icmp *)((char *)ip_hdr + 4U * ip_hdr->ip_hl));
}
}
int icmp_helper_validate(struct ip  const  *ip_hdr , uint32_t len , size_t min_l4_len ,
                         struct ip **probe_pkt , size_t *probe_len ) ;
probe_module_t module_icmp_echo ;
char const   *icmp_usage_error  =    "unknown ICMP probe specification (expected file:/path or text:STRING or hex:01020304)";
static size_t icmp_payload_len  =    (size_t )0;
static unsigned long const   icmp_payload_default_len  =    (size_t const   )20;
static char *icmp_payload  =    (char *)((void *)0);
int icmp_global_initialize(struct state_conf *conf )
{
  void *tmp ;
  size_t tmp___0 ;
  char *c ;
  char *tmp___1 ;
  FILE *inp ;
  FILE *tmp___2 ;
  int tmp___3 ;
  size_t input_size ;
  long tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  unsigned int n ;
  size_t i ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  if (conf->probe_args) {
    tmp___0 = strlen((char const   *)conf->probe_args);
    if (! (tmp___0 > 0UL)) {
      tmp = xmalloc((size_t )icmp_payload_default_len);
      icmp_payload = (char *)tmp;
      icmp_payload_len = (size_t )icmp_payload_default_len;
      return (0);
    }
  } else {
    tmp = xmalloc((size_t )icmp_payload_default_len);
    icmp_payload = (char *)tmp;
    icmp_payload_len = (size_t )icmp_payload_default_len;
    return (0);
  }
  tmp___1 = strchr((char const   *)conf->probe_args, ':');
  c = tmp___1;
  if (! c) {
    log_error("icmp", icmp_usage_error);
    return (1);
  }
  c ++;
  tmp___13 = strncmp((char const   *)conf->probe_args, "text", (size_t )4);
  if (tmp___13 == 0) {
    icmp_payload = strdup((char const   *)c);
    icmp_payload_len = strlen((char const   *)icmp_payload);
  } else {
    tmp___12 = strncmp((char const   *)conf->probe_args, "file", (size_t )4);
    if (tmp___12 == 0) {
      tmp___2 = fopen((char const   * __restrict  )c, (char const   * __restrict  )"rb");
      inp = tmp___2;
      if (! inp) {
        log_error("icmp", "could not open ICMP data file \'%s\'", c);
        return (1);
      }
      tmp___3 = fseek(inp, 0L, 2);
      if (tmp___3) {
        log_error("icmp", "unable to get size of ICMP data file \'%s\'", c);
        return (1);
      }
      tmp___4 = ftell(inp);
      input_size = (size_t )tmp___4;
      if (input_size > 1458UL) {
        log_error("icmp", "input file larger than %d bytes and will not fit on the wire (%llu bytes provided)",
                  1458, input_size);
        return (1);
      }
      tmp___5 = fseek(inp, 0L, 0);
      if (tmp___5) {
        log_error("icmp", "unable to read ICMP data file \'%s\'", c);
        return (1);
      }
      tmp___6 = xmalloc((size_t )1458);
      icmp_payload = (char *)tmp___6;
      icmp_payload_len = fread((void * __restrict  )icmp_payload, (size_t )1, (size_t )1458,
                               (FILE * __restrict  )inp);
      fclose(inp);
    } else {
      tmp___11 = strncmp((char const   *)conf->probe_args, "hex", (size_t )3);
      if (tmp___11 == 0) {
        tmp___7 = strlen((char const   *)c);
        if (tmp___7 % 2UL != 0UL) {
          log_error("icmp", "invalid hex input (length must be a multiple of 2)");
          return (1);
        }
        tmp___8 = strlen((char const   *)c);
        icmp_payload_len = tmp___8 / 2UL;
        tmp___9 = xmalloc(icmp_payload_len);
        icmp_payload = (char *)tmp___9;
        i = (size_t )0;
        while (i < icmp_payload_len) {
          tmp___10 = sscanf((char const   * __restrict  )(c + i * 2UL), (char const   * __restrict  )"%2x",
                            & n);
          if (tmp___10 != 1) {
            free((void *)icmp_payload);
            log_error("icmp", "non-hex character: \'%c\'", (int )*(c + i * 2UL));
            return (1);
          }
          *(icmp_payload + i) = (char )(n & 255U);
          i ++;
        }
      } else {
        log_error("icmp", icmp_usage_error);
        return (1);
      }
    }
  }
  if (icmp_payload_len > 1458UL) {
    log_error("icmp", "reducing ICMP payload must be at most %d bytes to fit on the wire (%d were provided)\n",
              1458, icmp_payload_len);
    return (1);
  }
  module_icmp_echo.max_packet_length = ((sizeof(struct ether_header ) + sizeof(struct ip )) + 8UL) + icmp_payload_len;
  if (! (module_icmp_echo.max_packet_length <= 1500UL)) {
    __assert_fail("module_icmp_echo.max_packet_length <= 1500", "src/probe_modules/module_icmp_echo.c",
                  112U, "icmp_global_initialize");
  }
  return (0);
}
}
int icmp_global_cleanup(struct state_conf *zconf___0  __attribute__((__unused__)) ,
                        struct state_send *zsend___0  __attribute__((__unused__)) ,
                        struct state_recv *zrecv___0  __attribute__((__unused__)) )
{


  {
  if (icmp_payload) {
    free((void *)icmp_payload);
    icmp_payload = (char *)((void *)0);
  }
  return (0);
}
}
static int icmp_echo_init_perthread(void *buf , macaddr_t *src , macaddr_t *gw , port_h_t dst_port  __attribute__((__unused__)) ,
                                    void **arg_ptr  __attribute__((__unused__)) )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  uint16_t len ;
  __uint16_t tmp ;
  struct icmp *icmp_header ;
  char *payload ;

  {
  memset(buf, 0, (size_t )4096);
  eth_header = (struct ether_header *)buf;
  make_eth_header(eth_header, src, gw);
  ip_header = (struct ip *)(eth_header + 1);
  tmp = __bswap_16((__uint16_t )((sizeof(struct ip ) + 8UL) + icmp_payload_len));
  len = tmp;
  make_ip_header(ip_header, (uint8_t )1, len);
  icmp_header = (struct icmp *)(ip_header + 1);
  make_icmp_header(icmp_header);
  payload = (char *)icmp_header + 8;
  memcpy((void * __restrict  )payload, (void const   * __restrict  )icmp_payload,
         icmp_payload_len);
  return (0);
}
}
static int icmp_echo_make_packet(void *buf , size_t *buf_len , ipaddr_n_t src_ip ,
                                 ipaddr_n_t dst_ip , uint8_t ttl , uint32_t *validation ,
                                 int probe_num  __attribute__((__unused__)) , void *arg  __attribute__((__unused__)) )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  struct icmp *icmp_header ;
  uint16_t icmp_idnum ;
  uint16_t icmp_seqnum ;
  size_t ip_len ;

  {
  eth_header = (struct ether_header *)buf;
  ip_header = (struct ip *)(eth_header + 1);
  icmp_header = (struct icmp *)(ip_header + 1);
  icmp_idnum = (uint16_t )(*(validation + 1) & 65535U);
  icmp_seqnum = (uint16_t )(*(validation + 2) & 65535U);
  ip_header->ip_src.s_addr = src_ip;
  ip_header->ip_dst.s_addr = dst_ip;
  ip_header->ip_ttl = ttl;
  icmp_header->icmp_hun.ih_idseq.icd_id = icmp_idnum;
  icmp_header->icmp_hun.ih_idseq.icd_seq = icmp_seqnum;
  icmp_header->icmp_cksum = (uint16_t )0;
  icmp_header->icmp_cksum = icmp_checksum((unsigned short *)icmp_header, 8UL + icmp_payload_len);
  ip_len = (sizeof(struct ip ) + 8UL) + icmp_payload_len;
  ip_header->ip_len = __bswap_16((__uint16_t )ip_len);
  ip_header->ip_sum = (unsigned short)0;
  ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
  *buf_len = ip_len + sizeof(struct ether_header );
  return (0);
}
}
static void icmp_echo_print_packet(FILE *fp , void *packet )
{
  struct ether_header *ethh ;
  struct ip *iph ;
  struct icmp *icmp_header ;
  __uint16_t tmp ;
  __uint16_t tmp___0 ;
  __uint16_t tmp___1 ;

  {
  ethh = (struct ether_header *)packet;
  iph = (struct ip *)(ethh + 1);
  icmp_header = (struct icmp *)(iph + 1);
  tmp = __bswap_16(icmp_header->icmp_hun.ih_idseq.icd_seq);
  tmp___0 = __bswap_16(icmp_header->icmp_hun.ih_idseq.icd_id);
  tmp___1 = __bswap_16(icmp_header->icmp_cksum);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"icmp { type: %u | code: %u | checksum: %#04X | id: %u | seq: %u }\n",
                (int )icmp_header->icmp_type, (int )icmp_header->icmp_code, (int )tmp___1,
                (int )tmp___0, (int )tmp);
  fprintf_ip_header(fp, iph);
  fprintf_eth_header(fp, ethh);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"------------------------------------------------------\n");
  return;
}
}
static int imcp_validate_id_seq(struct icmp *icmp_h , uint32_t *validation )
{


  {
  if ((unsigned int )icmp_h->icmp_hun.ih_idseq.icd_id != (*(validation + 1) & 65535U)) {
    return (0);
  }
  if ((unsigned int )icmp_h->icmp_hun.ih_idseq.icd_seq != (*(validation + 2) & 65535U)) {
    return (0);
  }
  return (1);
}
}
static int icmp_validate_packet(struct ip  const  *ip_hdr , uint32_t len , uint32_t *src_ip  __attribute__((__unused__)) ,
                                uint32_t *validation )
{
  struct icmp *icmp_h ;
  struct icmp *tmp ;
  int tmp___0 ;
  struct ip *ip_inner ;
  size_t ip_inner_len ;
  int icmp_inner_valid ;
  int tmp___1 ;
  struct icmp *icmp_inner ;
  struct icmp *tmp___2 ;
  int tmp___3 ;

  {
  if ((int const   )ip_hdr->ip_p != 1) {
    return (0);
  }
  tmp = get_icmp_header(ip_hdr, len);
  icmp_h = tmp;
  if (! icmp_h) {
    return (0);
  }
  if ((int )icmp_h->icmp_type == 0) {
    tmp___0 = imcp_validate_id_seq(icmp_h, validation);
    return (tmp___0);
  } else {
    tmp___1 = icmp_helper_validate(ip_hdr, len, sizeof(struct icmp ), & ip_inner,
                                   & ip_inner_len);
    icmp_inner_valid = tmp___1;
    if (icmp_inner_valid == 0) {
      return (0);
    }
    tmp___2 = get_icmp_header((struct ip  const  *)ip_inner, (uint32_t )ip_inner_len);
    icmp_inner = tmp___2;
    if (! icmp_inner) {
      return (0);
    }
    validate_gen(ip_hdr->ip_dst.s_addr, (uint32_t const   )ip_inner->ip_dst.s_addr,
                 (uint8_t *)((uint8_t *)validation));
    tmp___3 = imcp_validate_id_seq(icmp_inner, validation);
    return (tmp___3);
  }
}
}
static void icmp_echo_process_packet(u_char const   *packet , uint32_t len , fieldset_t *fs ,
                                     uint32_t *validation  __attribute__((__unused__)) ,
                                     struct timespec ts  __attribute__((__unused__)) )
{
  struct ip *ip_hdr ;
  struct icmp *icmp_hdr ;
  __uint16_t tmp ;
  __uint16_t tmp___0 ;
  uint32_t hdrlen ;
  int datalen ;
  uint8_t const   *data ;

  {
  ip_hdr = (struct ip *)(packet + sizeof(struct ether_header ));
  icmp_hdr = (struct icmp *)((char *)ip_hdr + 4U * ip_hdr->ip_hl);
  fs_add_uint64(fs, "type", (uint64_t )icmp_hdr->icmp_type);
  fs_add_uint64(fs, "code", (uint64_t )icmp_hdr->icmp_code);
  tmp = __bswap_16(icmp_hdr->icmp_hun.ih_idseq.icd_id);
  fs_add_uint64(fs, "icmp_id", (uint64_t )tmp);
  tmp___0 = __bswap_16(icmp_hdr->icmp_hun.ih_idseq.icd_seq);
  fs_add_uint64(fs, "seq", (uint64_t )tmp___0);
  hdrlen = (uint32_t )((sizeof(struct ether_header ) + (unsigned long )(4U * ip_hdr->ip_hl)) + 4UL);
  switch ((int )icmp_hdr->icmp_type) {
  case 0:
  fs_add_string(fs, "classification", (char *)"echoreply", 0);
  fs_add_uint64(fs, "success", (uint64_t )1);
  break;
  case 3:
  fs_add_string(fs, "classification", (char *)"unreach", 0);
  fs_add_bool(fs, "success", 0);
  break;
  case 4:
  fs_add_string(fs, "classification", (char *)"sourcequench", 0);
  fs_add_bool(fs, "success", 0);
  break;
  case 5:
  fs_add_string(fs, "classification", (char *)"redirect", 0);
  fs_add_bool(fs, "success", 0);
  break;
  case 11:
  fs_add_string(fs, "classification", (char *)"timxceed", 0);
  fs_add_bool(fs, "success", 0);
  break;
  default:
  fs_add_string(fs, "classification", (char *)"other", 0);
  fs_add_bool(fs, "success", 0);
  break;
  }
  datalen = (int )(len - hdrlen);
  if (datalen > 0) {
    data = (uint8_t const   *)((uint8_t *)(packet + hdrlen));
    fs_add_binary(fs, "data", (size_t )datalen, (void *)data, 0);
  } else {
    fs_add_null(fs, "data");
  }
  return;
}
}
static fielddef_t fields[7]  = {      {"type", "int", "icmp message type"},
        {"code", "int", "icmp message sub type code"},
        {"icmp_id", "int", "icmp id number"},
        {"seq", "int", "icmp sequence number"},
        {"classification", "string", "probe module classification"},
        {"success", "bool", "did probe module classify response as success"},
        {"data", "binary", "ICMP payload"}};
probe_module_t module_icmp_echo  =
     {"icmp_echoscan", (size_t )48, "icmp and icmp[0]!=8", (size_t )96, (uint8_t )0,
    & icmp_global_initialize, & icmp_echo_init_perthread, & icmp_echo_make_packet,
    & icmp_echo_print_packet, & icmp_validate_packet, (void (*)(u_char const   *packetbuf ,
                                                                uint32_t len , fieldset_t * ,
                                                                uint32_t *validation ,
                                                                struct timespec  const  ts ))(& icmp_echo_process_packet),
    & icmp_global_cleanup, 1, fields, 7, "Probe module that sends ICMP echo requests to hosts.\nPayload of ICMP packets will consist of zeroes unless you customize it with\n --probe-args=file:/path_to_payload_file\n --probe-args=text:SomeText\n --probe-args=hex:5061796c6f6164"};
#pragma merger("0","/tmp/cil-_ehBgRa8.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
probe_module_t module_icmp_echo_time ;
static int icmp_echo_init_perthread___0(void *buf , macaddr_t *src , macaddr_t *gw ,
                                        port_h_t dst_port  __attribute__((__unused__)) ,
                                        void **arg_ptr  __attribute__((__unused__)) )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  uint16_t len ;
  __uint16_t tmp ;
  struct icmp *icmp_header ;

  {
  memset(buf, 0, (size_t )4096);
  eth_header = (struct ether_header *)buf;
  make_eth_header(eth_header, src, gw);
  ip_header = (struct ip *)(eth_header + 1);
  tmp = __bswap_16((__uint16_t )((sizeof(struct ip ) + sizeof(struct icmp )) - 8UL));
  len = tmp;
  make_ip_header(ip_header, (uint8_t )1, len);
  icmp_header = (struct icmp *)(ip_header + 1);
  make_icmp_header(icmp_header);
  return (0);
}
}
static int icmp_echo_make_packet___0(void *buf , size_t *buf_len , ipaddr_n_t src_ip ,
                                     ipaddr_n_t dst_ip , uint8_t ttl , uint32_t *validation ,
                                     int probe_num  __attribute__((__unused__)) ,
                                     void *arg  __attribute__((__unused__)) )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  struct icmp *icmp_header ;
  struct icmp_payload_for_rtt *payload ;
  uint16_t icmp_idnum ;
  uint16_t icmp_seqnum ;
  struct timeval tv ;
  size_t ip_len ;

  {
  eth_header = (struct ether_header *)buf;
  ip_header = (struct ip *)(eth_header + 1);
  icmp_header = (struct icmp *)(ip_header + 1);
  payload = (struct icmp_payload_for_rtt *)((char *)icmp_header + 8);
  icmp_idnum = (uint16_t )(*(validation + 1) & 65535U);
  icmp_seqnum = (uint16_t )(*(validation + 2) & 65535U);
  ip_header->ip_src.s_addr = src_ip;
  ip_header->ip_dst.s_addr = dst_ip;
  ip_header->ip_ttl = ttl;
  icmp_header->icmp_hun.ih_idseq.icd_id = icmp_idnum;
  icmp_header->icmp_hun.ih_idseq.icd_seq = icmp_seqnum;
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  payload->sent_tv_sec = (uint32_t )tv.tv_sec;
  payload->sent_tv_usec = (uint32_t )tv.tv_usec;
  payload->dst = dst_ip;
  icmp_header->icmp_cksum = (uint16_t )0;
  icmp_header->icmp_cksum = icmp_checksum((unsigned short *)icmp_header, sizeof(struct icmp ));
  ip_len = (sizeof(struct ip ) + 8UL) + sizeof(struct icmp_payload_for_rtt );
  ip_header->ip_len = __bswap_16((__uint16_t )ip_len);
  ip_header->ip_sum = (unsigned short)0;
  ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
  *buf_len = ip_len + sizeof(struct ether_header );
  return (0);
}
}
static void icmp_echo_print_packet___0(FILE *fp , void *packet )
{
  struct ether_header *ethh ;
  struct ip *iph ;
  struct icmp *icmp_header ;
  __uint16_t tmp ;
  __uint16_t tmp___0 ;
  __uint16_t tmp___1 ;

  {
  ethh = (struct ether_header *)packet;
  iph = (struct ip *)(ethh + 1);
  icmp_header = (struct icmp *)(iph + 1);
  tmp = __bswap_16(icmp_header->icmp_hun.ih_idseq.icd_seq);
  tmp___0 = __bswap_16(icmp_header->icmp_hun.ih_idseq.icd_id);
  tmp___1 = __bswap_16(icmp_header->icmp_cksum);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"icmp { type: %u | code: %u | checksum: %#04X | id: %u | seq: %u }\n",
                (int )icmp_header->icmp_type, (int )icmp_header->icmp_code, (int )tmp___1,
                (int )tmp___0, (int )tmp);
  fprintf_ip_header(fp, iph);
  fprintf_eth_header(fp, ethh);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"------------------------------------------------------\n");
  return;
}
}
static int icmp_validate_packet___0(struct ip  const  *ip_hdr , uint32_t len , uint32_t *src_ip ,
                                    uint32_t *validation )
{
  struct icmp *icmp_h ;
  uint16_t icmp_idnum ;
  uint16_t icmp_seqnum ;
  struct ip *ip_inner ;
  struct icmp *icmp_inner ;

  {
  if ((int const   )ip_hdr->ip_p != 1) {
    return (0);
  }
  if (4U * (uint32_t )ip_hdr->ip_hl + 5U > len) {
    return (0);
  }
  icmp_h = (struct icmp *)((char *)ip_hdr + 4U * ip_hdr->ip_hl);
  icmp_idnum = icmp_h->icmp_hun.ih_idseq.icd_id;
  icmp_seqnum = icmp_h->icmp_hun.ih_idseq.icd_seq;
  if ((int )icmp_h->icmp_type == 11) {
    goto _L;
  } else
  if ((int )icmp_h->icmp_type == 3) {
    _L: /* CIL Label */
    if ((unsigned long )(4U * ip_hdr->ip_hl + 8U) + sizeof(struct ip ) > (unsigned long )len) {
      return (0);
    }
    ip_inner = (struct ip *)((char *)icmp_h + 8);
    if (((4U * (uint32_t )ip_hdr->ip_hl + 8U) + 4U * ip_inner->ip_hl) + 8U > len) {
      return (0);
    }
    icmp_inner = (struct icmp *)((char *)ip_inner + 4U * ip_hdr->ip_hl);
    icmp_idnum = icmp_inner->icmp_hun.ih_idseq.icd_id;
    icmp_seqnum = icmp_inner->icmp_hun.ih_idseq.icd_seq;
    *src_ip = ip_inner->ip_dst.s_addr;
    validate_gen(ip_hdr->ip_dst.s_addr, (uint32_t const   )ip_inner->ip_dst.s_addr,
                 (uint8_t *)((uint8_t *)validation));
  }
  if ((unsigned int )icmp_idnum != (*(validation + 1) & 65535U)) {
    return (0);
  }
  if ((unsigned int )icmp_seqnum != (*(validation + 2) & 65535U)) {
    return (0);
  }
  return (1);
}
}
static void icmp_echo_process_packet___0(u_char const   *packet , uint32_t len  __attribute__((__unused__)) ,
                                         fieldset_t *fs , uint32_t *validation  __attribute__((__unused__)) ,
                                         struct timespec ts  __attribute__((__unused__)) )
{
  struct ip *ip_hdr ;
  struct icmp *icmp_hdr ;
  __uint16_t tmp ;
  __uint16_t tmp___0 ;
  struct icmp_payload_for_rtt *payload ;

  {
  ip_hdr = (struct ip *)(packet + sizeof(struct ether_header ));
  icmp_hdr = (struct icmp *)((char *)ip_hdr + 4U * ip_hdr->ip_hl);
  fs_add_uint64(fs, "type", (uint64_t )icmp_hdr->icmp_type);
  fs_add_uint64(fs, "code", (uint64_t )icmp_hdr->icmp_code);
  tmp = __bswap_16(icmp_hdr->icmp_hun.ih_idseq.icd_id);
  fs_add_uint64(fs, "icmp_id", (uint64_t )tmp);
  tmp___0 = __bswap_16(icmp_hdr->icmp_hun.ih_idseq.icd_seq);
  fs_add_uint64(fs, "seq", (uint64_t )tmp___0);
  payload = (struct icmp_payload_for_rtt *)((char *)icmp_hdr + 8);
  fs_add_uint64(fs, "sent_timestamp_ts", (uint64_t )payload->sent_tv_sec);
  fs_add_uint64(fs, "sent_timestamp_us", (uint64_t )payload->sent_tv_usec);
  fs_add_uint64(fs, "dst_raw", (uint64_t )payload->dst);
  switch ((int )icmp_hdr->icmp_type) {
  case 0:
  fs_add_string(fs, "classification", (char *)"echoreply", 0);
  fs_add_uint64(fs, "success", (uint64_t )1);
  break;
  case 3:
  fs_add_string(fs, "classification", (char *)"unreach", 0);
  fs_add_uint64(fs, "success", (uint64_t )0);
  break;
  case 4:
  fs_add_string(fs, "classification", (char *)"sourcequench", 0);
  fs_add_uint64(fs, "success", (uint64_t )0);
  break;
  case 5:
  fs_add_string(fs, "classification", (char *)"redirect", 0);
  fs_add_uint64(fs, "success", (uint64_t )0);
  break;
  case 11:
  fs_add_string(fs, "classification", (char *)"timxceed", 0);
  fs_add_uint64(fs, "success", (uint64_t )0);
  break;
  default:
  fs_add_string(fs, "classification", (char *)"other", 0);
  fs_add_uint64(fs, "success", (uint64_t )0);
  break;
  }
  return;
}
}
static fielddef_t fields___0[9]  =
  {      {"type", "int", "icmp message type"},
        {"code", "int", "icmp message sub type code"},
        {"icmp_id", "int", "icmp id number"},
        {"seq", "int", "icmp sequence number"},
        {"sent_timestamp_ts", "int", "timestamp of sent probe in seconds since Epoch"},
        {"sent_timestamp_us",
      "int", "microsecond part of sent timestamp"},
        {"dst-raw", "int", "raw destination IP address of sent probe"},
        {"classification", "string", "probe module classification"},
        {"success", "int", "did probe module classify response as success"}};
probe_module_t module_icmp_echo_time  =
     {"icmp_echo_time", (size_t )62, "icmp and icmp[0]!=8", (size_t )96, (uint8_t )0,
    (int (*)(struct state_conf * ))0, & icmp_echo_init_perthread___0, & icmp_echo_make_packet___0,
    & icmp_echo_print_packet___0, & icmp_validate_packet___0, (void (*)(u_char const   *packetbuf ,
                                                                        uint32_t len ,
                                                                        fieldset_t * ,
                                                                        uint32_t *validation ,
                                                                        struct timespec  const  ts ))(& icmp_echo_process_packet___0),
    (int (*)(struct state_conf * , struct state_send * , struct state_recv * ))((void *)0),
    1, fields___0, 9, (char const   *)0};
#pragma merger("0","/tmp/cil-_UeDGsOL.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern int blocklist_is_allowed(uint32_t s_addr ) ;
void make_tcp_header(struct tcphdr *tcp_header , port_h_t dest_port , uint16_t th_flags ) ;
size_t set_mss_option(struct tcphdr *tcp_header ) ;
__inline static uint16_t tcp_checksum(unsigned short len_tcp , uint32_t saddr , uint32_t daddr ,
                                      struct tcphdr *tcp_pkt )
{
  alias_unsigned_short *src_addr ;
  alias_unsigned_short *dest_addr ;
  unsigned char prot_tcp ;
  unsigned long sum ;
  int nleft ;
  unsigned short *w ;
  unsigned short *tmp ;
  __uint16_t tmp___0 ;
  __uint16_t tmp___1 ;
  __uint16_t tmp___2 ;

  {
  src_addr = (alias_unsigned_short *)(& saddr);
  dest_addr = (alias_unsigned_short *)(& daddr);
  prot_tcp = (unsigned char)6;
  sum = 0UL;
  nleft = (int )len_tcp;
  w = (unsigned short *)tcp_pkt;
  while (nleft > 1) {
    tmp = w;
    w ++;
    sum += (unsigned long )*tmp;
    nleft -= 2;
  }
  if (nleft > 0) {
    tmp___0 = __bswap_16((__uint16_t )65280);
    sum += (unsigned long )((int )*w & (int )tmp___0);
  }
  sum += (unsigned long )*(src_addr + 0);
  sum += (unsigned long )*(src_addr + 1);
  sum += (unsigned long )*(dest_addr + 0);
  sum += (unsigned long )*(dest_addr + 1);
  tmp___1 = __bswap_16(len_tcp);
  sum += (unsigned long )tmp___1;
  tmp___2 = __bswap_16((__uint16_t )prot_tcp);
  sum += (unsigned long )tmp___2;
  sum = (sum >> 16) + (sum & 65535UL);
  sum += sum >> 16;
  return ((unsigned short )(~ sum));
}
}
__inline static int check_dst_port(uint16_t port , int num_ports___6 , uint32_t *validation )
{
  int32_t to_validate ;
  int32_t min ;
  int32_t max ;

  {
  if ((int )port > (int )zconf.source_port_last) {
    return (0);
  } else
  if ((int )port < (int )zconf.source_port_first) {
    return (0);
  }
  to_validate = (int )port - (int )zconf.source_port_first;
  min = (int32_t )(*(validation + 1) % (unsigned int )num_ports___6);
  max = (int32_t )(((*(validation + 1) + (uint32_t )zconf.packet_streams) - 1U) % (unsigned int )num_ports___6);
  return ((max - min) % num_ports___6 >= (to_validate - min) % num_ports___6);
}
}
__inline static uint16_t get_src_port(int num_ports___6 , int probe_num , uint32_t *validation )
{


  {
  return ((uint16_t )((unsigned int )zconf.source_port_first + (*(validation + 1) + (uint32_t )probe_num) % (unsigned int )num_ports___6));
}
}
__inline static struct ip *get_ip_header(u_char const   *packet , uint32_t len )
{


  {
  if ((unsigned long )len < sizeof(struct ether_header )) {
    return ((struct ip *)((void *)0));
  }
  return ((struct ip *)(packet + sizeof(struct ether_header )));
}
}
__inline static struct tcphdr *get_tcp_header(struct ip  const  *ip_hdr , uint32_t len )
{


  {
  if ((unsigned long )(4U * ip_hdr->ip_hl) + sizeof(struct tcphdr ) > (unsigned long )len) {
    return ((struct tcphdr *)((void *)0));
  }
  return ((struct tcphdr *)((char *)ip_hdr + 4U * ip_hdr->ip_hl));
}
}
void fs_add_null_icmp(fieldset_t *fs ) ;
void fs_populate_icmp_from_iphdr(struct ip *ip , size_t len , fieldset_t *fs ) ;
probe_module_t module_tcp_synscan ;
static uint16_t num_ports  ;
static port_h_t target_port  ;
static int synscan_global_initialize(struct state_conf *state )
{


  {
  num_ports = (uint16_t )(((int )state->source_port_last - (int )state->source_port_first) + 1);
  target_port = state->target_port;
  return (0);
}
}
static int synscan_init_perthread(void *buf , macaddr_t *src , macaddr_t *gw , port_h_t dst_port ,
                                  void **arg_ptr  __attribute__((__unused__)) )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  uint16_t len ;
  __uint16_t tmp ;
  struct tcphdr *tcp_header ;

  {
  eth_header = (struct ether_header *)buf;
  make_eth_header(eth_header, src, gw);
  ip_header = (struct ip *)(eth_header + 1);
  tmp = __bswap_16((__uint16_t )(sizeof(struct ip ) + 24UL));
  len = tmp;
  make_ip_header(ip_header, (uint8_t )6, len);
  tcp_header = (struct tcphdr *)(ip_header + 1);
  make_tcp_header(tcp_header, dst_port, (uint16_t )2);
  set_mss_option(tcp_header);
  return (0);
}
}
static int synscan_make_packet(void *buf , size_t *buf_len , ipaddr_n_t src_ip , ipaddr_n_t dst_ip ,
                               uint8_t ttl , uint32_t *validation , int probe_num ,
                               void *arg  __attribute__((__unused__)) )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  struct tcphdr *tcp_header ;
  uint32_t tcp_seq___0 ;
  port_h_t sport ;
  uint16_t tmp ;

  {
  eth_header = (struct ether_header *)buf;
  ip_header = (struct ip *)(eth_header + 1);
  tcp_header = (struct tcphdr *)(ip_header + 1);
  tcp_seq___0 = *(validation + 0);
  ip_header->ip_src.s_addr = src_ip;
  ip_header->ip_dst.s_addr = dst_ip;
  ip_header->ip_ttl = ttl;
  tmp = get_src_port((int )num_ports, probe_num, validation);
  sport = tmp;
  tcp_header->__annonCompField8.__annonCompField6.th_sport = __bswap_16(sport);
  tcp_header->__annonCompField8.__annonCompField6.th_seq = tcp_seq___0;
  tcp_header->__annonCompField8.__annonCompField6.th_sum = (uint16_t )0;
  tcp_header->__annonCompField8.__annonCompField6.th_sum = tcp_checksum((unsigned short)24,
                                                                        ip_header->ip_src.s_addr,
                                                                        ip_header->ip_dst.s_addr,
                                                                        tcp_header);
  ip_header->ip_sum = (unsigned short)0;
  ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
  *buf_len = (size_t )58;
  return (0);
}
}
void synscan_print_packet(FILE *fp , void *packet )
{
  struct ether_header *ethh ;
  struct ip *iph ;
  struct tcphdr *tcph ;
  __uint16_t tmp ;
  __uint32_t tmp___0 ;
  __uint16_t tmp___1 ;
  __uint16_t tmp___2 ;

  {
  ethh = (struct ether_header *)packet;
  iph = (struct ip *)(ethh + 1);
  tcph = (struct tcphdr *)(iph + 1);
  tmp = __bswap_16(tcph->__annonCompField8.__annonCompField6.th_sum);
  tmp___0 = __bswap_32(tcph->__annonCompField8.__annonCompField6.th_seq);
  tmp___1 = __bswap_16(tcph->__annonCompField8.__annonCompField6.th_dport);
  tmp___2 = __bswap_16(tcph->__annonCompField8.__annonCompField6.th_sport);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"tcp { source: %u | dest: %u | seq: %u | checksum: %#04X }\n",
                (int )tmp___2, (int )tmp___1, tmp___0, (int )tmp);
  fprintf_ip_header(fp, iph);
  fprintf_eth_header(fp, ethh);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"------------------------------------------------------\n");
  return;
}
}
static int synscan_validate_packet(struct ip  const  *ip_hdr , uint32_t len , uint32_t *src_ip ,
                                   uint32_t *validation )
{
  struct tcphdr *tcp ;
  struct tcphdr *tmp ;
  port_h_t sport ;
  __uint16_t tmp___0 ;
  port_h_t dport ;
  __uint16_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uint32_t tmp___4 ;
  __uint32_t tmp___5 ;
  __uint32_t tmp___6 ;
  __uint32_t tmp___7 ;
  __uint32_t tmp___8 ;
  __uint32_t tmp___9 ;
  struct ip *ip_inner ;
  size_t ip_inner_len ;
  int tmp___10 ;
  struct tcphdr *tcp___0 ;
  struct tcphdr *tmp___11 ;
  port_h_t sport___0 ;
  __uint16_t tmp___12 ;
  port_h_t dport___0 ;
  __uint16_t tmp___13 ;
  int tmp___14 ;

  {
  if ((int const   )ip_hdr->ip_p == 6) {
    tmp = get_tcp_header(ip_hdr, len);
    tcp = tmp;
    if (! tcp) {
      return (0);
    }
    tmp___0 = __bswap_16(tcp->__annonCompField8.__annonCompField6.th_sport);
    sport = tmp___0;
    tmp___1 = __bswap_16(tcp->__annonCompField8.__annonCompField6.th_dport);
    dport = tmp___1;
    if ((int )sport != (int )target_port) {
      return (0);
    }
    tmp___2 = check_dst_port(dport, (int )num_ports, validation);
    if (! tmp___2) {
      return (0);
    }
    tmp___3 = blocklist_is_allowed(*src_ip);
    if (! tmp___3) {
      return (0);
    }
    if ((int )tcp->__annonCompField8.__annonCompField6.th_flags & 4) {
      tmp___4 = __bswap_32(tcp->__annonCompField8.__annonCompField6.th_ack);
      tmp___5 = __bswap_32(*(validation + 0));
      if (tmp___4 != tmp___5) {
        tmp___6 = __bswap_32(tcp->__annonCompField8.__annonCompField6.th_ack);
        tmp___7 = __bswap_32(*(validation + 0));
        if (tmp___6 != tmp___7 + 1U) {
          return (0);
        }
      }
    } else {
      tmp___8 = __bswap_32(tcp->__annonCompField8.__annonCompField6.th_ack);
      tmp___9 = __bswap_32(*(validation + 0));
      if (tmp___8 != tmp___9 + 1U) {
        return (0);
      }
    }
  } else
  if ((int const   )ip_hdr->ip_p == 1) {
    tmp___10 = icmp_helper_validate(ip_hdr, len, sizeof(struct tcphdr ), & ip_inner,
                                    & ip_inner_len);
    if (tmp___10 == 0) {
      return (0);
    }
    tmp___11 = get_tcp_header((struct ip  const  *)ip_inner, (uint32_t )ip_inner_len);
    tcp___0 = tmp___11;
    if (! tcp___0) {
      return (0);
    }
    tmp___12 = __bswap_16(tcp___0->__annonCompField8.__annonCompField6.th_sport);
    sport___0 = tmp___12;
    tmp___13 = __bswap_16(tcp___0->__annonCompField8.__annonCompField6.th_dport);
    dport___0 = tmp___13;
    if ((int )dport___0 != (int )target_port) {
      return (0);
    }
    validate_gen(ip_hdr->ip_dst.s_addr, (uint32_t const   )ip_inner->ip_dst.s_addr,
                 (uint8_t *)((uint8_t *)validation));
    tmp___14 = check_dst_port(sport___0, (int )num_ports, validation);
    if (! tmp___14) {
      return (0);
    }
  } else {
    return (0);
  }
  return (1);
}
}
static void synscan_process_packet(u_char const   *packet , uint32_t len  __attribute__((__unused__)) ,
                                   fieldset_t *fs , uint32_t *validation  __attribute__((__unused__)) ,
                                   struct timespec ts  __attribute__((__unused__)) )
{
  struct ip *ip_hdr ;
  struct ip *tmp ;
  struct tcphdr *tcp ;
  struct tcphdr *tmp___1 ;
  __uint16_t tmp___3 ;
  __uint16_t tmp___4 ;
  __uint32_t tmp___5 ;
  __uint32_t tmp___6 ;
  __uint16_t tmp___7 ;

  {
  tmp = get_ip_header(packet, len);
  ip_hdr = tmp;
  if (! ip_hdr) {
    __assert_fail("ip_hdr", "src/probe_modules/module_tcp_synscan.c", 175U, "synscan_process_packet");
  }
  if ((int )ip_hdr->ip_p == 6) {
    tmp___1 = get_tcp_header((struct ip  const  *)ip_hdr, len);
    tcp = tmp___1;
    if (! tcp) {
      __assert_fail("tcp", "src/probe_modules/module_tcp_synscan.c", 178U, "synscan_process_packet");
    }
    tmp___3 = __bswap_16(tcp->__annonCompField8.__annonCompField6.th_sport);
    fs_add_uint64(fs, "sport", (uint64_t )tmp___3);
    tmp___4 = __bswap_16(tcp->__annonCompField8.__annonCompField6.th_dport);
    fs_add_uint64(fs, "dport", (uint64_t )tmp___4);
    tmp___5 = __bswap_32(tcp->__annonCompField8.__annonCompField6.th_seq);
    fs_add_uint64(fs, "seqnum", (uint64_t )tmp___5);
    tmp___6 = __bswap_32(tcp->__annonCompField8.__annonCompField6.th_ack);
    fs_add_uint64(fs, "acknum", (uint64_t )tmp___6);
    tmp___7 = __bswap_16(tcp->__annonCompField8.__annonCompField6.th_win);
    fs_add_uint64(fs, "window", (uint64_t )tmp___7);
    if ((int )tcp->__annonCompField8.__annonCompField6.th_flags & 4) {
      fs_add_constchar(fs, "classification", "rst");
      fs_add_bool(fs, "success", 0);
    } else {
      fs_add_constchar(fs, "classification", "synack");
      fs_add_bool(fs, "success", 1);
    }
    fs_add_null_icmp(fs);
  } else
  if ((int )ip_hdr->ip_p == 1) {
    fs_add_null(fs, "sport");
    fs_add_null(fs, "dport");
    fs_add_null(fs, "seqnum");
    fs_add_null(fs, "acknum");
    fs_add_null(fs, "window");
    fs_add_constchar(fs, "classification", "icmp");
    fs_add_bool(fs, "success", 0);
    fs_populate_icmp_from_iphdr(ip_hdr, (size_t )len, fs);
  }
  return;
}
}
static fielddef_t fields___1[11]  =
  {      {"sport", "int", "TCP source port"},
        {"dport", "int", "TCP destination port"},
        {"seqnum", "int", "TCP sequence number"},
        {"acknum", "int", "TCP acknowledgement number"},
        {"window", "int", "TCP window"},
        {"classification", "string", "packet classification"},
        {"success", "bool", "is response considered success"},
        {"icmp_responder", "string", "Source IP of ICMP_UNREACH messages"},
        {"icmp_type", "int", "icmp message type"},
        {"icmp_code", "int", "icmp message sub type code"},
        {"icmp_unreach_str", "string", "for icmp_unreach responses, the string version of icmp_code (e.g. network-unreach)"}};
probe_module_t module_tcp_synscan  =
     {"tcp_synscan", (size_t )58, "(tcp && tcp[13] & 4 != 0 || tcp[13] == 18) || icmp",
    (size_t )96, (uint8_t )1, & synscan_global_initialize, & synscan_init_perthread,
    & synscan_make_packet, & synscan_print_packet, & synscan_validate_packet, (void (*)(u_char const   *packetbuf ,
                                                                                        uint32_t len ,
                                                                                        fieldset_t * ,
                                                                                        uint32_t *validation ,
                                                                                        struct timespec  const  ts ))(& synscan_process_packet),
    (int (*)(struct state_conf * , struct state_send * , struct state_recv * ))((void *)0),
    1, fields___1, (int )(sizeof(fields___1) / sizeof(fields___1[0])), "Probe module that sends a TCP SYN packet to a specific port. Possible classifications are: synack and rst. A SYN-ACK packet is considered a success and a reset packet is considered a failed response."};
#pragma merger("0","/tmp/cil-MqRz6qWN.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
probe_module_t module_tcp_synackscan ;
static uint32_t num_ports___0  ;
static int synackscan_global_initialize(struct state_conf *state )
{


  {
  num_ports___0 = (uint32_t )(((int )state->source_port_last - (int )state->source_port_first) + 1);
  return (0);
}
}
static int synackscan_init_perthread(void *buf , macaddr_t *src , macaddr_t *gw ,
                                     port_h_t dst_port , void **arg_ptr  __attribute__((__unused__)) )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  uint16_t len ;
  __uint16_t tmp ;
  struct tcphdr *tcp_header ;

  {
  memset(buf, 0, (size_t )4096);
  eth_header = (struct ether_header *)buf;
  make_eth_header(eth_header, src, gw);
  ip_header = (struct ip *)(eth_header + 1);
  tmp = __bswap_16((__uint16_t )(sizeof(struct ip ) + 24UL));
  len = tmp;
  make_ip_header(ip_header, (uint8_t )6, len);
  tcp_header = (struct tcphdr *)(ip_header + 1);
  make_tcp_header(tcp_header, dst_port, (uint16_t )18);
  set_mss_option(tcp_header);
  return (0);
}
}
static int synackscan_make_packet(void *buf , size_t *buf_len  __attribute__((__unused__)) ,
                                  ipaddr_n_t src_ip , ipaddr_n_t dst_ip , uint8_t ttl ,
                                  uint32_t *validation , int probe_num , void *arg  __attribute__((__unused__)) )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  struct tcphdr *tcp_header ;
  uint32_t tcp_seq___0 ;
  uint32_t tcp_ack ;
  uint16_t tmp ;

  {
  eth_header = (struct ether_header *)buf;
  ip_header = (struct ip *)(eth_header + 1);
  tcp_header = (struct tcphdr *)(ip_header + 1);
  tcp_seq___0 = *(validation + 0);
  tcp_ack = *(validation + 2);
  ip_header->ip_src.s_addr = src_ip;
  ip_header->ip_dst.s_addr = dst_ip;
  ip_header->ip_ttl = ttl;
  tmp = get_src_port((int )num_ports___0, probe_num, validation);
  tcp_header->__annonCompField8.__annonCompField6.th_sport = __bswap_16(tmp);
  tcp_header->__annonCompField8.__annonCompField6.th_seq = tcp_seq___0;
  tcp_header->__annonCompField8.__annonCompField6.th_ack = tcp_ack;
  tcp_header->__annonCompField8.__annonCompField6.th_sum = (uint16_t )0;
  tcp_header->__annonCompField8.__annonCompField6.th_sum = tcp_checksum((unsigned short)24,
                                                                        ip_header->ip_src.s_addr,
                                                                        ip_header->ip_dst.s_addr,
                                                                        tcp_header);
  ip_header->ip_sum = (unsigned short)0;
  ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
  *buf_len = (size_t )58;
  return (0);
}
}
static int synackscan_validate_packet(struct ip  const  *ip_hdr , uint32_t len , uint32_t *src_ip  __attribute__((__unused__)) ,
                                      uint32_t *validation )
{
  struct tcphdr *tcp ;
  struct tcphdr *tmp ;
  uint16_t sport ;
  __uint16_t tmp___0 ;
  uint16_t dport ;
  __uint16_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uint32_t tmp___4 ;
  __uint32_t tmp___5 ;
  __uint32_t tmp___6 ;
  __uint32_t tmp___7 ;
  __uint32_t tmp___8 ;
  __uint32_t tmp___9 ;
  __uint32_t tmp___10 ;
  __uint32_t tmp___11 ;
  struct ip *ip_inner ;
  size_t ip_inner_len ;
  int tmp___12 ;
  struct tcphdr *tcp___0 ;
  struct tcphdr *tmp___13 ;
  uint16_t sport___0 ;
  __uint16_t tmp___14 ;
  uint16_t dport___0 ;
  __uint16_t tmp___15 ;
  int tmp___16 ;

  {
  if ((int const   )ip_hdr->ip_p == 6) {
    tmp = get_tcp_header(ip_hdr, len);
    tcp = tmp;
    if (! tcp) {
      return (0);
    }
    tmp___0 = __bswap_16(tcp->__annonCompField8.__annonCompField6.th_sport);
    sport = tmp___0;
    tmp___1 = __bswap_16(tcp->__annonCompField8.__annonCompField6.th_dport);
    dport = tmp___1;
    if ((int )sport != (int )zconf.target_port) {
      return (0);
    }
    tmp___2 = check_dst_port(dport, (int )num_ports___0, validation);
    if (! tmp___2) {
      return (0);
    }
    tmp___3 = blocklist_is_allowed(*src_ip);
    if (! tmp___3) {
      return (0);
    }
    if ((int )tcp->__annonCompField8.__annonCompField6.th_flags & 4) {
      tmp___4 = __bswap_32(tcp->__annonCompField8.__annonCompField6.th_ack);
      tmp___5 = __bswap_32(*(validation + 0));
      if (tmp___4 != tmp___5 + 1U) {
        tmp___6 = __bswap_32(tcp->__annonCompField8.__annonCompField6.th_seq);
        tmp___7 = __bswap_32(*(validation + 2));
        if (tmp___6 != tmp___7) {
          tmp___8 = __bswap_32(tcp->__annonCompField8.__annonCompField6.th_seq);
          tmp___9 = __bswap_32(*(validation + 2));
          if (tmp___8 != tmp___9 + 1U) {
            return (0);
          }
        }
      }
    } else {
      tmp___10 = __bswap_32(tcp->__annonCompField8.__annonCompField6.th_ack);
      tmp___11 = __bswap_32(*(validation + 0));
      if (tmp___10 != tmp___11 + 1U) {
        return (0);
      }
    }
  } else
  if ((int const   )ip_hdr->ip_p == 1) {
    tmp___12 = icmp_helper_validate(ip_hdr, len, sizeof(struct udphdr ), & ip_inner,
                                    & ip_inner_len);
    if (tmp___12 == 0) {
      return (0);
    }
    tmp___13 = get_tcp_header((struct ip  const  *)ip_inner, (uint32_t )ip_inner_len);
    tcp___0 = tmp___13;
    if (! tcp___0) {
      return (0);
    }
    tmp___14 = __bswap_16(tcp___0->__annonCompField8.__annonCompField6.th_sport);
    sport___0 = tmp___14;
    tmp___15 = __bswap_16(tcp___0->__annonCompField8.__annonCompField6.th_dport);
    dport___0 = tmp___15;
    if ((int )dport___0 != (int )zconf.target_port) {
      return (0);
    }
    validate_gen(ip_hdr->ip_dst.s_addr, (uint32_t const   )ip_inner->ip_dst.s_addr,
                 (uint8_t *)((uint8_t *)validation));
    tmp___16 = check_dst_port(sport___0, (int )num_ports___0, validation);
    if (! tmp___16) {
      return (0);
    }
  } else {
    return (0);
  }
  return (1);
}
}
static void synackscan_process_packet(u_char const   *packet , uint32_t len  __attribute__((__unused__)) ,
                                      fieldset_t *fs , uint32_t *validation  __attribute__((__unused__)) ,
                                      struct timespec ts  __attribute__((__unused__)) )
{
  struct ip *ip_hdr ;
  struct ip *tmp ;
  struct tcphdr *tcp ;
  struct tcphdr *tmp___0 ;
  __uint16_t tmp___1 ;
  __uint16_t tmp___2 ;
  __uint32_t tmp___3 ;
  __uint32_t tmp___4 ;
  __uint16_t tmp___5 ;

  {
  tmp = get_ip_header(packet, len);
  ip_hdr = tmp;
  if ((int )ip_hdr->ip_p == 6) {
    tmp___0 = get_tcp_header((struct ip  const  *)ip_hdr, len);
    tcp = tmp___0;
    tmp___1 = __bswap_16(tcp->__annonCompField8.__annonCompField6.th_sport);
    fs_add_uint64(fs, "sport", (uint64_t )tmp___1);
    tmp___2 = __bswap_16(tcp->__annonCompField8.__annonCompField6.th_dport);
    fs_add_uint64(fs, "dport", (uint64_t )tmp___2);
    tmp___3 = __bswap_32(tcp->__annonCompField8.__annonCompField6.th_seq);
    fs_add_uint64(fs, "seqnum", (uint64_t )tmp___3);
    tmp___4 = __bswap_32(tcp->__annonCompField8.__annonCompField6.th_ack);
    fs_add_uint64(fs, "acknum", (uint64_t )tmp___4);
    tmp___5 = __bswap_16(tcp->__annonCompField8.__annonCompField6.th_win);
    fs_add_uint64(fs, "window", (uint64_t )tmp___5);
    if ((int )tcp->__annonCompField8.__annonCompField6.th_flags & 4) {
      fs_add_constchar(fs, "classification", "rst");
    } else {
      fs_add_constchar(fs, "classification", "synack");
    }
    fs_add_bool(fs, "success", 1);
    fs_add_null_icmp(fs);
  } else
  if ((int )ip_hdr->ip_p == 1) {
    fs_add_null(fs, "sport");
    fs_add_null(fs, "dport");
    fs_add_null(fs, "seqnum");
    fs_add_null(fs, "acknum");
    fs_add_null(fs, "window");
    fs_add_constchar(fs, "classification", "icmp");
    fs_add_bool(fs, "success", 0);
    fs_populate_icmp_from_iphdr(ip_hdr, (size_t )len, fs);
  }
  return;
}
}
static fielddef_t fields___2[11]  =
  {      {"sport", "int", "TCP source port"},
        {"dport", "int", "TCP destination port"},
        {"seqnum", "int", "TCP sequence number"},
        {"acknum", "int", "TCP acknowledgement number"},
        {"window", "int", "TCP window"},
        {"classification", "string", "packet classification"},
        {"success", "bool", "is response considered success"},
        {"icmp_responder", "string", "Source IP of ICMP_UNREACH messages"},
        {"icmp_type", "int", "icmp message type"},
        {"icmp_code", "int", "icmp message sub type code"},
        {"icmp_unreach_str", "string", "for icmp_unreach responses, the string version of icmp_code (e.g. network-unreach)"}};
probe_module_t module_tcp_synackscan  =
     {"tcp_synackscan", (size_t )58, "(tcp && tcp[13] & 4 != 0 || tcp[13] == 18) || icmp",
    (size_t )96, (uint8_t )1, & synackscan_global_initialize, & synackscan_init_perthread,
    & synackscan_make_packet, & synscan_print_packet, & synackscan_validate_packet,
    (void (*)(u_char const   *packetbuf , uint32_t len , fieldset_t * , uint32_t *validation ,
              struct timespec  const  ts ))(& synackscan_process_packet), (int (*)(struct state_conf * ,
                                                                                   struct state_send * ,
                                                                                   struct state_recv * ))((void *)0),
    1, fields___2, (int )(sizeof(fields___2) / sizeof(fields___2[0])), "Probe module that sends a TCP SYNACK packet to a specific port. Possible classifications are: synack and rst. A SYN-ACK packet is considered a failure and a reset packet is considered a success."};
#pragma merger("0","/tmp/cil-u8lSMGD6.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern void *xrealloc(void *ptr , size_t size ) ;
void make_udp_header(struct udphdr *udp_header , port_h_t dest_port , uint16_t len ) ;
__inline static struct udphdr *get_udp_header(struct ip  const  *ip_hdr , uint32_t len )
{


  {
  if ((unsigned long )(4U * ip_hdr->ip_hl) + sizeof(struct udphdr ) > (unsigned long )len) {
    return ((struct udphdr *)((void *)0));
  }
  return ((struct udphdr *)((char *)ip_hdr + 4U * ip_hdr->ip_hl));
}
}
void udp_print_packet(FILE *fp , void *packet ) ;
int udp_make_packet(void *buf , size_t *buf_len , ipaddr_n_t src_ip , ipaddr_n_t dst_ip ,
                    uint8_t ttl , uint32_t *validation , int probe_num , void *arg  __attribute__((__unused__)) ) ;
int udp_make_templated_packet(void *buf , size_t *buf_len , ipaddr_n_t src_ip , ipaddr_n_t dst_ip ,
                              uint8_t ttl , uint32_t *validation , int probe_num ,
                              void *arg ) ;
int udp_do_validate_packet(struct ip  const  *ip_hdr , uint32_t len , uint32_t *src_ip  __attribute__((__unused__)) ,
                           uint32_t *validation , int num_ports___6 , int expected_port ) ;
void udp_set_num_ports(int x ) ;
int udp_global_initialize(struct state_conf *conf ) ;
int udp_global_cleanup(struct state_conf *zconf___0  __attribute__((__unused__)) ,
                       struct state_send *zsend___0  __attribute__((__unused__)) ,
                       struct state_recv *zrecv___0  __attribute__((__unused__)) ) ;
void udp_template_add_field(udp_payload_template_t *t , udp_payload_field_type_t ftype ,
                            unsigned int length , char *data ) ;
void udp_template_free(udp_payload_template_t *t ) ;
int udp_template_build(udp_payload_template_t *t , char *out , unsigned int len ,
                       struct ip *ip_hdr , struct udphdr *udp_hdr , aesrand_t *aes ) ;
int udp_template_field_lookup(char const   *vname , udp_payload_field_t *c ) ;
udp_payload_template_t *udp_template_load(uint8_t *buf , uint32_t buf_len , uint32_t *max_pkt_len ) ;
static uint8_t *udp_fixed_payload  =    (uint8_t *)((void *)0);
static size_t udp_fixed_payload_len  =    (size_t )0;
static udp_payload_template_t *udp_template  =    (udp_payload_template_t *)((void *)0);
char const   *udp_usage_error  =    "unknown UDP probe specification (expected file:/path or text:STRING or hex:01020304 or template:/path or template-fields)";
unsigned char const   *charset_alphanum  =    (unsigned char const   *)((unsigned char *)"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
unsigned char const   *charset_alpha  =    (unsigned char const   *)((unsigned char *)"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
unsigned char const   *charset_digit  =    (unsigned char const   *)((unsigned char *)"0123456789");
unsigned char const   charset_all[257]  =
  {      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )4,
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8,
        (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )12,
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )16,
        (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19,      (unsigned char const   )20,
        (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23,      (unsigned char const   )24,
        (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27,      (unsigned char const   )28,
        (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )32,
        (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )36,
        (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39,      (unsigned char const   )40,
        (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )44,
        (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47,      (unsigned char const   )48,
        (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51,      (unsigned char const   )52,
        (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55,      (unsigned char const   )56,
        (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59,      (unsigned char const   )60,
        (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )63,      (unsigned char const   )64,
        (unsigned char const   )65,      (unsigned char const   )66,      (unsigned char const   )67,      (unsigned char const   )68,
        (unsigned char const   )69,      (unsigned char const   )70,      (unsigned char const   )71,      (unsigned char const   )72,
        (unsigned char const   )73,      (unsigned char const   )74,      (unsigned char const   )75,      (unsigned char const   )76,
        (unsigned char const   )77,      (unsigned char const   )78,      (unsigned char const   )79,      (unsigned char const   )80,
        (unsigned char const   )81,      (unsigned char const   )82,      (unsigned char const   )83,      (unsigned char const   )84,
        (unsigned char const   )85,      (unsigned char const   )86,      (unsigned char const   )87,      (unsigned char const   )88,
        (unsigned char const   )89,      (unsigned char const   )90,      (unsigned char const   )91,      (unsigned char const   )92,
        (unsigned char const   )93,      (unsigned char const   )94,      (unsigned char const   )95,      (unsigned char const   )96,
        (unsigned char const   )97,      (unsigned char const   )98,      (unsigned char const   )99,      (unsigned char const   )100,
        (unsigned char const   )101,      (unsigned char const   )102,      (unsigned char const   )103,      (unsigned char const   )104,
        (unsigned char const   )105,      (unsigned char const   )106,      (unsigned char const   )107,      (unsigned char const   )108,
        (unsigned char const   )109,      (unsigned char const   )110,      (unsigned char const   )111,      (unsigned char const   )112,
        (unsigned char const   )113,      (unsigned char const   )114,      (unsigned char const   )115,      (unsigned char const   )116,
        (unsigned char const   )117,      (unsigned char const   )118,      (unsigned char const   )119,      (unsigned char const   )120,
        (unsigned char const   )121,      (unsigned char const   )122,      (unsigned char const   )123,      (unsigned char const   )124,
        (unsigned char const   )125,      (unsigned char const   )126,      (unsigned char const   )127,      (unsigned char const   )128,
        (unsigned char const   )129,      (unsigned char const   )130,      (unsigned char const   )131,      (unsigned char const   )132,
        (unsigned char const   )133,      (unsigned char const   )134,      (unsigned char const   )135,      (unsigned char const   )136,
        (unsigned char const   )137,      (unsigned char const   )138,      (unsigned char const   )139,      (unsigned char const   )140,
        (unsigned char const   )141,      (unsigned char const   )142,      (unsigned char const   )143,      (unsigned char const   )144,
        (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147,      (unsigned char const   )148,
        (unsigned char const   )149,      (unsigned char const   )150,      (unsigned char const   )151,      (unsigned char const   )152,
        (unsigned char const   )153,      (unsigned char const   )154,      (unsigned char const   )155,      (unsigned char const   )156,
        (unsigned char const   )157,      (unsigned char const   )158,      (unsigned char const   )159,      (unsigned char const   )160,
        (unsigned char const   )161,      (unsigned char const   )162,      (unsigned char const   )163,      (unsigned char const   )164,
        (unsigned char const   )165,      (unsigned char const   )166,      (unsigned char const   )167,      (unsigned char const   )168,
        (unsigned char const   )169,      (unsigned char const   )170,      (unsigned char const   )171,      (unsigned char const   )172,
        (unsigned char const   )173,      (unsigned char const   )174,      (unsigned char const   )175,      (unsigned char const   )176,
        (unsigned char const   )177,      (unsigned char const   )178,      (unsigned char const   )179,      (unsigned char const   )180,
        (unsigned char const   )181,      (unsigned char const   )182,      (unsigned char const   )183,      (unsigned char const   )184,
        (unsigned char const   )185,      (unsigned char const   )186,      (unsigned char const   )187,      (unsigned char const   )188,
        (unsigned char const   )189,      (unsigned char const   )190,      (unsigned char const   )191,      (unsigned char const   )192,
        (unsigned char const   )193,      (unsigned char const   )194,      (unsigned char const   )195,      (unsigned char const   )196,
        (unsigned char const   )197,      (unsigned char const   )198,      (unsigned char const   )199,      (unsigned char const   )200,
        (unsigned char const   )201,      (unsigned char const   )202,      (unsigned char const   )203,      (unsigned char const   )204,
        (unsigned char const   )205,      (unsigned char const   )206,      (unsigned char const   )207,      (unsigned char const   )208,
        (unsigned char const   )209,      (unsigned char const   )210,      (unsigned char const   )211,      (unsigned char const   )212,
        (unsigned char const   )213,      (unsigned char const   )214,      (unsigned char const   )215,      (unsigned char const   )216,
        (unsigned char const   )217,      (unsigned char const   )218,      (unsigned char const   )219,      (unsigned char const   )220,
        (unsigned char const   )221,      (unsigned char const   )222,      (unsigned char const   )223,      (unsigned char const   )224,
        (unsigned char const   )225,      (unsigned char const   )226,      (unsigned char const   )227,      (unsigned char const   )228,
        (unsigned char const   )229,      (unsigned char const   )230,      (unsigned char const   )231,      (unsigned char const   )232,
        (unsigned char const   )233,      (unsigned char const   )234,      (unsigned char const   )235,      (unsigned char const   )236,
        (unsigned char const   )237,      (unsigned char const   )238,      (unsigned char const   )239,      (unsigned char const   )240,
        (unsigned char const   )241,      (unsigned char const   )242,      (unsigned char const   )243,      (unsigned char const   )244,
        (unsigned char const   )245,      (unsigned char const   )246,      (unsigned char const   )247,      (unsigned char const   )248,
        (unsigned char const   )249,      (unsigned char const   )250,      (unsigned char const   )251,      (unsigned char const   )252,
        (unsigned char const   )253,      (unsigned char const   )254,      (unsigned char const   )255,      (unsigned char const   )0};
static int num_ports___1  ;
probe_module_t module_udp ;
static uint32_t udp_num_template_field_types  =    (uint32_t )12;
static udp_payload_field_type_def_t udp_payload_template_fields[12]  =
  {      {"SADDR_N", "Source IP address in network byte order", (size_t )4, (udp_payload_field_type_t )1},
        {"SADDR",
      "Source IP address in dotted-quad format", (size_t )15, (udp_payload_field_type_t )2},
        {"DADDR_N",
      "Destination IP address in network byte order", (size_t )4, (udp_payload_field_type_t )3},
        {"DADDR",
      "Destination IP address in dotted-quad format", (size_t )15, (udp_payload_field_type_t )4},
        {"SPORT_N",
      "UDP source port in netowrk byte order", (size_t )2, (udp_payload_field_type_t )5},
        {"SPORT",
      "UDP source port in ascii format", (size_t )5, (udp_payload_field_type_t )6},
        {"DPORT_N",
      "UDP destination port in network byte order", (size_t )2, (udp_payload_field_type_t )7},
        {"DPORT",
      "UDP destination port in ascii format", (size_t )5, (udp_payload_field_type_t )8},
        {"RAND_BYTE",
      "Random bytes from 0-255", (size_t )0, (udp_payload_field_type_t )9},
        {"RAND_DIGIT", "Random digits from 0-9", (size_t )0, (udp_payload_field_type_t )10},
        {"RAND_ALPHA",
      "Random mixed-case letters (a-z)", (size_t )0, (udp_payload_field_type_t )11},
        {"RAND_ALPHANUM",
      "Random mixed-case letters (a-z) and numbers", (size_t )0, (udp_payload_field_type_t )12}};
void udp_set_num_ports(int x )
{


  {
  num_ports___1 = x;
  return;
}
}
int udp_global_initialize(struct state_conf *conf )
{
  uint32_t udp_template_max_len ;
  char const   *args ;
  uint32_t i ;
  int tmp ;
  char const   *c ;
  char *tmp___0 ;
  size_t arg_name_len ;
  char *tmp___1 ;
  void *tmp___2 ;
  FILE *f ;
  FILE *tmp___3 ;
  uint8_t in[1472] ;
  FILE *f___0 ;
  FILE *tmp___4 ;
  size_t in_len ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  unsigned int n ;
  size_t i___0 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t header_len ;

  {
  udp_template_max_len = (uint32_t )0;
  num_ports___1 = ((int )conf->source_port_last - (int )conf->source_port_first) + 1;
  if (! conf->probe_args) {
    log_error("udp", "%s", "--probe-args are required, run --probe-module=udp --help for a longer description of the arguments");
    return (1);
  }
  args = (char const   *)conf->probe_args;
  tmp = strcmp(args, "template-fields");
  if (tmp == 0) {
    lock_file(stderr);
    __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s",
                  "List of allowed UDP template fields (name: description)\n\n");
    i = (uint32_t )0;
    while (i < udp_num_template_field_types) {
      __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s: %s\n",
                    udp_payload_template_fields[i].name, udp_payload_template_fields[i].desc);
      i ++;
    }
    __fprintf_chk((FILE * __restrict  )stderr, 1, (char const   * __restrict  )"%s\n",
                  "");
    fflush(stderr);
    unlock_file(stderr);
    exit(0);
  }
  tmp___0 = strchr(args, ':');
  c = (char const   *)tmp___0;
  if (! c) {
    log_fatal("udp", udp_usage_error);
  }
  arg_name_len = (size_t )(c - args);
  c ++;
  tmp___12 = strncmp(args, "text", arg_name_len);
  if (tmp___12 == 0) {
    tmp___1 = strdup(c);
    udp_fixed_payload = (uint8_t *)tmp___1;
    udp_fixed_payload_len = strlen(c);
  } else {
    tmp___11 = strncmp(args, "file", arg_name_len);
    if (tmp___11 == 0) {
      tmp___2 = xmalloc((size_t )1472);
      udp_fixed_payload = (uint8_t *)tmp___2;
      tmp___3 = fopen((char const   * __restrict  )c, (char const   * __restrict  )"rb");
      f = tmp___3;
      if (! f) {
        log_fatal("udp", "could not open UDP data file \'%s\'\n", c);
      }
      udp_fixed_payload_len = fread((void * __restrict  )udp_fixed_payload, (size_t )1,
                                    (size_t )1472, (FILE * __restrict  )f);
      fclose(f);
    } else {
      tmp___10 = strncmp(args, "template", arg_name_len);
      if (tmp___10 == 0) {
        tmp___4 = fopen((char const   * __restrict  )c, (char const   * __restrict  )"rb");
        f___0 = tmp___4;
        if (! f___0) {
          log_fatal("udp", "could not open UDP data file \'%s\'\n", c);
        }
        tmp___5 = fread((void * __restrict  )(in), (size_t )1, (size_t )1472, (FILE * __restrict  )f___0);
        in_len = tmp___5;
        fclose(f___0);
        udp_template = udp_template_load(in, (uint32_t )in_len, & udp_template_max_len);
        module_udp.make_packet = & udp_make_templated_packet;
      } else {
        tmp___9 = strncmp(args, "hex", arg_name_len);
        if (tmp___9 == 0) {
          tmp___6 = strlen(c);
          udp_fixed_payload_len = tmp___6 / 2UL;
          tmp___7 = xmalloc(udp_fixed_payload_len);
          udp_fixed_payload = (uint8_t *)tmp___7;
          i___0 = (size_t )0;
          while (i___0 < udp_fixed_payload_len) {
            tmp___8 = sscanf((char const   * __restrict  )(c + i___0 * 2UL), (char const   * __restrict  )"%2x",
                             & n);
            if (tmp___8 != 1) {
              log_fatal("udp", "non-hex character: \'%c\'", (int const   )*(c + i___0 * 2UL));
            }
            *(udp_fixed_payload + i___0) = (uint8_t )(n & 255U);
            i___0 ++;
          }
        } else {
          log_fatal("udp", udp_usage_error);
        }
      }
    }
  }
  if (udp_fixed_payload_len > 1472UL) {
    log_warn("udp", "warning: reducing fixed UDP payload to %d bytes (from %d) to fit on the wire\n",
             1472, udp_fixed_payload_len);
    udp_fixed_payload_len = (size_t )1472;
  }
  header_len = (sizeof(struct ether_header ) + sizeof(struct ip )) + sizeof(struct udphdr );
  if (udp_fixed_payload_len > 0UL) {
    module_udp.max_packet_length = header_len + udp_fixed_payload_len;
  } else
  if (udp_template_max_len > 0U) {
    module_udp.max_packet_length = header_len + (size_t )udp_template_max_len;
  }
  if (! module_udp.max_packet_length) {
    __assert_fail("module_udp.max_packet_length", "src/probe_modules/module_udp.c",
                  224U, "udp_global_initialize");
  }
  if (! (module_udp.max_packet_length <= 4096UL)) {
    __assert_fail("module_udp.max_packet_length <= MAX_PACKET_SIZE", "src/probe_modules/module_udp.c",
                  225U, "udp_global_initialize");
  }
  return (0);
}
}
int udp_global_cleanup(struct state_conf *zconf___0  __attribute__((__unused__)) ,
                       struct state_send *zsend___0  __attribute__((__unused__)) ,
                       struct state_recv *zrecv___0  __attribute__((__unused__)) )
{


  {
  if (udp_fixed_payload) {
    free((void *)udp_fixed_payload);
    udp_fixed_payload = (uint8_t *)((void *)0);
  }
  if (udp_template) {
    udp_template_free(udp_template);
    udp_template = (udp_payload_template_t *)((void *)0);
  }
  return (0);
}
}
int udp_init_perthread(void *buf , macaddr_t *src , macaddr_t *gw , port_h_t dst_port  __attribute__((__unused__)) ,
                       void **arg_ptr )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  uint16_t ip_len ;
  __uint16_t tmp ;
  struct udphdr *udp_header ;
  uint16_t udp_len ;
  void *payload ;
  uint32_t seed ;
  uint64_t tmp___0 ;
  aesrand_t *aes ;
  aesrand_t *tmp___1 ;

  {
  memset(buf, 0, (size_t )4096);
  eth_header = (struct ether_header *)buf;
  make_eth_header(eth_header, src, gw);
  ip_header = (struct ip *)(eth_header + 1);
  tmp = __bswap_16((__uint16_t )((sizeof(struct ip ) + sizeof(struct udphdr )) + udp_fixed_payload_len));
  ip_len = tmp;
  make_ip_header(ip_header, (uint8_t )17, ip_len);
  udp_header = (struct udphdr *)(ip_header + 1);
  udp_len = (uint16_t )(sizeof(struct udphdr ) + udp_fixed_payload_len);
  make_udp_header(udp_header, zconf.target_port, udp_len);
  if (udp_fixed_payload) {
    payload = (void *)(udp_header + 1);
    memcpy((void * __restrict  )payload, (void const   * __restrict  )udp_fixed_payload,
           udp_fixed_payload_len);
  }
  tmp___0 = aesrand_getword(zconf.aes);
  seed = (uint32_t )tmp___0;
  tmp___1 = aesrand_init_from_seed((uint64_t )seed);
  aes = tmp___1;
  *arg_ptr = (void *)aes;
  return (0);
}
}
int udp_make_packet(void *buf , size_t *buf_len , ipaddr_n_t src_ip , ipaddr_n_t dst_ip ,
                    uint8_t ttl , uint32_t *validation , int probe_num , void *arg  __attribute__((__unused__)) )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  struct udphdr *udp_header ;
  size_t headers_len ;
  uint16_t tmp ;

  {
  eth_header = (struct ether_header *)buf;
  ip_header = (struct ip *)(eth_header + 1);
  udp_header = (struct udphdr *)(ip_header + 1);
  headers_len = (sizeof(struct ether_header ) + sizeof(struct ip )) + sizeof(struct udphdr );
  ip_header->ip_src.s_addr = src_ip;
  ip_header->ip_dst.s_addr = dst_ip;
  ip_header->ip_ttl = ttl;
  tmp = get_src_port(num_ports___1, probe_num, validation);
  udp_header->__annonCompField5.__annonCompField3.uh_sport = __bswap_16(tmp);
  ip_header->ip_sum = (unsigned short)0;
  ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
  *buf_len = headers_len + udp_fixed_payload_len;
  return (0);
}
}
int udp_make_templated_packet(void *buf , size_t *buf_len , ipaddr_n_t src_ip , ipaddr_n_t dst_ip ,
                              uint8_t ttl , uint32_t *validation , int probe_num ,
                              void *arg )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  struct udphdr *udp_header ;
  size_t headers_len ;
  uint16_t tmp ;
  char *payload ;
  aesrand_t *aes ;
  int payload_len ;
  int tmp___0 ;

  {
  eth_header = (struct ether_header *)buf;
  ip_header = (struct ip *)(eth_header + 1);
  udp_header = (struct udphdr *)(ip_header + 1);
  headers_len = (sizeof(struct ether_header ) + sizeof(struct ip )) + sizeof(struct udphdr );
  ip_header->ip_src.s_addr = src_ip;
  ip_header->ip_dst.s_addr = dst_ip;
  ip_header->ip_ttl = ttl;
  tmp = get_src_port(num_ports___1, probe_num, validation);
  udp_header->__annonCompField5.__annonCompField3.uh_sport = __bswap_16(tmp);
  payload = (char *)(udp_header + 1);
  memset((void *)payload, 0, (size_t )1472);
  aes = (aesrand_t *)arg;
  tmp___0 = udp_template_build(udp_template, payload, 1472U, ip_header, udp_header,
                               aes);
  payload_len = tmp___0;
  if (payload_len <= 0) {
    log_fatal("udp", "UDP payload template generated an empty payload");
  }
  ip_header->ip_len = __bswap_16((__uint16_t )((sizeof(struct ip ) + sizeof(struct udphdr )) + (unsigned long )payload_len));
  udp_header->__annonCompField5.__annonCompField3.uh_ulen = __bswap_16((__uint16_t )(sizeof(struct udphdr ) + (unsigned long )payload_len));
  ip_header->ip_sum = (unsigned short)0;
  ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
  *buf_len = headers_len + (size_t )payload_len;
  return (0);
}
}
void udp_print_packet(FILE *fp , void *packet )
{
  struct ether_header *ethh ;
  struct ip *iph ;
  struct udphdr *udph ;
  __uint16_t tmp ;
  __uint16_t tmp___0 ;
  __uint16_t tmp___1 ;

  {
  ethh = (struct ether_header *)packet;
  iph = (struct ip *)(ethh + 1);
  udph = (struct udphdr *)(iph + 1);
  tmp = __bswap_16(udph->__annonCompField5.__annonCompField3.uh_sum);
  tmp___0 = __bswap_16(udph->__annonCompField5.__annonCompField3.uh_dport);
  tmp___1 = __bswap_16(udph->__annonCompField5.__annonCompField3.uh_sport);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"udp { source: %u | dest: %u | checksum: %#04X }\n",
                (int )tmp___1, (int )tmp___0, (int )tmp);
  fprintf_ip_header(fp, iph);
  fprintf_eth_header(fp, ethh);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"------------------------------------------------------\n");
  return;
}
}
void udp_process_packet(u_char const   *packet , uint32_t len  __attribute__((__unused__)) ,
                        fieldset_t *fs , uint32_t *validation  __attribute__((__unused__)) ,
                        struct timespec ts  __attribute__((__unused__)) )
{
  struct ip *ip_hdr ;
  struct udphdr *udp ;
  struct udphdr *tmp ;
  __uint16_t tmp___0 ;
  __uint16_t tmp___1 ;
  __uint16_t tmp___2 ;
  uint16_t data_len ;
  __uint16_t tmp___3 ;
  uint32_t overhead ;
  uint32_t max_rlen ;
  uint32_t max_ilen ;
  __uint16_t tmp___4 ;

  {
  ip_hdr = (struct ip *)(packet + sizeof(struct ether_header ));
  if ((int )ip_hdr->ip_p == 17) {
    tmp = get_udp_header((struct ip  const  *)ip_hdr, len);
    udp = tmp;
    fs_add_constchar(fs, "classification", "udp");
    fs_add_bool(fs, "success", 1);
    tmp___0 = __bswap_16(udp->__annonCompField5.__annonCompField3.uh_sport);
    fs_add_uint64(fs, "sport", (uint64_t )tmp___0);
    tmp___1 = __bswap_16(udp->__annonCompField5.__annonCompField3.uh_dport);
    fs_add_uint64(fs, "dport", (uint64_t )tmp___1);
    tmp___2 = __bswap_16(udp->__annonCompField5.__annonCompField3.uh_ulen);
    fs_add_uint64(fs, "udp_pkt_size", (uint64_t )tmp___2);
    tmp___3 = __bswap_16(udp->__annonCompField5.__annonCompField3.uh_ulen);
    data_len = tmp___3;
    if ((unsigned long )data_len > sizeof(struct udphdr )) {
      overhead = (uint32_t )(sizeof(struct udphdr ) + (unsigned long )(ip_hdr->ip_hl * 4U));
      max_rlen = len - overhead;
      tmp___4 = __bswap_16(ip_hdr->ip_len);
      max_ilen = (uint32_t )tmp___4 - overhead;
      if ((uint32_t )data_len > max_rlen) {
        data_len = (uint16_t )max_rlen;
      }
      if ((uint32_t )data_len > max_ilen) {
        data_len = (uint16_t )max_ilen;
      }
      fs_add_binary(fs, "data", (size_t )data_len, (void *)(udp + 1), 0);
    } else {
      fs_add_null(fs, "data");
    }
    fs_add_null_icmp(fs);
  } else
  if ((int )ip_hdr->ip_p == 1) {
    fs_add_constchar(fs, "classification", "icmp");
    fs_add_bool(fs, "success", 0);
    fs_add_null(fs, "sport");
    fs_add_null(fs, "dport");
    fs_add_null(fs, "udp_pkt_size");
    fs_add_null(fs, "data");
    fs_populate_icmp_from_iphdr(ip_hdr, (size_t )len, fs);
  } else {
    fs_add_constchar(fs, "classification", "other");
    fs_add_bool(fs, "success", 0);
    fs_add_null(fs, "sport");
    fs_add_null(fs, "dport");
    fs_add_null(fs, "udp_pkt_size");
    fs_add_null(fs, "data");
    fs_add_null_icmp(fs);
  }
  return;
}
}
int udp_validate_packet(struct ip  const  *ip_hdr , uint32_t len , uint32_t *src_ip ,
                        uint32_t *validation )
{
  int tmp ;

  {
  tmp = udp_do_validate_packet(ip_hdr, len, src_ip, validation, num_ports___1, -1);
  return (tmp);
}
}
int udp_do_validate_packet(struct ip  const  *ip_hdr , uint32_t len , uint32_t *src_ip  __attribute__((__unused__)) ,
                           uint32_t *validation , int num_ports___6 , int expected_port )
{
  struct udphdr *udp ;
  struct udphdr *tmp ;
  uint16_t dport ;
  __uint16_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t ep ;
  uint16_t sport ;
  __uint16_t tmp___3 ;
  struct ip *ip_inner ;
  size_t ip_inner_len ;
  int tmp___4 ;
  struct udphdr *udp___0 ;
  struct udphdr *tmp___5 ;
  uint16_t dport___0 ;
  __uint16_t tmp___6 ;
  uint16_t sport___0 ;
  __uint16_t tmp___7 ;
  int tmp___8 ;

  {
  if ((int const   )ip_hdr->ip_p == 17) {
    tmp = get_udp_header(ip_hdr, len);
    udp = tmp;
    if (! udp) {
      return (0);
    }
    tmp___0 = __bswap_16(udp->__annonCompField5.__annonCompField3.uh_dport);
    dport = tmp___0;
    tmp___1 = check_dst_port(dport, num_ports___6, validation);
    if (! tmp___1) {
      return (0);
    }
    tmp___2 = blocklist_is_allowed(*src_ip);
    if (! tmp___2) {
      return (0);
    }
    if (expected_port != -1) {
      ep = (uint16_t )expected_port;
      tmp___3 = __bswap_16(udp->__annonCompField5.__annonCompField3.uh_sport);
      sport = tmp___3;
      if ((int )sport != (int )ep) {
        return (0);
      }
    }
  } else
  if ((int const   )ip_hdr->ip_p == 1) {
    tmp___4 = icmp_helper_validate(ip_hdr, len, sizeof(struct udphdr ), & ip_inner,
                                   & ip_inner_len);
    tmp___5 = get_udp_header((struct ip  const  *)ip_inner, (uint32_t )ip_inner_len);
    udp___0 = tmp___5;
    tmp___6 = __bswap_16(udp___0->__annonCompField5.__annonCompField3.uh_dport);
    dport___0 = tmp___6;
    tmp___7 = __bswap_16(udp___0->__annonCompField5.__annonCompField3.uh_sport);
    sport___0 = tmp___7;
    if ((int )dport___0 != (int )zconf.target_port) {
      return (0);
    }
    tmp___8 = check_dst_port(sport___0, num_ports___6, validation);
    if (! tmp___8) {
      return (0);
    }
  } else {
    return (0);
  }
  return (1);
}
}
void udp_template_add_field(udp_payload_template_t *t , udp_payload_field_type_t ftype ,
                            unsigned int length , char *data )
{
  udp_payload_field_t *c ;
  void *tmp ;
  void *tmp___0 ;

  {
  (t->fcount) ++;
  tmp = xrealloc((void *)t->fields, sizeof(udp_payload_field_t ) * (unsigned long )t->fcount);
  t->fields = (struct udp_payload_field **)tmp;
  tmp___0 = xmalloc(sizeof(udp_payload_field_t ));
  *(t->fields + (t->fcount - 1U)) = (struct udp_payload_field *)tmp___0;
  c = *(t->fields + (t->fcount - 1U));
  if (! c) {
    __assert_fail("c", "src/probe_modules/module_udp.c", 486U, "udp_template_add_field");
  }
  c->ftype = ftype;
  c->length = (size_t )length;
  c->data = data;
  return;
}
}
void udp_template_free(udp_payload_template_t *t )
{
  unsigned int x ;

  {
  x = 0U;
  while (x < t->fcount) {
    if ((*(t->fields + x))->data) {
      free((void *)(*(t->fields + x))->data);
      (*(t->fields + x))->data = (char *)((void *)0);
    }
    free((void *)*(t->fields + x));
    *(t->fields + x) = (struct udp_payload_field *)((void *)0);
    x ++;
  }
  free((void *)t->fields);
  t->fields = (struct udp_payload_field **)((void *)0);
  t->fcount = 0U;
  free((void *)t);
  return;
}
}
int udp_random_bytes(char *dst , int len , unsigned char const   *charset , int charset_len ,
                     aesrand_t *aes )
{
  int i ;
  char *tmp ;
  uint64_t tmp___0 ;

  {
  i = 0;
  while (i < len) {
    tmp = dst;
    dst ++;
    tmp___0 = aesrand_getword(aes);
    *tmp = (char )*(charset + (tmp___0 & 4294967295UL) % (unsigned long )charset_len);
    i ++;
  }
  return (i);
}
}
int udp_template_build(udp_payload_template_t *t , char *out , unsigned int len ,
                       struct ip *ip_hdr , struct udphdr *udp_hdr , aesrand_t *aes )
{
  udp_payload_field_t *c ;
  char *p ;
  char *max ;
  char tmp[256] ;
  int full ;
  unsigned int x ;
  unsigned int y ;
  uint32_t *u32 ;
  uint16_t *u16 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  __uint16_t tmp___8 ;
  unsigned long tmp___9 ;
  int tmp___10 ;
  __uint16_t tmp___11 ;
  unsigned long tmp___12 ;
  int tmp___13 ;

  {
  full = 0;
  max = out + len;
  p = out;
  x = 0U;
  while (x < t->fcount) {
    c = *(t->fields + x);
    if ((unsigned long )(p + c->length) >= (unsigned long )max) {
      full = 1;
      return (0);
    }
    switch ((unsigned int )c->ftype) {
    case 0U:
    if (c->data) {
      if (! c->length) {
        break;
      }
    } else {
      break;
    }
    memcpy((void * __restrict  )p, (void const   * __restrict  )c->data, c->length);
    p += c->length;
    break;
    case 10U:
    tmp___0 = udp_random_bytes(p, (int )c->length, charset_digit, 10, aes);
    p += tmp___0;
    break;
    case 11U:
    tmp___1 = udp_random_bytes(p, (int )c->length, charset_alpha, 52, aes);
    p += tmp___1;
    break;
    case 12U:
    tmp___2 = udp_random_bytes(p, (int )c->length, charset_alphanum, 62, aes);
    p += tmp___2;
    break;
    case 9U:
    tmp___3 = udp_random_bytes(p, (int )c->length, charset_all, 256, aes);
    p += tmp___3;
    break;
    case 2U:
    if ((unsigned long )(p + 15) >= (unsigned long )max) {
      full = 1;
      break;
    }
    inet_ntop(2, (void const   * __restrict  )((char *)(& ip_hdr->ip_src)), (char * __restrict  )(tmp),
              (socklen_t )(sizeof(tmp) - 1UL));
    tmp___4 = strlen((char const   *)(tmp));
    memcpy((void * __restrict  )p, (void const   * __restrict  )(tmp), tmp___4);
    tmp___5 = strlen((char const   *)(tmp));
    p += tmp___5;
    break;
    case 4U:
    if ((unsigned long )(p + 15) >= (unsigned long )max) {
      full = 1;
      break;
    }
    inet_ntop(2, (void const   * __restrict  )((char *)(& ip_hdr->ip_dst)), (char * __restrict  )(tmp),
              (socklen_t )(sizeof(tmp) - 1UL));
    tmp___6 = strlen((char const   *)(tmp));
    memcpy((void * __restrict  )p, (void const   * __restrict  )(tmp), tmp___6);
    tmp___7 = strlen((char const   *)(tmp));
    p += tmp___7;
    break;
    case 1U:
    if ((unsigned long )(p + 4) >= (unsigned long )max) {
      full = 1;
      break;
    }
    u32 = (uint32_t *)p;
    *u32 = ip_hdr->ip_src.s_addr;
    p += 4;
    break;
    case 3U:
    if ((unsigned long )(p + 4) >= (unsigned long )max) {
      full = 1;
      break;
    }
    u32 = (uint32_t *)p;
    *u32 = ip_hdr->ip_dst.s_addr;
    p += 4;
    break;
    case 5U:
    if ((unsigned long )(p + 2) >= (unsigned long )max) {
      full = 1;
      break;
    }
    u16 = (uint16_t *)p;
    *u16 = udp_hdr->__annonCompField5.__annonCompField3.uh_sport;
    p += 2;
    break;
    case 7U:
    if ((unsigned long )(p + 2) >= (unsigned long )max) {
      full = 1;
      break;
    }
    u16 = (uint16_t *)p;
    *u16 = udp_hdr->__annonCompField5.__annonCompField3.uh_sport;
    p += 2;
    break;
    case 6U:
    if ((unsigned long )(p + 5) >= (unsigned long )max) {
      full = 1;
      break;
    }
    tmp___8 = __bswap_16(udp_hdr->__annonCompField5.__annonCompField3.uh_sport);
    tmp___9 = __builtin_object_size((void *)(tmp), 1);
    tmp___10 = __builtin___snprintf_chk(tmp, 6UL, 1, tmp___9, "%d", (int )tmp___8);
    y = (unsigned int )tmp___10;
    memcpy((void * __restrict  )p, (void const   * __restrict  )(tmp), (size_t )y);
    p += y;
    break;
    case 8U:
    if ((unsigned long )(p + 5) >= (unsigned long )max) {
      full = 1;
      break;
    }
    tmp___11 = __bswap_16(udp_hdr->__annonCompField5.__annonCompField3.uh_sport);
    tmp___12 = __builtin_object_size((void *)(tmp), 1);
    tmp___13 = __builtin___snprintf_chk(tmp, 6UL, 1, tmp___12, "%d", (int )tmp___11);
    y = (unsigned int )tmp___13;
    memcpy((void * __restrict  )p, (void const   * __restrict  )(tmp), (size_t )y);
    p += y;
    break;
    }
    if (full == 1) {
      return (0);
    }
    x ++;
  }
  return ((int )(p - out));
}
}
static unsigned long const   fcount  =    (size_t const   )(sizeof(udp_payload_template_fields) / sizeof(udp_payload_template_fields[0]));
int udp_template_field_lookup(char const   *vname ,
                              udp_payload_field_t *c )
{
  size_t vname_len ;
  size_t tmp ;
  size_t type_name_len ;
  char const   *param ;
  char *tmp___0 ;
  long olen ;
  char *end ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  unsigned int f ;
  udp_payload_field_type_def_t const   *ftype ;
  int tmp___5 ;
  size_t tmp___6 ;

  {
  tmp = strlen(vname);
  vname_len = tmp;
  type_name_len = vname_len;
  tmp___0 = strstr(vname, "=");
  param = (char const   *)tmp___0;
  if (param) {
    type_name_len = (size_t )(param - vname);
    param ++;
  }
  olen = 0L;
  if (param) {
    if (! *param) {
      log_fatal("udp", "invalid template: field spec %s is invalid (missing length)",
                vname);
    }
  }
  if (param) {
    end = (char *)((void *)0);
    tmp___1 = __errno_location();
    *tmp___1 = 0;
    olen = strtol((char const   * __restrict  )param, (char ** __restrict  )(& end),
                  10);
    tmp___4 = __errno_location();
    if (*tmp___4) {
      tmp___2 = __errno_location();
      tmp___3 = strerror(*tmp___2);
      log_fatal("udp", "invalid template: unable to read length from %s: %s", vname,
                tmp___3);
    }
    if (! end) {
      log_fatal("udp", "invalid template: unable to read length from %s", vname);
    } else
    if ((unsigned long )end != (unsigned long )(vname + vname_len)) {
      log_fatal("udp", "invalid template: unable to read length from %s", vname);
    }
    if (olen < 0L) {
      log_fatal("udp", "invalid template: field size %d is larger than the max (%d)",
                olen, 1472);
    } else
    if (olen > 1472L) {
      log_fatal("udp", "invalid template: field size %d is larger than the max (%d)",
                olen, 1472);
    }
  }
  f = 0U;
  while ((unsigned long const   )f < fcount) {
    ftype = (udp_payload_field_type_def_t const   *)(& udp_payload_template_fields[f]);
    tmp___5 = strncmp(vname, (char const   *)ftype->name, type_name_len);
    if (tmp___5 == 0) {
      tmp___6 = strlen((char const   *)ftype->name);
      if (tmp___6 == type_name_len) {
        c->ftype = (enum udp_payload_field_type )ftype->ftype;
        if (ftype->max_length) {
          c->length = (size_t )ftype->max_length;
        } else {
          c->length = (size_t )olen;
        }
        c->data = (char *)((void *)0);
        return (1);
      }
    }
    f ++;
  }
  return (0);
}
}
udp_payload_template_t *udp_template_load(uint8_t *buf , uint32_t buf_len , uint32_t *max_pkt_len )
{
  udp_payload_template_t *t ;
  void *tmp ;
  uint32_t _max_pkt_len ;
  uint8_t *dollar ;
  uint8_t *lbrack ;
  uint8_t *s ;
  uint8_t *p ;
  char *tmp___0 ;
  unsigned int tlen ;
  udp_payload_field_t c ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
  tmp = xmalloc(sizeof(udp_payload_template_t ));
  t = (udp_payload_template_t *)tmp;
  _max_pkt_len = (uint32_t )0;
  dollar = (uint8_t *)((void *)0);
  lbrack = (uint8_t *)((void *)0);
  s = buf;
  p = buf;
  t->fcount = 0U;
  t->fields = (struct udp_payload_field **)((void *)0);
  while ((unsigned long )p < (unsigned long )(buf + buf_len)) {
    switch ((int )*p) {
    case 36:
    if (dollar) {
      if (! lbrack) {
        dollar = p;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */
    if (! dollar) {
      dollar = p;
    }
    p ++;
    continue;
    case 123:
    if (dollar) {
      if (! lbrack) {
        lbrack = p;
      }
    }
    p ++;
    continue;
    case 125:
    if (dollar) {
      if (! lbrack) {
        p ++;
        continue;
      }
    } else {
      p ++;
      continue;
    }
    tlen = (unsigned int )(dollar - s);
    if (tlen > 0U) {
      tmp___1 = xmalloc((size_t )tlen);
      tmp___0 = (char *)tmp___1;
      memcpy((void * __restrict  )tmp___0, (void const   * __restrict  )s, (size_t )tlen);
      udp_template_add_field(t, (udp_payload_field_type_t )0, tlen, tmp___0);
      _max_pkt_len += tlen;
    }
    tmp___2 = xcalloc((size_t )1, (size_t )(p - lbrack));
    tmp___0 = (char *)tmp___2;
    memcpy((void * __restrict  )tmp___0, (void const   * __restrict  )(lbrack + 1),
           (size_t )((p - lbrack) - 1L));
    tmp___3 = udp_template_field_lookup((char const   *)tmp___0, & c);
    if (tmp___3) {
      udp_template_add_field(t, c.ftype, (unsigned int )c.length, c.data);
      _max_pkt_len = (uint32_t )((size_t )_max_pkt_len + c.length);
      s = p + 1;
    } else {
      s = dollar;
    }
    free((void *)tmp___0);
    break;
    default:
    if (dollar) {
      if (lbrack) {
        p ++;
        continue;
      }
    }
    }
    dollar = (uint8_t *)((void *)0);
    lbrack = (uint8_t *)((void *)0);
    p ++;
  }
  if ((unsigned long )s < (unsigned long )p) {
    tlen = (unsigned int )(p - s);
    tmp___4 = xmalloc((size_t )tlen);
    tmp___0 = (char *)tmp___4;
    memcpy((void * __restrict  )tmp___0, (void const   * __restrict  )s, (size_t )tlen);
    udp_template_add_field(t, (udp_payload_field_type_t )0, tlen, tmp___0);
    _max_pkt_len += tlen;
  }
  *max_pkt_len = _max_pkt_len;
  return (t);
}
}
static fielddef_t fields___3[10]  =
  {      {"classification", "string", "packet classification"},
        {"success", "bool", "is response considered success"},
        {"sport", "int", "UDP source port"},
        {"dport", "int", "UDP destination port"},
        {"udp_pkt_size", "int", "UDP packet length"},
        {"data", "binary", "UDP payload"},
        {"icmp_responder", "string", "Source IP of ICMP_UNREACH messages"},
        {"icmp_type", "int", "icmp message type"},
        {"icmp_code", "int", "icmp message sub type code"},
        {"icmp_unreach_str", "string", "for icmp_unreach responses, the string version of icmp_code (e.g. network-unreach)"}};
probe_module_t module_udp  =
     {"udp", (size_t )0, "udp || icmp", (size_t )1500, (uint8_t )1, & udp_global_initialize,
    & udp_init_perthread, & udp_make_packet, & udp_print_packet, & udp_validate_packet,
    (void (*)(u_char const   *packetbuf , uint32_t len , fieldset_t * , uint32_t *validation ,
              struct timespec  const  ts ))(& udp_process_packet), & udp_global_cleanup,
    0, fields___3, (int )(sizeof(fields___3) / sizeof(fields___3[0])), "Probe module that sends UDP packets to hosts. Packets can optionally be templated based on destination host. Specify packet file with --probe-args=file:/path_to_packet_file and templates with template:/path_to_template_file."};
#pragma merger("0","/tmp/cil-bHI_Md2T.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern  __attribute__((__nothrow__)) long random(void) ;
__inline static struct ip *get_inner_ip_header(struct icmp  const  *icmp , uint32_t len )
{


  {
  if ((unsigned long )len < 8UL + sizeof(struct ip )) {
    return ((struct ip *)((void *)0));
  }
  return ((struct ip *)((char *)icmp + 8));
}
}
char *make_ip_str(uint32_t ip ) ;
char const   *icmp_unreach_strings[16] ;
void print_macaddr(struct ifreq *i )
{


  {
  __printf_chk(1, (char const   * __restrict  )"Device %s -> Ethernet %02x:%02x:%02x:%02x:%02x:%02x\n",
               i->ifr_ifrn.ifrn_name, (int )*((unsigned char *)(& i->ifr_ifru.ifru_addr.sa_data) + 0),
               (int )*((unsigned char *)(& i->ifr_ifru.ifru_addr.sa_data) + 1), (int )*((unsigned char *)(& i->ifr_ifru.ifru_addr.sa_data) + 2),
               (int )*((unsigned char *)(& i->ifr_ifru.ifru_addr.sa_data) + 3), (int )*((unsigned char *)(& i->ifr_ifru.ifru_addr.sa_data) + 4),
               (int )*((unsigned char *)(& i->ifr_ifru.ifru_addr.sa_data) + 5));
  return;
}
}
void fprintf_ip_header(FILE *fp , struct ip *iph )
{
  struct in_addr *s ;
  struct in_addr *d ;
  char srcip[21] ;
  char dstip[21] ;
  char *tmp ;
  char *tmp___0 ;
  __uint16_t tmp___1 ;

  {
  s = & iph->ip_src;
  d = & iph->ip_dst;
  tmp = inet_ntoa(*s);
  strncpy((char * __restrict  )(srcip), (char const   * __restrict  )tmp, (size_t )19);
  tmp___0 = inet_ntoa(*d);
  strncpy((char * __restrict  )(dstip), (char const   * __restrict  )tmp___0, (size_t )19);
  srcip[20] = (char )'\000';
  dstip[20] = (char )'\000';
  tmp___1 = __bswap_16(iph->ip_sum);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"ip { saddr: %s | daddr: %s | checksum: %#04X }\n",
                srcip, dstip, (int )tmp___1);
  return;
}
}
void fprintf_eth_header(FILE *fp , struct ether_header *ethh )
{


  {
  if (! zconf.send_ip_pkts) {
    __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"eth { shost: %02x:%02x:%02x:%02x:%02x:%02x | dhost: %02x:%02x:%02x:%02x:%02x:%02x }\n",
                  (int )ethh->ether_shost[0], (int )ethh->ether_shost[1], (int )ethh->ether_shost[2],
                  (int )ethh->ether_shost[3], (int )ethh->ether_shost[4], (int )ethh->ether_shost[5],
                  (int )ethh->ether_dhost[0], (int )ethh->ether_dhost[1], (int )ethh->ether_dhost[2],
                  (int )ethh->ether_dhost[3], (int )ethh->ether_dhost[4], (int )ethh->ether_dhost[5]);
  }
  return;
}
}
void make_eth_header(struct ether_header *ethh , macaddr_t *src , macaddr_t *dst )
{


  {
  memcpy((void * __restrict  )(ethh->ether_shost), (void const   * __restrict  )src,
         (size_t )6);
  memcpy((void * __restrict  )(ethh->ether_dhost), (void const   * __restrict  )dst,
         (size_t )6);
  ethh->ether_type = __bswap_16((__uint16_t )2048);
  return;
}
}
void make_ip_header(struct ip *iph , uint8_t protocol , uint16_t len )
{


  {
  iph->ip_hl = 5U;
  iph->ip_v = 4U;
  iph->ip_tos = (uint8_t )0;
  iph->ip_len = len;
  iph->ip_id = __bswap_16((__uint16_t )54321);
  iph->ip_off = (unsigned short)0;
  iph->ip_ttl = (uint8_t )255;
  iph->ip_p = protocol;
  iph->ip_sum = (unsigned short)0;
  return;
}
}
void make_icmp_header(struct icmp *buf )
{


  {
  memset((void *)buf, 0, sizeof(struct icmp ));
  buf->icmp_type = (uint8_t )8;
  buf->icmp_code = (uint8_t )0;
  buf->icmp_hun.ih_idseq.icd_seq = (uint16_t )0;
  return;
}
}
void make_tcp_header(struct tcphdr *tcp_header , port_h_t dest_port , uint16_t th_flags )
{
  long tmp ;

  {
  tmp = random();
  tcp_header->__annonCompField8.__annonCompField6.th_seq = (tcp_seq )tmp;
  tcp_header->__annonCompField8.__annonCompField6.th_ack = (tcp_seq )0;
  tcp_header->__annonCompField8.__annonCompField6.th_x2 = (uint8_t )0;
  tcp_header->__annonCompField8.__annonCompField6.th_off = (uint8_t )5;
  tcp_header->__annonCompField8.__annonCompField6.th_flags = (uint8_t )0;
  tcp_header->__annonCompField8.__annonCompField6.th_flags = (uint8_t )((int )tcp_header->__annonCompField8.__annonCompField6.th_flags | (int )th_flags);
  tcp_header->__annonCompField8.__annonCompField6.th_win = __bswap_16((__uint16_t )65535);
  tcp_header->__annonCompField8.__annonCompField6.th_sum = (uint16_t )0;
  tcp_header->__annonCompField8.__annonCompField6.th_urp = (uint16_t )0;
  tcp_header->__annonCompField8.__annonCompField6.th_dport = __bswap_16(dest_port);
  return;
}
}
size_t set_mss_option(struct tcphdr *tcp_header )
{
  size_t header_size ;
  uint8_t *base ;
  uint8_t *last_opt ;

  {
  header_size = (size_t )((int )tcp_header->__annonCompField8.__annonCompField6.th_off * 4);
  base = (uint8_t *)tcp_header;
  last_opt = base + header_size;
  *(last_opt + 0) = (uint8_t )2;
  *(last_opt + 1) = (uint8_t )4;
  *(last_opt + 2) = (uint8_t )5;
  *(last_opt + 3) = (uint8_t )180;
  tcp_header->__annonCompField8.__annonCompField6.th_off = (uint8_t )((int )tcp_header->__annonCompField8.__annonCompField6.th_off + 1);
  return ((size_t )((int )tcp_header->__annonCompField8.__annonCompField6.th_off * 4));
}
}
void make_udp_header(struct udphdr *udp_header , port_h_t dest_port , uint16_t len )
{


  {
  udp_header->__annonCompField5.__annonCompField3.uh_dport = __bswap_16(dest_port);
  udp_header->__annonCompField5.__annonCompField3.uh_ulen = __bswap_16(len);
  udp_header->__annonCompField5.__annonCompField3.uh_sum = (uint16_t )0;
  return;
}
}
int icmp_helper_validate(struct ip  const  *ip_hdr , uint32_t len , size_t min_l4_len ,
                         struct ip **probe_pkt , size_t *probe_len )
{
  uint32_t min_len ;
  struct icmp *icmp ;
  struct ip *ip_inner ;
  size_t inner_packet_len ;
  uint32_t dest ;
  int tmp___0 ;

  {
  if (! ((int const   )ip_hdr->ip_p == 1)) {
    __assert_fail("ip_hdr->ip_p == IPPROTO_ICMP", "src/probe_modules/packet.c", 153U,
                  "icmp_helper_validate");
  }
  min_len = (uint32_t )(((unsigned long )(4U * ip_hdr->ip_hl + 8U) + sizeof(struct ip )) + min_l4_len);
  if (len < min_len) {
    return (0);
  }
  icmp = (struct icmp *)((char *)ip_hdr + 4U * ip_hdr->ip_hl);
  if (! ((int )icmp->icmp_type == 3)) {
    if (! ((int )icmp->icmp_type == 4)) {
      if (! ((int )icmp->icmp_type == 5)) {
        if (! ((int )icmp->icmp_type == 11)) {
          return (0);
        }
      }
    }
  }
  ip_inner = (struct ip *)((char *)icmp + 8);
  inner_packet_len = (size_t )(len - (uint32_t )(4U * ip_hdr->ip_hl + 8U));
  if (inner_packet_len < (size_t )(4U * ip_inner->ip_hl) + min_l4_len) {
    return (0);
  }
  dest = ip_inner->ip_dst.s_addr;
  tmp___0 = blocklist_is_allowed(dest);
  if (! tmp___0) {
    return (0);
  }
  *probe_pkt = ip_inner;
  *probe_len = inner_packet_len;
  return (1);
}
}
void fs_add_null_icmp(fieldset_t *fs )
{


  {
  fs_add_null(fs, "icmp_responder");
  fs_add_null(fs, "icmp_type");
  fs_add_null(fs, "icmp_code");
  fs_add_null(fs, "icmp_unreach_str");
  return;
}
}
void fs_add_failure_no_port(fieldset_t *fs )
{


  {
  fs_add_null(fs, "icmp_responder");
  fs_add_null(fs, "icmp_type");
  fs_add_null(fs, "icmp_code");
  fs_add_null(fs, "icmp_unreach_str");
  return;
}
}
void fs_populate_icmp_from_iphdr(struct ip *ip , size_t len , fieldset_t *fs )
{
  struct icmp *icmp ;
  struct icmp *tmp___1 ;
  struct ip *ip_inner ;
  struct ip *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  if (ip) {
    if (! "no ip header provide to fs_populate_icmp_from_iphdr") {
      __assert_fail("ip && \"no ip header provide to fs_populate_icmp_from_iphdr\"",
                    "src/probe_modules/packet.c", 215U, "fs_populate_icmp_from_iphdr");
    }
  } else {
    __assert_fail("ip && \"no ip header provide to fs_populate_icmp_from_iphdr\"",
                  "src/probe_modules/packet.c", 215U, "fs_populate_icmp_from_iphdr");
  }
  if (fs) {
    if (! "no fieldset provided to fs_populate_icmp_from_iphdr") {
      __assert_fail("fs && \"no fieldset provided to fs_populate_icmp_from_iphdr\"",
                    "src/probe_modules/packet.c", 216U, "fs_populate_icmp_from_iphdr");
    }
  } else {
    __assert_fail("fs && \"no fieldset provided to fs_populate_icmp_from_iphdr\"",
                  "src/probe_modules/packet.c", 216U, "fs_populate_icmp_from_iphdr");
  }
  tmp___1 = get_icmp_header((struct ip  const  *)ip, (uint32_t )len);
  icmp = tmp___1;
  if (! icmp) {
    __assert_fail("icmp", "src/probe_modules/packet.c", 218U, "fs_populate_icmp_from_iphdr");
  }
  tmp___3 = get_inner_ip_header((struct icmp  const  *)icmp, (uint32_t )len);
  ip_inner = tmp___3;
  tmp___4 = make_ip_str(ip_inner->ip_dst.s_addr);
  fs_modify_string(fs, "saddr", tmp___4, 1);
  tmp___5 = make_ip_str(ip->ip_src.s_addr);
  fs_add_string(fs, "icmp_responder", tmp___5, 1);
  fs_add_uint64(fs, "icmp_type", (uint64_t )icmp->icmp_type);
  fs_add_uint64(fs, "icmp_code", (uint64_t )icmp->icmp_code);
  if ((int )icmp->icmp_code <= 15) {
    fs_add_constchar(fs, "icmp_unreach_str", icmp_unreach_strings[icmp->icmp_code]);
  } else {
    fs_add_constchar(fs, "icmp_unreach_str", "unknown");
  }
  return;
}
}
char *make_ip_str(uint32_t ip )
{
  struct in_addr t ;
  char const   *temp ;
  char *tmp ;
  char *retv ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  t.s_addr = ip;
  tmp = inet_ntoa(t);
  temp = (char const   *)tmp;
  tmp___0 = strlen(temp);
  tmp___1 = xmalloc(tmp___0 + 1UL);
  retv = (char *)tmp___1;
  strcpy((char * __restrict  )retv, (char const   * __restrict  )temp);
  return (retv);
}
}
char const   *icmp_unreach_strings[16]  =
  {      "network unreachable",      "host unreachable",      "protocol unreachable",      "port unreachable",
        "fragments required",      "source route failed",      "network unknown",      "host unknown",
        "source host isolated",      "network admin. prohibited",      "host admin. prohibited",      "network unreachable TOS",
        "host unreachable TOS",      "communication admin. prohibited",      "host presdence violation",      "precedence cutoff"};
#pragma merger("0","/tmp/cil-8VjOvi3I.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
probe_module_t module_ntp ;
probe_module_t module_upnp ;
probe_module_t module_dns ;
probe_module_t module_bacnet ;
probe_module_t *probe_modules[9]  =
  {      & module_tcp_synscan,      & module_tcp_synackscan,      & module_icmp_echo,      & module_icmp_echo_time,
        & module_udp,      & module_ntp,      & module_upnp,      & module_dns,
        & module_bacnet};
probe_module_t *get_probe_module_by_name(char const   *name )
{
  int len ;
  int i ;
  int tmp ;

  {
  len = (int )(sizeof(probe_modules) / sizeof(probe_modules[0]));
  i = 0;
  while (i < len) {
    tmp = strcmp((probe_modules[i])->name, name);
    if (! tmp) {
      return (probe_modules[i]);
    }
    i ++;
  }
  return ((probe_module_t *)((void *)0));
}
}
void print_probe_modules(void)
{
  int len ;
  int i ;

  {
  len = (int )(sizeof(probe_modules) / sizeof(probe_modules[0]));
  i = 0;
  while (i < len) {
    __printf_chk(1, (char const   * __restrict  )"%s\n", (probe_modules[i])->name);
    i ++;
  }
  return;
}
}
void fs_add_ip_fields(fieldset_t *fs , struct ip *ip )
{
  char *tmp ;
  char *tmp___0 ;
  __uint16_t tmp___1 ;

  {
  tmp = make_ip_str(ip->ip_src.s_addr);
  fs_add_string(fs, "saddr", tmp, 1);
  fs_add_uint64(fs, "saddr_raw", (uint64_t )ip->ip_src.s_addr);
  tmp___0 = make_ip_str(ip->ip_dst.s_addr);
  fs_add_string(fs, "daddr", tmp___0, 1);
  fs_add_uint64(fs, "daddr_raw", (uint64_t )ip->ip_dst.s_addr);
  tmp___1 = __bswap_16(ip->ip_id);
  fs_add_uint64(fs, "ipid", (uint64_t )tmp___1);
  fs_add_uint64(fs, "ttl", (uint64_t )ip->ip_ttl);
  return;
}
}
void fs_add_system_fields(fieldset_t *fs , int is_repeat , int in_cooldown )
{
  char *timestr ;
  void *tmp ;
  char *timestr_ms ;
  void *tmp___0 ;
  struct timeval t ;
  struct tm *ptm ;
  struct tm *tmp___1 ;
  unsigned long tmp___2 ;

  {
  fs_add_bool(fs, "repeat", is_repeat);
  fs_add_bool(fs, "cooldown", in_cooldown);
  tmp = xmalloc((size_t )56);
  timestr = (char *)tmp;
  tmp___0 = xmalloc((size_t )56);
  timestr_ms = (char *)tmp___0;
  gettimeofday((struct timeval * __restrict  )(& t), (void * __restrict  )((void *)0));
  tmp___1 = localtime((time_t const   *)(& t.tv_sec));
  ptm = tmp___1;
  strftime((char * __restrict  )timestr, (size_t )55, (char const   * __restrict  )"%Y-%m-%dT%H:%M:%S.%%03d%z",
           (struct tm  const  * __restrict  )ptm);
  tmp___2 = __builtin_object_size((void *)timestr_ms, 1);
  __builtin___snprintf_chk(timestr_ms, 55UL, 1, tmp___2, (char const   *)timestr,
                           t.tv_usec / 1000L);
  free((void *)timestr);
  fs_add_string(fs, "timestamp_str", timestr_ms, 1);
  fs_add_uint64(fs, "timestamp_ts", (uint64_t )t.tv_sec);
  fs_add_uint64(fs, "timestamp_us", (uint64_t )t.tv_usec);
  return;
}
}
int ip_fields_len  =    6;
fielddef_t ip_fields[6]  = {      {"saddr", "string", "source IP address of response"},
        {"saddr_raw", "int", "network order integer form of source IP address"},
        {"daddr", "string", "destination IP address of response"},
        {"daddr_raw", "int", "network order integer form of destination IP address"},
        {"ipid",
      "int", "IP identification number of response"},
        {"ttl", "int", "time-to-live of response packet"}};
int sys_fields_len  =    5;
fielddef_t sys_fields[5]  = {      {"repeat", "bool", "Is response a repeat response from host"},
        {"cooldown", "bool", "Was response received during the cooldown period"},
        {"timestamp_str", "string", "timestamp of when response arrived in ISO8601 format."},
        {"timestamp_ts",
      "int", "timestamp of when response arrived in seconds since Epoch"},
        {"timestamp_us", "int", "microsecond part of timestamp (e.g. microseconds since \'timestamp-ts\')"}};
#pragma merger("0","/tmp/cil-Drl7vGf8.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
static int num_ports___2  ;
int ntp_global_initialize(struct state_conf *conf )
{
  int tmp ;

  {
  num_ports___2 = ((int )conf->source_port_last - (int )conf->source_port_first) + 1;
  tmp = udp_global_initialize(conf);
  return (tmp);
}
}
int ntp_make_packet(void *buf , ipaddr_n_t src_ip , ipaddr_n_t dst_ip , uint8_t ttl ,
                    uint32_t *validation , int probe_num )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  struct udphdr *udp_header ;
  struct ntphdr *ntp ;
  uint16_t tmp ;

  {
  eth_header = (struct ether_header *)buf;
  ip_header = (struct ip *)(eth_header + 1);
  udp_header = (struct udphdr *)(ip_header + 1);
  ntp = (struct ntphdr *)(udp_header + 1);
  ip_header->ip_src.s_addr = src_ip;
  ip_header->ip_dst.s_addr = dst_ip;
  ip_header->ip_ttl = ttl;
  tmp = get_src_port(num_ports___2, probe_num, validation);
  udp_header->__annonCompField5.__annonCompField3.uh_sport = __bswap_16(tmp);
  ip_header->ip_sum = (unsigned short)0;
  ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
  ntp->LI_VN_MODE = (uint8_t )227;
  return (0);
}
}
int ntp_validate_packet(struct ip  const  *ip_hdr , uint32_t len , uint32_t *src_ip ,
                        uint32_t *validation )
{
  int tmp ;

  {
  tmp = udp_do_validate_packet(ip_hdr, len, src_ip, validation, num_ports___2, (int )zconf.target_port);
  return (tmp);
}
}
void ntp_process_packet(u_char const   *packet , uint32_t len  __attribute__((__unused__)) ,
                        fieldset_t *fs , uint32_t *validation  __attribute__((__unused__)) ,
                        struct timespec ts  __attribute__((__unused__)) )
{
  struct ip *ip_hdr ;
  uint64_t temp64 ;
  uint8_t temp8 ;
  uint32_t temp32 ;
  struct udphdr *udp ;
  uint8_t *ptr ;
  __uint16_t tmp ;
  __uint16_t tmp___0 ;
  struct icmp *icmp ;
  struct ip *ip_inner ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  ip_hdr = (struct ip *)(packet + sizeof(struct ether_header ));
  if ((int )ip_hdr->ip_p == 17) {
    udp = (struct udphdr *)((char *)ip_hdr + ip_hdr->ip_hl * 4U);
    ptr = (uint8_t *)(udp + 1);
    fs_add_string(fs, "classification", (char *)"ntp", 0);
    fs_add_bool(fs, "success", 1);
    tmp = __bswap_16(udp->__annonCompField5.__annonCompField3.uh_sport);
    fs_add_uint64(fs, "sport", (uint64_t )tmp);
    tmp___0 = __bswap_16(udp->__annonCompField5.__annonCompField3.uh_dport);
    fs_add_uint64(fs, "dport", (uint64_t )tmp___0);
    fs_add_null(fs, "icmp_responder");
    fs_add_null(fs, "icmp_type");
    fs_add_null(fs, "icmp_code");
    fs_add_null(fs, "icmp_unreach_str");
    if (len > 90U) {
      temp8 = *ptr;
      fs_add_uint64(fs, "LI_VN_MODE", (uint64_t )temp8);
      temp8 = *(ptr + 1);
      fs_add_uint64(fs, "stratum", (uint64_t )temp8);
      temp8 = *(ptr + 2);
      fs_add_uint64(fs, "poll", (uint64_t )temp8);
      temp8 = *(ptr + 3);
      fs_add_uint64(fs, "precision", (uint64_t )temp8);
      temp32 = *((uint32_t *)ptr + 4);
      fs_add_uint64(fs, "root_delay", (uint64_t )temp32);
      temp32 = *((uint32_t *)ptr + 8);
      fs_add_uint64(fs, "root_dispersion", (uint64_t )temp32);
      temp32 = *((uint32_t *)ptr + 12);
      fs_add_uint64(fs, "reference_clock_identifier", (uint64_t )temp32);
      temp64 = *((uint64_t *)ptr + 16);
      fs_add_uint64(fs, "reference_timestamp", temp64);
      temp64 = *((uint64_t *)ptr + 24);
      fs_add_uint64(fs, "originate_timestamp", temp64);
      temp64 = *((uint64_t *)ptr + 32);
      fs_add_uint64(fs, "receive_timestamp", temp64);
      temp64 = *((uint64_t *)ptr + 39);
      fs_add_uint64(fs, "transmit_timestamp", temp64);
    } else {
      fs_add_null(fs, "LI_VN_MODE");
      fs_add_null(fs, "stratum");
      fs_add_null(fs, "poll");
      fs_add_null(fs, "precision");
      fs_add_null(fs, "root_delay");
      fs_add_null(fs, "root_dispersion");
      fs_add_null(fs, "reference_clock_identifier");
      fs_add_null(fs, "reference_timestamp");
      fs_add_null(fs, "originate_timestamp");
      fs_add_null(fs, "receive_timestamp");
      fs_add_null(fs, "transmit_timestamp");
    }
  } else
  if ((int )ip_hdr->ip_p == 1) {
    icmp = (struct icmp *)((char *)ip_hdr + ip_hdr->ip_hl * 4U);
    ip_inner = (struct ip *)((char *)icmp + 8);
    tmp___1 = make_ip_str(ip_inner->ip_dst.s_addr);
    fs_modify_string(fs, "saddr", tmp___1, 1);
    fs_add_constchar(fs, "classification", "icmp");
    fs_add_bool(fs, "success", 0);
    fs_add_null(fs, "sport");
    fs_add_null(fs, "dport");
    tmp___2 = make_ip_str(ip_hdr->ip_src.s_addr);
    fs_add_string(fs, "icmp_responder", tmp___2, 1);
    fs_add_uint64(fs, "icmp_type", (uint64_t )icmp->icmp_type);
    fs_add_uint64(fs, "icmp_code", (uint64_t )icmp->icmp_code);
    fs_add_null(fs, "icmp_unreach_str");
    fs_add_null(fs, "LI_VN_MODE");
    fs_add_null(fs, "stratum");
    fs_add_null(fs, "poll");
    fs_add_null(fs, "precision");
    fs_add_null(fs, "root_delay");
    fs_add_null(fs, "root_dispersion");
    fs_add_null(fs, "reference_clock_identifier");
    fs_add_null(fs, "reference_timestamp");
    fs_add_null(fs, "originate_timestamp");
    fs_add_null(fs, "receive_timestamp");
    fs_add_null(fs, "transmit_timestamp");
  } else {
    fs_add_constchar(fs, "classification", "other");
    fs_add_bool(fs, "success", 0);
    fs_add_null(fs, "sport");
    fs_add_null(fs, "dport");
    fs_add_null(fs, "icmp_responder");
    fs_add_null(fs, "icmp_type");
    fs_add_null(fs, "icmp_code");
    fs_add_null(fs, "icmp_unreach_str");
    fs_add_null(fs, "LI_VN_MODE");
    fs_add_null(fs, "stratum");
    fs_add_null(fs, "poll");
    fs_add_null(fs, "precision");
    fs_add_null(fs, "root_delay");
    fs_add_null(fs, "root_dispersion");
    fs_add_null(fs, "reference_clock_identifier");
    fs_add_null(fs, "reference_timestamp");
    fs_add_null(fs, "originate_timestamp");
    fs_add_null(fs, "receive_timestamp");
    fs_add_null(fs, "transmit_timestamp");
  }
  return;
}
}
int ntp_init_perthread(void *buf , macaddr_t *src , macaddr_t *gw , port_h_t dst_port  __attribute__((__unused__)) ,
                       void **arg )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  uint16_t len ;
  __uint16_t tmp ;
  struct udphdr *udp_header ;
  struct ntphdr *ntp_header ;
  size_t header_len ;
  uint32_t seed ;
  uint64_t tmp___0 ;
  aesrand_t *aes ;
  aesrand_t *tmp___1 ;

  {
  memset(buf, 0, (size_t )4096);
  eth_header = (struct ether_header *)buf;
  make_eth_header(eth_header, src, gw);
  ip_header = (struct ip *)(eth_header + 1);
  tmp = __bswap_16((__uint16_t )((sizeof(struct ip ) + sizeof(struct udphdr )) + sizeof(struct ntphdr )));
  len = tmp;
  make_ip_header(ip_header, (uint8_t )17, len);
  udp_header = (struct udphdr *)(ip_header + 1);
  ntp_header = (struct ntphdr *)(udp_header + 1);
  ntp_header->LI_VN_MODE = (uint8_t )227;
  len = (uint16_t )(sizeof(struct udphdr ) + sizeof(struct ntphdr ));
  make_udp_header(udp_header, zconf.target_port, len);
  header_len = ((sizeof(struct ether_header ) + sizeof(struct ip )) + sizeof(struct udphdr )) + sizeof(struct ntphdr );
  module_ntp.max_packet_length = header_len;
  tmp___0 = aesrand_getword(zconf.aes);
  seed = (uint32_t )tmp___0;
  tmp___1 = aesrand_init_from_seed((uint64_t )seed);
  aes = tmp___1;
  *arg = (void *)aes;
  return (0);
}
}
void ntp_print_packet(FILE *fp , void *packet )
{
  struct ether_header *ethh ;
  struct ip *iph ;
  struct udphdr *udph ;
  struct ntphdr *ntph ;
  __uint16_t tmp ;
  __uint16_t tmp___0 ;
  __uint16_t tmp___1 ;

  {
  ethh = (struct ether_header *)packet;
  iph = (struct ip *)(ethh + 1);
  udph = (struct udphdr *)(iph + 4U * iph->ip_hl);
  ntph = (struct ntphdr *)(udph + 1);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"ntp { LI_VN_MODE: %u | stratum: %u | poll: %u }\n",
                (int )ntph->LI_VN_MODE, (int )ntph->stratum, (int )ntph->poll);
  tmp = __bswap_16(udph->__annonCompField5.__annonCompField3.uh_sum);
  tmp___0 = __bswap_16(udph->__annonCompField5.__annonCompField3.uh_dport);
  tmp___1 = __bswap_16(udph->__annonCompField5.__annonCompField3.uh_sport);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"udp { source: %u | dest: %u | checksum: %#04X }\n",
                (int )tmp___1, (int )tmp___0, (int )tmp);
  fprintf_ip_header(fp, iph);
  fprintf_eth_header(fp, ethh);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"------------------------------------------------------\n");
  return;
}
}
static fielddef_t fields___4[19]  =
  {      {"classification", "string", "packet classification"},
        {"success", "bool", "is  response considered success"},
        {"sport", "int", "UDP source port"},
        {"dport", "int", "UDP destination port"},
        {"icmp_responder", "string", "Source IP of ICMP_UNREACH messages"},
        {"icmp_type", "int", "icmp message type"},
        {"icmp_code", "int", "icmp message sub type code"},
        {"icmp_unreach_str", "string", "for icmp_unreach responses, the string version of icmp_code (e.g. network-unreach)"},
        {"LI_VN_MODE",
      "int", "leap indication, version number, mode"},
        {"stratum", "int", "stratum"},
        {"poll", "int", "poll"},
        {"precision", "int", "precision"},
        {"root_delay", "int", "root delay"},
        {"root_dispersion", "int", "root dispersion"},
        {"reference_clock_identifier", "int", "code identifying clock reference"},
        {"reference_timestamp", "int", "local time at which local clock was last set or corrected"},
        {"originate_timestamp",
      "int", "local time at which request deparated client for service"},
        {"receive_timestamp", "int", "local time at which request arrvied at service host"},
        {"transmit_timestamp",
      "int", "local time which reply departed service host for client"}};
probe_module_t module_ntp  =
     {"ntp", (size_t )0, "udp || icmp", (size_t )1500, (uint8_t )1, & ntp_global_initialize,
    & ntp_init_perthread, & udp_make_packet, & ntp_print_packet, & ntp_validate_packet,
    (void (*)(u_char const   *packetbuf , uint32_t len , fieldset_t * , uint32_t *validation ,
              struct timespec  const  ts ))(& ntp_process_packet), & udp_global_cleanup,
    1, fields___4, (int )(sizeof(fields___4) / sizeof(fields___4[0])), (char const   *)0};
#pragma merger("0","/tmp/cil-wueJNA5u.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strsep)(char ** __restrict  __stringp ,
                                                                                       char const   * __restrict  __delim ) ;
static char const   *upnp_query  =    "M-SEARCH * HTTP/1.1\r\nHost:239.255.255.250:1900\r\nST:upnp:rootdevice\r\nMan:\"ssdp:discover\"\r\nMX:3\r\n\r\n";
static int num_ports___3  ;
int upnp_global_initialize(struct state_conf *state )
{


  {
  num_ports___3 = ((int )state->source_port_last - (int )state->source_port_first) + 1;
  udp_set_num_ports(num_ports___3);
  return (0);
}
}
int upnp_init_perthread(void *buf , macaddr_t *src , macaddr_t *gw , port_h_t dst_port ,
                        void **arg_ptr  __attribute__((__unused__)) )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  uint16_t len ;
  size_t tmp ;
  __uint16_t tmp___0 ;
  struct udphdr *udp_header ;
  size_t tmp___1 ;
  char *payload ;
  size_t tmp___5 ;
  size_t tmp___9 ;

  {
  memset(buf, 0, (size_t )4096);
  eth_header = (struct ether_header *)buf;
  make_eth_header(eth_header, src, gw);
  ip_header = (struct ip *)(eth_header + 1);
  tmp = strlen(upnp_query);
  tmp___0 = __bswap_16((__uint16_t )((sizeof(struct ip ) + sizeof(struct udphdr )) + tmp));
  len = tmp___0;
  make_ip_header(ip_header, (uint8_t )17, len);
  udp_header = (struct udphdr *)(ip_header + 1);
  tmp___1 = strlen(upnp_query);
  len = (uint16_t )(sizeof(struct udphdr ) + tmp___1);
  make_udp_header(udp_header, dst_port, len);
  payload = (char *)(udp_header + 1);
  tmp___5 = strlen(upnp_query);
  if (! (((sizeof(struct ether_header ) + sizeof(struct ip )) + sizeof(struct udphdr )) + tmp___5 <= 4096UL)) {
    __assert_fail("sizeof(struct ether_header) + sizeof(struct ip) + sizeof(struct udphdr) + strlen(upnp_query) <= MAX_PACKET_SIZE",
                  "src/probe_modules/module_upnp.c", 63U, "upnp_init_perthread");
  }
  tmp___9 = strlen(upnp_query);
  if (! (4096L - (payload - (char *)buf) > (long )((int )tmp___9))) {
    __assert_fail("MAX_PACKET_SIZE - ((char *)payload - (char *)buf) > (int)strlen(upnp_query)",
                  "src/probe_modules/module_upnp.c", 66U, "upnp_init_perthread");
  }
  strcpy((char * __restrict  )payload, (char const   * __restrict  )upnp_query);
  return (0);
}
}
int upnp_validate_packet(struct ip  const  *ip_hdr , uint32_t len , uint32_t *src_ip ,
                         uint32_t *validation )
{
  int tmp ;

  {
  tmp = udp_do_validate_packet(ip_hdr, len, src_ip, validation, num_ports___3, (int )zconf.target_port);
  return (tmp);
}
}
void upnp_process_packet(u_char const   *packet , uint32_t len  __attribute__((__unused__)) ,
                         fieldset_t *fs , uint32_t *validation  __attribute__((__unused__)) ,
                         struct timespec ts  __attribute__((__unused__)) )
{
  struct ip *ip_hdr ;
  struct udphdr *udp ;
  char *payload ;
  uint16_t plen ;
  char *s ;
  void *tmp ;
  int is_first ;
  char const   *classification ;
  uint64_t is_success ;
  char *server ;
  char *location ;
  char *usn ;
  char *st ;
  char *cachecontrol ;
  char *ext ;
  char *xusragent ;
  char *date ;
  char *agent ;
  char *pch ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *value ;
  char *key ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  __uint16_t tmp___15 ;
  __uint16_t tmp___16 ;
  __uint16_t tmp___17 ;

  {
  ip_hdr = (struct ip *)(packet + sizeof(struct ether_header ));
  if ((int )ip_hdr->ip_p == 17) {
    udp = (struct udphdr *)((char *)ip_hdr + ip_hdr->ip_hl * 4U);
    payload = (char *)(udp + 1);
    plen = (uint16_t )((int )udp->__annonCompField5.__annonCompField3.uh_ulen - 8);
    tmp = xmalloc((size_t )((int )plen + 1));
    s = (char *)tmp;
    strncpy((char * __restrict  )s, (char const   * __restrict  )payload, (size_t )plen);
    *(s + plen) = (char)0;
    is_first = 1;
    classification = "none";
    is_success = (uint64_t )0;
    server = (char *)((void *)0);
    location = (char *)((void *)0);
    usn = (char *)((void *)0);
    st = (char *)((void *)0);
    cachecontrol = (char *)((void *)0);
    ext = (char *)((void *)0);
    xusragent = (char *)((void *)0);
    date = (char *)((void *)0);
    agent = (char *)((void *)0);
    tmp___0 = strtok((char * __restrict  )s, (char const   * __restrict  )"\n");
    pch = tmp___0;
    while ((unsigned long )pch != (unsigned long )((void *)0)) {
      tmp___2 = strlen((char const   *)pch);
      if ((int )*(pch + (tmp___2 - 1UL)) == 13) {
        tmp___1 = strlen((char const   *)pch);
        *(pch + (tmp___1 - 1UL)) = (char )'\000';
      }
      tmp___3 = strlen((char const   *)pch);
      if (tmp___3 == 0UL) {
        pch = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
        continue;
      }
      if (is_first) {
        tmp___4 = strcmp((char const   *)pch, "HTTP/1.1 200 OK");
        if (tmp___4) {
          classification = "no-http-header";
          is_success = (uint64_t )0;
          goto cleanup;
        }
        is_first = 0;
        is_success = (uint64_t )1;
        classification = "upnp";
        pch = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
        continue;
      }
      value = pch;
      tmp___5 = strsep((char ** __restrict  )(& value), (char const   * __restrict  )":");
      key = tmp___5;
      if (! key) {
        pch = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
        continue;
      }
      if (! value) {
        pch = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
        continue;
      }
      if ((int )*(value + 0) == 32) {
        value ++;
      }
      tmp___14 = strcasecmp((char const   *)key, "server");
      if (tmp___14) {
        tmp___13 = strcasecmp((char const   *)key, "location");
        if (tmp___13) {
          tmp___12 = strcasecmp((char const   *)key, "USN");
          if (tmp___12) {
            tmp___11 = strcasecmp((char const   *)key, "EXT");
            if (tmp___11) {
              tmp___10 = strcasecmp((char const   *)key, "ST");
              if (tmp___10) {
                tmp___9 = strcasecmp((char const   *)key, "Agent");
                if (tmp___9) {
                  tmp___8 = strcasecmp((char const   *)key, "X-User-Agent");
                  if (tmp___8) {
                    tmp___7 = strcasecmp((char const   *)key, "date");
                    if (tmp___7) {
                      tmp___6 = strcasecmp((char const   *)key, "Cache-Control");
                      if (! tmp___6) {
                        cachecontrol = strdup((char const   *)value);
                      }
                    } else {
                      date = strdup((char const   *)value);
                    }
                  } else {
                    xusragent = strdup((char const   *)value);
                  }
                } else {
                  agent = strdup((char const   *)value);
                }
              } else {
                st = strdup((char const   *)value);
              }
            } else {
              ext = strdup((char const   *)value);
            }
          } else {
            usn = strdup((char const   *)value);
          }
        } else {
          location = strdup((char const   *)value);
        }
      } else {
        server = strdup((char const   *)value);
      }
      pch = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
    }
    cleanup:
    fs_add_string(fs, "classification", (char *)classification, 0);
    fs_add_bool(fs, "success", (int )is_success);
    fs_chkadd_unsafe_string(fs, "server", server, 1);
    fs_chkadd_unsafe_string(fs, "location", location, 1);
    fs_chkadd_unsafe_string(fs, "usn", usn, 1);
    fs_chkadd_unsafe_string(fs, "st", st, 1);
    fs_chkadd_unsafe_string(fs, "ext", ext, 1);
    fs_chkadd_unsafe_string(fs, "cache_control", cachecontrol, 1);
    fs_chkadd_unsafe_string(fs, "x_user_agent", xusragent, 1);
    fs_chkadd_unsafe_string(fs, "agent", agent, 1);
    fs_chkadd_unsafe_string(fs, "date", date, 1);
    tmp___15 = __bswap_16(udp->__annonCompField5.__annonCompField3.uh_sport);
    fs_add_uint64(fs, "sport", (uint64_t )tmp___15);
    tmp___16 = __bswap_16(udp->__annonCompField5.__annonCompField3.uh_dport);
    fs_add_uint64(fs, "dport", (uint64_t )tmp___16);
    fs_add_null(fs, "icmp_responder");
    fs_add_null(fs, "icmp_type");
    fs_add_null(fs, "icmp_code");
    fs_add_null(fs, "icmp_unreach_str");
    tmp___17 = __bswap_16(udp->__annonCompField5.__annonCompField3.uh_ulen);
    fs_add_binary(fs, "data", (unsigned long )tmp___17 - sizeof(struct udphdr ), (void *)(udp + 1),
                  0);
    free((void *)s);
  } else
  if ((int )ip_hdr->ip_p == 1) {
    fs_add_constchar(fs, "classification", "icmp");
    fs_add_uint64(fs, "success", (uint64_t )0);
    fs_add_null(fs, "server");
    fs_add_null(fs, "location");
    fs_add_null(fs, "usn");
    fs_add_null(fs, "st");
    fs_add_null(fs, "ext");
    fs_add_null(fs, "cache_control");
    fs_add_null(fs, "x_user_agent");
    fs_add_null(fs, "agent");
    fs_add_null(fs, "date");
    fs_add_null(fs, "sport");
    fs_add_null(fs, "dport");
    fs_populate_icmp_from_iphdr(ip_hdr, (size_t )len, fs);
    fs_add_null(fs, "data");
  } else {
    fs_add_constchar(fs, "classification", "other");
    fs_add_bool(fs, "success", 0);
    fs_add_null(fs, "server");
    fs_add_null(fs, "location");
    fs_add_null(fs, "usn");
    fs_add_null(fs, "st");
    fs_add_null(fs, "ext");
    fs_add_null(fs, "cache_control");
    fs_add_null(fs, "x_user_agent");
    fs_add_null(fs, "agent");
    fs_add_null(fs, "date");
    fs_add_null(fs, "sport");
    fs_add_null(fs, "dport");
    fs_add_null(fs, "icmp_responder");
    fs_add_null(fs, "icmp_type");
    fs_add_null(fs, "icmp_code");
    fs_add_null(fs, "icmp_unreach_str");
    fs_add_null(fs, "data");
  }
  return;
}
}
static fielddef_t fields___5[18]  =
  {      {"classification", "string", "packet classification"},
        {"success", "bool", "is response considered success"},
        {"server", "string", "UPnP server"},
        {"location", "string", "UPnP location"},
        {"usn", "string", "UPnP usn"},
        {"st", "string", "UPnP st"},
        {"ext", "string", "UPnP ext"},
        {"cache_control", "string", "UPnP cache-control"},
        {"x_user_agent", "string", "UPnP x-user-agent"},
        {"agent", "string", "UPnP agent"},
        {"date", "string", "UPnP date"},
        {"sport", "int", "UDP source port"},
        {"dport", "int", "UDP destination port"},
        {"icmp_responder", "string", "Source IP of ICMP_UNREACH messages"},
        {"icmp_type", "int", "icmp message type"},
        {"icmp_code", "int", "icmp message sub type code"},
        {"icmp_unreach_str", "string", "for icmp_unreach responses, the string version of icmp_code (e.g. network-unreach)"},
        {"data",
      "binary", "UDP payload"}};
probe_module_t module_upnp  =
     {"upnp", (size_t )139, "udp || icmp", (size_t )2048, (uint8_t )1, & upnp_global_initialize,
    & upnp_init_perthread, & udp_make_packet, & udp_print_packet, & upnp_validate_packet,
    (void (*)(u_char const   *packetbuf , uint32_t len , fieldset_t * , uint32_t *validation ,
              struct timespec  const  ts ))(& upnp_process_packet), (int (*)(struct state_conf * ,
                                                                             struct state_send * ,
                                                                             struct state_recv * ))((void *)0),
    2, fields___5, 18, "Probe module that sends a TCP SYN packet to a specific port. Possible classifications are: synack and rst. A SYN-ACK packet is considered a success and a reset packet is considered a failed response."};
#pragma merger("0","/tmp/cil-tSFy327H.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
static int num_ports___4  ;
char const   default_domain[15]  =
  {      (char const   )'w',      (char const   )'w',      (char const   )'w',      (char const   )'.',
        (char const   )'g',      (char const   )'o',      (char const   )'o',      (char const   )'g',
        (char const   )'l',      (char const   )'e',      (char const   )'.',      (char const   )'c',
        (char const   )'o',      (char const   )'m',      (char const   )'\000'};
unsigned short const   default_qtype  =    (uint16_t const   )1;
static char **dns_packets  ;
static uint16_t *dns_packet_lens  ;
static uint16_t *qname_lens  ;
static char **qnames  ;
static uint16_t *qtypes  ;
static int num_questions  =    0;
char const   *qtype_strs[10]  =
  {      "A",      "NS",      "CNAME",      "SOA",
        "PTR",      "MX",      "TXT",      "AAAA",
        "RRSIG",      "ALL"};
int const   qtype_strs_len  =    (int const   )10;
dns_qtype const   qtype_strid_to_qtype[10]  =
  {      (dns_qtype const   )1,      (dns_qtype const   )2,      (dns_qtype const   )5,      (dns_qtype const   )6,
        (dns_qtype const   )12,      (dns_qtype const   )15,      (dns_qtype const   )16,      (dns_qtype const   )28,
        (dns_qtype const   )46,      (dns_qtype const   )255};
int8_t qtype_qtype_to_strid[256]  = {      (int8_t )-1};
void setup_qtype_str_map(void)
{


  {
  qtype_qtype_to_strid[1] = (int8_t )0;
  qtype_qtype_to_strid[2] = (int8_t )1;
  qtype_qtype_to_strid[5] = (int8_t )2;
  qtype_qtype_to_strid[6] = (int8_t )3;
  qtype_qtype_to_strid[12] = (int8_t )4;
  qtype_qtype_to_strid[15] = (int8_t )5;
  qtype_qtype_to_strid[16] = (int8_t )6;
  qtype_qtype_to_strid[28] = (int8_t )7;
  qtype_qtype_to_strid[46] = (int8_t )8;
  qtype_qtype_to_strid[255] = (int8_t )9;
  return;
}
}
static uint16_t qtype_str_to_code(char const   *str )
{
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < (int )qtype_strs_len) {
    tmp = strcmp(qtype_strs[i], str);
    if (tmp == 0) {
      return ((uint16_t )qtype_strid_to_qtype[i]);
    }
    i ++;
  }
  return ((uint16_t )0);
}
}
static uint16_t domain_to_qname(char **qname_handle , char const   *domain )
{
  uint16_t len ;
  size_t tmp ;
  char *qname ;
  void *tmp___0 ;
  int i ;
  int j ;

  {
  tmp = strlen(domain);
  len = (uint16_t )((tmp + 1UL) + 1UL);
  tmp___0 = xmalloc((size_t )len);
  qname = (char *)tmp___0;
  *(qname + 0) = (char )'.';
  strcpy((char * __restrict  )(qname + 1), (char const   * __restrict  )domain);
  i = 0;
  while (i < (int )len) {
    if ((int )*(qname + i) == 46) {
      j = i + 1;
      while (j < (int )len - 1) {
        if ((int )*(qname + j) == 46) {
          break;
        }
        j ++;
      }
      *(qname + i) = (char )((j - i) - 1);
    }
    i ++;
  }
  *qname_handle = qname;
  if (! ((int )*(*qname_handle + ((int )len - 1)) == 0)) {
    __assert_fail("(*qname_handle)[len - 1] == \'\\0\'", "src/probe_modules/module_dns.c",
                  152U, "domain_to_qname");
  }
  return (len);
}
}
static int build_global_dns_packets(char **domains , int num_domains , size_t *max_len )
{
  size_t _max_len ;
  int i ;
  uint16_t len ;
  void *tmp ;
  dns_header *dns_header_p ;
  char *qname_p ;
  dns_question_tail *tail_p ;

  {
  _max_len = (size_t )0;
  i = 0;
  while (i < num_domains) {
    *(qname_lens + i) = domain_to_qname(qnames + i, (char const   *)*(domains + i));
    if ((unsigned long )*(domains + i) != (unsigned long )((char *)(default_domain))) {
      free((void *)*(domains + i));
    }
    len = (uint16_t )((sizeof(dns_header ) + (unsigned long )*(qname_lens + i)) + sizeof(dns_question_tail ));
    *(dns_packet_lens + i) = len;
    if ((size_t )len > _max_len) {
      _max_len = (size_t )len;
    }
    if ((int )*(dns_packet_lens + i) > 512) {
      log_fatal("dns", "DNS packet bigger (%d) than our limit (%d)", (int )*(dns_packet_lens + i),
                512);
      return (1);
    }
    tmp = xmalloc((size_t )*(dns_packet_lens + i));
    *(dns_packets + i) = (char *)tmp;
    dns_header_p = (dns_header *)*(dns_packets + i);
    qname_p = *(dns_packets + i) + sizeof(dns_header );
    tail_p = (dns_question_tail *)((*(dns_packets + i) + sizeof(dns_header )) + (int )*(qname_lens + i));
    dns_header_p->rd = 1U;
    dns_header_p->qdcount = __bswap_16((__uint16_t )1);
    memcpy((void * __restrict  )qname_p, (void const   * __restrict  )*(qnames + i),
           (size_t )*(qname_lens + i));
    tail_p->qtype = __bswap_16(*(qtypes + i));
    tail_p->qclass = __bswap_16((__uint16_t )1);
    i ++;
  }
  *max_len = _max_len;
  return (0);
}
}
static uint16_t get_name_helper(char const   *data , uint16_t data_len , char const   *payload ,
                                uint16_t payload_len , char *name , uint16_t name_len ,
                                uint16_t recursion_level )
{
  uint16_t bytes_consumed ;
  uint8_t byte ;
  uint16_t offset ;
  uint16_t rec_bytes_consumed ;
  uint16_t tmp ;

  {
  if ((int )data_len == 0) {
    return ((uint16_t )0);
  } else
  if ((int )name_len == 0) {
    return ((uint16_t )0);
  } else
  if ((int )payload_len == 0) {
    return ((uint16_t )0);
  }
  if ((int )recursion_level > 10) {
    return ((uint16_t )0);
  }
  bytes_consumed = (uint16_t )0;
  while ((int )data_len > 0) {
    byte = (uint8_t )*(data + 0);
    if ((int )byte >= 192) {
      if ((int )data_len < 2) {
        return ((uint16_t )0);
      }
      offset = (uint16_t )((((int )byte & 3) << 8) | (int )((uint8_t )*(data + 1)));
      if ((int )offset >= (int )payload_len) {
        return ((uint16_t )0);
      }
      if ((int )recursion_level > 0) {
        goto _L;
      } else
      if ((int )bytes_consumed > 0) {
        _L: /* CIL Label */
        if ((int )name_len < 1) {
          log_warn("dns", "Exceeded static name field allocation.");
          return ((uint16_t )0);
        }
        *(name + 0) = (char )'.';
        name ++;
        name_len = (uint16_t )((int )name_len - 1);
      }
      tmp = get_name_helper(payload + (int )offset, (uint16_t )((int )payload_len - (int )offset),
                            payload, payload_len, name, name_len, (uint16_t )((int )recursion_level + 1));
      rec_bytes_consumed = tmp;
      if ((int )rec_bytes_consumed == 0) {
        return ((uint16_t )0);
      } else {
        bytes_consumed = (uint16_t )((int )bytes_consumed + 2);
        return (bytes_consumed);
      }
    } else
    if ((int )byte == 0) {
      bytes_consumed = (uint16_t )((int )bytes_consumed + 1);
      return (bytes_consumed);
    } else {
      data ++;
      data_len = (uint16_t )((int )data_len - 1);
      if ((int )byte + 1 > (int )data_len) {
        return ((uint16_t )0);
      }
      if ((int )bytes_consumed > 0) {
        if ((int )name_len < 1) {
          log_warn("dns", "Exceeded static name field allocation.");
          return ((uint16_t )0);
        }
        *(name + 0) = (char )'.';
        name ++;
        name_len = (uint16_t )((int )name_len - 1);
      }
      bytes_consumed = (uint16_t )((int )bytes_consumed + 1);
      if ((int )byte > (int )name_len) {
        log_warn("dns", "Exceeded static name field allocation.");
        return ((uint16_t )0);
      }
      if (! ((int )data_len > 0)) {
        __assert_fail("data_len > 0", "src/probe_modules/module_dns.c", 335U, "get_name_helper");
      }
      memcpy((void * __restrict  )name, (void const   * __restrict  )data, (size_t )byte);
      name += (int )byte;
      name_len = (uint16_t )((int )name_len - (int )byte);
      data_len = (uint16_t )((int )data_len - (int )byte);
      data += (int )byte;
      bytes_consumed = (uint16_t )((int )bytes_consumed + (int )byte);
      if (! ((int )data_len > 0)) {
        __assert_fail("data_len > 0", "src/probe_modules/module_dns.c", 343U, "get_name_helper");
      }
    }
  }
  __assert_fail("0", "src/probe_modules/module_dns.c", 352U, "get_name_helper");
  return ((uint16_t )0);
}
}
static char *get_name(char const   *data , uint16_t data_len , char const   *payload ,
                      uint16_t payload_len , uint16_t *bytes_consumed )
{
  char *name ;
  void *tmp ;

  {
  tmp = xmalloc((size_t )512);
  name = (char *)tmp;
  *bytes_consumed = get_name_helper(data, data_len, payload, payload_len, name, (uint16_t )511,
                                    (uint16_t )0);
  if ((int )*bytes_consumed == 0) {
    free((void *)name);
    return ((char *)((void *)0));
  }
  if (! ((int )*(name + 511) == 0)) {
    __assert_fail("name[MAX_NAME_LENGTH - 1] == \'\\0\'", "src/probe_modules/module_dns.c",
                  370U, "get_name");
  }
  return (name);
}
}
static bool process_response_question(char **data , uint16_t *data_len , char const   *payload ,
                                      uint16_t payload_len , fieldset_t *list )
{
  uint16_t bytes_consumed ;
  char *question_name ;
  char *tmp ;
  dns_question_tail *tail ;
  uint16_t qtype ;
  __uint16_t tmp___1 ;
  uint16_t qclass ;
  __uint16_t tmp___2 ;
  fieldset_t *qfs ;
  fieldset_t *tmp___3 ;

  {
  bytes_consumed = (uint16_t )0;
  tmp = get_name((char const   *)*data, *data_len, payload, payload_len, & bytes_consumed);
  question_name = tmp;
  if ((unsigned long )question_name == (unsigned long )((void *)0)) {
    return ((bool )1);
  }
  if (! ((int )bytes_consumed > 0)) {
    __assert_fail("bytes_consumed > 0", "src/probe_modules/module_dns.c", 393U, "process_response_question");
  }
  if ((unsigned long )bytes_consumed + sizeof(dns_question_tail ) > (unsigned long )*data_len) {
    free((void *)question_name);
    return ((bool )1);
  }
  tail = (dns_question_tail *)(*data + (int )bytes_consumed);
  tmp___1 = __bswap_16(tail->qtype);
  qtype = tmp___1;
  tmp___2 = __bswap_16(tail->qclass);
  qclass = tmp___2;
  tmp___3 = fs_new_fieldset((fielddefset_t *)((void *)0));
  qfs = tmp___3;
  fs_add_unsafe_string(qfs, "name", question_name, 1);
  fs_add_uint64(qfs, "qtype", (uint64_t )qtype);
  if ((int )qtype > 255) {
    fs_add_string(qfs, "qtype_str", (char *)"BAD QTYPE", 0);
  } else
  if ((int )qtype_qtype_to_strid[qtype] == -1) {
    fs_add_string(qfs, "qtype_str", (char *)"BAD QTYPE", 0);
  } else {
    fs_add_string(qfs, "qtype_str", (char *)qtype_strs[qtype_qtype_to_strid[qtype]],
                  0);
  }
  fs_add_uint64(qfs, "qclass", (uint64_t )qclass);
  fs_add_fieldset(list, (char const   *)((void *)0), qfs);
  *data = (*data + (int )bytes_consumed) + sizeof(dns_question_tail );
  *data_len = (uint16_t )((unsigned long )((int )*data_len - (int )bytes_consumed) - sizeof(dns_question_tail ));
  return ((bool )0);
}
}
static bool process_response_answer(char **data , uint16_t *data_len , char const   *payload ,
                                    uint16_t payload_len , fieldset_t *list )
{
  uint16_t bytes_consumed ;
  char *answer_name ;
  char *tmp ;
  dns_answer_tail *tail ;
  uint16_t type ;
  __uint16_t tmp___1 ;
  uint16_t class ;
  __uint16_t tmp___2 ;
  uint32_t ttl ;
  __uint32_t tmp___3 ;
  uint16_t rdlength ;
  __uint16_t tmp___4 ;
  char *rdata ;
  fieldset_t *afs ;
  fieldset_t *tmp___5 ;
  uint16_t rdata_bytes_consumed ;
  char *rdata_name ;
  char *tmp___6 ;
  uint16_t rdata_bytes_consumed___0 ;
  char *rdata_name___0 ;
  char *tmp___7 ;
  char *rdata_with_pref ;
  size_t tmp___8 ;
  void *tmp___9 ;
  uint8_t num_printed ;
  __uint16_t tmp___10 ;
  unsigned long tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  char *txt ;
  void *tmp___14 ;
  char *addr ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *ipv6_str ;
  void *tmp___17 ;

  {
  bytes_consumed = (uint16_t )0;
  tmp = get_name((char const   *)*data, *data_len, payload, payload_len, & bytes_consumed);
  answer_name = tmp;
  if ((unsigned long )answer_name == (unsigned long )((void *)0)) {
    return ((bool )1);
  }
  if (! ((int )bytes_consumed > 0)) {
    __assert_fail("bytes_consumed > 0", "src/probe_modules/module_dns.c", 440U, "process_response_answer");
  }
  if ((unsigned long )bytes_consumed + sizeof(dns_answer_tail ) > (unsigned long )*data_len) {
    free((void *)answer_name);
    return ((bool )1);
  }
  tail = (dns_answer_tail *)(*data + (int )bytes_consumed);
  tmp___1 = __bswap_16(tail->type);
  type = tmp___1;
  tmp___2 = __bswap_16(tail->class);
  class = tmp___2;
  tmp___3 = __bswap_32(tail->ttl);
  ttl = tmp___3;
  tmp___4 = __bswap_16(tail->rdlength);
  rdlength = tmp___4;
  rdata = tail->rdata;
  if ((unsigned long )((int )rdlength + (int )bytes_consumed) + sizeof(dns_answer_tail ) > (unsigned long )*data_len) {
    free((void *)answer_name);
    return ((bool )1);
  }
  tmp___5 = fs_new_fieldset((fielddefset_t *)((void *)0));
  afs = tmp___5;
  fs_add_unsafe_string(afs, "name", answer_name, 1);
  fs_add_uint64(afs, "type", (uint64_t )type);
  if ((int )type > 255) {
    fs_add_string(afs, "type_str", (char *)"BAD QTYPE", 0);
  } else
  if ((int )qtype_qtype_to_strid[type] == -1) {
    fs_add_string(afs, "type_str", (char *)"BAD QTYPE", 0);
  } else {
    fs_add_string(afs, "type_str", (char *)qtype_strs[qtype_qtype_to_strid[type]],
                  0);
  }
  fs_add_uint64(afs, "class", (uint64_t )class);
  fs_add_uint64(afs, "ttl", (uint64_t )ttl);
  fs_add_uint64(afs, "rdlength", (uint64_t )rdlength);
  if ((int )type == 2) {
    goto _L;
  } else
  if ((int )type == 5) {
    _L: /* CIL Label */
    rdata_bytes_consumed = (uint16_t )0;
    tmp___6 = get_name((char const   *)rdata, rdlength, payload, payload_len, & rdata_bytes_consumed);
    rdata_name = tmp___6;
    if ((unsigned long )rdata_name == (unsigned long )((void *)0)) {
      fs_add_uint64(afs, "rdata_is_parsed", (uint64_t )0);
      fs_add_binary(afs, "rdata", (size_t )rdlength, (void *)rdata, 0);
    } else {
      fs_add_uint64(afs, "rdata_is_parsed", (uint64_t )1);
      fs_add_unsafe_string(afs, "rdata", rdata_name, 1);
    }
  } else
  if ((int )type == 15) {
    rdata_bytes_consumed___0 = (uint16_t )0;
    if ((int )rdlength <= 4) {
      fs_add_uint64(afs, "rdata_is_parsed", (uint64_t )0);
      fs_add_binary(afs, "rdata", (size_t )rdlength, (void *)rdata, 0);
    } else {
      tmp___7 = get_name((char const   *)(rdata + 2), (uint16_t )((int )rdlength - 2),
                         payload, payload_len, & rdata_bytes_consumed___0);
      rdata_name___0 = tmp___7;
      if ((unsigned long )rdata_name___0 == (unsigned long )((void *)0)) {
        fs_add_uint64(afs, "rdata_is_parsed", (uint64_t )0);
        fs_add_binary(afs, "rdata", (size_t )rdlength, (void *)rdata, 0);
      } else {
        tmp___8 = strlen((char const   *)rdata_name___0);
        tmp___9 = xmalloc((6UL + tmp___8) + 1UL);
        rdata_with_pref = (char *)tmp___9;
        tmp___10 = __bswap_16(*((uint16_t *)rdata));
        tmp___11 = __builtin_object_size((void *)rdata_with_pref, 1);
        tmp___12 = __builtin___snprintf_chk(rdata_with_pref, 6UL, 1, tmp___11, "%hu ",
                                            (int )tmp___10);
        num_printed = (uint8_t )tmp___12;
        tmp___13 = strlen((char const   *)rdata_name___0);
        memcpy((void * __restrict  )(rdata_with_pref + (int )num_printed), (void const   * __restrict  )rdata_name___0,
               tmp___13);
        fs_add_uint64(afs, "rdata_is_parsed", (uint64_t )1);
        fs_add_unsafe_string(afs, "rdata", rdata_with_pref, 1);
      }
    }
  } else
  if ((int )type == 16) {
    if ((int )rdlength >= 1) {
      if ((int )rdlength - 1 != (int )*((uint8_t *)rdata)) {
        log_warn("dns", "TXT record with wrong TXT len. Not processing.");
        fs_add_uint64(afs, "rdata_is_parsed", (uint64_t )0);
        fs_add_binary(afs, "rdata", (size_t )rdlength, (void *)rdata, 0);
      } else {
        fs_add_uint64(afs, "rdata_is_parsed", (uint64_t )1);
        tmp___14 = xmalloc((size_t )rdlength);
        txt = (char *)tmp___14;
        memcpy((void * __restrict  )txt, (void const   * __restrict  )(rdata + 1),
               (size_t )((int )rdlength - 1));
        fs_add_unsafe_string(afs, "rdata", txt, 1);
      }
    } else {
      fs_add_uint64(afs, "rdata_is_parsed", (uint64_t )1);
      tmp___14 = xmalloc((size_t )rdlength);
      txt = (char *)tmp___14;
      memcpy((void * __restrict  )txt, (void const   * __restrict  )(rdata + 1), (size_t )((int )rdlength - 1));
      fs_add_unsafe_string(afs, "rdata", txt, 1);
    }
  } else
  if ((int )type == 1) {
    if ((int )rdlength != 4) {
      log_warn("dns", "A record with IP of length %d. Not processing.", (int )rdlength);
      fs_add_uint64(afs, "rdata_is_parsed", (uint64_t )0);
      fs_add_binary(afs, "rdata", (size_t )rdlength, (void *)rdata, 0);
    } else {
      fs_add_uint64(afs, "rdata_is_parsed", (uint64_t )1);
      tmp___15 = inet_ntoa(*((struct in_addr *)rdata));
      tmp___16 = strdup((char const   *)tmp___15);
      addr = tmp___16;
      fs_add_unsafe_string(afs, "rdata", addr, 1);
    }
  } else
  if ((int )type == 28) {
    if ((int )rdlength != 16) {
      log_warn("dns", "AAAA record with IP of length %d. Not processing.", (int )rdlength);
      fs_add_uint64(afs, "rdata_is_parsed", (uint64_t )0);
      fs_add_binary(afs, "rdata", (size_t )rdlength, (void *)rdata, 0);
    } else {
      fs_add_uint64(afs, "rdata_is_parsed", (uint64_t )1);
      tmp___17 = xmalloc((size_t )46);
      ipv6_str = (char *)tmp___17;
      inet_ntop(10, (void const   * __restrict  )((struct sockaddr_in6 *)rdata), (char * __restrict  )ipv6_str,
                (socklen_t )46);
      fs_add_unsafe_string(afs, "rdata", ipv6_str, 1);
    }
  } else {
    fs_add_uint64(afs, "rdata_is_parsed", (uint64_t )0);
    fs_add_binary(afs, "rdata", (size_t )rdlength, (void *)rdata, 0);
  }
  fs_add_fieldset(list, (char const   *)((void *)0), afs);
  *data = ((*data + (int )bytes_consumed) + sizeof(dns_answer_tail )) + (int )rdlength;
  *data_len = (uint16_t )(((unsigned long )((int )*data_len - (int )bytes_consumed) - sizeof(dns_answer_tail )) - (unsigned long )rdlength);
  return ((bool )0);
}
}
static int dns_global_initialize(struct state_conf *conf )
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *qtype_str ;
  char **domains ;
  void *tmp___4 ;
  int i ;
  int arg_strlen ;
  size_t tmp___5 ;
  char *arg_pos ;
  int i___0 ;
  char *probe_q_delimiter_p ;
  char *tmp___6 ;
  char *probe_arg_delimiter_p ;
  char *tmp___7 ;
  size_t tmp___8 ;
  int domain_len ;
  size_t tmp___9 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t max_payload_len ;
  int ret ;
  int tmp___13 ;

  {
  num_questions = conf->packet_streams;
  if (num_questions < 1) {
    log_fatal("dns", "Invalid number of probes for the DNS module: %i", num_questions);
  }
  tmp = xmalloc(sizeof(char *) * (unsigned long )num_questions);
  dns_packets = (char **)tmp;
  tmp___0 = xmalloc(sizeof(uint16_t ) * (unsigned long )num_questions);
  dns_packet_lens = (uint16_t *)tmp___0;
  tmp___1 = xmalloc(sizeof(uint16_t ) * (unsigned long )num_questions);
  qname_lens = (uint16_t *)tmp___1;
  tmp___2 = xmalloc(sizeof(char *) * (unsigned long )num_questions);
  qnames = (char **)tmp___2;
  tmp___3 = xmalloc(sizeof(uint16_t ) * (unsigned long )num_questions);
  qtypes = (uint16_t *)tmp___3;
  qtype_str = (char *)((void *)0);
  tmp___4 = xmalloc(sizeof(char *) * (unsigned long )num_questions);
  domains = (char **)tmp___4;
  i = 0;
  while (i < num_questions) {
    *(domains + i) = (char *)(default_domain);
    *(qtypes + i) = (uint16_t )default_qtype;
    i ++;
  }
  num_ports___4 = ((int )conf->source_port_last - (int )conf->source_port_first) + 1;
  setup_qtype_str_map();
  if (conf->probe_args) {
    tmp___5 = strlen((char const   *)conf->probe_args);
    arg_strlen = (int )tmp___5;
    arg_pos = conf->probe_args;
    i___0 = 0;
    while (i___0 < num_questions) {
      if ((unsigned long )arg_pos >= (unsigned long )(conf->probe_args + arg_strlen)) {
        log_fatal("dns", "More probes than questions configured. Add additional questions.");
      }
      tmp___6 = strchr((char const   *)arg_pos, ',');
      probe_q_delimiter_p = tmp___6;
      tmp___7 = strchr((char const   *)arg_pos, ';');
      probe_arg_delimiter_p = tmp___7;
      if ((unsigned long )probe_q_delimiter_p == (unsigned long )((void *)0)) {
        log_fatal("dns", "Invalid probe args. Format: \"A,google.com\" or \"A,google.com;A,example.com\"");
      } else
      if ((unsigned long )probe_q_delimiter_p == (unsigned long )arg_pos) {
        log_fatal("dns", "Invalid probe args. Format: \"A,google.com\" or \"A,google.com;A,example.com\"");
      } else {
        tmp___8 = strlen((char const   *)arg_pos);
        if ((unsigned long )(arg_pos + tmp___8) == (unsigned long )(probe_q_delimiter_p + 1)) {
          log_fatal("dns", "Invalid probe args. Format: \"A,google.com\" or \"A,google.com;A,example.com\"");
        } else
        if ((unsigned long )probe_arg_delimiter_p == (unsigned long )((void *)0)) {
          if (i___0 + 1 != num_questions) {
            log_fatal("dns", "Invalid probe args. Format: \"A,google.com\" or \"A,google.com;A,example.com\"");
          }
        }
      }
      domain_len = 0;
      if (probe_arg_delimiter_p) {
        domain_len = (int )((probe_arg_delimiter_p - probe_q_delimiter_p) - 1L);
      } else {
        tmp___9 = strlen((char const   *)probe_q_delimiter_p);
        domain_len = (int )tmp___9;
      }
      if (! (domain_len > 0)) {
        __assert_fail("domain_len > 0", "src/probe_modules/module_dns.c", 637U, "dns_global_initialize");
      }
      tmp___11 = xmalloc((size_t )(domain_len + 1));
      *(domains + i___0) = (char *)tmp___11;
      strncpy((char * __restrict  )*(domains + i___0), (char const   * __restrict  )(probe_q_delimiter_p + 1),
              (size_t )domain_len);
      *(*(domains + i___0) + domain_len) = (char )'\000';
      tmp___12 = xmalloc((size_t )((probe_q_delimiter_p - arg_pos) + 1L));
      qtype_str = (char *)tmp___12;
      strncpy((char * __restrict  )qtype_str, (char const   * __restrict  )arg_pos,
              (size_t )(probe_q_delimiter_p - arg_pos));
      *(qtype_str + (probe_q_delimiter_p - arg_pos)) = (char )'\000';
      *(qtypes + i___0) = qtype_str_to_code((char const   *)qtype_str);
      free((void *)qtype_str);
      if (! *(qtypes + i___0)) {
        log_fatal("dns", "Incorrect qtype supplied. %s", qtype_str);
        return (1);
      }
      arg_pos = (probe_q_delimiter_p + domain_len) + 2;
      i___0 ++;
    }
    if ((unsigned long )arg_pos != (unsigned long )((conf->probe_args + arg_strlen) + 2)) {
      log_fatal("dns", "More args than probes passed. Add additional probes.");
    }
  }
  tmp___13 = build_global_dns_packets(domains, num_questions, & max_payload_len);
  ret = tmp___13;
  module_dns.max_packet_length = ((max_payload_len + sizeof(struct ether_header )) + sizeof(struct ip )) + sizeof(struct udphdr );
  return (ret);
}
}
static int dns_global_cleanup(struct state_conf *zconf___0  __attribute__((__unused__)) ,
                              struct state_send *zsend___0  __attribute__((__unused__)) ,
                              struct state_recv *zrecv___0  __attribute__((__unused__)) )
{
  int i ;
  int i___0 ;

  {
  if (dns_packets) {
    i = 0;
    while (i < num_questions) {
      if (*(dns_packets + i)) {
        free((void *)*(dns_packets + i));
      }
      i ++;
    }
    free((void *)dns_packets);
  }
  dns_packets = (char **)((void *)0);
  if (qnames) {
    i___0 = 0;
    while (i___0 < num_questions) {
      if (*(qnames + i___0)) {
        free((void *)*(qnames + i___0));
      }
      i___0 ++;
    }
    free((void *)qnames);
  }
  qnames = (char **)((void *)0);
  if (dns_packet_lens) {
    free((void *)dns_packet_lens);
  }
  if (qname_lens) {
    free((void *)qname_lens);
  }
  if (qtypes) {
    free((void *)qtypes);
  }
  return (0);
}
}
int dns_init_perthread(void *buf , macaddr_t *src , macaddr_t *gw , port_h_t dst_port  __attribute__((__unused__)) ,
                       void **arg_ptr  __attribute__((__unused__)) )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  uint16_t len ;
  __uint16_t tmp ;
  struct udphdr *udp_header ;
  char *payload ;

  {
  memset(buf, 0, (size_t )4096);
  eth_header = (struct ether_header *)buf;
  make_eth_header(eth_header, src, gw);
  ip_header = (struct ip *)(eth_header + 1);
  tmp = __bswap_16((__uint16_t )((sizeof(struct ip ) + sizeof(struct udphdr )) + (unsigned long )*(dns_packet_lens + 0)));
  len = tmp;
  make_ip_header(ip_header, (uint8_t )17, len);
  udp_header = (struct udphdr *)(ip_header + 1);
  len = (uint16_t )(sizeof(struct udphdr ) + (unsigned long )*(dns_packet_lens + 0));
  make_udp_header(udp_header, zconf.target_port, len);
  payload = (char *)(udp_header + 1);
  memcpy((void * __restrict  )payload, (void const   * __restrict  )*(dns_packets + 0),
         (size_t )*(dns_packet_lens + 0));
  return (0);
}
}
int dns_make_packet(void *buf , size_t *buf_len , ipaddr_n_t src_ip , ipaddr_n_t dst_ip ,
                    uint8_t ttl , uint32_t *validation , int probe_num , void *arg  __attribute__((__unused__)) )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  struct udphdr *udp_header ;
  uint16_t encoded_len ;
  __uint16_t tmp ;
  __uint16_t tmp___0 ;
  char *payload ;
  uint16_t tmp___2 ;
  dns_header *dns_header_p ;

  {
  eth_header = (struct ether_header *)buf;
  ip_header = (struct ip *)(eth_header + 1);
  udp_header = (struct udphdr *)(ip_header + 1);
  if (num_questions > 1) {
    tmp = __bswap_16((__uint16_t )((sizeof(struct ip ) + sizeof(struct udphdr )) + (unsigned long )*(dns_packet_lens + probe_num)));
    encoded_len = tmp;
    make_ip_header(ip_header, (uint8_t )17, encoded_len);
    encoded_len = (uint16_t )(sizeof(struct udphdr ) + (unsigned long )*(dns_packet_lens + probe_num));
    tmp___0 = __bswap_16(udp_header->__annonCompField5.__annonCompField3.uh_dport);
    make_udp_header(udp_header, tmp___0, encoded_len);
    payload = (char *)(udp_header + 1);
    *buf_len = ((sizeof(struct ether_header ) + sizeof(struct ip )) + sizeof(struct udphdr )) + (unsigned long )*(dns_packet_lens + probe_num);
    if (! (*buf_len <= 4096UL)) {
      __assert_fail("*buf_len <= MAX_PACKET_SIZE", "src/probe_modules/module_dns.c",
                    766U, "dns_make_packet");
    }
    memcpy((void * __restrict  )payload, (void const   * __restrict  )*(dns_packets + probe_num),
           (size_t )*(dns_packet_lens + probe_num));
  }
  ip_header->ip_src.s_addr = src_ip;
  ip_header->ip_dst.s_addr = dst_ip;
  ip_header->ip_ttl = ttl;
  tmp___2 = get_src_port(num_ports___4, probe_num, validation);
  udp_header->__annonCompField5.__annonCompField3.uh_sport = __bswap_16(tmp___2);
  dns_header_p = (dns_header *)(udp_header + 1);
  dns_header_p->id = (uint16_t )(*(validation + 2) & 65535U);
  ip_header->ip_sum = (unsigned short)0;
  ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
  return (0);
}
}
void dns_print_packet(FILE *fp , void *packet )
{
  struct ether_header *ethh ;
  struct ip *iph ;
  struct udphdr *udph ;
  __uint16_t tmp ;
  __uint16_t tmp___0 ;
  __uint16_t tmp___1 ;

  {
  ethh = (struct ether_header *)packet;
  iph = (struct ip *)(ethh + 1);
  udph = (struct udphdr *)(iph + 1);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"------------------------------------------------------\n");
  tmp = __bswap_16(udph->__annonCompField5.__annonCompField3.uh_sum);
  tmp___0 = __bswap_16(udph->__annonCompField5.__annonCompField3.uh_dport);
  tmp___1 = __bswap_16(udph->__annonCompField5.__annonCompField3.uh_sport);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"dns { source: %u | dest: %u | checksum: %#04X }\n",
                (int )tmp___1, (int )tmp___0, (int )tmp);
  fprintf_ip_header(fp, iph);
  fprintf_eth_header(fp, ethh);
  __fprintf_chk((FILE * __restrict  )fp, 1, (char const   * __restrict  )"------------------------------------------------------\n");
  return;
}
}
int dns_validate_packet(struct ip  const  *ip_hdr , uint32_t len , uint32_t *src_ip ,
                        uint32_t *validation )
{
  int tmp ;
  struct udphdr *udp ;
  struct udphdr *tmp___0 ;
  uint16_t udp_len ;
  __uint16_t tmp___1 ;
  int match ;
  int i ;

  {
  tmp = udp_do_validate_packet(ip_hdr, len, src_ip, validation, num_ports___4, (int )zconf.target_port);
  if (tmp == 0) {
    return (0);
  }
  if ((int const   )ip_hdr->ip_p == 17) {
    tmp___0 = get_udp_header(ip_hdr, len);
    udp = tmp___0;
    if (! udp) {
      return (0);
    }
    tmp___1 = __bswap_16(udp->__annonCompField5.__annonCompField3.uh_ulen);
    udp_len = tmp___1;
    match = 0;
    i = 0;
    while (i < num_questions) {
      if ((int )udp_len >= (int )*(dns_packet_lens + i)) {
        match ++;
      }
      i ++;
    }
    if (match == 0) {
      return (0);
    }
    if (len < (uint32_t )udp_len) {
      return (0);
    }
  }
  return (1);
}
}
void dns_add_null_fs(fieldset_t *fs )
{
  fieldset_t *tmp ;
  fieldset_t *tmp___0 ;
  fieldset_t *tmp___1 ;
  fieldset_t *tmp___2 ;

  {
  fs_add_null(fs, "dns_id");
  fs_add_null(fs, "dns_rd");
  fs_add_null(fs, "dns_tc");
  fs_add_null(fs, "dns_aa");
  fs_add_null(fs, "dns_opcode");
  fs_add_null(fs, "dns_qr");
  fs_add_null(fs, "dns_rcode");
  fs_add_null(fs, "dns_cd");
  fs_add_null(fs, "dns_ad");
  fs_add_null(fs, "dns_z");
  fs_add_null(fs, "dns_ra");
  fs_add_null(fs, "dns_qdcount");
  fs_add_null(fs, "dns_ancount");
  fs_add_null(fs, "dns_nscount");
  fs_add_null(fs, "dns_arcount");
  tmp = fs_new_repeated_fieldset();
  fs_add_repeated(fs, "dns_questions", tmp);
  tmp___0 = fs_new_repeated_fieldset();
  fs_add_repeated(fs, "dns_answers", tmp___0);
  tmp___1 = fs_new_repeated_fieldset();
  fs_add_repeated(fs, "dns_authorities", tmp___1);
  tmp___2 = fs_new_repeated_fieldset();
  fs_add_repeated(fs, "dns_additionals", tmp___2);
  fs_add_uint64(fs, "dns_parse_err", (uint64_t )1);
  fs_add_uint64(fs, "dns_unconsumed_bytes", (uint64_t )0);
  return;
}
}
void dns_process_packet(u_char const   *packet , uint32_t len , fieldset_t *fs , uint32_t *validation ,
                        struct timespec ts  __attribute__((__unused__)) )
{
  struct ip *ip_hdr ;
  struct udphdr *udp_hdr ;
  struct udphdr *tmp ;
  uint16_t udp_len ;
  __uint16_t tmp___1 ;
  int match ;
  bool is_valid ;
  int i ;
  char *qname_p ;
  dns_question_tail *tail_p ;
  dns_header *dns_header_p ;
  __uint16_t tmp___2 ;
  __uint16_t tmp___3 ;
  int tmp___4 ;
  dns_header *dns_hdr ;
  uint16_t qr ;
  uint16_t rcode ;
  __uint16_t tmp___6 ;
  __uint16_t tmp___7 ;
  int tmp___8 ;
  __uint16_t tmp___9 ;
  __uint16_t tmp___10 ;
  __uint16_t tmp___11 ;
  __uint16_t tmp___12 ;
  __uint16_t tmp___13 ;
  char *data ;
  uint16_t data_len ;
  bool err ;
  fieldset_t *list ;
  fieldset_t *tmp___14 ;
  int i___0 ;
  __uint16_t tmp___15 ;
  int i___1 ;
  __uint16_t tmp___16 ;
  int i___2 ;
  __uint16_t tmp___17 ;
  int i___3 ;
  __uint16_t tmp___18 ;

  {
  ip_hdr = (struct ip *)(packet + sizeof(struct ether_header ));
  if ((int )ip_hdr->ip_p == 17) {
    tmp = get_udp_header((struct ip  const  *)ip_hdr, len);
    udp_hdr = tmp;
    if (! udp_hdr) {
      __assert_fail("udp_hdr", "src/probe_modules/module_dns.c", 869U, "dns_process_packet");
    }
    tmp___1 = __bswap_16(udp_hdr->__annonCompField5.__annonCompField3.uh_ulen);
    udp_len = tmp___1;
    match = 0;
    is_valid = (bool )0;
    i = 0;
    while (i < num_questions) {
      if ((int )udp_len < (int )*(dns_packet_lens + i)) {
        goto __Cont;
      }
      match ++;
      qname_p = (char *)((void *)0);
      tail_p = (dns_question_tail *)((void *)0);
      dns_header_p = (dns_header *)(udp_hdr + 1);
      if ((unsigned int )dns_header_p->id == (*(validation + 2) & 65535U)) {
        qname_p = (char *)dns_header_p + sizeof(dns_header );
        tail_p = (dns_question_tail *)((*(dns_packets + i) + sizeof(dns_header )) + (int )*(qname_lens + i));
        tmp___4 = strcmp((char const   *)*(qnames + i), (char const   *)qname_p);
        if (tmp___4 == 0) {
          tmp___2 = __bswap_16(*(qtypes + i));
          if ((int )tail_p->qtype == (int )tmp___2) {
            tmp___3 = __bswap_16((__uint16_t )1);
            if ((int )tail_p->qclass == (int )tmp___3) {
              is_valid = (bool )1;
              break;
            }
          }
        }
      }
      __Cont: /* CIL Label */
      i ++;
    }
    if (! (match > 0)) {
      __assert_fail("match > 0", "src/probe_modules/module_dns.c", 903U, "dns_process_packet");
    }
    dns_hdr = (dns_header *)(udp_hdr + 1);
    qr = (uint16_t )dns_hdr->qr;
    rcode = (uint16_t )dns_hdr->rcode;
    tmp___6 = __bswap_16(udp_hdr->__annonCompField5.__annonCompField3.uh_sport);
    fs_add_uint64(fs, "sport", (uint64_t )tmp___6);
    tmp___7 = __bswap_16(udp_hdr->__annonCompField5.__annonCompField3.uh_dport);
    fs_add_uint64(fs, "dport", (uint64_t )tmp___7);
    fs_add_string(fs, "classification", (char *)"dns", 0);
    fs_add_bool(fs, "success", (int )is_valid);
    if (is_valid) {
      if ((int )qr == 1) {
        if ((int )rcode == 0) {
          tmp___8 = 1;
        } else {
          tmp___8 = 0;
        }
      } else {
        tmp___8 = 0;
      }
    } else {
      tmp___8 = 0;
    }
    fs_add_bool(fs, "app_success", tmp___8);
    fs_add_null_icmp(fs);
    fs_add_uint64(fs, "udp_len", (uint64_t )udp_len);
    if (! is_valid) {
      dns_add_null_fs(fs);
    } else {
      tmp___9 = __bswap_16(dns_hdr->id);
      fs_add_uint64(fs, "dns_id", (uint64_t )tmp___9);
      fs_add_uint64(fs, "dns_rd", (uint64_t )dns_hdr->rd);
      fs_add_uint64(fs, "dns_tc", (uint64_t )dns_hdr->tc);
      fs_add_uint64(fs, "dns_aa", (uint64_t )dns_hdr->aa);
      fs_add_uint64(fs, "dns_opcode", (uint64_t )dns_hdr->opcode);
      fs_add_uint64(fs, "dns_qr", (uint64_t )qr);
      fs_add_uint64(fs, "dns_rcode", (uint64_t )rcode);
      fs_add_uint64(fs, "dns_cd", (uint64_t )dns_hdr->cd);
      fs_add_uint64(fs, "dns_ad", (uint64_t )dns_hdr->ad);
      fs_add_uint64(fs, "dns_z", (uint64_t )dns_hdr->z);
      fs_add_uint64(fs, "dns_ra", (uint64_t )dns_hdr->ra);
      tmp___10 = __bswap_16(dns_hdr->qdcount);
      fs_add_uint64(fs, "dns_qdcount", (uint64_t )tmp___10);
      tmp___11 = __bswap_16(dns_hdr->ancount);
      fs_add_uint64(fs, "dns_ancount", (uint64_t )tmp___11);
      tmp___12 = __bswap_16(dns_hdr->nscount);
      fs_add_uint64(fs, "dns_nscount", (uint64_t )tmp___12);
      tmp___13 = __bswap_16(dns_hdr->arcount);
      fs_add_uint64(fs, "dns_arcount", (uint64_t )tmp___13);
      data = (char *)dns_hdr + sizeof(dns_header );
      data_len = (uint16_t )(((unsigned long )udp_len - sizeof(udp_hdr)) - sizeof(dns_header ));
      err = (bool )0;
      tmp___14 = fs_new_repeated_fieldset();
      list = tmp___14;
      i___0 = 0;
      while (1) {
        tmp___15 = __bswap_16(dns_hdr->qdcount);
        if (i___0 < (int )tmp___15) {
          if (! (! err)) {
            break;
          }
        } else {
          break;
        }
        err = process_response_question(& data, & data_len, (char const   *)((char *)dns_hdr),
                                        udp_len, list);
        i___0 ++;
      }
      fs_add_repeated(fs, "dns_questions", list);
      list = fs_new_repeated_fieldset();
      i___1 = 0;
      while (1) {
        tmp___16 = __bswap_16(dns_hdr->ancount);
        if (i___1 < (int )tmp___16) {
          if (! (! err)) {
            break;
          }
        } else {
          break;
        }
        err = process_response_answer(& data, & data_len, (char const   *)((char *)dns_hdr),
                                      udp_len, list);
        i___1 ++;
      }
      fs_add_repeated(fs, "dns_answers", list);
      list = fs_new_repeated_fieldset();
      i___2 = 0;
      while (1) {
        tmp___17 = __bswap_16(dns_hdr->nscount);
        if (i___2 < (int )tmp___17) {
          if (! (! err)) {
            break;
          }
        } else {
          break;
        }
        err = process_response_answer(& data, & data_len, (char const   *)((char *)dns_hdr),
                                      udp_len, list);
        i___2 ++;
      }
      fs_add_repeated(fs, "dns_authorities", list);
      list = fs_new_repeated_fieldset();
      i___3 = 0;
      while (1) {
        tmp___18 = __bswap_16(dns_hdr->arcount);
        if (i___3 < (int )tmp___18) {
          if (! (! err)) {
            break;
          }
        } else {
          break;
        }
        err = process_response_answer(& data, & data_len, (char const   *)((char *)dns_hdr),
                                      udp_len, list);
        i___3 ++;
      }
      fs_add_repeated(fs, "dns_additionals", list);
      if ((int )data_len != 0) {
        err = (bool )1;
      }
      fs_add_uint64(fs, "dns_parse_err", (uint64_t )err);
      fs_add_uint64(fs, "dns_unconsumed_bytes", (uint64_t )data_len);
    }
    fs_add_binary(fs, "raw_data", (unsigned long )udp_len - sizeof(struct udphdr ),
                  (void *)(udp_hdr + 1), 0);
  } else
  if ((int )ip_hdr->ip_p == 1) {
    fs_add_null(fs, "sport");
    fs_add_null(fs, "dport");
    fs_add_constchar(fs, "classification", "icmp");
    fs_add_bool(fs, "success", 0);
    fs_add_bool(fs, "app_success", 0);
    fs_populate_icmp_from_iphdr(ip_hdr, (size_t )len, fs);
    fs_add_null(fs, "udp_len");
    dns_add_null_fs(fs);
    fs_add_binary(fs, "raw_data", (size_t )len, (void *)((char *)packet), 0);
  } else {
    log_fatal("dns", "Die. This can only happen if you change the pcap filter and don\'t update the process function.");
  }
  return;
}
}
static fielddef_t fields___6[32]  =
  {      {"sport", "int", "UDP source port"},
        {"dport", "int", "UDP destination port"},
        {"classification", "string", "packet classification"},
        {"success", "bool", "is response considered success"},
        {"app_success", "bool", "Is the RA bit set with no error code?"},
        {"icmp_responder", "string", "Source IP of ICMP_UNREACH messages"},
        {"icmp_type", "int", "icmp message type"},
        {"icmp_code", "int", "icmp message sub type code"},
        {"icmp_unreach_str", "string", "for icmp_unreach responses, the string version of icmp_code (e.g. network-unreach)"},
        {"udp_len",
      "int", "UDP packet lenght"},
        {"dns_id", "int", "DNS transaction ID"},
        {"dns_rd", "int", "DNS recursion desired"},
        {"dns_tc", "int", "DNS packet truncated"},
        {"dns_aa", "int", "DNS authoritative answer"},
        {"dns_opcode", "int", "DNS opcode (query type)"},
        {"dns_qr", "int", "DNS query(0) or response (1)"},
        {"dns_rcode", "int", "DNS response code"},
        {"dns_cd", "int", "DNS checking disabled"},
        {"dns_ad", "int", "DNS authenticated data"},
        {"dns_z", "int", "DNS reserved"},
        {"dns_ra", "int", "DNS recursion available"},
        {"dns_qdcount", "int", "DNS number questions"},
        {"dns_ancount", "int", "DNS number answer RR\'s"},
        {"dns_nscount", "int", "DNS number NS RR\'s in authority section"},
        {"dns_arcount", "int", "DNS number additional RR\'s"},
        {"dns_questions", "repeated", "DNS question list"},
        {"dns_answers", "repeated", "DNS answer list"},
        {"dns_authorities", "repeated", "DNS authority list"},
        {"dns_additionals", "repeated", "DNS additional list"},
        {"dns_parse_err", "int", "Problem parsing the DNS response"},
        {"dns_unconsumed_bytes", "int", "Bytes left over when parsing the DNS response"},
        {"raw_data",
      "binary", "UDP payload"}};
probe_module_t module_dns  =
     {"dns", (size_t )0, "udp || icmp", (size_t )1500, (uint8_t )1, & dns_global_initialize,
    & dns_init_perthread, & dns_make_packet, & dns_print_packet, & dns_validate_packet,
    (void (*)(u_char const   *packetbuf , uint32_t len , fieldset_t * , uint32_t *validation ,
              struct timespec  const  ts ))(& dns_process_packet), & dns_global_cleanup,
    2, fields___6, (int )(sizeof(fields___6) / sizeof(fields___6[0])), "This module sends out DNS queries and parses basic responses. By default, the module will perform an A record lookup for google.com. You can specify other queries using the --probe-args argument in the form: \'type,query\', e.g. \'A,google.com\'. The module supports sending the the following types: of queries: A, NS, CNAME, SOA, PTR, MX, TXT, AAAA, RRSIG, and ALL. The module will accept and attempt to parse all DNS responses. There is currently support for parsing out full data from A, NS, CNAME, MX, TXT, and AAAA. Any other types will be output in raw form."};
#pragma merger("0","/tmp/cil-Y25XbCHJ.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
__inline static uint8_t *get_udp_payload(struct udphdr  const  *udp , uint32_t len  __attribute__((__unused__)) )
{


  {
  return ((uint8_t *)(udp + 1));
}
}
static int num_ports___5  ;
static uint8_t bacnet_body[7]  = {      (uint8_t )12,      (uint8_t )2,      (uint8_t )63,      (uint8_t )255,
        (uint8_t )255,      (uint8_t )25,      (uint8_t )75};
__inline static uint8_t get_invoke_id(uint32_t *validation )
{


  {
  return ((uint8_t )((*(validation + 1) >> 24) & 255U));
}
}
int bacnet_init_perthread(void *buf , macaddr_t *src , macaddr_t *gw , port_h_t dst_port  __attribute__((__unused__)) ,
                          void **arg )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  struct udphdr *udp_header ;
  struct bacnet_probe *bnp ;
  uint8_t *body ;
  uint16_t ip_len ;
  __uint16_t tmp___0 ;
  uint16_t udp_len ;
  uint32_t seed ;
  uint64_t tmp___1 ;
  aesrand_t *aes ;
  aesrand_t *tmp___2 ;

  {
  memset(buf, 0, (size_t )4096);
  eth_header = (struct ether_header *)buf;
  ip_header = (struct ip *)(eth_header + 1);
  udp_header = (struct udphdr *)(ip_header + 1);
  bnp = (struct bacnet_probe *)(udp_header + 1);
  body = (uint8_t *)(bnp + 1);
  make_eth_header(eth_header, src, gw);
  ip_len = (uint16_t )((sizeof(struct ip ) + sizeof(struct udphdr )) + 17UL);
  if (! ((int )ip_len <= 4096)) {
    __assert_fail("ip_len <= MAX_PACKET_SIZE", "src/probe_modules/module_bacnet.c",
                  51U, "bacnet_init_perthread");
  }
  tmp___0 = __bswap_16(ip_len);
  make_ip_header(ip_header, (uint8_t )17, tmp___0);
  udp_len = (uint16_t )(sizeof(struct udphdr ) + 17UL);
  make_udp_header(udp_header, zconf.target_port, udp_len);
  bnp->vlc.type = (uint8_t )129;
  bnp->vlc.function = (uint8_t )10;
  bnp->vlc.length = __bswap_16((__uint16_t )17);
  bnp->npdu.version = (uint8_t )1;
  bnp->npdu.control = (uint8_t )4;
  bnp->apdu.type_flags = (uint8_t )0;
  bnp->apdu.max_segments_apdu = (uint8_t )5;
  bnp->apdu.server_choice = (uint8_t )12;
  memcpy((void * __restrict  )body, (void const   * __restrict  )(bacnet_body), (size_t )7);
  tmp___1 = aesrand_getword(zconf.aes);
  seed = (uint32_t )tmp___1;
  tmp___2 = aesrand_init_from_seed((uint64_t )seed);
  aes = tmp___2;
  *arg = (void *)aes;
  return (0);
}
}
int bacnet_make_packet(void *buf , size_t *buf_len , ipaddr_n_t src_ip , ipaddr_n_t dst_ip ,
                       uint8_t ttl , uint32_t *validation , int probe_num , void *arg  __attribute__((__unused__)) )
{
  struct ether_header *eth_header ;
  struct ip *ip_header ;
  struct udphdr *udp_header ;
  struct bacnet_probe *bnp ;
  uint16_t tmp ;

  {
  eth_header = (struct ether_header *)buf;
  ip_header = (struct ip *)(eth_header + 1);
  udp_header = (struct udphdr *)(ip_header + 1);
  bnp = (struct bacnet_probe *)(udp_header + 1);
  ip_header->ip_src.s_addr = src_ip;
  ip_header->ip_dst.s_addr = dst_ip;
  ip_header->ip_ttl = ttl;
  ip_header->ip_sum = (unsigned short)0;
  tmp = get_src_port(num_ports___5, probe_num, validation);
  udp_header->__annonCompField5.__annonCompField3.uh_sport = __bswap_16(tmp);
  bnp->apdu.invoke_id = get_invoke_id(validation);
  ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
  *buf_len = ((sizeof(struct ether_header ) + sizeof(struct ip )) + sizeof(struct udphdr )) + 17UL;
  return (0);
}
}
int bacnet_validate_packet(struct ip  const  *ip_hdr , uint32_t len , uint32_t *src_ip ,
                           uint32_t *validation )
{
  int tmp ;
  struct udphdr *udp ;
  struct udphdr *tmp___0 ;
  size_t min_len ;
  struct bacnet_vlc *vlc ;
  uint8_t *tmp___1 ;

  {
  tmp = udp_do_validate_packet(ip_hdr, len, src_ip, validation, num_ports___5, (int )zconf.target_port);
  if (tmp == 0) {
    return (0);
  }
  if ((int const   )ip_hdr->ip_p == 17) {
    tmp___0 = get_udp_header(ip_hdr, len);
    udp = tmp___0;
    if (! udp) {
      return (0);
    }
    min_len = sizeof(struct udphdr ) + sizeof(struct bacnet_vlc );
    if ((size_t )udp->__annonCompField5.__annonCompField3.uh_ulen < min_len) {
      return (0);
    }
    tmp___1 = get_udp_payload((struct udphdr  const  *)udp, len);
    vlc = (struct bacnet_vlc *)tmp___1;
    if ((int )vlc->type != 129) {
      return (0);
    }
  }
  return (1);
}
}
void bacnet_process_packet(u_char const   *packet , uint32_t len , fieldset_t *fs ,
                           uint32_t *validation  __attribute__((__unused__)) , struct timespec ts  __attribute__((__unused__)) )
{
  struct ip *ip_hdr ;
  struct ip *tmp ;
  struct udphdr *udp ;
  struct udphdr *tmp___1 ;
  __uint16_t tmp___3 ;
  __uint16_t tmp___4 ;
  uint32_t udp_offset ;
  uint32_t payload_offset ;
  uint8_t *payload ;
  uint8_t *tmp___6 ;
  uint32_t payload_len ;

  {
  tmp = get_ip_header(packet, len);
  ip_hdr = tmp;
  if (! ip_hdr) {
    __assert_fail("ip_hdr", "src/probe_modules/module_bacnet.c", 134U, "bacnet_process_packet");
  }
  if ((int )ip_hdr->ip_p == 17) {
    tmp___1 = get_udp_header((struct ip  const  *)ip_hdr, len);
    udp = tmp___1;
    if (! udp) {
      __assert_fail("udp", "src/probe_modules/module_bacnet.c", 137U, "bacnet_process_packet");
    }
    tmp___3 = __bswap_16(udp->__annonCompField5.__annonCompField3.uh_sport);
    fs_add_uint64(fs, "sport", (uint64_t )tmp___3);
    tmp___4 = __bswap_16(udp->__annonCompField5.__annonCompField3.uh_dport);
    fs_add_uint64(fs, "dport", (uint64_t )tmp___4);
    fs_add_constchar(fs, "classification", "bacnet");
    fs_add_bool(fs, "success", 1);
    fs_add_null_icmp(fs);
    udp_offset = (uint32_t )(sizeof(struct ether_header ) + (unsigned long )(ip_hdr->ip_hl * 4U));
    payload_offset = (uint32_t )((unsigned long )udp_offset + sizeof(struct udphdr ));
    if (! (payload_offset < len)) {
      __assert_fail("payload_offset < len", "src/probe_modules/module_bacnet.c", 145U,
                    "bacnet_process_packet");
    }
    tmp___6 = get_udp_payload((struct udphdr  const  *)udp, len);
    payload = tmp___6;
    payload_len = len - payload_offset;
    fs_add_binary(fs, "udp_payload", (size_t )payload_len, (void *)payload, 0);
    fs_add_null_icmp(fs);
  } else
  if ((int )ip_hdr->ip_p == 1) {
    fs_add_null(fs, "sport");
    fs_add_null(fs, "dport");
    fs_add_constchar(fs, "classification", "icmp");
    fs_add_bool(fs, "success", 0);
    fs_add_null(fs, "udp_payload");
    fs_populate_icmp_from_iphdr(ip_hdr, (size_t )len, fs);
  }
  return;
}
}
int bacnet_global_initialize(struct state_conf *conf )
{


  {
  num_ports___5 = ((int )conf->source_port_last - (int )conf->source_port_first) + 1;
  return (0);
}
}
static fielddef_t fields___7[9]  =
  {      {"sport", "int", "UDP source port"},
        {"dport", "int", "UDP destination port"},
        {"classification", "string", "packet classification"},
        {"success", "bool", "is response considered success"},
        {"udp_payload", "binary", "UDP payload"},
        {"icmp_responder", "string", "Source IP of ICMP_UNREACH messages"},
        {"icmp_type", "int", "icmp message type"},
        {"icmp_code", "int", "icmp message sub type code"},
        {"icmp_unreach_str", "string", "for icmp_unreach responses, the string version of icmp_code (e.g. network-unreach)"}};
probe_module_t module_bacnet  =
     {"bacnet", ((sizeof(struct ether_header ) + sizeof(struct ip )) + sizeof(struct udphdr )) + 17UL,
    "udp || icmp", (size_t )1500, (uint8_t )1, & bacnet_global_initialize, & bacnet_init_perthread,
    & bacnet_make_packet, & udp_print_packet, & bacnet_validate_packet, (void (*)(u_char const   *packetbuf ,
                                                                                  uint32_t len ,
                                                                                  fieldset_t * ,
                                                                                  uint32_t *validation ,
                                                                                  struct timespec  const  ts ))(& bacnet_process_packet),
    & udp_global_cleanup, 1, fields___7, (int )(sizeof(fields___7) / sizeof(fields___7[0])),
    (char const   *)0};
#pragma merger("0","/tmp/cil-b7hbuZre.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern void check_and_log_file_error(FILE *file , char const   *name ) ;
static FILE *file  =    (FILE *)((void *)0);
int csv_init(struct state_conf *conf , char const   **fields___8 , int fieldlens )
{
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int i ;

  {
  if (! conf) {
    __assert_fail("conf", "src/output_modules/module_csv.c", 29U, "csv_init");
  }
  if (conf->output_filename) {
    tmp___2 = strcmp((char const   *)conf->output_filename, "-");
    if (tmp___2) {
      file = fopen((char const   * __restrict  )conf->output_filename, (char const   * __restrict  )"w");
      if (! file) {
        tmp___0 = __errno_location();
        tmp___1 = strerror(*tmp___0);
        log_fatal("csv", "could not open CSV output file (%s): %s", conf->output_filename,
                  tmp___1);
      }
    } else {
      file = stdout;
    }
  } else {
    file = stdout;
    log_debug("csv", "no output file selected, will use stdout");
  }
  if (! conf->no_header_row) {
    log_debug("csv", "more than one field, will add headers");
    i = 0;
    while (i < fieldlens) {
      if (i) {
        __fprintf_chk((FILE * __restrict  )file, 1, (char const   * __restrict  )",");
      }
      __fprintf_chk((FILE * __restrict  )file, 1, (char const   * __restrict  )"%s",
                    *(fields___8 + i));
      i ++;
    }
    __fprintf_chk((FILE * __restrict  )file, 1, (char const   * __restrict  )"\n");
  }
  check_and_log_file_error(file, "csv");
  return (0);
}
}
int csv_close(struct state_conf *c  __attribute__((__unused__)) , struct state_send *s  __attribute__((__unused__)) ,
              struct state_recv *r  __attribute__((__unused__)) )
{


  {
  if (file) {
    fflush(file);
    fclose(file);
  }
  return (0);
}
}
static void hex_encode___0(FILE *f , unsigned char *readbuf , size_t len )
{
  size_t i ;

  {
  i = (size_t )0;
  while (i < len) {
    __fprintf_chk((FILE * __restrict  )f, 1, (char const   * __restrict  )"%02x",
                  (int )*(readbuf + i));
    i ++;
  }
  check_and_log_file_error(f, "csv");
  return;
}
}
int csv_process(fieldset_t *fs )
{
  int i ;
  field_t *f ;
  char *tmp ;

  {
  if (! file) {
    return (0);
  }
  i = 0;
  while (i < fs->len) {
    f = & fs->fields[i];
    if (i) {
      __fprintf_chk((FILE * __restrict  )file, 1, (char const   * __restrict  )",");
    }
    if (f->type == 1) {
      tmp = strchr((char const   *)((char *)f->value.ptr), ',');
      if (tmp) {
        __fprintf_chk((FILE * __restrict  )file, 1, (char const   * __restrict  )"\"%s\"",
                      (char *)f->value.ptr);
      } else {
        __fprintf_chk((FILE * __restrict  )file, 1, (char const   * __restrict  )"%s",
                      (char *)f->value.ptr);
      }
    } else
    if (f->type == 2) {
      __fprintf_chk((FILE * __restrict  )file, 1, (char const   * __restrict  )"%lu",
                    f->value.num);
    } else
    if (f->type == 7) {
      __fprintf_chk((FILE * __restrict  )file, 1, (char const   * __restrict  )"%i",
                    (int )f->value.num);
    } else
    if (f->type == 3) {
      hex_encode___0(file, (unsigned char *)f->value.ptr, f->len);
    } else
    if (! (f->type == 4)) {
      log_fatal("csv", "received unknown output type");
    }
    i ++;
  }
  __fprintf_chk((FILE * __restrict  )file, 1, (char const   * __restrict  )"\n");
  fflush(file);
  check_and_log_file_error(file, "csv");
  return (0);
}
}
output_module_t module_csv_file  =
     {"csv", 0, 0U, & csv_init, (int (*)(struct state_conf * , struct state_send * ,
                                       struct state_recv * ))((void *)0), (int (*)(struct state_conf * ,
                                                                                   struct state_send * ,
                                                                                   struct state_recv * ))((void *)0),
    & csv_close, & csv_process, "Outputs one or more output fields as a comma-delimited file. By default, the probe module does not filter out duplicates or limit to successful fields, but rather includes all received packets. Fields can be controlled by setting --output-fields. Filtering out failures and duplicate packets can be achieved by setting an --output-filter."};
#pragma merger("0","/tmp/cil-ijhsfeGP.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern char const   *json_object_to_json_string_ext(struct json_object *obj , int flags ) ;
extern struct json_object *json_object_new_boolean(json_bool b ) ;
static FILE *file___0  =    (FILE *)((void *)0);
int json_output_file_init(struct state_conf *conf , char const   **fields___8  __attribute__((__unused__)) ,
                          int fieldlens  __attribute__((__unused__)) )
{
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  if (! conf) {
    __assert_fail("conf", "src/output_modules/module_json.c", 39U, "json_output_file_init");
  }
  if (! conf->output_filename) {
    file___0 = stdout;
  } else {
    tmp___2 = strcmp((char const   *)conf->output_filename, "-");
    if (tmp___2) {
      file___0 = fopen((char const   * __restrict  )conf->output_filename, (char const   * __restrict  )"w");
      if (! file___0) {
        tmp___0 = __errno_location();
        tmp___1 = strerror(*tmp___0);
        log_fatal("output-json", "could not open JSON output file (%s): %s", conf->output_filename,
                  tmp___1);
      }
    } else {
      file___0 = stdout;
    }
  }
  check_and_log_file_error(file___0, "json");
  return (0);
}
}
char *hex_encode(unsigned char *packet , int buflen )
{
  char *buf ;
  void *tmp ;
  int i ;
  unsigned long tmp___0 ;

  {
  tmp = xmalloc((size_t )(2 * buflen + 1));
  buf = (char *)tmp;
  i = 0;
  while (i < buflen) {
    tmp___0 = __builtin_object_size((void *)(buf + i * 2), 1);
    __builtin___snprintf_chk(buf + i * 2, 3UL, 1, tmp___0, "%.2x", (int )*(packet + i));
    i ++;
  }
  *(buf + buflen * 2) = (char)0;
  return (buf);
}
}
json_object *fs_to_jsonobj(fieldset_t *fs ) ;
json_object *repeated_to_jsonobj(fieldset_t *fs ) ;
json_object *field_to_jsonobj(field_t *f )
{
  struct json_object *tmp ;
  struct json_object *tmp___0 ;
  struct json_object *tmp___1 ;
  char *encoded ;
  char *tmp___2 ;
  json_object *t ;
  struct json_object *tmp___3 ;
  json_object *tmp___4 ;
  json_object *tmp___5 ;

  {
  if (f->type == 1) {
    tmp = json_object_new_string((char const   *)((char *)f->value.ptr));
    return (tmp);
  } else
  if (f->type == 2) {
    tmp___0 = json_object_new_int64((int64_t )f->value.num);
    return (tmp___0);
  } else
  if (f->type == 7) {
    tmp___1 = json_object_new_boolean((json_bool )f->value.num);
    return (tmp___1);
  } else
  if (f->type == 3) {
    tmp___2 = hex_encode((unsigned char *)f->value.ptr, (int )f->len);
    encoded = tmp___2;
    tmp___3 = json_object_new_string((char const   *)encoded);
    t = tmp___3;
    free((void *)encoded);
    return (t);
  } else
  if (f->type == 4) {
    return ((json_object *)((void *)0));
  } else
  if (f->type == 5) {
    tmp___4 = fs_to_jsonobj((fieldset_t *)f->value.ptr);
    return (tmp___4);
  } else
  if (f->type == 6) {
    tmp___5 = repeated_to_jsonobj((fieldset_t *)f->value.ptr);
    return (tmp___5);
  } else {
    log_fatal("json", "received unknown output type: %i", f->type);
  }
}
}
json_object *repeated_to_jsonobj(fieldset_t *fs )
{
  json_object *obj ;
  struct json_object *tmp ;
  int i ;
  field_t *f ;
  json_object *tmp___0 ;

  {
  tmp = json_object_new_array();
  obj = tmp;
  i = 0;
  while (i < fs->len) {
    f = & fs->fields[i];
    tmp___0 = field_to_jsonobj(f);
    json_object_array_add(obj, tmp___0);
    i ++;
  }
  return (obj);
}
}
json_object *fs_to_jsonobj(fieldset_t *fs )
{
  json_object *obj ;
  struct json_object *tmp ;
  int i ;
  field_t *f ;
  json_object *tmp___0 ;

  {
  tmp = json_object_new_object();
  obj = tmp;
  i = 0;
  while (i < fs->len) {
    f = & fs->fields[i];
    if (f->type != 4) {
      tmp___0 = field_to_jsonobj(f);
      json_object_object_add(obj, f->name, tmp___0);
    }
    i ++;
  }
  return (obj);
}
}
int json_output_to_file(fieldset_t *fs )
{
  json_object *record ;
  json_object *tmp ;
  char const   *tmp___0 ;

  {
  if (! file___0) {
    return (0);
  }
  tmp = fs_to_jsonobj(fs);
  record = tmp;
  tmp___0 = json_object_to_json_string_ext(record, 0);
  __fprintf_chk((FILE * __restrict  )file___0, 1, (char const   * __restrict  )"%s\n",
                tmp___0);
  fflush(file___0);
  check_and_log_file_error(file___0, "json");
  json_object_put(record);
  return (0);
}
}
int json_output_file_close(struct state_conf *c  __attribute__((__unused__)) , struct state_send *s  __attribute__((__unused__)) ,
                           struct state_recv *r  __attribute__((__unused__)) )
{


  {
  if (file___0) {
    fflush(file___0);
    fclose(file___0);
  }
  return (0);
}
}
int print_json_fieldset(fieldset_t *fs )
{
  json_object *record ;
  json_object *tmp ;
  char const   *tmp___0 ;

  {
  tmp = fs_to_jsonobj(fs);
  record = tmp;
  tmp___0 = json_object_to_json_string(record);
  __fprintf_chk((FILE * __restrict  )stdout, 1, (char const   * __restrict  )"%s\n",
                tmp___0);
  json_object_put(record);
  return (0);
}
}
output_module_t module_json_file  =
     {"json", 1, 0U, & json_output_file_init, (int (*)(struct state_conf * , struct state_send * ,
                                                     struct state_recv * ))((void *)0),
    (int (*)(struct state_conf * , struct state_send * , struct state_recv * ))((void *)0),
    & json_output_file_close, & json_output_to_file, "Outputs one or more output fileds as a json valid file. By default, the \nprobe module does not filter out duplicates or limit to successful fields, \nbut rather includes all received packets. Fields can be controlled by \nsetting --output-fields. Filtering out failures and duplicate pakcets can \nbe achieved by setting an --output-filter."};
#pragma merger("0","/tmp/cil-a1p6wWpl.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
output_module_t *output_modules[2]  = {      & module_csv_file,      & module_json_file};
output_module_t *get_output_module_by_name(char const   *name )
{
  int num_modules ;
  int i ;
  int tmp ;

  {
  num_modules = (int )(sizeof(output_modules) / sizeof(output_modules[0]));
  i = 0;
  while (i < num_modules) {
    tmp = strcmp((output_modules[i])->name, name);
    if (! tmp) {
      return (output_modules[i]);
    }
    i ++;
  }
  return ((output_module_t *)((void *)0));
}
}
void print_output_modules(void)
{
  int num_modules ;
  int i ;

  {
  num_modules = (int )(sizeof(output_modules) / sizeof(output_modules[0]));
  i = 0;
  while (i < num_modules) {
    __printf_chk(1, (char const   * __restrict  )"%s\n", (output_modules[i])->name);
    i ++;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-Y5wDcVRb.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
sock_t get_socket(uint32_t id  __attribute__((__unused__)) )
{
  int sock ;
  __uint16_t tmp ;
  __uint16_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  sock_t s ;

  {
  if (zconf.send_ip_pkts) {
    tmp = __bswap_16((__uint16_t )3);
    sock = socket(17, 2, (int )tmp);
  } else {
    tmp___0 = __bswap_16((__uint16_t )3);
    sock = socket(17, 3, (int )tmp___0);
  }
  if (sock <= 0) {
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    log_fatal("send", "couldn\'t create socket. Are you root? Error: %s\n", tmp___2);
  }
  s.sock = sock;
  return (s);
}
}
#pragma merger("0","/tmp/cil-uf0V7FwU.i","-Wall,-Wformat=2,-Wno-format-nonliteral,-pedantic,-fno-strict-aliasing,-Wextra,-Wfloat-equal,-Wundef,-Wwrite-strings,-Wredundant-decls,-Wnested-externs,-Wbad-function-cast,-Winit-self,-Wmissing-noreturn,-Wstack-protector,-fstack-protector-all,-fwrapv,-fPIC,--param,ssp-buffer-size=1,-O2,-std=gnu99")
extern int usleep(__useconds_t __useconds ) ;
extern pcap_t *pcap_open_live(char const   * , int  , int  , int  , char * ) ;
extern void pcap_close(pcap_t * ) ;
extern int pcap_dispatch(pcap_t * , int  , void (*)(u_char * , struct pcap_pkthdr  const  * ,
                                                    u_char const   * ) , u_char * ) ;
extern int pcap_stats(pcap_t * , struct pcap_stat * ) ;
extern int pcap_setfilter(pcap_t * , struct bpf_program * ) ;
extern int pcap_setnonblock(pcap_t * , int  , char * ) ;
extern char *pcap_geterr(pcap_t * ) ;
extern int pcap_compile(pcap_t * , struct bpf_program * , char const   * , int  ,
                        bpf_u_int32  ) ;
extern int pcap_datalink(pcap_t * ) ;
static pcap_t *pc  =    (pcap_t *)((void *)0);
void packet_cb(u_char *user  __attribute__((__unused__)) , struct pcap_pkthdr  const  *p ,
               u_char const   *bytes )
{
  struct timespec ts ;
  uint32_t buflen ;

  {
  if (! p) {
    return;
  }
  if (zrecv.filter_success >= (uint64_t )zconf.max_results) {
    return;
  }
  buflen = (uint32_t )p->caplen;
  ts.tv_sec = (__time_t )p->ts.tv_sec;
  ts.tv_nsec = (__syscall_slong_t )(p->ts.tv_usec * 1000L);
  handle_packet(buflen, bytes, (struct timespec  const  )ts);
  return;
}
}
void recv_init(void)
{
  char bpftmp[1024] ;
  char errbuf[256] ;
  int tmp ;
  struct bpf_program bpf ;
  unsigned long tmp___0 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  pc = pcap_open_live((char const   *)zconf.iface, (int )(zconf.probe_module)->pcap_snaplen,
                      1, 1000, errbuf);
  if ((unsigned long )pc == (unsigned long )((void *)0)) {
    log_fatal("recv", "could not open device %s: %s", zconf.iface, errbuf);
  }
  tmp = pcap_datalink(pc);
  switch (tmp) {
  case 1:
  log_debug("recv", "Data link layer Ethernet");
  zconf.data_link_size = (int )sizeof(struct ether_header );
  break;
  case 12:
  log_info("recv", "Data link RAW");
  zconf.data_link_size = 0;
  break;
  case 113:
  log_info("recv", "Data link cooked socket");
  zconf.data_link_size = 16;
  break;
  default:
  log_error("recv", "unknown data link layer");
  }
  if (! zconf.send_ip_pkts) {
    tmp___0 = __builtin_object_size((void *)(bpftmp), 1);
    __builtin___snprintf_chk(bpftmp, sizeof(bpftmp) - 1UL, 1, tmp___0, "not ether src %02x:%02x:%02x:%02x:%02x:%02x",
                             (int )zconf.hw_mac[0], (int )zconf.hw_mac[1], (int )zconf.hw_mac[2],
                             (int )zconf.hw_mac[3], (int )zconf.hw_mac[4], (int )zconf.hw_mac[5]);
    tmp___6 = strlen((zconf.probe_module)->pcap_filter);
    tmp___7 = strlen((char const   *)(bpftmp));
    if (! (tmp___6 + 10UL < 1024UL - tmp___7)) {
      __assert_fail("strlen(zconf.probe_module->pcap_filter) + 10 < (BPFLEN - strlen(bpftmp))",
                    "src/recv-pcap.c", 98U, "recv_init");
    }
  } else {
    bpftmp[0] = (char)0;
  }
  if ((zconf.probe_module)->pcap_filter) {
    if (! zconf.send_ip_pkts) {
      strcat((char * __restrict  )(bpftmp), (char const   * __restrict  )" and (");
    } else {
      strcat((char * __restrict  )(bpftmp), (char const   * __restrict  )"(");
    }
    strcat((char * __restrict  )(bpftmp), (char const   * __restrict  )(zconf.probe_module)->pcap_filter);
    strcat((char * __restrict  )(bpftmp), (char const   * __restrict  )")");
  }
  tmp___10 = strcmp((char const   *)(bpftmp), "");
  if (tmp___10) {
    tmp___8 = pcap_compile(pc, & bpf, (char const   *)(bpftmp), 1, (bpf_u_int32 )0);
    if (tmp___8 < 0) {
      log_fatal("recv", "couldn\'t compile filter");
    }
    tmp___9 = pcap_setfilter(pc, & bpf);
    if (tmp___9 < 0) {
      log_fatal("recv", "couldn\'t install filter");
    }
  }
  tmp___11 = pcap_setnonblock(pc, 1, errbuf);
  if (tmp___11 == -1) {
    log_fatal("recv", "pcap_setnonblock error:%s", errbuf);
  }
  return;
}
}
void recv_packets(void)
{
  int ret ;
  int tmp ;

  {
  tmp = pcap_dispatch(pc, -1, & packet_cb, (u_char *)((void *)0));
  ret = tmp;
  if (ret == -1) {
    log_fatal("recv", "pcap_dispatch error");
  } else
  if (ret == 0) {
    usleep((__useconds_t )1000);
  }
  return;
}
}
void recv_cleanup(void)
{


  {
  pcap_close(pc);
  pc = (pcap_t *)((void *)0);
  return;
}
}
int recv_update_stats(void)
{
  struct pcap_stat pcst ;
  char *tmp ;
  int tmp___0 ;

  {
  if (! pc) {
    return (1);
  }
  tmp___0 = pcap_stats(pc, & pcst);
  if (tmp___0) {
    tmp = pcap_geterr(pc);
    log_error("recv", "unable to retrieve pcap statistics: %s", tmp);
    return (1);
  } else {
    zrecv.pcap_recv = pcst.ps_recv;
    zrecv.pcap_drop = pcst.ps_drop;
    zrecv.pcap_ifdrop = pcst.ps_ifdrop;
  }
  return (0);
}
}
