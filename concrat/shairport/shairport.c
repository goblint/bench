/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned char __uint8_t;
typedef unsigned int __uint32_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __clock_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __syscall_slong_t;
typedef unsigned int __socklen_t;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
typedef __pid_t pid_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval __sigval_t;
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
union __anonunion__bounds_304607062 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
struct __anonstruct__sigfault_109243111 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_304607062 _bounds ;
};
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
struct __anonstruct__sigsys_44812255 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_235771088 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_109243111 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_44812255 _sigsys ;
};
struct __anonstruct_siginfo_t_1025666667 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_235771088 _sifields ;
};
typedef struct __anonstruct_siginfo_t_1025666667 siginfo_t;
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
typedef unsigned long size_t;
typedef unsigned long pthread_t;
typedef __socklen_t socklen_t;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
typedef __uint8_t uint8_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef int __gwchar_t;
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
typedef struct MD5state_st MD5_CTX;
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
typedef __builtin_va_list __gnuc_va_list;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
struct __anonstruct_audio_output_780339900 {
   void (*help)(void) ;
   char *name ;
   int (*init)(int argc , char **argv ) ;
   void (*deinit)(void) ;
   void (*start)(int sample_rate ) ;
   void (*play)(short *buf , int samples ) ;
   void (*stop)(void) ;
   void (*volume)(double vol ) ;
};
typedef struct __anonstruct_audio_output_780339900 audio_output;
struct __anonstruct_mdns_backend_66454024 {
   char *name ;
   int (*mdns_register)(char *apname , int port ) ;
   void (*mdns_unregister)(void) ;
};
typedef struct __anonstruct_mdns_backend_66454024 mdns_backend;
struct __anonstruct_shairport_cfg_113578856 {
   char *password ;
   char *apname ;
   uint8_t hw_addr[6] ;
   int port ;
   char *output_name ;
   audio_output *output ;
   char *mdns_name ;
   mdns_backend *mdns ;
   int buffer_start_fill ;
   int daemonise ;
   char *cmd_start ;
   char *cmd_stop ;
   int cmd_blocking ;
   char *meta_dir ;
   char *pidfile ;
   char *logfile ;
   char *errfile ;
};
typedef struct __anonstruct_shairport_cfg_113578856 shairport_cfg;
typedef long __ssize_t;
typedef __ssize_t ssize_t;
typedef __gnuc_va_list va_list___0;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef long __suseconds_t;
typedef __int32_t int32_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct sockaddr_storage {
   sa_family_t ss_family ;
   char __ss_padding[(128UL - sizeof(unsigned short )) - sizeof(unsigned long )] ;
   unsigned long __ss_align ;
};
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
union __anonunion___in6_u_979734923 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion___in6_u_979734923 __in6_u ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
struct __anonstruct_metadata_273595944 {
   char *artist ;
   char *title ;
   char *album ;
   char *artwork ;
   char *comment ;
   char *genre ;
};
typedef struct __anonstruct_metadata_273595944 metadata;
struct __anonstruct_stream_cfg_797956145 {
   uint8_t aesiv[16] ;
   uint8_t aeskey[16] ;
   int32_t fmtp[12] ;
};
typedef struct __anonstruct_stream_cfg_797956145 stream_cfg;
struct __anonstruct_rtsp_conn_info_364246510 {
   int fd ;
   stream_cfg stream ;
   struct sockaddr_storage remote ;
   int running ;
   pthread_t thread ;
};
typedef struct __anonstruct_rtsp_conn_info_364246510 rtsp_conn_info;
struct __anonstruct_rtsp_message_967555407 {
   int nheaders ;
   char *name[16] ;
   char *value[16] ;
   int contentlength ;
   char *content ;
   char method[16] ;
   int respcode ;
};
typedef struct __anonstruct_rtsp_message_967555407 rtsp_message;
struct method_handler {
   char *method ;
   void (*handler)(rtsp_conn_info *conn , rtsp_message *req , rtsp_message *resp ) ;
};
union __anonunion_ifa_ifu_753034692 {
   struct sockaddr *ifu_broadaddr ;
   struct sockaddr *ifu_dstaddr ;
};
struct ifaddrs {
   struct ifaddrs *ifa_next ;
   char *ifa_name ;
   unsigned int ifa_flags ;
   struct sockaddr *ifa_addr ;
   struct sockaddr *ifa_netmask ;
   union __anonunion_ifa_ifu_753034692 ifa_ifu ;
   void *ifa_data ;
};
struct rr_data_srv {
   uint16_t priority ;
   uint16_t weight ;
   uint16_t port ;
   uint8_t *target ;
};
struct rr_data_txt {
   struct rr_data_txt *next ;
   uint8_t *txt ;
};
struct rr_data_nsec {
   uint8_t bitmap[5] ;
};
struct rr_entry ;
struct rr_data_ptr {
   uint8_t *name ;
   struct rr_entry *entry ;
};
struct rr_data_a {
   uint32_t addr ;
};
struct rr_data_aaaa {
   struct in6_addr *addr ;
};
enum rr_type {
    RR_A = 1,
    RR_PTR = 12,
    RR_TXT = 16,
    RR_AAAA = 28,
    RR_SRV = 33,
    RR_NSEC = 47,
    RR_ANY = 255
} ;
union __anonunion_data_487002723 {
   struct rr_data_nsec NSEC ;
   struct rr_data_srv SRV ;
   struct rr_data_txt TXT ;
   struct rr_data_ptr PTR ;
   struct rr_data_a A ;
   struct rr_data_aaaa AAAA ;
};
struct rr_entry {
   uint8_t *name ;
   enum rr_type type ;
   uint32_t ttl ;
   char unicast_query ;
   char cache_flush ;
   uint16_t rr_class ;
   union __anonunion_data_487002723 data ;
};
struct mdnsd ;
struct mdns_service ;
struct bio_st ;
typedef struct bio_st BIO;
struct buf_mem_st ;
typedef struct buf_mem_st BUF_MEM;
struct rsa_st ;
typedef struct rsa_st RSA;
struct bio_method_st ;
typedef struct bio_method_st BIO_METHOD;
struct buf_mem_st {
   size_t length ;
   char *data ;
   size_t max ;
   unsigned long flags ;
};
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
typedef short __int16_t;
typedef __int16_t int16_t;
typedef uint16_t seq_t;
struct aes_key_st {
   unsigned int rd_key[60] ;
   int rounds ;
};
typedef struct aes_key_st AES_KEY;
struct alac_file ;
typedef struct alac_file alac_file;
struct alac_file {
   unsigned char *input_buffer ;
   int input_buffer_bitaccumulator ;
   int samplesize ;
   int numchannels ;
   int bytespersample ;
   int32_t *predicterror_buffer_a ;
   int32_t *predicterror_buffer_b ;
   int32_t *outputsamples_buffer_a ;
   int32_t *outputsamples_buffer_b ;
   int32_t *uncompressed_bytes_buffer_a ;
   int32_t *uncompressed_bytes_buffer_b ;
   uint32_t setinfo_max_samples_per_frame ;
   uint8_t setinfo_7a ;
   uint8_t setinfo_sample_size ;
   uint8_t setinfo_rice_historymult ;
   uint8_t setinfo_rice_initialhistory ;
   uint8_t setinfo_rice_kmodifier ;
   uint8_t setinfo_7f ;
   uint16_t setinfo_80 ;
   uint32_t setinfo_82 ;
   uint32_t setinfo_86 ;
   uint32_t setinfo_8a_rate ;
};
struct audio_buffer_entry {
   int ready ;
   short *data ;
};
typedef struct audio_buffer_entry abuf_t;
struct __anonstruct_biquad_t_616681636 {
   double hist[2] ;
   double a[2] ;
   double b[3] ;
};
typedef struct __anonstruct_biquad_t_616681636 biquad_t;
struct __anonstruct_se_struct_24_422959015 {
   int x : 24 ;
};
typedef unsigned int __useconds_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
struct rr_list {
   struct rr_entry *e ;
   struct rr_list *next ;
};
struct rr_group {
   uint8_t *name ;
   struct rr_list *rr ;
   struct rr_group *next ;
};
struct mdns_pkt {
   uint16_t id ;
   uint16_t flags ;
   uint16_t num_qn ;
   uint16_t num_ans_rr ;
   uint16_t num_auth_rr ;
   uint16_t num_add_rr ;
   struct rr_list *rr_qn ;
   struct rr_list *rr_ans ;
   struct rr_list *rr_auth ;
   struct rr_list *rr_add ;
};
struct name_comp {
   uint8_t *label ;
   size_t pos ;
   struct name_comp *next ;
};
struct mdnsd {
   pthread_mutex_t data_lock ;
   int sockfd ;
   int notify_pipe[2] ;
   int stop_flag ;
   struct rr_group *group ;
   struct rr_list *announce ;
   struct rr_list *services ;
   uint8_t *hostname ;
};
struct mdns_service {
   struct rr_list *entries ;
};
typedef unsigned int uint_32;
struct ao_device ;
typedef struct ao_device ao_device;
struct ao_sample_format {
   int bits ;
   int rate ;
   int channels ;
   int byte_format ;
   char *matrix ;
};
typedef struct ao_sample_format ao_sample_format;
struct ao_option {
   char *key ;
   char *value ;
   struct ao_option *next ;
};
typedef struct ao_option ao_option;
enum pa_sample_format {
    PA_SAMPLE_U8 = 0,
    PA_SAMPLE_ALAW = 1,
    PA_SAMPLE_ULAW = 2,
    PA_SAMPLE_S16LE = 3,
    PA_SAMPLE_S16BE = 4,
    PA_SAMPLE_FLOAT32LE = 5,
    PA_SAMPLE_FLOAT32BE = 6,
    PA_SAMPLE_S32LE = 7,
    PA_SAMPLE_S32BE = 8,
    PA_SAMPLE_S24LE = 9,
    PA_SAMPLE_S24BE = 10,
    PA_SAMPLE_S24_32LE = 11,
    PA_SAMPLE_S24_32BE = 12,
    PA_SAMPLE_MAX = 13,
    PA_SAMPLE_INVALID = -1
} ;
typedef enum pa_sample_format pa_sample_format_t;
struct pa_sample_spec {
   pa_sample_format_t format ;
   uint32_t rate ;
   uint8_t channels ;
};
typedef struct pa_sample_spec pa_sample_spec;
enum pa_channel_position {
    PA_CHANNEL_POSITION_INVALID = -1,
    PA_CHANNEL_POSITION_MONO = 0,
    PA_CHANNEL_POSITION_FRONT_LEFT = 1,
    PA_CHANNEL_POSITION_FRONT_RIGHT = 2,
    PA_CHANNEL_POSITION_FRONT_CENTER = 3,
    PA_CHANNEL_POSITION_LEFT = 1,
    PA_CHANNEL_POSITION_RIGHT = 2,
    PA_CHANNEL_POSITION_CENTER = 3,
    PA_CHANNEL_POSITION_REAR_CENTER = 4,
    PA_CHANNEL_POSITION_REAR_LEFT = 5,
    PA_CHANNEL_POSITION_REAR_RIGHT = 6,
    PA_CHANNEL_POSITION_LFE = 7,
    PA_CHANNEL_POSITION_SUBWOOFER = 7,
    PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER = 8,
    PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER = 9,
    PA_CHANNEL_POSITION_SIDE_LEFT = 10,
    PA_CHANNEL_POSITION_SIDE_RIGHT = 11,
    PA_CHANNEL_POSITION_AUX0 = 12,
    PA_CHANNEL_POSITION_AUX1 = 13,
    PA_CHANNEL_POSITION_AUX2 = 14,
    PA_CHANNEL_POSITION_AUX3 = 15,
    PA_CHANNEL_POSITION_AUX4 = 16,
    PA_CHANNEL_POSITION_AUX5 = 17,
    PA_CHANNEL_POSITION_AUX6 = 18,
    PA_CHANNEL_POSITION_AUX7 = 19,
    PA_CHANNEL_POSITION_AUX8 = 20,
    PA_CHANNEL_POSITION_AUX9 = 21,
    PA_CHANNEL_POSITION_AUX10 = 22,
    PA_CHANNEL_POSITION_AUX11 = 23,
    PA_CHANNEL_POSITION_AUX12 = 24,
    PA_CHANNEL_POSITION_AUX13 = 25,
    PA_CHANNEL_POSITION_AUX14 = 26,
    PA_CHANNEL_POSITION_AUX15 = 27,
    PA_CHANNEL_POSITION_AUX16 = 28,
    PA_CHANNEL_POSITION_AUX17 = 29,
    PA_CHANNEL_POSITION_AUX18 = 30,
    PA_CHANNEL_POSITION_AUX19 = 31,
    PA_CHANNEL_POSITION_AUX20 = 32,
    PA_CHANNEL_POSITION_AUX21 = 33,
    PA_CHANNEL_POSITION_AUX22 = 34,
    PA_CHANNEL_POSITION_AUX23 = 35,
    PA_CHANNEL_POSITION_AUX24 = 36,
    PA_CHANNEL_POSITION_AUX25 = 37,
    PA_CHANNEL_POSITION_AUX26 = 38,
    PA_CHANNEL_POSITION_AUX27 = 39,
    PA_CHANNEL_POSITION_AUX28 = 40,
    PA_CHANNEL_POSITION_AUX29 = 41,
    PA_CHANNEL_POSITION_AUX30 = 42,
    PA_CHANNEL_POSITION_AUX31 = 43,
    PA_CHANNEL_POSITION_TOP_CENTER = 44,
    PA_CHANNEL_POSITION_TOP_FRONT_LEFT = 45,
    PA_CHANNEL_POSITION_TOP_FRONT_RIGHT = 46,
    PA_CHANNEL_POSITION_TOP_FRONT_CENTER = 47,
    PA_CHANNEL_POSITION_TOP_REAR_LEFT = 48,
    PA_CHANNEL_POSITION_TOP_REAR_RIGHT = 49,
    PA_CHANNEL_POSITION_TOP_REAR_CENTER = 50,
    PA_CHANNEL_POSITION_MAX = 51
} ;
typedef enum pa_channel_position pa_channel_position_t;
struct pa_channel_map {
   uint8_t channels ;
   pa_channel_position_t map[32U] ;
};
typedef struct pa_channel_map pa_channel_map;
enum pa_stream_direction {
    PA_STREAM_NODIRECTION = 0,
    PA_STREAM_PLAYBACK = 1,
    PA_STREAM_RECORD = 2,
    PA_STREAM_UPLOAD = 3
} ;
typedef enum pa_stream_direction pa_stream_direction_t;
struct pa_buffer_attr {
   uint32_t maxlength ;
   uint32_t tlength ;
   uint32_t prebuf ;
   uint32_t minreq ;
   uint32_t fragsize ;
};
typedef struct pa_buffer_attr pa_buffer_attr;
struct pa_simple ;
typedef struct pa_simple pa_simple;
struct _snd_pcm_hw_params ;
typedef struct _snd_pcm_hw_params snd_pcm_hw_params_t;
enum _snd_pcm_stream {
    SND_PCM_STREAM_PLAYBACK = 0,
    SND_PCM_STREAM_CAPTURE = 1,
    SND_PCM_STREAM_LAST = 1
} ;
typedef enum _snd_pcm_stream snd_pcm_stream_t;
enum _snd_pcm_access {
    SND_PCM_ACCESS_MMAP_INTERLEAVED = 0,
    SND_PCM_ACCESS_MMAP_NONINTERLEAVED = 1,
    SND_PCM_ACCESS_MMAP_COMPLEX = 2,
    SND_PCM_ACCESS_RW_INTERLEAVED = 3,
    SND_PCM_ACCESS_RW_NONINTERLEAVED = 4,
    SND_PCM_ACCESS_LAST = 4
} ;
typedef enum _snd_pcm_access snd_pcm_access_t;
enum _snd_pcm_format {
    SND_PCM_FORMAT_UNKNOWN = -1,
    SND_PCM_FORMAT_S8 = 0,
    SND_PCM_FORMAT_U8 = 1,
    SND_PCM_FORMAT_S16_LE = 2,
    SND_PCM_FORMAT_S16_BE = 3,
    SND_PCM_FORMAT_U16_LE = 4,
    SND_PCM_FORMAT_U16_BE = 5,
    SND_PCM_FORMAT_S24_LE = 6,
    SND_PCM_FORMAT_S24_BE = 7,
    SND_PCM_FORMAT_U24_LE = 8,
    SND_PCM_FORMAT_U24_BE = 9,
    SND_PCM_FORMAT_S32_LE = 10,
    SND_PCM_FORMAT_S32_BE = 11,
    SND_PCM_FORMAT_U32_LE = 12,
    SND_PCM_FORMAT_U32_BE = 13,
    SND_PCM_FORMAT_FLOAT_LE = 14,
    SND_PCM_FORMAT_FLOAT_BE = 15,
    SND_PCM_FORMAT_FLOAT64_LE = 16,
    SND_PCM_FORMAT_FLOAT64_BE = 17,
    SND_PCM_FORMAT_IEC958_SUBFRAME_LE = 18,
    SND_PCM_FORMAT_IEC958_SUBFRAME_BE = 19,
    SND_PCM_FORMAT_MU_LAW = 20,
    SND_PCM_FORMAT_A_LAW = 21,
    SND_PCM_FORMAT_IMA_ADPCM = 22,
    SND_PCM_FORMAT_MPEG = 23,
    SND_PCM_FORMAT_GSM = 24,
    SND_PCM_FORMAT_S20_LE = 25,
    SND_PCM_FORMAT_S20_BE = 26,
    SND_PCM_FORMAT_U20_LE = 27,
    SND_PCM_FORMAT_U20_BE = 28,
    SND_PCM_FORMAT_SPECIAL = 31,
    SND_PCM_FORMAT_S24_3LE = 32,
    SND_PCM_FORMAT_S24_3BE = 33,
    SND_PCM_FORMAT_U24_3LE = 34,
    SND_PCM_FORMAT_U24_3BE = 35,
    SND_PCM_FORMAT_S20_3LE = 36,
    SND_PCM_FORMAT_S20_3BE = 37,
    SND_PCM_FORMAT_U20_3LE = 38,
    SND_PCM_FORMAT_U20_3BE = 39,
    SND_PCM_FORMAT_S18_3LE = 40,
    SND_PCM_FORMAT_S18_3BE = 41,
    SND_PCM_FORMAT_U18_3LE = 42,
    SND_PCM_FORMAT_U18_3BE = 43,
    SND_PCM_FORMAT_G723_24 = 44,
    SND_PCM_FORMAT_G723_24_1B = 45,
    SND_PCM_FORMAT_G723_40 = 46,
    SND_PCM_FORMAT_G723_40_1B = 47,
    SND_PCM_FORMAT_DSD_U8 = 48,
    SND_PCM_FORMAT_DSD_U16_LE = 49,
    SND_PCM_FORMAT_DSD_U32_LE = 50,
    SND_PCM_FORMAT_DSD_U16_BE = 51,
    SND_PCM_FORMAT_DSD_U32_BE = 52,
    SND_PCM_FORMAT_LAST = 52,
    SND_PCM_FORMAT_S16 = 2,
    SND_PCM_FORMAT_U16 = 4,
    SND_PCM_FORMAT_S24 = 6,
    SND_PCM_FORMAT_U24 = 8,
    SND_PCM_FORMAT_S32 = 10,
    SND_PCM_FORMAT_U32 = 12,
    SND_PCM_FORMAT_FLOAT = 14,
    SND_PCM_FORMAT_FLOAT64 = 16,
    SND_PCM_FORMAT_IEC958_SUBFRAME = 18,
    SND_PCM_FORMAT_S20 = 25,
    SND_PCM_FORMAT_U20 = 27
} ;
typedef enum _snd_pcm_format snd_pcm_format_t;
typedef unsigned long snd_pcm_uframes_t;
typedef long snd_pcm_sframes_t;
struct _snd_pcm ;
typedef struct _snd_pcm snd_pcm_t;
struct _snd_mixer ;
typedef struct _snd_mixer snd_mixer_t;
struct _snd_mixer_class ;
typedef struct _snd_mixer_class snd_mixer_class_t;
struct _snd_mixer_elem ;
typedef struct _snd_mixer_elem snd_mixer_elem_t;
enum snd_mixer_selem_regopt_abstract {
    SND_MIXER_SABSTRACT_NONE = 0,
    SND_MIXER_SABSTRACT_BASIC = 1
} ;
struct snd_mixer_selem_regopt {
   int ver ;
   enum snd_mixer_selem_regopt_abstract abstract ;
   char const   *device ;
   snd_pcm_t *playback_pcm ;
   snd_pcm_t *capture_pcm ;
};
struct _snd_mixer_selem_id ;
typedef struct _snd_mixer_selem_id snd_mixer_selem_id_t;
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-m0IfJcy3.i","-O2,-Wall")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigfillset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigdelset)(sigset_t *__set ,
                                                                                      int __signo ) ;
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                                                         __sigset_t * __restrict  __oldmask ) ;
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
extern char *optarg ;
extern int optind ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __strtol_internal)(char const   * __restrict  __nptr ,
                                                                                               char ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                      char ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  tmp = __strtol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __strtoul_internal)(char const   * __restrict  __nptr ,
                                                                                                         char ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                       char ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __strtoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __wcstol_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                               __gwchar_t ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                      __gwchar_t ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  tmp = __wcstol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __wcstoul_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                                         __gwchar_t ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                       __gwchar_t ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __wcstoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern int MD5_Init(MD5_CTX *c ) ;
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc ,
                                                                                          char * const  *___argv ,
                                                                                          char const   *__shortopts ,
                                                                                          struct option  const  *__longopts ,
                                                                                          int *__longind ) ;
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict  __stream , char * __restrict  __buf ,
                                                 int __modes , size_t __n ) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) setenv)(char const   *__name ,
                                                                                   char const   *__value ,
                                                                                   int __replace ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg ) 
{ 


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
audio_output *audio_get_output(char *name ) ;
void audio_ls_outputs(void) ;
int mdns_pid ;
void mdns_unregister(void) ;
void mdns_ls_backends(void) ;
int debuglev ;
void die(char *format  , ...) ;
shairport_cfg config ;
void shairport_shutdown(int retval ) ;
void shairport_startup_complete(void) ;
void daemon_init(void) ;
void daemon_ready(void) ;
void daemon_exit(void) ;
void rtsp_listen_loop(void) ;
void rtsp_shutdown_stream(void) ;
void metadata_open(void) ;
static char const   *version  =    "1.1.1-23-gd65b8e8";
static void log_setup(void) ;
static int shutting_down  =    0;
void shairport_shutdown(int retval ) 
{ 


  {
  if (shutting_down) {
    return;
  }
  shutting_down = 1;
  printf((char const   * __restrict  )"Shutting down...\n");
  mdns_unregister();
  rtsp_shutdown_stream();
  if (config.output) {
    (*((config.output)->deinit))();
  }
  daemon_exit();
  exit(retval);
}
}
static void sig_ignore(int foo , siginfo_t *bar , void *baz ) 
{ 


  {
  return;
}
}
static void sig_shutdown(int foo , siginfo_t *bar , void *baz ) 
{ 


  {
  shairport_shutdown(0);
  return;
}
}
static void sig_child(int foo , siginfo_t *bar , void *baz ) 
{ 
  pid_t pid ;

  {
  while (1) {
    pid = waitpid(-1, (int *)0, 1);
    if (! (pid > 0)) {
      break;
    }
    if (pid == mdns_pid) {
      if (! shutting_down) {
        die((char *)"MDNS child process died unexpectedly!");
      }
    }
  }
  return;
}
}
static void sig_logrotate(int foo , siginfo_t *bar , void *baz ) 
{ 


  {
  log_setup();
  return;
}
}
void usage(char *progname ) 
{ 


  {
  printf((char const   * __restrict  )"Usage: %s [options...]\n", progname);
  printf((char const   * __restrict  )"  or:  %s [options...] -- [audio output-specific options]\n",
         progname);
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"Mandatory arguments to long options are mandatory for short options too.\n");
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"Options:\n");
  printf((char const   * __restrict  )"    -h, --help          show this help\n");
  printf((char const   * __restrict  )"    -p, --port=PORT     set RTSP listening port\n");
  printf((char const   * __restrict  )"    -a, --name=NAME     set advertised name\n");
  printf((char const   * __restrict  )"    -k, --password=PW   require password to stream audio\n");
  printf((char const   * __restrict  )"    -b FILL             set how full the buffer must be before audio output\n");
  printf((char const   * __restrict  )"                        starts. This value is in frames; default %d\n",
         config.buffer_start_fill);
  printf((char const   * __restrict  )"    -d, --daemon        fork (daemonise). The PID of the child process is\n");
  printf((char const   * __restrict  )"                        written to stdout, unless a pidfile is used.\n");
  printf((char const   * __restrict  )"    -P, --pidfile=FILE  write daemon\'s pid to FILE on startup.\n");
  printf((char const   * __restrict  )"                        Has no effect if -d is not specified\n");
  printf((char const   * __restrict  )"    -l, --log=FILE      redirect shairport\'s standard output to FILE\n");
  printf((char const   * __restrict  )"                        If --error is not specified, it also redirects\n");
  printf((char const   * __restrict  )"                        error output to FILE\n");
  printf((char const   * __restrict  )"    -e, --error=FILE    redirect shairport\'s standard error output to FILE\n");
  printf((char const   * __restrict  )"    -B, --on-start=COMMAND  run a shell command when playback begins\n");
  printf((char const   * __restrict  )"    -E, --on-stop=COMMAND   run a shell command when playback ends\n");
  printf((char const   * __restrict  )"    -w, --wait-cmd          block while the shell command(s) run\n");
  printf((char const   * __restrict  )"    -M, --meta-dir=DIR      set a directory to write metadata and album cover art to\n");
  printf((char const   * __restrict  )"    -o, --output=BACKEND    select audio output method\n");
  printf((char const   * __restrict  )"    -m, --mdns=BACKEND      force the use of BACKEND to advertise the service\n");
  printf((char const   * __restrict  )"                            if no mdns provider is specified,\n");
  printf((char const   * __restrict  )"                            shairport tries them all until one works.\n");
  printf((char const   * __restrict  )"\n");
  mdns_ls_backends();
  printf((char const   * __restrict  )"\n");
  audio_ls_outputs();
  return;
}
}
int parse_options(int argc , char **argv ) ;
static struct option long_options[15]  = 
  {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"daemon", 0, (int *)((void *)0), 'd'}, 
        {"pidfile", 1, (int *)((void *)0), 'P'}, 
        {"log", 1, (int *)((void *)0), 'l'}, 
        {"error", 1, (int *)((void *)0), 'e'}, 
        {"port", 1, (int *)((void *)0), 'p'}, 
        {"name", 1, (int *)((void *)0), 'a'}, 
        {"password", 1, (int *)((void *)0), 'k'}, 
        {"output", 1, (int *)((void *)0), 'o'}, 
        {"on-start", 1, (int *)((void *)0), 'B'}, 
        {"on-stop", 1, (int *)((void *)0), 'E'}, 
        {"wait-cmd", 0, (int *)((void *)0), 'w'}, 
        {"meta-dir", 1, (int *)((void *)0), 'M'}, 
        {"mdns", 1, (int *)((void *)0), 'm'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
int parse_options(int argc , char **argv ) 
{ 
  int opt ;

  {
  setenv("POSIXLY_CORRECT", "", 1);
  while (1) {
    opt = getopt_long(argc, (char * const  *)argv, "+hdvP:l:e:p:a:k:o:b:B:E:M:wm:",
                      (struct option  const  *)(long_options), (int *)((void *)0));
    if (! (opt > 0)) {
      break;
    }
    switch (opt) {
    default: 
    usage(*(argv + 0));
    exit(1);
    case 104: 
    usage(*(argv + 0));
    exit(0);
    case 100: 
    config.daemonise = 1;
    break;
    case 118: 
    debuglev ++;
    break;
    case 112: 
    config.port = atoi((char const   *)optarg);
    break;
    case 97: 
    config.apname = optarg;
    break;
    case 111: 
    config.output_name = optarg;
    break;
    case 107: 
    config.password = optarg;
    break;
    case 98: 
    config.buffer_start_fill = atoi((char const   *)optarg);
    break;
    case 66: 
    config.cmd_start = optarg;
    break;
    case 69: 
    config.cmd_stop = optarg;
    break;
    case 119: 
    config.cmd_blocking = 1;
    break;
    case 77: 
    config.meta_dir = optarg;
    break;
    case 80: 
    config.pidfile = optarg;
    break;
    case 108: 
    config.logfile = optarg;
    break;
    case 101: 
    config.errfile = optarg;
    break;
    case 109: 
    config.mdns_name = optarg;
    break;
    }
  }
  return (optind);
}
}
void signal_setup(void) 
{ 
  sigset_t set ;
  struct sigaction sa ;

  {
  sigfillset(& set);
  sigdelset(& set, 2);
  sigdelset(& set, 15);
  sigdelset(& set, 1);
  sigdelset(& set, 19);
  sigdelset(& set, 17);
  pthread_sigmask(0, (__sigset_t const   * __restrict  )(& set), (__sigset_t * __restrict  )((void *)0));
  memset((void *)(& sa), 0, sizeof(sa));
  sa.sa_flags = 4;
  sa.__sigaction_handler.sa_sigaction = & sig_ignore;
  sigaction(10, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  sa.sa_flags = 268435460;
  sa.__sigaction_handler.sa_sigaction = & sig_shutdown;
  sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  sigaction(15, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  sa.__sigaction_handler.sa_sigaction = & sig_logrotate;
  sigaction(1, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  sa.__sigaction_handler.sa_sigaction = & sig_child;
  sigaction(17, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  return;
}
}
void shairport_startup_complete(void) 
{ 


  {
  if (config.daemonise) {
    daemon_ready();
  }
  return;
}
}
static void log_setup(void) 
{ 
  int log_fd ;
  int tmp ;
  int err_fd ;
  int tmp___0 ;

  {
  if (config.logfile) {
    tmp = open((char const   *)config.logfile, 1089, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
    log_fd = tmp;
    if (log_fd < 0) {
      die((char *)"Could not open logfile");
    }
    dup2(log_fd, 1);
    setvbuf((FILE * __restrict  )stdout, (char * __restrict  )((void *)0), 1, (size_t )8192);
    if (! config.errfile) {
      dup2(log_fd, 2);
      setvbuf((FILE * __restrict  )stderr, (char * __restrict  )((void *)0), 1, (size_t )8192);
    }
  }
  if (config.errfile) {
    tmp___0 = open((char const   *)config.errfile, 1089, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
    err_fd = tmp___0;
    if (err_fd < 0) {
      die((char *)"Could not open logfile");
    }
    dup2(err_fd, 2);
    setvbuf((FILE * __restrict  )stderr, (char * __restrict  )((void *)0), 1, (size_t )8192);
  }
  return;
}
}
int main(int argc , char **argv ) 
{ 
  char hostname[100] ;
  void *tmp ;
  int audio_arg ;
  int tmp___0 ;
  size_t tmp___1 ;
  uint8_t ap_md5[16] ;
  MD5_CTX ctx ;
  size_t tmp___2 ;

  {
  printf((char const   * __restrict  )"Starting Shairport %s\n", version);
  signal_setup();
  memset((void *)(& config), 0, sizeof(config));
  config.buffer_start_fill = 220;
  config.port = 5002;
  gethostname(hostname, (size_t )100);
  tmp = malloc((size_t )120);
  config.apname = (char *)tmp;
  snprintf((char * __restrict  )config.apname, (size_t )120, (char const   * __restrict  )"Shairport on %s",
           hostname);
  tmp___0 = parse_options(argc, argv);
  audio_arg = tmp___0;
  tmp___1 = strlen((char const   *)config.apname);
  if (tmp___1 > 50UL) {
    die((char *)"Supplied name too long (max 50 characters)");
  }
  if (config.daemonise) {
    daemon_init();
  }
  log_setup();
  config.output = audio_get_output(config.output_name);
  if (! config.output) {
    audio_ls_outputs();
    die((char *)"Invalid audio output specified!");
  }
  (*((config.output)->init))(argc - audio_arg, argv + audio_arg);
  MD5_Init(& ctx);
  tmp___2 = strlen((char const   *)config.apname);
  MD5_Update(& ctx, (void const   *)config.apname, tmp___2);
  MD5_Final(ap_md5, & ctx);
  memcpy((void * __restrict  )(config.hw_addr), (void const   * __restrict  )(ap_md5),
         sizeof(config.hw_addr));
  if (config.meta_dir) {
    metadata_open();
  }
  rtsp_listen_loop();
  shairport_shutdown(1);
  return (1);
}
}
#pragma merger("0","/tmp/cil-RfH43Rsh.i","-O2,-Wall")
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int ( /* format attribute */  vdprintf)(int __fd , char const   * __restrict  __fmt ,
                                               __gnuc_va_list __arg ) ;
extern int ( /* format attribute */  dprintf)(int __fd , char const   * __restrict  __fmt 
                                              , ...) ;
static int lock_fd  =    -1;
static int daemon_pipe[2]  = {      -1,      -1};
void daemon_init(void) 
{ 
  int ret ;
  pid_t pid ;
  __pid_t tmp ;
  char buf[64] ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  __pid_t tmp___2 ;

  {
  ret = pipe((int *)(daemon_pipe));
  if (ret < 0) {
    die((char *)"couldn\'t create a pipe?!");
  }
  tmp = fork();
  pid = tmp;
  if (pid < 0) {
    die((char *)"failed to fork!");
  }
  if (pid) {
    close(daemon_pipe[1]);
    tmp___0 = read(daemon_pipe[0], (void *)(buf), sizeof(buf));
    ret = (int )tmp___0;
    if (ret < 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Spawning the daemon failed.\n");
      exit(1);
    } else
    if ((int )buf[0] != 0) {
      tmp___1 = write(2, (void const   *)(buf), (size_t )ret);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
      exit(1);
    } else {
      if (! config.pidfile) {
        printf((char const   * __restrict  )"%d\n", pid);
      }
      exit(0);
    }
  } else {
    close(daemon_pipe[0]);
    if (config.pidfile) {
      lock_fd = open((char const   *)config.pidfile, 66, 384);
      if (lock_fd < 0) {
        die((char *)"Could not open pidfile");
      }
      ret = lockf(lock_fd, 2, (__off_t )0);
      if (ret < 0) {
        die((char *)"Could not lock pidfile. Is an other instance running ?");
      }
      tmp___2 = getpid();
      dprintf(lock_fd, (char const   * __restrict  )"%d\n", tmp___2);
    }
  }
  return;
}
}
void daemon_ready(void) 
{ 
  char ok ;
  ssize_t tmp ;

  {
  ok = (char)0;
  tmp = write(daemon_pipe[1], (void const   *)(& ok), (size_t )1);
  close(daemon_pipe[1]);
  daemon_pipe[1] = -1;
  return;
}
}
void daemon_fail(char const   *format , va_list___0 arg ) 
{ 


  {
  if (daemon_pipe[1] > 0) {
    vdprintf(daemon_pipe[1], (char const   * __restrict  )format, arg);
  }
  return;
}
}
void daemon_exit(void) 
{ 
  int tmp ;

  {
  if (lock_fd > 0) {
    tmp = lockf(lock_fd, 0, (__off_t )0);
    close(lock_fd);
    unlink((char const   *)config.pidfile);
    lock_fd = -1;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-6BluhA78.i","-O2,-Wall")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3))) strtok_r)(char * __restrict  __s ,
                                                                                         char const   * __restrict  __delim ,
                                                                                         char ** __restrict  __save_ptr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strsep)(char ** __restrict  __stringp ,
                                                                                       char const   * __restrict  __delim ) ;
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 


  {
  return (((((__bsx & 4278190080U) >> 24) | ((__bsx & 16711680U) >> 8)) | ((__bsx & 65280U) << 8)) | ((__bsx & 255U) << 24));
}
}
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   * __restrict  __cp ,
                                                             char * __restrict  __buf ,
                                                             socklen_t __len ) ;
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
extern  __attribute__((__nothrow__)) int pthread_kill(pthread_t __threadid , int __signo ) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_trylock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
void mdns_register(void) ;
void warn(char *format  , ...) ;
void debug(int level , char *format  , ...) ;
uint8_t *base64_dec(char *input , int *outlen ) ;
char *base64_enc(uint8_t *input , int length ) ;
uint8_t *rsa_apply(uint8_t *input , int inlen , int *outlen , int mode ) ;
void metadata_set(char **field , char const   *value ) ;
void metadata_write(void) ;
void metadata_cover_image(char const   *buf , int len , char const   *ext ) ;
metadata player_meta ;
int player_play(stream_cfg *stream ) ;
void player_stop(void) ;
void player_volume(double f ) ;
void player_flush(void) ;
int rtp_setup(struct sockaddr_storage *remote , int cport , int tport ) ;
void rtp_shutdown(void) ;
static pthread_mutex_t playing_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static int please_shutdown  =    0;
static pthread_t playing_thread  ;
__inline static int rtsp_playing(void) 
{ 
  pthread_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___1 = pthread_mutex_trylock(& playing_mutex);
  if (tmp___1) {
    tmp = pthread_self();
    tmp___0 = pthread_equal(playing_thread, tmp);
    return (tmp___0);
  } else {
    pthread_mutex_unlock(& playing_mutex);
    return (0);
  }
}
}
static void rtsp_take_player(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp = rtsp_playing();
  if (tmp) {
    return;
  }
  tmp___0 = pthread_mutex_trylock(& playing_mutex);
  if (tmp___0) {
    debug(1, (char *)"shutting down playing thread\n");
    please_shutdown = 1;
    pthread_kill(playing_thread, 10);
    pthread_mutex_lock(& playing_mutex);
  }
  playing_thread = pthread_self();
  return;
}
}
void rtsp_shutdown_stream(void) 
{ 


  {
  rtsp_take_player();
  pthread_mutex_unlock(& playing_mutex);
  return;
}
}
static rtsp_conn_info **conns  =    (rtsp_conn_info **)((void *)0);
static int nconns  =    0;
static void track_thread(rtsp_conn_info *conn ) 
{ 
  void *tmp ;

  {
  tmp = realloc((void *)conns, sizeof(rtsp_conn_info *) * (unsigned long )(nconns + 1));
  conns = (rtsp_conn_info **)tmp;
  *(conns + nconns) = conn;
  nconns ++;
  return;
}
}
static void cleanup_threads(void) 
{ 
  void *retval ;
  int i ;

  {
  debug(2, (char *)"culling threads.\n");
  i = 0;
  while (i < nconns) {
    if ((*(conns + i))->running == 0) {
      pthread_join((*(conns + i))->thread, & retval);
      free((void *)*(conns + i));
      debug(2, (char *)"one joined\n");
      nconns --;
      if (nconns) {
        *(conns + i) = *(conns + nconns);
      }
    } else {
      i ++;
    }
  }
  return;
}
}
static char *nextline(char *in , int inbuf ) 
{ 
  char *out ;
  char *tmp ;
  char *tmp___0 ;

  {
  out = (char *)((void *)0);
  while (inbuf) {
    if ((int )*in == 13) {
      tmp = in;
      in ++;
      *tmp = (char)0;
      out = in;
    }
    if ((int )*in == 10) {
      tmp___0 = in;
      in ++;
      *tmp___0 = (char)0;
      out = in;
    }
    if (out) {
      break;
    }
    in ++;
    inbuf --;
  }
  return (out);
}
}
static rtsp_message *msg_init(void) 
{ 
  rtsp_message *msg ;
  void *tmp ;

  {
  tmp = malloc(sizeof(rtsp_message ));
  msg = (rtsp_message *)tmp;
  memset((void *)msg, 0, sizeof(rtsp_message ));
  return (msg);
}
}
static int msg_add_header(rtsp_message *msg , char *name , char *value ) 
{ 


  {
  if ((unsigned long )msg->nheaders >= sizeof(msg->name) / sizeof(char *)) {
    warn((char *)"too many headers?!");
    return (1);
  }
  msg->name[msg->nheaders] = strdup((char const   *)name);
  msg->value[msg->nheaders] = strdup((char const   *)value);
  (msg->nheaders) ++;
  return (0);
}
}
static char *msg_get_header(rtsp_message *msg , char *name ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < msg->nheaders) {
    tmp = strcasecmp((char const   *)msg->name[i], (char const   *)name);
    if (! tmp) {
      return (msg->value[i]);
    }
    i ++;
  }
  return ((char *)((void *)0));
}
}
static void msg_free(rtsp_message *msg ) 
{ 
  int i ;

  {
  i = 0;
  while (i < msg->nheaders) {
    free((void *)msg->name[i]);
    free((void *)msg->value[i]);
    i ++;
  }
  if (msg->content) {
    free((void *)msg->content);
  }
  free((void *)msg);
  return;
}
}
static int msg_handle_line(rtsp_message **pmsg , char *line ) 
{ 
  rtsp_message *msg ;
  char *sp ;
  char *p ;
  int tmp ;
  char *p___0 ;
  char *cl ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  msg = *pmsg;
  if (! msg) {
    msg = msg_init();
    *pmsg = msg;
    debug(1, (char *)"received request: %s\n", line);
    p = strtok_r((char * __restrict  )line, (char const   * __restrict  )" ", (char ** __restrict  )(& sp));
    if (! p) {
      goto fail;
    }
    strncpy((char * __restrict  )(msg->method), (char const   * __restrict  )p, sizeof(msg->method) - 1UL);
    p = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                 (char ** __restrict  )(& sp));
    if (! p) {
      goto fail;
    }
    p = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                 (char ** __restrict  )(& sp));
    if (! p) {
      goto fail;
    }
    tmp = strcmp((char const   *)p, "RTSP/1.0");
    if (tmp) {
      goto fail;
    }
    return (-1);
  }
  tmp___2 = strlen((char const   *)line);
  if (tmp___2) {
    p___0 = strstr((char const   *)line, ": ");
    if (! p___0) {
      warn((char *)"bad header: >>%s<<", line);
      goto fail;
    }
    *p___0 = (char)0;
    p___0 += 2;
    msg_add_header(msg, line, p___0);
    debug(2, (char *)"    %s: %s\n", line, p___0);
    return (-1);
  } else {
    tmp___0 = msg_get_header(msg, (char *)"Content-Length");
    cl = tmp___0;
    if (cl) {
      tmp___1 = atoi((char const   *)cl);
      return (tmp___1);
    } else {
      return (0);
    }
  }
  fail: 
  *pmsg = (rtsp_message *)((void *)0);
  msg_free(msg);
  return (0);
}
}
static rtsp_message *rtsp_read_request(int fd___1 ) 
{ 
  ssize_t buflen ;
  char *buf ;
  void *tmp ;
  rtsp_message *msg ;
  ssize_t nread ;
  ssize_t inbuf ;
  int msg_size ;
  int *tmp___0 ;
  char *next ;
  void *tmp___1 ;

  {
  buflen = (ssize_t )512;
  tmp = malloc((size_t )(buflen + 1L));
  buf = (char *)tmp;
  msg = (rtsp_message *)((void *)0);
  inbuf = (ssize_t )0;
  msg_size = -1;
  while (msg_size < 0) {
    if (please_shutdown) {
      debug(1, (char *)"RTSP shutdown requested\n");
      goto shutdown;
    }
    nread = read(fd___1, (void *)(buf + inbuf), (size_t )(buflen - inbuf));
    if (! nread) {
      debug(1, (char *)"RTSP connection closed\n");
      goto shutdown;
    }
    if (nread < 0L) {
      tmp___0 = __errno_location();
      if (*tmp___0 == 4) {
        continue;
      }
      perror("read failure");
      goto shutdown;
    }
    inbuf += nread;
    while (1) {
      if (msg_size < 0) {
        next = nextline(buf, (int )inbuf);
        if (! next) {
          break;
        }
      } else {
        break;
      }
      msg_size = msg_handle_line(& msg, buf);
      if (! msg) {
        warn((char *)"no RTSP header received");
        goto shutdown;
      }
      inbuf -= next - buf;
      if (inbuf) {
        memmove((void *)buf, (void const   *)next, (size_t )inbuf);
      }
    }
  }
  if ((ssize_t )msg_size > buflen) {
    tmp___1 = realloc((void *)buf, (size_t )msg_size);
    buf = (char *)tmp___1;
    if (! buf) {
      warn((char *)"too much content");
      goto shutdown;
    }
    buflen = (ssize_t )msg_size;
  }
  while (inbuf < (ssize_t )msg_size) {
    nread = read(fd___1, (void *)(buf + inbuf), (size_t )((ssize_t )msg_size - inbuf));
    if (! nread) {
      goto shutdown;
    }
    if (nread == 4L) {
      continue;
    }
    if (nread < 0L) {
      perror("read failure");
      goto shutdown;
    }
    inbuf += nread;
  }
  msg->contentlength = (int )inbuf;
  msg->content = buf;
  return (msg);
  shutdown: 
  free((void *)buf);
  if (msg) {
    msg_free(msg);
  }
  return ((rtsp_message *)((void *)0));
}
}
static void msg_write_response(int fd___1 , rtsp_message *resp ) 
{ 
  char pkt[1024] ;
  int pktfree ;
  char *p ;
  int i ;
  int n ;
  char const   *tmp ;
  ssize_t tmp___0 ;

  {
  pktfree = (int )sizeof(pkt);
  p = pkt;
  if (resp->respcode == 200) {
    tmp = "OK";
  } else {
    tmp = "Error";
  }
  n = snprintf((char * __restrict  )p, (size_t )pktfree, (char const   * __restrict  )"RTSP/1.0 %d %s\r\n",
               resp->respcode, tmp);
  debug(1, (char *)"sending response: %s", pkt);
  pktfree -= n;
  p += n;
  i = 0;
  while (i < resp->nheaders) {
    debug(2, (char *)"    %s: %s\n", resp->name[i], resp->value[i]);
    n = snprintf((char * __restrict  )p, (size_t )pktfree, (char const   * __restrict  )"%s: %s\r\n",
                 resp->name[i], resp->value[i]);
    pktfree -= n;
    p += n;
    if (pktfree <= 0) {
      die((char *)"Attempted to write overlong RTSP packet");
    }
    i ++;
  }
  if (pktfree < 3) {
    die((char *)"Attempted to write overlong RTSP packet");
  }
  strcpy((char * __restrict  )p, (char const   * __restrict  )"\r\n");
  tmp___0 = write(fd___1, (void const   *)(pkt), (size_t )((p - pkt) + 2L));
  return;
}
}
static void handle_options(rtsp_conn_info *conn , rtsp_message *req , rtsp_message *resp ) 
{ 


  {
  resp->respcode = 200;
  msg_add_header(resp, (char *)"Public", (char *)"ANNOUNCE, SETUP, RECORD, PAUSE, FLUSH, TEARDOWN, OPTIONS, GET_PARAMETER, SET_PARAMETER");
  return;
}
}
static void handle_teardown(rtsp_conn_info *conn , rtsp_message *req , rtsp_message *resp ) 
{ 
  int tmp ;

  {
  tmp = rtsp_playing();
  if (! tmp) {
    return;
  }
  resp->respcode = 200;
  msg_add_header(resp, (char *)"Connection", (char *)"close");
  please_shutdown = 1;
  return;
}
}
static void handle_flush(rtsp_conn_info *conn , rtsp_message *req , rtsp_message *resp ) 
{ 
  int tmp ;

  {
  tmp = rtsp_playing();
  if (! tmp) {
    return;
  }
  player_flush();
  resp->respcode = 200;
  return;
}
}
static void handle_setup(rtsp_conn_info *conn , rtsp_message *req , rtsp_message *resp ) 
{ 
  int cport ;
  int tport ;
  char *hdr ;
  char *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  int sport ;
  int tmp___2 ;
  char resphdr[100] ;

  {
  tmp = msg_get_header(req, (char *)"Transport");
  hdr = tmp;
  if (! hdr) {
    return;
  }
  p = strstr((char const   *)hdr, "control_port=");
  if (! p) {
    return;
  }
  tmp___0 = strchr((char const   *)p, '=');
  p = tmp___0 + 1;
  cport = atoi((char const   *)p);
  p = strstr((char const   *)hdr, "timing_port=");
  if (! p) {
    return;
  }
  tmp___1 = strchr((char const   *)p, '=');
  p = tmp___1 + 1;
  tport = atoi((char const   *)p);
  rtsp_take_player();
  tmp___2 = rtp_setup(& conn->remote, cport, tport);
  sport = tmp___2;
  if (! sport) {
    return;
  }
  player_play(& conn->stream);
  snprintf((char * __restrict  )(resphdr), sizeof(resphdr), (char const   * __restrict  )"RTP/AVP/UDP;unicast;mode=record;server_port=%d;control_port=%d;timing_port=%d",
           sport, sport, sport);
  msg_add_header(resp, (char *)"Transport", resphdr);
  msg_add_header(resp, (char *)"Session", (char *)"1");
  resp->respcode = 200;
  return;
}
}
static void handle_ignore(rtsp_conn_info *conn , rtsp_message *req , rtsp_message *resp ) 
{ 


  {
  resp->respcode = 200;
  return;
}
}
static void handle_set_parameter_parameter(rtsp_conn_info *conn , rtsp_message *req ,
                                           rtsp_message *resp ) 
{ 
  char *cp ;
  int cp_left ;
  char *next ;
  float volume___1 ;
  double tmp ;
  char *progress ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  cp = req->content;
  cp_left = req->contentlength;
  while (1) {
    if (cp_left) {
      if (! cp) {
        break;
      }
    } else {
      break;
    }
    next = nextline(cp, cp_left);
    cp_left = (int )((long )cp_left - (next - cp));
    tmp___2 = strncmp((char const   *)cp, "volume: ", (size_t )8);
    if (tmp___2) {
      tmp___1 = strncmp((char const   *)cp, "progress: ", (size_t )10);
      if (tmp___1) {
        tmp___0 = strlen((char const   *)cp);
        debug(1, (char *)"unrecognised parameter: >>%s<< (%d)\n", cp, tmp___0);
      } else {
        progress = cp + 10;
        debug(1, (char *)"progress: %s\n", progress);
      }
    } else {
      tmp = atof((char const   *)(cp + 8));
      volume___1 = (float )tmp;
      debug(1, (char *)"volume: %f\n", (double )volume___1);
      player_volume((double )volume___1);
    }
    cp = next;
  }
  return;
}
}
static void handle_set_parameter_metadata(rtsp_conn_info *conn , rtsp_message *req ,
                                          rtsp_message *resp ) 
{ 
  char *cp ;
  int cl ;
  unsigned int off ;
  char tag[5] ;
  uint32_t vl ;
  __uint32_t tmp ;
  char *val ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  cp = req->content;
  cl = req->contentlength;
  off = 8U;
  while (off < (unsigned int )cl) {
    strncpy((char * __restrict  )(tag), (char const   * __restrict  )(cp + off), (size_t )4);
    tag[4] = (char )'\000';
    off += 4U;
    tmp = __bswap_32(*((uint32_t *)(cp + off)));
    vl = tmp;
    off = (unsigned int )((unsigned long )off + sizeof(uint32_t ));
    tmp___0 = malloc((size_t )(vl + 1U));
    val = (char *)tmp___0;
    strncpy((char * __restrict  )val, (char const   * __restrict  )(cp + off), (size_t )vl);
    *(val + vl) = (char )'\000';
    off += vl;
    debug(2, (char *)"Tag: %s   Content: %s\n", tag, val);
    tmp___5 = strncmp((char const   *)(tag), "asal ", (size_t )4);
    if (tmp___5) {
      tmp___4 = strncmp((char const   *)(tag), "asar ", (size_t )4);
      if (tmp___4) {
        tmp___3 = strncmp((char const   *)(tag), "ascm ", (size_t )4);
        if (tmp___3) {
          tmp___2 = strncmp((char const   *)(tag), "asgn ", (size_t )4);
          if (tmp___2) {
            tmp___1 = strncmp((char const   *)(tag), "minm ", (size_t )4);
            if (! tmp___1) {
              debug(1, (char *)"META Title: %s\n", val);
              metadata_set(& player_meta.title, (char const   *)val);
            }
          } else {
            debug(1, (char *)"META Genre: %s\n", val);
            metadata_set(& player_meta.genre, (char const   *)val);
          }
        } else {
          debug(1, (char *)"META Comment: %s\n", val);
          metadata_set(& player_meta.comment, (char const   *)val);
        }
      } else {
        debug(1, (char *)"META Artist: %s\n", val);
        metadata_set(& player_meta.artist, (char const   *)val);
      }
    } else {
      debug(1, (char *)"META Album: %s\n", val);
      metadata_set(& player_meta.album, (char const   *)val);
    }
    free((void *)val);
  }
  metadata_write();
  return;
}
}
static void handle_set_parameter_coverart(rtsp_conn_info *conn , rtsp_message *req ,
                                          rtsp_message *resp ) 
{ 
  char *cp ;
  int cl ;
  char *ct ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  cp = req->content;
  cl = req->contentlength;
  tmp = msg_get_header(req, (char *)"Content-Type");
  ct = tmp;
  tmp___1 = strncmp((char const   *)ct, "image/jpeg", (size_t )10);
  if (tmp___1) {
    tmp___0 = strncmp((char const   *)ct, "image/png", (size_t )9);
    if (tmp___0) {
      metadata_cover_image((char const   *)((void *)0), 0, (char const   *)((void *)0));
    } else {
      metadata_cover_image((char const   *)cp, cl, "png");
    }
  } else {
    metadata_cover_image((char const   *)cp, cl, "jpg");
  }
  return;
}
}
static void handle_set_parameter(rtsp_conn_info *conn , rtsp_message *req , rtsp_message *resp ) 
{ 
  char *ct ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (! req->contentlength) {
    debug(1, (char *)"received empty SET_PARAMETER request\n");
  }
  tmp = msg_get_header(req, (char *)"Content-Type");
  ct = tmp;
  if (ct) {
    debug(2, (char *)"SET_PARAMETER Content-Type: %s\n", ct);
    tmp___4 = strncmp((char const   *)ct, "application/x-dmap-tagged", (size_t )25);
    if (tmp___4) {
      tmp___1 = strncmp((char const   *)ct, "image/jpeg", (size_t )10);
      if (tmp___1) {
        tmp___2 = strncmp((char const   *)ct, "image/png", (size_t )9);
        if (tmp___2) {
          tmp___3 = strncmp((char const   *)ct, "image/none", (size_t )10);
          if (tmp___3) {
            tmp___0 = strncmp((char const   *)ct, "text/parameters", (size_t )15);
            if (tmp___0) {
              debug(1, (char *)"received unknown Content-Type %s in SET_PARAMETER request\n",
                    ct);
            } else {
              debug(1, (char *)"received parameters in SET_PARAMETER request\n");
              handle_set_parameter_parameter(conn, req, resp);
            }
          } else {
            debug(1, (char *)"received image in SET_PARAMETER request\n");
            handle_set_parameter_coverart(conn, req, resp);
          }
        } else {
          debug(1, (char *)"received image in SET_PARAMETER request\n");
          handle_set_parameter_coverart(conn, req, resp);
        }
      } else {
        debug(1, (char *)"received image in SET_PARAMETER request\n");
        handle_set_parameter_coverart(conn, req, resp);
      }
    } else {
      debug(1, (char *)"received metadata tags in SET_PARAMETER request\n");
      handle_set_parameter_metadata(conn, req, resp);
    }
  } else {
    debug(1, (char *)"missing Content-Type header in SET_PARAMETER request\n");
  }
  resp->respcode = 200;
  return;
}
}
static void handle_announce(rtsp_conn_info *conn , rtsp_message *req , rtsp_message *resp ) 
{ 
  char *paesiv ;
  char *prsaaeskey ;
  char *pfmtp ;
  char *cp ;
  int cp_left ;
  char *next ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  int keylen ;
  uint8_t *aesiv___0 ;
  uint8_t *tmp___2 ;
  uint8_t *rsaaeskey ;
  uint8_t *tmp___3 ;
  uint8_t *aeskey ;
  uint8_t *tmp___4 ;
  int i ;
  char *tmp___5 ;

  {
  paesiv = (char *)((void *)0);
  prsaaeskey = (char *)((void *)0);
  pfmtp = (char *)((void *)0);
  cp = req->content;
  cp_left = req->contentlength;
  while (1) {
    if (cp_left) {
      if (! cp) {
        break;
      }
    } else {
      break;
    }
    next = nextline(cp, cp_left);
    cp_left = (int )((long )cp_left - (next - cp));
    tmp = strncmp((char const   *)cp, "a=fmtp:", (size_t )7);
    if (! tmp) {
      pfmtp = cp + 7;
    }
    tmp___0 = strncmp((char const   *)cp, "a=aesiv:", (size_t )8);
    if (! tmp___0) {
      paesiv = cp + 8;
    }
    tmp___1 = strncmp((char const   *)cp, "a=rsaaeskey:", (size_t )12);
    if (! tmp___1) {
      prsaaeskey = cp + 12;
    }
    cp = next;
  }
  if (! paesiv) {
    warn((char *)"required params missing from announce");
    return;
  } else
  if (! prsaaeskey) {
    warn((char *)"required params missing from announce");
    return;
  } else
  if (! pfmtp) {
    warn((char *)"required params missing from announce");
    return;
  }
  tmp___2 = base64_dec(paesiv, & len);
  aesiv___0 = tmp___2;
  if (len != 16) {
    warn((char *)"client announced aeskey of %d bytes, wanted 16", len);
    free((void *)aesiv___0);
    return;
  }
  memcpy((void * __restrict  )(conn->stream.aesiv), (void const   * __restrict  )aesiv___0,
         (size_t )16);
  free((void *)aesiv___0);
  tmp___3 = base64_dec(prsaaeskey, & len);
  rsaaeskey = tmp___3;
  tmp___4 = rsa_apply(rsaaeskey, len, & keylen, 1);
  aeskey = tmp___4;
  free((void *)rsaaeskey);
  if (keylen != 16) {
    warn((char *)"client announced rsaaeskey of %d bytes, wanted 16", keylen);
    free((void *)aeskey);
    return;
  }
  memcpy((void * __restrict  )(conn->stream.aeskey), (void const   * __restrict  )aeskey,
         (size_t )16);
  free((void *)aeskey);
  i = 0;
  while ((unsigned long )i < sizeof(conn->stream.fmtp) / sizeof(conn->stream.fmtp[0])) {
    tmp___5 = strsep((char ** __restrict  )(& pfmtp), (char const   * __restrict  )" \t");
    conn->stream.fmtp[i] = atoi((char const   *)tmp___5);
    i ++;
  }
  resp->respcode = 200;
  return;
}
}
static struct method_handler method_handlers[9]  = 
  {      {(char *)"OPTIONS", & handle_options}, 
        {(char *)"ANNOUNCE", & handle_announce}, 
        {(char *)"FLUSH", & handle_flush}, 
        {(char *)"TEARDOWN", & handle_teardown}, 
        {(char *)"SETUP", & handle_setup}, 
        {(char *)"GET_PARAMETER", & handle_ignore}, 
        {(char *)"SET_PARAMETER", & handle_set_parameter}, 
        {(char *)"RECORD", & handle_ignore}, 
        {(char *)((void *)0), (void (*)(rtsp_conn_info *conn , rtsp_message *req , rtsp_message *resp ))((void *)0)}};
static void apple_challenge(int fd___1 ,
                            rtsp_message *req , rtsp_message *resp ) 
{ 
  char *hdr ;
  char *tmp ;
  struct sockaddr_storage fdsa ;
  socklen_t sa_len ;
  int chall_len ;
  uint8_t *chall ;
  uint8_t *tmp___0 ;
  uint8_t buf[48] ;
  uint8_t *bp ;
  int i ;
  struct sockaddr_in6 *sa6 ;
  struct sockaddr_in *sa ;
  uint8_t *tmp___1 ;
  int buflen ;
  int resplen ;
  uint8_t *challresp ;
  uint8_t *tmp___2 ;
  char *encoded ;
  char *tmp___3 ;
  char *padding ;
  char *tmp___4 ;

  {
  tmp = msg_get_header(req, (char *)"Apple-Challenge");
  hdr = tmp;
  if (! hdr) {
    return;
  }
  sa_len = (socklen_t )sizeof(fdsa);
  getsockname(fd___1, (struct sockaddr * __restrict  )((struct sockaddr *)(& fdsa)),
              (socklen_t * __restrict  )(& sa_len));
  tmp___0 = base64_dec(hdr, & chall_len);
  chall = tmp___0;
  bp = buf;
  memset((void *)(buf), 0, sizeof(buf));
  if (chall_len > 16) {
    warn((char *)"oversized Apple-Challenge!");
    free((void *)chall);
    return;
  }
  memcpy((void * __restrict  )bp, (void const   * __restrict  )chall, (size_t )chall_len);
  free((void *)chall);
  bp += chall_len;
  if ((int )fdsa.ss_family == 10) {
    sa6 = (struct sockaddr_in6 *)(& fdsa);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(sa6->sin6_addr.__in6_u.__u6_addr8),
           (size_t )16);
    bp += 16;
  } else {
    sa = (struct sockaddr_in *)(& fdsa);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& sa->sin_addr.s_addr),
           (size_t )4);
    bp += 4;
  }
  i = 0;
  while (i < 6) {
    tmp___1 = bp;
    bp ++;
    *tmp___1 = config.hw_addr[i];
    i ++;
  }
  buflen = (int )(bp - buf);
  if (buflen < 32) {
    buflen = 32;
  }
  tmp___2 = rsa_apply(buf, buflen, & resplen, 0);
  challresp = tmp___2;
  tmp___3 = base64_enc(challresp, resplen);
  encoded = tmp___3;
  tmp___4 = strchr((char const   *)encoded, '=');
  padding = tmp___4;
  if (padding) {
    *padding = (char)0;
  }
  msg_add_header(resp, (char *)"Apple-Response", encoded);
  free((void *)challresp);
  free((void *)encoded);
  return;
}
}
static char *make_nonce(void) 
{ 
  uint8_t random___0[8] ;
  int fd___1 ;
  int tmp ;
  ssize_t tmp___0 ;
  char *tmp___1 ;

  {
  tmp = open("/dev/random", 0);
  fd___1 = tmp;
  if (fd___1 < 0) {
    die((char *)"could not open /dev/random!");
  }
  tmp___0 = read(fd___1, (void *)(random___0), sizeof(random___0));
  close(fd___1);
  tmp___1 = base64_enc(random___0, 8);
  return (tmp___1);
}
}
static int rtsp_auth(char **nonce , rtsp_message *req , rtsp_message *resp ) 
{ 
  char *hdr ;
  char *tmp ;
  int tmp___0 ;
  char *realm ;
  char *tmp___1 ;
  char *username ;
  char *tmp___2 ;
  char *response ;
  char *tmp___3 ;
  char *uri ;
  char *tmp___4 ;
  char *quote ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  uint8_t digest_urp[16] ;
  uint8_t digest_mu[16] ;
  uint8_t digest_total[16] ;
  MD5_CTX ctx ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int i ;
  char buf[33] ;
  size_t tmp___14 ;
  int tmp___15 ;
  int hdrlen ;
  size_t tmp___16 ;
  char *authhdr ;
  void *tmp___17 ;

  {
  if (! config.password) {
    return (0);
  }
  if (! *nonce) {
    *nonce = make_nonce();
    goto authenticate;
  }
  tmp = msg_get_header(req, (char *)"Authorization");
  hdr = tmp;
  if (! hdr) {
    goto authenticate;
  } else {
    tmp___0 = strncmp((char const   *)hdr, "Digest ", (size_t )7);
    if (tmp___0) {
      goto authenticate;
    }
  }
  tmp___1 = strstr((char const   *)hdr, "realm=\"");
  realm = tmp___1;
  tmp___2 = strstr((char const   *)hdr, "username=\"");
  username = tmp___2;
  tmp___3 = strstr((char const   *)hdr, "response=\"");
  response = tmp___3;
  tmp___4 = strstr((char const   *)hdr, "uri=\"");
  uri = tmp___4;
  if (! realm) {
    goto authenticate;
  } else
  if (! username) {
    goto authenticate;
  } else
  if (! response) {
    goto authenticate;
  } else
  if (! uri) {
    goto authenticate;
  }
  tmp___5 = strchr((char const   *)realm, '\"');
  realm = tmp___5 + 1;
  quote = strchr((char const   *)realm, '\"');
  if (! quote) {
    goto authenticate;
  }
  *quote = (char)0;
  tmp___6 = strchr((char const   *)username, '\"');
  username = tmp___6 + 1;
  quote = strchr((char const   *)username, '\"');
  if (! quote) {
    goto authenticate;
  }
  *quote = (char)0;
  tmp___7 = strchr((char const   *)response, '\"');
  response = tmp___7 + 1;
  quote = strchr((char const   *)response, '\"');
  if (! quote) {
    goto authenticate;
  }
  *quote = (char)0;
  tmp___8 = strchr((char const   *)uri, '\"');
  uri = tmp___8 + 1;
  quote = strchr((char const   *)uri, '\"');
  if (! quote) {
    goto authenticate;
  }
  *quote = (char)0;
  MD5_Init(& ctx);
  tmp___9 = strlen((char const   *)username);
  MD5_Update(& ctx, (void const   *)username, tmp___9);
  MD5_Update(& ctx, (void const   *)":", (size_t )1);
  tmp___10 = strlen((char const   *)realm);
  MD5_Update(& ctx, (void const   *)realm, tmp___10);
  MD5_Update(& ctx, (void const   *)":", (size_t )1);
  tmp___11 = strlen((char const   *)config.password);
  MD5_Update(& ctx, (void const   *)config.password, tmp___11);
  MD5_Final(digest_urp, & ctx);
  MD5_Init(& ctx);
  tmp___12 = strlen((char const   *)(req->method));
  MD5_Update(& ctx, (void const   *)(req->method), tmp___12);
  MD5_Update(& ctx, (void const   *)":", (size_t )1);
  tmp___13 = strlen((char const   *)uri);
  MD5_Update(& ctx, (void const   *)uri, tmp___13);
  MD5_Final(digest_mu, & ctx);
  i = 0;
  while (i < 16) {
    sprintf((char * __restrict  )(buf + 2 * i), (char const   * __restrict  )"%02x",
            (int )digest_urp[i]);
    i ++;
  }
  MD5_Init(& ctx);
  MD5_Update(& ctx, (void const   *)(buf), (size_t )32);
  MD5_Update(& ctx, (void const   *)":", (size_t )1);
  tmp___14 = strlen((char const   *)*nonce);
  MD5_Update(& ctx, (void const   *)*nonce, tmp___14);
  MD5_Update(& ctx, (void const   *)":", (size_t )1);
  i = 0;
  while (i < 16) {
    sprintf((char * __restrict  )(buf + 2 * i), (char const   * __restrict  )"%02x",
            (int )digest_mu[i]);
    i ++;
  }
  MD5_Update(& ctx, (void const   *)(buf), (size_t )32);
  MD5_Final(digest_total, & ctx);
  i = 0;
  while (i < 16) {
    sprintf((char * __restrict  )(buf + 2 * i), (char const   * __restrict  )"%02x",
            (int )digest_total[i]);
    i ++;
  }
  tmp___15 = strcmp((char const   *)response, (char const   *)(buf));
  if (! tmp___15) {
    return (0);
  }
  warn((char *)"auth failed");
  authenticate: 
  resp->respcode = 401;
  tmp___16 = strlen((char const   *)*nonce);
  hdrlen = (int )(tmp___16 + 40UL);
  tmp___17 = malloc((size_t )hdrlen);
  authhdr = (char *)tmp___17;
  snprintf((char * __restrict  )authhdr, (size_t )hdrlen, (char const   * __restrict  )"Digest realm=\"taco\", nonce=\"%s\"",
           *nonce);
  msg_add_header(resp, (char *)"WWW-Authenticate", authhdr);
  free((void *)authhdr);
  return (1);
}
}
static void *rtsp_conversation_thread_func(void *pconn ) 
{ 
  sigset_t set ;
  rtsp_conn_info *conn ;
  rtsp_message *req ;
  rtsp_message *resp ;
  char *hdr ;
  char *auth_nonce ;
  int tmp ;
  struct method_handler *mh ;
  int tmp___0 ;
  int tmp___1 ;

  {
  sigemptyset(& set);
  sigaddset(& set, 10);
  pthread_sigmask(1, (__sigset_t const   * __restrict  )(& set), (__sigset_t * __restrict  )((void *)0));
  conn = (rtsp_conn_info *)pconn;
  auth_nonce = (char *)((void *)0);
  while (1) {
    req = rtsp_read_request(conn->fd);
    if (! req) {
      break;
    }
    resp = msg_init();
    resp->respcode = 400;
    apple_challenge(conn->fd, req, resp);
    hdr = msg_get_header(req, (char *)"CSeq");
    if (hdr) {
      msg_add_header(resp, (char *)"CSeq", hdr);
    }
    msg_add_header(resp, (char *)"Audio-Jack-Status", (char *)"connected; type=analog");
    tmp = rtsp_auth(& auth_nonce, req, resp);
    if (tmp) {
      goto respond;
    }
    mh = method_handlers;
    while (mh->method) {
      tmp___0 = strcmp((char const   *)mh->method, (char const   *)(req->method));
      if (! tmp___0) {
        (*(mh->handler))(conn, req, resp);
        break;
      }
      mh ++;
    }
    respond: 
    msg_write_response(conn->fd, resp);
    msg_free(req);
    msg_free(resp);
  }
  debug(1, (char *)"closing RTSP connection\n");
  if (conn->fd > 0) {
    close(conn->fd);
  }
  tmp___1 = rtsp_playing();
  if (tmp___1) {
    rtp_shutdown();
    player_stop();
    please_shutdown = 0;
    pthread_mutex_unlock(& playing_mutex);
  }
  if (auth_nonce) {
    free((void *)auth_nonce);
  }
  conn->running = 0;
  debug(2, (char *)"terminating RTSP thread\n");
  return ((void *)0);
}
}
static char string[46]  ;
static char const   *format_address(struct sockaddr *fsa ) 
{ 
  void *addr ;
  struct sockaddr_in6 *sa6 ;
  struct sockaddr_in *sa ;
  char const   *tmp ;

  {
  if ((int )fsa->sa_family == 10) {
    sa6 = (struct sockaddr_in6 *)fsa;
    addr = (void *)(& sa6->sin6_addr);
  } else {
    sa = (struct sockaddr_in *)fsa;
    addr = (void *)(& sa->sin_addr);
  }
  tmp = inet_ntop((int )fsa->sa_family, (void const   * __restrict  )addr, (char * __restrict  )(string),
                  (socklen_t )sizeof(string));
  return (tmp);
}
}
void rtsp_listen_loop(void) 
{ 
  struct addrinfo hints ;
  struct addrinfo *info ;
  struct addrinfo *p ;
  char portstr[6] ;
  int *sockfd ;
  int nsock ;
  int i ;
  int ret ;
  char const   *tmp ;
  int fd___1 ;
  int tmp___0 ;
  int yes ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  void *tmp___4 ;
  int maxfd ;
  fd_set fds ;
  int __d0 ;
  int __d1 ;
  int acceptfd ;
  struct timeval tv ;
  int *tmp___5 ;
  rtsp_conn_info *conn ;
  void *tmp___6 ;
  socklen_t slen ;
  pthread_t rtsp_conversation_thread ;

  {
  sockfd = (int *)((void *)0);
  nsock = 0;
  memset((void *)(& hints), 0, sizeof(hints));
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  hints.ai_flags = 1;
  snprintf((char * __restrict  )(portstr), (size_t )6, (char const   * __restrict  )"%d",
           config.port);
  ret = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(portstr),
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& info));
  if (ret) {
    tmp = gai_strerror(ret);
    die((char *)"getaddrinfo failed: %s", tmp);
  }
  p = info;
  while (p) {
    tmp___0 = socket(p->ai_family, p->ai_socktype, 6);
    fd___1 = tmp___0;
    yes = 1;
    ret = setsockopt(fd___1, 1, 2, (void const   *)(& yes), (socklen_t )sizeof(yes));
    if (p->ai_family == 10) {
      tmp___1 = setsockopt(fd___1, 41, 26, (void const   *)(& yes), (socklen_t )sizeof(yes));
      ret |= tmp___1;
    }
    if (! ret) {
      ret = bind(fd___1, (struct sockaddr  const  *)p->ai_addr, p->ai_addrlen);
    }
    if (ret) {
      tmp___2 = format_address(p->ai_addr);
      debug(1, (char *)"Failed to bind to address %s\n", tmp___2);
      goto __Cont;
    }
    tmp___3 = format_address(p->ai_addr);
    debug(1, (char *)"Bound to address %s\n", tmp___3);
    listen(fd___1, 5);
    nsock ++;
    tmp___4 = realloc((void *)sockfd, (unsigned long )nsock * sizeof(int ));
    sockfd = (int *)tmp___4;
    *(sockfd + (nsock - 1)) = fd___1;
    __Cont: /* CIL Label */ 
    p = p->ai_next;
  }
  freeaddrinfo(info);
  if (! nsock) {
    die((char *)"could not bind any listen sockets!");
  }
  maxfd = -1;
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.__fds_bits[0]): "memory");
    break;
  }
  i = 0;
  while (i < nsock) {
    if (*(sockfd + i) > maxfd) {
      maxfd = *(sockfd + i);
    }
    i ++;
  }
  mdns_register();
  printf((char const   * __restrict  )"Listening for connections.\n");
  shairport_startup_complete();
  while (1) {
    tv.tv_sec = (__time_t )300;
    tv.tv_usec = (__suseconds_t )0;
    i = 0;
    while (i < nsock) {
      fds.__fds_bits[*(sockfd + i) / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << *(sockfd + i) % (8 * (int )sizeof(__fd_mask )));
      i ++;
    }
    ret = select(maxfd + 1, (fd_set * __restrict  )(& fds), (fd_set * __restrict  )0,
                 (fd_set * __restrict  )0, (struct timeval * __restrict  )(& tv));
    if (ret < 0) {
      tmp___5 = __errno_location();
      if (*tmp___5 == 4) {
        continue;
      }
      break;
    }
    cleanup_threads();
    acceptfd = -1;
    i = 0;
    while (i < nsock) {
      if ((fds.__fds_bits[*(sockfd + i) / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << *(sockfd + i) % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        acceptfd = *(sockfd + i);
        break;
      }
      i ++;
    }
    if (acceptfd < 0) {
      continue;
    }
    tmp___6 = malloc(sizeof(rtsp_conn_info ));
    conn = (rtsp_conn_info *)tmp___6;
    memset((void *)conn, 0, sizeof(rtsp_conn_info ));
    slen = (socklen_t )sizeof(conn->remote);
    debug(1, (char *)"new RTSP connection\n");
    conn->fd = accept(acceptfd, (struct sockaddr * __restrict  )((struct sockaddr *)(& conn->remote)),
                      (socklen_t * __restrict  )(& slen));
    if (conn->fd < 0) {
      perror("failed to accept connection");
      free((void *)conn);
    } else {
      ret = pthread_create((pthread_t * __restrict  )(& rtsp_conversation_thread),
                           (pthread_attr_t const   * __restrict  )((void *)0), & rtsp_conversation_thread_func,
                           (void * __restrict  )conn);
      if (ret) {
        die((char *)"Failed to create RTSP receiver thread!");
      }
      conn->thread = rtsp_conversation_thread;
      conn->running = 1;
      track_thread(conn);
    }
  }
  perror("select");
  die((char *)"fell out of the RTSP select loop");
  return;
}
}
#pragma merger("0","/tmp/cil-xbyDDpvs.i","-O2,-Wall")
mdns_backend mdns_external_avahi ;
mdns_backend mdns_external_dns_sd ;
mdns_backend mdns_tinysvcmdns ;
static mdns_backend *mdns_backends[4]  = {      & mdns_external_avahi,      & mdns_external_dns_sd,      & mdns_tinysvcmdns,      (mdns_backend *)((void *)0)};
void mdns_register(void) 
{ 
  char *mdns_apname ;
  size_t tmp ;
  void *tmp___0 ;
  char *p ;
  int i ;
  char *tmp___1 ;
  mdns_backend **b ;
  int tmp___2 ;
  int error ;
  int tmp___3 ;
  int error___0 ;
  int tmp___4 ;

  {
  tmp = strlen((char const   *)config.apname);
  tmp___0 = malloc(tmp + 14UL);
  mdns_apname = (char *)tmp___0;
  p = mdns_apname;
  i = 0;
  while (i < 6) {
    sprintf((char * __restrict  )p, (char const   * __restrict  )"%02X", (int )config.hw_addr[i]);
    p += 2;
    i ++;
  }
  tmp___1 = p;
  p ++;
  *tmp___1 = (char )'@';
  strcpy((char * __restrict  )p, (char const   * __restrict  )config.apname);
  b = (mdns_backend **)((void *)0);
  if ((unsigned long )config.mdns_name != (unsigned long )((void *)0)) {
    b = mdns_backends;
    while (*b) {
      tmp___2 = strcmp((char const   *)(*b)->name, (char const   *)config.mdns_name);
      if (tmp___2 != 0) {
        goto __Cont;
      }
      tmp___3 = (*((*b)->mdns_register))(mdns_apname, config.port);
      error = tmp___3;
      if (error >= 0) {
        config.mdns = *b;
      }
      break;
      __Cont: /* CIL Label */ 
      b ++;
    }
    if ((unsigned long )*b == (unsigned long )((void *)0)) {
      warn((char *)"%s mDNS backend not found");
    }
  } else {
    b = mdns_backends;
    while (*b) {
      tmp___4 = (*((*b)->mdns_register))(mdns_apname, config.port);
      error___0 = tmp___4;
      if (error___0 >= 0) {
        config.mdns = *b;
        break;
      }
      b ++;
    }
  }
  if ((unsigned long )config.mdns == (unsigned long )((void *)0)) {
    die((char *)"Could not establish mDNS advertisement!");
  }
  return;
}
}
void mdns_unregister(void) 
{ 


  {
  if (config.mdns) {
    (*((config.mdns)->mdns_unregister))();
  }
  return;
}
}
void mdns_ls_backends(void) 
{ 
  mdns_backend **b ;

  {
  b = (mdns_backend **)((void *)0);
  printf((char const   * __restrict  )"Available mDNS backends: \n");
  b = mdns_backends;
  while (*b) {
    printf((char const   * __restrict  )"    %s\n", (*b)->name);
    b ++;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-AXSnrGYY.i","-O2,-Wall")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) execvp)(char const   *__file ,
                                                                                     char * const  *__argv ) ;
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
int mdns_pid  =    0;
static int fork_execvp(char const   *file , char * const  *argv ) 
{ 
  int execpipe[2] ;
  int pid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  ssize_t tmp___4 ;
  int childErrno ;
  int *tmp___5 ;
  ssize_t tmp___6 ;

  {
  pid = 0;
  tmp = pipe((int *)(execpipe));
  if (tmp < 0) {
    return (-1);
  }
  tmp___0 = fcntl(execpipe[1], 1);
  tmp___1 = fcntl(execpipe[1], 2, tmp___0 | 1);
  if (tmp___1 < 0) {
    close(execpipe[0]);
    close(execpipe[1]);
    return (-1);
  }
  pid = fork();
  if (pid < 0) {
    close(execpipe[0]);
    close(execpipe[1]);
    return (-1);
  } else
  if (pid == 0) {
    close(execpipe[0]);
    execvp(file, argv);
    tmp___3 = __errno_location();
    tmp___4 = write(execpipe[1], (void const   *)tmp___3, sizeof(*tmp___2));
    _exit(-1);
    return (0);
  } else {
    close(execpipe[1]);
    tmp___6 = read(execpipe[0], (void *)(& childErrno), sizeof(childErrno));
    if ((unsigned long )tmp___6 == sizeof(childErrno)) {
      tmp___5 = __errno_location();
      *tmp___5 = childErrno;
      return (-1);
    } else {
      return (pid);
    }
  }
}
}
static int mdns_external_avahi_register(char *apname , int port ) 
{ 
  char mdns_port[6] ;
  char *argv[18] ;
  char const   *tmp ;
  int pid ;
  int tmp___0 ;

  {
  sprintf((char * __restrict  )(mdns_port), (char const   * __restrict  )"%d", config.port);
  if (config.password) {
    tmp = "pw=true";
  } else {
    tmp = "pw=false";
  }
  argv[0] = (char *)((void *)0);
  argv[1] = apname;
  argv[2] = (char *)"_raop._tcp";
  argv[3] = mdns_port;
  argv[4] = (char *)"tp=UDP";
  argv[5] = (char *)"sm=false";
  argv[6] = (char *)"ek=1";
  argv[7] = (char *)"et=0,1";
  argv[8] = (char *)"cn=0,1";
  argv[9] = (char *)"ch=2";
  argv[10] = (char *)"ss=16";
  argv[11] = (char *)"sr=44100";
  argv[12] = (char *)"vn=3";
  argv[13] = (char *)"txtvers=1";
  argv[14] = (char *)"da=true";
  argv[15] = (char *)"md=0,1,2";
  argv[16] = (char *)tmp;
  argv[17] = (char *)((void *)0);
  argv[0] = (char *)"avahi-publish-service";
  tmp___0 = fork_execvp((char const   *)argv[0], (char * const  *)(argv));
  pid = tmp___0;
  if (pid >= 0) {
    mdns_pid = pid;
    return (0);
  } else {
    debug(1, (char *)"Calling %s failed", argv[0]);
  }
  argv[0] = (char *)"mDNSPublish";
  pid = fork_execvp((char const   *)argv[0], (char * const  *)(argv));
  if (pid >= 0) {
    mdns_pid = pid;
    return (0);
  } else {
    debug(1, (char *)"Calling %s failed", argv[0]);
  }
  return (-1);
}
}
static int mdns_external_dns_sd_register(char *apname , int port ) 
{ 
  char mdns_port[6] ;
  char *argv[20] ;
  char const   *tmp ;
  int pid ;
  int tmp___0 ;

  {
  sprintf((char * __restrict  )(mdns_port), (char const   * __restrict  )"%d", config.port);
  if (config.password) {
    tmp = "pw=true";
  } else {
    tmp = "pw=false";
  }
  argv[0] = (char *)"dns-sd";
  argv[1] = (char *)"-R";
  argv[2] = apname;
  argv[3] = (char *)"_raop._tcp";
  argv[4] = (char *)".";
  argv[5] = mdns_port;
  argv[6] = (char *)"tp=UDP";
  argv[7] = (char *)"sm=false";
  argv[8] = (char *)"ek=1";
  argv[9] = (char *)"et=0,1";
  argv[10] = (char *)"cn=0,1";
  argv[11] = (char *)"ch=2";
  argv[12] = (char *)"ss=16";
  argv[13] = (char *)"sr=44100";
  argv[14] = (char *)"vn=3";
  argv[15] = (char *)"txtvers=1";
  argv[16] = (char *)"da=true";
  argv[17] = (char *)"md=0,1,2";
  argv[18] = (char *)tmp;
  argv[19] = (char *)((void *)0);
  tmp___0 = fork_execvp((char const   *)argv[0], (char * const  *)(argv));
  pid = tmp___0;
  if (pid >= 0) {
    mdns_pid = pid;
    return (0);
  } else {
    debug(1, (char *)"Calling %s failed", argv[0]);
  }
  return (-1);
}
}
static void kill_mdns_child(void) 
{ 


  {
  if (mdns_pid) {
    kill(mdns_pid, 15);
  }
  mdns_pid = 0;
  return;
}
}
mdns_backend mdns_external_avahi  =    {(char *)"external-avahi", & mdns_external_avahi_register, & kill_mdns_child};
mdns_backend mdns_external_dns_sd  =    {(char *)"external-dns-sd", & mdns_external_dns_sd_register, & kill_mdns_child};
#pragma merger("0","/tmp/cil-oFQ2MZgk.i","-O2,-Wall")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int getifaddrs(struct ifaddrs **__ifap ) ;
extern  __attribute__((__nothrow__)) void freeifaddrs(struct ifaddrs *__ifa ) ;
struct rr_entry *rr_create_aaaa(uint8_t *name , struct in6_addr *addr ) ;
struct rr_entry *rr_create_a(uint8_t *name , uint32_t addr ) ;
uint8_t *create_nlabel(char const   *name ) ;
struct mdnsd *mdnsd_start(void) ;
void mdnsd_stop(struct mdnsd *s ) ;
void mdnsd_set_hostname(struct mdnsd *svr___0 , char const   *hostname , uint32_t ip ) ;
void mdnsd_set_hostname_v6(struct mdnsd *svr___0 , char const   *hostname , struct in6_addr *addr ) ;
void mdnsd_add_rr(struct mdnsd *svr___0 , struct rr_entry *rr ) ;
struct mdns_service *mdnsd_register_svc(struct mdnsd *svr___0 , char const   *instance_name ,
                                        char const   *type , uint16_t port , char const   *hostname ,
                                        char const   **txt ) ;
void mdns_service_destroy(struct mdns_service *srv ) ;
static struct mdnsd *svr  =    (struct mdnsd *)((void *)0);
static int mdns_tinysvcmdns_register(char *apname , int port ) 
{ 
  struct ifaddrs *ifalist ;
  struct ifaddrs *ifa ;
  char hostname[106] ;
  char *hostend ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32_t main_ip ;
  struct in6_addr *addr ;
  uint32_t ip ;
  struct rr_entry *a_e ;
  uint8_t *tmp___3 ;
  struct rr_entry *tmp___4 ;
  struct in6_addr *addr___0 ;
  struct rr_entry *aaaa_e ;
  uint8_t *tmp___5 ;
  struct rr_entry *tmp___6 ;
  char const   *txt[14] ;
  char const   *tmp___7 ;
  struct mdns_service *svc ;
  struct mdns_service *tmp___8 ;

  {
  svr = mdnsd_start();
  if ((unsigned long )svr == (unsigned long )((void *)0)) {
    warn((char *)"tinysvcmdns: mdnsd_start() failed");
    return (-1);
  }
  gethostname(hostname, (size_t )99);
  hostname[99] = (char)0;
  tmp = strlen((char const   *)(hostname));
  hostend = hostname + tmp;
  tmp___0 = strlen((char const   *)(hostname));
  if (tmp___0 > 6UL) {
    tmp___1 = strcmp((char const   *)(hostend - 6), ".local");
    if (tmp___1) {
      strcat((char * __restrict  )(hostname), (char const   * __restrict  )".local");
    }
  }
  tmp___2 = getifaddrs(& ifalist);
  if (tmp___2 < 0) {
    warn((char *)"tinysvcmdns: getifaddrs() failed");
    return (-1);
  }
  ifa = ifalist;
  ifa = ifalist;
  while ((unsigned long )ifa != (unsigned long )((void *)0)) {
    if (! (ifa->ifa_flags & 8U)) {
      if (ifa->ifa_addr) {
        if ((int )(ifa->ifa_addr)->sa_family == 2) {
          main_ip = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr;
          mdnsd_set_hostname(svr, (char const   *)(hostname), main_ip);
          break;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (! (ifa->ifa_flags & 8U)) {
      if (ifa->ifa_addr) {
        if ((int )(ifa->ifa_addr)->sa_family == 10) {
          addr = & ((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr;
          mdnsd_set_hostname_v6(svr, (char const   *)(hostname), addr);
          break;
        }
      }
    }
    ifa = ifa->ifa_next;
  }
  if ((unsigned long )ifa == (unsigned long )((void *)0)) {
    warn((char *)"tinysvcmdns: no non-loopback ipv4 or ipv6 interface found");
    return (-1);
  }
  ifa = ifa->ifa_next;
  while ((unsigned long )ifa != (unsigned long )((void *)0)) {
    if (ifa->ifa_flags & 8U) {
      goto __Cont;
    }
    switch ((int )(ifa->ifa_addr)->sa_family) {
    case 2: 
    ip = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr;
    tmp___3 = create_nlabel((char const   *)(hostname));
    tmp___4 = rr_create_a(tmp___3, ip);
    a_e = tmp___4;
    mdnsd_add_rr(svr, a_e);
    break;
    case 10: 
    addr___0 = & ((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr;
    tmp___5 = create_nlabel((char const   *)(hostname));
    tmp___6 = rr_create_aaaa(tmp___5, addr___0);
    aaaa_e = tmp___6;
    mdnsd_add_rr(svr, aaaa_e);
    break;
    }
    __Cont: /* CIL Label */ 
    ifa = ifa->ifa_next;
  }
  freeifaddrs(ifa);
  if (config.password) {
    tmp___7 = "pw=true";
  } else {
    tmp___7 = "pw=false";
  }
  txt[0] = "tp=UDP";
  txt[1] = "sm=false";
  txt[2] = "ek=1";
  txt[3] = "et=0,1";
  txt[4] = "cn=0,1";
  txt[5] = "ch=2";
  txt[6] = "ss=16";
  txt[7] = "sr=44100";
  txt[8] = "vn=3";
  txt[9] = "txtvers=1";
  txt[10] = "da=true";
  txt[11] = "md=0,1,2";
  txt[12] = tmp___7;
  txt[13] = (char const   *)((void *)0);
  tmp___8 = mdnsd_register_svc(svr, (char const   *)apname, "_raop._tcp.local", (uint16_t )port,
                               (char const   *)((void *)0), txt);
  svc = tmp___8;
  mdns_service_destroy(svc);
  return (0);
}
}
static void mdns_tinysvcmdns_unregister(void) 
{ 


  {
  if (svr) {
    mdnsd_stop(svr);
    svr = (struct mdnsd *)((void *)0);
  }
  return;
}
}
mdns_backend mdns_tinysvcmdns  =    {(char *)"tinysvcmdns", & mdns_tinysvcmdns_register, & mdns_tinysvcmdns_unregister};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-_nabJqlb.i","-O2,-Wall")
extern int system(char const   *__command ) ;
extern void BIO_set_flags(BIO *b , int flags ) ;
extern BIO *BIO_new(BIO_METHOD const   *type ) ;
extern int BIO_free(BIO *a ) ;
extern int BIO_read(BIO *b , void *data , int dlen ) ;
extern int BIO_write(BIO *b , void const   *data , int dlen ) ;
extern long BIO_ctrl(BIO *bp , int cmd , long larg , void *parg ) ;
extern BIO *BIO_push(BIO *b , BIO *append ) ;
extern void BIO_free_all(BIO *a ) ;
extern BIO_METHOD const   *BIO_s_mem(void) ;
extern BIO *BIO_new_mem_buf(void const   *buf , int len ) ;
extern int RSA_size(RSA const   *rsa ) ;
extern int RSA_private_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
extern BIO_METHOD const   *BIO_f_base64(void) ;
extern RSA *PEM_read_bio_RSAPrivateKey(BIO *bp , RSA **x , pem_password_cb *cb , void *u ) ;
void command_start(void) ;
void command_stop(void) ;
shairport_cfg config  ;
int debuglev  =    0;
void die(char *format  , ...) 
{ 
  va_list___0 args ;

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"FATAL: ");
  __builtin_va_start(args, format);
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )format, args);
  if (config.daemonise) {
    daemon_fail((char const   *)format, args);
  }
  __builtin_va_end(args);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  shairport_shutdown(1);
  return;
}
}
void warn(char *format  , ...) 
{ 
  va_list___0 args ;

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: ");
  __builtin_va_start(args, format);
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )format, args);
  __builtin_va_end(args);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  return;
}
}
void debug(int level , char *format  , ...) 
{ 
  va_list___0 args ;

  {
  if (level > debuglev) {
    return;
  }
  __builtin_va_start(args, format);
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )format, args);
  __builtin_va_end(args);
  return;
}
}
char *base64_enc(uint8_t *input , int length ) 
{ 
  BIO *bmem ;
  BIO *b64 ;
  BUF_MEM *bptr ;
  BIO_METHOD const   *tmp ;
  BIO_METHOD const   *tmp___0 ;
  char *buf ;
  void *tmp___1 ;

  {
  tmp = BIO_f_base64();
  b64 = BIO_new(tmp);
  tmp___0 = BIO_s_mem();
  bmem = BIO_new(tmp___0);
  b64 = BIO_push(b64, bmem);
  BIO_set_flags(b64, 256);
  BIO_write(b64, (void const   *)input, length);
  BIO_ctrl(b64, 11, 0L, (void *)0);
  BIO_ctrl(b64, 115, 0L, (void *)((char *)(& bptr)));
  tmp___1 = malloc(bptr->length);
  buf = (char *)tmp___1;
  if (bptr->length) {
    memcpy((void * __restrict  )buf, (void const   * __restrict  )bptr->data, bptr->length - 1UL);
    *(buf + (bptr->length - 1UL)) = (char)0;
  }
  BIO_free_all(bmem);
  return (buf);
}
}
uint8_t *base64_dec(char *input , int *outlen ) 
{ 
  BIO *bmem ;
  BIO *b64 ;
  int inlen ;
  size_t tmp ;
  BIO_METHOD const   *tmp___0 ;
  BIO_METHOD const   *tmp___1 ;
  int tmp___2 ;
  int bufsize ;
  size_t tmp___3 ;
  uint8_t *buf ;
  void *tmp___4 ;
  int nread ;

  {
  tmp = strlen((char const   *)input);
  inlen = (int )tmp;
  tmp___0 = BIO_f_base64();
  b64 = BIO_new(tmp___0);
  BIO_set_flags(b64, 256);
  tmp___1 = BIO_s_mem();
  bmem = BIO_new(tmp___1);
  b64 = BIO_push(b64, bmem);
  BIO_write(bmem, (void const   *)input, inlen);
  while (1) {
    tmp___2 = inlen;
    inlen ++;
    if (! (tmp___2 & 3)) {
      break;
    }
    BIO_write(bmem, (void const   *)"=", 1);
  }
  BIO_ctrl(bmem, 11, 0L, (void *)0);
  tmp___3 = strlen((char const   *)input);
  bufsize = (int )((tmp___3 * 3UL) / 4UL + 1UL);
  tmp___4 = malloc((size_t )bufsize);
  buf = (uint8_t *)tmp___4;
  nread = BIO_read(b64, (void *)buf, bufsize);
  BIO_free_all(bmem);
  *outlen = nread;
  return (buf);
}
}
static char super_secret_key[1675]  = 
  {      (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'B',      (char )'E',      (char )'G', 
        (char )'I',      (char )'N',      (char )' ',      (char )'R', 
        (char )'S',      (char )'A',      (char )' ',      (char )'P', 
        (char )'R',      (char )'I',      (char )'V',      (char )'A', 
        (char )'T',      (char )'E',      (char )' ',      (char )'K', 
        (char )'E',      (char )'Y',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'\n', 
        (char )'M',      (char )'I',      (char )'I',      (char )'E', 
        (char )'p',      (char )'Q',      (char )'I',      (char )'B', 
        (char )'A',      (char )'A',      (char )'K',      (char )'C', 
        (char )'A',      (char )'Q',      (char )'E',      (char )'A', 
        (char )'5',      (char )'9',      (char )'d',      (char )'E', 
        (char )'8',      (char )'q',      (char )'L',      (char )'i', 
        (char )'e',      (char )'I',      (char )'t',      (char )'s', 
        (char )'H',      (char )'1',      (char )'W',      (char )'g', 
        (char )'j',      (char )'r',      (char )'c',      (char )'F', 
        (char )'R',      (char )'K',      (char )'j',      (char )'6', 
        (char )'e',      (char )'U',      (char )'W',      (char )'q', 
        (char )'i',      (char )'+',      (char )'b',      (char )'G', 
        (char )'L',      (char )'O',      (char )'X',      (char )'1', 
        (char )'H',      (char )'L',      (char )'3',      (char )'U', 
        (char )'3',      (char )'G',      (char )'h',      (char )'C', 
        (char )'/',      (char )'j',      (char )'0',      (char )'Q', 
        (char )'g',      (char )'9',      (char )'0',      (char )'u', 
        (char )'3',      (char )'s',      (char )'G',      (char )'/', 
        (char )'1',      (char )'C',      (char )'U',      (char )'t', 
        (char )'\n',      (char )'w',      (char )'C',      (char )'5', 
        (char )'v',      (char )'O',      (char )'Y',      (char )'v', 
        (char )'f',      (char )'D',      (char )'m',      (char )'F', 
        (char )'I',      (char )'6',      (char )'o',      (char )'S', 
        (char )'F',      (char )'X',      (char )'i',      (char )'5', 
        (char )'E',      (char )'L',      (char )'a',      (char )'b', 
        (char )'W',      (char )'J',      (char )'m',      (char )'T', 
        (char )'2',      (char )'d',      (char )'K',      (char )'H', 
        (char )'z',      (char )'B',      (char )'J',      (char )'K', 
        (char )'a',      (char )'3',      (char )'k',      (char )'9', 
        (char )'o',      (char )'k',      (char )'+',      (char )'8', 
        (char )'t',      (char )'9',      (char )'u',      (char )'c', 
        (char )'R',      (char )'q',      (char )'M',      (char )'d', 
        (char )'6',      (char )'D',      (char )'Z',      (char )'H', 
        (char )'J',      (char )'2',      (char )'Y',      (char )'C', 
        (char )'C',      (char )'L',      (char )'l',      (char )'D', 
        (char )'R',      (char )'K',      (char )'S',      (char )'K', 
        (char )'v',      (char )'6',      (char )'k',      (char )'D', 
        (char )'q',      (char )'n',      (char )'w',      (char )'4', 
        (char )'U',      (char )'\n',      (char )'w',      (char )'P', 
        (char )'d',      (char )'p',      (char )'O',      (char )'M', 
        (char )'X',      (char )'z',      (char )'i',      (char )'C', 
        (char )'/',      (char )'A',      (char )'M',      (char )'j', 
        (char )'3',      (char )'Z',      (char )'/',      (char )'l', 
        (char )'U',      (char )'V',      (char )'X',      (char )'1', 
        (char )'G',      (char )'7',      (char )'W',      (char )'S', 
        (char )'H',      (char )'C',      (char )'A',      (char )'W', 
        (char )'K',      (char )'f',      (char )'1',      (char )'z', 
        (char )'N',      (char )'S',      (char )'1',      (char )'e', 
        (char )'L',      (char )'v',      (char )'q',      (char )'r', 
        (char )'+',      (char )'b',      (char )'o',      (char )'E', 
        (char )'j',      (char )'X',      (char )'u',      (char )'B', 
        (char )'O',      (char )'i',      (char )'t',      (char )'n', 
        (char )'Z',      (char )'/',      (char )'b',      (char )'D', 
        (char )'z',      (char )'P',      (char )'H',      (char )'r', 
        (char )'T',      (char )'O',      (char )'Z',      (char )'z', 
        (char )'0',      (char )'D',      (char )'e',      (char )'w', 
        (char )'0',      (char )'u',      (char )'o',      (char )'w', 
        (char )'x',      (char )'f',      (char )'\n',      (char )'/', 
        (char )'+',      (char )'s',      (char )'G',      (char )'+', 
        (char )'N',      (char )'C',      (char )'K',      (char )'3', 
        (char )'e',      (char )'Q',      (char )'J',      (char )'V', 
        (char )'x',      (char )'q',      (char )'c',      (char )'a', 
        (char )'J',      (char )'/',      (char )'v',      (char )'E', 
        (char )'H',      (char )'K',      (char )'I',      (char )'V', 
        (char )'d',      (char )'2',      (char )'M',      (char )'+', 
        (char )'5',      (char )'q',      (char )'L',      (char )'7', 
        (char )'1',      (char )'y',      (char )'J',      (char )'Q', 
        (char )'+',      (char )'8',      (char )'7',      (char )'X', 
        (char )'6',      (char )'o',      (char )'V',      (char )'3', 
        (char )'e',      (char )'a',      (char )'Y',      (char )'v', 
        (char )'t',      (char )'3',      (char )'z',      (char )'W', 
        (char )'Z',      (char )'Y',      (char )'D',      (char )'6', 
        (char )'z',      (char )'5',      (char )'v',      (char )'Y', 
        (char )'T',      (char )'c',      (char )'r',      (char )'t', 
        (char )'i',      (char )'j',      (char )'2',      (char )'V', 
        (char )'Z',      (char )'9',      (char )'Z',      (char )'m', 
        (char )'n',      (char )'i',      (char )'/',      (char )'\n', 
        (char )'U',      (char )'A',      (char )'a',      (char )'H', 
        (char )'q',      (char )'n',      (char )'9',      (char )'J', 
        (char )'d',      (char )'s',      (char )'B',      (char )'W', 
        (char )'L',      (char )'U',      (char )'E',      (char )'p', 
        (char )'V',      (char )'v',      (char )'i',      (char )'Y', 
        (char )'n',      (char )'h',      (char )'i',      (char )'m', 
        (char )'N',      (char )'V',      (char )'v',      (char )'Y', 
        (char )'F',      (char )'Z',      (char )'e',      (char )'C', 
        (char )'X',      (char )'g',      (char )'/',      (char )'I', 
        (char )'d',      (char )'T',      (char )'Q',      (char )'+', 
        (char )'x',      (char )'4',      (char )'I',      (char )'R', 
        (char )'d',      (char )'i',      (char )'X',      (char )'N', 
        (char )'v',      (char )'5',      (char )'h',      (char )'E', 
        (char )'e',      (char )'w',      (char )'I',      (char )'D', 
        (char )'A',      (char )'Q',      (char )'A',      (char )'B', 
        (char )'A',      (char )'o',      (char )'I',      (char )'B', 
        (char )'A',      (char )'Q',      (char )'D',      (char )'l', 
        (char )'8',      (char )'A',      (char )'x',      (char )'y', 
        (char )'9',      (char )'X',      (char )'f',      (char )'W', 
        (char )'\n',      (char )'B',      (char )'L',      (char )'m', 
        (char )'k',      (char )'z',      (char )'k',      (char )'E', 
        (char )'i',      (char )'q',      (char )'o',      (char )'S', 
        (char )'w',      (char )'F',      (char )'0',      (char )'P', 
        (char )'s',      (char )'m',      (char )'V',      (char )'r', 
        (char )'P',      (char )'z',      (char )'H',      (char )'9', 
        (char )'K',      (char )'s',      (char )'n',      (char )'w', 
        (char )'L',      (char )'G',      (char )'H',      (char )'+', 
        (char )'Q',      (char )'Z',      (char )'l',      (char )'v', 
        (char )'j',      (char )'W',      (char )'d',      (char )'8', 
        (char )'S',      (char )'W',      (char )'Y',      (char )'G', 
        (char )'N',      (char )'7',      (char )'u',      (char )'1', 
        (char )'5',      (char )'0',      (char )'7',      (char )'H', 
        (char )'v',      (char )'h',      (char )'F',      (char )'5', 
        (char )'N',      (char )'3',      (char )'d',      (char )'r', 
        (char )'J',      (char )'o',      (char )'V',      (char )'U', 
        (char )'3',      (char )'O',      (char )'1',      (char )'4', 
        (char )'n',      (char )'D',      (char )'Y',      (char )'4', 
        (char )'T',      (char )'F',      (char )'Q',      (char )'A', 
        (char )'a',      (char )'\n',      (char )'L',      (char )'l', 
        (char )'J',      (char )'9',      (char )'V',      (char )'M', 
        (char )'3',      (char )'5',      (char )'A',      (char )'A', 
        (char )'p',      (char )'X',      (char )'a',      (char )'L', 
        (char )'y',      (char )'Y',      (char )'1',      (char )'E', 
        (char )'R',      (char )'r',      (char )'N',      (char )'7', 
        (char )'u',      (char )'9',      (char )'A',      (char )'L', 
        (char )'K',      (char )'d',      (char )'2',      (char )'L', 
        (char )'U',      (char )'w',      (char )'Y',      (char )'h', 
        (char )'M',      (char )'7',      (char )'K',      (char )'m', 
        (char )'5',      (char )'3',      (char )'9',      (char )'O', 
        (char )'4',      (char )'y',      (char )'U',      (char )'F', 
        (char )'Y',      (char )'i',      (char )'k',      (char )'E', 
        (char )'2',      (char )'n',      (char )'I',      (char )'P', 
        (char )'s',      (char )'c',      (char )'E',      (char )'s', 
        (char )'A',      (char )'5',      (char )'l',      (char )'t', 
        (char )'p',      (char )'x',      (char )'O',      (char )'g', 
        (char )'U',      (char )'G',      (char )'C',      (char )'Y', 
        (char )'7',      (char )'b',      (char )'7',      (char )'e', 
        (char )'z',      (char )'5',      (char )'\n',      (char )'N', 
        (char )'t',      (char )'D',      (char )'6',      (char )'n', 
        (char )'L',      (char )'1',      (char )'Z',      (char )'K', 
        (char )'a',      (char )'u',      (char )'w',      (char )'7', 
        (char )'a',      (char )'N',      (char )'X',      (char )'m', 
        (char )'V',      (char )'A',      (char )'v',      (char )'m', 
        (char )'J',      (char )'T',      (char )'c',      (char )'u', 
        (char )'P',      (char )'x',      (char )'W',      (char )'m', 
        (char )'o',      (char )'k',      (char )'t',      (char )'F', 
        (char )'3',      (char )'g',      (char )'D',      (char )'J', 
        (char )'K',      (char )'K',      (char )'2',      (char )'w', 
        (char )'x',      (char )'Z',      (char )'u',      (char )'N', 
        (char )'G',      (char )'c',      (char )'J',      (char )'E', 
        (char )'0',      (char )'u',      (char )'F',      (char )'Q', 
        (char )'E',      (char )'G',      (char )'4',      (char )'Z', 
        (char )'3',      (char )'B',      (char )'r',      (char )'W', 
        (char )'P',      (char )'7',      (char )'y',      (char )'o', 
        (char )'N',      (char )'u',      (char )'S',      (char )'K', 
        (char )'3',      (char )'d',      (char )'i',      (char )'i', 
        (char )'2',      (char )'j',      (char )'m',      (char )'\n', 
        (char )'l',      (char )'p',      (char )'P',      (char )'H', 
        (char )'r',      (char )'0',      (char )'O',      (char )'/', 
        (char )'K',      (char )'n',      (char )'P',      (char )'Q', 
        (char )'t',      (char )'z',      (char )'I',      (char )'3', 
        (char )'e',      (char )'g',      (char )'u',      (char )'h', 
        (char )'e',      (char )'0',      (char )'T',      (char )'w', 
        (char )'U',      (char )'e',      (char )'m',      (char )'/', 
        (char )'e',      (char )'Y',      (char )'S',      (char )'d', 
        (char )'y',      (char )'z',      (char )'M',      (char )'y', 
        (char )'V',      (char )'x',      (char )'/',      (char )'Y', 
        (char )'p',      (char )'w',      (char )'k',      (char )'z', 
        (char )'w',      (char )'t',      (char )'Y',      (char )'L', 
        (char )'3',      (char )'s',      (char )'R',      (char )'5', 
        (char )'k',      (char )'0',      (char )'o',      (char )'9', 
        (char )'r',      (char )'K',      (char )'Q',      (char )'L', 
        (char )'t',      (char )'v',      (char )'L',      (char )'z', 
        (char )'f',      (char )'A',      (char )'q',      (char )'d', 
        (char )'B',      (char )'x',      (char )'B',      (char )'u', 
        (char )'r',      (char )'c',      (char )'i',      (char )'z', 
        (char )'\n',      (char )'a',      (char )'a',      (char )'A', 
        (char )'/',      (char )'L',      (char )'0',      (char )'H', 
        (char )'I',      (char )'g',      (char )'A',      (char )'m', 
        (char )'O',      (char )'i',      (char )'t',      (char )'1', 
        (char )'G',      (char )'J',      (char )'A',      (char )'2', 
        (char )'s',      (char )'a',      (char )'M',      (char )'x', 
        (char )'T',      (char )'V',      (char )'P',      (char )'N', 
        (char )'h',      (char )'A',      (char )'o',      (char )'G', 
        (char )'B',      (char )'A',      (char )'P',      (char )'f', 
        (char )'g',      (char )'v',      (char )'1',      (char )'o', 
        (char )'e',      (char )'Z',      (char )'x',      (char )'g', 
        (char )'x',      (char )'m',      (char )'o',      (char )'t', 
        (char )'i',      (char )'C',      (char )'c',      (char )'M', 
        (char )'X',      (char )'F',      (char )'E',      (char )'Q', 
        (char )'E',      (char )'W',      (char )'f',      (char )'l', 
        (char )'z',      (char )'h',      (char )'W',      (char )'Y', 
        (char )'T',      (char )'s',      (char )'X',      (char )'r', 
        (char )'h',      (char )'U',      (char )'I',      (char )'u', 
        (char )'z',      (char )'5',      (char )'j',      (char )'F', 
        (char )'u',      (char )'\n',      (char )'a',      (char )'3', 
        (char )'9',      (char )'G',      (char )'L',      (char )'S', 
        (char )'9',      (char )'9',      (char )'Z',      (char )'E', 
        (char )'E',      (char )'r',      (char )'h',      (char )'L', 
        (char )'d',      (char )'r',      (char )'w',      (char )'j', 
        (char )'8',      (char )'r',      (char )'D',      (char )'D', 
        (char )'V',      (char )'i',      (char )'R',      (char )'V', 
        (char )'J',      (char )'5',      (char )'s',      (char )'k', 
        (char )'O',      (char )'p',      (char )'9',      (char )'z', 
        (char )'F',      (char )'v',      (char )'l',      (char )'Y', 
        (char )'A',      (char )'H',      (char )'s',      (char )'0', 
        (char )'x',      (char )'h',      (char )'9',      (char )'2', 
        (char )'j',      (char )'i',      (char )'1',      (char )'E', 
        (char )'7',      (char )'V',      (char )'/',      (char )'y', 
        (char )'s',      (char )'n',      (char )'K',      (char )'B', 
        (char )'f',      (char )'s',      (char )'M',      (char )'r', 
        (char )'P',      (char )'k',      (char )'k',      (char )'5', 
        (char )'K',      (char )'S',      (char )'K',      (char )'P', 
        (char )'r',      (char )'n',      (char )'j',      (char )'n', 
        (char )'d',      (char )'M',      (char )'\n',      (char )'o', 
        (char )'P',      (char )'d',      (char )'e',      (char )'v', 
        (char )'W',      (char )'n',      (char )'V',      (char )'k', 
        (char )'g',      (char )'J',      (char )'5',      (char )'j', 
        (char )'x',      (char )'F',      (char )'u',      (char )'N', 
        (char )'g',      (char )'x',      (char )'k',      (char )'O', 
        (char )'L',      (char )'M',      (char )'u',      (char )'G', 
        (char )'9',      (char )'i',      (char )'5',      (char )'3', 
        (char )'B',      (char )'4',      (char )'y',      (char )'M', 
        (char )'v',      (char )'D',      (char )'T',      (char )'C', 
        (char )'R',      (char )'i',      (char )'I',      (char )'P', 
        (char )'M',      (char )'Q',      (char )'+',      (char )'+', 
        (char )'N',      (char )'2',      (char )'i',      (char )'L', 
        (char )'D',      (char )'a',      (char )'R',      (char )'A', 
        (char )'o',      (char )'G',      (char )'B',      (char )'A', 
        (char )'O',      (char )'9',      (char )'v',      (char )'/', 
        (char )'/',      (char )'m',      (char )'U',      (char )'8', 
        (char )'e',      (char )'V',      (char )'k',      (char )'Q', 
        (char )'a',      (char )'o',      (char )'A',      (char )'N', 
        (char )'f',      (char )'0',      (char )'Z',      (char )'\n', 
        (char )'o',      (char )'M',      (char )'j',      (char )'W', 
        (char )'8',      (char )'C',      (char )'N',      (char )'4', 
        (char )'x',      (char )'w',      (char )'W',      (char )'A', 
        (char )'2',      (char )'c',      (char )'S',      (char )'E', 
        (char )'I',      (char )'H',      (char )'k',      (char )'d', 
        (char )'9',      (char )'A',      (char )'f',      (char )'F', 
        (char )'k',      (char )'f',      (char )'t',      (char )'u', 
        (char )'v',      (char )'8',      (char )'o',      (char )'y', 
        (char )'L',      (char )'D',      (char )'C',      (char )'G', 
        (char )'3',      (char )'Z',      (char )'A',      (char )'f', 
        (char )'0',      (char )'v',      (char )'r',      (char )'h', 
        (char )'r',      (char )'r',      (char )'t',      (char )'k', 
        (char )'r',      (char )'f',      (char )'a',      (char )'7', 
        (char )'e',      (char )'f',      (char )'+',      (char )'A', 
        (char )'U',      (char )'b',      (char )'6',      (char )'9', 
        (char )'D',      (char )'N',      (char )'g',      (char )'g', 
        (char )'q',      (char )'4',      (char )'m',      (char )'H', 
        (char )'Q',      (char )'A',      (char )'Y',      (char )'B', 
        (char )'p',      (char )'7',      (char )'L',      (char )'+', 
        (char )'\n',      (char )'k',      (char )'5',      (char )'D', 
        (char )'K',      (char )'z',      (char )'J',      (char )'r', 
        (char )'K',      (char )'u',      (char )'O',      (char )'0', 
        (char )'r',      (char )'+',      (char )'R',      (char )'0', 
        (char )'Y',      (char )'b',      (char )'Y',      (char )'9', 
        (char )'p',      (char )'Z',      (char )'D',      (char )'1', 
        (char )'+',      (char )'/',      (char )'g',      (char )'9', 
        (char )'d',      (char )'V',      (char )'t',      (char )'9', 
        (char )'1',      (char )'d',      (char )'6',      (char )'L', 
        (char )'Q',      (char )'N',      (char )'e',      (char )'p', 
        (char )'U',      (char )'E',      (char )'/',      (char )'y', 
        (char )'Y',      (char )'2',      (char )'P',      (char )'P', 
        (char )'5',      (char )'C',      (char )'N',      (char )'o', 
        (char )'F',      (char )'m',      (char )'j',      (char )'e', 
        (char )'d',      (char )'p',      (char )'L',      (char )'H', 
        (char )'M',      (char )'O',      (char )'P',      (char )'F', 
        (char )'d',      (char )'V',      (char )'g',      (char )'q', 
        (char )'D',      (char )'z',      (char )'D',      (char )'F', 
        (char )'x',      (char )'U',      (char )'8',      (char )'h', 
        (char )'L',      (char )'\n',      (char )'A',      (char )'o', 
        (char )'G',      (char )'B',      (char )'A',      (char )'N', 
        (char )'D',      (char )'r',      (char )'r',      (char )'7', 
        (char )'x',      (char )'A',      (char )'J',      (char )'b', 
        (char )'q',      (char )'B',      (char )'j',      (char )'H', 
        (char )'V',      (char )'w',      (char )'I',      (char )'z', 
        (char )'Q',      (char )'4',      (char )'T',      (char )'o', 
        (char )'9',      (char )'p',      (char )'b',      (char )'4', 
        (char )'B',      (char )'N',      (char )'e',      (char )'q', 
        (char )'D',      (char )'n',      (char )'d',      (char )'k', 
        (char )'5',      (char )'Q',      (char )'e',      (char )'7', 
        (char )'f',      (char )'T',      (char )'3',      (char )'+', 
        (char )'/',      (char )'H',      (char )'1',      (char )'n', 
        (char )'j',      (char )'G',      (char )'a',      (char )'C', 
        (char )'0',      (char )'/',      (char )'r',      (char )'X', 
        (char )'E',      (char )'0',      (char )'Q',      (char )'b', 
        (char )'7',      (char )'q',      (char )'5',      (char )'y', 
        (char )'S',      (char )'g',      (char )'n',      (char )'s', 
        (char )'C',      (char )'b',      (char )'3',      (char )'D', 
        (char )'v',      (char )'A',      (char )'\n',      (char )'c', 
        (char )'J',      (char )'y',      (char )'R',      (char )'M', 
        (char )'9',      (char )'S',      (char )'J',      (char )'7', 
        (char )'O',      (char )'K',      (char )'l',      (char )'G', 
        (char )'t',      (char )'0',      (char )'F',      (char )'M', 
        (char )'S',      (char )'d',      (char )'J',      (char )'D', 
        (char )'5',      (char )'K',      (char )'G',      (char )'0', 
        (char )'X',      (char )'P',      (char )'I',      (char )'p', 
        (char )'A',      (char )'V',      (char )'N',      (char )'w', 
        (char )'g',      (char )'p',      (char )'X',      (char )'X', 
        (char )'H',      (char )'5',      (char )'M',      (char )'D', 
        (char )'J',      (char )'g',      (char )'0',      (char )'9', 
        (char )'K',      (char )'H',      (char )'e',      (char )'h', 
        (char )'0',      (char )'k',      (char )'X',      (char )'o', 
        (char )'+',      (char )'Q',      (char )'A',      (char )'6', 
        (char )'v',      (char )'i',      (char )'F',      (char )'B', 
        (char )'i',      (char )'2',      (char )'1',      (char )'y', 
        (char )'3',      (char )'4',      (char )'0',      (char )'N', 
        (char )'o',      (char )'n',      (char )'n',      (char )'E', 
        (char )'f',      (char )'d',      (char )'f',      (char )'\n', 
        (char )'5',      (char )'4',      (char )'P',      (char )'X', 
        (char )'4',      (char )'Z',      (char )'G',      (char )'S', 
        (char )'/',      (char )'X',      (char )'a',      (char )'c', 
        (char )'1',      (char )'U',      (char )'K',      (char )'+', 
        (char )'p',      (char )'L',      (char )'k',      (char )'B', 
        (char )'B',      (char )'+',      (char )'z',      (char )'R', 
        (char )'A',      (char )'o',      (char )'G',      (char )'A', 
        (char )'f',      (char )'0',      (char )'A',      (char )'Y', 
        (char )'3',      (char )'H',      (char )'3',      (char )'q', 
        (char )'K',      (char )'S',      (char )'2',      (char )'l', 
        (char )'M',      (char )'E',      (char )'I',      (char )'4', 
        (char )'b',      (char )'z',      (char )'E',      (char )'F', 
        (char )'o',      (char )'H',      (char )'e',      (char )'K', 
        (char )'3',      (char )'G',      (char )'8',      (char )'9', 
        (char )'5',      (char )'p',      (char )'D',      (char )'a', 
        (char )'K',      (char )'3',      (char )'T',      (char )'F', 
        (char )'B',      (char )'V',      (char )'m',      (char )'D', 
        (char )'7',      (char )'f',      (char )'V',      (char )'0', 
        (char )'Z',      (char )'h',      (char )'o',      (char )'v', 
        (char )'\n',      (char )'1',      (char )'7',      (char )'f', 
        (char )'e',      (char )'g',      (char )'F',      (char )'P', 
        (char )'M',      (char )'w',      (char )'O',      (char )'I', 
        (char )'I',      (char )'8',      (char )'M',      (char )'i', 
        (char )'s',      (char )'Y',      (char )'m',      (char )'9', 
        (char )'Z',      (char )'f',      (char )'T',      (char )'2', 
        (char )'Z',      (char )'0',      (char )'s',      (char )'5', 
        (char )'R',      (char )'o',      (char )'3',      (char )'s', 
        (char )'5',      (char )'r',      (char )'k',      (char )'t', 
        (char )'+',      (char )'n',      (char )'v',      (char )'L', 
        (char )'A',      (char )'d',      (char )'f',      (char )'C', 
        (char )'/',      (char )'P',      (char )'Y',      (char )'P', 
        (char )'K',      (char )'z',      (char )'T',      (char )'L', 
        (char )'a',      (char )'l',      (char )'p',      (char )'G', 
        (char )'S',      (char )'w',      (char )'o',      (char )'m', 
        (char )'S',      (char )'N',      (char )'Y',      (char )'J', 
        (char )'c',      (char )'B',      (char )'9',      (char )'H', 
        (char )'N',      (char )'M',      (char )'l',      (char )'m', 
        (char )'h',      (char )'k',      (char )'G',      (char )'z', 
        (char )'c',      (char )'\n',      (char )'1',      (char )'J', 
        (char )'n',      (char )'L',      (char )'Y',      (char )'T', 
        (char )'4',      (char )'i',      (char )'y',      (char )'U', 
        (char )'y',      (char )'x',      (char )'6',      (char )'p', 
        (char )'c',      (char )'Z',      (char )'B',      (char )'m', 
        (char )'C',      (char )'d',      (char )'8',      (char )'b', 
        (char )'D',      (char )'0',      (char )'i',      (char )'w', 
        (char )'Y',      (char )'/',      (char )'F',      (char )'z', 
        (char )'c',      (char )'g',      (char )'N',      (char )'D', 
        (char )'a',      (char )'U',      (char )'m',      (char )'b', 
        (char )'X',      (char )'9',      (char )'+',      (char )'X', 
        (char )'D',      (char )'v',      (char )'R',      (char )'A', 
        (char )'0',      (char )'C',      (char )'g',      (char )'Y', 
        (char )'E',      (char )'A',      (char )'k',      (char )'E', 
        (char )'7',      (char )'p',      (char )'I',      (char )'P', 
        (char )'l',      (char )'E',      (char )'7',      (char )'1', 
        (char )'q',      (char )'v',      (char )'f',      (char )'J', 
        (char )'Q',      (char )'g',      (char )'o',      (char )'A', 
        (char )'9',      (char )'e',      (char )'m',      (char )'0', 
        (char )'g',      (char )'I',      (char )'\n',      (char )'L', 
        (char )'A',      (char )'u',      (char )'E',      (char )'4', 
        (char )'P',      (char )'u',      (char )'1',      (char )'3', 
        (char )'a',      (char )'K',      (char )'i',      (char )'J', 
        (char )'n',      (char )'f',      (char )'f',      (char )'t', 
        (char )'7',      (char )'h',      (char )'I',      (char )'j', 
        (char )'b',      (char )'K',      (char )'+',      (char )'5', 
        (char )'k',      (char )'y',      (char )'b',      (char )'3', 
        (char )'T',      (char )'y',      (char )'s',      (char )'Z', 
        (char )'v',      (char )'o',      (char )'y',      (char )'D', 
        (char )'n',      (char )'b',      (char )'3',      (char )'H', 
        (char )'O',      (char )'K',      (char )'v',      (char )'I', 
        (char )'n',      (char )'K',      (char )'7',      (char )'v', 
        (char )'X',      (char )'b',      (char )'K',      (char )'u', 
        (char )'U',      (char )'4',      (char )'I',      (char )'S', 
        (char )'g',      (char )'x',      (char )'B',      (char )'2', 
        (char )'b',      (char )'B',      (char )'3',      (char )'H', 
        (char )'c',      (char )'Y',      (char )'z',      (char )'Q', 
        (char )'M',      (char )'G',      (char )'s',      (char )'z', 
        (char )'1',      (char )'q',      (char )'J',      (char )'\n', 
        (char )'2',      (char )'g',      (char )'G',      (char )'0', 
        (char )'N',      (char )'5',      (char )'h',      (char )'v', 
        (char )'J',      (char )'p',      (char )'z',      (char )'w', 
        (char )'w',      (char )'h',      (char )'b',      (char )'h', 
        (char )'X',      (char )'q',      (char )'F',      (char )'K', 
        (char )'A',      (char )'4',      (char )'z',      (char )'a', 
        (char )'a',      (char )'S',      (char )'r',      (char )'w', 
        (char )'6',      (char )'2',      (char )'2',      (char )'w', 
        (char )'D',      (char )'n',      (char )'i',      (char )'A', 
        (char )'K',      (char )'5',      (char )'M',      (char )'l', 
        (char )'I',      (char )'E',      (char )'0',      (char )'t', 
        (char )'I',      (char )'A',      (char )'K',      (char )'K', 
        (char )'P',      (char )'4',      (char )'y',      (char )'x', 
        (char )'N',      (char )'G',      (char )'j',      (char )'o', 
        (char )'D',      (char )'2',      (char )'Q',      (char )'Y', 
        (char )'j',      (char )'h',      (char )'B',      (char )'G', 
        (char )'u',      (char )'h',      (char )'v',      (char )'k', 
        (char )'W',      (char )'K',      (char )'Y',      (char )'=', 
        (char )'\n',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'E',      (char )'N', 
        (char )'D',      (char )' ',      (char )'R',      (char )'S', 
        (char )'A',      (char )' ',      (char )'P',      (char )'R', 
        (char )'I',      (char )'V',      (char )'A',      (char )'T', 
        (char )'E',      (char )' ',      (char )'K',      (char )'E', 
        (char )'Y',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'\000'};
static RSA *rsa  =    (RSA *)((void *)0);
uint8_t *rsa_apply(uint8_t *input , int inlen , int *outlen , int mode ) 
{ 
  BIO *bmem ;
  BIO *tmp ;
  uint8_t *out ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  if (! rsa) {
    tmp = BIO_new_mem_buf((void const   *)(super_secret_key), -1);
    bmem = tmp;
    rsa = PEM_read_bio_RSAPrivateKey(bmem, (RSA **)((void *)0), (pem_password_cb *)((void *)0),
                                     (void *)0);
    BIO_free(bmem);
  }
  tmp___0 = RSA_size((RSA const   *)rsa);
  tmp___1 = malloc((size_t )tmp___0);
  out = (uint8_t *)tmp___1;
  switch (mode) {
  case 0: 
  *outlen = RSA_private_encrypt(inlen, (unsigned char const   *)input, out, rsa, 1);
  break;
  case 1: 
  *outlen = RSA_private_decrypt(inlen, (unsigned char const   *)input, out, rsa, 4);
  break;
  default: 
  die((char *)"bad rsa mode");
  }
  return (out);
}
}
void command_start(void) 
{ 
  __pid_t tmp ;
  int tmp___0 ;

  {
  if (! config.cmd_start) {
    return;
  }
  if (! config.cmd_blocking) {
    tmp = fork();
    if (tmp) {
      return;
    }
  }
  debug(1, (char *)"running start command: %s", config.cmd_start);
  tmp___0 = system((char const   *)config.cmd_start);
  if (tmp___0) {
    warn((char *)"exec of external start command failed");
  }
  if (! config.cmd_blocking) {
    exit(0);
  }
  return;
}
}
void command_stop(void) 
{ 
  __pid_t tmp ;
  int tmp___0 ;

  {
  if (! config.cmd_stop) {
    return;
  }
  if (! config.cmd_blocking) {
    tmp = fork();
    if (tmp) {
      return;
    }
  }
  debug(1, (char *)"running stop command: %s", config.cmd_stop);
  tmp___0 = system((char const   *)config.cmd_stop);
  if (tmp___0) {
    warn((char *)"exec of external stop command failed");
  }
  if (! config.cmd_blocking) {
    exit(0);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-_1jo58oB.i","-O2,-Wall")
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 


  {
  return ((__uint16_t )((((int )__bsx >> 8) & 255) | (((int )__bsx & 255) << 8)));
}
}
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
__inline static uint16_t seq_diff(seq_t a , seq_t b ) 
{ 
  int16_t diff ;

  {
  diff = (int16_t )((int )b - (int )a);
  return ((uint16_t )diff);
}
}
void player_put_packet(seq_t seqno , uint8_t *data , int len ) ;
static int running  =    0;
static int please_shutdown___0  ;
static struct sockaddr_storage rtp_client  ;
static int sock  ;
static pthread_t rtp_thread  ;
static void *rtp_receiver(void *arg ) 
{ 
  uint8_t packet[2048] ;
  uint8_t *pktp ;
  ssize_t nread ;
  ssize_t plen ;
  uint8_t type ;
  seq_t seqno ;
  __uint16_t tmp ;

  {
  while (! please_shutdown___0) {
    nread = recv(sock, (void *)(packet), sizeof(packet), 0);
    if (nread < 0L) {
      break;
    }
    plen = nread;
    type = (uint8_t )((int )packet[1] & -129);
    if ((int )type == 84) {
      continue;
    }
    if ((int )type == 96) {
      goto _L;
    } else
    if ((int )type == 86) {
      _L: /* CIL Label */ 
      pktp = packet;
      if ((int )type == 86) {
        pktp += 4;
        plen -= 4L;
      }
      tmp = __bswap_16(*((unsigned short *)(pktp + 2)));
      seqno = tmp;
      pktp += 12;
      plen -= 12L;
      if (plen >= 16L) {
        player_put_packet(seqno, pktp, (int )plen);
        continue;
      }
      if ((int )type == 86) {
        if ((int )seqno == 0) {
          debug(2, (char *)"resend-related request packet received, ignoring.\n");
          continue;
        }
      }
      debug(1, (char *)"Unknown RTP packet of type 0x%02X length %d seqno %d\n", (int )type,
            nread, (int )seqno);
      continue;
    }
    warn((char *)"Unknown RTP packet of type 0x%02X length %d", (int )type, nread);
  }
  debug(1, (char *)"RTP thread interrupted. terminating.\n");
  close(sock);
  return ((void *)0);
}
}
static int bind_port(struct sockaddr_storage *remote ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *info ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int sport ;
  struct sockaddr_storage local ;
  socklen_t local_len ;
  struct sockaddr_in6 *sa6 ;
  __uint16_t tmp___1 ;
  struct sockaddr_in *sa ;
  __uint16_t tmp___2 ;

  {
  memset((void *)(& hints), 0, sizeof(hints));
  hints.ai_family = (int )remote->ss_family;
  hints.ai_socktype = 2;
  hints.ai_flags = 1;
  tmp = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )"0",
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& info));
  ret = tmp;
  if (ret < 0) {
    tmp___0 = gai_strerror(ret);
    die((char *)"failed to get usable addrinfo?! %s", tmp___0);
  }
  sock = socket((int )remote->ss_family, 2, 17);
  ret = bind(sock, (struct sockaddr  const  *)info->ai_addr, info->ai_addrlen);
  freeaddrinfo(info);
  if (ret < 0) {
    die((char *)"could not bind a UDP port!");
  }
  local_len = (socklen_t )sizeof(local);
  getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& local)),
              (socklen_t * __restrict  )(& local_len));
  if ((int )local.ss_family == 10) {
    sa6 = (struct sockaddr_in6 *)(& local);
    tmp___1 = __bswap_16(sa6->sin6_port);
    sport = (int )tmp___1;
  } else {
    sa = (struct sockaddr_in *)(& local);
    tmp___2 = __bswap_16(sa->sin_port);
    sport = (int )tmp___2;
  }
  return (sport);
}
}
int rtp_setup(struct sockaddr_storage *remote , int cport , int tport ) 
{ 
  struct sockaddr_in6 *sa6 ;
  struct sockaddr_in *sa ;
  int sport ;
  int tmp ;

  {
  if (running) {
    die((char *)"rtp_setup called with active stream!");
  }
  debug(1, (char *)"rtp_setup: cport=%d tport=%d\n", cport, tport);
  memcpy((void * __restrict  )(& rtp_client), (void const   * __restrict  )remote,
         sizeof(rtp_client));
  if ((int )rtp_client.ss_family == 10) {
    sa6 = (struct sockaddr_in6 *)(& rtp_client);
    sa6->sin6_port = __bswap_16((__uint16_t )cport);
  } else {
    sa = (struct sockaddr_in *)(& rtp_client);
    sa->sin_port = __bswap_16((__uint16_t )cport);
  }
  tmp = bind_port(remote);
  sport = tmp;
  debug(1, (char *)"rtp listening on port %d\n", sport);
  please_shutdown___0 = 0;
  pthread_create((pthread_t * __restrict  )(& rtp_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                 & rtp_receiver, (void * __restrict  )((void *)0));
  running = 1;
  return (sport);
}
}
void rtp_shutdown(void) 
{ 
  void *retval ;

  {
  if (! running) {
    die((char *)"rtp_shutdown called without active stream!");
  }
  debug(2, (char *)"shutting down RTP thread\n");
  please_shutdown___0 = 1;
  pthread_kill(rtp_thread, 10);
  pthread_join(rtp_thread, & retval);
  running = 0;
  return;
}
}
void rtp_request_resend(seq_t first , seq_t last ) 
{ 
  uint16_t tmp ;
  char req[8] ;

  {
  if (! running) {
    die((char *)"rtp_request_resend called without active stream!");
  }
  tmp = seq_diff(first, last);
  debug(1, (char *)"requesting resend on %d packets (%04X:%04X)\n", (int )tmp + 1,
        (int )first, (int )last);
  req[0] = (char)-128;
  req[1] = (char)-43;
  *((unsigned short *)(req + 2)) = __bswap_16((__uint16_t )1);
  *((unsigned short *)(req + 4)) = __bswap_16(first);
  *((unsigned short *)(req + 6)) = __bswap_16((__uint16_t )(((int )last - (int )first) + 1));
  sendto(sock, (void const   *)(req), sizeof(req), 0, (struct sockaddr  const  *)((struct sockaddr *)(& rtp_client)),
         (socklen_t )sizeof(rtp_client));
  return;
}
}
#pragma merger("0","/tmp/cil-Wtlxhedi.i","-O2,-Wall")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkfifo)(char const   *__path ,
                                                                                   __mode_t __mode ) ;
metadata player_meta  ;
static int fd  =    -1;
static int dirty  =    0;
void metadata_set(char **field , char const   *value ) 
{ 
  int tmp ;

  {
  if (*field) {
    tmp = strcmp((char const   *)*field, value);
    if (! tmp) {
      return;
    }
    free((void *)*field);
  }
  *field = strdup(value);
  dirty = 1;
  return;
}
}
void metadata_open(void) 
{ 
  char fn[12] ;
  size_t pl ;
  size_t tmp ;
  size_t tmp___0 ;
  char *path ;
  void *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  if (! config.meta_dir) {
    return;
  }
  fn[0] = (char )'n';
  fn[1] = (char )'o';
  fn[2] = (char )'w';
  fn[3] = (char )'_';
  fn[4] = (char )'p';
  fn[5] = (char )'l';
  fn[6] = (char )'a';
  fn[7] = (char )'y';
  fn[8] = (char )'i';
  fn[9] = (char )'n';
  fn[10] = (char )'g';
  fn[11] = (char )'\000';
  tmp = strlen((char const   *)config.meta_dir);
  tmp___0 = strlen((char const   *)(fn));
  pl = (tmp + 1UL) + tmp___0;
  tmp___1 = malloc(pl + 1UL);
  path = (char *)tmp___1;
  snprintf((char * __restrict  )path, pl + 1UL, (char const   * __restrict  )"%s/%s",
           config.meta_dir, fn);
  tmp___2 = mkfifo((char const   *)path, (__mode_t )420);
  if (tmp___2) {
    tmp___3 = __errno_location();
    if (*tmp___3 != 17) {
      die((char *)"Could not create metadata FIFO %s", path);
    }
  }
  fd = open((char const   *)path, 2049);
  if (fd < 0) {
    debug(1, (char *)"Could not open metadata FIFO %s. Will try again later.", path);
  }
  free((void *)path);
  return;
}
}
static void metadata_close(void) 
{ 


  {
  close(fd);
  fd = -1;
  return;
}
}
static void print_one(char const   *name , char const   *value ) 
{ 
  size_t tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
  tmp = strlen(name);
  tmp___0 = write(fd, (void const   *)name, tmp);
  tmp___1 = write(fd, (void const   *)"=", (size_t )1);
  if (value) {
    tmp___2 = strlen(value);
    tmp___3 = write(fd, (void const   *)value, tmp___2);
  }
  tmp___4 = write(fd, (void const   *)"\n", (size_t )1);
  return;
}
}
void metadata_write(void) 
{ 
  int ret ;
  ssize_t tmp ;

  {
  if (fd < 0) {
    metadata_open();
  }
  if (fd < 0) {
    return;
  }
  if (! dirty) {
    return;
  }
  dirty = 0;
  print_one("artist", (char const   *)player_meta.artist);
  print_one("title", (char const   *)player_meta.title);
  print_one("album", (char const   *)player_meta.album);
  print_one("artwork", (char const   *)player_meta.artwork);
  print_one("genre", (char const   *)player_meta.genre);
  print_one("comment", (char const   *)player_meta.comment);
  tmp = write(fd, (void const   *)"\n", (size_t )1);
  ret = (int )tmp;
  if (ret < 1) {
    metadata_close();
  }
  return;
}
}
void metadata_cover_image(char const   *buf , int len , char const   *ext ) 
{ 
  uint8_t img_md5[16] ;
  MD5_CTX ctx ;
  char img_md5_str[33] ;
  int i ;
  char *dir ;
  char *prefix ;
  size_t pl ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *path ;
  void *tmp___3 ;
  int cover_fd ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;

  {
  if (! config.meta_dir) {
    return;
  }
  if (buf) {
    debug(1, (char *)"Cover Art set\n");
  } else {
    debug(1, (char *)"Cover Art cleared\n");
    return;
  }
  MD5_Init(& ctx);
  MD5_Update(& ctx, (void const   *)buf, (size_t )len);
  MD5_Final(img_md5, & ctx);
  i = 0;
  while (i < 16) {
    sprintf((char * __restrict  )(& img_md5_str[i * 2]), (char const   * __restrict  )"%02x",
            (int )img_md5[i]);
    i ++;
  }
  dir = config.meta_dir;
  prefix = (char *)"cover-";
  tmp = strlen((char const   *)dir);
  tmp___0 = strlen((char const   *)prefix);
  tmp___1 = strlen((char const   *)(img_md5_str));
  tmp___2 = strlen(ext);
  pl = ((((tmp + 1UL) + tmp___0) + tmp___1) + 1UL) + tmp___2;
  tmp___3 = malloc(pl + 1UL);
  path = (char *)tmp___3;
  snprintf((char * __restrict  )path, pl + 1UL, (char const   * __restrict  )"%s/%s%s.%s",
           dir, prefix, img_md5_str, ext);
  tmp___4 = open((char const   *)path, 65, 384);
  cover_fd = tmp___4;
  if (cover_fd < 0) {
    warn((char *)"Could not open file %s for writing cover art", path);
    return;
  }
  tmp___5 = write(cover_fd, (void const   *)buf, (size_t )len);
  if (tmp___5 < (ssize_t )len) {
    warn((char *)"writing %s failed\n", path);
    free((void *)path);
    return;
  }
  close(cover_fd);
  debug(1, (char *)"Cover Art file is %s\n", path);
  tmp___6 = strlen((char const   *)dir);
  metadata_set(& player_meta.artwork, (char const   *)((path + tmp___6) + 1));
  free((void *)path);
  return;
}
}
#pragma merger("0","/tmp/cil-GcVkj5f6.i","-O2,-Wall")
extern  __attribute__((__nothrow__)) int rand(void) ;
extern int AES_set_decrypt_key(unsigned char const   *userKey , int const   bits ,
                               AES_KEY *key ) ;
extern void AES_cbc_encrypt(unsigned char const   *in , unsigned char *out , size_t length ,
                            AES_KEY const   *key , unsigned char *ivec , int const   enc ) ;
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
alac_file *alac_create(int samplesize , int numchannels ) ;
void alac_decode_frame(alac_file *alac , unsigned char *inbuffer , void *outbuffer ,
                       int *outputsize ) ;
void alac_allocate_buffers(alac_file *alac ) ;
void alac_free(alac_file *alac ) ;
static unsigned char *aesiv  ;
static AES_KEY aes  ;
static int sampling_rate  ;
static int frame_size  ;
static pthread_t player_thread  ;
static int please_stop  ;
static alac_file *decoder_info  ;
static double volume  =    1.0;
static int fix_volume  =    65536;
static pthread_mutex_t vol_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static abuf_t audio_buffer[512]  ;
static seq_t ab_read  ;
static seq_t ab_write  ;
static int ab_buffering  =    1;
static int ab_synced  =    0;
static pthread_mutex_t ab_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static void bf_est_reset(short fill ) ;
static void ab_resync(void) 
{ 
  int i ;

  {
  i = 0;
  while (i < 512) {
    audio_buffer[i].ready = 0;
    i ++;
  }
  ab_synced = 0;
  ab_buffering = 1;
  return;
}
}
__inline static int seq_order(seq_t a , seq_t b ) 
{ 
  short d ;

  {
  d = (short )((int )b - (int )a);
  return ((int )d > 0);
}
}
static void alac_decode(short *dest , uint8_t *buf , int len ) 
{ 
  unsigned char packet[2048] ;
  unsigned char iv[16] ;
  int aeslen ;
  int outsize ;

  {
  if (! (len <= 2048)) {
    __assert_fail("len<=MAX_PACKET", "player.c", 112U, "alac_decode");
  }
  aeslen = len & -16;
  memcpy((void * __restrict  )(iv), (void const   * __restrict  )aesiv, sizeof(iv));
  AES_cbc_encrypt((unsigned char const   *)buf, packet, (size_t )aeslen, (AES_KEY const   *)(& aes),
                  iv, (int const   )0);
  memcpy((void * __restrict  )(packet + aeslen), (void const   * __restrict  )(buf + aeslen),
         (size_t )(len - aeslen));
  alac_decode_frame(decoder_info, packet, (void *)dest, & outsize);
  if (! (outsize == 4 * frame_size)) {
    __assert_fail("outsize == FRAME_BYTES(frame_size)", "player.c", 124U, "alac_decode");
  }
  return;
}
}
static int init_decoder(int32_t *fmtp ) 
{ 
  alac_file *alac ;
  int sample_size ;

  {
  frame_size = *(fmtp + 1);
  sampling_rate = *(fmtp + 11);
  sample_size = *(fmtp + 3);
  if (sample_size != 16) {
    die((char *)"only 16-bit samples supported!");
  }
  alac = alac_create(sample_size, 2);
  if (! alac) {
    return (1);
  }
  decoder_info = alac;
  alac->setinfo_max_samples_per_frame = (uint32_t )frame_size;
  alac->setinfo_7a = (uint8_t )*(fmtp + 2);
  alac->setinfo_sample_size = (uint8_t )sample_size;
  alac->setinfo_rice_historymult = (uint8_t )*(fmtp + 4);
  alac->setinfo_rice_initialhistory = (uint8_t )*(fmtp + 5);
  alac->setinfo_rice_kmodifier = (uint8_t )*(fmtp + 6);
  alac->setinfo_7f = (uint8_t )*(fmtp + 7);
  alac->setinfo_80 = (uint16_t )*(fmtp + 8);
  alac->setinfo_82 = (uint32_t )*(fmtp + 9);
  alac->setinfo_86 = (uint32_t )*(fmtp + 10);
  alac->setinfo_8a_rate = (uint32_t )*(fmtp + 11);
  alac_allocate_buffers(alac);
  return (0);
}
}
static void free_decoder(void) 
{ 


  {
  alac_free(decoder_info);
  return;
}
}
static void init_buffer(void) 
{ 
  int i ;
  void *tmp ;

  {
  i = 0;
  while (i < 512) {
    tmp = malloc((size_t )(4 * (frame_size + 3)));
    audio_buffer[i].data = (short *)tmp;
    i ++;
  }
  ab_resync();
  return;
}
}
static void free_buffer(void) 
{ 
  int i ;

  {
  i = 0;
  while (i < 512) {
    free((void *)audio_buffer[i].data);
    i ++;
  }
  return;
}
}
void player_put_packet(seq_t seqno , uint8_t *data , int len ) 
{ 
  abuf_t *abuf ;
  int16_t buf_fill ;
  int tmp ;
  int tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;

  {
  abuf = (abuf_t *)0;
  pthread_mutex_lock(& ab_mutex);
  if (! ab_synced) {
    debug(2, (char *)"syncing to first seqno %04X\n", (int )seqno);
    ab_write = (seq_t )((int )seqno - 1);
    ab_read = seqno;
    ab_synced = 1;
  }
  tmp___1 = seq_diff(ab_write, seqno);
  if ((int )tmp___1 == 1) {
    abuf = audio_buffer + (int )seqno % 512;
    ab_write = seqno;
  } else {
    tmp___0 = seq_order(ab_write, seqno);
    if (tmp___0) {
      rtp_request_resend((seq_t )((int )ab_write + 1), (seq_t )((int )seqno - 1));
      abuf = audio_buffer + (int )seqno % 512;
      ab_write = seqno;
    } else {
      tmp = seq_order(ab_read, seqno);
      if (tmp) {
        abuf = audio_buffer + (int )seqno % 512;
      } else {
        debug(1, (char *)"late packet %04X (%04X:%04X)", (int )seqno, (int )ab_read,
              (int )ab_write);
      }
    }
  }
  tmp___2 = seq_diff(ab_read, ab_write);
  buf_fill = (int16_t )tmp___2;
  pthread_mutex_unlock(& ab_mutex);
  if (abuf) {
    alac_decode(abuf->data, data, len);
    abuf->ready = 1;
  }
  pthread_mutex_lock(& ab_mutex);
  if (ab_buffering) {
    if ((int )buf_fill >= config.buffer_start_fill) {
      debug(1, (char *)"buffering over. starting play\n");
      ab_buffering = 0;
      bf_est_reset(buf_fill);
    }
  }
  pthread_mutex_unlock(& ab_mutex);
  return;
}
}
static short lcg_rand(void) ;
static unsigned long lcg_prev  =    12345UL;
static short lcg_rand(void) 
{ 


  {
  lcg_prev = lcg_prev * 69069UL + 3UL;
  return ((short )(lcg_prev & 65535UL));
}
}
static short rand_a  ;
static short rand_b  ;
__inline static short dithered_vol(short sample ) 
{ 
  long out ;

  {
  out = (long )sample * (long )fix_volume;
  if (fix_volume < 65536) {
    rand_b = rand_a;
    rand_a = lcg_rand();
    out += (long )rand_a;
    out -= (long )rand_b;
  }
  return ((short )(out >> 16));
}
}
static void biquad_init(biquad_t *bq , double *a , double *b ) 
{ 
  double tmp ;

  {
  tmp = 0.0;
  bq->hist[1] = tmp;
  bq->hist[0] = tmp;
  memcpy((void * __restrict  )(bq->a), (void const   * __restrict  )a, 2UL * sizeof(double ));
  memcpy((void * __restrict  )(bq->b), (void const   * __restrict  )b, 3UL * sizeof(double ));
  return;
}
}
static void biquad_lpf(biquad_t *bq , double freq , double Q ) 
{ 
  double w0 ;
  double alpha ;
  double tmp ;
  double a_0 ;
  double b[3] ;
  double a[2] ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  w0 = (((2.0 * 3.14159265358979323846) * freq) * (double )frame_size) / (double )sampling_rate;
  tmp = sin(w0);
  alpha = tmp / (2.0 * Q);
  a_0 = 1.0 + alpha;
  tmp___0 = cos(w0);
  b[0] = (1.0 - tmp___0) / (2.0 * a_0);
  tmp___1 = cos(w0);
  b[1] = (1.0 - tmp___1) / a_0;
  b[2] = b[0];
  tmp___2 = cos(w0);
  a[0] = (- 2.0 * tmp___2) / a_0;
  a[1] = ((double )1 - alpha) / a_0;
  biquad_init(bq, a, b);
  return;
}
}
static double biquad_filt(biquad_t *bq , double in ) 
{ 
  double w ;
  double out ;

  {
  w = (in - bq->a[0] * bq->hist[0]) - bq->a[1] * bq->hist[1];
  out = (bq->b[1] * bq->hist[0] + bq->b[2] * bq->hist[1]) + bq->b[0] * w;
  bq->hist[1] = bq->hist[0];
  bq->hist[0] = w;
  return (out);
}
}
static double bf_playback_rate  =    1.0;
static double bf_est_drift  =    0.0;
static biquad_t bf_drift_lpf  ;
static double bf_est_err  =    0.0;
static double bf_last_err  ;
static biquad_t bf_err_lpf  ;
static biquad_t bf_err_deriv_lpf  ;
static double desired_fill  ;
static int fill_count  ;
static void bf_est_reset(short fill ) 
{ 


  {
  biquad_lpf(& bf_drift_lpf, 1.0 / 180.0, 0.3);
  biquad_lpf(& bf_err_lpf, 1.0 / 10.0, 0.25);
  biquad_lpf(& bf_err_deriv_lpf, 1.0 / 2.0, 0.2);
  fill_count = 0;
  bf_playback_rate = 1.0;
  bf_last_err = (double )0;
  bf_est_err = bf_last_err;
  fill_count = 0;
  desired_fill = (double )fill_count;
  return;
}
}
static void bf_est_update(short fill ) 
{ 
  double buf_delta ;
  double err_deriv ;
  double tmp ;
  double adj_error ;

  {
  if (fill_count < 1000) {
    desired_fill += (double )fill / 1000.0;
    fill_count ++;
    return;
  } else
  if (fill_count == 1000) {
    debug(1, (char *)"established desired fill of %f frames, so output chain buffered about %f frames\n",
          desired_fill, (double )config.buffer_start_fill - desired_fill);
    fill_count ++;
  }
  buf_delta = (double )fill - desired_fill;
  bf_est_err = biquad_filt(& bf_err_lpf, buf_delta);
  tmp = biquad_filt(& bf_err_deriv_lpf, bf_est_err - bf_last_err);
  err_deriv = tmp;
  adj_error = 1e-4 * bf_est_err;
  bf_est_drift = biquad_filt(& bf_drift_lpf, 1e-1 * (adj_error + err_deriv) + bf_est_drift);
  debug(3, (char *)"bf %d err %f drift %f desiring %f ed %f estd %f\n", (int )fill,
        bf_est_err, bf_est_drift, desired_fill, err_deriv, err_deriv + adj_error);
  bf_playback_rate = (1.0 + adj_error) + bf_est_drift;
  bf_last_err = bf_est_err;
  return;
}
}
static short *buffer_get_frame(void) 
{ 
  int16_t buf_fill ;
  seq_t read___0 ;
  seq_t next ;
  abuf_t *abuf ;
  int i ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  abuf_t *curframe ;

  {
  abuf = (abuf_t *)0;
  if (ab_buffering) {
    return ((short *)0);
  }
  pthread_mutex_lock(& ab_mutex);
  tmp = seq_diff(ab_read, ab_write);
  buf_fill = (int16_t )tmp;
  if ((int )buf_fill < 1) {
    goto _L;
  } else
  if (! ab_synced) {
    _L: /* CIL Label */ 
    if ((int )buf_fill < 1) {
      warn((char *)"underrun.");
    }
    ab_buffering = 1;
    pthread_mutex_unlock(& ab_mutex);
    return ((short *)0);
  }
  if ((int )buf_fill >= 512) {
    warn((char *)"overrun.");
    ab_read = (seq_t )((int )ab_write - config.buffer_start_fill);
  }
  read___0 = ab_read;
  ab_read = (seq_t )((int )ab_read + 1);
  tmp___0 = seq_diff(ab_read, ab_write);
  buf_fill = (int16_t )tmp___0;
  bf_est_update(buf_fill);
  if (! ab_buffering) {
    i = 16;
    while (i < config.buffer_start_fill / 2) {
      next = (seq_t )((int )ab_read + i);
      abuf = audio_buffer + (int )next % 512;
      if (! abuf->ready) {
        rtp_request_resend(next, next);
      }
      i *= 2;
    }
  }
  curframe = audio_buffer + (int )read___0 % 512;
  if (! curframe->ready) {
    debug(1, (char *)"missing frame %04X.", (int )read___0);
    memset((void *)curframe->data, 0, (size_t )(4 * frame_size));
  }
  curframe->ready = 0;
  pthread_mutex_unlock(& ab_mutex);
  return (curframe->data);
}
}
static int stuff_buffer(double playback_rate , short *inptr , short *outptr ) 
{ 
  int i ;
  int stuffsamp ;
  int stuff ;
  double p_stuff ;
  double tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  short *tmp___3 ;
  short *tmp___4 ;
  short *tmp___5 ;
  short *tmp___6 ;
  short *tmp___7 ;
  short *tmp___8 ;
  short *tmp___9 ;
  short *tmp___10 ;
  short *tmp___11 ;
  short *tmp___12 ;

  {
  stuffsamp = frame_size;
  stuff = 0;
  tmp = fabs(playback_rate - 1.0);
  tmp___0 = pow(1.0 - tmp, (double )frame_size);
  p_stuff = 1.0 - tmp___0;
  tmp___2 = rand();
  if ((double )tmp___2 < p_stuff * (double )2147483647) {
    if (playback_rate > 1.0) {
      stuff = -1;
    } else {
      stuff = 1;
    }
    tmp___1 = rand();
    stuffsamp = tmp___1 % (frame_size - 1);
  }
  pthread_mutex_lock(& vol_mutex);
  i = 0;
  while (i < stuffsamp) {
    tmp___3 = outptr;
    outptr ++;
    tmp___4 = inptr;
    inptr ++;
    *tmp___3 = dithered_vol(*tmp___4);
    tmp___5 = outptr;
    outptr ++;
    tmp___6 = inptr;
    inptr ++;
    *tmp___5 = dithered_vol(*tmp___6);
    i ++;
  }
  if (stuff) {
    if (stuff == 1) {
      debug(2, (char *)"+++++++++\n");
      tmp___7 = outptr;
      outptr ++;
      *tmp___7 = dithered_vol((short )(((long )*(inptr + -2) + (long )*(inptr + 0)) >> 1));
      tmp___8 = outptr;
      outptr ++;
      *tmp___8 = dithered_vol((short )(((long )*(inptr + -1) + (long )*(inptr + 1)) >> 1));
    } else
    if (stuff == -1) {
      debug(2, (char *)"---------\n");
      inptr ++;
      inptr ++;
    }
    i = stuffsamp;
    while (i < frame_size + stuff) {
      tmp___9 = outptr;
      outptr ++;
      tmp___10 = inptr;
      inptr ++;
      *tmp___9 = dithered_vol(*tmp___10);
      tmp___11 = outptr;
      outptr ++;
      tmp___12 = inptr;
      inptr ++;
      *tmp___11 = dithered_vol(*tmp___12);
      i ++;
    }
  }
  pthread_mutex_unlock(& vol_mutex);
  return (frame_size + stuff);
}
}
static void *player_thread_func(void *arg ) 
{ 
  int play_samples ;
  short *inbuf ;
  short *outbuf ;
  short *silence ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = malloc((size_t )(4 * (frame_size + 3)));
  outbuf = (short *)tmp;
  tmp___0 = malloc((size_t )(4 * (frame_size + 3)));
  silence = (short *)tmp___0;
  memset((void *)silence, 0, (size_t )(4 * (frame_size + 3)));
  while (! please_stop) {
    inbuf = buffer_get_frame();
    if (! inbuf) {
      inbuf = silence;
    }
    play_samples = stuff_buffer(bf_playback_rate, inbuf, outbuf);
    (*((config.output)->play))(outbuf, play_samples);
  }
  return ((void *)0);
}
}
void player_volume(double f ) 
{ 
  double linear_volume ;
  double tmp ;

  {
  tmp = pow(10.0, 0.05 * f);
  linear_volume = tmp;
  if ((config.output)->volume) {
    (*((config.output)->volume))(linear_volume);
  } else {
    pthread_mutex_lock(& vol_mutex);
    volume = linear_volume;
    fix_volume = (int )(65536.0 * volume);
    pthread_mutex_unlock(& vol_mutex);
  }
  return;
}
}
void player_flush(void) 
{ 


  {
  pthread_mutex_lock(& ab_mutex);
  ab_resync();
  pthread_mutex_unlock(& ab_mutex);
  return;
}
}
int player_play(stream_cfg *stream ) 
{ 


  {
  if (config.buffer_start_fill > 512) {
    die((char *)"specified buffer starting fill %d > buffer size %d", config.buffer_start_fill,
        512);
  }
  AES_set_decrypt_key((unsigned char const   *)(stream->aeskey), (int const   )128,
                      & aes);
  aesiv = stream->aesiv;
  init_decoder((int32_t *)(stream->fmtp));
  init_buffer();
  please_stop = 0;
  command_start();
  (*((config.output)->start))(sampling_rate);
  pthread_create((pthread_t * __restrict  )(& player_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                 & player_thread_func, (void * __restrict  )((void *)0));
  return (0);
}
}
void player_stop(void) 
{ 


  {
  please_stop = 1;
  pthread_join(player_thread, (void **)((void *)0));
  (*((config.output)->stop))();
  command_stop();
  free_buffer();
  free_decoder();
  return;
}
}
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
#pragma merger("0","/tmp/cil-jfG0FlyH.i","-O2,-Wall")
static int const   host_bigendian  =    (int const   )0;
void alac_set_info(alac_file *alac , char *inputbuffer ) ;
struct __anonstruct_se_struct_24_422959015 se_struct_24  ;
void alac_free(alac_file *alac ) 
{ 


  {
  if (alac->predicterror_buffer_a) {
    free((void *)alac->predicterror_buffer_a);
  }
  if (alac->predicterror_buffer_b) {
    free((void *)alac->predicterror_buffer_b);
  }
  if (alac->outputsamples_buffer_a) {
    free((void *)alac->outputsamples_buffer_a);
  }
  if (alac->outputsamples_buffer_b) {
    free((void *)alac->outputsamples_buffer_b);
  }
  if (alac->uncompressed_bytes_buffer_a) {
    free((void *)alac->uncompressed_bytes_buffer_a);
  }
  if (alac->uncompressed_bytes_buffer_b) {
    free((void *)alac->uncompressed_bytes_buffer_b);
  }
  free((void *)alac);
  return;
}
}
void alac_allocate_buffers(alac_file *alac ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  tmp = malloc((size_t )(alac->setinfo_max_samples_per_frame * 4U));
  alac->predicterror_buffer_a = (int32_t *)tmp;
  tmp___0 = malloc((size_t )(alac->setinfo_max_samples_per_frame * 4U));
  alac->predicterror_buffer_b = (int32_t *)tmp___0;
  tmp___1 = malloc((size_t )(alac->setinfo_max_samples_per_frame * 4U));
  alac->outputsamples_buffer_a = (int32_t *)tmp___1;
  tmp___2 = malloc((size_t )(alac->setinfo_max_samples_per_frame * 4U));
  alac->outputsamples_buffer_b = (int32_t *)tmp___2;
  tmp___3 = malloc((size_t )(alac->setinfo_max_samples_per_frame * 4U));
  alac->uncompressed_bytes_buffer_a = (int32_t *)tmp___3;
  tmp___4 = malloc((size_t )(alac->setinfo_max_samples_per_frame * 4U));
  alac->uncompressed_bytes_buffer_b = (int32_t *)tmp___4;
  return;
}
}
void alac_set_info(alac_file *alac , char *inputbuffer ) 
{ 
  char *ptr ;

  {
  ptr = inputbuffer;
  ptr += 4;
  ptr += 4;
  ptr += 4;
  ptr += 4;
  ptr += 4;
  ptr += 4;
  alac->setinfo_max_samples_per_frame = *((uint32_t *)ptr);
  if (! host_bigendian) {
    while (1) {
      alac->setinfo_max_samples_per_frame = ((((alac->setinfo_max_samples_per_frame & 255U) << 24) | ((alac->setinfo_max_samples_per_frame & 65280U) << 8)) | ((alac->setinfo_max_samples_per_frame & 16711680U) >> 8)) | ((alac->setinfo_max_samples_per_frame & 4278190080U) >> 24);
      break;
    }
  }
  ptr += 4;
  alac->setinfo_7a = *((uint8_t *)ptr);
  ptr ++;
  alac->setinfo_sample_size = *((uint8_t *)ptr);
  ptr ++;
  alac->setinfo_rice_historymult = *((uint8_t *)ptr);
  ptr ++;
  alac->setinfo_rice_initialhistory = *((uint8_t *)ptr);
  ptr ++;
  alac->setinfo_rice_kmodifier = *((uint8_t *)ptr);
  ptr ++;
  alac->setinfo_7f = *((uint8_t *)ptr);
  ptr ++;
  alac->setinfo_80 = *((uint16_t *)ptr);
  if (! host_bigendian) {
    while (1) {
      alac->setinfo_80 = (uint16_t )((((int )alac->setinfo_80 & 255) << 8) | (((int )alac->setinfo_80 & 65280) >> 8));
      break;
    }
  }
  ptr += 2;
  alac->setinfo_82 = *((uint32_t *)ptr);
  if (! host_bigendian) {
    while (1) {
      alac->setinfo_82 = ((((alac->setinfo_82 & 255U) << 24) | ((alac->setinfo_82 & 65280U) << 8)) | ((alac->setinfo_82 & 16711680U) >> 8)) | ((alac->setinfo_82 & 4278190080U) >> 24);
      break;
    }
  }
  ptr += 4;
  alac->setinfo_86 = *((uint32_t *)ptr);
  if (! host_bigendian) {
    while (1) {
      alac->setinfo_86 = ((((alac->setinfo_86 & 255U) << 24) | ((alac->setinfo_86 & 65280U) << 8)) | ((alac->setinfo_86 & 16711680U) >> 8)) | ((alac->setinfo_86 & 4278190080U) >> 24);
      break;
    }
  }
  ptr += 4;
  alac->setinfo_8a_rate = *((uint32_t *)ptr);
  if (! host_bigendian) {
    while (1) {
      alac->setinfo_8a_rate = ((((alac->setinfo_8a_rate & 255U) << 24) | ((alac->setinfo_8a_rate & 65280U) << 8)) | ((alac->setinfo_8a_rate & 16711680U) >> 8)) | ((alac->setinfo_8a_rate & 4278190080U) >> 24);
      break;
    }
  }
  alac_allocate_buffers(alac);
  return;
}
}
static uint32_t readbits_16(alac_file *alac , int bits ) 
{ 
  uint32_t result ;
  int new_accumulator ;

  {
  result = (uint32_t )((((int )*(alac->input_buffer + 0) << 16) | ((int )*(alac->input_buffer + 1) << 8)) | (int )*(alac->input_buffer + 2));
  result <<= alac->input_buffer_bitaccumulator;
  result &= 16777215U;
  result >>= 24 - bits;
  new_accumulator = alac->input_buffer_bitaccumulator + bits;
  alac->input_buffer += new_accumulator >> 3;
  alac->input_buffer_bitaccumulator = new_accumulator & 7;
  return (result);
}
}
static uint32_t readbits(alac_file *alac , int bits ) 
{ 
  int32_t result ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  result = 0;
  if (bits > 16) {
    bits -= 16;
    tmp = readbits_16(alac, 16);
    result = (int32_t )(tmp << bits);
  }
  tmp___0 = readbits_16(alac, bits);
  result = (int32_t )((unsigned int )result | tmp___0);
  return ((uint32_t )result);
}
}
static int readbit(alac_file *alac ) 
{ 
  int result ;
  int new_accumulator ;

  {
  result = (int )*(alac->input_buffer + 0);
  result <<= alac->input_buffer_bitaccumulator;
  result = (result >> 7) & 1;
  new_accumulator = alac->input_buffer_bitaccumulator + 1;
  alac->input_buffer += new_accumulator / 8;
  alac->input_buffer_bitaccumulator = new_accumulator % 8;
  return (result);
}
}
static void unreadbits(alac_file *alac , int bits ) 
{ 
  int new_accumulator ;

  {
  new_accumulator = alac->input_buffer_bitaccumulator - bits;
  alac->input_buffer += new_accumulator >> 3;
  alac->input_buffer_bitaccumulator = new_accumulator & 7;
  if (alac->input_buffer_bitaccumulator < 0) {
    alac->input_buffer_bitaccumulator *= -1;
  }
  return;
}
}
static int count_leading_zeros(int input ) 
{ 
  int tmp ;

  {
  tmp = __builtin_clz((unsigned int )input);
  return (tmp);
}
}
static int32_t entropy_decode_value(alac_file *alac , int readSampleSize , int k ,
                                    int rice_kmodifier_mask ) 
{ 
  int32_t x ;
  int tmp ;
  int32_t value ;
  uint32_t tmp___0 ;
  int extraBits ;
  uint32_t tmp___1 ;

  {
  x = 0;
  while (1) {
    if (x <= 8) {
      tmp = readbit(alac);
      if (! tmp) {
        break;
      }
    } else {
      break;
    }
    x ++;
  }
  if (x > 8) {
    tmp___0 = readbits(alac, readSampleSize);
    value = (int32_t )tmp___0;
    value = (int32_t )((unsigned int )value & (4294967295U >> (32 - readSampleSize)));
    x = value;
  } else
  if (k != 1) {
    tmp___1 = readbits(alac, k);
    extraBits = (int )tmp___1;
    x *= ((1 << k) - 1) & rice_kmodifier_mask;
    if (extraBits > 1) {
      x += extraBits - 1;
    } else {
      unreadbits(alac, 1);
    }
  }
  return (x);
}
}
static void entropy_rice_decode(alac_file *alac , int32_t *outputBuffer , int outputSize ,
                                int readSampleSize , int rice_initialhistory , int rice_kmodifier ,
                                int rice_historymult , int rice_kmodifier_mask ) 
{ 
  int outputCount ;
  int history ;
  int signModifier ;
  int32_t decodedValue ;
  int32_t finalValue ;
  int32_t k ;
  int tmp ;
  int32_t blockSize ;
  int tmp___0 ;

  {
  history = rice_initialhistory;
  signModifier = 0;
  outputCount = 0;
  while (outputCount < outputSize) {
    tmp = count_leading_zeros((history >> 9) + 3);
    k = (31 - rice_kmodifier) - tmp;
    if (k < 0) {
      k += rice_kmodifier;
    } else {
      k = rice_kmodifier;
    }
    decodedValue = entropy_decode_value(alac, readSampleSize, k, -1);
    decodedValue += signModifier;
    finalValue = (decodedValue + 1) / 2;
    if (decodedValue & 1) {
      finalValue *= -1;
    }
    *(outputBuffer + outputCount) = finalValue;
    signModifier = 0;
    history += decodedValue * rice_historymult - (history * rice_historymult >> 9);
    if (decodedValue > 65535) {
      history = 65535;
    }
    if (history < 128) {
      if (outputCount + 1 < outputSize) {
        signModifier = 1;
        tmp___0 = count_leading_zeros(history);
        k = (tmp___0 + (history + 16) / 64) - 24;
        blockSize = entropy_decode_value(alac, 16, k, rice_kmodifier_mask);
        if (blockSize > 0) {
          memset((void *)(outputBuffer + (outputCount + 1)), 0, (unsigned long )blockSize * sizeof(*outputBuffer));
          outputCount += blockSize;
        }
        if (blockSize > 65535) {
          signModifier = 0;
        }
        history = 0;
      }
    }
    outputCount ++;
  }
  return;
}
}
static void predictor_decompress_fir_adapt(int32_t *error_buffer , int32_t *buffer_out ,
                                           int output_size , int readsamplesize ,
                                           int16_t *predictor_coef_table , int predictor_coef_num ,
                                           int predictor_quantitization ) 
{ 
  int i ;
  int32_t prev_value ;
  int32_t error_value ;
  int i___0 ;
  int32_t val ;
  int j ;
  int sum ;
  int outval ;
  int error_val ;
  int predictor_num ;
  int val___0 ;
  int sign ;
  int tmp ;
  int tmp___0 ;
  int predictor_num___0 ;
  int val___1 ;
  int sign___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  *buffer_out = *error_buffer;
  if (! predictor_coef_num) {
    if (output_size <= 1) {
      return;
    }
    memcpy((void * __restrict  )(buffer_out + 1), (void const   * __restrict  )(error_buffer + 1),
           (size_t )((output_size - 1) * 4));
    return;
  }
  if (predictor_coef_num == 31) {
    if (output_size <= 1) {
      return;
    }
    i = 0;
    while (i < output_size - 1) {
      prev_value = *(buffer_out + i);
      error_value = *(error_buffer + (i + 1));
      *(buffer_out + (i + 1)) = ((prev_value + error_value) << (32 - readsamplesize)) >> (32 - readsamplesize);
      i ++;
    }
    return;
  }
  if (predictor_coef_num > 0) {
    i___0 = 0;
    while (i___0 < predictor_coef_num) {
      val = *(buffer_out + i___0) + *(error_buffer + (i___0 + 1));
      val = (val << (32 - readsamplesize)) >> (32 - readsamplesize);
      *(buffer_out + (i___0 + 1)) = val;
      i___0 ++;
    }
  }
  if (predictor_coef_num > 0) {
    i = predictor_coef_num + 1;
    while (i < output_size) {
      sum = 0;
      error_val = *(error_buffer + i);
      j = 0;
      while (j < predictor_coef_num) {
        sum += (*(buffer_out + (predictor_coef_num - j)) - *(buffer_out + 0)) * (int32_t )*(predictor_coef_table + j);
        j ++;
      }
      outval = (1 << (predictor_quantitization - 1)) + sum;
      outval >>= predictor_quantitization;
      outval = (outval + *(buffer_out + 0)) + error_val;
      outval = (outval << (32 - readsamplesize)) >> (32 - readsamplesize);
      *(buffer_out + (predictor_coef_num + 1)) = outval;
      if (error_val > 0) {
        predictor_num = predictor_coef_num - 1;
        while (1) {
          if (predictor_num >= 0) {
            if (! (error_val > 0)) {
              break;
            }
          } else {
            break;
          }
          val___0 = *(buffer_out + 0) - *(buffer_out + (predictor_coef_num - predictor_num));
          if (val___0 < 0) {
            tmp___0 = -1;
          } else {
            if (val___0 > 0) {
              tmp = 1;
            } else {
              tmp = 0;
            }
            tmp___0 = tmp;
          }
          sign = tmp___0;
          *(predictor_coef_table + predictor_num) = (int16_t )((int )*(predictor_coef_table + predictor_num) - sign);
          val___0 *= sign;
          error_val -= (val___0 >> predictor_quantitization) * (predictor_coef_num - predictor_num);
          predictor_num --;
        }
      } else
      if (error_val < 0) {
        predictor_num___0 = predictor_coef_num - 1;
        while (1) {
          if (predictor_num___0 >= 0) {
            if (! (error_val < 0)) {
              break;
            }
          } else {
            break;
          }
          val___1 = *(buffer_out + 0) - *(buffer_out + (predictor_coef_num - predictor_num___0));
          if (val___1 < 0) {
            tmp___2 = -1;
          } else {
            if (val___1 > 0) {
              tmp___1 = 1;
            } else {
              tmp___1 = 0;
            }
            tmp___2 = tmp___1;
          }
          sign___0 = - tmp___2;
          *(predictor_coef_table + predictor_num___0) = (int16_t )((int )*(predictor_coef_table + predictor_num___0) - sign___0);
          val___1 *= sign___0;
          error_val -= (val___1 >> predictor_quantitization) * (predictor_coef_num - predictor_num___0);
          predictor_num___0 --;
        }
      }
      buffer_out ++;
      i ++;
    }
  }
  return;
}
}
static void deinterlace_16(int32_t *buffer_a , int32_t *buffer_b , int16_t *buffer_out ,
                           int numchannels , int numsamples , uint8_t interlacing_shift ,
                           uint8_t interlacing_leftweight ) 
{ 
  int i ;
  int32_t difference ;
  int32_t midright ;
  int16_t left ;
  int16_t right ;
  int16_t left___0 ;
  int16_t right___0 ;

  {
  if (numsamples <= 0) {
    return;
  }
  if (interlacing_leftweight) {
    i = 0;
    while (i < numsamples) {
      midright = *(buffer_a + i);
      difference = *(buffer_b + i);
      right = (int16_t )(midright - (difference * (int32_t )interlacing_leftweight >> (int )interlacing_shift));
      left = (int16_t )((int )right + difference);
      if (host_bigendian) {
        while (1) {
          left = (int16_t )((((int )left & 255) << 8) | (((int )left & 65280) >> 8));
          break;
        }
        while (1) {
          right = (int16_t )((((int )right & 255) << 8) | (((int )right & 65280) >> 8));
          break;
        }
      }
      *(buffer_out + i * numchannels) = left;
      *(buffer_out + (i * numchannels + 1)) = right;
      i ++;
    }
    return;
  }
  i = 0;
  while (i < numsamples) {
    left___0 = (int16_t )*(buffer_a + i);
    right___0 = (int16_t )*(buffer_b + i);
    if (host_bigendian) {
      while (1) {
        left___0 = (int16_t )((((int )left___0 & 255) << 8) | (((int )left___0 & 65280) >> 8));
        break;
      }
      while (1) {
        right___0 = (int16_t )((((int )right___0 & 255) << 8) | (((int )right___0 & 65280) >> 8));
        break;
      }
    }
    *(buffer_out + i * numchannels) = left___0;
    *(buffer_out + (i * numchannels + 1)) = right___0;
    i ++;
  }
  return;
}
}
static void deinterlace_24(int32_t *buffer_a , int32_t *buffer_b , int uncompressed_bytes ,
                           int32_t *uncompressed_bytes_buffer_a , int32_t *uncompressed_bytes_buffer_b ,
                           void *buffer_out , int numchannels , int numsamples , uint8_t interlacing_shift ,
                           uint8_t interlacing_leftweight ) 
{ 
  int i ;
  int32_t difference ;
  int32_t midright ;
  int32_t left ;
  int32_t right ;
  uint32_t mask ;
  int32_t left___0 ;
  int32_t right___0 ;
  uint32_t mask___0 ;

  {
  if (numsamples <= 0) {
    return;
  }
  if (interlacing_leftweight) {
    i = 0;
    while (i < numsamples) {
      midright = *(buffer_a + i);
      difference = *(buffer_b + i);
      right = midright - (difference * (int32_t )interlacing_leftweight >> (int )interlacing_shift);
      left = right + difference;
      if (uncompressed_bytes) {
        mask = ~ (4294967295U << uncompressed_bytes * 8);
        left <<= uncompressed_bytes * 8;
        right <<= uncompressed_bytes * 8;
        left = (int32_t )((unsigned int )left | ((unsigned int )*(uncompressed_bytes_buffer_a + i) & mask));
        right = (int32_t )((unsigned int )right | ((unsigned int )*(uncompressed_bytes_buffer_b + i) & mask));
      }
      *((uint8_t *)buffer_out + (i * numchannels) * 3) = (uint8_t )(left & 255);
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 1)) = (uint8_t )((left >> 8) & 255);
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 2)) = (uint8_t )((left >> 16) & 255);
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 3)) = (uint8_t )(right & 255);
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 4)) = (uint8_t )((right >> 8) & 255);
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 5)) = (uint8_t )((right >> 16) & 255);
      i ++;
    }
    return;
  }
  i = 0;
  while (i < numsamples) {
    left___0 = *(buffer_a + i);
    right___0 = *(buffer_b + i);
    if (uncompressed_bytes) {
      mask___0 = ~ (4294967295U << uncompressed_bytes * 8);
      left___0 <<= uncompressed_bytes * 8;
      right___0 <<= uncompressed_bytes * 8;
      left___0 = (int32_t )((unsigned int )left___0 | ((unsigned int )*(uncompressed_bytes_buffer_a + i) & mask___0));
      right___0 = (int32_t )((unsigned int )right___0 | ((unsigned int )*(uncompressed_bytes_buffer_b + i) & mask___0));
    }
    *((uint8_t *)buffer_out + (i * numchannels) * 3) = (uint8_t )(left___0 & 255);
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 1)) = (uint8_t )((left___0 >> 8) & 255);
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 2)) = (uint8_t )((left___0 >> 16) & 255);
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 3)) = (uint8_t )(right___0 & 255);
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 4)) = (uint8_t )((right___0 >> 8) & 255);
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 5)) = (uint8_t )((right___0 >> 16) & 255);
    i ++;
  }
  return;
}
}
void alac_decode_frame(alac_file *alac , unsigned char *inbuffer , void *outbuffer ,
                       int *outputsize ) 
{ 
  int channels ;
  int32_t outputsamples ;
  uint32_t tmp ;
  int hassize ;
  int isnotcompressed ;
  int readsamplesize ;
  int uncompressed_bytes ;
  int ricemodifier ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  int16_t predictor_coef_table[32] ;
  int predictor_coef_num ;
  int prediction_type ;
  int prediction_quantitization ;
  int i ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  int i___0 ;
  uint32_t tmp___9 ;
  int i___1 ;
  int32_t audiobits ;
  uint32_t tmp___10 ;
  int i___2 ;
  int32_t audiobits___0 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  int i___3 ;
  int16_t sample ;
  int i___4 ;
  int32_t sample___0 ;
  uint32_t mask ;
  int hassize___0 ;
  int isnotcompressed___0 ;
  int readsamplesize___0 ;
  int uncompressed_bytes___0 ;
  uint8_t interlacing_shift ;
  uint8_t interlacing_leftweight ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  int16_t predictor_coef_table_a[32] ;
  int predictor_coef_num_a ;
  int prediction_type_a ;
  int prediction_quantitization_a ;
  int ricemodifier_a ;
  int16_t predictor_coef_table_b[32] ;
  int predictor_coef_num_b ;
  int prediction_type_b ;
  int prediction_quantitization_b ;
  int ricemodifier_b ;
  int i___5 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t tmp___27 ;
  uint32_t tmp___28 ;
  int i___6 ;
  uint32_t tmp___29 ;
  uint32_t tmp___30 ;
  int i___7 ;
  int32_t audiobits_a ;
  int32_t audiobits_b ;
  uint32_t tmp___31 ;
  uint32_t tmp___32 ;
  int i___8 ;
  int32_t audiobits_a___0 ;
  int32_t audiobits_b___0 ;
  uint32_t tmp___33 ;
  uint32_t tmp___34 ;
  uint32_t tmp___35 ;
  uint32_t tmp___36 ;

  {
  outputsamples = (int32_t )alac->setinfo_max_samples_per_frame;
  alac->input_buffer = inbuffer;
  alac->input_buffer_bitaccumulator = 0;
  tmp = readbits(alac, 3);
  channels = (int )tmp;
  *outputsize = outputsamples * alac->bytespersample;
  switch (channels) {
  case 0: 
  readbits(alac, 4);
  readbits(alac, 12);
  tmp___0 = readbits(alac, 1);
  hassize = (int )tmp___0;
  tmp___1 = readbits(alac, 2);
  uncompressed_bytes = (int )tmp___1;
  tmp___2 = readbits(alac, 1);
  isnotcompressed = (int )tmp___2;
  if (hassize) {
    tmp___3 = readbits(alac, 32);
    outputsamples = (int32_t )tmp___3;
    *outputsize = outputsamples * alac->bytespersample;
  }
  readsamplesize = (int )alac->setinfo_sample_size - uncompressed_bytes * 8;
  if (! isnotcompressed) {
    readbits(alac, 8);
    readbits(alac, 8);
    tmp___4 = readbits(alac, 4);
    prediction_type = (int )tmp___4;
    tmp___5 = readbits(alac, 4);
    prediction_quantitization = (int )tmp___5;
    tmp___6 = readbits(alac, 3);
    ricemodifier = (int )tmp___6;
    tmp___7 = readbits(alac, 5);
    predictor_coef_num = (int )tmp___7;
    i = 0;
    while (i < predictor_coef_num) {
      tmp___8 = readbits(alac, 16);
      predictor_coef_table[i] = (int16_t )tmp___8;
      i ++;
    }
    if (uncompressed_bytes) {
      i___0 = 0;
      while (i___0 < outputsamples) {
        tmp___9 = readbits(alac, uncompressed_bytes * 8);
        *(alac->uncompressed_bytes_buffer_a + i___0) = (int32_t )tmp___9;
        i___0 ++;
      }
    }
    entropy_rice_decode(alac, alac->predicterror_buffer_a, outputsamples, readsamplesize,
                        (int )alac->setinfo_rice_initialhistory, (int )alac->setinfo_rice_kmodifier,
                        (ricemodifier * (int )alac->setinfo_rice_historymult) / 4,
                        (1 << (int )alac->setinfo_rice_kmodifier) - 1);
    if (prediction_type == 0) {
      predictor_decompress_fir_adapt(alac->predicterror_buffer_a, alac->outputsamples_buffer_a,
                                     outputsamples, readsamplesize, predictor_coef_table,
                                     predictor_coef_num, prediction_quantitization);
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"FIXME: unhandled predicition type: %i\n",
              prediction_type);
    }
  } else {
    if ((int )alac->setinfo_sample_size <= 16) {
      i___1 = 0;
      while (i___1 < outputsamples) {
        tmp___10 = readbits(alac, (int )alac->setinfo_sample_size);
        audiobits = (int32_t )tmp___10;
        audiobits = (audiobits << (32 - (int )alac->setinfo_sample_size)) >> (32 - (int )alac->setinfo_sample_size);
        *(alac->outputsamples_buffer_a + i___1) = audiobits;
        i___1 ++;
      }
    } else {
      i___2 = 0;
      while (i___2 < outputsamples) {
        tmp___11 = readbits(alac, 16);
        audiobits___0 = (int32_t )tmp___11;
        audiobits___0 <<= (int )alac->setinfo_sample_size - 16;
        tmp___12 = readbits(alac, (int )alac->setinfo_sample_size - 16);
        audiobits___0 = (int32_t )((unsigned int )audiobits___0 | tmp___12);
        se_struct_24.x = audiobits___0;
        audiobits___0 = se_struct_24.x;
        *(alac->outputsamples_buffer_a + i___2) = audiobits___0;
        i___2 ++;
      }
    }
    uncompressed_bytes = 0;
  }
  switch ((int )alac->setinfo_sample_size) {
  case 16: 
  i___3 = 0;
  while (i___3 < outputsamples) {
    sample = (int16_t )*(alac->outputsamples_buffer_a + i___3);
    if (host_bigendian) {
      while (1) {
        sample = (int16_t )((((int )sample & 255) << 8) | (((int )sample & 65280) >> 8));
        break;
      }
    }
    *((int16_t *)outbuffer + i___3 * alac->numchannels) = sample;
    i___3 ++;
  }
  break;
  case 24: 
  i___4 = 0;
  while (i___4 < outputsamples) {
    sample___0 = *(alac->outputsamples_buffer_a + i___4);
    if (uncompressed_bytes) {
      sample___0 <<= uncompressed_bytes * 8;
      mask = ~ (4294967295U << uncompressed_bytes * 8);
      sample___0 = (int32_t )((unsigned int )sample___0 | ((unsigned int )*(alac->uncompressed_bytes_buffer_a + i___4) & mask));
    }
    *((uint8_t *)outbuffer + (i___4 * alac->numchannels) * 3) = (uint8_t )(sample___0 & 255);
    *((uint8_t *)outbuffer + ((i___4 * alac->numchannels) * 3 + 1)) = (uint8_t )((sample___0 >> 8) & 255);
    *((uint8_t *)outbuffer + ((i___4 * alac->numchannels) * 3 + 2)) = (uint8_t )((sample___0 >> 16) & 255);
    i___4 ++;
  }
  break;
  case 32: 
  case 20: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"FIXME: unimplemented sample size %i\n",
          (int )alac->setinfo_sample_size);
  break;
  default: 
  break;
  }
  break;
  case 1: 
  readbits(alac, 4);
  readbits(alac, 12);
  tmp___13 = readbits(alac, 1);
  hassize___0 = (int )tmp___13;
  tmp___14 = readbits(alac, 2);
  uncompressed_bytes___0 = (int )tmp___14;
  tmp___15 = readbits(alac, 1);
  isnotcompressed___0 = (int )tmp___15;
  if (hassize___0) {
    tmp___16 = readbits(alac, 32);
    outputsamples = (int32_t )tmp___16;
    *outputsize = outputsamples * alac->bytespersample;
  }
  readsamplesize___0 = ((int )alac->setinfo_sample_size - uncompressed_bytes___0 * 8) + 1;
  if (! isnotcompressed___0) {
    tmp___17 = readbits(alac, 8);
    interlacing_shift = (uint8_t )tmp___17;
    tmp___18 = readbits(alac, 8);
    interlacing_leftweight = (uint8_t )tmp___18;
    tmp___19 = readbits(alac, 4);
    prediction_type_a = (int )tmp___19;
    tmp___20 = readbits(alac, 4);
    prediction_quantitization_a = (int )tmp___20;
    tmp___21 = readbits(alac, 3);
    ricemodifier_a = (int )tmp___21;
    tmp___22 = readbits(alac, 5);
    predictor_coef_num_a = (int )tmp___22;
    i___5 = 0;
    while (i___5 < predictor_coef_num_a) {
      tmp___23 = readbits(alac, 16);
      predictor_coef_table_a[i___5] = (int16_t )tmp___23;
      i___5 ++;
    }
    tmp___24 = readbits(alac, 4);
    prediction_type_b = (int )tmp___24;
    tmp___25 = readbits(alac, 4);
    prediction_quantitization_b = (int )tmp___25;
    tmp___26 = readbits(alac, 3);
    ricemodifier_b = (int )tmp___26;
    tmp___27 = readbits(alac, 5);
    predictor_coef_num_b = (int )tmp___27;
    i___5 = 0;
    while (i___5 < predictor_coef_num_b) {
      tmp___28 = readbits(alac, 16);
      predictor_coef_table_b[i___5] = (int16_t )tmp___28;
      i___5 ++;
    }
    if (uncompressed_bytes___0) {
      i___6 = 0;
      while (i___6 < outputsamples) {
        tmp___29 = readbits(alac, uncompressed_bytes___0 * 8);
        *(alac->uncompressed_bytes_buffer_a + i___6) = (int32_t )tmp___29;
        tmp___30 = readbits(alac, uncompressed_bytes___0 * 8);
        *(alac->uncompressed_bytes_buffer_b + i___6) = (int32_t )tmp___30;
        i___6 ++;
      }
    }
    entropy_rice_decode(alac, alac->predicterror_buffer_a, outputsamples, readsamplesize___0,
                        (int )alac->setinfo_rice_initialhistory, (int )alac->setinfo_rice_kmodifier,
                        (ricemodifier_a * (int )alac->setinfo_rice_historymult) / 4,
                        (1 << (int )alac->setinfo_rice_kmodifier) - 1);
    if (prediction_type_a == 0) {
      predictor_decompress_fir_adapt(alac->predicterror_buffer_a, alac->outputsamples_buffer_a,
                                     outputsamples, readsamplesize___0, predictor_coef_table_a,
                                     predictor_coef_num_a, prediction_quantitization_a);
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"FIXME: unhandled predicition type: %i\n",
              prediction_type_a);
    }
    entropy_rice_decode(alac, alac->predicterror_buffer_b, outputsamples, readsamplesize___0,
                        (int )alac->setinfo_rice_initialhistory, (int )alac->setinfo_rice_kmodifier,
                        (ricemodifier_b * (int )alac->setinfo_rice_historymult) / 4,
                        (1 << (int )alac->setinfo_rice_kmodifier) - 1);
    if (prediction_type_b == 0) {
      predictor_decompress_fir_adapt(alac->predicterror_buffer_b, alac->outputsamples_buffer_b,
                                     outputsamples, readsamplesize___0, predictor_coef_table_b,
                                     predictor_coef_num_b, prediction_quantitization_b);
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"FIXME: unhandled predicition type: %i\n",
              prediction_type_b);
    }
  } else {
    if ((int )alac->setinfo_sample_size <= 16) {
      i___7 = 0;
      while (i___7 < outputsamples) {
        tmp___31 = readbits(alac, (int )alac->setinfo_sample_size);
        audiobits_a = (int32_t )tmp___31;
        tmp___32 = readbits(alac, (int )alac->setinfo_sample_size);
        audiobits_b = (int32_t )tmp___32;
        audiobits_a = (audiobits_a << (32 - (int )alac->setinfo_sample_size)) >> (32 - (int )alac->setinfo_sample_size);
        audiobits_b = (audiobits_b << (32 - (int )alac->setinfo_sample_size)) >> (32 - (int )alac->setinfo_sample_size);
        *(alac->outputsamples_buffer_a + i___7) = audiobits_a;
        *(alac->outputsamples_buffer_b + i___7) = audiobits_b;
        i___7 ++;
      }
    } else {
      i___8 = 0;
      while (i___8 < outputsamples) {
        tmp___33 = readbits(alac, 16);
        audiobits_a___0 = (int32_t )tmp___33;
        audiobits_a___0 <<= (int )alac->setinfo_sample_size - 16;
        tmp___34 = readbits(alac, (int )alac->setinfo_sample_size - 16);
        audiobits_a___0 = (int32_t )((unsigned int )audiobits_a___0 | tmp___34);
        se_struct_24.x = audiobits_a___0;
        audiobits_a___0 = se_struct_24.x;
        tmp___35 = readbits(alac, 16);
        audiobits_b___0 = (int32_t )tmp___35;
        audiobits_b___0 <<= (int )alac->setinfo_sample_size - 16;
        tmp___36 = readbits(alac, (int )alac->setinfo_sample_size - 16);
        audiobits_b___0 = (int32_t )((unsigned int )audiobits_b___0 | tmp___36);
        se_struct_24.x = audiobits_b___0;
        audiobits_b___0 = se_struct_24.x;
        *(alac->outputsamples_buffer_a + i___8) = audiobits_a___0;
        *(alac->outputsamples_buffer_b + i___8) = audiobits_b___0;
        i___8 ++;
      }
    }
    uncompressed_bytes___0 = 0;
    interlacing_shift = (uint8_t )0;
    interlacing_leftweight = (uint8_t )0;
  }
  switch ((int )alac->setinfo_sample_size) {
  case 16: 
  deinterlace_16(alac->outputsamples_buffer_a, alac->outputsamples_buffer_b, (int16_t *)outbuffer,
                 alac->numchannels, outputsamples, interlacing_shift, interlacing_leftweight);
  break;
  case 24: 
  deinterlace_24(alac->outputsamples_buffer_a, alac->outputsamples_buffer_b, uncompressed_bytes___0,
                 alac->uncompressed_bytes_buffer_a, alac->uncompressed_bytes_buffer_b,
                 (void *)((int16_t *)outbuffer), alac->numchannels, outputsamples,
                 interlacing_shift, interlacing_leftweight);
  break;
  case 32: 
  case 20: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"FIXME: unimplemented sample size %i\n",
          (int )alac->setinfo_sample_size);
  break;
  default: 
  break;
  }
  break;
  }
  return;
}
}
alac_file *alac_create(int samplesize , int numchannels ) 
{ 
  alac_file *newfile ;
  void *tmp ;

  {
  tmp = malloc(sizeof(alac_file ));
  newfile = (alac_file *)tmp;
  memset((void *)newfile, 0, sizeof(alac_file ));
  newfile->samplesize = samplesize;
  newfile->numchannels = numchannels;
  newfile->bytespersample = (samplesize / 8) * numchannels;
  return (newfile);
}
}
#pragma merger("0","/tmp/cil-ICO2weIv.i","-O2,-Wall")
audio_output audio_ao ;
audio_output audio_pulse ;
audio_output audio_alsa ;
audio_output audio_dummy ;
audio_output audio_pipe ;
static audio_output *outputs[6]  = {      & audio_alsa,      & audio_pulse,      & audio_ao,      & audio_dummy, 
        & audio_pipe,      (audio_output *)((void *)0)};
audio_output *audio_get_output(char *name ) 
{ 
  audio_output **out ;
  int tmp ;

  {
  if (! name) {
    return (outputs[0]);
  }
  out = outputs;
  while (*out) {
    tmp = strcasecmp((char const   *)name, (char const   *)(*out)->name);
    if (! tmp) {
      return (*out);
    }
    out ++;
  }
  return ((audio_output *)((void *)0));
}
}
void audio_ls_outputs(void) 
{ 
  audio_output **out ;
  char const   *tmp ;

  {
  printf((char const   * __restrict  )"Available audio outputs:\n");
  out = outputs;
  while (*out) {
    if ((unsigned long )out == (unsigned long )(outputs)) {
      tmp = " (default)";
    } else {
      tmp = "";
    }
    printf((char const   * __restrict  )"    %s%s\n", (*out)->name, tmp);
    out ++;
  }
  out = outputs;
  while (*out) {
    printf((char const   * __restrict  )"\n");
    printf((char const   * __restrict  )"Options for output %s:\n", (*out)->name);
    (*((*out)->help))();
    out ++;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-cWoHqjJw.i","-O2,-Wall")
extern int usleep(__useconds_t __useconds ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
int Fs  ;
long long starttime  ;
long long samples_played  ;
static int init(int argc , char **argv ) 
{ 


  {
  return (0);
}
}
static void deinit(void) 
{ 


  {
  return;
}
}
static void start(int sample_rate ) 
{ 


  {
  Fs = sample_rate;
  starttime = 0LL;
  samples_played = 0LL;
  printf((char const   * __restrict  )"dummy audio output started at Fs=%d Hz\n",
         sample_rate);
  return;
}
}
static void play(short *buf , int samples ) 
{ 
  struct timeval tv ;
  long long nowtime ;
  long long finishtime ;

  {
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  nowtime = (long long )((double )tv.tv_usec + 1e6 * (double )tv.tv_sec);
  if (! starttime) {
    starttime = nowtime;
  }
  samples_played += (long long )samples;
  finishtime = (long long )((double )starttime + ((double )samples_played * 1e6) / (double )Fs);
  usleep((__useconds_t )(finishtime - nowtime));
  return;
}
}
static void stop(void) 
{ 


  {
  printf((char const   * __restrict  )"dummy audio stopped\n");
  return;
}
}
static void help(void) 
{ 


  {
  printf((char const   * __restrict  )"    There are no options for dummy audio.\n");
  return;
}
}
audio_output audio_dummy  = 
     {& help, (char *)"dummy", & init, & deinit, & start, & play, & stop, (void (*)(double vol ))((void *)0)};
#pragma merger("0","/tmp/cil-akbBheO8.i","-O2,-Wall")
static int fd___0  =    -1;
static char *pipename  =    (char *)((void *)0);
static int Fs___0  ;
static long long starttime___0  ;
static long long samples_played___0  ;
static void stop___0(void) 
{ 


  {
  close(fd___0);
  fd___0 = -1;
  return;
}
}
static void start___0(int sample_rate ) 
{ 
  int *tmp ;

  {
  if (fd___0 >= 0) {
    stop___0();
  }
  fd___0 = open((char const   *)pipename, 2049);
  if (fd___0 < 0) {
    tmp = __errno_location();
    if (*tmp != 6) {
      perror("open");
      die((char *)"could not open specified pipe for writing");
    }
  }
  if (fd___0 >= 0) {
    close(fd___0);
    fd___0 = open((char const   *)pipename, 1);
  }
  Fs___0 = sample_rate;
  starttime___0 = 0LL;
  samples_played___0 = 0LL;
  return;
}
}
static void wait_samples(int samples ) 
{ 
  struct timeval tv ;
  long long nowtime ;
  long long finishtime ;

  {
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  nowtime = (long long )((double )tv.tv_usec + 1e6 * (double )tv.tv_sec);
  if (! starttime___0) {
    starttime___0 = nowtime;
  }
  samples_played___0 += (long long )samples;
  finishtime = (long long )((double )starttime___0 + ((double )samples_played___0 * 1e6) / (double )Fs___0);
  usleep((__useconds_t )(finishtime - nowtime));
  return;
}
}
static void play___0(short *buf , int samples ) 
{ 
  ssize_t tmp ;

  {
  if (fd___0 < 0) {
    wait_samples(samples);
    if (samples_played___0 > (long long )(5 * Fs___0)) {
      start___0(Fs___0);
    }
    return;
  }
  tmp = write(fd___0, (void const   *)buf, (size_t )(samples * 4));
  if (tmp < 0L) {
    stop___0();
  }
  return;
}
}
static int init___0(int argc , char **argv ) 
{ 
  struct stat sb ;
  int tmp ;

  {
  if (argc != 1) {
    die((char *)"bad argument(s) to pipe");
  }
  pipename = strdup((char const   *)*(argv + 0));
  tmp = stat((char const   * __restrict  )pipename, (struct stat * __restrict  )(& sb));
  if (tmp < 0) {
    die((char *)"could not stat() pipe");
  }
  if (! ((sb.st_mode & 61440U) == 4096U)) {
    die((char *)"not a pipe");
  }
  return (0);
}
}
static void deinit___0(void) 
{ 


  {
  if (fd___0 >= 0) {
    stop___0();
  }
  if (pipename) {
    free((void *)pipename);
  }
  return;
}
}
static void help___0(void) 
{ 


  {
  printf((char const   * __restrict  )"    pipe takes 1 argument: the name of the FIFO to write to.\n");
  return;
}
}
audio_output audio_pipe  = 
     {& help___0, (char *)"pipe", & init___0, & deinit___0, & start___0, & play___0,
    & stop___0, (void (*)(double vol ))((void *)0)};
#pragma merger("0","/tmp/cil-4QmKyYQa.i","-O2,-Wall")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
struct mdns_pkt *mdns_parse_pkt(uint8_t *pkt_buf , size_t pkt_len ) ;
void mdns_init_reply(struct mdns_pkt *pkt , uint16_t id ) ;
size_t mdns_encode_pkt(struct mdns_pkt *answer , uint8_t *pkt_buf , size_t pkt_len ) ;
void mdns_pkt_destroy(struct mdns_pkt *p ) ;
void rr_group_destroy(struct rr_group *group ) ;
struct rr_group *rr_group_find(struct rr_group *g , uint8_t *name ) ;
struct rr_entry *rr_entry_find(struct rr_list *rr_list , uint8_t *name , uint16_t type ) ;
struct rr_entry *rr_entry_match(struct rr_list *rr_list , struct rr_entry *entry ) ;
void rr_group_add(struct rr_group **group , struct rr_entry *rr ) ;
int rr_list_count(struct rr_list *rr ) ;
int rr_list_append(struct rr_list **rr_head , struct rr_entry *rr ) ;
struct rr_entry *rr_list_remove(struct rr_list **rr_head , struct rr_entry *rr ) ;
void rr_list_destroy(struct rr_list *rr , char destroy_items ) ;
struct rr_entry *rr_create_ptr(uint8_t *name , struct rr_entry *d_rr ) ;
struct rr_entry *rr_create_srv(uint8_t *name , uint16_t port , uint8_t *target ) ;
struct rr_entry *rr_create(uint8_t *name , enum rr_type type ) ;
void rr_set_nsec(struct rr_entry *rr_nsec , enum rr_type type ) ;
void rr_add_txt(struct rr_entry *rr_txt , char const   *txt ) ;
char const   *rr_get_type_name(enum rr_type type ) ;
uint8_t *create_label(char const   *txt ) ;
char *nlabel_to_str(uint8_t const   *name ) ;
uint8_t *dup_label(uint8_t const   *label ) ;
__inline uint8_t *dup_nlabel(uint8_t const   *n ) ;
uint8_t *join_nlabel(uint8_t const   *n1 , uint8_t const   *n2 ) ;
__inline static int cmp_nlabel(uint8_t const   *L1 , uint8_t const   *L2 ) 
{ 
  int tmp ;

  {
  tmp = strcmp((char const   *)((char *)L1), (char const   *)((char *)L2));
  return (tmp);
}
}
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_init)(pthread_attr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                                        int __detachstate ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
__inline uint8_t *dup_nlabel(uint8_t const   *n ) 
{ 
  char *tmp___0 ;

  {
  if (! ((int const   )*(n + 0) <= 63)) {
    __assert_fail("n[0] <= 63", "tinysvcmdns.c", 81U, "dup_nlabel");
  }
  tmp___0 = strdup((char const   *)((char *)n));
  return ((uint8_t *)tmp___0);
}
}
uint8_t *dup_label(uint8_t const   *label ) 
{ 
  int len ;
  uint8_t *newlabel ;
  void *tmp ;

  {
  len = (int )((int const   )*label + 1);
  if (len > 63) {
    return ((uint8_t *)((void *)0));
  }
  tmp = malloc((size_t )(len + 1));
  newlabel = (uint8_t *)tmp;
  strncpy((char * __restrict  )((char *)newlabel), (char const   * __restrict  )((char *)label),
          (size_t )len);
  *(newlabel + len) = (uint8_t )'\000';
  return (newlabel);
}
}
uint8_t *join_nlabel(uint8_t const   *n1 , uint8_t const   *n2 ) 
{ 
  int len1 ;
  int len2 ;
  uint8_t *s ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  if ((int const   )*(n1 + 0) <= 63) {
    if (! ((int const   )*(n2 + 0) <= 63)) {
      __assert_fail("n1[0] <= 63 && n2[0] <= 63", "tinysvcmdns.c", 100U, "join_nlabel");
    }
  } else {
    __assert_fail("n1[0] <= 63 && n2[0] <= 63", "tinysvcmdns.c", 100U, "join_nlabel");
  }
  tmp___0 = strlen((char const   *)((char *)n1));
  len1 = (int )tmp___0;
  tmp___1 = strlen((char const   *)((char *)n2));
  len2 = (int )tmp___1;
  tmp___2 = malloc((size_t )((len1 + len2) + 1));
  s = (uint8_t *)tmp___2;
  strncpy((char * __restrict  )((char *)s), (char const   * __restrict  )((char *)n1),
          (size_t )len1);
  strncpy((char * __restrict  )((char *)s + len1), (char const   * __restrict  )((char *)n2),
          (size_t )len2);
  *(s + (len1 + len2)) = (uint8_t )'\000';
  return (s);
}
}
char *nlabel_to_str(uint8_t const   *name ) 
{ 
  char *label ;
  char *labelp ;
  uint8_t const   *p ;
  void *tmp___0 ;

  {
  if (! ((unsigned long )name != (unsigned long )((void *)0))) {
    __assert_fail("name != NULL", "tinysvcmdns.c", 117U, "nlabel_to_str");
  }
  tmp___0 = malloc((size_t )256);
  labelp = (char *)tmp___0;
  label = labelp;
  p = name;
  while (*p) {
    strncpy((char * __restrict  )labelp, (char const   * __restrict  )((char *)p + 1),
            (size_t )*p);
    labelp += (int const   )*p;
    *labelp = (char )'.';
    labelp ++;
    p += (int const   )*p;
    p ++;
  }
  *labelp = (char )'\000';
  return (label);
}
}
static size_t label_len(uint8_t *pkt_buf , size_t pkt_len , size_t off ) 
{ 
  uint8_t *p ;
  uint8_t *e ;
  size_t len ;

  {
  e = pkt_buf + pkt_len;
  len = (size_t )0;
  p = pkt_buf + off;
  while ((unsigned long )p < (unsigned long )e) {
    if ((int )*p == 0) {
      return (len + 1UL);
    } else
    if (((int )*p & 192) == 192) {
      return (len + 2UL);
    } else {
      len += (size_t )((int )*p + 1);
      p += (int )*p;
    }
    p ++;
  }
  return (len);
}
}
uint8_t *create_label(char const   *txt ) 
{ 
  int len ;
  uint8_t *s ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  if (! ((unsigned long )txt != (unsigned long )((void *)0))) {
    __assert_fail("txt != NULL", "tinysvcmdns.c", 163U, "create_label");
  }
  tmp___0 = strlen(txt);
  len = (int )tmp___0;
  if (len > 63) {
    return ((uint8_t *)((void *)0));
  }
  tmp___1 = malloc((size_t )(len + 2));
  s = (uint8_t *)tmp___1;
  *(s + 0) = (uint8_t )len;
  strncpy((char * __restrict  )((char *)s + 1), (char const   * __restrict  )txt,
          (size_t )len);
  *(s + (len + 1)) = (uint8_t )'\000';
  return (s);
}
}
uint8_t *create_nlabel(char const   *name ) 
{ 
  char *label ;
  char *p ;
  char *e ;
  char *lenpos ;
  int len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *dot ;
  void *tmp___2 ;

  {
  len = 0;
  if (! ((unsigned long )name != (unsigned long )((void *)0))) {
    __assert_fail("name != NULL", "tinysvcmdns.c", 183U, "create_nlabel");
  }
  tmp___0 = strlen(name);
  len = (int )tmp___0;
  tmp___1 = malloc((size_t )((len + 1) + 1));
  label = (char *)tmp___1;
  if ((unsigned long )label == (unsigned long )((void *)0)) {
    return ((uint8_t *)((void *)0));
  }
  strncpy((char * __restrict  )(label + 1), (char const   * __restrict  )name, (size_t )len);
  *(label + (len + 1)) = (char )'\000';
  p = label;
  e = p + len;
  lenpos = p;
  while ((unsigned long )p < (unsigned long )e) {
    *lenpos = (char)0;
    tmp___2 = memchr((void const   *)(p + 1), '.', (size_t )((e - p) - 1L));
    dot = (char *)tmp___2;
    if ((unsigned long )dot == (unsigned long )((void *)0)) {
      dot = e + 1;
    }
    *lenpos = (char )((dot - p) - 1L);
    p = dot;
    lenpos = dot;
  }
  return ((uint8_t *)label);
}
}
static uint8_t *copy_label(uint8_t *pkt_buf , size_t pkt_len , size_t off ) 
{ 
  int len ;
  uint8_t *tmp ;

  {
  if (off > pkt_len) {
    return ((uint8_t *)((void *)0));
  }
  len = (int )*(pkt_buf + off) + 1;
  if (off + (size_t )len > pkt_len) {
    debug(1, (char *)"label length exceeds packet buffer\n");
    return ((uint8_t *)((void *)0));
  }
  tmp = dup_label((uint8_t const   *)(pkt_buf + off));
  return (tmp);
}
}
static uint8_t *uncompress_nlabel(uint8_t *pkt_buf , size_t pkt_len , size_t off ) 
{ 
  uint8_t *p ;
  uint8_t *e ;
  size_t len ;
  char *str ;
  char *sp ;
  size_t llen ;
  uint8_t *p2 ;
  void *tmp ;
  size_t llen___0 ;
  uint8_t *p2___0 ;

  {
  e = pkt_buf + pkt_len;
  len = (size_t )0;
  if (off >= pkt_len) {
    return ((uint8_t *)((void *)0));
  }
  p = pkt_buf + off;
  while (1) {
    if (*p) {
      if (! ((unsigned long )p < (unsigned long )e)) {
        break;
      }
    } else {
      break;
    }
    llen = (size_t )0;
    if (((int )*p & 192) == 192) {
      p2 = pkt_buf + ((((int )*(p + 0) & -193) << 8) | (int )*(p + 1));
      llen = (size_t )((int )*p2 + 1);
      p = (p2 + llen) - 1;
    } else {
      llen = (size_t )((int )*p + 1);
      p += llen - 1UL;
    }
    len += llen;
    p ++;
  }
  tmp = malloc(len + 1UL);
  sp = (char *)tmp;
  str = sp;
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    return ((uint8_t *)((void *)0));
  }
  p = pkt_buf + off;
  while (1) {
    if (*p) {
      if (! ((unsigned long )p < (unsigned long )e)) {
        break;
      }
    } else {
      break;
    }
    llen___0 = (size_t )0;
    if (((int )*p & 192) == 192) {
      p2___0 = pkt_buf + ((((int )*(p + 0) & -193) << 8) | (int )*(p + 1));
      llen___0 = (size_t )((int )*p2___0 + 1);
      strncpy((char * __restrict  )sp, (char const   * __restrict  )((char *)p2___0),
              llen___0);
      p = (p2___0 + llen___0) - 1;
    } else {
      llen___0 = (size_t )((int )*p + 1);
      strncpy((char * __restrict  )sp, (char const   * __restrict  )((char *)p), llen___0);
      p += llen___0 - 1UL;
    }
    sp += llen___0;
    p ++;
  }
  *sp = (char )'\000';
  return ((uint8_t *)str);
}
}
char const   *rr_get_type_name(enum rr_type type ) 
{ 


  {
  switch ((unsigned int )type) {
  case 1U: 
  return ("A");
  case 12U: 
  return ("PTR");
  case 16U: 
  return ("TXT");
  case 28U: 
  return ("AAAA");
  case 33U: 
  return ("SRV");
  case 47U: 
  return ("NSEC");
  case 255U: 
  return ("ANY");
  }
  return ((char const   *)((void *)0));
}
}
void rr_entry_destroy(struct rr_entry *rr ) 
{ 
  struct rr_data_txt *txt_rec ;
  struct rr_data_txt *next ;

  {
  if (! rr) {
    __assert_fail("rr", "tinysvcmdns.c", 293U, "rr_entry_destroy");
  }
  switch ((unsigned int )rr->type) {
  case 12U: 
  if (rr->data.PTR.name) {
    free((void *)rr->data.PTR.name);
  }
  break;
  case 16U: 
  txt_rec = & rr->data.TXT;
  while (txt_rec) {
    next = txt_rec->next;
    if (txt_rec->txt) {
      free((void *)txt_rec->txt);
    }
    if ((unsigned long )txt_rec != (unsigned long )(& rr->data.TXT)) {
      free((void *)txt_rec);
    }
    txt_rec = next;
  }
  break;
  case 33U: 
  if (rr->data.SRV.target) {
    free((void *)rr->data.SRV.target);
  }
  break;
  default: 
  break;
  }
  free((void *)rr->name);
  free((void *)rr);
  return;
}
}
void rr_list_destroy(struct rr_list *rr , char destroy_items ) 
{ 
  struct rr_list *rr_next ;

  {
  while (rr) {
    rr_next = rr->next;
    if (destroy_items) {
      rr_entry_destroy(rr->e);
    }
    free((void *)rr);
    rr = rr_next;
  }
  return;
}
}
int rr_list_count(struct rr_list *rr ) 
{ 
  int i ;

  {
  i = 0;
  while (rr) {
    i ++;
    rr = rr->next;
  }
  return (i);
}
}
struct rr_entry *rr_list_remove(struct rr_list **rr_head , struct rr_entry *rr ) 
{ 
  struct rr_list *le ;
  struct rr_list *pe ;

  {
  le = *rr_head;
  pe = (struct rr_list *)((void *)0);
  while (le) {
    if ((unsigned long )le->e == (unsigned long )rr) {
      if ((unsigned long )pe == (unsigned long )((void *)0)) {
        *rr_head = le->next;
        free((void *)le);
        return (rr);
      } else {
        pe->next = le->next;
        free((void *)le);
        return (rr);
      }
    }
    pe = le;
    le = le->next;
  }
  return ((struct rr_entry *)((void *)0));
}
}
int rr_list_append(struct rr_list **rr_head , struct rr_entry *rr ) 
{ 
  struct rr_list *node ;
  void *tmp ;
  struct rr_list *e ;
  struct rr_list *taile ;

  {
  tmp = malloc(sizeof(struct rr_list ));
  node = (struct rr_list *)tmp;
  node->e = rr;
  node->next = (struct rr_list *)((void *)0);
  if ((unsigned long )*rr_head == (unsigned long )((void *)0)) {
    *rr_head = node;
  } else {
    e = *rr_head;
    while (e) {
      if ((unsigned long )e->e == (unsigned long )rr) {
        free((void *)node);
        return (0);
      }
      if ((unsigned long )e->next == (unsigned long )((void *)0)) {
        taile = e;
      }
      e = e->next;
    }
    taile->next = node;
  }
  return (1);
}
}
struct rr_entry *rr_create_a(uint8_t *name , uint32_t addr ) 
{ 
  struct rr_entry *rr ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct rr_entry ));
  rr = (struct rr_entry *)tmp;
  memset((void *)rr, 0, sizeof(struct rr_entry ));
  rr->name = name;
  rr->type = (enum rr_type )1;
  rr->ttl = (uint32_t )120;
  rr->cache_flush = (char)1;
  rr->rr_class = (uint16_t )1;
  rr->data.A.addr = addr;
  return (rr);
}
}
struct rr_entry *rr_create_aaaa(uint8_t *name , struct in6_addr *addr ) 
{ 
  struct rr_entry *rr ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct rr_entry ));
  rr = (struct rr_entry *)tmp;
  memset((void *)rr, 0, sizeof(struct rr_entry ));
  rr->name = name;
  rr->type = (enum rr_type )28;
  rr->ttl = (uint32_t )120;
  rr->cache_flush = (char)1;
  rr->rr_class = (uint16_t )1;
  rr->data.AAAA.addr = addr;
  return (rr);
}
}
struct rr_entry *rr_create_srv(uint8_t *name , uint16_t port , uint8_t *target ) 
{ 
  struct rr_entry *rr ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct rr_entry ));
  rr = (struct rr_entry *)tmp;
  memset((void *)rr, 0, sizeof(struct rr_entry ));
  rr->name = name;
  rr->type = (enum rr_type )33;
  rr->ttl = (uint32_t )120;
  rr->cache_flush = (char)1;
  rr->rr_class = (uint16_t )1;
  rr->data.SRV.port = port;
  rr->data.SRV.target = target;
  return (rr);
}
}
struct rr_entry *rr_create_ptr(uint8_t *name , struct rr_entry *d_rr ) 
{ 
  struct rr_entry *rr ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct rr_entry ));
  rr = (struct rr_entry *)tmp;
  memset((void *)rr, 0, sizeof(struct rr_entry ));
  rr->name = name;
  rr->type = (enum rr_type )12;
  rr->ttl = (uint32_t )120;
  rr->cache_flush = (char)1;
  rr->rr_class = (uint16_t )1;
  rr->cache_flush = (char)0;
  rr->data.PTR.entry = d_rr;
  return (rr);
}
}
struct rr_entry *rr_create(uint8_t *name , enum rr_type type ) 
{ 
  struct rr_entry *rr ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct rr_entry ));
  rr = (struct rr_entry *)tmp;
  memset((void *)rr, 0, sizeof(struct rr_entry ));
  rr->name = name;
  rr->type = type;
  rr->ttl = (uint32_t )120;
  rr->cache_flush = (char)1;
  rr->rr_class = (uint16_t )1;
  return (rr);
}
}
void rr_set_nsec(struct rr_entry *rr_nsec , enum rr_type type ) 
{ 
  enum rr_type tmp___2 ;

  {
  tmp___2 = (enum rr_type )47;
  rr_nsec->type = tmp___2;
  if (! tmp___2) {
    __assert_fail("rr_nsec->type = RR_NSEC", "tinysvcmdns.c", 440U, "rr_set_nsec");
  }
  if (! ((unsigned long )((unsigned int )type / 8U) < sizeof(rr_nsec->data.NSEC.bitmap))) {
    __assert_fail("(type / 8) < sizeof(rr_nsec->data.NSEC.bitmap)", "tinysvcmdns.c",
                  441U, "rr_set_nsec");
  }
  rr_nsec->data.NSEC.bitmap[(unsigned int )type / 8U] = (uint8_t )(1 << (7U - (unsigned int )type % 8U));
  return;
}
}
void rr_add_txt(struct rr_entry *rr_txt , char const   *txt ) 
{ 
  struct rr_data_txt *txt_rec ;
  void *tmp___0 ;

  {
  if (! ((unsigned int )rr_txt->type == 16U)) {
    __assert_fail("rr_txt->type == RR_TXT", "tinysvcmdns.c", 448U, "rr_add_txt");
  }
  txt_rec = & rr_txt->data.TXT;
  if ((unsigned long )txt_rec->txt == (unsigned long )((void *)0)) {
    txt_rec->txt = create_label(txt);
    return;
  }
  while (txt_rec->next) {
    txt_rec = txt_rec->next;
  }
  tmp___0 = malloc(sizeof(struct rr_data_txt ));
  txt_rec->next = (struct rr_data_txt *)tmp___0;
  txt_rec = txt_rec->next;
  txt_rec->txt = create_label(txt);
  txt_rec->next = (struct rr_data_txt *)((void *)0);
  return;
}
}
void rr_group_add(struct rr_group **group , struct rr_entry *rr ) 
{ 
  struct rr_group *g ;
  void *tmp___0 ;

  {
  if (! ((unsigned long )rr != (unsigned long )((void *)0))) {
    __assert_fail("rr != NULL", "tinysvcmdns.c", 473U, "rr_group_add");
  }
  if (*group) {
    g = rr_group_find(*group, rr->name);
    if (g) {
      rr_list_append(& g->rr, rr);
      return;
    }
  }
  tmp___0 = malloc(sizeof(struct rr_group ));
  g = (struct rr_group *)tmp___0;
  memset((void *)g, 0, sizeof(struct rr_group ));
  g->name = dup_nlabel((uint8_t const   *)rr->name);
  rr_list_append(& g->rr, rr);
  g->next = *group;
  *group = g;
  return;
}
}
struct rr_group *rr_group_find(struct rr_group *g , uint8_t *name ) 
{ 
  int tmp ;

  {
  while (g) {
    tmp = cmp_nlabel((uint8_t const   *)g->name, (uint8_t const   *)name);
    if (tmp == 0) {
      return (g);
    }
    g = g->next;
  }
  return ((struct rr_group *)((void *)0));
}
}
struct rr_entry *rr_entry_find(struct rr_list *rr_list , uint8_t *name , uint16_t type ) 
{ 
  struct rr_list *rr ;
  int tmp ;

  {
  rr = rr_list;
  while (rr) {
    if ((unsigned int )(rr->e)->type == (unsigned int )type) {
      tmp = cmp_nlabel((uint8_t const   *)(rr->e)->name, (uint8_t const   *)name);
      if (tmp == 0) {
        return (rr->e);
      }
    }
    rr = rr->next;
  }
  return ((struct rr_entry *)((void *)0));
}
}
struct rr_entry *rr_entry_match(struct rr_list *rr_list , struct rr_entry *entry ) 
{ 
  struct rr_list *rr ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  rr = rr_list;
  while (rr) {
    if ((unsigned int )(rr->e)->type == (unsigned int )entry->type) {
      tmp___2 = cmp_nlabel((uint8_t const   *)(rr->e)->name, (uint8_t const   *)entry->name);
      if (tmp___2 == 0) {
        if ((unsigned int )entry->type != 12U) {
          return (rr->e);
        } else {
          if ((unsigned long )(rr->e)->data.PTR.name != (unsigned long )((void *)0)) {
            tmp = (rr->e)->data.PTR.name;
          } else {
            tmp = ((rr->e)->data.PTR.entry)->name;
          }
          if ((unsigned long )entry->data.PTR.name != (unsigned long )((void *)0)) {
            tmp___0 = entry->data.PTR.name;
          } else {
            tmp___0 = (entry->data.PTR.entry)->name;
          }
          tmp___1 = cmp_nlabel((uint8_t const   *)tmp___0, (uint8_t const   *)tmp);
          if (tmp___1 == 0) {
            return (rr->e);
          }
        }
      }
    }
    rr = rr->next;
  }
  return ((struct rr_entry *)((void *)0));
}
}
void rr_group_destroy(struct rr_group *group ) 
{ 
  struct rr_group *g ;
  struct rr_group *nextg ;

  {
  g = group;
  while (g) {
    nextg = g->next;
    free((void *)g->name);
    rr_list_destroy(g->rr, (char)1);
    free((void *)g);
    g = nextg;
  }
  return;
}
}
uint8_t *mdns_write_u16(uint8_t *ptr , uint16_t const   v ) 
{ 
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
  tmp = ptr;
  ptr ++;
  *tmp = (uint8_t )((int )((uint8_t )((int const   )v >> 8)) & 255);
  tmp___0 = ptr;
  ptr ++;
  *tmp___0 = (uint8_t )((int )((uint8_t )((int const   )v)) & 255);
  return (ptr);
}
}
uint8_t *mdns_write_u32(uint8_t *ptr , uint32_t const   v ) 
{ 
  uint8_t *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;

  {
  tmp = ptr;
  ptr ++;
  *tmp = (uint8_t )((int )((uint8_t )(v >> 24)) & 255);
  tmp___0 = ptr;
  ptr ++;
  *tmp___0 = (uint8_t )((int )((uint8_t )(v >> 16)) & 255);
  tmp___1 = ptr;
  ptr ++;
  *tmp___1 = (uint8_t )((int )((uint8_t )(v >> 8)) & 255);
  tmp___2 = ptr;
  ptr ++;
  *tmp___2 = (uint8_t )((int )((uint8_t )v) & 255);
  return (ptr);
}
}
uint16_t mdns_read_u16(uint8_t const   *ptr ) 
{ 


  {
  return ((uint16_t )((((int const   )*(ptr + 0) & 255) << 8) | ((int const   )*(ptr + 1) & 255)));
}
}
uint32_t mdns_read_u32(uint8_t const   *ptr ) 
{ 


  {
  return ((uint32_t )((((((int const   )*(ptr + 0) & 255) << 24) | (((int const   )*(ptr + 1) & 255) << 16)) | (((int const   )*(ptr + 2) & 255) << 8)) | ((int const   )*(ptr + 3) & 255)));
}
}
void mdns_init_reply(struct mdns_pkt *pkt , uint16_t id ) 
{ 


  {
  pkt->id = id;
  pkt->flags = (uint16_t )((1 << 15) | (1 << 10));
  rr_list_destroy(pkt->rr_qn, (char)0);
  rr_list_destroy(pkt->rr_ans, (char)0);
  rr_list_destroy(pkt->rr_auth, (char)0);
  rr_list_destroy(pkt->rr_add, (char)0);
  pkt->rr_qn = (struct rr_list *)((void *)0);
  pkt->rr_ans = (struct rr_list *)((void *)0);
  pkt->rr_auth = (struct rr_list *)((void *)0);
  pkt->rr_add = (struct rr_list *)((void *)0);
  pkt->num_qn = (uint16_t )0;
  pkt->num_ans_rr = (uint16_t )0;
  pkt->num_auth_rr = (uint16_t )0;
  pkt->num_add_rr = (uint16_t )0;
  return;
}
}
void mdns_pkt_destroy(struct mdns_pkt *p ) 
{ 


  {
  rr_list_destroy(p->rr_qn, (char)1);
  rr_list_destroy(p->rr_ans, (char)1);
  rr_list_destroy(p->rr_auth, (char)1);
  rr_list_destroy(p->rr_add, (char)1);
  free((void *)p);
  return;
}
}
static size_t mdns_parse_qn(uint8_t *pkt_buf , size_t pkt_len , size_t off , struct mdns_pkt *pkt ) 
{ 
  uint8_t const   *p ;
  struct rr_entry *rr ;
  uint8_t *name ;
  void *tmp___0 ;
  size_t tmp___1 ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;

  {
  p = (uint8_t const   *)(pkt_buf + off);
  if (! ((unsigned long )pkt != (unsigned long )((void *)0))) {
    __assert_fail("pkt != NULL", "tinysvcmdns.c", 609U, "mdns_parse_qn");
  }
  tmp___0 = malloc(sizeof(struct rr_entry ));
  rr = (struct rr_entry *)tmp___0;
  memset((void *)rr, 0, sizeof(struct rr_entry ));
  name = uncompress_nlabel(pkt_buf, pkt_len, off);
  tmp___1 = label_len(pkt_buf, pkt_len, off);
  p += tmp___1;
  rr->name = name;
  tmp___2 = mdns_read_u16(p);
  rr->type = (enum rr_type )tmp___2;
  p += sizeof(uint16_t );
  rr->unicast_query = (char )(((int const   )*p & 128) == 128);
  tmp___3 = mdns_read_u16(p);
  rr->rr_class = (uint16_t )((int )tmp___3 & -129);
  p += sizeof(uint16_t );
  rr_list_append(& pkt->rr_qn, rr);
  return ((size_t )(p - (uint8_t const   *)(pkt_buf + off)));
}
}
static size_t mdns_parse_rr(uint8_t *pkt_buf , size_t pkt_len , size_t off , struct mdns_pkt *pkt ) 
{ 
  uint8_t const   *p ;
  uint8_t const   *e ;
  struct rr_entry *rr ;
  uint8_t *name ;
  size_t rr_data_len ;
  struct rr_data_txt *txt_rec ;
  int parse_error ;
  void *tmp___0 ;
  size_t tmp___1 ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  uint32_t tmp___5 ;
  void *tmp___6 ;
  int i ;
  void *tmp___7 ;

  {
  p = (uint8_t const   *)(pkt_buf + off);
  e = (uint8_t const   *)(pkt_buf + pkt_len);
  rr_data_len = (size_t )0;
  parse_error = 0;
  if (! ((unsigned long )pkt != (unsigned long )((void *)0))) {
    __assert_fail("pkt != NULL", "tinysvcmdns.c", 642U, "mdns_parse_rr");
  }
  if (off > pkt_len) {
    return ((size_t )0);
  }
  tmp___0 = malloc(sizeof(struct rr_entry ));
  rr = (struct rr_entry *)tmp___0;
  memset((void *)rr, 0, sizeof(struct rr_entry ));
  name = uncompress_nlabel(pkt_buf, pkt_len, off);
  tmp___1 = label_len(pkt_buf, pkt_len, off);
  p += tmp___1;
  rr->name = name;
  tmp___2 = mdns_read_u16(p);
  rr->type = (enum rr_type )tmp___2;
  p += sizeof(uint16_t );
  rr->cache_flush = (char )(((int const   )*p & 128) == 128);
  tmp___3 = mdns_read_u16(p);
  rr->rr_class = (uint16_t )((int )tmp___3 & -129);
  p += sizeof(uint16_t );
  rr->ttl = mdns_read_u32(p);
  p += sizeof(uint32_t );
  tmp___4 = mdns_read_u16(p);
  rr_data_len = (size_t )tmp___4;
  p += sizeof(uint16_t );
  if ((unsigned long )(p + rr_data_len) > (unsigned long )e) {
    debug(1, (char *)"rr_data_len goes beyond packet buffer: %lu > %lu\n", rr_data_len,
          e - p);
    rr_entry_destroy(rr);
    return ((size_t )0);
  }
  e = p + rr_data_len;
  switch ((unsigned int )rr->type) {
  case 1U: 
  if (rr_data_len < sizeof(uint32_t )) {
    debug(1, (char *)"invalid rr_data_len=%lu for A record\n", rr_data_len);
    parse_error = 1;
    break;
  }
  tmp___5 = mdns_read_u32(p);
  rr->data.A.addr = __bswap_32(tmp___5);
  p += sizeof(uint32_t );
  break;
  case 28U: 
  if (rr_data_len < sizeof(struct in6_addr )) {
    debug(1, (char *)"invalid rr_data_len=%lu for AAAA record\n", rr_data_len);
    parse_error = 1;
    break;
  }
  tmp___6 = malloc(sizeof(struct in6_addr ));
  rr->data.AAAA.addr = (struct in6_addr *)tmp___6;
  i = 0;
  while ((unsigned long )i < sizeof(struct in6_addr )) {
    (rr->data.AAAA.addr)->__in6_u.__u6_addr8[i] = (uint8_t )*(p + i);
    i ++;
  }
  p += sizeof(struct in6_addr );
  break;
  case 12U: 
  rr->data.PTR.name = uncompress_nlabel(pkt_buf, pkt_len, (size_t )(p - (uint8_t const   *)pkt_buf));
  if ((unsigned long )rr->data.PTR.name == (unsigned long )((void *)0)) {
    debug(1, (char *)"unable to parse/uncompress label for PTR name\n");
    parse_error = 1;
    break;
  }
  p += rr_data_len;
  break;
  case 16U: 
  txt_rec = & rr->data.TXT;
  if (rr_data_len == 0UL) {
    debug(1, (char *)"WARN: rr_data_len for TXT is 0\n");
    txt_rec->txt = create_label("");
    break;
  }
  while (1) {
    txt_rec->txt = copy_label(pkt_buf, pkt_len, (size_t )(p - (uint8_t const   *)pkt_buf));
    if ((unsigned long )txt_rec->txt == (unsigned long )((void *)0)) {
      debug(1, (char *)"unable to copy label for TXT record\n");
      parse_error = 1;
      break;
    }
    p += (int )*(txt_rec->txt + 0) + 1;
    if ((unsigned long )p >= (unsigned long )e) {
      break;
    }
    tmp___7 = malloc(sizeof(struct rr_data_txt ));
    txt_rec->next = (struct rr_data_txt *)tmp___7;
    txt_rec = txt_rec->next;
    txt_rec->next = (struct rr_data_txt *)((void *)0);
  }
  break;
  default: 
  p = e;
  }
  if (parse_error) {
    rr_entry_destroy(rr);
    return ((size_t )0);
  }
  rr_list_append(& pkt->rr_ans, rr);
  return ((size_t )(p - (uint8_t const   *)(pkt_buf + off)));
}
}
struct mdns_pkt *mdns_parse_pkt(uint8_t *pkt_buf , size_t pkt_len ) 
{ 
  uint8_t *p ;
  size_t off ;
  struct mdns_pkt *pkt ;
  int i ;
  void *tmp ;
  size_t l ;
  size_t tmp___0 ;
  size_t l___0 ;
  size_t tmp___1 ;

  {
  p = pkt_buf;
  if (pkt_len < 12UL) {
    return ((struct mdns_pkt *)((void *)0));
  }
  tmp = malloc(sizeof(struct mdns_pkt ));
  pkt = (struct mdns_pkt *)tmp;
  memset((void *)pkt, 0, sizeof(struct mdns_pkt ));
  pkt->id = mdns_read_u16((uint8_t const   *)p);
  p += sizeof(uint16_t );
  pkt->flags = mdns_read_u16((uint8_t const   *)p);
  p += sizeof(uint16_t );
  pkt->num_qn = mdns_read_u16((uint8_t const   *)p);
  p += sizeof(uint16_t );
  pkt->num_ans_rr = mdns_read_u16((uint8_t const   *)p);
  p += sizeof(uint16_t );
  pkt->num_auth_rr = mdns_read_u16((uint8_t const   *)p);
  p += sizeof(uint16_t );
  pkt->num_add_rr = mdns_read_u16((uint8_t const   *)p);
  p += sizeof(uint16_t );
  off = (size_t )(p - pkt_buf);
  i = 0;
  while (i < (int )pkt->num_qn) {
    tmp___0 = mdns_parse_qn(pkt_buf, pkt_len, off, pkt);
    l = tmp___0;
    if (! l) {
      debug(1, (char *)"error parsing question #%d\n", i);
      mdns_pkt_destroy(pkt);
      return ((struct mdns_pkt *)((void *)0));
    }
    off += l;
    i ++;
  }
  i = 0;
  while (i < (int )pkt->num_ans_rr) {
    tmp___1 = mdns_parse_rr(pkt_buf, pkt_len, off, pkt);
    l___0 = tmp___1;
    if (! l___0) {
      debug(1, (char *)"error parsing answer #%d\n", i);
      mdns_pkt_destroy(pkt);
      return ((struct mdns_pkt *)((void *)0));
    }
    off += l___0;
    i ++;
  }
  return (pkt);
}
}
static size_t mdns_encode_name(uint8_t *pkt_buf , size_t pkt_len , size_t off , uint8_t const   *name ,
                               struct name_comp *comp ) 
{ 
  struct name_comp *c ;
  struct name_comp *c_tail ;
  uint8_t *p ;
  size_t len ;
  int tmp ;
  int segment_len ;
  struct name_comp *new_c ;
  void *tmp___0 ;

  {
  c_tail = (struct name_comp *)((void *)0);
  p = pkt_buf + off;
  len = (size_t )0;
  if (name) {
    while (*name) {
      c = comp;
      while (c) {
        tmp = cmp_nlabel(name, (uint8_t const   *)c->label);
        if (tmp == 0) {
          mdns_write_u16(p, (uint16_t const   )(49152UL | (c->pos & 0xffffffffffff3fffUL)));
          return (len + sizeof(uint16_t ));
        }
        if ((unsigned long )c->next == (unsigned long )((void *)0)) {
          c_tail = c;
        }
        c = c->next;
      }
      segment_len = (int )((int const   )*name + 1);
      strncpy((char * __restrict  )((char *)p), (char const   * __restrict  )((char *)name),
              (size_t )segment_len);
      tmp___0 = malloc(sizeof(struct name_comp ));
      new_c = (struct name_comp *)tmp___0;
      memset((void *)new_c, 0, sizeof(struct name_comp ));
      new_c->label = (uint8_t *)name;
      new_c->pos = (size_t )(p - pkt_buf);
      c_tail->next = new_c;
      p += segment_len;
      len += (size_t )segment_len;
      name += segment_len;
    }
  }
  *p = (uint8_t )'\000';
  len ++;
  return (len);
}
}
static size_t mdns_encode_rr(uint8_t *pkt_buf , size_t pkt_len , size_t off , struct rr_entry *rr ,
                             struct name_comp *comp ) 
{ 
  uint8_t *p ;
  uint8_t *p_data ;
  size_t l ;
  struct rr_data_txt *txt_rec ;
  uint8_t *label ;
  int i ;
  __uint32_t tmp___1 ;
  uint8_t *tmp___2 ;
  size_t tmp___3 ;
  int len ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  uint8_t *tmp___6 ;
  uint8_t *tmp___7 ;
  uint8_t *tmp___8 ;

  {
  p = pkt_buf + off;
  if (! (off < pkt_len)) {
    __assert_fail("off < pkt_len", "tinysvcmdns.c", 862U, "mdns_encode_rr");
  }
  l = mdns_encode_name(pkt_buf, pkt_len, off, (uint8_t const   *)rr->name, comp);
  if (! (l != 0UL)) {
    __assert_fail("l != 0", "tinysvcmdns.c", 866U, "mdns_encode_rr");
  }
  p += l;
  p = mdns_write_u16(p, (uint16_t const   )rr->type);
  p = mdns_write_u16(p, (uint16_t const   )(((int )rr->rr_class & -32769) | ((int )rr->cache_flush << 15)));
  p = mdns_write_u32(p, (uint32_t const   )rr->ttl);
  p += sizeof(uint16_t );
  p_data = p;
  switch ((unsigned int )rr->type) {
  case 1U: 
  tmp___1 = __bswap_32(rr->data.A.addr);
  p = mdns_write_u32(p, (uint32_t const   )tmp___1);
  break;
  case 28U: 
  i = 0;
  while ((unsigned long )i < sizeof(struct in6_addr )) {
    tmp___2 = p;
    p ++;
    *tmp___2 = (rr->data.AAAA.addr)->__in6_u.__u6_addr8[i];
    i ++;
  }
  break;
  case 12U: 
  if (rr->data.PTR.name) {
    label = rr->data.PTR.name;
  } else {
    label = (rr->data.PTR.entry)->name;
  }
  tmp___3 = mdns_encode_name(pkt_buf, pkt_len, (size_t )(p - pkt_buf), (uint8_t const   *)label,
                             comp);
  p += tmp___3;
  break;
  case 16U: 
  txt_rec = & rr->data.TXT;
  while (txt_rec) {
    len = (int )*(txt_rec->txt + 0) + 1;
    strncpy((char * __restrict  )((char *)p), (char const   * __restrict  )((char *)txt_rec->txt),
            (size_t )len);
    p += len;
    txt_rec = txt_rec->next;
  }
  break;
  case 33U: 
  p = mdns_write_u16(p, (uint16_t const   )rr->data.SRV.priority);
  p = mdns_write_u16(p, (uint16_t const   )rr->data.SRV.weight);
  p = mdns_write_u16(p, (uint16_t const   )rr->data.SRV.port);
  tmp___4 = mdns_encode_name(pkt_buf, pkt_len, (size_t )(p - pkt_buf), (uint8_t const   *)rr->data.SRV.target,
                             comp);
  p += tmp___4;
  break;
  case 47U: 
  tmp___5 = mdns_encode_name(pkt_buf, pkt_len, (size_t )(p - pkt_buf), (uint8_t const   *)rr->name,
                             comp);
  p += tmp___5;
  tmp___6 = p;
  p ++;
  *tmp___6 = (uint8_t )0;
  tmp___7 = p;
  p ++;
  *tmp___7 = (uint8_t )sizeof(rr->data.NSEC.bitmap);
  i = 0;
  while ((unsigned long )i < sizeof(rr->data.NSEC.bitmap)) {
    tmp___8 = p;
    p ++;
    *tmp___8 = rr->data.NSEC.bitmap[i];
    i ++;
  }
  break;
  default: 
  debug(1, (char *)"unhandled rr type 0x%02x\n", (unsigned int )rr->type);
  }
  l = (size_t )(p - p_data);
  mdns_write_u16((p - l) - sizeof(uint16_t ), (uint16_t const   )l);
  return ((size_t )(p - pkt_buf) - off);
}
}
size_t mdns_encode_pkt(struct mdns_pkt *answer , uint8_t *pkt_buf , size_t pkt_len ) 
{ 
  struct name_comp *comp ;
  uint8_t *p ;
  size_t off ;
  int i ;
  void *tmp___2 ;
  struct rr_list *rr_set[3] ;
  struct rr_list *rr ;
  size_t l ;
  size_t tmp___3 ;
  struct name_comp *c ;

  {
  p = pkt_buf;
  if (! ((unsigned long )answer != (unsigned long )((void *)0))) {
    __assert_fail("answer != NULL", "tinysvcmdns.c", 957U, "mdns_encode_pkt");
  }
  if (! (pkt_len >= 12UL)) {
    __assert_fail("pkt_len >= 12", "tinysvcmdns.c", 958U, "mdns_encode_pkt");
  }
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    return ((size_t )-1);
  }
  if (! ((int )answer->num_qn == 0)) {
    __assert_fail("answer->num_qn == 0", "tinysvcmdns.c", 964U, "mdns_encode_pkt");
  }
  p = mdns_write_u16(p, (uint16_t const   )answer->id);
  p = mdns_write_u16(p, (uint16_t const   )answer->flags);
  p = mdns_write_u16(p, (uint16_t const   )answer->num_qn);
  p = mdns_write_u16(p, (uint16_t const   )answer->num_ans_rr);
  p = mdns_write_u16(p, (uint16_t const   )answer->num_auth_rr);
  p = mdns_write_u16(p, (uint16_t const   )answer->num_add_rr);
  off = (size_t )(p - pkt_buf);
  tmp___2 = malloc(sizeof(struct name_comp ));
  comp = (struct name_comp *)tmp___2;
  if ((unsigned long )comp == (unsigned long )((void *)0)) {
    return ((size_t )-1);
  }
  memset((void *)comp, 0, sizeof(struct name_comp ));
  comp->label = (uint8_t *)"";
  comp->pos = (size_t )0;
  rr_set[0] = answer->rr_ans;
  rr_set[1] = answer->rr_auth;
  rr_set[2] = answer->rr_add;
  i = 0;
  while ((unsigned long )i < sizeof(rr_set) / sizeof(rr_set[0])) {
    rr = rr_set[i];
    while (rr) {
      tmp___3 = mdns_encode_rr(pkt_buf, pkt_len, off, rr->e, comp);
      l = tmp___3;
      off += l;
      if (off >= pkt_len) {
        debug(1, (char *)"packet buffer too small\n");
        return ((size_t )-1);
      }
      rr = rr->next;
    }
    i ++;
  }
  while (comp) {
    c = comp->next;
    free((void *)comp);
    comp = c;
  }
  return (off);
}
}
static int create_recv_sock(void) 
{ 
  int sd ;
  int tmp ;
  int r ;
  int on ;
  struct sockaddr_in serveraddr ;
  struct ip_mreq mreq ;

  {
  tmp = socket(2, 2, 0);
  sd = tmp;
  if (sd < 0) {
    while (1) {
      switch (3) {
      case 3: 
      warn((char *)"recv socket(): %m");
      break;
      default: 
      debug(1, (char *)"recv socket(): %m");
      }
      break;
    }
    return (sd);
  }
  r = -1;
  on = 1;
  r = setsockopt(sd, 1, 2, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
  if (r < 0) {
    while (1) {
      switch (3) {
      case 3: 
      warn((char *)"recv setsockopt(SO_REUSEADDR): %m");
      break;
      default: 
      debug(1, (char *)"recv setsockopt(SO_REUSEADDR): %m");
      }
      break;
    }
    return (r);
  }
  memset((void *)(& serveraddr), 0, sizeof(serveraddr));
  serveraddr.sin_family = (sa_family_t )2;
  serveraddr.sin_port = __bswap_16((__uint16_t )5353);
  serveraddr.sin_addr.s_addr = __bswap_32((in_addr_t )0);
  r = bind(sd, (struct sockaddr  const  *)((struct sockaddr *)(& serveraddr)), (socklen_t )sizeof(serveraddr));
  if (r < 0) {
    while (1) {
      switch (3) {
      case 3: 
      warn((char *)"recv bind(): %m");
      break;
      default: 
      debug(1, (char *)"recv bind(): %m");
      }
      break;
    }
  }
  memset((void *)(& mreq), 0, sizeof(struct ip_mreq ));
  mreq.imr_interface.s_addr = __bswap_32((in_addr_t )0);
  mreq.imr_multiaddr.s_addr = inet_addr("224.0.0.251");
  r = setsockopt(sd, 0, 35, (void const   *)((char *)(& mreq)), (socklen_t )sizeof(mreq));
  if (r < 0) {
    while (1) {
      switch (3) {
      case 3: 
      warn((char *)"recv setsockopt(IP_ADD_MEMBERSHIP): %m");
      break;
      default: 
      debug(1, (char *)"recv setsockopt(IP_ADD_MEMBERSHIP): %m");
      }
      break;
    }
    return (r);
  }
  r = setsockopt(sd, 0, 34, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
  if (r < 0) {
    while (1) {
      switch (3) {
      case 3: 
      warn((char *)"recv setsockopt(IP_MULTICAST_LOOP): %m");
      break;
      default: 
      debug(1, (char *)"recv setsockopt(IP_MULTICAST_LOOP): %m");
      }
      break;
    }
    return (r);
  }
  r = setsockopt(sd, 0, 8, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
  if (r < 0) {
    while (1) {
      switch (3) {
      case 3: 
      warn((char *)"recv setsockopt(IP_PKTINFO): %m");
      break;
      default: 
      debug(1, (char *)"recv setsockopt(IP_PKTINFO): %m");
      }
      break;
    }
    return (r);
  }
  return (sd);
}
}
static struct sockaddr_in toaddr  ;
static ssize_t send_packet(int fd___1 , void const   *data , size_t len ) 
{ 
  ssize_t tmp ;

  {
  if ((int )toaddr.sin_family != 2) {
    memset((void *)(& toaddr), 0, sizeof(struct sockaddr_in ));
    toaddr.sin_family = (sa_family_t )2;
    toaddr.sin_port = __bswap_16((__uint16_t )5353);
    toaddr.sin_addr.s_addr = inet_addr("224.0.0.251");
  }
  tmp = sendto(fd___1, data, len, 0, (struct sockaddr  const  *)((struct sockaddr *)(& toaddr)),
               (socklen_t )sizeof(struct sockaddr_in ));
  return (tmp);
}
}
static int populate_answers(struct mdnsd *svr___0 , struct rr_list **rr_head , uint8_t *name ,
                            enum rr_type type ) 
{ 
  int num_ans ;
  struct rr_group *ans_grp ;
  struct rr_group *tmp ;
  struct rr_list *n ;
  int tmp___0 ;
  int tmp___1 ;

  {
  num_ans = 0;
  pthread_mutex_lock(& svr___0->data_lock);
  tmp = rr_group_find(svr___0->group, name);
  ans_grp = tmp;
  if ((unsigned long )ans_grp == (unsigned long )((void *)0)) {
    pthread_mutex_unlock(& svr___0->data_lock);
    return (num_ans);
  }
  n = ans_grp->rr;
  while (n) {
    if ((unsigned int )type == 255U) {
      if ((unsigned int )(n->e)->type == 47U) {
        goto __Cont;
      }
    }
    if ((unsigned int )type == (unsigned int )(n->e)->type) {
      goto _L;
    } else
    if ((unsigned int )type == 255U) {
      _L: /* CIL Label */ 
      tmp___1 = cmp_nlabel((uint8_t const   *)name, (uint8_t const   *)(n->e)->name);
      if (tmp___1 == 0) {
        tmp___0 = rr_list_append(rr_head, n->e);
        num_ans += tmp___0;
      }
    }
    __Cont: /* CIL Label */ 
    n = n->next;
  }
  pthread_mutex_unlock(& svr___0->data_lock);
  return (num_ans);
}
}
static void add_related_rr(struct mdnsd *svr___0 , struct rr_list *list , struct mdns_pkt *reply ) 
{ 
  struct rr_entry *ans ;
  uint8_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  while (list) {
    ans = list->e;
    switch ((unsigned int )ans->type) {
    case 12U: 
    if ((unsigned long )ans->data.PTR.name != (unsigned long )((void *)0)) {
      tmp = ans->data.PTR.name;
    } else {
      tmp = (ans->data.PTR.entry)->name;
    }
    tmp___0 = populate_answers(svr___0, & reply->rr_add, tmp, (enum rr_type )255);
    reply->num_add_rr = (uint16_t )((int )reply->num_add_rr + tmp___0);
    break;
    case 33U: 
    tmp___1 = populate_answers(svr___0, & reply->rr_add, ans->data.SRV.target, (enum rr_type )255);
    reply->num_add_rr = (uint16_t )((int )reply->num_add_rr + tmp___1);
    tmp___2 = populate_answers(svr___0, & reply->rr_add, ans->name, (enum rr_type )16);
    reply->num_add_rr = (uint16_t )((int )reply->num_add_rr + tmp___2);
    break;
    case 28U: 
    case 1U: 
    tmp___3 = populate_answers(svr___0, & reply->rr_add, ans->name, (enum rr_type )47);
    reply->num_add_rr = (uint16_t )((int )reply->num_add_rr + tmp___3);
    break;
    default: 
    break;
    }
    list = list->next;
  }
  return;
}
}
static void announce_srv(struct mdnsd *svr___0 , struct mdns_pkt *reply , uint8_t *name ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  mdns_init_reply(reply, (uint16_t )0);
  tmp = populate_answers(svr___0, & reply->rr_ans, name, (enum rr_type )12);
  reply->num_ans_rr = (uint16_t )((int )reply->num_ans_rr + tmp);
  tmp___0 = populate_answers(svr___0, & reply->rr_ans, (uint8_t *)"\t_services\a_dns-sd\004_udp\005local",
                             (enum rr_type )12);
  reply->num_ans_rr = (uint16_t )((int )reply->num_ans_rr + tmp___0);
  add_related_rr(svr___0, reply->rr_ans, reply);
  add_related_rr(svr___0, reply->rr_add, reply);
  return;
}
}
static int process_mdns_pkt(struct mdnsd *svr___0 , struct mdns_pkt *pkt , struct mdns_pkt *reply ) 
{ 
  int i ;
  struct rr_list *qnl ;
  struct rr_entry *qn ;
  int num_ans_added ;
  char *namestr ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  struct rr_list *ans ;
  struct rr_list *prev_ans ;
  struct rr_list *next_ans ;
  struct rr_entry *known_ans ;
  struct rr_entry *tmp___2 ;
  char *namestr___0 ;
  char *tmp___3 ;

  {
  if (! ((unsigned long )pkt != (unsigned long )((void *)0))) {
    __assert_fail("pkt != NULL", "tinysvcmdns.c", 1237U, "process_mdns_pkt");
  }
  if (((int )pkt->flags & (1 << 15)) == 0) {
    if ((((int )pkt->flags >> 11) & 15) == 0) {
      mdns_init_reply(reply, pkt->id);
      debug(1, (char *)"flags = %04x, qn = %d, ans = %d, add = %d\n", (int )pkt->flags,
            (int )pkt->num_qn, (int )pkt->num_ans_rr, (int )pkt->num_add_rr);
      qnl = pkt->rr_qn;
      i = 0;
      while (i < (int )pkt->num_qn) {
        qn = qnl->e;
        num_ans_added = 0;
        tmp___0 = nlabel_to_str((uint8_t const   *)qn->name);
        namestr = tmp___0;
        tmp___1 = rr_get_type_name(qn->type);
        debug(1, (char *)"qn #%d: type %s (%02x) %s - ", i, tmp___1, (unsigned int )qn->type,
              namestr);
        free((void *)namestr);
        if (qn->unicast_query) {
          debug(1, (char *)"skipping unicast query\n");
          goto __Cont;
        }
        num_ans_added = populate_answers(svr___0, & reply->rr_ans, qn->name, qn->type);
        reply->num_ans_rr = (uint16_t )((int )reply->num_ans_rr + num_ans_added);
        debug(1, (char *)"added %d answers\n", num_ans_added);
        __Cont: /* CIL Label */ 
        i ++;
        qnl = qnl->next;
      }
      ans = (struct rr_list *)((void *)0);
      prev_ans = (struct rr_list *)((void *)0);
      ans = reply->rr_ans;
      while (ans) {
        next_ans = ans->next;
        tmp___2 = rr_entry_match(pkt->rr_ans, ans->e);
        known_ans = tmp___2;
        if ((unsigned long )known_ans != (unsigned long )((void *)0)) {
          if (known_ans->ttl >= (ans->e)->ttl / 2U) {
            tmp___3 = nlabel_to_str((uint8_t const   *)(ans->e)->name);
            namestr___0 = tmp___3;
            debug(1, (char *)"removing answer for %s\n", namestr___0);
            free((void *)namestr___0);
            if ((unsigned long )prev_ans == (unsigned long )((void *)0)) {
              reply->rr_ans = ans->next;
            } else {
              prev_ans->next = ans->next;
            }
            free((void *)ans);
            ans = prev_ans;
            reply->num_ans_rr = (uint16_t )((int )reply->num_ans_rr - 1);
          }
        }
        prev_ans = ans;
        ans = next_ans;
      }
      add_related_rr(svr___0, reply->rr_ans, reply);
      add_related_rr(svr___0, reply->rr_add, reply);
      debug(1, (char *)"\n");
      return ((int )reply->num_ans_rr);
    }
  }
  return (0);
}
}
int create_pipe(int *handles ) 
{ 
  int tmp ;

  {
  tmp = pipe(handles);
  return (tmp);
}
}
int read_pipe(int s , char *buf , int len ) 
{ 
  ssize_t tmp ;

  {
  tmp = read(s, (void *)buf, (size_t )len);
  return ((int )tmp);
}
}
int write_pipe(int s , char *buf , int len ) 
{ 
  ssize_t tmp ;

  {
  tmp = write(s, (void const   *)buf, (size_t )len);
  return ((int )tmp);
}
}
int close_pipe(int s ) 
{ 
  int tmp ;

  {
  tmp = close(s);
  return (tmp);
}
}
static void main_loop(struct mdnsd *svr___0 ) 
{ 
  fd_set sockfd_set ;
  int max_fd ;
  char notify_buf[2] ;
  void *pkt_buffer ;
  void *tmp ;
  struct mdns_pkt *mdns_reply ;
  void *tmp___0 ;
  int __d0 ;
  int __d1 ;
  struct sockaddr_in fromaddr ;
  socklen_t sockaddr_size ;
  ssize_t recvsize ;
  ssize_t tmp___1 ;
  char *tmp___2 ;
  struct mdns_pkt *mdns ;
  struct mdns_pkt *tmp___3 ;
  size_t replylen ;
  size_t tmp___4 ;
  int tmp___5 ;
  struct rr_entry *ann_e ;
  char *namestr ;
  char *tmp___6 ;
  size_t replylen___0 ;
  size_t tmp___7 ;
  struct rr_list *svc_le ;
  int tmp___8 ;
  size_t replylen___1 ;
  size_t tmp___9 ;

  {
  max_fd = svr___0->sockfd;
  tmp = malloc((size_t )65536);
  pkt_buffer = tmp;
  if (svr___0->notify_pipe[0] > max_fd) {
    max_fd = svr___0->notify_pipe[0];
  }
  tmp___0 = malloc(sizeof(struct mdns_pkt ));
  mdns_reply = (struct mdns_pkt *)tmp___0;
  memset((void *)mdns_reply, 0, sizeof(struct mdns_pkt ));
  while (! svr___0->stop_flag) {
    while (1) {
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& sockfd_set.__fds_bits[0]): "memory");
      break;
    }
    sockfd_set.__fds_bits[svr___0->sockfd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << svr___0->sockfd % (8 * (int )sizeof(__fd_mask )));
    sockfd_set.__fds_bits[svr___0->notify_pipe[0] / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << svr___0->notify_pipe[0] % (8 * (int )sizeof(__fd_mask )));
    select(max_fd + 1, (fd_set * __restrict  )(& sockfd_set), (fd_set * __restrict  )((void *)0),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
    if ((sockfd_set.__fds_bits[svr___0->notify_pipe[0] / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << svr___0->notify_pipe[0] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      read_pipe(svr___0->notify_pipe[0], (char *)(& notify_buf), 1);
    } else
    if ((sockfd_set.__fds_bits[svr___0->sockfd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << svr___0->sockfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      sockaddr_size = (socklen_t )sizeof(struct sockaddr_in );
      tmp___1 = recvfrom(svr___0->sockfd, (void * __restrict  )pkt_buffer, (size_t )65536,
                         0, (struct sockaddr * __restrict  )((struct sockaddr *)(& fromaddr)),
                         (socklen_t * __restrict  )(& sockaddr_size));
      recvsize = tmp___1;
      if (recvsize < 0L) {
        while (1) {
          switch (3) {
          case 3: 
          warn((char *)"recv(): %m");
          break;
          default: 
          debug(1, (char *)"recv(): %m");
          }
          break;
        }
      }
      tmp___2 = inet_ntoa(fromaddr.sin_addr);
      debug(1, (char *)"data from=%s size=%ld\n", tmp___2, recvsize);
      tmp___3 = mdns_parse_pkt((uint8_t *)pkt_buffer, (size_t )recvsize);
      mdns = tmp___3;
      if ((unsigned long )mdns != (unsigned long )((void *)0)) {
        tmp___5 = process_mdns_pkt(svr___0, mdns, mdns_reply);
        if (tmp___5) {
          tmp___4 = mdns_encode_pkt(mdns_reply, (uint8_t *)pkt_buffer, (size_t )65536);
          replylen = tmp___4;
          send_packet(svr___0->sockfd, (void const   *)pkt_buffer, replylen);
        } else
        if ((int )mdns->num_qn == 0) {
          debug(1, (char *)"(no questions in packet)\n\n");
        }
        mdns_pkt_destroy(mdns);
      }
    }
    while (1) {
      ann_e = (struct rr_entry *)((void *)0);
      pthread_mutex_lock(& svr___0->data_lock);
      if (svr___0->announce) {
        ann_e = rr_list_remove(& svr___0->announce, (svr___0->announce)->e);
      }
      pthread_mutex_unlock(& svr___0->data_lock);
      if (! ann_e) {
        break;
      }
      tmp___6 = nlabel_to_str((uint8_t const   *)ann_e->name);
      namestr = tmp___6;
      debug(1, (char *)"sending announce for %s\n", namestr);
      free((void *)namestr);
      announce_srv(svr___0, mdns_reply, ann_e->name);
      if ((int )mdns_reply->num_ans_rr > 0) {
        tmp___7 = mdns_encode_pkt(mdns_reply, (uint8_t *)pkt_buffer, (size_t )65536);
        replylen___0 = tmp___7;
        send_packet(svr___0->sockfd, (void const   *)pkt_buffer, replylen___0);
      }
    }
  }
  mdns_init_reply(mdns_reply, (uint16_t )0);
  pthread_mutex_lock(& svr___0->data_lock);
  svc_le = svr___0->services;
  while (svc_le) {
    (svc_le->e)->ttl = (uint32_t )0;
    tmp___8 = rr_list_append(& mdns_reply->rr_ans, svc_le->e);
    mdns_reply->num_ans_rr = (uint16_t )((int )mdns_reply->num_ans_rr + tmp___8);
    svc_le = svc_le->next;
  }
  pthread_mutex_unlock(& svr___0->data_lock);
  if ((int )mdns_reply->num_ans_rr > 0) {
    tmp___9 = mdns_encode_pkt(mdns_reply, (uint8_t *)pkt_buffer, (size_t )65536);
    replylen___1 = tmp___9;
    send_packet(svr___0->sockfd, (void const   *)pkt_buffer, replylen___1);
  }
  mdns_init_reply(mdns_reply, (uint16_t )0);
  free((void *)mdns_reply);
  free(pkt_buffer);
  close_pipe(svr___0->sockfd);
  svr___0->stop_flag = 2;
  return;
}
}
void mdnsd_set_hostname(struct mdnsd *svr___0 , char const   *hostname , uint32_t ip ) 
{ 
  struct rr_entry *a_e ;
  struct rr_entry *nsec_e ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;

  {
  a_e = (struct rr_entry *)((void *)0);
  nsec_e = (struct rr_entry *)((void *)0);
  if (! ((unsigned long )svr___0->hostname == (unsigned long )((void *)0))) {
    __assert_fail("svr->hostname == NULL", "tinysvcmdns.c", 1501U, "mdnsd_set_hostname");
  }
  tmp___0 = create_nlabel(hostname);
  a_e = rr_create_a(tmp___0, ip);
  tmp___1 = create_nlabel(hostname);
  nsec_e = rr_create(tmp___1, (enum rr_type )47);
  rr_set_nsec(nsec_e, (enum rr_type )1);
  pthread_mutex_lock(& svr___0->data_lock);
  svr___0->hostname = create_nlabel(hostname);
  rr_group_add(& svr___0->group, a_e);
  rr_group_add(& svr___0->group, nsec_e);
  pthread_mutex_unlock(& svr___0->data_lock);
  return;
}
}
void mdnsd_set_hostname_v6(struct mdnsd *svr___0 , char const   *hostname , struct in6_addr *addr ) 
{ 
  struct rr_entry *aaaa_e ;
  struct rr_entry *nsec_e ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;

  {
  aaaa_e = (struct rr_entry *)((void *)0);
  nsec_e = (struct rr_entry *)((void *)0);
  if (! ((unsigned long )svr___0->hostname == (unsigned long )((void *)0))) {
    __assert_fail("svr->hostname == NULL", "tinysvcmdns.c", 1522U, "mdnsd_set_hostname_v6");
  }
  tmp___0 = create_nlabel(hostname);
  aaaa_e = rr_create_aaaa(tmp___0, addr);
  tmp___1 = create_nlabel(hostname);
  nsec_e = rr_create(tmp___1, (enum rr_type )47);
  rr_set_nsec(nsec_e, (enum rr_type )28);
  pthread_mutex_lock(& svr___0->data_lock);
  svr___0->hostname = create_nlabel(hostname);
  rr_group_add(& svr___0->group, aaaa_e);
  rr_group_add(& svr___0->group, nsec_e);
  pthread_mutex_unlock(& svr___0->data_lock);
  return;
}
}
void mdnsd_add_rr(struct mdnsd *svr___0 , struct rr_entry *rr ) 
{ 


  {
  pthread_mutex_lock(& svr___0->data_lock);
  rr_group_add(& svr___0->group, rr);
  pthread_mutex_unlock(& svr___0->data_lock);
  return;
}
}
struct mdns_service *mdnsd_register_svc(struct mdnsd *svr___0 , char const   *instance_name ,
                                        char const   *type , uint16_t port , char const   *hostname ,
                                        char const   **txt ) 
{ 
  struct rr_entry *txt_e ;
  struct rr_entry *srv_e ;
  struct rr_entry *ptr_e ;
  struct rr_entry *bptr_e ;
  uint8_t *target ;
  uint8_t *inst_nlabel ;
  uint8_t *type_nlabel ;
  uint8_t *nlabel ;
  struct mdns_service *service ;
  void *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___2 ;
  uint8_t *tmp___3 ;
  uint8_t *tmp___4 ;
  uint8_t *tmp___5 ;

  {
  txt_e = (struct rr_entry *)((void *)0);
  srv_e = (struct rr_entry *)((void *)0);
  ptr_e = (struct rr_entry *)((void *)0);
  bptr_e = (struct rr_entry *)((void *)0);
  tmp = malloc(sizeof(struct mdns_service ));
  service = (struct mdns_service *)tmp;
  memset((void *)service, 0, sizeof(struct mdns_service ));
  type_nlabel = create_nlabel(type);
  inst_nlabel = create_label(instance_name);
  nlabel = join_nlabel((uint8_t const   *)inst_nlabel, (uint8_t const   *)type_nlabel);
  if (txt) {
    if (*txt) {
      tmp___0 = dup_nlabel((uint8_t const   *)nlabel);
      txt_e = rr_create(tmp___0, (enum rr_type )16);
      rr_list_append(& service->entries, txt_e);
      while (*txt) {
        rr_add_txt(txt_e, *txt);
        txt ++;
      }
    }
  }
  if (! hostname) {
    if (! svr___0->hostname) {
      __assert_fail("hostname || svr->hostname", "tinysvcmdns.c", 1569U, "mdnsd_register_svc");
    }
  }
  if (hostname) {
    tmp___2 = create_nlabel(hostname);
    target = tmp___2;
  } else {
    tmp___3 = dup_nlabel((uint8_t const   *)svr___0->hostname);
    target = tmp___3;
  }
  tmp___4 = dup_nlabel((uint8_t const   *)nlabel);
  srv_e = rr_create_srv(tmp___4, port, target);
  rr_list_append(& service->entries, srv_e);
  ptr_e = rr_create_ptr(type_nlabel, srv_e);
  tmp___5 = dup_nlabel((uint8_t const   *)((uint8_t *)"\t_services\a_dns-sd\004_udp\005local"));
  bptr_e = rr_create_ptr(tmp___5, ptr_e);
  pthread_mutex_lock(& svr___0->data_lock);
  if (txt_e) {
    rr_group_add(& svr___0->group, txt_e);
  }
  rr_group_add(& svr___0->group, srv_e);
  rr_group_add(& svr___0->group, ptr_e);
  rr_group_add(& svr___0->group, bptr_e);
  rr_list_append(& svr___0->announce, ptr_e);
  rr_list_append(& svr___0->services, ptr_e);
  pthread_mutex_unlock(& svr___0->data_lock);
  free((void *)nlabel);
  free((void *)inst_nlabel);
  write_pipe(svr___0->notify_pipe[1], (char *)".", 1);
  return (service);
}
}
void mdns_service_destroy(struct mdns_service *srv ) 
{ 


  {
  if (! ((unsigned long )srv != (unsigned long )((void *)0))) {
    __assert_fail("srv != NULL", "tinysvcmdns.c", 1610U, "mdns_service_destroy");
  }
  rr_list_destroy(srv->entries, (char)0);
  free((void *)srv);
  return;
}
}
struct mdnsd *mdnsd_start(void) 
{ 
  pthread_t tid ;
  pthread_attr_t attr ;
  struct mdnsd *server ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = malloc(sizeof(struct mdnsd ));
  server = (struct mdnsd *)tmp;
  memset((void *)server, 0, sizeof(struct mdnsd ));
  tmp___0 = create_pipe((int *)(server->notify_pipe));
  if (tmp___0 != 0) {
    while (1) {
      switch (3) {
      case 3: 
      warn((char *)"pipe(): %m\n");
      break;
      default: 
      debug(1, (char *)"pipe(): %m\n");
      }
      break;
    }
    free((void *)server);
    return ((struct mdnsd *)((void *)0));
  }
  server->sockfd = create_recv_sock();
  if (server->sockfd < 0) {
    while (1) {
      switch (3) {
      case 3: 
      warn((char *)"unable to create recv socket");
      break;
      default: 
      debug(1, (char *)"unable to create recv socket");
      }
      break;
    }
    free((void *)server);
    return ((struct mdnsd *)((void *)0));
  }
  pthread_mutex_init(& server->data_lock, (pthread_mutexattr_t const   *)((void *)0));
  pthread_attr_init(& attr);
  pthread_attr_setdetachstate(& attr, 1);
  tmp___1 = pthread_create((pthread_t * __restrict  )(& tid), (pthread_attr_t const   * __restrict  )(& attr),
                           (void *(*)(void * ))(& main_loop), (void * __restrict  )((void *)server));
  if (tmp___1 != 0) {
    pthread_mutex_destroy(& server->data_lock);
    free((void *)server);
    return ((struct mdnsd *)((void *)0));
  }
  return (server);
}
}
void mdnsd_stop(struct mdnsd *s ) 
{ 
  struct timespec ts ;

  {
  if (! ((unsigned long )s != (unsigned long )((void *)0))) {
    __assert_fail("s != NULL", "tinysvcmdns.c", 1651U, "mdnsd_stop");
  }
  ts.tv_sec = (__time_t )0;
  ts.tv_nsec = (__syscall_slong_t )500000000;
  s->stop_flag = 1;
  write_pipe(s->notify_pipe[1], (char *)".", 1);
  while (s->stop_flag != 2) {
    nanosleep((struct timespec  const  *)(& ts), (struct timespec *)((void *)0));
  }
  close_pipe(s->notify_pipe[0]);
  close_pipe(s->notify_pipe[1]);
  pthread_mutex_destroy(& s->data_lock);
  rr_group_destroy(s->group);
  rr_list_destroy(s->announce, (char)0);
  rr_list_destroy(s->services, (char)0);
  if (s->hostname) {
    free((void *)s->hostname);
  }
  free((void *)s);
  return;
}
}
#pragma merger("0","/tmp/cil-aLca8Tad.i","-O2,-Wall")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt)(int ___argc ,
                                                                                     char * const  *___argv ,
                                                                                     char const   *__shortopts ) ;
extern void ao_initialize(void) ;
extern void ao_shutdown(void) ;
extern int ao_append_option(ao_option **options , char const   *key , char const   *value ) ;
extern ao_device *ao_open_live(int driver_id , ao_sample_format *format , ao_option *option ) ;
extern int ao_play(ao_device *device , char *output_samples , uint_32 num_bytes ) ;
extern int ao_close(ao_device *device ) ;
extern int ao_driver_id(char const   *short_name ) ;
extern int ao_default_driver_id(void) ;
ao_device *dev  =    (ao_device *)((void *)0);
static void help___1(void) 
{ 


  {
  printf((char const   * __restrict  )"    -d driver           set the output driver\n    -o name=value       set an arbitrary ao option\n    -i id               shorthand for -o id=<id>\n    -n name             shorthand for -o dev=<name> -o dsp=<name>\n");
  return;
}
}
static int init___1(int argc , char **argv ) 
{ 
  int driver ;
  int tmp ;
  ao_option *ao_opts ;
  int opt ;
  char *mid ;
  ao_sample_format fmt ;
  int tmp___0 ;

  {
  ao_initialize();
  tmp = ao_default_driver_id();
  driver = tmp;
  ao_opts = (ao_option *)((void *)0);
  optind = 1;
  argv --;
  argc ++;
  while (1) {
    opt = getopt(argc, (char * const  *)argv, "d:i:n:o:");
    if (! (opt > 0)) {
      break;
    }
    switch (opt) {
    case 100: 
    driver = ao_driver_id((char const   *)optarg);
    if (driver < 0) {
      die((char *)"could not find ao driver %s", optarg);
    }
    break;
    case 105: 
    ao_append_option(& ao_opts, "id", (char const   *)optarg);
    break;
    case 110: 
    ao_append_option(& ao_opts, "dev", (char const   *)optarg);
    ao_append_option(& ao_opts, "dsp", (char const   *)optarg);
    break;
    case 111: 
    mid = strchr((char const   *)optarg, '=');
    if (! mid) {
      die((char *)"Expected an = in audio option %s", optarg);
    }
    *mid = (char)0;
    ao_append_option(& ao_opts, (char const   *)optarg, (char const   *)(mid + 1));
    break;
    default: 
    help___1();
    die((char *)"Invalid audio option -%c specified", opt);
    }
  }
  if (optind < argc) {
    die((char *)"Invalid audio argument: %s", *(argv + optind));
  }
  memset((void *)(& fmt), 0, sizeof(fmt));
  fmt.bits = 16;
  fmt.rate = 44100;
  fmt.channels = 2;
  fmt.byte_format = 4;
  dev = ao_open_live(driver, & fmt, ao_opts);
  if (dev) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return (tmp___0);
}
}
static void deinit___1(void) 
{ 


  {
  if (dev) {
    ao_close(dev);
  }
  dev = (ao_device *)((void *)0);
  ao_shutdown();
  return;
}
}
static void start___1(int sample_rate ) 
{ 


  {
  if (sample_rate != 44100) {
    die((char *)"unexpected sample rate!");
  }
  return;
}
}
static void play___1(short *buf , int samples ) 
{ 


  {
  ao_play(dev, (char *)buf, (uint_32 )(samples * 4));
  return;
}
}
static void stop___1(void) 
{ 


  {
  return;
}
}
audio_output audio_ao  = 
     {& help___1, (char *)"ao", & init___1, & deinit___1, & start___1, & play___1, & stop___1,
    (void (*)(double vol ))((void *)0)};
#pragma merger("0","/tmp/cil-0aLZEs7n.i","-O2,-Wall")
extern pa_simple *pa_simple_new(char const   *server , char const   *name , pa_stream_direction_t dir ,
                                char const   *dev , char const   *stream_name , pa_sample_spec const   *ss ,
                                pa_channel_map const   *map , pa_buffer_attr const   *attr ,
                                int *error ) ;
extern void pa_simple_free(pa_simple *s ) ;
extern int pa_simple_write(pa_simple *s , void const   *data , size_t bytes , int *error ) ;
extern int pa_simple_drain(pa_simple *s , int *error ) ;
extern char const   *pa_strerror(int error ) ;
static pa_simple *pa_dev  =    (pa_simple *)((void *)0);
static int pa_error  ;
static void help___2(void) 
{ 


  {
  printf((char const   * __restrict  )"    -a server           set the server name\n    -s sink             set the output sink\n    -n name             set the application name, as seen by PulseAudio\n                            defaults to the access point name\n");
  return;
}
}
static int init___2(int argc , char **argv ) ;
static struct pa_sample_spec  const  ss  =    {(pa_sample_format_t )3, (uint32_t )44100, (uint8_t )2};
static int init___2(int argc , char **argv ) 
{ 
  char *pa_server ;
  char *pa_sink ;
  char *pa_appname ;
  int opt ;
  char const   *tmp ;

  {
  pa_server = (char *)((void *)0);
  pa_sink = (char *)((void *)0);
  pa_appname = config.apname;
  optind = 1;
  argv --;
  argc ++;
  while (1) {
    opt = getopt(argc, (char * const  *)argv, "a:s:n:");
    if (! (opt > 0)) {
      break;
    }
    switch (opt) {
    case 97: 
    pa_server = optarg;
    break;
    case 115: 
    pa_sink = optarg;
    break;
    case 110: 
    pa_appname = optarg;
    break;
    default: 
    help___2();
    die((char *)"Invalid audio option -%c specified", opt);
    }
  }
  if (optind < argc) {
    die((char *)"Invalid audio argument: %s", *(argv + optind));
  }
  pa_dev = pa_simple_new((char const   *)pa_server, (char const   *)pa_appname, (pa_stream_direction_t )1,
                         (char const   *)pa_sink, "Shairport Stream", & ss, (pa_channel_map const   *)((void *)0),
                         (pa_buffer_attr const   *)((void *)0), & pa_error);
  if (! pa_dev) {
    tmp = pa_strerror(pa_error);
    die((char *)"Could not connect to pulseaudio server: %s", tmp);
  }
  return (0);
}
}
static void deinit___2(void) 
{ 


  {
  if (pa_dev) {
    pa_simple_free(pa_dev);
  }
  pa_dev = (pa_simple *)((void *)0);
  return;
}
}
static void start___2(int sample_rate ) 
{ 


  {
  if (sample_rate != 44100) {
    die((char *)"unexpected sample rate!");
  }
  return;
}
}
static void play___2(short *buf , int samples ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  tmp___0 = pa_simple_write(pa_dev, (void const   *)((char *)buf), (size_t )samples * 4UL,
                            & pa_error);
  if (tmp___0 < 0) {
    tmp = pa_strerror(pa_error);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"audio_pulse.c: pa_simple_write() failed: %s\n",
            tmp);
  }
  return;
}
}
static void stop___2(void) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  tmp___0 = pa_simple_drain(pa_dev, & pa_error);
  if (tmp___0 < 0) {
    tmp = pa_strerror(pa_error);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"audio_pulse.c: pa_simple_drain() failed: %s\n",
            tmp);
  }
  return;
}
}
audio_output audio_pulse  = 
     {& help___2, (char *)"pulse", & init___2, & deinit___2, & start___2, & play___2,
    & stop___2, (void (*)(double vol ))((void *)0)};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-ewAo5f6W.i","-O2,-Wall")
extern char const   *snd_strerror(int errnum ) ;
extern int snd_pcm_open(snd_pcm_t **pcm , char const   *name , snd_pcm_stream_t stream ,
                        int mode ) ;
extern int snd_pcm_close(snd_pcm_t *pcm ) ;
extern int snd_pcm_hw_params(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ) ;
extern int snd_pcm_drain(snd_pcm_t *pcm ) ;
extern snd_pcm_sframes_t snd_pcm_writei(snd_pcm_t *pcm , void const   *buffer , snd_pcm_uframes_t size ) ;
extern int snd_pcm_recover(snd_pcm_t *pcm , int err , int silent ) ;
extern int snd_pcm_hw_params_any(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ) ;
extern size_t snd_pcm_hw_params_sizeof(void) ;
extern int snd_pcm_hw_params_set_access(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        snd_pcm_access_t _access ) ;
extern int snd_pcm_hw_params_set_format(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        snd_pcm_format_t val ) ;
extern int snd_pcm_hw_params_set_channels(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                          unsigned int val ) ;
extern int snd_pcm_hw_params_set_rate_near(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                           unsigned int *val , int *dir ) ;
extern int snd_pcm_hw_params_set_period_size_near(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                                  snd_pcm_uframes_t *val , int *dir ) ;
extern int snd_mixer_open(snd_mixer_t **mixer , int mode ) ;
extern int snd_mixer_close(snd_mixer_t *mixer ) ;
extern int snd_mixer_attach(snd_mixer_t *mixer , char const   *name ) ;
extern int snd_mixer_load(snd_mixer_t *mixer ) ;
extern int snd_mixer_selem_register(snd_mixer_t *mixer , struct snd_mixer_selem_regopt *options ,
                                    snd_mixer_class_t **classp ) ;
extern snd_mixer_elem_t *snd_mixer_find_selem(snd_mixer_t *mixer , snd_mixer_selem_id_t const   *id ) ;
extern int snd_mixer_selem_set_playback_volume_all(snd_mixer_elem_t *elem , long value ) ;
extern int snd_mixer_selem_get_playback_volume_range(snd_mixer_elem_t *elem , long *min ,
                                                     long *max ) ;
extern size_t snd_mixer_selem_id_sizeof(void) ;
extern void snd_mixer_selem_id_set_name(snd_mixer_selem_id_t *obj , char const   *val ) ;
extern void snd_mixer_selem_id_set_index(snd_mixer_selem_id_t *obj , unsigned int val ) ;
static void help___3(void) ;
static int init___3(int argc , char **argv ) ;
static void deinit___3(void) ;
static void start___3(int sample_rate ) ;
static void play___3(short *buf , int samples ) ;
static void stop___3(void) ;
static void volume___0(double vol ) ;
audio_output audio_alsa  = 
     {& help___3, (char *)"alsa", & init___3, & deinit___3, & start___3, & play___3,
    & stop___3, (void (*)(double vol ))((void *)0)};
static snd_pcm_t *alsa_handle  =    (snd_pcm_t *)((void *)0);
static snd_pcm_hw_params_t *alsa_params  =    (snd_pcm_hw_params_t *)((void *)0);
static snd_mixer_t *alsa_mix_handle  =    (snd_mixer_t *)((void *)0);
static snd_mixer_elem_t *alsa_mix_elem  =    (snd_mixer_elem_t *)((void *)0);
static snd_mixer_selem_id_t *alsa_mix_sid  =    (snd_mixer_selem_id_t *)((void *)0);
static long alsa_mix_minv  ;
static long alsa_mix_range  ;
static char *alsa_out_dev  =    (char *)"default";
static char *alsa_mix_dev  =    (char *)((void *)0);
static char *alsa_mix_ctrl  =    (char *)"Master";
static int alsa_mix_index  =    0;
static void help___3(void) 
{ 


  {
  printf((char const   * __restrict  )"    -d output-device    set the output device [default*|...]\n    -t mixer-type       set the mixer type [software*|hardware]\n    -m mixer-device     set the mixer device [\'output-device\'*|...]\n    -c mixer-control    set the mixer control [Master*|...]\n    -i mixer-index      set the mixer index [0*|...]\n    *) default option\n");
  return;
}
}
static int init___3(int argc , char **argv ) 
{ 
  int hardware_mixer ;
  int opt ;
  int tmp ;
  long tmp___0 ;
  int ret ;
  long alsa_mix_maxv ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  hardware_mixer = 0;
  optind = 1;
  argv --;
  argc ++;
  while (1) {
    opt = getopt(argc, (char * const  *)argv, "d:t:m:c:i:");
    if (! (opt > 0)) {
      break;
    }
    switch (opt) {
    case 100: 
    alsa_out_dev = optarg;
    break;
    case 116: 
    tmp = strcmp((char const   *)optarg, "hardware");
    if (tmp == 0) {
      hardware_mixer = 1;
    }
    break;
    case 109: 
    alsa_mix_dev = optarg;
    break;
    case 99: 
    alsa_mix_ctrl = optarg;
    break;
    case 105: 
    tmp___0 = strtol((char const   * __restrict  )optarg, (char ** __restrict  )((void *)0),
                     10);
    alsa_mix_index = (int )tmp___0;
    break;
    default: 
    help___3();
    die((char *)"Invalid audio option -%c specified", opt);
    }
  }
  if (optind < argc) {
    die((char *)"Invalid audio argument: %s", *(argv + optind));
  }
  if (! hardware_mixer) {
    return (0);
  }
  if ((unsigned long )alsa_mix_dev == (unsigned long )((void *)0)) {
    alsa_mix_dev = alsa_out_dev;
  }
  audio_alsa.volume = & volume___0;
  ret = 0;
  while (1) {
    tmp___1 = snd_mixer_selem_id_sizeof();
    tmp___2 = __builtin_alloca(tmp___1);
    alsa_mix_sid = (snd_mixer_selem_id_t *)tmp___2;
    tmp___3 = snd_mixer_selem_id_sizeof();
    memset((void *)alsa_mix_sid, 0, tmp___3);
    break;
  }
  snd_mixer_selem_id_set_index(alsa_mix_sid, (unsigned int )alsa_mix_index);
  snd_mixer_selem_id_set_name(alsa_mix_sid, (char const   *)alsa_mix_ctrl);
  tmp___4 = snd_mixer_open(& alsa_mix_handle, 0);
  if (tmp___4 < 0) {
    die((char *)"Failed to open mixer");
  }
  tmp___5 = snd_mixer_attach(alsa_mix_handle, (char const   *)alsa_mix_dev);
  if (tmp___5 < 0) {
    die((char *)"Failed to attach mixer");
  }
  tmp___6 = snd_mixer_selem_register(alsa_mix_handle, (struct snd_mixer_selem_regopt *)((void *)0),
                                     (snd_mixer_class_t **)((void *)0));
  if (tmp___6 < 0) {
    die((char *)"Failed to register mixer element");
  }
  ret = snd_mixer_load(alsa_mix_handle);
  if (ret < 0) {
    die((char *)"Failed to load mixer element");
  }
  alsa_mix_elem = snd_mixer_find_selem(alsa_mix_handle, (snd_mixer_selem_id_t const   *)alsa_mix_sid);
  if (! alsa_mix_elem) {
    die((char *)"Failed to find mixer element");
  }
  snd_mixer_selem_get_playback_volume_range(alsa_mix_elem, & alsa_mix_minv, & alsa_mix_maxv);
  alsa_mix_range = alsa_mix_maxv - alsa_mix_minv;
  return (0);
}
}
static void deinit___3(void) 
{ 


  {
  stop___3();
  if (alsa_mix_handle) {
    snd_mixer_close(alsa_mix_handle);
  }
  return;
}
}
static void start___3(int sample_rate ) 
{ 
  int ret ;
  int dir ;
  snd_pcm_uframes_t frames ;
  char const   *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;

  {
  if (sample_rate != 44100) {
    die((char *)"Unexpected sample rate!");
  }
  dir = 0;
  frames = (snd_pcm_uframes_t )64;
  ret = snd_pcm_open(& alsa_handle, (char const   *)alsa_out_dev, (snd_pcm_stream_t )0,
                     0);
  if (ret < 0) {
    tmp = snd_strerror(ret);
    die((char *)"Alsa initialization failed: unable to open pcm device: %s\n", tmp);
  }
  while (1) {
    tmp___0 = snd_pcm_hw_params_sizeof();
    tmp___1 = __builtin_alloca(tmp___0);
    alsa_params = (snd_pcm_hw_params_t *)tmp___1;
    tmp___2 = snd_pcm_hw_params_sizeof();
    memset((void *)alsa_params, 0, tmp___2);
    break;
  }
  snd_pcm_hw_params_any(alsa_handle, alsa_params);
  snd_pcm_hw_params_set_access(alsa_handle, alsa_params, (snd_pcm_access_t )3);
  snd_pcm_hw_params_set_format(alsa_handle, alsa_params, (snd_pcm_format_t )2);
  snd_pcm_hw_params_set_channels(alsa_handle, alsa_params, 2U);
  snd_pcm_hw_params_set_rate_near(alsa_handle, alsa_params, (unsigned int *)(& sample_rate),
                                  & dir);
  snd_pcm_hw_params_set_period_size_near(alsa_handle, alsa_params, & frames, & dir);
  ret = snd_pcm_hw_params(alsa_handle, alsa_params);
  if (ret < 0) {
    tmp___3 = snd_strerror(ret);
    die((char *)"unable to set hw parameters: %s\n", tmp___3);
  }
  return;
}
}
static void play___3(short *buf , int samples ) 
{ 
  int err ;
  snd_pcm_sframes_t tmp ;
  char const   *tmp___0 ;

  {
  tmp = snd_pcm_writei(alsa_handle, (void const   *)((char *)buf), (snd_pcm_uframes_t )samples);
  err = (int )tmp;
  if (err < 0) {
    err = snd_pcm_recover(alsa_handle, err, 0);
  }
  if (err < 0) {
    tmp___0 = snd_strerror(err);
    die((char *)"Failed to write to PCM device: %s\n", tmp___0);
  }
  return;
}
}
static void stop___3(void) 
{ 


  {
  if (alsa_handle) {
    snd_pcm_drain(alsa_handle);
    snd_pcm_close(alsa_handle);
    alsa_handle = (snd_pcm_t *)((void *)0);
  }
  return;
}
}
static void volume___0(double vol ) 
{ 
  long alsa_volume ;
  int tmp ;

  {
  alsa_volume = (long )(vol * (double )alsa_mix_range + (double )alsa_mix_minv);
  tmp = snd_mixer_selem_set_playback_volume_all(alsa_mix_elem, alsa_volume);
  if (tmp != 0) {
    die((char *)"Failed to set playback volume");
  }
  return;
}
}
