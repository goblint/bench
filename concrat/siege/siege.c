/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef int __int32_t;
typedef long __off_t;
typedef long __off64_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef unsigned long pthread_t;
struct ARRAY_T ;
typedef struct ARRAY_T *ARRAY;
typedef void *array;
struct ARRAY_T {
   int index ;
   int length ;
   array *data ;
   void (*free)(void *v ) ;
};
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef long __ssize_t;
typedef __ssize_t ssize_t;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef unsigned int md5_uint32;
struct md5_ctx {
   md5_uint32 A ;
   md5_uint32 B ;
   md5_uint32 C ;
   md5_uint32 D ;
   md5_uint32 total[2] ;
   md5_uint32 buflen ;
   char buffer[128]  __attribute__((__aligned__(__alignof__(md5_uint32 )))) ;
};
enum __anonenum_BOOLEAN_54306505 {
    boolean_false = 0,
    boolean_true = 1
} ;
typedef enum __anonenum_BOOLEAN_54306505 BOOLEAN;
enum __anonenum_SCHEME_132615588 {
    UNSUPPORTED = 0,
    HTTP = 1,
    HTTPS = 2,
    FTP = 3,
    PROXY = 4
} ;
typedef enum __anonenum_SCHEME_132615588 SCHEME;
struct CREDS_T ;
typedef struct CREDS_T *CREDS;
struct AUTH_T ;
typedef struct AUTH_T *AUTH;
struct DIGEST_CRED ;
typedef struct DIGEST_CRED DCRED;
struct DIGEST_CHLG ;
typedef struct DIGEST_CHLG DCHLG;
enum __anonenum_LEVEL_649277070 {
    DEBUG = 0,
    WARNING = 1,
    ERROR = 2,
    FATAL = 3
} ;
typedef enum __anonenum_LEVEL_649277070 LEVEL;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef int __gwchar_t;
typedef unsigned int DES_LONG;
typedef unsigned char DES_cblock[8];
typedef unsigned char const_DES_cblock[8];
union __anonunion_ks_909163901 {
   DES_cblock cblock ;
   DES_LONG deslong[2] ;
};
struct DES_ks {
   union __anonunion_ks_909163901 ks[16] ;
};
typedef struct DES_ks DES_key_schedule;
struct MD4state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
typedef struct MD4state_st MD4_CTX;
enum __anonenum_STATE_768722769 {
    TYPE_N = 0,
    TYPE_1 = 1,
    TYPE_2 = 2,
    TYPE_3 = 3,
    TYPE_L = 4
} ;
typedef enum __anonenum_STATE_768722769 STATE;
struct __anonstruct_basic_352126815 {
   char *encode ;
};
struct __anonstruct_digest_352126816 {
   char *encode ;
};
struct __anonstruct_ntlm_516272236 {
   STATE state ;
   char *encode ;
   BOOLEAN ready ;
   unsigned char nonce[8] ;
};
struct __anonstruct_proxy_1015572126 {
   BOOLEAN required ;
   char *hostname ;
   int port ;
   char *encode ;
};
struct AUTH_T {
   ARRAY creds ;
   BOOLEAN okay ;
   struct __anonstruct_basic_352126815 basic ;
   struct __anonstruct_digest_352126816 digest ;
   struct __anonstruct_ntlm_516272236 ntlm ;
   struct __anonstruct_proxy_1015572126 proxy ;
   pthread_mutex_t lock ;
};
struct DIGEST_CRED {
   char *username ;
   char *password ;
   char *cnonce_value ;
   char *h_a1 ;
   char nc[9] ;
   unsigned int nc_value ;
};
struct DIGEST_CHLG {
   char *realm ;
   char *domain ;
   char *nonce ;
   char *opaque ;
   char *stale ;
   char *algorithm ;
   char *qop ;
};
enum __anonenum_KEY_HEADER_E_282889070 {
    REALM = 0,
    DOMAIN = 1,
    NONCE = 2,
    OPAQUE = 3,
    STALE = 4,
    ALGORITHM = 5,
    QOP = 6,
    UNKNOWN = 7
} ;
typedef enum __anonenum_KEY_HEADER_E_282889070 KEY_HEADER_E;
struct __anonstruct_KEYPARSER_335600686 {
   char const   *keyname ;
   KEY_HEADER_E keyval ;
};
typedef struct __anonstruct_KEYPARSER_335600686 KEYPARSER;
typedef long __clock_t;
typedef long __time_t;
typedef unsigned int __socklen_t;
typedef __clock_t clock_t;
typedef __time_t time_t;
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_236290450 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_958857993 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_958857992 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_958857993 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_236290450 __annonCompField1 ;
   union __anonunion____missing_field_name_958857992 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
typedef long __jmp_buf[8];
struct __anonstruct___cancel_jmp_buf_572769531 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
struct __anonstruct___pthread_unwind_buf_t_808729522 {
   struct __anonstruct___cancel_jmp_buf_572769531 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
typedef struct __anonstruct___pthread_unwind_buf_t_808729522  __attribute__((__aligned__)) __pthread_unwind_buf_t;
struct __jmp_buf_tag ;
typedef __socklen_t socklen_t;
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
struct URL_T ;
typedef struct URL_T *URL;
typedef int METHOD;
enum __anonenum_TYPE_82145593 {
    BASIC = 0,
    DIGEST = 1,
    NTLM = 2
} ;
typedef enum __anonenum_TYPE_82145593 TYPE;
struct HASH_T ;
typedef struct HASH_T *HASH;
struct COOKIES_T ;
typedef struct COOKIES_T *COOKIES;
struct __anonstruct_LINES_216488822 {
   int index ;
   char **line ;
};
typedef struct __anonstruct_LINES_216488822 LINES;
struct CONFIG {
   BOOLEAN logging ;
   BOOLEAN shlog ;
   int limit ;
   char *url ;
   char logfile[128] ;
   BOOLEAN verbose ;
   BOOLEAN quiet ;
   BOOLEAN parser ;
   BOOLEAN csv ;
   BOOLEAN fullurl ;
   BOOLEAN display ;
   BOOLEAN config ;
   BOOLEAN color ;
   int cusers ;
   float delay ;
   int timeout ;
   BOOLEAN bench ;
   BOOLEAN internet ;
   BOOLEAN timestamp ;
   int time ;
   int secs ;
   int reps ;
   char file[128] ;
   int length ;
   LINES *nomap ;
   BOOLEAN debug ;
   BOOLEAN chunked ;
   BOOLEAN unique ;
   BOOLEAN get ;
   BOOLEAN print ;
   BOOLEAN mark ;
   char *markstr ;
   int protocol ;
   COOKIES cookies ;
   char uagent[256] ;
   char encoding[256] ;
   char conttype[256] ;
   int bids ;
   AUTH auth ;
   BOOLEAN keepalive ;
   int signaled ;
   char extra[2048] ;
   BOOLEAN login ;
   char *loginurl ;
   ARRAY lurl ;
   int failures ;
   int failed ;
   BOOLEAN escape ;
   BOOLEAN expire ;
   BOOLEAN follow ;
   BOOLEAN zero_ok ;
   BOOLEAN spinner ;
   BOOLEAN cache ;
   char rc[256] ;
   int ssl_timeout ;
   char *ssl_cert ;
   char *ssl_key ;
   char *ssl_ciphers ;
   METHOD method ;
   BOOLEAN json_output ;
   pthread_cond_t cond ;
   pthread_mutex_t lock ;
};
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
struct x509_st ;
typedef struct x509_st X509;
struct ssl_st ;
typedef struct ssl_st SSL;
struct ssl_ctx_st ;
typedef struct ssl_ctx_st SSL_CTX;
struct ssl_method_st ;
typedef struct ssl_method_st SSL_METHOD;
struct PAGE_T ;
typedef struct PAGE_T *PAGE;
struct DATE_T ;
typedef struct DATE_T *DATE;
struct CACHE_T ;
typedef struct CACHE_T *CACHE;
enum __anonenum_S_STATUS_297285769 {
    S_CONNECTING = 1,
    S_READING = 2,
    S_WRITING = 4,
    S_DONE = 8
} ;
typedef enum __anonenum_S_STATUS_297285769 S_STATUS;
enum __anonenum_SDSET_930488899 {
    UNDEF = 0,
    READ = 1,
    WRITE = 2,
    RDWR = 3
} ;
typedef enum __anonenum_SDSET_930488899 SDSET;
struct __anonstruct_content_151561562 {
   int transfer ;
   size_t length ;
};
struct __anonstruct_connection_887606460 {
   int max ;
   int timeout ;
   int reuse ;
   int status ;
   int keepalive ;
   int tested ;
};
struct __anonstruct_type_192952330 {
   TYPE www ;
   TYPE proxy ;
};
struct __anonstruct_auth_1053230411 {
   DCHLG *wchlg ;
   DCRED *wcred ;
   int www ;
   DCHLG *pchlg ;
   DCRED *pcred ;
   int proxy ;
   struct __anonstruct_type_192952330 type ;
};
struct __anonstruct_ftp_768237192 {
   int code ;
   char host[64] ;
   int port ;
   size_t size ;
   BOOLEAN pasv ;
};
struct __anonstruct_CONN_573095640 {
   int sock ;
   S_STATUS status ;
   BOOLEAN encrypt ;
   SCHEME scheme ;
   PAGE page ;
   CACHE cache ;
   struct __anonstruct_content_151561562 content ;
   struct __anonstruct_connection_887606460 connection ;
   struct __anonstruct_auth_1053230411 auth ;
   SSL *ssl ;
   SSL_CTX *ctx ;
   SSL_METHOD const   *method ;
   X509 *cert ;
   size_t inbuffer ;
   int pos_ini ;
   char buffer[4096] ;
   char chkbuf[1024] ;
   struct pollfd pfd[1] ;
   fd_set *ws ;
   fd_set *rs ;
   SDSET state ;
   struct __anonstruct_ftp_768237192 ftp ;
};
typedef struct __anonstruct_CONN_573095640 CONN;
struct RESPONSE_T ;
typedef struct RESPONSE_T *RESPONSE;
struct BROWSER_T ;
typedef struct BROWSER_T *BROWSER;
struct __anonstruct_bids_1053230412 {
   int www ;
   int proxy ;
};
struct __anonstruct_type_1053230413 {
   TYPE www ;
   TYPE proxy ;
};
struct __anonstruct_auth_185766227 {
   DCHLG *wchlg ;
   DCRED *wcred ;
   int www ;
   DCHLG *pchlg ;
   DCRED *pcred ;
   int proxy ;
   struct __anonstruct_bids_1053230412 bids ;
   struct __anonstruct_type_1053230413 type ;
};
struct BROWSER_T {
   int id ;
   size_t tid ;
   ARRAY urls ;
   ARRAY parts ;
   HASH cookies ;
   CONN *conn ;
   int type ;
   int state ;
   float total ;
   float available ;
   float lowest ;
   float highest ;
   float elapsed ;
   float time ;
   float himark ;
   float lomark ;
   clock_t start ;
   clock_t stop ;
   struct tms t_start ;
   struct tms t_stop ;
   struct __anonstruct_auth_185766227 auth ;
   unsigned int code ;
   unsigned int count ;
   unsigned int okay ;
   unsigned int fail ;
   unsigned long hits ;
   unsigned long long bytes ;
   unsigned int rseed ;
};
enum __anonenum_CTYPE_619574907 {
    C_ETAG = 0,
    C_LAST = 1,
    C_EXPIRES = 2
} ;
typedef enum __anonenum_CTYPE_619574907 CTYPE;
struct CACHE_T {
   HASH cache ;
   int hlen ;
   char *header ;
};
struct COOKIE_T ;
typedef struct COOKIE_T *COOKIE;
struct COOKIE_T {
   char *name ;
   char *value ;
   char *domain ;
   char *path ;
   time_t expires ;
   char *expstr ;
   char *none ;
   char *string ;
   BOOLEAN session ;
   BOOLEAN secure ;
};
struct NODE {
   size_t threadID ;
   COOKIE cookie ;
   struct NODE *next ;
};
typedef struct NODE NODE;
struct COOKIES_T {
   NODE *head ;
   size_t size ;
   char *file ;
};
struct CREDS_T {
   SCHEME scheme ;
   char *username ;
   char *password ;
   char *realm ;
};
typedef long __suseconds_t;
typedef long __syscall_slong_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
struct work {
   void (*routine)() ;
   void *arg ;
   struct work *next ;
};
typedef struct work WORK;
struct CREW_T ;
typedef struct CREW_T *CREW;
struct CREW_T {
   int size ;
   int maxsize ;
   int cursize ;
   int total ;
   WORK *head ;
   WORK *tail ;
   BOOLEAN block ;
   BOOLEAN closed ;
   BOOLEAN shutdown ;
   pthread_t *threads ;
   pthread_mutex_t lock ;
   pthread_cond_t not_empty ;
   pthread_cond_t not_full ;
   pthread_cond_t empty ;
};
struct DATA_T ;
typedef struct DATA_T *DATA;
struct DATA_T {
   float total ;
   float available ;
   float lowest ;
   float highest ;
   float elapsed ;
   clock_t start ;
   clock_t stop ;
   struct tms t_start ;
   struct tms t_stop ;
   unsigned int code ;
   unsigned int count ;
   unsigned int okay ;
   unsigned int fail ;
   unsigned long long bytes ;
};
enum assume {
    DATE_MDAY = 0,
    DATE_YEAR = 1,
    DATE_TIME = 2
} ;
struct tzinfo {
   char const   *name ;
   int offset ;
};
struct DATE_T {
   char *date ;
   char *etag ;
   char *head ;
   struct tm *tm ;
   struct tm safe ;
};
typedef __gnuc_va_list va_list___0;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
typedef unsigned int __uint32_t;
typedef __uint32_t u_int32_t;
struct NODE___0 {
   char *key ;
   void *val ;
   struct NODE___0 *next ;
};
typedef struct NODE___0 NODE___0;
struct HASH_T {
   int size ;
   int entries ;
   int index ;
   NODE___0 **table ;
   void (*free)(void *v ) ;
};
enum __anonenum_HTTP_TE_732632201 {
    NONE = 1,
    CHUNKED = 2,
    TRAILER = 4
} ;
typedef enum __anonenum_HTTP_TE_732632201 HTTP_TE;
enum __anonenum_HTTP_CE_872574738 {
    COMPRESS = 1,
    DEFLATE = 2,
    GZIP = 4,
    BZIP2 = 8
} ;
typedef enum __anonenum_HTTP_CE_872574738 HTTP_CE;
typedef unsigned char Byte;
typedef unsigned int uInt;
typedef unsigned long uLong;
typedef Byte Bytef;
typedef void *voidpf;
struct internal_state ;
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
typedef struct z_stream_s z_stream;
typedef z_stream *z_streamp;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct ContentType {
   char *ext ;
   BOOLEAN ascii ;
   char *type ;
};
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
typedef unsigned long md5_uintptr;
typedef __builtin_va_list va_list;
struct PAGE_T {
   char *buf ;
   size_t len ;
   size_t size ;
};
enum __anonenum_HTTP_CONN_945596102 {
    CLOSE = 1,
    KEEPALIVE = 2,
    METER = 4
} ;
typedef enum __anonenum_HTTP_CONN_945596102 HTTP_CONN;
struct __anonstruct_realm_476363767 {
   char *www ;
   char *proxy ;
};
struct __anonstruct_challenge_476363768 {
   char *www ;
   char *proxy ;
};
struct __anonstruct_type_192952330___0 {
   TYPE www ;
   TYPE proxy ;
};
struct __anonstruct_auth_478522335 {
   int www ;
   int proxy ;
   struct __anonstruct_realm_476363767 realm ;
   struct __anonstruct_challenge_476363768 challenge ;
   struct __anonstruct_type_192952330___0 type ;
};
struct RESPONSE_T {
   HASH headers ;
   struct __anonstruct_auth_478522335 auth ;
   BOOLEAN cached ;
};
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
typedef unsigned long nfds_t;
typedef unsigned long __uint64_t;
typedef __uint64_t uint64_t;
struct ossl_init_settings_st ;
typedef struct ossl_init_settings_st OPENSSL_INIT_SETTINGS;
struct URL_T {
   int ID ;
   char *url ;
   SCHEME scheme ;
   METHOD method ;
   char *username ;
   char *password ;
   char *hostname ;
   int port ;
   char *path ;
   char *file ;
   char *params ;
   BOOLEAN hasparams ;
   char *query ;
   char *frag ;
   char *request ;
   size_t postlen ;
   char *postdata ;
   char *posttemp ;
   char *conttype ;
   BOOLEAN cached ;
   BOOLEAN redir ;
};
enum copy_method {
    CM_DECODE = 0,
    CM_ENCODE = 1,
    CM_PASSTHROUGH = 2
} ;
typedef unsigned int __useconds_t;
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-M6sxRBHc.i","-W,-Wall,-Wunused-value,-g,-O2")
extern FILE *stdin ;
extern FILE *stdout ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
size_t ARRAYSIZE ;
ARRAY new_array(void) ;
ARRAY array_destroy(ARRAY this ) ;
ARRAY array_destroyer(ARRAY this , void (*m)(void *v ) ) ;
void array_set_destroyer(ARRAY this , void (*m)(void *v ) ) ;
void array_push(ARRAY this , void *thing ) ;
void array_npush(ARRAY this , void *thing , size_t len ) ;
void *array_get(ARRAY this , int index___0 ) ;
void *array_remove(ARRAY this , int index___0 ) ;
void *array_pop(ARRAY this ) ;
void *array_next(ARRAY this ) ;
void *array_prev(ARRAY this ) ;
size_t array_length(ARRAY this ) ;
char *array_to_string(ARRAY this ) ;
void *xmalloc(size_t size ) ;
void *xcalloc(size_t num , size_t size ) ;
void xfree(void *ptr ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
size_t ARRAYSIZE  =    sizeof(struct ARRAY_T );
ARRAY new_array(void) 
{ 
  ARRAY this ;
  void *tmp ;

  {
  tmp = xcalloc(sizeof(struct ARRAY_T ), (size_t )1);
  this = (ARRAY )tmp;
  this->index = -1;
  this->length = 0;
  this->free = (void (*)(void *v ))((void *)0);
  return (this);
}
}
ARRAY array_destroy(ARRAY this ) 
{ 
  int i ;

  {
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    return ((ARRAY )((void *)0));
  }
  if ((unsigned long )this->free == (unsigned long )((void *)0)) {
    this->free = & free;
  }
  i = 0;
  while (i < this->length) {
    (*(this->free))(*(this->data + i));
    i ++;
  }
  xfree((void *)this->data);
  xfree((void *)this);
  this = (ARRAY )((void *)0);
  return (this);
}
}
ARRAY array_destroyer(ARRAY this , void (*m)(void *v ) ) 
{ 
  ARRAY tmp ;

  {
  this->free = m;
  tmp = array_destroy(this);
  return (tmp);
}
}
void array_set_destroyer(ARRAY this , void (*m)(void *v ) ) 
{ 


  {
  this->free = m;
  return;
}
}
void array_push(ARRAY this , void *thing ) 
{ 
  int len ;
  size_t tmp ;

  {
  len = 0;
  if ((unsigned long )thing == (unsigned long )((void *)0)) {
    return;
  }
  tmp = strlen((char const   *)thing);
  len = (int )(tmp + 1UL);
  array_npush(this, thing, (size_t )len);
  return;
}
}
void array_npush(ARRAY this , void *thing , size_t len ) 
{ 
  array arr ;
  void *tmp ;
  void *tmp___0 ;

  {
  if ((unsigned long )thing == (unsigned long )((void *)0)) {
    return;
  }
  if ((unsigned long )this->data == (unsigned long )((void *)0)) {
    if (this->length == 0) {
      tmp = xmalloc(sizeof(array ));
      this->data = (array *)tmp;
    } else {
      tmp___0 = realloc((void *)this->data, (unsigned long )(this->length + 1) * sizeof(array ));
      this->data = (array *)tmp___0;
    }
  } else {
    tmp___0 = realloc((void *)this->data, (unsigned long )(this->length + 1) * sizeof(array ));
    this->data = (array *)tmp___0;
  }
  arr = xmalloc(len + 1UL);
  memset(arr, '\000', len + 1UL);
  memcpy((void * __restrict  )arr, (void const   * __restrict  )thing, len);
  *(this->data + this->length) = arr;
  (this->length) ++;
  return;
}
}
void *array_get(ARRAY this , int index___0 ) 
{ 


  {
  if (index___0 > this->length) {
    return ((void *)0);
  }
  return (*(this->data + index___0));
}
}
void *array_remove(ARRAY this , int index___0 ) 
{ 
  int length ;
  array arr ;

  {
  length = 0;
  if (index___0 > this->length) {
    return ((void *)0);
  }
  arr = *(this->data + index___0);
  (this->length) --;
  length = this->length;
  while (index___0 < length) {
    *(this->data + index___0) = *(this->data + (index___0 + 1));
    index___0 ++;
  }
  return (arr);
}
}
void *array_pop(ARRAY this ) 
{ 
  array tmp ;

  {
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    return ((void *)0);
  }
  if (this->length) {
    (this->length) --;
    tmp = *(this->data + this->length);
  } else {
    tmp = (void *)0;
  }
  return (tmp);
}
}
void *array_next(ARRAY this ) 
{ 


  {
  (this->index) ++;
  return (*(this->data + this->index % this->length));
}
}
void *array_prev(ARRAY this ) 
{ 


  {
  (this->index) --;
  return (*(this->data + (this->index + (this->length - 1)) % this->length));
}
}
size_t array_length(ARRAY this ) 
{ 


  {
  return ((size_t )this->length);
}
}
char *array_to_string(ARRAY this ) 
{ 
  size_t i ;
  int len ;
  char *str ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
  len = 0;
  if (this->length == 0) {
    return ((char *)"NULL");
  }
  i = (size_t )0;
  while (1) {
    tmp___1 = array_length(this);
    if (! (i < tmp___1)) {
      break;
    }
    tmp = array_get(this, (int )i);
    tmp___0 = strlen((char const   *)tmp);
    len = (int )((size_t )len + (tmp___0 + 3UL));
    i ++;
  }
  tmp___2 = malloc((size_t )(len + 1));
  str = (char *)tmp___2;
  memset((void *)str, '\000', (size_t )(len + 1));
  i = (size_t )0;
  while (1) {
    tmp___5 = array_length(this);
    if (! (i < tmp___5)) {
      break;
    }
    strcat((char * __restrict  )str, (char const   * __restrict  )"[");
    tmp___3 = array_get(this, (int )i);
    strcat((char * __restrict  )str, (char const   * __restrict  )tmp___3);
    tmp___4 = array_length(this);
    if (i == tmp___4 - 1UL) {
      strcat((char * __restrict  )str, (char const   * __restrict  )"]");
    } else {
      strcat((char * __restrict  )str, (char const   * __restrict  )"],");
    }
    i ++;
  }
  return (str);
}
}
void array_print(ARRAY this ) 
{ 
  char *tmp ;

  {
  tmp = array_to_string(this);
  printf((char const   * __restrict  )"%s\n", tmp);
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-UqNIVB6a.i","-W,-Wall,-Wunused-value,-g,-O2")
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
int base64_encode(void const   *data , int size , char **str ) ;
int base64_decode(char const   *str , void *data ) ;
void md5_init_ctx(struct md5_ctx *ctx ) ;
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) ;
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
size_t CREDSIZE ;
SCHEME creds_get_scheme(CREDS this ) ;
char *creds_get_username(CREDS this ) ;
char *creds_get_password(CREDS this ) ;
char *creds_get_realm(CREDS this ) ;
size_t AUTHSIZE ;
AUTH new_auth(void) ;
AUTH auth_destroy(AUTH this ) ;
void auth_add(AUTH this , CREDS creds ) ;
void auth_display(AUTH this , SCHEME scheme ) ;
char *auth_get_basic_header(AUTH this , SCHEME scheme ) ;
BOOLEAN auth_set_basic_header(AUTH this , SCHEME scheme , char *realm ) ;
char *auth_get_ntlm_header(AUTH this , SCHEME scheme ) ;
BOOLEAN auth_set_ntlm_header(AUTH this , SCHEME scheme , char *header , char *realm ) ;
char *auth_get_digest_header(AUTH this , SCHEME scheme , DCHLG *chlg , DCRED *cred ,
                             char const   *method___0 , char const   *uri ) ;
BOOLEAN auth_set_digest_header(AUTH this , DCHLG **chlg , DCRED **cred , unsigned int *rand___0 ,
                               char *realm , char *str ) ;
BOOLEAN auth_get_proxy_required(AUTH this ) ;
void auth_set_proxy_required(AUTH this , BOOLEAN required ) ;
char *auth_get_proxy_host(AUTH this ) ;
void auth_set_proxy_host(AUTH this , char *host ) ;
int auth_get_proxy_port(AUTH this ) ;
void auth_set_proxy_port(AUTH this , int port ) ;
char *auth_get_ftp_username(AUTH this , char *realm ) ;
char *auth_get_ftp_password(AUTH this , char *realm ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
int pthread_rand_np(unsigned int *ctx ) ;
BOOLEAN strmatch(char *option , char *param ) ;
char *xstrdup(char const   *str ) ;
char *xstrcat(char const   *arg1  , ...) ;
void *xrealloc(void *ptr , size_t size ) ;
void NOTIFY(LEVEL L , char const   *fmt  , ...) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __strtol_internal)(char const   * __restrict  __nptr ,
                                                                                               char ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                      char ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  tmp = __strtol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __strtoul_internal)(char const   * __restrict  __nptr ,
                                                                                                         char ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                       char ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __strtoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __wcstol_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                               __gwchar_t ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                      __gwchar_t ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  tmp = __wcstol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __wcstoul_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                                         __gwchar_t ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                       __gwchar_t ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __wcstoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern void DES_ecb_encrypt(const_DES_cblock *input , DES_cblock *output , DES_key_schedule *ks ,
                            int enc ) ;
extern void DES_set_odd_parity(DES_cblock *key ) ;
extern int DES_set_key(const_DES_cblock *key , DES_key_schedule *schedule ) ;
extern int MD4_Init(MD4_CTX *c ) ;
extern int MD4_Update(MD4_CTX *c , void const   *data , size_t len ) ;
extern int MD4_Final(unsigned char *md , MD4_CTX *c ) ;
size_t AUTHSIZE  =    sizeof(struct AUTH_T );
static BOOLEAN __basic_header(AUTH this , SCHEME scheme , CREDS creds ) ;
static BOOLEAN __ntlm_header(AUTH this , SCHEME scheme , char const   *header , CREDS creds ) ;
static DCHLG *__digest_challenge(char const   *challenge ) ;
static DCRED *__digest_credentials(CREDS creds , unsigned int *randseed ) ;
static KEY_HEADER_E __get_keyval(char const   *key ) ;
static char *__get_random_string(size_t length , unsigned int *randseed ) ;
static char *__get_h_a1(DCHLG const   *chlg , DCRED *cred , char const   *nonce_value ) ;
static char *__get_md5_str(char const   *buf ) ;
static BOOLEAN __str_list_contains(char const   *str , char const   *pattern , size_t pattern_len ) ;
static void __mkhash(char const   *password , unsigned char *nonce , unsigned char *lmresp ,
                     unsigned char *ntresp ) ;
AUTH new_auth(void) 
{ 
  AUTH this ;
  void *tmp ;

  {
  tmp = calloc(AUTHSIZE, (size_t )1);
  this = (AUTH )tmp;
  this->creds = new_array();
  this->basic.encode = (char *)((void *)0);
  this->digest.encode = (char *)((void *)0);
  this->ntlm.encode = (char *)((void *)0);
  this->ntlm.state = (STATE )0;
  this->proxy.encode = (char *)((void *)0);
  return (this);
}
}
AUTH auth_destroy(AUTH this ) 
{ 


  {
  this->creds = array_destroy(this->creds);
  xfree((void *)this->basic.encode);
  xfree((void *)this->digest.encode);
  xfree((void *)this->ntlm.encode);
  xfree((void *)this->proxy.encode);
  xfree((void *)this);
  return ((AUTH )((void *)0));
}
}
void auth_add(AUTH this , CREDS creds ) 
{ 


  {
  array_npush(this->creds, (void *)creds, CREDSIZE);
  return;
}
}
void auth_display(AUTH this , SCHEME scheme ) 
{ 
  size_t i ;
  char space[33] ;
  BOOLEAN first ;
  CREDS tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  SCHEME tmp___5 ;
  size_t tmp___6 ;

  {
  space[0] = (char )' ';
  space[1] = (char )' ';
  space[2] = (char )' ';
  space[3] = (char )' ';
  space[4] = (char )' ';
  space[5] = (char )' ';
  space[6] = (char )' ';
  space[7] = (char )' ';
  space[8] = (char )' ';
  space[9] = (char )' ';
  space[10] = (char )' ';
  space[11] = (char )' ';
  space[12] = (char )' ';
  space[13] = (char )' ';
  space[14] = (char )' ';
  space[15] = (char )' ';
  space[16] = (char )' ';
  space[17] = (char )' ';
  space[18] = (char )' ';
  space[19] = (char )' ';
  space[20] = (char )' ';
  space[21] = (char )' ';
  space[22] = (char )' ';
  space[23] = (char )' ';
  space[24] = (char )' ';
  space[25] = (char )' ';
  space[26] = (char )' ';
  space[27] = (char )' ';
  space[28] = (char )' ';
  space[29] = (char )' ';
  space[30] = (char )' ';
  space[31] = (char )' ';
  space[32] = (char )'\000';
  first = (BOOLEAN )1;
  i = (size_t )0;
  while (1) {
    tmp___6 = array_length(this->creds);
    if (! (i < tmp___6)) {
      break;
    }
    tmp___0 = array_get(this->creds, (int )i);
    tmp = (CREDS )tmp___0;
    tmp___5 = creds_get_scheme(tmp);
    if ((unsigned int )tmp___5 == (unsigned int )scheme) {
      tmp___1 = creds_get_realm(tmp);
      tmp___2 = creds_get_password(tmp);
      tmp___3 = creds_get_username(tmp);
      if ((unsigned int )first == 1U) {
        tmp___4 = "";
      } else {
        tmp___4 = (char const   *)(space);
      }
      printf((char const   * __restrict  )"%scredentials:  %s:%s:%s\n", tmp___4, tmp___3,
             tmp___2, tmp___1);
      first = (BOOLEAN )0;
    }
    i ++;
  }
  return;
}
}
char *auth_get_basic_header(AUTH this , SCHEME scheme ) 
{ 


  {
  if ((unsigned int )scheme == 4U) {
    return (this->proxy.encode);
  } else {
    return (this->basic.encode);
  }
}
}
BOOLEAN auth_set_basic_header(AUTH this , SCHEME scheme , char *realm ) 
{ 
  size_t i ;
  CREDS tmp ;
  void *tmp___0 ;
  BOOLEAN tmp___1 ;
  SCHEME tmp___2 ;
  char *tmp___3 ;
  BOOLEAN tmp___4 ;
  size_t tmp___5 ;
  CREDS tmp___6 ;
  void *tmp___7 ;
  BOOLEAN tmp___8 ;
  SCHEME tmp___9 ;
  char *tmp___10 ;
  BOOLEAN tmp___11 ;
  size_t tmp___12 ;

  {
  i = (size_t )0;
  while (1) {
    tmp___5 = array_length(this->creds);
    if (! (i < tmp___5)) {
      break;
    }
    tmp___0 = array_get(this->creds, (int )i);
    tmp = (CREDS )tmp___0;
    if ((unsigned long )realm == (unsigned long )((void *)0)) {
      break;
    }
    tmp___3 = creds_get_realm(tmp);
    tmp___4 = strmatch(tmp___3, realm);
    if (tmp___4) {
      tmp___2 = creds_get_scheme(tmp);
      if ((unsigned int )tmp___2 == (unsigned int )scheme) {
        tmp___1 = __basic_header(this, scheme, tmp);
        return (tmp___1);
      }
    }
    i ++;
  }
  i = (size_t )0;
  while (1) {
    tmp___12 = array_length(this->creds);
    if (! (i < tmp___12)) {
      break;
    }
    tmp___7 = array_get(this->creds, (int )i);
    tmp___6 = (CREDS )tmp___7;
    tmp___10 = creds_get_realm(tmp___6);
    tmp___11 = strmatch(tmp___10, (char *)"any");
    if (tmp___11) {
      tmp___9 = creds_get_scheme(tmp___6);
      if ((unsigned int )tmp___9 == (unsigned int )scheme) {
        tmp___8 = __basic_header(this, scheme, tmp___6);
        return (tmp___8);
      }
    }
    i ++;
  }
  return ((BOOLEAN )0);
}
}
BOOLEAN auth_set_ntlm_header(AUTH this , SCHEME scheme , char *header , char *realm ) 
{ 
  size_t i ;
  CREDS tmp ;
  void *tmp___0 ;
  BOOLEAN tmp___1 ;
  SCHEME tmp___2 ;
  SCHEME tmp___3 ;
  char *tmp___4 ;
  BOOLEAN tmp___5 ;
  size_t tmp___6 ;
  CREDS tmp___7 ;
  void *tmp___8 ;
  BOOLEAN tmp___9 ;
  SCHEME tmp___10 ;
  SCHEME tmp___11 ;
  char *tmp___12 ;
  BOOLEAN tmp___13 ;
  size_t tmp___14 ;

  {
  i = (size_t )0;
  while (1) {
    tmp___6 = array_length(this->creds);
    if (! (i < tmp___6)) {
      break;
    }
    tmp___0 = array_get(this->creds, (int )i);
    tmp = (CREDS )tmp___0;
    if ((unsigned long )realm == (unsigned long )((void *)0)) {
      break;
    }
    tmp___4 = creds_get_realm(tmp);
    tmp___5 = strmatch(tmp___4, realm);
    if (tmp___5) {
      tmp___2 = creds_get_scheme(tmp);
      if ((unsigned int )tmp___2 == 1U) {
        tmp___1 = __ntlm_header(this, scheme, (char const   *)header, tmp);
        return (tmp___1);
      } else {
        tmp___3 = creds_get_scheme(tmp);
        if ((unsigned int )tmp___3 == 2U) {
          tmp___1 = __ntlm_header(this, scheme, (char const   *)header, tmp);
          return (tmp___1);
        }
      }
    }
    i ++;
  }
  i = (size_t )0;
  while (1) {
    tmp___14 = array_length(this->creds);
    if (! (i < tmp___14)) {
      break;
    }
    tmp___8 = array_get(this->creds, (int )i);
    tmp___7 = (CREDS )tmp___8;
    tmp___12 = creds_get_realm(tmp___7);
    tmp___13 = strmatch(tmp___12, (char *)"any");
    if (tmp___13) {
      tmp___10 = creds_get_scheme(tmp___7);
      if ((unsigned int )tmp___10 == 1U) {
        tmp___9 = __ntlm_header(this, scheme, (char const   *)header, tmp___7);
        return (tmp___9);
      } else {
        tmp___11 = creds_get_scheme(tmp___7);
        if ((unsigned int )tmp___11 == 2U) {
          tmp___9 = __ntlm_header(this, scheme, (char const   *)header, tmp___7);
          return (tmp___9);
        }
      }
    }
    i ++;
  }
  return ((BOOLEAN )0);
}
}
char *auth_get_ntlm_header(AUTH this , SCHEME scheme ) 
{ 


  {
  if ((unsigned int )scheme == 4U) {
    return (this->proxy.encode);
  } else {
    return (this->ntlm.encode);
  }
}
}
char *auth_get_digest_header(AUTH this , SCHEME scheme , DCHLG *chlg , DCRED *cred ,
                             char const   *method___0 , char const   *uri ) 
{ 
  size_t len ;
  char *cnonce ;
  char *nonce_count ;
  char *qop ;
  char *response ;
  char *request_digest ;
  char *h_a1 ;
  char *h_a2 ;
  char *opaque ;
  char *result ;
  char *tmp ;
  BOOLEAN tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
  cnonce = (char *)((void *)0);
  nonce_count = (char *)((void *)0);
  qop = (char *)((void *)0);
  response = (char *)((void *)0);
  request_digest = (char *)((void *)0);
  h_a1 = (char *)((void *)0);
  h_a2 = (char *)((void *)0);
  opaque = (char *)((void *)0);
  result = (char *)((void *)0);
  tmp = (char *)((void *)0);
  if ((unsigned long )chlg == (unsigned long )((void *)0)) {
    return ((char *)"");
  } else
  if ((unsigned long )cred == (unsigned long )((void *)0)) {
    return ((char *)"");
  }
  if ((unsigned long )chlg != (unsigned long )((void *)0)) {
    if ((unsigned long )chlg->qop != (unsigned long )((void *)0)) {
      nonce_count = xstrcat(", nc=", cred->nc, (void *)0);
      cnonce = xstrcat(", cnonce=\"", cred->cnonce_value, "\"", (void *)0);
      h_a1 = __get_h_a1((DCHLG const   *)chlg, cred, (char const   *)chlg->nonce);
      if ((unsigned long )((void *)0) == (unsigned long )h_a1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"error calling __get_h_a1\n");
        return ((char *)((void *)0));
      }
      tmp___0 = __str_list_contains((char const   *)chlg->qop, "auth", (size_t )4);
      if (tmp___0) {
        qop = xstrdup(", qop=auth");
        tmp = xstrcat(method___0, ":", uri, (void *)0);
        h_a2 = __get_md5_str((char const   *)tmp);
        xfree((void *)tmp);
        tmp = xstrcat((char const   *)h_a1, ":", chlg->nonce, ":", cred->nc, ":",
                      cred->cnonce_value, ":auth:", h_a2, (void *)0);
        request_digest = __get_md5_str((char const   *)tmp);
        xfree((void *)tmp);
        response = xstrcat(", response=\"", request_digest, "\"", (void *)0);
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"error quality of protection not supported: %s\n",
                chlg->qop);
        return ((char *)((void *)0));
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    h_a1 = __get_h_a1((DCHLG const   *)chlg, cred, "");
    if ((unsigned long )((void *)0) == (unsigned long )h_a1) {
      NOTIFY((LEVEL )2, "__get_h_a1\n");
      return ((char *)((void *)0));
    }
    tmp = xstrcat(method___0, ":", uri, (void *)0);
    h_a2 = __get_md5_str((char const   *)tmp);
    xfree((void *)tmp);
    tmp = xstrcat((char const   *)h_a1, ":", chlg->nonce, ":", h_a2, (void *)0);
    request_digest = __get_md5_str((char const   *)tmp);
    xfree((void *)tmp);
    response = xstrcat(" response=\"", request_digest, "\"", (void *)0);
  }
  if ((unsigned long )chlg != (unsigned long )((void *)0)) {
    if ((unsigned long )chlg->opaque != (unsigned long )((void *)0)) {
      opaque = xstrcat(", opaque=\"", chlg->opaque, "\"", (void *)0);
    }
  }
  if (cnonce) {
    tmp___1 = (char const   *)cnonce;
  } else {
    tmp___1 = "";
  }
  if (nonce_count) {
    tmp___2 = (char const   *)nonce_count;
  } else {
    tmp___2 = "";
  }
  if (qop) {
    tmp___3 = (char const   *)qop;
  } else {
    tmp___3 = "";
  }
  if (opaque) {
    tmp___4 = (char const   *)opaque;
  } else {
    tmp___4 = "";
  }
  result = xstrcat("Digest username=\"", cred->username, "\", realm=\"", chlg->realm,
                   "\", nonce=\"", chlg->nonce, "\", uri=\"", uri, "\", algorithm=",
                   chlg->algorithm, response, tmp___4, tmp___3, tmp___2, tmp___1,
                   (void *)0);
  (cred->nc_value) ++;
  snprintf((char * __restrict  )(cred->nc), sizeof(cred->nc), (char const   * __restrict  )"%.8x",
           cred->nc_value);
  tmp___5 = strcasecmp("MD5", (char const   *)chlg->algorithm);
  if (0 == tmp___5) {
    xfree((void *)h_a1);
  }
  xfree((void *)nonce_count);
  xfree((void *)cnonce);
  xfree((void *)qop);
  xfree((void *)response);
  xfree((void *)request_digest);
  xfree((void *)h_a2);
  xfree((void *)opaque);
  tmp___6 = strlen((char const   *)result);
  len = tmp___6 + 32UL;
  if ((unsigned int )scheme == 4U) {
    tmp___7 = xmalloc(len);
    this->proxy.encode = (char *)tmp___7;
    memset((void *)this->proxy.encode, '\000', len);
    snprintf((char * __restrict  )this->proxy.encode, len, (char const   * __restrict  )"Proxy-Authorization: %s\r\n",
             result);
    xfree((void *)result);
    return (this->proxy.encode);
  } else {
    tmp___8 = xmalloc(len);
    this->digest.encode = (char *)tmp___8;
    memset((void *)this->digest.encode, '\000', len);
    snprintf((char * __restrict  )this->digest.encode, len, (char const   * __restrict  )"Authorization: %s\r\n",
             result);
    xfree((void *)result);
    return (this->digest.encode);
  }
}
}
BOOLEAN auth_set_digest_header(AUTH this , DCHLG **chlg , DCRED **cred , unsigned int *rand___0 ,
                               char *realm , char *str ) 
{ 
  size_t i ;
  CREDS tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  BOOLEAN tmp___2 ;
  size_t tmp___3 ;
  CREDS tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  BOOLEAN tmp___7 ;
  size_t tmp___8 ;

  {
  i = (size_t )0;
  while (1) {
    tmp___3 = array_length(this->creds);
    if (! (i < tmp___3)) {
      break;
    }
    tmp___0 = array_get(this->creds, (int )i);
    tmp = (CREDS )tmp___0;
    if ((unsigned long )realm == (unsigned long )((void *)0)) {
      break;
    }
    tmp___1 = creds_get_realm(tmp);
    tmp___2 = strmatch(tmp___1, realm);
    if (tmp___2) {
      *chlg = __digest_challenge((char const   *)str);
      *cred = __digest_credentials(tmp, rand___0);
      if ((unsigned long )*cred == (unsigned long )((void *)0)) {
        return ((BOOLEAN )0);
      } else
      if ((unsigned long )*chlg == (unsigned long )((void *)0)) {
        return ((BOOLEAN )0);
      }
      return ((BOOLEAN )1);
    }
    i ++;
  }
  i = (size_t )0;
  while (1) {
    tmp___8 = array_length(this->creds);
    if (! (i < tmp___8)) {
      break;
    }
    tmp___5 = array_get(this->creds, (int )i);
    tmp___4 = (CREDS )tmp___5;
    tmp___6 = creds_get_realm(tmp___4);
    tmp___7 = strmatch(tmp___6, (char *)"any");
    if (tmp___7) {
      *chlg = __digest_challenge((char const   *)str);
      *cred = __digest_credentials(tmp___4, rand___0);
      if ((unsigned long )*cred == (unsigned long )((void *)0)) {
        return ((BOOLEAN )0);
      } else
      if ((unsigned long )*chlg == (unsigned long )((void *)0)) {
        return ((BOOLEAN )0);
      }
      return ((BOOLEAN )1);
    }
    i ++;
  }
  return ((BOOLEAN )0);
}
}
BOOLEAN auth_get_proxy_required(AUTH this ) 
{ 


  {
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    return ((BOOLEAN )0);
  }
  return (this->proxy.required);
}
}
char *auth_get_proxy_host(AUTH this ) 
{ 


  {
  return (this->proxy.hostname);
}
}
int auth_get_proxy_port(AUTH this ) 
{ 


  {
  return (this->proxy.port);
}
}
void auth_set_proxy_required(AUTH this , BOOLEAN required ) 
{ 


  {
  this->proxy.required = required;
  return;
}
}
void auth_set_proxy_host(AUTH this , char *host ) 
{ 


  {
  this->proxy.hostname = xstrdup((char const   *)host);
  this->proxy.required = (BOOLEAN )1;
  return;
}
}
void auth_set_proxy_port(AUTH this , int port ) 
{ 


  {
  this->proxy.port = port;
  return;
}
}
char *auth_get_ftp_username(AUTH this , char *realm ) 
{ 
  size_t i ;
  CREDS tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  SCHEME tmp___2 ;
  char *tmp___3 ;
  BOOLEAN tmp___4 ;
  size_t tmp___5 ;
  CREDS tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  SCHEME tmp___9 ;
  char *tmp___10 ;
  BOOLEAN tmp___11 ;
  size_t tmp___12 ;

  {
  i = (size_t )0;
  while (1) {
    tmp___5 = array_length(this->creds);
    if (! (i < tmp___5)) {
      break;
    }
    tmp___0 = array_get(this->creds, (int )i);
    tmp = (CREDS )tmp___0;
    tmp___3 = creds_get_realm(tmp);
    tmp___4 = strmatch(tmp___3, realm);
    if (tmp___4) {
      tmp___2 = creds_get_scheme(tmp);
      if ((unsigned int )tmp___2 == 3U) {
        tmp___1 = creds_get_username(tmp);
        return (tmp___1);
      }
    }
    i ++;
  }
  i = (size_t )0;
  while (1) {
    tmp___12 = array_length(this->creds);
    if (! (i < tmp___12)) {
      break;
    }
    tmp___7 = array_get(this->creds, (int )i);
    tmp___6 = (CREDS )tmp___7;
    tmp___10 = creds_get_realm(tmp___6);
    tmp___11 = strmatch(tmp___10, (char *)"any");
    if (tmp___11) {
      tmp___9 = creds_get_scheme(tmp___6);
      if ((unsigned int )tmp___9 == 3U) {
        tmp___8 = creds_get_username(tmp___6);
        return (tmp___8);
      }
    }
    i ++;
  }
  return ((char *)"");
}
}
char *auth_get_ftp_password(AUTH this , char *realm ) 
{ 
  size_t i ;
  CREDS tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  SCHEME tmp___2 ;
  char *tmp___3 ;
  BOOLEAN tmp___4 ;
  size_t tmp___5 ;
  CREDS tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  SCHEME tmp___9 ;
  char *tmp___10 ;
  BOOLEAN tmp___11 ;
  size_t tmp___12 ;

  {
  i = (size_t )0;
  while (1) {
    tmp___5 = array_length(this->creds);
    if (! (i < tmp___5)) {
      break;
    }
    tmp___0 = array_get(this->creds, (int )i);
    tmp = (CREDS )tmp___0;
    tmp___3 = creds_get_realm(tmp);
    tmp___4 = strmatch(tmp___3, realm);
    if (tmp___4) {
      tmp___2 = creds_get_scheme(tmp);
      if ((unsigned int )tmp___2 == 3U) {
        tmp___1 = creds_get_password(tmp);
        return (tmp___1);
      }
    }
    i ++;
  }
  i = (size_t )0;
  while (1) {
    tmp___12 = array_length(this->creds);
    if (! (i < tmp___12)) {
      break;
    }
    tmp___7 = array_get(this->creds, (int )i);
    tmp___6 = (CREDS )tmp___7;
    tmp___10 = creds_get_realm(tmp___6);
    tmp___11 = strmatch(tmp___10, (char *)"any");
    if (tmp___11) {
      tmp___9 = creds_get_scheme(tmp___6);
      if ((unsigned int )tmp___9 == 3U) {
        tmp___8 = creds_get_password(tmp___6);
        return (tmp___8);
      }
    }
    i ++;
  }
  return ((char *)"");
}
}
static BOOLEAN __basic_header(AUTH this , SCHEME scheme , CREDS creds ) 
{ 
  char buf[256] ;
  char *hdr ;
  size_t len ;
  BOOLEAN ret ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  ret = (BOOLEAN )1;
  memset((void *)(buf), '\000', sizeof(buf));
  pthread_mutex_lock(& this->lock);
  tmp = creds_get_password(creds);
  tmp___0 = creds_get_username(creds);
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%s:%s",
           tmp___0, tmp);
  if ((unsigned int )scheme == 4U) {
    xfree((void *)this->proxy.encode);
    tmp___3 = strlen((char const   *)(buf));
    tmp___4 = base64_encode((void const   *)(buf), (int )tmp___3, & hdr);
    if (tmp___4 < 0) {
      ret = (BOOLEAN )0;
    } else {
      tmp___1 = strlen((char const   *)hdr);
      len = tmp___1 + 32UL;
      tmp___2 = xmalloc(len);
      this->proxy.encode = (char *)tmp___2;
      memset((void *)this->proxy.encode, '\000', len);
      snprintf((char * __restrict  )this->proxy.encode, len, (char const   * __restrict  )"Proxy-Authorization: Basic %s\r\n",
               hdr);
    }
  } else {
    xfree((void *)this->basic.encode);
    tmp___7 = strlen((char const   *)(buf));
    tmp___8 = base64_encode((void const   *)(buf), (int )tmp___7, & hdr);
    if (tmp___8 < 0) {
      ret = (BOOLEAN )0;
    } else {
      tmp___5 = strlen((char const   *)hdr);
      len = tmp___5 + 32UL;
      tmp___6 = xmalloc(len);
      this->basic.encode = (char *)tmp___6;
      memset((void *)this->basic.encode, '\000', len);
      snprintf((char * __restrict  )this->basic.encode, len, (char const   * __restrict  )"Authorization: Basic %s\r\n",
               hdr);
    }
  }
  pthread_mutex_unlock(& this->lock);
  return (ret);
}
}
static BOOLEAN __ntlm_header(AUTH this , SCHEME scheme , char const   *header , CREDS creds ) 
{ 
  size_t size ;
  size_t final ;
  char const   *domstr ;
  char const   *srvstr ;
  size_t domlen ;
  size_t tmp ;
  size_t srvlen ;
  size_t tmp___0 ;
  size_t srvoff ;
  size_t domoff ;
  char *hdr ;
  char tmp___1[8192] ;
  char buf[256] ;
  int tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  ssize_t size___0 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t lmrespoff ;
  size_t ntrespoff ;
  size_t usroff ;
  unsigned char lmresp[24] ;
  unsigned char ntresp[24] ;
  size_t usrlen ;
  char const   *usr ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  void *tmp___20 ;

  {
  size = (size_t )0;
  final = (size_t )0;
  domstr = "";
  srvstr = "";
  tmp = strlen(domstr);
  domlen = tmp;
  tmp___0 = strlen(srvstr);
  srvlen = tmp___0;
  tmp___2 = strncasecmp(header, "NTLM", (size_t )4);
  if (tmp___2) {
    return ((BOOLEAN )0);
  }
  tmp___3 = creds_get_username(creds);
  NOTIFY((LEVEL )0, "Parsing NTLM header:  %d, %d, %s, %s", (unsigned int )this->okay,
         (unsigned int )scheme, header, tmp___3);
  header += 4;
  while (1) {
    if (*header) {
      tmp___4 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___4 + (int )((unsigned char )*header)) & 8192)) {
        break;
      }
    } else {
      break;
    }
    header ++;
  }
  if (*header) {
    tmp___5 = strlen(header);
    memset((void *)(tmp___1), '\000', tmp___5);
    tmp___6 = base64_decode(header, (void *)(& tmp___1));
    size___0 = (ssize_t )tmp___6;
    if (size___0 < 0L) {
      return ((BOOLEAN )0);
    }
    if (size___0 >= 48L) {
      memcpy((void * __restrict  )(this->ntlm.nonce), (void const   * __restrict  )(& tmp___1[24]),
             (size_t )8);
    }
    this->ntlm.state = (STATE )2;
  } else {
    if ((unsigned int )this->ntlm.state >= 1U) {
      return ((BOOLEAN )0);
    }
    this->ntlm.state = (STATE )1;
  }
  switch ((unsigned int )this->ntlm.state) {
  case 4U: 
  case 0U: 
  case 1U: 
  srvoff = (size_t )32;
  domoff = srvoff + srvlen;
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"NTLMSSP%c\001%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%s%s",
           0, 0, 0, 0, ((1 << 1) | (1 << 9)) & 255, (((1 << 1) | (1 << 9)) >> 8) & 255,
           (((1 << 1) | (1 << 9)) >> 16) & 255, ((1 << 1) | (1 << 9)) >> 24, (int )((char )(domlen & 255UL)),
           (int )((char )(domlen >> 8)), (int )((char )(domlen & 255UL)), (int )((char )(domlen >> 8)),
           (int )((char )(domoff & 255UL)), (int )((char )(domoff >> 8)), 0, 0, (int )((char )(srvlen & 255UL)),
           (int )((char )(srvlen >> 8)), (int )((char )(srvlen & 255UL)), (int )((char )(srvlen >> 8)),
           (int )((char )(srvoff & 255UL)), (int )((char )(srvoff >> 8)), 0, 0, srvstr,
           domstr);
  size = (32UL + srvlen) + domlen;
  tmp___7 = base64_encode((void const   *)(buf), (int )size, & hdr);
  if (tmp___7 < 0) {
    return ((BOOLEAN )0);
  }
  tmp___8 = strlen((char const   *)hdr);
  final = tmp___8 + 23UL;
  tmp___9 = xmalloc(final);
  this->ntlm.encode = (char *)tmp___9;
  this->ntlm.state = (STATE )2;
  memset((void *)this->ntlm.encode, '\000', final);
  snprintf((char * __restrict  )this->ntlm.encode, final, (char const   * __restrict  )"Authorization: NTLM %s\r\n",
           hdr);
  break;
  case 2U: 
  tmp___10 = creds_get_username(creds);
  tmp___11 = strchr((char const   *)tmp___10, '\\');
  usr = (char const   *)tmp___11;
  if (! usr) {
    tmp___12 = creds_get_username(creds);
    tmp___13 = strchr((char const   *)tmp___12, '/');
    usr = (char const   *)tmp___13;
  }
  if (usr) {
    tmp___14 = creds_get_username(creds);
    domstr = (char const   *)tmp___14;
    domlen = (size_t )(usr - domstr);
    usr ++;
  } else {
    tmp___15 = creds_get_username(creds);
    usr = (char const   *)tmp___15;
  }
  usrlen = strlen(usr);
  tmp___16 = creds_get_password(creds);
  __mkhash((char const   *)tmp___16, & this->ntlm.nonce[0], lmresp, ntresp);
  domoff = (size_t )64;
  usroff = domoff + domlen;
  srvoff = usroff + usrlen;
  lmrespoff = srvoff + srvlen;
  ntrespoff = lmrespoff + 24UL;
  tmp___17 = snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"NTLMSSP%c\003%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\377\377%c%c\001\202%c%c",
                      0, 0, 0, 0, 24, (int )((char )(24 >> 8)), 24, (int )((char )(24 >> 8)),
                      (int )((char )(lmrespoff & 255UL)), (int )((char )(lmrespoff >> 8)),
                      0, 0, 24, (int )((char )(24 >> 8)), 24, (int )((char )(24 >> 8)),
                      (int )((char )(ntrespoff & 255UL)), (int )((char )(ntrespoff >> 8)),
                      0, 0, (int )((char )(domlen & 255UL)), (int )((char )(domlen >> 8)),
                      (int )((char )(domlen & 255UL)), (int )((char )(domlen >> 8)),
                      (int )((char )(domoff & 255UL)), (int )((char )(domoff >> 8)),
                      0, 0, (int )((char )(usrlen & 255UL)), (int )((char )(usrlen >> 8)),
                      (int )((char )(usrlen & 255UL)), (int )((char )(usrlen >> 8)),
                      (int )((char )(usroff & 255UL)), (int )((char )(usroff >> 8)),
                      0, 0, (int )((char )(srvlen & 255UL)), (int )((char )(srvlen >> 8)),
                      (int )((char )(srvlen & 255UL)), (int )((char )(srvlen >> 8)),
                      (int )((char )(srvoff & 255UL)), (int )((char )(srvoff >> 8)),
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  size = (size_t )tmp___17;
  size = (size_t )64;
  buf[63] = (char)0;
  buf[62] = buf[63];
  if ((size + usrlen) + domlen >= sizeof(buf)) {
    return ((BOOLEAN )0);
  }
  memcpy((void * __restrict  )(& buf[size]), (void const   * __restrict  )domstr,
         domlen);
  size += domlen;
  memcpy((void * __restrict  )(& buf[size]), (void const   * __restrict  )usr, usrlen);
  size += usrlen;
  if (size < sizeof(buf) - 24UL) {
    memcpy((void * __restrict  )(& buf[size]), (void const   * __restrict  )(lmresp),
           (size_t )24);
    size += 24UL;
  }
  if (size < sizeof(buf) - 24UL) {
    memcpy((void * __restrict  )(& buf[size]), (void const   * __restrict  )(ntresp),
           (size_t )24);
    size += 24UL;
  }
  buf[56] = (char )(size & 255UL);
  buf[57] = (char )(size >> 8);
  tmp___18 = base64_encode((void const   *)(buf), (int )size, & hdr);
  if (tmp___18 < 0) {
    return ((BOOLEAN )0);
  }
  this->ntlm.state = (STATE )3;
  this->ntlm.ready = (BOOLEAN )1;
  tmp___19 = strlen((char const   *)hdr);
  final = tmp___19 + 23UL;
  tmp___20 = xrealloc((void *)this->ntlm.encode, final);
  this->ntlm.encode = (char *)tmp___20;
  memset((void *)this->ntlm.encode, '\000', final);
  snprintf((char * __restrict  )this->ntlm.encode, final, (char const   * __restrict  )"Authorization: NTLM %s\r\n",
           hdr);
  break;
  case 3U: 
  this->ntlm.ready = (BOOLEAN )1;
  break;
  default: 
  break;
  }
  return ((BOOLEAN )1);
}
}
static void setup_des_key(unsigned char *key_56 , DES_key_schedule *ks ) 
{ 
  DES_cblock key ;

  {
  key[0] = *(key_56 + 0);
  key[1] = (unsigned char )((((int )*(key_56 + 0) << 7) & 255) | ((int )*(key_56 + 1) >> 1));
  key[2] = (unsigned char )((((int )*(key_56 + 1) << 6) & 255) | ((int )*(key_56 + 2) >> 2));
  key[3] = (unsigned char )((((int )*(key_56 + 2) << 5) & 255) | ((int )*(key_56 + 3) >> 3));
  key[4] = (unsigned char )((((int )*(key_56 + 3) << 4) & 255) | ((int )*(key_56 + 4) >> 4));
  key[5] = (unsigned char )((((int )*(key_56 + 4) << 3) & 255) | ((int )*(key_56 + 5) >> 5));
  key[6] = (unsigned char )((((int )*(key_56 + 5) << 2) & 255) | ((int )*(key_56 + 6) >> 6));
  key[7] = (unsigned char )(((int )*(key_56 + 6) << 1) & 255);
  DES_set_odd_parity(& key);
  DES_set_key(& key, ks);
  return;
}
}
static void calc_resp(unsigned char *keys___0 , unsigned char *plaintext , unsigned char *results ) 
{ 
  DES_key_schedule ks ;

  {
  setup_des_key(keys___0, & ks);
  DES_ecb_encrypt((DES_cblock *)plaintext, (DES_cblock *)results, & ks, 1);
  setup_des_key(keys___0 + 7, & ks);
  DES_ecb_encrypt((DES_cblock *)plaintext, (DES_cblock *)(results + 8), & ks, 1);
  setup_des_key(keys___0 + 14, & ks);
  DES_ecb_encrypt((DES_cblock *)plaintext, (DES_cblock *)(results + 16), & ks, 1);
  return;
}
}
static unsigned char const   magic[8]  = 
  {      (unsigned char const   )75,      (unsigned char const   )71,      (unsigned char const   )83,      (unsigned char const   )33, 
        (unsigned char const   )64,      (unsigned char const   )35,      (unsigned char const   )36,      (unsigned char const   )37};
static void __mkhash(char const   *password , unsigned char *nonce , unsigned char *lmresp ,
                     unsigned char *ntresp ) 
{ 
  unsigned char *pw ;
  unsigned char lmbuffer[21] ;
  unsigned char ntbuffer[21] ;
  size_t i ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int __res ;
  __int32_t const   **tmp___3 ;
  int tmp___4 ;
  DES_key_schedule ks ;
  MD4_CTX MD4___0 ;

  {
  tmp = strlen(password);
  len = tmp;
  if (len < 7UL) {
    tmp___0 = (size_t )14;
  } else {
    tmp___0 = len * 2UL;
  }
  tmp___1 = __builtin_alloca(tmp___0);
  pw = (unsigned char *)tmp___1;
  if (len > 14UL) {
    len = (size_t )14;
  }
  i = (size_t )0;
  while (i < len) {
    if ((unsigned int )*(password + i) - 97U <= 25U) {
      if (sizeof(*(password + i)) > 1UL) {
        __res = toupper((int )*(password + i));
      } else {
        tmp___3 = __ctype_toupper_loc();
        __res = (int )*(*tmp___3 + (int )*(password + i));
      }
      tmp___4 = __res;
    } else {
      tmp___4 = (int )*(password + i);
    }
    *(pw + i) = (unsigned char )tmp___4;
    i ++;
  }
  while (i < 14UL) {
    *(pw + i) = (unsigned char)0;
    i ++;
  }
  setup_des_key(pw, & ks);
  DES_ecb_encrypt((DES_cblock *)(magic), (DES_cblock *)(lmbuffer), & ks, 1);
  setup_des_key(pw + 7, & ks);
  DES_ecb_encrypt((DES_cblock *)(magic), (DES_cblock *)(lmbuffer + 8), & ks, 1);
  memset((void *)(lmbuffer + 16), 0, (size_t )5);
  calc_resp(lmbuffer, nonce, lmresp);
  len = strlen(password);
  i = (size_t )0;
  while (i < len) {
    *(pw + 2UL * i) = (unsigned char )*(password + i);
    *(pw + (2UL * i + 1UL)) = (unsigned char)0;
    i ++;
  }
  MD4_Init(& MD4___0);
  MD4_Update(& MD4___0, (void const   *)pw, 2UL * len);
  MD4_Final(ntbuffer, & MD4___0);
  memset((void *)(ntbuffer + 16), 0, (size_t )5);
  calc_resp(ntbuffer, nonce, ntresp);
  return;
}
}
static KEYPARSER const   keyparser[8]  = 
  {      {"realm", (KEY_HEADER_E )0}, 
        {"domain", (KEY_HEADER_E )1}, 
        {"nonce", (KEY_HEADER_E )2}, 
        {"opaque", (KEY_HEADER_E )3}, 
        {"stale", (KEY_HEADER_E )4}, 
        {"algorithm", (KEY_HEADER_E )5}, 
        {"qop", (KEY_HEADER_E )6}, 
        {(char const   *)((void *)0), (KEY_HEADER_E )7}};
static KEY_HEADER_E __get_keyval(char const   *key ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  while (keyparser[i].keyname) {
    tmp = strcasecmp(key, (char const   *)keyparser[i].keyname);
    if (! tmp) {
      return ((KEY_HEADER_E )keyparser[i].keyval);
    }
    i ++;
  }
  return ((KEY_HEADER_E )7);
}
}
static char *__get_random_string(size_t length , unsigned int *randseed ) 
{ 
  unsigned char b64_alphabet[65] ;
  unsigned char *result ;
  size_t i ;
  void *tmp ;
  int tmp___0 ;

  {
  b64_alphabet[0] = (unsigned char )'0';
  b64_alphabet[1] = (unsigned char )'1';
  b64_alphabet[2] = (unsigned char )'2';
  b64_alphabet[3] = (unsigned char )'3';
  b64_alphabet[4] = (unsigned char )'4';
  b64_alphabet[5] = (unsigned char )'5';
  b64_alphabet[6] = (unsigned char )'6';
  b64_alphabet[7] = (unsigned char )'7';
  b64_alphabet[8] = (unsigned char )'8';
  b64_alphabet[9] = (unsigned char )'9';
  b64_alphabet[10] = (unsigned char )'a';
  b64_alphabet[11] = (unsigned char )'b';
  b64_alphabet[12] = (unsigned char )'c';
  b64_alphabet[13] = (unsigned char )'d';
  b64_alphabet[14] = (unsigned char )'e';
  b64_alphabet[15] = (unsigned char )'f';
  b64_alphabet[16] = (unsigned char )'g';
  b64_alphabet[17] = (unsigned char )'h';
  b64_alphabet[18] = (unsigned char )'i';
  b64_alphabet[19] = (unsigned char )'j';
  b64_alphabet[20] = (unsigned char )'k';
  b64_alphabet[21] = (unsigned char )'l';
  b64_alphabet[22] = (unsigned char )'m';
  b64_alphabet[23] = (unsigned char )'n';
  b64_alphabet[24] = (unsigned char )'o';
  b64_alphabet[25] = (unsigned char )'p';
  b64_alphabet[26] = (unsigned char )'q';
  b64_alphabet[27] = (unsigned char )'r';
  b64_alphabet[28] = (unsigned char )'s';
  b64_alphabet[29] = (unsigned char )'t';
  b64_alphabet[30] = (unsigned char )'u';
  b64_alphabet[31] = (unsigned char )'v';
  b64_alphabet[32] = (unsigned char )'w';
  b64_alphabet[33] = (unsigned char )'x';
  b64_alphabet[34] = (unsigned char )'y';
  b64_alphabet[35] = (unsigned char )'z';
  b64_alphabet[36] = (unsigned char )'A';
  b64_alphabet[37] = (unsigned char )'B';
  b64_alphabet[38] = (unsigned char )'C';
  b64_alphabet[39] = (unsigned char )'D';
  b64_alphabet[40] = (unsigned char )'E';
  b64_alphabet[41] = (unsigned char )'F';
  b64_alphabet[42] = (unsigned char )'G';
  b64_alphabet[43] = (unsigned char )'H';
  b64_alphabet[44] = (unsigned char )'I';
  b64_alphabet[45] = (unsigned char )'J';
  b64_alphabet[46] = (unsigned char )'K';
  b64_alphabet[47] = (unsigned char )'L';
  b64_alphabet[48] = (unsigned char )'M';
  b64_alphabet[49] = (unsigned char )'N';
  b64_alphabet[50] = (unsigned char )'O';
  b64_alphabet[51] = (unsigned char )'P';
  b64_alphabet[52] = (unsigned char )'Q';
  b64_alphabet[53] = (unsigned char )'R';
  b64_alphabet[54] = (unsigned char )'S';
  b64_alphabet[55] = (unsigned char )'T';
  b64_alphabet[56] = (unsigned char )'U';
  b64_alphabet[57] = (unsigned char )'V';
  b64_alphabet[58] = (unsigned char )'W';
  b64_alphabet[59] = (unsigned char )'X';
  b64_alphabet[60] = (unsigned char )'Y';
  b64_alphabet[61] = (unsigned char )'Z';
  b64_alphabet[62] = (unsigned char )'.';
  b64_alphabet[63] = (unsigned char )'/';
  b64_alphabet[64] = (unsigned char )'\000';
  tmp = xmalloc(sizeof(unsigned char ) * (length + 1UL));
  result = (unsigned char *)tmp;
  i = (size_t )0;
  while (i < length) {
    tmp___0 = pthread_rand_np(randseed);
    *(result + i) = (unsigned char )((int )(255.0 * ((double )tmp___0 / ((double )2147483647 + 1.0))));
    i ++;
  }
  i = (size_t )0;
  while (i < length) {
    *(result + i) = b64_alphabet[(unsigned long )*(result + i) % ((sizeof(b64_alphabet) - 1UL) / sizeof(unsigned char ))];
    i ++;
  }
  *(result + length) = (unsigned char )'\000';
  return ((char *)result);
}
}
static DCRED *__digest_credentials(CREDS creds , unsigned int *randseed ) 
{ 
  DCRED *result ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  tmp = xcalloc((size_t )1, sizeof(struct DIGEST_CRED ));
  result = (DCRED *)tmp;
  tmp___0 = creds_get_username(creds);
  result->username = xstrdup((char const   *)tmp___0);
  tmp___1 = creds_get_password(creds);
  result->password = xstrdup((char const   *)tmp___1);
  result->cnonce_value = __get_random_string((size_t )16, randseed);
  result->nc_value = 1U;
  snprintf((char * __restrict  )(result->nc), sizeof(result->nc), (char const   * __restrict  )"%.8x",
           result->nc_value);
  result->h_a1 = (char *)((void *)0);
  return (result);
}
}
static DCHLG *__digest_challenge(char const   *challenge ) 
{ 
  DCHLG *result ;
  char *key ;
  char *val ;
  char const   *beg ;
  char const   *end ;
  KEY_HEADER_E keyval ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  void *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  void *tmp___8 ;
  unsigned short const   **tmp___9 ;
  void *tmp___10 ;

  {
  tmp = xcalloc((size_t )1, sizeof(struct DIGEST_CHLG ));
  result = (DCHLG *)tmp;
  end = challenge;
  beg = end;
  while (1) {
    tmp___0 = __ctype_b_loc();
    if ((int const   )*(*tmp___0 + (int )*end) & 8192) {
      break;
    } else
    if (! *end) {
      break;
    }
    end ++;
  }
  tmp___1 = strncasecmp("Digest", beg, (size_t )(end - beg));
  if (tmp___1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"no Digest keyword in challenge [%s]\n",
            challenge);
    return ((DCHLG *)((void *)0));
  }
  beg = end;
  while (1) {
    tmp___2 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___2 + (int )*beg) & 8192)) {
      break;
    }
    beg ++;
  }
  while ((int const   )*beg != 0) {
    while (1) {
      tmp___3 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___3 + (int )*beg) & 8192)) {
        break;
      }
      beg ++;
    }
    end = beg;
    while (1) {
      if ((int const   )*end != 61) {
        if ((int const   )*end != 44) {
          if ((int const   )*end != 0) {
            tmp___4 = __ctype_b_loc();
            if ((int const   )*(*tmp___4 + (int )*end) & 8192) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      end ++;
    }
    tmp___5 = xmalloc((unsigned long )((end + 1) - beg) * sizeof(char ));
    key = (char *)tmp___5;
    memcpy((void * __restrict  )key, (void const   * __restrict  )beg, (size_t )(end - beg));
    *(key + (end - beg)) = (char )'\000';
    beg = end;
    while (1) {
      tmp___6 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___6 + (int )*beg) & 8192)) {
        break;
      }
      beg ++;
    }
    val = (char *)((void *)0);
    if ((int const   )*beg == 61) {
      beg ++;
      while (1) {
        tmp___7 = __ctype_b_loc();
        if (! ((int const   )*(*tmp___7 + (int )*beg) & 8192)) {
          break;
        }
        beg ++;
      }
      if ((int const   )*beg == 34) {
        beg ++;
        end = beg;
        while (1) {
          if ((int const   )*end != 34) {
            if (! ((int const   )*end != 0)) {
              break;
            }
          } else {
            break;
          }
          if ((int const   )*end == 92) {
            if ((int const   )*(end + 1) != 0) {
              end ++;
            }
          }
          end ++;
        }
        tmp___8 = xmalloc((unsigned long )((end + 1) - beg) * sizeof(char ));
        val = (char *)tmp___8;
        memcpy((void * __restrict  )val, (void const   * __restrict  )beg, (size_t )(end - beg));
        *(val + (end - beg)) = (char )'\000';
        beg = end;
        if ((int const   )*beg != 0) {
          beg ++;
        }
      } else {
        end = beg;
        while (1) {
          if ((int const   )*end != 44) {
            if ((int const   )*end != 0) {
              tmp___9 = __ctype_b_loc();
              if ((int const   )*(*tmp___9 + (int )*end) & 8192) {
                break;
              }
            } else {
              break;
            }
          } else {
            break;
          }
          end ++;
        }
        tmp___10 = xmalloc((unsigned long )((end + 1) - beg) * sizeof(char ));
        val = (char *)tmp___10;
        memcpy((void * __restrict  )val, (void const   * __restrict  )beg, (size_t )(end - beg));
        *(val + (end - beg)) = (char )'\000';
        beg = end;
      }
    }
    while (1) {
      if ((int const   )*beg != 44) {
        if (! ((int const   )*beg != 0)) {
          break;
        }
      } else {
        break;
      }
      beg ++;
    }
    if ((int const   )*beg != 0) {
      beg ++;
    }
    keyval = __get_keyval((char const   *)key);
    switch ((unsigned int )keyval) {
    case 0U: 
    result->realm = val;
    break;
    case 1U: 
    result->domain = val;
    break;
    case 2U: 
    result->nonce = val;
    break;
    case 3U: 
    result->opaque = val;
    break;
    case 4U: 
    result->stale = val;
    break;
    case 5U: 
    result->algorithm = val;
    break;
    case 6U: 
    result->qop = val;
    break;
    default: 
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unknown key [%s]\n",
            key);
    xfree((void *)val);
    break;
    }
    xfree((void *)key);
  }
  return (result);
}
}
static char *__get_md5_str(char const   *buf ) 
{ 
  char const   *hex ;
  struct md5_ctx ctx ;
  unsigned char hash[16] ;
  char *r ;
  char *result ;
  size_t length ;
  int i ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  hex = "0123456789abcdef";
  length = strlen(buf);
  tmp = xmalloc(33UL * sizeof(char ));
  result = (char *)tmp;
  md5_init_ctx(& ctx);
  md5_process_bytes((void const   *)buf, length, & ctx);
  md5_finish_ctx(& ctx, (void *)(hash));
  i = 0;
  r = result;
  while (i < 16) {
    tmp___0 = r;
    r ++;
    *tmp___0 = (char )*(hex + ((int )hash[i] >> 4));
    tmp___1 = r;
    r ++;
    *tmp___1 = (char )*(hex + ((int )hash[i] & 15));
    i ++;
  }
  *r = (char )'\000';
  return (result);
}
}
static char *__get_h_a1(DCHLG const   *chlg , DCRED *cred , char const   *nonce_value ) 
{ 
  char *h_usrepa ;
  char *result ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___1 = strcasecmp("MD5", (char const   *)chlg->algorithm);
  if (0 == tmp___1) {
    tmp = xstrcat((char const   *)cred->username, ":", chlg->realm, ":", cred->password,
                  (void *)0);
    h_usrepa = __get_md5_str((char const   *)tmp);
    xfree((void *)tmp);
    result = h_usrepa;
  } else {
    tmp___0 = strcasecmp("MD5-sess", (char const   *)chlg->algorithm);
    if (0 == tmp___0) {
      if ((unsigned long )((void *)0) == (unsigned long )cred->h_a1) {
        tmp = xstrcat((char const   *)cred->username, ":", chlg->realm, ":", cred->password,
                      (void *)0);
        h_usrepa = __get_md5_str((char const   *)tmp);
        xfree((void *)tmp);
        tmp = xstrcat((char const   *)h_usrepa, ":", nonce_value, ":", cred->cnonce_value,
                      (void *)0);
        result = __get_md5_str((char const   *)tmp);
        xfree((void *)tmp);
        cred->h_a1 = result;
      } else {
        return (cred->h_a1);
      }
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"invalid call to %s algorithm is [%s]\n",
              "__get_h_a1", chlg->algorithm);
      return ((char *)((void *)0));
    }
  }
  return (result);
}
}
static BOOLEAN __str_list_contains(char const   *str , char const   *pattern , size_t pattern_len ) 
{ 
  char const   *ptr ;
  int tmp ;
  char *tmp___0 ;

  {
  ptr = str;
  while (1) {
    tmp = strncmp(ptr, pattern, pattern_len);
    if (0 == tmp) {
      if (44 == (int )*(ptr + pattern_len)) {
        return ((BOOLEAN )1);
      } else
      if (0 == (int )*(ptr + pattern_len)) {
        return ((BOOLEAN )1);
      }
    }
    tmp___0 = strchr(ptr, ',');
    ptr = (char const   *)tmp___0;
    if ((unsigned long )((void *)0) != (unsigned long )ptr) {
      ptr ++;
    }
    if (! ((unsigned long )((void *)0) != (unsigned long )ptr)) {
      break;
    }
  }
  return ((BOOLEAN )0);
}
}
#pragma merger("0","/tmp/cil-5KG7l7Yr.i","-W,-Wall,-Wunused-value,-g,-O2")
static char base64[65]  = 
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/', 
        (char )'\000'};
static int pos(char c ) 
{ 
  char *p ;

  {
  p = base64;
  while (*p) {
    if ((int )*p == (int )c) {
      return ((int )(p - base64));
    }
    p ++;
  }
  return (-1);
}
}
int base64_encode(void const   *data , int size , char **str ) 
{ 
  char *s ;
  char *p ;
  int i ;
  int c ;
  unsigned char const   *q ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  tmp = malloc((size_t )((size * 4) / 3 + 4));
  s = (char *)tmp;
  p = s;
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    return (-1);
  }
  q = (unsigned char const   *)data;
  i = 0;
  i = 0;
  while (i < size) {
    tmp___0 = i;
    i ++;
    c = (int )*(q + tmp___0);
    c *= 256;
    if (i < size) {
      c += (int )*(q + i);
    }
    i ++;
    c *= 256;
    if (i < size) {
      c += (int )*(q + i);
    }
    i ++;
    *(p + 0) = base64[(c & 16515072) >> 18];
    *(p + 1) = base64[(c & 258048) >> 12];
    *(p + 2) = base64[(c & 4032) >> 6];
    *(p + 3) = base64[c & 63];
    if (i > size) {
      *(p + 3) = (char )'=';
    }
    if (i > size + 1) {
      *(p + 2) = (char )'=';
    }
    p += 4;
  }
  *p = (char)0;
  *str = s;
  tmp___1 = strlen((char const   *)s);
  return ((int )tmp___1);
}
}
int base64_decode(char const   *str , void *data ) 
{ 
  char const   *p ;
  unsigned char *q ;
  int c ;
  int x ;
  int done ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
  done = 0;
  q = (unsigned char *)data;
  p = str;
  while (1) {
    if (*p) {
      if (! (! done)) {
        break;
      }
    } else {
      break;
    }
    x = pos((char )*(p + 0));
    if (x >= 0) {
      c = x;
    } else {
      done = 3;
      break;
    }
    c *= 64;
    x = pos((char )*(p + 1));
    if (x >= 0) {
      c += x;
    } else {
      return (-1);
    }
    c *= 64;
    if ((int const   )*(p + 2) == 61) {
      done ++;
    } else {
      x = pos((char )*(p + 2));
      if (x >= 0) {
        c += x;
      } else {
        return (-1);
      }
    }
    c *= 64;
    if ((int const   )*(p + 3) == 61) {
      done ++;
    } else {
      if (done) {
        return (-1);
      }
      x = pos((char )*(p + 3));
      if (x >= 0) {
        c += x;
      } else {
        return (-1);
      }
    }
    if (done < 3) {
      tmp = q;
      q ++;
      *tmp = (unsigned char )((c & 16711680) >> 16);
    }
    if (done < 2) {
      tmp___0 = q;
      q ++;
      *tmp___0 = (unsigned char )((c & 65280) >> 8);
    }
    if (done < 1) {
      tmp___1 = q;
      q ++;
      *tmp___1 = (unsigned char )(c & 255);
    }
    p += 4;
  }
  return ((int )(q - (unsigned char *)data));
}
}
#pragma merger("0","/tmp/cil-EtNFcZDr.i","-W,-Wall,-Wunused-value,-g,-O2")
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t const   * __restrict  __timer ,
                                                            struct tm * __restrict  __tp ) ;
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
extern void pthread_testcancel(void) ;
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
extern  __attribute__((__noreturn__)) void __pthread_unwind_next(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__)) ;
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) clock_t times(struct tms *__buffer ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
URL new_url(char *str ) ;
URL url_destroy(URL this ) ;
void url_set_ID(URL this , int ID ) ;
void url_set_hostname(URL this , char *hostname ) ;
void url_set_redirect(URL this , BOOLEAN redir ) ;
void url_set_conttype(URL this , char *type ) ;
void url_set_postdata(URL this , char *postdata , size_t postlen ) ;
void url_set_method(URL this , METHOD method___0 ) ;
int url_get_ID(URL this ) ;
METHOD url_get_method(URL this ) ;
char *url_get_method_name(URL this ) ;
BOOLEAN url_is_redirect(URL this ) ;
char *url_get_absolute(URL this ) ;
SCHEME url_get_scheme(URL this ) ;
char *url_get_username(URL this ) ;
char *url_get_password(URL this ) ;
char *url_get_hostname(URL this ) ;
int url_get_port(URL this ) ;
char *url_get_request(URL this ) ;
char *url_get_display(URL this ) ;
size_t url_get_postlen(URL this ) ;
char *url_get_postdata(URL this ) ;
char *url_get_conttype(URL this ) ;
void url_set_username(URL this , char *username ) ;
void url_set_password(URL this , char *password ) ;
URL url_normalize(URL req , char *location ) ;
void *hash_get(HASH this , char *key ) ;
char **hash_get_keys(HASH this ) ;
int hash_get_entries(HASH this ) ;
BOOLEAN cookies_add(COOKIES this , char *str , char *host ) ;
BOOLEAN cookies_delete_all(COOKIES this ) ;
struct CONFIG my ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg ) 
{ 


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
PAGE new_page(char *str ) ;
PAGE page_destroy(PAGE this ) ;
void page_clear(PAGE this ) ;
char *page_value(PAGE this ) ;
DATE new_date(char *date ) ;
DATE date_destroy(DATE this ) ;
char *date_stamp(DATE this ) ;
CACHE new_cache(void) ;
CACHE cache_destroy(CACHE this ) ;
BOOLEAN is_cached(CACHE this , URL U ) ;
int new_socket(CONN *C , char const   *hostparam , int portparam ) ;
void socket_close(CONN *C ) ;
BOOLEAN SSL_initialize(CONN *C , char const   *servername ) ;
BOOLEAN ftp_login(CONN *C , URL U ) ;
BOOLEAN ftp_size(CONN *C , URL U ) ;
BOOLEAN ftp_pasv(CONN *C ) ;
BOOLEAN ftp_stor(CONN *C , URL U ) ;
BOOLEAN ftp_retr(CONN *C , URL U ) ;
size_t ftp_get(CONN *D , URL U , size_t size ) ;
size_t ftp_put(CONN *D , URL U ) ;
BOOLEAN ftp_quit(CONN *C ) ;
RESPONSE new_response(void) ;
RESPONSE response_destroy(RESPONSE this ) ;
BOOLEAN response_set_code(RESPONSE this , char *line ) ;
int response_get_code(RESPONSE this ) ;
char *response_get_protocol(RESPONSE this ) ;
void response_set_from_cache(RESPONSE this , BOOLEAN cached ) ;
BOOLEAN response_get_from_cache(RESPONSE this ) ;
int response_success(RESPONSE this ) ;
int response_failure(RESPONSE this ) ;
char *response_get_content_type(RESPONSE this ) ;
char *response_get_location(RESPONSE this ) ;
TYPE response_get_www_auth_type(RESPONSE this ) ;
char *response_get_www_auth_challenge(RESPONSE this ) ;
char *response_get_www_auth_realm(RESPONSE this ) ;
TYPE response_get_proxy_auth_type(RESPONSE this ) ;
char *response_get_proxy_auth_challenge(RESPONSE this ) ;
char *response_get_proxy_auth_realm(RESPONSE this ) ;
BOOLEAN http_get(CONN *C , URL U ) ;
BOOLEAN http_post(CONN *C , URL U ) ;
RESPONSE http_read_headers(CONN *C , URL U ) ;
ssize_t http_read(CONN *C , RESPONSE resp ) ;
BOOLEAN https_tunnel_request(CONN *C , char *host , int port ) ;
int https_tunnel_response(CONN *C ) ;
float elapsed_time(clock_t time___0 ) ;
void pthread_sleep_np(unsigned int secs ) ;
void pthread_usleep_np(unsigned long usec ) ;
int urandom(void) ;
void echo(char const   *fmt  , ...) ;
void debug(char const   *fmt  , ...) ;
char *stristr(char const   *haystack , char const   *needle ) ;
BOOLEAN html_parser(ARRAY array , URL base , char *page ) ;
BOOLEAN empty(char const   *s ) ;
void DISPLAY(int color , char const   *fmt  , ...) ;
size_t BROWSERSIZE ;
BROWSER new_browser(int id ) ;
BROWSER browser_destroy(BROWSER this ) ;
void *start(BROWSER this ) ;
void browser_set_urls(BROWSER this , ARRAY urls ) ;
void browser_set_cookies(BROWSER this , HASH cookies ) ;
unsigned long browser_get_hits(BROWSER this ) ;
unsigned long long browser_get_bytes(BROWSER this ) ;
float browser_get_time(BROWSER this ) ;
unsigned int browser_get_code(BROWSER this ) ;
unsigned int browser_get_okay(BROWSER this ) ;
unsigned int browser_get_fail(BROWSER this ) ;
float browser_get_himark(BROWSER this ) ;
float browser_get_lomark(BROWSER this ) ;
float __himark  =    (float )0;
float __lomark  =    (float )-1;
size_t BROWSERSIZE  =    sizeof(struct BROWSER_T );
static BOOLEAN __init_connection(BROWSER this , URL U ) ;
static BOOLEAN __request(BROWSER this , URL U ) ;
static BOOLEAN __http(BROWSER this , URL U ) ;
static BOOLEAN __ftp(BROWSER this , URL U ) ;
static BOOLEAN __no_follow(char const   *hostname ) ;
static void __increment_failures(void) ;
static int __select_color(int code ) ;
static void __display_result(BROWSER this , RESPONSE resp , URL U , unsigned long bytes ,
                             float etime ) ;
static void __signal_cleanup(void) ;
BROWSER new_browser(int id ) 
{ 
  BROWSER this ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = calloc(BROWSERSIZE, (size_t )1);
  this = (BROWSER )tmp;
  this->id = id;
  this->total = (float )0.0;
  this->available = (float )0.0;
  this->count = (unsigned int )0.0;
  this->okay = 0U;
  this->fail = 0U;
  this->lowest = (float )-1;
  this->highest = (float )0.0;
  this->elapsed = (float )0.0;
  this->bytes = (unsigned long long )0.0;
  this->urls = (ARRAY )((void *)0);
  this->parts = new_array();
  tmp___0 = urandom();
  this->rseed = (unsigned int )tmp___0;
  return (this);
}
}
BROWSER browser_destroy(BROWSER this ) 
{ 
  URL u ;
  void *tmp ;

  {
  if ((unsigned long )this != (unsigned long )((void *)0)) {
    if ((unsigned long )this->parts != (unsigned long )((void *)0)) {
      while (1) {
        tmp = array_pop(this->parts);
        u = (URL )tmp;
        if (! ((unsigned long )u != (unsigned long )((void *)0))) {
          break;
        }
        u = url_destroy(u);
      }
      this->parts = array_destroy(this->parts);
    }
    xfree((void *)this);
  }
  this = (BROWSER )((void *)0);
  return (this);
}
}
unsigned long browser_get_hits(BROWSER this ) 
{ 


  {
  return (this->hits);
}
}
unsigned long long browser_get_bytes(BROWSER this ) 
{ 


  {
  return (this->bytes);
}
}
float browser_get_time(BROWSER this ) 
{ 


  {
  return (this->time);
}
}
unsigned int browser_get_code(BROWSER this ) 
{ 


  {
  return (this->code);
}
}
unsigned int browser_get_okay(BROWSER this ) 
{ 


  {
  return (this->okay);
}
}
unsigned int browser_get_fail(BROWSER this ) 
{ 


  {
  return (this->fail);
}
}
float browser_get_himark(BROWSER this ) 
{ 


  {
  return (this->himark);
}
}
float browser_get_lomark(BROWSER this ) 
{ 


  {
  return (this->lomark);
}
}
void *start(BROWSER this ) 
{ 
  int x ;
  int y ;
  int max_y ;
  int ret ;
  int len ;
  void *tmp ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp___0 ;
  long tmp___1 ;
  URL tmp___2 ;
  void *tmp___3 ;
  URL tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  URL tmp___8 ;
  void *tmp___9 ;
  BOOLEAN tmp___10 ;
  char *tmp___11 ;
  URL u ;
  RESPONSE r ;
  RESPONSE tmp___12 ;
  BOOLEAN tmp___13 ;
  char *tmp___14 ;
  BOOLEAN tmp___15 ;
  BOOLEAN tmp___16 ;
  SCHEME tmp___17 ;
  void *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  this->conn = (CONN *)((void *)0);
  tmp = xcalloc(sizeof(CONN ), (size_t )1);
  this->conn = (CONN *)tmp;
  (this->conn)->sock = -1;
  (this->conn)->page = new_page("");
  (this->conn)->cache = new_cache();
  while (1) {
    __cancel_routine = (void (*)(void * ))((void *)(& __signal_cleanup));
    __cancel_arg = (void *)this->conn;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    __not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )__not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      pthread_setcanceltype(1, & this->type);
      pthread_setcancelstate(0, & this->state);
      if ((unsigned int )my.login == 1U) {
        tmp___3 = array_next(my.lurl);
        tmp___4 = new_url((char *)tmp___3);
        tmp___2 = tmp___4;
        url_set_ID(tmp___2, 0);
        __request(this, tmp___2);
      }
      if (my.reps == -1) {
        tmp___5 = array_length(this->urls);
        len = (int )tmp___5;
      } else {
        len = my.reps;
      }
      if (my.reps == -1) {
        y = 0;
      } else {
        y = this->id * (my.length / my.cusers);
      }
      tmp___6 = array_length(this->urls);
      max_y = (int )tmp___6;
      x = 0;
      while (x < len) {
        if (my.secs > 0) {
          if (my.reps <= 0) {
            x = 0;
          } else
          if (my.reps == 10301062) {
            x = 0;
          } else {
            x = x;
          }
        } else {
          x = x;
        }
        if ((unsigned int )my.internet == 1U) {
          tmp___7 = pthread_rand_np(& this->rseed);
          y = (int )((unsigned int )(((double )tmp___7 / ((double )2147483647 + (double )1)) * (double )my.length + .5));
          if (y >= my.length) {
            y = my.length - 1;
          } else {
            y = y;
          }
          if (y < 0) {
            y = 0;
          } else {
            y = y;
          }
        } else
        if (y >= max_y) {
          y = 0;
          if (my.expire) {
            cookies_delete_all(my.cookies);
          }
        }
        if (y >= max_y) {
          y = 0;
        } else
        if (y < 0) {
          y = 0;
        }
        tmp___9 = array_get(this->urls, y);
        tmp___8 = (URL )tmp___9;
        if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
          tmp___11 = url_get_hostname(tmp___8);
          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
            this->auth.bids.www = 0;
            tmp___10 = __request(this, tmp___8);
            ret = (int )tmp___10;
            if (ret == 0) {
              __increment_failures();
            }
          }
        }
        if ((unsigned int )my.parser == 1U) {
          if ((unsigned long )this->parts != (unsigned long )((void *)0)) {
            while (1) {
              tmp___18 = array_pop(this->parts);
              u = (URL )tmp___18;
              if (! ((unsigned long )u != (unsigned long )((void *)0))) {
                break;
              }
              tmp___17 = url_get_scheme(u);
              if (! ((unsigned int )tmp___17 == 0U)) {
                if (my.cache) {
                  tmp___16 = is_cached((this->conn)->cache, u);
                  if (tmp___16) {
                    tmp___12 = new_response();
                    r = tmp___12;
                    response_set_code(r, (char *)"HTTP/1.1 200 OK");
                    response_set_from_cache(r, (BOOLEAN )1);
                    __display_result(this, r, u, 0UL, (float )0.00);
                    r = response_destroy(r);
                  } else {
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  this->auth.bids.www = 0;
                  tmp___14 = url_get_hostname(u);
                  tmp___15 = __no_follow((char const   *)tmp___14);
                  if (! tmp___15) {
                    tmp___13 = __request(this, u);
                    ret = (int )tmp___13;
                    if (ret == 0) {
                      __increment_failures();
                    }
                  }
                }
              }
              u = url_destroy(u);
            }
          }
        }
        if (my.delay >= (float )1) {
          tmp___19 = pthread_rand_np(& this->rseed);
          pthread_sleep_np((unsigned int )(((double )tmp___19 / ((double )2147483647 + (double )1)) * (double )my.delay + .5));
        } else
        if ((double )my.delay >= .001) {
          tmp___20 = pthread_rand_np(& this->rseed);
          pthread_usleep_np((unsigned long )((unsigned int )((((double )tmp___20 / ((double )2147483647 + (double )1)) * (double )my.delay) * (double )1000000 + .0005)));
        }
        if (my.failures > 0) {
          if (my.failed >= my.failures) {
            break;
          }
        }
        x ++;
        y ++;
      }
      while (1) {
        break;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    break;
  }
  if ((this->conn)->sock >= 0) {
    (this->conn)->connection.reuse = 0;
    socket_close(this->conn);
  }
  (this->conn)->page = page_destroy((this->conn)->page);
  (this->conn)->cache = cache_destroy((this->conn)->cache);
  xfree((void *)this->conn);
  this->conn = (CONN *)((void *)0);
  return ((void *)0);
}
}
void browser_set_urls(BROWSER this , ARRAY urls ) 
{ 


  {
  this->urls = urls;
  return;
}
}
void browser_set_cookies(BROWSER this , HASH cookies ) 
{ 
  int i ;
  char **keys___0 ;
  char **tmp ;
  char *tmp___0 ;
  int len ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
  i = 0;
  this->cookies = cookies;
  if ((unsigned long )this->cookies != (unsigned long )((void *)0)) {
    tmp = hash_get_keys(this->cookies);
    keys___0 = tmp;
    i = 0;
    while (1) {
      tmp___5 = hash_get_entries(this->cookies);
      if (! (i < tmp___5)) {
        break;
      }
      tmp___1 = hash_get(this->cookies, *(keys___0 + i));
      tmp___2 = strlen((char const   *)tmp___1);
      len = (int )tmp___2;
      tmp___3 = xmalloc((size_t )(len + 2));
      tmp___0 = (char *)tmp___3;
      memset((void *)tmp___0, '\000', (size_t )(len + 2));
      tmp___4 = hash_get(this->cookies, *(keys___0 + i));
      snprintf((char * __restrict  )tmp___0, (size_t )(len + 1), (char const   * __restrict  )"%s",
               (char *)tmp___4);
      cookies_add(my.cookies, tmp___0, (char *)".");
      xfree((void *)tmp___0);
      i ++;
    }
  }
  return;
}
}
static BOOLEAN __request(BROWSER this , URL U ) 
{ 
  BOOLEAN tmp ;
  BOOLEAN tmp___0 ;

  {
  (this->conn)->scheme = url_get_scheme(U);
  switch ((unsigned int )(this->conn)->scheme) {
  case 3U: 
  tmp = __ftp(this, U);
  return (tmp);
  default: 
  tmp___0 = __http(this, U);
  return (tmp___0);
  }
}
}
static BOOLEAN __http(BROWSER this , URL U ) 
{ 
  unsigned long bytes ;
  int code ;
  int okay___0 ;
  int fail ;
  float etime ;
  clock_t start___0 ;
  clock_t stop ;
  struct tms t_start ;
  struct tms t_stop ;
  RESPONSE resp ;
  char *meta ;
  struct tm keepsake ;
  time_t now ;
  struct tm *tmp ;
  size_t len ;
  char fmtime[65] ;
  URL redirect_url ;
  struct tm *tmp___0 ;
  SCHEME tmp___1 ;
  BOOLEAN tmp___2 ;
  BOOLEAN tmp___3 ;
  BOOLEAN tmp___4 ;
  METHOD tmp___5 ;
  METHOD tmp___6 ;
  METHOD tmp___7 ;
  METHOD tmp___8 ;
  METHOD tmp___9 ;
  ssize_t tmp___10 ;
  char *tmp___11 ;
  int i ;
  char *tmp___12 ;
  URL url ;
  void *tmp___13 ;
  URL tmp___14 ;
  void *tmp___15 ;
  char *tmp___16 ;
  BOOLEAN tmp___17 ;
  size_t tmp___18 ;
  char *tmp___19 ;
  BOOLEAN tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  BOOLEAN tmp___23 ;
  BOOLEAN tmp___24 ;
  size_t tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  BOOLEAN tmp___29 ;
  BOOLEAN tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  BOOLEAN tmp___35 ;
  char *tmp___36 ;
  METHOD tmp___37 ;
  size_t tmp___38 ;
  char *tmp___39 ;
  METHOD tmp___40 ;
  METHOD tmp___41 ;
  METHOD tmp___42 ;
  METHOD tmp___43 ;
  METHOD tmp___44 ;
  BOOLEAN tmp___45 ;
  char *tmp___46 ;
  BOOLEAN b ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  TYPE tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  TYPE tmp___53 ;
  char *tmp___54 ;
  TYPE tmp___55 ;
  BOOLEAN tmp___56 ;
  int tmp___57 ;
  BOOLEAN b___0 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  TYPE tmp___61 ;
  char *tmp___62 ;
  TYPE tmp___63 ;
  BOOLEAN tmp___64 ;
  int tmp___65 ;

  {
  bytes = 0UL;
  meta = (char *)((void *)0);
  redirect_url = (URL )((void *)0);
  page_clear((this->conn)->page);
  if (my.csv) {
    now = time((time_t *)((void *)0));
    tmp___0 = localtime_r((time_t const   * __restrict  )(& now), (struct tm * __restrict  )(& keepsake));
    tmp = tmp___0;
    if (tmp) {
      len = strftime((char * __restrict  )(fmtime), (size_t )64, (char const   * __restrict  )"%Y-%m-%d %H:%M:%S",
                     (struct tm  const  * __restrict  )tmp);
      if (len == 0UL) {
        memset((void *)(fmtime), '\000', (size_t )64);
        snprintf((char * __restrict  )(fmtime), (size_t )64, (char const   * __restrict  )"n/a");
      }
    } else {
      snprintf((char * __restrict  )(fmtime), (size_t )64, (char const   * __restrict  )"n/a");
    }
  }
  tmp___1 = url_get_scheme(U);
  if ((unsigned int )tmp___1 == 0U) {
    if (my.verbose) {
      if (! my.get) {
        if (! my.print) {
          NOTIFY((LEVEL )2, "%s %d %6.2f secs: %7d bytes ==> %s\n", "UNSPPRTD", 501,
                 0.00, 0, "PROTOCOL NOT SUPPORTED BY SIEGE");
        }
      }
    }
    return ((BOOLEAN )0);
  }
  start___0 = times(& t_start);
  tmp___2 = __init_connection(this, U);
  if (! tmp___2) {
    return ((BOOLEAN )0);
  }
  tmp___5 = url_get_method(U);
  if ((unsigned int )tmp___5 == 3U) {
    goto _L;
  } else {
    tmp___6 = url_get_method(U);
    if ((unsigned int )tmp___6 == 4U) {
      goto _L;
    } else {
      tmp___7 = url_get_method(U);
      if ((unsigned int )tmp___7 == 9U) {
        goto _L;
      } else {
        tmp___8 = url_get_method(U);
        if ((unsigned int )tmp___8 == 5U) {
          goto _L;
        } else {
          tmp___9 = url_get_method(U);
          if ((unsigned int )tmp___9 == 7U) {
            _L: /* CIL Label */ 
            tmp___3 = http_post(this->conn, U);
            if ((unsigned int )tmp___3 == 0U) {
              (this->conn)->connection.reuse = 0;
              socket_close(this->conn);
              return ((BOOLEAN )0);
            }
          } else {
            tmp___4 = http_get(this->conn, U);
            if ((unsigned int )tmp___4 == 0U) {
              (this->conn)->connection.reuse = 0;
              socket_close(this->conn);
              return ((BOOLEAN )0);
            }
          }
        }
      }
    }
  }
  resp = http_read_headers(this->conn, U);
  if ((unsigned long )resp == (unsigned long )((void *)0)) {
    (this->conn)->connection.reuse = 0;
    socket_close(this->conn);
    echo("%s:%d NULL headers", "browser.c", 496);
    return ((BOOLEAN )0);
  }
  code = response_get_code(resp);
  if (code == 418) {
    (this->conn)->connection.reuse = 0;
    socket_close(this->conn);
    stop = times(& t_stop);
    etime = elapsed_time(stop - start___0);
    (this->hits) ++;
    this->time += etime;
    (this->fail) ++;
    __display_result(this, resp, U, 0UL, etime);
    resp = response_destroy(resp);
    return ((BOOLEAN )0);
  }
  tmp___10 = http_read(this->conn, resp);
  bytes = (unsigned long )tmp___10;
  if (my.print) {
    tmp___11 = page_value((this->conn)->page);
    printf((char const   * __restrict  )"%s\n", tmp___11);
  }
  if ((unsigned int )my.parser == 1U) {
    tmp___19 = response_get_content_type(resp);
    tmp___20 = strmatch(tmp___19, (char *)"text/html");
    if (tmp___20) {
      if (code < 300) {
        tmp___12 = page_value((this->conn)->page);
        html_parser(this->parts, U, tmp___12);
        i = 0;
        while (1) {
          tmp___18 = array_length(this->parts);
          if (! (i < (int )tmp___18)) {
            break;
          }
          tmp___13 = array_get(this->parts, i);
          url = (URL )tmp___13;
          tmp___17 = url_is_redirect(url);
          if (tmp___17) {
            tmp___15 = array_remove(this->parts, i);
            tmp___14 = (URL )tmp___15;
            tmp___16 = url_get_absolute(tmp___14);
            meta = xstrdup((char const   *)tmp___16);
            tmp___14 = url_destroy(tmp___14);
          }
          i ++;
        }
      }
    }
  }
  if (! my.zero_ok) {
    if (bytes < 1UL) {
      (this->conn)->connection.reuse = 0;
      socket_close(this->conn);
      resp = response_destroy(resp);
      echo("%s:%d zero bytes back from server", "browser.c", 544);
      return ((BOOLEAN )0);
    }
  }
  stop = times(& t_stop);
  etime = elapsed_time(stop - start___0);
  okay___0 = response_success(resp);
  fail = response_failure(resp);
  this->bytes += (unsigned long long )bytes;
  this->time += etime;
  this->code += (unsigned int )okay___0;
  this->fail += (unsigned int )fail;
  if (code == 200) {
    (this->okay) ++;
  }
  if (etime > __himark) {
    __himark = etime;
  }
  if (__lomark < (float )0) {
    __lomark = etime;
  } else
  if (etime < __lomark) {
    __lomark = etime;
  }
  this->himark = __himark;
  this->lomark = __lomark;
  __display_result(this, resp, U, bytes, etime);
  if (! my.keepalive) {
    socket_close(this->conn);
  }
  switch (code) {
  case 200: 
  if ((unsigned long )meta != (unsigned long )((void *)0)) {
    tmp___25 = strlen((char const   *)meta);
    if (tmp___25 > 2UL) {
      redirect_url = url_normalize(U, meta);
      xfree((void *)meta);
      meta = (char *)((void *)0);
      page_clear((this->conn)->page);
      tmp___22 = url_get_hostname(redirect_url);
      tmp___23 = empty((char const   *)tmp___22);
      if (tmp___23) {
        tmp___21 = url_get_hostname(U);
        url_set_hostname(redirect_url, tmp___21);
      }
      url_set_redirect(U, (BOOLEAN )0);
      url_set_redirect(redirect_url, (BOOLEAN )0);
      tmp___24 = __request(this, redirect_url);
      if ((unsigned int )tmp___24 == 0U) {
        redirect_url = url_destroy(redirect_url);
        return ((BOOLEAN )0);
      }
      redirect_url = url_destroy(redirect_url);
    }
  }
  break;
  case 201: 
  if (my.follow) {
    tmp___31 = response_get_location(resp);
    if ((unsigned long )tmp___31 != (unsigned long )((void *)0)) {
      tmp___26 = response_get_location(resp);
      redirect_url = url_normalize(U, tmp___26);
      tmp___28 = url_get_hostname(redirect_url);
      tmp___29 = empty((char const   *)tmp___28);
      if (tmp___29) {
        tmp___27 = url_get_hostname(U);
        url_set_hostname(redirect_url, tmp___27);
      }
      tmp___30 = __request(this, redirect_url);
      if ((unsigned int )tmp___30 == 0U) {
        redirect_url = url_destroy(redirect_url);
        return ((BOOLEAN )0);
      }
    }
  }
  break;
  case 307: 
  case 303: 
  case 302: 
  case 301: 
  if (my.follow) {
    tmp___46 = response_get_location(resp);
    if ((unsigned long )tmp___46 != (unsigned long )((void *)0)) {
      tmp___32 = response_get_location(resp);
      redirect_url = url_normalize(U, tmp___32);
      tmp___34 = url_get_hostname(redirect_url);
      tmp___35 = empty((char const   *)tmp___34);
      if (tmp___35) {
        tmp___33 = url_get_hostname(U);
        url_set_hostname(redirect_url, tmp___33);
      }
      if (code == 307) {
        tmp___36 = url_get_conttype(U);
        url_set_conttype(redirect_url, tmp___36);
        tmp___37 = url_get_method(U);
        url_set_method(redirect_url, tmp___37);
        tmp___40 = url_get_method(redirect_url);
        if ((unsigned int )tmp___40 == 3U) {
          tmp___38 = url_get_postlen(U);
          tmp___39 = url_get_postdata(U);
          url_set_postdata(redirect_url, tmp___39, tmp___38);
        } else {
          tmp___41 = url_get_method(redirect_url);
          if ((unsigned int )tmp___41 == 4U) {
            tmp___38 = url_get_postlen(U);
            tmp___39 = url_get_postdata(U);
            url_set_postdata(redirect_url, tmp___39, tmp___38);
          } else {
            tmp___42 = url_get_method(redirect_url);
            if ((unsigned int )tmp___42 == 9U) {
              tmp___38 = url_get_postlen(U);
              tmp___39 = url_get_postdata(U);
              url_set_postdata(redirect_url, tmp___39, tmp___38);
            } else {
              tmp___43 = url_get_method(U);
              if ((unsigned int )tmp___43 == 5U) {
                tmp___38 = url_get_postlen(U);
                tmp___39 = url_get_postdata(U);
                url_set_postdata(redirect_url, tmp___39, tmp___38);
              } else {
                tmp___44 = url_get_method(U);
                if ((unsigned int )tmp___44 == 7U) {
                  tmp___38 = url_get_postlen(U);
                  tmp___39 = url_get_postdata(U);
                  url_set_postdata(redirect_url, tmp___39, tmp___38);
                }
              }
            }
          }
        }
      }
      tmp___45 = __request(this, redirect_url);
      if ((unsigned int )tmp___45 == 0U) {
        redirect_url = url_destroy(redirect_url);
        return ((BOOLEAN )0);
      }
    }
  }
  redirect_url = url_destroy(redirect_url);
  break;
  case 401: 
  if (this->auth.www == 0) {
    this->auth.www = 1;
  } else {
    this->auth.www = this->auth.www;
  }
  tmp___57 = this->auth.bids.www;
  (this->auth.bids.www) ++;
  if (tmp___57 < my.bids - 1) {
    tmp___50 = response_get_www_auth_type(resp);
    if ((unsigned int )tmp___50 == 1U) {
      this->auth.type.www = (TYPE )1;
      tmp___47 = response_get_www_auth_challenge(resp);
      tmp___48 = response_get_www_auth_realm(resp);
      b = auth_set_digest_header(my.auth, & this->auth.wchlg, & this->auth.wcred,
                                 & this->rseed, tmp___48, tmp___47);
      if ((unsigned int )b == 0U) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Unable to respond to an authorization challenge\n");
        tmp___49 = response_get_www_auth_realm(resp);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"       in the following realm: \'%s\'\n",
                tmp___49);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"       Did you set login credentials in the conf file?\n");
        resp = response_destroy(resp);
        return ((BOOLEAN )0);
      }
    }
    tmp___53 = response_get_www_auth_type(resp);
    if ((unsigned int )tmp___53 == 2U) {
      this->auth.type.www = (TYPE )2;
      tmp___51 = response_get_www_auth_realm(resp);
      tmp___52 = response_get_www_auth_challenge(resp);
      b = auth_set_ntlm_header(my.auth, (SCHEME )1, tmp___52, tmp___51);
    }
    tmp___55 = response_get_www_auth_type(resp);
    if ((unsigned int )tmp___55 == 0U) {
      this->auth.type.www = (TYPE )0;
      tmp___54 = response_get_www_auth_realm(resp);
      auth_set_basic_header(my.auth, (SCHEME )1, tmp___54);
    }
    tmp___56 = __request(this, U);
    if ((unsigned int )tmp___56 == 0U) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR from http_request\n");
      return ((BOOLEAN )0);
    }
  }
  break;
  case 407: 
  if (this->auth.proxy == 0) {
    this->auth.proxy = 1;
  } else {
    this->auth.proxy = this->auth.proxy;
  }
  tmp___65 = this->auth.bids.proxy;
  (this->auth.bids.proxy) ++;
  if (tmp___65 < my.bids - 1) {
    tmp___61 = response_get_proxy_auth_type(resp);
    if ((unsigned int )tmp___61 == 1U) {
      this->auth.type.proxy = (TYPE )1;
      tmp___58 = response_get_proxy_auth_challenge(resp);
      tmp___59 = response_get_proxy_auth_realm(resp);
      b___0 = auth_set_digest_header(my.auth, & this->auth.pchlg, & this->auth.pcred,
                                     & this->rseed, tmp___59, tmp___58);
      if ((unsigned int )b___0 == 0U) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Unable to respond to a proxy authorization challenge\n");
        tmp___60 = response_get_proxy_auth_realm(resp);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"       in the following HTTP realm: \'%s\'\n",
                tmp___60);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"       Did you set proxy-login credentials in the conf file?\n");
        resp = response_destroy(resp);
        return ((BOOLEAN )0);
      }
    }
    tmp___63 = response_get_proxy_auth_type(resp);
    if ((unsigned int )tmp___63 == 0U) {
      this->auth.type.proxy = (TYPE )0;
      tmp___62 = response_get_proxy_auth_realm(resp);
      auth_set_basic_header(my.auth, (SCHEME )4, tmp___62);
    }
    tmp___64 = __request(this, U);
    if ((unsigned int )tmp___64 == 0U) {
      return ((BOOLEAN )0);
    }
  }
  break;
  case 509: 
  case 508: 
  case 507: 
  case 506: 
  case 505: 
  case 504: 
  case 503: 
  case 502: 
  case 501: 
  case 500: 
  case 408: 
  return ((BOOLEAN )0);
  default: 
  break;
  }
  (this->hits) ++;
  resp = response_destroy(resp);
  return ((BOOLEAN )1);
}
}
static BOOLEAN __ftp(BROWSER this , URL U ) 
{ 
  int pass ;
  int fail ;
  int code ;
  float etime ;
  CONN *D ;
  size_t bytes ;
  clock_t start___0 ;
  clock_t stop ;
  struct tms t_start ;
  struct tms t_stop ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  BOOLEAN tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  int color ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  BOOLEAN tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;
  BOOLEAN tmp___22 ;
  BOOLEAN tmp___23 ;
  METHOD tmp___24 ;
  METHOD tmp___25 ;
  METHOD tmp___26 ;
  METHOD tmp___27 ;
  METHOD tmp___28 ;
  int color___0 ;
  int tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;

  {
  code = 0;
  D = (CONN *)((void *)0);
  bytes = (size_t )0;
  tmp = xcalloc(sizeof(CONN ), (size_t )1);
  D = (CONN *)tmp;
  D->sock = -1;
  tmp___2 = __init_connection(this, U);
  if (! tmp___2) {
    tmp___0 = url_get_port(U);
    tmp___1 = url_get_hostname(U);
    NOTIFY((LEVEL )2, "%s:%d connection failed %s:%d", "browser.c", 765, tmp___1,
           tmp___0);
    xfree((void *)D);
    return ((BOOLEAN )0);
  }
  start___0 = times(& t_start);
  if ((this->conn)->sock < 0) {
    tmp___3 = url_get_port(U);
    tmp___4 = url_get_hostname(U);
    NOTIFY((LEVEL )2, "%s:%d connection failed %s:%d", "browser.c", 775, tmp___4,
           tmp___3);
    socket_close(this->conn);
    xfree((void *)D);
    return ((BOOLEAN )0);
  }
  tmp___7 = url_get_username(U);
  if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
    tmp___5 = url_get_hostname(U);
    tmp___6 = auth_get_ftp_username(my.auth, tmp___5);
    url_set_username(U, tmp___6);
  } else {
    tmp___8 = url_get_username(U);
    tmp___9 = strlen((char const   *)tmp___8);
    if (tmp___9 < 1UL) {
      tmp___5 = url_get_hostname(U);
      tmp___6 = auth_get_ftp_username(my.auth, tmp___5);
      url_set_username(U, tmp___6);
    }
  }
  tmp___12 = url_get_password(U);
  if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
    tmp___10 = url_get_hostname(U);
    tmp___11 = auth_get_ftp_password(my.auth, tmp___10);
    url_set_password(U, tmp___11);
  } else {
    tmp___13 = url_get_password(U);
    tmp___14 = strlen((char const   *)tmp___13);
    if (tmp___14 < 1UL) {
      tmp___10 = url_get_hostname(U);
      tmp___11 = auth_get_ftp_password(my.auth, tmp___10);
      url_set_password(U, tmp___11);
    }
  }
  tmp___18 = ftp_login(this->conn, U);
  if ((unsigned int )tmp___18 == 0U) {
    if (my.verbose) {
      tmp___15 = __select_color((this->conn)->ftp.code);
      color = tmp___15;
      tmp___16 = url_get_request(U);
      tmp___17 = url_get_method_name(U);
      DISPLAY(color, "FTP/%d %6.2f secs: %7lu bytes ==> %-6s %s", (this->conn)->ftp.code,
              0.0, bytes, tmp___17, tmp___16);
    }
    xfree((void *)D);
    (this->fail) ++;
    return ((BOOLEAN )0);
  }
  ftp_pasv(this->conn);
  if ((unsigned int )(this->conn)->ftp.pasv == 1U) {
    debug("Connecting to: %s:%d", (this->conn)->ftp.host, (this->conn)->ftp.port);
    D->sock = new_socket(D, (char const   *)((this->conn)->ftp.host), (this->conn)->ftp.port);
    if (D->sock < 0) {
      tmp___19 = __errno_location();
      tmp___20 = strerror(*tmp___19);
      tmp___21 = __errno_location();
      debug("%s:%d connection failed. error %d(%s)", "browser.c", 809, *tmp___21,
            tmp___20);
      (this->fail) ++;
      socket_close(D);
      xfree((void *)D);
      return ((BOOLEAN )0);
    }
  }
  tmp___24 = url_get_method(U);
  if ((unsigned int )tmp___24 == 3U) {
    ftp_stor(this->conn, U);
    bytes = ftp_put(D, U);
    code = (this->conn)->ftp.code;
  } else {
    tmp___25 = url_get_method(U);
    if ((unsigned int )tmp___25 == 4U) {
      ftp_stor(this->conn, U);
      bytes = ftp_put(D, U);
      code = (this->conn)->ftp.code;
    } else {
      tmp___26 = url_get_method(U);
      if ((unsigned int )tmp___26 == 9U) {
        ftp_stor(this->conn, U);
        bytes = ftp_put(D, U);
        code = (this->conn)->ftp.code;
      } else {
        tmp___27 = url_get_method(U);
        if ((unsigned int )tmp___27 == 5U) {
          ftp_stor(this->conn, U);
          bytes = ftp_put(D, U);
          code = (this->conn)->ftp.code;
        } else {
          tmp___28 = url_get_method(U);
          if ((unsigned int )tmp___28 == 7U) {
            ftp_stor(this->conn, U);
            bytes = ftp_put(D, U);
            code = (this->conn)->ftp.code;
          } else {
            tmp___23 = ftp_size(this->conn, U);
            if ((unsigned int )tmp___23 == 1U) {
              tmp___22 = ftp_retr(this->conn, U);
              if ((unsigned int )tmp___22 == 1U) {
                bytes = ftp_get(D, U, (this->conn)->ftp.size);
              }
            }
            code = (this->conn)->ftp.code;
          }
        }
      }
    }
  }
  socket_close(D);
  ftp_quit(this->conn);
  if (bytes == (this->conn)->ftp.size) {
    pass = 1;
  } else {
    pass = 0;
  }
  if (pass == 0) {
    fail = 1;
  } else {
    fail = 0;
  }
  stop = times(& t_stop);
  etime = elapsed_time(stop - start___0);
  this->bytes += (unsigned long long )bytes;
  this->time += etime;
  this->code += (unsigned int )pass;
  this->fail += (unsigned int )fail;
  if (etime > __himark) {
    __himark = etime;
  }
  if (__lomark < (float )0) {
    __lomark = etime;
  } else
  if (etime < __lomark) {
    __lomark = etime;
  }
  this->himark = __himark;
  this->lomark = __lomark;
  if (my.verbose) {
    if ((unsigned int )my.color == 1U) {
      tmp___29 = __select_color(code);
      tmp___30 = tmp___29;
    } else {
      tmp___30 = -1;
    }
    color___0 = tmp___30;
    tmp___31 = url_get_request(U);
    tmp___32 = url_get_method_name(U);
    DISPLAY(color___0, "FTP/%d %6.2f secs: %7lu bytes ==> %-6s %s", code, (double )etime,
            bytes, tmp___32, tmp___31);
  }
  (this->hits) ++;
  xfree((void *)D);
  return ((BOOLEAN )1);
}
}
static BOOLEAN __init_connection(BROWSER this , URL U ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  BOOLEAN tmp___3 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  BOOLEAN tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  BOOLEAN tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  BOOLEAN tmp___25 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  BOOLEAN tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  BOOLEAN tmp___33 ;
  char *tmp___34 ;
  BOOLEAN tmp___35 ;
  SCHEME tmp___36 ;

  {
  (this->conn)->pos_ini = 0;
  (this->conn)->inbuffer = (size_t )0;
  (this->conn)->content.transfer = 1;
  (this->conn)->content.length = (size_t )(~ 0L);
  if ((this->conn)->connection.max == 1) {
    (this->conn)->connection.keepalive = 0;
  } else {
    (this->conn)->connection.keepalive = (int )my.keepalive;
  }
  if ((this->conn)->connection.max == 1) {
    (this->conn)->connection.reuse = 0;
  } else {
    (this->conn)->connection.reuse = (int )my.keepalive;
  }
  if ((this->conn)->connection.tested == 0) {
    (this->conn)->connection.tested = 1;
  } else {
    (this->conn)->connection.tested = (this->conn)->connection.tested;
  }
  (this->conn)->auth.www = this->auth.www;
  (this->conn)->auth.wchlg = this->auth.wchlg;
  (this->conn)->auth.wcred = this->auth.wcred;
  (this->conn)->auth.proxy = this->auth.proxy;
  (this->conn)->auth.pchlg = this->auth.pchlg;
  (this->conn)->auth.pcred = this->auth.pcred;
  (this->conn)->auth.type.www = this->auth.type.www;
  (this->conn)->auth.type.proxy = this->auth.type.proxy;
  memset((void *)((this->conn)->buffer), 0, sizeof((this->conn)->buffer));
  tmp___3 = auth_get_proxy_required(my.auth);
  if (tmp___3) {
    tmp___0 = auth_get_proxy_port(my.auth);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = url_get_port(U);
    tmp___2 = tmp___1;
  }
  tmp___8 = auth_get_proxy_required(my.auth);
  if (tmp___8) {
    tmp___5 = auth_get_proxy_host(my.auth);
    tmp___7 = tmp___5;
  } else {
    tmp___6 = url_get_hostname(U);
    tmp___7 = tmp___6;
  }
  debug("%s:%d attempting connection to %s:%d", "browser.c", 888, tmp___7, tmp___2);
  if (! (this->conn)->connection.reuse) {
    goto _L;
  } else
  if ((this->conn)->connection.status == 0) {
    _L: /* CIL Label */ 
    tmp___17 = auth_get_proxy_required(my.auth);
    if (tmp___17) {
      tmp___9 = auth_get_proxy_port(my.auth);
      tmp___10 = auth_get_proxy_host(my.auth);
      debug("%s:%d creating new socket:     %s:%d", "browser.c", 897, tmp___10, tmp___9);
      tmp___11 = auth_get_proxy_port(my.auth);
      tmp___12 = auth_get_proxy_host(my.auth);
      (this->conn)->sock = new_socket(this->conn, (char const   *)tmp___12, tmp___11);
    } else {
      tmp___13 = url_get_port(U);
      tmp___14 = url_get_hostname(U);
      debug("%s:%d creating new socket:     %s:%d", "browser.c", 903, tmp___14, tmp___13);
      tmp___15 = url_get_port(U);
      tmp___16 = url_get_hostname(U);
      (this->conn)->sock = new_socket(this->conn, (char const   *)tmp___16, tmp___15);
    }
  }
  if (my.keepalive) {
    (this->conn)->connection.reuse = 1;
  }
  if ((this->conn)->sock < 0) {
    tmp___18 = __errno_location();
    tmp___19 = strerror(*tmp___18);
    tmp___20 = __errno_location();
    debug("%s:%d connection failed. error %d(%s)", "browser.c", 915, *tmp___20, tmp___19);
    socket_close(this->conn);
    return ((BOOLEAN )0);
  }
  tmp___25 = auth_get_proxy_required(my.auth);
  if (tmp___25) {
    tmp___22 = auth_get_proxy_port(my.auth);
    tmp___24 = tmp___22;
  } else {
    tmp___23 = url_get_port(U);
    tmp___24 = tmp___23;
  }
  tmp___30 = auth_get_proxy_required(my.auth);
  if (tmp___30) {
    tmp___27 = auth_get_proxy_host(my.auth);
    tmp___29 = tmp___27;
  } else {
    tmp___28 = url_get_hostname(U);
    tmp___29 = tmp___28;
  }
  debug("%s:%d good socket connection:  %s:%d", "browser.c", 923, tmp___29, tmp___24);
  tmp___36 = url_get_scheme(U);
  if ((unsigned int )tmp___36 == 2U) {
    tmp___33 = auth_get_proxy_required(my.auth);
    if (tmp___33) {
      tmp___31 = url_get_port(U);
      tmp___32 = url_get_hostname(U);
      https_tunnel_request(this->conn, tmp___32, tmp___31);
      https_tunnel_response(this->conn);
    }
    (this->conn)->encrypt = (BOOLEAN )1;
    tmp___34 = url_get_hostname(U);
    tmp___35 = SSL_initialize(this->conn, (char const   *)tmp___34);
    if ((unsigned int )tmp___35 == 0U) {
      return ((BOOLEAN )0);
    }
  }
  return ((BOOLEAN )1);
}
}
static void __display_result(BROWSER this , RESPONSE resp , URL U , unsigned long bytes ,
                             float etime ) 
{ 
  char fmtime[65] ;
  struct tm keepsake ;
  time_t now ;
  struct tm *tmp ;
  size_t len ;
  struct tm *tmp___0 ;
  int color ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  DATE date ;
  DATE tmp___4 ;
  char *stamp ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *cached ;
  char const   *tmp___8 ;
  BOOLEAN tmp___9 ;
  BOOLEAN tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;

  {
  if (my.csv) {
    now = time((time_t *)((void *)0));
    tmp___0 = localtime_r((time_t const   * __restrict  )(& now), (struct tm * __restrict  )(& keepsake));
    tmp = tmp___0;
    if (tmp) {
      len = strftime((char * __restrict  )(fmtime), (size_t )64, (char const   * __restrict  )"%Y-%m-%d %H:%M:%S",
                     (struct tm  const  * __restrict  )tmp);
      if (len == 0UL) {
        memset((void *)(fmtime), '\000', (size_t )64);
        snprintf((char * __restrict  )(fmtime), (size_t )64, (char const   * __restrict  )"n/a");
      }
    } else {
      snprintf((char * __restrict  )(fmtime), (size_t )64, (char const   * __restrict  )"n/a");
    }
  }
  if (my.verbose) {
    if (! my.get) {
      if (! my.print) {
        if (! my.debug) {
          if ((unsigned int )my.color == 1U) {
            tmp___1 = response_get_code(resp);
            tmp___2 = __select_color(tmp___1);
            tmp___3 = tmp___2;
          } else {
            tmp___3 = -1;
          }
          color = tmp___3;
          tmp___4 = new_date((void *)0);
          date = tmp___4;
          if (my.timestamp) {
            tmp___5 = date_stamp(date);
            tmp___6 = (char const   *)tmp___5;
          } else {
            tmp___6 = "";
          }
          stamp = (char *)tmp___6;
          tmp___9 = response_get_from_cache(resp);
          if (tmp___9) {
            tmp___8 = "(C)";
          } else {
            tmp___8 = "   ";
          }
          cached = (char *)tmp___8;
          if (my.color) {
            tmp___10 = response_get_from_cache(resp);
            if ((unsigned int )tmp___10 == 1U) {
              color = 2;
            }
          }
          if (my.csv) {
            if (my.display) {
              tmp___11 = url_get_ID(U);
              tmp___12 = url_get_display(U);
              tmp___13 = response_get_code(resp);
              tmp___14 = response_get_protocol(resp);
              if (my.mark) {
                tmp___15 = ",";
              } else {
                tmp___15 = "";
              }
              if (my.mark) {
                tmp___16 = (char const   *)my.markstr;
              } else {
                tmp___16 = "";
              }
              DISPLAY(color, "%s%s%s%4d,%s,%d,%6.2f,%7lu,%s,%d,%s", stamp, tmp___16,
                      tmp___15, this->id, tmp___14, tmp___13, (double )etime, bytes,
                      tmp___12, tmp___11, fmtime);
            } else {
              tmp___17 = url_get_ID(U);
              tmp___18 = url_get_display(U);
              tmp___19 = response_get_code(resp);
              tmp___20 = response_get_protocol(resp);
              if (my.mark) {
                tmp___21 = ",";
              } else {
                tmp___21 = "";
              }
              if (my.mark) {
                tmp___22 = (char const   *)my.markstr;
              } else {
                tmp___22 = "";
              }
              DISPLAY(color, "%s%s%s%s,%d,%6.2f,%7lu,%s,%d,%s", stamp, tmp___22, tmp___21,
                      tmp___20, tmp___19, (double )etime, bytes, tmp___18, tmp___17,
                      fmtime);
            }
          } else
          if (my.display) {
            tmp___23 = url_get_display(U);
            tmp___24 = url_get_method_name(U);
            tmp___25 = response_get_code(resp);
            tmp___26 = response_get_protocol(resp);
            DISPLAY(color, "%4d) %s %d %6.2f secs: %7lu bytes ==> %-4s %s", this->id,
                    tmp___26, tmp___25, (double )etime, bytes, tmp___24, tmp___23);
          } else {
            tmp___27 = url_get_display(U);
            tmp___28 = url_get_method_name(U);
            tmp___29 = response_get_code(resp);
            tmp___30 = response_get_protocol(resp);
            DISPLAY(color, "%s%s %d%s %5.2f secs: %7lu bytes ==> %-4s %s", stamp,
                    tmp___30, tmp___29, cached, (double )etime, bytes, tmp___28, tmp___27);
          }
          date = date_destroy(date);
        }
      }
    }
  }
  return;
}
}
static void __increment_failures(void) 
{ 


  {
  pthread_mutex_lock(& my.lock);
  (my.failed) ++;
  pthread_mutex_unlock(& my.lock);
  pthread_testcancel();
  return;
}
}
static BOOLEAN __no_follow(char const   *hostname ) 
{ 
  int i ;
  char *tmp ;

  {
  i = 0;
  while (i < (my.nomap)->index) {
    tmp = stristr(hostname, (char const   *)*((my.nomap)->line + i));
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      return ((BOOLEAN )1);
    }
    i ++;
  }
  return ((BOOLEAN )0);
}
}
static int __select_color(int code ) 
{ 


  {
  switch (code) {
  case 226: 
  case 206: 
  case 205: 
  case 204: 
  case 203: 
  case 202: 
  case 201: 
  case 200: 
  case 150: 
  return (4);
  case 307: 
  case 306: 
  case 305: 
  case 304: 
  case 303: 
  case 302: 
  case 301: 
  case 300: 
  return (6);
  case 417: 
  case 416: 
  case 415: 
  case 414: 
  case 413: 
  case 412: 
  case 411: 
  case 410: 
  case 409: 
  case 408: 
  case 407: 
  case 406: 
  case 405: 
  case 404: 
  case 403: 
  case 402: 
  case 401: 
  case 400: 
  return (5);
  default: 
  return (1);
  }
  return (1);
}
}
static void __signal_cleanup(void) 
{ 


  {
  return;
}
}
#pragma merger("0","/tmp/cil-hpi4phzB.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
HASH new_hash(void) ;
void hash_nadd(HASH this , char *key , void *val , size_t len ) ;
void hash_remove(HASH this , char *key ) ;
BOOLEAN hash_contains(HASH this , char *key ) ;
HASH hash_destroy(HASH this ) ;
void hash_set_destroyer(HASH this , void (*m)(void *v ) ) ;
size_t DATESIZE ;
DATE new_etag(char *etag ) ;
BOOLEAN date_expired(DATE this ) ;
char *date_get_etag(DATE this ) ;
char *date_get_rfc850(DATE this ) ;
size_t CACHESIZE ;
BOOLEAN cache_contains(CACHE this , CTYPE type , URL U ) ;
void cache_add(CACHE this , CTYPE type , URL U , char *date ) ;
DATE cache_get(CACHE this , CTYPE type , URL U ) ;
char *cache_get_header(CACHE this , CTYPE type , URL U ) ;
static char const   *keys[4]  = {      "ET_",      "LM_",      "EX_",      (char const   *)((void *)0)};
static char *__build_key(CTYPE type , URL U ) ;
size_t CACHESIZE  =    sizeof(struct CACHE_T );
CACHE new_cache(void) 
{ 
  CACHE this ;
  void *tmp ;

  {
  tmp = calloc(CACHESIZE, (size_t )1);
  this = (CACHE )tmp;
  this->cache = new_hash();
  this->header = (char *)((void *)0);
  hash_set_destroyer(this->cache, (void (*)(void *v ))((void *)(& date_destroy)));
  return (this);
}
}
CACHE cache_destroy(CACHE this ) 
{ 


  {
  if ((unsigned long )this != (unsigned long )((void *)0)) {
    this->cache = hash_destroy(this->cache);
    free((void *)this);
    this = (CACHE )((void *)0);
  }
  return (this);
}
}
BOOLEAN cache_contains(CACHE this , CTYPE type , URL U ) 
{ 
  char *key ;
  BOOLEAN found ;

  {
  found = (BOOLEAN )0;
  if (! my.cache) {
    return ((BOOLEAN )0);
  }
  key = __build_key(type, U);
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    return ((BOOLEAN )0);
  }
  found = hash_contains(this->cache, key);
  free((void *)key);
  return (found);
}
}
BOOLEAN is_cached(CACHE this , URL U ) 
{ 
  DATE day ;
  char *key ;
  char *tmp ;
  void *tmp___0 ;
  BOOLEAN tmp___1 ;
  BOOLEAN tmp___2 ;

  {
  day = (DATE )((void *)0);
  tmp = __build_key((CTYPE )2, U);
  key = tmp;
  tmp___2 = hash_contains(this->cache, key);
  if (tmp___2) {
    tmp___0 = hash_get(this->cache, key);
    day = (DATE )tmp___0;
    tmp___1 = date_expired(day);
    if ((unsigned int )tmp___1 == 0U) {
      return ((BOOLEAN )1);
    } else {
      hash_remove(this->cache, key);
      return ((BOOLEAN )0);
    }
  }
  return ((BOOLEAN )0);
}
}
void cache_add(CACHE this , CTYPE type , URL U , char *date ) 
{ 
  char *key ;
  char *tmp ;
  BOOLEAN tmp___0 ;
  DATE tmp___1 ;
  BOOLEAN tmp___2 ;
  DATE tmp___3 ;
  DATE tmp___4 ;

  {
  tmp = __build_key(type, U);
  key = tmp;
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    return;
  }
  if ((unsigned int )type != 2U) {
    tmp___0 = hash_contains(this->cache, key);
    if (tmp___0) {
      hash_remove(this->cache, key);
    }
  }
  switch ((unsigned int )type) {
  case 0U: 
  tmp___1 = new_etag(date);
  hash_nadd(this->cache, key, (void *)tmp___1, DATESIZE);
  break;
  case 2U: 
  tmp___2 = hash_contains(this->cache, key);
  if ((unsigned int )tmp___2 == 1U) {
    break;
  }
  tmp___3 = new_date(date);
  hash_nadd(this->cache, key, (void *)tmp___3, DATESIZE);
  break;
  default: 
  tmp___4 = new_date(date);
  hash_nadd(this->cache, key, (void *)tmp___4, DATESIZE);
  break;
  }
  free((void *)key);
  return;
}
}
DATE cache_get(CACHE this , CTYPE type , URL U ) 
{ 
  DATE date ;
  char *key ;
  char *tmp ;
  void *tmp___0 ;

  {
  tmp = __build_key(type, U);
  key = tmp;
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    return ((DATE )((void *)0));
  }
  tmp___0 = hash_get(this->cache, key);
  date = (DATE )tmp___0;
  free((void *)key);
  return (date);
}
}
char *cache_get_header(CACHE this , CTYPE type , URL U ) 
{ 
  DATE d ;
  DATE e ;
  char *key ;
  char *exp ;
  char *ptr ;
  char tmp[256] ;
  BOOLEAN tmp___0 ;
  void *tmp___1 ;
  BOOLEAN tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  BOOLEAN tmp___5 ;
  char *tmp___6 ;
  BOOLEAN tmp___7 ;

  {
  d = (DATE )((void *)0);
  e = (DATE )((void *)0);
  key = (char *)((void *)0);
  exp = (char *)((void *)0);
  ptr = (char *)((void *)0);
  tmp___0 = cache_contains(this, type, U);
  if (! tmp___0) {
    return ((char *)((void *)0));
  }
  exp = __build_key((CTYPE )2, U);
  if (exp) {
    tmp___1 = hash_get(this->cache, exp);
    e = (DATE )tmp___1;
    free((void *)exp);
    tmp___2 = date_expired(e);
    if (tmp___2) {
      return ((char *)((void *)0));
    }
  }
  key = __build_key(type, U);
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  tmp___3 = hash_get(this->cache, key);
  d = (DATE )tmp___3;
  if ((unsigned long )d == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  memset((void *)(tmp), '\000', (size_t )256);
  switch ((unsigned int )type) {
  case 0U: 
  tmp___4 = date_get_etag(d);
  ptr = strdup((char const   *)tmp___4);
  tmp___5 = empty((char const   *)ptr);
  if (tmp___5) {
    return ((char *)"");
  }
  snprintf((char * __restrict  )(tmp), (size_t )256, (char const   * __restrict  )"If-None-Match: %s\r\n",
           ptr);
  this->header = strdup((char const   *)(tmp));
  free((void *)ptr);
  return (this->header);
  default: 
  tmp___6 = date_get_rfc850(d);
  ptr = strdup((char const   *)tmp___6);
  tmp___7 = empty((char const   *)ptr);
  if (tmp___7) {
    return ((char *)"");
  }
  snprintf((char * __restrict  )(tmp), (size_t )256, (char const   * __restrict  )"If-Modified-Since: %s\r\n",
           ptr);
  this->header = strdup((char const   *)(tmp));
  free((void *)ptr);
  return (this->header);
  }
  return ((char *)((void *)0));
}
}
static char *__build_key(CTYPE type , URL U ) 
{ 
  int len ;
  char *key ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;

  {
  len = 0;
  key = (char *)((void *)0);
  if ((unsigned long )U == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  } else {
    tmp = url_get_request(U);
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      return ((char *)((void *)0));
    } else {
      tmp___0 = url_get_request(U);
      tmp___1 = strlen((char const   *)tmp___0);
      if (tmp___1 < 1UL) {
        return ((char *)((void *)0));
      }
    }
  }
  tmp___2 = url_get_request(U);
  tmp___3 = strlen((char const   *)tmp___2);
  tmp___4 = strlen(keys[type]);
  len = (int )((tmp___3 + tmp___4) + 1UL);
  tmp___5 = malloc((size_t )(len + 1));
  key = (char *)tmp___5;
  memset((void *)key, '\000', (size_t )(len + 1));
  tmp___6 = url_get_request(U);
  snprintf((char * __restrict  )key, (size_t )len, (char const   * __restrict  )"%s%s",
           keys[type], tmp___6);
  return (key);
}
}
#pragma merger("0","/tmp/cil-_rTHJFKX.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
size_t COOKIESIZE ;
COOKIE new_cookie(char *str , char *host ) ;
COOKIE cookie_destroy(COOKIE this ) ;
void cookie_set_name(COOKIE this , char *str ) ;
void cookie_set_value(COOKIE this , char *str ) ;
void cookie_reset_value(COOKIE this , char *value ) ;
void cookie_set_path(COOKIE this , char *str ) ;
void cookie_set_domain(COOKIE this , char *str ) ;
void cookie_set_expires(COOKIE this , time_t expires ) ;
char *cookie_get_name(COOKIE this ) ;
char *cookie_get_value(COOKIE this ) ;
char *cookie_get_domain(COOKIE this ) ;
char *cookie_get_path(COOKIE this ) ;
time_t cookie_get_expires(COOKIE this ) ;
BOOLEAN cookie_get_session(COOKIE this ) ;
char *cookie_expires_string(COOKIE this ) ;
char *cookie_to_string(COOKIE this ) ;
COOKIE cookie_clone(COOKIE this , COOKIE that ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
char *trim(char *str ) ;
size_t COOKIESIZE  =    sizeof(struct COOKIE_T );
static BOOLEAN __parse_input(COOKIE this , char *str , char *host ) ;
static char *__parse_pair(char **str ) ;
static int __parse_time(char const   *str ) ;
static int __mkmonth(char *s , char **ends ) ;
static char *months[12]  = 
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec"};
COOKIE new_cookie(char *str , char *host ) 
{ 
  COOKIE this ;
  void *tmp ;
  COOKIE tmp___0 ;
  BOOLEAN tmp___1 ;

  {
  tmp = calloc(sizeof(struct COOKIE_T ), (size_t )1);
  this = (COOKIE )tmp;
  this->name = (char *)((void *)0);
  this->value = (char *)((void *)0);
  this->domain = (char *)((void *)0);
  this->expires = (time_t )0;
  this->expstr = (char *)((void *)0);
  this->string = (char *)((void *)0);
  this->session = (BOOLEAN )1;
  this->none = strdup("none");
  tmp___1 = __parse_input(this, str, host);
  if ((unsigned int )tmp___1 == 0U) {
    tmp___0 = cookie_destroy(this);
    return (tmp___0);
  }
  return (this);
}
}
COOKIE cookie_destroy(COOKIE this ) 
{ 


  {
  if ((unsigned long )this != (unsigned long )((void *)0)) {
    free((void *)this->name);
    free((void *)this->value);
    free((void *)this->domain);
    free((void *)this->expstr);
    free((void *)this->path);
    free((void *)this->none);
    free((void *)this->string);
    free((void *)this);
  }
  return ((COOKIE )((void *)0));
}
}
void cookie_set_name(COOKIE this , char *str ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)str);
  len = tmp + 1UL;
  tmp___0 = malloc(sizeof(this->name) * len);
  this->name = (char *)tmp___0;
  memset((void *)this->name, '\000', len);
  memcpy((void * __restrict  )this->name, (void const   * __restrict  )str, len);
  return;
}
}
void cookie_set_value(COOKIE this , char *str ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)str);
  len = tmp + 1UL;
  tmp___0 = malloc(sizeof(this->value) * len);
  this->value = (char *)tmp___0;
  memset((void *)this->value, '\000', len);
  memcpy((void * __restrict  )this->value, (void const   * __restrict  )str, len);
  return;
}
}
void cookie_set_path(COOKIE this , char *str ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)str);
  len = tmp + 1UL;
  tmp___0 = malloc(sizeof(this->path) * len);
  this->path = (char *)tmp___0;
  memset((void *)this->path, '\000', len);
  memcpy((void * __restrict  )this->path, (void const   * __restrict  )str, len);
  return;
}
}
void cookie_set_domain(COOKIE this , char *str ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)str);
  len = tmp + 1UL;
  tmp___0 = malloc(sizeof(this->domain) * len);
  this->domain = (char *)tmp___0;
  memset((void *)this->domain, '\000', len);
  memcpy((void * __restrict  )this->domain, (void const   * __restrict  )str, len);
  return;
}
}
void cookie_set_expires(COOKIE this , time_t expires ) 
{ 


  {
  this->expires = expires;
  return;
}
}
char *cookie_get_name(COOKIE this ) 
{ 


  {
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    if ((unsigned long )this->name == (unsigned long )((void *)0)) {
      return (this->none);
    }
  }
  return (this->name);
}
}
char *cookie_get_value(COOKIE this ) 
{ 


  {
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    if ((unsigned long )this->value == (unsigned long )((void *)0)) {
      return (this->none);
    }
  }
  return (this->value);
}
}
char *cookie_get_domain(COOKIE this ) 
{ 


  {
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    if ((unsigned long )this->domain == (unsigned long )((void *)0)) {
      return (this->none);
    }
  }
  return (this->domain);
}
}
char *cookie_get_path(COOKIE this ) 
{ 


  {
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    if ((unsigned long )this->path == (unsigned long )((void *)0)) {
      return (this->none);
    }
  }
  return (this->path);
}
}
time_t cookie_get_expires(COOKIE this ) 
{ 


  {
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    return ((time_t )-1);
  }
  return (this->expires);
}
}
BOOLEAN cookie_get_session(COOKIE this ) 
{ 


  {
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    return ((BOOLEAN )1);
  }
  return (this->session);
}
}
char *cookie_expires_string(COOKIE this ) 
{ 
  void *tmp ;
  struct tm *timeinfo ;

  {
  tmp = realloc((void *)this->expstr, sizeof(this->expstr) * 128UL);
  this->expstr = (char *)tmp;
  memset((void *)this->expstr, '\000', (size_t )128);
  timeinfo = localtime((time_t const   *)(& this->expires));
  strftime((char * __restrict  )this->expstr, (size_t )128, (char const   * __restrict  )"%a, %d %b %Y %H:%M:%S %z",
           (struct tm  const  * __restrict  )timeinfo);
  return (this->expstr);
}
}
char *cookie_to_string(COOKIE this ) 
{ 
  int len ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  len = 4096;
  if ((unsigned long )this->name == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  } else
  if ((unsigned long )this->value == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  } else
  if ((unsigned long )this->domain == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  tmp = realloc((void *)this->string, sizeof(this->string) * (unsigned long )len);
  this->string = (char *)tmp;
  memset((void *)this->string, '\000', (size_t )len);
  if ((unsigned long )this->path != (unsigned long )((void *)0)) {
    tmp___0 = (char const   *)this->path;
  } else {
    tmp___0 = "/";
  }
  if ((unsigned long )this->domain != (unsigned long )((void *)0)) {
    tmp___1 = (char const   *)this->domain;
  } else {
    tmp___1 = "none";
  }
  snprintf((char * __restrict  )this->string, (size_t )len, (char const   * __restrict  )"%s=%s; domain=%s; path=%s; expires=%lld",
           this->name, this->value, tmp___1, tmp___0, (long long )this->expires);
  return (this->string);
}
}
void *strealloc(char *old , char *str ) 
{ 
  size_t num ;
  size_t tmp ;
  char *newptr ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)str);
  num = tmp + 1UL;
  tmp___0 = realloc((void *)old, sizeof(char *) * num);
  newptr = (char *)tmp___0;
  if (newptr) {
    memset((void *)newptr, '\000', num + 1UL);
    memcpy((void * __restrict  )newptr, (void const   * __restrict  )str, num);
  }
  return ((void *)newptr);
}
}
void cookie_reset_value(COOKIE this , char *value ) 
{ 
  void *tmp ;

  {
  tmp = strealloc(this->value, value);
  this->value = (char *)tmp;
  return;
}
}
COOKIE cookie_clone(COOKIE this , COOKIE that ) 
{ 
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  time_t tmp___5 ;

  {
  tmp = cookie_get_value(that);
  tmp___0 = strealloc(this->value, tmp);
  this->value = (char *)tmp___0;
  tmp___1 = cookie_get_domain(that);
  tmp___2 = strealloc(this->domain, tmp___1);
  this->domain = (char *)tmp___2;
  tmp___3 = cookie_get_path(that);
  tmp___4 = strealloc(this->path, tmp___3);
  this->path = (char *)tmp___4;
  if (this->expires > 0L) {
    tmp___5 = cookie_get_expires(that);
    this->expires = time((time_t *)tmp___5);
  }
  if ((unsigned int )this->session == 1U) {
    this->session = cookie_get_session(that);
  }
  return (this);
}
}
static BOOLEAN __parse_input(COOKIE this , char *str , char *host ) 
{ 
  char *tmp ;
  char *key ;
  char *val ;
  char *pos___0 ;
  int expires ;
  char *newline ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  struct tm *gmt ;
  long max ;
  time_t now ;
  time_t tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  expires = 0;
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    printf((char const   * __restrict  )"Coookie: Unable to parse header string");
    return ((BOOLEAN )0);
  }
  while (1) {
    if (*str) {
      if (! ((int )*str == 32)) {
        break;
      }
    } else {
      break;
    }
    str ++;
  }
  newline = str;
  while (1) {
    tmp = __parse_pair(& newline);
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
      break;
    }
    key = tmp;
    while (1) {
      if (*tmp) {
        tmp___0 = __ctype_b_loc();
        if ((int const   )*(*tmp___0 + (int )((unsigned char )((int )*tmp))) & 8192) {
          break;
        } else
        if (61 == (int )*tmp) {
          break;
        } else
        if (58 == (int )*tmp) {
          break;
        }
      } else {
        break;
      }
      tmp ++;
    }
    tmp___1 = tmp;
    tmp ++;
    *tmp___1 = (char)0;
    while (1) {
      tmp___2 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___2 + (int )((unsigned char )((int )*tmp))) & 8192)) {
        if (! (61 == (int )*tmp)) {
          if (! (58 == (int )*tmp)) {
            break;
          }
        }
      }
      tmp ++;
    }
    val = tmp;
    while (*tmp) {
      tmp ++;
    }
    tmp___9 = strncasecmp((char const   *)key, "expires", (size_t )7);
    if (tmp___9) {
      tmp___8 = strncasecmp((char const   *)key, "max-age", (size_t )7);
      if (tmp___8) {
        tmp___7 = strncasecmp((char const   *)key, "path", (size_t )4);
        if (tmp___7) {
          tmp___6 = strncasecmp((char const   *)key, "domain", (size_t )6);
          if (tmp___6) {
            tmp___5 = strncasecmp((char const   *)key, "secure", (size_t )6);
            if (tmp___5) {
              this->name = strdup((char const   *)key);
              this->value = strdup((char const   *)val);
            } else {
              this->secure = (BOOLEAN )1;
            }
          } else {
            cookie_set_domain(this, val);
          }
        } else {
          this->path = strdup((char const   *)val);
        }
      } else {
        max = -1L;
        tmp___3 = time((time_t *)((void *)0));
        now = tmp___3;
        gmt = gmtime((time_t const   *)(& now));
        now = mktime(gmt);
        tmp___4 = atof((char const   *)val);
        max = (long )tmp___4;
        if (max != -1L) {
          this->session = (BOOLEAN )0;
        }
      }
    } else {
      expires = __parse_time((char const   *)val);
      if (expires != -1) {
        this->session = (BOOLEAN )0;
        this->expires = (time_t )expires;
      }
    }
  }
  if (this->expires < 1000L) {
    this->session = (BOOLEAN )1;
  }
  if ((unsigned long )this->domain == (unsigned long )((void *)0)) {
    pos___0 = strchr((char const   *)host, '.');
    if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
      this->domain = xstrdup(".");
    } else {
      this->domain = xstrdup((char const   *)pos___0);
    }
  }
  return ((BOOLEAN )1);
}
}
static char *__parse_pair(char **str ) 
{ 
  int okay___0 ;
  char *p ;
  char *pair ;
  char *tmp ;

  {
  okay___0 = 0;
  p = *str;
  pair = (char *)((void *)0);
  if (! str) {
    return ((char *)((void *)0));
  } else
  if (! *str) {
    return ((char *)((void *)0));
  }
  pair = p;
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  while (1) {
    if ((int )*p != 0) {
      if (! ((int )*p != 59)) {
        break;
      }
    } else {
      break;
    }
    if (! *p) {
      *str = p;
      return ((char *)((void *)0));
    }
    if ((int )*p == 61) {
      okay___0 = 1;
    }
    p ++;
  }
  tmp = p;
  p ++;
  *tmp = (char )'\000';
  *str = p;
  trim(pair);
  if (okay___0) {
    return (pair);
  } else {
    return ((char *)((void *)0));
  }
}
}
static int __utc_offset(void) 
{ 
  int hrs ;
  struct tm *ptr ;
  time_t zip ;

  {
  zip = 86400L;
  ptr = localtime((time_t const   *)(& zip));
  hrs = ptr->tm_hour;
  if (ptr->tm_mday < 2) {
    hrs -= 24;
  }
  return (hrs);
}
}
static int __parse_time(char const   *str ) 
{ 
  char *s ;
  struct tm tm ;
  time_t rv ;
  time_t now ;
  size_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  size_t tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  unsigned short const   **tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;

  {
  if (! str) {
    return (0);
  }
  s = strchr(str, ',');
  if (s) {
    s ++;
    while (1) {
      if (*s) {
        if (! ((int )*s == 32)) {
          break;
        }
      } else {
        break;
      }
      s ++;
    }
    tmp___11 = strchr((char const   *)s, '-');
    if (tmp___11) {
      tmp = strlen((char const   *)s);
      if ((int )tmp < 18) {
        return (0);
      }
      tmp___0 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                       10);
      tm.tm_mday = (int )tmp___0;
      s ++;
      tm.tm_mon = __mkmonth(s, & s);
      s ++;
      tmp___1 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                       10);
      tm.tm_year = (int )(tmp___1 - 1900L);
      s ++;
      tmp___2 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                       10);
      tm.tm_hour = (int )tmp___2;
      s ++;
      tmp___3 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                       10);
      tm.tm_min = (int )tmp___3;
      s ++;
      tmp___4 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                       10);
      tm.tm_sec = (int )tmp___4;
    } else {
      tmp___5 = strlen((char const   *)s);
      if ((int )tmp___5 < 20) {
        return (0);
      }
      tmp___6 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                       10);
      tm.tm_mday = (int )tmp___6;
      tm.tm_mon = __mkmonth(s, & s);
      tmp___7 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                       10);
      tm.tm_year = (int )(tmp___7 - 1900L);
      tmp___8 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                       10);
      tm.tm_hour = (int )tmp___8;
      s ++;
      tmp___9 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                       10);
      tm.tm_min = (int )tmp___9;
      s ++;
      tmp___10 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                        10);
      tm.tm_sec = (int )tmp___10;
    }
  } else {
    tmp___27 = __ctype_b_loc();
    if ((int const   )*(*tmp___27 + (int )*str) & 2048) {
      tmp___20 = strchr(str, 'T');
      if (tmp___20) {
        s = (char *)str;
        while (1) {
          if (*s) {
            if (! ((int )*s == 32)) {
              break;
            }
          } else {
            break;
          }
          s ++;
        }
        tmp___12 = strlen((char const   *)s);
        if ((int )tmp___12 < 21) {
          return (0);
        }
        tmp___13 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                          10);
        tm.tm_year = (int )(tmp___13 - 1900L);
        s ++;
        tmp___14 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                          10);
        tm.tm_mon = (int )tmp___14;
        s ++;
        tmp___15 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                          10);
        tm.tm_mday = (int )tmp___15;
        s ++;
        tmp___16 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                          10);
        tm.tm_hour = (int )tmp___16;
        s ++;
        tmp___17 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                          10);
        tm.tm_min = (int )tmp___17;
        s ++;
        tmp___18 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                          10);
        tm.tm_sec = (int )tmp___18;
      } else {
        tmp___19 = atol(str);
        return ((int )tmp___19);
      }
    } else {
      s = (char *)str;
      while (1) {
        if (*s) {
          if (! ((int )*s != 32)) {
            break;
          }
        } else {
          break;
        }
        s ++;
      }
      tmp___21 = strlen((char const   *)s);
      if ((int )tmp___21 < 20) {
        return (0);
      }
      tm.tm_mon = __mkmonth(s, & s);
      tmp___22 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                        10);
      tm.tm_mday = (int )tmp___22;
      tmp___23 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                        10);
      tm.tm_hour = (int )tmp___23;
      s ++;
      tmp___24 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                        10);
      tm.tm_min = (int )tmp___24;
      s ++;
      tmp___25 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                        10);
      tm.tm_sec = (int )tmp___25;
      tmp___26 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& s),
                        10);
      tm.tm_year = (int )(tmp___26 - 1900L);
    }
  }
  if (tm.tm_sec < 0) {
    return (0);
  } else
  if (tm.tm_sec > 59) {
    return (0);
  } else
  if (tm.tm_min < 0) {
    return (0);
  } else
  if (tm.tm_min > 59) {
    return (0);
  } else
  if (tm.tm_hour < 0) {
    return (0);
  } else
  if (tm.tm_hour > 23) {
    return (0);
  } else
  if (tm.tm_mday < 1) {
    return (0);
  } else
  if (tm.tm_mday > 31) {
    return (0);
  } else
  if (tm.tm_mon < 0) {
    return (0);
  } else
  if (tm.tm_mon > 11) {
    return (0);
  }
  tm.tm_isdst = -1;
  rv = mktime(& tm);
  tmp___29 = strstr(str, " GMT");
  if (! tmp___29) {
    tmp___30 = strstr(str, " UTC");
    if (! tmp___30) {
      tmp___28 = __utc_offset();
      rv += (time_t )(tmp___28 * 3600);
    }
  }
  if (rv == -1L) {
    return ((int )rv);
  }
  now = time((time_t *)((void *)0));
  if (rv - now < 0L) {
    return (0);
  }
  return ((int )rv);
}
}
static int __mkmonth(char *s , char **ends ) 
{ 
  char *ptr ;
  unsigned short const   **tmp ;
  int i ;
  int tmp___0 ;

  {
  ptr = s;
  while (1) {
    tmp = __ctype_b_loc();
    if ((int const   )*(*tmp + (int )*ptr) & 1024) {
      break;
    }
    ptr ++;
  }
  if (*ptr) {
    *ends = ptr + 3;
    i = 0;
    while (i < 12) {
      tmp___0 = strncasecmp((char const   *)months[i], (char const   *)ptr, (size_t )3);
      if (! tmp___0) {
        return (i);
      }
      i ++;
    }
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-R8Bv1Dou.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fgetc(FILE *__stream ) ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern int close(int __fd ) ;
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t const   * __restrict  __timer ,
                                                         struct tm * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
size_t HASHSIZE ;
void hash_add(HASH this , char *key , void *val ) ;
char *chomp(char *str ) ;
char **split(char pattern , char *s , int *n_words ) ;
void split_free(char **split___0 , int length ) ;
COOKIES new_cookies(void) ;
COOKIES cookies_destroy(COOKIES this ) ;
char *cookies_header(COOKIES this , char *host , char *newton ) ;
BOOLEAN cookies_delete(COOKIES this , char *str ) ;
void cookies_list(COOKIES this ) ;
HASH load_cookies(COOKIES this ) ;
static NODE *__delete_node(NODE *node ) ;
static BOOLEAN __exists(char *file ) ;
static BOOLEAN __save_cookies(COOKIES this ) ;
COOKIES new_cookies(void) 
{ 
  int len ;
  COOKIES this ;
  char name[20] ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
  name[0] = (char )'/';
  name[1] = (char )'.';
  name[2] = (char )'s';
  name[3] = (char )'i';
  name[4] = (char )'e';
  name[5] = (char )'g';
  name[6] = (char )'e';
  name[7] = (char )'/';
  name[8] = (char )'c';
  name[9] = (char )'o';
  name[10] = (char )'o';
  name[11] = (char )'k';
  name[12] = (char )'i';
  name[13] = (char )'e';
  name[14] = (char )'s';
  name[15] = (char )'.';
  name[16] = (char )'t';
  name[17] = (char )'x';
  name[18] = (char )'t';
  name[19] = (char )'\000';
  tmp = calloc(sizeof(struct COOKIES_T ), (size_t )1);
  this = (COOKIES )tmp;
  this->size = (size_t )0;
  tmp___0 = getenv("HOME");
  p = tmp___0;
  if (p) {
    tmp___1 = strlen((char const   *)p);
    len = (int )tmp___1;
  } else {
    len = 60;
  }
  tmp___2 = strlen((char const   *)(name));
  len = (int )((size_t )len + (tmp___2 + 1UL));
  tmp___3 = xmalloc(sizeof(char *) * (unsigned long )len);
  this->file = (char *)tmp___3;
  memset((void *)this->file, '\000', (size_t )len);
  tmp___4 = getenv("HOME");
  snprintf((char * __restrict  )this->file, (size_t )len, (char const   * __restrict  )"%s%s",
           tmp___4, name);
  return (this);
}
}
COOKIES cookies_destroy(COOKIES this ) 
{ 
  NODE *cur ;

  {
  cur = (NODE *)((void *)0);
  __save_cookies(this);
  cur = this->head;
  while (cur) {
    cur = __delete_node(cur);
  }
  xfree((void *)this->file);
  free((void *)this);
  return ((COOKIES )((void *)0));
}
}
BOOLEAN cookies_add(COOKIES this , char *str , char *host ) 
{ 
  size_t id ;
  pthread_t tmp ;
  int hlen ;
  int dlen ;
  NODE *cur ;
  NODE *pre ;
  NODE *new ;
  BOOLEAN found ;
  BOOLEAN valid___0 ;
  COOKIE oreo ;
  COOKIE tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *domainptr ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;

  {
  tmp = pthread_self();
  id = tmp;
  hlen = 0;
  dlen = 0;
  cur = (NODE *)((void *)0);
  pre = (NODE *)((void *)0);
  new = (NODE *)((void *)0);
  found = (BOOLEAN )0;
  valid___0 = (BOOLEAN )0;
  tmp___0 = new_cookie(str, host);
  oreo = tmp___0;
  if ((unsigned long )oreo == (unsigned long )((void *)0)) {
    return ((BOOLEAN )0);
  }
  tmp___1 = cookie_get_name(oreo);
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    return ((BOOLEAN )0);
  } else {
    tmp___2 = cookie_get_value(oreo);
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      return ((BOOLEAN )0);
    }
  }
  pre = this->head;
  cur = pre;
  while ((unsigned long )cur != (unsigned long )((void *)0)) {
    tmp___3 = cookie_get_domain(cur->cookie);
    domainptr = (char const   *)tmp___3;
    if ((int const   )*domainptr == 46) {
      domainptr ++;
    }
    if (host) {
      tmp___4 = strlen((char const   *)host);
      hlen = (int )tmp___4;
    } else {
      hlen = 0;
    }
    if (domainptr) {
      tmp___5 = strlen(domainptr);
      dlen = (int )tmp___5;
    } else {
      dlen = 0;
    }
    tmp___6 = strcasecmp((char const   *)host, domainptr);
    if (! tmp___6) {
      valid___0 = (BOOLEAN )1;
    }
    if (! valid___0) {
      if (dlen < hlen) {
        tmp___7 = strcasecmp((char const   *)(host + (hlen - dlen)), domainptr);
        if (! tmp___7) {
          valid___0 = (BOOLEAN )1;
        }
      }
    }
    if (valid___0) {
      if (cur->threadID == id) {
        tmp___9 = cookie_get_name(oreo);
        tmp___10 = cookie_get_name(cur->cookie);
        tmp___11 = strcasecmp((char const   *)tmp___10, (char const   *)tmp___9);
        if (! tmp___11) {
          tmp___8 = cookie_get_value(oreo);
          cookie_reset_value(cur->cookie, tmp___8);
          oreo = cookie_destroy(oreo);
          found = (BOOLEAN )1;
          break;
        }
      }
    }
    pre = cur;
    cur = cur->next;
  }
  if (! found) {
    tmp___12 = malloc(sizeof(NODE ));
    new = (NODE *)tmp___12;
    new->threadID = id;
    new->cookie = oreo;
    new->next = cur;
    if ((unsigned long )cur == (unsigned long )this->head) {
      this->head = new;
    } else {
      pre->next = new;
    }
  }
  return ((BOOLEAN )1);
}
}
BOOLEAN cookies_delete(COOKIES this , char *str ) 
{ 
  NODE *cur ;
  NODE *pre ;
  BOOLEAN ret ;
  pthread_t id ;
  pthread_t tmp ;
  char *name ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  ret = (BOOLEAN )0;
  tmp = pthread_self();
  id = tmp;
  pre = this->head;
  cur = pre;
  while ((unsigned long )cur != (unsigned long )((void *)0)) {
    if (cur->threadID == id) {
      tmp___0 = cookie_get_name(cur->cookie);
      name = tmp___0;
      tmp___1 = strcasecmp((char const   *)name, (char const   *)str);
      if (! tmp___1) {
        cur->cookie = cookie_destroy(cur->cookie);
        pre->next = cur->next;
        if ((unsigned long )cur == (unsigned long )this->head) {
          this->head = cur->next;
          pre = this->head;
        } else {
          pre->next = cur->next;
        }
        ret = (BOOLEAN )1;
        break;
      }
    }
    pre = cur;
    cur = cur->next;
  }
  return (ret);
}
}
BOOLEAN cookies_delete_all(COOKIES this ) 
{ 
  NODE *cur ;
  NODE *pre ;
  pthread_t id ;
  pthread_t tmp ;

  {
  tmp = pthread_self();
  id = tmp;
  pre = this->head;
  cur = pre;
  while ((unsigned long )cur != (unsigned long )((void *)0)) {
    if (cur->threadID == id) {
      cur->cookie = cookie_destroy(cur->cookie);
      pre->next = cur->next;
      if ((unsigned long )cur == (unsigned long )this->head) {
        this->head = cur->next;
        pre = this->head;
      } else {
        pre->next = cur->next;
      }
    }
    pre = cur;
    cur = cur->next;
  }
  return ((BOOLEAN )1);
}
}
char *cookies_header(COOKIES this , char *host , char *newton ) 
{ 
  int dlen ;
  int hlen ;
  NODE *pre ;
  NODE *cur ;
  time_t tmp ;
  time_t now ;
  struct tm tm ;
  char oreo[81920] ;
  size_t id ;
  pthread_t tmp___0 ;
  size_t tmp___1 ;
  char const   *domainptr ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  time_t tmp___5 ;
  BOOLEAN tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  time_t tmp___16 ;
  BOOLEAN tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;

  {
  tmp___0 = pthread_self();
  id = tmp___0;
  memset((void *)(oreo), '\000', sizeof(oreo));
  tmp___1 = strlen((char const   *)host);
  hlen = (int )tmp___1;
  tmp = time((time_t *)((void *)0));
  gmtime_r((time_t const   * __restrict  )(& tmp), (struct tm * __restrict  )(& tm));
  tm.tm_isdst = -1;
  now = mktime(& tm);
  pre = this->head;
  cur = pre;
  while ((unsigned long )cur != (unsigned long )((void *)0)) {
    tmp___2 = cookie_get_domain(cur->cookie);
    domainptr = (char const   *)tmp___2;
    if ((int const   )*domainptr == 46) {
      domainptr ++;
    }
    if (domainptr) {
      tmp___3 = strlen(domainptr);
      dlen = (int )tmp___3;
    } else {
      dlen = 0;
    }
    if (cur->threadID == id) {
      tmp___14 = strcasecmp(domainptr, (char const   *)host);
      if (! tmp___14) {
        tmp___5 = cookie_get_expires(cur->cookie);
        if (tmp___5 <= now) {
          tmp___6 = cookie_get_session(cur->cookie);
          if ((unsigned int )tmp___6 != 1U) {
            tmp___4 = cookie_get_name(cur->cookie);
            cookies_delete(this, tmp___4);
            goto __Cont;
          }
        }
        tmp___8 = strlen((char const   *)(oreo));
        if (tmp___8 > 0UL) {
          tmp___7 = strlen((char const   *)(oreo));
          strncat((char * __restrict  )(oreo), (char const   * __restrict  )";", (sizeof(oreo) - 10UL) - tmp___7);
        }
        tmp___9 = strlen((char const   *)(oreo));
        tmp___10 = cookie_get_name(cur->cookie);
        strncat((char * __restrict  )(oreo), (char const   * __restrict  )tmp___10,
                (sizeof(oreo) - 10UL) - tmp___9);
        tmp___11 = strlen((char const   *)(oreo));
        strncat((char * __restrict  )(oreo), (char const   * __restrict  )"=", (sizeof(oreo) - 10UL) - tmp___11);
        tmp___12 = strlen((char const   *)(oreo));
        tmp___13 = cookie_get_value(cur->cookie);
        strncat((char * __restrict  )(oreo), (char const   * __restrict  )tmp___13,
                (sizeof(oreo) - 10UL) - tmp___12);
      }
      if (dlen < hlen) {
        tmp___25 = strcasecmp((char const   *)(host + (hlen - dlen)), domainptr);
        if (! tmp___25) {
          tmp___16 = cookie_get_expires(cur->cookie);
          if (tmp___16 <= now) {
            tmp___17 = cookie_get_session(cur->cookie);
            if ((unsigned int )tmp___17 != 1U) {
              tmp___15 = cookie_get_name(cur->cookie);
              cookies_delete(this, tmp___15);
              goto __Cont;
            }
          }
          tmp___19 = strlen((char const   *)(oreo));
          if (tmp___19 > 0UL) {
            tmp___18 = strlen((char const   *)(oreo));
            strncat((char * __restrict  )(oreo), (char const   * __restrict  )";",
                    (sizeof(oreo) - 10UL) - tmp___18);
          }
          tmp___20 = strlen((char const   *)(oreo));
          tmp___21 = cookie_get_name(cur->cookie);
          strncat((char * __restrict  )(oreo), (char const   * __restrict  )tmp___21,
                  (sizeof(oreo) - 10UL) - tmp___20);
          tmp___22 = strlen((char const   *)(oreo));
          strncat((char * __restrict  )(oreo), (char const   * __restrict  )"=", (sizeof(oreo) - 10UL) - tmp___22);
          tmp___23 = strlen((char const   *)(oreo));
          tmp___24 = cookie_get_value(cur->cookie);
          strncat((char * __restrict  )(oreo), (char const   * __restrict  )tmp___24,
                  (sizeof(oreo) - 10UL) - tmp___23);
        }
      }
    }
    __Cont: /* CIL Label */ 
    pre = cur;
    cur = cur->next;
  }
  tmp___26 = strlen((char const   *)(oreo));
  if (tmp___26 > 0UL) {
    strncpy((char * __restrict  )newton, (char const   * __restrict  )"Cookie: ",
            (size_t )8);
    strncat((char * __restrict  )newton, (char const   * __restrict  )(oreo), (size_t )4096);
    strncat((char * __restrict  )newton, (char const   * __restrict  )"\r\n", (size_t )2);
  }
  return (newton);
}
}
void cookies_list(COOKIES this ) 
{ 
  NODE *cur ;
  NODE *pre ;
  COOKIE tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  cur = (NODE *)((void *)0);
  pre = (NODE *)((void *)0);
  pre = this->head;
  cur = pre;
  while ((unsigned long )cur != (unsigned long )((void *)0)) {
    tmp = cur->cookie;
    if (! ((unsigned long )tmp == (unsigned long )((void *)0))) {
      tmp___0 = cookie_expires_string(tmp);
      tmp___1 = cookie_get_value(tmp);
      tmp___2 = cookie_get_name(tmp);
      printf((char const   * __restrict  )"%lld: NAME: %s\n   VALUE: %s\n   Expires: %s\n",
             (long long )cur->threadID, tmp___2, tmp___1, tmp___0);
    }
    pre = cur;
    cur = cur->next;
  }
  return;
}
}
static NODE *__delete_node(NODE *node ) 
{ 
  NODE *tmp ;

  {
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    return ((NODE *)((void *)0));
  }
  tmp = node->next;
  node->cookie = cookie_destroy(node->cookie);
  free((void *)node);
  node = tmp;
  return (node);
}
}
static void __strip(char *str ) 
{ 
  char *ch ;
  char *tmp ;
  char *tmp___0 ;

  {
  tmp = strstr((char const   *)str, "#");
  ch = tmp;
  if (ch) {
    *ch = (char )'\000';
  }
  tmp___0 = strstr((char const   *)str, "\n");
  ch = tmp___0;
  if (ch) {
    *ch = (char )'\000';
  }
  return;
}
}
HASH load_cookies(COOKIES this ) 
{ 
  FILE *fp ;
  int n ;
  HASH HOH ;
  HASH IDX ;
  size_t len ;
  BOOLEAN tmp ;
  char *p ;
  char *tmp___0 ;
  int i ;
  int num ;
  char **pair ;
  char tmp___1[1024] ;
  void *tmp___2 ;
  HASH tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;

  {
  n = -1;
  len = (size_t )4096;
  char line[len] ;
  tmp = __exists(this->file);
  if (! tmp) {
    return ((HASH )((void *)0));
  }
  fp = fopen((char const   * __restrict  )this->file, (char const   * __restrict  )"r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    return ((HASH )((void *)0));
  }
  HOH = new_hash();
  IDX = new_hash();
  memset((void *)(line), '\000', len);
  while (1) {
    tmp___8 = fgets((char * __restrict  )(line), (int )len, (FILE * __restrict  )fp);
    if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
      break;
    }
    tmp___0 = strchr((char const   *)(line), '\n');
    p = tmp___0;
    if (p) {
      *p = (char )'\000';
    } else {
      i = fgetc(fp);
      if (i != -1) {
        while (1) {
          i = fgetc(fp);
          if (i != -1) {
            if (! (i != 10)) {
              break;
            }
          } else {
            break;
          }
        }
        line[0] = (char )'\000';
      }
    }
    __strip(line);
    chomp(line);
    tmp___7 = strlen((char const   *)(line));
    if (tmp___7 > 1UL) {
      num = 2;
      pair = split((char )'|', line, & num);
      trim(*(pair + 0));
      trim(*(pair + 1));
      if ((unsigned long )*(pair + 0) != (unsigned long )((void *)0)) {
        if ((unsigned long )*(pair + 1) != (unsigned long )((void *)0)) {
          tmp___2 = hash_get(IDX, *(pair + 0));
          if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
            n ++;
            memset((void *)(tmp___1), '\000', (size_t )1024);
            snprintf((char * __restrict  )(tmp___1), (size_t )1024, (char const   * __restrict  )"%d",
                     n);
            hash_add(IDX, *(pair + 0), (void *)(tmp___1));
          }
          tmp___4 = hash_get(IDX, *(pair + 0));
          tmp___5 = hash_get(HOH, (char *)tmp___4);
          tmp___3 = (HASH )tmp___5;
          if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
            tmp___3 = new_hash();
            hash_add(tmp___3, *(pair + 1), (void *)*(pair + 1));
            tmp___6 = hash_get(IDX, *(pair + 0));
            hash_nadd(HOH, (char *)tmp___6, (void *)tmp___3, HASHSIZE);
          } else {
            hash_add(tmp___3, *(pair + 1), (void *)*(pair + 1));
          }
        }
      }
      split_free(pair, num);
    }
    memset((void *)(line), '\000', len);
  }
  fclose(fp);
  hash_destroy(IDX);
  return (HOH);
}
}
static BOOLEAN __save_cookies(COOKIES this ) 
{ 
  FILE *fp ;
  char *line ;
  size_t len ;
  time_t now ;
  NODE *cur ;
  void *tmp ;
  COOKIE tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  BOOLEAN tmp___3 ;
  time_t tmp___4 ;

  {
  len = (size_t )4120;
  cur = (NODE *)((void *)0);
  now = time((time_t *)((void *)0));
  fp = fopen((char const   * __restrict  )this->file, (char const   * __restrict  )"w");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Unable to open cookies file: %s\n",
            this->file);
    return ((BOOLEAN )0);
  }
  fputs((char const   * __restrict  )"#\n", (FILE * __restrict  )fp);
  fputs((char const   * __restrict  )"# Siege cookies file. You may edit this file to add cookies\n",
        (FILE * __restrict  )fp);
  fputs((char const   * __restrict  )"# manually but comments and formatting will be removed.    \n",
        (FILE * __restrict  )fp);
  fputs((char const   * __restrict  )"# All cookies that expire in the future will be preserved. \n",
        (FILE * __restrict  )fp);
  fputs((char const   * __restrict  )"# ---------------------------------------------------------\n",
        (FILE * __restrict  )fp);
  tmp = malloc(sizeof(char *) * len);
  line = (char *)tmp;
  cur = this->head;
  while ((unsigned long )cur != (unsigned long )((void *)0)) {
    tmp___0 = cur->cookie;
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      tmp___3 = cookie_get_session(tmp___0);
      if ((unsigned int )tmp___3 != 1U) {
        tmp___4 = cookie_get_expires(cur->cookie);
        if (tmp___4 >= now) {
          memset((void *)line, '\000', len);
          tmp___2 = cookie_to_string(tmp___0);
          if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
            tmp___1 = cookie_to_string(tmp___0);
            snprintf((char * __restrict  )line, len, (char const   * __restrict  )"%ld | %s\n",
                     cur->threadID, tmp___1);
          }
          fputs((char const   * __restrict  )line, (FILE * __restrict  )fp);
        }
      }
    }
    cur = cur->next;
  }
  free((void *)line);
  fclose(fp);
  return ((BOOLEAN )1);
}
}
static BOOLEAN __exists(char *file ) 
{ 
  int fd ;

  {
  fd = open((char const   *)file, 0);
  if (fd < 0) {
    return ((BOOLEAN )0);
  } else {
    close(fd);
    return ((BOOLEAN )1);
  }
  return ((BOOLEAN )0);
}
}
#pragma merger("0","/tmp/cil-sWzR7jeK.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
void display_help(void) ;
char *escape(char *buf ) ;
char *evaluate(HASH hash , char *buf ) ;
BOOLEAN is_variable_line(char *line ) ;
void parse(char *str ) 
{ 
  char *ch ;
  char *sp ;
  char *sl ;
  char *tmp ;
  char *tmp___0 ;

  {
  str = trim(str);
  if ((int )*(str + 0) == 35) {
    *(str + 0) = (char )'\000';
  }
  sp = strchr((char const   *)str, ' ');
  sl = strchr((char const   *)str, '/');
  if ((unsigned long )sl == (unsigned long )((void *)0)) {
    if ((unsigned long )sp != (unsigned long )((void *)0)) {
      tmp = strstr((char const   *)str, "#");
      ch = tmp;
      if (ch) {
        *ch = (char )'\000';
      }
    }
  }
  tmp___0 = strstr((char const   *)str, "\n");
  ch = tmp___0;
  if (ch) {
    *ch = (char )'\000';
  }
  trim(str);
  return;
}
}
int count(char *s , char c ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((int )*s == 0) {
    tmp___0 = 0;
  } else {
    tmp = count(s + 1, c);
    tmp___0 = tmp + ((int )*s == (int )c);
  }
  return (tmp___0);
}
}
int read_cfg_file(LINES *l , char *filename ) 
{ 
  FILE *file ;
  HASH H ;
  char *line ;
  char *option ;
  char *value ;
  void *tmp ;
  int num ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int r ;
  int cnt ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  BOOLEAN tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;

  {
  if (! l) {
    printf((char const   * __restrict  )"Structure not initialized!\n");
    return (-1);
  }
  file = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    NOTIFY((LEVEL )1, "unable to open file: %s", filename);
    display_help();
    exit(1);
  }
  tmp = xmalloc((size_t )40000);
  line = (char *)tmp;
  memset((void *)line, '\000', (size_t )40000);
  H = new_hash();
  l->index = 0;
  while (1) {
    tmp___15 = fgets((char * __restrict  )line, 40000, (FILE * __restrict  )file);
    if (! ((unsigned long )tmp___15 != (unsigned long )((void *)0))) {
      break;
    }
    tmp___0 = strchr((char const   *)line, '\n');
    p = tmp___0;
    if (p) {
      *p = (char )'\000';
    } else {
      num = fgetc(file);
      if (num != -1) {
        while (1) {
          num = fgetc(file);
          if (num != -1) {
            if (! (num != 10)) {
              break;
            }
          } else {
            break;
          }
        }
        *(line + 0) = (char )'\000';
      }
    }
    parse(line);
    chomp(line);
    tmp___14 = strlen((char const   *)line);
    if (! (tmp___14 == 0UL)) {
      tmp___13 = is_variable_line(line);
      if (tmp___13) {
        tmp___1 = line;
        option = tmp___1;
        while (1) {
          if (*tmp___1) {
            tmp___2 = __ctype_b_loc();
            if ((int const   )*(*tmp___2 + (int )((unsigned char )((int )*tmp___1))) & 8192) {
              break;
            } else
            if (61 == (int )*tmp___1) {
              break;
            } else
            if (58 == (int )*tmp___1) {
              break;
            }
          } else {
            break;
          }
          tmp___1 ++;
        }
        tmp___3 = tmp___1;
        tmp___1 ++;
        *tmp___3 = (char)0;
        while (1) {
          tmp___4 = __ctype_b_loc();
          if (! ((int const   )*(*tmp___4 + (int )((unsigned char )((int )*tmp___1))) & 8192)) {
            if (! (61 == (int )*tmp___1)) {
              if (! (58 == (int )*tmp___1)) {
                break;
              }
            }
          }
          tmp___1 ++;
        }
        value = tmp___1;
        while (*tmp___1) {
          tmp___1 ++;
        }
        tmp___5 = tmp___1;
        tmp___1 ++;
        *tmp___5 = (char)0;
        hash_add(H, option, (void *)value);
      } else {
        tmp___7 = xstrdup((char const   *)line);
        tmp___6 = tmp___7;
        r = 0;
        cnt = 0;
        tmp___8 = count(tmp___6, (char )'$');
        cnt += tmp___8;
        while (1) {
          tmp___10 = strstr((char const   *)tmp___6, "$");
          if (! tmp___10) {
            break;
          }
          tmp___9 = strstr((char const   *)tmp___6, "\\$");
          if (tmp___9) {
            tmp___6 = escape(tmp___6);
          } else {
            tmp___6 = evaluate(H, tmp___6);
          }
          r ++;
          if (r == cnt) {
            break;
          }
        }
        tmp___11 = realloc((void *)l->line, sizeof(char *) * (unsigned long )(l->index + 1));
        l->line = (char **)tmp___11;
        tmp___12 = strdup((char const   *)tmp___6);
        *(l->line + l->index) = tmp___12;
        (l->index) ++;
        free((void *)tmp___6);
      }
    }
    memset((void *)line, 0, (size_t )40000);
  }
  fclose(file);
  xfree((void *)line);
  hash_destroy(H);
  return (l->index);
}
}
int read_cmd_line(LINES *l , char *url ) 
{ 
  int x ;
  char head[40000] ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  x = 0;
  if (! l) {
    printf((char const   * __restrict  )"Structure not initialized!\n");
    return (-1);
  }
  l->index = 0;
  while (x < 4) {
    snprintf((char * __restrict  )(head), sizeof(head), (char const   * __restrict  )"%s",
             url);
    parse(head);
    chomp(head);
    tmp___1 = strlen((char const   *)(head));
    if (! (tmp___1 == 0UL)) {
      tmp = realloc((void *)l->line, sizeof(char *) * (unsigned long )(l->index + 1));
      l->line = (char **)tmp;
      tmp___0 = strdup((char const   *)(head));
      *(l->line + l->index) = tmp___0;
      (l->index) ++;
    }
    x ++;
  }
  return (l->index);
}
}
BOOLEAN is_variable_line(char *line ) 
{ 
  char *pos___0 ;
  char *x ;
  char c ;

  {
  pos___0 = strstr((char const   *)line, "=");
  if ((unsigned long )pos___0 != (unsigned long )((void *)0)) {
    x = line;
    while ((unsigned long )x < (unsigned long )pos___0) {
      c = *x;
      if ((int )c < 97) {
        goto _L___1;
      } else
      if ((int )c > 122) {
        _L___1: /* CIL Label */ 
        if ((int )c < 65) {
          goto _L___0;
        } else
        if ((int )c > 90) {
          _L___0: /* CIL Label */ 
          if ((int )c < 48) {
            goto _L;
          } else
          if ((int )c > 57) {
            _L: /* CIL Label */ 
            if ((int )c != 95) {
              return ((BOOLEAN )0);
            }
          }
        }
      }
      x ++;
    }
  } else {
    return ((BOOLEAN )0);
  }
  return ((BOOLEAN )1);
}
}
#pragma merger("0","/tmp/cil-h3BKIkFP.i","-W,-Wall,-Wunused-value,-g,-O2")
CREDS new_creds(SCHEME scheme , char *str ) ;
CREDS creds_destroy(CREDS this ) ;
void creds_set_username(CREDS this , char *username ) ;
void creds_set_password(CREDS this , char *password ) ;
void creds_set_realm(CREDS this , char *realm ) ;
size_t CREDSIZE  =    sizeof(struct CREDS_T );
static void __parse_input___0(CREDS this , char *str ) ;
CREDS new_creds(SCHEME scheme , char *str ) 
{ 
  CREDS this ;
  void *tmp ;

  {
  tmp = calloc(sizeof(struct CREDS_T ), (size_t )1);
  this = (CREDS )tmp;
  this->scheme = scheme;
  this->username = (char *)((void *)0);
  this->password = (char *)((void *)0);
  this->realm = (char *)((void *)0);
  __parse_input___0(this, str);
  return (this);
}
}
CREDS creds_destroy(CREDS this ) 
{ 


  {
  xfree((void *)this->username);
  xfree((void *)this->password);
  xfree((void *)this->realm);
  xfree((void *)this);
  return ((CREDS )((void *)0));
}
}
SCHEME creds_get_scheme(CREDS this ) 
{ 


  {
  return (this->scheme);
}
}
char *creds_get_username(CREDS this ) 
{ 


  {
  return (this->username);
}
}
char *creds_get_password(CREDS this ) 
{ 


  {
  return (this->password);
}
}
char *creds_get_realm(CREDS this ) 
{ 


  {
  return (this->realm);
}
}
void creds_set_username(CREDS this , char *username ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)username);
  len = tmp;
  tmp___0 = malloc(len + 1UL);
  this->username = (char *)tmp___0;
  memset((void *)this->username, '\000', len + 1UL);
  memcpy((void * __restrict  )this->username, (void const   * __restrict  )username,
         len);
  return;
}
}
void creds_set_password(CREDS this , char *password ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)password);
  len = tmp;
  tmp___0 = malloc(len + 1UL);
  this->password = (char *)tmp___0;
  memset((void *)this->password, '\000', len + 1UL);
  memcpy((void * __restrict  )this->password, (void const   * __restrict  )password,
         len);
  return;
}
}
void creds_set_realm(CREDS this , char *realm ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)realm);
  len = tmp;
  tmp___0 = malloc(len + 1UL);
  this->realm = (char *)tmp___0;
  memset((void *)this->realm, '\000', len + 1UL);
  memcpy((void * __restrict  )this->realm, (void const   * __restrict  )realm, len);
  return;
}
}
static void __parse_input___0(CREDS this , char *str ) 
{ 
  char *usr ;
  char *pwd ;
  char *rlm ;
  char *tmp ;
  char any[5] ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  any[0] = (char )'a';
  any[1] = (char )'n';
  any[2] = (char )'y';
  any[3] = (char )'\000';
  any[4] = (char )'\000';
  tmp = str;
  usr = tmp;
  while (1) {
    if (*tmp) {
      if ((int )*tmp != 58) {
        if (! ((int )*tmp != 0)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    tmp ++;
  }
  tmp___0 = tmp;
  tmp ++;
  *tmp___0 = (char)0;
  pwd = tmp;
  while (1) {
    if (*tmp) {
      if ((int )*tmp != 58) {
        if (! ((int )*tmp != 0)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    tmp ++;
  }
  if (0 != (int )*tmp) {
    tmp___1 = tmp;
    tmp ++;
    *tmp___1 = (char)0;
    rlm = tmp;
  } else {
    rlm = (char *)((void *)0);
  }
  creds_set_username(this, usr);
  creds_set_password(this, pwd);
  if ((unsigned long )rlm == (unsigned long )((void *)0)) {
    tmp___2 = any;
  } else {
    tmp___2 = rlm;
  }
  creds_set_realm(this, tmp___2);
  return;
}
}
#pragma merger("0","/tmp/cil-ZhChZ3_k.i","-W,-Wall,-Wunused-value,-g,-O2")
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern int pthread_cancel(pthread_t __th ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
CREW new_crew(int size , int maxsize , BOOLEAN block ) ;
BOOLEAN crew_add(CREW crew , void (*routine)() , void *arg ) ;
BOOLEAN crew_cancel(CREW this ) ;
BOOLEAN crew_join(CREW crew , BOOLEAN finish , void **payload ) ;
void crew_destroy(CREW crew ) ;
void crew_set_shutdown(CREW this , BOOLEAN shutdown___0 ) ;
int crew_get_size(CREW this ) ;
int crew_get_total(CREW this ) ;
BOOLEAN crew_get_shutdown(CREW this ) ;
static void *crew_thread(void *crew ) ;
CREW new_crew(int size , int maxsize , BOOLEAN block ) 
{ 
  int x ;
  int c ;
  CREW this ;
  void *tmp ;
  pthread_t *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  tmp = calloc(sizeof(*this), (size_t )1);
  this = (CREW )tmp;
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    return ((CREW )((void *)0));
  }
  tmp___1 = malloc(sizeof(pthread_t ) * (unsigned long )size);
  tmp___0 = (pthread_t *)tmp___1;
  this->threads = tmp___0;
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    return ((CREW )((void *)0));
  }
  this->size = size;
  this->maxsize = maxsize;
  this->cursize = 0;
  this->total = 0;
  this->block = block;
  this->head = (WORK *)((void *)0);
  this->tail = (WORK *)((void *)0);
  this->closed = (BOOLEAN )0;
  this->shutdown = (BOOLEAN )0;
  c = pthread_mutex_init(& this->lock, (pthread_mutexattr_t const   *)((void *)0));
  if (c != 0) {
    return ((CREW )((void *)0));
  }
  c = pthread_cond_init((pthread_cond_t * __restrict  )(& this->not_empty), (pthread_condattr_t const   * __restrict  )((void *)0));
  if (c != 0) {
    return ((CREW )((void *)0));
  }
  c = pthread_cond_init((pthread_cond_t * __restrict  )(& this->not_full), (pthread_condattr_t const   * __restrict  )((void *)0));
  if (c != 0) {
    return ((CREW )((void *)0));
  }
  c = pthread_cond_init((pthread_cond_t * __restrict  )(& this->empty), (pthread_condattr_t const   * __restrict  )((void *)0));
  if (c != 0) {
    return ((CREW )((void *)0));
  }
  x = 0;
  while (x != size) {
    c = pthread_create((pthread_t * __restrict  )(this->threads + x), (pthread_attr_t const   * __restrict  )((void *)0),
                       & crew_thread, (void * __restrict  )((void *)this));
    if (c != 0) {
      tmp___2 = __errno_location();
      switch (*tmp___2) {
      case 22: 
      NOTIFY((LEVEL )2, "Error creating additional threads %s:%d", "crew.c", 86);
      break;
      case 1: 
      NOTIFY((LEVEL )2, "Inadequate permission to create pool %s:%d", "crew.c", 87);
      break;
      case 11: 
      NOTIFY((LEVEL )2, "Inadequate resources to create pool %s:%d", "crew.c", 88);
      break;
      case 12: 
      NOTIFY((LEVEL )2, "Exceeded thread limit for this system %s:%d", "crew.c", 89);
      break;
      default: 
      NOTIFY((LEVEL )2, "Unknown error building thread pool %s:%d", "crew.c", 90);
      break;
      }
      return ((CREW )((void *)0));
    }
    x ++;
  }
  return (this);
}
}
static void *crew_thread(void *crew ) 
{ 
  int c ;
  WORK *workptr ;
  CREW this ;
  WORK *tmp ;

  {
  this = (CREW )crew;
  while (1) {
    c = pthread_mutex_lock(& this->lock);
    if (c != 0) {
      NOTIFY((LEVEL )3, "mutex lock");
    }
    while (1) {
      if (this->cursize == 0) {
        if (! (! this->shutdown)) {
          break;
        }
      } else {
        break;
      }
      c = pthread_cond_wait((pthread_cond_t * __restrict  )(& this->not_empty), (pthread_mutex_t * __restrict  )(& this->lock));
      if (c != 0) {
        NOTIFY((LEVEL )3, "pthread wait");
      }
    }
    if ((unsigned int )this->shutdown == 1U) {
      c = pthread_mutex_unlock(& this->lock);
      if (c != 0) {
        NOTIFY((LEVEL )3, "mutex unlock");
      }
      pthread_exit((void *)0);
    }
    workptr = this->head;
    (this->cursize) --;
    if (this->cursize == 0) {
      tmp = (WORK *)((void *)0);
      this->tail = tmp;
      this->head = tmp;
    } else {
      this->head = workptr->next;
    }
    if (this->block) {
      if (this->cursize == this->maxsize - 1) {
        c = pthread_cond_broadcast(& this->not_full);
        if (c != 0) {
          NOTIFY((LEVEL )3, "pthread broadcast");
        }
      }
    }
    if (this->cursize == 0) {
      c = pthread_cond_signal(& this->empty);
      if (c != 0) {
        NOTIFY((LEVEL )3, "pthread signal");
      }
    }
    c = pthread_mutex_unlock(& this->lock);
    if (c != 0) {
      NOTIFY((LEVEL )3, "pthread unlock");
    }
    (*(workptr->routine))(workptr->arg);
    xfree((void *)workptr);
  }
  return ((void *)0);
}
}
BOOLEAN crew_add(CREW crew , void (*routine)() , void *arg ) 
{ 
  int c ;
  WORK *workptr ;
  void *tmp ;
  WORK *tmp___0 ;

  {
  c = pthread_mutex_lock(& crew->lock);
  if (c != 0) {
    NOTIFY((LEVEL )3, "pthread lock");
  }
  if (crew->cursize == crew->maxsize) {
    if (! crew->block) {
      c = pthread_mutex_unlock(& crew->lock);
      if (c != 0) {
        NOTIFY((LEVEL )3, "pthread unlock");
      }
      return ((BOOLEAN )0);
    }
  }
  while (1) {
    if (crew->cursize == crew->maxsize) {
      if (crew->shutdown) {
        break;
      } else
      if (crew->closed) {
        break;
      }
    } else {
      break;
    }
    c = pthread_cond_wait((pthread_cond_t * __restrict  )(& crew->not_full), (pthread_mutex_t * __restrict  )(& crew->lock));
    if (c != 0) {
      NOTIFY((LEVEL )3, "pthread wait");
    }
  }
  if (crew->shutdown) {
    goto _L;
  } else
  if (crew->closed) {
    _L: /* CIL Label */ 
    c = pthread_mutex_unlock(& crew->lock);
    if (c != 0) {
      NOTIFY((LEVEL )3, "pthread unlock");
    }
    return ((BOOLEAN )0);
  }
  tmp = malloc(sizeof(WORK ));
  workptr = (WORK *)tmp;
  if ((unsigned long )workptr == (unsigned long )((void *)0)) {
    NOTIFY((LEVEL )3, "out of memory");
  }
  workptr->routine = routine;
  workptr->arg = arg;
  workptr->next = (struct work *)((void *)0);
  if (crew->cursize == 0) {
    tmp___0 = workptr;
    crew->head = tmp___0;
    crew->tail = tmp___0;
    c = pthread_cond_broadcast(& crew->not_empty);
    if (c != 0) {
      NOTIFY((LEVEL )3, "pthread signal");
    }
  } else {
    (crew->tail)->next = workptr;
    crew->tail = workptr;
  }
  (crew->cursize) ++;
  (crew->total) ++;
  c = pthread_mutex_unlock(& crew->lock);
  if (c != 0) {
    NOTIFY((LEVEL )3, "pthread unlock");
  }
  return ((BOOLEAN )1);
}
}
BOOLEAN crew_cancel(CREW this ) 
{ 
  int x ;
  int size ;

  {
  size = this->size;
  crew_set_shutdown(this, (BOOLEAN )1);
  x = 0;
  while (x < size) {
    pthread_cancel(*(this->threads + x));
    x ++;
  }
  return ((BOOLEAN )1);
}
}
BOOLEAN crew_join(CREW crew , BOOLEAN finish , void **payload ) 
{ 
  int x ;
  int c ;
  int rc ;
  struct timespec ts ;
  struct timeval tp ;

  {
  c = pthread_mutex_lock(& crew->lock);
  if (c != 0) {
    NOTIFY((LEVEL )3, "pthread lock");
  }
  if (crew->closed) {
    goto _L;
  } else
  if (crew->shutdown) {
    _L: /* CIL Label */ 
    c = pthread_mutex_unlock(& crew->lock);
    if (c != 0) {
      NOTIFY((LEVEL )3, "pthread unlock");
    }
    return ((BOOLEAN )0);
  }
  crew->closed = (BOOLEAN )1;
  if ((unsigned int )finish == 1U) {
    while (1) {
      if (crew->cursize != 0) {
        if (! (! crew->shutdown)) {
          break;
        }
      } else {
        break;
      }
      rc = gettimeofday((struct timeval * __restrict  )(& tp), (void * __restrict  )((void *)0));
      if (rc != 0) {
        perror("gettimeofday");
      }
      ts.tv_sec = tp.tv_sec + 60L;
      ts.tv_nsec = tp.tv_usec * 1000L;
      rc = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& crew->empty),
                                  (pthread_mutex_t * __restrict  )(& crew->lock),
                                  (struct timespec  const  * __restrict  )(& ts));
      if (rc == 110) {
        pthread_mutex_unlock(& crew->lock);
      }
      if (rc != 0) {
        NOTIFY((LEVEL )3, "pthread wait");
      }
    }
  }
  crew->shutdown = (BOOLEAN )1;
  c = pthread_mutex_unlock(& crew->lock);
  if (c != 0) {
    NOTIFY((LEVEL )3, "pthread_mutex_unlock");
  }
  c = pthread_cond_broadcast(& crew->not_empty);
  if (c != 0) {
    NOTIFY((LEVEL )3, "pthread broadcast");
  }
  c = pthread_cond_broadcast(& crew->not_full);
  if (c != 0) {
    NOTIFY((LEVEL )3, "pthread broadcast");
  }
  x = 0;
  while (x < crew->size) {
    c = pthread_join(*(crew->threads + x), payload);
    if (c != 0) {
      NOTIFY((LEVEL )3, "pthread_join");
    }
    x ++;
  }
  return ((BOOLEAN )1);
}
}
void crew_destroy(CREW crew ) 
{ 
  WORK *workptr ;

  {
  xfree((void *)crew->threads);
  while ((unsigned long )crew->head != (unsigned long )((void *)0)) {
    workptr = crew->head;
    crew->head = (crew->head)->next;
    xfree((void *)workptr);
  }
  xfree((void *)crew);
  return;
}
}
void crew_set_shutdown(CREW this , BOOLEAN shutdown___0 ) 
{ 


  {
  this->shutdown = shutdown___0;
  pthread_cond_broadcast(& this->not_empty);
  pthread_cond_broadcast(& this->not_full);
  pthread_cond_broadcast(& this->empty);
  return;
}
}
int crew_get_size(CREW this ) 
{ 


  {
  return (this->size);
}
}
int crew_get_total(CREW this ) 
{ 


  {
  return (this->total);
}
}
BOOLEAN crew_get_shutdown(CREW this ) 
{ 


  {
  return (this->shutdown);
}
}
#pragma merger("0","/tmp/cil-tP8N_aPL.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
DATA new_data(void) ;
DATA data_destroy(DATA this ) ;
void data_set_start(DATA this ) ;
void data_set_stop(DATA this ) ;
void data_set_highest(DATA this , float highest ) ;
void data_set_lowest(DATA this , float lowest ) ;
void data_increment_bytes(DATA this , unsigned long bytes ) ;
void data_increment_count(DATA this , unsigned long count___0 ) ;
void data_increment_total(DATA this , float total ) ;
void data_increment_code(DATA this , int code ) ;
void data_increment_fail(DATA this , int fail ) ;
void data_increment_okay(DATA this , int okay___0 ) ;
float data_get_total(DATA this ) ;
float data_get_bytes(DATA this ) ;
float data_get_megabytes(DATA this ) ;
float data_get_highest(DATA this ) ;
float data_get_lowest(DATA this ) ;
float data_get_elapsed(DATA this ) ;
float data_get_availability(DATA this ) ;
float data_get_response_time(DATA this ) ;
float data_get_transaction_rate(DATA this ) ;
float data_get_throughput(DATA this ) ;
float data_get_concurrency(DATA this ) ;
unsigned int data_get_count(DATA this ) ;
unsigned int data_get_code(DATA this ) ;
unsigned int data_get_fail(DATA this ) ;
unsigned int data_get_okay(DATA this ) ;
DATA new_data(void) 
{ 
  DATA this ;
  void *tmp ;

  {
  tmp = calloc(sizeof(*this), (size_t )1);
  this = (DATA )tmp;
  this->total = (float )0.0;
  this->available = (float )0.0;
  this->count = (unsigned int )0.0;
  this->okay = 0U;
  this->fail = (unsigned int )0.0;
  this->lowest = (float )-1;
  this->highest = (float )0.0;
  this->elapsed = (float )0.0;
  this->bytes = (unsigned long long )0.0;
  return (this);
}
}
DATA data_destroy(DATA this ) 
{ 


  {
  xfree((void *)this);
  return ((DATA )((void *)0));
}
}
void data_increment_bytes(DATA this , unsigned long bytes ) 
{ 


  {
  this->bytes += (unsigned long long )bytes;
  return;
}
}
void data_increment_count(DATA this , unsigned long count___0 ) 
{ 


  {
  this->count = (unsigned int )((unsigned long )this->count + count___0);
  return;
}
}
void data_increment_total(DATA this , float total ) 
{ 


  {
  this->total += total;
  return;
}
}
void data_increment_code(DATA this , int code ) 
{ 


  {
  this->code += (unsigned int )code;
  return;
}
}
void data_increment_fail(DATA this , int fail ) 
{ 


  {
  this->fail += (unsigned int )fail;
  return;
}
}
void data_increment_okay(DATA this , int okay___0 ) 
{ 


  {
  this->okay += (unsigned int )okay___0;
  return;
}
}
void data_set_start(DATA this ) 
{ 


  {
  this->start = times(& this->t_start);
  return;
}
}
void data_set_stop(DATA this ) 
{ 


  {
  this->stop = times(& this->t_stop);
  return;
}
}
void data_set_highest(DATA this , float highest ) 
{ 


  {
  if (this->highest < highest) {
    this->highest = highest;
  }
  return;
}
}
void data_set_lowest(DATA this , float lowest ) 
{ 


  {
  if (this->lowest <= (float )0) {
    this->lowest = lowest;
  } else
  if (this->lowest > lowest) {
    this->lowest = lowest;
  }
  return;
}
}
unsigned int data_get_count(DATA this ) 
{ 


  {
  return (this->count);
}
}
unsigned int data_get_code(DATA this ) 
{ 


  {
  return (this->code);
}
}
unsigned int data_get_fail(DATA this ) 
{ 


  {
  return (this->fail);
}
}
unsigned int data_get_okay(DATA this ) 
{ 


  {
  return (this->okay);
}
}
float data_get_total(DATA this ) 
{ 


  {
  return (this->total);
}
}
float data_get_bytes(DATA this ) 
{ 


  {
  return ((float )this->bytes);
}
}
float data_get_highest(DATA this ) 
{ 


  {
  return (this->highest);
}
}
float data_get_lowest(DATA this ) 
{ 


  {
  if (this->code) {
    return (this->lowest);
  } else {
    return ((float )this->code);
  }
}
}
float data_get_megabytes(DATA this ) 
{ 


  {
  return ((float )((double )((float )this->bytes) / (1024.0 * 1024.0)));
}
}
float data_get_elapsed(DATA this ) 
{ 
  long tps ;
  clock_t time___0 ;

  {
  time___0 = this->stop - this->start;
  tps = sysconf(2);
  this->elapsed = (float )time___0 / (float )tps;
  return (this->elapsed);
}
}
float data_get_availability(DATA this ) 
{ 


  {
  if (this->count == 0U) {
    this->available = (float )0;
  } else {
    this->available = (float )((this->count / (this->count + this->fail)) * 100U);
  }
  return (this->available);
}
}
float data_get_response_time(DATA this ) 
{ 


  {
  if (this->total == (float )0) {
    return ((float )0);
  } else
  if (this->count == 0U) {
    return ((float )0);
  }
  return (this->total / (float )this->count);
}
}
float data_get_transaction_rate(DATA this ) 
{ 


  {
  if (this->count == 0U) {
    return ((float )0);
  } else
  if (this->elapsed == (float )0) {
    return ((float )0);
  }
  return ((float )this->count / this->elapsed);
}
}
float data_get_throughput(DATA this ) 
{ 


  {
  if (this->elapsed == (float )0) {
    return ((float )0);
  }
  return ((float )((double )this->bytes / (((double )this->elapsed * 1024.0) * 1024.0)));
}
}
float data_get_concurrency(DATA this ) 
{ 


  {
  if (this->elapsed == (float )0) {
    return ((float )0);
  }
  return (this->total / this->elapsed);
}
}
#pragma merger("0","/tmp/cil-zXJLXENs.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 )  __attribute__((__const__)) ;
char *date_to_string(DATE this ) ;
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
char const   * const  wday[7]  = {      (char const   * const  )"Mon",      (char const   * const  )"Tue",      (char const   * const  )"Wed",      (char const   * const  )"Thu", 
        (char const   * const  )"Fri",      (char const   * const  )"Sat",      (char const   * const  )"Sun"};
char const   * const  weekday[7]  = {      (char const   * const  )"Sunday",      (char const   * const  )"Monday",      (char const   * const  )"Tuesday",      (char const   * const  )"Wednesday", 
        (char const   * const  )"Thursday",      (char const   * const  )"Friday",      (char const   * const  )"Saturday"};
char const   * const  month[12]  = 
  {      (char const   * const  )"Jan",      (char const   * const  )"Feb",      (char const   * const  )"Mar",      (char const   * const  )"Apr", 
        (char const   * const  )"May",      (char const   * const  )"Jun",      (char const   * const  )"Jul",      (char const   * const  )"Aug", 
        (char const   * const  )"Sep",      (char const   * const  )"Oct",      (char const   * const  )"Nov",      (char const   * const  )"Dec"};
static struct tzinfo  const  tz[43]  = 
  {      {"GMT", 0}, 
        {"UTC", 0}, 
        {"WET", 0}, 
        {"BST", -60}, 
        {"WAT", 60}, 
        {"AST", 240}, 
        {"ADT", 180}, 
        {"EST", 300}, 
        {"EDT", 240}, 
        {"CST", 360}, 
        {"CDT", 300}, 
        {"MST", 420}, 
        {"MDT", 360}, 
        {"PST", 480}, 
        {"PDT", 420}, 
        {"YST", 540}, 
        {"YDT", 480}, 
        {"HST", 600}, 
        {"HDT", 540}, 
        {"CAT", 600}, 
        {"AHST", 600}, 
        {"NT", 660}, 
        {"IDLW", 720}, 
        {"CET", -60}, 
        {"MET", -60}, 
        {"MEWT", -60}, 
        {"MEST", -120}, 
        {"CEST", -120}, 
        {"MESZ", -120}, 
        {"FWT", -60}, 
        {"FST", -120}, 
        {"EET", -120}, 
        {"WAST", -420}, 
        {"WADT", -480}, 
        {"CCT", -480}, 
        {"JST", -540}, 
        {"EAST", -600}, 
        {"EADT", -660}, 
        {"GST", -600}, 
        {"NZT", -720}, 
        {"NZST", -720}, 
        {"NZDT", -780}, 
        {"IDLE", -720}};
static int __checkday(char *check , size_t len ) ;
static int __checkmonth(char *check ) ;
static int __checktz(char *check ) ;
static time_t __strtotime(char const   *string ) ;
size_t DATESIZE  =    sizeof(struct DATE_T );
DATE new_date(char *date ) 
{ 
  time_t now ;
  DATE this ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = calloc(DATESIZE, (size_t )1);
  this = (DATE )tmp;
  this->tm = (struct tm *)((void *)0);
  this->etag = (char *)((void *)0);
  tmp___0 = malloc((size_t )64);
  this->date = (char *)tmp___0;
  tmp___1 = malloc((size_t )64);
  this->head = (char *)tmp___1;
  memset((void *)this->date, '\000', (size_t )64);
  memset((void *)this->head, '\000', (size_t )64);
  if ((unsigned long )date == (unsigned long )((void *)0)) {
    now = time((time_t *)((void *)0));
    this->tm = gmtime_r((time_t const   * __restrict  )(& now), (struct tm * __restrict  )(& this->safe));
  } else {
    now = __strtotime((char const   *)date);
    this->tm = gmtime_r((time_t const   * __restrict  )(& now), (struct tm * __restrict  )(& this->safe));
  }
  return (this);
}
}
DATE new_etag(char *etag ) 
{ 
  DATE this ;
  void *tmp ;

  {
  tmp = calloc(DATESIZE, (size_t )1);
  this = (DATE )tmp;
  this->tm = (struct tm *)((void *)0);
  this->date = (char *)((void *)0);
  this->etag = (char *)((void *)0);
  if ((unsigned long )etag != (unsigned long )((void *)0)) {
    this->etag = xstrdup((char const   *)etag);
  }
  return (this);
}
}
DATE date_destroy(DATE this ) 
{ 


  {
  if ((unsigned long )this != (unsigned long )((void *)0)) {
    free((void *)this->date);
    free((void *)this->head);
    free((void *)this->etag);
    free((void *)this);
    this = (DATE )((void *)0);
  }
  return (this);
}
}
char *date_get_etag(DATE this ) 
{ 
  char const   *tmp ;

  {
  if ((unsigned long )this->etag == (unsigned long )((void *)0)) {
    tmp = "";
  } else {
    tmp = (char const   *)this->etag;
  }
  return ((char *)tmp);
}
}
char *date_get_rfc850(DATE this ) 
{ 


  {
  memset((void *)this->date, '\000', (size_t )64);
  if ((unsigned long )this->tm == (unsigned long )((void *)0)) {
    return ((char *)"");
  } else
  if ((this->tm)->tm_year == 0) {
    return ((char *)"");
  }
  snprintf((char * __restrict  )this->date, (size_t )64, (char const   * __restrict  )"%s, %d %s %d %d:%d:%d GMT",
           wday[(this->tm)->tm_wday], (this->tm)->tm_mday, month[(this->tm)->tm_mon],
           (this->tm)->tm_year, (this->tm)->tm_hour, (this->tm)->tm_min, (this->tm)->tm_sec);
  return (this->date);
}
}
BOOLEAN date_expired(DATE this ) 
{ 
  long res ;
  time_t now ;
  struct tm *gmt ;
  time_t then ;
  double tmp ;
  int tmp___0 ;

  {
  res = 0L;
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    return ((BOOLEAN )1);
  } else
  if ((unsigned long )this->tm == (unsigned long )((void *)0)) {
    return ((BOOLEAN )1);
  }
  now = time((time_t *)((void *)0));
  gmt = gmtime((time_t const   *)(& now));
  then = mktime(this->tm);
  now = mktime(gmt);
  tmp = difftime(then, now);
  res = (long )tmp;
  if (res < 0L) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return ((BOOLEAN )tmp___0);
}
}
char *date_to_string(DATE this ) 
{ 


  {
  if ((unsigned long )this->etag != (unsigned long )((void *)0)) {
    return (this->etag);
  }
  memset((void *)this->date, '\000', (size_t )64);
  setlocale(2, "C");
  strftime((char * __restrict  )this->date, (size_t )64, (char const   * __restrict  )"%a, %F %T ",
           (struct tm  const  * __restrict  )this->tm);
  return (this->date);
}
}
time_t mylocaltime(struct tm *tm ) 
{ 
  time_t epoch ;
  time_t offset ;
  struct tm *tmp ;
  time_t tmp___0 ;
  time_t local ;
  time_t tmp___1 ;
  double tmp___2 ;

  {
  epoch = (time_t )0;
  tmp = localtime((time_t const   *)(& epoch));
  tmp___0 = mktime(tmp);
  offset = tmp___0;
  tmp___1 = mktime(tm);
  local = tmp___1;
  tmp___2 = difftime(local, offset);
  return ((time_t )tmp___2);
}
}
char *date_stamp(DATE this ) 
{ 
  struct tm *tmp ;
  time_t time___0 ;

  {
  time___0 = mylocaltime(this->tm);
  tmp = localtime((time_t const   *)(& time___0));
  memset((void *)this->date, '\000', (size_t )64);
  strftime((char * __restrict  )this->date, (size_t )64, (char const   * __restrict  )"[%a, %F %T] ",
           (struct tm  const  * __restrict  )tmp);
  return (this->date);
}
}
time_t date_adjust(time_t tvalue , int secs ) 
{ 
  struct tm *tp ;
  time_t ret ;

  {
  ret = (time_t )(tvalue != -1L);
  if (ret) {
    tp = localtime((time_t const   *)(& tvalue));
    if (secs > 2147483647 - tp->tm_sec) {
      ret = (time_t )-1;
    } else {
      tp->tm_sec += secs;
      ret = mktime(tp);
    }
  }
  return (ret);
}
}
static int __checkday(char *check , size_t len ) 
{ 
  int i ;
  char const   * const  *what ;
  BOOLEAN found ;
  BOOLEAN tmp ;
  int tmp___0 ;

  {
  found = (BOOLEAN )0;
  if (len > 3UL) {
    what = & weekday[0];
  } else {
    what = & wday[0];
  }
  i = 0;
  while (i < 7) {
    tmp = strmatch(check, (char *)*(what + 0));
    if (tmp) {
      found = (BOOLEAN )1;
      break;
    }
    what ++;
    i ++;
  }
  if (found) {
    tmp___0 = i;
  } else {
    tmp___0 = -1;
  }
  return (tmp___0);
}
}
static int __checkmonth(char *check ) 
{ 
  int i ;
  char const   * const  *what ;
  BOOLEAN found ;
  BOOLEAN tmp ;
  int tmp___0 ;

  {
  found = (BOOLEAN )0;
  what = & month[0];
  i = 0;
  while (i < 12) {
    tmp = strmatch(check, (char *)*(what + 0));
    if (tmp) {
      found = (BOOLEAN )1;
      break;
    }
    what ++;
    i ++;
  }
  if (found) {
    tmp___0 = i;
  } else {
    tmp___0 = -1;
  }
  return (tmp___0);
}
}
static int __checktz(char *check ) 
{ 
  unsigned int i ;
  struct tzinfo  const  *what ;
  BOOLEAN found ;
  BOOLEAN tmp ;
  int tmp___0 ;

  {
  found = (BOOLEAN )0;
  what = tz;
  i = 0U;
  while ((unsigned long )i < sizeof(tz) / sizeof(tz[0])) {
    tmp = strmatch(check, (char *)what->name);
    if (tmp) {
      found = (BOOLEAN )1;
      break;
    }
    what ++;
    i ++;
  }
  if (found) {
    tmp___0 = what->offset * 60;
  } else {
    tmp___0 = (int const   )-1;
  }
  return ((int )tmp___0);
}
}
static void skip(char const   **date ) 
{ 
  unsigned short const   **tmp ;

  {
  while (1) {
    if (*(*date)) {
      tmp = __ctype_b_loc();
      if ((int const   )*(*tmp + (int )((unsigned char )*(*date))) & 8) {
        break;
      }
    } else {
      break;
    }
    (*date) ++;
  }
  return;
}
}
static time_t __strtotime(char const   *string ) 
{ 
  int sec ;
  int min ;
  int hour ;
  int mday ;
  int mon ;
  int year ;
  int wday___0 ;
  int tzoff ;
  int part ;
  time_t t ;
  struct tm tm ;
  char const   *date ;
  char const   *indate ;
  enum assume dignext ;
  BOOLEAN found ;
  char buf[32] ;
  unsigned int tmp ;
  size_t len ;
  int val ;
  char *end ;
  long tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  struct tm *gmt ;
  long delta ;
  time_t t2 ;
  struct tm keeptime2 ;
  struct tm *tmp___4 ;
  int tmp___5 ;

  {
  sec = -1;
  min = -1;
  hour = -1;
  mday = -1;
  mon = -1;
  year = -1;
  wday___0 = -1;
  tzoff = -1;
  part = 0;
  t = (time_t )0;
  indate = string;
  dignext = (enum assume )0;
  found = (BOOLEAN )0;
  if (string) {
    if (! *string) {
      return ((time_t )0);
    }
  } else {
    return ((time_t )0);
  }
  date = string;
  while (1) {
    if (*date) {
      if (! (part < 6)) {
        break;
      }
    } else {
      break;
    }
    found = (BOOLEAN )0;
    skip(& date);
    tmp___3 = __ctype_b_loc();
    if ((int const   )*(*tmp___3 + (int )((unsigned char )*date)) & 1024) {
      buf[0] = (char )'\000';
      tmp = 1U;
      while (! (tmp >= 32U)) {
        buf[tmp] = (char)0;
        tmp ++;
      }
      sscanf((char const   * __restrict  )date, (char const   * __restrict  )"%31[A-Za-z]",
             buf);
      len = strlen((char const   *)(buf));
      if (wday___0 == -1) {
        wday___0 = __checkday(buf, len);
        if (wday___0 != -1) {
          found = (BOOLEAN )1;
        }
      }
      if (! found) {
        if (mon == -1) {
          mon = __checkmonth(buf);
          if (mon != -1) {
            found = (BOOLEAN )1;
          }
        }
      }
      if (! found) {
        if (tzoff == -1) {
          tzoff = __checktz(buf);
          if (tzoff != -1) {
            found = (BOOLEAN )1;
          }
        }
      }
      if (! found) {
        return ((time_t )-1);
      }
      date += len;
    } else {
      tmp___2 = __ctype_b_loc();
      if ((int const   )*(*tmp___2 + (int )((unsigned char )*date)) & 2048) {
        if (sec == -1) {
          tmp___1 = sscanf((char const   * __restrict  )date, (char const   * __restrict  )"%02d:%02d:%02d",
                           & hour, & min, & sec);
          if (3 == tmp___1) {
            date += 8;
            found = (BOOLEAN )1;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          tmp___0 = strtol((char const   * __restrict  )date, (char ** __restrict  )(& end),
                           10);
          val = (int )tmp___0;
          if (tzoff == -1) {
            if (end - (char *)date == 4L) {
              if (val < 1300) {
                if ((unsigned long )indate < (unsigned long )date) {
                  if ((int const   )*(date + -1) == 43) {
                    goto _L;
                  } else
                  if ((int const   )*(date + -1) == 45) {
                    _L: /* CIL Label */ 
                    found = (BOOLEAN )1;
                    tzoff = ((val / 100) * 60 + val % 100) * 60;
                    if ((int const   )*(date + -1) == 43) {
                      tzoff = - tzoff;
                    } else {
                      tzoff = tzoff;
                    }
                  }
                }
              }
            }
          }
          if (end - (char *)date == 8L) {
            if (year == -1) {
              if (mon == -1) {
                if (mday == -1) {
                  found = (BOOLEAN )1;
                  year = val / 10000;
                  mon = (val % 10000) / 100 - 1;
                  mday = val % 100;
                }
              }
            }
          }
          if (! found) {
            if ((unsigned int )dignext == 0U) {
              if (mday == -1) {
                if (val > 0) {
                  if (val < 32) {
                    mday = val;
                    found = (BOOLEAN )1;
                  }
                }
                dignext = (enum assume )1;
              }
            }
          }
          if (! found) {
            if ((unsigned int )dignext == 1U) {
              if (year == -1) {
                year = val;
                found = (BOOLEAN )1;
                if (year > 1970) {
                  year -= 1900;
                }
                if (mday == -1) {
                  dignext = (enum assume )0;
                }
              }
            }
          }
          if (! found) {
            return ((time_t )-1);
          }
          date = (char const   *)end;
        }
      }
    }
    part ++;
  }
  if (-1 == sec) {
    hour = 0;
    min = hour;
    sec = min;
  }
  if (-1 == mday) {
    return ((time_t )-1);
  } else
  if (-1 == mon) {
    return ((time_t )-1);
  } else
  if (-1 == year) {
    return ((time_t )-1);
  }
  if (year > 2037) {
    return ((time_t )2147483647);
  }
  tm.tm_sec = sec;
  tm.tm_min = min;
  tm.tm_hour = hour;
  tm.tm_mday = mday;
  tm.tm_mon = mon;
  tm.tm_year = year;
  tm.tm_wday = 0;
  tm.tm_yday = 0;
  tm.tm_isdst = 0;
  t = mktime(& tm);
  if (-1 != (int )t) {
    tmp___4 = gmtime_r((time_t const   * __restrict  )(& t), (struct tm * __restrict  )(& keeptime2));
    gmt = tmp___4;
    if (! gmt) {
      return ((time_t )-1);
    }
    t2 = mktime(gmt);
    if (tzoff != -1) {
      tmp___5 = tzoff;
    } else {
      tmp___5 = 0;
    }
    delta = (time_t )tmp___5 + (t - t2);
    if (delta > 0L) {
      if (t + delta < t) {
        return ((time_t )-1);
      }
    }
    t += delta;
  }
  return (t);
}
}
#pragma merger("0","/tmp/cil-tQcdXwxx.i","-W,-Wall,-Wunused-value,-g,-O2")
char *substring(char *str , int start___0 , int len ) ;
char *escape(char *buf ) 
{ 
  size_t i ;
  size_t len ;
  char *res ;
  char fin[40000] ;
  void *tmp ;
  size_t tmp___0 ;

  {
  i = (size_t )0;
  tmp = xrealloc((void *)buf, 40000UL * sizeof(char ));
  res = (char *)tmp;
  if ((unsigned long )res != (unsigned long )((void *)0)) {
    buf = res;
  }
  len = strlen((char const   *)buf);
  while (1) {
    if (i < len) {
      if (! ((int )*(buf + i) != 92)) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  while (i < len) {
    *(buf + i) = *(buf + (i + 1UL));
    i ++;
  }
  *(buf + len) = (char )'\000';
  strncpy((char * __restrict  )(fin), (char const   * __restrict  )buf, len);
  memset((void *)res, '\000', 40000UL * sizeof(char ));
  tmp___0 = strlen((char const   *)(fin));
  strncpy((char * __restrict  )res, (char const   * __restrict  )(fin), tmp___0);
  return (res);
}
}
char *evaluate(HASH hash , char *buf ) 
{ 
  int x ;
  int ENV ;
  int len ;
  char final[40000] ;
  char *ptr ;
  char *string ;
  char const   *scan ;
  char *result ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  BOOLEAN tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;

  {
  x = 0;
  ENV = 0;
  len = 0;
  tmp = xrealloc((void *)buf, 40000UL * sizeof(char ));
  result = (char *)tmp;
  if ((unsigned long )result != (unsigned long )((void *)0)) {
    buf = result;
  }
  tmp___0 = strchr((char const   *)buf, '$');
  scan = (char const   *)(tmp___0 + 1);
  tmp___1 = strlen((char const   *)buf);
  tmp___2 = strlen(scan);
  len = (int )((tmp___1 - tmp___2) - 1UL);
  if ((int const   )*(scan + 0) == 123) {
    scan ++;
  } else
  if ((int const   )*(scan + 0) == 40) {
    scan ++;
  }
  ptr = (char *)scan;
  while (1) {
    if (*scan) {
      if ((int const   )*scan != 125) {
        if ((int const   )*scan != 41) {
          if (! ((int const   )*scan != 47)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    scan ++;
    x ++;
  }
  if ((int const   )*(scan + 0) == 125) {
    scan ++;
  } else
  if ((int const   )*(scan + 0) == 41) {
    scan ++;
  }
  string = substring(ptr, 0, x);
  tmp___4 = hash_contains(hash, string);
  if ((unsigned int )tmp___4 == 0U) {
    tmp___3 = getenv((char const   *)string);
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
      ENV = 1;
    } else {
      string = (char *)((void *)0);
    }
  }
  memset((void *)(final), '\000', sizeof(final));
  strncpy((char * __restrict  )(final), (char const   * __restrict  )buf, (size_t )len);
  if ((unsigned long )string != (unsigned long )((void *)0)) {
    if (ENV == 0) {
      tmp___5 = hash_get(hash, string);
      tmp___7 = (char *)tmp___5;
    } else {
      tmp___6 = getenv((char const   *)string);
      tmp___7 = tmp___6;
    }
    strcat((char * __restrict  )(final), (char const   * __restrict  )tmp___7);
  }
  strcat((char * __restrict  )(final), (char const   * __restrict  )scan);
  memset((void *)result, '\000', 40000UL * sizeof(char ));
  tmp___8 = strlen((char const   *)(final));
  strncpy((char * __restrict  )result, (char const   * __restrict  )(final), tmp___8);
  xfree((void *)string);
  return (result);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-6q48eJeR.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
char *url_get_path(URL this ) ;
char *url_get_file(URL this ) ;
BOOLEAN okay(int code ) ;
int socket_write(CONN *C , void const   *buf , size_t len ) ;
ssize_t socket_read(CONN *C , void *vbuf , size_t len ) ;
BOOLEAN ftp_ascii(CONN *C ) ;
BOOLEAN ftp_binary(CONN *C ) ;
BOOLEAN ftp_cwd(CONN *C , URL U ) ;
BOOLEAN ftp_list(CONN *C , CONN *D , URL U ) ;
void write_file(URL U , char *buf , size_t len ) ;
static int __request___0(CONN *C , char *fmt  , ...) ;
static int __response(CONN *C ) ;
static int __response_code(char const   *buf ) ;
static BOOLEAN __in_range(int code , int lower , int upper ) ;
BOOLEAN ftp_login(CONN *C , URL U ) 
{ 
  int code ;
  char tmp[128] ;
  BOOLEAN tmp___0 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  BOOLEAN tmp___5 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  BOOLEAN tmp___10 ;

  {
  code = 120;
  code = __response(C);
  tmp___0 = okay(code);
  if (! tmp___0) {
    NOTIFY((LEVEL )2, "FTP: Server responded: %d", code);
    return ((BOOLEAN )0);
  }
  tmp___4 = url_get_username(U);
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
    tmp___3 = "anonymous";
  } else {
    tmp___2 = url_get_username(U);
    tmp___3 = (char const   *)tmp___2;
  }
  snprintf((char * __restrict  )(tmp), sizeof(tmp), (char const   * __restrict  )"%s",
           tmp___3);
  code = __request___0(C, (char *)"USER %s", tmp);
  if (code != 331) {
    tmp___5 = okay(code);
    if (tmp___5) {
      return ((BOOLEAN )1);
    }
  }
  memset((void *)(tmp), '\000', sizeof(tmp));
  tmp___9 = url_get_password(U);
  if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
    tmp___8 = "siege@joedog.org";
  } else {
    tmp___7 = url_get_password(U);
    tmp___8 = (char const   *)tmp___7;
  }
  snprintf((char * __restrict  )(tmp), sizeof(tmp), (char const   * __restrict  )"%s",
           tmp___8);
  code = __request___0(C, (char *)"PASS %s", tmp);
  tmp___10 = __in_range(code, 200, 299);
  return (tmp___10);
}
}
BOOLEAN ftp_pasv(CONN *C ) 
{ 
  int i ;
  int code ;
  char *ptr ;
  unsigned char addr[6] ;
  BOOLEAN tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  code = __request___0(C, (char *)"PASV");
  tmp = okay(code);
  if (! tmp) {
    return ((BOOLEAN )0);
  }
  ptr = C->chkbuf;
  ptr += 4;
  while (1) {
    if (*ptr) {
      tmp___0 = __ctype_b_loc();
      if ((int const   )*(*tmp___0 + (int )*ptr) & 2048) {
        break;
      }
    } else {
      break;
    }
    ptr ++;
  }
  if (! *ptr) {
    return ((BOOLEAN )0);
  }
  i = 0;
  while (i < 6) {
    addr[i] = (unsigned char)0;
    while (1) {
      tmp___1 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___1 + (int )*ptr) & 2048)) {
        break;
      }
      addr[i] = (unsigned char )(((int )*ptr - 48) + 10 * (int )addr[i]);
      ptr ++;
    }
    if ((int )*ptr == 44) {
      ptr ++;
    } else
    if (i < 5) {
      return ((BOOLEAN )0);
    }
    i ++;
  }
  snprintf((char * __restrict  )(C->ftp.host), sizeof(C->ftp.host), (char const   * __restrict  )"%d.%d.%d.%d",
           (int )addr[0], (int )addr[1], (int )addr[2], (int )addr[3]);
  C->ftp.port = ((int )addr[4] << 8) + (int )addr[5];
  return ((BOOLEAN )1);
}
}
BOOLEAN ftp_cwd(CONN *C , URL U ) 
{ 
  int code ;
  char *tmp ;
  BOOLEAN tmp___0 ;

  {
  tmp = url_get_path(U);
  code = __request___0(C, (char *)"CWD %s", tmp);
  tmp___0 = okay(code);
  return (tmp___0);
}
}
BOOLEAN ftp_ascii(CONN *C ) 
{ 
  BOOLEAN tmp ;

  {
  C->ftp.code = __request___0(C, (char *)"TYPE A");
  tmp = okay(C->ftp.code);
  return (tmp);
}
}
BOOLEAN ftp_binary(CONN *C ) 
{ 
  BOOLEAN tmp ;

  {
  C->ftp.code = __request___0(C, (char *)"TYPE I");
  tmp = okay(C->ftp.code);
  return (tmp);
}
}
BOOLEAN ftp_quit(CONN *C ) 
{ 
  BOOLEAN tmp ;

  {
  C->ftp.code = __request___0(C, (char *)"QUIT");
  tmp = okay(C->ftp.code);
  return (tmp);
}
}
BOOLEAN ftp_size(CONN *C , URL U ) 
{ 
  int size ;
  int resp ;
  BOOLEAN tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  BOOLEAN tmp___3 ;

  {
  tmp = ftp_binary(C);
  if ((unsigned int )tmp != 1U) {
    return ((BOOLEAN )0);
  }
  tmp___0 = url_get_file(U);
  tmp___1 = url_get_path(U);
  C->ftp.code = __request___0(C, (char *)"SIZE %s%s", tmp___1, tmp___0);
  tmp___3 = okay(C->ftp.code);
  if (tmp___3) {
    tmp___2 = sscanf((char const   * __restrict  )(C->chkbuf), (char const   * __restrict  )"%d %d",
                     & resp, & size);
    if (tmp___2 == 2) {
      C->ftp.size = (size_t )size;
      return ((BOOLEAN )1);
    } else {
      return ((BOOLEAN )0);
    }
  } else {
    return ((BOOLEAN )0);
  }
  return ((BOOLEAN )1);
}
}
BOOLEAN ftp_stor(CONN *C , URL U ) 
{ 
  size_t len ;
  char *file ;
  size_t id ;
  pthread_t tmp ;
  int num ;
  char **parts ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  BOOLEAN tmp___6 ;

  {
  tmp = pthread_self();
  id = tmp;
  num = 2;
  if ((double )id < 0.0) {
    id = - id;
  }
  tmp___0 = url_get_file(U);
  tmp___1 = strlen((char const   *)tmp___0);
  len = tmp___1 + 17UL;
  tmp___2 = url_get_file(U);
  parts = split((char )'.', tmp___2, & num);
  tmp___3 = xmalloc(len);
  file = (char *)tmp___3;
  memset((void *)file, '\000', len);
  if ((unsigned long )*(parts + 1) == (unsigned long )((void *)0)) {
    tmp___4 = "";
  } else {
    tmp___4 = (char const   *)*(parts + 1);
  }
  snprintf((char * __restrict  )file, len, (char const   * __restrict  )"%s-%zu.%s",
           *(parts + 0), id, tmp___4);
  if (my.unique) {
    C->ftp.code = __request___0(C, (char *)"STOR %s", file);
  } else {
    tmp___5 = url_get_file(U);
    C->ftp.code = __request___0(C, (char *)"STOR %s", tmp___5);
  }
  xfree((void *)file);
  split_free(parts, num);
  tmp___6 = okay(C->ftp.code);
  return (tmp___6);
}
}
BOOLEAN ftp_retr(CONN *C , URL U ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  BOOLEAN tmp___1 ;

  {
  tmp = url_get_file(U);
  tmp___0 = url_get_path(U);
  C->ftp.code = __request___0(C, (char *)"RETR %s%s", tmp___0, tmp);
  tmp___1 = okay(C->ftp.code);
  return (tmp___1);
}
}
size_t ftp_put(CONN *D , URL U ) 
{ 
  size_t n ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  tmp = url_get_postlen(U);
  tmp___0 = url_get_postdata(U);
  tmp___1 = socket_write(D, (void const   *)tmp___0, tmp);
  n = (size_t )tmp___1;
  tmp___2 = url_get_postlen(U);
  if (n != tmp___2) {
    NOTIFY((LEVEL )2, "HTTP: unable to write to socket.");
    return ((size_t )-1);
  }
  tmp___3 = url_get_postlen(U);
  return (tmp___3);
}
}
size_t ftp_get(CONN *D , URL U , size_t size ) 
{ 
  int n ;
  char c ;
  size_t bytes ;
  char *file ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
  bytes = (size_t )0;
  tmp = xmalloc(size);
  file = (char *)tmp;
  memset((void *)file, '\000', size);
  while (1) {
    tmp___0 = socket_read(D, (void *)(& c), (size_t )1);
    n = (int )tmp___0;
    if (n == 0) {
      break;
    }
    *(file + bytes) = c;
    bytes += (size_t )n;
    if (! (bytes < size)) {
      break;
    }
  }
  if (my.get) {
    write_file(U, file, size);
  }
  xfree((void *)file);
  return (bytes);
}
}
BOOLEAN ftp_list(CONN *C , CONN *D , URL U ) 
{ 
  int n ;
  char c ;
  int bytes ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;

  {
  tmp___3 = url_get_file(U);
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    tmp___0 = url_get_path(U);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = url_get_file(U);
    tmp___2 = tmp___1;
  }
  C->ftp.code = __request___0(C, (char *)"LIST %s", tmp___2);
  if (C->ftp.code == 150) {
    if (D->sock < 1) {
      NOTIFY((LEVEL )2, "unable to read from socket: %s:%d", C->ftp.host, C->ftp.port);
      return ((BOOLEAN )0);
    }
    while (1) {
      tmp___4 = socket_read(D, (void *)(& c), (size_t )1);
      n = (int )tmp___4;
      if (n == 0) {
        break;
      }
      if (my.verbose) {
        printf((char const   * __restrict  )"%c", (int )c);
      }
      bytes += n;
    }
  }
  return ((BOOLEAN )1);
}
}
static int __request___0(CONN *C , char *fmt  , ...) 
{ 
  int code ;
  char buf[1024] ;
  char cmd[1032] ;
  size_t len ;
  size_t n ;
  va_list___0 ap ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  code = 0;
  memset((void *)(buf), '\000', sizeof(buf));
  memset((void *)(cmd), '\000', sizeof(cmd));
  __builtin_va_start(ap, fmt);
  vsnprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )fmt,
            ap);
  tmp = snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s\r\n",
                 buf);
  len = (size_t )tmp;
  tmp___0 = socket_write(C, (void const   *)(cmd), len);
  n = (size_t )tmp___0;
  if (n != len) {
    NOTIFY((LEVEL )2, "FTP: unable to write to socket.");
    code = 500;
  }
  __builtin_va_end(ap);
  tmp___1 = chomp(cmd);
  debug((char const   *)tmp___1);
  if (code == 500) {
    C->ftp.code = 500;
    return (C->ftp.code);
  } else {
    C->ftp.code = __response(C);
    return (C->ftp.code);
  }
}
}
static int __response(CONN *C ) 
{ 
  int n ;
  char c ;
  int code ;
  BOOLEAN cont ;
  int x ;
  ssize_t tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;

  {
  code = 120;
  cont = (BOOLEAN )1;
  while (cont) {
    while (1) {
      x = 0;
      memset((void *)(C->chkbuf), '\000', sizeof(C->chkbuf));
      while (1) {
        tmp = socket_read(C, (void *)(& c), (size_t )1);
        n = (int )tmp;
        if (! (n == 1)) {
          break;
        }
        echo("%c", (int )c);
        C->chkbuf[x] = c;
        if ((int )C->chkbuf[x] == 10) {
          break;
        }
        x ++;
      }
      tmp___0 = __ctype_b_loc();
      if ((int const   )*(*tmp___0 + (int )C->chkbuf[0]) & 2048) {
        if ((int )C->chkbuf[3] != 45) {
          break;
        }
      }
    }
    code = __response_code((char const   *)(C->chkbuf));
    if ((int )C->chkbuf[3] == 32) {
      cont = (BOOLEAN )0;
    }
  }
  if (code > 499) {
    if (! my.quiet) {
      tmp___1 = chomp(C->chkbuf);
      printf((char const   * __restrict  )"%s\n", tmp___1);
    }
  }
  return (code);
}
}
static int __response_code(char const   *buf ) 
{ 
  int ret ;
  char code[4] ;

  {
  memset((void *)(code), '\000', sizeof(code));
  strncpy((char * __restrict  )(code), (char const   * __restrict  )buf, (size_t )3);
  code[3] = (char )'\000';
  ret = atoi((char const   *)(code));
  return (ret);
}
}
static BOOLEAN __in_range(int code , int lower , int upper ) 
{ 
  int tmp ;

  {
  if (code >= lower) {
    if (code <= upper) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((BOOLEAN )tmp);
}
}
#pragma merger("0","/tmp/cil-lgGtVkUD.i","-W,-Wall,-Wunused-value,-g,-O2")
#pragma merger("0","/tmp/cil-Wnox2j9X.i","-W,-Wall,-Wunused-value,-g,-O2")
#pragma merger("0","/tmp/cil-0M6Qt9Gn.i","-W,-Wall,-Wunused-value,-g,-O2")
extern int fflush(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
extern int ( __attribute__((__nonnull__(1,2))) sigwait)(sigset_t const   * __restrict  __set ,
                                                        int * __restrict  __sig ) ;
void spin_doctor(CREW crew ) ;
void sig_handler(CREW crew ) ;
void spin_doctor(CREW crew ) 
{ 
  long x ;
  char h[4] ;
  int tmp ;

  {
  h[0] = (char )'-';
  h[1] = (char )'\\';
  h[2] = (char )'|';
  h[3] = (char )'/';
  if ((unsigned int )my.spinner == 0U) {
    return;
  }
  x = 0L;
  while (1) {
    tmp = crew_get_total(crew);
    if (! (tmp > 1)) {
      if (! (x < 55L)) {
        break;
      }
    }
    fflush(stderr);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%c", (int )h[x % 4L]);
    pthread_usleep_np(20000UL);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\b");
    x ++;
  }
  return;
}
}
void sig_handler(CREW crew ) 
{ 
  int gotsig ;
  sigset_t sigs ;

  {
  gotsig = 0;
  sigemptyset(& sigs);
  sigaddset(& sigs, 1);
  sigaddset(& sigs, 2);
  sigaddset(& sigs, 15);
  sigprocmask(0, (sigset_t const   * __restrict  )(& sigs), (sigset_t * __restrict  )((void *)0));
  sigwait((sigset_t const   * __restrict  )(& sigs), (int * __restrict  )(& gotsig));
  my.verbose = (BOOLEAN )0;
  if (! my.quiet) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nLifting the server siege...");
  }
  crew_cancel(crew);
  pthread_usleep_np(501125UL);
  pthread_exit((void *)0);
}
}
#pragma merger("0","/tmp/cil-2dUQtPwv.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
void hash_remover(HASH this , char *key , void (*m)(void *v ) ) ;
HASH hash_destroyer(HASH this , void (*m)(void *v ) ) ;
void hash_free_keys(HASH this , char **keys___0 ) ;
size_t HASHSIZE  =    sizeof(struct HASH_T );
static BOOLEAN __lookup(HASH this , char *key ) ;
static void __resize(HASH this ) ;
static unsigned int __genkey(int size , char *str ) ;
static unsigned int fnv_32_buf(void *buf , size_t len , unsigned int hval ) ;
HASH new_hash(void) 
{ 
  HASH this ;
  int size ;
  void *tmp ;
  void *tmp___0 ;

  {
  size = 10240;
  tmp = calloc(HASHSIZE, (size_t )1);
  this = (HASH )tmp;
  this->size = size;
  this->entries = 0;
  this->index = 0;
  while (this->size < size) {
    this->size <<= 1;
  }
  tmp___0 = calloc((unsigned long )this->size * sizeof(NODE___0 *), (size_t )1);
  this->table = (NODE___0 **)tmp___0;
  this->free = (void (*)(void *v ))((void *)0);
  return (this);
}
}
int hash_size(HASH this ) 
{ 


  {
  return (this->entries);
}
}
void hash_reset(HASH this , ssize_t size ) 
{ 
  void *tmp ;

  {
  this->size = 2;
  this->entries = 0;
  while ((ssize_t )this->size < size) {
    this->size <<= 1;
  }
  tmp = calloc((unsigned long )this->size * sizeof(NODE___0 *), (size_t )1);
  this->table = (NODE___0 **)tmp;
  return;
}
}
void hash_add(HASH this , char *key , void *val ) 
{ 
  size_t len ;
  BOOLEAN tmp ;

  {
  len = (size_t )0;
  tmp = __lookup(this, key);
  if ((unsigned int )tmp == 1U) {
    return;
  }
  len = strlen((char const   *)val);
  hash_nadd(this, key, val, len);
  return;
}
}
void hash_nadd(HASH this , char *key , void *val , size_t len ) 
{ 
  int x ;
  NODE___0 *node ;
  BOOLEAN tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;

  {
  tmp = __lookup(this, key);
  if ((unsigned int )tmp == 1U) {
    return;
  }
  if (this->entries >= this->size / 4) {
    __resize(this);
  }
  tmp___0 = __genkey(this->size, key);
  x = (int )tmp___0;
  tmp___1 = xmalloc(sizeof(NODE___0 ));
  node = (NODE___0 *)tmp___1;
  node->key = strdup((char const   *)key);
  node->val = xmalloc(len + 1UL);
  memset(node->val, '\000', len + 1UL);
  memcpy((void * __restrict  )node->val, (void const   * __restrict  )val, len);
  node->next = *(this->table + x);
  *(this->table + x) = node;
  (this->entries) ++;
  return;
}
}
void *hash_get(HASH this , char *key ) 
{ 
  int x ;
  NODE___0 *node ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  tmp = __genkey(this->size, key);
  x = (int )tmp;
  node = *(this->table + x);
  while ((unsigned long )node != (unsigned long )((void *)0)) {
    tmp___0 = strcmp((char const   *)node->key, (char const   *)key);
    if (! tmp___0) {
      return (node->val);
    }
    node = node->next;
  }
  return ((void *)0);
}
}
void hash_remove(HASH this , char *key ) 
{ 
  int x ;
  NODE___0 *n1 ;
  NODE___0 *n2 ;
  BOOLEAN tmp ;
  unsigned int tmp___0 ;

  {
  x = 0;
  n1 = (NODE___0 *)((void *)0);
  n2 = (NODE___0 *)((void *)0);
  tmp = __lookup(this, key);
  if ((unsigned int )tmp == 0U) {
    return;
  }
  if ((unsigned long )this->free == (unsigned long )((void *)0)) {
    this->free = & free;
  }
  tmp___0 = __genkey(this->size, key);
  x = (int )tmp___0;
  n1 = *(this->table + x);
  while ((unsigned long )n1 != (unsigned long )((void *)0)) {
    n2 = n1->next;
    if ((unsigned long )n1->key != (unsigned long )((void *)0)) {
      xfree((void *)n1->key);
      (this->entries) --;
    }
    if ((unsigned long )n1->val != (unsigned long )((void *)0)) {
      (*(this->free))(n1->val);
    }
    xfree((void *)n1);
    n1 = n2;
  }
  *(this->table + x) = (NODE___0 *)((void *)0);
  return;
}
}
void hash_remover(HASH this , char *key , void (*m)(void *v ) ) 
{ 


  {
  this->free = m;
  hash_remove(this, key);
  return;
}
}
void hash_set_destroyer(HASH this , void (*m)(void *v ) ) 
{ 


  {
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    return;
  }
  this->free = m;
  return;
}
}
BOOLEAN hash_contains(HASH this , char *key ) 
{ 
  BOOLEAN tmp ;

  {
  tmp = __lookup(this, key);
  return (tmp);
}
}
char **hash_get_keys(HASH this ) 
{ 
  int x ;
  int i ;
  NODE___0 *node ;
  char **keys___0 ;
  void *tmp ;
  size_t len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  i = 0;
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  } else
  if (this->entries == 0) {
    return ((char **)((void *)0));
  }
  tmp = malloc(sizeof(char *) * (unsigned long )this->entries);
  keys___0 = (char **)tmp;
  x = 0;
  while (x < this->size) {
    node = *(this->table + x);
    while ((unsigned long )node != (unsigned long )((void *)0)) {
      tmp___0 = strlen((char const   *)node->key);
      len = tmp___0 + 1UL;
      tmp___1 = malloc(len);
      *(keys___0 + i) = (char *)tmp___1;
      memset((void *)*(keys___0 + i), '\000', len);
      tmp___2 = strlen((char const   *)node->key);
      memcpy((void * __restrict  )*(keys___0 + i), (void const   * __restrict  )node->key,
             tmp___2);
      i ++;
      node = node->next;
    }
    x ++;
  }
  return (keys___0);
}
}
void hash_free_keys(HASH this , char **keys___0 ) 
{ 
  int x ;
  char *tmp ;

  {
  x = 0;
  while (x < this->entries) {
    if ((unsigned long )*(keys___0 + x) != (unsigned long )((void *)0)) {
      tmp = *(keys___0 + x);
      xfree((void *)tmp);
    }
    x ++;
  }
  xfree((void *)keys___0);
  return;
}
}
HASH hash_destroy(HASH this ) 
{ 
  int x ;
  NODE___0 *t1 ;
  NODE___0 *t2 ;

  {
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    return (this);
  }
  if ((unsigned long )this->free == (unsigned long )((void *)0)) {
    this->free = & free;
  }
  x = 0;
  while (x < this->size) {
    t1 = *(this->table + x);
    while ((unsigned long )t1 != (unsigned long )((void *)0)) {
      t2 = t1->next;
      if ((unsigned long )t1->key != (unsigned long )((void *)0)) {
        xfree((void *)t1->key);
      }
      if ((unsigned long )t1->val != (unsigned long )((void *)0)) {
        (*(this->free))(t1->val);
      }
      xfree((void *)t1);
      t1 = t2;
    }
    *(this->table + x) = (NODE___0 *)((void *)0);
    x ++;
  }
  if ((unsigned long )this->table != (unsigned long )((void *)0)) {
    xfree((void *)this->table);
    memset((void *)this, '\000', sizeof(struct HASH_T ));
  }
  xfree((void *)this);
  return ((HASH )((void *)0));
}
}
HASH hash_destroyer(HASH this , void (*m)(void *v ) ) 
{ 
  HASH tmp ;

  {
  this->free = m;
  tmp = hash_destroy(this);
  return (tmp);
}
}
int hash_get_entries(HASH this ) 
{ 


  {
  return (this->entries);
}
}
static void __resize(HASH this ) 
{ 
  NODE___0 *tmp ;
  NODE___0 *last_node ;
  NODE___0 **last_table ;
  int x ;
  int hash ;
  int size ;
  unsigned int tmp___0 ;

  {
  size = this->size;
  last_table = this->table;
  hash_reset(this, (ssize_t )(size * 2));
  x = 0;
  while (x < size) {
    last_node = *(last_table + x);
    while ((unsigned long )last_node != (unsigned long )((void *)0)) {
      tmp = last_node;
      last_node = last_node->next;
      tmp___0 = __genkey(this->size, tmp->key);
      hash = (int )tmp___0;
      tmp->next = *(this->table + hash);
      *(this->table + hash) = tmp;
      (this->entries) ++;
    }
    x ++;
  }
  return;
}
}
static unsigned int fnv_32_buf(void *buf , size_t len , unsigned int hval ) 
{ 
  unsigned char *bp ;
  unsigned char *be ;
  unsigned char *tmp ;

  {
  bp = (unsigned char *)buf;
  be = bp + len;
  while ((unsigned long )bp < (unsigned long )be) {
    tmp = bp;
    bp ++;
    hval ^= (u_int32_t )*tmp;
    hval += ((((hval << 1) + (hval << 4)) + (hval << 7)) + (hval << 8)) + (hval << 24);
  }
  return (hval);
}
}
static unsigned int __genkey(int size , char *str ) 
{ 
  unsigned int hash ;
  void *data ;
  size_t tmp ;

  {
  data = (void *)str;
  tmp = strlen((char const   *)str);
  hash = fnv_32_buf(data, tmp, 2166136261U);
  hash %= (unsigned int )size;
  return (hash);
}
}
static BOOLEAN __lookup(HASH this , char *key ) 
{ 
  int x ;
  NODE___0 *node ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    return ((BOOLEAN )0);
  }
  tmp = __genkey(this->size, key);
  x = (int )tmp;
  node = *(this->table + x);
  while ((unsigned long )node != (unsigned long )((void *)0)) {
    tmp___0 = strcmp((char const   *)node->key, (char const   *)key);
    if (! tmp___0) {
      return ((BOOLEAN )1);
    }
    node = node->next;
  }
  return ((BOOLEAN )0);
}
}
#pragma merger("0","/tmp/cil-SjyrDOuF.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
void page_concat(PAGE this , char const   *str , int const   len ) ;
ssize_t socket_readline(CONN *C , char *ptr , size_t maxlen ) ;
BOOLEAN response_set_content_type(RESPONSE this , char *line ) ;
BOOLEAN response_set_content_length(RESPONSE this , char *line ) ;
BOOLEAN response_set_connection(RESPONSE this , char *line ) ;
BOOLEAN response_set_keepalive(RESPONSE this , char *line ) ;
int response_get_keepalive_timeout(RESPONSE this ) ;
int response_get_keepalive_max(RESPONSE this ) ;
BOOLEAN response_set_location(RESPONSE this , char *line ) ;
BOOLEAN response_set_last_modified(RESPONSE this , char *line ) ;
BOOLEAN response_set_content_encoding(RESPONSE this , char *line ) ;
HTTP_CE response_get_content_encoding(RESPONSE this ) ;
BOOLEAN response_set_transfer_encoding(RESPONSE this , char *line ) ;
HTTP_TE response_get_transfer_encoding(RESPONSE this ) ;
BOOLEAN response_set_www_authenticate(RESPONSE this , char *line ) ;
BOOLEAN response_set_proxy_authenticate(RESPONSE this , char *line ) ;
extern int inflate(z_streamp strm , int flush ) ;
extern int inflateEnd(z_streamp strm ) ;
extern int inflateInit2_(z_streamp strm , int windowBits , char const   *version ,
                         int stream_size ) ;
char const   *strncasestr(char const   *str1 , char const   *str2 , size_t len ) ;
pthread_mutex_t __mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
pthread_cond_t __cond  =    {{{0ULL},
     {0ULL}, {0U, 0U}, {0U, 0U}, 0U, 0U, {0U, 0U}}};
static int __gzip_inflate(int window , char const   *src , int srcLen , char const   *dst ,
                          int dstLen ) ;
BOOLEAN https_tunnel_request(CONN *C , char *host , int port ) 
{ 
  size_t rlen ;
  size_t n ;
  char request[256] ;
  int tmp ;
  BOOLEAN tmp___0 ;

  {
  if ((unsigned int )C->encrypt == 1U) {
    tmp___0 = auth_get_proxy_required(my.auth);
    if (tmp___0) {
      snprintf((char * __restrict  )(request), sizeof(request), (char const   * __restrict  )"CONNECT %s:%d HTTP/1.0\r\nUser-agent: Proxy-User\r\n\r\n",
               host, port);
      rlen = strlen((char const   *)(request));
      echo("%s", request);
      C->encrypt = (BOOLEAN )0;
      tmp = socket_write(C, (void const   *)(request), rlen);
      n = (size_t )tmp;
      if (n != rlen) {
        NOTIFY((LEVEL )2, "HTTP: unable to write to socket.");
        return ((BOOLEAN )0);
      }
    } else {
      return ((BOOLEAN )0);
    }
  } else {
    return ((BOOLEAN )0);
  }
  return ((BOOLEAN )1);
}
}
int https_tunnel_response(CONN *C ) 
{ 
  int x ;
  int n ;
  char c ;
  char line[256] ;
  int code ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  code = 100;
  while (1) {
    x = 0;
    memset((void *)(& line), '\000', sizeof(line));
    while (1) {
      tmp = read(C->sock, (void *)(& c), (size_t )1);
      n = (int )tmp;
      if (! (n == 1)) {
        break;
      }
      line[x] = c;
      echo("%c", (int )c);
      if ((int )line[0] == 10) {
        return (code);
      } else
      if ((int )line[1] == 10) {
        return (code);
      }
      if ((int )line[x] == 10) {
        break;
      }
      x ++;
    }
    line[x] = (char)0;
    tmp___0 = strncasecmp((char const   *)(line), "http", (size_t )4);
    if (tmp___0 == 0) {
      code = atoi((char const   *)(line + 9));
    }
  }
}
}
BOOLEAN http_get(CONN *C , URL U ) 
{ 
  size_t rlen ;
  size_t mlen ;
  char protocol[16] ;
  char keepalive[16] ;
  char hoststr[512] ;
  char authwww[512] ;
  char authpxy[512] ;
  char accept___0[14] ;
  char encoding[512] ;
  char *request ;
  char portstr[16] ;
  char fullpath[8192] ;
  char cookie[4104] ;
  char *ifnon ;
  char *ifmod ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  BOOLEAN tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  SCHEME tmp___21 ;
  int tmp___22 ;
  SCHEME tmp___23 ;
  int tmp___24 ;
  char const   *tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  char const   *tmp___31 ;
  size_t tmp___32 ;
  char const   *tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  char const   *tmp___36 ;
  size_t tmp___37 ;
  char const   *tmp___38 ;
  size_t tmp___39 ;
  char const   *tmp___41 ;
  int tmp___42 ;
  size_t tmp___43 ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  size_t tmp___46 ;
  void *tmp___47 ;
  char const   *tmp___49 ;
  int tmp___50 ;
  char const   *tmp___51 ;
  char const   *tmp___52 ;
  char const   *tmp___54 ;
  size_t tmp___55 ;
  char const   *tmp___56 ;
  char const   *tmp___57 ;
  char *tmp___58 ;
  int tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;

  {
  accept___0[0] = (char )'A';
  accept___0[1] = (char )'c';
  accept___0[2] = (char )'c';
  accept___0[3] = (char )'e';
  accept___0[4] = (char )'p';
  accept___0[5] = (char )'t';
  accept___0[6] = (char )':';
  accept___0[7] = (char )' ';
  accept___0[8] = (char )'*';
  accept___0[9] = (char )'/';
  accept___0[10] = (char )'*';
  accept___0[11] = (char )'\r';
  accept___0[12] = (char )'\n';
  accept___0[13] = (char )'\000';
  ifnon = (char *)((void *)0);
  ifmod = (char *)((void *)0);
  memset((void *)(hoststr), '\000', sizeof(hoststr));
  memset((void *)(cookie), '\000', sizeof(cookie));
  memset((void *)(portstr), '\000', sizeof(portstr));
  ifnon = cache_get_header(C->cache, (CTYPE )0, U);
  ifmod = cache_get_header(C->cache, (CTYPE )1, U);
  tmp___4 = auth_get_proxy_required(my.auth);
  if (tmp___4) {
    tmp = url_get_request(U);
    tmp___0 = url_get_port(U);
    tmp___1 = url_get_hostname(U);
    if ((unsigned int )C->encrypt == 0U) {
      tmp___2 = "http";
    } else {
      tmp___2 = "https";
    }
    sprintf((char * __restrict  )(fullpath), (char const   * __restrict  )"%s://%s:%d%s",
            tmp___2, tmp___1, tmp___0, tmp);
  } else {
    tmp___3 = url_get_request(U);
    sprintf((char * __restrict  )(fullpath), (char const   * __restrict  )"%s", tmp___3);
  }
  tmp___6 = url_get_port(U);
  if (tmp___6 == 80) {
    if ((unsigned int )C->encrypt == 0U) {
      portstr[0] = (char )'\000';
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___7 = url_get_port(U);
    if (tmp___7 == 443) {
      if ((unsigned int )C->encrypt == 0U) {
        portstr[0] = (char )'\000';
      } else {
        tmp___5 = url_get_port(U);
        snprintf((char * __restrict  )(portstr), sizeof(portstr), (char const   * __restrict  )":%d",
                 tmp___5);
      }
    } else {
      tmp___5 = url_get_port(U);
      snprintf((char * __restrict  )(portstr), sizeof(portstr), (char const   * __restrict  )":%d",
               tmp___5);
    }
  }
  if (my.protocol == 0) {
    snprintf((char * __restrict  )(protocol), sizeof(protocol), (char const   * __restrict  )"HTTP/1.0");
  } else
  if ((unsigned int )my.get == 1U) {
    snprintf((char * __restrict  )(protocol), sizeof(protocol), (char const   * __restrict  )"HTTP/1.0");
  } else
  if ((unsigned int )my.print == 1U) {
    snprintf((char * __restrict  )(protocol), sizeof(protocol), (char const   * __restrict  )"HTTP/1.0");
  } else {
    snprintf((char * __restrict  )(protocol), sizeof(protocol), (char const   * __restrict  )"HTTP/1.1");
  }
  if (C->connection.keepalive == 1) {
    snprintf((char * __restrict  )(keepalive), sizeof(keepalive), (char const   * __restrict  )"keep-alive");
  } else {
    snprintf((char * __restrict  )(keepalive), sizeof(keepalive), (char const   * __restrict  )"close");
  }
  tmp___8 = url_get_hostname(U);
  cookies_header(my.cookies, tmp___8, cookie);
  if (C->auth.www) {
    if ((unsigned int )C->auth.type.www == 1U) {
      tmp___9 = url_get_method_name(U);
      tmp___10 = auth_get_digest_header(my.auth, (SCHEME )1, C->auth.wchlg, C->auth.wcred,
                                        (char const   *)tmp___9, (char const   *)(fullpath));
      snprintf((char * __restrict  )(authwww), sizeof(authwww), (char const   * __restrict  )"%s",
               tmp___10);
    } else
    if ((unsigned int )C->auth.type.www == 2U) {
      tmp___11 = auth_get_ntlm_header(my.auth, (SCHEME )1);
      snprintf((char * __restrict  )(authwww), sizeof(authwww), (char const   * __restrict  )"%s",
               tmp___11);
    } else {
      tmp___12 = auth_get_basic_header(my.auth, (SCHEME )1);
      snprintf((char * __restrict  )(authwww), sizeof(authwww), (char const   * __restrict  )"%s",
               tmp___12);
    }
  }
  if (C->auth.proxy) {
    if ((unsigned int )C->auth.type.proxy == 1U) {
      tmp___13 = url_get_method_name(U);
      tmp___14 = auth_get_digest_header(my.auth, (SCHEME )4, C->auth.pchlg, C->auth.pcred,
                                        (char const   *)tmp___13, (char const   *)(fullpath));
      snprintf((char * __restrict  )(authpxy), sizeof(authpxy), (char const   * __restrict  )"%s",
               tmp___14);
    } else {
      tmp___15 = auth_get_basic_header(my.auth, (SCHEME )4);
      snprintf((char * __restrict  )(authpxy), sizeof(authpxy), (char const   * __restrict  )"%s",
               tmp___15);
    }
  }
  tmp___25 = strncasestr((char const   *)(my.extra), "host:", sizeof(my.extra));
  if ((unsigned long )tmp___25 == (unsigned long )((void *)0)) {
    tmp___21 = url_get_scheme(U);
    if ((unsigned int )tmp___21 == 1U) {
      tmp___22 = url_get_port(U);
      if (tmp___22 != 80) {
        tmp___16 = url_get_port(U);
        tmp___17 = url_get_hostname(U);
        tmp___18 = snprintf((char * __restrict  )(hoststr), sizeof(hoststr), (char const   * __restrict  )"Host: %s:%d\r\n",
                            tmp___17, tmp___16);
        rlen = (size_t )tmp___18;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      tmp___23 = url_get_scheme(U);
      if ((unsigned int )tmp___23 == 2U) {
        tmp___24 = url_get_port(U);
        if (tmp___24 != 443) {
          tmp___16 = url_get_port(U);
          tmp___17 = url_get_hostname(U);
          tmp___18 = snprintf((char * __restrict  )(hoststr), sizeof(hoststr), (char const   * __restrict  )"Host: %s:%d\r\n",
                              tmp___17, tmp___16);
          rlen = (size_t )tmp___18;
        } else {
          tmp___19 = url_get_hostname(U);
          tmp___20 = snprintf((char * __restrict  )(hoststr), sizeof(hoststr), (char const   * __restrict  )"Host: %s\r\n",
                              tmp___19);
          rlen = (size_t )tmp___20;
        }
      } else {
        tmp___19 = url_get_hostname(U);
        tmp___20 = snprintf((char * __restrict  )(hoststr), sizeof(hoststr), (char const   * __restrict  )"Host: %s\r\n",
                            tmp___19);
        rlen = (size_t )tmp___20;
      }
    }
  }
  tmp___26 = url_get_method_name(U);
  tmp___27 = strlen((char const   *)tmp___26);
  tmp___28 = strlen((char const   *)(fullpath));
  tmp___29 = strlen((char const   *)(protocol));
  tmp___30 = strlen((char const   *)(hoststr));
  if (C->auth.www == 1) {
    tmp___31 = (char const   *)(authwww);
  } else {
    tmp___31 = "";
  }
  tmp___32 = strlen(tmp___31);
  if (C->auth.proxy == 1) {
    tmp___33 = (char const   *)(authpxy);
  } else {
    tmp___33 = "";
  }
  tmp___34 = strlen(tmp___33);
  tmp___35 = strlen((char const   *)(cookie));
  if ((unsigned long )ifmod != (unsigned long )((void *)0)) {
    tmp___36 = (char const   *)ifmod;
  } else {
    tmp___36 = "";
  }
  tmp___37 = strlen(tmp___36);
  if ((unsigned long )ifnon != (unsigned long )((void *)0)) {
    tmp___38 = (char const   *)ifnon;
  } else {
    tmp___38 = "";
  }
  tmp___39 = strlen(tmp___38);
  tmp___42 = strncasecmp((char const   *)(my.extra), "Accept:", (size_t )7);
  if (tmp___42 == 0) {
    tmp___41 = "";
  } else {
    tmp___41 = (char const   *)(accept___0);
  }
  tmp___43 = strlen(tmp___41);
  tmp___44 = strlen((char const   *)(my.uagent));
  tmp___45 = strlen((char const   *)(my.extra));
  tmp___46 = strlen((char const   *)(keepalive));
  mlen = (((((((((((((tmp___27 + tmp___28) + tmp___29) + tmp___30) + tmp___32) + tmp___34) + tmp___35) + tmp___37) + tmp___39) + tmp___43) + sizeof(encoding)) + tmp___44) + tmp___45) + tmp___46) + 128UL;
  tmp___47 = xmalloc(mlen);
  request = (char *)tmp___47;
  memset((void *)request, '\000', mlen);
  memset((void *)(encoding), '\000', sizeof(encoding));
  if (! my.get) {
    snprintf((char * __restrict  )(encoding), sizeof(encoding), (char const   * __restrict  )"Accept-Encoding: %s\r\n",
             my.encoding);
  } else
  if (! my.print) {
    snprintf((char * __restrict  )(encoding), sizeof(encoding), (char const   * __restrict  )"Accept-Encoding: %s\r\n",
             my.encoding);
  }
  tmp___50 = strncasecmp((char const   *)(my.extra), "Accept:", (size_t )7);
  if (tmp___50 == 0) {
    tmp___49 = "";
  } else {
    tmp___49 = (char const   *)(accept___0);
  }
  if ((unsigned long )ifnon != (unsigned long )((void *)0)) {
    tmp___51 = (char const   *)ifnon;
  } else {
    tmp___51 = "";
  }
  if ((unsigned long )ifmod != (unsigned long )((void *)0)) {
    tmp___52 = (char const   *)ifmod;
  } else {
    tmp___52 = "";
  }
  tmp___55 = strlen((char const   *)(cookie));
  if (tmp___55 > 8UL) {
    tmp___54 = (char const   *)(cookie);
  } else {
    tmp___54 = "";
  }
  if (C->auth.proxy == 1) {
    tmp___56 = (char const   *)(authpxy);
  } else {
    tmp___56 = "";
  }
  if (C->auth.www == 1) {
    tmp___57 = (char const   *)(authwww);
  } else {
    tmp___57 = "";
  }
  tmp___58 = url_get_method_name(U);
  tmp___59 = snprintf((char * __restrict  )request, mlen, (char const   * __restrict  )"%s %s %s\r\n%s%s%s%s%s%s%s%sUser-Agent: %s\r\n%sConnection: %s\r\n\r\n",
                      tmp___58, fullpath, protocol, hoststr, tmp___57, tmp___56, tmp___54,
                      tmp___52, tmp___51, tmp___49, encoding, my.uagent, my.extra,
                      keepalive);
  rlen = (size_t )tmp___59;
  if (my.debug) {
    goto _L___1;
  } else
  if (my.get) {
    goto _L___1;
  } else
  if (my.print) {
    _L___1: /* CIL Label */ 
    if (! my.quiet) {
      printf((char const   * __restrict  )"%s\n", request);
      fflush(stdout);
    }
  }
  if (rlen == 0UL) {
    tmp___60 = url_get_method_name(U);
    NOTIFY((LEVEL )3, "HTTP %s: request buffer overrun!", tmp___60);
  } else
  if (rlen > mlen) {
    tmp___60 = url_get_method_name(U);
    NOTIFY((LEVEL )3, "HTTP %s: request buffer overrun!", tmp___60);
  }
  tmp___61 = socket_write(C, (void const   *)request, rlen);
  if (tmp___61 < 0) {
    xfree((void *)ifmod);
    xfree((void *)ifnon);
    return ((BOOLEAN )0);
  }
  xfree((void *)ifmod);
  xfree((void *)ifnon);
  xfree((void *)request);
  return ((BOOLEAN )1);
}
}
BOOLEAN http_post(CONN *C , URL U ) 
{ 
  size_t rlen ;
  size_t mlen ;
  char hoststr[128] ;
  char authwww[128] ;
  char authpxy[128] ;
  char accept___0[14] ;
  char encoding[512] ;
  char *request ;
  char portstr[16] ;
  char protocol[16] ;
  char keepalive[16] ;
  char cookie[4096] ;
  char fullpath[8192] ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  BOOLEAN tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  SCHEME tmp___21 ;
  int tmp___22 ;
  SCHEME tmp___23 ;
  int tmp___24 ;
  char const   *tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  char const   *tmp___31 ;
  size_t tmp___32 ;
  char const   *tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  char const   *tmp___37 ;
  int tmp___38 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  char *tmp___41 ;
  size_t tmp___42 ;
  size_t tmp___43 ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  void *tmp___46 ;
  size_t tmp___47 ;
  char *tmp___48 ;
  char const   *tmp___50 ;
  int tmp___51 ;
  char const   *tmp___53 ;
  size_t tmp___54 ;
  char const   *tmp___55 ;
  char const   *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;
  size_t tmp___59 ;
  char *tmp___60 ;
  size_t tmp___61 ;
  size_t tmp___62 ;
  char *tmp___63 ;
  int tmp___64 ;

  {
  accept___0[0] = (char )'A';
  accept___0[1] = (char )'c';
  accept___0[2] = (char )'c';
  accept___0[3] = (char )'e';
  accept___0[4] = (char )'p';
  accept___0[5] = (char )'t';
  accept___0[6] = (char )':';
  accept___0[7] = (char )' ';
  accept___0[8] = (char )'*';
  accept___0[9] = (char )'/';
  accept___0[10] = (char )'*';
  accept___0[11] = (char )'\r';
  accept___0[12] = (char )'\n';
  accept___0[13] = (char )'\000';
  memset((void *)(hoststr), '\000', sizeof(hoststr));
  memset((void *)(cookie), '\000', (size_t )4096);
  memset((void *)(portstr), '\000', sizeof(portstr));
  memset((void *)(protocol), '\000', sizeof(protocol));
  memset((void *)(keepalive), '\000', sizeof(keepalive));
  tmp___4 = auth_get_proxy_required(my.auth);
  if (tmp___4) {
    tmp = url_get_request(U);
    tmp___0 = url_get_port(U);
    tmp___1 = url_get_hostname(U);
    if ((unsigned int )C->encrypt == 0U) {
      tmp___2 = "http";
    } else {
      tmp___2 = "https";
    }
    sprintf((char * __restrict  )(fullpath), (char const   * __restrict  )"%s://%s:%d%s",
            tmp___2, tmp___1, tmp___0, tmp);
  } else {
    tmp___3 = url_get_request(U);
    sprintf((char * __restrict  )(fullpath), (char const   * __restrict  )"%s", tmp___3);
  }
  tmp___6 = url_get_port(U);
  if (tmp___6 == 80) {
    if ((unsigned int )C->encrypt == 0U) {
      portstr[0] = (char )'\000';
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___7 = url_get_port(U);
    if (tmp___7 == 443) {
      if ((unsigned int )C->encrypt == 1U) {
        portstr[0] = (char )'\000';
      } else {
        tmp___5 = url_get_port(U);
        snprintf((char * __restrict  )(portstr), sizeof(portstr), (char const   * __restrict  )":%d",
                 tmp___5);
      }
    } else {
      tmp___5 = url_get_port(U);
      snprintf((char * __restrict  )(portstr), sizeof(portstr), (char const   * __restrict  )":%d",
               tmp___5);
    }
  }
  if (my.protocol == 0) {
    snprintf((char * __restrict  )(protocol), sizeof(protocol), (char const   * __restrict  )"HTTP/1.0");
  } else
  if ((unsigned int )my.get == 1U) {
    snprintf((char * __restrict  )(protocol), sizeof(protocol), (char const   * __restrict  )"HTTP/1.0");
  } else
  if ((unsigned int )my.print == 1U) {
    snprintf((char * __restrict  )(protocol), sizeof(protocol), (char const   * __restrict  )"HTTP/1.0");
  } else {
    snprintf((char * __restrict  )(protocol), sizeof(protocol), (char const   * __restrict  )"HTTP/1.1");
  }
  if (C->connection.keepalive == 1) {
    snprintf((char * __restrict  )(keepalive), sizeof(keepalive), (char const   * __restrict  )"keep-alive");
  } else {
    snprintf((char * __restrict  )(keepalive), sizeof(keepalive), (char const   * __restrict  )"close");
  }
  tmp___8 = url_get_hostname(U);
  cookies_header(my.cookies, tmp___8, cookie);
  if (C->auth.www) {
    if ((unsigned int )C->auth.type.www == 1U) {
      tmp___9 = url_get_method_name(U);
      tmp___10 = auth_get_digest_header(my.auth, (SCHEME )1, C->auth.wchlg, C->auth.wcred,
                                        (char const   *)tmp___9, (char const   *)(fullpath));
      snprintf((char * __restrict  )(authwww), sizeof(authwww), (char const   * __restrict  )"%s",
               tmp___10);
    } else
    if ((unsigned int )C->auth.type.www == 2U) {
      tmp___11 = auth_get_ntlm_header(my.auth, (SCHEME )1);
      snprintf((char * __restrict  )(authwww), sizeof(authwww), (char const   * __restrict  )"%s",
               tmp___11);
    } else {
      tmp___12 = auth_get_basic_header(my.auth, (SCHEME )1);
      snprintf((char * __restrict  )(authwww), sizeof(authwww), (char const   * __restrict  )"%s",
               tmp___12);
    }
  }
  if (C->auth.proxy) {
    if ((unsigned int )C->auth.type.proxy == 1U) {
      tmp___13 = url_get_method_name(U);
      tmp___14 = auth_get_digest_header(my.auth, (SCHEME )1, C->auth.pchlg, C->auth.pcred,
                                        (char const   *)tmp___13, (char const   *)(fullpath));
      snprintf((char * __restrict  )(authpxy), sizeof(authpxy), (char const   * __restrict  )"%s",
               tmp___14);
    } else {
      tmp___15 = auth_get_basic_header(my.auth, (SCHEME )4);
      snprintf((char * __restrict  )(authpxy), sizeof(authpxy), (char const   * __restrict  )"%s",
               tmp___15);
    }
  }
  tmp___25 = strncasestr((char const   *)(my.extra), "host:", sizeof(my.extra));
  if ((unsigned long )tmp___25 == (unsigned long )((void *)0)) {
    tmp___21 = url_get_scheme(U);
    if ((unsigned int )tmp___21 == 1U) {
      tmp___22 = url_get_port(U);
      if (tmp___22 != 80) {
        tmp___16 = url_get_port(U);
        tmp___17 = url_get_hostname(U);
        tmp___18 = snprintf((char * __restrict  )(hoststr), sizeof(hoststr), (char const   * __restrict  )"Host: %s:%d\r\n",
                            tmp___17, tmp___16);
        rlen = (size_t )tmp___18;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      tmp___23 = url_get_scheme(U);
      if ((unsigned int )tmp___23 == 2U) {
        tmp___24 = url_get_port(U);
        if (tmp___24 != 443) {
          tmp___16 = url_get_port(U);
          tmp___17 = url_get_hostname(U);
          tmp___18 = snprintf((char * __restrict  )(hoststr), sizeof(hoststr), (char const   * __restrict  )"Host: %s:%d\r\n",
                              tmp___17, tmp___16);
          rlen = (size_t )tmp___18;
        } else {
          tmp___19 = url_get_hostname(U);
          tmp___20 = snprintf((char * __restrict  )(hoststr), sizeof(hoststr), (char const   * __restrict  )"Host: %s\r\n",
                              tmp___19);
          rlen = (size_t )tmp___20;
        }
      } else {
        tmp___19 = url_get_hostname(U);
        tmp___20 = snprintf((char * __restrict  )(hoststr), sizeof(hoststr), (char const   * __restrict  )"Host: %s\r\n",
                            tmp___19);
        rlen = (size_t )tmp___20;
      }
    }
  }
  tmp___26 = url_get_method_name(U);
  tmp___27 = strlen((char const   *)tmp___26);
  tmp___28 = strlen((char const   *)(fullpath));
  tmp___29 = strlen((char const   *)(protocol));
  tmp___30 = strlen((char const   *)(hoststr));
  if (C->auth.www == 1) {
    tmp___31 = (char const   *)(authwww);
  } else {
    tmp___31 = "";
  }
  tmp___32 = strlen(tmp___31);
  if (C->auth.proxy == 1) {
    tmp___33 = (char const   *)(authpxy);
  } else {
    tmp___33 = "";
  }
  tmp___34 = strlen(tmp___33);
  tmp___35 = strlen((char const   *)(cookie));
  tmp___38 = strncasecmp((char const   *)(my.extra), "Accept:", (size_t )7);
  if (tmp___38 == 0) {
    tmp___37 = "";
  } else {
    tmp___37 = (char const   *)(accept___0);
  }
  tmp___39 = strlen(tmp___37);
  tmp___40 = strlen((char const   *)(my.uagent));
  tmp___41 = url_get_conttype(U);
  tmp___42 = strlen((char const   *)tmp___41);
  tmp___43 = strlen((char const   *)(my.extra));
  tmp___44 = strlen((char const   *)(keepalive));
  tmp___45 = url_get_postlen(U);
  mlen = (((((((((((((tmp___27 + tmp___28) + tmp___29) + tmp___30) + tmp___32) + tmp___34) + tmp___35) + tmp___39) + sizeof(encoding)) + tmp___40) + tmp___42) + tmp___43) + tmp___44) + tmp___45) + 128UL;
  tmp___46 = xmalloc(mlen);
  request = (char *)tmp___46;
  memset((void *)request, '\000', mlen);
  memset((void *)(encoding), '\000', sizeof(encoding));
  if (! my.get) {
    snprintf((char * __restrict  )(encoding), sizeof(encoding), (char const   * __restrict  )"Accept-Encoding: %s\r\n",
             my.encoding);
  } else
  if (! my.print) {
    snprintf((char * __restrict  )(encoding), sizeof(encoding), (char const   * __restrict  )"Accept-Encoding: %s\r\n",
             my.encoding);
  }
  tmp___47 = url_get_postlen(U);
  tmp___48 = url_get_conttype(U);
  tmp___51 = strncasecmp((char const   *)(my.extra), "Accept:", (size_t )7);
  if (tmp___51 == 0) {
    tmp___50 = "";
  } else {
    tmp___50 = (char const   *)(accept___0);
  }
  tmp___54 = strlen((char const   *)(cookie));
  if (tmp___54 > 8UL) {
    tmp___53 = (char const   *)(cookie);
  } else {
    tmp___53 = "";
  }
  if (C->auth.proxy == 1) {
    tmp___55 = (char const   *)(authpxy);
  } else {
    tmp___55 = "";
  }
  if (C->auth.www == 1) {
    tmp___56 = (char const   *)(authwww);
  } else {
    tmp___56 = "";
  }
  tmp___57 = url_get_method_name(U);
  tmp___58 = snprintf((char * __restrict  )request, mlen, (char const   * __restrict  )"%s %s %s\r\n%s%s%s%s%s%sUser-Agent: %s\r\n%sConnection: %s\r\nContent-Type: %s\r\nContent-Length: %ld\r\n\r\n",
                      tmp___57, fullpath, protocol, hoststr, tmp___56, tmp___55, tmp___53,
                      tmp___50, encoding, my.uagent, my.extra, keepalive, tmp___48,
                      (long )tmp___47);
  rlen = (size_t )tmp___58;
  if (rlen < mlen) {
    tmp___59 = url_get_postlen(U);
    tmp___60 = url_get_postdata(U);
    memcpy((void * __restrict  )(request + rlen), (void const   * __restrict  )tmp___60,
           tmp___59);
    tmp___61 = url_get_postlen(U);
    *(request + (rlen + tmp___61)) = (char)0;
  }
  tmp___62 = url_get_postlen(U);
  rlen += tmp___62;
  if (my.get) {
    printf((char const   * __restrict  )"%s\n\n", request);
  } else
  if (my.debug) {
    printf((char const   * __restrict  )"%s\n\n", request);
  } else
  if (my.print) {
    printf((char const   * __restrict  )"%s\n\n", request);
  }
  if (rlen == 0UL) {
    tmp___63 = url_get_method_name(U);
    NOTIFY((LEVEL )3, "HTTP %s: request buffer overrun! Unable to continue...", tmp___63);
  } else
  if (rlen > mlen) {
    tmp___63 = url_get_method_name(U);
    NOTIFY((LEVEL )3, "HTTP %s: request buffer overrun! Unable to continue...", tmp___63);
  }
  tmp___64 = socket_write(C, (void const   *)request, rlen);
  if (tmp___64 < 0) {
    return ((BOOLEAN )0);
  }
  xfree((void *)request);
  return ((BOOLEAN )1);
}
}
RESPONSE http_read_headers(CONN *C , URL U ) 
{ 
  int x ;
  int n ;
  char c ;
  char line[4096] ;
  RESPONSE resp ;
  RESPONSE tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  char tmp___9[4096] ;
  size_t tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  BOOLEAN tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  char *date ;
  size_t len ;
  size_t tmp___22 ;
  void *tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  char *etag ;
  size_t len___0 ;
  size_t tmp___26 ;
  void *tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  int tmp___35 ;
  char *expires ;
  size_t len___1 ;
  size_t tmp___36 ;
  void *tmp___37 ;
  size_t tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;

  {
  tmp = new_response();
  resp = tmp;
  while (1) {
    x = 0;
    while (1) {
      tmp___0 = socket_read(C, (void *)(& c), (size_t )1);
      n = (int )tmp___0;
      if (! (n == 1)) {
        break;
      }
      if (x < 4095) {
        line[x] = c;
      } else {
        line[x] = (char )'\n';
      }
      echo("%c", (int )c);
      if (x <= 1) {
        if ((int )line[x] == 10) {
          return (resp);
        }
      }
      if ((int )line[x] == 10) {
        break;
      }
      x ++;
    }
    line[x] = (char )'\000';
    if (x > 0) {
      if ((int )line[x - 1] == 13) {
        line[x - 1] = (char )'\000';
      }
    }
    tmp___1 = strncasecmp((char const   *)(line), "http", (size_t )4);
    if (tmp___1 == 0) {
      response_set_code(resp, line);
    }
    tmp___2 = strlen("content-type");
    tmp___3 = strncasecmp((char const   *)(line), "content-type", tmp___2);
    if (tmp___3 == 0) {
      response_set_content_type(resp, line);
    }
    tmp___4 = strlen("content-encoding");
    tmp___5 = strncasecmp((char const   *)(line), "content-encoding", tmp___4);
    if (tmp___5 == 0) {
      response_set_content_encoding(resp, line);
    }
    tmp___7 = strlen("content-length");
    tmp___8 = strncasecmp((char const   *)(line), "content-length", tmp___7);
    if (tmp___8 == 0) {
      response_set_content_length(resp, line);
      tmp___6 = atoi((char const   *)(line + 16));
      C->content.length = (size_t )tmp___6;
    }
    tmp___12 = strlen("set-cookie");
    tmp___13 = strncasecmp((char const   *)(line), "set-cookie", tmp___12);
    if (tmp___13 == 0) {
      if (my.cookies) {
        memset((void *)(tmp___9), '\000', (size_t )4096);
        tmp___10 = strlen((char const   *)(line));
        strncpy((char * __restrict  )(tmp___9), (char const   * __restrict  )(line + 12),
                tmp___10);
        tmp___11 = url_get_hostname(U);
        cookies_add(my.cookies, tmp___9, tmp___11);
      }
    }
    tmp___14 = strlen("connection");
    tmp___15 = strncasecmp((char const   *)(line), "connection", tmp___14);
    if (tmp___15 == 0) {
      response_set_connection(resp, line);
    }
    tmp___17 = strncasecmp((char const   *)(line), "keep-alive: ", (size_t )12);
    if (tmp___17 == 0) {
      tmp___16 = response_set_keepalive(resp, line);
      if ((unsigned int )tmp___16 == 1U) {
        C->connection.timeout = response_get_keepalive_timeout(resp);
        C->connection.max = response_get_keepalive_max(resp);
      }
    }
    tmp___18 = strlen("location");
    tmp___19 = strncasecmp((char const   *)(line), "location", tmp___18);
    if (tmp___19 == 0) {
      response_set_location(resp, line);
    }
    tmp___20 = strlen("content-location");
    tmp___21 = strncasecmp((char const   *)(line), "content-location", tmp___20);
    if (tmp___21 == 0) {
      response_set_location(resp, line);
    }
    tmp___24 = strlen("last-modified");
    tmp___25 = strncasecmp((char const   *)(line), "last-modified", tmp___24);
    if (tmp___25 == 0) {
      response_set_last_modified(resp, line);
      tmp___22 = strlen((char const   *)(line));
      len = tmp___22;
      if (my.cache) {
        tmp___23 = xmalloc(len);
        date = (char *)tmp___23;
        memcpy((void * __restrict  )date, (void const   * __restrict  )(line + 15),
               len - 14UL);
        cache_add(C->cache, (CTYPE )1, U, date);
        xfree((void *)date);
      }
    }
    tmp___28 = strlen("etag");
    tmp___29 = strncasecmp((char const   *)(line), "etag", tmp___28);
    if (tmp___29 == 0) {
      tmp___26 = strlen((char const   *)(line));
      len___0 = tmp___26;
      if (my.cache) {
        tmp___27 = xmalloc(len___0);
        etag = (char *)tmp___27;
        memset((void *)etag, '\000', len___0);
        memcpy((void * __restrict  )etag, (void const   * __restrict  )(line + 6),
               len___0 - 5UL);
        cache_add(C->cache, (CTYPE )0, U, etag);
        xfree((void *)etag);
      }
    }
    tmp___30 = strlen("www-authenticate");
    tmp___31 = strncasecmp((char const   *)(line), "www-authenticate", tmp___30);
    if (tmp___31 == 0) {
      response_set_www_authenticate(resp, line);
    }
    tmp___32 = strlen("proxy-authenticate");
    tmp___33 = strncasecmp((char const   *)(line), "proxy-authenticate", tmp___32);
    if (tmp___33 == 0) {
      response_set_proxy_authenticate(resp, line);
    }
    tmp___34 = strlen("transfer-encoding");
    tmp___35 = strncasecmp((char const   *)(line), "transfer-encoding", tmp___34);
    if (tmp___35 == 0) {
      response_set_transfer_encoding(resp, line);
    }
    tmp___38 = strlen("expires");
    tmp___39 = strncasecmp((char const   *)(line), "expires", tmp___38);
    if (tmp___39 == 0) {
      tmp___36 = strlen((char const   *)(line));
      len___1 = tmp___36;
      if (my.cache) {
        tmp___37 = xmalloc(len___1);
        expires = (char *)tmp___37;
        memset((void *)expires, '\000', len___1);
        memcpy((void * __restrict  )expires, (void const   * __restrict  )(line + 9),
               len___1 - 8UL);
        cache_add(C->cache, (CTYPE )2, U, expires);
        xfree((void *)expires);
      }
    }
    tmp___40 = strncasecmp((char const   *)(line), "cache-control: ", (size_t )15);
    if (n <= 0) {
      echo("read error: %s:%d", "http.c", 543);
      resp = response_destroy(resp);
      return (resp);
    }
  }
  return (resp);
}
}
int http_chunk_size(CONN *C ) 
{ 
  int n ;
  char *end ;
  size_t length ;
  ssize_t tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  unsigned short const   **tmp___2 ;
  int *tmp___3 ;

  {
  memset((void *)(C->chkbuf), '\000', sizeof(C->chkbuf));
  tmp = socket_readline(C, C->chkbuf, sizeof(C->chkbuf));
  n = (int )tmp;
  if (n < 1) {
    NOTIFY((LEVEL )1, "HTTP: unable to determine chunk size");
    return (-1);
  }
  if ((int )C->chkbuf[0] == 10) {
    return (-1);
  } else {
    tmp___0 = strlen((char const   *)(C->chkbuf));
    if (tmp___0 == 0UL) {
      return (-1);
    } else
    if ((int )C->chkbuf[0] == 13) {
      return (-1);
    }
  }
  tmp___1 = __errno_location();
  *tmp___1 = 0;
  tmp___2 = __ctype_b_loc();
  if (! ((int const   )*(*tmp___2 + (int )((unsigned int )C->chkbuf[0])) & 4096)) {
    return (-1);
  }
  length = strtoul((char const   * __restrict  )(C->chkbuf), (char ** __restrict  )(& end),
                   16);
  tmp___3 = __errno_location();
  if (*tmp___3 == 34) {
    NOTIFY((LEVEL )1, "HTTP: invalid chunk line %s\n", C->chkbuf);
    return (0);
  } else
  if ((unsigned long )end == (unsigned long )(C->chkbuf)) {
    NOTIFY((LEVEL )1, "HTTP: invalid chunk line %s\n", C->chkbuf);
    return (0);
  } else {
    return ((int )length);
  }
  return (-1);
}
}
ssize_t http_read(CONN *C , RESPONSE resp ) 
{ 
  int n ;
  int chunk ;
  size_t bytes ;
  size_t length ;
  char dest[393216] ;
  char *ptr ;
  char *tmp ;
  size_t size ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  int r ;
  BOOLEAN done ;
  void *tmp___2 ;
  int remaining_in_chunk ;
  int space_in_buf ;
  int to_read ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  ssize_t tmp___7 ;
  HTTP_TE tmp___8 ;
  HTTP_CE tmp___9 ;
  HTTP_CE tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
  n = 0;
  chunk = 0;
  bytes = (size_t )0;
  length = (size_t )0;
  ptr = (char *)((void *)0);
  tmp = (char *)((void *)0);
  size = (size_t )65536;
  if ((unsigned long )C == (unsigned long )((void *)0)) {
    NOTIFY((LEVEL )3, "Connection is NULL! Unable to proceed");
    return ((ssize_t )0);
  }
  if (C->content.length == 0UL) {
    return ((ssize_t )0);
  } else
  if (C->content.length == 0xffffffffffffffffUL) {
    C->content.length = (size_t )0;
  }
  memset((void *)(dest), '\000', sizeof(dest));
  if (C->content.length > 0UL) {
    length = C->content.length;
    tmp___0 = xmalloc(length + 1UL);
    ptr = (char *)tmp___0;
    memset((void *)ptr, '\000', length + 1UL);
    while (1) {
      tmp___1 = socket_read(C, (void *)ptr, length);
      n = (int )tmp___1;
      if (n == 0) {
        break;
      }
      bytes += (size_t )n;
      if (! (bytes < length)) {
        break;
      }
    }
  } else
  if (my.chunked) {
    tmp___8 = response_get_transfer_encoding(resp);
    if ((unsigned int )tmp___8 == 2U) {
      r = 0;
      bytes = (size_t )0;
      done = (BOOLEAN )0;
      tmp___2 = xmalloc(size);
      ptr = (char *)tmp___2;
      memset((void *)ptr, '\000', size);
      while (1) {
        chunk = http_chunk_size(C);
        if (chunk == 0) {
          socket_readline(C, C->chkbuf, sizeof(C->chkbuf));
          break;
        } else
        if (chunk < 0) {
          chunk = 0;
          goto __Cont;
        }
        while (n < chunk) {
          remaining_in_chunk = chunk - n;
          space_in_buf = (int )(size - bytes);
          if (remaining_in_chunk < space_in_buf) {
            tmp___3 = remaining_in_chunk;
          } else {
            tmp___3 = space_in_buf;
          }
          to_read = tmp___3;
          tmp___4 = socket_read(C, (void *)(ptr + bytes), (size_t )to_read);
          r = (int )tmp___4;
          bytes += (size_t )r;
          if (r <= 0) {
            done = (BOOLEAN )1;
            break;
          }
          n += r;
          if (bytes >= size) {
            tmp___5 = realloc((void *)ptr, size * 2UL);
            tmp = (char *)tmp___5;
            if ((unsigned long )tmp == (unsigned long )((void *)0)) {
              free((void *)ptr);
              return ((ssize_t )-1);
            }
            ptr = tmp;
            size *= 2UL;
          }
        }
        n = 0;
        __Cont: /* CIL Label */ 
        if (! (! done)) {
          break;
        }
      }
      *(ptr + bytes) = (char )'\000';
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___6 = xmalloc(size);
    ptr = (char *)tmp___6;
    memset((void *)ptr, '\000', size);
    while (1) {
      tmp___7 = socket_read(C, (void *)ptr, size);
      n = (int )tmp___7;
      bytes += (size_t )n;
      if (n <= 0) {
        break;
      }
    }
  }
  tmp___9 = response_get_content_encoding(resp);
  if ((unsigned int )tmp___9 == 4U) {
    __gzip_inflate(47, (char const   *)ptr, (int )bytes, (char const   *)(dest), (int )sizeof(dest));
  }
  tmp___10 = response_get_content_encoding(resp);
  if ((unsigned int )tmp___10 == 2U) {
    __gzip_inflate(-15, (char const   *)ptr, (int )bytes, (char const   *)(dest),
                   (int )sizeof(dest));
  }
  tmp___13 = strlen((char const   *)(dest));
  if (tmp___13 > 0UL) {
    tmp___11 = strlen((char const   *)(dest));
    page_concat(C->page, (char const   *)(dest), (int const   )tmp___11);
  } else {
    tmp___12 = strlen((char const   *)ptr);
    page_concat(C->page, (char const   *)ptr, (int const   )tmp___12);
  }
  xfree((void *)ptr);
  echo("\n");
  return ((ssize_t )bytes);
}
}
static int __gzip_inflate(int window , char const   *src , int srcLen , char const   *dst ,
                          int dstLen ) 
{ 
  int err ;
  z_stream strm ;
  int ret ;

  {
  err = -1;
  ret = -1;
  strm.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
  strm.zfree = (void (*)(voidpf opaque , voidpf address ))0;
  strm.opaque = (voidpf )0;
  strm.avail_in = (uInt )srcLen;
  strm.avail_out = (uInt )dstLen;
  strm.next_in = (Bytef *)src;
  strm.next_out = (Bytef *)dst;
  err = inflateInit2_(& strm, window, "1.2.11", (int )sizeof(z_stream ));
  if (err == 0) {
    err = inflate(& strm, 4);
    if (err == 1) {
      ret = (int )strm.total_out;
    } else {
      inflateEnd(& strm);
      return (err);
    }
  } else {
    inflateEnd(& strm);
    return (err);
  }
  inflateEnd(& strm);
  return (ret);
}
}
#pragma merger("0","/tmp/cil-lOSQjYbu.i","-W,-Wall,-Wunused-value,-g,-O2")
extern int system(char const   *__command ) ;
int init_config(void) ;
int show_config(int EXIT ) ;
int load_conf(char *filename ) ;
void ds_module_check(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
void parse_time(char *p ) ;
char *stralloc(char *str ) ;
char const   *version_string ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
int init_config(void) 
{ 
  char *e ;
  char dir[256] ;
  int res ;
  struct stat buf ;
  BOOLEAN needed ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int ret ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
  needed = (BOOLEAN )0;
  memset((void *)(dir), '\000', sizeof(dir));
  tmp = getenv("HOME");
  snprintf((char * __restrict  )(dir), sizeof(dir), (char const   * __restrict  )"%s/.siege",
           tmp);
  tmp___1 = stat((char const   * __restrict  )(dir), (struct stat * __restrict  )(& buf));
  if (tmp___1 < 0) {
    tmp___2 = __errno_location();
    if (2 == *tmp___2) {
      needed = (BOOLEAN )1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (! ((buf.st_mode & 61440U) == 16384U)) {
    tmp___0 = unlink((char const   *)(dir));
    if (tmp___0 == 0) {
      needed = (BOOLEAN )1;
    }
  }
  while (needed) {
    mkdir((char const   *)(dir), (__mode_t )488);
    ret = system("siege.config");
    if ((int )((signed char )((ret & 127) + 1)) >> 1 > 0) {
      if ((ret & 127) == 2) {
        break;
      } else
      if ((ret & 127) == 3) {
        break;
      }
    }
    needed = (BOOLEAN )0;
  }
  tmp___6 = strcmp((char const   *)(my.rc), "");
  if (tmp___6 == 0) {
    e = getenv("SIEGERC");
    if ((unsigned long )e != (unsigned long )((void *)0)) {
      snprintf((char * __restrict  )(my.rc), sizeof(my.rc), (char const   * __restrict  )"%s",
               e);
    } else {
      tmp___3 = getenv("HOME");
      snprintf((char * __restrict  )(my.rc), sizeof(my.rc), (char const   * __restrict  )"%s/.siege/siege.conf",
               tmp___3);
      tmp___4 = stat((char const   * __restrict  )(my.rc), (struct stat * __restrict  )(& buf));
      if (tmp___4 < 0) {
        tmp___5 = __errno_location();
        if (*tmp___5 == 2) {
          snprintf((char * __restrict  )(my.rc), sizeof(my.rc), (char const   * __restrict  )"/usr/local/etc/siegerc");
        }
      }
    }
  }
  my.debug = (BOOLEAN )0;
  my.quiet = (BOOLEAN )0;
  my.color = (BOOLEAN )1;
  my.internet = (BOOLEAN )0;
  my.config = (BOOLEAN )0;
  my.csv = (BOOLEAN )0;
  my.fullurl = (BOOLEAN )0;
  my.escape = (BOOLEAN )1;
  my.parser = (BOOLEAN )0;
  my.secs = -1;
  my.limit = 255;
  my.reps = 10301062;
  my.bids = 5;
  my.login = (BOOLEAN )0;
  my.failures = 1024;
  my.failed = 0;
  my.auth = new_auth();
  auth_set_proxy_required(my.auth, (BOOLEAN )0);
  auth_set_proxy_port(my.auth, 3128);
  my.timeout = 30;
  my.timestamp = (BOOLEAN )0;
  my.chunked = (BOOLEAN )0;
  my.unique = (BOOLEAN )1;
  my.json_output = (BOOLEAN )0;
  my.extra[0] = (char)0;
  my.follow = (BOOLEAN )1;
  my.zero_ok = (BOOLEAN )1;
  my.signaled = 0;
  my.ssl_timeout = 300;
  my.ssl_cert = (char *)((void *)0);
  my.ssl_key = (char *)((void *)0);
  my.ssl_ciphers = (char *)((void *)0);
  my.lurl = new_array();
  my.cookies = new_cookies();
  tmp___7 = xcalloc((size_t )1, sizeof(LINES ));
  my.nomap = (LINES *)tmp___7;
  (my.nomap)->index = 0;
  (my.nomap)->line = (char **)((void *)0);
  res = pthread_mutex_init(& my.lock, (pthread_mutexattr_t const   *)((void *)0));
  if (res != 0) {
    NOTIFY((LEVEL )3, "unable to initiate lock");
  }
  res = pthread_cond_init((pthread_cond_t * __restrict  )(& my.cond), (pthread_condattr_t const   * __restrict  )((void *)0));
  if (res != 0) {
    NOTIFY((LEVEL )3, "unable to initiate condition");
  }
  tmp___8 = load_conf(my.rc);
  if (tmp___8 < 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"**************************************************\n");
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"siege: could not open %s\n",
            my.rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"run \'siege.config\' to generate a new config file\n");
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"**************************************************\n");
    return (-1);
  }
  tmp___9 = strlen((char const   *)(my.file));
  if (tmp___9 < 1UL) {
    snprintf((char * __restrict  )(my.file), sizeof(my.file), (char const   * __restrict  )"%s",
             "/usr/local/etc/urls.txt");
  }
  tmp___10 = strlen((char const   *)(my.uagent));
  if (tmp___10 < 1UL) {
    snprintf((char * __restrict  )(my.uagent), sizeof(my.uagent), (char const   * __restrict  )"Mozilla/5.0 (%s) Siege/%s",
             "pc-x86_64-linux-gnu", version_string);
  }
  tmp___11 = strlen((char const   *)(my.conttype));
  if (tmp___11 < 1UL) {
    snprintf((char * __restrict  )(my.conttype), sizeof(my.conttype), (char const   * __restrict  )"application/x-www-form-urlencoded");
  }
  tmp___12 = strlen((char const   *)(my.encoding));
  if (tmp___12 < 1UL) {
    snprintf((char * __restrict  )(my.encoding), sizeof(my.encoding), (char const   * __restrict  )"*");
  }
  tmp___13 = strlen((char const   *)(my.logfile));
  if (tmp___13 < 1UL) {
    snprintf((char * __restrict  )(my.logfile), sizeof(my.logfile), (char const   * __restrict  )"%s",
             "/usr/local/var/log/siege.log");
  }
  return (0);
}
}
int show_config(int EXIT ) 
{ 
  char *method___0 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  BOOLEAN tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___14 ;
  size_t tmp___15 ;
  char const   *tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  int i ;

  {
  switch ((unsigned int )my.method) {
  case 2U: 
  method___0 = strdup("GET");
  break;
  default: 
  method___0 = strdup("HEAD");
  break;
  }
  printf((char const   * __restrict  )"CURRENT  SIEGE  CONFIGURATION\n");
  printf((char const   * __restrict  )"%s\n", my.uagent);
  printf((char const   * __restrict  )"Edit the resource file to change the settings.\n");
  printf((char const   * __restrict  )"----------------------------------------------\n");
  printf((char const   * __restrict  )"version:                        %s\n", version_string);
  if (my.verbose) {
    tmp = "true";
  } else {
    tmp = "false";
  }
  printf((char const   * __restrict  )"verbose:                        %s\n", tmp);
  if (my.color) {
    tmp___0 = "true";
  } else {
    tmp___0 = "false";
  }
  printf((char const   * __restrict  )"color:                          %s\n", tmp___0);
  if (my.quiet) {
    tmp___1 = "true";
  } else {
    tmp___1 = "false";
  }
  printf((char const   * __restrict  )"quiet:                          %s\n", tmp___1);
  if (my.debug) {
    tmp___2 = "true";
  } else {
    tmp___2 = "false";
  }
  printf((char const   * __restrict  )"debug:                          %s\n", tmp___2);
  if (my.protocol) {
    tmp___3 = "HTTP/1.1";
  } else {
    tmp___3 = "HTTP/1.0";
  }
  printf((char const   * __restrict  )"protocol:                       %s\n", tmp___3);
  if (my.parser) {
    tmp___4 = "enabled";
  } else {
    tmp___4 = "disabled";
  }
  printf((char const   * __restrict  )"HTML parser:                    %s\n", tmp___4);
  printf((char const   * __restrict  )"get method:                     %s\n", method___0);
  tmp___7 = auth_get_proxy_required(my.auth);
  if (tmp___7) {
    tmp___5 = auth_get_proxy_host(my.auth);
    printf((char const   * __restrict  )"proxy-host:                     %s\n", tmp___5);
    tmp___6 = auth_get_proxy_port(my.auth);
    printf((char const   * __restrict  )"proxy-port:                     %d\n", tmp___6);
  }
  if (my.keepalive) {
    tmp___8 = "keep-alive";
  } else {
    tmp___8 = "close";
  }
  printf((char const   * __restrict  )"connection:                     %s\n", tmp___8);
  printf((char const   * __restrict  )"concurrent users:               %d\n", my.cusers);
  if (my.secs > 0) {
    printf((char const   * __restrict  )"time to run:                    %d seconds\n",
           my.secs);
  } else {
    printf((char const   * __restrict  )"time to run:                    n/a\n");
  }
  if (my.reps > 0) {
    if (my.reps != 10301062) {
      printf((char const   * __restrict  )"repetitions:                    %d\n",
             my.reps);
    } else {
      printf((char const   * __restrict  )"repetitions:                    n/a\n");
    }
  } else {
    printf((char const   * __restrict  )"repetitions:                    n/a\n");
  }
  printf((char const   * __restrict  )"socket timeout:                 %d\n", my.timeout);
  if ((unsigned int )my.cache == 1U) {
    tmp___9 = "true";
  } else {
    tmp___9 = "false";
  }
  printf((char const   * __restrict  )"cache enabled:                  %s\n", tmp___9);
  printf((char const   * __restrict  )"accept-encoding:                %s\n", my.encoding);
  if (my.delay > (float )1) {
    tmp___10 = "s";
  } else {
    tmp___10 = "";
  }
  printf((char const   * __restrict  )"delay:                          %.3f sec%s\n",
         (double )my.delay, tmp___10);
  if (my.internet) {
    tmp___11 = "true";
  } else {
    tmp___11 = "false";
  }
  printf((char const   * __restrict  )"internet simulation:            %s\n", tmp___11);
  if (my.bench) {
    tmp___12 = "true";
  } else {
    tmp___12 = "false";
  }
  printf((char const   * __restrict  )"benchmark mode:                 %s\n", tmp___12);
  printf((char const   * __restrict  )"failures until abort:           %d\n", my.failures);
  if ((unsigned long )my.url == (unsigned long )((void *)0)) {
    tmp___14 = "none";
  } else {
    tmp___15 = strlen((char const   *)my.url);
    if (tmp___15 < 2UL) {
      tmp___14 = "none";
    } else {
      tmp___14 = (char const   *)my.url;
    }
  }
  printf((char const   * __restrict  )"named URL:                      %s\n", tmp___14);
  tmp___18 = strlen((char const   *)(my.file));
  if (tmp___18 > 1UL) {
    tmp___17 = (char const   *)(my.file);
  } else {
    tmp___17 = "/usr/local/etc/urls.txt";
  }
  printf((char const   * __restrict  )"URLs file:                      %s\n", tmp___17);
  if (my.limit < 1) {
    tmp___19 = 255;
  } else {
    tmp___19 = my.limit;
  }
  printf((char const   * __restrict  )"thread limit:                   %d\n", tmp___19);
  if (my.logging) {
    tmp___20 = "true";
  } else {
    tmp___20 = "false";
  }
  printf((char const   * __restrict  )"logging:                        %s\n", tmp___20);
  if ((unsigned long )(my.logfile) == (unsigned long )((void *)0)) {
    tmp___21 = "/usr/local/var/log/siege.log";
  } else {
    tmp___21 = (char const   *)(my.logfile);
  }
  printf((char const   * __restrict  )"log file:                       %s\n", tmp___21);
  printf((char const   * __restrict  )"resource file:                  %s\n", my.rc);
  if (my.timestamp) {
    tmp___22 = "true";
  } else {
    tmp___22 = "false";
  }
  printf((char const   * __restrict  )"timestamped output:             %s\n", tmp___22);
  if (my.csv) {
    tmp___23 = "true";
  } else {
    tmp___23 = "false";
  }
  printf((char const   * __restrict  )"comma separated output:         %s\n", tmp___23);
  if (my.follow) {
    tmp___24 = "true";
  } else {
    tmp___24 = "false";
  }
  printf((char const   * __restrict  )"allow redirects:                %s\n", tmp___24);
  if (my.zero_ok) {
    tmp___25 = "true";
  } else {
    tmp___25 = "false";
  }
  printf((char const   * __restrict  )"allow zero byte data:           %s\n", tmp___25);
  if (my.chunked) {
    tmp___26 = "true";
  } else {
    tmp___26 = "false";
  }
  printf((char const   * __restrict  )"allow chunked encoding:         %s\n", tmp___26);
  if (my.unique) {
    tmp___27 = "true";
  } else {
    tmp___27 = "false";
  }
  printf((char const   * __restrict  )"upload unique files:            %s\n", tmp___27);
  if (my.json_output) {
    tmp___28 = "true";
  } else {
    tmp___28 = "false";
  }
  printf((char const   * __restrict  )"json output:                    %s\n", tmp___28);
  if ((unsigned int )my.parser == 1U) {
    if ((my.nomap)->index > 0) {
      printf((char const   * __restrict  )"no-follow:\n");
      i = 0;
      while (i < (my.nomap)->index) {
        printf((char const   * __restrict  )" - %s\n", *((my.nomap)->line + i));
        i ++;
      }
    }
  }
  printf((char const   * __restrict  )"proxy auth:                     ");
  auth_display(my.auth, (SCHEME )4);
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"www auth:                       ");
  auth_display(my.auth, (SCHEME )1);
  printf((char const   * __restrict  )"\n");
  xfree((void *)method___0);
  my.auth = auth_destroy(my.auth);
  my.lurl = array_destroy(my.lurl);
  my.cookies = cookies_destroy(my.cookies);
  if (EXIT) {
    exit(0);
  } else {
    return (0);
  }
}
}
int readline(char **s , FILE *fp ) 
{ 
  int c ;
  int i ;
  int len ;
  int size ;
  char *tmp ;
  char *ptr ;
  char *txt ;
  BOOLEAN lop ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  len = 0;
  size = 0;
  tmp = (char *)((void *)0);
  ptr = (char *)((void *)0);
  txt = (char *)((void *)0);
  lop = (BOOLEAN )1;
  tmp___0 = xmalloc((size_t )1024);
  ptr = (char *)tmp___0;
  size = 1024;
  while (1) {
    c = fgetc(fp);
    if (c != -1) {
      if (! (c != 10)) {
        break;
      }
    } else {
      break;
    }
    if (len >= size) {
      tmp___1 = realloc((void *)ptr, (size_t )(size + 1024));
      tmp = (char *)tmp___1;
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        free((void *)ptr);
        return (-1);
      }
      ptr = tmp;
      size += 1024;
    }
    tmp___2 = len;
    len ++;
    *(ptr + tmp___2) = (char )c;
  }
  if (len == 0) {
    if (c == -1) {
      free((void *)ptr);
      return (-1);
    } else {
      *(ptr + 0) = (char )'\000';
      *s = ptr;
      return (0);
    }
  }
  if (len + 1 != size) {
    tmp___3 = realloc((void *)ptr, (size_t )(len + 1));
    tmp = (char *)tmp___3;
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      free((void *)ptr);
      return (-1);
    }
    ptr = tmp;
  }
  *(ptr + len) = (char )'\000';
  txt = strdup((char const   *)ptr);
  trim(txt);
  tmp___4 = strncmp((char const   *)txt, "login", (size_t )5);
  if (tmp___4 == 0) {
    lop = (BOOLEAN )0;
  }
  xfree((void *)txt);
  i = 0;
  while ((int )*(ptr + i) != 0) {
    if ((int )*(ptr + i) == 35) {
      if ((unsigned int )lop == 1U) {
        *(ptr + i) = (char )'\000';
      }
    }
    i ++;
  }
  *s = ptr;
  return (len);
}
}
int load_conf(char *filename ) 
{ 
  FILE *fp ;
  HASH H ;
  char *line ;
  char *option ;
  char *optionptr ;
  char *value ;
  BOOLEAN zlib ;
  char *tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  BOOLEAN tmp___7 ;
  BOOLEAN tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  double tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  BOOLEAN tmp___25 ;
  BOOLEAN compress ;
  char *tmp___26 ;
  char *tmp___27 ;
  CREDS tmp___28 ;
  BOOLEAN tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  CREDS tmp___34 ;
  CREDS tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  char *tmp___39 ;
  size_t tmp___40 ;
  size_t tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  BOOLEAN tmp___47 ;
  BOOLEAN tmp___48 ;
  BOOLEAN tmp___49 ;
  BOOLEAN tmp___50 ;
  BOOLEAN tmp___51 ;
  BOOLEAN tmp___52 ;
  BOOLEAN tmp___53 ;
  BOOLEAN tmp___54 ;
  BOOLEAN tmp___55 ;
  BOOLEAN tmp___56 ;
  BOOLEAN tmp___57 ;
  BOOLEAN tmp___58 ;
  BOOLEAN tmp___59 ;
  BOOLEAN tmp___60 ;
  BOOLEAN tmp___61 ;
  BOOLEAN tmp___62 ;
  BOOLEAN tmp___63 ;
  BOOLEAN tmp___64 ;
  BOOLEAN tmp___65 ;
  BOOLEAN tmp___66 ;
  BOOLEAN tmp___67 ;
  int tmp___68 ;
  BOOLEAN tmp___69 ;
  BOOLEAN tmp___70 ;
  BOOLEAN tmp___71 ;
  BOOLEAN tmp___72 ;
  BOOLEAN tmp___73 ;
  BOOLEAN tmp___74 ;
  BOOLEAN tmp___75 ;
  BOOLEAN tmp___76 ;
  BOOLEAN tmp___77 ;
  BOOLEAN tmp___78 ;
  BOOLEAN tmp___79 ;
  BOOLEAN tmp___80 ;
  BOOLEAN tmp___81 ;
  BOOLEAN tmp___82 ;
  BOOLEAN tmp___83 ;
  BOOLEAN tmp___84 ;
  BOOLEAN tmp___85 ;
  BOOLEAN tmp___86 ;
  BOOLEAN tmp___87 ;
  BOOLEAN tmp___88 ;
  BOOLEAN tmp___89 ;
  BOOLEAN tmp___90 ;
  BOOLEAN tmp___91 ;
  BOOLEAN tmp___92 ;
  BOOLEAN tmp___93 ;
  BOOLEAN tmp___94 ;
  BOOLEAN tmp___95 ;
  int tmp___96 ;

  {
  zlib = (BOOLEAN )1;
  fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    return (-1);
  }
  H = new_hash();
  while (1) {
    tmp___96 = readline(& line, fp);
    if (! (tmp___96 != -1)) {
      break;
    }
    tmp = line;
    line = trim(line);
    if ((int )*line == 35) {
      free((void *)line);
      continue;
    } else
    if ((int )*line == 0) {
      free((void *)line);
      continue;
    } else {
      tmp___0 = strlen((char const   *)line);
      if (tmp___0 < 1UL) {
        free((void *)line);
        continue;
      }
    }
    option = xstrdup((char const   *)line);
    optionptr = option;
    while (1) {
      if (*optionptr) {
        tmp___1 = __ctype_b_loc();
        if ((int const   )*(*tmp___1 + (int )((unsigned char )((int )*optionptr))) & 8192) {
          break;
        } else
        if (61 == (int )*optionptr) {
          break;
        } else
        if (58 == (int )*optionptr) {
          break;
        }
      } else {
        break;
      }
      optionptr ++;
    }
    tmp___2 = optionptr;
    optionptr ++;
    *tmp___2 = (char )'\000';
    while (1) {
      tmp___3 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___3 + (int )((unsigned char )((int )*optionptr))) & 8192)) {
        if (! (61 == (int )*optionptr)) {
          if (! (58 == (int )*optionptr)) {
            break;
          }
        }
      }
      optionptr ++;
    }
    value = xstrdup((char const   *)optionptr);
    while (*line) {
      line ++;
    }
    while (1) {
      tmp___4 = strstr((char const   *)option, "$");
      if (! tmp___4) {
        break;
      }
      option = evaluate(H, option);
    }
    while (1) {
      tmp___5 = strstr((char const   *)value, "$");
      if (! tmp___5) {
        break;
      }
      value = evaluate(H, value);
    }
    tmp___95 = strmatch(option, (char *)"verbose");
    if (tmp___95) {
      tmp___6 = strncasecmp((char const   *)value, "true", (size_t )4);
      if (tmp___6) {
        my.verbose = (BOOLEAN )0;
      } else {
        my.verbose = (BOOLEAN )1;
      }
    } else {
      tmp___94 = strmatch(option, (char *)"color");
      if (tmp___94) {
        tmp___7 = strmatch(value, (char *)"false");
        if (tmp___7) {
          my.color = (BOOLEAN )0;
        } else {
          tmp___8 = strmatch(value, (char *)"off");
          if (tmp___8) {
            my.color = (BOOLEAN )0;
          } else {
            my.color = (BOOLEAN )1;
          }
        }
      } else {
        tmp___93 = strmatch(option, (char *)"quiet");
        if (tmp___93) {
          tmp___9 = strncasecmp((char const   *)value, "true", (size_t )4);
          if (tmp___9) {
            my.quiet = (BOOLEAN )0;
          } else {
            my.quiet = (BOOLEAN )1;
          }
        } else {
          tmp___92 = strmatch(option, (char *)"parser");
          if (tmp___92) {
            tmp___10 = strncasecmp((char const   *)value, "true", (size_t )4);
            if (tmp___10) {
              my.parser = (BOOLEAN )0;
            } else {
              my.parser = (BOOLEAN )1;
            }
          } else {
            tmp___91 = strmatch(option, (char *)"nofollow");
            if (tmp___91) {
              if (value) {
                tmp___13 = strlen((char const   *)value);
                if (tmp___13 > 3UL) {
                  tmp___11 = realloc((void *)(my.nomap)->line, sizeof(char *) * (unsigned long )((my.nomap)->index + 1));
                  (my.nomap)->line = (char **)tmp___11;
                  tmp___12 = strdup((char const   *)value);
                  *((my.nomap)->line + (my.nomap)->index) = tmp___12;
                  ((my.nomap)->index) ++;
                }
              }
            } else {
              tmp___90 = strmatch(option, (char *)"csv");
              if (tmp___90) {
                tmp___14 = strncasecmp((char const   *)value, "true", (size_t )4);
                if (tmp___14) {
                  my.csv = (BOOLEAN )0;
                } else {
                  my.csv = (BOOLEAN )1;
                }
              } else {
                tmp___89 = strmatch(option, (char *)"fullurl");
                if (tmp___89) {
                  tmp___15 = strncasecmp((char const   *)value, "true", (size_t )4);
                  if (tmp___15) {
                    my.fullurl = (BOOLEAN )0;
                  } else {
                    my.fullurl = (BOOLEAN )1;
                  }
                } else {
                  tmp___88 = strmatch(option, (char *)"display-id");
                  if (tmp___88) {
                    tmp___16 = strncasecmp((char const   *)value, "true", (size_t )4);
                    if (tmp___16) {
                      my.display = (BOOLEAN )0;
                    } else {
                      my.display = (BOOLEAN )1;
                    }
                  } else {
                    tmp___87 = strmatch(option, (char *)"logging");
                    if (tmp___87) {
                      tmp___17 = strncasecmp((char const   *)value, "true", (size_t )4);
                      if (tmp___17) {
                        my.logging = (BOOLEAN )0;
                      } else {
                        my.logging = (BOOLEAN )1;
                      }
                    } else {
                      tmp___86 = strmatch(option, (char *)"show-logfile");
                      if (tmp___86) {
                        tmp___18 = strncasecmp((char const   *)value, "true", (size_t )4);
                        if (tmp___18) {
                          my.shlog = (BOOLEAN )0;
                        } else {
                          my.shlog = (BOOLEAN )1;
                        }
                      } else {
                        tmp___85 = strmatch(option, (char *)"logfile");
                        if (tmp___85) {
                          strncpy((char * __restrict  )(my.logfile), (char const   * __restrict  )value,
                                  sizeof(my.logfile));
                        } else {
                          tmp___84 = strmatch(option, (char *)"concurrent");
                          if (tmp___84) {
                            if ((unsigned long )value != (unsigned long )((void *)0)) {
                              my.cusers = atoi((char const   *)value);
                            } else {
                              my.cusers = 10;
                            }
                          } else {
                            tmp___83 = strmatch(option, (char *)"reps");
                            if (tmp___83) {
                              if ((unsigned long )value != (unsigned long )((void *)0)) {
                                my.reps = atoi((char const   *)value);
                              } else {
                                my.reps = 5;
                              }
                            } else {
                              tmp___82 = strmatch(option, (char *)"limit");
                              if (tmp___82) {
                                if ((unsigned long )value != (unsigned long )((void *)0)) {
                                  my.limit = atoi((char const   *)value);
                                } else {
                                  my.limit = 255;
                                }
                              } else {
                                tmp___81 = strmatch(option, (char *)"time");
                                if (tmp___81) {
                                  parse_time(value);
                                } else {
                                  tmp___80 = strmatch(option, (char *)"delay");
                                  if (tmp___80) {
                                    if ((unsigned long )value != (unsigned long )((void *)0)) {
                                      tmp___19 = atof((char const   *)value);
                                      my.delay = (float )tmp___19;
                                    } else {
                                      my.delay = (float )1;
                                    }
                                  } else {
                                    tmp___79 = strmatch(option, (char *)"timeout");
                                    if (tmp___79) {
                                      if ((unsigned long )value != (unsigned long )((void *)0)) {
                                        my.timeout = atoi((char const   *)value);
                                      } else {
                                        my.timeout = 15;
                                      }
                                    } else {
                                      tmp___78 = strmatch(option, (char *)"timestamp");
                                      if (tmp___78) {
                                        tmp___20 = strncasecmp((char const   *)value,
                                                               "true", (size_t )4);
                                        if (tmp___20) {
                                          my.timestamp = (BOOLEAN )0;
                                        } else {
                                          my.timestamp = (BOOLEAN )1;
                                        }
                                      } else {
                                        tmp___77 = strmatch(option, (char *)"internet");
                                        if (tmp___77) {
                                          tmp___21 = strncasecmp((char const   *)value,
                                                                 "true", (size_t )4);
                                          if (tmp___21) {
                                            my.internet = (BOOLEAN )0;
                                          } else {
                                            my.internet = (BOOLEAN )1;
                                          }
                                        } else {
                                          tmp___76 = strmatch(option, (char *)"benchmark");
                                          if (tmp___76) {
                                            tmp___22 = strncasecmp((char const   *)value,
                                                                   "true", (size_t )4);
                                            if (tmp___22) {
                                              my.bench = (BOOLEAN )0;
                                            } else {
                                              my.bench = (BOOLEAN )1;
                                            }
                                          } else {
                                            tmp___75 = strmatch(option, (char *)"cache");
                                            if (tmp___75) {
                                              tmp___23 = strncasecmp((char const   *)value,
                                                                     "true", (size_t )4);
                                              if (tmp___23) {
                                                my.cache = (BOOLEAN )0;
                                              } else {
                                                my.cache = (BOOLEAN )1;
                                              }
                                            } else {
                                              tmp___74 = strmatch(option, (char *)"debug");
                                              if (tmp___74) {
                                                tmp___24 = strncasecmp((char const   *)value,
                                                                       "true", (size_t )4);
                                                if (tmp___24) {
                                                  my.debug = (BOOLEAN )0;
                                                } else {
                                                  my.debug = (BOOLEAN )1;
                                                }
                                              } else {
                                                tmp___73 = strmatch(option, (char *)"gmethod");
                                                if (tmp___73) {
                                                  tmp___25 = strmatch(value, (char *)"GET");
                                                  if (tmp___25) {
                                                    my.method = (METHOD )2;
                                                  } else {
                                                    my.method = (METHOD )1;
                                                  }
                                                } else {
                                                  tmp___72 = strmatch(option, (char *)"file");
                                                  if (tmp___72) {
                                                    memset((void *)(my.file), 0, sizeof(my.file));
                                                    strncpy((char * __restrict  )(my.file),
                                                            (char const   * __restrict  )value,
                                                            sizeof(my.file));
                                                  } else {
                                                    tmp___71 = strmatch(option, (char *)"url");
                                                    if (tmp___71) {
                                                      my.url = stralloc(value);
                                                    } else {
                                                      tmp___70 = strmatch(option,
                                                                          (char *)"user-agent");
                                                      if (tmp___70) {
                                                        strncpy((char * __restrict  )(my.uagent),
                                                                (char const   * __restrict  )value,
                                                                sizeof(my.uagent));
                                                      } else {
                                                        tmp___69 = strmatch(option,
                                                                            (char *)"accept-encoding");
                                                        if (tmp___69) {
                                                          compress = (BOOLEAN )0;
                                                          tmp___26 = strstr((char const   *)value,
                                                                            "gzip");
                                                          if ((unsigned long )tmp___26 != (unsigned long )((void *)0)) {
                                                            compress = (BOOLEAN )1;
                                                          } else {
                                                            tmp___27 = strstr((char const   *)value,
                                                                              "compress");
                                                            if ((unsigned long )tmp___27 != (unsigned long )((void *)0)) {
                                                              compress = (BOOLEAN )1;
                                                            }
                                                          }
                                                          if ((unsigned int )compress == 1U) {
                                                            if ((unsigned int )zlib == 0U) {
                                                              NOTIFY((LEVEL )1, "Zip encoding disabled; siege requires zlib support to enable it");
                                                            } else {
                                                              strncpy((char * __restrict  )(my.encoding),
                                                                      (char const   * __restrict  )value,
                                                                      sizeof(my.encoding));
                                                            }
                                                          } else {
                                                            strncpy((char * __restrict  )(my.encoding),
                                                                    (char const   * __restrict  )value,
                                                                    sizeof(my.encoding));
                                                          }
                                                        } else {
                                                          tmp___68 = strncasecmp((char const   *)option,
                                                                                 "login",
                                                                                 (size_t )5);
                                                          if (tmp___68) {
                                                            tmp___67 = strmatch(option,
                                                                                (char *)"attempts");
                                                            if (tmp___67) {
                                                              if ((unsigned long )value != (unsigned long )((void *)0)) {
                                                                my.bids = atoi((char const   *)value);
                                                              } else {
                                                                my.bids = 3;
                                                              }
                                                            } else {
                                                              tmp___66 = strmatch(option,
                                                                                  (char *)"connection");
                                                              if (tmp___66) {
                                                                tmp___30 = strncasecmp((char const   *)value,
                                                                                       "keep-alive",
                                                                                       (size_t )10);
                                                                if (tmp___30) {
                                                                  my.keepalive = (BOOLEAN )0;
                                                                } else {
                                                                  my.keepalive = (BOOLEAN )1;
                                                                }
                                                              } else {
                                                                tmp___65 = strmatch(option,
                                                                                    (char *)"protocol");
                                                                if (tmp___65) {
                                                                  tmp___31 = strncasecmp((char const   *)value,
                                                                                         "HTTP/1.1",
                                                                                         (size_t )8);
                                                                  if (tmp___31) {
                                                                    my.protocol = 0;
                                                                  } else {
                                                                    my.protocol = 1;
                                                                  }
                                                                } else {
                                                                  tmp___64 = strmatch(option,
                                                                                      (char *)"proxy-host");
                                                                  if (tmp___64) {
                                                                    tmp___32 = trim(value);
                                                                    auth_set_proxy_host(my.auth,
                                                                                        tmp___32);
                                                                  } else {
                                                                    tmp___63 = strmatch(option,
                                                                                        (char *)"proxy-port");
                                                                    if (tmp___63) {
                                                                      if ((unsigned long )value != (unsigned long )((void *)0)) {
                                                                        tmp___33 = atoi((char const   *)value);
                                                                        auth_set_proxy_port(my.auth,
                                                                                            tmp___33);
                                                                      } else {
                                                                        auth_set_proxy_port(my.auth,
                                                                                            3128);
                                                                      }
                                                                    } else {
                                                                      tmp___62 = strmatch(option,
                                                                                          (char *)"ftp-login");
                                                                      if (tmp___62) {
                                                                        tmp___34 = new_creds((SCHEME )3,
                                                                                             value);
                                                                        auth_add(my.auth,
                                                                                 tmp___34);
                                                                      } else {
                                                                        tmp___61 = strmatch(option,
                                                                                            (char *)"proxy-login");
                                                                        if (tmp___61) {
                                                                          tmp___35 = new_creds((SCHEME )4,
                                                                                               value);
                                                                          auth_add(my.auth,
                                                                                   tmp___35);
                                                                        } else {
                                                                          tmp___60 = strmatch(option,
                                                                                              (char *)"failures");
                                                                          if (tmp___60) {
                                                                            if ((unsigned long )value != (unsigned long )((void *)0)) {
                                                                              my.failures = atoi((char const   *)value);
                                                                            } else {
                                                                              my.failures = 30;
                                                                            }
                                                                          } else {
                                                                            tmp___59 = strmatch(option,
                                                                                                (char *)"chunked");
                                                                            if (tmp___59) {
                                                                              tmp___36 = strncasecmp((char const   *)value,
                                                                                                     "true",
                                                                                                     (size_t )4);
                                                                              if (tmp___36) {
                                                                                my.chunked = (BOOLEAN )0;
                                                                              } else {
                                                                                my.chunked = (BOOLEAN )1;
                                                                              }
                                                                            } else {
                                                                              tmp___58 = strmatch(option,
                                                                                                  (char *)"unique");
                                                                              if (tmp___58) {
                                                                                tmp___37 = strncasecmp((char const   *)value,
                                                                                                       "true",
                                                                                                       (size_t )4);
                                                                                if (tmp___37) {
                                                                                  my.unique = (BOOLEAN )0;
                                                                                } else {
                                                                                  my.unique = (BOOLEAN )1;
                                                                                }
                                                                              } else {
                                                                                tmp___57 = strmatch(option,
                                                                                                    (char *)"json_output");
                                                                                if (tmp___57) {
                                                                                  tmp___38 = strncasecmp((char const   *)value,
                                                                                                         "true",
                                                                                                         (size_t )4);
                                                                                  if (tmp___38) {
                                                                                    my.json_output = (BOOLEAN )0;
                                                                                  } else {
                                                                                    my.json_output = (BOOLEAN )1;
                                                                                  }
                                                                                } else {
                                                                                  tmp___56 = strmatch(option,
                                                                                                      (char *)"header");
                                                                                  if (tmp___56) {
                                                                                    tmp___39 = strchr((char const   *)value,
                                                                                                      ':');
                                                                                    if (! tmp___39) {
                                                                                      NOTIFY((LEVEL )3,
                                                                                             "no \':\' in http-header");
                                                                                    }
                                                                                    tmp___40 = strlen((char const   *)value);
                                                                                    tmp___41 = strlen((char const   *)(my.extra));
                                                                                    if ((tmp___40 + tmp___41) + 3UL > 512UL) {
                                                                                      NOTIFY((LEVEL )3,
                                                                                             "too many headers");
                                                                                    }
                                                                                    strcat((char * __restrict  )(my.extra),
                                                                                           (char const   * __restrict  )value);
                                                                                    strcat((char * __restrict  )(my.extra),
                                                                                           (char const   * __restrict  )"\r\n");
                                                                                  } else {
                                                                                    tmp___55 = strmatch(option,
                                                                                                        (char *)"expire-session");
                                                                                    if (tmp___55) {
                                                                                      tmp___42 = strncasecmp((char const   *)value,
                                                                                                             "true",
                                                                                                             (size_t )4);
                                                                                      if (tmp___42) {
                                                                                        my.expire = (BOOLEAN )0;
                                                                                      } else {
                                                                                        my.expire = (BOOLEAN )1;
                                                                                      }
                                                                                    } else {
                                                                                      tmp___54 = strmatch(option,
                                                                                                          (char *)"follow-location");
                                                                                      if (tmp___54) {
                                                                                        tmp___43 = strncasecmp((char const   *)value,
                                                                                                               "true",
                                                                                                               (size_t )4);
                                                                                        if (tmp___43) {
                                                                                          my.follow = (BOOLEAN )0;
                                                                                        } else {
                                                                                          my.follow = (BOOLEAN )1;
                                                                                        }
                                                                                      } else {
                                                                                        tmp___53 = strmatch(option,
                                                                                                            (char *)"url-escaping");
                                                                                        if (tmp___53) {
                                                                                          tmp___44 = strncasecmp((char const   *)value,
                                                                                                                 "false",
                                                                                                                 (size_t )5);
                                                                                          if (tmp___44) {
                                                                                            my.escape = (BOOLEAN )1;
                                                                                          } else {
                                                                                            my.escape = (BOOLEAN )0;
                                                                                          }
                                                                                        } else {
                                                                                          tmp___52 = strmatch(option,
                                                                                                              (char *)"zero-data-ok");
                                                                                          if (tmp___52) {
                                                                                            tmp___45 = strncasecmp((char const   *)value,
                                                                                                                   "true",
                                                                                                                   (size_t )4);
                                                                                            if (tmp___45) {
                                                                                              my.zero_ok = (BOOLEAN )0;
                                                                                            } else {
                                                                                              my.zero_ok = (BOOLEAN )1;
                                                                                            }
                                                                                          } else {
                                                                                            tmp___51 = strmatch(option,
                                                                                                                (char *)"ssl-cert");
                                                                                            if (tmp___51) {
                                                                                              my.ssl_cert = stralloc(value);
                                                                                            } else {
                                                                                              tmp___50 = strmatch(option,
                                                                                                                  (char *)"ssl-key");
                                                                                              if (tmp___50) {
                                                                                                my.ssl_key = stralloc(value);
                                                                                              } else {
                                                                                                tmp___49 = strmatch(option,
                                                                                                                    (char *)"ssl-timeout");
                                                                                                if (tmp___49) {
                                                                                                  if ((unsigned long )value != (unsigned long )((void *)0)) {
                                                                                                    my.ssl_timeout = atoi((char const   *)value);
                                                                                                  } else {
                                                                                                    my.ssl_timeout = 15;
                                                                                                  }
                                                                                                } else {
                                                                                                  tmp___48 = strmatch(option,
                                                                                                                      (char *)"ssl-ciphers");
                                                                                                  if (tmp___48) {
                                                                                                    my.ssl_ciphers = stralloc(value);
                                                                                                  } else {
                                                                                                    tmp___47 = strmatch(option,
                                                                                                                        (char *)"spinner");
                                                                                                    if (tmp___47) {
                                                                                                      tmp___46 = strncasecmp((char const   *)value,
                                                                                                                             "true",
                                                                                                                             (size_t )4);
                                                                                                      if (tmp___46) {
                                                                                                        my.spinner = (BOOLEAN )0;
                                                                                                      } else {
                                                                                                        my.spinner = (BOOLEAN )1;
                                                                                                      }
                                                                                                    } else {
                                                                                                      hash_add(H,
                                                                                                               option,
                                                                                                               (void *)value);
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          } else {
                                                            tmp___29 = strmatch(option,
                                                                                (char *)"login-url");
                                                            if (tmp___29) {
                                                              my.login = (BOOLEAN )1;
                                                              array_push(my.lurl,
                                                                         (void *)value);
                                                            } else {
                                                              tmp___28 = new_creds((SCHEME )1,
                                                                                   value);
                                                              auth_add(my.auth, tmp___28);
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    xfree((void *)tmp);
    xfree((void *)value);
    xfree((void *)option);
  }
  H = hash_destroy(H);
  fclose(fp);
  return (0);
}
}
void ds_module_check(void) 
{ 


  {
  if (my.bench) {
    my.delay = (float )0;
  }
  if (my.secs > 0) {
    if (my.reps > 0) {
      if (my.reps != 10301062) {
        NOTIFY((LEVEL )2, "CONFIG conflict: selected time and repetition based testing");
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"defaulting to time-based testing: %d seconds\n",
                my.secs);
        my.reps = 10301062;
      }
    }
  }
  if (my.cusers <= 0) {
    my.cusers = 1;
  }
  if (my.get) {
    my.cusers = 1;
    my.reps = 1;
    my.logging = (BOOLEAN )0;
    my.bench = (BOOLEAN )1;
  }
  if (my.json_output) {
    my.quiet = (BOOLEAN )1;
  }
  if (my.quiet) {
    my.verbose = (BOOLEAN )0;
    my.debug = (BOOLEAN )0;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-j0639B_M.i","-W,-Wall,-Wunused-value,-g,-O2")
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern long ftell(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
void load_file(URL U , char *file ) ;
static struct ContentType  const  tmap[168]  = 
  {      {(char *)"default", (BOOLEAN )1, (char *)"application/x-www-form-urlencoded"}, 
        {(char *)"ai",
      (BOOLEAN )0, (char *)"application/postscript"}, 
        {(char *)"aif", (BOOLEAN )0, (char *)"audio/x-aiff"}, 
        {(char *)"aifc", (BOOLEAN )0, (char *)"audio/x-aiff"}, 
        {(char *)"aiff", (BOOLEAN )0, (char *)"audio/x-aiff"}, 
        {(char *)"asc", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"au", (BOOLEAN )0, (char *)"audio/basic"}, 
        {(char *)"avi", (BOOLEAN )0, (char *)"video/x-msvideo"}, 
        {(char *)"bcpio", (BOOLEAN )0, (char *)"application/x-bcpio"}, 
        {(char *)"bin", (BOOLEAN )0, (char *)"application/octet-stream"}, 
        {(char *)"c", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"cc", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"ccad", (BOOLEAN )0, (char *)"application/clariscad"}, 
        {(char *)"cdf", (BOOLEAN )0, (char *)"application/x-netcdf"}, 
        {(char *)"class", (BOOLEAN )0, (char *)"application/octet-stream"}, 
        {(char *)"cpio", (BOOLEAN )0, (char *)"application/x-cpio"}, 
        {(char *)"cpt", (BOOLEAN )0, (char *)"application/mac-compactpro"}, 
        {(char *)"csh", (BOOLEAN )0, (char *)"application/x-csh"}, 
        {(char *)"css", (BOOLEAN )1, (char *)"text/css"}, 
        {(char *)"csv", (BOOLEAN )1, (char *)"text/csv"}, 
        {(char *)"dcr", (BOOLEAN )0, (char *)"application/x-director"}, 
        {(char *)"dir", (BOOLEAN )0, (char *)"application/x-director"}, 
        {(char *)"dms", (BOOLEAN )0, (char *)"application/octet-stream"}, 
        {(char *)"doc", (BOOLEAN )0, (char *)"application/msword"}, 
        {(char *)"drw", (BOOLEAN )0, (char *)"application/drafting"}, 
        {(char *)"dvi", (BOOLEAN )0, (char *)"application/x-dvi"}, 
        {(char *)"dwg", (BOOLEAN )0, (char *)"application/acad"}, 
        {(char *)"dxf", (BOOLEAN )0, (char *)"application/dxf"}, 
        {(char *)"dxr", (BOOLEAN )0, (char *)"application/x-director"}, 
        {(char *)"eps", (BOOLEAN )0, (char *)"application/postscript"}, 
        {(char *)"etx", (BOOLEAN )1, (char *)"text/x-setext"}, 
        {(char *)"exe", (BOOLEAN )0, (char *)"application/octet-stream"}, 
        {(char *)"ez", (BOOLEAN )0, (char *)"application/andrew-inset"}, 
        {(char *)"f", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"f90", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"fli", (BOOLEAN )0, (char *)"video/x-fli"}, 
        {(char *)"gif", (BOOLEAN )0, (char *)"image/gif"}, 
        {(char *)"gtar", (BOOLEAN )0, (char *)"application/x-gtar"}, 
        {(char *)"gz", (BOOLEAN )0, (char *)"application/x-gzip"}, 
        {(char *)"h", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"hdf", (BOOLEAN )0, (char *)"application/x-hdf"}, 
        {(char *)"hh", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"hqx", (BOOLEAN )0, (char *)"application/mac-binhex40"}, 
        {(char *)"htm", (BOOLEAN )1, (char *)"text/html"}, 
        {(char *)"html", (BOOLEAN )1, (char *)"text/html"}, 
        {(char *)"ice", (BOOLEAN )0, (char *)"x-conference/x-cooltalk"}, 
        {(char *)"ico", (BOOLEAN )0, (char *)"image/x-icon"}, 
        {(char *)"ief", (BOOLEAN )0, (char *)"image/ief"}, 
        {(char *)"iges", (BOOLEAN )0, (char *)"model/iges"}, 
        {(char *)"igs", (BOOLEAN )0, (char *)"model/iges"}, 
        {(char *)"ips", (BOOLEAN )0, (char *)"application/x-ipscript"}, 
        {(char *)"ipx", (BOOLEAN )0, (char *)"application/x-ipix"}, 
        {(char *)"jpe", (BOOLEAN )0, (char *)"image/jpeg"}, 
        {(char *)"jpeg", (BOOLEAN )0, (char *)"image/jpeg"}, 
        {(char *)"jpg", (BOOLEAN )0, (char *)"image/jpeg"}, 
        {(char *)"js", (BOOLEAN )0, (char *)"application/x-javascript"}, 
        {(char *)"json", (BOOLEAN )0, (char *)"application/json"}, 
        {(char *)"kar", (BOOLEAN )0, (char *)"audio/midi"}, 
        {(char *)"latex", (BOOLEAN )0, (char *)"application/x-latex"}, 
        {(char *)"lha", (BOOLEAN )0, (char *)"application/octet-stream"}, 
        {(char *)"lsp", (BOOLEAN )0, (char *)"application/x-lisp"}, 
        {(char *)"lzh", (BOOLEAN )0, (char *)"application/octet-stream"}, 
        {(char *)"m", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"man", (BOOLEAN )0, (char *)"application/x-troff-man"}, 
        {(char *)"md", (BOOLEAN )1, (char *)"text/x-markdown"}, 
        {(char *)"me", (BOOLEAN )0, (char *)"application/x-troff-me"}, 
        {(char *)"mesh", (BOOLEAN )0, (char *)"model/mesh"}, 
        {(char *)"mid", (BOOLEAN )0, (char *)"audio/midi"}, 
        {(char *)"midi", (BOOLEAN )0, (char *)"audio/midi"}, 
        {(char *)"mif", (BOOLEAN )0, (char *)"application/vnd.mif"}, 
        {(char *)"mime", (BOOLEAN )0, (char *)"www/mime"}, 
        {(char *)"mov", (BOOLEAN )0, (char *)"video/quicktime"}, 
        {(char *)"movie", (BOOLEAN )0, (char *)"video/x-sgi-movie"}, 
        {(char *)"mp2", (BOOLEAN )0, (char *)"audio/mpeg"}, 
        {(char *)"mp3", (BOOLEAN )0, (char *)"audio/mpeg"}, 
        {(char *)"mpe", (BOOLEAN )0, (char *)"video/mpeg"}, 
        {(char *)"mpeg", (BOOLEAN )0, (char *)"video/mpeg"}, 
        {(char *)"mpg", (BOOLEAN )0, (char *)"video/mpeg"}, 
        {(char *)"mpga", (BOOLEAN )0, (char *)"audio/mpeg"}, 
        {(char *)"ms", (BOOLEAN )0, (char *)"application/x-troff-ms"}, 
        {(char *)"msh", (BOOLEAN )0, (char *)"model/mesh"}, 
        {(char *)"nc", (BOOLEAN )0, (char *)"application/x-netcdf"}, 
        {(char *)"oda", (BOOLEAN )0, (char *)"application/oda"}, 
        {(char *)"pbm", (BOOLEAN )0, (char *)"image/x-portable-bitmap"}, 
        {(char *)"pdb", (BOOLEAN )0, (char *)"chemical/x-pdb"}, 
        {(char *)"pdf", (BOOLEAN )0, (char *)"application/pdf"}, 
        {(char *)"pgm", (BOOLEAN )0, (char *)"image/x-portable-graymap"}, 
        {(char *)"pgn", (BOOLEAN )0, (char *)"application/x-chess-pgn"}, 
        {(char *)"png", (BOOLEAN )0, (char *)"image/png"}, 
        {(char *)"pnm", (BOOLEAN )0, (char *)"image/x-portable-anymap"}, 
        {(char *)"pot", (BOOLEAN )0, (char *)"application/mspowerpoint"}, 
        {(char *)"ppm", (BOOLEAN )0, (char *)"image/x-portable-pixmap"}, 
        {(char *)"pps", (BOOLEAN )0, (char *)"application/mspowerpoint"}, 
        {(char *)"ppt", (BOOLEAN )0, (char *)"application/mspowerpoint"}, 
        {(char *)"ppz", (BOOLEAN )0, (char *)"application/mspowerpoint"}, 
        {(char *)"pre", (BOOLEAN )0, (char *)"application/x-freelance"}, 
        {(char *)"proto", (BOOLEAN )0, (char *)"application/x-protobuf"}, 
        {(char *)"prt", (BOOLEAN )0, (char *)"application/pro_eng"}, 
        {(char *)"ps", (BOOLEAN )0, (char *)"application/postscript"}, 
        {(char *)"qt", (BOOLEAN )0, (char *)"video/quicktime"}, 
        {(char *)"ra", (BOOLEAN )0, (char *)"audio/x-realaudio"}, 
        {(char *)"ram", (BOOLEAN )0, (char *)"audio/x-pn-realaudio"}, 
        {(char *)"ras", (BOOLEAN )0, (char *)"image/cmu-raster"}, 
        {(char *)"rgb", (BOOLEAN )0, (char *)"image/x-rgb"}, 
        {(char *)"rm", (BOOLEAN )0, (char *)"audio/x-pn-realaudio"}, 
        {(char *)"roff", (BOOLEAN )0, (char *)"application/x-troff"}, 
        {(char *)"rpm", (BOOLEAN )0, (char *)"audio/x-pn-realaudio-plugin"}, 
        {(char *)"rtf", (BOOLEAN )0, (char *)"text/rtf"}, 
        {(char *)"rtx", (BOOLEAN )0, (char *)"text/richtext"}, 
        {(char *)"scm", (BOOLEAN )0, (char *)"application/x-lotusscreencam"}, 
        {(char *)"set", (BOOLEAN )0, (char *)"application/set"}, 
        {(char *)"sgm", (BOOLEAN )1, (char *)"text/sgml"}, 
        {(char *)"sgml", (BOOLEAN )1, (char *)"text/sgml"}, 
        {(char *)"sh", (BOOLEAN )0, (char *)"application/x-sh"}, 
        {(char *)"shar", (BOOLEAN )0, (char *)"application/x-shar"}, 
        {(char *)"silo", (BOOLEAN )0, (char *)"model/mesh"}, 
        {(char *)"sit", (BOOLEAN )0, (char *)"application/x-stuffit"}, 
        {(char *)"skd", (BOOLEAN )0, (char *)"application/x-koan"}, 
        {(char *)"skm", (BOOLEAN )0, (char *)"application/x-koan"}, 
        {(char *)"skp", (BOOLEAN )0, (char *)"application/x-koan"}, 
        {(char *)"skt", (BOOLEAN )0, (char *)"application/x-koan"}, 
        {(char *)"smi", (BOOLEAN )0, (char *)"application/smil"}, 
        {(char *)"smil", (BOOLEAN )0, (char *)"application/smil"}, 
        {(char *)"snd", (BOOLEAN )0, (char *)"audio/basic"}, 
        {(char *)"sol", (BOOLEAN )0, (char *)"application/solids"}, 
        {(char *)"spl", (BOOLEAN )0, (char *)"application/x-futuresplash"}, 
        {(char *)"src", (BOOLEAN )0, (char *)"application/x-wais-source"}, 
        {(char *)"step", (BOOLEAN )0, (char *)"application/STEP"}, 
        {(char *)"stl", (BOOLEAN )0, (char *)"application/SLA"}, 
        {(char *)"stp", (BOOLEAN )0, (char *)"application/STEP"}, 
        {(char *)"sv4cpio", (BOOLEAN )0, (char *)"application/x-sv4cpio"}, 
        {(char *)"sv4crc", (BOOLEAN )0, (char *)"application/x-sv4crc"}, 
        {(char *)"svg", (BOOLEAN )1, (char *)"image/svg+xml"}, 
        {(char *)"swf", (BOOLEAN )0, (char *)"application/x-shockwave-flash"}, 
        {(char *)"t", (BOOLEAN )0, (char *)"application/x-troff"}, 
        {(char *)"tar", (BOOLEAN )0, (char *)"application/x-tar"}, 
        {(char *)"tcl", (BOOLEAN )0, (char *)"application/x-tcl"}, 
        {(char *)"tex", (BOOLEAN )0, (char *)"application/x-tex"}, 
        {(char *)"texi", (BOOLEAN )0, (char *)"application/x-texinfo"}, 
        {(char *)"texinfo", (BOOLEAN )0, (char *)"application/x-texinfo"}, 
        {(char *)"tif", (BOOLEAN )0, (char *)"image/tiff"}, 
        {(char *)"tiff", (BOOLEAN )0, (char *)"image/tiff"}, 
        {(char *)"tr", (BOOLEAN )0, (char *)"application/x-troff"}, 
        {(char *)"tsi", (BOOLEAN )0, (char *)"audio/TSP-audio"}, 
        {(char *)"tsp", (BOOLEAN )0, (char *)"application/dsptype"}, 
        {(char *)"tsv", (BOOLEAN )1, (char *)"text/tab-separated-values"}, 
        {(char *)"txt", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"unv", (BOOLEAN )0, (char *)"application/i-deas"}, 
        {(char *)"ustar", (BOOLEAN )0, (char *)"application/x-ustar"}, 
        {(char *)"vcd", (BOOLEAN )0, (char *)"application/x-cdlink"}, 
        {(char *)"vda", (BOOLEAN )0, (char *)"application/vda"}, 
        {(char *)"viv", (BOOLEAN )0, (char *)"video/vnd.vivo"}, 
        {(char *)"vivo", (BOOLEAN )0, (char *)"video/vnd.vivo"}, 
        {(char *)"vrml", (BOOLEAN )0, (char *)"model/vrml"}, 
        {(char *)"wav", (BOOLEAN )0, (char *)"audio/x-wav"}, 
        {(char *)"wrl", (BOOLEAN )0, (char *)"model/vrml"}, 
        {(char *)"xbm", (BOOLEAN )0, (char *)"image/x-xbitmap"}, 
        {(char *)"xlc", (BOOLEAN )0, (char *)"application/vnd.ms-excel"}, 
        {(char *)"xll", (BOOLEAN )0, (char *)"application/vnd.ms-excel"}, 
        {(char *)"xlm", (BOOLEAN )0, (char *)"application/vnd.ms-excel"}, 
        {(char *)"xls", (BOOLEAN )0, (char *)"application/vnd.ms-excel"}, 
        {(char *)"xlw", (BOOLEAN )0, (char *)"application/vnd.ms-excel"}, 
        {(char *)"xml", (BOOLEAN )1, (char *)"text/xml"}, 
        {(char *)"xpm", (BOOLEAN )0, (char *)"image/x-xpixmap"}, 
        {(char *)"xwd", (BOOLEAN )0, (char *)"image/x-xwindowdump"}, 
        {(char *)"xyz", (BOOLEAN )0, (char *)"chemical/x-pdb"}, 
        {(char *)"yml", (BOOLEAN )1, (char *)"application/x-yaml"}, 
        {(char *)"zip", (BOOLEAN )0, (char *)"application/zip"}};
char *get_file_extension(char *file ) 
{ 
  char *dot ;
  char *tmp ;

  {
  tmp = strrchr((char const   *)file, '.');
  dot = tmp;
  if (! dot) {
    return ((char *)"");
  } else
  if ((unsigned long )dot == (unsigned long )file) {
    return ((char *)"");
  }
  return (dot + 1);
}
}
char *get_content_type(char *file ) 
{ 
  int i ;
  char *ext ;
  BOOLEAN tmp ;

  {
  ext = get_file_extension(file);
  i = 0;
  while (i < (int )sizeof(tmap) / (int )sizeof(tmap[0])) {
    tmp = strmatch(ext, (char *)tmap[i].ext);
    if (tmp) {
      return ((char *)tmap[i].type);
    }
    i ++;
  }
  return ((char *)tmap[0].type);
}
}
BOOLEAN is_ascii(char *file ) 
{ 
  int i ;
  char *ext ;
  BOOLEAN tmp ;

  {
  ext = get_file_extension(file);
  i = 0;
  while (i < (int )sizeof(tmap) / (int )sizeof(tmap[0])) {
    tmp = strmatch(ext, (char *)tmap[i].ext);
    if (tmp) {
      return ((BOOLEAN )tmap[i].ascii);
    }
    i ++;
  }
  return ((BOOLEAN )tmap[0].ascii);
}
}
void load_file(URL U , char *file ) 
{ 
  FILE *fp ;
  size_t len ;
  char *buf ;
  char *filename ;
  char mode[8] ;
  char const   *tmp___0 ;
  BOOLEAN tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  BOOLEAN tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  BOOLEAN tmp___7 ;

  {
  filename = trim(file);
  memset((void *)(mode), '\000', sizeof(mode));
  tmp___1 = is_ascii(filename);
  if (tmp___1) {
    tmp___0 = "r";
  } else {
    tmp___0 = "rb";
  }
  snprintf((char * __restrict  )(mode), sizeof(mode), (char const   * __restrict  )"%s",
           tmp___0);
  fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )(mode));
  if (! fp) {
    NOTIFY((LEVEL )2, "unable to open file: %s", filename);
    return;
  }
  fseek(fp, 0L, 2);
  tmp___2 = ftell(fp);
  len = (size_t )tmp___2;
  fseek(fp, 0L, 0);
  tmp___3 = xmalloc(len + 1UL);
  buf = (char *)tmp___3;
  tmp___5 = fread((void * __restrict  )buf, (size_t )1, len, (FILE * __restrict  )fp);
  if (tmp___5 == len) {
    tmp___4 = is_ascii(filename);
    if (tmp___4) {
      *(buf + len) = (char )'\000';
      trim(buf);
      len = strlen((char const   *)buf);
    }
  } else {
    NOTIFY((LEVEL )2, "unable to read file: %s", filename);
  }
  fclose(fp);
  if (len > 0UL) {
    tmp___7 = empty((char const   *)(my.conttype));
    if (tmp___7) {
      tmp___6 = get_content_type(filename);
      url_set_conttype(U, tmp___6);
    } else {
      url_set_conttype(U, my.conttype);
    }
    url_set_postdata(U, buf, len);
  }
  xfree((void *)buf);
  return;
}
}
void write_file(URL U , char *buf , size_t len ) 
{ 
  FILE *fp ;
  char mode[8] ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  memset((void *)(mode), '\000', sizeof(mode));
  tmp___1 = url_get_file(U);
  if (tmp___1) {
    tmp___0 = "w";
  } else {
    tmp___0 = "wb";
  }
  snprintf((char * __restrict  )(mode), sizeof(mode), (char const   * __restrict  )"%s",
           tmp___0);
  tmp___2 = url_get_file(U);
  fp = fopen((char const   * __restrict  )tmp___2, (char const   * __restrict  )(mode));
  if (fp) {
    fwrite((void const   * __restrict  )buf, len, (size_t )1, (FILE * __restrict  )fp);
  } else {
    NOTIFY((LEVEL )2, "unable to write to file");
  }
  fclose(fp);
  return;
}
}
#pragma merger("0","/tmp/cil-012lm4Nv.i","-W,-Wall,-Wunused-value,-g,-O2")
extern int puts(char const   *__s ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
void log_transaction(DATA D ) ;
void write_to_log(int count___0 , float elapsed , int bytes , float ttime , int code ,
                  int failed ) ;
void mark_log_file(char *message ) ;
BOOLEAN file_exists(char *file ) ;
BOOLEAN create_logfile(char const   *file ) ;
void log_transaction(DATA D ) 
{ 
  unsigned int tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  unsigned int tmp___3 ;

  {
  tmp = data_get_code(D);
  tmp___0 = data_get_total(D);
  tmp___1 = data_get_megabytes(D);
  tmp___2 = data_get_elapsed(D);
  tmp___3 = data_get_count(D);
  write_to_log((int )tmp___3, tmp___2, (int )tmp___1, tmp___0, (int )tmp, my.failed);
  return;
}
}
void write_to_log(int count___0 , float elapsed , int bytes , float ttime , int code ,
                  int failed ) 
{ 
  int fd ;
  char entry[512] ;
  struct tm keepsake ;
  struct tm *tmp ;
  time_t now ;
  size_t len ;
  char date[65] ;
  struct tm *tmp___0 ;
  char *tmp___1 ;
  BOOLEAN tmp___2 ;
  BOOLEAN tmp___3 ;
  size_t tmp___4 ;
  ssize_t tmp___5 ;
  int *tmp___6 ;

  {
  len = (size_t )0;
  now = time((time_t *)((void *)0));
  tmp___0 = localtime_r((time_t const   * __restrict  )(& now), (struct tm * __restrict  )(& keepsake));
  tmp = tmp___0;
  setlocale(2, "C");
  len = strftime((char * __restrict  )(date), sizeof(date), (char const   * __restrict  )"%Y-%m-%d %H:%M:%S",
                 (struct tm  const  * __restrict  )tmp);
  if (my.shlog) {
    printf((char const   * __restrict  )"LOG FILE: %s\n", my.logfile);
    printf((char const   * __restrict  )"You can disable this log file notification by editing\n");
    tmp___1 = getenv("HOME");
    printf((char const   * __restrict  )"%s/.siege/siege.conf ", tmp___1);
    puts("and changing \'show-logfile\' to false.");
  }
  tmp___3 = file_exists(my.logfile);
  if (! tmp___3) {
    tmp___2 = create_logfile((char const   *)(my.logfile));
    if (! tmp___2) {
      NOTIFY((LEVEL )2, "unable to create log file: %s", my.logfile);
      return;
    }
  }
  snprintf((char * __restrict  )(entry), sizeof(entry), (char const   * __restrict  )"%s,%7d,%11.2f,%12u,%11.2f,%12.2f,%12.2f,%12.2f,%8d,%8d\n",
           date, count___0, (double )elapsed, bytes, (double )(ttime / (float )count___0),
           (double )((float )count___0 / elapsed), (double )((float )bytes / elapsed),
           (double )(ttime / elapsed), code, failed);
  fd = open((char const   *)(my.logfile), 1025, 420);
  if (fd < 0) {
    NOTIFY((LEVEL )2, "Unable to open file: %s", my.logfile);
    return;
  }
  tmp___4 = strlen((char const   *)(entry));
  tmp___5 = write(fd, (void const   *)(entry), tmp___4);
  len = (size_t )tmp___5;
  if (len == 4294967295UL) {
    tmp___6 = __errno_location();
    switch (*tmp___6) {
    case 9: 
    NOTIFY((LEVEL )2, "Unable to write to log file (bad file descriptor): %s", my.logfile);
    break;
    case 4: 
    NOTIFY((LEVEL )2, "Unable to write to log file (system interrupt): %s", my.logfile);
    break;
    default: 
    NOTIFY((LEVEL )2, "Unable to write to log file (unknown error): %s", my.logfile);
    break;
    }
  }
  close(fd);
  return;
}
}
void mark_log_file(char *message ) 
{ 
  int fd ;
  size_t len ;
  char entry[512] ;
  BOOLEAN tmp ;
  BOOLEAN tmp___0 ;
  size_t tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;

  {
  tmp___0 = file_exists(my.logfile);
  if (! tmp___0) {
    tmp = create_logfile((char const   *)(my.logfile));
    if (! tmp) {
      NOTIFY((LEVEL )2, "unable to create log file: %s", my.logfile);
      return;
    }
  }
  snprintf((char * __restrict  )(entry), sizeof(entry), (char const   * __restrict  )"**** %s ****\n",
           message);
  fd = open((char const   *)(my.logfile), 1025, 420);
  if (fd < 0) {
    NOTIFY((LEVEL )2, "Unable to write to file: %s", my.logfile);
  }
  tmp___1 = strlen((char const   *)(entry));
  tmp___2 = write(fd, (void const   *)(entry), tmp___1);
  len = (size_t )tmp___2;
  if (len == 4294967295UL) {
    tmp___3 = __errno_location();
    switch (*tmp___3) {
    case 9: 
    NOTIFY((LEVEL )2, "Unable to mark log file (bad file descriptor): %s", my.logfile);
    break;
    case 4: 
    NOTIFY((LEVEL )2, "Unable to mark log file (system interrupt): %s", my.logfile);
    break;
    default: 
    NOTIFY((LEVEL )2, "Unable to mark log file (unknown error): %s", my.logfile);
    break;
    }
  }
  close(fd);
  return;
}
}
BOOLEAN file_exists(char *file ) 
{ 
  int fd ;

  {
  fd = open((char const   *)file, 0);
  if (fd < 0) {
    close(fd);
    return ((BOOLEAN )0);
  } else {
    close(fd);
    return ((BOOLEAN )1);
  }
  return ((BOOLEAN )0);
}
}
BOOLEAN create_logfile(char const   *file ) 
{ 
  int fd ;
  size_t len ;
  BOOLEAN ret ;
  char *head ;
  size_t tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;

  {
  len = (size_t )0;
  ret = (BOOLEAN )1;
  head = (char *)"      Date & Time,  Trans,  Elap Time,  Data Trans,  Resp Time,  Trans Rate,  Throughput,  Concurrent,    OKAY,   Failed\n";
  fd = open(file, 65, 420);
  if (fd < 0) {
    return ((BOOLEAN )0);
  }
  tmp = strlen((char const   *)head);
  tmp___0 = write(fd, (void const   *)head, tmp);
  len = (size_t )tmp___0;
  if (len == 4294967295UL) {
    ret = (BOOLEAN )0;
    tmp___1 = __errno_location();
    switch (*tmp___1) {
    case 9: 
    NOTIFY((LEVEL )2, "Unable to create log file (bad file descriptor): %s", my.logfile);
    break;
    case 4: 
    NOTIFY((LEVEL )2, "Unable to create log file (system interrupt): %s", my.logfile);
    break;
    default: 
    NOTIFY((LEVEL )2, "Unable to create log file (unknown error): %s", my.logfile);
    break;
    }
  }
  close(fd);
  return (ret);
}
}
#pragma merger("0","/tmp/cil-L6v0wma9.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_init)(pthread_attr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_setscope)(pthread_attr_t *__attr ,
                                                                                                  int __scope ) ;
extern unsigned int sleep(unsigned int __seconds ) ;
extern char *optarg ;
extern int optind ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
size_t URLSIZE ;
void display_version(BOOLEAN b ) ;
struct CONFIG my  ;
void siege_timer(pthread_t handler ) ;
char *uppercase(char *s , size_t len ) ;
void SSL_thread_setup(void) ;
void SSL_thread_cleanup(void) ;
char const   *program_name ;
char const   *copyright ;
extern int getopt_long(int __argc , char * const  *__argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
static struct option long_options[25]  = 
  {      {"version", 0, (int *)((void *)0), 'V'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"config", 0, (int *)((void *)0), 'C'}, 
        {"debug", 0, (int *)((void *)0), 'D'}, 
        {"get", 0, (int *)((void *)0), 'g'}, 
        {"print", 0, (int *)((void *)0), 'p'}, 
        {"concurrent", 1, (int *)((void *)0), 'c'}, 
        {"no-parser", 0, (int *)((void *)0), 'N'}, 
        {"no-follow", 0, (int *)((void *)0), 'F'}, 
        {"internet", 0, (int *)((void *)0), 'i'}, 
        {"benchmark", 0, (int *)((void *)0), 'b'}, 
        {"reps", 1, (int *)((void *)0), 'r'}, 
        {"time", 1, (int *)((void *)0), 't'}, 
        {"delay", 1, (int *)((void *)0), 'd'}, 
        {"log", 2, (int *)((void *)0), 'l'}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"rc", 1, (int *)((void *)0), 'R'}, 
        {"mark", 1, (int *)((void *)0), 'm'}, 
        {"header", 1, (int *)((void *)0), 'H'}, 
        {"user-agent", 1, (int *)((void *)0), 'A'}, 
        {"content-type", 1, (int *)((void *)0), 'T'}, 
        {"json-output", 0, (int *)((void *)0), 'j'}, 
        {(char const   *)0, 0, (int *)0, 0}};
void display_version(BOOLEAN b ) 
{ 
  char name[128] ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;

  {
  memset((void *)(name), 0, sizeof(name));
  tmp = strlen((char const   *)program_name);
  strncpy((char * __restrict  )(name), (char const   * __restrict  )program_name,
          tmp);
  if (my.debug) {
    tmp___0 = strlen((char const   *)(name));
    tmp___1 = uppercase(name, tmp___0);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s %s: debugging enabled\n\n%s\n",
            tmp___1, version_string, copyright);
  } else
  if ((unsigned int )b == 1U) {
    tmp___2 = strlen((char const   *)(name));
    tmp___3 = uppercase(name, tmp___2);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s %s\n\n%s\n",
            tmp___3, version_string, copyright);
    exit(0);
  } else {
    tmp___4 = strlen((char const   *)(name));
    tmp___5 = uppercase(name, tmp___4);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s %s\n", tmp___5,
            version_string);
  }
  return;
}
}
void display_help(void) 
{ 


  {
  display_version((BOOLEAN )0);
  printf((char const   * __restrict  )"Usage: %s [options]\n", program_name);
  printf((char const   * __restrict  )"       %s [options] URL\n", program_name);
  printf((char const   * __restrict  )"       %s -g URL\n", program_name);
  printf((char const   * __restrict  )"Options:\n");
  puts("  -V, --version             VERSION, prints the version number.");
  puts("  -h, --help                HELP, prints this section.");
  puts("  -C, --config              CONFIGURATION, show the current config.");
  puts("  -v, --verbose             VERBOSE, prints notification to screen.");
  puts("  -q, --quiet               QUIET turns verbose off and suppresses output.");
  puts("  -g, --get                 GET, pull down HTTP headers and display the");
  puts("                            transaction. Great for application debugging.");
  puts("  -p, --print               PRINT, like GET only it prints the entire page.");
  puts("  -c, --concurrent=NUM      CONCURRENT users, default is 10");
  puts("  -r, --reps=NUM            REPS, number of times to run the test.");
  puts("  -t, --time=NUMm           TIMED testing where \"m\" is modifier S, M, or H");
  puts("                            ex: --time=1H, one hour test.");
  puts("  -d, --delay=NUM           Time DELAY, random delay before each request");
  puts("  -b, --benchmark           BENCHMARK: no delays between requests.");
  puts("  -i, --internet            INTERNET user simulation, hits URLs randomly.");
  puts("  -f, --file=FILE           FILE, select a specific URLS FILE.");
  printf((char const   * __restrict  )"  -R, --rc=FILE             RC, specify an %src file\n",
         program_name);
  puts("  -l, --log[=FILE]          LOG to FILE. If FILE is not specified, the");
  printf((char const   * __restrict  )"                            default is used: PREFIX/var/%s.log\n",
         program_name);
  puts("  -m, --mark=\"text\"         MARK, mark the log file with a string.");
  puts("                            between .001 and NUM. (NOT COUNTED IN STATS)");
  puts("  -H, --header=\"text\"       Add a header to request (can be many)");
  puts("  -A, --user-agent=\"text\"   Sets User-Agent in request");
  puts("  -T, --content-type=\"text\" Sets Content-Type in request");
  puts("  -j, --json-output         JSON OUTPUT, print final stats to stdout as JSON");
  puts("      --no-parser           NO PARSER, turn off the HTML page parser");
  puts("      --no-follow           NO FOLLOW, do not follow HTTP redirects");
  puts("");
  puts((char const   *)copyright);
  exit(0);
}
}
void parse_rc_cmdline(int argc , char **argv ) 
{ 
  int a ;

  {
  a = 0;
  strcpy((char * __restrict  )(my.rc), (char const   * __restrict  )"");
  while (a > -1) {
    a = getopt_long(argc, (char * const  *)argv, "VhvqCDNFpgl::ibr:t:f:d:c:m:H:R:A:T:j",
                    (struct option  const  *)(long_options), (int *)0);
    if (a == 82) {
      strcpy((char * __restrict  )(my.rc), (char const   * __restrict  )optarg);
      a = -1;
    }
  }
  optind = 0;
  return;
}
}
void parse_cmdline(int argc , char **argv ) 
{ 
  int c ;
  int nargs ;
  double tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  BOOLEAN tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  c = 0;
  while (1) {
    c = getopt_long(argc, (char * const  *)argv, "VhvqCDNFpgl::ibr:t:f:d:c:m:H:R:A:T:j",
                    (struct option  const  *)(long_options), (int *)0);
    if (! (c != -1)) {
      break;
    }
    switch (c) {
    case 86: 
    display_version((BOOLEAN )1);
    break;
    case 104: 
    display_help();
    exit(0);
    case 68: 
    my.debug = (BOOLEAN )1;
    break;
    case 67: 
    my.config = (BOOLEAN )1;
    my.get = (BOOLEAN )0;
    break;
    case 99: 
    my.cusers = atoi((char const   *)optarg);
    break;
    case 105: 
    my.internet = (BOOLEAN )1;
    break;
    case 98: 
    my.bench = (BOOLEAN )1;
    break;
    case 100: 
    tmp = atof((char const   *)optarg);
    my.delay = (float )tmp;
    if (my.delay < (float )0) {
      my.delay = (float )0;
    }
    break;
    case 103: 
    my.get = (BOOLEAN )1;
    break;
    case 112: 
    my.print = (BOOLEAN )1;
    my.cusers = 1;
    my.reps = 1;
    break;
    case 108: 
    my.logging = (BOOLEAN )1;
    if (optarg) {
      tmp___0 = strlen((char const   *)optarg);
      my.logfile[tmp___0] = (char )'\000';
      tmp___1 = strlen((char const   *)optarg);
      strncpy((char * __restrict  )(my.logfile), (char const   * __restrict  )optarg,
              tmp___1);
    }
    break;
    case 109: 
    my.mark = (BOOLEAN )1;
    my.markstr = optarg;
    my.logging = (BOOLEAN )1;
    break;
    case 113: 
    my.quiet = (BOOLEAN )1;
    break;
    case 118: 
    my.verbose = (BOOLEAN )1;
    break;
    case 114: 
    tmp___2 = strmatch(optarg, (char *)"once");
    if (tmp___2) {
      my.reps = -1;
    } else {
      my.reps = atoi((char const   *)optarg);
    }
    break;
    case 116: 
    parse_time(optarg);
    break;
    case 102: 
    memset((void *)(my.file), 0, sizeof(my.file));
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
      break;
    }
    tmp___3 = strlen((char const   *)optarg);
    strncpy((char * __restrict  )(my.file), (char const   * __restrict  )optarg, tmp___3);
    break;
    case 65: 
    strncpy((char * __restrict  )(my.uagent), (char const   * __restrict  )optarg,
            (size_t )255);
    break;
    case 84: 
    strncpy((char * __restrict  )(my.conttype), (char const   * __restrict  )optarg,
            (size_t )255);
    break;
    case 78: 
    my.parser = (BOOLEAN )0;
    break;
    case 70: 
    my.follow = (BOOLEAN )0;
    break;
    case 82: 
    break;
    case 72: 
    tmp___4 = strchr((char const   *)optarg, ':');
    if (! tmp___4) {
      NOTIFY((LEVEL )3, "no \':\' in http-header");
    }
    tmp___5 = strlen((char const   *)optarg);
    tmp___6 = strlen((char const   *)(my.extra));
    if ((tmp___5 + tmp___6) + 3UL > 2048UL) {
      NOTIFY((LEVEL )3, "header is too large");
    }
    strcat((char * __restrict  )(my.extra), (char const   * __restrict  )optarg);
    strcat((char * __restrict  )(my.extra), (char const   * __restrict  )"\r\n");
    break;
    case 106: 
    my.json_output = (BOOLEAN )1;
    break;
    }
  }
  nargs = argc - optind;
  if (nargs) {
    my.url = xstrdup((char const   *)*(argv + (argc - 1)));
  }
  if (my.get) {
    if ((unsigned long )my.url == (unsigned long )((void *)0)) {
      puts("ERROR: -g/--get requires a commandline URL");
      exit(1);
    }
  }
  return;
}
}
static void __signal_setup(void) 
{ 
  sigset_t sigs ;

  {
  sigemptyset(& sigs);
  sigaddset(& sigs, 1);
  sigaddset(& sigs, 2);
  sigaddset(& sigs, 14);
  sigaddset(& sigs, 15);
  sigaddset(& sigs, 13);
  sigprocmask(0, (sigset_t const   * __restrict  )(& sigs), (sigset_t * __restrict  )((void *)0));
  return;
}
}
static void __config_setup(int argc , char **argv ) 
{ 
  int tmp ;
  char const   *tmp___0 ;

  {
  memset((void *)(& my), '\000', sizeof(struct CONFIG ));
  parse_rc_cmdline(argc, argv);
  tmp = init_config();
  if (tmp < 0) {
    exit(1);
  }
  parse_cmdline(argc, argv);
  ds_module_check();
  if (my.config) {
    show_config(1);
  }
  if (my.cusers > my.limit) {
    printf((char const   * __restrict  )"\n");
    printf((char const   * __restrict  )"================================================================\n");
    if (my.limit > 999) {
      tmp___0 = " ";
    } else {
      tmp___0 = "  ";
    }
    printf((char const   * __restrict  )"WARNING: The number of users is capped at %d.%sTo increase this\n",
           my.limit, tmp___0);
    printf((char const   * __restrict  )"         limit, search your .siegerc file for \'limit\' and change\n");
    printf((char const   * __restrict  )"         its value. Make sure you read the instructions there...\n");
    printf((char const   * __restrict  )"================================================================\n");
    sleep(10U);
    my.cusers = my.limit;
  }
  return;
}
}
static LINES *__urls_setup(void) 
{ 
  LINES *lines ;
  void *tmp ;

  {
  tmp = xcalloc((size_t )1, sizeof(LINES ));
  lines = (LINES *)tmp;
  lines->index = 0;
  lines->line = (char **)((void *)0);
  if ((unsigned long )my.url != (unsigned long )((void *)0)) {
    my.length = 1;
  } else {
    my.length = read_cfg_file(lines, my.file);
  }
  if (my.length == 0) {
    display_help();
  }
  return (lines);
}
}
int main(int argc , char **argv ) 
{ 
  int i ;
  int j ;
  int result ;
  void *status ;
  LINES *lines ;
  CREW crew ;
  DATA data ;
  HASH cookies ;
  ARRAY urls ;
  ARRAY tmp ;
  ARRAY browsers ;
  ARRAY tmp___0 ;
  pthread_t cease ;
  pthread_t timer ;
  pthread_attr_t scope_attr ;
  URL tmp___1 ;
  URL tmp___2 ;
  METHOD tmp___3 ;
  METHOD tmp___4 ;
  URL tmp___5 ;
  URL tmp___6 ;
  char tmp___7[4096] ;
  BROWSER B ;
  BROWSER tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  int n_urls ;
  size_t tmp___11 ;
  int per_user ;
  int remainder ;
  int begin_url ;
  int tmp___12 ;
  int end_url ;
  int tmp___13 ;
  ARRAY url_slice ;
  ARRAY tmp___14 ;
  URL u ;
  void *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  BROWSER B___0 ;
  void *tmp___19 ;
  BOOLEAN tmp___20 ;
  BOOLEAN tmp___21 ;
  BROWSER B___1 ;
  void *tmp___22 ;
  unsigned long tmp___23 ;
  unsigned long long tmp___24 ;
  float tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  float tmp___29 ;
  float tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  double tmp___41 ;
  unsigned int tmp___42 ;
  float tmp___43 ;
  float tmp___44 ;
  float tmp___45 ;
  float tmp___46 ;
  float tmp___47 ;
  float tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  float tmp___51 ;
  float tmp___52 ;
  unsigned int tmp___53 ;
  double availability ;
  unsigned int tmp___54 ;
  unsigned int tmp___55 ;
  unsigned int tmp___56 ;
  float tmp___57 ;
  float tmp___58 ;
  float tmp___59 ;
  float tmp___60 ;
  float tmp___61 ;
  float tmp___62 ;
  unsigned int tmp___63 ;
  unsigned int tmp___64 ;
  float tmp___65 ;
  float tmp___66 ;

  {
  result = 0;
  status = (void *)0;
  lines = (LINES *)((void *)0);
  crew = (CREW )((void *)0);
  data = (DATA )((void *)0);
  cookies = (HASH )((void *)0);
  tmp = new_array();
  urls = tmp;
  tmp___0 = new_array();
  browsers = tmp___0;
  __signal_setup();
  __config_setup(argc, argv);
  lines = __urls_setup();
  pthread_attr_init(& scope_attr);
  pthread_attr_setscope(& scope_attr, 0);
  SSL_thread_setup();
  if ((unsigned long )my.url != (unsigned long )((void *)0)) {
    tmp___2 = new_url(my.url);
    tmp___1 = tmp___2;
    url_set_ID(tmp___1, 0);
    if (my.get) {
      tmp___3 = url_get_method(tmp___1);
      if ((unsigned int )tmp___3 != 3U) {
        tmp___4 = url_get_method(tmp___1);
        if ((unsigned int )tmp___4 != 4U) {
          url_set_method(tmp___1, my.method);
        }
      }
    }
    array_npush(urls, (void *)tmp___1, URLSIZE);
  } else {
    i = 0;
    while (i < my.length) {
      tmp___6 = new_url(*(lines->line + i));
      tmp___5 = tmp___6;
      url_set_ID(tmp___5, i);
      array_npush(urls, (void *)tmp___5, URLSIZE);
      i ++;
    }
  }
  cookies = load_cookies(my.cookies);
  i = 0;
  while (i < my.cusers) {
    tmp___8 = new_browser(i);
    B = tmp___8;
    memset((void *)(tmp___7), '\000', sizeof(tmp___7));
    snprintf((char * __restrict  )(tmp___7), (size_t )4096, (char const   * __restrict  )"%d",
             i);
    if ((unsigned long )cookies != (unsigned long )((void *)0)) {
      tmp___10 = hash_get(cookies, tmp___7);
      if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
        tmp___9 = hash_get(cookies, tmp___7);
        browser_set_cookies(B, (HASH )tmp___9);
      }
    }
    if (my.reps > 0) {
      browser_set_urls(B, urls);
    } else {
      tmp___11 = array_length(urls);
      n_urls = (int )tmp___11;
      per_user = n_urls / my.cusers;
      remainder = n_urls % my.cusers;
      if (i < remainder) {
        tmp___12 = i;
      } else {
        tmp___12 = remainder;
      }
      begin_url = i * per_user + tmp___12;
      if (i < remainder) {
        tmp___13 = i + 1;
      } else {
        tmp___13 = remainder;
      }
      end_url = (i + 1) * per_user + tmp___13;
      tmp___14 = new_array();
      url_slice = tmp___14;
      j = begin_url;
      while (1) {
        if (j < end_url) {
          if (! (j < n_urls)) {
            break;
          }
        } else {
          break;
        }
        tmp___15 = array_get(urls, j);
        u = (URL )tmp___15;
        if ((unsigned long )u != (unsigned long )((void *)0)) {
          tmp___16 = url_get_hostname(u);
          if ((unsigned long )tmp___16 != (unsigned long )((void *)0)) {
            tmp___17 = url_get_hostname(u);
            tmp___18 = strlen((char const   *)tmp___17);
            if (tmp___18 > 1UL) {
              array_npush(url_slice, (void *)u, URLSIZE);
            }
          }
        }
        j ++;
      }
      browser_set_urls(B, url_slice);
    }
    array_npush(browsers, (void *)B, BROWSERSIZE);
    i ++;
  }
  crew = new_crew(my.cusers, my.cusers, (BOOLEAN )0);
  if ((unsigned long )crew == (unsigned long )((void *)0)) {
    NOTIFY((LEVEL )3, "unable to allocate memory for %d simulated browser", my.cusers);
  }
  result = pthread_create((pthread_t * __restrict  )(& cease), (pthread_attr_t const   * __restrict  )((void *)0),
                          (void *(*)(void * ))((void *)(& sig_handler)), (void * __restrict  )((void *)crew));
  if (result < 0) {
    NOTIFY((LEVEL )3, "failed to create handler: %d\n", result);
  }
  if (my.secs > 0) {
    result = pthread_create((pthread_t * __restrict  )(& timer), (pthread_attr_t const   * __restrict  )((void *)0),
                            (void *(*)(void * ))((void *)(& siege_timer)), (void * __restrict  )((void *)cease));
    if (result < 0) {
      NOTIFY((LEVEL )3, "failed to create handler: %d\n", result);
    }
  }
  if (! my.get) {
    if (! my.quiet) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"** ");
      display_version((BOOLEAN )0);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"** Preparing %d concurrent users for battle.\n",
              my.cusers);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"The server is now under siege...");
      if (my.verbose) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
      }
    }
  }
  data = new_data();
  data_set_start(data);
  i = 0;
  while (1) {
    if (i < my.cusers) {
      tmp___21 = crew_get_shutdown(crew);
      if (! ((unsigned int )tmp___21 != 1U)) {
        break;
      }
    } else {
      break;
    }
    tmp___19 = array_get(browsers, i);
    B___0 = (BROWSER )tmp___19;
    tmp___20 = crew_add(crew, (void (*)())((void *)(& start)), (void *)B___0);
    result = (int )tmp___20;
    if (result == 0) {
      my.verbose = (BOOLEAN )0;
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unable to spawn additional threads; you may need to\n");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"upgrade your libraries or tune your system in order\n");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"to exceed %d users.\n",
              my.cusers);
      NOTIFY((LEVEL )3, "system resources exhausted");
    }
    i ++;
  }
  crew_join(crew, (BOOLEAN )1, & status);
  data_set_stop(data);
  SSL_thread_cleanup();
  i = 0;
  while (1) {
    tmp___35 = crew_get_total(crew);
    if (tmp___35 > my.cusers) {
      tmp___34 = my.cusers;
    } else {
      tmp___36 = crew_get_total(crew);
      if (tmp___36 == 0) {
        tmp___34 = my.cusers;
      } else {
        tmp___33 = crew_get_total(crew);
        tmp___34 = tmp___33;
      }
    }
    if (! (i < tmp___34)) {
      break;
    }
    tmp___22 = array_get(browsers, i);
    B___1 = (BROWSER )tmp___22;
    tmp___23 = browser_get_hits(B___1);
    data_increment_count(data, tmp___23);
    tmp___24 = browser_get_bytes(B___1);
    data_increment_bytes(data, (unsigned long )tmp___24);
    tmp___25 = browser_get_time(B___1);
    data_increment_total(data, tmp___25);
    tmp___26 = browser_get_code(B___1);
    data_increment_code(data, (int )tmp___26);
    tmp___27 = browser_get_okay(B___1);
    data_increment_okay(data, (int )tmp___27);
    tmp___28 = browser_get_fail(B___1);
    data_increment_fail(data, (int )tmp___28);
    tmp___29 = browser_get_himark(B___1);
    data_set_highest(data, tmp___29);
    tmp___30 = browser_get_lomark(B___1);
    data_set_lowest(data, tmp___30);
    i ++;
  }
  crew_destroy(crew);
  pthread_usleep_np(10000UL);
  if (! my.quiet) {
    if (my.failures > 0) {
      if (my.failed >= my.failures) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s aborted due to excessive socket failure; you\n",
                program_name);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"can change the failure threshold in $HOME/.%src\n",
                program_name);
      }
    }
    tmp___37 = data_get_count(data);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nTransactions:\t\t%12u hits\n",
            tmp___37);
    tmp___42 = data_get_count(data);
    if (tmp___42 == 0U) {
      tmp___41 = (double )0;
    } else {
      tmp___39 = data_get_count(data);
      tmp___40 = data_get_count(data);
      tmp___41 = ((double )tmp___39 / (double )(tmp___40 + (unsigned int )my.failed)) * (double )100;
    }
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Availability:\t\t%12.2f %%\n",
            tmp___41);
    tmp___43 = data_get_elapsed(data);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Elapsed time:\t\t%12.2f secs\n",
            (double )tmp___43);
    tmp___44 = data_get_megabytes(data);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Data transferred:\t%12.2f MB\n",
            (double )tmp___44);
    tmp___45 = data_get_response_time(data);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Response time:\t\t%12.2f secs\n",
            (double )tmp___45);
    tmp___46 = data_get_transaction_rate(data);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Transaction rate:\t%12.2f trans/sec\n",
            (double )tmp___46);
    tmp___47 = data_get_throughput(data);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Throughput:\t\t%12.2f MB/sec\n",
            (double )tmp___47);
    tmp___48 = data_get_concurrency(data);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Concurrency:\t\t%12.2f\n",
            (double )tmp___48);
    tmp___49 = data_get_code(data);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Successful transactions:%12u\n",
            tmp___49);
    if (my.debug) {
      tmp___50 = data_get_okay(data);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"HTTP OK received:\t%12u\n",
              tmp___50);
    }
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed transactions:\t%12u\n",
            my.failed);
    tmp___51 = data_get_highest(data);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Longest transaction:\t%12.2f\n",
            (double )tmp___51);
    tmp___52 = data_get_lowest(data);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Shortest transaction:\t%12.2f\n",
            (double )tmp___52);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" \n");
  }
  if (my.json_output) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    printf((char const   * __restrict  )"{\n");
    tmp___53 = data_get_count(data);
    printf((char const   * __restrict  )"\t\"transactions\":\t\t\t%12u,\n", tmp___53);
    tmp___56 = data_get_count(data);
    if (tmp___56 == 0U) {
      availability = (double )0;
    } else {
      tmp___54 = data_get_count(data);
      tmp___55 = data_get_count(data);
      availability = ((double )tmp___54 / (double )(tmp___55 + (unsigned int )my.failed)) * (double )100;
    }
    printf((char const   * __restrict  )"\t\"availability\":\t\t\t%12.2f,\n", availability);
    tmp___57 = data_get_elapsed(data);
    printf((char const   * __restrict  )"\t\"elapsed_time\":\t\t\t%12.2f,\n", (double )tmp___57);
    tmp___58 = data_get_megabytes(data);
    printf((char const   * __restrict  )"\t\"data_transferred\":\t\t%12.2f,\n", (double )tmp___58);
    tmp___59 = data_get_response_time(data);
    printf((char const   * __restrict  )"\t\"response_time\":\t\t%12.2f,\n", (double )tmp___59);
    tmp___60 = data_get_transaction_rate(data);
    printf((char const   * __restrict  )"\t\"transaction_rate\":\t\t%12.2f,\n", (double )tmp___60);
    tmp___61 = data_get_throughput(data);
    printf((char const   * __restrict  )"\t\"throughput\":\t\t\t%12.2f,\n", (double )tmp___61);
    tmp___62 = data_get_concurrency(data);
    printf((char const   * __restrict  )"\t\"concurrency\":\t\t\t%12.2f,\n", (double )tmp___62);
    tmp___63 = data_get_code(data);
    printf((char const   * __restrict  )"\t\"successful_transactions\":\t%12u,\n",
           tmp___63);
    if (my.debug) {
      tmp___64 = data_get_okay(data);
      printf((char const   * __restrict  )"\t\"http_ok_received\":\t\t%12u,\n", tmp___64);
    }
    printf((char const   * __restrict  )"\t\"failed_transactions\":\t\t%12u,\n", my.failed);
    tmp___65 = data_get_highest(data);
    printf((char const   * __restrict  )"\t\"longest_transaction\":\t\t%12.2f,\n",
           (double )tmp___65);
    tmp___66 = data_get_lowest(data);
    printf((char const   * __restrict  )"\t\"shortest_transaction\":\t\t%12.2f\n",
           (double )tmp___66);
    puts("}");
  }
  if (my.mark) {
    mark_log_file(my.markstr);
  }
  if (my.logging) {
    log_transaction(data);
    if (my.failures > 0) {
      if (my.failed >= my.failures) {
        mark_log_file((char *)"siege aborted due to excessive socket failure.");
      }
    }
  }
  data = data_destroy(data);
  urls = array_destroyer(urls, (void (*)(void *v ))((void *)(& url_destroy)));
  browsers = array_destroyer(browsers, (void (*)(void *v ))((void *)(& browser_destroy)));
  cookies = hash_destroy(cookies);
  my.cookies = cookies_destroy(my.cookies);
  if ((unsigned long )my.url == (unsigned long )((void *)0)) {
    i = 0;
    while (i < my.length) {
      xfree((void *)*(lines->line + i));
      i ++;
    }
    xfree((void *)lines->line);
    xfree((void *)lines);
  } else {
    xfree((void *)lines->line);
    xfree((void *)lines);
  }
  exit(0);
}
}
#pragma merger("0","/tmp/cil-zYwqahzT.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) ;
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
int md5_stream(FILE *stream , void *resblock ) ;
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) ;
static unsigned char const   fillbuf[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
void md5_init_ctx(struct md5_ctx *ctx ) 
{ 
  md5_uint32 tmp ;

  {
  ctx->A = (md5_uint32 )1732584193;
  ctx->B = 4023233417U;
  ctx->C = 2562383102U;
  ctx->D = (md5_uint32 )271733878;
  tmp = (md5_uint32 )0;
  ctx->total[1] = tmp;
  ctx->total[0] = tmp;
  ctx->buflen = (md5_uint32 )0;
  return;
}
}
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) 
{ 
  md5_uint32 buffer[4] ;

  {
  buffer[0] = (md5_uint32 )ctx->A;
  buffer[1] = (md5_uint32 )ctx->B;
  buffer[2] = (md5_uint32 )ctx->C;
  buffer[3] = (md5_uint32 )ctx->D;
  memcpy((void * __restrict  )resbuf, (void const   * __restrict  )(buffer), (size_t )16);
  return (resbuf);
}
}
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) 
{ 
  md5_uint32 bytes ;
  md5_uint32 swap_bytes ;
  size_t pad ;
  void *tmp ;

  {
  bytes = ctx->buflen;
  ctx->total[0] += bytes;
  if (ctx->total[0] < bytes) {
    (ctx->total[1]) ++;
  }
  if (bytes >= 56U) {
    pad = (size_t )(120U - bytes);
  } else {
    pad = (size_t )(56U - bytes);
  }
  memcpy((void * __restrict  )(& ctx->buffer[bytes]), (void const   * __restrict  )(fillbuf),
         pad);
  swap_bytes = ctx->total[0] << 3;
  memcpy((void * __restrict  )(& ctx->buffer[(size_t )bytes + pad]), (void const   * __restrict  )(& swap_bytes),
         sizeof(swap_bytes));
  swap_bytes = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
  memcpy((void * __restrict  )(& ctx->buffer[((size_t )bytes + pad) + 4UL]), (void const   * __restrict  )(& swap_bytes),
         sizeof(swap_bytes));
  md5_process_block((void const   *)(ctx->buffer), ((size_t )bytes + pad) + 8UL, ctx);
  tmp = md5_read_ctx((struct md5_ctx  const  *)ctx, resbuf);
  return (tmp);
}
}
int md5_stream(FILE *stream , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int tmp ;

  {
  md5_init_ctx(& ctx);
  while (1) {
    sum = (size_t )0;
    while (1) {
      n = fread((void * __restrict  )(buffer + sum), (size_t )1, 4096UL - sum, (FILE * __restrict  )stream);
      sum += n;
      if (sum < 4096UL) {
        if (! (n != 0UL)) {
          break;
        }
      } else {
        break;
      }
    }
    if (n == 0UL) {
      tmp = ferror(stream);
      if (tmp) {
        return (1);
      }
    }
    if (n == 0UL) {
      break;
    }
    md5_process_block((void const   *)(buffer), (size_t )4096, & ctx);
  }
  if (sum > 0UL) {
    md5_process_bytes((void const   *)(buffer), sum, & ctx);
  }
  md5_finish_ctx(& ctx, resblock);
  return (0);
}
}
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  void *tmp ;

  {
  md5_init_ctx(& ctx);
  md5_process_bytes((void const   *)buffer, len, & ctx);
  tmp = md5_finish_ctx(& ctx, resblock);
  return (tmp);
}
}
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;

  {
  if (ctx->buflen != 0U) {
    left_over = (size_t )ctx->buflen;
    if (128UL - left_over > len) {
      tmp = len;
    } else {
      tmp = 128UL - left_over;
    }
    add = tmp;
    memcpy((void * __restrict  )(& ctx->buffer[left_over]), (void const   * __restrict  )buffer,
           add);
    ctx->buflen = (md5_uint32 )((size_t )ctx->buflen + add);
    if (left_over + add > 64UL) {
      md5_process_block((void const   *)(ctx->buffer), (left_over + add) & 0xffffffffffffffc0UL,
                        ctx);
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )(& ctx->buffer[(left_over + add) & 0xffffffffffffffc0UL]),
             (left_over + add) & 63UL);
      ctx->buflen = (md5_uint32 )((left_over + add) & 63UL);
    }
    buffer = (void const   *)((char const   *)buffer + add);
    len -= add;
  }
  if (len > 64UL) {
    if ((md5_uintptr )buffer % __alignof__(md5_uint32 ) != 0UL) {
      while (len > 64UL) {
        memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )buffer,
               (size_t )64);
        md5_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
        buffer = (void const   *)((char const   *)buffer + 64);
        len -= 64UL;
      }
    } else {
      md5_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
      buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
      len &= 63UL;
    }
  }
  if (len > 0UL) {
    memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )buffer,
           len);
    ctx->buflen = (md5_uint32 )len;
  }
  return;
}
}
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ 
  md5_uint32 correct_words[16] ;
  md5_uint32 const   *words ;
  size_t nwords ;
  md5_uint32 const   *endp ;
  md5_uint32 A ;
  md5_uint32 B ;
  md5_uint32 C ;
  md5_uint32 D ;
  md5_uint32 *cwp ;
  md5_uint32 A_save ;
  md5_uint32 B_save ;
  md5_uint32 C_save ;
  md5_uint32 D_save ;
  md5_uint32 *tmp ;
  md5_uint32 tmp___0 ;
  md5_uint32 *tmp___1 ;
  md5_uint32 tmp___2 ;
  md5_uint32 *tmp___3 ;
  md5_uint32 tmp___4 ;
  md5_uint32 *tmp___5 ;
  md5_uint32 tmp___6 ;
  md5_uint32 *tmp___7 ;
  md5_uint32 tmp___8 ;
  md5_uint32 *tmp___9 ;
  md5_uint32 tmp___10 ;
  md5_uint32 *tmp___11 ;
  md5_uint32 tmp___12 ;
  md5_uint32 *tmp___13 ;
  md5_uint32 tmp___14 ;
  md5_uint32 *tmp___15 ;
  md5_uint32 tmp___16 ;
  md5_uint32 *tmp___17 ;
  md5_uint32 tmp___18 ;
  md5_uint32 *tmp___19 ;
  md5_uint32 tmp___20 ;
  md5_uint32 *tmp___21 ;
  md5_uint32 tmp___22 ;
  md5_uint32 *tmp___23 ;
  md5_uint32 tmp___24 ;
  md5_uint32 *tmp___25 ;
  md5_uint32 tmp___26 ;
  md5_uint32 *tmp___27 ;
  md5_uint32 tmp___28 ;
  md5_uint32 *tmp___29 ;
  md5_uint32 tmp___30 ;

  {
  words = (md5_uint32 const   *)buffer;
  nwords = len / sizeof(md5_uint32 );
  endp = words + nwords;
  A = ctx->A;
  B = ctx->B;
  C = ctx->C;
  D = ctx->D;
  ctx->total[0] = (md5_uint32 )((size_t )ctx->total[0] + len);
  ctx->total[1] = (md5_uint32 )((size_t )ctx->total[1] + (((len >> 31) >> 1) + (size_t )((size_t )ctx->total[0] < len)));
  while ((unsigned long )words < (unsigned long )endp) {
    cwp = correct_words;
    A_save = A;
    B_save = B;
    C_save = C;
    D_save = D;
    while (1) {
      tmp = cwp;
      cwp ++;
      tmp___0 = (md5_uint32 )*words;
      *tmp = tmp___0;
      A += ((D ^ (B & (C ^ D))) + tmp___0) + 3614090360U;
      words ++;
      A = (A << 7) | (A >> 25);
      A += B;
      break;
    }
    while (1) {
      tmp___1 = cwp;
      cwp ++;
      tmp___2 = (md5_uint32 )*words;
      *tmp___1 = tmp___2;
      D += ((C ^ (A & (B ^ C))) + tmp___2) + 3905402710U;
      words ++;
      D = (D << 12) | (D >> 20);
      D += A;
      break;
    }
    while (1) {
      tmp___3 = cwp;
      cwp ++;
      tmp___4 = (md5_uint32 )*words;
      *tmp___3 = tmp___4;
      C += ((B ^ (D & (A ^ B))) + tmp___4) + 606105819U;
      words ++;
      C = (C << 17) | (C >> 15);
      C += D;
      break;
    }
    while (1) {
      tmp___5 = cwp;
      cwp ++;
      tmp___6 = (md5_uint32 )*words;
      *tmp___5 = tmp___6;
      B += ((A ^ (C & (D ^ A))) + tmp___6) + 3250441966U;
      words ++;
      B = (B << 22) | (B >> 10);
      B += C;
      break;
    }
    while (1) {
      tmp___7 = cwp;
      cwp ++;
      tmp___8 = (md5_uint32 )*words;
      *tmp___7 = tmp___8;
      A += ((D ^ (B & (C ^ D))) + tmp___8) + 4118548399U;
      words ++;
      A = (A << 7) | (A >> 25);
      A += B;
      break;
    }
    while (1) {
      tmp___9 = cwp;
      cwp ++;
      tmp___10 = (md5_uint32 )*words;
      *tmp___9 = tmp___10;
      D += ((C ^ (A & (B ^ C))) + tmp___10) + 1200080426U;
      words ++;
      D = (D << 12) | (D >> 20);
      D += A;
      break;
    }
    while (1) {
      tmp___11 = cwp;
      cwp ++;
      tmp___12 = (md5_uint32 )*words;
      *tmp___11 = tmp___12;
      C += ((B ^ (D & (A ^ B))) + tmp___12) + 2821735955U;
      words ++;
      C = (C << 17) | (C >> 15);
      C += D;
      break;
    }
    while (1) {
      tmp___13 = cwp;
      cwp ++;
      tmp___14 = (md5_uint32 )*words;
      *tmp___13 = tmp___14;
      B += ((A ^ (C & (D ^ A))) + tmp___14) + 4249261313U;
      words ++;
      B = (B << 22) | (B >> 10);
      B += C;
      break;
    }
    while (1) {
      tmp___15 = cwp;
      cwp ++;
      tmp___16 = (md5_uint32 )*words;
      *tmp___15 = tmp___16;
      A += ((D ^ (B & (C ^ D))) + tmp___16) + 1770035416U;
      words ++;
      A = (A << 7) | (A >> 25);
      A += B;
      break;
    }
    while (1) {
      tmp___17 = cwp;
      cwp ++;
      tmp___18 = (md5_uint32 )*words;
      *tmp___17 = tmp___18;
      D += ((C ^ (A & (B ^ C))) + tmp___18) + 2336552879U;
      words ++;
      D = (D << 12) | (D >> 20);
      D += A;
      break;
    }
    while (1) {
      tmp___19 = cwp;
      cwp ++;
      tmp___20 = (md5_uint32 )*words;
      *tmp___19 = tmp___20;
      C += ((B ^ (D & (A ^ B))) + tmp___20) + 4294925233U;
      words ++;
      C = (C << 17) | (C >> 15);
      C += D;
      break;
    }
    while (1) {
      tmp___21 = cwp;
      cwp ++;
      tmp___22 = (md5_uint32 )*words;
      *tmp___21 = tmp___22;
      B += ((A ^ (C & (D ^ A))) + tmp___22) + 2304563134U;
      words ++;
      B = (B << 22) | (B >> 10);
      B += C;
      break;
    }
    while (1) {
      tmp___23 = cwp;
      cwp ++;
      tmp___24 = (md5_uint32 )*words;
      *tmp___23 = tmp___24;
      A += ((D ^ (B & (C ^ D))) + tmp___24) + 1804603682U;
      words ++;
      A = (A << 7) | (A >> 25);
      A += B;
      break;
    }
    while (1) {
      tmp___25 = cwp;
      cwp ++;
      tmp___26 = (md5_uint32 )*words;
      *tmp___25 = tmp___26;
      D += ((C ^ (A & (B ^ C))) + tmp___26) + 4254626195U;
      words ++;
      D = (D << 12) | (D >> 20);
      D += A;
      break;
    }
    while (1) {
      tmp___27 = cwp;
      cwp ++;
      tmp___28 = (md5_uint32 )*words;
      *tmp___27 = tmp___28;
      C += ((B ^ (D & (A ^ B))) + tmp___28) + 2792965006U;
      words ++;
      C = (C << 17) | (C >> 15);
      C += D;
      break;
    }
    while (1) {
      tmp___29 = cwp;
      cwp ++;
      tmp___30 = (md5_uint32 )*words;
      *tmp___29 = tmp___30;
      B += ((A ^ (C & (D ^ A))) + tmp___30) + 1236535329U;
      words ++;
      B = (B << 22) | (B >> 10);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
      A = (A << 5) | (A >> 27);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
      D = (D << 9) | (D >> 23);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
      C = (C << 14) | (C >> 18);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
      B = (B << 20) | (B >> 12);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
      A = (A << 5) | (A >> 27);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
      D = (D << 9) | (D >> 23);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
      C = (C << 14) | (C >> 18);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
      B = (B << 20) | (B >> 12);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
      A = (A << 5) | (A >> 27);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
      D = (D << 9) | (D >> 23);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
      C = (C << 14) | (C >> 18);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
      B = (B << 20) | (B >> 12);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
      A = (A << 5) | (A >> 27);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
      D = (D << 9) | (D >> 23);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
      C = (C << 14) | (C >> 18);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
      B = (B << 20) | (B >> 12);
      B += C;
      break;
    }
    while (1) {
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
      A = (A << 4) | (A >> 28);
      A += B;
      break;
    }
    while (1) {
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
      D = (D << 11) | (D >> 21);
      D += A;
      break;
    }
    while (1) {
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
      C = (C << 16) | (C >> 16);
      C += D;
      break;
    }
    while (1) {
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
      B = (B << 23) | (B >> 9);
      B += C;
      break;
    }
    while (1) {
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
      A = (A << 4) | (A >> 28);
      A += B;
      break;
    }
    while (1) {
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
      D = (D << 11) | (D >> 21);
      D += A;
      break;
    }
    while (1) {
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
      C = (C << 16) | (C >> 16);
      C += D;
      break;
    }
    while (1) {
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
      B = (B << 23) | (B >> 9);
      B += C;
      break;
    }
    while (1) {
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
      A = (A << 4) | (A >> 28);
      A += B;
      break;
    }
    while (1) {
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
      D = (D << 11) | (D >> 21);
      D += A;
      break;
    }
    while (1) {
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
      C = (C << 16) | (C >> 16);
      C += D;
      break;
    }
    while (1) {
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
      B = (B << 23) | (B >> 9);
      B += C;
      break;
    }
    while (1) {
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
      A = (A << 4) | (A >> 28);
      A += B;
      break;
    }
    while (1) {
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
      D = (D << 11) | (D >> 21);
      D += A;
      break;
    }
    while (1) {
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
      C = (C << 16) | (C >> 16);
      C += D;
      break;
    }
    while (1) {
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
      B = (B << 23) | (B >> 9);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
      A = (A << 6) | (A >> 26);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
      D = (D << 10) | (D >> 22);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
      C = (C << 15) | (C >> 17);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
      B = (B << 21) | (B >> 11);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
      A = (A << 6) | (A >> 26);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
      D = (D << 10) | (D >> 22);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
      C = (C << 15) | (C >> 17);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
      B = (B << 21) | (B >> 11);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
      A = (A << 6) | (A >> 26);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
      D = (D << 10) | (D >> 22);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
      C = (C << 15) | (C >> 17);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
      B = (B << 21) | (B >> 11);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
      A = (A << 6) | (A >> 26);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
      D = (D << 10) | (D >> 22);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
      C = (C << 15) | (C >> 17);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
      B = (B << 21) | (B >> 11);
      B += C;
      break;
    }
    A += A_save;
    B += B_save;
    C += C_save;
    D += D_save;
  }
  ctx->A = A;
  ctx->B = B;
  ctx->C = C;
  ctx->D = D;
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#pragma merger("0","/tmp/cil-D7mb9c5o.i","-W,-Wall,-Wunused-value,-g,-O2")
char *xstrdup(char const   *str ) 
{ 
  register char *ret ;

  {
  if (! str) {
    NOTIFY((LEVEL )2, "string has no value!");
    return ((char *)((void *)0));
  }
  ret = strdup(str);
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    NOTIFY((LEVEL )3, "xstrdup: unable to allocate additional memory");
  }
  return (ret);
}
}
char *xstrcat(char const   *arg1  , ...) 
{ 
  char const   *argptr ;
  char *resptr ;
  char *result ;
  size_t len ;
  va_list valist ;
  char const   *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;

  {
  len = (size_t )0;
  __builtin_va_start(valist, arg1);
  argptr = arg1;
  while ((unsigned long )argptr != (unsigned long )((void *)0)) {
    tmp___0 = strlen(argptr);
    len += tmp___0;
    tmp = __builtin_va_arg(valist, char *);
    argptr = tmp;
  }
  __builtin_va_end(valist);
  tmp___1 = xmalloc(len + 1UL);
  result = (char *)tmp___1;
  resptr = result;
  __builtin_va_start(valist, arg1);
  argptr = arg1;
  while ((unsigned long )argptr != (unsigned long )((void *)0)) {
    len = strlen(argptr);
    memcpy((void * __restrict  )resptr, (void const   * __restrict  )argptr, len);
    resptr += len;
    tmp___2 = __builtin_va_arg(valist, char *);
    argptr = tmp___2;
  }
  __builtin_va_end(valist);
  *resptr = (char )'\000';
  return (result);
}
}
void *xrealloc(void *ptr , size_t size ) 
{ 
  void *tmp ;

  {
  if (ptr) {
    tmp = realloc(ptr, size);
  } else {
    tmp = malloc(size);
  }
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    NOTIFY((LEVEL )3, "Memory exhausted; unable to continue.");
  }
  return (tmp);
}
}
void *xmalloc(size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp___0 = malloc(size);
  tmp = tmp___0;
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    NOTIFY((LEVEL )3, "Unable to allocate additional memory.");
  }
  return (tmp);
}
}
void *xcalloc(size_t num , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp___0 = xmalloc(num * size);
  tmp = tmp___0;
  memset(tmp, 0, num * size);
  return (tmp);
}
}
void xfree(void *ptr ) 
{ 


  {
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    free(ptr);
    ptr = (void *)0;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-6KX4ddq5.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
extern void closelog(void) ;
extern void openlog(char const   *__ident , int __option , int __facility ) ;
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
void OPENLOG(char *program ) ;
void CLOSELOG(void) ;
void SYSLOG(LEVEL L , char const   *fmt  , ...) ;
static void __message(METHOD M , LEVEL L , char const   *fmt , va_list___0 ap ) ;
void OPENLOG(char *program ) 
{ 


  {
  openlog((char const   *)program, 1, 3 << 3);
  return;
}
}
void CLOSELOG(void) 
{ 


  {
  closelog();
  return;
}
}
static void __message(METHOD M , LEVEL L , char const   *fmt , va_list___0 ap ) 
{ 
  char buf[40000] ;
  char msg[41024] ;
  LEVEL level ;
  char pmode[64] ;
  char lmode[64] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  level = (LEVEL )1;
  memset((void *)(lmode), '\000', (size_t )64);
  memset((void *)(pmode), '\000', (size_t )64);
  vsprintf((char * __restrict  )(buf), (char const   * __restrict  )fmt, ap);
  tmp___1 = __errno_location();
  if (*tmp___1 == 0) {
    snprintf((char * __restrict  )(msg), sizeof(msg), (char const   * __restrict  )"%s\n",
             buf);
  } else {
    tmp___2 = __errno_location();
    if (*tmp___2 == 38) {
      snprintf((char * __restrict  )(msg), sizeof(msg), (char const   * __restrict  )"%s\n",
               buf);
    } else
    if ((unsigned int )L == 0U) {
      snprintf((char * __restrict  )(msg), sizeof(msg), (char const   * __restrict  )"%s\n",
               buf);
    } else {
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      snprintf((char * __restrict  )(msg), sizeof(msg), (char const   * __restrict  )"%s: %s\n",
               buf, tmp___0);
    }
  }
  switch ((unsigned int )L) {
  case 0U: 
  sprintf((char * __restrict  )(pmode), (char const   * __restrict  )"[%c[%d;%dmdebug%c[%dm]",
          27, 1, 34, 27, 0);
  strcpy((char * __restrict  )(lmode), (char const   * __restrict  )"[debug]");
  level = (LEVEL )4;
  break;
  case 1U: 
  sprintf((char * __restrict  )(pmode), (char const   * __restrict  )"[%c[%d;%dmalert%c[%dm]",
          27, 1, 32, 27, 0);
  strcpy((char * __restrict  )(lmode), (char const   * __restrict  )"[alert] ");
  level = (LEVEL )4;
  break;
  case 2U: 
  sprintf((char * __restrict  )(pmode), (char const   * __restrict  )"[%c[%d;%dmerror%c[%dm]",
          27, 1, 33, 27, 0);
  strcpy((char * __restrict  )(lmode), (char const   * __restrict  )"[error]");
  level = (LEVEL )3;
  break;
  case 3U: 
  sprintf((char * __restrict  )(pmode), (char const   * __restrict  )"[%c[%d;%dmfatal%c[%dm]",
          27, 1, 31, 27, 0);
  strcpy((char * __restrict  )(lmode), (char const   * __restrict  )"[fatal]");
  level = (LEVEL )2;
  break;
  }
  if ((unsigned int )M == 1U) {
    syslog((int )level, "%s %s", lmode, msg);
  } else {
    fflush(stdout);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s %s", pmode,
            msg);
  }
  if ((unsigned int )L == 3U) {
    exit(1);
  }
  return;
}
}
void SYSLOG(LEVEL L , char const   *fmt  , ...) 
{ 
  va_list___0 ap ;

  {
  __builtin_va_start(ap, fmt);
  __message((METHOD )1, L, fmt, ap);
  __builtin_va_end(ap);
  return;
}
}
void NOTIFY(LEVEL L , char const   *fmt  , ...) 
{ 
  va_list___0 ap ;

  {
  __builtin_va_start(ap, fmt);
  __message((METHOD )2, L, fmt, ap);
  __builtin_va_end(ap);
  return;
}
}
void __display(int color , char const   *fmt , va_list___0 ap ) 
{ 
  char buf[40000] ;
  char msg[41024] ;

  {
  vsprintf((char * __restrict  )(buf), (char const   * __restrict  )fmt, ap);
  if (color == -1) {
    snprintf((char * __restrict  )(msg), sizeof(msg), (char const   * __restrict  )"%s\n",
             buf);
  } else {
    snprintf((char * __restrict  )(msg), sizeof(msg), (char const   * __restrict  )"%c[%d;%dm%s%c[%dm\n",
             27, 0, color + 30, buf, 27, 0);
  }
  printf((char const   * __restrict  )"%s", msg);
  return;
}
}
void DISPLAY(int color , char const   *fmt  , ...) 
{ 
  va_list___0 ap ;

  {
  __builtin_va_start(ap, fmt);
  __display(color, fmt, ap);
  __builtin_va_end(ap);
  return;
}
}
#pragma merger("0","/tmp/cil-XuFB78bL.i","-W,-Wall,-Wunused-value,-g,-O2")
size_t page_length(PAGE this ) ;
size_t PAGESIZE  =    sizeof(struct PAGE_T );
void __expand(PAGE this , int const   len ) ;
PAGE new_page(char *str ) 
{ 
  PAGE this ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = calloc((size_t )1, PAGESIZE);
  this = (PAGE )tmp;
  this->len = strlen((char const   *)str);
  this->size = this->len + 24576UL;
  tmp___0 = calloc((size_t )1, this->size);
  this->buf = (char *)tmp___0;
  memcpy((void * __restrict  )this->buf, (void const   * __restrict  )str, this->len);
  return (this);
}
}
PAGE page_destroy(PAGE this ) 
{ 


  {
  if ((unsigned long )this != (unsigned long )((void *)0)) {
    this->len = (size_t )0;
    this->size = (size_t )0;
    free((void *)this->buf);
    free((void *)this);
  }
  return (this);
}
}
size_t page_length(PAGE this ) 
{ 


  {
  return (this->len);
}
}
size_t page_size(PAGE this ) 
{ 


  {
  return (this->size);
}
}
void page_concat(PAGE this , char const   *str , int const   len ) 
{ 
  size_t tmp ;

  {
  if (! this) {
    return;
  } else
  if (! str) {
    return;
  } else {
    tmp = strlen(str);
    if (tmp < 1UL) {
      return;
    } else
    if (len < 0) {
      return;
    }
  }
  if (this->len + (size_t )len > this->size) {
    __expand(this, len + 1);
  }
  memcpy((void * __restrict  )(this->buf + this->len), (void const   * __restrict  )str,
         (size_t )len);
  this->len += (size_t )len;
  *(this->buf + (this->len + 1UL)) = (char )'\000';
  return;
}
}
void page_clear(PAGE this ) 
{ 


  {
  if (! this) {
    return;
  }
  this->len = (size_t )0;
  memset((void *)this->buf, '\000', this->size);
  return;
}
}
char *page_value(PAGE this ) 
{ 


  {
  return (this->buf);
}
}
void __expand(PAGE this , int const   len ) 
{ 
  void *tmp ;

  {
  if (! this) {
    return;
  } else
  if (len < 0) {
    return;
  }
  this->size += (size_t )len;
  tmp = realloc((void *)this->buf, this->size);
  this->buf = (char *)tmp;
  memset((void *)(this->buf + (this->size - (size_t )len)), '\000', (size_t )len);
  return;
}
}
#pragma merger("0","/tmp/cil-VomiCseu.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3))) strtok_r)(char * __restrict  __s ,
                                                                                         char const   * __restrict  __delim ,
                                                                                         char ** __restrict  __save_ptr ) ;
BOOLEAN startswith(char const   *pre , char const   *str ) ;
BOOLEAN endswith(char const   *suffix , char const   *str ) ;
static void __parse_control(ARRAY array , URL base , char *html ) ;
static void __add_url(ARRAY array , URL U ) ;
static char *__strcasestr(char const   *s , char const   *find ) ;
static char *__xstrip(char const   *str , char const   *pat ) ;
BOOLEAN html_parser(ARRAY array , URL base , char *page ) 
{ 
  char *str ;
  char *ptr ;
  int i ;
  char tmp[4096] ;
  size_t tmp___0 ;
  BOOLEAN tmp___1 ;
  BOOLEAN tmp___2 ;

  {
  memset((void *)(tmp), '\000', (size_t )4096);
  str = __xstrip((char const   *)page, "\\");
  ptr = str;
  if ((unsigned long )page == (unsigned long )((void *)0)) {
    return ((BOOLEAN )0);
  }
  tmp___0 = strlen((char const   *)page);
  if (tmp___0 < 1UL) {
    return ((BOOLEAN )0);
  }
  while ((int )*ptr != 0) {
    if ((int )*ptr == 60) {
      ptr ++;
      tmp___2 = startswith("!--", (char const   *)ptr);
      if ((unsigned int )tmp___2 == 1U) {
        ptr += 3;
        while ((int )*ptr != 0) {
          tmp___1 = startswith("-->", (char const   *)ptr);
          if ((unsigned int )tmp___1 == 1U) {
            ptr += 3;
            break;
          }
          ptr ++;
        }
      } else {
        i = 0;
        memset((void *)(tmp), '\000', sizeof(tmp));
        while (1) {
          if ((int )*ptr != 0) {
            if ((int )*ptr != 62) {
              if (! (i < 4095)) {
                break;
              }
            } else {
              break;
            }
          } else {
            break;
          }
          tmp[i] = *ptr;
          i ++;
          ptr ++;
        }
        __parse_control(array, base, tmp);
      }
    }
    ptr ++;
  }
  xfree((void *)str);
  return ((BOOLEAN )1);
}
}
static void __add_url(ARRAY array , URL U ) 
{ 
  int i ;
  BOOLEAN found ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  URL url ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  BOOLEAN tmp___5 ;
  size_t tmp___6 ;

  {
  i = 0;
  found = (BOOLEAN )0;
  if ((unsigned long )U == (unsigned long )((void *)0)) {
    return;
  } else {
    tmp = url_get_hostname(U);
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      return;
    } else {
      tmp___0 = url_get_hostname(U);
      tmp___1 = strlen((char const   *)tmp___0);
      if (tmp___1 < 2UL) {
        return;
      }
    }
  }
  if ((unsigned long )array != (unsigned long )((void *)0)) {
    i = 0;
    while (1) {
      tmp___6 = array_length(array);
      if (! (i < (int )tmp___6)) {
        break;
      }
      tmp___2 = array_get(array, i);
      url = (URL )tmp___2;
      tmp___3 = url_get_absolute(url);
      tmp___4 = url_get_absolute(U);
      tmp___5 = strmatch(tmp___4, tmp___3);
      if (tmp___5) {
        found = (BOOLEAN )1;
      }
      i ++;
    }
  }
  if (! found) {
    array_npush(array, (void *)U, URLSIZE);
  }
  return;
}
}
static void __parse_control(ARRAY array , URL base , char *html ) 
{ 
  char *ptr ;
  char *aid ;
  char tmp[4096] ;
  char *top ;
  BOOLEAN debug___0 ;
  URL U ;
  URL tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  URL U___0 ;
  URL tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  BOOLEAN tmp___9 ;
  URL U___1 ;
  URL tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  BOOLEAN okay___0 ;
  char buf[2048] ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  URL U___2 ;
  URL tmp___22 ;
  char *tmp___23 ;
  BOOLEAN tmp___24 ;
  URL U___3 ;
  URL tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  URL U___4 ;
  URL tmp___29 ;
  char *tmp___30 ;
  BOOLEAN tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;

  {
  ptr = (char *)((void *)0);
  debug___0 = (BOOLEAN )0;
  top = strtok_r((char * __restrict  )html, (char const   * __restrict  )" =", (char ** __restrict  )(& aid));
  ptr = top;
  while ((unsigned long )ptr != (unsigned long )((void *)0)) {
    tmp___39 = strncasecmp((char const   *)ptr, "href", (size_t )4);
    if (tmp___39 == 0) {
      ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =\"\'",
                     (char ** __restrict  )(& aid));
      if ((unsigned long )ptr != (unsigned long )((void *)0)) {
        memset((void *)(tmp), '\000', (size_t )4096);
        strncpy((char * __restrict  )(tmp), (char const   * __restrict  )ptr, (size_t )4095);
      }
    } else {
      tmp___38 = strncasecmp((char const   *)ptr, "meta", (size_t )4);
      if (tmp___38 == 0) {
        ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =",
                       (char ** __restrict  )(& aid));
        while ((unsigned long )ptr != (unsigned long )((void *)0)) {
          tmp___3 = strncasecmp((char const   *)ptr, "content", (size_t )7);
          if (tmp___3 == 0) {
            ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =",
                           (char ** __restrict  )(& aid));
            while ((unsigned long )ptr != (unsigned long )((void *)0)) {
              tmp___2 = __strcasestr((char const   *)ptr, "url");
              if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
                ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" \"\'",
                               (char ** __restrict  )(& aid));
                if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                  tmp___0 = url_normalize(base, ptr);
                  U = tmp___0;
                  url_set_redirect(U, (BOOLEAN )1);
                  if (debug___0) {
                    tmp___1 = url_get_absolute(U);
                    printf((char const   * __restrict  )"1.) Adding: %s\n", tmp___1);
                  }
                  __add_url(array, U);
                }
              }
              ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =",
                             (char ** __restrict  )(& aid));
            }
          }
          ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =",
                         (char ** __restrict  )(& aid));
        }
      } else {
        tmp___37 = strncasecmp((char const   *)ptr, "img", (size_t )3);
        if (tmp___37 == 0) {
          ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =",
                         (char ** __restrict  )(& aid));
          if ((unsigned long )ptr != (unsigned long )((void *)0)) {
            if ((unsigned long )aid != (unsigned long )((void *)0)) {
              tmp___4 = strncasecmp((char const   *)aid, "\"\"", (size_t )2);
              if (! tmp___4) {
                continue;
              }
              tmp___15 = strncasecmp((char const   *)ptr, "src", (size_t )3);
              if (tmp___15) {
                ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =",
                               (char ** __restrict  )(& aid));
                while ((unsigned long )ptr != (unsigned long )((void *)0)) {
                  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                    tmp___14 = strncasecmp((char const   *)ptr, "src", (size_t )3);
                    if (tmp___14 == 0) {
                      ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" \"\'",
                                     (char ** __restrict  )(& aid));
                      if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                        tmp___12 = strlen((char const   *)ptr);
                        if (tmp___12 > 1UL) {
                          tmp___13 = strncasecmp((char const   *)ptr, "data:image",
                                                 (size_t )10);
                          if (tmp___13) {
                            tmp___10 = url_normalize(base, ptr);
                            U___1 = tmp___10;
                            if (debug___0) {
                              tmp___11 = url_get_absolute(U___1);
                              printf((char const   * __restrict  )"3.) Adding: %s\n",
                                     tmp___11);
                            }
                            __add_url(array, U___1);
                          }
                        }
                      }
                    }
                  }
                  ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =",
                                 (char ** __restrict  )(& aid));
                }
              } else {
                ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" \"\'",
                               (char ** __restrict  )(& aid));
                if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                  tmp___5 = strncasecmp((char const   *)ptr, "data:image", (size_t )10);
                  if (! tmp___5) {
                    continue;
                  }
                  tmp___6 = url_normalize(base, ptr);
                  U___0 = tmp___6;
                  if (debug___0) {
                    tmp___7 = url_get_absolute(U___0);
                    printf((char const   * __restrict  )"2.) Adding: %s\n", tmp___7);
                  }
                  tmp___8 = url_get_absolute(U___0);
                  tmp___9 = endswith("+", (char const   *)tmp___8);
                  if (! tmp___9) {
                    __add_url(array, U___0);
                  }
                }
              }
            }
          }
        } else {
          tmp___36 = strncasecmp((char const   *)ptr, "link", (size_t )4);
          if (tmp___36 == 0) {
            okay___0 = (BOOLEAN )0;
            ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =",
                           (char ** __restrict  )(& aid));
            while ((unsigned long )ptr != (unsigned long )((void *)0)) {
              tmp___19 = strncasecmp((char const   *)ptr, "rel", (size_t )3);
              if (tmp___19 == 0) {
                ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =\"\'",
                               (char ** __restrict  )(& aid));
                if ((unsigned long )ptr == (unsigned long )((void *)0)) {
                  goto __Cont;
                }
                tmp___16 = strncasecmp((char const   *)ptr, "stylesheet", (size_t )10);
                if (tmp___16 == 0) {
                  okay___0 = (BOOLEAN )1;
                }
                tmp___17 = strncasecmp((char const   *)ptr, "next", (size_t )4);
                if (tmp___17 == 0) {
                  okay___0 = (BOOLEAN )0;
                }
                tmp___18 = strncasecmp((char const   *)ptr, "alternate", (size_t )9);
                if (tmp___18 == 0) {
                  okay___0 = (BOOLEAN )0;
                }
              }
              tmp___21 = strncasecmp((char const   *)ptr, "href", (size_t )4);
              if (tmp___21 == 0) {
                ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" \"\'",
                               (char ** __restrict  )(& aid));
                if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                  memset((void *)(buf), '\000', sizeof(buf));
                  tmp___20 = strlen((char const   *)ptr);
                  strncpy((char * __restrict  )(buf), (char const   * __restrict  )ptr,
                          tmp___20);
                }
              }
              __Cont: /* CIL Label */ 
              ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =",
                             (char ** __restrict  )(& aid));
            }
            if (okay___0) {
              tmp___22 = url_normalize(base, buf);
              U___2 = tmp___22;
              if (debug___0) {
                tmp___23 = url_get_absolute(U___2);
                printf((char const   * __restrict  )"4.) Adding: %s\n", tmp___23);
              }
              __add_url(array, U___2);
            }
          } else {
            tmp___35 = strncasecmp((char const   *)ptr, "script", (size_t )6);
            if (tmp___35 == 0) {
              ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =",
                             (char ** __restrict  )(& aid));
              while ((unsigned long )ptr != (unsigned long )((void *)0)) {
                tmp___27 = strncasecmp((char const   *)ptr, "src", (size_t )3);
                if (tmp___27 == 0) {
                  ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" \"\'",
                                 (char ** __restrict  )(& aid));
                  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                    tmp___24 = startswith("+", (char const   *)ptr);
                    if (tmp___24) {
                      goto __Cont___0;
                    }
                    memset((void *)(tmp), 0, (size_t )4096);
                    strncpy((char * __restrict  )(tmp), (char const   * __restrict  )ptr,
                            (size_t )4095);
                    tmp___25 = url_normalize(base, tmp);
                    U___3 = tmp___25;
                    if (debug___0) {
                      tmp___26 = url_get_absolute(U___3);
                      printf((char const   * __restrict  )"5.) Adding: %s\n", tmp___26);
                    }
                    __add_url(array, U___3);
                  }
                }
                __Cont___0: /* CIL Label */ 
                ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =",
                               (char ** __restrict  )(& aid));
              }
            } else {
              tmp___34 = strncasecmp((char const   *)ptr, "location.href", (size_t )13);
              if (tmp___34 == 0) {
                ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =\"\'",
                               (char ** __restrict  )(& aid));
                if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                  memset((void *)(tmp), '\000', (size_t )4096);
                  strncpy((char * __restrict  )(tmp), (char const   * __restrict  )ptr,
                          (size_t )4095);
                }
              } else {
                tmp___33 = strncasecmp((char const   *)ptr, "frame", (size_t )5);
                if (tmp___33 == 0) {
                  ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =",
                                 (char ** __restrict  )(& aid));
                  while ((unsigned long )ptr != (unsigned long )((void *)0)) {
                    tmp___28 = strncasecmp((char const   *)ptr, "src", (size_t )3);
                    if (tmp___28 == 0) {
                      ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =\"\'",
                                     (char ** __restrict  )(& aid));
                      if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                        memset((void *)(tmp), '\000', (size_t )4096);
                        strncpy((char * __restrict  )(tmp), (char const   * __restrict  )ptr,
                                (size_t )4095);
                      }
                    }
                    ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =",
                                   (char ** __restrict  )(& aid));
                  }
                } else {
                  tmp___32 = strncasecmp((char const   *)ptr, "background", (size_t )10);
                  if (tmp___32 == 0) {
                    ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" \"\'",
                                   (char ** __restrict  )(& aid));
                    if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                      tmp___31 = strmatch((char *)"body", top);
                      if (tmp___31) {
                        memset((void *)(tmp), 0, (size_t )4096);
                        strncpy((char * __restrict  )(tmp), (char const   * __restrict  )ptr,
                                (size_t )4095);
                        tmp___29 = url_normalize(base, tmp);
                        U___4 = tmp___29;
                        if (debug___0) {
                          tmp___30 = url_get_absolute(U___4);
                          printf((char const   * __restrict  )"6.) Adding: %s\n",
                                 tmp___30);
                        }
                        __add_url(array, U___4);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    ptr = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" =",
                   (char ** __restrict  )(& aid));
  }
  return;
}
}
static char *__strcasestr(char const   *s , char const   *find ) 
{ 
  char c ;
  char sc ;
  size_t len ;
  int __res ;
  __int32_t const   **tmp___0 ;
  char const   *tmp___1 ;
  int __res___0 ;
  __int32_t const   **tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
  tmp___5 = find;
  find ++;
  c = (char )*tmp___5;
  if ((int )c != 0) {
    if (sizeof((unsigned char )c) > 1UL) {
      __res = tolower((int )((unsigned char )c));
    } else {
      tmp___0 = __ctype_tolower_loc();
      __res = (int )*(*tmp___0 + (int )((unsigned char )c));
    }
    c = (char )__res;
    len = strlen(find);
    while (1) {
      while (1) {
        tmp___1 = s;
        s ++;
        sc = (char )*tmp___1;
        if ((int )sc == 0) {
          return ((char *)((void *)0));
        }
        if (sizeof((unsigned char )sc) > 1UL) {
          __res___0 = tolower((int )((unsigned char )sc));
        } else {
          tmp___3 = __ctype_tolower_loc();
          __res___0 = (int )*(*tmp___3 + (int )((unsigned char )sc));
        }
        if (! ((int )((char )__res___0) != (int )c)) {
          break;
        }
      }
      tmp___4 = strncasecmp(s, find, len);
      if (! (tmp___4 != 0)) {
        break;
      }
    }
    s --;
  }
  return ((char *)s);
}
}
static char *__xstrip(char const   *str , char const   *pat ) 
{ 
  int i ;
  int tbl[128] ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  char *ret ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  void *tmp___5 ;

  {
  i = 0;
  tbl[0] = 0;
  tmp = 1U;
  while (! (tmp >= 128U)) {
    tbl[tmp] = 0;
    tmp ++;
  }
  while ((int const   )*pat != 0) {
    tmp___0 = pat;
    pat ++;
    tbl[(int )*tmp___0] = 1;
  }
  tmp___1 = strlen(str);
  tmp___2 = xmalloc(tmp___1 + 1UL);
  ret = (char *)tmp___2;
  while (1) {
    if (! tbl[(int )*str]) {
      tmp___3 = i;
      i ++;
      *(ret + tmp___3) = (char )*str;
    }
    tmp___4 = str;
    str ++;
    if (! ((int const   )*tmp___4 != 0)) {
      break;
    }
  }
  tmp___5 = xrealloc((void *)ret, (size_t )i);
  return ((char *)tmp___5);
}
}
#pragma merger("0","/tmp/cil-qBlAKn_G.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
char *rtrim(char *str ) ;
char *ltrim(char *str ) ;
int word_count(char pattern , char *s ) ;
char *chomp(char *str ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  if (*str) {
    tmp___0 = strlen((char const   *)str);
    if ((int )*(str + (tmp___0 - 1UL)) == 10) {
      tmp = strlen((char const   *)str);
      *(str + (tmp - 1UL)) = (char)0;
    }
  }
  return (str);
}
}
char *rtrim(char *str ) 
{ 
  char *ptr ;
  int len ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  ptr = str;
  while (1) {
    if (*ptr) {
      tmp = __ctype_b_loc();
      if (! ((int const   )*(*tmp + (int )*ptr) & 8192)) {
        break;
      }
    } else {
      break;
    }
    ptr ++;
  }
  tmp___0 = strlen((char const   *)str);
  len = (int )tmp___0;
  ptr = (str + len) - 1;
  while (1) {
    if ((unsigned long )ptr >= (unsigned long )str) {
      tmp___1 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___1 + (int )*ptr) & 8192)) {
        break;
      }
    } else {
      break;
    }
    ptr --;
  }
  *(ptr + 1) = (char )'\000';
  return (str);
}
}
char *ltrim(char *str ) 
{ 
  char *ptr ;
  int len ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;

  {
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  ptr = str;
  while (1) {
    if (*ptr) {
      tmp = __ctype_b_loc();
      if (! ((int const   )*(*tmp + (int )*ptr) & 8192)) {
        break;
      }
    } else {
      break;
    }
    ptr ++;
  }
  tmp___0 = strlen((char const   *)ptr);
  len = (int )tmp___0;
  memmove((void *)str, (void const   *)ptr, (size_t )(len + 1));
  return (str);
}
}
char *trim(char *str ) 
{ 
  char *ptr ;

  {
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  ptr = rtrim(str);
  str = ltrim(ptr);
  return (str);
}
}
int valid(char const   *s ) 
{ 
  int flag ;
  int i ;
  int tmp ;

  {
  flag = 0;
  i = 0;
  i = 0;
  while (i <= 255) {
    if (flag) {
      tmp = 1;
    } else
    if ((int const   )*(s + i) == 0) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    flag = tmp;
    i ++;
  }
  if (flag) {
    return (1);
  } else {
    return (0);
  }
}
}
BOOLEAN empty(char const   *s ) 
{ 
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  if (! s) {
    return ((BOOLEAN )1);
  }
  tmp = strlen(s);
  if (tmp < 1UL) {
    return ((BOOLEAN )1);
  }
  while (1) {
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 8192)) {
      break;
    }
    s ++;
  }
  return ((BOOLEAN )((int const   )*s == 0));
}
}
int word_count(char pattern , char *s ) 
{ 
  int in_word_flag ;
  int count___0 ;
  char *ptr ;

  {
  in_word_flag = 0;
  count___0 = 0;
  ptr = s;
  while (*ptr) {
    if ((int )*ptr != (int )pattern) {
      if (in_word_flag == 0) {
        count___0 ++;
      }
      in_word_flag = 1;
    } else {
      in_word_flag = 0;
    }
    ptr ++;
  }
  return (count___0);
}
}
char **split(char pattern , char *s , int *n_words ) 
{ 
  char **words ;
  char *str0 ;
  char *str1 ;
  int i ;
  void *tmp ;
  size_t len ;
  void *tmp___0 ;

  {
  *n_words = word_count(pattern, s);
  if (*n_words == 0) {
    return ((char **)((void *)0));
  }
  tmp = xmalloc((unsigned long )*n_words * sizeof(*words));
  words = (char **)tmp;
  if (! words) {
    return ((char **)((void *)0));
  }
  str0 = s;
  i = 0;
  while (*str0) {
    str1 = strchr((char const   *)str0, (int )pattern);
    if ((unsigned long )str1 != (unsigned long )((void *)0)) {
      len = (size_t )(str1 - str0);
    } else {
      len = strlen((char const   *)str0);
    }
    if (len == 0UL) {
      i --;
    } else {
      tmp___0 = xmalloc((size_t )4096);
      *(words + i) = (char *)tmp___0;
      memset((void *)*(words + i), '\000', (size_t )4096);
      memcpy((void * __restrict  )*(words + i), (void const   * __restrict  )str0,
             (size_t )4096);
      *(*(words + i) + len) = (char )'\000';
    }
    if ((unsigned long )str1 != (unsigned long )((void *)0)) {
      str1 ++;
      str0 = str1;
    } else {
      break;
    }
    i ++;
  }
  return (words);
}
}
void split_free(char **split___0 , int length ) 
{ 
  int x ;
  char *tmp ;

  {
  x = 0;
  while (x < length) {
    if ((unsigned long )*(split___0 + x) != (unsigned long )((void *)0)) {
      tmp = *(split___0 + x);
      xfree((void *)tmp);
    }
    x ++;
  }
  free((void *)split___0);
  return;
}
}
#pragma merger("0","/tmp/cil-y5TmaKfn.i","-W,-Wall,-Wunused-value,-g,-O2")
size_t RESPONSESIZE ;
char *response_get_charset(RESPONSE this ) ;
int response_get_content_length(RESPONSE this ) ;
HTTP_CONN response_get_connection(RESPONSE this ) ;
BOOLEAN response_get_redirect(RESPONSE this ) ;
char *response_get_last_modified(RESPONSE this ) ;
BOOLEAN response_set_etag(RESPONSE this , char *line ) ;
char *response_get_etag(RESPONSE this ) ;
size_t RESPONSESIZE  =    sizeof(struct RESPONSE_T );
static char *__parse_pair___0(char **str ) ;
static char *__dequote(char *str ) ;
static int __int_value(RESPONSE this , char *key , int def ) ;
static BOOLEAN __boolean_value(RESPONSE this , char *key , BOOLEAN def ) ;
RESPONSE new_response(void) 
{ 
  RESPONSE this ;
  void *tmp ;

  {
  tmp = xcalloc(RESPONSESIZE, (size_t )1);
  this = (RESPONSE )tmp;
  this->headers = new_hash();
  this->auth.realm.www = (char *)((void *)0);
  this->auth.challenge.www = (char *)((void *)0);
  this->auth.realm.proxy = (char *)((void *)0);
  this->auth.challenge.www = (char *)((void *)0);
  return (this);
}
}
RESPONSE response_destroy(RESPONSE this ) 
{ 


  {
  if ((unsigned long )this != (unsigned long )((void *)0)) {
    this->headers = hash_destroy(this->headers);
    xfree((void *)this->auth.realm.www);
    xfree((void *)this->auth.challenge.www);
    xfree((void *)this->auth.realm.proxy);
    xfree((void *)this->auth.challenge.proxy);
    xfree((void *)this);
    this = (RESPONSE )((void *)0);
  }
  return (this);
}
}
BOOLEAN response_set_code(RESPONSE this , char *line ) 
{ 
  char *tmp ;
  char arr[32] ;
  int num ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = line;
  tmp___1 = strncasecmp((char const   *)line, "http", (size_t )4);
  if (tmp___1 == 0) {
    tmp___0 = atoi((char const   *)(tmp + 9));
    num = tmp___0;
    if (num > 1) {
      memset((void *)(arr), '\000', sizeof(arr));
      strncpy((char * __restrict  )(arr), (char const   * __restrict  )line, (size_t )8);
      hash_add(this->headers, (char *)"protocol", (void *)(arr));
      hash_add(this->headers, (char *)"response-code", (void *)(line + 9));
      return ((BOOLEAN )1);
    }
  }
  return ((BOOLEAN )0);
}
}
int response_get_code(RESPONSE this ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    return (418);
  } else
  if ((unsigned long )this->headers == (unsigned long )((void *)0)) {
    return (418);
  } else {
    tmp = hash_get(this->headers, (char *)"response-code");
    if ((unsigned long )((char *)tmp) == (unsigned long )((void *)0)) {
      return (418);
    }
  }
  tmp___0 = hash_get(this->headers, (char *)"response-code");
  tmp___1 = atoi((char const   *)((char *)tmp___0));
  return (tmp___1);
}
}
char *response_get_protocol(RESPONSE this ) 
{ 
  void *tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;

  {
  tmp___2 = hash_get(this->headers, (char *)"protocol");
  if ((unsigned long )((char *)tmp___2) == (unsigned long )((void *)0)) {
    tmp___1 = "HTTP/1.1";
  } else {
    tmp___0 = hash_get(this->headers, (char *)"protocol");
    tmp___1 = (char const   *)((char *)tmp___0);
  }
  return ((char *)tmp___1);
}
}
int response_success(RESPONSE this ) 
{ 
  void *tmp ;
  int code ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = hash_get(this->headers, (char *)"response-code");
  if ((unsigned long )((char *)tmp) == (unsigned long )((void *)0)) {
    return (0);
  }
  tmp___0 = hash_get(this->headers, (char *)"response-code");
  tmp___1 = atoi((char const   *)((char *)tmp___0));
  code = tmp___1;
  if (code < 400) {
    tmp___2 = 1;
  } else
  if (code == 401) {
    tmp___2 = 1;
  } else
  if (code == 407) {
    tmp___2 = 1;
  } else {
    tmp___2 = 0;
  }
  return (tmp___2);
}
}
int response_failure(RESPONSE this ) 
{ 
  void *tmp ;
  int code ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = hash_get(this->headers, (char *)"response-code");
  if ((unsigned long )((char *)tmp) == (unsigned long )((void *)0)) {
    return (1);
  }
  tmp___0 = hash_get(this->headers, (char *)"response-code");
  tmp___1 = atoi((char const   *)((char *)tmp___0));
  code = tmp___1;
  if (code >= 400) {
    if (code != 401) {
      if (code != 407) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  return (tmp___2);
}
}
void response_set_from_cache(RESPONSE this , BOOLEAN cached ) 
{ 


  {
  this->cached = cached;
  return;
}
}
BOOLEAN response_get_from_cache(RESPONSE this ) 
{ 


  {
  return (this->cached);
}
}
BOOLEAN response_set_content_type(RESPONSE this , char *line ) 
{ 
  char *type ;
  char *set ;
  char *aid ;
  char *ptr ;
  BOOLEAN res ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
  type = (char *)((void *)0);
  set = (char *)((void *)0);
  aid = (char *)((void *)0);
  ptr = (char *)((void *)0);
  res = (BOOLEAN )0;
  tmp___2 = strstr((char const   *)line, ";");
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
    tmp = strlen("content-type");
    ptr = line + (tmp + 2UL);
    type = strtok_r((char * __restrict  )ptr, (char const   * __restrict  )";", (char ** __restrict  )(& aid));
    if ((unsigned long )type != (unsigned long )((void *)0)) {
      hash_add(this->headers, (char *)"content-type", (void *)type);
      res = (BOOLEAN )1;
    }
    set = stristr((char const   *)aid, "charset=");
    if (set) {
      tmp___0 = strlen((char const   *)set);
      if (tmp___0 > 8UL) {
        hash_add(this->headers, (char *)"charset", (void *)(set + 8));
      }
    }
  } else {
    tmp___1 = strlen("content-type");
    hash_add(this->headers, (char *)"content-type", (void *)(line + (tmp___1 + 2UL)));
    res = (BOOLEAN )1;
  }
  return (res);
}
}
char *response_get_content_type(RESPONSE this ) 
{ 
  void *tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;

  {
  tmp___2 = hash_get(this->headers, (char *)"content-type");
  if ((unsigned long )((char *)tmp___2) == (unsigned long )((void *)0)) {
    tmp___1 = "unknown";
  } else {
    tmp___0 = hash_get(this->headers, (char *)"content-type");
    tmp___1 = (char const   *)((char *)tmp___0);
  }
  return ((char *)tmp___1);
}
}
char *response_get_charset(RESPONSE this ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = hash_get(this->headers, (char *)"charset");
  if ((unsigned long )((char *)tmp) == (unsigned long )((void *)0)) {
    hash_add(this->headers, (char *)"charset", (void *)"iso-8859-1");
  }
  tmp___0 = hash_get(this->headers, (char *)"charset");
  return ((char *)tmp___0);
}
}
BOOLEAN response_set_content_length(RESPONSE this , char *line ) 
{ 
  char *tmp ;
  int num ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  tmp = line;
  tmp___3 = strlen("content-length");
  tmp___4 = strncasecmp((char const   *)line, "content-length", tmp___3);
  if (tmp___4 == 0) {
    tmp___0 = strlen("content-length");
    tmp___1 = atoi((char const   *)(tmp + (tmp___0 + 2UL)));
    num = tmp___1;
    if (num > 1) {
      tmp___2 = strlen("content-length");
      hash_add(this->headers, (char *)"content-length", (void *)(line + (tmp___2 + 2UL)));
      return ((BOOLEAN )1);
    }
  }
  return ((BOOLEAN )0);
}
}
int response_get_content_length(RESPONSE this ) 
{ 
  int tmp ;

  {
  tmp = __int_value(this, (char *)"content-length", 0);
  return (tmp);
}
}
BOOLEAN response_set_content_encoding(RESPONSE this , char *line ) 
{ 
  char *ptr ;
  char tmp[128] ;
  size_t tmp___0 ;
  BOOLEAN tmp___1 ;
  BOOLEAN tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  ptr = (char *)((void *)0);
  tmp___3 = strlen("content-encoding");
  tmp___4 = strncasecmp((char const   *)line, "content-encoding", tmp___3);
  if (tmp___4 == 0) {
    memset((void *)(tmp), '\000', sizeof(tmp));
    tmp___0 = strlen("content-encoding");
    ptr = line + (tmp___0 + 2UL);
    tmp___1 = strmatch(ptr, (char *)"gzip");
    if (tmp___1) {
      snprintf((char * __restrict  )(tmp), sizeof(tmp), (char const   * __restrict  )"%d",
               4);
      hash_add(this->headers, (char *)"content-encoding", (void *)(tmp));
      return ((BOOLEAN )1);
    }
    tmp___2 = strmatch(ptr, (char *)"deflate");
    if (tmp___2) {
      snprintf((char * __restrict  )(tmp), sizeof(tmp), (char const   * __restrict  )"%d",
               2);
      hash_add(this->headers, (char *)"content-encoding", (void *)(tmp));
      return ((BOOLEAN )1);
    }
  }
  return ((BOOLEAN )0);
}
}
HTTP_CE response_get_content_encoding(RESPONSE this ) 
{ 
  int tmp ;

  {
  tmp = __int_value(this, (char *)"content-encoding", 0);
  return ((HTTP_CE )tmp);
}
}
BOOLEAN response_set_transfer_encoding(RESPONSE this , char *line ) 
{ 
  char *ptr ;
  char tmp[128] ;
  size_t tmp___0 ;
  BOOLEAN tmp___1 ;
  BOOLEAN tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  ptr = (char *)((void *)0);
  tmp___3 = strlen("transfer-encoding");
  tmp___4 = strncasecmp((char const   *)line, "transfer-encoding", tmp___3);
  if (tmp___4 == 0) {
    memset((void *)(tmp), '\000', sizeof(tmp));
    tmp___0 = strlen("transfer-encoding");
    ptr = line + (tmp___0 + 2UL);
    ptr = trim(ptr);
    tmp___2 = strmatch(ptr, (char *)"chunked");
    if (tmp___2) {
      snprintf((char * __restrict  )(tmp), sizeof(tmp), (char const   * __restrict  )"%d",
               2);
    } else {
      tmp___1 = strmatch(ptr, (char *)"trailer");
      if (tmp___1) {
        snprintf((char * __restrict  )(tmp), sizeof(tmp), (char const   * __restrict  )"%d",
                 4);
      } else {
        snprintf((char * __restrict  )(tmp), sizeof(tmp), (char const   * __restrict  )"%d",
                 1);
      }
    }
    hash_add(this->headers, (char *)"transfer-encoding", (void *)(tmp));
    return ((BOOLEAN )1);
  }
  return ((BOOLEAN )0);
}
}
HTTP_TE response_get_transfer_encoding(RESPONSE this ) 
{ 
  int tmp ;

  {
  tmp = __int_value(this, (char *)"transfer-encoding", 1);
  return ((HTTP_TE )tmp);
}
}
BOOLEAN response_set_location(RESPONSE this , char *line ) 
{ 
  int len ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  BOOLEAN tmp___8 ;

  {
  len = 0;
  tmp = (char *)((void *)0);
  tmp___2 = strlen("location");
  tmp___3 = strncasecmp((char const   *)line, "location", tmp___2);
  if (tmp___3 == 0) {
    tmp___0 = strlen((char const   *)line);
    len = (int )tmp___0;
    tmp___1 = xmalloc((size_t )len);
    tmp = (char *)tmp___1;
    memset((void *)tmp, '\000', (size_t )len);
    memmove((void *)tmp, (void const   *)(line + 10), (size_t )(len - 9));
    *(tmp + (len - 10)) = (char )'\000';
    hash_add(this->headers, (char *)"location", (void *)tmp);
    hash_add(this->headers, (char *)"redirect", (void *)"true");
    xfree((void *)tmp);
  }
  tmp___6 = strlen("content-location");
  tmp___7 = strncasecmp((char const   *)line, "content-location", tmp___6);
  if (tmp___7 == 0) {
    tmp___4 = strlen((char const   *)line);
    len = (int )tmp___4;
    tmp___5 = xmalloc((size_t )len);
    tmp = (char *)tmp___5;
    memset((void *)tmp, '\000', (size_t )len);
    memmove((void *)tmp, (void const   *)(line + 18), (size_t )(len - 17));
    *(tmp + (len - 18)) = (char )'\000';
    hash_add(this->headers, (char *)"location", (void *)tmp);
    hash_add(this->headers, (char *)"redirect", (void *)"true");
    xfree((void *)tmp);
  }
  tmp___8 = __boolean_value(this, (char *)"redirect", (BOOLEAN )0);
  return (tmp___8);
}
}
char *response_get_location(RESPONSE this ) 
{ 
  void *tmp ;

  {
  tmp = hash_get(this->headers, (char *)"location");
  return ((char *)tmp);
}
}
BOOLEAN response_get_redirect(RESPONSE this ) 
{ 
  BOOLEAN tmp ;

  {
  tmp = __boolean_value(this, (char *)"redirect", (BOOLEAN )0);
  return (tmp);
}
}
BOOLEAN response_set_connection(RESPONSE this , char *line ) 
{ 
  char tmp[128] ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  tmp___1 = strlen("connection");
  tmp___2 = strncasecmp((char const   *)line, "connection", tmp___1);
  if (tmp___2 == 0) {
    memset((void *)(tmp), '\000', (size_t )128);
    tmp___0 = strncasecmp((char const   *)(line + 12), "keep-alive", (size_t )10);
    if (tmp___0 == 0) {
      snprintf((char * __restrict  )(tmp), sizeof(tmp), (char const   * __restrict  )"%d",
               2);
    } else {
      snprintf((char * __restrict  )(tmp), sizeof(tmp), (char const   * __restrict  )"%d",
               1);
    }
    hash_add(this->headers, (char *)"connection", (void *)(tmp));
    return ((BOOLEAN )1);
  }
  return ((BOOLEAN )0);
}
}
HTTP_CONN response_get_connection(RESPONSE this ) 
{ 
  int tmp ;

  {
  tmp = __int_value(this, (char *)"connection", 1);
  return ((HTTP_CONN )tmp);
}
}
BOOLEAN response_set_keepalive(RESPONSE this , char *line ) 
{ 
  char *tmp ;
  char *option ;
  char *value ;
  char *newline ;
  BOOLEAN res ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  int num ;
  int tmp___3 ;
  int tmp___4 ;
  int num___0 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  tmp = (char *)"";
  option = (char *)"";
  value = (char *)"";
  newline = line;
  res = (BOOLEAN )0;
  while (1) {
    tmp = __parse_pair___0(& newline);
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
      break;
    }
    option = tmp;
    while (1) {
      if (*tmp) {
        tmp___0 = __ctype_b_loc();
        if ((int const   )*(*tmp___0 + (int )((unsigned char )((int )*tmp))) & 8192) {
          break;
        } else
        if (61 == (int )*tmp) {
          break;
        } else
        if (58 == (int )*tmp) {
          break;
        }
      } else {
        break;
      }
      tmp ++;
    }
    tmp___1 = tmp;
    tmp ++;
    *tmp___1 = (char)0;
    while (1) {
      tmp___2 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___2 + (int )((unsigned char )((int )*tmp))) & 8192)) {
        if (! (61 == (int )*tmp)) {
          if (! (58 == (int )*tmp)) {
            break;
          }
        }
      }
      tmp ++;
    }
    value = tmp;
    while (*tmp) {
      tmp ++;
    }
    tmp___4 = strncasecmp((char const   *)option, "timeout", (size_t )7);
    if (! tmp___4) {
      if ((unsigned long )value == (unsigned long )((void *)0)) {
        hash_add(this->headers, (char *)"keepalive-timeout", (void *)"15");
      } else {
        tmp___3 = atoi((char const   *)value);
        num = tmp___3;
        if (num > 0) {
          hash_add(this->headers, (char *)"keepalive-timeout", (void *)value);
        }
      }
      res = (BOOLEAN )1;
    }
    tmp___6 = strncasecmp((char const   *)option, "max", (size_t )3);
    if (! tmp___6) {
      if ((unsigned long )value == (unsigned long )((void *)0)) {
        hash_add(this->headers, (char *)"keepalive-max", (void *)"15");
      } else {
        tmp___5 = atoi((char const   *)value);
        num___0 = tmp___5;
        if (num___0 > 0) {
          hash_add(this->headers, (char *)"keepalive-max", (void *)value);
        }
      }
      res = (BOOLEAN )1;
    }
  }
  return (res);
}
}
int response_get_keepalive_timeout(RESPONSE this ) 
{ 
  int tmp ;

  {
  tmp = __int_value(this, (char *)"keepalive-timeout", 15);
  return (tmp);
}
}
int response_get_keepalive_max(RESPONSE this ) 
{ 
  int tmp ;

  {
  tmp = __int_value(this, (char *)"keepalive-max", 5);
  return (tmp);
}
}
BOOLEAN response_set_last_modified(RESPONSE this , char *line ) 
{ 
  int len ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  len = 0;
  tmp = (char *)((void *)0);
  tmp___2 = strlen("last-modified");
  tmp___3 = strncasecmp((char const   *)line, "last-modified", tmp___2);
  if (tmp___3 == 0) {
    tmp___0 = strlen((char const   *)line);
    len = (int )tmp___0;
    tmp___1 = xmalloc((size_t )len);
    tmp = (char *)tmp___1;
    memset((void *)tmp, '\000', (size_t )len);
    memcpy((void * __restrict  )tmp, (void const   * __restrict  )(line + 15), (size_t )(len - 14));
    *(tmp + (len - 15)) = (char )'\000';
    hash_add(this->headers, (char *)"last-modified", (void *)tmp);
    xfree((void *)tmp);
    return ((BOOLEAN )1);
  }
  return ((BOOLEAN )0);
}
}
char *response_get_last_modified(RESPONSE this ) 
{ 
  void *tmp ;

  {
  tmp = hash_get(this->headers, (char *)"last-modified");
  return ((char *)tmp);
}
}
BOOLEAN response_set_etag(RESPONSE this , char *line ) 
{ 
  int len ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  len = 0;
  tmp = (char *)((void *)0);
  tmp___3 = strlen("etag");
  tmp___4 = strncasecmp((char const   *)line, "etag", tmp___3);
  if (tmp___4 == 0) {
    tmp___0 = strlen((char const   *)line);
    len = (int )tmp___0;
    tmp___1 = xmalloc((size_t )len);
    tmp = (char *)tmp___1;
    memset((void *)tmp, '\000', (size_t )len);
    memcpy((void * __restrict  )tmp, (void const   * __restrict  )(line + 6), (size_t )(len - 5));
    *(tmp + (len - 6)) = (char )'\000';
    tmp___2 = __dequote(tmp);
    hash_add(this->headers, (char *)"etag", (void *)tmp___2);
    xfree((void *)tmp);
    return ((BOOLEAN )1);
  }
  return ((BOOLEAN )0);
}
}
char *response_get_etag(RESPONSE this ) 
{ 
  void *tmp ;

  {
  tmp = hash_get(this->headers, (char *)"etag");
  return ((char *)tmp);
}
}
BOOLEAN response_set_www_authenticate(RESPONSE this , char *line ) 
{ 
  char *tmp ;
  char *option ;
  char *value ;
  char *newline ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  tmp = (char *)"";
  option = (char *)"";
  value = (char *)"";
  newline = line;
  tmp___7 = strlen("www-authenticate");
  tmp___8 = strncasecmp((char const   *)line, "www-authenticate", tmp___7);
  if (tmp___8 == 0) {
    tmp___1 = strncasecmp((char const   *)(line + 18), "digest", (size_t )6);
    if (tmp___1 == 0) {
      newline += 24;
      this->auth.type.www = (TYPE )1;
      this->auth.challenge.www = xstrdup((char const   *)(line + 18));
    } else {
      tmp___0 = strncasecmp((char const   *)(line + 18), "ntlm", (size_t )4);
      if (tmp___0 == 0) {
        newline += 22;
        this->auth.type.www = (TYPE )2;
        this->auth.challenge.www = xstrdup((char const   *)(line + 18));
      } else
      if ((unsigned int )this->auth.type.www != 1U) {
        if ((unsigned int )this->auth.type.www != 2U) {
          newline += 23;
          this->auth.type.www = (TYPE )0;
        }
      }
    }
    while (1) {
      tmp = __parse_pair___0(& newline);
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
        break;
      }
      option = tmp;
      while (1) {
        if (*tmp) {
          tmp___2 = __ctype_b_loc();
          if ((int const   )*(*tmp___2 + (int )((unsigned char )((int )*tmp))) & 8192) {
            break;
          } else
          if (61 == (int )*tmp) {
            break;
          } else
          if (58 == (int )*tmp) {
            break;
          }
        } else {
          break;
        }
        tmp ++;
      }
      tmp___3 = tmp;
      tmp ++;
      *tmp___3 = (char )'\000';
      while (1) {
        tmp___4 = __ctype_b_loc();
        if (! ((int const   )*(*tmp___4 + (int )((unsigned char )((int )*tmp))) & 8192)) {
          if (! (61 == (int )*tmp)) {
            if (! (58 == (int )*tmp)) {
              break;
            }
          }
        }
        tmp ++;
      }
      value = tmp;
      while (*tmp) {
        tmp ++;
      }
      tmp___6 = strncasecmp((char const   *)option, "realm", (size_t )5);
      if (! tmp___6) {
        if ((unsigned long )value != (unsigned long )((void *)0)) {
          tmp___5 = __dequote(value);
          this->auth.realm.www = xstrdup((char const   *)tmp___5);
        } else {
          this->auth.realm.www = xstrdup("");
        }
      }
    }
  }
  return ((BOOLEAN )1);
}
}
TYPE response_get_www_auth_type(RESPONSE this ) 
{ 


  {
  return (this->auth.type.www);
}
}
char *response_get_www_auth_challenge(RESPONSE this ) 
{ 


  {
  return (this->auth.challenge.www);
}
}
char *response_get_www_auth_realm(RESPONSE this ) 
{ 


  {
  return (this->auth.realm.www);
}
}
BOOLEAN response_set_proxy_authenticate(RESPONSE this , char *line ) 
{ 
  char *tmp ;
  char *option ;
  char *value ;
  char *newline ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
  tmp = (char *)"";
  option = (char *)"";
  value = (char *)"";
  newline = line;
  tmp___6 = strlen("proxy-authenticate");
  tmp___7 = strncasecmp((char const   *)line, "proxy-authenticate", tmp___6);
  if (tmp___7 == 0) {
    tmp___0 = strncasecmp((char const   *)(line + 20), "digest", (size_t )6);
    if (tmp___0 == 0) {
      newline += 26;
      this->auth.type.proxy = (TYPE )1;
      this->auth.challenge.proxy = xstrdup((char const   *)(line + 20));
    } else {
      newline += 25;
      this->auth.type.proxy = (TYPE )0;
    }
    while (1) {
      tmp = __parse_pair___0(& newline);
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
        break;
      }
      option = tmp;
      while (1) {
        if (*tmp) {
          tmp___1 = __ctype_b_loc();
          if ((int const   )*(*tmp___1 + (int )((unsigned char )((int )*tmp))) & 8192) {
            break;
          } else
          if (61 == (int )*tmp) {
            break;
          } else
          if (58 == (int )*tmp) {
            break;
          }
        } else {
          break;
        }
        tmp ++;
      }
      tmp___2 = tmp;
      tmp ++;
      *tmp___2 = (char )'\000';
      while (1) {
        tmp___3 = __ctype_b_loc();
        if (! ((int const   )*(*tmp___3 + (int )((unsigned char )((int )*tmp))) & 8192)) {
          if (! (61 == (int )*tmp)) {
            if (! (58 == (int )*tmp)) {
              break;
            }
          }
        }
        tmp ++;
      }
      value = tmp;
      while (*tmp) {
        tmp ++;
      }
      tmp___5 = strncasecmp((char const   *)option, "realm", (size_t )5);
      if (! tmp___5) {
        if ((unsigned long )value != (unsigned long )((void *)0)) {
          tmp___4 = __dequote(value);
          this->auth.realm.proxy = xstrdup((char const   *)tmp___4);
        } else {
          this->auth.realm.proxy = xstrdup("");
        }
      }
    }
  }
  return ((BOOLEAN )1);
}
}
TYPE response_get_proxy_auth_type(RESPONSE this ) 
{ 


  {
  return (this->auth.type.proxy);
}
}
char *response_get_proxy_auth_challenge(RESPONSE this ) 
{ 


  {
  return (this->auth.challenge.proxy);
}
}
char *response_get_proxy_auth_realm(RESPONSE this ) 
{ 


  {
  return (this->auth.realm.proxy);
}
}
static int __int_value(RESPONSE this , char *key , int def ) 
{ 
  int num ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  num = -1;
  tmp___0 = hash_get(this->headers, key);
  if ((unsigned long )((char *)tmp___0) != (unsigned long )((void *)0)) {
    tmp = hash_get(this->headers, key);
    num = atoi((char const   *)((char *)tmp));
  }
  if (num > 0) {
    tmp___1 = num;
  } else {
    tmp___1 = def;
  }
  return (tmp___1);
}
}
static BOOLEAN __boolean_value(RESPONSE this , char *key , BOOLEAN def ) 
{ 
  BOOLEAN res ;
  char *b ;
  void *tmp ;
  BOOLEAN tmp___0 ;
  BOOLEAN tmp___1 ;

  {
  res = def;
  tmp = hash_get(this->headers, key);
  b = (char *)tmp;
  if ((unsigned long )b == (unsigned long )((void *)0)) {
    res = def;
  } else {
    tmp___1 = strmatch(b, (char *)"true");
    if (tmp___1) {
      res = (BOOLEAN )1;
    } else {
      tmp___0 = strmatch(b, (char *)"false");
      if (tmp___0) {
        res = (BOOLEAN )0;
      } else {
        res = def;
      }
    }
  }
  return (res);
}
}
static char *__parse_pair___0(char **str ) 
{ 
  int okay___0 ;
  char *p ;
  char *pair ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  okay___0 = 0;
  p = *str;
  pair = (char *)((void *)0);
  if (! str) {
    return ((char *)((void *)0));
  } else
  if (! *str) {
    return ((char *)((void *)0));
  }
  while (1) {
    if (*p) {
      if (! ((int )*p != 32)) {
        break;
      }
    } else {
      break;
    }
    p ++;
  }
  tmp = p;
  p ++;
  *tmp = (char)0;
  if (! *p) {
    *str = p;
    return ((char *)((void *)0));
  }
  pair = p;
  while (1) {
    if (*p) {
      if ((int )*p != 59) {
        if (! ((int )*p != 44)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    if (! *p) {
      *str = p;
      return ((char *)((void *)0));
    }
    if ((int )*p == 61) {
      okay___0 = 1;
    }
    p ++;
  }
  tmp___0 = p;
  p ++;
  *tmp___0 = (char)0;
  *str = p;
  if (okay___0) {
    tmp___1 = pair;
  } else {
    tmp___1 = (char *)((void *)0);
  }
  return (tmp___1);
}
}
static char *__rquote(char *str ) 
{ 
  char *ptr ;
  int len ;
  size_t tmp ;

  {
  tmp = strlen((char const   *)str);
  len = (int )tmp;
  ptr = (str + len) - 1;
  while (1) {
    if ((unsigned long )ptr >= (unsigned long )str) {
      if (! ((int )*ptr == 34)) {
        if (! ((int )*ptr == 39)) {
          break;
        }
      }
    } else {
      break;
    }
    ptr --;
  }
  *(ptr + 1) = (char )'\000';
  return (str);
}
}
static char *__lquote(char *str ) 
{ 
  char *ptr ;
  int len ;
  size_t tmp ;

  {
  ptr = str;
  while (1) {
    if (*ptr) {
      if (! ((int )*ptr == 34)) {
        if (! ((int )*ptr == 39)) {
          break;
        }
      }
    } else {
      break;
    }
    ptr ++;
  }
  tmp = strlen((char const   *)ptr);
  len = (int )tmp;
  memmove((void *)str, (void const   *)ptr, (size_t )(len + 1));
  return (str);
}
}
static char *__dequote(char *str ) 
{ 
  char *ptr ;

  {
  ptr = __rquote(str);
  str = __lquote(ptr);
  return (str);
}
}
#pragma merger("0","/tmp/cil-feqK9frv.i","-W,-Wall,-Wunused-value,-g,-O2")
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
extern void SSL_CTX_free(SSL_CTX * ) ;
extern void SSL_free(SSL *ssl ) ;
extern int SSL_read(SSL *ssl , void *buf , int num ) ;
extern int SSL_write(SSL *ssl , void const   *buf , int num ) ;
extern int SSL_get_error(SSL const   *s , int ret_code ) ;
extern int SSL_shutdown(SSL *s ) ;
extern int SSL_get_shutdown(SSL const   *ssl ) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
static int __socket_block(int sock , BOOLEAN block ) ;
static ssize_t __socket_write(int sock , void const   *vbuf , size_t len ) ;
static BOOLEAN __socket_check(CONN *C , SDSET mode ) ;
static BOOLEAN __socket_select(CONN *C , SDSET mode ) ;
static int __socket_create(CONN *C , int domain ) ;
static void __hostname_strip(char *hn , int len ) ;
static BOOLEAN __socket_poll(CONN *C , SDSET mode ) ;
static ssize_t __ssl_socket_write(CONN *C , void const   *vbuf , size_t len ) ;
int new_socket(CONN *C , char const   *hostparam , int portparam ) 
{ 
  int conn ;
  int res ;
  int addrlen ;
  struct sockaddr *s_addr ;
  char hn[512] ;
  int port ;
  int domain ;
  char port_str[10] ;
  struct addrinfo hints ;
  struct addrinfo *addr_res ;
  struct addrinfo *r ;
  char *tmp ;
  BOOLEAN tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  pthread_t tmp___6 ;
  pthread_t tmp___7 ;
  pthread_t tmp___8 ;
  pthread_t tmp___9 ;
  pthread_t tmp___10 ;
  pthread_t tmp___11 ;
  pthread_t tmp___12 ;
  int *tmp___13 ;
  BOOLEAN tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;

  {
  if ((unsigned long )hostparam == (unsigned long )((void *)0)) {
    NOTIFY((LEVEL )2, "Unable to resolve host %s:%d", "sock.c", 118);
    return (-1);
  }
  if ((unsigned int )C->scheme == 2U) {
    C->encrypt = (BOOLEAN )1;
  } else {
    C->encrypt = (BOOLEAN )0;
  }
  C->state = (SDSET )0;
  C->ftp.pasv = (BOOLEAN )1;
  C->ftp.size = (size_t )0;
  memset((void *)(hn), '\000', sizeof(hn));
  tmp___0 = auth_get_proxy_required(my.auth);
  if (tmp___0) {
    tmp = auth_get_proxy_host(my.auth);
    snprintf((char * __restrict  )(hn), sizeof(hn), (char const   * __restrict  )"%s",
             tmp);
    port = auth_get_proxy_port(my.auth);
  } else {
    snprintf((char * __restrict  )(hn), sizeof(hn), (char const   * __restrict  )"%s",
             hostparam);
    port = portparam;
  }
  __hostname_strip(hn, 512);
  if (port < 1) {
    NOTIFY((LEVEL )2, "invalid port number %d in %s:%d", port, "sock.c", 142);
    return (-1);
  } else
  if (port > 65535) {
    NOTIFY((LEVEL )2, "invalid port number %d in %s:%d", port, "sock.c", 142);
    return (-1);
  }
  snprintf((char * __restrict  )(port_str), sizeof(port_str), (char const   * __restrict  )"%d",
           port);
  memset((void *)(& hints), 0, sizeof(struct addrinfo ));
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  hints.ai_protocol = 6;
  res = getaddrinfo((char const   * __restrict  )(hn), (char const   * __restrict  )(port_str),
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& addr_res));
  if (res != 0) {
    NOTIFY((LEVEL )2, "Address resolution failed at %s:%d with the following error:",
           "sock.c", 158);
    tmp___1 = gai_strerror(res);
    NOTIFY((LEVEL )2, "%s", tmp___1);
    return (-1);
  }
  s_addr = addr_res->ai_addr;
  addrlen = (int )addr_res->ai_addrlen;
  domain = addr_res->ai_family;
  tmp___2 = __socket_create(C, domain);
  if (tmp___2 < 0) {
    return (-1);
  }
  conn = connect(C->sock, (struct sockaddr  const  * __restrict  )s_addr, (socklen_t )addrlen);
  pthread_testcancel();
  if (conn < 0) {
    tmp___4 = __errno_location();
    if (*tmp___4 != 115) {
      addr_res = addr_res->ai_next;
      r = addr_res;
      while (r) {
        socket_close(C);
        tmp___3 = __socket_create(C, domain);
        if (tmp___3 < 0) {
          return (-1);
        }
        conn = connect(C->sock, (struct sockaddr  const  * __restrict  )s_addr, (socklen_t )addrlen);
        pthread_testcancel();
        if (conn == 0) {
          break;
        }
        r = r->ai_next;
      }
    }
  }
  if (conn < 0) {
    tmp___15 = __errno_location();
    if (*tmp___15 != 115) {
      tmp___5 = __errno_location();
      switch (*tmp___5) {
      case 13: 
      tmp___6 = pthread_self();
      NOTIFY((LEVEL )2, "socket: %d EACCES", tmp___6);
      break;
      case 99: 
      tmp___7 = pthread_self();
      NOTIFY((LEVEL )2, "socket: %d address is unavailable.", tmp___7);
      break;
      case 110: 
      tmp___8 = pthread_self();
      NOTIFY((LEVEL )2, "socket: %d connection timed out.", tmp___8);
      break;
      case 111: 
      tmp___9 = pthread_self();
      NOTIFY((LEVEL )2, "socket: %d connection refused.", tmp___9);
      break;
      case 101: 
      tmp___10 = pthread_self();
      NOTIFY((LEVEL )2, "socket: %d network is unreachable.", tmp___10);
      break;
      case 106: 
      tmp___11 = pthread_self();
      NOTIFY((LEVEL )2, "socket: %d already connected.", tmp___11);
      break;
      default: 
      tmp___12 = pthread_self();
      NOTIFY((LEVEL )2, "socket: %d unknown network error.", tmp___12);
      break;
      }
      socket_close(C);
      return (-1);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___14 = __socket_check(C, (SDSET )1);
    if ((unsigned int )tmp___14 == 0U) {
      pthread_testcancel();
      NOTIFY((LEVEL )1, "socket: read check timed out(%d) %s:%d", my.timeout, "sock.c",
             273);
      socket_close(C);
      return (-1);
    } else {
      res = connect(C->sock, (struct sockaddr  const  * __restrict  )s_addr, (socklen_t )addrlen);
      if (res < 0) {
        tmp___13 = __errno_location();
        if (*tmp___13 != 106) {
          NOTIFY((LEVEL )2, "socket: unable to connect %s:%d", "sock.c", 282);
          socket_close(C);
          return (-1);
        }
      }
      C->status = (S_STATUS )2;
    }
  }
  tmp___16 = __socket_block(C->sock, (BOOLEAN )1);
  if (tmp___16 < 0) {
    NOTIFY((LEVEL )2, "socket: unable to set socket to non-blocking %s:%d", "sock.c",
           291);
    return (-1);
  }
  C->connection.status = 1;
  return (C->sock);
}
}
static BOOLEAN __socket_check(CONN *C , SDSET mode ) 
{ 
  BOOLEAN tmp ;
  BOOLEAN tmp___0 ;

  {
  if (C->sock >= 1024) {
    tmp = __socket_poll(C, mode);
    return (tmp);
  } else {
    tmp___0 = __socket_select(C, mode);
    return (tmp___0);
  }
}
}
static BOOLEAN __socket_poll(CONN *C , SDSET mode ) 
{ 
  int res ;
  int timo ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  if (my.timeout) {
    tmp = my.timeout * 1000;
  } else {
    tmp = 15000;
  }
  timo = tmp;
  __socket_block(C->sock, (BOOLEAN )0);
  C->pfd[0].fd = C->sock + 1;
  C->pfd[0].events = (short )((int )C->pfd[0].events | 1);
  while (1) {
    res = poll(C->pfd, (nfds_t )1, timo);
    pthread_testcancel();
    if (res < 0) {
      puts("LESS THAN ZERO!");
    }
    if (! (res < 0)) {
      break;
    }
  }
  if (res == 0) {
    tmp___0 = __errno_location();
    *tmp___0 = 110;
  }
  if (res <= 0) {
    C->state = (SDSET )0;
    if (my.timeout) {
      tmp___1 = my.timeout;
    } else {
      tmp___1 = 15;
    }
    NOTIFY((LEVEL )1, "socket: polled(%d) and discovered it\'s not ready %s:%d", tmp___1,
           "sock.c", 343);
    return ((BOOLEAN )0);
  } else {
    C->state = mode;
    return ((BOOLEAN )1);
  }
}
}
static BOOLEAN __socket_select(CONN *C , SDSET mode ) 
{ 
  struct timeval timeout ;
  int res ;
  fd_set rs ;
  fd_set ws ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp ;
  int *tmp___0 ;

  {
  memset((void *)(& timeout), '\000', sizeof(struct timeval ));
  if (my.timeout > 0) {
    timeout.tv_sec = (__time_t )my.timeout;
  } else {
    timeout.tv_sec = (__time_t )30;
  }
  timeout.tv_usec = (__suseconds_t )0;
  if (C->sock < 0) {
    return ((BOOLEAN )0);
  } else
  if (C->sock >= 1024) {
    return ((BOOLEAN )0);
  }
  while (1) {
    while (1) {
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rs.fds_bits[0]): "memory");
      break;
    }
    while (1) {
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& ws.fds_bits[0]): "memory");
      break;
    }
    rs.fds_bits[C->sock / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << C->sock % (8 * (int )sizeof(__fd_mask )));
    ws.fds_bits[C->sock / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << C->sock % (8 * (int )sizeof(__fd_mask )));
    res = select(C->sock + 1, (fd_set * __restrict  )(& rs), (fd_set * __restrict  )(& ws),
                 (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& timeout));
    pthread_testcancel();
    if (res < 0) {
      tmp = __errno_location();
      if (! (*tmp == 4)) {
        break;
      }
    } else {
      break;
    }
  }
  if (res == 0) {
    tmp___0 = __errno_location();
    *tmp___0 = 110;
  }
  if (res <= 0) {
    C->state = (SDSET )0;
    NOTIFY((LEVEL )1, "socket: select and discovered it\'s not ready %s:%d", "sock.c",
           384);
    return ((BOOLEAN )0);
  } else {
    C->state = mode;
    return ((BOOLEAN )1);
  }
}
}
static int __socket_create(CONN *C , int domain ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int opt ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  tmp___0 = socket(domain, 1, 0);
  C->sock = tmp___0;
  if (tmp___0 < 0) {
    tmp = __errno_location();
    switch (*tmp) {
    case 93: 
    NOTIFY((LEVEL )2, "unsupported protocol %s:%d", "sock.c", 401);
    break;
    case 24: 
    NOTIFY((LEVEL )2, "descriptor table full %s:%d", "sock.c", 402);
    break;
    case 23: 
    NOTIFY((LEVEL )2, "file table full %s:%d", "sock.c", 403);
    break;
    case 13: 
    NOTIFY((LEVEL )2, "permission denied %s:%d", "sock.c", 404);
    break;
    case 105: 
    NOTIFY((LEVEL )2, "insufficient buffer %s:%d", "sock.c", 405);
    break;
    default: 
    NOTIFY((LEVEL )2, "unknown socket error %s:%d", "sock.c", 406);
    break;
    }
    socket_close(C);
    return (-1);
  }
  tmp___1 = fcntl(C->sock, 2, 2048);
  if (tmp___1 < 0) {
    NOTIFY((LEVEL )2, "unable to set close control %s:%d", "sock.c", 410);
  }
  if (C->connection.keepalive) {
    opt = 1;
    tmp___3 = setsockopt(C->sock, 1, 9, (void const   *)((char *)(& opt)), (socklen_t )sizeof(opt));
    if (tmp___3 < 0) {
      tmp___2 = __errno_location();
      switch (*tmp___2) {
      case 9: 
      NOTIFY((LEVEL )2, "invalid descriptor %s:%d", "sock.c", 417);
      break;
      case 88: 
      NOTIFY((LEVEL )2, "not a socket %s:%d", "sock.c", 418);
      break;
      case 92: 
      NOTIFY((LEVEL )2, "not a protocol option %s:%d", "sock.c", 419);
      break;
      case 14: 
      NOTIFY((LEVEL )2, "setsockopt unknown %s:%d", "sock.c", 420);
      break;
      default: 
      NOTIFY((LEVEL )2, "unknown sockopt error %s:%d", "sock.c", 421);
      break;
      }
      socket_close(C);
      return (-1);
    }
  }
  tmp___4 = __socket_block(C->sock, (BOOLEAN )0);
  if (tmp___4 < 0) {
    NOTIFY((LEVEL )2, "socket: unable to set socket to non-blocking %s:%d", "sock.c",
           427);
    return (-1);
  }
  return (0);
}
}
static void __hostname_strip(char *hn , int len ) 
{ 
  int i ;
  BOOLEAN tmp ;

  {
  tmp = startswith("[", (char const   *)hn);
  if (tmp) {
    memmove((void *)hn, (void const   *)(hn + 1), (size_t )(len - 1));
    i = 0;
    while (1) {
      if (*(hn + i)) {
        if (! ((int )*(hn + i) != 93)) {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
    if ((int )*(hn + i) == 93) {
      memmove((void *)(hn + i), (void const   *)((hn + i) + 1), (size_t )((len - i) - 1));
    }
  }
  return;
}
}
static int __socket_block(int sock , BOOLEAN block ) 
{ 
  int flags ;
  int retval ;
  int *tmp ;

  {
  if (sock == -1) {
    return (sock);
  }
  flags = fcntl(sock, 3, 0);
  if (flags < 0) {
    tmp = __errno_location();
    switch (*tmp) {
    case 13: 
    NOTIFY((LEVEL )2, "EACCES %s:%d", "sock.c", 478);
    break;
    case 9: 
    NOTIFY((LEVEL )2, "bad file descriptor %s:%d", "sock.c", 479);
    break;
    case 11: 
    NOTIFY((LEVEL )2, "address is unavailable %s:%d", "sock.c", 480);
    break;
    default: 
    NOTIFY((LEVEL )2, "unknown network error %s:%d", "sock.c", 481);
    break;
    }
    return (-1);
  }
  if (block) {
    flags &= -2049;
  } else {
    flags |= 2048;
    flags |= 2048;
  }
  retval = fcntl(sock, 4, flags);
  if (retval < 0) {
    NOTIFY((LEVEL )2, "unable to set fcntl flags %s:%d", "sock.c", 496);
    return (-1);
  }
  return (retval);
}
}
static ssize_t __socket_write(int sock , void const   *vbuf , size_t len ) 
{ 
  size_t n ;
  ssize_t w ;
  char const   *buf ;
  int *tmp ;

  {
  buf = (char const   *)vbuf;
  n = len;
  while (n > 0UL) {
    w = write(sock, (void const   *)buf, n);
    if (w <= 0L) {
      tmp = __errno_location();
      if (*tmp == 4) {
        w = (ssize_t )0;
      } else {
        return ((ssize_t )-1);
      }
    }
    n -= (size_t )w;
    buf += w;
  }
  return ((ssize_t )len);
}
}
static ssize_t __ssl_socket_write(CONN *C , void const   *vbuf , size_t len ) 
{ 
  size_t n ;
  ssize_t w ;
  char const   *buf ;
  int err ;
  int tmp ;

  {
  buf = (char const   *)vbuf;
  n = len;
  while (n > 0UL) {
    tmp = SSL_write(C->ssl, (void const   *)buf, (int )n);
    w = (ssize_t )tmp;
    if (w <= 0L) {
      if (w < 0L) {
        err = SSL_get_error((SSL const   *)C->ssl, (int )w);
        switch (err) {
        case 3: 
        case 2: 
        NOTIFY((LEVEL )0, "SSL_write non-critical error %d", err);
        return ((ssize_t )0);
        case 5: 
        NOTIFY((LEVEL )2, "SSL_write() failed (syscall)");
        return ((ssize_t )-1);
        case 1: 
        return ((ssize_t )-1);
        }
      }
      NOTIFY((LEVEL )2, "SSL_write() failed.");
      return ((ssize_t )-1);
    }
    n -= (size_t )w;
    buf += w;
  }
  return ((ssize_t )len);
}
}
ssize_t socket_read(CONN *C , void *vbuf , size_t len ) 
{ 
  int type ;
  size_t n ;
  ssize_t r ;
  char *buf ;
  int ret_eof ;
  int tmp ;
  BOOLEAN tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  BOOLEAN tmp___5 ;
  int lidos ;
  int tmp___6 ;
  BOOLEAN tmp___7 ;
  ssize_t tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;

  {
  ret_eof = 0;
  pthread_setcanceltype(0, & type);
  buf = (char *)vbuf;
  n = len;
  if ((unsigned int )C->encrypt == 1U) {
    while (n > 0UL) {
      tmp___0 = __socket_check(C, (SDSET )1);
      if ((unsigned int )tmp___0 == 0U) {
        if (my.timeout) {
          tmp = my.timeout;
        } else {
          tmp = 15;
        }
        NOTIFY((LEVEL )1, "socket: read check timed out(%d) %s:%d", tmp, "sock.c",
               595);
        return ((ssize_t )-1);
      }
      tmp___1 = SSL_read(C->ssl, (void *)buf, (int )n);
      r = (ssize_t )tmp___1;
      if (r < 0L) {
        tmp___2 = __errno_location();
        if (*tmp___2 == 4) {
          r = (ssize_t )0;
        } else {
          tmp___3 = SSL_get_error((SSL const   *)C->ssl, (int )r);
          if (tmp___3 == 2) {
            r = (ssize_t )0;
          } else {
            return ((ssize_t )-1);
          }
        }
      } else
      if (r == 0L) {
        break;
      }
      n -= (size_t )r;
      buf += r;
    }
  } else {
    while (n > 0UL) {
      if (C->inbuffer < len) {
        tmp___5 = __socket_check(C, (SDSET )1);
        if ((unsigned int )tmp___5 == 0U) {
          if (my.timeout) {
            tmp___4 = my.timeout;
          } else {
            tmp___4 = 15;
          }
          NOTIFY((LEVEL )1, "socket: read check timed out(%d) %s:%d", tmp___4, "sock.c",
                 614);
          return ((ssize_t )-1);
        }
      }
      if (C->inbuffer < n) {
        memmove((void *)(C->buffer), (void const   *)(& C->buffer[C->pos_ini]), C->inbuffer);
        C->pos_ini = 0;
        tmp___7 = __socket_check(C, (SDSET )1);
        if ((unsigned int )tmp___7 == 0U) {
          if (my.timeout) {
            tmp___6 = my.timeout;
          } else {
            tmp___6 = 15;
          }
          NOTIFY((LEVEL )1, "socket: read check timed out(%d) %s:%d", tmp___6, "sock.c",
                 623);
          return ((ssize_t )-1);
        }
        tmp___8 = read(C->sock, (void *)(& C->buffer[C->inbuffer]), sizeof(C->buffer) - C->inbuffer);
        lidos = (int )tmp___8;
        if (lidos == 0) {
          ret_eof = 1;
        }
        if (lidos < 0) {
          tmp___9 = __errno_location();
          if (*tmp___9 == 4) {
            lidos = 0;
          } else {
            tmp___10 = __errno_location();
            if (*tmp___10 == 11) {
              lidos = 0;
            }
          }
          tmp___13 = __errno_location();
          if (*tmp___13 == 32) {
            return ((ssize_t )0);
          } else {
            tmp___11 = __errno_location();
            tmp___12 = strerror(*tmp___11);
            NOTIFY((LEVEL )2, "socket: read error %s %s:%d", tmp___12, "sock.c", 635);
            return ((ssize_t )0);
          }
        }
        C->inbuffer += (size_t )lidos;
      }
      if (C->inbuffer >= n) {
        r = (ssize_t )n;
      } else {
        r = (ssize_t )C->inbuffer;
      }
      if (r == 0L) {
        break;
      }
      memmove((void *)buf, (void const   *)(& C->buffer[C->pos_ini]), (size_t )r);
      C->pos_ini = (int )((ssize_t )C->pos_ini + r);
      C->inbuffer -= (size_t )r;
      n -= (size_t )r;
      buf += r;
      if (ret_eof) {
        break;
      }
    }
  }
  pthread_setcanceltype(type, (int *)((void *)0));
  pthread_testcancel();
  return ((ssize_t )(len - n));
}
}
ssize_t socket_readline(CONN *C , char *ptr , size_t maxlen ) 
{ 
  int type ;
  int n ;
  int len ;
  int res ;
  char c ;
  char *tmp ;
  ssize_t tmp___0 ;

  {
  len = (int )maxlen;
  pthread_setcanceltype(0, & type);
  n = 1;
  while (n < len) {
    tmp___0 = socket_read(C, (void *)(& c), (size_t )1);
    res = (int )tmp___0;
    if (res == 1) {
      tmp = ptr;
      ptr ++;
      *tmp = c;
      if ((int )c == 10) {
        break;
      }
    } else
    if (res == 0) {
      if (n == 1) {
        return ((ssize_t )0);
      } else {
        break;
      }
    } else {
      return ((ssize_t )-1);
    }
    n ++;
  }
  *ptr = (char)0;
  pthread_setcanceltype(type, (int *)((void *)0));
  pthread_testcancel();
  return ((ssize_t )n);
}
}
int socket_write(CONN *C , void const   *buf , size_t len ) 
{ 
  int type ;
  size_t bytes ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  pthread_setcanceltype(0, & type);
  if ((unsigned int )C->encrypt == 1U) {
    while (1) {
      tmp = __ssl_socket_write(C, buf, len);
      bytes = (size_t )tmp;
      if (bytes != len) {
        if (! (bytes == 0UL)) {
          return (-1);
        }
      }
      if (! (bytes == 0UL)) {
        break;
      }
    }
  } else {
    tmp___0 = __socket_write(C->sock, buf, len);
    bytes = (size_t )tmp___0;
    if (bytes != len) {
      NOTIFY((LEVEL )2, "unable to write to socket %s:%d", "sock.c", 733);
      return (-1);
    }
  }
  pthread_setcanceltype(type, (int *)((void *)0));
  pthread_testcancel();
  return ((int )bytes);
}
}
void socket_close(CONN *C ) 
{ 
  int type ;
  int ret ;
  int tries ;
  int tmp ;

  {
  ret = 0;
  tries = 0;
  if ((unsigned long )C == (unsigned long )((void *)0)) {
    return;
  }
  pthread_setcanceltype(0, & type);
  if ((unsigned int )C->encrypt == 1U) {
    if (! C->connection.reuse) {
      goto _L;
    } else
    if (C->connection.max == 1) {
      _L: /* CIL Label */ 
      if ((unsigned long )C->ssl != (unsigned long )((void *)0)) {
        while (1) {
          ret = SSL_get_shutdown((SSL const   *)C->ssl);
          if (ret < 0) {
            NOTIFY((LEVEL )1, "socket: SSL Socket closed by server: %s:%d", "sock.c",
                   769);
            break;
          }
          ret = SSL_shutdown(C->ssl);
          if (ret == 1) {
            break;
          }
          tries ++;
          if (! (tries < 5)) {
            break;
          }
        }
      }
      SSL_free(C->ssl);
      C->ssl = (SSL *)((void *)0);
      SSL_CTX_free(C->ctx);
      C->ctx = (SSL_CTX *)((void *)0);
      close(C->sock);
      C->sock = -1;
      C->connection.status = 0;
      C->connection.max = 0;
      C->connection.tested = 0;
    }
  } else
  if (C->connection.reuse == 0) {
    goto _L___0;
  } else
  if (C->connection.max == 1) {
    _L___0: /* CIL Label */ 
    if (C->sock != -1) {
      tmp = __socket_block(C->sock, (BOOLEAN )0);
      if (tmp < 0) {
        NOTIFY((LEVEL )2, "unable to set to non-blocking %s:%d", "sock.c", 795);
      }
      if (C->connection.status > 1) {
        ret = shutdown(C->sock, 2);
        if (ret < 0) {
          NOTIFY((LEVEL )2, "unable to shutdown the socket %s:%d", "sock.c", 797);
        }
      }
      ret = close(C->sock);
      if (ret < 0) {
        NOTIFY((LEVEL )2, "unable to close the socket %s:%d", "sock.c", 799);
      }
    }
    C->sock = -1;
    C->connection.status = 0;
    C->connection.max = 0;
    C->connection.tested = 0;
  }
  C = (CONN *)((void *)0);
  pthread_setcanceltype(type, (int *)((void *)0));
  pthread_testcancel();
  return;
}
}
#pragma merger("0","/tmp/cil-YLkNGGSR.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern void *CRYPTO_malloc(size_t num , char const   *file , int line ) ;
extern void CRYPTO_free(void *ptr , char const   *file , int line ) ;
extern unsigned long SSL_CTX_set_options(SSL_CTX *ctx , unsigned long op ) ;
extern int SSL_CTX_set_cipher_list(SSL_CTX * , char const   *str ) ;
extern SSL_CTX *SSL_CTX_new(SSL_METHOD const   *meth ) ;
extern long SSL_CTX_set_timeout(SSL_CTX *ctx , long t ) ;
extern int SSL_set_fd(SSL *s , int fd ) ;
extern int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx , char const   *file , int type ) ;
extern int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx , char const   *file ) ;
extern int SSL_CTX_check_private_key(SSL_CTX const   *ctx ) ;
extern SSL *SSL_new(SSL_CTX *ctx ) ;
extern int SSL_connect(SSL *ssl ) ;
extern long SSL_ctrl(SSL *ssl , int cmd , long larg , void *parg ) ;
extern long SSL_CTX_ctrl(SSL_CTX *ctx , int cmd , long larg , void *parg ) ;
extern SSL_METHOD const   *TLS_client_method(void) ;
extern int OPENSSL_init_ssl(uint64_t opts , OPENSSL_INIT_SETTINGS const   *settings ) ;
extern unsigned long ERR_get_error(void) ;
extern unsigned long ERR_peek_error(void) ;
extern char *ERR_error_string(unsigned long e , char *buf ) ;
extern void ERR_remove_thread_state(void * )  __attribute__((__deprecated__)) ;
extern void ERR_remove_state(unsigned long pid )  __attribute__((__deprecated__)) ;
static pthread_mutex_t *lock_cs  ;
static long *lock_count  ;
unsigned long SSL_pthreads_thread_id(void) ;
static void SSL_error_stack(void) ;
BOOLEAN SSL_initialize(CONN *C , char const   *servername ) 
{ 
  int i ;
  int serr ;
  SSL_METHOD const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if (C->ssl) {
    return ((BOOLEAN )1);
  }
  C->ssl = (SSL *)((void *)0);
  C->ctx = (SSL_CTX *)((void *)0);
  C->method = (SSL_METHOD const   *)((void *)0);
  C->cert = (X509 *)((void *)0);
  if (! my.ssl_key) {
    if (my.ssl_cert) {
      my.ssl_key = my.ssl_cert;
    }
  }
  if (! my.ssl_ciphers) {
    my.ssl_ciphers = stralloc((char *)"ALL:!COMPLEMENTOFDEFAULT:!eNULL");
  }
  tmp = TLS_client_method();
  C->method = (SSL_METHOD const   *)((SSL_METHOD *)tmp);
  if ((unsigned long )C->method == (unsigned long )((void *)0)) {
    SSL_error_stack();
    return ((BOOLEAN )0);
  }
  C->ctx = SSL_CTX_new(C->method);
  if ((unsigned long )C->ctx == (unsigned long )((void *)0)) {
    SSL_error_stack();
    return ((BOOLEAN )0);
  }
  SSL_CTX_ctrl(C->ctx, 33, 3L, (void *)0);
  SSL_CTX_set_options(C->ctx, 33554432UL);
  SSL_CTX_ctrl(C->ctx, 44, 3L, (void *)0);
  SSL_CTX_set_timeout(C->ctx, (long )my.ssl_timeout);
  if (my.ssl_ciphers) {
    tmp___0 = SSL_CTX_set_cipher_list(C->ctx, (char const   *)my.ssl_ciphers);
    if (! tmp___0) {
      NOTIFY((LEVEL )2, "SSL_CTX_set_cipher_list");
      return ((BOOLEAN )0);
    }
  }
  if (my.ssl_cert) {
    tmp___1 = SSL_CTX_use_certificate_chain_file(C->ctx, (char const   *)my.ssl_cert);
    if (! tmp___1) {
      SSL_error_stack();
      NOTIFY((LEVEL )2, "Error reading certificate file: %s", my.ssl_cert);
    }
    i = 0;
    while (i < 3) {
      tmp___2 = SSL_CTX_use_PrivateKey_file(C->ctx, (char const   *)my.ssl_key, 1);
      if (tmp___2) {
        break;
      }
      if (i < 2) {
        tmp___3 = ERR_peek_error();
        if ((int )(tmp___3 & 4095UL) == 100) {
          SSL_error_stack();
          NOTIFY((LEVEL )1, "Wrong pass phrase: retrying");
          goto __Cont;
        }
      }
      __Cont: /* CIL Label */ 
      i ++;
    }
    tmp___4 = SSL_CTX_check_private_key((SSL_CTX const   *)C->ctx);
    if (! tmp___4) {
      NOTIFY((LEVEL )2, "Private key does not match the certificate");
      return ((BOOLEAN )0);
    }
  }
  C->ssl = SSL_new(C->ctx);
  SSL_ctrl(C->ssl, 55, 0L, (void *)((char *)servername));
  if ((unsigned long )C->ssl == (unsigned long )((void *)0)) {
    SSL_error_stack();
    return ((BOOLEAN )0);
  }
  SSL_set_fd(C->ssl, C->sock);
  serr = SSL_connect(C->ssl);
  if (serr != 1) {
    SSL_error_stack();
    tmp___5 = SSL_get_error((SSL const   *)C->ssl, serr);
    NOTIFY((LEVEL )2, "Failed to make an SSL connection: %d", tmp___5);
    return ((BOOLEAN )0);
  }
  return ((BOOLEAN )1);
}
}
void SSL_thread_setup(void) 
{ 
  int x ;
  void *tmp ;
  void *tmp___0 ;

  {
  OPENSSL_init_ssl((uint64_t )0, (OPENSSL_INIT_SETTINGS const   *)((void *)0));
  OPENSSL_init_ssl((uint64_t )2097154L, (OPENSSL_INIT_SETTINGS const   *)((void *)0));
  tmp = CRYPTO_malloc(sizeof(pthread_mutex_t ), "ssl.c", 192);
  lock_cs = (pthread_mutex_t *)tmp;
  tmp___0 = CRYPTO_malloc(sizeof(long ), "ssl.c", 195);
  lock_count = (long *)tmp___0;
  x = 0;
  while (x < 1) {
    *(lock_count + x) = 0L;
    pthread_mutex_init(lock_cs + x, (pthread_mutexattr_t const   *)((void *)0));
    x ++;
  }
  return;
}
}
void SSL_thread_cleanup(void) 
{ 
  int x ;

  {
  xfree((void *)my.ssl_ciphers);
  x = 0;
  while (x < 1) {
    pthread_mutex_destroy(lock_cs + x);
    x ++;
  }
  if ((unsigned long )lock_cs != (unsigned long )((pthread_mutex_t *)((void *)0))) {
    CRYPTO_free((void *)lock_cs, "ssl.c", 217);
    lock_cs = (pthread_mutex_t *)((void *)0);
  }
  if ((unsigned long )lock_count != (unsigned long )((long *)((void *)0))) {
    CRYPTO_free((void *)lock_count, "ssl.c", 221);
    lock_count = (long *)((void *)0);
  }
  while (1) {
    break;
    continue;
  }
  ERR_remove_state(0UL);
  while (1) {
    break;
    continue;
  }
  while (1) {
    break;
    continue;
  }
  while (1) {
    break;
    continue;
  }
  ERR_remove_thread_state((void *)0);
  return;
}
}
unsigned long SSL_pthreads_thread_id(void) 
{ 
  unsigned long ret ;
  pthread_t tmp ;

  {
  tmp = pthread_self();
  ret = tmp;
  return (ret);
}
}
static void SSL_error_stack(void) 
{ 
  unsigned long err ;
  char string[120] ;

  {
  err = ERR_get_error();
  if (! err) {
    return;
  }
  SSL_error_stack();
  ERR_error_string(err, string);
  NOTIFY((LEVEL )2, "stack: %lX : %s", err, string);
  return;
}
}
#pragma merger("0","/tmp/cil-DrdVeJai.i","-W,-Wall,-Wunused-value,-g,-O2")
char *stralloc(char *str ) 
{ 
  char *retval ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)str);
  tmp___0 = calloc(tmp + 1UL, (size_t )1);
  retval = (char *)tmp___0;
  if (! retval) {
    NOTIFY((LEVEL )3, "Fatal memory allocation error");
  }
  strcpy((char * __restrict  )retval, (char const   * __restrict  )str);
  return (retval);
}
}
#pragma merger("0","/tmp/cil-HHYieLee.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) int pthread_kill(pthread_t __threadid , int __signo ) ;
void siege_timer(pthread_t handler ) 
{ 
  int err ;
  time_t now ;
  struct timespec timeout ;
  pthread_mutex_t timer_mutex ;
  pthread_cond_t timer_cond ;
  time_t tmp ;

  {
  timer_mutex.__data.__lock = 0;
  timer_mutex.__data.__count = 0U;
  timer_mutex.__data.__owner = 0;
  timer_mutex.__data.__nusers = 0U;
  timer_mutex.__data.__kind = 0;
  timer_mutex.__data.__spins = (short)0;
  timer_mutex.__data.__elision = (short)0;
  timer_mutex.__data.__list.__prev = (struct __pthread_internal_list *)0;
  timer_mutex.__data.__list.__next = (struct __pthread_internal_list *)0;
  timer_cond.__data.__annonCompField1.__wseq = 0ULL;
  timer_cond.__data.__annonCompField2.__g1_start = 0ULL;
  timer_cond.__data.__g_refs[0] = 0U;
  timer_cond.__data.__g_refs[1] = 0U;
  timer_cond.__data.__g_size[0] = 0U;
  timer_cond.__data.__g_size[1] = 0U;
  timer_cond.__data.__g1_orig_size = 0U;
  timer_cond.__data.__wrefs = 0U;
  timer_cond.__data.__g_signals[0] = 0U;
  timer_cond.__data.__g_signals[1] = 0U;
  tmp = time(& now);
  if (tmp < 0L) {
    NOTIFY((LEVEL )3, "unable to set the siege timer!");
  }
  timeout.tv_sec = now + (time_t )my.secs;
  timeout.tv_nsec = (__syscall_slong_t )0;
  pthread_mutex_lock(& timer_mutex);
  while (1) {
    err = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& timer_cond), (pthread_mutex_t * __restrict  )(& timer_mutex),
                                 (struct timespec  const  * __restrict  )(& timeout));
    if (err == 110) {
      if (my.debug) {
        printf((char const   * __restrict  )"TIMED OUT!!\n");
        fflush(stdout);
      }
      my.verbose = (BOOLEAN )0;
      pthread_kill(handler, 15);
      break;
    }

  }
  pthread_mutex_unlock(& timer_mutex);
  return;
}
}
#pragma merger("0","/tmp/cil-Q5xbCw6K.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strpbrk)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
void url_dump(URL this ) ;
void url_set_scheme(URL this , SCHEME scheme ) ;
char *url_get_scheme_name(URL this ) ;
char *url_get_parameters(URL this ) ;
char *url_get_query(URL this ) ;
char *url_get_fragment(URL this ) ;
char *url_get_posttemp(URL this ) ;
char *url_normalize_string(URL req , char *location ) ;
size_t URLSIZE  =    sizeof(struct URL_T );
static void __url_parse(URL this , char *url ) ;
static void __parse_post_data(URL this , char *datap ) ;
static char *__url_set_absolute(URL this , char *url ) ;
static BOOLEAN __url_has_scheme(char *url ) ;
static BOOLEAN __url_has_credentials(char *url ) ;
static int __url_default_port(URL this ) ;
static char *__url_set_scheme(URL this , char *url ) ;
static char *__url_set_password(URL this , char *str ) ;
static char *__url_set_username(URL this , char *str ) ;
static char *__url_set_hostname(URL this , char *str ) ;
static char *__url_set_port(URL this , char *str ) ;
static char *__url_set_path(URL this , char *str ) ;
static char *__url_set_file(URL this , char *str ) ;
static char *__url_set_parameters(URL this , char *str ) ;
static char *__url_set_query(URL this , char *str ) ;
static char *__url_set_fragment(URL this , char *str ) ;
static char *__url_escape(char const   *s ) ;
static METHOD __url_has_method(char const   *url ) ;
static void __url_replace(char *url , char const   *needle , char const   *replacement ) ;
URL new_url(char *str ) 
{ 
  URL this ;
  void *tmp ;

  {
  tmp = xmalloc(URLSIZE);
  this = (URL )tmp;
  this->ID = 0;
  this->scheme = (SCHEME )1;
  this->hasparams = (BOOLEAN )0;
  this->params = (char *)((void *)0);
  this->redir = (BOOLEAN )0;
  this->method = (METHOD )2;
  this->username = (char *)((void *)0);
  this->password = (char *)((void *)0);
  this->hostname = (char *)((void *)0);
  this->port = 80;
  this->path = (char *)((void *)0);
  this->file = (char *)((void *)0);
  this->params = (char *)((void *)0);
  this->hasparams = (BOOLEAN )0;
  this->query = (char *)((void *)0);
  this->frag = (char *)((void *)0);
  this->request = (char *)((void *)0);
  this->postlen = (size_t )0;
  this->postdata = (char *)((void *)0);
  this->posttemp = (char *)((void *)0);
  this->conttype = (char *)((void *)0);
  this->cached = (BOOLEAN )0;
  this->redir = (BOOLEAN )0;
  __url_parse(this, str);
  return (this);
}
}
URL url_destroy(URL this ) 
{ 


  {
  if ((unsigned long )this != (unsigned long )((void *)0)) {
    xfree((void *)this->url);
    xfree((void *)this->username);
    xfree((void *)this->password);
    xfree((void *)this->hostname);
    if ((unsigned long )this->path != (unsigned long )((void *)0)) {
      if ((int )*(this->path + 0) != 0) {
        xfree((void *)this->path);
      }
    }
    xfree((void *)this->file);
    xfree((void *)this->query);
    xfree((void *)this->frag);
    xfree((void *)this->request);
    xfree((void *)this->conttype);
    xfree((void *)this->postdata);
    xfree((void *)this->posttemp);
    if ((unsigned int )this->hasparams == 1U) {
      xfree((void *)this->params);
    }
    xfree((void *)this);
  }
  return ((URL )((void *)0));
}
}
void url_set_ID(URL this , int ID ) 
{ 


  {
  this->ID = ID;
  return;
}
}
void url_set_scheme(URL this , SCHEME scheme ) 
{ 
  char *tmp ;
  char *str ;
  int n ;
  int len ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  this->scheme = scheme;
  tmp___0 = url_get_scheme_name(this);
  str = strdup((char const   *)tmp___0);
  if ((unsigned long )this->url != (unsigned long )((void *)0)) {
    tmp = xstrdup((char const   *)this->url);
    tmp___1 = strncasecmp((char const   *)tmp, "http:", (size_t )5);
    if (! tmp___1) {
      n = 7;
    }
    tmp___2 = strncasecmp((char const   *)tmp, "https:", (size_t )6);
    if (! tmp___2) {
      n = 8;
    }
    tmp___3 = strncasecmp((char const   *)tmp, "ftp:", (size_t )4);
    if (! tmp___3) {
      n = 6;
    }
    tmp___4 = strlen((char const   *)tmp);
    len = (int )tmp___4;
    memmove((void *)tmp, (void const   *)(tmp + n), (size_t )((len - n) + 1));
    xfree((void *)this->url);
    tmp___5 = strlen((char const   *)tmp);
    tmp___6 = strlen((char const   *)str);
    len = (int )((tmp___5 + tmp___6) + 4UL);
    tmp___7 = xmalloc((size_t )len);
    this->url = (char *)tmp___7;
    memset((void *)this->url, '\000', (size_t )len);
    snprintf((char * __restrict  )this->url, (size_t )len, (char const   * __restrict  )"%s://%s",
             str, tmp);
    xfree((void *)tmp);
    xfree((void *)str);
  }
  return;
}
}
void url_set_hostname(URL this , char *hostname ) 
{ 
  size_t len ;
  BOOLEAN tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  tmp = empty((char const   *)hostname);
  if (tmp) {
    return;
  }
  xfree((void *)this->hostname);
  tmp___0 = strlen((char const   *)hostname);
  len = tmp___0 + 1UL;
  tmp___1 = xmalloc(len);
  this->hostname = (char *)tmp___1;
  memset((void *)this->hostname, '\000', len);
  strncpy((char * __restrict  )this->hostname, (char const   * __restrict  )hostname,
          len);
  return;
}
}
void url_set_redirect(URL this , BOOLEAN redir ) 
{ 


  {
  this->redir = redir;
  return;
}
}
void url_set_conttype(URL this , char *type ) 
{ 


  {
  this->conttype = xstrdup((char const   *)type);
  return;
}
}
void url_set_method(URL this , METHOD method___0 ) 
{ 


  {
  this->method = method___0;
  return;
}
}
void url_set_postdata(URL this , char *postdata , size_t postlen ) 
{ 
  void *tmp ;

  {
  this->postlen = postlen;
  tmp = xmalloc(this->postlen + 1UL);
  this->postdata = (char *)tmp;
  memcpy((void * __restrict  )this->postdata, (void const   * __restrict  )postdata,
         this->postlen);
  *(this->postdata + this->postlen) = (char )'\000';
  return;
}
}
int url_get_ID(URL this ) 
{ 


  {
  return (this->ID);
}
}
char *url_get_absolute(URL this ) 
{ 
  char const   *tmp ;

  {
  if ((unsigned long )this == (unsigned long )((void *)0)) {
    tmp = "NULL";
  } else {
    tmp = (char const   *)this->url;
  }
  return ((char *)tmp);
}
}
SCHEME url_get_scheme(URL this ) 
{ 


  {
  return (this->scheme);
}
}
char *url_get_display(URL this ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  if (my.fullurl) {
    tmp = url_get_absolute(this);
    return (tmp);
  }
  if ((unsigned int )this->method == 2U) {
    tmp___0 = url_get_request(this);
    return (tmp___0);
  }
  tmp___1 = url_get_absolute(this);
  return (tmp___1);
}
}
char *url_get_scheme_name(URL this ) 
{ 


  {
  switch ((unsigned int )this->scheme) {
  case 1U: 
  return ((char *)"http");
  case 2U: 
  return ((char *)"https");
  case 3U: 
  return ((char *)"ftp");
  case 4U: 
  return ((char *)"proxy");
  default: 
  return ((char *)"unsupported");
  }
  return ((char *)"unsupported");
}
}
char *url_get_username(URL this ) 
{ 


  {
  return (this->username);
}
}
char *url_get_password(URL this ) 
{ 


  {
  return (this->password);
}
}
char *url_get_hostname(URL this ) 
{ 


  {
  return (this->hostname);
}
}
int url_get_port(URL this ) 
{ 


  {
  return (this->port);
}
}
char *url_get_path(URL this ) 
{ 


  {
  return (this->path);
}
}
char *url_get_file(URL this ) 
{ 


  {
  return (this->file);
}
}
char *url_get_request(URL this ) 
{ 


  {
  return (this->request);
}
}
char *url_get_parameters(URL this ) 
{ 


  {
  return (this->params);
}
}
char *url_get_query(URL this ) 
{ 


  {
  return (this->query);
}
}
char *url_get_fragment(URL this ) 
{ 


  {
  return (this->frag);
}
}
size_t url_get_postlen(URL this ) 
{ 


  {
  return (this->postlen);
}
}
char *url_get_postdata(URL this ) 
{ 


  {
  return (this->postdata);
}
}
char *url_get_posttemp(URL this ) 
{ 


  {
  return (this->posttemp);
}
}
char *url_get_conttype(URL this ) 
{ 
  BOOLEAN tmp ;

  {
  if ((unsigned long )this->conttype == (unsigned long )((void *)0)) {
    tmp = empty((char const   *)(my.conttype));
    if (tmp) {
      this->conttype = xstrdup("application/x-www-form-urlencoded");
    } else {
      this->conttype = xstrdup((char const   *)(my.conttype));
    }
  }
  return (this->conttype);
}
}
METHOD url_get_method(URL this ) 
{ 


  {
  return (this->method);
}
}
char *url_get_method_name(URL this ) 
{ 


  {
  switch ((unsigned int )this->method) {
  case 3U: 
  return ((char *)"POST");
  case 9U: 
  return ((char *)"PATCH");
  case 4U: 
  return ((char *)"PUT");
  case 5U: 
  return ((char *)"DELETE");
  case 7U: 
  return ((char *)"OPTIONS");
  case 1U: 
  return ((char *)"HEAD");
  default: 
  return ((char *)"GET");
  }
  return ((char *)"GET");
}
}
BOOLEAN url_is_redirect(URL this ) 
{ 


  {
  return (this->redir);
}
}
void url_set_username(URL this , char *username ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)username);
  len = tmp;
  tmp___0 = malloc(len + 1UL);
  this->username = (char *)tmp___0;
  memset((void *)this->username, '\000', len + 1UL);
  memcpy((void * __restrict  )this->username, (void const   * __restrict  )username,
         len);
  return;
}
}
void url_set_password(URL this , char *password ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)password);
  len = tmp;
  tmp___0 = malloc(len + 1UL);
  this->password = (char *)tmp___0;
  memset((void *)this->password, '\000', len + 1UL);
  memcpy((void * __restrict  )this->password, (void const   * __restrict  )password,
         len);
  return;
}
}
void url_dump(URL this ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  printf((char const   * __restrict  )"URL ID:    %d\n", this->ID);
  printf((char const   * __restrict  )"Abolute:   %s\n", this->url);
  tmp = url_get_scheme_name(this);
  printf((char const   * __restrict  )"Scheme:    %s\n", tmp);
  tmp___0 = url_get_method_name(this);
  printf((char const   * __restrict  )"Method:    %s\n", tmp___0);
  tmp___1 = url_get_username(this);
  printf((char const   * __restrict  )"Username:  %s\n", tmp___1);
  tmp___2 = url_get_password(this);
  printf((char const   * __restrict  )"Password:  %s\n", tmp___2);
  tmp___3 = url_get_hostname(this);
  printf((char const   * __restrict  )"Hostname:  %s\n", tmp___3);
  tmp___4 = url_get_port(this);
  printf((char const   * __restrict  )"Port:      %d\n", tmp___4);
  tmp___5 = url_get_path(this);
  printf((char const   * __restrict  )"Path:      %s\n", tmp___5);
  tmp___6 = url_get_file(this);
  printf((char const   * __restrict  )"File:      %s\n", tmp___6);
  tmp___7 = url_get_request(this);
  printf((char const   * __restrict  )"Request:   %s\n", tmp___7);
  if ((unsigned int )this->hasparams == 1U) {
    tmp___8 = url_get_parameters(this);
    printf((char const   * __restrict  )"Params:   %s\n", tmp___8);
  }
  tmp___9 = url_get_query(this);
  printf((char const   * __restrict  )"Query:     %s\n", tmp___9);
  tmp___10 = url_get_fragment(this);
  printf((char const   * __restrict  )"Fragment:  %s\n", tmp___10);
  tmp___11 = url_get_postlen(this);
  printf((char const   * __restrict  )"Post Len:  %d\n", (int )tmp___11);
  tmp___12 = url_get_postdata(this);
  printf((char const   * __restrict  )"Post Data: %s\n", tmp___12);
  tmp___13 = url_get_conttype(this);
  printf((char const   * __restrict  )"Cont Type: %s\n", tmp___13);
  return;
}
}
URL url_normalize(URL req , char *location ) 
{ 
  URL ret ;
  char *url ;
  size_t len ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  SCHEME tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  SCHEME tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  void *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  BOOLEAN tmp___32 ;
  SCHEME tmp___33 ;

  {
  __url_replace(location, "&amp;", "&");
  __url_replace(location, "&#038;", "&");
  tmp = url_get_absolute(req);
  tmp___0 = strlen((char const   *)tmp);
  tmp___1 = strlen((char const   *)location);
  len = (tmp___0 + tmp___1) + 32UL;
  tmp___2 = stristr((char const   *)location, "data:image/gif");
  if (tmp___2) {
    return ((URL )((void *)0));
  }
  tmp___5 = stristr((char const   *)location, "://");
  if (tmp___5) {
    ret = new_url(location);
    tmp___3 = url_get_hostname(ret);
    tmp___4 = strlen((char const   *)tmp___3);
    if (tmp___4 > 1UL) {
      return (ret);
    }
  }
  if ((int )*(location + 0) != 47) {
    if ((int )*(location + 0) != 46) {
      tmp___9 = strchr((char const   *)location, '.');
      if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
        tmp___10 = strchr((char const   *)location, '/');
        if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
          ret = new_url(location);
          tmp___6 = url_get_scheme(req);
          url_set_scheme(ret, tmp___6);
          tmp___7 = url_get_hostname(ret);
          tmp___8 = strchr((char const   *)tmp___7, '.');
          if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
            return (ret);
          }
        }
      }
    }
  }
  tmp___14 = strstr((char const   *)location, "localhost");
  if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
    ret = new_url(location);
    tmp___11 = url_get_scheme(req);
    url_set_scheme(ret, tmp___11);
    tmp___12 = url_get_hostname(ret);
    tmp___13 = strlen((char const   *)tmp___12);
    if (tmp___13 == 9UL) {
      return (ret);
    }
  }
  tmp___15 = malloc(len);
  url = (char *)tmp___15;
  memset((void *)url, '\000', len);
  if ((int )*(location + 0) == 47) {
    tmp___20 = strlen((char const   *)location);
    if (tmp___20 > 1UL) {
      if ((int )*(location + 1) == 47) {
        tmp___16 = url_get_scheme_name(req);
        snprintf((char * __restrict  )url, len, (char const   * __restrict  )"%s:%s",
                 tmp___16, location);
      } else {
        tmp___17 = url_get_port(req);
        tmp___18 = url_get_hostname(req);
        tmp___19 = url_get_scheme_name(req);
        snprintf((char * __restrict  )url, len, (char const   * __restrict  )"%s://%s:%d%s",
                 tmp___19, tmp___18, tmp___17, location);
      }
    } else {
      tmp___17 = url_get_port(req);
      tmp___18 = url_get_hostname(req);
      tmp___19 = url_get_scheme_name(req);
      snprintf((char * __restrict  )url, len, (char const   * __restrict  )"%s://%s:%d%s",
               tmp___19, tmp___18, tmp___17, location);
    }
  } else {
    tmp___31 = url_get_path(req);
    tmp___32 = endswith("/", (char const   *)tmp___31);
    if ((unsigned int )tmp___32 == 1U) {
      if ((int )*(location + 0) == 46) {
        tmp___22 = strlen((char const   *)location);
        if (tmp___22 > 1UL) {
          tmp___21 = location + 2;
        } else {
          tmp___21 = location;
        }
      } else {
        tmp___21 = location;
      }
      tmp___23 = url_get_path(req);
      tmp___24 = url_get_port(req);
      tmp___25 = url_get_hostname(req);
      tmp___26 = url_get_scheme_name(req);
      snprintf((char * __restrict  )url, len, (char const   * __restrict  )"%s://%s:%d%s%s",
               tmp___26, tmp___25, tmp___24, tmp___23, tmp___21);
    } else {
      tmp___27 = url_get_path(req);
      tmp___28 = url_get_port(req);
      tmp___29 = url_get_hostname(req);
      tmp___30 = url_get_scheme_name(req);
      snprintf((char * __restrict  )url, len, (char const   * __restrict  )"%s://%s:%d%s/%s",
               tmp___30, tmp___29, tmp___28, tmp___27, location);
    }
  }
  ret = new_url(url);
  tmp___33 = url_get_scheme(req);
  url_set_scheme(ret, tmp___33);
  free((void *)url);
  return (ret);
}
}
char *url_normalize_string(URL req , char *location ) 
{ 
  char *t ;
  URL u ;
  char *tmp ;

  {
  u = url_normalize(req, location);
  tmp = url_get_absolute(u);
  t = strdup((char const   *)tmp);
  u = url_destroy(u);
  return (t);
}
}
static void __url_parse(URL this , char *url ) 
{ 
  char *ptr ;
  char *esc ;
  char *post ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  BOOLEAN tmp___3 ;

  {
  ptr = (char *)((void *)0);
  esc = (char *)((void *)0);
  esc = __url_escape((char const   *)url);
  if (my.escape) {
    ptr = __url_set_absolute(this, esc);
  } else {
    ptr = __url_set_absolute(this, url);
  }
  ptr = __url_set_scheme(this, ptr);
  post = strstr((char const   *)this->url, " POST");
  if (! post) {
    post = strstr((char const   *)this->url, " PUT");
  }
  if (! post) {
    post = strstr((char const   *)this->url, " PATCH");
  }
  if (! post) {
    post = strstr((char const   *)this->url, " OPTIONS");
  }
  if (! post) {
    post = strstr((char const   *)this->url, " DELETE");
  }
  if ((unsigned long )post != (unsigned long )((void *)0)) {
    tmp___2 = strncasecmp((char const   *)post, " PUT", (size_t )4);
    if (tmp___2) {
      tmp___1 = strncasecmp((char const   *)post, " POST", (size_t )5);
      if (tmp___1) {
        tmp___0 = strncasecmp((char const   *)post, " DELETE", (size_t )7);
        if (tmp___0) {
          tmp = strncasecmp((char const   *)post, " OPTIONS", (size_t )8);
          if (tmp) {
            this->method = (METHOD )9;
            *post = (char )'\000';
            post += 6;
          } else {
            this->method = (METHOD )7;
            *post = (char )'\000';
            post += 8;
          }
        } else {
          this->method = (METHOD )5;
          *post = (char )'\000';
          post += 7;
        }
      } else {
        this->method = (METHOD )3;
        *post = (char )'\000';
        post += 5;
      }
    } else {
      this->method = (METHOD )4;
      *post = (char )'\000';
      post += 4;
    }
    __parse_post_data(this, post);
  } else {
    this->method = (METHOD )2;
    this->postdata = (char *)((void *)0);
    this->posttemp = (char *)((void *)0);
    this->postlen = (size_t )0;
  }
  tmp___3 = __url_has_credentials(ptr);
  if (tmp___3) {
    ptr = __url_set_username(this, ptr);
    ptr = __url_set_password(this, ptr);
  }
  ptr = __url_set_hostname(this, ptr);
  ptr = __url_set_port(this, ptr);
  ptr = __url_set_path(this, ptr);
  ptr = __url_set_file(this, ptr);
  ptr = __url_set_parameters(this, ptr);
  ptr = __url_set_query(this, ptr);
  ptr = __url_set_fragment(this, ptr);
  return;
}
}
static void __parse_post_data(URL this , char *datap ) 
{ 
  unsigned short const   **tmp ;
  BOOLEAN tmp___0 ;

  {
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )*(*tmp + (int )((unsigned int )*datap)) & 8192)) {
      break;
    }
    datap ++;
  }
  if ((int )*datap == 60) {
    datap ++;
    load_file(this, datap);
    datap = __url_set_path(this, datap);
    datap = __url_set_file(this, datap);
    return;
  } else {
    this->postdata = xstrdup((char const   *)datap);
    this->postlen = strlen((char const   *)this->postdata);
    tmp___0 = empty((char const   *)(my.conttype));
    if (tmp___0) {
      this->conttype = xstrdup("application/x-www-form-urlencoded");
    } else {
      this->conttype = xstrdup((char const   *)(my.conttype));
    }
    return;
  }
  return;
}
}
static char *__url_set_absolute(URL this , char *url ) 
{ 
  int n ;
  size_t len ;
  char *slash ;
  char scheme[16] ;
  BOOLEAN tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  BOOLEAN tmp___7 ;

  {
  tmp = empty((char const   *)url);
  if (tmp) {
    return ((char *)((void *)0));
  }
  memset((void *)(scheme), '\000', (size_t )16);
  tmp___0 = strncasecmp((char const   *)url, "http:", (size_t )5);
  if (! tmp___0) {
    n = 7;
    strncpy((char * __restrict  )(scheme), (char const   * __restrict  )"http", (size_t )4);
  }
  tmp___1 = strncasecmp((char const   *)url, "https:", (size_t )6);
  if (! tmp___1) {
    n = 8;
    strncpy((char * __restrict  )(scheme), (char const   * __restrict  )"https", (size_t )5);
  }
  tmp___2 = strncasecmp((char const   *)url, "ftp:", (size_t )4);
  if (! tmp___2) {
    n = 6;
    strncpy((char * __restrict  )(scheme), (char const   * __restrict  )"ftp", (size_t )3);
  }
  tmp___3 = strlen((char const   *)(scheme));
  if (tmp___3 < 3UL) {
    n = 7;
    strncpy((char * __restrict  )(scheme), (char const   * __restrict  )"http", (size_t )4);
  }
  tmp___4 = strlen((char const   *)url);
  len = tmp___4 + 5UL;
  tmp___7 = __url_has_scheme(url);
  if (tmp___7) {
    tmp___6 = xmalloc(len);
    this->url = (char *)tmp___6;
    memset((void *)this->url, '\000', len);
    snprintf((char * __restrict  )this->url, len, (char const   * __restrict  )"%s",
             url);
  } else {
    tmp___5 = xmalloc(len + (size_t )n);
    this->url = (char *)tmp___5;
    memset((void *)this->url, '\000', len + (size_t )n);
    slash = strstr((char const   *)url, "/");
    if (slash) {
      snprintf((char * __restrict  )this->url, len + (size_t )n, (char const   * __restrict  )"%s://%s",
               scheme, url);
    } else {
      snprintf((char * __restrict  )this->url, len + (size_t )n, (char const   * __restrict  )"%s://%s/",
               scheme, url);
    }
  }
  return (this->url);
}
}
static BOOLEAN __url_has_scheme(char *url ) 
{ 
  char const   *p ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  p = (char const   *)url;
  if (! *p) {
    return ((BOOLEAN )0);
  } else {
    tmp = __ctype_b_loc();
    if (! ((int const   )*(*tmp + (int )*p) & 8)) {
      if (! ((int const   )*p == 45)) {
        if (! ((int const   )*p == 43)) {
          return ((BOOLEAN )0);
        }
      }
    }
  }
  p ++;
  while (1) {
    if (*p) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___0 + (int )*p) & 8)) {
        if (! ((int const   )*p == 45)) {
          if (! ((int const   )*p == 43)) {
            break;
          }
        }
      }
    } else {
      break;
    }
    p ++;
  }
  return ((BOOLEAN )((int const   )*p == 58));
}
}
static BOOLEAN __url_has_credentials(char *url ) 
{ 
  char const   *p ;
  char *tmp ;

  {
  tmp = strpbrk((char const   *)url, "@/?#;");
  p = (char const   *)tmp;
  if (! p) {
    return ((BOOLEAN )0);
  } else
  if ((int const   )*p != 64) {
    return ((BOOLEAN )0);
  }
  return ((BOOLEAN )1);
}
}
static int __url_default_port(URL this ) 
{ 


  {
  switch ((unsigned int )this->scheme) {
  case 3U: 
  return (21);
  case 1U: 
  return (80);
  case 2U: 
  return (443);
  default: 
  return (80);
  }
}
}
static char *__url_set_scheme(URL this , char *url ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = strncasecmp((char const   *)this->url, "http:", (size_t )5);
  if (! tmp) {
    this->scheme = (SCHEME )1;
    return (url + 7);
  }
  tmp___0 = strncasecmp((char const   *)this->url, "https:", (size_t )6);
  if (! tmp___0) {
    this->scheme = (SCHEME )2;
    return (url + 8);
  }
  tmp___1 = strncasecmp((char const   *)this->url, "ftp:", (size_t )4);
  if (! tmp___1) {
    this->scheme = (SCHEME )3;
    return (url + 6);
  }
  this->scheme = (SCHEME )0;
  return (url);
}
}
static char *__url_set_username(URL this , char *str ) 
{ 
  int i ;
  char *a ;
  char *s ;
  void *tmp ;

  {
  a = strchr((char const   *)str, '@');
  s = strchr((char const   *)str, '/');
  if (! a) {
    return (str);
  } else
  if (s) {
    if ((unsigned long )a >= (unsigned long )s) {
      return (str);
    }
  }
  i = 0;
  while (1) {
    if (*(str + i)) {
      if ((int )*(str + i) != 58) {
        if ((int )*(str + i) != 64) {
          if (! ((int )*(str + i) != 47)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  if ((int )*(str + i) != 64) {
    if ((int )*(str + i) != 58) {
      return (str);
    }
  }
  tmp = malloc((size_t )(i + 1));
  this->username = (char *)tmp;
  memcpy((void * __restrict  )this->username, (void const   * __restrict  )str, (size_t )(i + 1));
  *(this->username + i) = (char )'\000';
  str += i + 1;
  return (str);
}
}
static char *__url_set_password(URL this , char *str ) 
{ 
  int i ;
  char *a ;
  char *s ;
  void *tmp ;

  {
  a = strchr((char const   *)str, '@');
  s = strchr((char const   *)str, '/');
  if (! a) {
    return (str);
  } else
  if (s) {
    if ((unsigned long )a >= (unsigned long )s) {
      return (str);
    }
  }
  i = 0;
  while ((int )*(str + i) != 64) {
    i ++;
  }
  tmp = xmalloc((size_t )(i + 1));
  this->password = (char *)tmp;
  memcpy((void * __restrict  )this->password, (void const   * __restrict  )str, (size_t )i);
  *(this->password + i) = (char )'\000';
  str += i + 1;
  return (str);
}
}
static char *__url_set_hostname(URL this , char *str ) 
{ 
  int i ;
  int n ;
  int len ;
  size_t tmp ;
  BOOLEAN tmp___0 ;
  BOOLEAN tmp___1 ;
  void *tmp___2 ;

  {
  tmp___0 = startswith("//", (char const   *)str);
  if (tmp___0) {
    n = 2;
    tmp = strlen((char const   *)str);
    len = (int )tmp;
    memmove((void *)str, (void const   *)(str + n), (size_t )((len - n) + 1));
  }
  tmp___1 = startswith("[", (char const   *)str);
  if (tmp___1) {
    i = 0;
    while (1) {
      if (*(str + i)) {
        if (! ((int )*(str + i) != 93)) {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
    if ((int )*(str + i) == 93) {
      i ++;
    }
  } else {
    i = 0;
    while (1) {
      if (*(str + i)) {
        if ((int )*(str + i) != 47) {
          if ((int )*(str + i) != 35) {
            if (! ((int )*(str + i) != 58)) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
  }
  tmp___2 = xmalloc((size_t )(i + 1));
  this->hostname = (char *)tmp___2;
  memset((void *)this->hostname, '\000', (size_t )(i + 1));
  memcpy((void * __restrict  )this->hostname, (void const   * __restrict  )str, (size_t )i);
  if ((int )*(str + i) == 58) {
    str += i + 1;
  } else {
    str += i;
  }
  return (str);
}
}
static char *__url_set_port(URL this , char *str ) 
{ 
  char *portstr ;
  int i ;
  unsigned short const   **tmp ;
  void *tmp___0 ;

  {
  this->port = __url_default_port(this);
  i = 0;
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )*(*tmp + (int )*(str + i)) & 2048)) {
      break;
    }
    i ++;
  }
  if (i == 0) {
    return (str);
  }
  tmp___0 = malloc((size_t )(i + 1));
  portstr = (char *)tmp___0;
  memcpy((void * __restrict  )portstr, (void const   * __restrict  )str, (size_t )(i + 1));
  *(portstr + i) = (char )'\000';
  this->port = atoi((char const   *)portstr);
  xfree((void *)portstr);
  str += i;
  return (str);
}
}
static char *__url_set_path(URL this , char *str ) 
{ 
  int i ;
  int j ;
  char *c ;
  char *tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;

  {
  if ((unsigned long )str != (unsigned long )((void *)0)) {
    if ((int )*(str + 0) == 35) {
      this->request = xstrdup("/");
      return (str);
    }
  }
  this->request = xstrdup((char const   *)str);
  tmp = strstr((char const   *)this->request, "#");
  c = tmp;
  if (c) {
    *c = (char )'\000';
  }
  tmp___0 = strlen((char const   *)str);
  i = (int )tmp___0;
  while (1) {
    if (i > 0) {
      if (! ((int )*(str + i) != 47)) {
        break;
      }
    } else {
      break;
    }
    i --;
  }
  j = 0;
  while (1) {
    if (*(str + j)) {
      if ((int )*(str + j) != 35) {
        tmp___1 = __ctype_b_loc();
        if ((int const   )*(*tmp___1 + (int )*(str + j)) & 8192) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    j ++;
  }
  if ((int )*(str + i) != 47) {
    if ((unsigned int )this->scheme == 3U) {
      this->path = (char *)"";
    } else {
      tmp___2 = xmalloc((size_t )2);
      this->path = (char *)tmp___2;
      tmp___3 = xmalloc((size_t )2);
      this->request = (char *)tmp___3;
      strncpy((char * __restrict  )this->path, (char const   * __restrict  )"/", (size_t )2);
      strncpy((char * __restrict  )this->request, (char const   * __restrict  )"/",
              (size_t )2);
      *(this->path + 1) = (char )'\000';
      *(this->request + 1) = (char )'\000';
    }
  } else {
    tmp___4 = xmalloc((size_t )(i + 2));
    this->path = (char *)tmp___4;
    memcpy((void * __restrict  )this->path, (void const   * __restrict  )str, (size_t )(i + 1));
    *(this->path + i) = (char )'/';
    *(this->path + (i + 1)) = (char )'\000';
    if ((unsigned int )this->scheme == 3U) {
      if ((int )*(this->path + 0) == 47) {
        tmp___5 = strlen((char const   *)this->path);
        memmove((void *)this->path, (void const   *)(this->path + 1), tmp___5);
      }
    }
  }
  trim(this->request);
  str += i + 1;
  return (str);
}
}
static char *__url_set_file(URL this , char *str ) 
{ 
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;

  {
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  if ((unsigned long )this->file != (unsigned long )((void *)0)) {
    tmp = strlen((char const   *)this->file);
    if (tmp > 1UL) {
      return (str);
    }
  }
  i = 0;
  while (1) {
    if (*(str + i)) {
      if ((int )*(str + i) != 59) {
        if ((int )*(str + i) != 63) {
          tmp___0 = __ctype_b_loc();
          if ((int const   )*(*tmp___0 + (int )*(str + i)) & 8192) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  tmp___1 = xmalloc((size_t )(i + 1));
  this->file = (char *)tmp___1;
  memset((void *)this->file, '\000', (size_t )(i + 1));
  memcpy((void * __restrict  )this->file, (void const   * __restrict  )str, (size_t )i);
  trim(this->file);
  if ((int )*(str + i) == 59) {
    this->hasparams = (BOOLEAN )1;
    str += i + 1;
  } else
  if ((int )*(str + i) == 63) {
    str += i + 1;
  } else {
    str += i;
  }
  return (str);
}
}
static char *__url_set_parameters(URL this , char *str ) 
{ 
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;

  {
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  if ((unsigned long )this->params != (unsigned long )((void *)0)) {
    tmp = strlen((char const   *)this->params);
    if (tmp > 1UL) {
      return (str);
    }
  }
  if ((unsigned int )this->hasparams == 0U) {
    this->params = (char *)"";
    return (str);
  }
  i = 0;
  while (1) {
    if (*(str + i)) {
      if ((int )*(str + i) != 63) {
        tmp___0 = __ctype_b_loc();
        if ((int const   )*(*tmp___0 + (int )*(str + i)) & 8192) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  tmp___1 = xmalloc((size_t )(i + 1));
  this->params = (char *)tmp___1;
  memset((void *)this->params, '\000', (size_t )(i + 1));
  memcpy((void * __restrict  )this->params, (void const   * __restrict  )str, (size_t )i);
  if ((int )*(str + i) == 63) {
    str += i + 1;
  } else {
    str += i;
  }
  return (str);
}
}
static char *__url_set_query(URL this , char *str ) 
{ 
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;

  {
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    this->query = xstrcat("");
    return ((char *)((void *)0));
  }
  if ((unsigned long )this->query != (unsigned long )((void *)0)) {
    tmp = strlen((char const   *)this->query);
    if (tmp > 1UL) {
      return (str);
    }
  }
  i = 0;
  while (1) {
    if (*(str + i)) {
      if ((int )*(str + i) != 35) {
        tmp___0 = __ctype_b_loc();
        if ((int const   )*(*tmp___0 + (int )*(str + i)) & 8192) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  tmp___1 = xmalloc((size_t )(i + 1));
  this->query = (char *)tmp___1;
  memset((void *)this->query, '\000', (size_t )(i + 1));
  memcpy((void * __restrict  )this->query, (void const   * __restrict  )str, (size_t )i);
  if ((int )*(str + i) == 35) {
    str += i + 1;
  } else {
    str += i;
  }
  return (str);
}
}
static char *__url_set_fragment(URL this , char *str ) 
{ 
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;

  {
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  if ((unsigned long )this->frag != (unsigned long )((void *)0)) {
    tmp = strlen((char const   *)this->frag);
    if (tmp > 1UL) {
      return (str);
    }
  }
  i = 0;
  while (1) {
    if (*(str + i)) {
      tmp___0 = __ctype_b_loc();
      if ((int const   )*(*tmp___0 + (int )*(str + i)) & 8192) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  tmp___1 = xmalloc((size_t )(i + 1));
  this->frag = (char *)tmp___1;
  memcpy((void * __restrict  )this->frag, (void const   * __restrict  )str, (size_t )i);
  str += i + 1;
  return (str);
}
}
static unsigned char const   urlchr_table[256]  = 
  {      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2};
__inline static enum copy_method decide_copy_method(char const   *p ) 
{ 
  char preempt ;
  int __res ;
  __int32_t const   **tmp___0 ;
  int tmp___1 ;
  int __res___0 ;
  __int32_t const   **tmp___3 ;
  int tmp___4 ;

  {
  if ((int const   )*p == 37) {
    if (((((((((((((((((((((((((unsigned int )*(p + 1) - 48U) & 255U) * 18U) / 17U) * 52U) / 51U) * 58U) / 114U) * 13U) / 11U) * 14U) / 13U) * 35U + 35U) / 36U) * 35U) / 33U) * 34U) / 33U) * 35U) / 170U ^ 4U) - 3U) & 255U) ^ 1U) <= 2U) {
      if (((((((((((((((((((((((((unsigned int )*(p + 2) - 48U) & 255U) * 18U) / 17U) * 52U) / 51U) * 58U) / 114U) * 13U) / 11U) * 14U) / 13U) * 35U + 35U) / 36U) * 35U) / 33U) * 34U) / 33U) * 35U) / 170U ^ 4U) - 3U) & 255U) ^ 1U) <= 2U) {
        if ((int const   )*(p + 1) < 65) {
          tmp___1 = (int const   )*(p + 1) - 48;
        } else {
          if (sizeof(*(p + 1)) > 1UL) {
            __res = toupper((int )*(p + 1));
          } else {
            tmp___0 = __ctype_toupper_loc();
            __res = (int )*(*tmp___0 + (int )*(p + 1));
          }
          tmp___1 = (int const   )((__res - 65) + 10);
        }
        if ((int const   )*(p + 2) < 65) {
          tmp___4 = (int const   )*(p + 2) - 48;
        } else {
          if (sizeof(*(p + 2)) > 1UL) {
            __res___0 = toupper((int )*(p + 2));
          } else {
            tmp___3 = __ctype_toupper_loc();
            __res___0 = (int )*(*tmp___3 + (int )*(p + 2));
          }
          tmp___4 = (int const   )((__res___0 - 65) + 10);
        }
        preempt = (char )((tmp___1 << 4) + tmp___4);
        if ((int const   )urlchr_table[(unsigned char )preempt] & 2) {
          return ((enum copy_method )2);
        } else
        if ((int const   )urlchr_table[(unsigned char )preempt] & 1) {
          return ((enum copy_method )2);
        } else {
          return ((enum copy_method )0);
        }
      } else {
        return ((enum copy_method )1);
      }
    } else {
      return ((enum copy_method )1);
    }
  } else
  if ((int const   )urlchr_table[(unsigned char )*p] & 2) {
    if (! ((int const   )urlchr_table[(unsigned char )*p] & 1)) {
      return ((enum copy_method )1);
    } else {
      return ((enum copy_method )2);
    }
  } else {
    return ((enum copy_method )2);
  }
}
}
static char const   * const  methods[9]  = 
  {      (char const   * const  )" GET",      (char const   * const  )" HEAD",      (char const   * const  )" POST",      (char const   * const  )" PUT", 
        (char const   * const  )" TRACE",      (char const   * const  )" DELETE",      (char const   * const  )" OPTIONS",      (char const   * const  )" CONNECT", 
        (char const   * const  )" PATCH"};
static METHOD __url_has_method(char const   *url ) 
{ 
  unsigned int i ;
  char const   *r ;
  char *tmp ;

  {
  i = 0U;
  r = (char const   *)((void *)0);
  i = 0U;
  while ((unsigned long )i < sizeof(methods) / sizeof(methods[0])) {
    tmp = strstr(url, (char const   *)methods[i]);
    r = (char const   *)tmp;
    if ((unsigned long )r != (unsigned long )((void *)0)) {
      return ((METHOD )i);
    }
    i ++;
  }
  return ((METHOD )0);
}
}
static char *__url_escape(char const   *s ) 
{ 
  char const   *p1 ;
  char *newstr ;
  char *p2 ;
  int oldlen ;
  int newlen ;
  int host_len ;
  char *path_start ;
  char *host_start ;
  int encode_count ;
  int decode_count ;
  METHOD tmp ;
  enum copy_method tmp___0 ;
  void *tmp___1 ;
  enum copy_method tmp___2 ;
  unsigned char c ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int __res ;
  __int32_t const   **tmp___9 ;
  int tmp___10 ;
  int __res___0 ;
  __int32_t const   **tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;

  {
  encode_count = 0;
  decode_count = 0;
  tmp = __url_has_method(s);
  if ((unsigned int )tmp != 0U) {
    return ((char *)s);
  }
  host_start = strstr(s, "//");
  if (host_start) {
    host_start += 2;
  } else {
    host_start = (char *)s;
  }
  path_start = strstr((char const   *)host_start, "/");
  if (path_start) {
    path_start ++;
  } else {
    return ((char *)s);
  }
  p1 = (char const   *)path_start;
  while (*p1) {
    tmp___0 = decide_copy_method(p1);
    switch ((unsigned int )tmp___0) {
    case 1U: 
    encode_count ++;
    break;
    case 0U: 
    decode_count ++;
    break;
    case 2U: 
    break;
    }
    p1 ++;
  }
  if (! encode_count) {
    if (! decode_count) {
      return ((char *)s);
    }
  }
  oldlen = (int )(p1 - s);
  host_len = (int )(path_start - (char *)s);
  newlen = oldlen + 2 * (encode_count - decode_count);
  tmp___1 = xmalloc((size_t )(newlen + 1));
  newstr = (char *)tmp___1;
  memcpy((void * __restrict  )newstr, (void const   * __restrict  )s, (size_t )host_len);
  p1 = (char const   *)path_start;
  p2 = newstr + host_len;
  while (*p1) {
    tmp___2 = decide_copy_method(p1);
    switch ((unsigned int )tmp___2) {
    case 1U: 
    tmp___3 = p1;
    p1 ++;
    c = (unsigned char )*tmp___3;
    tmp___4 = p2;
    p2 ++;
    *tmp___4 = (char )'%';
    tmp___5 = p2;
    p2 ++;
    *tmp___5 = (char )*("0123456789ABCDEF" + ((int )c >> 4));
    tmp___6 = p2;
    p2 ++;
    *tmp___6 = (char )*("0123456789ABCDEF" + ((int )c & 15));
    break;
    case 0U: 
    tmp___7 = p2;
    p2 ++;
    if ((int const   )*(p1 + 1) < 65) {
      tmp___10 = (int const   )*(p1 + 1) - 48;
    } else {
      if (sizeof(*(p1 + 1)) > 1UL) {
        __res = toupper((int )*(p1 + 1));
      } else {
        tmp___9 = __ctype_toupper_loc();
        __res = (int )*(*tmp___9 + (int )*(p1 + 1));
      }
      tmp___10 = (int const   )((__res - 65) + 10);
    }
    if ((int const   )*(p1 + 2) < 65) {
      tmp___13 = (int const   )*(p1 + 2) - 48;
    } else {
      if (sizeof(*(p1 + 2)) > 1UL) {
        __res___0 = toupper((int )*(p1 + 2));
      } else {
        tmp___12 = __ctype_toupper_loc();
        __res___0 = (int )*(*tmp___12 + (int )*(p1 + 2));
      }
      tmp___13 = (int const   )((__res___0 - 65) + 10);
    }
    *tmp___7 = (char )((tmp___10 << 4) + tmp___13);
    p1 += 3;
    break;
    case 2U: 
    tmp___14 = p2;
    p2 ++;
    tmp___15 = p1;
    p1 ++;
    *tmp___14 = (char )*tmp___15;
    }
  }
  *p2 = (char )'\000';
  return (newstr);
}
}
static void __url_replace(char *url , char const   *needle , char const   *replacement ) 
{ 
  char buf[4096] ;
  unsigned int tmp ;
  char *ins ;
  char *str ;
  char const   *tmp___0 ;
  size_t nlen ;
  size_t tmp___1 ;
  size_t rlen ;
  size_t tmp___2 ;
  char const   *p ;
  char *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
  buf[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 4096U)) {
    buf[tmp] = (char)0;
    tmp ++;
  }
  ins = & buf[0];
  str = (char *)((void *)0);
  tmp___0 = (char const   *)url;
  tmp___1 = strlen(needle);
  nlen = tmp___1;
  tmp___2 = strlen(replacement);
  rlen = tmp___2;
  while (1) {
    tmp___3 = strstr(tmp___0, needle);
    p = (char const   *)tmp___3;
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      strcpy((char * __restrict  )ins, (char const   * __restrict  )tmp___0);
      break;
    }
    memcpy((void * __restrict  )ins, (void const   * __restrict  )tmp___0, (size_t )(p - tmp___0));
    ins += p - tmp___0;
    memcpy((void * __restrict  )ins, (void const   * __restrict  )replacement, rlen);
    ins += rlen;
    tmp___0 = p + nlen;
  }
  tmp___8 = strlen((char const   *)(buf));
  tmp___9 = strlen((char const   *)url);
  if (tmp___8 > tmp___9) {
    tmp___4 = strlen((char const   *)(buf));
    tmp___5 = realloc((void *)url, tmp___4 + 1UL);
    str = (char *)tmp___5;
    if ((unsigned long )str == (unsigned long )((void *)0)) {
      return;
    }
    url = str;
    tmp___6 = strlen((char const   *)(buf));
    memset((void *)url, '\000', tmp___6 + 1UL);
  } else {
    tmp___7 = strlen((char const   *)url);
    memset((void *)url, '\000', tmp___7);
  }
  tmp___10 = strlen((char const   *)(buf));
  strncpy((char * __restrict  )url, (char const   * __restrict  )(buf), tmp___10);
  return;
}
}
#pragma merger("0","/tmp/cil-uxOW61aU.i","-W,-Wall,-Wunused-value,-g,-O2")
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
extern int usleep(__useconds_t __useconds ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
 __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strnlen)(char const   *str ,
                                                                                size_t len )  __attribute__((__pure__)) ;
char *lowercase(char *s , size_t len ) ;
void parse_time(char *p ) 
{ 
  size_t x ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  int __res ;
  __int32_t const   **tmp___2 ;
  size_t tmp___3 ;

  {
  x = (size_t )0;
  my.secs = 0;
  my.time = my.secs;
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )*(*tmp + (int )((unsigned char )*(p + x))) & 2048)) {
      break;
    }
    x ++;
  }
  if (x == 0UL) {
    return;
  }
  tmp___0 = substring(p, 0, (int )x);
  my.time = atoi((char const   *)tmp___0);
  while (1) {
    tmp___3 = strlen((char const   *)p);
    if (! (x < tmp___3)) {
      break;
    }
    if (sizeof(*(p + x)) > 1UL) {
      __res = tolower((int )*(p + x));
    } else {
      tmp___2 = __ctype_tolower_loc();
      __res = (int )*(*tmp___2 + (int )*(p + x));
    }
    switch (__res) {
    case 115: 
    my.secs = my.time;
    my.time = 1;
    return;
    case 109: 
    my.secs = my.time * 60;
    my.time = 1;
    return;
    case 104: 
    my.secs = my.time * 3600;
    my.time = 1;
    return;
    default: 
    break;
    }
    x ++;
  }
  if (my.time > 0) {
    if (my.secs <= 0) {
      my.secs = my.time * 60;
    }
  }
  return;
}
}
char *substring(char *str , int start___0 , int len ) 
{ 
  int i ;
  char *ret ;
  char *res ;
  char *ptr ;
  char *end ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  if (len < 1) {
    return ((char *)((void *)0));
  } else
  if (start___0 < 0) {
    return ((char *)((void *)0));
  } else {
    tmp = strlen((char const   *)str);
    if (start___0 > (int )tmp) {
      return ((char *)((void *)0));
    }
  }
  tmp___1 = strlen((char const   *)str);
  if (start___0 + len > (int )tmp___1) {
    tmp___0 = strlen((char const   *)str);
    len = (int )(tmp___0 - (size_t )start___0);
  }
  tmp___2 = xmalloc((size_t )(len + 1));
  ret = (char *)tmp___2;
  res = ret;
  ptr = str;
  end = str;
  i = 0;
  while (i < start___0) {
    i ++;
    ptr ++;
  }
  i = 0;
  while (i < start___0 + len) {
    i ++;
    end ++;
  }
  while ((unsigned long )ptr < (unsigned long )end) {
    tmp___3 = res;
    res ++;
    tmp___4 = ptr;
    ptr ++;
    *tmp___3 = *tmp___4;
  }
  *res = (char)0;
  return (ret);
}
}
BOOLEAN okay(int code ) 
{ 
  int tmp ;

  {
  if (code >= 100) {
    if (code <= 299) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((BOOLEAN )tmp);
}
}
BOOLEAN strmatch(char *option , char *param ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  tmp = strlen((char const   *)param);
  tmp___0 = strncasecmp((char const   *)option, (char const   *)param, tmp);
  if (tmp___0) {
    return ((BOOLEAN )0);
  } else {
    tmp___1 = strlen((char const   *)option);
    tmp___2 = strlen((char const   *)param);
    if (tmp___1 == tmp___2) {
      return ((BOOLEAN )1);
    } else {
      return ((BOOLEAN )0);
    }
  }
}
}
BOOLEAN startswith(char const   *pre , char const   *str ) 
{ 
  size_t lenpre ;
  size_t tmp ;
  size_t lenstr ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = strlen(pre);
  lenpre = tmp;
  tmp___0 = strlen(str);
  lenstr = tmp___0;
  if (lenstr < lenpre) {
    tmp___2 = 0;
  } else {
    tmp___1 = strncmp(pre, str, lenpre);
    tmp___2 = tmp___1 == 0;
  }
  return ((BOOLEAN )tmp___2);
}
}
BOOLEAN endswith(char const   *suffix , char const   *str ) 
{ 
  size_t lenstr ;
  size_t tmp ;
  size_t lensuffix ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  if (! str) {
    return ((BOOLEAN )0);
  } else
  if (! suffix) {
    return ((BOOLEAN )0);
  }
  tmp = strlen(str);
  lenstr = tmp;
  tmp___0 = strlen(suffix);
  lensuffix = tmp___0;
  if (lensuffix > lenstr) {
    return ((BOOLEAN )0);
  }
  tmp___1 = strncmp((str + lenstr) - lensuffix, suffix, lensuffix);
  return ((BOOLEAN )(tmp___1 == 0));
}
}
char *uppercase(char *s , size_t len ) 
{ 
  unsigned char *c ;
  unsigned char *e ;
  int __res ;
  __int32_t const   **tmp___0 ;

  {
  c = (unsigned char *)s;
  e = c + len;
  while ((unsigned long )c < (unsigned long )e) {
    if (sizeof(*c) > 1UL) {
      __res = toupper((int )*c);
    } else {
      tmp___0 = __ctype_toupper_loc();
      __res = (int )*(*tmp___0 + (int )*c);
    }
    *c = (unsigned char )__res;
    c ++;
  }
  return (s);
}
}
char *lowercase(char *s , size_t len ) 
{ 
  unsigned char *c ;
  unsigned char *e ;
  int __res ;
  __int32_t const   **tmp___0 ;

  {
  c = (unsigned char *)s;
  e = c + len;
  while ((unsigned long )c < (unsigned long )e) {
    if (sizeof(*c) > 1UL) {
      __res = tolower((int )*c);
    } else {
      tmp___0 = __ctype_tolower_loc();
      __res = (int )*(*tmp___0 + (int )*c);
    }
    *c = (unsigned char )__res;
    c ++;
  }
  return (s);
}
}
char *stristr(char const   *haystack , char const   *needle ) 
{ 
  char const   *h ;
  char const   *n ;
  int __res ;
  __int32_t const   **tmp___0 ;
  int __res___0 ;
  __int32_t const   **tmp___2 ;
  char const   *tmp___3 ;

  {
  while (1) {
    h = haystack;
    n = needle;
    while (1) {
      if (sizeof((unsigned char )*h) > 1UL) {
        __res = tolower((int )((unsigned char )*h));
      } else {
        tmp___0 = __ctype_tolower_loc();
        __res = (int )*(*tmp___0 + (int )((unsigned char )*h));
      }
      if (sizeof((unsigned char )*n) > 1UL) {
        __res___0 = tolower((int )((unsigned char )*n));
      } else {
        tmp___2 = __ctype_tolower_loc();
        __res___0 = (int )*(*tmp___2 + (int )((unsigned char )*n));
      }
      if (__res == __res___0) {
        if (! *n) {
          break;
        }
      } else {
        break;
      }
      h ++;
      n ++;
    }
    if ((int const   )*n == 0) {
      return ((char *)haystack);
    }
    tmp___3 = haystack;
    haystack ++;
    if (! *tmp___3) {
      break;
    }
  }
  return ((char *)((void *)0));
}
}
void pthread_sleep_np(unsigned int secs ) 
{ 


  {
  sleep(secs);
  return;
}
}
void pthread_usleep_np(unsigned long usec ) 
{ 


  {
  usleep((__useconds_t )usec);
  return;
}
}
float elapsed_time(clock_t time___0 ) 
{ 
  long tps ;
  long tmp ;

  {
  tmp = sysconf(2);
  tps = tmp;
  return ((float )time___0 / (float )tps);
}
}
void echo(char const   *fmt  , ...) 
{ 
  char buf[256] ;
  va_list___0 ap ;
  size_t tmp ;

  {
  if (my.quiet) {
    return;
  }
  if (my.get) {
    __builtin_va_start(ap, fmt);
    vsnprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )fmt,
              ap);
    printf((char const   * __restrict  )"%s", buf);
    __builtin_va_end(ap);
    fflush(stdout);
    return;
  }
  if (my.debug) {
    __builtin_va_start(ap, fmt);
    vsnprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )fmt,
              ap);
    tmp = strlen((char const   *)(buf));
    if (tmp == 1UL) {
      printf((char const   * __restrict  )"%s", buf);
    } else {
      NOTIFY((LEVEL )0, (char const   *)(buf));
    }
    __builtin_va_end(ap);
  }
  return;
}
}
void debug(char const   *fmt  , ...) 
{ 
  char buf[256] ;
  va_list___0 ap ;
  size_t tmp ;

  {
  if (my.quiet) {
    return;
  }
  if (my.debug) {
    __builtin_va_start(ap, fmt);
    vsnprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )fmt,
              ap);
    tmp = strlen((char const   *)(buf));
    if (tmp == 1UL) {
      printf((char const   * __restrict  )"%s", buf);
    } else {
      NOTIFY((LEVEL )0, (char const   *)(buf));
    }
    __builtin_va_end(ap);
  }
  return;
}
}
int pthread_rand_np(unsigned int *ctx ) 
{ 
  int tmp ;

  {
  tmp = rand_r(ctx);
  return (tmp);
}
}
int urandom(void) 
{ 
  int rand___0 ;
  int fd ;
  int len ;
  ssize_t tmp ;

  {
  rand___0 = -1;
  fd = open("/dev/urandom", 0);
  if (fd >= 0) {
    tmp = read(fd, (void *)(& rand___0), sizeof(rand___0));
    len = (int )tmp;
    if (len == -1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: failed to open /dev/urandom\n");
    }
    close(fd);
  }
  return (rand___0);
}
}
 __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strnlen)(char const   *str ,
                                                                                size_t len )  __attribute__((__pure__)) ;
size_t ( __attribute__((__nonnull__(1))) strnlen)(char const   *str , size_t len ) 
{ 
  char const   *end ;
  void *tmp ;
  size_t tmp___0 ;

  {
  tmp = memchr((void const   *)str, '\000', len);
  end = (char const   *)tmp;
  if ((unsigned long )end != (unsigned long )((void *)0)) {
    tmp___0 = (size_t )(end - str);
  } else {
    tmp___0 = len;
  }
  return (tmp___0);
}
}
char const   *strncasestr(char const   *str1 , char const   *str2 , size_t len ) 
{ 
  size_t str1_len ;
  size_t tmp ;
  size_t str2_len ;
  size_t tmp___0 ;
  size_t i ;
  int tmp___1 ;

  {
  tmp = strnlen(str1, len);
  str1_len = tmp;
  tmp___0 = strlen(str2);
  str2_len = tmp___0;
  if (str1_len < 1UL) {
    return ((char const   *)((void *)0));
  } else
  if (str2_len < 1UL) {
    return ((char const   *)((void *)0));
  }
  i = (size_t )0;
  while (i < (str1_len - str2_len) + 1UL) {
    tmp___1 = strncasecmp(str1, str2, str2_len);
    if (tmp___1 == 0) {
      return (str1);
    }
    str1 ++;
    i ++;
  }
  return ((char const   *)((void *)0));
}
}
#pragma merger("0","/tmp/cil-y9tm3x23.i","-W,-Wall,-Wunused-value,-g,-O2")
char const   *version_string  =    "4.1.1";
char const   *program_name  =    "siege";
char const   *author_name  =    "Jeffrey Fulmer, et al.";
char const   *email_address  =    "jeff@joedog.org";
char const   *years  =    "1999-2021";
char const   *copyright  =    "Copyright (C) 2021 by Jeffrey Fulmer, et al.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.\n";
