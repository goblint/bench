/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef unsigned char __uint8_t;
typedef unsigned short __uint16_t;
typedef unsigned int __uint32_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
struct sk_buff ;
struct netdev ;
struct netdev {
   uint32_t addr ;
   uint8_t addr_len ;
   uint8_t hwaddr[6] ;
   uint32_t mtu ;
};
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct rtentry {
   struct list_head list ;
   uint32_t dst ;
   uint32_t gateway ;
   uint32_t netmask ;
   uint8_t flags ;
   uint32_t metric ;
   struct netdev *dev ;
};
struct sk_buff {
   struct list_head list ;
   struct rtentry *rt ;
   struct netdev *dev ;
   int refcnt ;
   uint16_t protocol ;
   uint32_t len ;
   uint32_t dlen ;
   uint32_t seq ;
   uint32_t end_seq ;
   uint8_t *end ;
   uint8_t *head ;
   uint8_t *data ;
   uint8_t *payload ;
};
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef unsigned int __useconds_t;
typedef unsigned int __socklen_t;
typedef __pid_t pid_t;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_711291139 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_214694448 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_214694447 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_214694448 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_711291139 __annonCompField1 ;
   union __anonunion____missing_field_name_214694447 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
union __anonunion_pthread_rwlock_t_656928968 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
typedef union __anonunion_pthread_rwlock_t_656928968 pthread_rwlock_t;
union __anonunion_pthread_rwlockattr_t_145707745 {
   char __size[8] ;
   long __align ;
};
typedef union __anonunion_pthread_rwlockattr_t_145707745 pthread_rwlockattr_t;
typedef __builtin_va_list __gnuc_va_list;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __gnuc_va_list va_list___0;
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
typedef unsigned long nfds_t;
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
struct wait_lock {
   pthread_cond_t ready ;
   pthread_mutex_t lock ;
   uint8_t sleeping ;
};
struct sk_buff_head {
   struct list_head head ;
   uint32_t qlen ;
};
struct sock ;
struct net_ops {
   struct sock *(*alloc_sock)(int protocol ) ;
   int (*init)(struct sock *sk ) ;
   int (*connect)(struct sock *sk , struct sockaddr  const  *addr , int addr_len ,
                  int flags ) ;
   int (*disconnect)(struct sock *sk , int flags ) ;
   int (*write)(struct sock *sk , void const   *buf , int len ) ;
   int (*read)(struct sock *sk , void *buf , int len ) ;
   int (*recv_notify)(struct sock *sk ) ;
   int (*close)(struct sock *sk ) ;
   int (*abort)(struct sock *sk ) ;
};
struct socket ;
struct sock {
   struct socket *sock ;
   struct net_ops *ops ;
   struct wait_lock recv_wait ;
   struct sk_buff_head receive_queue ;
   struct sk_buff_head write_queue ;
   int protocol ;
   int state ;
   int err ;
   short poll_events ;
   uint16_t sport ;
   uint16_t dport ;
   uint32_t saddr ;
   uint32_t daddr ;
};
enum socket_state {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
struct sock_ops ;
struct sock_ops {
   int (*connect)(struct socket *sock , struct sockaddr  const  *addr , int addr_len ,
                  int flags ) ;
   int (*write)(struct socket *sock , void const   *buf , int len ) ;
   int (*read)(struct socket *sock , void *buf , int len ) ;
   int (*close)(struct socket *sock ) ;
   int (*free)(struct socket *sock ) ;
   int (*abort)(struct socket *sock ) ;
   int (*poll)(struct socket *sock ) ;
   int (*getpeername)(struct socket *sock , struct sockaddr * __restrict  addr , socklen_t * __restrict  address_len ) ;
   int (*getsockname)(struct socket *sock , struct sockaddr * __restrict  addr , socklen_t * __restrict  address_len ) ;
};
struct net_family {
   int (*create)(struct socket *sock , int protocol ) ;
};
struct socket {
   struct list_head list ;
   int fd ;
   pid_t pid ;
   int refcnt ;
   enum socket_state state ;
   short type ;
   int flags ;
   struct sock *sk ;
   struct sock_ops *ops ;
   struct wait_lock sleep ;
   pthread_rwlock_t lock ;
};
struct eth_hdr {
   uint8_t dmac[6] ;
   uint8_t smac[6] ;
   uint16_t ethertype ;
   uint8_t payload[] ;
} __attribute__((__packed__)) ;
struct iphdr {
   uint8_t ihl : 4 ;
   uint8_t version : 4 ;
   uint8_t tos ;
   uint16_t len ;
   uint16_t id ;
   uint16_t frag_offset ;
   uint8_t ttl ;
   uint8_t proto ;
   uint16_t csum ;
   uint32_t saddr ;
   uint32_t daddr ;
   uint8_t data[] ;
} __attribute__((__packed__)) ;
typedef long __ssize_t;
typedef __ssize_t ssize_t;
struct __anonstruct_sync_serial_settings_328012391 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
typedef struct __anonstruct_sync_serial_settings_328012391 sync_serial_settings;
struct __anonstruct_te1_settings_503328802 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
typedef struct __anonstruct_te1_settings_503328802 te1_settings;
struct __anonstruct_raw_hdlc_proto_1014196403 {
   unsigned short encoding ;
   unsigned short parity ;
};
typedef struct __anonstruct_raw_hdlc_proto_1014196403 raw_hdlc_proto;
struct __anonstruct_fr_proto_380219538 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
typedef struct __anonstruct_fr_proto_380219538 fr_proto;
struct __anonstruct_fr_proto_pvc_888776187 {
   unsigned int dlci ;
};
typedef struct __anonstruct_fr_proto_pvc_888776187 fr_proto_pvc;
struct __anonstruct_fr_proto_pvc_info_1072026035 {
   unsigned int dlci ;
   char master[16] ;
};
typedef struct __anonstruct_fr_proto_pvc_info_1072026035 fr_proto_pvc_info;
struct __anonstruct_cisco_proto_1072026036 {
   unsigned int interval ;
   unsigned int timeout ;
};
typedef struct __anonstruct_cisco_proto_1072026036 cisco_proto;
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
union __anonunion_ifs_ifsu_6890304 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_6890304 ifs_ifsu ;
};
union __anonunion_ifr_ifrn_352126815 {
   char ifrn_name[16] ;
};
union __anonunion_ifr_ifru_32340664 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
struct ifreq {
   union __anonunion_ifr_ifrn_352126815 ifr_ifrn ;
   union __anonunion_ifr_ifru_32340664 ifr_ifru ;
};
struct icmp_v4 {
   uint8_t type ;
   uint8_t code ;
   uint16_t csum ;
   uint8_t data[] ;
} __attribute__((__packed__)) ;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct sock_type {
   struct sock_ops *sock_ops ;
   struct net_ops *net_ops ;
   int type ;
   int protocol ;
};
typedef int __int32_t;
typedef long __time_t;
typedef __time_t time_t;
typedef __int32_t int32_t;
struct timer {
   struct list_head list ;
   int refcnt ;
   uint32_t expires ;
   int cancelled ;
   void *(*handler)(void * ) ;
   void *arg ;
   pthread_mutex_t lock ;
};
struct tcphdr {
   uint16_t sport ;
   uint16_t dport ;
   uint32_t seq ;
   uint32_t ack_seq ;
   uint8_t rsvd : 4 ;
   uint8_t hl : 4 ;
   uint8_t fin : 1 ;
   uint8_t syn : 1 ;
   uint8_t rst : 1 ;
   uint8_t psh : 1 ;
   uint8_t ack : 1 ;
   uint8_t urg : 1 ;
   uint8_t ece : 1 ;
   uint8_t cwr : 1 ;
   uint16_t win ;
   uint16_t csum ;
   uint16_t urp ;
   uint8_t data[] ;
} __attribute__((__packed__)) ;
struct tcb {
   uint32_t snd_una ;
   uint32_t snd_nxt ;
   uint32_t snd_wnd ;
   uint32_t snd_up ;
   uint32_t snd_wl1 ;
   uint32_t snd_wl2 ;
   uint32_t iss ;
   uint32_t rcv_nxt ;
   uint32_t rcv_wnd ;
   uint32_t rcv_up ;
   uint32_t irs ;
};
struct tcp_sack_block {
   uint32_t left ;
   uint32_t right ;
} __attribute__((__packed__)) ;
struct tcp_sock {
   struct sock sk ;
   int fd ;
   uint16_t tcp_header_len ;
   struct tcb tcb ;
   uint8_t flags ;
   uint8_t backoff ;
   int32_t srtt ;
   int32_t rttvar ;
   uint32_t rto ;
   struct timer *retransmit ;
   struct timer *delack ;
   struct timer *keepalive ;
   struct timer *linger ;
   uint8_t delacks ;
   uint16_t rmss ;
   uint16_t smss ;
   uint16_t cwnd ;
   uint32_t inflight ;
   uint8_t sackok ;
   uint8_t sacks_allowed ;
   uint8_t sacklen ;
   struct tcp_sack_block sacks[4] ;
   uint8_t tsopt ;
   struct sk_buff_head ofo_queue ;
};
struct tcp_options {
   uint16_t options ;
   uint16_t mss ;
   uint8_t sack ;
};
struct tcp_opt_mss {
   uint8_t kind ;
   uint8_t len ;
   uint16_t mss ;
} __attribute__((__packed__)) ;
struct arp_hdr {
   uint16_t hwtype ;
   uint16_t protype ;
   uint8_t hwsize ;
   uint8_t prosize ;
   uint16_t opcode ;
   unsigned char data[] ;
} __attribute__((__packed__)) ;
struct arp_ipv4 {
   unsigned char smac[6] ;
   uint32_t sip ;
   unsigned char dmac[6] ;
   uint32_t dip ;
} __attribute__((__packed__)) ;
struct arp_cache_entry {
   struct list_head list ;
   uint16_t hwtype ;
   uint32_t sip ;
   unsigned char smac[6] ;
   unsigned int state ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
typedef unsigned int __mode_t;
typedef unsigned long pthread_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
struct ipc_thread {
   struct list_head list ;
   int sock ;
   pthread_t id ;
};
struct ipc_msg {
   uint16_t type ;
   pid_t pid ;
   uint8_t data[] ;
} __attribute__((__packed__)) ;
struct ipc_err {
   int rc ;
   int err ;
   uint8_t data[] ;
} __attribute__((__packed__)) ;
struct ipc_socket {
   int domain ;
   int type ;
   int protocol ;
} __attribute__((__packed__)) ;
struct ipc_connect {
   int sockfd ;
   struct sockaddr addr ;
   socklen_t addrlen ;
} __attribute__((__packed__)) ;
struct ipc_write {
   int sockfd ;
   size_t len ;
   uint8_t buf[] ;
} __attribute__((__packed__)) ;
struct ipc_read {
   int sockfd ;
   size_t len ;
   uint8_t buf[] ;
} __attribute__((__packed__)) ;
struct ipc_close {
   int sockfd ;
} __attribute__((__packed__)) ;
struct ipc_pollfd {
   int fd ;
   short events ;
   short revents ;
} __attribute__((__packed__)) ;
struct ipc_poll {
   nfds_t nfds ;
   int timeout ;
   struct ipc_pollfd fds[] ;
} __attribute__((__packed__)) ;
struct ipc_fcntl {
   int sockfd ;
   int cmd ;
   uint8_t data[] ;
} __attribute__((__packed__)) ;
struct ipc_sockopt {
   int fd ;
   int level ;
   int optname ;
   socklen_t optlen ;
   uint8_t optval[] ;
} __attribute__((__packed__)) ;
struct ipc_sockname {
   int socket ;
   socklen_t address_len ;
   uint8_t sa_data[128] ;
};
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
#pragma merger("0","/tmp/cil-WegLBHp4.i","-Wall,-pthread")
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
uint8_t *skb_head(struct sk_buff *skb ) ;
__inline static void list_init(struct list_head *head )
{
  struct list_head *tmp ;

  {
  tmp = head;
  head->next = tmp;
  head->prev = tmp;
  return;
}
}
struct sk_buff *alloc_skb(unsigned int size ) ;
void free_skb(struct sk_buff *skb ) ;
uint8_t *skb_push(struct sk_buff *skb , unsigned int len ) ;
void *skb_reserve(struct sk_buff *skb , unsigned int len ) ;
void skb_reset_header(struct sk_buff *skb ) ;
struct sk_buff *alloc_skb(unsigned int size )
{
  struct sk_buff *skb ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = malloc(sizeof(struct sk_buff ));
  skb = (struct sk_buff *)tmp;
  memset((void *)skb, 0, sizeof(struct sk_buff ));
  tmp___0 = malloc((size_t )size);
  skb->data = (uint8_t *)tmp___0;
  memset((void *)skb->data, 0, (size_t )size);
  skb->refcnt = 0;
  skb->head = skb->data;
  skb->end = skb->data + size;
  list_init(& skb->list);
  return (skb);
}
}
void free_skb(struct sk_buff *skb )
{


  {
  if (skb->refcnt < 1) {
    free((void *)skb->head);
    free((void *)skb);
  }
  return;
}
}
void *skb_reserve(struct sk_buff *skb , unsigned int len )
{


  {
  skb->data += len;
  return ((void *)skb->data);
}
}
uint8_t *skb_push(struct sk_buff *skb , unsigned int len )
{


  {
  skb->data -= len;
  skb->len += len;
  return (skb->data);
}
}
uint8_t *skb_head(struct sk_buff *skb )
{


  {
  return (skb->head);
}
}
void skb_reset_header(struct sk_buff *skb )
{


  {
  skb->data = skb->end - skb->dlen;
  skb->len = skb->dlen;
  return;
}
}
/* compiler builtin:
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#pragma merger("0","/tmp/cil-C5KPgRKR.i","-Wall,-pthread")
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format
                   , ...) ;
extern int usleep(__useconds_t __useconds ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_init)(pthread_rwlock_t * __restrict  __rwlock ,
                                                                                                pthread_rwlockattr_t const   * __restrict  __attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_rdlock)(pthread_rwlock_t *__rwlock ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_wrlock)(pthread_rwlock_t *__rwlock ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_unlock)(pthread_rwlock_t *__rwlock ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
__inline static int wait_init(struct wait_lock *w )
{


  {
  pthread_cond_init((pthread_cond_t * __restrict  )(& w->ready), (pthread_condattr_t const   * __restrict  )((void *)0));
  pthread_mutex_init(& w->lock, (pthread_mutexattr_t const   *)((void *)0));
  w->sleeping = (uint8_t )0;
  return (0);
}
}
__inline static int wait_wakeup(struct wait_lock *w )
{


  {
  pthread_mutex_lock(& w->lock);
  pthread_cond_signal(& w->ready);
  w->sleeping = (uint8_t )0;
  pthread_mutex_unlock(& w->lock);
  return (0);
}
}
__inline static void wait_free(struct wait_lock *w )
{


  {
  wait_wakeup(w);
  pthread_mutex_destroy(& w->lock);
  pthread_cond_destroy(& w->ready);
  return;
}
}
__inline static void list_add_tail(struct list_head *new , struct list_head *head )
{


  {
  (head->prev)->next = new;
  new->prev = head->prev;
  new->next = head;
  head->prev = new;
  return;
}
}
__inline static void list_del(struct list_head *elem )
{
  struct list_head *prev ;
  struct list_head *next ;

  {
  prev = elem->prev;
  next = elem->next;
  prev->next = next;
  next->prev = prev;
  return;
}
}
int _socket(pid_t pid , int domain , int type , int protocol ) ;
int _connect(pid_t pid , int sockfd , struct sockaddr  const  *addr , socklen_t addrlen ) ;
int _write(pid_t pid , int sockfd , void const   *buf , unsigned int const   count ) ;
int _read(pid_t pid , int sockfd , void *buf , unsigned int const   count ) ;
int _close(pid_t pid , int sockfd ) ;
int _poll(pid_t pid , struct pollfd *fds , nfds_t nfds , int timeout ) ;
int _fcntl(pid_t pid , int fildes , int cmd  , ...) ;
int _getsockopt(pid_t pid , int fd___0 , int level , int optname , void *optval ,
                socklen_t *optlen ) ;
int _getpeername(pid_t pid , int socket___0 , struct sockaddr * __restrict  address ,
                 socklen_t * __restrict  address_len ) ;
int _getsockname(pid_t pid , int socket___0 , struct sockaddr * __restrict  address ,
                 socklen_t * __restrict  address_len ) ;
struct socket *socket_lookup(uint16_t remoteport , uint16_t localport ) ;
struct socket *socket_find(struct socket *find ) ;
int socket_rd_acquire(struct socket *sock ) ;
int socket_wr_acquire(struct socket *sock ) ;
int socket_release(struct socket *sock ) ;
int socket_free(struct socket *sock ) ;
int socket_delete(struct socket *sock ) ;
void abort_sockets(void) ;
void socket_debug(void) ;
void timer_oneshot(uint32_t expire , void *(*handler)(void * ) , void *arg ) ;
static int sock_amount  =    0;
static struct list_head sockets  =    {& sockets, & sockets};
static pthread_rwlock_t slock  =    {{0U, 0U, 0U, 0U, 0U, 0U, 0, 0, (signed char)0, {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0}, 0UL, 0U}};
struct net_family inet ;
static struct net_family *families[128]  = {      (struct net_family *)0,      (struct net_family *)0,      & inet};
static struct socket *alloc_socket(pid_t pid ) ;
static int fd  =    4097;
static struct socket *alloc_socket(pid_t pid )
{
  struct socket *sock ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = malloc(sizeof(struct socket ));
  sock = (struct socket *)tmp;
  list_init(& sock->list);
  sock->pid = pid;
  sock->refcnt = 1;
  pthread_rwlock_wrlock(& slock);
  tmp___0 = fd;
  fd ++;
  sock->fd = tmp___0;
  pthread_rwlock_unlock(& slock);
  sock->state = (enum socket_state )1;
  sock->ops = (struct sock_ops *)((void *)0);
  sock->flags = 2;
  wait_init(& sock->sleep);
  pthread_rwlock_init((pthread_rwlock_t * __restrict  )(& sock->lock), (pthread_rwlockattr_t const   * __restrict  )((void *)0));
  return (sock);
}
}
int socket_rd_acquire(struct socket *sock )
{
  int rc ;
  int tmp ;

  {
  tmp = pthread_rwlock_rdlock(& sock->lock);
  rc = tmp;
  (sock->refcnt) ++;
  return (rc);
}
}
int socket_wr_acquire(struct socket *sock )
{
  int rc ;
  int tmp ;

  {
  tmp = pthread_rwlock_wrlock(& sock->lock);
  rc = tmp;
  (sock->refcnt) ++;
  return (rc);
}
}
int socket_release(struct socket *sock )
{
  int rc ;

  {
  rc = 0;
  (sock->refcnt) --;
  if (sock->refcnt == 0) {
    rc = pthread_rwlock_unlock(& sock->lock);
    free((void *)sock);
  } else {
    rc = pthread_rwlock_unlock(& sock->lock);
  }
  return (rc);
}
}
int socket_free(struct socket *sock )
{


  {
  pthread_rwlock_wrlock(& slock);
  socket_wr_acquire(sock);
  list_del(& sock->list);
  sock_amount --;
  pthread_rwlock_unlock(& slock);
  if (sock->ops) {
    (*((sock->ops)->free))(sock);
  }
  wait_free(& sock->sleep);
  socket_release(sock);
  return (0);
}
}
static void *socket_garbage_collect(void *arg )
{
  struct socket *sock ;
  struct socket *tmp ;

  {
  tmp = socket_find((struct socket *)arg);
  sock = tmp;
  if ((unsigned long )sock == (unsigned long )((void *)0)) {
    return ((void *)0);
  }
  socket_free(sock);
  return ((void *)0);
}
}
int socket_delete(struct socket *sock )
{
  int rc ;

  {
  rc = 0;
  if ((unsigned int )sock->state == 4U) {
    goto out;
  }
  sock->state = (enum socket_state )4;
  timer_oneshot((uint32_t )10000, & socket_garbage_collect, (void *)sock);
  out:
  return (rc);
}
}
void abort_sockets(void)
{
  struct list_head *item ;
  struct list_head *tmp ;
  struct socket *sock ;

  {
  item = sockets.next;
  tmp = item->next;
  while ((unsigned long )item != (unsigned long )(& sockets)) {
    sock = (struct socket *)((char *)item - (unsigned long )(& ((struct socket *)0)->list));
    (*((sock->ops)->abort))(sock);
    item = tmp;
    tmp = item->next;
  }
  return;
}
}
static struct socket *get_socket(pid_t pid , uint32_t fd___0 )
{
  struct list_head *item ;
  struct socket *sock ;

  {
  sock = (struct socket *)((void *)0);
  pthread_rwlock_rdlock(& slock);
  item = sockets.next;
  while ((unsigned long )item != (unsigned long )(& sockets)) {
    sock = (struct socket *)((char *)item - (unsigned long )(& ((struct socket *)0)->list));
    if (sock->pid == pid) {
      if ((uint32_t )sock->fd == fd___0) {
        goto out;
      }
    }
    item = item->next;
  }
  sock = (struct socket *)((void *)0);
  out:
  pthread_rwlock_unlock(& slock);
  return (sock);
}
}
struct socket *socket_lookup(uint16_t remoteport , uint16_t localport )
{
  struct list_head *item ;
  struct socket *sock ;
  struct sock *sk ;

  {
  sock = (struct socket *)((void *)0);
  sk = (struct sock *)((void *)0);
  pthread_rwlock_rdlock(& slock);
  item = sockets.next;
  while ((unsigned long )item != (unsigned long )(& sockets)) {
    sock = (struct socket *)((char *)item - (unsigned long )(& ((struct socket *)0)->list));
    if ((unsigned long )sock == (unsigned long )((void *)0)) {
      goto __Cont;
    } else
    if ((unsigned long )sock->sk == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    sk = sock->sk;
    if ((int )sk->sport == (int )localport) {
      if ((int )sk->dport == (int )remoteport) {
        goto found;
      }
    }
    __Cont: /* CIL Label */
    item = item->next;
  }
  sock = (struct socket *)((void *)0);
  found:
  pthread_rwlock_unlock(& slock);
  return (sock);
}
}
struct socket *socket_find(struct socket *find )
{
  struct list_head *item ;
  struct socket *sock ;

  {
  sock = (struct socket *)((void *)0);
  pthread_rwlock_rdlock(& slock);
  item = sockets.next;
  while ((unsigned long )item != (unsigned long )(& sockets)) {
    sock = (struct socket *)((char *)item - (unsigned long )(& ((struct socket *)0)->list));
    if ((unsigned long )sock == (unsigned long )find) {
      goto out;
    }
    item = item->next;
  }
  sock = (struct socket *)((void *)0);
  out:
  pthread_rwlock_unlock(& slock);
  return (sock);
}
}
void socket_debug(void)
{


  {
  return;
}
}
int _socket(pid_t pid , int domain , int type , int protocol )
{
  struct socket *sock ;
  struct net_family *family ;
  int tmp ;
  int rc ;

  {
  sock = alloc_socket(pid);
  if ((unsigned long )sock == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not alloc socket\n");
    return (-1);
  }
  sock->type = (short )type;
  family = families[domain];
  if (! family) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Domain not supported: %d\n",
            domain);
    goto abort_socket;
  }
  tmp = (*(family->create))(sock, protocol);
  if (tmp != 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Creating domain failed\n");
    goto abort_socket;
  }
  pthread_rwlock_wrlock(& slock);
  list_add_tail(& sock->list, & sockets);
  sock_amount ++;
  socket_rd_acquire(sock);
  pthread_rwlock_unlock(& slock);
  rc = sock->fd;
  socket_release(sock);
  return (rc);
  abort_socket:
  socket_free(sock);
  return (-1);
}
}
int _connect(pid_t pid , int sockfd , struct sockaddr  const  *addr , socklen_t addrlen )
{
  struct socket *sock ;
  int rc ;
  int tmp ;

  {
  sock = get_socket(pid, (uint32_t )sockfd);
  if ((unsigned long )sock == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Connect: could not find socket (fd %u) for connection (pid %d)\n",
            sockfd, pid);
    return (-9);
  }
  socket_wr_acquire(sock);
  tmp = (*((sock->ops)->connect))(sock, addr, (int )addrlen, 0);
  rc = tmp;
  switch (rc) {
  case -110:
  case -111:
  case -97:
  case -22:
  socket_release(sock);
  socket_free(sock);
  break;
  default:
  socket_release(sock);
  }
  return (rc);
}
}
int _write(pid_t pid , int sockfd , void const   *buf , unsigned int const   count )
{
  struct socket *sock ;
  int rc ;
  int tmp ;

  {
  sock = get_socket(pid, (uint32_t )sockfd);
  if ((unsigned long )sock == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Write: could not find socket (fd %u) for connection (pid %d)\n",
            sockfd, pid);
    return (-9);
  }
  socket_wr_acquire(sock);
  tmp = (*((sock->ops)->write))(sock, buf, (int )count);
  rc = tmp;
  socket_release(sock);
  return (rc);
}
}
int _read(pid_t pid , int sockfd , void *buf , unsigned int const   count )
{
  struct socket *sock ;
  int rc ;
  int tmp ;

  {
  sock = get_socket(pid, (uint32_t )sockfd);
  if ((unsigned long )sock == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Read: could not find socket (fd %u) for connection (pid %d)\n",
            sockfd, pid);
    return (-9);
  }
  socket_wr_acquire(sock);
  tmp = (*((sock->ops)->read))(sock, buf, (int )count);
  rc = tmp;
  socket_release(sock);
  return (rc);
}
}
int _close(pid_t pid , int sockfd )
{
  struct socket *sock ;
  int rc ;
  int tmp ;

  {
  sock = get_socket(pid, (uint32_t )sockfd);
  if ((unsigned long )sock == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Close: could not find socket (fd %u) for connection (pid %d)\n",
            sockfd, pid);
    return (-9);
  }
  socket_wr_acquire(sock);
  tmp = (*((sock->ops)->close))(sock);
  rc = tmp;
  socket_release(sock);
  return (rc);
}
}
int _poll(pid_t pid , struct pollfd *fds , nfds_t nfds , int timeout )
{
  int polled ;
  int i ;
  struct socket *sock ;
  struct pollfd *poll___0 ;

  {
  while (1) {
    polled = 0;
    i = 0;
    while ((nfds_t )i < nfds) {
      poll___0 = fds + i;
      sock = get_socket(pid, (uint32_t )poll___0->fd);
      if ((unsigned long )sock == (unsigned long )((void *)0)) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Poll: could not find socket (fd %u) for connection (pid %d)\n",
                poll___0->fd, pid);
        return (-9);
      }
      socket_rd_acquire(sock);
      poll___0->revents = (short )((int )(sock->sk)->poll_events & ((((int )poll___0->events | 16) | 8) | 32));
      if ((int )poll___0->revents > 0) {
        polled ++;
      }
      socket_release(sock);
      i ++;
    }
    if (polled > 0) {
      return (polled);
    } else
    if (timeout == 0) {
      return (polled);
    } else {
      if (timeout > 0) {
        if (timeout > 10) {
          timeout -= 10;
        } else {
          timeout = 0;
        }
      }
      usleep((__useconds_t )10000);
    }
  }
  return (-11);
}
}
int _fcntl(pid_t pid , int fildes , int cmd  , ...)
{
  struct socket *sock ;
  va_list___0 ap ;
  int rc ;
  int tmp ;

  {
  sock = get_socket(pid, (uint32_t )fildes);
  if ((unsigned long )sock == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Fcntl: could not find socket (fd %u) for connection (pid %d)\n",
            fildes, pid);
    return (-9);
  }
  socket_wr_acquire(sock);
  rc = 0;
  switch (cmd) {
  case 3:
  rc = sock->flags;
  goto out;
  case 4:
  __builtin_va_start(ap, cmd);
  tmp = __builtin_va_arg(ap, int );
  sock->flags = tmp;
  __builtin_va_end(ap);
  rc = 0;
  goto out;
  default:
  rc = -1;
  goto out;
  }
  rc = -1;
  out:
  socket_release(sock);
  return (rc);
}
}
int _getsockopt(pid_t pid , int fd___0 , int level , int optname , void *optval ,
                socklen_t *optlen )
{
  struct socket *sock ;
  int rc ;

  {
  sock = get_socket(pid, (uint32_t )fd___0);
  if ((unsigned long )sock == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Getsockopt: could not find socket (fd %u) for connection (pid %d)\n",
            fd___0, pid);
    return (-9);
  }
  rc = 0;
  socket_rd_acquire(sock);
  switch (level) {
  case 1:
  switch (optname) {
  case 4:
  *optlen = (socklen_t )4;
  *((int *)optval) = (sock->sk)->err;
  rc = 0;
  break;
  default:
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Getsockopt unsupported optname %d\n",
          optname);
  rc = -92;
  break;
  }
  break;
  default:
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Getsockopt: Unsupported level %d\n",
          level);
  rc = -22;
  break;
  }
  socket_release(sock);
  return (rc);
}
}
int _getpeername(pid_t pid , int socket___0 , struct sockaddr * __restrict  address ,
                 socklen_t * __restrict  address_len )
{
  struct socket *sock ;
  int rc ;
  int tmp ;

  {
  sock = get_socket(pid, (uint32_t )socket___0);
  if ((unsigned long )sock == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Getpeername: could not find socket (fd %u) for connection (pid %d)\n",
            socket___0, pid);
    return (-9);
  }
  socket_rd_acquire(sock);
  tmp = (*((sock->ops)->getpeername))(sock, address, address_len);
  rc = tmp;
  socket_release(sock);
  return (rc);
}
}
int _getsockname(pid_t pid , int socket___0 , struct sockaddr * __restrict  address ,
                 socklen_t * __restrict  address_len )
{
  struct socket *sock ;
  int rc ;
  int tmp ;

  {
  sock = get_socket(pid, (uint32_t )socket___0);
  if ((unsigned long )sock == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Getsockname: could not find socket (fd %u) for connection (pid %d)\n",
            socket___0, pid);
    return (-9);
  }
  socket_rd_acquire(sock);
  tmp = (*((sock->ops)->getsockname))(sock, address, address_len);
  rc = tmp;
  socket_release(sock);
  return (rc);
}
}
#pragma merger("0","/tmp/cil-6UFVE7KM.i","-Wall,-pthread")
extern  __attribute__((__nothrow__)) uint32_t ntohl(uint32_t __netlong )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
uint16_t checksum(void *addr , int count , int start_sum ) ;
__inline static struct iphdr *ip_hdr(struct sk_buff  const  *skb )
{


  {
  return ((struct iphdr *)(skb->head + sizeof(struct eth_hdr )));
}
}
int ip_rcv(struct sk_buff *skb ) ;
void icmpv4_incoming(struct sk_buff *skb ) ;
void tcp_in(struct sk_buff *skb ) ;
static void ip_init_pkt(struct iphdr *ih )
{


  {
  ih->saddr = ntohl(ih->saddr);
  ih->daddr = ntohl(ih->daddr);
  ih->len = ntohs(ih->len);
  ih->id = ntohs(ih->id);
  return;
}
}
int ip_rcv(struct sk_buff *skb )
{
  struct iphdr *ih ;
  struct iphdr *tmp ;
  uint16_t csum ;

  {
  tmp = ip_hdr((struct sk_buff  const  *)skb);
  ih = tmp;
  csum = (uint16_t )-1;
  if ((int )ih->version != 4) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Datagram version was not IPv4\n");
    goto drop_pkt;
  }
  if ((int )ih->ihl < 5) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"IPv4 header length must be at least 5\n");
    goto drop_pkt;
  }
  if ((int )ih->ttl == 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Time to live of datagram reached 0\n");
    goto drop_pkt;
  }
  csum = checksum((void *)ih, (int )ih->ihl * 4, 0);
  if ((int )csum != 0) {
    goto drop_pkt;
  }
  ip_init_pkt(ih);
  switch ((int )ih->proto) {
  case 1:
  icmpv4_incoming(skb);
  return (0);
  case 6:
  tcp_in(skb);
  return (0);
  default:
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unknown IP header proto\n");
  goto drop_pkt;
  }
  drop_pkt:
  free_skb(skb);
  return (0);
}
}
#pragma merger("0","/tmp/cil-P_MaA2bJ.i","-Wall,-pthread")
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern void perror(char const   *__s ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request
                                               , ...) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag
                                                   , ...) ;
int run_cmd(char *cmd  , ...) ;
static int tun_fd  ;
static char *dev  ;
char *tapaddr  =    (char *)"10.0.0.5";
char *taproute  =    (char *)"10.0.0.0/24";
static int set_if_route(char *dev___0 , char *cidr )
{
  int tmp ;

  {
  tmp = run_cmd((char *)"ip route add dev %s %s", dev___0, cidr);
  return (tmp);
}
}
static int set_if_address(char *dev___0 , char *cidr )
{
  int tmp ;

  {
  tmp = run_cmd((char *)"ip address add dev %s local %s", dev___0, cidr);
  return (tmp);
}
}
static int set_if_up(char *dev___0 )
{
  int tmp ;

  {
  tmp = run_cmd((char *)"ip link set dev %s up", dev___0);
  return (tmp);
}
}
static int tun_alloc(char *dev___0 )
{
  struct ifreq ifr ;
  int fd___0 ;
  int err ;

  {
  fd___0 = open("/dev/net/tap", 2);
  if (fd___0 < 0) {
    perror("Cannot open TUN/TAP dev\nMake sure one exists with \'$ mknod /dev/net/tap c 10 200\'");
    exit(1);
  }
  memset((void *)(& ifr), 0, sizeof(ifr));
  ifr.ifr_ifru.ifru_flags = (short)4098;
  if (*dev___0) {
    strncpy((char * __restrict  )(ifr.ifr_ifrn.ifrn_name), (char const   * __restrict  )dev___0,
            (size_t )16);
  }
  err = ioctl(fd___0, (unsigned long )(((1U << 30) | (unsigned int )(84 << 8)) | 202U) | (sizeof(int ) << 16),
              (void *)(& ifr));
  if (err < 0) {
    perror("ERR: Could not ioctl tun");
    close(fd___0);
    return (err);
  }
  strcpy((char * __restrict  )dev___0, (char const   * __restrict  )(ifr.ifr_ifrn.ifrn_name));
  return (fd___0);
}
}
int tun_read(char *buf , int len )
{
  ssize_t tmp ;

  {
  tmp = read(tun_fd, (void *)buf, (size_t )len);
  return ((int )tmp);
}
}
int tun_write(char *buf , int len )
{
  ssize_t tmp ;

  {
  tmp = write(tun_fd, (void const   *)buf, (size_t )len);
  return ((int )tmp);
}
}
void tun_init(void)
{
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = calloc((size_t )10, (size_t )1);
  dev = (char *)tmp;
  tun_fd = tun_alloc(dev);
  tmp___0 = set_if_up(dev);
  if (tmp___0 != 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR when setting up if\n");
  }
  tmp___1 = set_if_route(dev, taproute);
  if (tmp___1 != 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR when setting route for if\n");
  }
  tmp___2 = set_if_address(dev, tapaddr);
  if (tmp___2 != 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR when setting addr for if\n");
  }
  return;
}
}
void free_tun(void)
{


  {
  free((void *)dev);
  return;
}
}
#pragma merger("0","/tmp/cil-xwputfFT.i","-Wall,-pthread")
void icmpv4_reply(struct sk_buff *skb ) ;
int ip_output(struct sock *sk , struct sk_buff *skb ) ;
void icmpv4_incoming(struct sk_buff *skb )
{
  struct iphdr *iphdr ;
  struct iphdr *tmp ;
  struct icmp_v4 *icmp ;

  {
  tmp = ip_hdr((struct sk_buff  const  *)skb);
  iphdr = tmp;
  icmp = (struct icmp_v4 *)(iphdr->data);
  switch ((int )icmp->type) {
  case 8:
  icmpv4_reply(skb);
  return;
  case 3:
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ICMPv4 received \'dst unreachable\' code %d, check your routes and firewall rules\n",
          (int )icmp->code);
  goto drop_pkt;
  default:
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ICMPv4 did not match supported types\n");
  goto drop_pkt;
  }
  drop_pkt:
  free_skb(skb);
  return;
}
}
void icmpv4_reply(struct sk_buff *skb )
{
  struct iphdr *iphdr ;
  struct iphdr *tmp ;
  struct icmp_v4 *icmp ;
  struct sock sk ;
  uint16_t icmp_len ;

  {
  tmp = ip_hdr((struct sk_buff  const  *)skb);
  iphdr = tmp;
  memset((void *)(& sk), 0, sizeof(struct sock ));
  icmp_len = (uint16_t )((int )iphdr->len - (int )iphdr->ihl * 4);
  skb_reserve(skb, (unsigned int )((sizeof(struct eth_hdr ) + sizeof(struct iphdr )) + (unsigned long )icmp_len));
  skb_push(skb, (unsigned int )icmp_len);
  icmp = (struct icmp_v4 *)skb->data;
  icmp->type = (uint8_t )0;
  icmp->csum = (uint16_t )0;
  icmp->csum = checksum((void *)icmp, (int )icmp_len, 0);
  skb->protocol = (uint16_t )1;
  sk.daddr = iphdr->saddr;
  ip_output(& sk, skb);
  free_skb(skb);
  return;
}
}
#pragma merger("0","/tmp/cil-WyAbGNMk.i","-Wall,-pthread")
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
__inline static int wait_sleep(struct wait_lock *w )
{


  {
  w->sleeping = (uint8_t )1;
  pthread_cond_wait((pthread_cond_t * __restrict  )(& w->ready), (pthread_mutex_t * __restrict  )(& w->lock));
  return (0);
}
}
struct sock *sk_alloc(struct net_ops *ops , int protocol ) ;
void sock_free(struct sock *sk ) ;
void sock_init_data(struct socket *sock , struct sock *sk ) ;
int inet_create(struct socket *sock , int protocol ) ;
int inet_socket(struct socket *sock , int protocol ) ;
int inet_connect(struct socket *sock , struct sockaddr *addr , int addr_len , int flags ) ;
int inet_write(struct socket *sock , void const   *buf , int len ) ;
int inet_read(struct socket *sock , void *buf , int len ) ;
int inet_close(struct socket *sock ) ;
int inet_free(struct socket *sock ) ;
int inet_abort(struct socket *sock ) ;
int inet_getpeername(struct socket *sock , struct sockaddr * __restrict  address ,
                     socklen_t * __restrict  address_len ) ;
int inet_getsockname(struct socket *sock , struct sockaddr * __restrict  address ,
                     socklen_t * __restrict  address_len ) ;
struct sock *inet_lookup(struct sk_buff *skb , uint16_t sport , uint16_t dport ) ;
struct net_ops tcp_ops ;
static int inet_stream_connect(struct socket *sock , struct sockaddr  const  *addr ,
                               int addr_len , int flags ) ;
static int INET_OPS  =    1;
struct net_family inet  =    {& inet_create};
static struct sock_ops inet_stream_ops  =
     {& inet_stream_connect, & inet_write, & inet_read, & inet_close, & inet_free, & inet_abort,
    (int (*)(struct socket *sock ))0, & inet_getpeername, & inet_getsockname};
static struct sock_type inet_ops[1]  = {      {& inet_stream_ops, & tcp_ops, 1, 6}};
int inet_create(struct socket *sock , int protocol )
{
  struct sock *sk ;
  struct sock_type *skt ;
  int i ;

  {
  skt = (struct sock_type *)((void *)0);
  i = 0;
  while (i < INET_OPS) {
    if (inet_ops[i].type & (int )sock->type) {
      skt = & inet_ops[i];
      break;
    }
    i ++;
  }
  if (! skt) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not find socktype for socket\n");
    return (1);
  }
  sock->ops = skt->sock_ops;
  sk = sk_alloc(skt->net_ops, protocol);
  sk->protocol = protocol;
  sock_init_data(sock, sk);
  return (0);
}
}
int inet_socket(struct socket *sock , int protocol )
{


  {
  return (0);
}
}
int inet_connect(struct socket *sock , struct sockaddr *addr , int addr_len , int flags )
{


  {
  return (0);
}
}
static int inet_stream_connect(struct socket *sock , struct sockaddr  const  *addr ,
                               int addr_len , int flags )
{
  struct sock *sk ;
  int rc ;

  {
  sk = sock->sk;
  rc = 0;
  if ((unsigned long )addr_len < sizeof(addr->sa_family)) {
    return (-22);
  }
  if ((int const   )addr->sa_family == 0) {
    (*((sk->ops)->disconnect))(sk, flags);
    return (-97);
  }
  switch ((unsigned int )sock->state) {
  default:
  sk->err = -22;
  goto out;
  case 3U:
  sk->err = -106;
  goto out;
  case 2U:
  sk->err = -114;
  goto out;
  case 1U:
  sk->err = -106;
  if (sk->state != 6) {
    goto out;
  }
  (*((sk->ops)->connect))(sk, addr, addr_len, flags);
  sock->state = (enum socket_state )2;
  sk->err = -115;
  if (sock->flags & 2048) {
    goto out;
  }
  pthread_mutex_lock(& sock->sleep.lock);
  while (1) {
    if ((unsigned int )sock->state == 2U) {
      if (! (sk->err == -115)) {
        break;
      }
    } else {
      break;
    }
    socket_release(sock);
    wait_sleep(& sock->sleep);
    socket_wr_acquire(sock);
  }
  pthread_mutex_unlock(& sock->sleep.lock);
  socket_wr_acquire(sock);
  switch (sk->err) {
  case -111:
  case -110:
  goto sock_error;
  }
  if (sk->err != 0) {
    goto out;
  }
  sock->state = (enum socket_state )3;
  break;
  }
  out:
  return (sk->err);
  sock_error:
  rc = sk->err;
  return (rc);
}
}
int inet_write(struct socket *sock , void const   *buf , int len )
{
  struct sock *sk ;
  int tmp ;

  {
  sk = sock->sk;
  tmp = (*((sk->ops)->write))(sk, buf, len);
  return (tmp);
}
}
int inet_read(struct socket *sock , void *buf , int len )
{
  struct sock *sk ;
  int tmp ;

  {
  sk = sock->sk;
  tmp = (*((sk->ops)->read))(sk, buf, len);
  return (tmp);
}
}
struct sock *inet_lookup(struct sk_buff *skb , uint16_t sport , uint16_t dport )
{
  struct socket *sock ;
  struct socket *tmp ;

  {
  tmp = socket_lookup(sport, dport);
  sock = tmp;
  if ((unsigned long )sock == (unsigned long )((void *)0)) {
    return ((struct sock *)((void *)0));
  }
  return (sock->sk);
}
}
int inet_close(struct socket *sock )
{
  struct sock *sk ;
  int tmp ;

  {
  if (! sock) {
    return (0);
  }
  sk = sock->sk;
  tmp = (*(((sock->sk)->ops)->close))(sk);
  return (tmp);
}
}
int inet_free(struct socket *sock )
{
  struct sock *sk ;

  {
  sk = sock->sk;
  sock_free(sk);
  free((void *)sock->sk);
  return (0);
}
}
int inet_abort(struct socket *sock )
{
  struct sock *sk ;

  {
  sk = sock->sk;
  if (sk) {
    (*((sk->ops)->abort))(sk);
  }
  return (0);
}
}
int inet_getpeername(struct socket *sock , struct sockaddr * __restrict  address ,
                     socklen_t * __restrict  address_len )
{
  struct sock *sk ;
  struct sockaddr_in *res ;

  {
  sk = sock->sk;
  if ((unsigned long )sk == (unsigned long )((void *)0)) {
    return (-1);
  }
  res = (struct sockaddr_in *)address;
  res->sin_family = (sa_family_t )2;
  res->sin_port = htons(sk->dport);
  res->sin_addr.s_addr = htonl(sk->daddr);
  *address_len = (socklen_t )sizeof(struct sockaddr_in );
  return (0);
}
}
int inet_getsockname(struct socket *sock , struct sockaddr * __restrict  address ,
                     socklen_t * __restrict  address_len )
{
  struct sock *sk ;
  struct sockaddr_in *res ;

  {
  sk = sock->sk;
  if ((unsigned long )sk == (unsigned long )((void *)0)) {
    return (-1);
  }
  res = (struct sockaddr_in *)address;
  res->sin_family = (sa_family_t )2;
  res->sin_port = htons(sk->sport);
  res->sin_addr.s_addr = htonl(sk->saddr);
  *address_len = (socklen_t )sizeof(struct sockaddr_in );
  return (0);
}
}
#pragma merger("0","/tmp/cil-Wf3rA_D9.i","-Wall,-pthread")
extern  __attribute__((__nothrow__)) int rand(void) ;
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
uint32_t parse_ipv4_string(char *addr ) ;
__inline static uint32_t skb_queue_len(struct sk_buff_head  const  *list )
{


  {
  return ((uint32_t )list->qlen);
}
}
__inline static void skb_queue_init(struct sk_buff_head *list )
{


  {
  list_init(& list->head);
  list->qlen = (uint32_t )0;
  return;
}
}
__inline static struct sk_buff *skb_dequeue(struct sk_buff_head *list )
{
  struct sk_buff *skb ;

  {
  skb = (struct sk_buff *)((char *)list->head.next - (unsigned long )(& ((struct sk_buff *)0)->list));
  list_del(& skb->list);
  (list->qlen) --;
  return (skb);
}
}
__inline static int skb_queue_empty(struct sk_buff_head  const  *list )
{
  uint32_t tmp ;

  {
  tmp = skb_queue_len(list);
  return (tmp < 1U);
}
}
__inline static struct sk_buff *skb_peek(struct sk_buff_head *list )
{
  int tmp ;

  {
  tmp = skb_queue_empty((struct sk_buff_head  const  *)list);
  if (tmp) {
    return ((struct sk_buff *)((void *)0));
  }
  return ((struct sk_buff *)((char *)list->head.next - (unsigned long )(& ((struct sk_buff *)0)->list)));
}
}
__inline static void skb_queue_free(struct sk_buff_head *list )
{
  struct sk_buff *skb ;

  {
  skb = (struct sk_buff *)((void *)0);
  while (1) {
    skb = skb_peek(list);
    if (! ((unsigned long )skb != (unsigned long )((void *)0))) {
      break;
    }
    skb_dequeue(list);
    (skb->refcnt) --;
    free_skb(skb);
  }
  return;
}
}
struct timer *timer_add(uint32_t expire , void *(*handler)(void * ) , void *arg ) ;
void timer_release(struct timer *t ) ;
void timer_cancel(struct timer *t ) ;
int timer_get_tick(void) ;
void tcp_init(void) ;
int generate_iss(void) ;
struct sock *tcp_alloc_sock(void) ;
int tcp_v4_init_sock(struct sock *sk ) ;
int tcp_init_sock(struct sock *sk ) ;
void __tcp_set_state(struct sock *sk , uint32_t state ) ;
int tcp_v4_checksum(struct sk_buff *skb , uint32_t saddr , uint32_t daddr ) ;
int tcp_v4_connect(struct sock *sk , struct sockaddr  const  *addr , int addrlen ,
                   int flags ) ;
int tcp_connect(struct sock *sk ) ;
int tcp_disconnect(struct sock *sk , int flags ) ;
int tcp_write(struct sock *sk , void const   *buf , int len ) ;
int tcp_read(struct sock *sk , void *buf , int len ) ;
int tcp_receive(struct tcp_sock *tsk , void *buf , int len ) ;
int tcp_input_state(struct sock *sk , struct tcphdr *th , struct sk_buff *skb ) ;
int tcp_queue_fin(struct sock *sk ) ;
int tcp_send(struct tcp_sock *tsk , void const   *buf , int len ) ;
int tcp_send_reset(struct tcp_sock *tsk ) ;
int tcp_recv_notify(struct sock *sk ) ;
int tcp_close(struct sock *sk ) ;
int tcp_abort(struct sock *sk ) ;
int tcp_done(struct sock *sk ) ;
void tcp_rtt(struct tcp_sock *tsk ) ;
void tcp_handle_fin_state(struct sock *sk ) ;
void tcp_enter_time_wait(struct sock *sk ) ;
void tcp_clear_timers(struct sock *sk ) ;
void tcp_stop_rto_timer(struct tcp_sock *tsk ) ;
void tcp_release_rto_timer(struct tcp_sock *tsk ) ;
void tcp_stop_delack_timer(struct tcp_sock *tsk ) ;
void tcp_release_delack_timer(struct tcp_sock *tsk ) ;
void tcp_rearm_user_timeout(struct sock *sk ) ;
int tcp_calculate_sacks(struct tcp_sock *tsk ) ;
static pthread_rwlock_t tcplock  =    {{0U, 0U, 0U, 0U, 0U, 0U, 0, 0, (signed char)0, {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0}, 0UL, 0U}};
struct net_ops tcp_ops  =
     {(struct sock *(*)(int protocol ))(& tcp_alloc_sock), & tcp_v4_init_sock, & tcp_v4_connect,
    & tcp_disconnect, & tcp_write, & tcp_read, & tcp_recv_notify, & tcp_close, & tcp_abort};
void tcp_init(void)
{


  {
  return;
}
}
static void tcp_init_segment(struct tcphdr *th , struct iphdr *ih , struct sk_buff *skb )
{


  {
  th->sport = ntohs(th->sport);
  th->dport = ntohs(th->dport);
  th->seq = ntohl(th->seq);
  th->ack_seq = ntohl(th->ack_seq);
  th->win = ntohs(th->win);
  th->csum = ntohs(th->csum);
  th->urp = ntohs(th->urp);
  skb->seq = th->seq;
  skb->dlen = (uint32_t )(((int )ih->len - (int )ih->ihl * 4) - ((int )th->hl << 2));
  skb->len = (skb->dlen + (uint32_t )th->syn) + (uint32_t )th->fin;
  skb->end_seq = skb->seq + skb->dlen;
  skb->payload = th->data;
  return;
}
}
static void tcp_clear_queues(struct tcp_sock *tsk )
{


  {
  skb_queue_free(& tsk->ofo_queue);
  return;
}
}
void tcp_in(struct sk_buff *skb )
{
  struct sock *sk ;
  struct iphdr *iph ;
  struct tcphdr *th ;

  {
  iph = ip_hdr((struct sk_buff  const  *)skb);
  th = (struct tcphdr *)(iph->data);
  tcp_init_segment(th, iph, skb);
  sk = inet_lookup(skb, th->sport, th->dport);
  if ((unsigned long )sk == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No TCP socket for sport %d dport %d\n",
            (int )th->sport, (int )th->dport);
    free_skb(skb);
    return;
  }
  socket_wr_acquire(sk->sock);
  tcp_input_state(sk, th, skb);
  socket_release(sk->sock);
  return;
}
}
int tcp_udp_checksum(uint32_t saddr , uint32_t daddr , uint8_t proto , uint8_t *data ,
                     uint16_t len )
{
  uint32_t sum ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;

  {
  sum = (uint32_t )0;
  sum += saddr;
  sum += daddr;
  tmp = htons((uint16_t )proto);
  sum += (uint32_t )tmp;
  tmp___0 = htons(len);
  sum += (uint32_t )tmp___0;
  tmp___1 = checksum((void *)data, (int )len, (int )sum);
  return ((int )tmp___1);
}
}
int tcp_v4_checksum(struct sk_buff *skb , uint32_t saddr , uint32_t daddr )
{
  int tmp ;

  {
  tmp = tcp_udp_checksum(saddr, daddr, (uint8_t )6, skb->data, (uint16_t )skb->len);
  return (tmp);
}
}
struct sock *tcp_alloc_sock(void)
{
  struct tcp_sock *tsk ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct tcp_sock ));
  tsk = (struct tcp_sock *)tmp;
  memset((void *)tsk, 0, sizeof(struct tcp_sock ));
  tsk->sk.state = 6;
  tsk->sackok = (uint8_t )1;
  tsk->rmss = (uint16_t )1460;
  tsk->smss = (uint16_t )536;
  skb_queue_init(& tsk->ofo_queue);
  return ((struct sock *)tsk);
}
}
int tcp_v4_init_sock(struct sock *sk )
{


  {
  tcp_init_sock(sk);
  return (0);
}
}
int tcp_init_sock(struct sock *sk )
{


  {
  return (0);
}
}
void __tcp_set_state(struct sock *sk , uint32_t state )
{


  {
  sk->state = (int )state;
  return;
}
}
static uint16_t generate_port(void) ;
static int port  =    40000;
static uint16_t generate_port(void)
{
  int copy ;
  int tmp ;

  {
  pthread_rwlock_wrlock(& tcplock);
  port ++;
  tmp = timer_get_tick();
  copy = port + tmp % 10000;
  pthread_rwlock_unlock(& tcplock);
  return ((uint16_t )copy);
}
}
int generate_iss(void)
{
  time_t tmp ;
  int tmp___0 ;

  {
  tmp = time((time_t *)((void *)0));
  tmp___0 = rand();
  return ((int )tmp * tmp___0);
}
}
int tcp_v4_connect(struct sock *sk , struct sockaddr  const  *addr , int addrlen ,
                   int flags )
{
  uint16_t dport ;
  uint32_t daddr ;
  int tmp ;

  {
  dport = ((struct sockaddr_in *)addr)->sin_port;
  daddr = ((struct sockaddr_in *)addr)->sin_addr.s_addr;
  sk->dport = ntohs(dport);
  sk->sport = generate_port();
  sk->daddr = ntohl(daddr);
  sk->saddr = parse_ipv4_string((char *)"10.0.0.4");
  tmp = tcp_connect(sk);
  return (tmp);
}
}
int tcp_disconnect(struct sock *sk , int flags )
{


  {
  return (0);
}
}
int tcp_write(struct sock *sk , void const   *buf , int len )
{
  struct tcp_sock *tsk ;
  int ret ;
  int tmp ;

  {
  tsk = (struct tcp_sock *)sk;
  ret = sk->err;
  if (ret != 0) {
    goto out;
  }
  switch (sk->state) {
  case 7:
  case 3:
  break;
  default:
  ret = -9;
  goto out;
  }
  tmp = tcp_send(tsk, buf, len);
  return (tmp);
  out:
  return (ret);
}
}
int tcp_read(struct sock *sk , void *buf , int len )
{
  struct tcp_sock *tsk ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  tsk = (struct tcp_sock *)sk;
  ret = -1;
  switch (sk->state) {
  case 6:
  ret = -9;
  goto out;
  case 5:
  case 4:
  case 3:
  case 2:
  case 1:
  case 0:
  break;
  case 7:
  tmp = skb_queue_empty((struct sk_buff_head  const  *)(& tsk->sk.receive_queue));
  if (! tmp) {
    break;
  }
  if ((int )tsk->flags & 1) {
    tsk->flags = (uint8_t )((int )tsk->flags & -2);
    return (0);
  }
  break;
  case 10:
  case 9:
  case 8:
  ret = sk->err;
  goto out;
  default:
  goto out;
  }
  tmp___0 = tcp_receive(tsk, buf, len);
  return (tmp___0);
  out:
  return (ret);
}
}
int tcp_recv_notify(struct sock *sk )
{
  int tmp ;

  {
  if (& sk->recv_wait) {
    tmp = wait_wakeup(& sk->recv_wait);
    return (tmp);
  }
  return (-1);
}
}
int tcp_close(struct sock *sk )
{
  int tmp ;

  {
  switch (sk->state) {
  case 5:
  case 4:
  case 10:
  case 9:
  case 8:
  case 6:
  sk->err = -9;
  return (-1);
  case 2:
  case 1:
  case 0:
  tmp = tcp_done(sk);
  return (tmp);
  case 3:
  __tcp_set_state(sk, (uint32_t )4);
  tcp_queue_fin(sk);
  break;
  case 7:
  tcp_queue_fin(sk);
  break;
  default:
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unknown TCP state for close\n");
  return (-1);
  }
  return (0);
}
}
int tcp_abort(struct sock *sk )
{
  struct tcp_sock *tsk ;
  int tmp ;

  {
  tsk = (struct tcp_sock *)sk;
  tcp_send_reset(tsk);
  tmp = tcp_done(sk);
  return (tmp);
}
}
static int tcp_free(struct sock *sk )
{
  struct tcp_sock *tsk ;

  {
  tsk = (struct tcp_sock *)sk;
  tcp_clear_timers(sk);
  tcp_clear_queues(tsk);
  wait_wakeup(& (sk->sock)->sleep);
  return (0);
}
}
int tcp_done(struct sock *sk )
{
  int tmp ;

  {
  __tcp_set_state(sk, (uint32_t )8);
  tcp_free(sk);
  tmp = socket_delete(sk->sock);
  return (tmp);
}
}
void tcp_clear_timers(struct sock *sk )
{
  struct tcp_sock *tsk ;

  {
  tsk = (struct tcp_sock *)sk;
  tcp_stop_rto_timer(tsk);
  tcp_stop_delack_timer(tsk);
  timer_cancel(tsk->keepalive);
  tsk->keepalive = (struct timer *)((void *)0);
  timer_cancel(tsk->linger);
  tsk->linger = (struct timer *)((void *)0);
  return;
}
}
void tcp_stop_rto_timer(struct tcp_sock *tsk )
{


  {
  if (tsk) {
    timer_cancel(tsk->retransmit);
    tsk->retransmit = (struct timer *)((void *)0);
    tsk->backoff = (uint8_t )0;
  }
  return;
}
}
void tcp_release_rto_timer(struct tcp_sock *tsk )
{


  {
  if (tsk) {
    timer_release(tsk->retransmit);
    tsk->retransmit = (struct timer *)((void *)0);
  }
  return;
}
}
void tcp_stop_delack_timer(struct tcp_sock *tsk )
{


  {
  timer_cancel(tsk->delack);
  tsk->delack = (struct timer *)((void *)0);
  return;
}
}
void tcp_release_delack_timer(struct tcp_sock *tsk )
{


  {
  timer_release(tsk->delack);
  tsk->delack = (struct timer *)((void *)0);
  return;
}
}
void tcp_handle_fin_state(struct sock *sk )
{


  {
  switch (sk->state) {
  case 7:
  __tcp_set_state(sk, (uint32_t )9);
  break;
  case 3:
  __tcp_set_state(sk, (uint32_t )4);
  break;
  }
  return;
}
}
static void *tcp_linger(void *arg )
{
  struct sock *sk ;
  struct tcp_sock *tsk ;

  {
  sk = (struct sock *)arg;
  socket_wr_acquire(sk->sock);
  tsk = (struct tcp_sock *)sk;
  timer_cancel(tsk->linger);
  tsk->linger = (struct timer *)((void *)0);
  tcp_done(sk);
  socket_release(sk->sock);
  return ((void *)0);
}
}
static void *tcp_user_timeout(void *arg )
{
  struct sock *sk ;
  struct tcp_sock *tsk ;

  {
  sk = (struct sock *)arg;
  socket_wr_acquire(sk->sock);
  tsk = (struct tcp_sock *)sk;
  timer_cancel(tsk->linger);
  tsk->linger = (struct timer *)((void *)0);
  tcp_abort(sk);
  socket_release(sk->sock);
  return ((void *)0);
}
}
void tcp_enter_time_wait(struct sock *sk )
{
  struct tcp_sock *tsk ;

  {
  tsk = (struct tcp_sock *)sk;
  __tcp_set_state(sk, (uint32_t )10);
  tcp_clear_timers(sk);
  tsk->linger = timer_add((uint32_t )60000, & tcp_linger, (void *)sk);
  return;
}
}
void tcp_rearm_user_timeout(struct sock *sk )
{
  struct tcp_sock *tsk ;

  {
  tsk = (struct tcp_sock *)sk;
  if (sk->state == 10) {
    return;
  }
  timer_cancel(tsk->linger);
  tsk->linger = timer_add((uint32_t )180000, & tcp_user_timeout, (void *)sk);
  return;
}
}
void tcp_rtt(struct tcp_sock *tsk )
{
  int r ;
  int tmp ;
  double beta ;
  double alpha ;
  int tmp___0 ;
  int k ;

  {
  if ((int )tsk->backoff > 0) {
    return;
  } else
  if (! tsk->retransmit) {
    return;
  }
  tmp = timer_get_tick();
  r = (int )((uint32_t )tmp - ((tsk->retransmit)->expires - tsk->rto));
  if (r < 0) {
    return;
  }
  if (! tsk->srtt) {
    tsk->srtt = r;
    tsk->rttvar = r / 2;
  } else {
    beta = 0.25;
    alpha = 0.125;
    tmp___0 = abs(tsk->srtt - r);
    tsk->rttvar = (int32_t )(((double )1 - beta) * (double )tsk->rttvar + beta * (double )tmp___0);
    tsk->srtt = (int32_t )(((double )1 - alpha) * (double )tsk->srtt + alpha * (double )r);
  }
  k = 4 * tsk->rttvar;
  if (k < 200) {
    k = 200;
  }
  tsk->rto = (uint32_t )(tsk->srtt + k);
  return;
}
}
int tcp_calculate_sacks(struct tcp_sock *tsk )
{
  struct tcp_sack_block *sb ;
  struct sk_buff *next ;
  struct list_head *item ;
  struct list_head *tmp ;

  {
  sb = & tsk->sacks[tsk->sacklen];
  sb->left = (uint32_t )0;
  sb->right = (uint32_t )0;
  item = tsk->ofo_queue.head.next;
  tmp = item->next;
  while ((unsigned long )item != (unsigned long )(& tsk->ofo_queue.head)) {
    next = (struct sk_buff *)((char *)item - (unsigned long )(& ((struct sk_buff *)0)->list));
    if (sb->left == 0U) {
      sb->left = next->seq;
      tsk->sacklen = (uint8_t )((int )tsk->sacklen + 1);
    }
    if (sb->right == 0U) {
      sb->right = next->end_seq;
    } else
    if (sb->right == next->seq) {
      sb->right = next->end_seq;
    } else {
      if ((int )tsk->sacklen >= (int )tsk->sacks_allowed) {
        break;
      }
      sb = & tsk->sacks[tsk->sacklen];
      sb->left = next->seq;
      sb->right = next->end_seq;
      tsk->sacklen = (uint8_t )((int )tsk->sacklen + 1);
    }
    item = tmp;
    tmp = item->next;
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-aCpWacRK.i","-Wall,-pthread")
extern int optind ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt)(int ___argc ,
                                                                                     char * const  *___argv ,
                                                                                     char const   *__shortopts ) ;
void parse_cli(int argc , char **argv ) ;
int debug  =    0;
static void usage(char *app )
{


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s\n",
          app);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Linux TCP/IP stack implemented with TUN/TAP devices.\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Requires the CAP_NET_ADMIN capability. See capabilities(7).\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"See https://www.kernel.org/doc/Documentation/networking/tuntap.txt\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -d Debug logging and tracing\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -h Print usage\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  exit(1);
}
}
static int parse_opts(int *argc , char ***argv )
{
  int opt ;

  {
  while (1) {
    opt = getopt(*argc, (char * const  *)*argv, "hd");
    if (! (opt != -1)) {
      break;
    }
    switch (opt) {
    case 100:
    debug = 1;
    break;
    default:
    usage(*(*(argv + 0)));
    }
  }
  *argc -= optind;
  *argv += optind;
  return (optind);
}
}
void parse_cli(int argc , char **argv )
{


  {
  parse_opts(& argc, & argv);
  return;
}
}
#pragma merger("0","/tmp/cil-QuAPpHdI.i","-Wall,-pthread")
void sock_connected(struct sock *sk ) ;
struct sock *sk_alloc(struct net_ops *ops , int protocol )
{
  struct sock *sk ;

  {
  sk = (*(ops->alloc_sock))(protocol);
  sk->ops = ops;
  return (sk);
}
}
void sock_init_data(struct socket *sock , struct sock *sk )
{


  {
  sock->sk = sk;
  sk->sock = sock;
  wait_init(& sk->recv_wait);
  skb_queue_init(& sk->receive_queue);
  skb_queue_init(& sk->write_queue);
  sk->poll_events = (short)0;
  (*((sk->ops)->init))(sk);
  return;
}
}
void sock_free(struct sock *sk )
{


  {
  skb_queue_free(& sk->receive_queue);
  skb_queue_free(& sk->write_queue);
  return;
}
}
void sock_connected(struct sock *sk )
{
  struct socket *sock ;

  {
  sock = sk->sock;
  sock->state = (enum socket_state )3;
  sk->err = 0;
  sk->poll_events = (short)772;
  wait_wakeup(& sock->sleep);
  return;
}
}
#pragma merger("0","/tmp/cil-savxD1_6.i","-Wall,-pthread")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
__inline static void skb_queue_tail(struct sk_buff_head *list , struct sk_buff *new )
{


  {
  list_add_tail(& new->list, & list->head);
  (list->qlen) ++;
  return;
}
}
__inline static struct sk_buff *write_queue_head(struct sock *sk )
{
  struct sk_buff *tmp ;

  {
  tmp = skb_peek(& sk->write_queue);
  return (tmp);
}
}
__inline static struct tcphdr *tcp_hdr(struct sk_buff  const  *skb )
{


  {
  return ((struct tcphdr *)((skb->head + sizeof(struct eth_hdr )) + sizeof(struct iphdr )));
}
}
void tcp_select_initial_window(uint32_t *rcv_wnd ) ;
int tcp_send_synack(struct sock *sk ) ;
int tcp_send_next(struct sock *sk , int amount ) ;
int tcp_send_ack(struct sock *sk ) ;
void *tcp_send_delack(void *arg ) ;
int tcp_send_fin(struct sock *sk ) ;
int tcp_send_challenge_ack(struct sock *sk , struct sk_buff *skb ) ;
void tcp_rearm_rto_timer(struct tcp_sock *tsk ) ;
static void *tcp_retransmission_timeout(void *arg ) ;
static struct sk_buff *tcp_alloc_skb(int optlen , int size )
{
  int reserved ;
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
  reserved = (int )((((sizeof(struct eth_hdr ) + sizeof(struct iphdr )) + sizeof(struct tcphdr )) + (unsigned long )optlen) + (unsigned long )size);
  tmp = alloc_skb((unsigned int )reserved);
  skb = tmp;
  skb_reserve(skb, (unsigned int )reserved);
  skb->protocol = (uint16_t )6;
  skb->dlen = (uint32_t )size;
  skb->seq = (uint32_t )0;
  return (skb);
}
}
static int tcp_write_syn_options(struct tcphdr *th , struct tcp_options *opts , int optlen )
{
  struct tcp_opt_mss *opt_mss ;
  uint32_t i ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  opt_mss = (struct tcp_opt_mss *)(th->data);
  i = (uint32_t )0;
  opt_mss->kind = (uint8_t )2;
  opt_mss->len = (uint8_t )4;
  opt_mss->mss = htons(opts->mss);
  i = (uint32_t )((unsigned long )i + sizeof(struct tcp_opt_mss ));
  if (opts->sack) {
    tmp = i;
    i ++;
    th->data[tmp] = (uint8_t )1;
    tmp___0 = i;
    i ++;
    th->data[tmp___0] = (uint8_t )1;
    tmp___1 = i;
    i ++;
    th->data[tmp___1] = (uint8_t )4;
    tmp___2 = i;
    i ++;
    th->data[tmp___2] = (uint8_t )2;
  }
  th->hl = (uint8_t )(sizeof(struct tcphdr ) / 4UL + (unsigned long )(optlen / 4));
  return (0);
}
}
static int tcp_syn_options(struct sock *sk , struct tcp_options *opts )
{
  struct tcp_sock *tsk ;
  int optlen ;

  {
  tsk = (struct tcp_sock *)sk;
  optlen = 0;
  opts->mss = tsk->rmss;
  optlen += 4;
  if (tsk->sackok) {
    opts->sack = (uint8_t )1;
    optlen += 2;
    optlen += 2;
  } else {
    opts->sack = (uint8_t )0;
  }
  return (optlen);
}
}
static int tcp_write_options(struct tcp_sock *tsk , struct tcphdr *th )
{
  uint8_t *ptr ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;
  struct tcp_sack_block *sb ;
  int i ;

  {
  ptr = th->data;
  if (! tsk->sackok) {
    return (0);
  } else
  if (tsk->sacks[0].left == 0U) {
    return (0);
  }
  tmp = ptr;
  ptr ++;
  *tmp = (uint8_t )1;
  tmp___0 = ptr;
  ptr ++;
  *tmp___0 = (uint8_t )1;
  tmp___1 = ptr;
  ptr ++;
  *tmp___1 = (uint8_t )5;
  tmp___2 = ptr;
  ptr ++;
  *tmp___2 = (uint8_t )(2 + (int )tsk->sacklen * 8);
  sb = (struct tcp_sack_block *)ptr;
  i = (int )tsk->sacklen - 1;
  while (i >= 0) {
    sb->left = htonl(tsk->sacks[i].left);
    sb->right = htonl(tsk->sacks[i].right);
    tsk->sacks[i].left = (uint32_t )0;
    tsk->sacks[i].right = (uint32_t )0;
    sb ++;
    ptr += sizeof(struct tcp_sack_block );
    i --;
  }
  tsk->sacklen = (uint8_t )0;
  return (0);
}
}
static int tcp_transmit_skb(struct sock *sk , struct sk_buff *skb , uint32_t seq )
{
  struct tcp_sock *tsk ;
  struct tcb *tcb ;
  struct tcphdr *thdr ;
  struct tcphdr *tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tsk = (struct tcp_sock *)sk;
  tcb = & tsk->tcb;
  tmp = tcp_hdr((struct sk_buff  const  *)skb);
  thdr = tmp;
  if ((int )thdr->hl == 0) {
    thdr->hl = (uint8_t )(sizeof(struct tcphdr ) / 4UL);
  }
  skb_push(skb, (unsigned int )((int )thdr->hl * 4));
  thdr->sport = sk->sport;
  thdr->dport = sk->dport;
  thdr->seq = seq;
  thdr->ack_seq = tcb->rcv_nxt;
  thdr->rsvd = (uint8_t )0;
  thdr->win = (uint16_t )tcb->rcv_wnd;
  thdr->csum = (uint16_t )0;
  thdr->urp = (uint16_t )0;
  if ((int )thdr->hl > 5) {
    tcp_write_options(tsk, thdr);
  }
  thdr->sport = htons(thdr->sport);
  thdr->dport = htons(thdr->dport);
  thdr->seq = htonl(thdr->seq);
  thdr->ack_seq = htonl(thdr->ack_seq);
  thdr->win = htons(thdr->win);
  thdr->csum = htons(thdr->csum);
  thdr->urp = htons(thdr->urp);
  tmp___0 = htonl(sk->daddr);
  tmp___1 = htonl(sk->saddr);
  tmp___2 = tcp_v4_checksum(skb, tmp___1, tmp___0);
  thdr->csum = (uint16_t )tmp___2;
  tmp___3 = ip_output(sk, skb);
  return (tmp___3);
}
}
static int tcp_queue_transmit_skb(struct sock *sk , struct sk_buff *skb )
{
  struct tcp_sock *tsk ;
  struct tcb *tcb ;
  struct tcphdr *th ;
  struct tcphdr *tmp ;
  int rc ;
  int tmp___0 ;

  {
  tsk = (struct tcp_sock *)sk;
  tcb = & tsk->tcb;
  tmp = tcp_hdr((struct sk_buff  const  *)skb);
  th = tmp;
  rc = 0;
  tmp___0 = skb_queue_empty((struct sk_buff_head  const  *)(& sk->write_queue));
  if (tmp___0) {
    tcp_rearm_rto_timer(tsk);
  }
  if (tsk->inflight == 0U) {
    rc = tcp_transmit_skb(sk, skb, tcb->snd_nxt);
    (tsk->inflight) ++;
    skb->seq = tcb->snd_nxt;
    tcb->snd_nxt += skb->dlen;
    skb->end_seq = tcb->snd_nxt;
    if (th->fin) {
      (tcb->snd_nxt) ++;
    }
  }
  skb_queue_tail(& sk->write_queue, skb);
  return (rc);
}
}
int tcp_send_synack(struct sock *sk )
{
  struct sk_buff *skb ;
  struct tcphdr *th ;
  struct tcb *tcb ;
  int rc ;

  {
  if (sk->state != 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"TCP synack: Socket was not in correct state (SYN_SENT)\n");
    return (1);
  }
  tcb = & ((struct tcp_sock *)sk)->tcb;
  rc = 0;
  skb = tcp_alloc_skb(0, 0);
  th = tcp_hdr((struct sk_buff  const  *)skb);
  th->syn = (uint8_t )1;
  th->ack = (uint8_t )1;
  rc = tcp_transmit_skb(sk, skb, tcb->snd_nxt);
  free_skb(skb);
  return (rc);
}
}
void *tcp_send_delack(void *arg )
{
  struct sock *sk ;
  struct tcp_sock *tsk ;

  {
  sk = (struct sock *)arg;
  socket_wr_acquire(sk->sock);
  tsk = (struct tcp_sock *)sk;
  tsk->delacks = (uint8_t )0;
  tcp_release_delack_timer(tsk);
  tcp_send_ack(sk);
  socket_release(sk->sock);
  return ((void *)0);
}
}
int tcp_send_next(struct sock *sk , int amount )
{
  struct tcp_sock *tsk ;
  struct tcb *tcb ;
  struct tcphdr *th ;
  struct sk_buff *next ;
  struct list_head *item ;
  struct list_head *tmp ;
  int i ;

  {
  tsk = (struct tcp_sock *)sk;
  tcb = & tsk->tcb;
  i = 0;
  item = sk->write_queue.head.next;
  tmp = item->next;
  while ((unsigned long )item != (unsigned long )(& sk->write_queue.head)) {
    i ++;
    if (i > amount) {
      break;
    }
    next = (struct sk_buff *)((char *)item - (unsigned long )(& ((struct sk_buff *)0)->list));
    if ((unsigned long )next == (unsigned long )((void *)0)) {
      return (-1);
    }
    skb_reset_header(next);
    tcp_transmit_skb(sk, next, tcb->snd_nxt);
    next->seq = tcb->snd_nxt;
    tcb->snd_nxt += next->dlen;
    next->end_seq = tcb->snd_nxt;
    th = tcp_hdr((struct sk_buff  const  *)next);
    if (th->fin) {
      (tcb->snd_nxt) ++;
    }
    item = tmp;
    tmp = item->next;
  }
  return (0);
}
}
static int tcp_options_len(struct sock *sk )
{
  struct tcp_sock *tsk ;
  uint8_t optlen ;
  int i ;

  {
  tsk = (struct tcp_sock *)sk;
  optlen = (uint8_t )0;
  if (tsk->sackok) {
    if ((int )tsk->sacklen > 0) {
      i = 0;
      while (i < (int )tsk->sacklen) {
        if (tsk->sacks[i].left != 0U) {
          optlen = (uint8_t )((int )optlen + 8);
        }
        i ++;
      }
      optlen = (uint8_t )((int )optlen + 2);
    }
  }
  while ((int )optlen % 4 > 0) {
    optlen = (uint8_t )((int )optlen + 1);
  }
  return ((int )optlen);
}
}
int tcp_send_ack(struct sock *sk )
{
  struct sk_buff *skb ;
  struct tcphdr *th ;
  struct tcb *tcb ;
  int rc ;
  int optlen ;
  int tmp ;

  {
  if (sk->state == 6) {
    return (0);
  }
  tcb = & ((struct tcp_sock *)sk)->tcb;
  rc = 0;
  tmp = tcp_options_len(sk);
  optlen = tmp;
  skb = tcp_alloc_skb(optlen, 0);
  th = tcp_hdr((struct sk_buff  const  *)skb);
  th->ack = (uint8_t )1;
  th->hl = (uint8_t )(sizeof(struct tcphdr ) / 4UL + (unsigned long )(optlen / 4));
  rc = tcp_transmit_skb(sk, skb, tcb->snd_nxt);
  free_skb(skb);
  return (rc);
}
}
static int tcp_send_syn(struct sock *sk )
{
  struct sk_buff *skb ;
  struct tcphdr *th ;
  struct tcp_options opts ;
  int tcp_options_len___0 ;
  int tmp ;

  {
  if (sk->state != 1) {
    if (sk->state != 6) {
      if (sk->state != 0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Socket was not in correct state (closed or listen)\n");
        return (1);
      }
    }
  }
  opts.options = (uint16_t )0;
  opts.mss = (unsigned short)0;
  opts.sack = (unsigned char)0;
  tcp_options_len___0 = 0;
  tcp_options_len___0 = tcp_syn_options(sk, & opts);
  skb = tcp_alloc_skb(tcp_options_len___0, 0);
  th = tcp_hdr((struct sk_buff  const  *)skb);
  tcp_write_syn_options(th, & opts, tcp_options_len___0);
  sk->state = 1;
  th->syn = (uint8_t )1;
  tmp = tcp_queue_transmit_skb(sk, skb);
  return (tmp);
}
}
int tcp_send_fin(struct sock *sk )
{
  struct sk_buff *skb ;
  struct tcphdr *th ;
  int rc ;

  {
  if (sk->state == 6) {
    return (0);
  }
  rc = 0;
  skb = tcp_alloc_skb(0, 0);
  th = tcp_hdr((struct sk_buff  const  *)skb);
  th->fin = (uint8_t )1;
  th->ack = (uint8_t )1;
  rc = tcp_queue_transmit_skb(sk, skb);
  return (rc);
}
}
void tcp_select_initial_window(uint32_t *rcv_wnd )
{


  {
  *rcv_wnd = (uint32_t )44477;
  return;
}
}
static void tcp_notify_user(struct sock *sk )
{


  {
  switch (sk->state) {
  case 7:
  wait_wakeup(& (sk->sock)->sleep);
  break;
  }
  return;
}
}
static void *tcp_connect_rto(void *arg )
{
  struct tcp_sock *tsk ;
  struct tcb *tcb ;
  struct sock *sk ;
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
  tsk = (struct tcp_sock *)arg;
  tcb = & tsk->tcb;
  sk = & tsk->sk;
  socket_wr_acquire(sk->sock);
  tcp_release_rto_timer(tsk);
  if (sk->state == 1) {
    if ((int )tsk->backoff > 3) {
      tsk->sk.err = -110;
      sk->poll_events = (short )((int )sk->poll_events | 28);
      tcp_done(sk);
    } else {
      tmp = write_queue_head(sk);
      skb = tmp;
      if (skb) {
        skb_reset_header(skb);
        tcp_transmit_skb(sk, skb, tcb->snd_una);
        tsk->backoff = (uint8_t )((int )tsk->backoff + 1);
        tcp_rearm_rto_timer(tsk);
      }
    }
  } else {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"TCP connect RTO triggered even when not in SYNSENT\n");
  }
  socket_release(sk->sock);
  return ((void *)0);
}
}
static void *tcp_retransmission_timeout(void *arg )
{
  struct tcp_sock *tsk ;
  struct tcb *tcb ;
  struct sock *sk ;
  struct sk_buff *skb ;
  struct sk_buff *tmp ;
  struct tcphdr *th ;
  struct tcphdr *tmp___0 ;

  {
  tsk = (struct tcp_sock *)arg;
  tcb = & tsk->tcb;
  sk = & tsk->sk;
  socket_wr_acquire(sk->sock);
  tcp_release_rto_timer(tsk);
  tmp = write_queue_head(sk);
  skb = tmp;
  if (! skb) {
    tsk->backoff = (uint8_t )0;
    tcp_notify_user(sk);
    goto unlock;
  }
  tmp___0 = tcp_hdr((struct sk_buff  const  *)skb);
  th = tmp___0;
  skb_reset_header(skb);
  tcp_transmit_skb(sk, skb, tcb->snd_una);
  if (tsk->rto > 60000U) {
    tcp_done(sk);
    tsk->sk.err = -110;
    sk->poll_events = (short )((int )sk->poll_events | 28);
    socket_release(sk->sock);
    return ((void *)0);
  } else {
    tsk->rto *= 2U;
    tsk->backoff = (uint8_t )((int )tsk->backoff + 1);
    tsk->retransmit = timer_add(tsk->rto, & tcp_retransmission_timeout, (void *)tsk);
    if (th->fin) {
      tcp_handle_fin_state(sk);
    }
  }
  unlock:
  socket_release(sk->sock);
  return ((void *)0);
}
}
void tcp_rearm_rto_timer(struct tcp_sock *tsk )
{
  struct sock *sk ;

  {
  sk = & tsk->sk;
  tcp_release_rto_timer(tsk);
  if (sk->state == 1) {
    tsk->retransmit = timer_add((uint32_t )(500 << (int )tsk->backoff), & tcp_connect_rto,
                                (void *)tsk);
  } else {
    tsk->retransmit = timer_add(tsk->rto, & tcp_retransmission_timeout, (void *)tsk);
  }
  return;
}
}
int tcp_connect(struct sock *sk )
{
  struct tcp_sock *tsk ;
  struct tcb *tcb ;
  int rc ;
  int tmp ;

  {
  tsk = (struct tcp_sock *)sk;
  tcb = & tsk->tcb;
  rc = 0;
  tsk->tcp_header_len = (uint16_t )sizeof(struct tcphdr );
  tmp = generate_iss();
  tcb->iss = (uint32_t )tmp;
  tcb->snd_wnd = (uint32_t )0;
  tcb->snd_wl1 = (uint32_t )0;
  tcb->snd_una = tcb->iss;
  tcb->snd_up = tcb->iss;
  tcb->snd_nxt = tcb->iss;
  tcb->rcv_nxt = (uint32_t )0;
  tcp_select_initial_window(& tsk->tcb.rcv_wnd);
  rc = tcp_send_syn(sk);
  (tcb->snd_nxt) ++;
  return (rc);
}
}
int tcp_send(struct tcp_sock *tsk , void const   *buf , int len )
{
  struct sk_buff *skb ;
  struct tcphdr *th ;
  int slen ;
  int mss ;
  int dlen ;
  int tmp ;

  {
  slen = len;
  mss = (int )tsk->smss;
  dlen = 0;
  while (slen > 0) {
    if (slen > mss) {
      dlen = mss;
    } else {
      dlen = slen;
    }
    slen -= dlen;
    skb = tcp_alloc_skb(0, dlen);
    skb_push(skb, (unsigned int )dlen);
    memcpy((void * __restrict  )skb->data, (void const   * __restrict  )buf, (size_t )dlen);
    buf += dlen;
    th = tcp_hdr((struct sk_buff  const  *)skb);
    th->ack = (uint8_t )1;
    if (slen == 0) {
      th->psh = (uint8_t )1;
    }
    tmp = tcp_queue_transmit_skb(& tsk->sk, skb);
    if (tmp == -1) {
      perror("Error on TCP skb queueing");
    }
  }
  tcp_rearm_user_timeout(& tsk->sk);
  return (len);
}
}
int tcp_send_reset(struct tcp_sock *tsk )
{
  struct sk_buff *skb ;
  struct tcphdr *th ;
  struct tcb *tcb ;
  int rc ;

  {
  rc = 0;
  skb = tcp_alloc_skb(0, 0);
  th = tcp_hdr((struct sk_buff  const  *)skb);
  tcb = & tsk->tcb;
  th->rst = (uint8_t )1;
  tcb->snd_una = tcb->snd_nxt;
  rc = tcp_transmit_skb(& tsk->sk, skb, tcb->snd_nxt);
  free_skb(skb);
  return (rc);
}
}
int tcp_send_challenge_ack(struct sock *sk , struct sk_buff *skb )
{


  {
  return (0);
}
}
int tcp_queue_fin(struct sock *sk )
{
  struct sk_buff *skb ;
  struct tcphdr *th ;
  int rc ;

  {
  rc = 0;
  skb = tcp_alloc_skb(0, 0);
  th = tcp_hdr((struct sk_buff  const  *)skb);
  th->fin = (uint8_t )1;
  th->ack = (uint8_t )1;
  rc = tcp_queue_transmit_skb(sk, skb);
  return (rc);
}
}
#pragma merger("0","/tmp/cil-S8_K58X7.i","-Wall,-pthread")
extern int printf(char const   * __restrict  __format  , ...) ;
int netdev_transmit(struct sk_buff *skb , uint8_t *dst_hw , uint16_t ethertype ) ;
struct netdev *netdev_get(uint32_t sip ) ;
void arp_init(void) ;
void free_arp(void) ;
void arp_rcv(struct sk_buff *skb ) ;
void arp_reply(struct sk_buff *skb , struct netdev *netdev___0 ) ;
int arp_request(uint32_t sip , uint32_t dip , struct netdev *netdev___0 ) ;
unsigned char *arp_get_hwaddr(uint32_t sip ) ;
__inline static struct arp_hdr *arp_hdr(struct sk_buff *skb )
{


  {
  return ((struct arp_hdr *)(skb->head + sizeof(struct eth_hdr )));
}
}
static uint8_t broadcast_hw[6]  = {      (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255,
        (uint8_t )255,      (uint8_t )255};
static struct list_head arp_cache  =    {& arp_cache, & arp_cache};
static pthread_mutex_t lock  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static struct sk_buff *arp_alloc_skb(void)
{
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
  tmp = alloc_skb((unsigned int )((sizeof(struct eth_hdr ) + sizeof(struct arp_hdr )) + sizeof(struct arp_ipv4 )));
  skb = tmp;
  skb_reserve(skb, (unsigned int )((sizeof(struct eth_hdr ) + sizeof(struct arp_hdr )) + sizeof(struct arp_ipv4 )));
  skb->protocol = htons((uint16_t )2054);
  return (skb);
}
}
static struct arp_cache_entry *arp_entry_alloc(struct arp_hdr *hdr , struct arp_ipv4 *data )
{
  struct arp_cache_entry *entry ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct arp_cache_entry ));
  entry = (struct arp_cache_entry *)tmp;
  list_init(& entry->list);
  entry->state = 2U;
  entry->hwtype = hdr->hwtype;
  entry->sip = data->sip;
  memcpy((void * __restrict  )(entry->smac), (void const   * __restrict  )(data->smac),
         sizeof(entry->smac));
  return (entry);
}
}
static int insert_arp_translation_table(struct arp_hdr *hdr , struct arp_ipv4 *data )
{
  struct arp_cache_entry *entry ;
  struct arp_cache_entry *tmp ;

  {
  tmp = arp_entry_alloc(hdr, data);
  entry = tmp;
  pthread_mutex_lock(& lock);
  list_add_tail(& entry->list, & arp_cache);
  pthread_mutex_unlock(& lock);
  return (0);
}
}
static int update_arp_translation_table(struct arp_hdr *hdr , struct arp_ipv4 *data )
{
  struct list_head *item ;
  struct arp_cache_entry *entry ;

  {
  pthread_mutex_lock(& lock);
  item = arp_cache.next;
  while ((unsigned long )item != (unsigned long )(& arp_cache)) {
    entry = (struct arp_cache_entry *)((char *)item - (unsigned long )(& ((struct arp_cache_entry *)0)->list));
    if ((int )entry->hwtype == (int )hdr->hwtype) {
      if (entry->sip == data->sip) {
        memcpy((void * __restrict  )(entry->smac), (void const   * __restrict  )(data->smac),
               (size_t )6);
        pthread_mutex_unlock(& lock);
        return (1);
      }
    }
    item = item->next;
  }
  pthread_mutex_unlock(& lock);
  return (0);
}
}
void arp_init(void)
{


  {
  return;
}
}
void arp_rcv(struct sk_buff *skb )
{
  struct arp_hdr *arphdr ;
  struct arp_ipv4 *arpdata ;
  struct netdev *netdev___0 ;
  int merge ;
  int tmp ;

  {
  merge = 0;
  arphdr = arp_hdr(skb);
  arphdr->hwtype = ntohs(arphdr->hwtype);
  arphdr->protype = ntohs(arphdr->protype);
  arphdr->opcode = ntohs(arphdr->opcode);
  if ((int )arphdr->hwtype != 1) {
    printf((char const   * __restrict  )"ARP: Unsupported HW type\n");
    goto drop_pkt;
  }
  if ((int )arphdr->protype != 2048) {
    printf((char const   * __restrict  )"ARP: Unsupported protocol\n");
    goto drop_pkt;
  }
  arpdata = (struct arp_ipv4 *)(arphdr->data);
  arpdata->sip = ntohl(arpdata->sip);
  arpdata->dip = ntohl(arpdata->dip);
  merge = update_arp_translation_table(arphdr, arpdata);
  netdev___0 = netdev_get(arpdata->dip);
  if (! netdev___0) {
    printf((char const   * __restrict  )"ARP was not for us\n");
    goto drop_pkt;
  }
  if (! merge) {
    tmp = insert_arp_translation_table(arphdr, arpdata);
    if (tmp != 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERR: No free space in ARP translation table\n");
      goto drop_pkt;
    }
  }
  switch ((int )arphdr->opcode) {
  case 1:
  arp_reply(skb, netdev___0);
  return;
  default:
  printf((char const   * __restrict  )"ARP: Opcode not supported\n");
  goto drop_pkt;
  }
  drop_pkt:
  free_skb(skb);
  return;
}
}
int arp_request(uint32_t sip , uint32_t dip , struct netdev *netdev___0 )
{
  struct sk_buff *skb ;
  struct arp_hdr *arp ;
  struct arp_ipv4 *payload ;
  int rc ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
  rc = 0;
  skb = arp_alloc_skb();
  if (! skb) {
    return (-1);
  }
  skb->dev = netdev___0;
  tmp = skb_push(skb, (unsigned int )sizeof(struct arp_ipv4 ));
  payload = (struct arp_ipv4 *)tmp;
  memcpy((void * __restrict  )(payload->smac), (void const   * __restrict  )(netdev___0->hwaddr),
         (size_t )netdev___0->addr_len);
  payload->sip = sip;
  memcpy((void * __restrict  )(payload->dmac), (void const   * __restrict  )(broadcast_hw),
         (size_t )netdev___0->addr_len);
  payload->dip = dip;
  tmp___0 = skb_push(skb, (unsigned int )sizeof(struct arp_hdr ));
  arp = (struct arp_hdr *)tmp___0;
  arp->opcode = htons((uint16_t )1);
  arp->hwtype = htons((uint16_t )1);
  arp->protype = htons((uint16_t )2048);
  arp->hwsize = netdev___0->addr_len;
  arp->prosize = (uint8_t )4;
  payload->sip = htonl(payload->sip);
  payload->dip = htonl(payload->dip);
  rc = netdev_transmit(skb, broadcast_hw, (uint16_t )2054);
  free_skb(skb);
  return (rc);
}
}
void arp_reply(struct sk_buff *skb , struct netdev *netdev___0 )
{
  struct arp_hdr *arphdr ;
  struct arp_ipv4 *arpdata ;

  {
  arphdr = arp_hdr(skb);
  skb_reserve(skb, (unsigned int )((sizeof(struct eth_hdr ) + sizeof(struct arp_hdr )) + sizeof(struct arp_ipv4 )));
  skb_push(skb, (unsigned int )(sizeof(struct arp_hdr ) + sizeof(struct arp_ipv4 )));
  arpdata = (struct arp_ipv4 *)(arphdr->data);
  memcpy((void * __restrict  )(arpdata->dmac), (void const   * __restrict  )(arpdata->smac),
         (size_t )6);
  arpdata->dip = arpdata->sip;
  memcpy((void * __restrict  )(arpdata->smac), (void const   * __restrict  )(netdev___0->hwaddr),
         (size_t )6);
  arpdata->sip = netdev___0->addr;
  arphdr->opcode = (uint16_t )2;
  arphdr->opcode = htons(arphdr->opcode);
  arphdr->hwtype = htons(arphdr->hwtype);
  arphdr->protype = htons(arphdr->protype);
  arpdata->sip = htonl(arpdata->sip);
  arpdata->dip = htonl(arpdata->dip);
  skb->dev = netdev___0;
  netdev_transmit(skb, arpdata->dmac, (uint16_t )2054);
  free_skb(skb);
  return;
}
}
unsigned char *arp_get_hwaddr(uint32_t sip )
{
  struct list_head *item ;
  struct arp_cache_entry *entry ;
  uint8_t *copy ;

  {
  pthread_mutex_lock(& lock);
  item = arp_cache.next;
  while ((unsigned long )item != (unsigned long )(& arp_cache)) {
    entry = (struct arp_cache_entry *)((char *)item - (unsigned long )(& ((struct arp_cache_entry *)0)->list));
    if (entry->state == 2U) {
      if (entry->sip == sip) {
        copy = entry->smac;
        pthread_mutex_unlock(& lock);
        return (copy);
      }
    }
    item = item->next;
  }
  pthread_mutex_unlock(& lock);
  return ((unsigned char *)((void *)0));
}
}
void free_arp(void)
{
  struct list_head *item ;
  struct list_head *tmp ;
  struct arp_cache_entry *entry ;

  {
  item = arp_cache.next;
  tmp = item->next;
  while ((unsigned long )item != (unsigned long )(& arp_cache)) {
    entry = (struct arp_cache_entry *)((char *)item - (unsigned long )(& ((struct arp_cache_entry *)0)->list));
    list_del(item);
    free((void *)entry);
    item = tmp;
    tmp = item->next;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-sv_obdUY.i","-Wall,-pthread")
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern  __attribute__((__nothrow__)) int inet_pton(int __af , char const   * __restrict  __cp ,
                                                   void * __restrict  __buf ) ;
__inline static struct eth_hdr *eth_hdr(struct sk_buff *skb )
{
  struct eth_hdr *hdr ;
  uint8_t *tmp ;

  {
  tmp = skb_head(skb);
  hdr = (struct eth_hdr *)tmp;
  hdr->ethertype = ntohs(hdr->ethertype);
  return (hdr);
}
}
void netdev_init(char *addr , char *hwaddr ) ;
void *netdev_rx_loop(void) ;
void free_netdev(void) ;
__inline static uint32_t ip_parse(char *addr )
{
  uint32_t dst ;
  int tmp ;
  uint32_t tmp___0 ;

  {
  dst = (uint32_t )0;
  tmp = inet_pton(2, (char const   * __restrict  )addr, (void * __restrict  )(& dst));
  if (tmp != 1) {
    perror("ERR: Parsing inet address failed");
    exit(1);
  }
  tmp___0 = ntohl(dst);
  return (tmp___0);
}
}
struct netdev *loop  ;
struct netdev *netdev  ;
int running ;
static struct netdev *netdev_alloc(char *addr , char *hwaddr , uint32_t mtu )
{
  struct netdev *dev___0 ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct netdev ));
  dev___0 = (struct netdev *)tmp;
  dev___0->addr = ip_parse(addr);
  sscanf((char const   * __restrict  )hwaddr, (char const   * __restrict  )"%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
         & dev___0->hwaddr[0], & dev___0->hwaddr[1], & dev___0->hwaddr[2], & dev___0->hwaddr[3],
         & dev___0->hwaddr[4], & dev___0->hwaddr[5]);
  dev___0->addr_len = (uint8_t )6;
  dev___0->mtu = mtu;
  return (dev___0);
}
}
void netdev_init(char *addr , char *hwaddr )
{


  {
  loop = netdev_alloc((char *)"127.0.0.1", (char *)"00:00:00:00:00:00", (uint32_t )1500);
  netdev = netdev_alloc((char *)"10.0.0.4", (char *)"00:0c:29:6d:50:25", (uint32_t )1500);
  return;
}
}
int netdev_transmit(struct sk_buff *skb , uint8_t *dst_hw , uint16_t ethertype )
{
  struct netdev *dev___0 ;
  struct eth_hdr *hdr ;
  int ret ;

  {
  ret = 0;
  dev___0 = skb->dev;
  skb_push(skb, (unsigned int )sizeof(struct eth_hdr ));
  hdr = (struct eth_hdr *)skb->data;
  memcpy((void * __restrict  )(hdr->dmac), (void const   * __restrict  )dst_hw, (size_t )dev___0->addr_len);
  memcpy((void * __restrict  )(hdr->smac), (void const   * __restrict  )(dev___0->hwaddr),
         (size_t )dev___0->addr_len);
  hdr->ethertype = htons(ethertype);
  ret = tun_write((char *)skb->data, (int )skb->len);
  return (ret);
}
}
static int netdev_receive(struct sk_buff *skb )
{
  struct eth_hdr *hdr ;
  struct eth_hdr *tmp ;

  {
  tmp = eth_hdr(skb);
  hdr = tmp;
  switch ((int )hdr->ethertype) {
  case 2054:
  arp_rcv(skb);
  break;
  case 2048:
  ip_rcv(skb);
  break;
  default:
  printf((char const   * __restrict  )"Unsupported ethertype %x\n", (int )hdr->ethertype);
  free_skb(skb);
  break;
  }
  return (0);
}
}
void *netdev_rx_loop(void)
{
  struct sk_buff *skb ;
  struct sk_buff *tmp ;
  int tmp___0 ;

  {
  while (running) {
    tmp = alloc_skb(1600U);
    skb = tmp;
    tmp___0 = tun_read((char *)skb->data, 1600);
    if (tmp___0 < 0) {
      perror("ERR: Read from tun_fd");
      free_skb(skb);
      return ((void *)0);
    }
    netdev_receive(skb);
  }
  return ((void *)0);
}
}
struct netdev *netdev_get(uint32_t sip )
{


  {
  if (netdev->addr == sip) {
    return (netdev);
  } else {
    return ((struct netdev *)((void *)0));
  }
}
}
void free_netdev(void)
{


  {
  free((void *)loop);
  free((void *)netdev);
  return;
}
}
#pragma merger("0","/tmp/cil-1YDVKd4u.i","-Wall,-pthread")
extern int system(char const   *__command ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
uint32_t sum_every_16bits(void *addr , int count ) ;
int get_address(char *host , char *port___0 , struct sockaddr *addr ) ;
uint32_t min(uint32_t x , uint32_t y ) ;
int run_cmd(char *cmd  , ...)
{
  va_list___0 ap ;
  char buf[100] ;
  int tmp ;

  {
  __builtin_va_start(ap, cmd);
  vsnprintf((char * __restrict  )(buf), (size_t )100, (char const   * __restrict  )cmd,
            ap);
  __builtin_va_end(ap);
  if (debug) {
    printf((char const   * __restrict  )"EXEC: %s\n", buf);
  }
  tmp = system((char const   *)(buf));
  return (tmp);
}
}
uint32_t sum_every_16bits(void *addr , int count )
{
  register uint32_t sum ;
  uint16_t *ptr ;
  uint16_t *tmp ;

  {
  sum = (uint32_t )0;
  ptr = (uint16_t *)addr;
  while (count > 1) {
    tmp = ptr;
    ptr ++;
    sum += (uint32_t )*tmp;
    count -= 2;
  }
  if (count > 0) {
    sum += (uint32_t )*((uint8_t *)ptr);
  }
  return (sum);
}
}
uint16_t checksum(void *addr , int count , int start_sum )
{
  uint32_t sum ;
  uint32_t tmp ;

  {
  sum = (uint32_t )start_sum;
  tmp = sum_every_16bits(addr, count);
  sum += tmp;
  while (sum >> 16) {
    sum = (sum & 65535U) + (sum >> 16);
  }
  return ((uint16_t )(~ sum));
}
}
int get_address(char *host , char *port___0 , struct sockaddr *addr )
{
  struct addrinfo hints ;
  struct addrinfo *result ;
  struct addrinfo *rp ;
  int s ;
  char const   *tmp ;

  {
  memset((void *)(& hints), 0, sizeof(struct addrinfo ));
  hints.ai_family = 2;
  hints.ai_socktype = 1;
  s = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )port___0,
                  (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& result));
  if (s != 0) {
    tmp = gai_strerror(s);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"getaddrinfo: %s\n",
            tmp);
    exit(1);
  }
  rp = result;
  while ((unsigned long )rp != (unsigned long )((void *)0)) {
    *addr = *(rp->ai_addr);
    freeaddrinfo(result);
    return (0);
    rp = rp->ai_next;
  }
  return (1);
}
}
uint32_t parse_ipv4_string(char *addr )
{
  uint8_t addr_bytes[4] ;

  {
  sscanf((char const   * __restrict  )addr, (char const   * __restrict  )"%hhu.%hhu.%hhu.%hhu",
         & addr_bytes[3], & addr_bytes[2], & addr_bytes[1], & addr_bytes[0]);
  return ((uint32_t )((((int )addr_bytes[0] | ((int )addr_bytes[1] << 8)) | ((int )addr_bytes[2] << 16)) | ((int )addr_bytes[3] << 24)));
}
}
uint32_t min(uint32_t x , uint32_t y )
{
  uint32_t tmp ;

  {
  if (x > y) {
    tmp = y;
  } else {
    tmp = x;
  }
  return (tmp);
}
}
/* compiler builtin:
   void *__builtin_alloca(unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-eRHervh3.i","-Wall,-pthread")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strnlen)(char const   *__string ,
                                                                                       size_t __maxlen )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
void *start_ipc_listener(void) ;
void *socket_ipc_open(void *args ) ;
static struct list_head sockets___0  =    {& sockets___0, & sockets___0};
static pthread_mutex_t lock___0  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static int socket_count  =    0;
static struct ipc_thread *ipc_alloc_thread(int sock )
{
  struct ipc_thread *th ;
  void *tmp ;

  {
  tmp = calloc(sizeof(struct ipc_thread ), (size_t )1);
  th = (struct ipc_thread *)tmp;
  list_init(& th->list);
  th->sock = sock;
  pthread_mutex_lock(& lock___0);
  list_add_tail(& th->list, & sockets___0);
  socket_count ++;
  pthread_mutex_unlock(& lock___0);
  return (th);
}
}
static void ipc_free_thread(int sock )
{
  struct list_head *item ;
  struct list_head *tmp ;
  struct ipc_thread *th ;

  {
  tmp = (struct list_head *)((void *)0);
  th = (struct ipc_thread *)((void *)0);
  pthread_mutex_lock(& lock___0);
  item = sockets___0.next;
  tmp = item->next;
  while ((unsigned long )item != (unsigned long )(& sockets___0)) {
    th = (struct ipc_thread *)((char *)item - (unsigned long )(& ((struct ipc_thread *)0)->list));
    if (th->sock == sock) {
      list_del(& th->list);
      close(th->sock);
      free((void *)th);
      socket_count --;
      break;
    }
    item = tmp;
    tmp = item->next;
  }
  pthread_mutex_unlock(& lock___0);
  return;
}
}
static int ipc_try_send(int sockfd , void const   *buf , size_t len )
{
  ssize_t tmp ;

  {
  tmp = send(sockfd, buf, len, 16384);
  return ((int )tmp);
}
}
static int ipc_write_rc(int sockfd , pid_t pid , uint16_t type , int rc )
{
  int resplen ;
  struct ipc_msg *response ;
  void *tmp ;
  struct ipc_err err ;
  int tmp___0 ;

  {
  resplen = (int )(sizeof(struct ipc_msg ) + sizeof(struct ipc_err ));
  tmp = __builtin_alloca((unsigned long )resplen);
  response = (struct ipc_msg *)tmp;
  if ((unsigned long )response == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not allocate memory for IPC write response\n");
    return (-1);
  }
  response->type = type;
  response->pid = pid;
  if (rc < 0) {
    err.err = - rc;
    err.rc = -1;
  } else {
    err.err = 0;
    err.rc = rc;
  }
  memcpy((void * __restrict  )(response->data), (void const   * __restrict  )(& err),
         sizeof(struct ipc_err ));
  tmp___0 = ipc_try_send(sockfd, (void const   *)((char *)response), (size_t )resplen);
  if (tmp___0 == -1) {
    perror("Error on writing IPC write response");
  }
  return (0);
}
}
static int ipc_read(int sockfd , struct ipc_msg *msg )
{
  struct ipc_read *requested ;
  pid_t pid ;
  int rlen ;
  int resplen ;
  int tmp ;
  struct ipc_msg *response ;
  void *tmp___0 ;
  struct ipc_err *error ;
  struct ipc_read *actual ;
  int tmp___1 ;
  int tmp___2 ;

  {
  requested = (struct ipc_read *)(msg->data);
  pid = msg->pid;
  rlen = -1;
  char rbuf[requested->len] ;
  memset((void *)(rbuf), 0, requested->len);
  rlen = _read(pid, requested->sockfd, (void *)(rbuf), (unsigned int const   )requested->len);
  if (rlen > 0) {
    tmp = rlen;
  } else {
    tmp = 0;
  }
  resplen = (int )(((sizeof(struct ipc_msg ) + sizeof(struct ipc_err )) + sizeof(struct ipc_read )) + (unsigned long )tmp);
  tmp___0 = __builtin_alloca((unsigned long )resplen);
  response = (struct ipc_msg *)tmp___0;
  error = (struct ipc_err *)(response->data);
  actual = (struct ipc_read *)(error->data);
  if ((unsigned long )response == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not allocate memory for IPC read response\n");
    return (-1);
  }
  response->type = (uint16_t )4;
  response->pid = pid;
  if (rlen < 0) {
    error->rc = -1;
  } else {
    error->rc = rlen;
  }
  if (rlen < 0) {
    error->err = - rlen;
  } else {
    error->err = 0;
  }
  actual->sockfd = requested->sockfd;
  actual->len = (size_t )rlen;
  if (rlen > 0) {
    tmp___1 = rlen;
  } else {
    tmp___1 = 0;
  }
  memcpy((void * __restrict  )(actual->buf), (void const   * __restrict  )(rbuf),
         (size_t )tmp___1);
  tmp___2 = ipc_try_send(sockfd, (void const   *)((char *)response), (size_t )resplen);
  if (tmp___2 == -1) {
    perror("Error on writing IPC read response");
  }
  return (0);
}
}
static int ipc_write(int sockfd , struct ipc_msg *msg )
{
  struct ipc_write *payload ;
  pid_t pid ;
  int rc ;
  int head ;
  size_t tmp ;
  int tail ;
  int res ;
  ssize_t tmp___0 ;
  int tmp___1 ;

  {
  payload = (struct ipc_write *)(msg->data);
  pid = msg->pid;
  rc = -1;
  head = (int )((8192UL - sizeof(struct ipc_write )) - sizeof(struct ipc_msg ));
  char buf[payload->len] ;
  memset((void *)(buf), 0, payload->len);
  if (payload->len > (size_t )head) {
    tmp = (size_t )head;
  } else {
    tmp = payload->len;
  }
  memcpy((void * __restrict  )(buf), (void const   * __restrict  )(payload->buf),
         tmp);
  if (payload->len > (size_t )head) {
    tail = (int )(payload->len - (size_t )head);
    tmp___0 = read(sockfd, (void *)(& buf[head]), (size_t )tail);
    res = (int )tmp___0;
    if (res == -1) {
      perror("Read on IPC payload guard");
      return (-1);
    } else
    if (res != tail) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Hmm, we did not read exact payload amount in IPC write\n");
    }
  }
  rc = _write(pid, payload->sockfd, (void const   *)(buf), (unsigned int const   )payload->len);
  tmp___1 = ipc_write_rc(sockfd, pid, (uint16_t )3, rc);
  return (tmp___1);
}
}
static int ipc_connect(int sockfd , struct ipc_msg *msg )
{
  struct ipc_connect *payload ;
  pid_t pid ;
  int rc ;
  int tmp ;

  {
  payload = (struct ipc_connect *)(msg->data);
  pid = msg->pid;
  rc = -1;
  rc = _connect(pid, payload->sockfd, (struct sockaddr  const  *)(& payload->addr),
                payload->addrlen);
  tmp = ipc_write_rc(sockfd, pid, (uint16_t )2, rc);
  return (tmp);
}
}
static int ipc_socket(int sockfd , struct ipc_msg *msg )
{
  struct ipc_socket *sock ;
  pid_t pid ;
  int rc ;
  int tmp ;

  {
  sock = (struct ipc_socket *)(msg->data);
  pid = msg->pid;
  rc = -1;
  rc = _socket(pid, sock->domain, sock->type, sock->protocol);
  tmp = ipc_write_rc(sockfd, pid, (uint16_t )1, rc);
  return (tmp);
}
}
static int ipc_close(int sockfd , struct ipc_msg *msg )
{
  struct ipc_close *payload ;
  pid_t pid ;
  int rc ;

  {
  payload = (struct ipc_close *)(msg->data);
  pid = msg->pid;
  rc = -1;
  rc = _close(pid, payload->sockfd);
  rc = ipc_write_rc(sockfd, pid, (uint16_t )5, rc);
  return (rc);
}
}
static int ipc_poll(int sockfd , struct ipc_msg *msg )
{
  struct ipc_poll *data ;
  pid_t pid ;
  int rc ;
  int i ;
  int resplen ;
  struct ipc_msg *response ;
  void *tmp ;
  struct ipc_err err ;
  struct ipc_pollfd *polled ;
  int i___0 ;
  int tmp___0 ;

  {
  data = (struct ipc_poll *)(msg->data);
  pid = msg->pid;
  rc = -1;
  struct pollfd fds[data->nfds] ;
  i = 0;
  while ((nfds_t )i < data->nfds) {
    fds[i].fd = data->fds[i].fd;
    fds[i].events = data->fds[i].events;
    fds[i].revents = data->fds[i].revents;
    i ++;
  }
  rc = _poll(pid, fds, data->nfds, data->timeout);
  resplen = (int )((sizeof(struct ipc_msg ) + sizeof(struct ipc_err )) + sizeof(struct ipc_pollfd ) * data->nfds);
  tmp = __builtin_alloca((unsigned long )resplen);
  response = (struct ipc_msg *)tmp;
  if ((unsigned long )response == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not allocate memory for IPC write response\n");
    return (-1);
  }
  response->type = (uint16_t )6;
  response->pid = pid;
  if (rc < 0) {
    err.err = - rc;
    err.rc = -1;
  } else {
    err.err = 0;
    err.rc = rc;
  }
  memcpy((void * __restrict  )(response->data), (void const   * __restrict  )(& err),
         sizeof(struct ipc_err ));
  polled = (struct ipc_pollfd *)(((struct ipc_err *)(response->data))->data);
  i___0 = 0;
  while ((nfds_t )i___0 < data->nfds) {
    (polled + i___0)->fd = fds[i___0].fd;
    (polled + i___0)->events = fds[i___0].events;
    (polled + i___0)->revents = fds[i___0].revents;
    i___0 ++;
  }
  tmp___0 = ipc_try_send(sockfd, (void const   *)((char *)response), (size_t )resplen);
  if (tmp___0 == -1) {
    perror("Error on writing IPC poll response");
  }
  return (0);
}
}
static int ipc_fcntl(int sockfd , struct ipc_msg *msg )
{
  struct ipc_fcntl *fc ;
  pid_t pid ;
  int rc ;
  int tmp ;

  {
  fc = (struct ipc_fcntl *)(msg->data);
  pid = msg->pid;
  rc = -1;
  switch (fc->cmd) {
  case 3:
  rc = _fcntl(pid, fc->sockfd, fc->cmd);
  break;
  case 4:
  rc = _fcntl(pid, fc->sockfd, fc->cmd, *((int *)(fc->data)));
  break;
  default:
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"IPC Fcntl cmd not supported %d\n",
          fc->cmd);
  rc = -22;
  }
  tmp = ipc_write_rc(sockfd, pid, (uint16_t )7, rc);
  return (tmp);
}
}
static int ipc_getsockopt(int sockfd , struct ipc_msg *msg )
{
  struct ipc_sockopt *opts ;
  pid_t pid ;
  int rc ;
  int resplen ;
  struct ipc_msg *response ;
  void *tmp ;
  struct ipc_err err ;
  struct ipc_sockopt *optres ;
  int tmp___0 ;

  {
  opts = (struct ipc_sockopt *)(msg->data);
  pid = msg->pid;
  rc = -1;
  rc = _getsockopt(pid, opts->fd, opts->level, opts->optname, (void *)(opts->optval),
                   & opts->optlen);
  resplen = (int )(((sizeof(struct ipc_msg ) + sizeof(struct ipc_err )) + sizeof(struct ipc_sockopt )) + (unsigned long )opts->optlen);
  tmp = __builtin_alloca((unsigned long )resplen);
  response = (struct ipc_msg *)tmp;
  if ((unsigned long )response == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not allocate memory for IPC getsockopt response\n");
    return (-1);
  }
  response->type = (uint16_t )8;
  response->pid = pid;
  if (rc < 0) {
    err.err = - rc;
    err.rc = -1;
  } else {
    err.err = 0;
    err.rc = rc;
  }
  memcpy((void * __restrict  )(response->data), (void const   * __restrict  )(& err),
         sizeof(struct ipc_err ));
  optres = (struct ipc_sockopt *)(((struct ipc_err *)(response->data))->data);
  optres->fd = opts->fd;
  optres->level = opts->level;
  optres->optname = opts->optname;
  optres->optlen = opts->optlen;
  memcpy((void * __restrict  )(& optres->optval), (void const   * __restrict  )(opts->optval),
         (size_t )opts->optlen);
  tmp___0 = ipc_try_send(sockfd, (void const   *)((char *)response), (size_t )resplen);
  if (tmp___0 == -1) {
    perror("Error on writing IPC getsockopt response");
  }
  return (rc);
}
}
static int ipc_getpeername(int sockfd , struct ipc_msg *msg )
{
  struct ipc_sockname *name ;
  pid_t pid ;
  int rc ;
  int resplen ;
  struct ipc_msg *response ;
  void *tmp ;
  struct ipc_sockname *nameres ;
  struct ipc_err err ;
  int tmp___0 ;

  {
  name = (struct ipc_sockname *)(msg->data);
  pid = msg->pid;
  rc = -1;
  resplen = (int )((sizeof(struct ipc_msg ) + sizeof(struct ipc_err )) + sizeof(struct ipc_sockname ));
  tmp = __builtin_alloca((unsigned long )resplen);
  response = (struct ipc_msg *)tmp;
  if ((unsigned long )response == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not allocate memory for IPC getpeername response\n");
    return (-1);
  }
  response->type = (uint16_t )10;
  response->pid = pid;
  nameres = (struct ipc_sockname *)(((struct ipc_err *)(response->data))->data);
  rc = _getpeername(pid, name->socket, (struct sockaddr * __restrict  )((struct sockaddr *)(nameres->sa_data)),
                    (socklen_t * __restrict  )(& nameres->address_len));
  if (rc < 0) {
    err.err = - rc;
    err.rc = -1;
  } else {
    err.err = 0;
    err.rc = rc;
  }
  memcpy((void * __restrict  )(response->data), (void const   * __restrict  )(& err),
         sizeof(struct ipc_err ));
  nameres->socket = name->socket;
  tmp___0 = ipc_try_send(sockfd, (void const   *)((char *)response), (size_t )resplen);
  if (tmp___0 == -1) {
    perror("Error on writing IPC getpeername response");
  }
  return (rc);
}
}
static int ipc_getsockname(int sockfd , struct ipc_msg *msg )
{
  struct ipc_sockname *name ;
  pid_t pid ;
  int rc ;
  int resplen ;
  struct ipc_msg *response ;
  void *tmp ;
  struct ipc_sockname *nameres ;
  struct ipc_err err ;
  int tmp___0 ;

  {
  name = (struct ipc_sockname *)(msg->data);
  pid = msg->pid;
  rc = -1;
  resplen = (int )((sizeof(struct ipc_msg ) + sizeof(struct ipc_err )) + sizeof(struct ipc_sockname ));
  tmp = __builtin_alloca((unsigned long )resplen);
  response = (struct ipc_msg *)tmp;
  if ((unsigned long )response == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not allocate memory for IPC getsockname response\n");
    return (-1);
  }
  response->type = (uint16_t )11;
  response->pid = pid;
  nameres = (struct ipc_sockname *)(((struct ipc_err *)(response->data))->data);
  rc = _getsockname(pid, name->socket, (struct sockaddr * __restrict  )((struct sockaddr *)(nameres->sa_data)),
                    (socklen_t * __restrict  )(& nameres->address_len));
  if (rc < 0) {
    err.err = - rc;
    err.rc = -1;
  } else {
    err.err = 0;
    err.rc = rc;
  }
  memcpy((void * __restrict  )(response->data), (void const   * __restrict  )(& err),
         sizeof(struct ipc_err ));
  nameres->socket = name->socket;
  tmp___0 = ipc_try_send(sockfd, (void const   *)((char *)response), (size_t )resplen);
  if (tmp___0 == -1) {
    perror("Error on writing IPC getsockname response");
  }
  return (rc);
}
}
static int demux_ipc_socket_call(int sockfd , char *cmdbuf , int blen )
{
  struct ipc_msg *msg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  msg = (struct ipc_msg *)cmdbuf;
  switch ((int )msg->type) {
  case 1:
  tmp = ipc_socket(sockfd, msg);
  return (tmp);
  break;
  case 2:
  tmp___0 = ipc_connect(sockfd, msg);
  return (tmp___0);
  break;
  case 3:
  tmp___1 = ipc_write(sockfd, msg);
  return (tmp___1);
  break;
  case 4:
  tmp___2 = ipc_read(sockfd, msg);
  return (tmp___2);
  break;
  case 5:
  tmp___3 = ipc_close(sockfd, msg);
  return (tmp___3);
  break;
  case 6:
  tmp___4 = ipc_poll(sockfd, msg);
  return (tmp___4);
  break;
  case 7:
  tmp___5 = ipc_fcntl(sockfd, msg);
  return (tmp___5);
  break;
  case 8:
  tmp___6 = ipc_getsockopt(sockfd, msg);
  return (tmp___6);
  case 10:
  tmp___7 = ipc_getpeername(sockfd, msg);
  return (tmp___7);
  case 11:
  tmp___8 = ipc_getsockname(sockfd, msg);
  return (tmp___8);
  default:
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No such IPC type %d\n",
          (int )msg->type);
  break;
  }
  return (0);
}
}
void *socket_ipc_open(void *args )
{
  int blen ;
  int sockfd ;
  int rc ;
  ssize_t tmp ;

  {
  blen = 8192;
  char buf[blen] ;
  sockfd = *((int *)args);
  rc = -1;
  while (1) {
    tmp = read(sockfd, (void *)(buf), (size_t )blen);
    rc = (int )tmp;
    if (! (rc > 0)) {
      break;
    }
    rc = demux_ipc_socket_call(sockfd, buf, blen);
    if (rc == -1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error on demuxing IPC socket call\n");
      close(sockfd);
      return ((void *)0);
    }
  }
  ipc_free_thread(sockfd);
  if (rc == -1) {
    perror("socket ipc read");
  }
  return ((void *)0);
}
}
void *start_ipc_listener(void)
{
  int fd___0 ;
  int rc ;
  int datasock ;
  struct sockaddr_un un ;
  char *sockname ;
  size_t tmp ;
  int tmp___0 ;
  struct ipc_thread *th ;
  struct ipc_thread *tmp___1 ;
  int tmp___2 ;

  {
  sockname = (char *)"/tmp/lvlip.socket";
  unlink((char const   *)sockname);
  tmp = strnlen((char const   *)sockname, sizeof(un.sun_path));
  if (tmp == sizeof(un.sun_path)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Path for UNIX socket is too long\n");
    exit(-1);
  }
  fd___0 = socket(1, 1, 0);
  if (fd___0 < 0) {
    perror("IPC listener UNIX socket");
    exit(1);
  }
  memset((void *)(& un), 0, sizeof(struct sockaddr_un ));
  un.sun_family = (sa_family_t )1;
  strncpy((char * __restrict  )(un.sun_path), (char const   * __restrict  )sockname,
          sizeof(un.sun_path) - 1UL);
  rc = bind(fd___0, (struct sockaddr  const  *)(& un), (socklen_t )sizeof(struct sockaddr_un ));
  if (rc == -1) {
    perror("IPC bind");
    exit(1);
  }
  rc = listen(fd___0, 20);
  if (rc == -1) {
    perror("IPC listen");
    exit(1);
  }
  tmp___0 = chmod((char const   *)sockname, (__mode_t )((((((448 | (256 >> 3)) | (128 >> 3)) | (64 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3)) | ((64 >> 3) >> 3)));
  if (tmp___0 == -1) {
    perror("Chmod on lvl-ip IPC UNIX socket failed");
    exit(1);
  }
  while (1) {
    datasock = accept(fd___0, (struct sockaddr * __restrict  )((void *)0), (socklen_t * __restrict  )((void *)0));
    if (datasock == -1) {
      perror("IPC accept");
      exit(1);
    }
    tmp___1 = ipc_alloc_thread(datasock);
    th = tmp___1;
    tmp___2 = pthread_create((pthread_t * __restrict  )(& th->id), (pthread_attr_t const   * __restrict  )((void *)0),
                             & socket_ipc_open, (void * __restrict  )(& th->sock));
    if (tmp___2 != 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error on socket thread creation\n");
      exit(1);
    }
  }
  close(fd___0);
  unlink((char const   *)sockname);
  return ((void *)0);
}
}
#pragma merger("0","/tmp/cil-9g7w5BkD.i","-Wall,-pthread")
struct rtentry *route_lookup(uint32_t daddr ) ;
int dst_neigh_output(struct sk_buff *skb ) ;
void ip_send_check(struct iphdr *ihdr )
{
  uint32_t csum ;
  uint16_t tmp ;

  {
  tmp = checksum((void *)ihdr, (int )ihdr->ihl * 4, 0);
  csum = (uint32_t )tmp;
  ihdr->csum = (uint16_t )csum;
  return;
}
}
int ip_output(struct sock *sk , struct sk_buff *skb )
{
  struct rtentry *rt ;
  struct iphdr *ihdr ;
  struct iphdr *tmp ;
  int tmp___0 ;

  {
  tmp = ip_hdr((struct sk_buff  const  *)skb);
  ihdr = tmp;
  rt = route_lookup(sk->daddr);
  if (! rt) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"IP output route lookup fail\n");
    return (-1);
  }
  skb->dev = rt->dev;
  skb->rt = rt;
  skb_push(skb, (unsigned int )sizeof(struct iphdr ));
  ihdr->version = (uint8_t )4;
  ihdr->ihl = (uint8_t )5;
  ihdr->tos = (uint8_t )0;
  ihdr->len = (uint16_t )skb->len;
  ihdr->id = ihdr->id;
  ihdr->frag_offset = (uint16_t )16384;
  ihdr->ttl = (uint8_t )64;
  ihdr->proto = (uint8_t )skb->protocol;
  ihdr->saddr = (skb->dev)->addr;
  ihdr->daddr = sk->daddr;
  ihdr->csum = (uint16_t )0;
  ihdr->len = htons(ihdr->len);
  ihdr->id = htons(ihdr->id);
  ihdr->daddr = htonl(ihdr->daddr);
  ihdr->saddr = htonl(ihdr->saddr);
  ihdr->csum = htons(ihdr->csum);
  ihdr->frag_offset = htons(ihdr->frag_offset);
  ip_send_check(ihdr);
  tmp___0 = dst_neigh_output(skb);
  return (tmp___0);
}
}
#pragma merger("0","/tmp/cil-097nyiJo.i","-Wall,-pthread")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
extern int ( __attribute__((__nonnull__(1,2))) sigwait)(sigset_t const   * __restrict  __set ,
                                                        int * __restrict  __sig ) ;
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                                                         __sigset_t * __restrict  __oldmask ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern int pthread_cancel(pthread_t __th ) ;
extern  __attribute__((__nothrow__)) int prctl(int __option  , ...) ;
void *timers_start(void) ;
void route_init(void) ;
void free_routes(void) ;
static pthread_t threads[4]  ;
int running  =    1;
sigset_t mask  ;
static void create_thread(pthread_t id , void *(*func)(void * ) )
{
  int tmp ;

  {
  tmp = pthread_create((pthread_t * __restrict  )(& threads[id]), (pthread_attr_t const   * __restrict  )((void *)0),
                       func, (void * __restrict  )((void *)0));
  if (tmp != 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not create core thread\n");
  }
  return;
}
}
static void *stop_stack_handler(void *arg )
{
  int err ;
  int signo ;

  {
  while (1) {
    err = sigwait((sigset_t const   * __restrict  )(& mask), (int * __restrict  )(& signo));
    if (err != 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Sigwait failed: %d\n",
              err);
    }
    switch (signo) {
    case 3:
    case 2:
    running = 0;
    pthread_cancel(threads[2]);
    pthread_cancel(threads[0]);
    pthread_cancel(threads[1]);
    return ((void *)0);
    default:
    printf((char const   * __restrict  )"Unexpected signal %d\n", signo);
    }
  }
}
}
static void init_signals(void)
{
  int err ;

  {
  sigemptyset(& mask);
  sigaddset(& mask, 2);
  sigaddset(& mask, 3);
  err = pthread_sigmask(0, (__sigset_t const   * __restrict  )(& mask), (__sigset_t * __restrict  )((void *)0));
  if (err != 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SIG_BLOCK error\n");
    exit(1);
  }
  return;
}
}
static void init_stack(void)
{


  {
  tun_init();
  netdev_init(0, 0);
  route_init();
  arp_init();
  tcp_init();
  return;
}
}
static void run_threads(void)
{


  {
  create_thread((pthread_t )0, (void *(*)(void * ))(& netdev_rx_loop));
  create_thread((pthread_t )1, (void *(*)(void * ))(& timers_start));
  create_thread((pthread_t )2, (void *(*)(void * ))(& start_ipc_listener));
  create_thread((pthread_t )3, & stop_stack_handler);
  return;
}
}
static void wait_for_threads(void)
{
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < 3) {
    tmp = pthread_join(threads[i], (void **)((void *)0));
    if (tmp != 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error when joining threads\n");
      exit(1);
    }
    i ++;
  }
  return;
}
}
void free_stack(void)
{


  {
  abort_sockets();
  free_arp();
  free_routes();
  free_netdev();
  free_tun();
  return;
}
}
void init_security(void)
{
  int tmp ;
  int tmp___0 ;

  {
  tmp = prctl(24, 12);
  if (tmp == -1) {
    perror("Error on network admin capability drop");
    exit(1);
  }
  tmp___0 = prctl(24, 8);
  if (tmp___0 == -1) {
    perror("Error on capability set drop");
    exit(1);
  }
  return;
}
}
int main(int argc , char **argv )
{


  {
  parse_cli(argc, argv);
  init_signals();
  init_stack();
  init_security();
  run_threads();
  wait_for_threads();
  free_stack();
  return (0);
}
}
#pragma merger("0","/tmp/cil-5eRVNgNk.i","-Wall,-pthread")
int dst_neigh_output(struct sk_buff *skb )
{
  struct iphdr *iphdr ;
  struct iphdr *tmp ;
  struct netdev *netdev___0 ;
  struct rtentry *rt ;
  uint32_t daddr ;
  uint32_t tmp___0 ;
  uint32_t saddr ;
  uint32_t tmp___1 ;
  uint8_t *dmac ;
  int tmp___2 ;

  {
  tmp = ip_hdr((struct sk_buff  const  *)skb);
  iphdr = tmp;
  netdev___0 = skb->dev;
  rt = skb->rt;
  tmp___0 = ntohl(iphdr->daddr);
  daddr = tmp___0;
  tmp___1 = ntohl(iphdr->saddr);
  saddr = tmp___1;
  if ((int )rt->flags & 2) {
    daddr = rt->gateway;
  }
  dmac = arp_get_hwaddr(daddr);
  if (dmac) {
    tmp___2 = netdev_transmit(skb, dmac, (uint16_t )2048);
    return (tmp___2);
  } else {
    arp_request(saddr, daddr, netdev___0);
    return (-1);
  }
}
}
#pragma merger("0","/tmp/cil-pSUbVops.i","-Wall,-pthread")
int tcp_data_dequeue(struct tcp_sock *tsk , void *user_buf , int userlen ) ;
int tcp_data_queue(struct tcp_sock *tsk , struct tcphdr *th , struct sk_buff *skb ) ;
static int tcp_parse_opts(struct tcp_sock *tsk , struct tcphdr *th )
{
  uint8_t *ptr ;
  uint8_t optlen ;
  struct tcp_opt_mss *opt_mss ;
  uint8_t sack_seen ;
  uint8_t tsopt_seen ;
  uint16_t mss ;
  uint16_t tmp ;

  {
  ptr = th->data;
  optlen = (uint8_t )(((int )th->hl << 2) - 20);
  opt_mss = (struct tcp_opt_mss *)((void *)0);
  sack_seen = (uint8_t )0;
  tsopt_seen = (uint8_t )0;
  while (1) {
    if ((int )optlen > 0) {
      if (! ((int )optlen < 20)) {
        break;
      }
    } else {
      break;
    }
    switch ((int )*ptr) {
    case 2:
    opt_mss = (struct tcp_opt_mss *)ptr;
    tmp = ntohs(opt_mss->mss);
    mss = tmp;
    if ((int )mss > 536) {
      if ((int )mss <= 1460) {
        tsk->smss = mss;
      }
    }
    ptr += sizeof(struct tcp_opt_mss );
    optlen = (uint8_t )((int )optlen - 4);
    break;
    case 1:
    ptr ++;
    optlen = (uint8_t )((int )optlen - 1);
    break;
    case 4:
    sack_seen = (uint8_t )1;
    optlen = (uint8_t )((int )optlen - 1);
    break;
    case 8:
    tsopt_seen = (uint8_t )1;
    optlen = (uint8_t )((int )optlen - 1);
    break;
    default:
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized TCPOPT\n");
    optlen = (uint8_t )((int )optlen - 1);
    break;
    }
  }
  if (! tsopt_seen) {
    tsk->tsopt = (uint8_t )0;
  }
  if (sack_seen) {
    if (tsk->sackok) {
      if (tsk->tsopt) {
        tsk->sacks_allowed = (uint8_t )3;
      } else {
        tsk->sacks_allowed = (uint8_t )4;
      }
    } else {
      tsk->sackok = (uint8_t )0;
    }
  } else {
    tsk->sackok = (uint8_t )0;
  }
  return (0);
}
}
static int tcp_clean_rto_queue(struct sock *sk , uint32_t una )
{
  struct tcp_sock *tsk ;
  struct sk_buff *skb ;
  int rc ;

  {
  tsk = (struct tcp_sock *)sk;
  rc = 0;
  while (1) {
    skb = skb_peek(& sk->write_queue);
    if (! ((unsigned long )skb != (unsigned long )((void *)0))) {
      break;
    }
    if (skb->seq > 0U) {
      if (skb->end_seq <= una) {
        skb_dequeue(& sk->write_queue);
        (skb->refcnt) --;
        free_skb(skb);
        if (tsk->inflight > 0U) {
          (tsk->inflight) --;
        }
      } else {
        break;
      }
    } else {
      break;
    }
  }
  if ((unsigned long )skb == (unsigned long )((void *)0)) {
    tcp_stop_rto_timer(tsk);
  } else
  if (tsk->inflight == 0U) {
    tcp_stop_rto_timer(tsk);
  }
  return (rc);
}
}
__inline static int __tcp_drop(struct sock *sk , struct sk_buff *skb )
{


  {
  free_skb(skb);
  return (0);
}
}
static int tcp_verify_segment(struct tcp_sock *tsk , struct tcphdr *th , struct sk_buff *skb )
{
  struct tcb *tcb ;

  {
  tcb = & tsk->tcb;
  if (skb->dlen > 0U) {
    if (tcb->rcv_wnd == 0U) {
      return (0);
    }
  }
  if (th->seq < tcb->rcv_nxt) {
    return (0);
  } else
  if (th->seq > tcb->rcv_nxt + tcb->rcv_wnd) {
    return (0);
  }
  return (1);
}
}
static void tcp_reset(struct sock *sk )
{


  {
  sk->poll_events = (short)284;
  switch (sk->state) {
  case 1:
  sk->err = -111;
  break;
  case 7:
  sk->err = -32;
  break;
  case 6:
  return;
  default:
  sk->err = -104;
  break;
  }
  tcp_done(sk);
  return;
}
}
__inline static int tcp_discard(struct tcp_sock *tsk , struct sk_buff *skb , struct tcphdr *th )
{


  {
  free_skb(skb);
  return (0);
}
}
static int tcp_listen(struct tcp_sock *tsk , struct sk_buff *skb , struct tcphdr *th )
{


  {
  free_skb(skb);
  return (0);
}
}
static int tcp_synsent(struct tcp_sock *tsk , struct sk_buff *skb , struct tcphdr *th )
{
  struct tcb *tcb ;
  struct sock *sk ;

  {
  tcb = & tsk->tcb;
  sk = & tsk->sk;
  if (th->ack) {
    if (th->ack_seq <= tcb->iss) {
      goto _L;
    } else
    if (th->ack_seq > tcb->snd_nxt) {
      _L: /* CIL Label */
      if (th->rst) {
        goto discard;
      }
      goto reset_and_discard;
    }
    if (th->ack_seq < tcb->snd_una) {
      goto reset_and_discard;
    } else
    if (th->ack_seq > tcb->snd_nxt) {
      goto reset_and_discard;
    }
  }
  if (th->rst) {
    tcp_reset(& tsk->sk);
    goto discard;
  }
  if (! th->syn) {
    goto discard;
  }
  tcb->rcv_nxt = th->seq + 1U;
  tcb->irs = th->seq;
  if (th->ack) {
    tcb->snd_una = th->ack_seq;
    tcp_clean_rto_queue(sk, tcb->snd_una);
  }
  if (tcb->snd_una > tcb->iss) {
    __tcp_set_state(sk, (uint32_t )3);
    tcb->snd_una = tcb->snd_nxt;
    tsk->backoff = (uint8_t )0;
    tsk->rto = (uint32_t )1000;
    tcp_send_ack(& tsk->sk);
    tcp_rearm_user_timeout(& tsk->sk);
    tcp_parse_opts(tsk, th);
    sock_connected(sk);
  } else {
    __tcp_set_state(sk, (uint32_t )2);
    tcb->snd_una = tcb->iss;
    tcp_send_synack(& tsk->sk);
  }
  discard:
  __tcp_drop(sk, skb);
  return (0);
  reset_and_discard:
  __tcp_drop(sk, skb);
  return (0);
}
}
static int tcp_closed(struct tcp_sock *tsk , struct sk_buff *skb , struct tcphdr *th )
{
  int rc ;

  {
  rc = -1;
  if (th->rst) {
    tcp_discard(tsk, skb, th);
    rc = 0;
    goto out;
  }
  rc = tcp_send_reset(tsk);
  free_skb(skb);
  out:
  return (rc);
}
}
int tcp_input_state(struct sock *sk , struct tcphdr *th , struct sk_buff *skb )
{
  struct tcp_sock *tsk ;
  struct tcb *tcb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int expected ;
  int tmp___12 ;
  int pending ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;

  {
  tsk = (struct tcp_sock *)sk;
  tcb = & tsk->tcb;
  switch (sk->state) {
  case 6:
  tmp = tcp_closed(tsk, skb, th);
  return (tmp);
  case 0:
  tmp___0 = tcp_listen(tsk, skb, th);
  return (tmp___0);
  case 1:
  tmp___1 = tcp_synsent(tsk, skb, th);
  return (tmp___1);
  }
  tmp___3 = tcp_verify_segment(tsk, th, skb);
  if (! tmp___3) {
    if (! th->rst) {
      tcp_send_ack(sk);
    }
    tmp___2 = __tcp_drop(sk, skb);
    return (tmp___2);
  }
  if (th->rst) {
    free_skb(skb);
    tcp_enter_time_wait(sk);
    (*((tsk->sk.ops)->recv_notify))(& tsk->sk);
    return (0);
  }
  if (th->syn) {
    tcp_send_challenge_ack(sk, skb);
    tmp___4 = __tcp_drop(sk, skb);
    return (tmp___4);
  }
  if (! th->ack) {
    tmp___5 = __tcp_drop(sk, skb);
    return (tmp___5);
  }
  switch (sk->state) {
  case 2:
  if (tcb->snd_una <= th->ack_seq) {
    if (th->ack_seq < tcb->snd_nxt) {
      __tcp_set_state(sk, (uint32_t )3);
    } else {
      tmp___6 = __tcp_drop(sk, skb);
      return (tmp___6);
    }
  } else {
    tmp___6 = __tcp_drop(sk, skb);
    return (tmp___6);
  }
  case 9:
  case 8:
  case 7:
  case 5:
  case 4:
  case 3:
  if (tcb->snd_una < th->ack_seq) {
    if (th->ack_seq <= tcb->snd_nxt) {
      tcb->snd_una = th->ack_seq;
      tcp_rtt(tsk);
      tcp_clean_rto_queue(sk, tcb->snd_una);
    }
  }
  if (th->ack_seq < tcb->snd_una) {
    tmp___7 = __tcp_drop(sk, skb);
    return (tmp___7);
  }
  if (th->ack_seq > tcb->snd_nxt) {
    tmp___8 = __tcp_drop(sk, skb);
    return (tmp___8);
  }
  if (tcb->snd_una < th->ack_seq) {
    if (th->ack_seq <= tcb->snd_nxt) {
      tmp___9 = 1;
    } else {
      tmp___9 = 0;
    }
  } else {
    tmp___9 = 0;
  }
  break;
  }
  tmp___11 = skb_queue_empty((struct sk_buff_head  const  *)(& sk->write_queue));
  if (tmp___11) {
    switch (sk->state) {
    case 4:
    __tcp_set_state(sk, (uint32_t )5);
    case 5:
    break;
    case 8:
    __tcp_set_state(sk, (uint32_t )10);
    break;
    case 9:
    free_skb(skb);
    tmp___10 = tcp_done(sk);
    return (tmp___10);
    case 10:
    if (tcb->rcv_nxt == th->seq) {
      tsk->flags = (uint8_t )((int )tsk->flags | 1);
      tcp_send_ack(sk);
    }
    break;
    }
  }
  expected = skb->seq == tcb->rcv_nxt;
  switch (sk->state) {
  case 5:
  case 4:
  case 3:
  if (th->psh) {
    tcp_data_queue(tsk, th, skb);
  } else
  if (skb->dlen > 0U) {
    tcp_data_queue(tsk, th, skb);
  }
  break;
  case 10:
  case 9:
  case 8:
  case 7:
  break;
  }
  if (th->fin) {
    if (expected) {
      switch (sk->state) {
      case 1:
      case 0:
      case 6:
      goto drop_and_unlock;
      }
      (tcb->rcv_nxt) ++;
      tsk->flags = (uint8_t )((int )tsk->flags | 1);
      sk->poll_events = (short )((int )sk->poll_events | 195);
      tcp_send_ack(sk);
      (*((tsk->sk.ops)->recv_notify))(& tsk->sk);
      switch (sk->state) {
      case 3:
      case 2:
      __tcp_set_state(sk, (uint32_t )7);
      break;
      case 4:
      tmp___12 = skb_queue_empty((struct sk_buff_head  const  *)(& sk->write_queue));
      if (tmp___12) {
        tcp_enter_time_wait(sk);
      } else {
        __tcp_set_state(sk, (uint32_t )8);
      }
      break;
      case 5:
      tcp_enter_time_wait(sk);
      break;
      case 9:
      case 8:
      case 7:
      break;
      case 10:
      break;
      }
    }
  }
  switch (sk->state) {
  case 5:
  case 4:
  case 3:
  if (expected) {
    tcp_stop_delack_timer(tsk);
    tmp___13 = skb_queue_len((struct sk_buff_head  const  *)(& sk->write_queue));
    tmp___14 = min(tmp___13, (uint32_t )3);
    pending = (int )tmp___14;
    if (tsk->inflight == 0U) {
      if (pending > 0) {
        tcp_send_next(sk, pending);
        tsk->inflight += (uint32_t )pending;
        tcp_rearm_rto_timer(tsk);
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */
    if (th->psh) {
      tsk->delacks = (uint8_t )0;
      tcp_send_ack(sk);
    } else
    if (skb->dlen > 1000U) {
      tsk->delacks = (uint8_t )((int )tsk->delacks + 1);
      if ((int )tsk->delacks > 1) {
        tsk->delacks = (uint8_t )0;
        tcp_send_ack(sk);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */
    if (skb->dlen > 0U) {
      tsk->delack = timer_add((uint32_t )200, & tcp_send_delack, (void *)(& tsk->sk));
    }
  }
  }
  free_skb(skb);
  unlock:
  return (0);
  drop_and_unlock:
  __tcp_drop(sk, skb);
  goto unlock;
}
}
int tcp_receive(struct tcp_sock *tsk , void *buf , int len )
{
  int rlen ;
  int curlen ;
  struct sock *sk ;
  struct socket *sock ;

  {
  rlen = 0;
  curlen = 0;
  sk = & tsk->sk;
  sock = sk->sock;
  memset(buf, 0, (size_t )len);
  while (rlen < len) {
    curlen = tcp_data_dequeue(tsk, buf + rlen, len - rlen);
    rlen += curlen;
    if ((int )tsk->flags & 8) {
      tsk->flags = (uint8_t )((int )tsk->flags & -9);
      break;
    }
    if ((int )tsk->flags & 1) {
      break;
    } else
    if (rlen == len) {
      break;
    }
    if (sock->flags & 2048) {
      if (rlen == 0) {
        rlen = -11;
      }
      break;
    } else {
      pthread_mutex_lock(& tsk->sk.recv_wait.lock);
      socket_release(sock);
      wait_sleep(& tsk->sk.recv_wait);
      pthread_mutex_unlock(& tsk->sk.recv_wait.lock);
      socket_wr_acquire(sock);
    }
  }
  if (rlen >= 0) {
    tcp_rearm_user_timeout(sk);
  }
  return (rlen);
}
}
#pragma merger("0","/tmp/cil-AWG7dk9H.i","-Wall,-pthread")
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_trylock)(pthread_mutex_t *__mutex ) ;
static struct list_head timers  =    {& timers, & timers};
static int tick  =    0;
static pthread_mutex_t lock___1  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static pthread_rwlock_t rwlock  =    {{0U,
     0U, 0U, 0U, 0U, 0U, 0, 0, (signed char)0, {(unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0,
                                                (unsigned char)0, (unsigned char)0,
                                                (unsigned char)0}, 0UL, 0U}};
static void timer_debug(void)
{


  {
  return;
}
}
static void timer_free(struct timer *t )
{


  {
  pthread_mutex_destroy(& t->lock);
  free((void *)t);
  return;
}
}
static struct timer *timer_alloc(void)
{
  struct timer *t ;
  void *tmp ;

  {
  tmp = calloc(sizeof(struct timer ), (size_t )1);
  t = (struct timer *)tmp;
  pthread_mutex_init(& t->lock, (pthread_mutexattr_t const   *)((void *)0));
  return (t);
}
}
static void timers_tick(void)
{
  struct list_head *item ;
  struct list_head *tmp ;
  struct timer *t ;
  int rc ;
  char *tmp___0 ;
  char *tmp___1 ;
  pthread_t th ;

  {
  tmp = (struct list_head *)((void *)0);
  t = (struct timer *)((void *)0);
  rc = 0;
  rc = pthread_mutex_lock(& lock___1);
  if (rc != 0) {
    tmp___0 = strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Timer tick lock not acquired: %s\n",
            tmp___0);
    return;
  }
  item = timers.next;
  tmp = item->next;
  while ((unsigned long )item != (unsigned long )(& timers)) {
    if (! item) {
      goto __Cont;
    }
    t = (struct timer *)((char *)item - (unsigned long )(& ((struct timer *)0)->list));
    rc = pthread_mutex_trylock(& t->lock);
    if (rc != 0) {
      if (rc != 16) {
        tmp___1 = strerror(rc);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Timer free mutex lock: %s\n",
                tmp___1);
      }
      goto __Cont;
    }
    if (! t->cancelled) {
      if (t->expires < (uint32_t )tick) {
        t->cancelled = 1;
        pthread_create((pthread_t * __restrict  )(& th), (pthread_attr_t const   * __restrict  )((void *)0),
                       t->handler, (void * __restrict  )t->arg);
      }
    }
    if (t->cancelled) {
      if (t->refcnt == 0) {
        list_del(& t->list);
        pthread_mutex_unlock(& t->lock);
        timer_free(t);
      } else {
        pthread_mutex_unlock(& t->lock);
      }
    } else {
      pthread_mutex_unlock(& t->lock);
    }
    __Cont: /* CIL Label */
    item = tmp;
    tmp = item->next;
  }
  pthread_mutex_unlock(& lock___1);
  return;
}
}
void timer_oneshot(uint32_t expire , void *(*handler)(void * ) , void *arg )
{
  struct timer *t ;
  struct timer *tmp ;
  int tick___0 ;
  int tmp___0 ;

  {
  tmp = timer_alloc();
  t = tmp;
  tmp___0 = timer_get_tick();
  tick___0 = tmp___0;
  t->refcnt = 0;
  t->expires = (uint32_t )tick___0 + expire;
  t->cancelled = 0;
  if (t->expires < (uint32_t )tick___0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERR: Timer expiry integer wrap around\n");
  }
  t->handler = handler;
  t->arg = arg;
  pthread_mutex_lock(& lock___1);
  list_add_tail(& t->list, & timers);
  pthread_mutex_unlock(& lock___1);
  return;
}
}
struct timer *timer_add(uint32_t expire , void *(*handler)(void * ) , void *arg )
{
  struct timer *t ;
  struct timer *tmp ;
  int tick___0 ;
  int tmp___0 ;

  {
  tmp = timer_alloc();
  t = tmp;
  tmp___0 = timer_get_tick();
  tick___0 = tmp___0;
  t->refcnt = 1;
  t->expires = (uint32_t )tick___0 + expire;
  t->cancelled = 0;
  if (t->expires < (uint32_t )tick___0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERR: Timer expiry integer wrap around\n");
  }
  t->handler = handler;
  t->arg = arg;
  pthread_mutex_lock(& lock___1);
  list_add_tail(& t->list, & timers);
  pthread_mutex_unlock(& lock___1);
  return (t);
}
}
void timer_release(struct timer *t )
{
  int rc ;
  char *tmp ;

  {
  rc = 0;
  if (! t) {
    return;
  }
  rc = pthread_mutex_lock(& t->lock);
  if (rc != 0) {
    tmp = strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Timer release lock: %s\n",
            tmp);
    return;
  }
  (t->refcnt) --;
  pthread_mutex_unlock(& t->lock);
  return;
}
}
void timer_cancel(struct timer *t )
{
  int rc ;
  char *tmp ;

  {
  rc = 0;
  if (! t) {
    return;
  }
  rc = pthread_mutex_lock(& t->lock);
  if (rc != 0) {
    tmp = strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Timer cancel lock: %s\n",
            tmp);
    return;
  }
  (t->refcnt) --;
  t->cancelled = 1;
  pthread_mutex_unlock(& t->lock);
  return;
}
}
void *timers_start(void)
{
  int tmp ;

  {
  while (1) {
    tmp = usleep((__useconds_t )10000);
    if (tmp != 0) {
      perror("Timer usleep");
    }
    pthread_rwlock_wrlock(& rwlock);
    tick += 10;
    pthread_rwlock_unlock(& rwlock);
    timers_tick();
    if (tick % 5000 == 0) {
      socket_debug();
      timer_debug();
    }
  }
}
}
int timer_get_tick(void)
{
  int copy ;

  {
  copy = 0;
  pthread_rwlock_rdlock(& rwlock);
  copy = tick;
  pthread_rwlock_unlock(& rwlock);
  return (copy);
}
}
#pragma merger("0","/tmp/cil-ioR_OhLI.i","-Wall,-pthread")
__inline static void skb_queue_add(struct sk_buff_head *list , struct sk_buff *new ,
                                   struct sk_buff *next )
{


  {
  list_add_tail(& new->list, & next->list);
  (list->qlen) ++;
  return;
}
}
static void tcp_data_insert_ordered(struct sk_buff_head *queue , struct sk_buff *skb )
{
  struct sk_buff *next ;
  struct list_head *item ;
  struct list_head *tmp ;

  {
  item = queue->head.next;
  tmp = item->next;
  while ((unsigned long )item != (unsigned long )(& queue->head)) {
    next = (struct sk_buff *)((char *)item - (unsigned long )(& ((struct sk_buff *)0)->list));
    if (skb->seq < next->seq) {
      if (skb->end_seq > next->seq) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not join skbs\n");
      } else {
        (skb->refcnt) ++;
        skb_queue_add(queue, skb, next);
        return;
      }
    } else
    if (skb->seq == next->seq) {
      return;
    }
    item = tmp;
    tmp = item->next;
  }
  (skb->refcnt) ++;
  skb_queue_tail(queue, skb);
  return;
}
}
static void tcp_consume_ofo_queue(struct tcp_sock *tsk )
{
  struct sock *sk ;
  struct tcb *tcb ;
  struct sk_buff *skb ;

  {
  sk = & tsk->sk;
  tcb = & tsk->tcb;
  skb = (struct sk_buff *)((void *)0);
  while (1) {
    skb = skb_peek(& tsk->ofo_queue);
    if ((unsigned long )skb != (unsigned long )((void *)0)) {
      if (! (tcb->rcv_nxt == skb->seq)) {
        break;
      }
    } else {
      break;
    }
    tcb->rcv_nxt += skb->dlen;
    skb_dequeue(& tsk->ofo_queue);
    skb_queue_tail(& sk->receive_queue, skb);
  }
  return;
}
}
int tcp_data_dequeue(struct tcp_sock *tsk , void *user_buf , int userlen )
{
  struct sock *sk ;
  struct tcphdr *th ;
  int rlen ;
  struct sk_buff *skb ;
  struct sk_buff *tmp ;
  int dlen ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  sk = & tsk->sk;
  rlen = 0;
  while (1) {
    tmp___1 = skb_queue_empty((struct sk_buff_head  const  *)(& sk->receive_queue));
    if (tmp___1) {
      break;
    } else
    if (! (rlen < userlen)) {
      break;
    }
    tmp = skb_peek(& sk->receive_queue);
    skb = tmp;
    if ((unsigned long )skb == (unsigned long )((void *)0)) {
      break;
    }
    th = tcp_hdr((struct sk_buff  const  *)skb);
    if ((uint32_t )rlen + skb->dlen > (uint32_t )userlen) {
      tmp___0 = (uint32_t )(userlen - rlen);
    } else {
      tmp___0 = skb->dlen;
    }
    dlen = (int )tmp___0;
    memcpy((void * __restrict  )user_buf, (void const   * __restrict  )skb->payload,
           (size_t )dlen);
    skb->dlen -= (uint32_t )dlen;
    skb->payload += dlen;
    rlen += dlen;
    user_buf += dlen;
    if (skb->dlen == 0U) {
      if (th->psh) {
        tsk->flags = (uint8_t )((int )tsk->flags | 8);
      }
      skb_dequeue(& sk->receive_queue);
      (skb->refcnt) --;
      free_skb(skb);
    }
  }
  tmp___2 = skb_queue_empty((struct sk_buff_head  const  *)(& sk->receive_queue));
  if (tmp___2) {
    if (! ((int )tsk->flags & 1)) {
      sk->poll_events = (short )((int )sk->poll_events & -2);
    }
  }
  return (rlen);
}
}
int tcp_data_queue(struct tcp_sock *tsk , struct tcphdr *th , struct sk_buff *skb )
{
  struct sock *sk ;
  struct tcb *tcb ;
  int rc ;
  int expected ;

  {
  sk = & tsk->sk;
  tcb = & tsk->tcb;
  rc = 0;
  if (! tcb->rcv_wnd) {
    free_skb(skb);
    return (-1);
  }
  expected = skb->seq == tcb->rcv_nxt;
  if (expected) {
    tcb->rcv_nxt += skb->dlen;
    (skb->refcnt) ++;
    skb_queue_tail(& sk->receive_queue, skb);
    tcp_consume_ofo_queue(tsk);
    sk->poll_events = (short )((int )sk->poll_events | 195);
    (*((tsk->sk.ops)->recv_notify))(& tsk->sk);
  } else {
    tcp_data_insert_ordered(& tsk->ofo_queue, skb);
    if (tsk->sackok) {
      tcp_calculate_sacks(tsk);
    }
    tcp_send_ack(sk);
  }
  return (rc);
}
}
#pragma merger("0","/tmp/cil-JJrhZ50Q.i","-Wall,-pthread")
static struct list_head routes  =    {& routes, & routes};
static struct rtentry *route_alloc(uint32_t dst , uint32_t gateway , uint32_t netmask ,
                                   uint8_t flags , uint32_t metric , struct netdev *dev___0 )
{
  struct rtentry *rt ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct rtentry ));
  rt = (struct rtentry *)tmp;
  list_init(& rt->list);
  rt->dst = dst;
  rt->gateway = gateway;
  rt->netmask = netmask;
  rt->flags = flags;
  rt->metric = metric;
  rt->dev = dev___0;
  return (rt);
}
}
void route_add(uint32_t dst , uint32_t gateway , uint32_t netmask , uint8_t flags ,
               uint32_t metric , struct netdev *dev___0 )
{
  struct rtentry *rt ;
  struct rtentry *tmp ;

  {
  tmp = route_alloc(dst, gateway, netmask, flags, metric, dev___0);
  rt = tmp;
  list_add_tail(& rt->list, & routes);
  return;
}
}
void route_init(void)
{
  uint32_t tmp ;

  {
  route_add(loop->addr, (uint32_t )0, 4278190080U, (uint8_t )1, (uint32_t )0, loop);
  route_add(netdev->addr, (uint32_t )0, 4294967040U, (uint8_t )4, (uint32_t )0, netdev);
  tmp = ip_parse(tapaddr);
  route_add((uint32_t )0, tmp, (uint32_t )0, (uint8_t )2, (uint32_t )0, netdev);
  return;
}
}
struct rtentry *route_lookup(uint32_t daddr )
{
  struct list_head *item ;
  struct rtentry *rt ;

  {
  rt = (struct rtentry *)((void *)0);
  item = routes.next;
  while ((unsigned long )item != (unsigned long )(& routes)) {
    rt = (struct rtentry *)((char *)item - (unsigned long )(& ((struct rtentry *)0)->list));
    if ((daddr & rt->netmask) == (rt->dst & rt->netmask)) {
      break;
    }
    item = item->next;
  }
  return (rt);
}
}
void free_routes(void)
{
  struct list_head *item ;
  struct list_head *tmp ;
  struct rtentry *rt ;

  {
  item = routes.next;
  tmp = item->next;
  while ((unsigned long )item != (unsigned long )(& routes)) {
    rt = (struct rtentry *)((char *)item - (unsigned long )(& ((struct rtentry *)0)->list));
    list_del(item);
    free((void *)rt);
    item = tmp;
    tmp = item->next;
  }
  return;
}
}
