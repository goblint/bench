/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef signed char __int8_t;
typedef short __int16_t;
typedef int __int32_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned int __socklen_t;
typedef unsigned long size_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef __pid_t pid_t;
typedef __ssize_t ssize_t;
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef unsigned long pthread_t;
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
typedef __builtin_va_list __gnuc_va_list;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
typedef long long L;
typedef void *V;
typedef long long I;
typedef double F;
typedef char C;
typedef C *S;
typedef C const   *cS;
struct k0 {
   I _c ;
   I t ;
   I n ;
   struct k0 *k[1] ;
};
typedef struct k0 *K;
struct m1 {
   char a ;
   char b ;
   char c[sizeof(I ) - 3UL] ;
   char d ;
   I n ;
};
typedef struct m1 M1;
typedef unsigned int __uint32_t;
typedef unsigned long __uint64_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef long __clock_t;
typedef __clock_t clock_t;
typedef unsigned long long UI;
typedef unsigned char UC;
struct pda {
   I i ;
   I s ;
   I n ;
   S c ;
};
typedef struct pda Pda;
typedef Pda *PDA;
struct af {
   V verb_over ;
   V verb_scan ;
   V verb_eachpair ;
};
typedef struct af AF;
struct tr {
   I adverbClass ;
   I arity ;
   V func ;
   S text ;
   AF alt_funcs ;
};
typedef struct tr TR;
typedef unsigned short __uint16_t;
typedef long __suseconds_t;
typedef __uint16_t uint16_t;
typedef __time_t time_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
typedef __gnuc_va_list va_list___0;
struct node {
   V k ;
   I b ;
   struct node *c[2] ;
};
typedef struct node Node;
typedef Node *N;
typedef unsigned int __useconds_t;
typedef int __sig_atomic_t;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
struct sockaddr_storage {
   sa_family_t ss_family ;
   char __ss_padding[(128UL - sizeof(unsigned short )) - sizeof(unsigned long )] ;
   unsigned long __ss_align ;
};
struct m0 {
   M1 m1 ;
   I r ;
   K k ;
   I a ;
};
typedef struct m0 M0;
typedef __sig_atomic_t sig_atomic_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval __sigval_t;
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
union __anonunion__bounds_548943257 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
struct __anonstruct__sigfault_738185185 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_548943257 _bounds ;
};
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
struct __anonstruct__sigsys_44812255 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_515865865 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_738185185 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_44812255 _sigsys ;
};
struct __anonstruct_siginfo_t_306704184 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_515865865 _sifields ;
};
typedef struct __anonstruct_siginfo_t_306704184 siginfo_t;
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
typedef unsigned long long uI;
union __anonunion_x_721633472 {
   I i ;
   F f ;
};
typedef unsigned long __ino64_t;
typedef long __blkcnt64_t;
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
typedef unsigned char __uint8_t;
typedef __uint8_t uint8_t;
union __anonunion___in6_u_979734923 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion___in6_u_979734923 __in6_u ;
};
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
union __anonunion_u_554368621 {
   F f ;
   I i ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-A79aT9rD.i","-g,-pthread,-O3")
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg ) 
{ 


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2))) dlsym)(void * __restrict  __handle ,
                                                                                    char const   * __restrict  __name ) ;
extern  __attribute__((__nothrow__)) char *dlerror(void) ;
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
extern int msync(void *__addr , size_t __len , int __flags ) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern void perror(char const   *__s ) ;
extern FILE *popen(char const   *__command , char const   *__modes ) ;
extern int pclose(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
extern  __attribute__((__nothrow__)) double ceil(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strsep)(char ** __restrict  __stringp ,
                                                                                       char const   * __restrict  __delim ) ;
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) execvp)(char const   *__file ,
                                                                                     char * const  *__argv ) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
S strdupn(S s , I k ) ;
I getdelim_(S *s , I *n , I d___0 , FILE *f ) ;
I getline_(S *s , I *n , FILE *f ) ;
extern __pid_t wait(int *__stat_loc ) ;
K _6d(K a , K b___1 ) ;
K _6m(K x___0 ) ;
K _5d(K x___0 , K y ) ;
void printAtDepth(V u , K a , I d___0 , I x___0 , I vdep , I b___1 ) ;
K _5m(K x___0 ) ;
K _4m(K x___0 ) ;
K _4d(K x___0 , K y ) ;
extern K kap(K *a , V v ) ;
K popen_charvec(C *cmd ) ;
K _3d(K x___0 , K y ) ;
K _bd(K x___0 ) ;
I ksender(I sockfd , K y , I t ) ;
K Ki(I x___0 ) ;
I wipe_tape(I i ) ;
K _3m(K x___0 ) ;
extern K kerr(cS s ) ;
K _2d(K a , K b___1 ) ;
K _2m(K a ) ;
S spn(S s , I n ) ;
K Kv(void) ;
K rrep(V v , V aft , I *b___1 , I y , I x___0 ) ;
I fbr ;
I fll ;
I sva(V p ) ;
I rep(K x___0 , I y ) ;
I wrep(K x___0 , V v , I y ) ;
K _1d(K x___0 , K y ) ;
I bp(I t ) ;
K _2m_r(V v , V aft , I *b___1 ) ;
S glueSS(S c , S d___0 ) ;
K _1m(K x___0 ) ;
S sp(S k ) ;
K formKfCS(S s ) ;
K formKiCS(S s ) ;
I charpos(S s , C c ) ;
I stringHasChar(S s , C c ) ;
K _n(void) ;
K _0d(K a , K b___1 ) ;
K cd(K x___0 ) ;
K newK(I t , I n ) ;
I stat_sz(S u , I *n ) ;
S CSK(K x___0 ) ;
K _0m(K a ) ;
I bswapI(I n ) ;
V membswpI(V d___0 , V s , I n , I x___0 ) ;
V membswpF(V d___0 , V s , I n , I x___0 ) ;
K read_tape(I i , I j , I type ) ;
F mMap ;
F mUsed ;
F mMax ;
I PG ;
I fer ;
K show(K a ) ;
V offsetColon ;
K Ks(S x___0 ) ;
I OOM_CD(I g  , ...) ;
K mrc(K x___0 , I c ) ;
static K _0d_write(K a , K b___1 ) ;
static K _0d_read(K a , K b___1 ) ;
static K _0d_rdDsv(K a , K b___1 ) ;
static K _0d_rdDsvWc(K a , K b___1 ) ;
static K _1m_r(I f , V fixed , V v , V aft , I *b___1 ) ;
static K _1d_char(K x___0 , K y ) ;
static K _1d_read(K a , K b___1 ) ;
static K _1d_write(K x___0 , K y , I dosync ) ;
static I disk(K x___0 ) ;
static I rrep_4(S *z , S a , S t ) ;
static K readVector(K x___0 , I t ) ;
static I sendall(I s , S b___1 , I k ) ;
static K _5d_(K x___0 , K y , I dosync ) ;
static V freopen_stdin(void) 
{ 
  FILE *tmp ;

  {
  tmp = freopen((char const   * __restrict  )0, (char const   * __restrict  )"r",
                (FILE * __restrict  )stdin);
  return ((V )tmp);
}
}
K _0m(K a ) 
{ 
  I t ;
  K tmp ;
  I tmp___0 ;
  I b___1 ;
  I s ;
  S v ;
  K z ;
  S m ;
  I tmp___1 ;
  struct stat sb ;
  I ff ;
  K tmp___2 ;
  int tmp___3 ;
  I tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  I fn ;
  I i ;
  I j ;
  C buf___1[256] ;
  int tmp___7 ;
  K y ;
  I n ;
  size_t tmp___8 ;
  int tmp___9 ;
  ssize_t tmp___10 ;
  char ss[300] ;
  S adr ;
  char *tmp___11 ;
  K tmp___12 ;
  I i___0 ;
  I j___0 ;
  I k ;
  I tmp___13 ;
  K tmp___14 ;
  V tmp___15 ;
  I f ;
  S tmp___16 ;
  int tmp___17 ;
  K tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  K tmp___21 ;
  S tmp___22 ;
  I tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  K tmp___26 ;
  void *tmp___27 ;
  I r ;
  int tmp___28 ;
  K tmp___29 ;
  I tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  I c ;
  int tmp___35 ;
  I d___0 ;
  I e ;
  I i___1 ;
  I _i___0 ;
  K k___0 ;
  I i___2 ;
  I _i___1 ;
  I i___3 ;
  I _i___2 ;
  I i___4 ;
  I _i___3 ;
  I r___0 ;
  int tmp___36 ;
  K tmp___37 ;

  {
  t = a->t;
  if (4LL != t) {
    if (t < 0LL) {
      tmp___0 = - t;
    } else {
      tmp___0 = t;
    }
    if (3LL != tmp___0) {
      tmp = kerr("type");
      return (tmp);
    }
  }
  b___1 = (I )0;
  s = (I )0;
  v = (S )0;
  z = (K )0;
  fll = (I )0;
  fbr = fll;
  if (t < 0LL) {
    tmp___1 = - t;
  } else {
    tmp___1 = t;
  }
  if (3LL == tmp___1) {
    m = CSK(a);
  }
  ff = (I )0;
  if (t < 0LL) {
    tmp___4 = - t;
  } else {
    tmp___4 = t;
  }
  if (3LL == tmp___4) {
    tmp___5 = strcmp((char const   *)m, "/dev/fd/0");
    if (tmp___5) {
      tmp___6 = strcmp((char const   *)m, "/dev/stdin");
      if (tmp___6) {
        tmp___3 = stat((char const   * __restrict  )m, (struct stat * __restrict  )(& sb));
        if (tmp___3 == -1) {
          tmp___2 = kerr("file");
          return (tmp___2);
        }
        if ((sb.st_mode & 61440U) == 4096U) {
          ff = (I )1;
        }
      }
    }
  }
  if (ff) {
    z = newK((I )0, (I )0);
    tmp___7 = open((char const   *)m, 0);
    fn = (I )tmp___7;
    while (1) {
      tmp___10 = read((int )fn, (void *)(& buf___1), (size_t )256);
      if (! (tmp___10 > 0L)) {
        break;
      }
      j = (I )256;
      y = (K )0;
      i = (I )0;
      while (i < 256LL) {
        if (i > j) {
          buf___1[j] = (C )'\000';
          break;
        }
        if ((int )buf___1[i] == 10) {
          j = i;
        }
        i ++;
      }
      tmp___8 = strlen((char const   *)(buf___1));
      n = (I )tmp___8;
      if (n < 2LL) {
        tmp___9 = 3;
      } else {
        tmp___9 = -3;
      }
      y = newK((I )tmp___9, n);
      memcpy((void * __restrict  )((C *)(y->k)), (void const   * __restrict  )(& buf___1),
             (size_t )n);
      kap(& z, (V )(& y));
      cd(y);
    }
    goto cleanup;
  } else
  if (4LL == t) {
    if (! *(*((S *)(a->k)))) {
      tmp___11 = fgets((char * __restrict  )(ss), (int )sizeof(ss), (FILE * __restrict  )stdin);
      adr = tmp___11;
      if ((unsigned long )adr == (unsigned long )((void *)0)) {
        tmp___12 = newK((I )6, (I )1);
        return (tmp___12);
      }
      i___0 = (I )0;
      while (i___0 < 300LL) {
        if ((int )ss[i___0] == 10) {
          break;
        }
        i___0 ++;
      }
      k = (I )0;
      j___0 = (I )0;
      while (j___0 <= i___0) {
        if ((int )ss[j___0] != 4) {
          tmp___13 = k;
          k ++;
          ss[tmp___13] = ss[j___0];
        }
        j___0 ++;
      }
      z = newK((I )-3, k - 1LL);
      j___0 = (I )0;
      while (j___0 < k - 1LL) {
        *((C *)(z->k) + j___0) = ss[j___0];
        j___0 ++;
      }
      goto cleanup;
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    if (t < 0LL) {
      tmp___30 = - t;
    } else {
      tmp___30 = t;
    }
    if (3LL == tmp___30) {
      tmp___31 = strcmp((char const   *)m, "/dev/fd/0");
      if (tmp___31) {
        tmp___32 = strcmp((char const   *)m, "/dev/stdin");
        if (tmp___32) {
          goto _L___2;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else
    _L___2: /* CIL Label */ 
    if (4LL == t) {
      tmp___33 = strcmp((char const   *)*((S *)(a->k)), "/dev/fd/0");
      if (tmp___33) {
        tmp___34 = strcmp((char const   *)*((S *)(a->k)), "/dev/stdin");
        if (tmp___34) {
          goto _L___0;
        } else {
          _L___1: /* CIL Label */ 
          b___1 = getdelim_(& v, & s, (I )-1, stdin);
          tmp___15 = freopen_stdin();
          if ((unsigned long )tmp___15 == (unsigned long )((void *)0)) {
            tmp___14 = kerr("file");
            return (tmp___14);
          }
          if (b___1 == -1LL) {
            z = newK((I )0, (I )0);
            goto cleanup;
          }
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___0: /* CIL Label */ 
      tmp___16 = CSK(a);
      tmp___17 = open((char const   *)tmp___16, 0);
      f = (I )tmp___17;
      if (f < 0LL) {
        tmp___18 = kerr("domain");
        return (tmp___18);
      }
      tmp___22 = CSK(a);
      tmp___23 = stat_sz(tmp___22, & s);
      if (tmp___23) {
        tmp___19 = __errno_location();
        tmp___20 = strerror(*tmp___19);
        tmp___21 = kerr((cS )tmp___20);
        return (tmp___21);
      }
      tmp___27 = mmap((void *)0, (size_t )s, 1, 1, (int )f, (__off_t )0);
      v = (S )tmp___27;
      if ((unsigned long )((void *)-1) == (unsigned long )v) {
        tmp___24 = __errno_location();
        tmp___25 = strerror(*tmp___24);
        tmp___26 = kerr((cS )tmp___25);
        return (tmp___26);
      }
      tmp___28 = close((int )f);
      r = (I )tmp___28;
      if (r) {
        tmp___29 = kerr("file");
        return (tmp___29);
      }
    }
  }
  if (s) {
    tmp___35 = 1;
  } else {
    tmp___35 = 0;
  }
  c = (I )tmp___35;
  d___0 = (I )0;
  i___1 = (I )0;
  _i___0 = s;
  while (i___1 < _i___0) {
    if (10 == (int )*(v + i___1)) {
      if (i___1 < s - 1LL) {
        c ++;
      }
    }
    i___1 ++;
  }
  z = newK((I )0, c);
  if (! z) {
    goto cleanup;
  }
  i___2 = (I )0;
  _i___1 = s;
  while (i___2 < _i___1) {
    if (10 != (int )*(v + i___2)) {
      z->k[d___0] = (struct k0 *)((V )1 + (L )z->k[d___0]);
    } else {
      d___0 ++;
    }
    i___2 ++;
  }
  i___3 = (I )0;
  _i___2 = c;
  while (i___3 < _i___2) {
    e = (L )z->k[i___3];
    k___0 = newK((I )-3, e);
    if (! k___0) {
      cd(z);
      z = (K )0;
      goto cleanup;
    }
    z->k[i___3] = k___0;
    i___3 ++;
  }
  e = (I )0;
  i___4 = (I )0;
  _i___3 = c;
  while (i___4 < _i___3) {
    k___0 = z->k[i___4];
    memcpy((void * __restrict  )((C *)(k___0->k)), (void const   * __restrict  )(v + e),
           (size_t )k___0->n);
    e += 1LL + k___0->n;
    i___4 ++;
  }
  cleanup: 
  if (v) {
    if (b___1) {
      free((void *)v);
    } else {
      tmp___36 = munmap((void *)v, (size_t )s);
      r___0 = (I )tmp___36;
      if (r___0) {
        tmp___37 = kerr("munmap");
        return (tmp___37);
      }
    }
  }
  return (z);
}
}
K _0d(K a , K b___1 ) 
{ 
  I t ;
  K tmp ;
  I tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;

  {
  t = a->t;
  if (4LL == t) {
    tmp = _0d_write(a, b___1);
    return (tmp);
  } else {
    if (t < 0LL) {
      tmp___0 = - t;
    } else {
      tmp___0 = t;
    }
    if (3LL == tmp___0) {
      tmp = _0d_write(a, b___1);
      return (tmp);
    }
  }
  if (! t) {
    tmp___1 = _0d_read(a, b___1);
    return (tmp___1);
  }
  tmp___2 = kerr("type");
  return (tmp___2);
}
}
static I ok_0dw(K b___1 ) 
{ 
  I t ;
  I n ;
  K k ;
  I i ;
  I _i___0 ;
  I tmp ;
  I tmp___0 ;

  {
  t = b___1->t;
  n = b___1->n;
  if (t < 0LL) {
    tmp___0 = - t;
  } else {
    tmp___0 = t;
  }
  if (3LL != tmp___0) {
    if (! t) {
      i = (I )0;
      _i___0 = n;
      while (i < _i___0) {
        k = b___1->k[i];
        if (k->t < 0LL) {
          tmp = - k->t;
        } else {
          tmp = k->t;
        }
        if (3LL != tmp) {
          if (t) {
            return ((I )0);
          } else
          if (k->n) {
            return ((I )0);
          }
        }
        i ++;
      }
    } else {
      return ((I )0);
    }
  }
  return ((I )1);
}
}
static K _0d_write(K a , K b___1 ) 
{ 
  I t ;
  I n ;
  K k ;
  K tmp ;
  I tmp___0 ;
  S m ;
  S tmp___1 ;
  I s ;
  I f ;
  struct stat sb ;
  int tmp___2 ;
  K tmp___3 ;
  S msg ;
  K tmp___4 ;
  size_t tmp___5 ;
  ssize_t tmp___6 ;
  S msg___0 ;
  I i ;
  I _i___0 ;
  K tmp___7 ;
  I tmp___8 ;
  K tmp___9 ;
  size_t tmp___10 ;
  ssize_t tmp___11 ;
  I r ;
  int tmp___12 ;
  K tmp___13 ;
  K tmp___14 ;
  I tmp___15 ;
  I r___0 ;
  int tmp___16 ;
  K tmp___17 ;
  K tmp___18 ;
  int tmp___19 ;
  I i___0 ;
  I _i___1 ;
  I tmp___20 ;
  I r___1 ;
  K tmp___21 ;
  ssize_t tmp___22 ;
  I i___1 ;
  I _i___2 ;
  ssize_t tmp___23 ;
  I tmp___24 ;
  ssize_t tmp___25 ;
  K tmp___26 ;
  I tmp___27 ;
  int tmp___28 ;
  K tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  K tmp___32 ;
  int tmp___33 ;
  S v ;
  int *tmp___34 ;
  char *tmp___35 ;
  K tmp___36 ;
  void *tmp___37 ;
  I r___2 ;
  int tmp___38 ;
  K tmp___39 ;
  I c ;
  I i___2 ;
  I _i___3 ;
  I tmp___40 ;
  I tmp___41 ;
  I tmp___42 ;
  int tmp___43 ;
  K tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  K tmp___47 ;

  {
  t = b___1->t;
  n = b___1->n;
  tmp___0 = ok_0dw(b___1);
  if (! tmp___0) {
    tmp = kerr("type");
    return (tmp);
  }
  tmp___1 = CSK(a);
  m = tmp___1;
  s = (I )0;
  f = (I )0;
  tmp___19 = stat((char const   * __restrict  )m, (struct stat * __restrict  )(& sb));
  if (tmp___19 != -1) {
    if ((sb.st_mode & 61440U) == 4096U) {
      tmp___2 = open((char const   *)m, 1);
      f = (I )tmp___2;
      if (f < 0LL) {
        tmp___3 = kerr("domain");
        return (tmp___3);
      }
      if (t < 0LL) {
        tmp___15 = - t;
      } else {
        tmp___15 = t;
      }
      if (3LL == tmp___15) {
        msg = (C *)(b___1->k);
        tmp___5 = strlen((char const   *)msg);
        tmp___6 = write((int )f, (void const   *)msg, tmp___5 + 1UL);
        if (tmp___6 == -1L) {
          tmp___4 = kerr("write");
          return (tmp___4);
        }
      } else
      if (0LL == t) {
        i = (I )0;
        _i___0 = n;
        while (i < _i___0) {
          if ((b___1->k[i])->t < 0LL) {
            tmp___8 = - (b___1->k[i])->t;
          } else {
            tmp___8 = (b___1->k[i])->t;
          }
          if (tmp___8 != 3LL) {
            tmp___7 = kerr("domain");
            return (tmp___7);
          }
          msg___0 = (C *)((b___1->k[i])->k);
          tmp___10 = strlen((char const   *)msg___0);
          tmp___11 = write((int )f, (void const   *)msg___0, tmp___10 + 1UL);
          if (tmp___11 == -1L) {
            tmp___9 = kerr("write");
            return (tmp___9);
          }
          i ++;
        }
      } else {
        tmp___12 = close((int )f);
        r = (I )tmp___12;
        if (r) {
          tmp___13 = kerr("file");
          return (tmp___13);
        }
        tmp___14 = kerr("domain");
        return (tmp___14);
      }
      tmp___16 = close((int )f);
      r___0 = (I )tmp___16;
      if (r___0) {
        tmp___17 = kerr("file");
        return (tmp___17);
      }
      tmp___18 = _n();
      return (tmp___18);
    }
  }
  if (t < 0LL) {
    tmp___20 = - t;
  } else {
    tmp___20 = t;
  }
  if (3LL == tmp___20) {
    s = n;
  } else {
    i___0 = (I )0;
    _i___1 = n;
    while (i___0 < _i___1) {
      s += 1LL + (b___1->k[i___0])->n;
      i___0 ++;
    }
  }
  if (! *(m + 0)) {
    goto _L;
  } else {
    tmp___45 = strcmp((char const   *)m, "/dev/fd/1");
    if (tmp___45) {
      tmp___46 = strcmp((char const   *)m, "/dev/stdout");
      if (tmp___46) {
        if (*(m + 0)) {
          tmp___28 = open((char const   *)m, 578, 436);
          f = (I )tmp___28;
        }
        if (f < 0LL) {
          tmp___29 = kerr("domain");
          return (tmp___29);
        }
        tmp___33 = ftruncate((int )f, (__off_t )s);
        if (tmp___33) {
          tmp___30 = __errno_location();
          tmp___31 = strerror(*tmp___30);
          tmp___32 = kerr((cS )tmp___31);
          return (tmp___32);
        }
        tmp___37 = mmap((void *)0, (size_t )s, 2, 1, (int )f, (__off_t )0);
        v = (S )tmp___37;
        if ((unsigned long )((void *)-1) == (unsigned long )v) {
          tmp___34 = __errno_location();
          tmp___35 = strerror(*tmp___34);
          tmp___36 = kerr((cS )tmp___35);
          return (tmp___36);
        }
        tmp___38 = close((int )f);
        r___2 = (I )tmp___38;
        if (r___2) {
          tmp___39 = kerr("file");
          return (tmp___39);
        }
        c = (I )0;
        if (t < 0LL) {
          tmp___42 = - t;
        } else {
          tmp___42 = t;
        }
        if (3LL == tmp___42) {
          memcpy((void * __restrict  )v, (void const   * __restrict  )((C *)(b___1->k)),
                 (size_t )s);
        } else {
          i___2 = (I )0;
          _i___3 = n;
          while (i___2 < _i___3) {
            k = b___1->k[i___2];
            if (k->t < 0LL) {
              tmp___40 = - k->t;
            } else {
              tmp___40 = k->t;
            }
            if (3LL == tmp___40) {
              memcpy((void * __restrict  )(v + c), (void const   * __restrict  )((C *)(k->k)),
                     (size_t )k->n);
              c += k->n;
            }
            tmp___41 = c;
            c ++;
            *(v + tmp___41) = (C )'\n';
            i___2 ++;
          }
        }
        tmp___43 = munmap((void *)v, (size_t )s);
        r___2 = (I )tmp___43;
        if (r___2) {
          tmp___44 = kerr("munmap");
          return (tmp___44);
        }
      } else {
        _L: /* CIL Label */ 
        f = (I )1;
        if (t < 0LL) {
          tmp___27 = - t;
        } else {
          tmp___27 = t;
        }
        if (3LL == tmp___27) {
          tmp___22 = write((int )f, (void const   *)((C *)(b___1->k)), (size_t )s);
          if (tmp___22 == -1L) {
            tmp___21 = kerr("write");
            show(tmp___21);
          }
        } else {
          i___1 = (I )0;
          _i___2 = n;
          while (i___1 < _i___2) {
            k = b___1->k[i___1];
            if (k->t < 0LL) {
              tmp___24 = - k->t;
            } else {
              tmp___24 = k->t;
            }
            if (3LL == tmp___24) {
              tmp___23 = write((int )f, (void const   *)((C *)(k->k)), (size_t )k->n);
              r___1 = (I )tmp___23;
            }
            tmp___25 = write((int )f, (void const   *)"\n", (size_t )1);
            r___1 = (I )tmp___25;
            if (r___1 == -1LL) {
              tmp___26 = kerr("write");
              show(tmp___26);
            }
            i___1 ++;
          }
        }
      }
    } else {
      goto _L;
    }
  }
  tmp___47 = _n();
  return (tmp___47);
}
}
static K _0d_read(K a , K b___1 ) 
{ 
  K z ;
  I res ;
  I an ;
  I bt ;
  I bn ;
  K tmp ;
  K c ;
  K d___0 ;
  I cn ;
  I dn ;
  K tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  K tmp___5 ;
  K tmp___6 ;
  I tmp___7 ;
  I fc ;
  I i ;
  I _i___0 ;
  K tmp___8 ;
  I tmp___9 ;
  I w___0 ;
  I x___0 ;
  I i___0 ;
  I _i___1 ;
  K tmp___10 ;
  K ff ;
  K k ;
  I fb ;
  I fn ;
  K tmp___11 ;
  K tmp___12 ;
  I tmp___13 ;
  K tmp___14 ;
  K tmp___15 ;
  I s ;
  int *tmp___16 ;
  char *tmp___17 ;
  K tmp___18 ;
  S tmp___19 ;
  I tmp___20 ;
  I tmp___22 ;
  I tmp___23 ;
  I f ;
  S tmp___24 ;
  int tmp___25 ;
  K tmp___26 ;
  S v ;
  int *tmp___27 ;
  char *tmp___28 ;
  K tmp___29 ;
  void *tmp___30 ;
  I r ;
  int tmp___31 ;
  K tmp___32 ;
  I t ;
  I i___1 ;
  I _i___2 ;
  I e ;
  C g ;
  I i___2 ;
  I _i___3 ;
  I tmp___33 ;
  struct k0 *tmp___34 ;
  I tmp___35 ;
  S m ;
  I u ;
  I y ;
  I p ;
  K q ;
  I i___3 ;
  I _i___4 ;
  I tmp___36 ;
  int tmp___37 ;
  K tmp___38 ;

  {
  z = (K )0;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (an != 2LL) {
    tmp = kerr("domain");
    return (tmp);
  }
  c = a->k[0];
  d___0 = a->k[1];
  cn = c->n;
  dn = d___0->n;
  if (3LL == d___0->t) {
    tmp___0 = _0d_rdDsv(a, b___1);
    return (tmp___0);
  }
  if (-3LL == d___0->t) {
    tmp___1 = _0d_rdDsvWc(a, b___1);
    return (tmp___1);
  }
  if (c->t < 0LL) {
    tmp___3 = - c->t;
  } else {
    tmp___3 = c->t;
  }
  if (3LL != tmp___3) {
    tmp___2 = kerr("type");
    return (tmp___2);
  } else {
    if (d___0->t < 0LL) {
      tmp___4 = - d___0->t;
    } else {
      tmp___4 = d___0->t;
    }
    if (1LL != tmp___4) {
      tmp___2 = kerr("type");
      return (tmp___2);
    }
  }
  if (! cn) {
    tmp___5 = kerr("length");
    return (tmp___5);
  } else
  if (cn != dn) {
    tmp___5 = kerr("length");
    return (tmp___5);
  }
  if (bt < 0LL) {
    tmp___7 = - bt;
  } else {
    tmp___7 = bt;
  }
  if (3LL != tmp___7) {
    if (4LL != bt) {
      if (0LL != bt) {
        tmp___6 = kerr("type");
        return (tmp___6);
      }
    }
  }
  fc = (I )0;
  i = (I )0;
  _i___0 = cn;
  while (i < _i___0) {
    if (32 == (int )*((C *)(c->k) + i)) {
      goto __Cont;
    }
    tmp___9 = stringHasChar((S )"IFCS", *((C *)(c->k) + i));
    if (tmp___9) {
      fc ++;
    } else {
      tmp___8 = kerr("type");
      return (tmp___8);
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  w___0 = (I )1;
  i___0 = (I )0;
  _i___1 = dn;
  while (i___0 < _i___1) {
    x___0 = *((I *)(d___0->k) + i___0);
    if (x___0 <= 0LL) {
      tmp___10 = kerr("length");
      return (tmp___10);
    }
    w___0 += x___0;
    i___0 ++;
  }
  ff = b___1;
  fb = (I )0;
  fn = (I )0;
  if (! bt) {
    if (3LL != bn) {
      tmp___11 = kerr("length");
      return (tmp___11);
    }
    ff = b___1->k[0];
    if (ff->t < 0LL) {
      tmp___13 = - ff->t;
    } else {
      tmp___13 = ff->t;
    }
    if (3LL != tmp___13) {
      if (4LL != ff->t) {
        tmp___12 = kerr("type");
        return (tmp___12);
      }
    }
    k = b___1->k[1];
    if (1LL != k->t) {
      if (2LL != k->t) {
        tmp___14 = kerr("type");
        return (tmp___14);
      }
    }
    if (k->t - 1LL) {
      fb = (I )*((F *)(k->k));
    } else {
      fb = *((I *)(k->k));
    }
    k = b___1->k[2];
    if (1LL != k->t) {
      if (2LL != k->t) {
        tmp___15 = kerr("type");
        return (tmp___15);
      }
    }
    if (k->t - 1LL) {
      fn = (I )*((F *)(k->k));
    } else {
      fn = *((I *)(k->k));
    }
  }
  tmp___19 = CSK(ff);
  tmp___20 = stat_sz(tmp___19, & s);
  if (tmp___20) {
    tmp___16 = __errno_location();
    tmp___17 = strerror(*tmp___16);
    tmp___18 = kerr((cS )tmp___17);
    return (tmp___18);
  }
  if (bt) {
    fn = s;
  }
  if (fn < 0LL) {
    fn = (I )0;
  }
  if (fb < 0LL) {
    fb = (I )0;
  }
  if (0LL > s - 1LL) {
    tmp___23 = (I )0;
  } else {
    tmp___23 = s - 1LL;
  }
  if (fb < tmp___23) {
    fb = fb;
  } else {
    if (0LL > s - 1LL) {
      tmp___22 = (I )0;
    } else {
      tmp___22 = s - 1LL;
    }
    fb = tmp___22;
  }
  if (fb + fn > s) {
    fn = s - fb;
  }
  tmp___24 = CSK(ff);
  tmp___25 = open((char const   *)tmp___24, 0);
  f = (I )tmp___25;
  if (f < 0LL) {
    tmp___26 = kerr("domain");
    return (tmp___26);
  }
  tmp___30 = mmap((void *)0, (size_t )fn, 1, 1, (int )f, (__off_t )fb);
  v = (S )tmp___30;
  if ((unsigned long )((void *)-1) == (unsigned long )v) {
    tmp___27 = __errno_location();
    tmp___28 = strerror(*tmp___27);
    tmp___29 = kerr((cS )tmp___28);
    return (tmp___29);
  }
  tmp___31 = close((int )f);
  r = (I )tmp___31;
  if (r) {
    tmp___32 = kerr("file");
    return (tmp___32);
  }
  r = (I )0;
  t = (I )0;
  i___1 = (I )0;
  _i___2 = fn;
  while (i___1 < _i___2) {
    if ((int )*(v + (fb + i___1)) == 10) {
      if (t == w___0 - 1LL) {
        r ++;
        t = (I )0;
      } else {
        t = (I )0;
      }
    } else {
      t ++;
    }
    i___1 ++;
  }
  z = newK((I )0, fc);
  if (! z) {
    goto cleanup;
  }
  e = (I )0;
  i___2 = (I )0;
  _i___3 = cn;
  while (i___2 < _i___3) {
    g = *((C *)(c->k) + i___2);
    if (32 == (int )g) {
      goto __Cont___0;
    }
    tmp___33 = e;
    e ++;
    tmp___35 = charpos((S )"CIF S", g);
    tmp___34 = newK(- tmp___35, r);
    z->k[tmp___33] = tmp___34;
    if (! tmp___34) {
      cd(z);
      z = (K )0;
      goto cleanup;
    }
    __Cont___0: /* CIL Label */ 
    i___2 ++;
  }
  u = (I )0;
  p = (I )0;
  while (u <= fn - w___0) {
    while (1) {
      if (u + t < fn) {
        if (! (10 != (int )*(v + (u + t)))) {
          break;
        }
      } else {
        break;
      }
      t ++;
    }
    if (t == w___0 - 1LL) {
      if (10 == (int )*(v + (u + t))) {
        y = u;
        x___0 = (I )0;
        e = x___0;
        q = (K )0;
        i___3 = (I )0;
        _i___4 = cn;
        while (i___3 < _i___4) {
          x___0 = *((I *)(d___0->k) + i___3);
          tmp___36 = e;
          e ++;
          k = z->k[tmp___36];
          switch ((int )*((C *)(c->k) + i___3)) {
          case 32: 
          e --;
          break;
          case 73: 
          m = strdupn(v + y, x___0);
          if (! m) {
            return ((K )0);
          }
          q = formKiCS(m);
          if (q) {
            *((I *)(k->k) + p) = *((I *)(q->k));
          } else {
            *((I *)(k->k) + p) = (-0x7FFFFFFFFFFFFFFF-1);
          }
          free((void *)m);
          break;
          case 70: 
          m = strdupn(v + y, x___0);
          if (! m) {
            return ((K )0);
          }
          q = formKfCS(m);
          if (q) {
            *((F *)(k->k) + p) = *((F *)(q->k));
          } else {
            *((F *)(k->k) + p) = (double )0 / 0.;
          }
          free((void *)m);
          break;
          case 67: 
          q = newK((I )-3, x___0);
          if (! q) {
            return ((K )0);
          }
          memcpy((void * __restrict  )((C *)(q->k)), (void const   * __restrict  )(v + y),
                 (size_t )x___0);
          k->k[p] = q;
          q = (K )0;
          break;
          case 83: 
          m = strdupn(v + y, x___0);
          if (! m) {
            return ((K )0);
          }
          *((S *)(k->k) + p) = sp(m);
          free((void *)m);
          break;
          }
          y += x___0;
          i___3 ++;
        }
        p ++;
      }
    }
    u += t + 1LL;
    t = (I )0;
  }
  cleanup: 
  tmp___37 = munmap((void *)v, (size_t )s);
  res = (I )tmp___37;
  if (res) {
    tmp___38 = kerr("munmap");
    return (tmp___38);
  }
  return (z);
}
}
static K _0d_rdDsv(K a , K b___1 ) 
{ 
  K z ;
  I res ;
  I an ;
  I bt ;
  K tmp ;
  K c ;
  K d___0 ;
  I cn ;
  K tmp___0 ;
  I tmp___1 ;
  C *x___0 ;
  C w___0 ;
  I fb ;
  I fn ;
  I s ;
  int *tmp___2 ;
  char *tmp___3 ;
  K tmp___4 ;
  S tmp___5 ;
  I tmp___6 ;
  I f ;
  S tmp___7 ;
  int tmp___8 ;
  K tmp___9 ;
  S v ;
  int *tmp___10 ;
  char *tmp___11 ;
  K tmp___12 ;
  void *tmp___13 ;
  I r ;
  int tmp___14 ;
  K tmp___15 ;
  I fc ;
  I i ;
  I _i___0 ;
  K tmp___16 ;
  I tmp___17 ;
  I i___0 ;
  I _i___1 ;
  I e ;
  C g ;
  I i___1 ;
  I _i___2 ;
  I tmp___18 ;
  struct k0 *tmp___19 ;
  I tmp___20 ;
  S m ;
  I u ;
  I t ;
  I p ;
  I n ;
  I h ;
  C *tok ;
  C y[2] ;
  K k ;
  K q ;
  I tmp___21 ;
  I tmp___22 ;
  size_t tmp___23 ;
  I tmp___24 ;
  I tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  K tmp___28 ;

  {
  z = (K )0;
  an = a->n;
  bt = b___1->t;
  if (an != 2LL) {
    tmp = kerr("domain");
    return (tmp);
  }
  c = a->k[0];
  d___0 = a->k[1];
  cn = c->n;
  if (bt < 0LL) {
    tmp___1 = - bt;
  } else {
    tmp___1 = bt;
  }
  if (3LL != tmp___1) {
    if (4LL != bt) {
      if (0LL != bt) {
        tmp___0 = kerr("type");
        return (tmp___0);
      }
    }
  }
  x___0 = (C *)(d___0->k);
  w___0 = *x___0;
  fb = (I )0;
  fn = (I )0;
  tmp___5 = CSK(b___1);
  tmp___6 = stat_sz(tmp___5, & s);
  if (tmp___6) {
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    tmp___4 = kerr((cS )tmp___3);
    return (tmp___4);
  }
  if (bt) {
    fn = s;
  }
  tmp___7 = CSK(b___1);
  tmp___8 = open((char const   *)tmp___7, 0);
  f = (I )tmp___8;
  if (f < 0LL) {
    tmp___9 = kerr("domain");
    return (tmp___9);
  }
  tmp___13 = mmap((void *)0, (size_t )fn, 1, 1, (int )f, (__off_t )fb);
  v = (S )tmp___13;
  if ((unsigned long )((void *)-1) == (unsigned long )v) {
    printf((char const   * __restrict  )"mmap failed\n");
    tmp___10 = __errno_location();
    tmp___11 = strerror(*tmp___10);
    tmp___12 = kerr((cS )tmp___11);
    return (tmp___12);
  }
  tmp___14 = close((int )f);
  r = (I )tmp___14;
  if (r) {
    tmp___15 = kerr("file");
    return (tmp___15);
  }
  fc = (I )0;
  i = (I )0;
  _i___0 = cn;
  while (i < _i___0) {
    if (32 == (int )*((C *)(c->k) + i)) {
      goto __Cont;
    }
    tmp___17 = stringHasChar((S )"IFCS", *((C *)(c->k) + i));
    if (tmp___17) {
      fc ++;
    } else {
      tmp___16 = kerr("type");
      return (tmp___16);
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  r = (I )0;
  i___0 = (I )0;
  _i___1 = fn;
  while (i___0 < _i___1) {
    if ((int )*(v + (fb + i___0)) == 10) {
      r ++;
    }
    i___0 ++;
  }
  if ((int )*(v + (fn - 1LL)) != 10) {
    r ++;
  }
  z = newK((I )0, fc);
  if (! z) {
    goto cleanup;
  }
  e = (I )0;
  i___1 = (I )0;
  _i___2 = cn;
  while (i___1 < _i___2) {
    g = *((C *)(c->k) + i___1);
    if (32 == (int )g) {
      goto __Cont___0;
    }
    tmp___18 = e;
    e ++;
    tmp___20 = charpos((S )"CIF S", g);
    tmp___19 = newK(- tmp___20, r);
    z->k[tmp___18] = tmp___19;
    if (! tmp___19) {
      cd(z);
      z = (K )0;
      goto cleanup;
    }
    __Cont___0: /* CIL Label */ 
    i___1 ++;
  }
  u = (I )0;
  t = (I )0;
  p = (I )0;
  n = (I )0;
  h = (I )0;
  y[0] = w___0;
  while (u <= fn) {
    while (1) {
      if (u + t <= fn) {
        if (10 != (int )*(v + (u + t))) {
          if (! ((L )*(v + (u + t)) != (L )((void *)0))) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      t ++;
    }
    if ((int )*(v + (u + t)) == 10) {
      goto _L;
    } else
    if ((L )*(v + (u + t)) == (L )((void *)0)) {
      _L: /* CIL Label */ 
      q = (K )0;
      h = (I )0;
      e = h;
      m = strdupn(v + u, t);
      if (! m) {
        return ((K )0);
      }
      if ((L )*(m + 0) != (L )((void *)0)) {
        tok = strsep((char ** __restrict  )(& m), (char const   * __restrict  )(y));
        tmp___21 = e;
        e ++;
        k = z->k[tmp___21];
        tmp___22 = h;
        h ++;
        switch ((int )*((C *)(c->k) + tmp___22)) {
        case 32: 
        e --;
        break;
        case 73: 
        q = formKiCS(tok);
        if (q) {
          *((I *)(k->k) + p) = *((I *)(q->k));
        } else {
          *((I *)(k->k) + p) = (-0x7FFFFFFFFFFFFFFF-1);
        }
        break;
        case 70: 
        q = formKfCS(tok);
        if (q) {
          *((F *)(k->k) + p) = *((F *)(q->k));
        } else {
          *((F *)(k->k) + p) = (double )0 / 0.;
        }
        break;
        case 67: 
        tmp___23 = strlen((char const   *)tok);
        n = (I )tmp___23;
        q = newK((I )-3, n);
        if (! q) {
          return ((K )0);
        }
        memcpy((void * __restrict  )((C *)(q->k)), (void const   * __restrict  )tok,
               (size_t )n);
        k->k[p] = q;
        q = (K )0;
        break;
        case 83: 
        *((S *)(k->k) + p) = sp(tok);
        break;
        }
        while ((unsigned long )tok != (unsigned long )((void *)0)) {
          tok = strsep((char ** __restrict  )(& m), (char const   * __restrict  )(y));
          if ((unsigned long )tok != (unsigned long )((void *)0)) {
            tmp___24 = e;
            e ++;
            k = z->k[tmp___24];
            tmp___25 = h;
            h ++;
            switch ((int )*((C *)(c->k) + tmp___25)) {
            case 32: 
            e --;
            break;
            case 73: 
            q = formKiCS(tok);
            if (q) {
              *((I *)(k->k) + p) = *((I *)(q->k));
            } else {
              *((I *)(k->k) + p) = (-0x7FFFFFFFFFFFFFFF-1);
            }
            break;
            case 70: 
            q = formKfCS(tok);
            if (q) {
              *((F *)(k->k) + p) = *((F *)(q->k));
            } else {
              *((F *)(k->k) + p) = (double )0 / 0.;
            }
            break;
            case 67: 
            tmp___26 = strlen((char const   *)tok);
            n = (I )tmp___26;
            q = newK((I )-3, n);
            if (! q) {
              return ((K )0);
            }
            memcpy((void * __restrict  )((C *)(q->k)), (void const   * __restrict  )tok,
                   (size_t )n);
            k->k[p] = q;
            q = (K )0;
            break;
            case 83: 
            *((S *)(k->k) + p) = sp(tok);
            break;
            }
          }
        }
      }
      free((void *)m);
    }
    p ++;
    u += t + 1LL;
    t = (I )0;
  }
  cleanup: 
  tmp___27 = munmap((void *)v, (size_t )s);
  res = (I )tmp___27;
  if (res) {
    tmp___28 = kerr("munmap");
    return (tmp___28);
  }
  return (z);
}
}
static K _0d_rdDsvWc(K a , K b___1 ) 
{ 
  K z ;
  I res ;
  I an ;
  I bt ;
  K tmp ;
  K c ;
  K d___0 ;
  I cn ;
  K tmp___0 ;
  I tmp___1 ;
  C *x___0 ;
  C w___0 ;
  I fb ;
  I fn ;
  I s ;
  int *tmp___2 ;
  char *tmp___3 ;
  K tmp___4 ;
  S tmp___5 ;
  I tmp___6 ;
  I f ;
  S tmp___7 ;
  int tmp___8 ;
  K tmp___9 ;
  S v ;
  int *tmp___10 ;
  char *tmp___11 ;
  K tmp___12 ;
  void *tmp___13 ;
  I r ;
  int tmp___14 ;
  K tmp___15 ;
  I fc ;
  I i ;
  I _i___0 ;
  K tmp___16 ;
  I tmp___17 ;
  I i___0 ;
  I _i___1 ;
  I e ;
  C g ;
  I i___1 ;
  I _i___2 ;
  I tmp___18 ;
  struct k0 *tmp___19 ;
  I tmp___20 ;
  S m ;
  I u ;
  I t ;
  I p ;
  I n ;
  I h ;
  C *tok ;
  C y[2] ;
  K k ;
  I tmp___21 ;
  I tmp___22 ;
  I tmp___23 ;
  I tmp___24 ;
  I tmp___25 ;
  I tmp___26 ;
  I tmp___27 ;
  K q ;
  I tmp___28 ;
  I tmp___29 ;
  size_t tmp___30 ;
  I tmp___31 ;
  I tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  K tmp___35 ;

  {
  z = (K )0;
  an = a->n;
  bt = b___1->t;
  if (an != 2LL) {
    tmp = kerr("domain");
    return (tmp);
  }
  c = a->k[0];
  d___0 = a->k[1];
  cn = c->n;
  if (bt < 0LL) {
    tmp___1 = - bt;
  } else {
    tmp___1 = bt;
  }
  if (3LL != tmp___1) {
    if (4LL != bt) {
      if (0LL != bt) {
        tmp___0 = kerr("type");
        return (tmp___0);
      }
    }
  }
  x___0 = (C *)(d___0->k);
  w___0 = *x___0;
  fb = (I )0;
  fn = (I )0;
  tmp___5 = CSK(b___1);
  tmp___6 = stat_sz(tmp___5, & s);
  if (tmp___6) {
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    tmp___4 = kerr((cS )tmp___3);
    return (tmp___4);
  }
  if (bt) {
    fn = s;
  }
  tmp___7 = CSK(b___1);
  tmp___8 = open((char const   *)tmp___7, 0);
  f = (I )tmp___8;
  if (f < 0LL) {
    tmp___9 = kerr("domain");
    return (tmp___9);
  }
  tmp___13 = mmap((void *)0, (size_t )fn, 1, 1, (int )f, (__off_t )fb);
  v = (S )tmp___13;
  if ((unsigned long )((void *)-1) == (unsigned long )v) {
    printf((char const   * __restrict  )"mmap failed\n");
    tmp___10 = __errno_location();
    tmp___11 = strerror(*tmp___10);
    tmp___12 = kerr((cS )tmp___11);
    return (tmp___12);
  }
  tmp___14 = close((int )f);
  r = (I )tmp___14;
  if (r) {
    tmp___15 = kerr("file");
    return (tmp___15);
  }
  fc = (I )0;
  i = (I )0;
  _i___0 = cn;
  while (i < _i___0) {
    if (32 == (int )*((C *)(c->k) + i)) {
      goto __Cont;
    }
    tmp___17 = stringHasChar((S )"IFCS", *((C *)(c->k) + i));
    if (tmp___17) {
      fc ++;
    } else {
      tmp___16 = kerr("type");
      return (tmp___16);
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  r = (I )0;
  i___0 = (I )0;
  _i___1 = fn;
  while (i___0 < _i___1) {
    if ((int )*(v + (fb + i___0)) == 10) {
      r ++;
    }
    i___0 ++;
  }
  if ((int )*(v + (fn - 1LL)) != 10) {
    r ++;
  }
  z = newK((I )0, (I )2);
  if (! z) {
    goto cleanup;
  }
  z->k[0] = newK((I )-4, fc);
  z->k[1] = newK((I )0, fc);
  e = (I )0;
  i___1 = (I )0;
  _i___2 = cn;
  while (i___1 < _i___2) {
    g = *((C *)(c->k) + i___1);
    if (32 == (int )g) {
      goto __Cont___0;
    }
    tmp___18 = e;
    e ++;
    tmp___20 = charpos((S )"CIF S", g);
    tmp___19 = newK(- tmp___20, r - 1LL);
    (z->k[1])->k[tmp___18] = tmp___19;
    if (! tmp___19) {
      cd(z);
      z = (K )0;
      goto cleanup;
    }
    __Cont___0: /* CIL Label */ 
    i___1 ++;
  }
  u = (I )0;
  t = (I )0;
  p = (I )0;
  n = (I )0;
  h = (I )0;
  y[0] = w___0;
  while (u <= fn) {
    while (1) {
      if (u + t <= fn) {
        if (10 != (int )*(v + (u + t))) {
          if (! ((L )*(v + (u + t)) != (L )((void *)0))) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      t ++;
    }
    tmp___27 = n;
    n ++;
    if (0LL == tmp___27) {
      if ((int )*(v + (u + t)) == 10) {
        goto _L;
      } else
      if ((L )*(v + (u + t)) == (L )((void *)0)) {
        _L: /* CIL Label */ 
        h = (I )0;
        e = h;
        m = strdupn(v + u, t);
        if (! m) {
          return ((K )0);
        }
        if ((L )*(m + 0) != (L )((void *)0)) {
          tok = strsep((char ** __restrict  )(& m), (char const   * __restrict  )(y));
          tmp___21 = e;
          e ++;
          k = z->k[tmp___21];
          tmp___23 = h;
          h ++;
          if ((int )*((C *)(c->k) + tmp___23) == 32) {
            e --;
          } else {
            tmp___22 = p;
            p ++;
            *((S *)((z->k[0])->k) + tmp___22) = sp(tok);
          }
          while ((unsigned long )tok != (unsigned long )((void *)0)) {
            tok = strsep((char ** __restrict  )(& m), (char const   * __restrict  )(y));
            if ((unsigned long )tok != (unsigned long )((void *)0)) {
              tmp___24 = e;
              e ++;
              k = z->k[tmp___24];
              tmp___26 = h;
              h ++;
              if ((int )*((C *)(c->k) + tmp___26) == 32) {
                e --;
              } else {
                tmp___25 = p;
                p ++;
                *((S *)((z->k[0])->k) + tmp___25) = sp(tok);
              }
            }
          }
        }
        free((void *)m);
        p = (I )0;
      }
    }
    if (n > 1LL) {
      if ((int )*(v + (u + t)) == 10) {
        goto _L___0;
      } else
      if ((L )*(v + (u + t)) == (L )((void *)0)) {
        _L___0: /* CIL Label */ 
        q = (K )0;
        h = (I )0;
        e = h;
        m = strdupn(v + u, t);
        if (! m) {
          return ((K )0);
        }
        if ((L )*(m + 0) != (L )((void *)0)) {
          tok = strsep((char ** __restrict  )(& m), (char const   * __restrict  )(y));
          tmp___28 = e;
          e ++;
          k = (z->k[1])->k[tmp___28];
          tmp___29 = h;
          h ++;
          switch ((int )*((C *)(c->k) + tmp___29)) {
          case 32: 
          e --;
          break;
          case 73: 
          q = formKiCS(tok);
          if (q) {
            *((I *)(k->k) + p) = *((I *)(q->k));
          } else {
            *((I *)(k->k) + p) = (-0x7FFFFFFFFFFFFFFF-1);
          }
          break;
          case 70: 
          q = formKfCS(tok);
          if (q) {
            *((F *)(k->k) + p) = *((F *)(q->k));
          } else {
            *((F *)(k->k) + p) = (double )0 / 0.;
          }
          break;
          case 67: 
          tmp___30 = strlen((char const   *)tok);
          n = (I )tmp___30;
          q = newK((I )-3, n);
          if (! n) {
            n ++;
          }
          memcpy((void * __restrict  )((C *)(q->k)), (void const   * __restrict  )tok,
                 (size_t )n);
          k->k[p] = q;
          q = (K )0;
          break;
          case 83: 
          *((S *)(k->k) + p) = sp(tok);
          break;
          }
          while ((unsigned long )tok != (unsigned long )((void *)0)) {
            tok = strsep((char ** __restrict  )(& m), (char const   * __restrict  )(y));
            if ((unsigned long )tok != (unsigned long )((void *)0)) {
              tmp___31 = e;
              e ++;
              k = (z->k[1])->k[tmp___31];
              tmp___32 = h;
              h ++;
              switch ((int )*((C *)(c->k) + tmp___32)) {
              case 32: 
              e --;
              break;
              case 73: 
              q = formKiCS(tok);
              if (q) {
                *((I *)(k->k) + p) = *((I *)(q->k));
              } else {
                *((I *)(k->k) + p) = (-0x7FFFFFFFFFFFFFFF-1);
              }
              break;
              case 70: 
              q = formKfCS(tok);
              if (q) {
                *((F *)(k->k) + p) = *((F *)(q->k));
              } else {
                *((F *)(k->k) + p) = (double )0 / 0.;
              }
              break;
              case 67: 
              tmp___33 = strlen((char const   *)tok);
              n = (I )tmp___33;
              q = newK((I )-3, n);
              if (! n) {
                n ++;
              }
              memcpy((void * __restrict  )((C *)(q->k)), (void const   * __restrict  )tok,
                     (size_t )n);
              k->k[p] = q;
              q = (K )0;
              break;
              case 83: 
              *((S *)(k->k) + p) = sp(tok);
              break;
              }
            }
          }
        }
        free((void *)m);
        p ++;
      }
    }
    u += t + 1LL;
    t = (I )0;
  }
  cleanup: 
  tmp___34 = munmap((void *)v, (size_t )s);
  res = (I )tmp___34;
  if (res) {
    tmp___35 = kerr("munmap");
    return (tmp___35);
  }
  return (z);
}
}
K _1m(K x___0 ) 
{ 
  K tmp ;
  I tmp___0 ;
  S m ;
  S tmp___1 ;
  I sm ;
  size_t tmp___2 ;
  S e ;
  S tmp___3 ;
  S tmp___4 ;
  S tmp___5 ;
  struct stat c ;
  I f ;
  int tmp___6 ;
  int tmp___7 ;
  K tmp___8 ;
  I s ;
  I r ;
  int tmp___9 ;
  K tmp___10 ;
  K tmp___11 ;
  S v ;
  int *tmp___12 ;
  char *tmp___13 ;
  K tmp___14 ;
  void *tmp___15 ;
  I b___1 ;
  K z ;
  K tmp___16 ;
  int tmp___17 ;
  K tmp___18 ;
  int tmp___19 ;
  K tmp___20 ;

  {
  if (4LL != x___0->t) {
    if (x___0->t < 0LL) {
      tmp___0 = - x___0->t;
    } else {
      tmp___0 = x___0->t;
    }
    if (3LL != tmp___0) {
      tmp = kerr("type");
      return (tmp);
    }
  }
  tmp___1 = CSK(x___0);
  m = tmp___1;
  tmp___2 = strlen((char const   *)m);
  sm = (I )tmp___2;
  if (sm > 1LL) {
    if (46 == (int )*(m + (sm - 2LL))) {
      if ((int const   )*"K" == (int const   )*(m + (sm - 1LL))) {
        tmp___3 = strdupn(m, sm);
        tmp___5 = tmp___3;
      } else {
        tmp___4 = glueSS(m, (S )"K");
        tmp___5 = tmp___4;
      }
    } else {
      tmp___4 = glueSS(m, (S )"K");
      tmp___5 = tmp___4;
    }
  } else {
    tmp___4 = glueSS(m, (S )"K");
    tmp___5 = tmp___4;
  }
  e = tmp___5;
  if (! e) {
    return ((K )0);
  }
  tmp___6 = open((char const   *)e, 2);
  f = (I )tmp___6;
  if (f >= 0LL) {
    stat((char const   * __restrict  )e, (struct stat * __restrict  )(& c));
  } else {
    tmp___7 = open((char const   *)m, 2);
    f = (I )tmp___7;
    stat((char const   * __restrict  )m, (struct stat * __restrict  )(& c));
  }
  free((void *)e);
  if (f < 0LL) {
    tmp___8 = kerr("domain");
    return (tmp___8);
  }
  s = (I )c.st_size;
  if ((unsigned long long )s < (unsigned long long )(4UL * sizeof(I ))) {
    tmp___9 = close((int )f);
    r = (I )tmp___9;
    if (r) {
      tmp___10 = kerr("nonce");
      return (tmp___10);
    }
    tmp___11 = kerr("nonce");
    return (tmp___11);
  }
  tmp___15 = mmap((void *)0, (size_t )s, 3, 16386, (int )f, (__off_t )0);
  v = (S )tmp___15;
  if ((unsigned long )((void *)-1) == (unsigned long )v) {
    tmp___12 = __errno_location();
    tmp___13 = strerror(*tmp___12);
    tmp___14 = kerr((cS )tmp___13);
    return (tmp___14);
  }
  b___1 = (I )0;
  tmp___16 = _1m_r(f, (V )v, (V )v, (V )(v + s), & b___1);
  z = tmp___16;
  tmp___17 = close((int )f);
  r = (I )tmp___17;
  if (r) {
    tmp___18 = kerr("file");
    return (tmp___18);
  }
  tmp___19 = munmap((void *)v, (size_t )s);
  r = (I )tmp___19;
  if (r) {
    tmp___20 = kerr("munmap");
    return (tmp___20);
  }
  return (z);
}
}
static K _1m_r(I f , V fixed , V v , V aft , I *b___1 ) 
{ 
  I s ;
  K tmp ;
  I *w___0 ;
  I t ;
  I n ;
  K tmp___0 ;
  K tmp___1 ;
  I tmp___2 ;
  I r ;
  I tmp___3 ;
  K tmp___4 ;
  K z ;
  K x___0 ;
  I i ;
  I _i___0 ;
  S u ;
  I length ;
  I offset ;
  int tmp___5 ;
  I mod___0 ;
  int *tmp___6 ;
  char *tmp___7 ;
  K tmp___8 ;
  void *tmp___9 ;
  unsigned long long tmp___10 ;

  {
  s = (I )(aft - v);
  if ((unsigned long long )s < (unsigned long long )(4UL * sizeof(I ))) {
    tmp = kerr("nonce");
    return (tmp);
  }
  w___0 = (I *)v;
  t = *(w___0 + 2);
  n = *(w___0 + 3);
  if (t < -4LL) {
    tmp___0 = kerr("nonce");
    return (tmp___0);
  } else
  if (t > 7LL) {
    tmp___0 = kerr("nonce");
    return (tmp___0);
  } else
  if (n < 0LL) {
    tmp___0 = kerr("nonce");
    return (tmp___0);
  }
  if (t < 0LL) {
    tmp___2 = - t;
  } else {
    tmp___2 = t;
  }
  if (4LL == tmp___2) {
    tmp___1 = _2m_r(v, aft, b___1);
    return (tmp___1);
  } else
  if (7LL == t) {
    tmp___1 = _2m_r(v, aft, b___1);
    return (tmp___1);
  } else
  if (1LL <= t) {
    if (t <= 3LL) {
      tmp___1 = _2m_r(v, aft, b___1);
      return (tmp___1);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (6LL == t) {
    tmp___1 = _2m_r(v, aft, b___1);
    return (tmp___1);
  }
  r = (I )(4UL * sizeof(I ));
  if (0LL != t) {
    if (5LL != t) {
      tmp___3 = bp(t);
      r = (I )((unsigned long long )r + ((unsigned long long )(tmp___3 * n + (I )(-3LL == t)) - (unsigned long long )((unsigned long )(t > 0LL) * sizeof(I ))));
    }
  }
  if (r % 8LL > 0LL) {
    r += 8LL - r % 8LL;
  }
  if (s < r) {
    tmp___4 = kerr("nonce");
    return (tmp___4);
  }
  if (0LL == t) {
    goto _L___0;
  } else
  if (5LL == t) {
    _L___0: /* CIL Label */ 
    z = newK(t, n);
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      x___0 = _1m_r(f, fixed, v + r, aft, & r);
      if (! x___0) {
        cd(z);
        return ((K )0);
      }
      z->k[i] = x___0;
      i ++;
    }
  } else {
    length = r;
    if (t > 0LL) {
      tmp___5 = 3;
    } else {
      tmp___5 = 4;
    }
    offset = (I )((unsigned long )(v - fixed) + (unsigned long )tmp___5 * sizeof(I ));
    mod___0 = offset;
    length += mod___0;
    offset -= mod___0;
    tmp___9 = mmap((void *)0, (size_t )length, 3, 16386, (int )f, (__off_t )offset);
    u = (S )tmp___9;
    if ((unsigned long )((void *)-1) == (unsigned long )u) {
      tmp___6 = __errno_location();
      tmp___7 = strerror(*tmp___6);
      tmp___8 = kerr((cS )tmp___7);
      return (tmp___8);
    }
    mMap += (F )length;
    mUsed += (F )length;
    if (mUsed > mMax) {
      mMax = mUsed;
    }
    z = (K )(((V )u + mod___0) - 3UL * sizeof(I ));
    mrc(z, (I )1);
  }
  if ((unsigned long long )r > (unsigned long long )(4UL * sizeof(I ))) {
    tmp___10 = (unsigned long long )r;
  } else {
    tmp___10 = (unsigned long long )(4UL * sizeof(I ));
  }
  *b___1 = (I )((unsigned long long )*b___1 + tmp___10);
  return (z);
}
}
K _1d(K x___0 , K y ) 
{ 
  I t ;
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;

  {
  t = x___0->t;
  if (4LL == t) {
    tmp = _1d_write(x___0, y, (I )0);
    return (tmp);
  } else
  if (-3LL == t) {
    tmp = _1d_write(x___0, y, (I )0);
    return (tmp);
  }
  if (! t) {
    tmp___0 = _1d_read(x___0, y);
    return (tmp___0);
  }
  if (3LL == t) {
    tmp___1 = _1d_char(x___0, y);
    return (tmp___1);
  }
  tmp___2 = kerr("type");
  return (tmp___2);
}
}
static K _1d_write(K x___0 , K y , I dosync ) 
{ 
  I n ;
  I tmp ;
  S m ;
  S tmp___0 ;
  I sm ;
  size_t tmp___1 ;
  S e ;
  S tmp___2 ;
  S tmp___3 ;
  S tmp___4 ;
  I f ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  K tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  K tmp___11 ;
  int tmp___12 ;
  S v ;
  int *tmp___13 ;
  char *tmp___14 ;
  K tmp___15 ;
  void *tmp___16 ;
  I r ;
  int tmp___17 ;
  K tmp___18 ;
  int tmp___19 ;
  K tmp___20 ;
  K tmp___21 ;

  {
  tmp = disk(y);
  n = tmp;
  tmp___0 = CSK(x___0);
  m = tmp___0;
  tmp___1 = strlen((char const   *)m);
  sm = (I )tmp___1;
  if (sm > 1LL) {
    if (46 == (int )*(m + (sm - 2LL))) {
      if ((int const   )*"K" == (int const   )*(m + (sm - 1LL))) {
        tmp___2 = strdupn(m, sm);
        tmp___4 = tmp___2;
      } else {
        tmp___3 = glueSS(m, (S )"K");
        tmp___4 = tmp___3;
      }
    } else {
      tmp___3 = glueSS(m, (S )"K");
      tmp___4 = tmp___3;
    }
  } else {
    tmp___3 = glueSS(m, (S )"K");
    tmp___4 = tmp___3;
  }
  e = tmp___4;
  if (! e) {
    return ((K )0);
  }
  tmp___5 = open((char const   *)e, 578, 4095);
  f = (I )tmp___5;
  free((void *)e);
  if (f < 0LL) {
    tmp___6 = __errno_location();
    tmp___7 = strerror(*tmp___6);
    tmp___8 = kerr((cS )tmp___7);
    return (tmp___8);
  }
  tmp___12 = ftruncate((int )f, (__off_t )n);
  if (tmp___12) {
    tmp___9 = __errno_location();
    tmp___10 = strerror(*tmp___9);
    tmp___11 = kerr((cS )tmp___10);
    return (tmp___11);
  }
  tmp___16 = mmap((void *)0, (size_t )n, 2, 1, (int )f, (__off_t )0);
  v = (S )tmp___16;
  if ((unsigned long )((void *)-1) == (unsigned long )v) {
    tmp___13 = __errno_location();
    tmp___14 = strerror(*tmp___13);
    tmp___15 = kerr((cS )tmp___14);
    return (tmp___15);
  }
  tmp___17 = close((int )f);
  r = (I )tmp___17;
  if (r) {
    tmp___18 = kerr("file");
    return (tmp___18);
  }
  wrep(y, (V )v, (I )1);
  if (dosync) {
    msync((void *)v, (size_t )n, 6);
  }
  tmp___19 = munmap((void *)v, (size_t )n);
  r = (I )tmp___19;
  if (r) {
    tmp___20 = kerr("munmap");
    return (tmp___20);
  }
  tmp___21 = _n();
  return (tmp___21);
}
}
I wrep(K x___0 , V v , I y ) 
{ 
  I t ;
  I n ;
  I *w___0 ;
  I m ;
  int tmp ;
  V d___0 ;
  I e ;
  I r ;
  I s ;
  I i ;
  I _i___0 ;
  V point ;
  I delta ;
  I tmp___0 ;
  I i___0 ;
  I _i___1 ;
  size_t tmp___1 ;
  K k ;
  I s___0 ;
  I tmp___2 ;
  K tmp___3 ;
  V s___1 ;
  I b___1 ;
  I tmp___4 ;
  I tmp___5 ;
  size_t tmp___6 ;

  {
  t = x___0->t;
  n = x___0->n;
  w___0 = (I *)v;
  if (y) {
    tmp = 2;
  } else {
    tmp = 0;
  }
  m = (I )tmp;
  if (y) {
    *w___0 = (I )-3;
    *(w___0 + 1) = (I )1;
    *(w___0 + 2) = t;
    *(w___0 + 3) = n;
  } else {
    memcpy((void * __restrict  )w___0, (void const   * __restrict  )(& x___0->t),
           sizeof(x___0->t) + sizeof(x___0->n));
  }
  d___0 = (V )((w___0 + 2) + m);
  e = (I )((unsigned long long )(2LL + m) * (unsigned long long )sizeof(I ));
  if (0LL != t) {
    if (5LL != t) {
      if (-4LL != t) {
        e = rep(x___0, y);
      }
    }
  }
  r = (I )0;
  if (0LL == t) {
    goto _L___0;
  } else
  if (5LL == t) {
    _L___0: /* CIL Label */ 
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      point = d___0 + r;
      tmp___0 = wrep(x___0->k[i], point, y);
      delta = tmp___0;
      r += delta;
      i ++;
    }
  } else
  if (-4LL == t) {
    i___0 = (I )0;
    _i___1 = n;
    while (i___0 < _i___1) {
      tmp___1 = strlen((char const   *)*((S *)(x___0->k) + i___0));
      s = (I )(1UL + tmp___1);
      memcpy((void * __restrict  )(d___0 + r), (void const   * __restrict  )*((S *)(x___0->k) + i___0),
             (size_t )s);
      r += s;
      i___0 ++;
    }
    if (r % 8LL > 0LL) {
      r += 8LL - r % 8LL;
    }
  } else
  if (7LL == t) {
    goto _L;
  } else
  if (8LL == t) {
    _L: /* CIL Label */ 
    if (1LL == x___0->n) {
      if (1LL == ((K )*((V *)(x___0->k) + 2))->n - 1LL) {
        if ((unsigned long )offsetColon == (unsigned long )((V )*((S *)((x___0->k[2])->k) + 0))) {
          k = (K )*((V *)((S *)(((K )*((V *)(x___0->k) + 2))->k)));
          tmp___2 = sva((V )k);
          s___0 = tmp___2;
          if (1LL == s___0) {
            *(w___0 + m) = (I )'\a';
          } else {
            *(w___0 + m) = (I )'\b';
          }
          *(w___0 + (1LL + m)) = (L )offsetColon;
        } else {
          tmp___3 = kerr("syntax");
          return ((L )tmp___3);
        }
      } else {
        tmp___3 = kerr("syntax");
        return ((L )tmp___3);
      }
    } else {
      tmp___3 = kerr("syntax");
      return ((L )tmp___3);
    }
  } else {
    s___1 = (V )(x___0->k);
    tmp___4 = bp(t);
    if (t < 0LL) {
      tmp___5 = - t;
    } else {
      tmp___5 = t;
    }
    b___1 = n * tmp___4 + (I )(3LL == tmp___5);
    if (t > 0LL) {
      d___0 -= sizeof(I );
    }
    if (4LL == t) {
      s___1 = (V )*((S *)(x___0->k));
      tmp___6 = strlen((char const   *)*((S *)(x___0->k)));
      b___1 = (I )(1UL + tmp___6);
    }
    if (b___1 % 8LL > 0LL) {
      b___1 = 8LL * (b___1 / 8LL) + (1LL + b___1 % 8LL);
    }
    memcpy((void * __restrict  )d___0, (void const   * __restrict  )s___1, (size_t )b___1);
  }
  return (e + r);
}
}
static I disk(K x___0 ) 
{ 
  I tmp ;

  {
  tmp = rep(x___0, (I )1);
  return (tmp);
}
}
I rep(K x___0 , I y ) 
{ 
  I m ;
  int tmp ;
  I r ;
  I n ;
  I q ;
  I i ;
  I _i___0 ;
  I tmp___0 ;
  I i___0 ;
  I _i___1 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  I tmp___3 ;

  {
  if (y) {
    tmp = 4;
  } else {
    tmp = 2;
  }
  m = (I )(sizeof(I ) * (unsigned long )tmp);
  r = m;
  n = x___0->n;
  q = (I )0;
  switch (x___0->t) {
  case 0LL: ;
  case 5LL: 
  i = (I )0;
  _i___0 = x___0->n;
  while (i < _i___0) {
    tmp___0 = rep(x___0->k[i], y);
    r += tmp___0;
    i ++;
  }
  break;
  case 7LL: ;
  case 8LL: ;
  break;
  case -4LL: 
  i___0 = (I )0;
  _i___1 = n;
  while (i___0 < _i___1) {
    tmp___1 = strlen((char const   *)*((S *)(x___0->k) + i___0));
    r = (I )((unsigned long long )r + (unsigned long long )(1UL + tmp___1));
    i___0 ++;
  }
  if (r % 8LL > 0LL) {
    r += 8LL - r % 8LL;
  }
  break;
  case -3LL: 
  r = (I )((unsigned long long )r + (unsigned long long )(1LL + n) * (unsigned long long )sizeof(C ));
  if (r % 8LL > 0LL) {
    r += 8LL - r % 8LL;
  }
  break;
  case -2LL: 
  r = (I )((unsigned long long )r + (unsigned long long )n * (unsigned long long )sizeof(F ));
  break;
  case -1LL: 
  r = (I )((unsigned long long )r + (unsigned long long )n * (unsigned long long )sizeof(I ));
  break;
  case 4LL: 
  tmp___2 = strlen((char const   *)*((S *)(x___0->k)));
  q = (I )(1UL + tmp___2);
  if ((unsigned long long )q >= (unsigned long long )sizeof(I )) {
    r = (I )((unsigned long long )r + ((unsigned long long )q - (unsigned long long )sizeof(I )));
  }
  break;
  }
  if (r > m) {
    tmp___3 = r;
  } else {
    tmp___3 = m;
  }
  return (tmp___3);
}
}
K rrep(V v , V aft , I *b___1 , I y , I x___0 ) 
{ 
  I m ;
  int tmp ;
  I s ;
  I *w___0 ;
  I r ;
  K tmp___0 ;
  K tmp___1 ;
  I t ;
  I n ;
  K tmp___2 ;
  K f ;
  K z ;
  K tmp___3 ;
  K tmp___4 ;
  K tmp___5 ;
  I c ;
  K k ;
  K tmp___6 ;
  I tmp___7 ;
  I tmp___8 ;
  K tmp___9 ;
  I tmp___10 ;
  I tmp___11 ;
  K tmp___12 ;
  I tmp___13 ;
  I tmp___14 ;
  K tmp___15 ;
  unsigned long long tmp___16 ;

  {
  if (y) {
    tmp = 2;
  } else {
    tmp = 0;
  }
  m = (I )tmp;
  s = (I )(aft - v);
  w___0 = (I *)v;
  r = (I )((unsigned long long )(2LL + m) * (unsigned long long )sizeof(I ));
  if (s < r) {
    tmp___0 = kerr("nonce");
    return (tmp___0);
  }
  if (y) {
    if (-3LL != *(w___0 + 0)) {
      tmp___1 = kerr("nonce");
      return (tmp___1);
    }
  }
  membswpI((V )(& t), (V )(w___0 + m), (I )sizeof(I ), x___0);
  if (t <= 0LL) {
    membswpI((V )(& n), (V )((w___0 + 1) + m), (I )sizeof(I ), x___0);
  } else
  if (5LL == t) {
    membswpI((V )(& n), (V )((w___0 + 1) + m), (I )sizeof(I ), x___0);
  } else
  if (! (10LL == t)) {
    n = (I )1;
  }
  if (-1LL == t) {
    r = (I )((unsigned long long )r + (unsigned long long )n * (unsigned long long )sizeof(I ));
  } else
  if (-2LL == t) {
    r = (I )((unsigned long long )r + (unsigned long long )n * (unsigned long long )sizeof(F ));
  } else
  if (-3LL == t) {
    r = (I )((unsigned long long )r + (unsigned long long )(1LL + n) * (unsigned long long )sizeof(C ));
  }
  if (s < r) {
    tmp___2 = kerr("nonce");
    return (tmp___2);
  }
  if (-4LL <= t) {
    if (t <= 6LL) {
      tmp___3 = newK(t, n);
      tmp___5 = tmp___3;
    } else {
      tmp___4 = Kv();
      tmp___5 = tmp___4;
    }
  } else {
    tmp___4 = Kv();
    tmp___5 = tmp___4;
  }
  z = tmp___5;
  if (! z) {
    return ((K )0);
  }
  c = (I )0;
  switch (t) {
  case 0LL: ;
  case 5LL: 
  while (1) {
    if ((unsigned long )(v + r) < (unsigned long )aft) {
      if (! (c < n)) {
        break;
      }
    } else {
      break;
    }
    tmp___6 = rrep(v + r, aft, & r, y, x___0);
    k = tmp___6;
    tmp___7 = OOM_CD((I )0, z, k, (V )-1);
    if (! tmp___7) {
      return ((K )0);
    }
    tmp___8 = c;
    c ++;
    memcpy((void * __restrict  )(& z->k[tmp___8]), (void const   * __restrict  )(& k),
           sizeof(K ));
  }
  if (c != n) {
    cd(z);
    tmp___9 = kerr("nonce");
    return (tmp___9);
  }
  break;
  case -4LL: 
  while (1) {
    if ((unsigned long )(v + r) < (unsigned long )aft) {
      if (! (c < n)) {
        break;
      }
    } else {
      break;
    }
    tmp___10 = c;
    c ++;
    tmp___11 = rrep_4((S *)(z->k) + tmp___10, (S )(v + r), (S )aft);
    r += tmp___11;
  }
  if (c != n) {
    tmp___12 = kerr("nonce");
    return (tmp___12);
  }
  break;
  case -3LL: 
  memcpy((void * __restrict  )((C *)(z->k)), (void const   * __restrict  )((w___0 + 2) + m),
         (size_t )((unsigned long long )n * (unsigned long long )sizeof(C )));
  break;
  case -2LL: 
  membswpF((V )((F *)(z->k)), (V )((w___0 + 2) + m), (I )((unsigned long long )n * (unsigned long long )sizeof(F )),
           x___0);
  break;
  case -1LL: 
  membswpI((V )((I *)(z->k)), (V )((w___0 + 2) + m), (I )((unsigned long long )n * (unsigned long long )sizeof(I )),
           x___0);
  break;
  case 1LL: 
  membswpI((V )((I *)(z->k)), (V )((w___0 + 1) + m), (I )sizeof(I ), x___0);
  break;
  case 2LL: 
  membswpF((V )((F *)(z->k)), (V )((w___0 + 1) + m), (I )sizeof(F ), x___0);
  break;
  case 3LL: 
  memcpy((void * __restrict  )((C *)(z->k)), (void const   * __restrict  )((w___0 + 1) + m),
         sizeof(C ));
  break;
  case 4LL: 
  tmp___13 = rrep_4((S *)(z->k), (S )((w___0 + 1) + m), (S )aft);
  r = (I )((unsigned long long )r + ((unsigned long long )tmp___13 - (unsigned long long )sizeof(I )));
  break;
  case 6LL: ;
  break;
  case 7LL: ;
  case 8LL: 
  f = newK((I )-4, (I )2);
  tmp___14 = OOM_CD((I )0, z, f, (V )-1);
  if (! tmp___14) {
    return ((K )0);
  }
  *((V *)(z->k) + 2) = (V )f;
  if (x___0) {
    *(w___0 + (1LL + m)) = bswapI(*(w___0 + (1LL + m)));
  }
  f->k[0] = (struct k0 *)((V )*(w___0 + (1LL + m)));
  r = r;
  break;
  default: 
  tmp___15 = kerr("nonce");
  return (tmp___15);
  }
  if ((unsigned long long )r > (unsigned long long )(2LL + m) * (unsigned long long )sizeof(I )) {
    tmp___16 = (unsigned long long )r;
  } else {
    tmp___16 = (unsigned long long )(2LL + m) * (unsigned long long )sizeof(I );
  }
  *b___1 = (I )((unsigned long long )*b___1 + tmp___16);
  *b___1 = 8LL * (*b___1 / 8LL + (I )(*b___1 % 8LL > 0LL));
  return (z);
}
}
static I rrep_4(S *z , S a , S t ) 
{ 
  S d___0 ;
  I c ;
  S e ;
  S tmp ;

  {
  d___0 = a;
  while (1) {
    if ((unsigned long )a < (unsigned long )t) {
      if (! *a) {
        break;
      }
    } else {
      break;
    }
    a ++;
  }
  c = (I )(a - d___0);
  tmp = strdupn(d___0, c);
  e = tmp;
  *z = sp(e);
  free((void *)e);
  return (c + (I )((unsigned long )a != (unsigned long )t));
}
}
static K _1d_read(K a , K b___1 ) 
{ 
  S types ;
  I fixed[8] ;
  I typelist[15] ;
  C g ;
  K z ;
  I an ;
  I bt ;
  I bn ;
  K tmp ;
  K c ;
  K d___0 ;
  I cn ;
  I dn ;
  K tmp___0 ;
  I tmp___1 ;
  I tmp___2 ;
  K tmp___3 ;
  K tmp___4 ;
  I tmp___5 ;
  I fc ;
  I i ;
  I _i___0 ;
  K tmp___6 ;
  I tmp___7 ;
  K tmp___8 ;
  unsigned short const   **tmp___9 ;
  I tmp___10 ;
  I w___0 ;
  I x___0 ;
  I i___0 ;
  I _i___1 ;
  K tmp___11 ;
  K ff ;
  K k ;
  I fb ;
  I fn ;
  K tmp___12 ;
  K tmp___13 ;
  I tmp___14 ;
  K tmp___15 ;
  K tmp___16 ;
  I s ;
  int *tmp___17 ;
  char *tmp___18 ;
  K tmp___19 ;
  S tmp___20 ;
  I tmp___21 ;
  I tmp___23 ;
  I tmp___24 ;
  I f ;
  S tmp___25 ;
  int tmp___26 ;
  K tmp___27 ;
  S v ;
  I fb_off_by ;
  I map_length ;
  I map_offset ;
  int *tmp___28 ;
  char *tmp___29 ;
  K tmp___30 ;
  void *tmp___31 ;
  I r ;
  int tmp___32 ;
  K tmp___33 ;
  I e ;
  I i___1 ;
  I _i___2 ;
  I tmp___34 ;
  I tmp___35 ;
  I i___2 ;
  I j ;
  V p ;
  K q ;
  I tmp___36 ;
  S u ;
  I res ;
  int tmp___37 ;
  K tmp___38 ;

  {
  types = (S )"cbsijfdmIFCSDZM";
  fixed[0] = (I )sizeof(C );
  fixed[1] = (I )sizeof(int8_t );
  fixed[2] = (I )sizeof(int16_t );
  fixed[3] = (I )sizeof(int32_t );
  fixed[4] = (I )sizeof(I );
  fixed[5] = (I )sizeof(float );
  fixed[6] = (I )sizeof(F );
  fixed[7] = (I )9;
  typelist[0] = (I )-3;
  typelist[1] = (I )-1;
  typelist[2] = (I )-1;
  typelist[3] = (I )-1;
  typelist[4] = (I )-1;
  typelist[5] = (I )-2;
  typelist[6] = (I )-2;
  typelist[7] = (I )9;
  typelist[8] = (I )9;
  typelist[9] = (I )9;
  typelist[10] = (I )0;
  typelist[11] = (I )-4;
  typelist[12] = (I )9;
  typelist[13] = (I )9;
  typelist[14] = (I )9;
  z = (K )0;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (an != 2LL) {
    tmp = kerr("domain");
    return (tmp);
  }
  c = a->k[0];
  d___0 = a->k[1];
  cn = c->n;
  dn = d___0->n;
  if (c->t < 0LL) {
    tmp___1 = - c->t;
  } else {
    tmp___1 = c->t;
  }
  if (3LL != tmp___1) {
    tmp___0 = kerr("type");
    return (tmp___0);
  } else {
    if (d___0->t < 0LL) {
      tmp___2 = - d___0->t;
    } else {
      tmp___2 = d___0->t;
    }
    if (1LL != tmp___2) {
      tmp___0 = kerr("type");
      return (tmp___0);
    }
  }
  if (! cn) {
    tmp___3 = kerr("length");
    return (tmp___3);
  } else
  if (cn != dn) {
    tmp___3 = kerr("length");
    return (tmp___3);
  }
  if (bt < 0LL) {
    tmp___5 = - bt;
  } else {
    tmp___5 = bt;
  }
  if (3LL != tmp___5) {
    if (4LL != bt) {
      if (0LL != bt) {
        tmp___4 = kerr("type");
        return (tmp___4);
      }
    }
  }
  fc = (I )0;
  i = (I )0;
  _i___0 = cn;
  while (i < _i___0) {
    g = *((C *)(c->k) + i);
    if (32 == (int )g) {
      goto __Cont;
    }
    tmp___7 = stringHasChar(types, g);
    if (tmp___7) {
      fc ++;
    } else {
      tmp___6 = kerr("type");
      return (tmp___6);
    }
    tmp___9 = __ctype_b_loc();
    if ((int const   )*(*tmp___9 + (int )g) & 512) {
      tmp___10 = charpos(types, g);
      if (fixed[tmp___10] != *((I *)(d___0->k) + i)) {
        tmp___8 = kerr("length");
        return (tmp___8);
      }
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  w___0 = (I )0;
  i___0 = (I )0;
  _i___1 = dn;
  while (i___0 < _i___1) {
    x___0 = *((I *)(d___0->k) + i___0);
    if (x___0 <= 0LL) {
      tmp___11 = kerr("length");
      return (tmp___11);
    }
    w___0 += x___0;
    i___0 ++;
  }
  ff = b___1;
  fb = (I )0;
  fn = (I )0;
  if (! bt) {
    if (3LL != bn) {
      tmp___12 = kerr("length");
      return (tmp___12);
    }
    ff = b___1->k[0];
    if (ff->t < 0LL) {
      tmp___14 = - ff->t;
    } else {
      tmp___14 = ff->t;
    }
    if (3LL != tmp___14) {
      if (4LL != ff->t) {
        tmp___13 = kerr("type");
        return (tmp___13);
      }
    }
    k = b___1->k[1];
    if (1LL != k->t) {
      if (2LL != k->t) {
        tmp___15 = kerr("type");
        return (tmp___15);
      }
    }
    if (k->t - 1LL) {
      fb = (I )*((F *)(k->k));
    } else {
      fb = *((I *)(k->k));
    }
    k = b___1->k[2];
    if (1LL != k->t) {
      if (2LL != k->t) {
        tmp___16 = kerr("type");
        return (tmp___16);
      }
    }
    if (k->t - 1LL) {
      fn = (I )*((F *)(k->k));
    } else {
      fn = *((I *)(k->k));
    }
  }
  tmp___20 = CSK(ff);
  tmp___21 = stat_sz(tmp___20, & s);
  if (tmp___21) {
    tmp___17 = __errno_location();
    tmp___18 = strerror(*tmp___17);
    tmp___19 = kerr((cS )tmp___18);
    return (tmp___19);
  }
  if (bt) {
    fn = s;
  }
  if (fn < 0LL) {
    fn = (I )0;
  }
  if (fb < 0LL) {
    fb = (I )0;
  }
  if (0LL > s - 1LL) {
    tmp___24 = (I )0;
  } else {
    tmp___24 = s - 1LL;
  }
  if (fb < tmp___24) {
    fb = fb;
  } else {
    if (0LL > s - 1LL) {
      tmp___23 = (I )0;
    } else {
      tmp___23 = s - 1LL;
    }
    fb = tmp___23;
  }
  if (fb + fn > s) {
    fn = s - fb;
  }
  tmp___25 = CSK(ff);
  tmp___26 = open((char const   *)tmp___25, 0);
  f = (I )tmp___26;
  if (f < 0LL) {
    tmp___27 = kerr("domain");
    return (tmp___27);
  }
  fb_off_by = fb % PG;
  map_length = fn + fb_off_by;
  map_offset = fb - fb_off_by;
  tmp___31 = mmap((void *)0, (size_t )map_length, 1, 1, (int )f, (__off_t )map_offset);
  v = (S )tmp___31;
  if ((unsigned long )((void *)-1) == (unsigned long )v) {
    tmp___28 = __errno_location();
    tmp___29 = strerror(*tmp___28);
    tmp___30 = kerr((cS )tmp___29);
    return (tmp___30);
  }
  tmp___32 = close((int )f);
  r = (I )tmp___32;
  if (r) {
    tmp___33 = kerr("file");
    return (tmp___33);
  }
  r = fn / w___0;
  z = newK((I )0, fc);
  if (! z) {
    return ((K )0);
  }
  e = (I )0;
  i___1 = (I )0;
  _i___2 = cn;
  while (i___1 < _i___2) {
    g = *((C *)(c->k) + i___1);
    if (32 == (int )g) {
      goto __Cont___0;
    }
    tmp___34 = e;
    e ++;
    tmp___35 = charpos(types, g);
    z->k[tmp___34] = newK(typelist[tmp___35], r);
    __Cont___0: /* CIL Label */ 
    i___1 ++;
  }
  p = (V )(v + fb_off_by);
  j = (I )0;
  while (j < r) {
    e = (I )0;
    i___2 = (I )0;
    while (i___2 < cn) {
      x___0 = *((I *)(d___0->k) + i___2);
      tmp___36 = e;
      e ++;
      q = z->k[tmp___36];
      g = *((C *)(c->k) + i___2);
      switch ((int )g) {
      case 32: 
      e --;
      break;
      case 99: 
      *((C *)(q->k) + j) = *((C *)p);
      break;
      case 98: 
      *((I *)(q->k) + j) = (I )*((int8_t *)p);
      break;
      case 115: 
      *((I *)(q->k) + j) = (I )*((int16_t *)p);
      break;
      case 105: 
      *((I *)(q->k) + j) = (I )*((int32_t *)p);
      break;
      case 106: 
      *((I *)(q->k) + j) = *((I *)p);
      break;
      case 102: 
      *((F *)(q->k) + j) = (F )*((float *)p);
      break;
      case 100: 
      *((F *)(q->k) + j) = *((F *)p);
      break;
      case 109: ;
      break;
      case 73: ;
      break;
      case 70: ;
      break;
      case 67: 
      k = newK((I )-3, x___0);
      if (! k) {
        return ((K )0);
      }
      memcpy((void * __restrict  )((C *)(k->k)), (void const   * __restrict  )p, (size_t )x___0);
      q->k[j] = k;
      break;
      case 83: 
      u = spn((S )p, x___0);
      if (! u) {
        return ((K )0);
      }
      *((S *)(q->k) + j) = u;
      break;
      case 68: ;
      break;
      case 90: ;
      break;
      case 77: ;
      break;
      }
      p += x___0;
      i___2 ++;
    }
    j ++;
  }
  tmp___37 = munmap((void *)v, (size_t )map_length);
  res = (I )tmp___37;
  if (res) {
    tmp___38 = kerr("munmap");
    return (tmp___38);
  }
  return (z);
}
}
static K _1d_char(K x___0 , K y ) 
{ 
  C a ;
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;

  {
  a = *((C *)(x___0->k));
  if (99 == (int )a) {
    tmp = readVector(y, (I )-3);
    return (tmp);
  }
  if (100 == (int )a) {
    tmp___0 = readVector(y, (I )-2);
    return (tmp___0);
  }
  if (105 == (int )a) {
    tmp___1 = readVector(y, (I )-1);
    return (tmp___1);
  }
  tmp___2 = kerr("nonce");
  return (tmp___2);
}
}
K _2m(K a ) 
{ 
  I t ;
  K tmp ;
  I tmp___0 ;
  S m ;
  S tmp___1 ;
  I sm ;
  size_t tmp___2 ;
  S e ;
  S tmp___3 ;
  S tmp___4 ;
  S tmp___5 ;
  I s ;
  I f ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  K tmp___9 ;
  I tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  K tmp___14 ;
  I tmp___15 ;
  K tmp___16 ;
  S v ;
  int *tmp___17 ;
  char *tmp___18 ;
  K tmp___19 ;
  void *tmp___20 ;
  I r ;
  int tmp___21 ;
  K tmp___22 ;
  I b___1 ;
  K z ;
  K tmp___23 ;
  int tmp___24 ;
  K tmp___25 ;

  {
  t = a->t;
  if (4LL != t) {
    if (t < 0LL) {
      tmp___0 = - t;
    } else {
      tmp___0 = t;
    }
    if (3LL != tmp___0) {
      tmp = kerr("type");
      return (tmp);
    }
  }
  tmp___1 = CSK(a);
  m = tmp___1;
  tmp___2 = strlen((char const   *)m);
  sm = (I )tmp___2;
  if (sm > 1LL) {
    if (46 == (int )*(m + (sm - 2LL))) {
      if ((int const   )*"K" == (int const   )*(m + (sm - 1LL))) {
        tmp___3 = strdupn(m, sm);
        tmp___5 = tmp___3;
      } else {
        tmp___4 = glueSS(m, (S )"K");
        tmp___5 = tmp___4;
      }
    } else {
      tmp___4 = glueSS(m, (S )"K");
      tmp___5 = tmp___4;
    }
  } else {
    tmp___4 = glueSS(m, (S )"K");
    tmp___5 = tmp___4;
  }
  e = tmp___5;
  if (! e) {
    return ((K )0);
  }
  tmp___6 = open((char const   *)e, 0);
  f = (I )tmp___6;
  if (f >= 0LL) {
    tmp___10 = stat_sz(e, & s);
    if (tmp___10) {
      tmp___7 = __errno_location();
      tmp___8 = strerror(*tmp___7);
      tmp___9 = kerr((cS )tmp___8);
      return (tmp___9);
    }
  } else {
    tmp___11 = open((char const   *)m, 0);
    f = (I )tmp___11;
    tmp___15 = stat_sz(m, & s);
    if (tmp___15) {
      tmp___12 = __errno_location();
      tmp___13 = strerror(*tmp___12);
      tmp___14 = kerr((cS )tmp___13);
      return (tmp___14);
    }
  }
  free((void *)e);
  if (f < 0LL) {
    tmp___16 = kerr("domain");
    return (tmp___16);
  }
  tmp___20 = mmap((void *)0, (size_t )s, 1, 1, (int )f, (__off_t )0);
  v = (S )tmp___20;
  if ((unsigned long )((void *)-1) == (unsigned long )v) {
    tmp___17 = __errno_location();
    tmp___18 = strerror(*tmp___17);
    tmp___19 = kerr((cS )tmp___18);
    return (tmp___19);
  }
  tmp___21 = close((int )f);
  r = (I )tmp___21;
  if (r) {
    tmp___22 = kerr("file");
    return (tmp___22);
  }
  b___1 = (I )0;
  tmp___23 = _2m_r((V )v, (V )(v + s), & b___1);
  z = tmp___23;
  tmp___24 = munmap((void *)v, (size_t )s);
  r = (I )tmp___24;
  if (r) {
    tmp___25 = kerr("munmap");
    return (tmp___25);
  }
  return (z);
}
}
K _2m_r(V v , V aft , I *b___1 ) 
{ 
  K tmp ;

  {
  tmp = rrep(v, aft, b___1, (I )1, (I )0);
  return (tmp);
}
}
K _2d(K a , K b___1 ) 
{ 
  K c ;
  K d___0 ;
  K tmp ;
  I tmp___0 ;
  I tmp___1 ;
  L v ;
  K tmp___2 ;
  cS e ;
  V x___0 ;
  S tmp___3 ;
  void *tmp___4 ;
  V y ;
  char *tmp___5 ;
  S tmp___6 ;
  S tmp___7 ;
  S tmp___8 ;
  char *tmp___9 ;
  K tmp___10 ;
  K tmp___11 ;
  K z ;
  K tmp___12 ;
  K w___0 ;
  K tmp___13 ;
  I tmp___14 ;

  {
  if (4LL != a->t) {
    if (a->t < 0LL) {
      tmp___0 = - a->t;
    } else {
      tmp___0 = a->t;
    }
    if (3LL != tmp___0) {
      tmp = kerr("type");
      return (tmp);
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (b___1->t) {
    tmp = kerr("type");
    return (tmp);
  } else
  if (b___1->n != 2LL) {
    tmp = kerr("type");
    return (tmp);
  } else {
    c = b___1->k[0];
    if (4LL != c->t) {
      if (c->t < 0LL) {
        tmp___1 = - c->t;
      } else {
        tmp___1 = c->t;
      }
      if (3LL != tmp___1) {
        tmp = kerr("type");
        return (tmp);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      d___0 = b___1->k[1];
      if (1LL != d___0->t) {
        tmp = kerr("type");
        return (tmp);
      }
    }
  }
  v = *((I *)(d___0->k));
  if (v < 0LL) {
    tmp___2 = kerr("valence");
    return (tmp___2);
  } else
  if (v > 7LL) {
    tmp___2 = kerr("valence");
    return (tmp___2);
  }
  tmp___3 = CSK(a);
  tmp___4 = dlopen((char const   *)tmp___3, 1);
  x___0 = tmp___4;
  tmp___5 = dlerror();
  e = (cS )tmp___5;
  if (e) {
    tmp___6 = CSK(a);
    printf((char const   * __restrict  )"error loading %s\nerr=%s\n", tmp___6, e);
    return ((K )0);
  }
  if (! x___0) {
    tmp___7 = CSK(a);
    printf((char const   * __restrict  )"error loading %s \n", tmp___7);
    return ((K )0);
  }
  tmp___8 = CSK(c);
  y = dlsym((void * __restrict  )x___0, (char const   * __restrict  )tmp___8);
  tmp___9 = dlerror();
  e = (cS )tmp___9;
  if (e) {
    if (*e) {
      tmp___10 = kerr(e);
      return (tmp___10);
    }
  }
  if (! y) {
    tmp___11 = kerr("domain");
    return (tmp___11);
  }
  tmp___12 = Kv();
  z = tmp___12;
  tmp___13 = newK((I )-4, (I )3);
  w___0 = tmp___13;
  tmp___14 = OOM_CD((I )0, z, w___0, (V )-1);
  if (! tmp___14) {
    return ((K )0);
  }
  z->n = (I )2;
  w___0->k[0] = (struct k0 *)((V )v);
  w___0->k[1] = (struct k0 *)y;
  *((V *)(z->k) + 2) = (V )w___0;
  return (z);
}
}
void dm1(S msg , M1 *m ) 
{ 


  {
  printf((char const   * __restrict  )"=== %s ===\n", msg);
  printf((char const   * __restrict  )"a: %d\n", (int )m->a);
  printf((char const   * __restrict  )"n: %lld\n", m->n);
  printf((char const   * __restrict  )"d: %d\n", (int )m->d);
  return;
}
}
static I sendall(I s , S b___1 , I k ) 
{ 
  I t ;
  I r ;
  I n ;
  ssize_t tmp ;
  I tmp___0 ;

  {
  t = (I )0;
  r = k;
  n = (I )0;
  while (t < k) {
    tmp = send((int )s, (void const   *)(b___1 + t), (size_t )r, 0);
    n = (I )tmp;
    if (-1LL == n) {
      break;
    }
    t += n;
    r -= n;
  }
  if (-1LL == n) {
    tmp___0 = n;
  } else {
    tmp___0 = (I )0;
  }
  return (tmp___0);
}
}
I ksender(I sockfd , K y , I t ) 
{ 
  I r ;
  K k ;
  M1 *m ;

  {
  r = (I )0;
  k = _bd(y);
  if (! k) {
    return ((I )0);
  }
  m = (M1 *)((V )((C *)(k->k)));
  m->d = (char )t;
  r = sendall(sockfd, (C *)(k->k), k->n);
  if (-1LL == r) {
    perror("conn: send error");
  }
  cd(k);
  return (r);
}
}
static K _3d_(K x___0 , K y ) 
{ 
  I res ;
  S sym ;
  I lenS ;
  size_t tmp ;
  S cod ;
  I lenC ;
  size_t tmp___0 ;
  I i ;
  K q ;
  K tmp___1 ;
  S sym___0 ;
  I lenS___0 ;
  size_t tmp___2 ;
  S cod___0 ;
  K tmp___3 ;
  I lenC___0 ;
  size_t tmp___4 ;
  I i___0 ;
  K q___0 ;
  K tmp___5 ;
  S sym___1 ;
  I lenS___1 ;
  size_t tmp___6 ;
  S cod___1 ;
  I lenC___1 ;
  size_t tmp___7 ;
  I i___1 ;
  K q___1 ;
  K tmp___8 ;
  S sym___2 ;
  I lenS___2 ;
  size_t tmp___9 ;
  S cod___2 ;
  K tmp___10 ;
  I lenC___2 ;
  size_t tmp___11 ;
  I i___2 ;
  K q___2 ;
  K tmp___12 ;
  K tmp___13 ;
  K tmp___14 ;
  K tmp___15 ;

  {
  res = (I )-1;
  if (y->t == -3LL) {
    res = ksender(*((I *)(x___0->k)), y, (I )0);
  } else
  if (y->t == 0LL) {
    if (y->n == 4LL) {
      if ((y->k[3])->t == 7LL) {
        if ((y->k[3])->n == 3LL) {
          if ((y->k[1])->t == 0LL) {
            if ((y->k[1])->n == 0LL) {
              if ((unsigned long )((y->k[2])->k[2])->k[0] == (unsigned long )offsetColon) {
                sym = *((S *)((y->k[0])->k));
                tmp = strlen((char const   *)sym);
                lenS = (I )tmp;
                cod = (C *)(((y->k[3])->k[2])->k);
                tmp___0 = strlen((char const   *)cod);
                lenC = (I )tmp___0;
                C str[(lenS + lenC) + 4LL] ;
                i = (I )0;
                i = (I )0;
                while (i < lenS) {
                  str[i] = *(sym + i);
                  i ++;
                }
                i = (I )0;
                while (i < lenC) {
                  str[(i + lenS) + 2LL] = *(cod + i);
                  i ++;
                }
                str[lenS] = (C )':';
                str[lenS + 1LL] = (C )'{';
                str[(lenS + lenC) + 2LL] = (C )'}';
                str[(lenS + lenC) + 3LL] = (C )'\000';
                tmp___1 = Ks(str);
                q = tmp___1;
                res = ksender(*((I *)(x___0->k)), q, (I )0);
                cd(q);
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            goto _L___15;
          }
        } else {
          goto _L___15;
        }
      } else {
        goto _L___15;
      }
    } else {
      goto _L___15;
    }
  } else
  _L___15: /* CIL Label */ 
  if (y->t == 0LL) {
    if (y->n == 4LL) {
      if ((y->k[3])->t == 7LL) {
        if ((y->k[3])->n == 1LL) {
          if ((y->k[1])->t == 0LL) {
            if ((y->k[1])->n == 0LL) {
              if ((unsigned long )((y->k[2])->k[2])->k[0] == (unsigned long )offsetColon) {
                sym___0 = *((S *)((y->k[0])->k));
                tmp___2 = strlen((char const   *)sym___0);
                lenS___0 = (I )tmp___2;
                tmp___3 = _5m(y->k[3]);
                cod___0 = (C *)(tmp___3->k);
                tmp___4 = strlen((char const   *)cod___0);
                lenC___0 = (I )tmp___4;
                C str___0[(lenS___0 + lenC___0) + 2LL] ;
                i___0 = (I )0;
                i___0 = (I )0;
                while (i___0 < lenS___0) {
                  str___0[i___0] = *(sym___0 + i___0);
                  i___0 ++;
                }
                i___0 = (I )0;
                while (i___0 < lenC___0) {
                  str___0[(i___0 + lenS___0) + 1LL] = *(cod___0 + i___0);
                  i___0 ++;
                }
                str___0[lenS___0] = (C )':';
                str___0[(lenS___0 + lenC___0) + 1LL] = (C )'\000';
                tmp___5 = Ks(str___0);
                q___0 = tmp___5;
                res = ksender(*((I *)(x___0->k)), q___0, (I )0);
                cd(q___0);
              } else {
                goto _L___9;
              }
            } else {
              goto _L___9;
            }
          } else {
            goto _L___9;
          }
        } else {
          goto _L___9;
        }
      } else {
        goto _L___9;
      }
    } else {
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
  if (y->t == 0LL) {
    if (y->n == 3LL) {
      if ((y->k[2])->t == 7LL) {
        if ((y->k[2])->n == 3LL) {
          if ((y->k[1])->t == 0LL) {
            if ((y->k[1])->n == 0LL) {
              sym___1 = *((S *)((y->k[0])->k));
              tmp___6 = strlen((char const   *)sym___1);
              lenS___1 = (I )tmp___6;
              cod___1 = (C *)(((y->k[2])->k[2])->k);
              tmp___7 = strlen((char const   *)cod___1);
              lenC___1 = (I )tmp___7;
              C str___1[(2LL * lenS___1 + lenC___1) + 4LL] ;
              i___1 = (I )0;
              i___1 = (I )0;
              while (i___1 < lenS___1) {
                str___1[i___1] = *(sym___1 + i___1);
                i___1 ++;
              }
              i___1 = (I )0;
              while (i___1 < lenC___1) {
                str___1[(i___1 + lenS___1) + 2LL] = *(cod___1 + i___1);
                i___1 ++;
              }
              i___1 = (I )0;
              while (i___1 < lenS___1) {
                str___1[((i___1 + lenS___1) + lenC___1) + 3LL] = *(sym___1 + i___1);
                i___1 ++;
              }
              str___1[lenS___1] = (C )':';
              str___1[lenS___1 + 1LL] = (C )'{';
              str___1[(lenS___1 + lenC___1) + 2LL] = (C )'}';
              str___1[(2LL * lenS___1 + lenC___1) + 3LL] = (C )'\000';
              tmp___8 = Ks(str___1);
              q___1 = tmp___8;
              res = ksender(*((I *)(x___0->k)), q___1, (I )0);
              cd(q___1);
            } else {
              goto _L___3;
            }
          } else {
            goto _L___3;
          }
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
  if (y->t == 0LL) {
    if (y->n == 3LL) {
      if ((y->k[2])->t == 7LL) {
        if ((y->k[2])->n == 1LL) {
          if ((y->k[1])->t == 0LL) {
            if ((y->k[1])->n == 0LL) {
              sym___2 = *((S *)((y->k[0])->k));
              tmp___9 = strlen((char const   *)sym___2);
              lenS___2 = (I )tmp___9;
              tmp___10 = _5m(y->k[2]);
              cod___2 = (C *)(tmp___10->k);
              tmp___11 = strlen((char const   *)cod___2);
              lenC___2 = (I )tmp___11;
              C str___2[(2LL * lenS___2 + lenC___2) + 2LL] ;
              i___2 = (I )0;
              i___2 = (I )0;
              while (i___2 < lenS___2) {
                str___2[i___2] = *(sym___2 + i___2);
                i___2 ++;
              }
              i___2 = (I )0;
              while (i___2 < lenC___2) {
                str___2[(i___2 + lenS___2) + 1LL] = *(cod___2 + i___2);
                i___2 ++;
              }
              i___2 = (I )0;
              while (i___2 < lenS___2) {
                str___2[((i___2 + lenS___2) + lenC___2) + 1LL] = *(sym___2 + i___2);
                i___2 ++;
              }
              str___2[lenS___2] = (C )':';
              str___2[(2LL * lenS___2 + lenC___2) + 1LL] = (C )'\000';
              tmp___12 = Ks(str___2);
              q___2 = tmp___12;
              res = ksender(*((I *)(x___0->k)), q___2, (I )0);
              cd(q___2);
            } else {
              tmp___13 = kerr("nyi");
              return (tmp___13);
            }
          } else {
            tmp___13 = kerr("nyi");
            return (tmp___13);
          }
        } else {
          tmp___13 = kerr("nyi");
          return (tmp___13);
        }
      } else {
        tmp___13 = kerr("nyi");
        return (tmp___13);
      }
    } else {
      tmp___13 = kerr("nyi");
      return (tmp___13);
    }
  } else {
    tmp___13 = kerr("nyi");
    return (tmp___13);
  }
  if (-1LL == res) {
    tmp___14 = kerr("domain");
    return (tmp___14);
  }
  tmp___15 = _n();
  return (tmp___15);
}
}
K popen_charvec(C *cmd ) 
{ 
  FILE *f ;
  K z ;
  K l ;
  S s ;
  I n ;
  K tmp ;
  I tmp___0 ;

  {
  s = (S )0;
  n = (I )0;
  f = popen((char const   *)cmd, "r");
  if (! f) {
    tmp = _n();
    return (tmp);
  }
  z = newK((I )0, (I )0);
  while (1) {
    tmp___0 = getline_(& s, & n, f);
    if (! (tmp___0 >= 0LL)) {
      break;
    }
    l = newK((I )-3, n - 1LL);
    strncpy((char * __restrict  )((C *)(l->k)), (char const   * __restrict  )s, (size_t )(n - 1LL));
    kap(& z, (V )(& l));
  }
  free((void *)s);
  pclose(f);
  return (z);
}
}
static void parse(S s , S *argv , C c ) 
{ 
  S tmp ;
  S *tmp___0 ;

  {
  while ((int )*s != 0) {
    while (1) {
      if (! ((int )*s == (int )c)) {
        if (! ((int )*s == 9)) {
          if (! ((int )*s == 10)) {
            break;
          }
        }
      }
      tmp = s;
      s ++;
      *tmp = (C )'\000';
    }
    tmp___0 = argv;
    argv ++;
    *tmp___0 = s;
    while (1) {
      if ((int )*s != 0) {
        if ((int )*s != (int )c) {
          if ((int )*s != 9) {
            if (! ((int )*s != 10)) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      s ++;
    }
  }
  *argv = (S )((void *)0);
  return;
}
}
static void execute(S *argvP , I fWait ) 
{ 
  pid_t pid ;
  I status ;
  int tmp ;
  __pid_t tmp___0 ;

  {
  pid = fork();
  if (pid < 0) {
    printf((char const   * __restrict  )"*** ERROR: forking child process failed\n");
    exit(1);
  } else
  if (pid == 0) {
    tmp = execvp((char const   *)*argvP, (char * const  *)argvP);
    if (tmp < 0) {
      printf((char const   * __restrict  )"*** ERROR: exec failed\n");
      exit(1);
    }
  } else
  if (fWait) {
    while (1) {
      tmp___0 = wait((int *)(& status));
      if (! (tmp___0 != pid)) {
        break;
      }
    }
  }
  return;
}
}
K _4d_(S srvr , S port___0 , K y ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *servinfo ;
  struct addrinfo *p ;
  int rv ;
  int sockfd ;
  S errstr ;
  I r ;
  char const   *tmp ;
  K tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  K tmp___3 ;
  int tmp___4 ;
  K tmp___5 ;
  I n ;
  size_t tmp___6 ;
  I i ;
  int tmp___7 ;
  K tmp___8 ;
  K tmp___9 ;
  size_t tmp___10 ;
  ssize_t tmp___11 ;
  C buf___1[20000] ;
  I size ;
  S data ;
  void *tmp___12 ;
  I n1 ;
  ssize_t tmp___13 ;
  int *tmp___14 ;
  void *tmp___15 ;
  int tmp___16 ;
  K tmp___17 ;
  K z ;
  int tmp___18 ;
  K tmp___19 ;
  K tmp___20 ;
  K tmp___21 ;

  {
  memset((void *)(& hints), 0, sizeof(hints));
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  rv = getaddrinfo((char const   * __restrict  )srvr, (char const   * __restrict  )port___0,
                   (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& servinfo));
  if (rv) {
    tmp = gai_strerror(rv);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"conn: %s\n",
            tmp);
    tmp___0 = kerr("domain");
    return (tmp___0);
  }
  p = servinfo;
  while ((unsigned long )p != (unsigned long )((void *)0)) {
    sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
    if (! (sockfd == -1)) {
      tmp___4 = connect(sockfd, (struct sockaddr  const  *)p->ai_addr, p->ai_addrlen);
      if (tmp___4 == -1) {
        tmp___1 = __errno_location();
        errstr = strerror(*tmp___1);
        tmp___2 = close(sockfd);
        r = (I )tmp___2;
        if (r) {
          tmp___3 = kerr("file");
          return (tmp___3);
        }
        goto __Cont;
      } else {
        break;
      }
    }
    __Cont: /* CIL Label */ 
    p = p->ai_next;
  }
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"conn: failed to connect (%s)\n",
            errstr);
    freeaddrinfo(servinfo);
    tmp___5 = kerr("domain");
    return (tmp___5);
  }
  tmp___6 = strlen((char const   *)((C *)(y->k)));
  n = (I )tmp___6;
  C msg[n + 5LL] ;
  i = (I )0;
  i = (I )0;
  while (i < n + 1LL) {
    msg[i] = *((C *)(y->k) + i);
    i ++;
  }
  msg[n] = (C )'\r';
  msg[n + 1LL] = (C )'\n';
  msg[n + 2LL] = (C )'\r';
  msg[n + 3LL] = (C )'\n';
  msg[n + 4LL] = (C )'\000';
  tmp___10 = strlen((char const   *)(msg));
  tmp___11 = write(sockfd, (void const   *)(& msg), tmp___10);
  if (tmp___11 == -1L) {
    tmp___7 = close(sockfd);
    r = (I )tmp___7;
    if (r) {
      tmp___8 = kerr("file");
      return (tmp___8);
    }
    tmp___9 = kerr("write");
    return (tmp___9);
  }
  size = (I )30000;
  tmp___12 = malloc((size_t )size);
  data = (S )tmp___12;
  n1 = (I )1;
  n = (I )0;
  while (1) {
    tmp___13 = read(sockfd, (void *)(& buf___1), (size_t )20000);
    n1 = (I )tmp___13;
    if (n1 == 0LL) {
      break;
    }
    if (n1 < 0LL) {
      tmp___14 = __errno_location();
      printf((char const   * __restrict  )"errno: %d\n", *tmp___14);
      return ((K )0);
    }
    if (n + n1 > size - 1LL) {
      size += 20000LL;
      tmp___15 = realloc((void *)data, (size_t )size);
      data = (S )tmp___15;
    }
    i = (I )0;
    while (i < n1 + 1LL) {
      *(data + (n + i)) = buf___1[i];
      i ++;
    }
    n += n1;
    if (! n1) {
      break;
    }
  }
  tmp___16 = close(sockfd);
  r = (I )tmp___16;
  if (r) {
    tmp___17 = kerr("file");
    return (tmp___17);
  }
  if (n == 1LL) {
    tmp___18 = 3;
  } else {
    tmp___18 = -3;
  }
  tmp___19 = newK((I )tmp___18, n);
  z = tmp___19;
  memcpy((void * __restrict  )((C *)(z->k)), (void const   * __restrict  )data, (size_t )n);
  freeaddrinfo(servinfo);
  free((void *)data);
  if (n) {
    tmp___21 = z;
  } else {
    tmp___20 = _n();
    tmp___21 = tmp___20;
  }
  return (tmp___21);
}
}
static K run(K x___0 ) 
{ 
  S line___0 ;
  S argvL[64] ;
  S argvP[64] ;
  I i ;
  I fWait ;
  int tmp ;
  K tmp___0 ;

  {
  line___0 = (C *)(x___0->k);
  fWait = (I )1;
  parse(line___0, argvL, (C )';');
  i = (I )0;
  while ((unsigned long )argvL[i] != (unsigned long )((void *)0)) {
    parse(argvL[i], argvP, (C )' ');
    if ((unsigned long )argvL[1] == (unsigned long )((void *)0)) {
      tmp = strcmp((char const   *)argvP[0], "echo");
      if (tmp != 0) {
        fWait = (I )0;
      }
    }
    execute(argvP, fWait);
    i ++;
  }
  tmp___0 = _n();
  return (tmp___0);
}
}
K _3d(K x___0 , K y ) 
{ 
  K tmp ;
  I tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  K tmp___4 ;
  K tmp___5 ;

  {
  if (x___0->t < 0LL) {
    tmp___0 = - x___0->t;
  } else {
    tmp___0 = x___0->t;
  }
  if (3LL == tmp___0) {
    tmp = _5d_(x___0, y, (I )0);
    return (tmp);
  }
  if (4LL == x___0->t) {
    if (! *(*((S *)(x___0->k)))) {
      tmp___1 = run(y);
      tmp___3 = tmp___1;
    } else {
      tmp___2 = _5d_(x___0, y, (I )0);
      tmp___3 = tmp___2;
    }
    return (tmp___3);
  }
  if (1LL != x___0->t) {
    tmp___4 = kerr("type");
    return (tmp___4);
  }
  tmp___5 = _3d_(x___0, y);
  return (tmp___5);
}
}
K _4d(K x___0 , K y ) 
{ 
  K tmp ;
  I sockfd ;
  K tmp___0 ;
  I tmp___1 ;
  K z ;
  K tmp___2 ;
  K tmp___3 ;
  C port___0[6] ;
  int n ;
  int tmp___4 ;
  K tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;

  {
  if (4LL == x___0->t) {
    if (! *(*((S *)(x___0->k)))) {
      if (-3LL == y->t) {
        tmp = popen_charvec((C *)(y->k));
        return (tmp);
      }
    }
  }
  if (1LL == x___0->t) {
    sockfd = *((I *)(x___0->k));
    tmp___1 = ksender(sockfd, y, (I )1);
    if (-1LL == tmp___1) {
      tmp___0 = kerr("domain");
      return (tmp___0);
    }
    z = (K )0;
    while (1) {
      if (2LL != fer) {
        z = read_tape(sockfd, sockfd, (I )1);
        if (z) {
          break;
        }
      } else {
        break;
      }
    }
    if ((unsigned long )z == (unsigned long )((K )-1)) {
      tmp___2 = kerr("domain");
      return (tmp___2);
    }
    if (! z) {
      return ((K )0);
    }
    return (z);
  }
  if (-4LL == x___0->t) {
    if (2LL == x___0->n) {
      tmp___3 = _4d_(*((S *)(x___0->k) + 0), *((S *)(x___0->k) + 1), y);
      return (tmp___3);
    }
  }
  if (0LL == x___0->t) {
    if (2LL == x___0->n) {
      if (4LL == (x___0->k[0])->t) {
        if (1LL == (x___0->k[1])->t) {
          if (0LL <= *((I *)((x___0->k[1])->k))) {
            tmp___4 = snprintf((char * __restrict  )(port___0), (size_t )6, (char const   * __restrict  )"%lld",
                               *((I *)((x___0->k[1])->k)));
            n = tmp___4;
            if (n >= 6) {
              tmp___5 = kerr("write");
              return (tmp___5);
            }
            tmp___6 = _4d_(*((S *)((x___0->k[0])->k)), port___0, y);
            return (tmp___6);
          }
        }
      }
    }
  }
  tmp___7 = kerr("type");
  return (tmp___7);
}
}
K _4m(K x___0 ) 
{ 
  K tmp ;

  {
  tmp = Ki(x___0->t);
  return (tmp);
}
}
K _5m(K x___0 ) 
{ 
  K z ;

  {
  z = newK((I )-3, (I )0);
  if (! z) {
    return ((K )0);
  }
  printAtDepth((V )(& z), x___0, (I )0, (I )0, (I )0, (I )0);
  return (z);
}
}
static K _5d_(K x___0 , K y , I dosync ) 
{ 
  I tmp ;
  S m ;
  S tmp___0 ;
  I sm ;
  size_t tmp___1 ;
  S e ;
  S tmp___2 ;
  S tmp___3 ;
  S tmp___4 ;
  struct stat c ;
  I f ;
  int tmp___5 ;
  int tmp___6 ;
  K tmp___7 ;
  I s ;
  I ft ;
  I fn ;
  I g ;
  ssize_t tmp___8 ;
  K tmp___9 ;
  ssize_t tmp___10 ;
  K tmp___11 ;
  I b___1 ;
  I tmp___12 ;
  I n ;
  int tmp___13 ;
  S v ;
  int *tmp___14 ;
  char *tmp___15 ;
  K tmp___16 ;
  void *tmp___17 ;
  I res ;
  int tmp___18 ;
  K tmp___19 ;
  I *w___0 ;
  I r ;
  V d___0 ;
  I i ;
  I _i___0 ;
  I tmp___20 ;
  I i___0 ;
  I _i___1 ;
  size_t tmp___21 ;
  int tmp___22 ;
  K tmp___23 ;
  K tmp___24 ;

  {
  if (4LL != x___0->t) {
    if (x___0->t < 0LL) {
      tmp = - x___0->t;
    } else {
      tmp = x___0->t;
    }
    if (3LL != tmp) {
      return ((K )0);
    }
  }
  tmp___0 = CSK(x___0);
  m = tmp___0;
  tmp___1 = strlen((char const   *)m);
  sm = (I )tmp___1;
  if (sm > 1LL) {
    if (46 == (int )*(m + (sm - 2LL))) {
      if ((int const   )*"K" == (int const   )*(m + (sm - 1LL))) {
        tmp___2 = strdupn(m, sm);
        tmp___4 = tmp___2;
      } else {
        tmp___3 = glueSS(m, (S )"K");
        tmp___4 = tmp___3;
      }
    } else {
      tmp___3 = glueSS(m, (S )"K");
      tmp___4 = tmp___3;
    }
  } else {
    tmp___3 = glueSS(m, (S )"K");
    tmp___4 = tmp___3;
  }
  e = tmp___4;
  if (! e) {
    return ((K )0);
  }
  tmp___5 = open((char const   *)e, 2, 4095);
  f = (I )tmp___5;
  if (f >= 0LL) {
    stat((char const   * __restrict  )e, (struct stat * __restrict  )(& c));
  } else {
    tmp___6 = open((char const   *)m, 2, 4095);
    f = (I )tmp___6;
    stat((char const   * __restrict  )m, (struct stat * __restrict  )(& c));
  }
  free((void *)e);
  if (f < 0LL) {
    tmp___7 = _1d_write(x___0, y, (I )1);
    return (tmp___7);
  }
  s = (I )c.st_size;
  if ((unsigned long long )s < (unsigned long long )(4UL * sizeof(I ))) {
    return ((K )0);
  }
  tmp___8 = pread((int )f, (void *)(& ft), sizeof(ft), (__off_t )(2UL * sizeof(I )));
  g = (I )tmp___8;
  if (! g) {
    tmp___9 = kerr("pread");
    show(tmp___9);
  }
  tmp___10 = pread((int )f, (void *)(& fn), sizeof(ft), (__off_t )(2UL * sizeof(I ) + sizeof(ft)));
  g = (I )tmp___10;
  if (! g) {
    tmp___11 = kerr("pread");
    show(tmp___11);
  }
  if (y->t > 0LL) {
    if (y->t != 5LL) {
      return ((K )0);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (ft != y->t) {
    return ((K )0);
  }
  tmp___12 = disk(y);
  b___1 = (I )(((unsigned long long )tmp___12 - (unsigned long long )(4UL * sizeof(I ))) - (unsigned long long )(-3LL == y->t));
  n = s + b___1;
  tmp___13 = ftruncate((int )f, (__off_t )n);
  if (tmp___13) {
    return ((K )0);
  }
  tmp___17 = mmap((void *)0, (size_t )n, 2, 1, (int )f, (__off_t )0);
  v = (S )tmp___17;
  if ((unsigned long )((void *)-1) == (unsigned long )v) {
    tmp___14 = __errno_location();
    tmp___15 = strerror(*tmp___14);
    tmp___16 = kerr((cS )tmp___15);
    return (tmp___16);
  }
  tmp___18 = close((int )f);
  res = (I )tmp___18;
  if (res) {
    tmp___19 = kerr("file");
    return (tmp___19);
  }
  w___0 = (I *)v;
  *(w___0 + 3) = fn + y->n;
  r = (I )0;
  d___0 = (V )(v + s);
  if (0LL == y->t) {
    goto _L___0;
  } else
  if (5LL == y->t) {
    _L___0: /* CIL Label */ 
    i = (I )0;
    _i___0 = y->n;
    while (i < _i___0) {
      tmp___20 = wrep(y->k[i], d___0 + r, (I )1);
      r += tmp___20;
      i ++;
    }
  } else
  if (-4LL == y->t) {
    i___0 = (I )0;
    _i___1 = y->n;
    while (i___0 < _i___1) {
      tmp___21 = strlen((char const   *)*((S *)(y->k) + i___0));
      s = (I )(1UL + tmp___21);
      memcpy((void * __restrict  )(d___0 + r), (void const   * __restrict  )*((S *)(y->k) + i___0),
             (size_t )s);
      r += s;
      i___0 ++;
    }
  } else
  if (-3LL == y->t) {
    memcpy((void * __restrict  )(d___0 - 1), (void const   * __restrict  )(y->k),
           (size_t )((unsigned long long )n * (unsigned long long )sizeof(C )));
    *((S )d___0 + y->n) = (C )0;
  } else
  if (-2LL == y->t) {
    memcpy((void * __restrict  )d___0, (void const   * __restrict  )(y->k), (size_t )((unsigned long long )y->n * (unsigned long long )sizeof(F )));
  } else
  if (-1LL == y->t) {
    memcpy((void * __restrict  )d___0, (void const   * __restrict  )(y->k), (size_t )((unsigned long long )y->n * (unsigned long long )sizeof(I )));
  }
  if (dosync) {
    msync((void *)v, (size_t )n, 6);
  }
  tmp___22 = munmap((void *)v, (size_t )n);
  res = (I )tmp___22;
  if (res) {
    tmp___23 = kerr("munmap");
    return (tmp___23);
  }
  tmp___24 = Ki(fn + y->n);
  return (tmp___24);
}
}
K _5d(K x___0 , K y ) 
{ 
  K tmp ;

  {
  tmp = _5d_(x___0, y, (I )1);
  return (tmp);
}
}
K _6m(K x___0 ) 
{ 
  K tmp ;

  {
  tmp = readVector(x___0, (I )-3);
  return (tmp);
}
}
static K readVector(K x___0 , I t ) 
{ 
  K tmp ;
  I tmp___0 ;
  I s ;
  int *tmp___1 ;
  char *tmp___2 ;
  K tmp___3 ;
  S tmp___4 ;
  I tmp___5 ;
  I f ;
  S tmp___6 ;
  int tmp___7 ;
  K tmp___8 ;
  S v ;
  int *tmp___9 ;
  char *tmp___10 ;
  K tmp___11 ;
  void *tmp___12 ;
  I r ;
  int tmp___13 ;
  K tmp___14 ;
  K z ;
  I tmp___15 ;
  double tmp___16 ;
  K tmp___17 ;
  int tmp___18 ;
  K tmp___19 ;

  {
  if (4LL != x___0->t) {
    if (x___0->t < 0LL) {
      tmp___0 = - x___0->t;
    } else {
      tmp___0 = x___0->t;
    }
    if (3LL != tmp___0) {
      tmp = kerr("type");
      return (tmp);
    }
  }
  tmp___4 = CSK(x___0);
  tmp___5 = stat_sz(tmp___4, & s);
  if (tmp___5) {
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    tmp___3 = kerr((cS )tmp___2);
    return (tmp___3);
  }
  tmp___6 = CSK(x___0);
  tmp___7 = open((char const   *)tmp___6, 0);
  f = (I )tmp___7;
  if (f < 0LL) {
    tmp___8 = kerr("domain");
    return (tmp___8);
  }
  tmp___12 = mmap((void *)0, (size_t )s, 1, 1, (int )f, (__off_t )0);
  v = (S )tmp___12;
  if ((unsigned long )((void *)-1) == (unsigned long )v) {
    tmp___9 = __errno_location();
    tmp___10 = strerror(*tmp___9);
    tmp___11 = kerr((cS )tmp___10);
    return (tmp___11);
  }
  tmp___13 = close((int )f);
  r = (I )tmp___13;
  if (r) {
    tmp___14 = kerr("file");
    return (tmp___14);
  }
  tmp___15 = bp(t);
  tmp___16 = ceil((F )s / (F )tmp___15);
  tmp___17 = newK(t, (I )tmp___16);
  z = tmp___17;
  memcpy((void * __restrict  )(z->k), (void const   * __restrict  )v, (size_t )s);
  tmp___18 = munmap((void *)v, (size_t )s);
  r = (I )tmp___18;
  if (r) {
    tmp___19 = kerr("munmap");
    return (tmp___19);
  }
  return (z);
}
}
K _6d(K a , K b___1 ) 
{ 
  I append ;
  K c ;
  I tmp ;
  I t ;
  I n ;
  K tmp___0 ;
  I tmp___1 ;
  S m ;
  S tmp___2 ;
  I f ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  I e ;
  int *tmp___6 ;
  char *tmp___7 ;
  K tmp___8 ;
  I tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  K tmp___12 ;
  I r ;
  ssize_t tmp___13 ;
  K tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  K tmp___17 ;
  int tmp___18 ;
  S v ;
  int *tmp___19 ;
  char *tmp___20 ;
  K tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;
  K tmp___24 ;
  int tmp___25 ;
  K tmp___26 ;
  K tmp___27 ;

  {
  append = (I )0;
  c = a;
  if (0LL == a->t) {
    if (1LL == a->n) {
      append = (I )1;
      c = a->k[0];
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (-4LL == c->t) {
    if (1LL == c->n) {
      append = (I )1;
    }
  }
  if (4LL != c->t) {
    if (c->t < 0LL) {
      tmp = - c->t;
    } else {
      tmp = c->t;
    }
    if (3LL != tmp) {
      if (! append) {
        if (-4LL == c->t) {
          return ((K )0);
        }
      }
    }
  }
  t = b___1->t;
  n = b___1->n;
  if (t < 0LL) {
    tmp___1 = - t;
  } else {
    tmp___1 = t;
  }
  if (3LL != tmp___1) {
    tmp___0 = kerr("type");
    return (tmp___0);
  }
  tmp___2 = CSK(c);
  m = tmp___2;
  if (*(m + 0)) {
    if (append) {
      tmp___3 = 0;
    } else {
      tmp___3 = 512;
    }
    tmp___4 = open((char const   *)m, 66 | tmp___3, 4095);
    tmp___5 = tmp___4;
  } else {
    tmp___5 = 1;
  }
  f = (I )tmp___5;
  e = (I )0;
  if (append) {
    if (*(m + 0)) {
      tmp___9 = stat_sz(m, & e);
      if (tmp___9) {
        tmp___6 = __errno_location();
        tmp___7 = strerror(*tmp___6);
        tmp___8 = kerr((cS )tmp___7);
        return (tmp___8);
      }
    }
  }
  if (f < 0LL) {
    tmp___10 = __errno_location();
    tmp___11 = strerror(*tmp___10);
    tmp___12 = kerr((cS )tmp___11);
    return (tmp___12);
  }
  if (1LL == f) {
    tmp___13 = write((int )f, (void const   *)((C *)(b___1->k)), (size_t )n);
    r = (I )tmp___13;
    if (! r) {
      tmp___14 = kerr("write");
      show(tmp___14);
    }
  } else {
    tmp___18 = ftruncate((int )f, (__off_t )(e + n));
    if (tmp___18) {
      tmp___15 = __errno_location();
      tmp___16 = strerror(*tmp___15);
      tmp___17 = kerr((cS )tmp___16);
      return (tmp___17);
    }
    tmp___22 = mmap((void *)0, (size_t )(e + n), 2, 1, (int )f, (__off_t )0);
    v = (S )tmp___22;
    if ((unsigned long )((void *)-1) == (unsigned long )v) {
      tmp___19 = __errno_location();
      tmp___20 = strerror(*tmp___19);
      tmp___21 = kerr((cS )tmp___20);
      return (tmp___21);
    }
    tmp___23 = close((int )f);
    r = (I )tmp___23;
    if (r) {
      tmp___24 = kerr("file");
      return (tmp___24);
    }
    memcpy((void * __restrict  )(v + e), (void const   * __restrict  )((C *)(b___1->k)),
           (size_t )n);
    msync((void *)(v + e), (size_t )n, 6);
    tmp___25 = munmap((void *)v, (size_t )(e + n));
    r = (I )tmp___25;
    if (r) {
      tmp___26 = kerr("munmap");
      return (tmp___26);
    }
  }
  tmp___27 = _n();
  return (tmp___27);
}
}
K _3m(K x___0 ) 
{ 
  I i ;
  int tmp ;
  K tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  S host ;
  S tmp___4 ;
  S errstr ;
  char port___0[256] ;
  int sockfd ;
  int rv ;
  struct addrinfo hints ;
  struct addrinfo *servinfo ;
  struct addrinfo *p ;
  I r ;
  char const   *tmp___5 ;
  K tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  K tmp___9 ;
  int tmp___10 ;
  K tmp___11 ;
  I yes ;
  K tmp___12 ;

  {
  if (1LL == x___0->t) {
    tmp = close((int )*((I *)(x___0->k)));
    i = (I )tmp;
    if (i) {
      tmp___0 = kerr("domain");
      tmp___2 = tmp___0;
    } else {
      tmp___1 = _n();
      tmp___2 = tmp___1;
    }
    return (tmp___2);
  } else
  if (x___0->t) {
    tmp___3 = kerr("type");
    return (tmp___3);
  } else
  if (x___0->n != 2LL) {
    tmp___3 = kerr("type");
    return (tmp___3);
  } else
  if ((x___0->k[0])->t != 4LL) {
    tmp___3 = kerr("type");
    return (tmp___3);
  } else
  if ((x___0->k[1])->t != 1LL) {
    tmp___3 = kerr("type");
    return (tmp___3);
  }
  tmp___4 = CSK(x___0->k[0]);
  host = tmp___4;
  snprintf((char * __restrict  )(port___0), (size_t )256, (char const   * __restrict  )"%lld",
           *((I *)((x___0->k[1])->k)));
  memset((void *)(& hints), 0, sizeof(hints));
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  rv = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(port___0),
                   (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& servinfo));
  if (rv) {
    tmp___5 = gai_strerror(rv);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"conn: %s\n",
            tmp___5);
    tmp___6 = kerr("domain");
    return (tmp___6);
  }
  p = servinfo;
  while ((unsigned long )p != (unsigned long )((void *)0)) {
    sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
    if (! (sockfd == -1)) {
      tmp___10 = connect(sockfd, (struct sockaddr  const  *)p->ai_addr, p->ai_addrlen);
      if (tmp___10 == -1) {
        tmp___7 = __errno_location();
        errstr = strerror(*tmp___7);
        tmp___8 = close(sockfd);
        r = (I )tmp___8;
        if (r) {
          tmp___9 = kerr("file");
          return (tmp___9);
        }
        goto __Cont;
      } else {
        break;
      }
    }
    __Cont: /* CIL Label */ 
    p = p->ai_next;
  }
  if (! p) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"conn: failed to connect (%s)\n",
            errstr);
    freeaddrinfo(servinfo);
    tmp___11 = kerr("domain");
    return (tmp___11);
  }
  yes = (I )1;
  setsockopt(sockfd, 6, 1, (void const   *)(& yes), (socklen_t )sizeof(I ));
  freeaddrinfo(servinfo);
  wipe_tape((I )sockfd);
  tmp___12 = Ki((I )sockfd);
  return (tmp___12);
}
}
#pragma merger("0","/tmp/cil-CkqJYcJQ.i","-g,-pthread,-O3")
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 


  {
  return (((((__bsx & 4278190080U) >> 24) | ((__bsx & 16711680U) >> 8)) | ((__bsx & 65280U) << 8)) | ((__bsx & 255U) << 24));
}
}
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 


  {
  return ((__uint64_t )((((((((((unsigned long long )__bsx & 18374686479671623680) >> 56) | (((unsigned long long )__bsx & 71776119061217280ULL) >> 40)) | (((unsigned long long )__bsx & 280375465082880ULL) >> 24)) | (((unsigned long long )__bsx & 1095216660480ULL) >> 8)) | (((unsigned long long )__bsx & 4278190080ULL) << 8)) | (((unsigned long long )__bsx & 16711680ULL) << 24)) | (((unsigned long long )__bsx & 65280ULL) << 40)) | (((unsigned long long )__bsx & 255ULL) << 56)));
}
}
V membswp32(V d___0 , V s , I n ) 
{ 
  uint32_t *q ;
  uint32_t *p ;
  I i ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
  q = (uint32_t *)d___0;
  p = (uint32_t *)s;
  i = (I )0;
  while (i < n) {
    tmp = q;
    q ++;
    tmp___0 = p;
    p ++;
    *tmp = __bswap_32(*tmp___0);
    i += 4LL;
  }
  return (d___0);
}
}
V membswp64(V d___0 , V s , I n ) 
{ 
  uint64_t *q ;
  uint64_t *p ;
  I i ;
  uint64_t *tmp ;
  uint64_t *tmp___0 ;

  {
  q = (uint64_t *)d___0;
  p = (uint64_t *)s;
  i = (I )0;
  while (i < n) {
    tmp = q;
    q ++;
    tmp___0 = p;
    p ++;
    *tmp = __bswap_64(*tmp___0);
    i += 8LL;
  }
  return (d___0);
}
}
I bswapI(I n ) 
{ 
  __uint64_t tmp ;

  {
  tmp = __bswap_64((__uint64_t )n);
  return ((I )tmp);
}
}
V membswpI(V d___0 , V s , I n , I x___0 ) 
{ 
  V tmp ;
  void *tmp___0 ;

  {
  if (x___0) {
    tmp = membswp64(d___0, s, n);
    return (tmp);
  }
  tmp___0 = memcpy((void * __restrict  )d___0, (void const   * __restrict  )s, (size_t )n);
  return (tmp___0);
}
}
V membswpF(V d___0 , V s , I n , I x___0 ) 
{ 
  V tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  if (x___0) {
    tmp = membswp64(d___0, s, n);
    tmp___1 = tmp;
  } else {
    tmp___0 = memcpy((void * __restrict  )d___0, (void const   * __restrict  )s, (size_t )n);
    tmp___1 = tmp___0;
  }
  return (tmp___1);
}
}
#pragma merger("0","/tmp/cil-tGZwzwBf.i","-g,-pthread,-O3")
extern int system(char const   *__command ) ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
I fError ;
I fer1 ;
void boilerplate(void) ;
I prompt(I n ) ;
K enumerate(K a ) ;
K wd(S s , int n ) ;
K ex(K a ) ;
K X(S s ) ;
C PPON ;
I PPMAX ;
I PP ;
S d_ ;
I SEED ;
K KTREE ;
void seedPRNG(I s ) ;
I StoI(S s , I *n ) ;
K backslash(S s , I n , K *dict ) ;
I fCmplt ;
K precision(UI n ) ;
I wds(K *a , FILE *f ) ;
I wds_(K *a , FILE *f , I l ) ;
I lines(FILE *f ) ;
K load(S s ) ;
I oerr(void) ;
I tmr_ival ;
C khome[4097] ;
I fLoad  =    (I )0;
K *denameD(K *d___0 , S t , I create ) ;
static K filexist(S s ) ;
static K backslash_b(S s , I n ) ;
static K backslash_d(S s , I n , K *dict ) ;
static K backslash_e(S s , I n ) ;
static K backslash_s(S s ) ;
static K backslash_t(S s ) ;
static K backslash_v(S s , I n , K *dict ) ;
static K backslash_w(S s ) ;
static K precision_(void) ;
I scrLim ;
I fError  =    (I )1;
I fWksp  =    (I )0;
S fBreak  =    (S )"t";
void boilerplate(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = fileno(stdout);
  tmp___0 = isatty(tmp);
  if (tmp___0) {
    tmp___1 = fileno(stdin);
    tmp___2 = isatty(tmp___1);
    if (! tmp___2) {
      return;
    }
  } else {
    return;
  }
  printf((char const   * __restrict  )"kona      \\ for help. \\\\ to exit.\n\n");
  return;
}
}
static K filexist(S s ) 
{ 
  FILE *f ;
  C b___1[4097] ;
  S p ;
  I n ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  K kp ;
  size_t tmp___2 ;
  K tmp___3 ;
  I tmp___4 ;

  {
  n = (I )0;
  strcpy((char * __restrict  )(b___1), (char const   * __restrict  )s);
  recheck: 
  tmp = strstr((char const   *)(b___1), ".k");
  if (tmp) {
    f = fopen((char const   * __restrict  )(b___1), (char const   * __restrict  )"r");
    if (f) {
      p = b___1;
      goto cleanup;
    }
  }
  strcat((char * __restrict  )(b___1), (char const   * __restrict  )".k");
  f = fopen((char const   * __restrict  )(b___1), (char const   * __restrict  )"r");
  if (f) {
    p = b___1;
    goto cleanup;
  }
  if (! n) {
    tmp___0 = strlen((char const   *)(khome));
    n = (I )tmp___0;
    tmp___1 = strlen((char const   *)s);
    if (((unsigned long long )n + (unsigned long long )tmp___1) + 2ULL > 4096ULL) {
      return ((K )0);
    }
    strcpy((char * __restrict  )(b___1), (char const   * __restrict  )(khome));
    strcpy((char * __restrict  )(b___1 + n), (char const   * __restrict  )s);
    goto recheck;
  }
  return ((K )0);
  cleanup: 
  fclose(f);
  tmp___2 = strlen((char const   *)p);
  tmp___3 = newK((I )-3, (I )tmp___2);
  kp = tmp___3;
  tmp___4 = OOM_CD((I )0, kp, (V )-1);
  if (! tmp___4) {
    return ((K )0);
  }
  strcpy((char * __restrict  )((C *)(kp->k)), (char const   * __restrict  )p);
  return (kp);
}
}
static FILE *loadf(S s ) 
{ 
  FILE *f ;
  K p ;
  K tmp ;
  K tmp___0 ;

  {
  f = (FILE *)0;
  tmp = filexist(s);
  p = tmp;
  if (p) {
    f = fopen((char const   * __restrict  )((C *)(p->k)), (char const   * __restrict  )"r");
  }
  if (! p) {
    tmp___0 = kerr("file");
    show(tmp___0);
  } else
  if (! f) {
    tmp___0 = kerr("file");
    show(tmp___0);
  }
  cd(p);
  return (f);
}
}
K load(S s ) 
{ 
  I ofLoad ;
  I ofCmplt ;
  S old_ ;
  K r ;
  K tmp ;
  FILE *f ;
  FILE *tmp___0 ;
  int tmp___1 ;

  {
  ofLoad = fLoad;
  ofCmplt = fCmplt;
  fLoad = (I )1;
  fCmplt = (I )0;
  old_ = d_;
  tmp = filexist(s);
  if (! tmp) {
    printf((char const   * __restrict  )"%s: file not found\n", s);
    r = _n();
    goto cleanup;
  }
  if (scrLim > 124LL) {
    printf((char const   * __restrict  )"limit\n");
    r = kerr("stack");
    goto cleanup;
  }
  scrLim ++;
  tmp___0 = loadf(s);
  f = tmp___0;
  if (! f) {
    printf((char const   * __restrict  )"%s.k: file not found\n", s);
    r = kerr("file");
    goto cleanup;
  }
  lines(f);
  tmp___1 = fclose(f);
  if (tmp___1) {
    r = kerr("file");
    goto cleanup;
  }
  scrLim --;
  if (fCmplt == 1LL) {
    kerr("open-in-next-line");
    oerr();
  }
  kerr("(nil)");
  fer1 = (I )0;
  fer = fer1;
  r = _n();
  cleanup: 
  fLoad = ofLoad;
  fCmplt = ofCmplt;
  d_ = old_;
  return (r);
}
}
I stepopt(S s , I n ) 
{ 


  {
  if (n == 1LL) {
    if ((int )*s == 10) {
      return ((I )0);
    } else {
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
  if (n == 1LL) {
    if ((int )*s == 47) {
      return ((I )1);
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (n == 2LL) {
    if ((int )*s == 47) {
      if ((int )*(s + 1) == 10) {
        return ((I )1);
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (n == 1LL) {
    if ((int )*s == 92) {
      return ((I )2);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (n == 2LL) {
    if ((int )*s == 92) {
      if ((int )*(s + 1) == 10) {
        return ((I )2);
      } else {
        return ((I )3);
      }
    } else {
      return ((I )3);
    }
  } else {
    return ((I )3);
  }
}
}
K precision(UI n ) 
{ 
  K tmp ;
  K tmp___0 ;

  {
  if (n > (UI )PPMAX) {
    tmp = kerr("domain");
    return (tmp);
  }
  PPON = (C )(n != 0ULL);
  if (PPON) {
    PP = (I )n;
  } else {
    PP = PPMAX;
  }
  tmp___0 = _n();
  return (tmp___0);
}
}
static K precision_(void) 
{ 
  I tmp ;
  K tmp___0 ;

  {
  if (PPON) {
    tmp = PP;
  } else {
    tmp = (I )0;
  }
  tmp___0 = Ki(tmp);
  return (tmp___0);
}
}
K backslash(S s , I n , K *dict ) 
{ 
  S t ;
  C b___1 ;
  K tmp ;
  int tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  K tmp___4 ;
  K tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  K tmp___8 ;
  K tmp___9 ;
  K tmp___10 ;
  K tmp___11 ;
  K tmp___12 ;
  K tmp___13 ;
  K tmp___14 ;
  K tmp___15 ;
  I p ;
  K tmp___16 ;
  I tmp___17 ;
  K tmp___18 ;
  K tmp___19 ;
  I r ;
  K tmp___20 ;
  I tmp___21 ;
  K tmp___22 ;
  K tmp___23 ;
  K tmp___24 ;
  K tmp___25 ;
  K tmp___26 ;
  K tmp___27 ;
  K tmp___28 ;
  unsigned short const   **tmp___29 ;
  unsigned short const   **tmp___30 ;
  K tmp___32 ;
  K tmp___33 ;
  K tmp___34 ;
  int tmp___35 ;

  {
  if (1LL == n) {
    printf((char const   * __restrict  )"Backslash Commands:\n\\0        datatypes help\n\\+        verb help\n\\\'        adverb help\n\\:        I/O verb help\n\\_        reserved word help\n\\.        assignment/amend, function, control flow help\n\\b [s|t]  show/set break mode (stop|trace|none)\n\\d [d|^]  change k directory (^=previous)\n\\e [n]    show/set error flag (0=off,1=on,2=exit)\n\\l f      load script f or f.k\n\\p [n]    show/set print precision (0=full)\n\\r [s]    show/set random seed (0=random)\n\\s f      step script f or f.k\n\\t [n]    show/set timer interval in msec (0=disable)\n          calls niladic .m.ts\n\\t e      measure runtime of some k expression\n\\v [d|^]  show k directory (^=previous)\n\\w        show workspace resources used\n\\[cmd]    system command (also \\[ cmd]), \\echo hello\n\\\\        exit (or ctrl+d)\n");
    tmp = _n();
    return (tmp);
  } else {
    b___1 = *(s + 2);
    if (b___1) {
      tmp___29 = __ctype_b_loc();
      if ((int const   )*(*tmp___29 + (int )b___1) & 8192) {
        _L: /* CIL Label */ 
        if (b___1) {
          tmp___0 = 3;
        } else {
          tmp___0 = 2;
        }
        t = s + tmp___0;
        switch ((int )*(s + 1)) {
        case 92: 
        exit(0);
        break;
        case 39: 
        printf((char const   * __restrict  )"Adverbs / \\ \' /: \\: \':\nUse adverbs in conjunction with verbs/functions\nOver and scan behave differently depending on whether their left argument\nis monadic or dyadic.\n/  over dyad    +/1 2 3  or 4+/1 2 3    */1+!5\n\\  scan dyad    +\\3 4 5  or 6+\\3 4 5    *\\10#2\n/  over monad   apply until fixed    f/x    (%%[;2.0])/9999.0 \n/  over monad   apply n times      n f/x    4 (2+)/0 \n/  over monad   apply while true   b f/x    {x<10} {x+1}/ 3\n\\  scan monad   trace until repeat   f\\x    (1!)\\1 2 3 4\n\\  scan monad   trace n times      n f\\x    10(|+\\)\\1 1\n/  over         {x+y+z}/[1 2 3;4;7 8 9]  f/[x;y;z]\n\\  scan         {x+y+z}[1 2 3;4;7 8 9]  f\\[x;y;z]\n/  join         \",\"/(\"a\";\"b\")\n\\  split        \",\"\\\"a,b\"\n\'  each         \"abc\" ,\' \"def\"    join each  \n\'  each         !:\' 2 3 4    enumerate each  \n/: eachright    2 #/: (\"alpha\";\"bravo\";\"charlie\")    take each right\n\\: eachleft     0 1 2 3 #\\: \"abc\"     take each left\n\': eachpair     apply pairwise  -\':1 3 4 8 10\n");
        tmp___1 = _n();
        return (tmp___1);
        break;
        case 43: 
        printf((char const   * __restrict  )"Verbs +-*%%|&^!<>=~@?_,#$.:\nVerbs work on all sensible types (ints, floats, strings, symbols, lists)\nDyadic or monadic is determined from context, default is dyadic\nAdd : after a verb to force the monadic form, + is plus, +: is flip\n+ monadic  flip. transpose a matrix (a depth-2 list)\n+ dyadic   plus. add numbers together\n- monadic  negate. invert sign\n- dyadic   minus. subtraction\n* monadic  first. first element from the list\n* dyadic   times. multiply two numbers\n%% monadic  reciprocal. 1 over x \n%% dyadic   divide. x divided by y (not mod) \n| monadic  reverse. reverse order of list\n| dyadic   max/or. MAX(x,y) or OR(x,y) \n& monadic  where. &0 0 1 0 3 yields 2 4 4 4. \n& dyadic   min/and. MIN(x,y) or AND(x,y) \n^ monadic  shape. #elts at each depth (min over) \n^ dyadic   power. x to the exponent y \n! monadic  enumerate. !4 yields 0 1 2 3\n! dyadic   mod/rotate. 5!3 yields 2;  1 ! 4 5 6 yields 5 6 4 \n< monadic  grade up. indices of list sorted ascending \n< dyadic   less. boolean is x less than y\n> monadic  grade down. indices of list sorted descending\n> dyadic   more. boolean is x greater than y\n= monadic  group. =3 4 3 4 4 yields (0 2;1 3 4)  \n= dyadic   equals. 1 2 3 = 1 2 4 yields 1 1 0 (tolerantly) \n~ monadic  not. ~ 0 1 0 2 0 yields 1 0 1 0 1 \n~ dyadic   match. 1 2 ~ 1 2 yields 1 (types must match)\n@ monadic  atom. boolean is arg an atom (as opposed to a list) \n@ dyadic   at. elts from x at indices y\n@ triadic  monadic amend. see \\. \n@ tetradic dyadic amend. see \\.\n? monadic  unique. distinct elts from a list \n? dyadic   find. x?y yields index of y in list x (or #x)\n? dyadic   invert. {x^2} ? 2 yields sqrt(2) \n? triadic  invert-guess. secant method with clues ?[{2^x};17;4]\n_ monadic  floor. tolerant floor function \n_ dyadic   drop/cut. lose x elts from list y / separate into pieces \n, monadic  enlist. put x inside a 1-element list \n, dyadic   join. \"ab\",\"cd\" yields \"abcd\"\n# monadic  count. number of elements in list \n# dyadic   take/reshape. fill x elts from y \n$ monadic  format. cast to string \n$ dyadic   form/format. cast \n. monadic  execute/make dictionary. .\"1+1\" yields 2 \n. dyadic   value. 1 2 3 . ,2 yields 3. see \\. \n. triadic  monadic amend. see \\. \n. tetradic dyadic amend. see \\. \n:          overloaded with many operations. \n");
        tmp___2 = _n();
        return (tmp___2);
        break;
        case 46: 
        printf((char const   * __restrict  )"Assign/Amend, Functions, Control Flow \n\nAssign/Amend (see https://github.com/kevinlawler/kona/wiki/Amend)\na:1 is assignment\na::1 is global assignment (works in functions)\na+:1 is like a+=1, works in general\na-: negates a in place, works in general\na[]:1 sets all the entries of a to 1\na[0]:1 sets the 0th entry of a to 1\na[0;1]+:2 increments the 0th entry\'s 1st entry by 2\n.[a;();+;1] returns a+1 but does not affect a on the K Tree\n.[`a;();+;1] updates a in place, returns `a\n\nAmend Equivalence\n@[a;b;c;d] is .[a;,b;c;d]\na:1        is .[`a;();:;1]\na+:1       is .[`a;();+;1]\na-:        is .[`a;();-:]\na[]:1      is .[`a;_n;:;1]\na[0]:1     is .[`a;0;:;1] or .[`a;,0;:;1] \na[0;1]+:2  is .[`a;0 1;+;2]\n\nError Trap\n@[a;b;:] and .[a;b;:] are error trap\n\nFunctions\nf:{[a;b;c] a+b+c} defines a function. f[1;2;3] yields 6\nFunctions may be anonymous.\nFunctions may have default arguments x,y,z.\nSo {x^2} 3 conveniently yields 9\n\nControl Flow\n:[x1;t1;x2;t2;...;xn;tn;else] evaluate xi until true and return ti, otherwise return else \n    :[0;10;0;20;1;30;40] yields 30\nif[x;e1;...;en] if x then evaluate all e. if[j>i;a:1;b:2] \ndo[m;e1;...;en] do all e m times. do[100;f[i];i+:1] \nwhile[x;e1;...;en] while x do e.  while[a>b; f a; a-:1] \n/ starts a comment. Must begin a line or have a space before\n\\ is trace when beginning an expression inside a function (todo)\n: is early return when beginning an expression inside a function\n\' is signal (todo)\n");
        tmp___3 = _n();
        return (tmp___3);
        break;
        case 95: 
        printf((char const   * __restrict  )"Constants:\n(Note: the K epoch is 2035-01-01T00:00:00)\n_T       [current UTC Julian day count]+[fraction complete]\n_a       arguments\n_c       message source address\n_d       K-Tree path / current working dictionary\n_f       anonymous reference to current function\n_h       host name\n_i       index of current amendment\n_k       build date as string\n_n       nil\n_p       host port\n_s       space used allocated mmapped max\n_t       current UTC time (int)\n_v       current global variable under amendment\n_w       message source handle\n\nMonadic Verbs:\n_acos    inverse cosine\n_asin    inverse sine\n_atan    inverse tangent\n_ceil    ceiling (intolerant)\n_ceiling ceiling (tolerant)\n_cos     cosine\n_cosh    hyperbolic cosine\n_exp     exponential\n_floor   largest previous integer (intolerant)\n_log     natural logarithm\n_sin     sine\n_sinh    hyperbolic sine\n_sqr     square\n_sqrt    square root\n_tan     tangent\n_tanh    hyperbolic tangent\n_abs     absolute value\n_bd      convert to binary representation\n_ci      char-of-int (octal if unprintable char)\n_db      construct from binary representation\n_dj      date from Julian day count\n_exit    exit with status x\n_getenv  get an environment variable\n_gtime   in UTC, ints: YYYMMDD,HHMMSS (_gtime _t)\n_host    host name IP address (int)\n_ic      int-of-char\n_inv     inverse of a matrix\n_jd      Julian day count from date _jd 20110315\n_lt      convert output of _t to local time\n_ltime   localized version of _gtime\n_size    size of file (bytes)\n\nDyadic Verbs:\n_bin     index of element using binary search\n_binl    search for several elements\n_di      delete element at index\n_dot     dot product\n_draw    draw x random numbers from 0 to y-1, negative y indicates without replacement\n_dv      delete value\n_dvl     delete several values\n_hash    hash, (x;_hash x)?y\n_hat     caret/without, x _hat y\n_in      true if x is in y\n_lin     _in for several values\n_lsq     matrix division\n_mul     matrix multiplication\n_setenv  set environment variable\n_sm      string match\n_ss      positions of substring y in string x\n_sv      scalar from vector with base change\n_vs      vector from scalar with base change\n_vsx     vector from scalar with base change - extended\n\nTriadic Verbs:\n_ssr     string search & replace\n");
        tmp___4 = _n();
        return (tmp___4);
        break;
        case 48: 
        printf((char const   * __restrict  )"Datatypes  -4 -3 -2 -1 0 1 2 3 4 5 6 7\nMonadic 4: reveals type, 4:1 2 3 yields -1\n-4 vector symbol     `a`b`c or ,`a\n-3 vector character  \"abc\" or ,\"c\" \n-2 vector float      1.0 2.0 3.33 or ,1.0\n-1 vector integer    1 2 3 or ,1\n 0 list   general    (`a;1 2 3) or (`a;(1 2 3;(3 4;\"c\")))\n 1 scalar integer    1\n 2 scalar float      1.0\n 3 scalar character  \"c\" \n 4 scalar symbol     `s\n 5 dictionary        .((`a;10;);(`b;20;))  or  .()  or  .,(`a;5;) \n 6 nil               _n or (;;) (list of 3 nils)  \n 7 verbs/functions   +  +: {1+x}  +[1;]  (|+)  {[a;b]1+a+b}  {x+y}[1;]\nEmpty Lists:\n-4 0#`\n-3 \"\"\n-2 0#0.0\n-1 !0\n 0 ()\nSpecial numeric types:\n 0N null integer\n 0n null float\n-0I infinity integer negative\n 0I infinity integer positive\n-0i infinity float   negative\n 0i infinity float   positive\nDictionaries:\nStart by making a dictionary d[`k]:4\nd[]   values\n!d    keys\nd[`k] value at k\nd@`k  value at k\n");
        tmp___5 = _n();
        return (tmp___5);
        break;
        case 58: 
        printf((char const   * __restrict  )"I/O Verbs 0: 1: 2: 3: 4: 5: 6:\n\nDisk\n0: dyadic   write text file `f 0: \"hello\" \n0: monadic  read text file  0: `f\n1: dyadic   write binary file `f 1: 4 5 6 \n1: monadic  read binary file  1: `f (mmapped)\n2: monadic  read binary file  2: `f (copied to memory)\n3: dyadic   append to binary file, w/o sync `f 3: ,7\n5: dyadic   append to binary file `f 5: ,7\n6: dyadic   write raw byte string `f 6: \"\\01\\02\\03\"\n6: monadic  read raw byte string  6: `f\n\nNetwork\nStart k listening for IPC on port 1234  ./k -i 1234\n3: monadic  open handle    h: 3:(`\"192.168.1.101\";1234) \n3: monadic  close handle   3: h \n            exec .m.c expression\n3: dyadic   asynchronous send, returns _n      h 3: \"a:2\"\n            calls monadic .m.s msg handler\n4: dyadic   synchronous send, returns result   h 4: \"1+1\"\n            calls monadic .m.g msg handler\n\nOther\n0: dyadic   write to console `0: \"hello\\n\" \n2: dyadic   dynamically load C function  a:`libfile 2:(`func,3); a[1;2;3]\n4: monadic  type of data [-4,7],  4: \"c\" /returns 3\n5: monadic  printed representation. 5:1 2 3 /returns \"1 2 3\"\n\n0: and 1: both have versions for reading fields\nIn all cases `f can instead be (`f;start;length)\nRead fixed-width fields: \"cbsijfd IFCSDTZMm\" (\" \" is ignore)\n(types;widths)0:`f    (\"IFC\";3 5 4)0:`f  /read rows like \"20 30.1 golf\\n\" \n(types;widths)1:`f \n\"c\" 1:`f for c in \"cid\", read bytes/ints/doubles\nLoad delimited text file (no column names):\n(types;delim)0:`f    \nLoad delimited text file (with column names):\n(types;,delim)0:`f   \nc 1-byte char, b 1-byte int, s 2-byte int, i 4-byte int, f 4-byte float,\nd 8-byte double, \" \" 1-byte skip, I int, F float, C string, S string (sym), DTZMm Y? \n");
        tmp___6 = _n();
        return (tmp___6);
        break;
        case 96: 
        tmp___7 = kerr("nyi");
        return (tmp___7);
        break;
        case 97: 
        tmp___8 = kerr("nyi");
        return (tmp___8);
        break;
        case 98: 
        tmp___9 = backslash_b(s, n);
        return (tmp___9);
        break;
        case 99: 
        tmp___10 = kerr("nyi");
        return (tmp___10);
        break;
        case 100: 
        tmp___11 = backslash_d(s, n, dict);
        return (tmp___11);
        break;
        case 101: 
        tmp___12 = backslash_e(s, n);
        return (tmp___12);
        break;
        case 105: 
        tmp___13 = kerr("nyi");
        return (tmp___13);
        break;
        case 108: 
        tmp___14 = load(t);
        return (tmp___14);
        break;
        case 109: 
        tmp___15 = kerr("nyi");
        return (tmp___15);
        break;
        case 112: 
        if (*t) {
          tmp___17 = StoI(t, & p);
          if (! tmp___17) {
            tmp___16 = kerr("type");
            return (tmp___16);
          }
          tmp___18 = precision((UI )p);
          return (tmp___18);
        } else {
          tmp___19 = precision_();
          return (tmp___19);
        }
        break;
        case 114: 
        if (*t) {
          tmp___21 = StoI(t, & r);
          if (! tmp___21) {
            tmp___20 = kerr("type");
            return (tmp___20);
          }
          seedPRNG(r);
          tmp___22 = _n();
          return (tmp___22);
        } else {
          seedPRNG(SEED);
          tmp___23 = Ki(SEED);
          return (tmp___23);
        }
        break;
        case 115: 
        tmp___24 = backslash_s(t);
        return (tmp___24);
        break;
        case 116: 
        tmp___25 = backslash_t(t);
        return (tmp___25);
        break;
        case 118: 
        tmp___26 = backslash_v(s, n, dict);
        return (tmp___26);
        break;
        case 119: 
        tmp___27 = backslash_w(s);
        return (tmp___27);
        break;
        }
        printf((char const   * __restrict  )"domain error\n");
        tmp___28 = _n();
        return (tmp___28);
      }
    } else {
      goto _L;
    }
  }
  tmp___30 = __ctype_b_loc();
  if ((int const   )*(*tmp___30 + (int )*(s + 1)) & 8192) {
    s ++;
  }
  tmp___35 = system((char const   *)s);
  if (tmp___35) {
    tmp___32 = kerr("domain");
    tmp___34 = tmp___32;
  } else {
    tmp___33 = _n();
    tmp___34 = tmp___33;
  }
  return (tmp___34);
}
}
static K backslash_b(S s , I n ) 
{ 
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;

  {
  if (n == 2LL) {
    printf((char const   * __restrict  )"%s\n", fBreak);
    tmp = _n();
    return (tmp);
  }
  if (n == 4LL) {
    if ((int )*(s + 3) == (int )*"n") {
      fBreak = (S )"n";
      tmp___0 = _n();
      return (tmp___0);
    }
  }
  if (n == 4LL) {
    if ((int )*(s + 3) == (int )*"t") {
      fBreak = (S )"t";
      tmp___1 = _n();
      return (tmp___1);
    }
  }
  if (n == 4LL) {
    if ((int )*(s + 3) == (int )*"s") {
      fBreak = (S )"s";
      tmp___2 = _n();
      return (tmp___2);
    }
  }
  printf((char const   * __restrict  )"valid options are: n, s, t\n");
  tmp___3 = _n();
  return (tmp___3);
}
}
static K backslash_d(S s , I n , K *dict ) 
{ 
  C z[256] ;
  K tmp ;
  S tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  size_t tmp___3 ;
  S tmp___4 ;
  K tmp___5 ;
  size_t tmp___6 ;
  I c ;
  I i ;
  size_t tmp___7 ;
  S tmp___8 ;
  K tmp___9 ;
  size_t tmp___10 ;
  S tmp___11 ;
  K tmp___12 ;
  K tmp___13 ;
  S tmp___14 ;
  K tmp___15 ;
  unsigned short const   **tmp___16 ;
  S tmp___17 ;
  K tmp___18 ;
  S tmp___19 ;
  K tmp___20 ;
  K tmp___21 ;

  {
  if (n == 2LL) {
    printf((char const   * __restrict  )"%s\n", d_);
    tmp = _n();
    return (tmp);
  }
  if (n == 4LL) {
    if ((int )*(s + 3) == 46) {
      tmp___0 = sp((S )"");
      d_ = tmp___0;
      tmp___1 = _n();
      return (tmp___1);
    }
  }
  if (n == 4LL) {
    if ((int )*(s + 3) == 94) {
      tmp___3 = strlen((char const   *)d_);
      if (tmp___3 == 0UL) {
        tmp___2 = _n();
        return (tmp___2);
      }
      tmp___6 = strlen((char const   *)d_);
      if (tmp___6 == 2UL) {
        tmp___4 = sp((S )"");
        d_ = tmp___4;
        tmp___5 = _n();
        return (tmp___5);
      }
      tmp___10 = strlen((char const   *)d_);
      if (tmp___10 > 3UL) {
        c = (I )0;
        i = (I )0;
        i = (I )0;
        while (1) {
          tmp___7 = strlen((char const   *)d_);
          if (! ((unsigned long long )i < (unsigned long long )tmp___7)) {
            break;
          }
          if ((int )*(d_ + i) == 46) {
            c = i;
          }
          i ++;
        }
        strcpy((char * __restrict  )(z), (char const   * __restrict  )d_);
        z[c] = (C )'\000';
        tmp___8 = sp(z);
        d_ = tmp___8;
        tmp___9 = _n();
        return (tmp___9);
      }
    }
  }
  if (n == 5LL) {
    if ((int )*(s + 3) == 46) {
      if ((int )*(s + 4) == 107) {
        tmp___11 = sp((S )".k");
        d_ = tmp___11;
        tmp___12 = _n();
        return (tmp___12);
      }
    }
  }
  if (n == 5LL) {
    if ((int )*(s + 3) == 46) {
      if ((int )*(s + 4) != 107) {
        printf((char const   * __restrict  )"absolute backslash-d should begin with .k\n");
        tmp___13 = _n();
        return (tmp___13);
      }
    }
  }
  tmp___16 = __ctype_b_loc();
  if ((int const   )*(*tmp___16 + (int )*(s + 3)) & 1024) {
    denameD(dict, s + 3, (I )1);
    strcpy((char * __restrict  )(z), (char const   * __restrict  )d_);
    strcat((char * __restrict  )(z), (char const   * __restrict  )".");
    strcat((char * __restrict  )(z), (char const   * __restrict  )(s + 3));
    tmp___14 = sp(z);
    d_ = tmp___14;
    tmp___15 = _n();
    return (tmp___15);
  }
  if (n >= 6LL) {
    if ((int )*(s + 3) == 46) {
      if ((int )*(s + 4) == 107) {
        if ((int )*(s + 5) == 46) {
          denameD(& KTREE, s + 3, (I )1);
          tmp___17 = sp(s + 3);
          d_ = tmp___17;
          tmp___18 = _n();
          return (tmp___18);
        }
      }
    }
  }
  if ((int )*(s + 3) == 46) {
    denameD(& KTREE, s + 3, (I )1);
    tmp___19 = sp(s + 3);
    d_ = tmp___19;
    tmp___20 = _n();
    return (tmp___20);
  }
  tmp___21 = kerr("nyi");
  return (tmp___21);
}
}
static K backslash_v(S s , I n , K *dict ) 
{ 
  K tmp ;
  C z[256] ;
  I c ;
  I i ;
  size_t tmp___0 ;
  K tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  K x___0 ;
  K *tmp___4 ;
  K tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  K tmp___8 ;

  {
  if (n > 2LL) {
    if ((int )*(s + 2) == 13) {
      tmp = kerr("syntax");
      return (tmp);
    }
  }
  z[0] = (C )'\000';
  if (2LL == n) {
    strcpy((char * __restrict  )(z), (char const   * __restrict  )d_);
  }
  if (4LL == n) {
    if ((int )*(s + 3) == (int )*"^") {
      tmp___2 = strlen((char const   *)d_);
      if (tmp___2 > 3UL) {
        c = (I )0;
        i = (I )0;
        i = (I )0;
        while (1) {
          tmp___0 = strlen((char const   *)d_);
          if (! ((unsigned long long )i < (unsigned long long )tmp___0)) {
            break;
          }
          if ((int )*(d_ + i) == (int )*".") {
            c = i;
          }
          i ++;
        }
        strcpy((char * __restrict  )(z), (char const   * __restrict  )d_);
        z[c] = (C )*"\000";
      } else {
        tmp___1 = _n();
        return (tmp___1);
      }
    }
  }
  tmp___3 = __ctype_b_loc();
  if ((int const   )*(*tmp___3 + (int )*(s + 3)) & 1024) {
    strcpy((char * __restrict  )(z), (char const   * __restrict  )d_);
    strcat((char * __restrict  )(z), (char const   * __restrict  )".");
    strcat((char * __restrict  )(z), (char const   * __restrict  )(s + 3));
  }
  if (z[0]) {
    tmp___4 = denameD(& KTREE, z, (I )0);
    x___0 = *tmp___4;
    if (6LL == x___0->t) {
      tmp___5 = _n();
      tmp___7 = tmp___5;
    } else {
      tmp___6 = enumerate(x___0);
      tmp___7 = tmp___6;
    }
    return (tmp___7);
  }
  tmp___8 = kerr("nyi");
  return (tmp___8);
}
}
static K backslash_e(S s , I n ) 
{ 
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;

  {
  if (n == 2LL) {
    printf((char const   * __restrict  )"%lld\n", fError);
    tmp = _n();
    return (tmp);
  }
  if (n == 4LL) {
    if ((int )*(s + 3) == (int )*"0") {
      fError = (I )0;
      tmp___0 = _n();
      return (tmp___0);
    }
  }
  if (n == 4LL) {
    if ((int )*(s + 3) == (int )*"1") {
      fError = (I )1;
      tmp___1 = _n();
      return (tmp___1);
    }
  }
  if (n == 4LL) {
    if ((int )*(s + 3) == (int )*"2") {
      fError = (I )2;
      tmp___2 = _n();
      return (tmp___2);
    }
  }
  printf((char const   * __restrict  )"valid options are: 0, 1, 2\n");
  tmp___3 = _n();
  return (tmp___3);
}
}
static K backslash_s(S s ) 
{ 
  S t ;
  S u ;
  S w___0 ;
  I c ;
  I d___0 ;
  I n ;
  I m ;
  I l ;
  I r ;
  FILE *f ;
  FILE *tmp ;
  K k ;
  K y ;
  K z ;
  K tmp___0 ;
  unsigned short const   **tmp___1 ;
  S tmp___2 ;
  I tmp___3 ;
  K tmp___4 ;
  I tmp___5 ;
  K tmp___6 ;
  int tmp___7 ;
  K tmp___8 ;
  K tmp___9 ;

  {
  u = (S )0;
  c = (I )0;
  m = (I )0;
  l = (I )0;
  tmp = loadf(s);
  f = tmp;
  k = (K )0;
  y = (K )0;
  z = (K )0;
  if (! f) {
    tmp___0 = _n();
    return (tmp___0);
  }
  while (1) {
    c = wds(& y, f);
    if (! (0LL < c)) {
      break;
    }
    n = y->n;
    t = (C *)(y->k);
    w___0 = t;
    while (1) {
      tmp___1 = __ctype_b_loc();
      tmp___2 = w___0;
      w___0 ++;
      if (! ((int const   )*(*tmp___1 + (int )*tmp___2) & 8192)) {
        break;
      }
      l ++;
    }
    if (l == n) {
      goto _L;
    } else
    if (! n) {
      _L: /* CIL Label */ 
      if (y) {
        cd(y);
      }
      y = (K )0;
      continue;
    }
    printf((char const   * __restrict  )"%s ", t);
    tmp___3 = getline_(& u, & m, stdin);
    if (-1LL == tmp___3) {
      goto cleanup;
    }
    d___0 = stepopt(u, m);
    if (d___0 == 1LL) {
      if (y) {
        cd(y);
      }
      y = (K )0;
      continue;
    } else
    if (d___0 == 2LL) {
      goto cleanup;
    }
    tmp___4 = wd(t, (int )n);
    k = ex(tmp___4);
    show(k);
    if (k) {
      cd(k);
      k = (K )0;
    }
    if (y) {
      cd(y);
      y = (K )0;
    }
    while (1) {
      prompt((I )1);
      tmp___5 = wds_(& z, stdin, (I )1);
      if (0LL > tmp___5) {
        goto cleanup;
      }
      w___0 = (C *)(z->k);
      l = z->n;
      d___0 = stepopt(w___0, l);
      if (d___0 == 1LL) {
        if (z) {
          cd(z);
        }
        z = (K )0;
        break;
      } else
      if (d___0 == 2LL) {
        goto cleanup;
      }
      tmp___6 = wd(w___0, (int )l);
      k = ex(tmp___6);
      show(k);
      if (k) {
        cd(k);
        k = (K )0;
      }
      if (z) {
        cd(z);
        z = (K )0;
      }
      if (! (d___0 == 0LL)) {
        if (! (d___0 == 3LL)) {
          break;
        }
      }
    }
  }
  cleanup: 
  tmp___7 = fclose(f);
  r = (I )tmp___7;
  if (r) {
    tmp___8 = kerr("file");
    return (tmp___8);
  }
  free((void *)u);
  if (k) {
    cd(k);
  }
  if (y) {
    cd(y);
  }
  if (z) {
    cd(z);
  }
  tmp___9 = _n();
  return (tmp___9);
}
}
static K backslash_t(S s ) 
{ 
  I r ;
  K tmp ;
  I tmp___0 ;
  I d___0 ;
  clock_t tmp___1 ;
  K z ;
  K tmp___2 ;
  clock_t tmp___3 ;
  K tmp___4 ;
  K tmp___5 ;

  {
  if (*s) {
    tmp___0 = StoI(s, & r);
    if (tmp___0) {
      tmr_ival = r;
      tmp = _n();
      return (tmp);
    }
    tmp___1 = clock();
    d___0 = (I )tmp___1;
    tmp___2 = X(s);
    z = tmp___2;
    tmp___3 = clock();
    d___0 = (I )((F )((I )tmp___3 - d___0) / ((F )1000000L / (F )1000));
    cd(z);
    tmp___4 = Ki(d___0);
    return (tmp___4);
  }
  tmp___5 = Ki(tmr_ival);
  return (tmp___5);
}
}
static K backslash_w(S s ) 
{ 
  K tmp ;

  {
  fWksp = (I )1;
  tmp = _n();
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-5Gr1hvUK.i","-g,-pthread,-O3")
extern __ssize_t getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                          int __delimiter , FILE * __restrict  __stream ) ;
I strlenn(S s , I k ) ;
I appender(S *s , I *n , S t , I k ) ;
I expander(S *s , I n ) ;
I expander(S *s , I n ) 
{ 
  S t ;
  I q ;
  I tmp ;
  void *tmp___0 ;

  {
  q = n;
  if (1LL > q) {
    tmp = (I )1;
  } else {
    tmp = q;
  }
  tmp___0 = realloc((void *)*s, (size_t )tmp);
  t = (S )tmp___0;
  if (! t) {
    kerr("wsfull");
    return ((I )-1);
  }
  *s = t;
  return ((I )0);
}
}
I appender(S *s , I *n , S t , I k ) 
{ 
  I tmp ;

  {
  tmp = expander(s, (*n + k) + 1LL);
  if (tmp) {
    return ((I )-1);
  }
  memcpy((void * __restrict  )(*s + *n), (void const   * __restrict  )t, (size_t )k);
  *n += k;
  *(*s + *n) = (C )'\000';
  return ((I )0);
}
}
I getline_(S *s , I *n , FILE *f ) 
{ 
  I tmp ;

  {
  tmp = getdelim_(s, n, (I )'\n', f);
  return (tmp);
}
}
I getdelim_(S *s , I *n , I d___0 , FILE *f ) 
{ 
  I m ;
  S z ;
  size_t o ;
  __ssize_t tmp ;
  I tmp___0 ;

  {
  o = (size_t )*n;
  tmp = getdelim((char ** __restrict  )s, (size_t * __restrict  )(& o), (int )d___0,
                 (FILE * __restrict  )f);
  if (tmp == -1L) {
    *n = (I )0;
    return ((I )-1);
  }
  *n = (I )o;
  m = strlenn(*s, *n);
  if (1LL < m) {
    if (10 == (int )*(*s + (m - 1LL))) {
      if (13 == (int )*(*s + (m - 2LL))) {
        m --;
        *(*s + m) = (C )'\000';
        *(*s + (m - 1LL)) = (C )'\n';
      }
    }
  }
  z = strdupn(*s, m);
  free((void *)*s);
  *s = z;
  tmp___0 = m;
  *n = tmp___0;
  return (tmp___0);
}
}
#pragma merger("0","/tmp/cil-BRwcD2SD.i","-g,-pthread,-O3")
static unsigned long long mt[312]  ;
static int mti  =    313;
void init_genrand64(unsigned long long seed ) 
{ 


  {
  mt[0] = seed;
  mti = 1;
  while (mti < 312) {
    mt[mti] = 6364136223846793005ULL * (mt[mti - 1] ^ (mt[mti - 1] >> 62)) + (unsigned long long )mti;
    mti ++;
  }
  return;
}
}
unsigned long long genrand64_int64(void) ;
static unsigned long long mag01[2]  = {      0ULL,      13043109905998158313};
unsigned long long genrand64_int64(void) 
{ 
  int i ;
  unsigned long long x___0 ;
  int tmp ;

  {
  if (mti >= 312) {
    if (mti == 313) {
      init_genrand64(5489ULL);
    }
    i = 0;
    while (i < 156) {
      x___0 = (mt[i] & 18446744071562067968) | (mt[i + 1] & 2147483647ULL);
      mt[i] = (mt[i + 156] ^ (x___0 >> 1)) ^ mag01[(int )(x___0 & 1ULL)];
      i ++;
    }
    while (i < 311) {
      x___0 = (mt[i] & 18446744071562067968) | (mt[i + 1] & 2147483647ULL);
      mt[i] = (mt[i + -156] ^ (x___0 >> 1)) ^ mag01[(int )(x___0 & 1ULL)];
      i ++;
    }
    x___0 = (mt[311] & 18446744071562067968) | (mt[0] & 2147483647ULL);
    mt[311] = (mt[155] ^ (x___0 >> 1)) ^ mag01[(int )(x___0 & 1ULL)];
    mti = 0;
  }
  tmp = mti;
  mti ++;
  x___0 = mt[tmp];
  x___0 ^= (x___0 >> 29) & 6148914691236517205ULL;
  x___0 ^= (x___0 << 17) & 8202884508482404352ULL;
  x___0 ^= (x___0 << 37) & 18444473444759240704;
  x___0 ^= x___0 >> 43;
  return (x___0);
}
}
double genrand64_real2(void) 
{ 
  unsigned long long tmp ;

  {
  tmp = genrand64_int64();
  return ((double )(tmp >> 11) * (1.0 / 9007199254740992.0));
}
}
#pragma merger("0","/tmp/cil-NdqR_2ZW.i","-g,-pthread,-O3")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
I lsz(I k ) ;
I adverbClass(V p ) ;
L charsAdverb(C c ) ;
L charsVerb(C c ) ;
I isCharVerb(C c ) ;
S IFP[3] ;
K match(K a , K b___1 ) ;
I bk(V p ) ;
K end(void) ;
I simpleString(S a ) ;
I maX(I a , I b___1 ) ;
L DT_OFFSET(V v ) ;
S LS ;
L DT_SIZE ;
L DT_ADVERB_OFFSET ;
L DT_VERB_OFFSET ;
L DT_SPECIAL_VERB_OFFSET ;
TR DT[130] ;
K newE(S s , K k ) ;
K newEntry(S s ) ;
K Kd(void) ;
void pdafree(PDA p ) ;
C bottom(PDA p ) ;
C pop(PDA p ) ;
C peek(PDA p ) ;
I push(PDA p , C c ) ;
PDA newPDA(void) ;
K ci(K x___0 ) ;
I sz(I t , I n ) ;
K stopDict ;
I fStop ;
V alloc(size_t sz___0 ) ;
I SC(S a , S b___1 ) ;
K *denameS(S dir_string , S t , I create ) ;
K EV(K e ) ;
V vn_[17] ;
S n_s ;
K DE(K d___0 , S b___1 ) ;
K *EVP(K e ) ;
K *EAP(K e ) ;
K DI(K d___0 , I i ) ;
S param_dfa ;
I capture(S s , I n , I k , I *m , V *w___0 , I *d___0 , K *locals , K *dict , K func ) ;
K wd_(S s , int n , K *dict , K func ) ;
I mark(I *m , I k , I t ) ;
I complete(S a , I n , PDA *q , I *marks ) ;
I parsedepth(PDA p ) ;
S right ;
S left ;
S formed_dfa ;
K lookupEntryOrCreate(K *p , S k ) ;
static I formed_group(C c ) 
{ 
  S s ;
  I tmp ;

  {
  s = (S )"\n \\/\"";
  tmp = charpos(s, c);
  return (tmp);
}
}
S formed_dfa  =    (S )"023451021151021451033333044444556515555555";
S left  =    (S )"([{";
S right  =    (S )")]}";
S lineA  ;
S lineB  ;
I fdc  =    (I )1;
I fll  =    (I )0;
static C flop(C c ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((int )c == 40) {
    tmp___1 = ')';
  } else {
    if ((int )c == 91) {
      tmp___0 = ']';
    } else {
      if ((int )c == 123) {
        tmp = '}';
      } else {
        tmp = (int )c;
      }
      tmp___0 = tmp;
    }
    tmp___1 = tmp___0;
  }
  return ((C )tmp___1);
}
}
I parsedepth(PDA p ) 
{ 
  int tmp ;
  I tmp___0 ;

  {
  if (p) {
    if (p->s >= 5LL) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    tmp___0 = p->n + (I )tmp;
  } else {
    tmp___0 = (I )0;
  }
  return (tmp___0);
}
}
I complete(S a , I n , PDA *q , I *marks ) 
{ 
  PDA p ;
  C t ;
  I r ;
  I tmp ;
  I before_pn ;
  I before_sq ;
  I before_sc ;
  C tmp___0 ;
  I tmp___1 ;
  C tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  I tmp___5 ;
  C bot ;
  C tmp___6 ;
  I m ;
  I tmp___7 ;
  I tmp___8 ;
  I tmp___9 ;
  I tmp___10 ;
  I tmp___11 ;
  I tmp___12 ;
  I tmp___13 ;
  int tmp___14 ;

  {
  if (! *q) {
    *q = newPDA();
  }
  p = *q;
  if (! p) {
    return ((I )-1);
  }
  tmp = formed_group((C )'\000');
  r = tmp + 1LL;
  while (p->i < n) {
    before_pn = p->n;
    before_sq = (I )(p->s >= 5LL);
    before_sc = (I )(p->s == 4LL);
    t = *(a + p->i);
    if (p->s < 4LL) {
      if (t) {
        tmp___4 = strchr((char const   *)left, (int )t);
        if (tmp___4) {
          tmp___0 = flop(t);
          tmp___1 = push(p, tmp___0);
          if (tmp___1) {
            return ((I )-1);
          }
          if (p->n > 99LL) {
            return ((I )3);
          }
        } else {
          tmp___3 = strchr((char const   *)right, (int )t);
          if (tmp___3) {
            tmp___2 = peek(p);
            if ((int )tmp___2 != (int )t) {
              return ((I )2);
            } else {
              pop(p);
            }
          }
        }
      }
    }
    tmp___5 = formed_group(*(a + p->i));
    p->s = (I )((int )*(formed_dfa + (r * p->s + tmp___5)) - 48);
    if (! marks) {
      goto __Cont;
    }
    tmp___6 = bottom(p);
    bot = tmp___6;
    if ((int )bot == 41) {
      tmp___13 = (I )4;
    } else {
      if ((int )bot == 93) {
        tmp___12 = (I )2;
      } else {
        if ((int )bot == 125) {
          tmp___11 = (I )5;
        } else {
          if (p->s == 4LL) {
            tmp___10 = (I )1;
          } else {
            if (p->s >= 5LL) {
              tmp___9 = (I )6;
            } else {
              if (before_pn) {
                goto _L;
              } else
              if (before_sq) {
                _L: /* CIL Label */ 
                if (*(marks + (p->i - 1LL)) < 0LL) {
                  tmp___7 = - *(marks + (p->i - 1LL));
                } else {
                  tmp___7 = *(marks + (p->i - 1LL));
                }
                tmp___8 = tmp___7;
              } else {
                tmp___8 = (I )0;
              }
              tmp___9 = tmp___8;
            }
            tmp___10 = tmp___9;
          }
          tmp___11 = tmp___10;
        }
        tmp___12 = tmp___11;
      }
      tmp___13 = tmp___12;
    }
    m = tmp___13;
    if (p->n) {
      if (! before_pn) {
        m *= -1LL;
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if (6LL == m) {
      if (! before_sq) {
        m *= -1LL;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (1LL == m) {
      if (! before_sc) {
        m *= -1LL;
      }
    }
    *(marks + p->i) = m;
    __Cont: /* CIL Label */ 
    (p->i) ++;
  }
  if (! (p->s >= 5LL)) {
    if (! p->n) {
      tmp___14 = 0;
    } else {
      tmp___14 = 1;
    }
  } else {
    tmp___14 = 1;
  }
  return ((I )tmp___14);
}
}
static I mark_symbol(S s , I n , I i , I *m ) 
{ 
  I adot ;
  I j ;
  I k ;
  C c ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  if (*(m + i)) {
    return ((I )0);
  } else
  if (96 != (int )*(s + i)) {
    return ((I )0);
  }
  adot = (I )0;
  j = (I )0;
  while (1) {
    if ((i + 2LL) + j < n) {
      if (-6LL == *(m + (i + 1LL))) {
        if (! (6LL == *(m + ((i + 2LL) + j)))) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    j ++;
  }
  if (j) {
    return (j + 2LL);
  }
  while (1) {
    k = (i + 1LL) + j;
    if (! (k < n)) {
      break;
    }
    c = *(s + k);
    if (! j) {
      tmp = __ctype_b_loc();
      if ((int const   )*(*tmp + (int )c) & 2048) {
        break;
      }
    }
    if (adot) {
      tmp___0 = __ctype_b_loc();
      if ((int const   )*(*tmp___0 + (int )c) & 2048) {
        break;
      } else
      if (46 == (int )c) {
        break;
      }
    }
    tmp___1 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___1 + (int )c) & 8)) {
      if (46 != (int )c) {
        if (95 != (int )c) {
          break;
        }
      }
    }
    adot = (I )(46 == (int )c);
    j ++;
  }
  if (1LL == j) {
    if (adot) {
      return ((I )1);
    }
  }
  return (j + 1LL);
}
}
static I isalnum_(C c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  tmp = __ctype_b_loc();
  if ((int const   )*(*tmp + (int )c) & 8) {
    tmp___0 = 1;
  } else
  if (95 == (int )c) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return ((I )tmp___0);
}
}
static I isalnumdot_(C c ) 
{ 
  I tmp ;
  int tmp___0 ;

  {
  tmp = isalnum_(c);
  if (tmp) {
    tmp___0 = 1;
  } else
  if (46 == (int )c) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return ((I )tmp___0);
}
}
static I mark_name(S s , I n , I i , I *m ) 
{ 
  I c ;
  I tmp ;
  unsigned short const   **tmp___0 ;
  I tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;

  {
  c = (I )0;
  if (*(m + i)) {
    return ((I )0);
  }
  if (i) {
    tmp = isalnum_(*(s + (i - 1LL)));
    if (tmp) {
      return ((I )0);
    }
  }
  if (i < n - 1LL) {
    if ((int )*(s + i) == 95) {
      tmp___0 = __ctype_b_loc();
      if ((int const   )*(*tmp___0 + (int )*(s + (i + 1LL))) & 1024) {
        if (i == n - 2LL) {
          return ((I )2);
        } else
        if (*(m + (i + 2LL))) {
          return ((I )2);
        } else {
          tmp___1 = isalnumdot_(*(s + (i + 2LL)));
          if (! tmp___1) {
            return ((I )2);
          }
        }
      }
    }
  }
  while (1) {
    if (i + c < n) {
      tmp___5 = isalnumdot_(*(s + (i + c)));
      if (! tmp___5) {
        break;
      }
    } else {
      break;
    }
    if (i + c < n - 1LL) {
      if (46 == (int )*(s + (i + c))) {
        tmp___3 = __ctype_b_loc();
        if ((int const   )*(*tmp___3 + (int )*(s + ((i + c) + 1LL))) & 1024) {
          c += 2LL;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      tmp___2 = __ctype_b_loc();
      if ((int const   )*(*tmp___2 + (int )*(s + (i + c))) & 1024) {
        c ++;
      } else {
        break;
      }
    }
    if (i + c >= n) {
      break;
    }
    while (1) {
      if (i + c < n) {
        tmp___4 = isalnum_(*(s + (i + c)));
        if (! tmp___4) {
          break;
        }
      } else {
        break;
      }
      c ++;
    }
    if (i + c >= n) {
      break;
    }
    if (46 == (int )*(s + (i + c))) {
      c ++;
    }
  }
  if (1LL < i) {
    if (46 == (int )*(s + (i - 1LL))) {
      if (0LL == *(m + (i - 2LL))) {
        if (46 != (int )*(s + (i - 2LL))) {
          c = (I )0;
        }
      }
    }
  }
  return (c);
}
}
static I mark_number(S s , I n , I i , I *m ) 
{ 
  I c ;
  I tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  int __res ;
  __int32_t const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  I tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;

  {
  c = (I )0;
  if (*(m + i)) {
    return ((I )0);
  }
  if (i) {
    if (45 == (int )*(s + i)) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___0 + (int )*(s + (i - 1LL))) & 8192)) {
        if (*(m + (i - 1LL)) < 0LL) {
          tmp = - *(m + (i - 1LL));
        } else {
          tmp = *(m + (i - 1LL));
        }
        switch (tmp) {
        case 9LL: 
        case 8LL: 
        case 7LL: 
        case 4LL: 
        case 2LL: 
        return ((I )0);
        }
      }
    }
  }
  if (45 == (int )*(s + i)) {
    if (i < n - 2LL) {
      if (46 == (int )*(s + (i + 1LL))) {
        tmp___2 = __ctype_b_loc();
        if ((int const   )*(*tmp___2 + (int )*(s + (i + 2LL))) & 2048) {
          c ++;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (i < n - 1LL) {
      tmp___1 = __ctype_b_loc();
      if ((int const   )*(*tmp___1 + (int )*(s + (i + 1LL))) & 2048) {
        c ++;
      } else {
        return ((I )0);
      }
    } else {
      return ((I )0);
    }
  }
  while (1) {
    if (i + c < n) {
      if (! *(m + (i + c))) {
        tmp___3 = __ctype_b_loc();
        if (! ((int const   )*(*tmp___3 + (int )*(s + (i + c))) & 2048)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    c ++;
  }
  if (i + c < n) {
    if (46 == (int )*(s + (i + c))) {
      if (c) {
        c ++;
      } else
      if (i + c < n - 1LL) {
        tmp___4 = __ctype_b_loc();
        if ((int const   )*(*tmp___4 + (int )*(s + ((i + c) + 1LL))) & 2048) {
          c ++;
        } else {
          return ((I )0);
        }
      } else {
        return ((I )0);
      }
    }
  }
  while (1) {
    if (i + c < n) {
      if (! *(m + (i + c))) {
        tmp___5 = __ctype_b_loc();
        if (! ((int const   )*(*tmp___5 + (int )*(s + (i + c))) & 2048)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    c ++;
  }
  if (i + c < n) {
    if (sizeof(*(s + (i + c))) > 1UL) {
      __res = tolower((int )*(s + (i + c)));
    } else {
      tmp___9 = __ctype_tolower_loc();
      __res = (int )*(*tmp___9 + (int )*(s + (i + c)));
    }
    if (101 == __res) {
      if (! c) {
        return ((I )0);
      } else
      if (i + c < n - 2LL) {
        if (45 == (int )*(s + ((i + c) + 1LL))) {
          tmp___7 = __ctype_b_loc();
          if ((int const   )*(*tmp___7 + (int )*(s + ((i + c) + 2LL))) & 2048) {
            c += 2LL;
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
      if (i + c < n - 1LL) {
        tmp___6 = __ctype_b_loc();
        if ((int const   )*(*tmp___6 + (int )*(s + ((i + c) + 1LL))) & 2048) {
          c ++;
        } else {
          return ((I )0);
        }
      } else {
        return ((I )0);
      }
    }
  }
  while (1) {
    if (i + c < n) {
      if (! *(m + (i + c))) {
        tmp___10 = __ctype_b_loc();
        if (! ((int const   )*(*tmp___10 + (int )*(s + (i + c))) & 2048)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    c ++;
  }
  if (i + c < n) {
    if (1LL == c) {
      if (48 == (int )*(s + i)) {
        goto _L___3;
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if (2LL == c) {
      if (45 == (int )*(s + i)) {
        if (48 == (int )*(s + (i + 1LL))) {
          _L___3: /* CIL Label */ 
          tmp___11 = stringHasChar((S )"NIni", *(s + (i + c)));
          if (tmp___11) {
            if (i + c == n - 1LL) {
              c ++;
            } else {
              tmp___12 = __ctype_b_loc();
              if (! ((int const   )*(*tmp___12 + (int )*(s + ((i + c) + 1LL))) & 1024)) {
                c ++;
              }
            }
          }
        }
      }
    }
  }
  if (c) {
    while (1) {
      if (i + c < n) {
        if (! *(m + (i + c))) {
          tmp___13 = __ctype_b_loc();
          if (! ((int const   )*(*tmp___13 + (int )*(s + (i + c))) & 8192)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      c ++;
    }
  }
  return (c);
}
}
static I mark_adverb(S s , I n , I i , I *m ) 
{ 
  C c ;
  I j ;
  I tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  if (*(m + i)) {
    return ((I )0);
  }
  c = *(s + i);
  if (i == 0LL) {
    if ((int )c == 39) {
      goto _L;
    } else
    if ((int )c == 92) {
      _L: /* CIL Label */ 
      tmp___0 = strlen((char const   *)s);
      if (tmp___0 > 3UL) {
        j = (I )3;
        while ((int )*(s + j) != 0) {
          tmp = j;
          j ++;
          if ((int )*(s + tmp) == 41) {
            return ((I )0);
          }
        }
      }
      return ((I )1);
    }
    return ((I )0);
  }
  tmp___1 = strcmp((char const   *)s, ";\\\\");
  if (! tmp___1) {
    return ((I )1);
  }
  if ((int )c == 92) {
    if ((int )*(s + (i - 1LL)) == 59) {
      return ((I )0);
    }
  }
  if ((int )*(s + (i - 1LL)) != 32) {
    if ((int )c == 47) {
      goto _L___0;
    } else
    if ((int )c == 92) {
      goto _L___0;
    } else
    if ((int )c == 39) {
      _L___0: /* CIL Label */ 
      if (i < n - 1LL) {
        if ((int )*(s + (i + 1LL)) == 58) {
          return ((I )2);
        }
      }
      return ((I )1);
    }
  }
  return ((I )0);
}
}
static I mark_verb(S s , I n , I i , I *m ) 
{ 
  I c ;
  unsigned short const   **tmp___0 ;
  I tmp___2 ;

  {
  c = (I )0;
  while (1) {
    if (i + c < n - 1LL) {
      if (-9LL == *(m + i)) {
        c ++;
        if (! (9LL == *(m + (c + i)))) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
  }
  if (c) {
    if (58 == (int )*(s + (i + c))) {
      c ++;
      return (c);
    }
  }
  if (*(m + i)) {
    return ((I )0);
  }
  c = (I )0;
  if (95 == (int )*(s + i)) {
    while (1) {
      if (i + c < n) {
        tmp___0 = __ctype_b_loc();
        if (! ((int const   )*(*tmp___0 + (int )*(s + ((i + 1LL) + c))) & 1024)) {
          break;
        }
      } else {
        break;
      }
      c ++;
    }
  }
  if (c > 1LL) {
    return (1LL + c);
  }
  if ((int )*(s + i) == 92) {
    if ((int )*(s + (i - 1LL)) == 32) {
      return ((I )1);
    } else
    if ((int )*(s + (i - 1LL)) == 59) {
      return ((I )1);
    } else
    if ((int )*(s + (i - 1LL)) == 40) {
      return ((I )1);
    }
  }
  c = (I )0;
  tmp___2 = isCharVerb(*(s + i));
  if (tmp___2) {
    c ++;
  }
  return (c);
}
}
static I mark_conditional(S s , I n , I k , I *m ) 
{ 
  S t[3] ;
  I i ;
  I _i___0 ;
  I c ;
  size_t tmp ;
  int tmp___0 ;

  {
  t[0] = (S )"if";
  t[1] = (S )"do";
  t[2] = (S )"while";
  if ((int )*(s + k) == 58) {
    if ((int )*(s + (k + 1LL)) == 91) {
      if ((int )*(s + (k + 2LL)) != 59) {
        if (! *(m + k)) {
          return ((I )1);
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (*(m + k) == -8LL) {
    i = (I )0;
    _i___0 = (I )(sizeof(t) / sizeof(t[0]));
    while (i < _i___0) {
      tmp = strlen((char const   *)t[i]);
      c = (I )tmp;
      tmp___0 = strncmp((char const   *)(s + k), (char const   *)t[i], (size_t )c);
      if (! tmp___0) {
        if ((int )*(s + (k + c)) == 91) {
          return (c);
        }
      }
      i ++;
    }
  }
  return ((I )0);
}
}
static I mark_end(S s , I n , I i , I *m ) 
{ 
  C c ;
  int tmp ;
  int tmp___0 ;

  {
  c = *(s + i);
  if (*(m + i)) {
    tmp___0 = 0;
  } else {
    if ((int )c == 59) {
      tmp = 1;
    } else
    if ((int )c == 10) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    tmp___0 = tmp;
  }
  return ((I )tmp___0);
}
}
static I mark_ignore(S s , I n , I i , I *m ) 
{ 
  C c ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
  c = *(s + i);
  if (*(m + i)) {
    tmp___2 = 0;
  } else {
    tmp___1 = __ctype_b_loc();
    if ((int const   )*(*tmp___1 + (int )c) & 8192) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    tmp___2 = tmp___0;
  }
  return ((I )tmp___2);
}
}
static I overcount(I *m , I n ) 
{ 
  I c ;
  I p ;
  I i ;
  I _i___0 ;

  {
  c = (I )0;
  p = (I )0;
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    if (*(m + i) <= -3LL) {
      if (*(m + i) == p) {
        if (! (p == -7LL)) {
          if (! (p == -9LL)) {
            p = *(m + i);
            c ++;
          }
        }
      } else {
        p = *(m + i);
        c ++;
      }
    }
    i ++;
  }
  return (c);
}
}
static I syntaxChk(S s ) 
{ 
  I n ;
  size_t tmp ;
  I i ;
  I j ;
  I k ;
  unsigned short const   **tmp___0 ;

  {
  if ((int )*(s + 0) == 9) {
    return ((I )5);
  } else
  if ((int )*(s + 0) == 12) {
    return ((I )5);
  }
  tmp = strlen((char const   *)s);
  n = (I )tmp;
  if (n == 1LL) {
    if ((int )*(s + 0) == 39) {
      return ((I )10);
    } else {
      return ((I )0);
    }
  }
  k = (I )0;
  i = (I )0;
  while (i < n) {
    if ((int )*(s + i) != 32) {
      break;
    }
    i ++;
  }
  if (i >= n - 1LL) {
    return ((I )0);
  }
  j = i + 1LL;
  while (j < n) {
    if ((int )*(s + j) != 32) {
      break;
    }
    j ++;
  }
  if ((int )*(s + i) == 92) {
    if ((int )*(s + j) == 92) {
      return ((I )0);
    }
  }
  if ((int )*(s + i) == 39) {
    if ((int )*(s + j) != 34) {
      return ((I )20);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (j == n) {
    return ((I )20);
  }
  i = (I )0;
  while (i < n) {
    if ((int )*(s + i) == 34) {
      break;
    }
    if (i > 0LL) {
      if ((int )*(s + i) == 11) {
        return ((I )30);
      } else
      if ((int )*(s + i) == 12) {
        return ((I )30);
      } else
      if ((int )*(s + i) == 39) {
        if ((int )*(s + (i - 1LL)) == 59) {
          return ((I )30);
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (i > 1LL) {
      if ((int )*(s + i) == 39) {
        if ((int )*(s + (i - 2LL)) == 92) {
          return ((I )30);
        }
      }
    }
    i ++;
  }
  if (n > 1LL) {
    if ((int )*(s + (n - 1LL)) == 39) {
      if ((int )*(s + (n - 2LL)) == 58) {
        return ((I )50);
      }
    }
  }
  if (n > 1LL) {
    i = (I )1;
    while (i < n) {
      if ((int )*(s + i) == 34) {
        break;
      }
      if ((int )*(s + i) == 58) {
        if ((int )*(s + (i - 1LL)) == 96) {
          return ((I )55);
        }
      }
      if ((int )*(s + i) == 44) {
        if ((int )*(s + (i - 1LL)) == 92) {
          return ((I )60);
        } else
        if ((int )*(s + (i - 1LL)) == 95) {
          return ((I )60);
        }
      }
      if ((int )*(s + i) == 63) {
        if ((int )*(s + (i - 1LL)) == 45) {
          return ((I )70);
        } else
        if ((int )*(s + (i - 1LL)) == 92) {
          return ((I )70);
        }
      }
      i ++;
    }
  }
  if (n > 2LL) {
    i = (I )2;
    while (i < n) {
      if ((int )*(s + i) == 92) {
        if ((int )*(s + (i - 1LL)) == 58) {
          if ((int )*(s + (i - 2LL)) != 47) {
            if ((int )*(s + (i - 2LL)) != 92) {
              if ((int )*(s + (i + 1LL)) != 110) {
                return ((I )80);
              }
            }
          }
        }
      }
      if ((int )*(s + i) == 47) {
        if ((int )*(s + (i - 1LL)) == 43) {
          goto _L___1;
        } else
        if ((int )*(s + (i - 1LL)) == 39) {
          goto _L___1;
        } else
        if ((int )*(s + (i - 1LL)) == 62) {
          goto _L___1;
        } else
        if ((int )*(s + (i - 1LL)) == 37) {
          goto _L___1;
        } else
        if ((int )*(s + (i - 1LL)) == 42) {
          goto _L___1;
        } else
        if ((int )*(s + (i - 1LL)) == 63) {
          goto _L___1;
        } else
        if ((int )*(s + (i - 1LL)) == 38) {
          goto _L___1;
        } else
        if ((int )*(s + (i - 1LL)) == 92) {
          _L___1: /* CIL Label */ 
          if ((int )*(s + (i - 2LL)) == 47) {
            return ((I )90);
          }
        }
      }
      if ((int )*(s + i) == 47) {
        if ((int )*(s + (i - 1LL)) == 47) {
          if ((int )*(s + (i - 2LL)) == 45) {
            return ((I )100);
          }
        }
      }
      if ((int )*(s + i) == 47) {
        if ((int )*(s + (i - 1LL)) == 47) {
          if ((int )*(s + (i + 1LL)) == 44) {
            return ((I )999);
          }
        }
      }
      if ((int )*(s + i) == 95) {
        if ((int )*(s + (i - 1LL)) == 44) {
          if ((int )*(s + (i - 2LL)) == 126) {
            return ((I )110);
          }
        }
      }
      if ((int )*(s + i) == 47) {
        if ((int )*(s + (i - 1LL)) == 35) {
          if ((int )*(s + (i - 2LL)) == 48) {
            return ((I )120);
          }
        }
      }
      if ((int )*(s + i) == 92) {
        if ((int )*(s + (i - 1LL)) == 92) {
          if ((int )*(s + (i - 2LL)) == 60) {
            return ((I )123);
          }
        }
      }
      if ((int )*(s + i) == 36) {
        if ((int )*(s + (i - 1LL)) == 44) {
          if ((int )*(s + (i - 2LL)) == 36) {
            return ((I )130);
          }
        }
      }
      if ((int )*(s + i) == 58) {
        if ((int )*(s + (i - 1LL)) == 48) {
          if ((int )*(s + (i - 2LL)) == 48) {
            return ((I )136);
          }
        }
      }
      if ((int )*(s + i) == 47) {
        if ((int )*(s + (i - 1LL)) == 47) {
          if ((int )*(s + (i - 2LL)) == 47) {
            return ((I )140);
          }
        }
      }
      i ++;
    }
  }
  if (n > 3LL) {
    i = (I )3;
    while (i < n) {
      if ((int )*(s + i) == 92) {
        if ((int )*(s + (i - 1LL)) == 32) {
          if ((int )*(s + (i - 2LL)) == 92) {
            goto _L___2;
          } else
          if ((int )*(s + (i - 2LL)) == 47) {
            _L___2: /* CIL Label */ 
            if ((int )*(s + (i - 3LL)) == 92) {
              return ((I )141);
            }
          }
        }
      }
      tmp___0 = __ctype_b_loc();
      if ((int const   )*(*tmp___0 + (int )*(s + i)) & 1024) {
        goto _L___3;
      } else
      if ((int )*(s + i) == 96) {
        _L___3: /* CIL Label */ 
        if ((int )*(s + (i - 1LL)) == 58) {
          if ((int )*(s + (i - 2LL)) == 58) {
            if ((int )*(s + (i - 3LL)) == 58) {
              return ((I )142);
            }
          }
        }
      }
      i ++;
    }
  }
  if (n > 3LL) {
    i = (I )2;
    while (i < n - 1LL) {
      if ((int )*(s + i) == 47) {
        if ((int )*(s + (i - 1LL)) == 58) {
          if ((int )*(s + (i - 2LL)) == 47) {
            if ((int )*(s + (i + 1LL)) != 58) {
              return ((I )150);
            }
          }
        }
      }
      i ++;
    }
  }
  return (k);
}
}
I mark(I *m , I k , I t ) 
{ 
  I i ;
  I _i___0 ;

  {
  i = (I )0;
  _i___0 = k;
  while (i < _i___0) {
    if (i) {
      *(m + i) = t;
    } else {
      *(m + i) = - t;
    }
    i ++;
  }
  return (k);
}
}
K wd(S s , int n ) 
{ 
  K *tmp ;
  K tmp___0 ;

  {
  lineA = s;
  fdc = (I )0;
  tmp = denameD(& KTREE, d_, (I )1);
  tmp___0 = wd_(s, n, tmp, (K )0);
  return (tmp___0);
}
}
K wd_(S s , int n , K *dict , K func ) 
{ 
  K tmp ;
  char *tmp___0 ;
  I z ;
  I tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  I i ;
  unsigned short const   **tmp___4 ;
  K tmp___5 ;
  PDA p ;
  K km ;
  K tmp___6 ;
  I *m ;
  I e ;
  I tmp___7 ;
  K tmp___8 ;
  K v ;
  K tmp___9 ;
  I tmp___10 ;
  I i___0 ;
  I _i___0 ;
  I tmp___11 ;
  I tmp___12 ;
  I tmp___13 ;
  I i___1 ;
  I _i___1 ;
  I tmp___14 ;
  I tmp___15 ;
  I tmp___16 ;
  I i___2 ;
  I _i___2 ;
  I tmp___17 ;
  I tmp___18 ;
  I tmp___19 ;
  I i___3 ;
  I _i___3 ;
  I tmp___20 ;
  I tmp___21 ;
  I tmp___22 ;
  I i___4 ;
  I _i___4 ;
  I tmp___23 ;
  I tmp___24 ;
  I tmp___25 ;
  I i___5 ;
  I _i___5 ;
  I tmp___26 ;
  I tmp___27 ;
  I tmp___28 ;
  I i___6 ;
  I _i___6 ;
  I tmp___29 ;
  I tmp___30 ;
  I tmp___31 ;
  I i___7 ;
  I _i___7 ;
  I tmp___32 ;
  I tmp___33 ;
  I tmp___34 ;
  I i___8 ;
  I _i___8 ;
  K tmp___35 ;
  I y ;
  K ks2 ;
  K tmp___36 ;
  I tmp___37 ;
  S s2 ;
  I i___9 ;
  I _i___9 ;
  I tmp___38 ;
  I tmp___39 ;
  I oc ;
  I tmp___40 ;
  K kw ;
  K tmp___41 ;
  I tmp___42 ;
  V *w___0 ;
  I c ;
  I j ;
  size_t tmp___43 ;
  I i___10 ;
  I _i___10 ;
  I tmp___44 ;
  K kw2 ;
  K tmp___45 ;
  I tmp___46 ;
  I tmp___47 ;
  I tmp___48 ;
  I tmp___49 ;
  I tmp___50 ;

  {
  if (! s) {
    return ((K )0);
  }
  tmp___0 = strstr((char const   *)s, ":\\t");
  if (tmp___0) {
    tmp = kerr("\\t  syntax");
    show(tmp);
    return ((K )0);
  }
  tmp___1 = syntaxChk(s);
  z = tmp___1;
  if (z == 999LL) {
    tmp___2 = kerr("nonce");
    return (tmp___2);
  }
  if (z) {
    tmp___3 = kerr("syntax");
    return (tmp___3);
  }
  i = (I )0;
  while (1) {
    if (i < (I )n) {
      tmp___4 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___4 + (int )*(s + i)) & 8192)) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  if (92 == (int )*(s + i)) {
    tmp___5 = backslash(s + i, (I )n, dict);
    return (tmp___5);
  }
  p = (PDA )0;
  tmp___6 = newK((I )-1, (I )(1 + n));
  km = tmp___6;
  if (! km) {
    return ((K )0);
  }
  m = (I *)(km->k);
  tmp___7 = complete(s, (I )n, & p, m);
  e = tmp___7;
  if (p) {
    pdafree(p);
    p = (PDA )0;
  }
  lineB = s;
  if (e) {
    cd(km);
    tmp___8 = kerr("parse");
    return (tmp___8);
  }
  tmp___9 = Kv();
  v = tmp___9;
  tmp___10 = OOM_CD((I )0, v, km, (V )-1);
  if (! tmp___10) {
    return ((K )0);
  }
  v->n = (I )0;
  i___0 = (I )0;
  _i___0 = (I )n;
  while (i___0 < _i___0) {
    tmp___11 = mark_end(s, (I )n, i___0, m);
    tmp___12 = mark(m + i___0, tmp___11, (I )3);
    tmp___13 = maX((I )0, -1LL + tmp___12);
    i___0 += tmp___13;
    i___0 ++;
  }
  i___1 = (I )0;
  _i___1 = (I )n;
  while (i___1 < _i___1) {
    tmp___14 = mark_symbol(s, (I )n, i___1, m);
    tmp___15 = mark(m + i___1, tmp___14, (I )7);
    tmp___16 = maX((I )0, -1LL + tmp___15);
    i___1 += tmp___16;
    i___1 ++;
  }
  i___2 = (I )0;
  _i___2 = (I )n;
  while (i___2 < _i___2) {
    tmp___17 = mark_name(s, (I )n, i___2, m);
    tmp___18 = mark(m + i___2, tmp___17, (I )8);
    tmp___19 = maX((I )0, -1LL + tmp___18);
    i___2 += tmp___19;
    i___2 ++;
  }
  i___3 = (I )0;
  _i___3 = (I )n;
  while (i___3 < _i___3) {
    tmp___20 = mark_number(s, (I )n, i___3, m);
    tmp___21 = mark(m + i___3, tmp___20, (I )9);
    tmp___22 = maX((I )0, -1LL + tmp___21);
    i___3 += tmp___22;
    i___3 ++;
  }
  i___4 = (I )0;
  _i___4 = (I )n;
  while (i___4 < _i___4) {
    tmp___23 = mark_adverb(s, (I )n, i___4, m);
    tmp___24 = mark(m + i___4, tmp___23, (I )11);
    tmp___25 = maX((I )0, -1LL + tmp___24);
    i___4 += tmp___25;
    i___4 ++;
  }
  i___5 = (I )0;
  _i___5 = (I )n;
  while (i___5 < _i___5) {
    tmp___26 = mark_conditional(s, (I )n, i___5, m);
    tmp___27 = mark(m + i___5, tmp___26, (I )12);
    tmp___28 = maX((I )0, -1LL + tmp___27);
    i___5 += tmp___28;
    i___5 ++;
  }
  i___6 = (I )0;
  _i___6 = (I )n;
  while (i___6 < _i___6) {
    tmp___29 = mark_verb(s, (I )n, i___6, m);
    tmp___30 = mark(m + i___6, tmp___29, (I )10);
    tmp___31 = maX((I )0, -1LL + tmp___30);
    i___6 += tmp___31;
    i___6 ++;
  }
  i___7 = (I )0;
  _i___7 = (I )n;
  while (i___7 < _i___7) {
    tmp___32 = mark_ignore(s, (I )n, i___7, m);
    tmp___33 = mark(m + i___7, tmp___32, (I )1);
    tmp___34 = maX((I )0, -1LL + tmp___33);
    i___7 += tmp___34;
    i___7 ++;
  }
  i___8 = (I )0;
  _i___8 = (I )n;
  while (i___8 < _i___8) {
    if (*(m + i___8) == 0LL) {
      cd(v);
      cd(km);
      tmp___35 = kerr("parse");
      return (tmp___35);
    }
    i___8 ++;
  }
  y = (I )0;
  tmp___36 = newK((I )-3, (I )n);
  ks2 = tmp___36;
  tmp___37 = OOM_CD((I )0, v, km, ks2, (V )-1);
  if (! tmp___37) {
    return ((K )0);
  }
  s2 = (S )(ks2->k);
  memcpy((void * __restrict  )s2, (void const   * __restrict  )s, (size_t )n);
  i___9 = (I )0;
  _i___9 = (I )n;
  while (i___9 < _i___9) {
    if (*(m + i___9) < 0LL) {
      tmp___38 = - *(m + i___9);
    } else {
      tmp___38 = *(m + i___9);
    }
    if (tmp___38 > 1LL) {
      *(m + y) = *(m + i___9);
      *(s2 + y) = *(s2 + i___9);
      y ++;
    }
    i___9 ++;
  }
  tmp___39 = (I )0;
  *(m + y) = tmp___39;
  *(s2 + y) = (C )tmp___39;
  tmp___40 = overcount(m, (I )n);
  oc = tmp___40;
  tmp___41 = newK((I )-4, 1LL + oc);
  kw = tmp___41;
  tmp___42 = OOM_CD((I )0, v, km, ks2, kw, (V )-1);
  if (! tmp___42) {
    return ((K )0);
  }
  w___0 = (V *)(kw->k);
  c = (I )0;
  j = (I )0;
  if (! fll) {
    tmp___43 = strlen((char const   *)s2);
    fll = (I )tmp___43;
  } else {
    fll = (I )-1;
  }
  i___10 = (I )0;
  _i___10 = y;
  while (i___10 < _i___10) {
    j = capture(s2, y, i___10, m, w___0, & c, (K *)((V *)(v->k)) + 3, dict, func);
    i___10 += -1LL + j;
    if (! j) {
      tmp___44 = OOM_CD((I )0, 0, v, km, ks2, kw, (V )-1);
      if (! tmp___44) {
        return ((K )0);
      }
    }
    i___10 ++;
  }
  cd(km);
  cd(ks2);
  if (oc > c) {
    tmp___47 = sz((I )0, 1LL + oc);
    tmp___48 = lsz(tmp___47);
    tmp___49 = sz((I )0, 1LL + c);
    tmp___50 = lsz(tmp___49);
    if (tmp___48 > tmp___50) {
      tmp___45 = newK((I )-4, 1LL + c);
      kw2 = tmp___45;
      tmp___46 = OOM_CD((I )0, v, kw, kw2, (V )-1);
      if (! tmp___46) {
        return ((K )0);
      }
      memcpy((void * __restrict  )(kw2->k), (void const   * __restrict  )(kw->k),
             (size_t )((unsigned long long )sizeof(V ) * (unsigned long long )c));
      cd(kw);
      kw = kw2;
    }
  }
  *((V *)(v->k) + 2) = (V )kw;
  *((V *)((S *)(((K )*((V *)(v->k) + 2))->k)) + c) = (V )0;
  return (v);
}
}
static I isodigit(C c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  tmp = __ctype_b_loc();
  if ((int const   )*(*tmp + (int )c) & 2048) {
    if ((int )c < 56) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return ((I )tmp___0);
}
}
static I odigitlen3(S s ) 
{ 
  I i ;
  I tmp ;

  {
  i = (I )0;
  while (1) {
    if (*(s + i)) {
      tmp = isodigit(*(s + i));
      if (tmp) {
        if (! (i < 3LL)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  return (i);
}
}
static C unescape(S s , I *k ) 
{ 
  C c ;
  I y ;
  I tmp ;
  I a ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  I i ;
  I _i___0 ;
  I tmp___4 ;

  {
  *k = (I )1;
  c = *s;
  if (92 != (int )c) {
    return (c);
  }
  tmp = odigitlen3(s + 1);
  y = tmp;
  a = (I )0;
  if (! y) {
    *k = (I )2;
    c = *(s + 1);
    if (98 == (int )c) {
      tmp___3 = '\b';
    } else {
      if (110 == (int )c) {
        tmp___2 = '\n';
      } else {
        if (114 == (int )c) {
          tmp___1 = '\r';
        } else {
          if (116 == (int )c) {
            tmp___0 = '\t';
          } else {
            tmp___0 = (int )c;
          }
          tmp___1 = tmp___0;
        }
        tmp___2 = tmp___1;
      }
      tmp___3 = tmp___2;
    }
    return ((C )tmp___3);
  }
  *k += y;
  i = (I )0;
  _i___0 = y;
  while (i < _i___0) {
    a = (a * 8LL + (I )*(s + (1LL + i))) - 48LL;
    i ++;
  }
  if (a < 255LL) {
    tmp___4 = a;
  } else {
    tmp___4 = (I )255;
  }
  return ((C )((UC )tmp___4));
}
}
static I unescaped_size(S s , I n ) 
{ 
  I k ;
  I i ;
  I _i___0 ;
  I tmp ;
  I tmp___0 ;

  {
  k = (I )0;
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    k ++;
    if (92 == (int )*(s + i)) {
      tmp = odigitlen3((s + i) + 1);
      tmp___0 = maX((I )1, tmp);
      i += tmp___0;
    }
    i ++;
  }
  return (k);
}
}
static I unescaped_fill(S d___0 , S s , I n ) 
{ 
  I k ;
  I q ;
  I i ;
  I _i___0 ;
  I tmp ;

  {
  k = (I )0;
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    tmp = k;
    k ++;
    *(d___0 + tmp) = unescape(s + i, & q);
    i += q - 1LL;
    i ++;
  }
  return (k);
}
}
S param_dfa  =    (S )"155045113245553245155355";
static I param_gp(C c ) 
{ 
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;

  {
  tmp___9 = __ctype_b_loc();
  if ((int const   )*(*tmp___9 + (int )c) & 1024) {
    tmp___8 = 0;
  } else {
    tmp___7 = __ctype_b_loc();
    if ((int const   )*(*tmp___7 + (int )c) & 2048) {
      tmp___6 = 1;
    } else
    if (95 == (int )c) {
      tmp___6 = 1;
    } else {
      if (59 == (int )c) {
        tmp___5 = 2;
      } else {
        tmp___4 = __ctype_b_loc();
        if ((int const   )*(*tmp___4 + (int )c) & 8192) {
          tmp___3 = 3;
        } else {
          if (93 == (int )c) {
            tmp___2 = 4;
          } else {
            tmp___2 = 5;
          }
          tmp___3 = tmp___2;
        }
        tmp___5 = tmp___3;
      }
      tmp___6 = tmp___5;
    }
    tmp___8 = tmp___6;
  }
  return ((I )tmp___8);
}
}
static I param_validate(S s , I n ) 
{ 
  S u ;
  unsigned short const   **tmp ;
  S tmp___0 ;
  I p ;
  I r ;
  I tmp___1 ;
  S tmp___2 ;
  I tmp___3 ;
  int tmp___4 ;

  {
  u = s + n;
  while (1) {
    if ((unsigned long )s < (unsigned long )u) {
      tmp = __ctype_b_loc();
      if ((int const   )*(*tmp + (int )*s) & 8192) {
        if (! (10 != (int )*s)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    s ++;
  }
  if ((unsigned long )s == (unsigned long )u) {
    return ((I )0);
  } else {
    tmp___0 = s;
    s ++;
    if (91 != (int )*tmp___0) {
      return ((I )0);
    }
  }
  p = (I )0;
  tmp___1 = param_gp((C )'.');
  r = tmp___1 + 1LL;
  while (1) {
    if ((unsigned long )s < (unsigned long )u) {
      if (! (4LL > p)) {
        break;
      }
    } else {
      break;
    }
    tmp___2 = s;
    s ++;
    tmp___3 = param_gp(*tmp___2);
    p = (I )((int )*(param_dfa + (r * p + tmp___3)) - 48);
  }
  if (4LL == p) {
    tmp___4 = 1;
  } else {
    tmp___4 = 2;
  }
  return ((I )tmp___4);
}
}
static K *inKtreeR(K *p , S t , I create ) 
{ 
  I c ;
  I a ;
  S u ;
  S tmp ;
  S k ;
  S tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K e ;
  K tmp___3 ;
  K a___0 ;
  K *tmp___4 ;

  {
  if (! *t) {
    return (p);
  }
  if (46 == (int )*t) {
    t ++;
  }
  c = (I )0;
  a = (*p)->t;
  while (1) {
    if (*(t + c)) {
      if (! (46 != (int )*(t + c))) {
        break;
      }
    } else {
      break;
    }
    c ++;
  }
  tmp = strdupn(t, c);
  u = tmp;
  tmp___0 = sp(u);
  k = tmp___0;
  free((void *)u);
  t += c;
  if (95 == (int )*k) {
    tmp___1 = kerr("reserved");
    return ((K *)tmp___1);
  }
  if (! (6LL == a)) {
    if (! (5LL == a)) {
      tmp___2 = kerr("type");
      return ((K *)tmp___2);
    }
  }
  e = (K )0;
  if (create) {
    e = lookupEntryOrCreate(p, k);
    if (! e) {
      tmp___3 = kerr("wsfull");
      return ((K *)tmp___3);
    }
  } else {
    a___0 = *p;
    if (5LL == a___0->t) {
      e = DE(a___0, k);
    }
    if (! e) {
      return ((K *)0);
    }
  }
  if (46 == (int )*t) {
    if (! *(t + 1)) {
      t ++;
      p = EAP(e);
    } else
    if (46 == (int )*(t + 1)) {
      t ++;
      p = EAP(e);
    } else {
      p = EVP(e);
    }
  } else {
    p = EVP(e);
  }
  tmp___4 = inKtreeR(p, t, create);
  return (tmp___4);
}
}
K *inKtree(K *d___0 , S t , I create ) 
{ 
  I tmp ;
  K *tmp___0 ;
  K *tmp___1 ;

  {
  tmp = simpleString(t);
  if (! tmp) {
    return ((K *)0);
  }
  if (46 == (int )*t) {
    tmp___0 = & KTREE;
  } else
  if (! *t) {
    tmp___0 = & KTREE;
  } else {
    tmp___0 = d___0;
  }
  tmp___1 = inKtreeR(tmp___0, t, create);
  return (tmp___1);
}
}
I capture(S s , I n , I k , I *m , V *w___0 , I *d___0 , K *locals , K *dict , K func ) 
{ 
  V z ;
  V *p ;
  I r ;
  I v ;
  I y ;
  I a ;
  I b___1 ;
  I c ;
  I l ;
  I frc ;
  S u ;
  S e ;
  K g ;
  K h ;
  K hh ;
  I M ;
  I tmp ;
  I tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  K ko ;
  K tmp___6 ;
  I tmp___7 ;
  V *o ;
  K tmp___8 ;
  K tmp___9 ;
  V *zp ;
  I tmp___10 ;
  I tmp___11 ;
  I i ;
  I _i___0 ;
  K *f ;
  K q ;
  K tmp___12 ;
  K tmp___13 ;
  K temp ;
  K tmp___14 ;
  K *tmp___15 ;
  int tmp___16 ;
  I tmp___17 ;
  I tmp___18 ;
  I tmp___19 ;
  I tmp___20 ;
  K tmp___21 ;
  I tmp___22 ;
  K *zdict ;
  K *ydict ;
  K j ;
  I state ;
  I tmp___23 ;
  K tmp___24 ;
  S a___0 ;
  char *tmp___25 ;
  S b___2 ;
  char *tmp___26 ;
  I tmp___27 ;
  K t ;
  K tmp___28 ;
  I tmp___29 ;
  I tmp___30 ;
  I n___0 ;
  I i___0 ;
  I _i___1 ;
  K tmp___31 ;
  I i___1 ;
  I _i___2 ;
  I tmp___32 ;
  I i___2 ;
  I _i___3 ;
  I tmp___33 ;
  I tmp___34 ;
  K tmp___35 ;
  I i___3 ;
  I _i___4 ;
  K tmp___36 ;
  K tmp___37 ;
  K tmp___38 ;
  I tmp___39 ;
  I tmp___40 ;
  I tmp___41 ;
  int tmp___42 ;
  K tmp___43 ;
  int tmp___44 ;
  K tmp___45 ;
  I i___4 ;
  I _i___5 ;
  V tmp___46 ;
  I tmp___47 ;
  I tmp___48 ;
  K tmp___49 ;
  K q___0 ;
  K tmp___50 ;
  K tmp___51 ;
  I tmp___52 ;
  K tmp___53 ;
  K *tmp___54 ;
  V q___1 ;
  K tmp___55 ;
  K tmp___56 ;
  I tmp___57 ;
  K tmp___58 ;
  K *tmp___59 ;
  K *tmp___60 ;
  K *tmp___61 ;
  K tmp___62 ;
  char *tmp___63 ;
  K *tmp___64 ;
  I i___5 ;
  size_t tmp___65 ;
  K *tmp___66 ;
  K *tmp___67 ;
  L err ;
  K tmp___68 ;
  int tmp___69 ;
  K *tmp___70 ;
  I tmp___71 ;
  size_t tmp___72 ;
  K tmp___73 ;
  K tmp___74 ;
  L i___6 ;
  I tmp___75 ;
  K tmp___76 ;
  I grab ;
  L i___7 ;
  I is_colon ;
  I name_bracket_assign ;
  I modifier_colon ;
  int tmp___77 ;
  I tmp___78 ;
  I tmp___79 ;
  I tmp___80 ;
  K tmp___81 ;
  I y_present ;
  I tmp___82 ;
  int tmp___83 ;
  I tmp___87 ;
  I tmp___88 ;
  I tmp___89 ;
  K tmp___90 ;
  L tmp___91 ;
  int tmp___92 ;
  long jj ;
  long tmp___93 ;
  long tmp___94 ;
  int tmp___95 ;
  K tmp___96 ;
  L tmp___97 ;
  int tmp___98 ;
  L tmp___99 ;
  K tmp___100 ;
  K tmp___101 ;
  K *tmp___102 ;

  {
  if (fll) {
    if (fll != n) {
      fll = (I )-1;
    }
  }
  z = (V )0;
  p = w___0 + *d___0;
  r = (I )1;
  v = (I )0;
  y = (I )0;
  b___1 = (I )0;
  frc = (I )0;
  u = (S )"";
  h = (K )0;
  hh = (K )0;
  if (k >= n) {
    return (r);
  } else
  if (! (*(m + k) < -1LL)) {
    return (r);
  }
  M = *(m + k);
  while (1) {
    if (k + r < n) {
      if (! (- M == *(m + (k + r)))) {
        break;
      }
    } else {
      break;
    }
    r ++;
  }
  if (M == -7LL) {
    goto _L;
  } else
  if (M == -9LL) {
    _L: /* CIL Label */ 
    while (1) {
      if (k + v < n) {
        if (*(m + (k + v)) < 0LL) {
          tmp___0 = - *(m + (k + v));
        } else {
          tmp___0 = *(m + (k + v));
        }
        if (! (- M == tmp___0)) {
          break;
        }
      } else {
        break;
      }
      tmp = v;
      v ++;
      if (*(m + (k + tmp)) <= -3LL) {
        y ++;
      }
    }
  }
  switch (- M) {
  case 12LL: 
  z = offsetColon;
  break;
  case 4LL: 
  fbr = (I )1;
  fdc = (I )1;
  tmp___1 = wd_((s + k) + 1, (int )(r - 2LL), dict, func);
  z = (V )tmp___1;
  if (! z) {
    tmp___2 = kerr("parse");
    return ((L )tmp___2);
  }
  break;
  case 2LL: 
  fbr = (I )1;
  if (! *d___0) {
    goto _L___0;
  } else {
    tmp___4 = bk(*(p + -1));
    if (tmp___4) {
      _L___0: /* CIL Label */ 
      if (func) {
        if (! k) {
          return (r);
        } else {
          tmp___3 = kerr("parse");
          return ((L )tmp___3);
        }
      } else {
        tmp___3 = kerr("parse");
        return ((L )tmp___3);
      }
    }
  }
  a = (I )0;
  while (1) {
    if (a < -1LL + *d___0) {
      tmp___5 = adverbClass(*(p + (-1LL - a)));
      if (! tmp___5) {
        break;
      }
    } else {
      break;
    }
    a ++;
  }
  g = Kv();
  tmp___6 = newK((I )-4, a + 2LL);
  ko = tmp___6;
  tmp___7 = OOM_CD((I )0, g, ko, (V )-1);
  if (! tmp___7) {
    return ((I )0);
  }
  g->n = (I )0;
  *((V *)(g->k) + 2) = (V )ko;
  o = (V *)((S *)(((K )*((V *)(g->k) + 2))->k));
  if ((int )*(((s + k) + 1) + 0) == 120) {
    if ((int )*(((s + k) + 1) + 1) == 59) {
      fbr = (I )0;
    }
  }
  tmp___8 = wd_((s + k) + 1, (int )(r - 2LL), dict, func);
  z = (V )tmp___8;
  if (! z) {
    cd(g);
    tmp___9 = kerr("parse");
    return ((L )tmp___9);
  }
  if (*(m + (k - 1LL)) < 0LL) {
    tmp___11 = - *(m + (k - 1LL));
  } else {
    tmp___11 = *(m + (k - 1LL));
  }
  if (12LL == tmp___11) {
    zp = (V *)((S *)(((K )*((V *)(((K )z)->k) + 2))->k));
    while (1) {
      if (*zp) {
        tmp___10 = bk(*zp);
        if (tmp___10) {
          break;
        }
      } else {
        break;
      }
      zp ++;
    }
    switch ((int )*(s + (k - 1LL))) {
    case 58: 
    b___1 = (I )4;
    break;
    case 102: 
    b___1 = (I )5;
    break;
    case 101: 
    b___1 = (I )6;
    break;
    case 111: 
    b___1 = (I )7;
    break;
    }
    ((K )z)->n = b___1;
    cd(g);
    goto grabdone;
  }
  i = (I )0;
  _i___0 = a + 1LL;
  while (i < _i___0) {
    *(o + i) = *(p + ((-1LL - a) + i));
    i ++;
  }
  *(o + (a + 1LL)) = (V )0;
  f = (K *)*(p + (-1LL - a));
  tmp___20 = sva((V )f);
  if (! tmp___20) {
    if (*(m + ((k - 1LL) - a)) < 0LL) {
      tmp___18 = - *(m + ((k - 1LL) - a));
    } else {
      tmp___18 = *(m + ((k - 1LL) - a));
    }
    if (! (11LL == tmp___18)) {
      if (*(m + (k - a)) < 0LL) {
        tmp___19 = - *(m + (k - a));
      } else {
        tmp___19 = *(m + (k - a));
      }
      if (! (11LL == tmp___19)) {
        if (*(m + ((k - 1LL) - a)) < 0LL) {
          tmp___17 = - *(m + ((k - 1LL) - a));
        } else {
          tmp___17 = *(m + ((k - 1LL) - a));
        }
        if (8LL != tmp___17) {
          tmp___12 = ci(*f);
          tmp___13 = newE(LS, tmp___12);
          q = tmp___13;
          kap((K *)((V *)(g->k)) + 3, (V )(& q));
          cd(q);
          tmp___14 = DI(*locals, (*locals)->n - 1LL);
          temp = tmp___14;
          if (temp) {
            cd(temp->k[1]);
            temp->k[1] = (struct k0 *)0;
          }
          tmp___15 = EVP(q);
          *o = (V )tmp___15;
        } else
        if (7LL == (*f)->t) {
          if (3LL == (*f)->n) {
            tmp___16 = 1;
          } else {
            tmp___16 = 0;
          }
        } else {
          tmp___16 = 0;
        }
      }
    }
  }
  *((V *)(g->k) + 5) = z;
  z = (V )g;
  grabdone: 
  *d___0 -= 1LL + a;
  p = w___0 + *d___0;
  break;
  case 5LL: 
  fbr = (I )1;
  fdc = (I )1;
  tmp___21 = Kv();
  z = (V )tmp___21;
  g = newK((I )-3, r - 2LL);
  tmp___22 = OOM_CD((I )0, z, g, (V )-1);
  if (! tmp___22) {
    return ((I )0);
  }
  *((V *)(((K )z)->k) + 2) = (V )g;
  ((K )z)->n = (I )3;
  memcpy((void * __restrict  )((C *)(g->k)), (void const   * __restrict  )((s + k) + 1),
         (size_t )(r - 2LL));
  if (func) {
    *((V *)(((K )z)->k) + 0) = *((V *)(func->k) + 0);
  } else {
    *((V *)(((K )z)->k) + 0) = (V )d_;
  }
  zdict = (K *)((V *)(((K )z)->k)) + 4;
  ydict = (K *)((V *)(((K )z)->k)) + 3;
  tmp___23 = param_validate((s + k) + 1, r - 2LL);
  state = tmp___23;
  if (state > 1LL) {
    tmp___24 = kerr("parameter");
    return ((L )tmp___24);
  }
  if (state) {
    tmp___25 = strchr((char const   *)((s + k) + 1), '[');
    a___0 = tmp___25;
    tmp___26 = strchr((char const   *)a___0, ']');
    b___2 = tmp___26;
    j = wd_(a___0 + 1, (int )((b___2 - a___0) - 1L), zdict, (K )z);
    tmp___27 = OOM_CD((I )0, z, j, (V )-1);
    if (! tmp___27) {
      return ((I )0);
    }
    cd(j);
  } else {
    tmp___28 = Kd();
    t = tmp___28;
    tmp___29 = OOM_CD((I )0, z, t, (V )-1);
    if (! tmp___29) {
      return ((I )0);
    }
    j = wd_((s + k) + 1, (int )(r - 2LL), & t, (K )0);
    tmp___30 = OOM_CD((I )0, z, t, j, (V )-1);
    if (! tmp___30) {
      return ((I )0);
    }
    n___0 = (I )0;
    i___0 = (I )0;
    _i___1 = (I )3;
    while (i___0 < _i___1) {
      tmp___31 = DE(t, IFP[2LL - i___0]);
      if (tmp___31) {
        n___0 = 3LL - i___0;
        break;
      }
      i___0 ++;
    }
    i___1 = (I )0;
    _i___2 = n___0;
    while (i___1 < _i___2) {
      denameD(zdict, IFP[i___1], (I )1);
      i___1 ++;
    }
    cd(t);
    cd(j);
  }
  j = wd_((s + k) + 1, (int )(r - 2LL), ydict, (K )z);
  tmp___32 = OOM_CD((I )0, z, j, (V )-1);
  if (! tmp___32) {
    return ((I )0);
  }
  cd(j);
  break;
  case 9LL: 
  r = v;
  a = (I )1;
  i___2 = (I )0;
  _i___3 = r;
  while (i___2 < _i___3) {
    tmp___33 = stringHasChar((S )".Eein", *(s + (k + i___2)));
    if (tmp___33) {
      a = (I )2;
      break;
    }
    i___2 ++;
  }
  if (1LL == y) {
    tmp___34 = a;
  } else {
    tmp___34 = - a;
  }
  tmp___35 = newK(tmp___34, y);
  z = (V )tmp___35;
  if (! z) {
    return ((I )0);
  }
  i___3 = (I )0;
  _i___4 = r;
  while (i___3 < _i___4) {
    if (*(m + (k + i___3)) >= 0LL) {
      goto __Cont;
    }
    l = (I )1;
    while (*(m + ((l + k) + i___3)) == 9LL) {
      l ++;
    }
    u = strdupn((s + k) + i___3, l);
    if (! u) {
      cd((K )z);
      tmp___36 = kerr("wsfull");
      return ((L )tmp___36);
    }
    if (1LL == a) {
      tmp___37 = formKiCS(u);
      g = tmp___37;
    } else {
      tmp___38 = formKfCS(u);
      g = tmp___38;
    }
    free((void *)u);
    tmp___39 = OOM_CD((I )0, z, g, (V )-1);
    if (! tmp___39) {
      return ((I )0);
    }
    if (1LL == a) {
      tmp___40 = b___1;
      b___1 ++;
      *((I *)(((K )z)->k) + tmp___40) = *((I *)(g->k));
    } else {
      tmp___41 = b___1;
      b___1 ++;
      *((F *)(((K )z)->k) + tmp___41) = *((F *)(g->k));
    }
    cd(g);
    __Cont: /* CIL Label */ 
    i___3 ++;
  }
  break;
  case 6LL: 
  a = unescaped_size((s + k) + 1, r - 2LL);
  if (1LL == a) {
    tmp___42 = 3;
  } else {
    tmp___42 = -3;
  }
  tmp___43 = newK((I )tmp___42, a);
  z = (V )tmp___43;
  unescaped_fill((C *)(((K )z)->k), (s + k) + 1, r - 2LL);
  break;
  case 7LL: 
  r = v;
  if (1LL == y) {
    tmp___44 = 4;
  } else {
    tmp___44 = -4;
  }
  tmp___45 = newK((I )tmp___44, y);
  z = (V )tmp___45;
  i___4 = (I )0;
  _i___5 = r;
  while (i___4 < _i___5) {
    if (*(m + (k + i___4)) >= 0LL) {
      goto __Cont___0;
    }
    a = (I )0;
    while (*(m + (((k + i___4) + 1LL) + a)) > 0LL) {
      a ++;
    }
    tmp___46 = alloc((size_t )(1LL + a));
    u = (S )tmp___46;
    if (34 == (int )*(s + ((k + i___4) + 1LL))) {
      c = (I )2;
    } else {
      c = (I )0;
    }
    tmp___47 = unescaped_fill(u, (((s + k) + i___4) + 1) + c / 2LL, a - c);
    *(u + tmp___47) = (C )0;
    tmp___48 = b___1;
    b___1 ++;
    *((S *)(((K )z)->k) + tmp___48) = sp(u);
    free((void *)u);
    i___4 += a;
    __Cont___0: /* CIL Label */ 
    i___4 ++;
  }
  break;
  case 8LL: 
  e = strdupn(s + k, r);
  u = sp(e);
  free((void *)e);
  if (! u) {
    tmp___49 = kerr("wsfull");
    return ((L )tmp___49);
  }
  if (2LL == r) {
    if (95 == (int )*u) {
      tmp___71 = stringHasChar(n_s, *(u + 1));
      if (tmp___71) {
        if (102 == (int )*(u + 1)) {
          if (func) {
            tmp___50 = ci(func);
            z = (V )tmp___50;
          } else {
            tmp___51 = _n();
            z = (V )tmp___51;
          }
        } else {
          tmp___52 = charpos(n_s, *(u + 1));
          tmp___53 = (*((K (*)())vn_[tmp___52]))();
          z = (V )tmp___53;
        }
      } else {
        goto _L___7;
      }
    } else {
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
  if (func) {
    if ((int )*(u + 0) == 95) {
      if ((int )*(u + 1) != 110) {
        return ((I )0);
      }
    }
    tmp___54 = denameS((S )".k", u, (I )0);
    h = *tmp___54;
    if (7LL == h->t) {
      hh = match((K )*((V *)(h->k) + 2), (K )*((V *)(func->k) + 2));
    }
    if ((unsigned long )dict == (unsigned long )((K *)((V *)(func->k)) + 4)) {
      tmp___55 = newEntry(u);
      q___1 = (V )tmp___55;
      if (! q___1) {
        return ((I )0);
      }
      tmp___56 = kap(dict, (V )(& q___1));
      tmp___57 = OOM_CD((I )0, q___1, tmp___56, (V )-1);
      if (! tmp___57) {
        return ((I )0);
      }
      tmp___58 = EV((K )q___1);
      z = (V )tmp___58;
      cd((K )q___1);
    } else {
      q___0 = DE(*dict, u);
      if (q___0) {
        tmp___59 = EVP(q___0);
        z = (V )tmp___59;
      } else
      if (-10LL == *(m + (k + r))) {
        if (58 == (int )*(s + ((k + r) + 1LL))) {
          if (-10LL == *(m + ((k + r) + 1LL))) {
            if (58 == (int )*(s + (k + r))) {
              r ++;
            }
            tmp___60 = denameS((S )*((V *)(func->k) + 0), u, (I )1);
            z = (V )tmp___60;
          } else {
            goto _L___4;
          }
        } else {
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
      if ((unsigned long )dict == (unsigned long )((K *)((V *)(func->k)) + 3)) {
        if (58 == (int )*(s + (k + r))) {
          if (-10LL == *(m + (k + r))) {
            tmp___61 = denameD(dict, u, (I )1);
            z = (V )tmp___61;
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
      if (7LL == h->t) {
        if (*((I *)(hh->k))) {
          tmp___62 = ci(func);
          z = (V )tmp___62;
          frc = (I )1;
        } else {
          tmp___63 = strstr((char const   *)s, "do[");
          tmp___64 = denameS((S )*((V *)(func->k) + 0), u, (I )((unsigned long )tmp___63 != (unsigned long )((void *)0)));
          z = (V )tmp___64;
        }
      } else {
        tmp___63 = strstr((char const   *)s, "do[");
        tmp___64 = denameS((S )*((V *)(func->k) + 0), u, (I )((unsigned long )tmp___63 != (unsigned long )((void *)0)));
        z = (V )tmp___64;
      }
    }
  } else {
    if (fll > 0LL) {
      fdc = (I )0;
    }
    i___5 = k;
    while (1) {
      tmp___65 = strlen((char const   *)s);
      if (! ((unsigned long long )i___5 < (unsigned long long )tmp___65)) {
        break;
      }
      if (! fbr) {
        if ((int )*(s + i___5) == 59) {
          break;
        } else {
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
      if ((int )*(s + i___5) == 58) {
        fdc = (I )1;
        break;
      } else
      if (fbr) {
        if ((int )*(s + i___5) == 120) {
          fdc = (I )1;
          break;
        } else
        if ((int )*(s + i___5) == 121) {
          fdc = (I )1;
          break;
        } else
        if ((int )*(s + i___5) == 122) {
          fdc = (I )1;
          break;
        }
      }
      i___5 ++;
    }
    tmp___66 = inKtree(dict, u, (I )0);
    z = (V )tmp___66;
    if (fStop) {
      if (! z) {
        tmp___67 = denameD(& stopDict, u, (I )0);
        z = (V )tmp___67;
      }
    }
    if (! fdc) {
      if (! z) {
        tmp___68 = kerr("value");
        err = (L )tmp___68;
        oerr();
        printf((char const   * __restrict  )"%s\n%c\n", u, '^');
        return (err);
      }
    }
    if (! fStop) {
      if (! z) {
        if (fll) {
          if (fdc) {
            tmp___69 = 1;
          } else {
            tmp___69 = 0;
          }
        } else {
          tmp___69 = 0;
        }
        tmp___70 = denameD(dict, u, (I )tmp___69);
        z = (V )tmp___70;
      }
    }
  }
  break;
  case 10LL: 
  if ((int )*(s + k) == 92) {
    z = (V )124;
    break;
  }
  if ((int )*(s + k) == 58) {
    if (k == 0LL) {
      tmp___72 = strlen((char const   *)s);
      if (tmp___72 > 1UL) {
        if ((int )*(s + (k + 1LL)) != 58) {
          z = (V )125;
          break;
        } else {
          goto _L___9;
        }
      } else {
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
    if (k > 0LL) {
      if (k != n - 1LL) {
        if ((int )*(s + (k - 1LL)) == 59) {
          if ((int )*(s + (k + 1LL)) != 59) {
            if ((int )*(s + (k + 1LL)) != 95) {
              if ((int )*(s + (k + 1LL)) != 91) {
                z = (V )125;
                break;
              }
            }
          }
        }
      }
    }
  }
  if (95 == (int )*(s + k)) {
    if (r > 1LL) {
      if (k + r < n) {
        if (58 == (int )*(s + (k + r))) {
          if (-10LL == *(m + (k + r))) {
            tmp___73 = kerr("parse");
            return ((L )tmp___73);
          }
        }
      }
      u = strdupn(s + k, r);
      if (! u) {
        tmp___74 = kerr("parse");
        return ((L )tmp___74);
      }
      i___6 = DT_SPECIAL_VERB_OFFSET;
      while (1) {
        if (i___6 < DT_SIZE) {
          if (! (! DT[i___6].text)) {
            tmp___75 = SC(u, DT[i___6].text);
            if (! tmp___75) {
              break;
            }
          }
        } else {
          break;
        }
        i___6 ++;
      }
      if (i___6 < DT_SIZE) {
        z = (V )i___6;
      }
      free((void *)u);
      if (! z) {
        tmp___76 = kerr("reserved");
        return ((L )tmp___76);
      }
      break;
    }
  }
  grab = (I )0;
  i___7 = (L )0;
  is_colon = (I )(58 == (int )*(s + k));
  name_bracket_assign = (I )0;
  if (k + r < n) {
    if (58 == (int )*(s + (k + r))) {
      if (-10LL == *(m + (k + r))) {
        tmp___77 = 1;
      } else {
        tmp___77 = 0;
      }
    } else {
      tmp___77 = 0;
    }
  } else {
    tmp___77 = 0;
  }
  modifier_colon = (I )tmp___77;
  if (k - i___7 > 0LL) {
    if (is_colon) {
      if (*(m + ((k - i___7) - 1LL)) < 0LL) {
        tmp___78 = - *(m + ((k - i___7) - 1LL));
      } else {
        tmp___78 = *(m + ((k - i___7) - 1LL));
      }
      if (10LL == tmp___78) {
        i___7 ++;
      }
    }
  }
  if (k - i___7 > 0LL) {
    if (*(m + ((k - i___7) - 1LL)) < 0LL) {
      tmp___79 = - *(m + ((k - i___7) - 1LL));
    } else {
      tmp___79 = *(m + ((k - i___7) - 1LL));
    }
    if (2LL == tmp___79) {
      while (*(m + (k - i___7)) != -2LL) {
        i___7 ++;
      }
    }
  }
  if (k - i___7 > 0LL) {
    if (*(m + ((k - i___7) - 1LL)) < 0LL) {
      tmp___80 = - *(m + ((k - i___7) - 1LL));
    } else {
      tmp___80 = *(m + ((k - i___7) - 1LL));
    }
    if (8LL == tmp___80) {
      name_bracket_assign = (I )1;
    }
  }
  if (! is_colon) {
    if (k + 1LL < n) {
      if (58 == (int )*(s + (k + 1LL))) {
        if (! (-10LL == *(m + (k + 1LL)))) {
          name_bracket_assign = (I )0;
        }
      } else {
        name_bracket_assign = (I )0;
      }
    } else {
      name_bracket_assign = (I )0;
    }
  }
  if (i___7) {
    if (is_colon) {
      if (! modifier_colon) {
        if (! name_bracket_assign) {
          tmp___81 = kerr("parse");
          return ((L )tmp___81);
        }
      }
    }
  }
  if ((k + r) + 1LL < n) {
    if ((int )*(s + ((k + r) + 1LL)) == 58) {
      if (-10LL == *(m + ((k + r) + 1LL))) {
        tmp___83 = 0;
      } else {
        goto _L___10;
      }
    } else {
      _L___10: /* CIL Label */ 
      if (*(m + ((k + r) + 1LL)) < 0LL) {
        tmp___82 = - *(m + ((k + r) + 1LL));
      } else {
        tmp___82 = *(m + ((k + r) + 1LL));
      }
      if (3LL != tmp___82) {
        tmp___83 = 1;
      } else {
        tmp___83 = 0;
      }
    }
  } else {
    tmp___83 = 0;
  }
  y_present = (I )tmp___83;
  if (! *d___0) {
    goto _L___11;
  } else {
    if (*(m + (k - 1LL)) < 0LL) {
      tmp___87 = - *(m + (k - 1LL));
    } else {
      tmp___87 = *(m + (k - 1LL));
    }
    if (3LL == tmp___87) {
      goto _L___11;
    } else {
      if (*(m + (k - 1LL)) < 0LL) {
        tmp___88 = - *(m + (k - 1LL));
      } else {
        tmp___88 = *(m + (k - 1LL));
      }
      if (11LL == tmp___88) {
        goto _L___11;
      } else {
        if (*(m + (k - 1LL)) < 0LL) {
          tmp___89 = - *(m + (k - 1LL));
        } else {
          tmp___89 = *(m + (k - 1LL));
        }
        if (10LL == tmp___89) {
          _L___11: /* CIL Label */ 
          if (k + r >= n) {
            a = (I )2;
          } else
          if (-3LL == *(m + (k + r))) {
            a = (I )2;
          } else
          if (-11LL == *(m + (k + r))) {
            a = (I )2;
          } else
          if (-2LL == *(m + (k + r))) {
            a = (I )2;
          } else {
            a = (I )1;
          }
        } else {
          a = (I )2;
        }
      }
    }
  }
  if (is_colon) {
    if (! modifier_colon) {
      a = (I )2;
      if (k > 0LL) {
        if (-3LL != *(m + (k - 1LL))) {
          if (! *(s + (k + 1LL))) {
            if (! name_bracket_assign) {
              tmp___90 = kerr("parse");
              return ((L )tmp___90);
            }
          }
        }
      }
    } else {
      goto _L___12;
    }
  } else
  _L___12: /* CIL Label */ 
  if (name_bracket_assign) {
    if (y_present) {
      a = (I )2;
    } else {
      a = (I )1;
    }
  } else
  if (modifier_colon) {
    *(m + (k + r)) *= -1LL;
    r ++;
    a = (I )1;
    grab = (I )1;
  }
  i___7 = (L )0;
  if (r - grab == 1LL) {
    tmp___91 = charsVerb(*(s + k));
    if (1LL == a) {
      tmp___92 = 0;
    } else {
      tmp___92 = 1;
    }
    z = (V )((DT_VERB_OFFSET + 2LL * tmp___91) + (L )tmp___92);
    if ((unsigned long )z == (unsigned long )((V )61)) {
      if ((int )*(s + k) != 58) {
        z = (V )124;
      }
    }
  } else {
    tmp___93 = atol((char const   *)(s + k));
    jj = tmp___93;
    i___7 = DT_SPECIAL_VERB_OFFSET;
    while (1) {
      if (i___7 < DT_SIZE) {
        if (! (! DT[i___7].text)) {
          tmp___94 = atol((char const   *)DT[i___7].text);
          if (! (jj != tmp___94)) {
            break;
          }
        }
      } else {
        break;
      }
      i___7 ++;
    }
    if (i___7 < DT_SIZE) {
      if (1LL == a) {
        tmp___95 = 0;
      } else {
        tmp___95 = 1;
      }
      z = (V )(i___7 + (L )tmp___95);
    } else {
      tmp___96 = kerr("parse");
      return ((L )tmp___96);
    }
  }
  break;
  case 11LL: 
  tmp___97 = charsAdverb(*(s + k));
  if (r > 1LL) {
    tmp___98 = 3;
  } else {
    tmp___98 = 0;
  }
  z = (V )((DT_ADVERB_OFFSET + tmp___97) + (L )tmp___98);
  break;
  case 3LL: 
  tmp___99 = DT_OFFSET((V )(& end));
  z = (V )tmp___99;
  break;
  }
  switch (- M) {
  case 8LL: 
  if (95 != (int )*u) {
    if (! frc) {
      break;
    }
  }
  case 4LL: ;
  case 2LL: ;
  case 5LL: ;
  case 9LL: ;
  case 6LL: ;
  case 7LL: 
  tmp___100 = newE(LS, (K )z);
  z = (V )tmp___100;
  if (! z) {
    tmp___101 = kerr("wsfull");
    return ((L )tmp___101);
  }
  kap(locals, (V )(& z));
  cd((K )z);
  tmp___102 = EVP((K )z);
  z = (V )tmp___102;
  break;
  }
  cd(hh);
  *p = z;
  (*d___0) ++;
  return (r);
}
}
#pragma merger("0","/tmp/cil-_J6zvKli.i","-g,-pthread,-O3")
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) setenv)(char const   *__name ,
                                                                                   char const   *__value ,
                                                                                   int __replace ) ;
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
extern  __attribute__((__nothrow__)) double log(double __x ) ;
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double round(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t const   * __restrict  __timer ,
                                                         struct tm * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t const   * __restrict  __timer ,
                                                            struct tm * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
I kreci ;
K _ssr(K x___0 , K y , K w___0 ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
K Kf(F x___0 ) ;
K mstat(void) ;
K _kona_exit(K a ) ;
K _dot_t(void) ;
I KC(K a , K b___1 ) ;
I FC(F a , F b___1 ) ;
K _m(void) ;
K _k(void) ;
K _a(void) ;
K _u(void) ;
K _w(void) ;
K _p(void) ;
K _s(void) ;
K _f(void) ;
K _i(void) ;
K _v(void) ;
K _d(void) ;
K _h(void) ;
K NIL ;
K _T(void) ;
I k_epoch_offset ;
K _t(void) ;
K _c(void) ;
K _ss(K a , K b___1 ) ;
K demote(K a ) ;
K promote(K a ) ;
K _sm(K a , K b___1 ) ;
K _setenv(K a , K b___1 ) ;
K _lsq(K a , K b___1 ) ;
K take_reshape(K a , K b___1 ) ;
void vitter(I *a , I n , I N___0 ) ;
F RF(void) ;
K _draw(K a , K b___1 ) ;
K _bin(K x___0 , K y ) ;
K _size(K a ) ;
K _ltime(K a ) ;
K _lt(K a ) ;
K _jd(K a ) ;
K _ic(K a ) ;
K _host(K a ) ;
K _getenv(K a ) ;
K _dj(K a ) ;
K _db(K x___0 ) ;
K _ci(K a ) ;
K floor_ceil(K a , F (*g)(F  ) ) ;
K _ceiling(K a ) ;
I net(K x___0 ) ;
K _abs(K a ) ;
K math(F (*f)(F  ) , K a ) ;
F sqr(F x___0 ) ;
K vf_ex(V q , K g ) ;
K KFIXED ;
K KONA_ARGS ;
K KONA_WHO ;
K KONA_PORT ;
K KONA_GSET ;
K KONA_IDX ;
K KONA_CLIENT ;
K _acos(K a ) ;
K _asin(K a ) ;
K _atan(K a ) ;
K _ceil(K a ) ;
K _cos(K a ) ;
K _cosh(K a ) ;
K _exp(K a ) ;
K _floor(K a ) ;
K _log(K a ) ;
K _sin(K a ) ;
K _sinh(K a ) ;
K _sqr(K a ) ;
K _sqrt(K a ) ;
K _tan(K a ) ;
K _tanh(K a ) ;
K _gtime(K x___0 ) ;
K _inv(K x___0 ) ;
K _binl(K x___0 , K y ) ;
K _di(K x___0 , K y ) ;
K _dv(K x___0 , K y ) ;
K _dvl(K x___0 , K y ) ;
K _hat(K x___0 , K y ) ;
K _in(K x___0 , K y ) ;
K _lin(K x___0 , K y ) ;
K _mul(K x___0 , K y ) ;
K _sv(K x___0 , K y ) ;
K _vs(K x___0 , K y ) ;
K _vsx(K x___0 , K y ) ;
static I CIX(K a , I i , K x___0 ) ;
static I binr(K a , I b___1 , I c , K x___0 ) ;
static I date_from_jdn(I j ) ;
static I jdn_from_date(I year , I month , I day ) ;
static S rangematch(S p , C t , S r ) ;
K gtime_KVAR  ;
K _gtime(K x___0 ) 
{ 
  I a ;
  K k ;
  K tmp ;
  K z ;
  K tmp___0 ;
  I i ;
  I _i___0 ;

  {
  a = kreci;
  if (! gtime_KVAR) {
    gtime_KVAR = X((S )"{(_dj _ x % 86400; 100 _sv 24 60 60 _vsx x ! 86400)}");
    if (! gtime_KVAR) {
      return ((K )0);
    }
    kap(& KFIXED, (V )(& gtime_KVAR));
    cd(gtime_KVAR);
  }
  tmp = newK((I )0, (I )1);
  k = tmp;
  if (! k) {
    return ((K )0);
  }
  k->k[0] = x___0;
  tmp___0 = vf_ex((V )(& gtime_KVAR), k);
  z = tmp___0;
  i = (I )0;
  _i___0 = k->n;
  while (i < _i___0) {
    k->k[i] = (struct k0 *)0;
    i ++;
  }
  cd(k);
  kreci = a + 1LL;
  return (z);
}
}
K inv_KVAR  ;
K _inv(K x___0 ) 
{ 
  I a ;
  K k ;
  K tmp ;
  K z ;
  K tmp___0 ;
  I i ;
  I _i___0 ;

  {
  a = kreci;
  if (! inv_KVAR) {
    inv_KVAR = X((S )"{((2##*x)#1,&#*x)_lsq x}");
    if (! inv_KVAR) {
      return ((K )0);
    }
    kap(& KFIXED, (V )(& inv_KVAR));
    cd(inv_KVAR);
  }
  tmp = newK((I )0, (I )1);
  k = tmp;
  if (! k) {
    return ((K )0);
  }
  k->k[0] = x___0;
  tmp___0 = vf_ex((V )(& inv_KVAR), k);
  z = tmp___0;
  i = (I )0;
  _i___0 = k->n;
  while (i < _i___0) {
    k->k[i] = (struct k0 *)0;
    i ++;
  }
  cd(k);
  kreci = a + 1LL;
  return (z);
}
}
K binl_KVAR  ;
K _binl(K x___0 , K y ) 
{ 
  I a ;
  K k ;
  K tmp ;
  K z ;
  K tmp___0 ;
  I i ;
  I _i___0 ;

  {
  a = kreci;
  if (! binl_KVAR) {
    binl_KVAR = X((S )"{x _bin/: y}");
    if (! binl_KVAR) {
      return ((K )0);
    }
    kap(& KFIXED, (V )(& binl_KVAR));
    cd(binl_KVAR);
  }
  tmp = newK((I )0, (I )2);
  k = tmp;
  if (! k) {
    return ((K )0);
  }
  k->k[0] = x___0;
  k->k[1] = y;
  tmp___0 = vf_ex((V )(& binl_KVAR), k);
  z = tmp___0;
  i = (I )0;
  _i___0 = k->n;
  while (i < _i___0) {
    k->k[i] = (struct k0 *)0;
    i ++;
  }
  cd(k);
  kreci = a + 1LL;
  return (z);
}
}
K dvl_KVAR  ;
K _dvl(K x___0 , K y ) 
{ 
  I a ;
  K k ;
  K tmp ;
  K z ;
  K tmp___0 ;
  I i ;
  I _i___0 ;

  {
  a = kreci;
  if (! dvl_KVAR) {
    dvl_KVAR = X((S )"{x@&(#y)=y?/:x}");
    if (! dvl_KVAR) {
      return ((K )0);
    }
    kap(& KFIXED, (V )(& dvl_KVAR));
    cd(dvl_KVAR);
  }
  tmp = newK((I )0, (I )2);
  k = tmp;
  if (! k) {
    return ((K )0);
  }
  k->k[0] = x___0;
  k->k[1] = y;
  tmp___0 = vf_ex((V )(& dvl_KVAR), k);
  z = tmp___0;
  i = (I )0;
  _i___0 = k->n;
  while (i < _i___0) {
    k->k[i] = (struct k0 *)0;
    i ++;
  }
  cd(k);
  kreci = a + 1LL;
  return (z);
}
}
K di_KVAR  ;
K _di(K x___0 , K y ) 
{ 
  I a ;
  K k ;
  K tmp ;
  K z ;
  K tmp___0 ;
  I i ;
  I _i___0 ;

  {
  a = kreci;
  if (! di_KVAR) {
    di_KVAR = X((S )"{r::[@x;_n;(#x)#1];:[@x;. _f[. x;(!x)?/:y];x@&@[r;y;:;0]]}");
    if (! di_KVAR) {
      return ((K )0);
    }
    kap(& KFIXED, (V )(& di_KVAR));
    cd(di_KVAR);
  }
  tmp = newK((I )0, (I )2);
  k = tmp;
  if (! k) {
    return ((K )0);
  }
  k->k[0] = x___0;
  k->k[1] = y;
  tmp___0 = vf_ex((V )(& di_KVAR), k);
  z = tmp___0;
  i = (I )0;
  _i___0 = k->n;
  while (i < _i___0) {
    k->k[i] = (struct k0 *)0;
    i ++;
  }
  cd(k);
  kreci = a + 1LL;
  return (z);
}
}
K dv_KVAR  ;
K _dv(K x___0 , K y ) 
{ 
  I a ;
  K k ;
  K tmp ;
  K z ;
  K tmp___0 ;
  I i ;
  I _i___0 ;

  {
  a = kreci;
  if (! dv_KVAR) {
    dv_KVAR = X((S )"{x _dvl ,y}");
    if (! dv_KVAR) {
      return ((K )0);
    }
    kap(& KFIXED, (V )(& dv_KVAR));
    cd(dv_KVAR);
  }
  tmp = newK((I )0, (I )2);
  k = tmp;
  if (! k) {
    return ((K )0);
  }
  k->k[0] = x___0;
  k->k[1] = y;
  tmp___0 = vf_ex((V )(& dv_KVAR), k);
  z = tmp___0;
  i = (I )0;
  _i___0 = k->n;
  while (i < _i___0) {
    k->k[i] = (struct k0 *)0;
    i ++;
  }
  cd(k);
  kreci = a + 1LL;
  return (z);
}
}
K in_KVAR  ;
K _in(K x___0 , K y ) 
{ 
  I a ;
  K k ;
  K tmp ;
  K z ;
  K tmp___0 ;
  I i ;
  I _i___0 ;

  {
  a = kreci;
  if (! in_KVAR) {
    in_KVAR = X((S )"{:[@y;x~y;:[~-2=4:y;1;~x~0n;1;0n=+/y];(#y)>y?x;0]}");
    if (! in_KVAR) {
      return ((K )0);
    }
    kap(& KFIXED, (V )(& in_KVAR));
    cd(in_KVAR);
  }
  tmp = newK((I )0, (I )2);
  k = tmp;
  if (! k) {
    return ((K )0);
  }
  k->k[0] = x___0;
  k->k[1] = y;
  tmp___0 = vf_ex((V )(& in_KVAR), k);
  z = tmp___0;
  i = (I )0;
  _i___0 = k->n;
  while (i < _i___0) {
    k->k[i] = (struct k0 *)0;
    i ++;
  }
  cd(k);
  kreci = a + 1LL;
  return (z);
}
}
K lin_KVAR  ;
K _lin(K x___0 , K y ) 
{ 
  I a ;
  K k ;
  K tmp ;
  K z ;
  K tmp___0 ;
  I i ;
  I _i___0 ;

  {
  a = kreci;
  if (! lin_KVAR) {
    lin_KVAR = X((S )"{{:[@y;x~y;:[~-2=4:y;1;~x~0n;1;0n=+/y];(#y)>y?x;0]}[;y]\'x}");
    if (! lin_KVAR) {
      return ((K )0);
    }
    kap(& KFIXED, (V )(& lin_KVAR));
    cd(lin_KVAR);
  }
  tmp = newK((I )0, (I )2);
  k = tmp;
  if (! k) {
    return ((K )0);
  }
  k->k[0] = x___0;
  k->k[1] = y;
  tmp___0 = vf_ex((V )(& lin_KVAR), k);
  z = tmp___0;
  i = (I )0;
  _i___0 = k->n;
  while (i < _i___0) {
    k->k[i] = (struct k0 *)0;
    i ++;
  }
  cd(k);
  kreci = a + 1LL;
  return (z);
}
}
K mul_KVAR  ;
K _mul(K x___0 , K y ) 
{ 
  I a ;
  K k ;
  K tmp ;
  K z ;
  K tmp___0 ;
  I i ;
  I _i___0 ;

  {
  a = kreci;
  if (! mul_KVAR) {
    mul_KVAR = X((S )"{x _dot\\:y}");
    if (! mul_KVAR) {
      return ((K )0);
    }
    kap(& KFIXED, (V )(& mul_KVAR));
    cd(mul_KVAR);
  }
  tmp = newK((I )0, (I )2);
  k = tmp;
  if (! k) {
    return ((K )0);
  }
  k->k[0] = x___0;
  k->k[1] = y;
  tmp___0 = vf_ex((V )(& mul_KVAR), k);
  z = tmp___0;
  i = (I )0;
  _i___0 = k->n;
  while (i < _i___0) {
    k->k[i] = (struct k0 *)0;
    i ++;
  }
  cd(k);
  kreci = a + 1LL;
  return (z);
}
}
K sv_KVAR  ;
K _sv(K x___0 , K y ) 
{ 
  I a ;
  K k ;
  K tmp ;
  K z ;
  K tmp___0 ;
  I i ;
  I _i___0 ;

  {
  a = kreci;
  if (! sv_KVAR) {
    sv_KVAR = X((S )"{{z+y*x}/[0;x;y]}");
    if (! sv_KVAR) {
      return ((K )0);
    }
    kap(& KFIXED, (V )(& sv_KVAR));
    cd(sv_KVAR);
  }
  tmp = newK((I )0, (I )2);
  k = tmp;
  if (! k) {
    return ((K )0);
  }
  k->k[0] = x___0;
  k->k[1] = y;
  tmp___0 = vf_ex((V )(& sv_KVAR), k);
  z = tmp___0;
  i = (I )0;
  _i___0 = k->n;
  while (i < _i___0) {
    k->k[i] = (struct k0 *)0;
    i ++;
  }
  cd(k);
  kreci = a + 1LL;
  return (z);
}
}
K hat_KVAR  ;
K _hat(K x___0 , K y ) 
{ 
  I a ;
  K k ;
  K tmp ;
  K z ;
  K tmp___0 ;
  I i ;
  I _i___0 ;

  {
  a = kreci;
  if (! hat_KVAR) {
    hat_KVAR = X((S )"{:[(1~4:x)|(2~4:x); _f[!x;y];:[@y;_f[x;,y]; x _dvl y]]}");
    if (! hat_KVAR) {
      return ((K )0);
    }
    kap(& KFIXED, (V )(& hat_KVAR));
    cd(hat_KVAR);
  }
  tmp = newK((I )0, (I )2);
  k = tmp;
  if (! k) {
    return ((K )0);
  }
  k->k[0] = x___0;
  k->k[1] = y;
  tmp___0 = vf_ex((V )(& hat_KVAR), k);
  z = tmp___0;
  i = (I )0;
  _i___0 = k->n;
  while (i < _i___0) {
    k->k[i] = (struct k0 *)0;
    i ++;
  }
  cd(k);
  kreci = a + 1LL;
  return (z);
}
}
K ssr_KVAR  ;
K _ssr(K x___0 , K y , K w___0 ) 
{ 
  I a ;
  K k ;
  K tmp ;
  K z ;
  K tmp___0 ;
  I i ;
  I _i___0 ;

  {
  a = kreci;
  if (! ssr_KVAR) {
    ssr_KVAR = X((S )"{if[_n~x;:_n];i:1+2*!_.5*#x:(0,/(0,+/~+\\(>\':0,\"[\"=y)-<\':(\"]\"=y$:),0)+/:x _ss y)_ x;,/ :[7=4:z;@[x;i;z];4:z$:;@[x;i;:[;z]];@[x;i;:;z]]}");
    if (! ssr_KVAR) {
      return ((K )0);
    }
    kap(& KFIXED, (V )(& ssr_KVAR));
    cd(ssr_KVAR);
  }
  tmp = newK((I )0, (I )3);
  k = tmp;
  if (! k) {
    return ((K )0);
  }
  k->k[0] = x___0;
  k->k[1] = y;
  k->k[2] = w___0;
  tmp___0 = vf_ex((V )(& ssr_KVAR), k);
  z = tmp___0;
  i = (I )0;
  _i___0 = k->n;
  while (i < _i___0) {
    k->k[i] = (struct k0 *)0;
    i ++;
  }
  cd(k);
  kreci = a + 1LL;
  return (z);
}
}
K kdef(I n ) 
{ 
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  K tmp___4 ;
  K tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  K tmp___8 ;
  K tmp___9 ;
  K tmp___10 ;

  {
  switch (n) {
  case 98LL: 
  tmp = X((S )"{(_dj _ x % 86400; 100 _sv 24 60 60 _vsx x ! 86400)}");
  return (tmp);
  break;
  case 101LL: 
  tmp___0 = X((S )"{((2##*x)#1,&#*x)_lsq x}");
  return (tmp___0);
  break;
  case 107LL: 
  tmp___1 = X((S )"{x _bin/: y}");
  return (tmp___1);
  break;
  case 108LL: 
  tmp___2 = X((S )"{r::[@x;_n;(#x)#1];:[@x;. _f[. x;(!x)?/:y];x@&@[r;y;:;0]]}");
  return (tmp___2);
  break;
  case 111LL: 
  tmp___3 = X((S )"{x _dvl ,y}");
  return (tmp___3);
  break;
  case 112LL: 
  tmp___4 = X((S )"{x@&(#y)=y?/:x}");
  return (tmp___4);
  break;
  case 113LL: 
  tmp___5 = X((S )"{:[(1~4:x)|(2~4:x); _f[!x;y];:[@y;_f[x;,y]; x _dvl y]]}");
  return (tmp___5);
  break;
  case 114LL: 
  tmp___6 = X((S )"{:[@y;x~y;:[~-2=4:y;1;~x~0n;1;0n=+/y];(#y)>y?x;0]}");
  return (tmp___6);
  break;
  case 115LL: 
  tmp___7 = X((S )"{{:[@y;x~y;:[~-2=4:y;1;~x~0n;1;0n=+/y];(#y)>y?x;0]}[;y]\'x}");
  return (tmp___7);
  break;
  case 117LL: 
  tmp___8 = X((S )"{x _dot\\:y}");
  return (tmp___8);
  break;
  case 121LL: 
  tmp___9 = X((S )"{{z+y*x}/[0;x;y]}");
  return (tmp___9);
  break;
  case 123LL: 
  tmp___10 = X((S )"{if[_n~x;:_n];i:1+2*!_.5*#x:(0,/(0,+/~+\\(>\':0,\"[\"=y)-<\':(\"]\"=y$:),0)+/:x _ss y)_ x;,/ :[7=4:z;@[x;i;z];4:z$:;@[x;i;:[;z]];@[x;i;:;z]]}");
  return (tmp___10);
  break;
  }
  return ((K )0);
}
}
F sqr(F x___0 ) 
{ 
  double tmp ;

  {
  tmp = pow(x___0, (double )2);
  return (tmp);
}
}
K math(F (*f)(F  ) , K a ) 
{ 
  I at___0 ;
  I n ;
  K tmp ;
  I tmp___0 ;
  I t ;
  I tmp___2 ;
  I tmp___3 ;
  K e ;
  K z ;
  K tmp___4 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I tmp___5 ;
  I tmp___6 ;

  {
  at___0 = a->t;
  n = a->n;
  if (at___0 < 0LL) {
    tmp___0 = - at___0;
  } else {
    tmp___0 = at___0;
  }
  if (tmp___0 > 2LL) {
    tmp = kerr("type");
    return (tmp);
  }
  if (at___0 < 0LL) {
    tmp___3 = - at___0;
  } else {
    tmp___3 = at___0;
  }
  if (1LL == tmp___3) {
    tmp___2 = 2LL * at___0;
  } else {
    tmp___2 = at___0;
  }
  t = tmp___2;
  tmp___4 = newK(t, n);
  z = tmp___4;
  if (0LL == at___0) {
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      e = a->k[i];
      z->k[i] = math(f, e);
      if (! z->k[i]) {
        cd(z);
        return ((K )0);
      }
      i ++;
    }
  } else {
    if (at___0 < 0LL) {
      tmp___6 = - at___0;
    } else {
      tmp___6 = at___0;
    }
    if (1LL == tmp___6) {
      i___0 = (I )0;
      _i___1 = n;
      while (i___0 < _i___1) {
        *((F *)(z->k) + i___0) = (*f)((F )*((I *)(a->k) + i___0));
        i___0 ++;
      }
    } else {
      if (at___0 < 0LL) {
        tmp___5 = - at___0;
      } else {
        tmp___5 = at___0;
      }
      if (2LL == tmp___5) {
        i___1 = (I )0;
        _i___2 = n;
        while (i___1 < _i___2) {
          *((F *)(z->k) + i___1) = (*f)(*((F *)(a->k) + i___1));
          i___1 ++;
        }
      }
    }
  }
  return (z);
}
}
K _kona_exit(K a ) 
{ 
  K tmp ;
  I tmp___0 ;

  {
  if (a->t < 0LL) {
    tmp___0 = - a->t;
  } else {
    tmp___0 = a->t;
  }
  if (1LL != tmp___0) {
    tmp = kerr("type");
    return (tmp);
  }
  exit((int )*((I *)(a->k)));
}
}
K _acos(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& acos, a);
  return (tmp);
}
}
K _asin(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& asin, a);
  return (tmp);
}
}
K _atan(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& atan, a);
  return (tmp);
}
}
K _ceil(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& ceil, a);
  return (tmp);
}
}
K _cos(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& cos, a);
  return (tmp);
}
}
K _cosh(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& cosh, a);
  return (tmp);
}
}
K _exp(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& exp, a);
  return (tmp);
}
}
K _floor(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& floor, a);
  return (tmp);
}
}
K _log(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& log, a);
  return (tmp);
}
}
K _sin(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& sin, a);
  return (tmp);
}
}
K _sinh(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& sinh, a);
  return (tmp);
}
}
K _sqr(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& sqr, a);
  return (tmp);
}
}
K _sqrt(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& sqrt, a);
  return (tmp);
}
}
K _tan(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& tan, a);
  return (tmp);
}
}
K _tanh(K a ) 
{ 
  K tmp ;

  {
  tmp = math(& tanh, a);
  return (tmp);
}
}
S n_s  =    (S )"Tacdfhikmnpstuvw";
V vn_[17]  = 
  {      (V )(& _T),      (V )(& _a),      (V )(& _c),      (V )(& _d), 
        (V )(& _f),      (V )(& _h),      (V )(& _i),      (V )(& _k), 
        (V )(& _m),      (V )(& _n),      (V )(& _p),      (V )(& _s), 
        (V )(& _t),      (V )(& _u),      (V )(& _v),      (V )(& _w), 
        (V )0};
K _abs(K a ) 
{ 
  I t ;
  I n ;
  K tmp ;
  I tmp___0 ;
  K z ;
  K tmp___1 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I tmp___2 ;
  I tmp___3 ;

  {
  t = a->t;
  n = a->n;
  if (t < 0LL) {
    tmp___0 = - t;
  } else {
    tmp___0 = t;
  }
  if (tmp___0 > 2LL) {
    tmp = kerr("type");
    return (tmp);
  }
  tmp___1 = newK(t, n);
  z = tmp___1;
  if (0LL == t) {
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      z->k[i] = _abs(a->k[i]);
      i ++;
    }
  } else {
    if (t < 0LL) {
      tmp___3 = - t;
    } else {
      tmp___3 = t;
    }
    if (1LL == tmp___3) {
      i___0 = (I )0;
      _i___1 = n;
      while (i___0 < _i___1) {
        if (*((I *)(a->k) + i___0) < 0LL) {
          *((I *)(z->k) + i___0) = - *((I *)(a->k) + i___0);
        } else {
          *((I *)(z->k) + i___0) = *((I *)(a->k) + i___0);
        }
        i___0 ++;
      }
    } else {
      if (t < 0LL) {
        tmp___2 = - t;
      } else {
        tmp___2 = t;
      }
      if (2LL == tmp___2) {
        i___1 = (I )0;
        _i___2 = n;
        while (i___1 < _i___2) {
          if (*((F *)(a->k) + i___1) < (F )0) {
            *((F *)(z->k) + i___1) = - *((F *)(a->k) + i___1);
          } else {
            *((F *)(z->k) + i___1) = *((F *)(a->k) + i___1);
          }
          i___1 ++;
        }
      }
    }
  }
  return (z);
}
}
I net(K x___0 ) 
{ 
  I tmp ;

  {
  tmp = rep(x___0, (I )0);
  return ((I )((unsigned long long )sizeof(M1 ) + (unsigned long long )tmp));
}
}
K _bd(K x___0 ) 
{ 
  I s ;
  I tmp ;
  K z ;
  K tmp___0 ;
  M1 *m ;
  I u ;

  {
  tmp = net(x___0);
  s = tmp;
  tmp___0 = newK((I )-3, s);
  z = tmp___0;
  if (! z) {
    return ((K )0);
  }
  m = (M1 *)((V )(z->k));
  u = (I )1;
  m->a = *((S )(& u));
  m->n = (I )((unsigned long long )s - (unsigned long long )sizeof(M1 ));
  wrep(x___0, (V )m + sizeof(M1 ), (I )0);
  return (z);
}
}
K _ceiling(K a ) 
{ 
  K tmp ;

  {
  tmp = floor_ceil(a, & ceil);
  return (tmp);
}
}
K _ci(K a ) 
{ 
  I t ;
  I n ;
  K tmp ;
  I tmp___0 ;
  K z ;
  K tmp___1 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;

  {
  t = a->t;
  n = a->n;
  if (t < 0LL) {
    tmp___0 = - t;
  } else {
    tmp___0 = t;
  }
  if (tmp___0 > 1LL) {
    tmp = kerr("type");
    return (tmp);
  }
  tmp___1 = newK(t * 3LL, n);
  z = tmp___1;
  if (! t) {
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      z->k[i] = _ci(a->k[i]);
      i ++;
    }
  } else {
    i___0 = (I )0;
    _i___1 = n;
    while (i___0 < _i___1) {
      *((C *)(z->k) + i___0) = (C )((UC )(*((I *)(a->k) + i___0) % 256LL));
      i___0 ++;
    }
  }
  return (z);
}
}
K _db(K x___0 ) 
{ 
  K tmp ;
  K tmp___0 ;
  M1 *m ;
  K tmp___1 ;
  V p ;
  I b___1 ;
  I u ;
  C a ;
  K tmp___2 ;

  {
  if (-3LL != x___0->t) {
    tmp = kerr("type");
    return (tmp);
  }
  if ((unsigned long long )x___0->n < (unsigned long long )sizeof(M1 )) {
    tmp___0 = kerr("length");
    return (tmp___0);
  }
  m = (M1 *)((V )((C *)(x___0->k)));
  if ((unsigned long long )m->n + (unsigned long long )sizeof(M1 ) != (unsigned long long )x___0->n) {
    tmp___1 = kerr("length");
    return (tmp___1);
  }
  p = (V )m + sizeof(M1 );
  b___1 = (I )0;
  u = (I )1;
  a = *((S )(& u));
  tmp___2 = rrep(p, p + m->n, & b___1, (I )0, (I )((int )m->a != (int )a));
  return (tmp___2);
}
}
K _dj(K a ) 
{ 
  I t ;
  I n ;
  K tmp ;
  I tmp___0 ;
  K z ;
  K tmp___1 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;

  {
  t = a->t;
  n = a->n;
  if (t < 0LL) {
    tmp___0 = - t;
  } else {
    tmp___0 = t;
  }
  if (tmp___0 > 1LL) {
    tmp = kerr("type");
    return (tmp);
  }
  tmp___1 = newK(t, n);
  z = tmp___1;
  if (! t) {
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      z->k[i] = _dj(a->k[i]);
      i ++;
    }
  } else {
    i___0 = (I )0;
    _i___1 = n;
    while (i___0 < _i___1) {
      *((I *)(z->k) + i___0) = date_from_jdn(*((I *)(a->k) + i___0));
      i___0 ++;
    }
  }
  return (z);
}
}
K _getenv(K a ) 
{ 
  S u ;
  S tmp ;
  char *tmp___0 ;
  K z ;
  I c ;
  size_t tmp___1 ;

  {
  tmp = CSK(a);
  tmp___0 = getenv((char const   *)tmp);
  u = tmp___0;
  if (u) {
    tmp___1 = strlen((char const   *)u);
    c = (I )tmp___1;
    z = newK((I )-3, c);
    if (! z) {
      return ((K )0);
    }
    memcpy((void * __restrict  )((C *)(z->k)), (void const   * __restrict  )u, (size_t )c);
  } else {
    z = _n();
  }
  return (z);
}
}
K _host(K a ) 
{ 
  I t ;
  struct addrinfo b___1 ;
  struct addrinfo *c ;
  I q ;
  __uint32_t tmp ;
  int *tmp___0 ;
  K tmp___1 ;
  int tmp___2 ;
  struct sockaddr_in s ;
  C host[1024] ;
  int *tmp___3 ;
  S tmp___4 ;
  K tmp___5 ;
  int tmp___6 ;
  K tmp___7 ;
  int *tmp___8 ;
  K tmp___9 ;

  {
  t = a->t;
  if (4LL == t) {
    memset((void *)(& b___1), 0, sizeof(b___1));
    b___1.ai_family = 2;
    b___1.ai_socktype = 1;
    tmp___2 = getaddrinfo((char const   * __restrict  )*((S *)(a->k)), (char const   * __restrict  )0,
                          (struct addrinfo  const  * __restrict  )(& b___1), (struct addrinfo ** __restrict  )(& c));
    if (! tmp___2) {
      tmp = __bswap_32(((struct sockaddr_in *)c->ai_addr)->sin_addr.s_addr);
      q = (I )tmp;
      freeaddrinfo(c);
      tmp___0 = __errno_location();
      *tmp___0 = 0;
      tmp___1 = Ki(q);
      return (tmp___1);
    }
  } else
  if (1LL == t) {
    memset((void *)(& s), 0, sizeof(s));
    s.sin_family = (sa_family_t )2;
    s.sin_addr.s_addr = __bswap_32((__uint32_t )*((I *)(a->k)));
    tmp___6 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& s)),
                          (socklen_t )sizeof(s), (char * __restrict  )(host), (socklen_t )sizeof(host),
                          (char * __restrict  )0, (socklen_t )0, 0);
    if (! tmp___6) {
      tmp___3 = __errno_location();
      *tmp___3 = 0;
      tmp___4 = sp(host);
      tmp___5 = Ks(tmp___4);
      return (tmp___5);
    }
  } else {
    tmp___7 = kerr("type");
    return (tmp___7);
  }
  tmp___8 = __errno_location();
  *tmp___8 = 0;
  tmp___9 = kerr("value");
  return (tmp___9);
}
}
K _ic(K a ) 
{ 
  I t ;
  I n ;
  K tmp ;
  I tmp___0 ;
  K z ;
  K tmp___1 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;

  {
  t = a->t;
  n = a->n;
  if (t) {
    if (t < 0LL) {
      tmp___0 = - t;
    } else {
      tmp___0 = t;
    }
    if (3LL != tmp___0) {
      tmp = kerr("type");
      return (tmp);
    }
  }
  tmp___1 = newK(t / 3LL, n);
  z = tmp___1;
  if (! t) {
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      z->k[i] = _ic(a->k[i]);
      i ++;
    }
  } else {
    i___0 = (I )0;
    _i___1 = n;
    while (i___0 < _i___1) {
      *((I *)(z->k) + i___0) = (I )((UC )*((C *)(a->k) + i___0));
      i___0 ++;
    }
  }
  return (z);
}
}
K _jd(K a ) 
{ 
  I t ;
  I n ;
  I x___0 ;
  K tmp ;
  I tmp___0 ;
  K z ;
  K tmp___1 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;

  {
  t = a->t;
  n = a->n;
  if (t < 0LL) {
    tmp___0 = - t;
  } else {
    tmp___0 = t;
  }
  if (tmp___0 > 1LL) {
    tmp = kerr("type");
    return (tmp);
  }
  tmp___1 = newK(t, n);
  z = tmp___1;
  if (! t) {
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      z->k[i] = _jd(a->k[i]);
      i ++;
    }
  } else {
    i___0 = (I )0;
    _i___1 = n;
    while (i___0 < _i___1) {
      x___0 = *((I *)(a->k) + i___0);
      *((I *)(z->k) + i___0) = jdn_from_date(x___0 / 10000LL, (x___0 / 100LL) % 100LL,
                                             x___0 % 100LL);
      i___0 ++;
    }
  }
  return (z);
}
}
K _lt(K a ) 
{ 
  I t ;
  I n ;
  K tmp ;
  I tmp___0 ;
  time_t b___1 ;
  struct tm c ;
  I d___0 ;
  K z ;
  K tmp___1 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;

  {
  t = a->t;
  n = a->n;
  if (t < 0LL) {
    tmp___0 = - t;
  } else {
    tmp___0 = t;
  }
  if (1LL < tmp___0) {
    tmp = kerr("type");
    return (tmp);
  }
  b___1 = (time_t )0;
  localtime_r((time_t const   * __restrict  )(& b___1), (struct tm * __restrict  )(& c));
  d___0 = (I )c.tm_gmtoff;
  tmp___1 = newK(t, n);
  z = tmp___1;
  if (! t) {
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      z->k[i] = _lt(a->k[i]);
      i ++;
    }
  } else {
    i___0 = (I )0;
    _i___1 = n;
    while (i___0 < _i___1) {
      *((I *)(z->k) + i___0) = *((I *)(a->k) + i___0) + d___0;
      i___0 ++;
    }
  }
  return (z);
}
}
K _ltime(K a ) 
{ 
  K tmp ;
  K tmp___0 ;

  {
  tmp = _lt(a);
  tmp___0 = _gtime(tmp);
  return (tmp___0);
}
}
I stat_sz(S u , I *n ) 
{ 
  struct stat s ;
  int tmp ;

  {
  tmp = stat((char const   * __restrict  )u, (struct stat * __restrict  )(& s));
  if (tmp) {
    return ((I )-1);
  }
  *n = (I )s.st_size;
  return ((I )0);
}
}
K _size(K a ) 
{ 
  I t ;
  I n ;
  K tmp ;
  I tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  K tmp___3 ;
  S tmp___4 ;
  I tmp___5 ;
  K tmp___6 ;

  {
  t = a->t;
  n = (I )0;
  if (4LL != t) {
    if (t < 0LL) {
      tmp___0 = - t;
    } else {
      tmp___0 = t;
    }
    if (3LL != tmp___0) {
      tmp = kerr("type");
      return (tmp);
    }
  }
  tmp___4 = CSK(a);
  tmp___5 = stat_sz(tmp___4, & n);
  if (tmp___5) {
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    tmp___3 = kerr((cS )tmp___2);
    return (tmp___3);
  }
  tmp___6 = Kf((F )n);
  return (tmp___6);
}
}
K _bin(K x___0 , K y ) 
{ 
  K tmp ;
  I tmp___0 ;
  K tmp___1 ;

  {
  if (x___0->t > 0LL) {
    tmp = kerr("rank");
    return (tmp);
  }
  tmp___0 = binr(x___0, (I )0, x___0->n - 1LL, y);
  tmp___1 = Ki(tmp___0);
  return (tmp___1);
}
}
K _draw(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  K y ;
  K z ;
  I c ;
  I n ;
  I j ;
  I k ;
  I s ;
  K tmp ;
  I tmp___0 ;
  I i ;
  I _i___0 ;
  K tmp___1 ;
  K tmp___2 ;
  int tmp___3 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  F tmp___4 ;
  I d___0 ;
  F tmp___5 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  c = *((I *)(b___1->k));
  n = (I )1;
  j = (I )0;
  if (at___0 < 0LL) {
    tmp___0 = - at___0;
  } else {
    tmp___0 = at___0;
  }
  if (1LL != tmp___0) {
    tmp = kerr("int");
    return (tmp);
  } else
  if (1LL != bt) {
    tmp = kerr("int");
    return (tmp);
  }
  i = (I )0;
  _i___0 = an;
  while (i < _i___0) {
    n *= *((I *)(a->k) + i);
    if (n < 0LL) {
      tmp___1 = kerr("int");
      return (tmp___1);
    }
    i ++;
  }
  if (c < 0LL) {
    if (n > - c) {
      tmp___2 = kerr("length");
      return (tmp___2);
    }
  }
  if (c) {
    tmp___3 = -1;
  } else {
    tmp___3 = -2;
  }
  y = newK((I )tmp___3, n);
  if (! c) {
    i___0 = (I )0;
    _i___1 = n;
    while (i___0 < _i___1) {
      *((F *)(y->k) + i___0) = RF();
      i___0 ++;
    }
  } else
  if (c > 0LL) {
    i___1 = (I )0;
    _i___2 = n;
    while (i___1 < _i___2) {
      tmp___4 = RF();
      *((I *)(y->k) + i___1) = (I )((F )c * tmp___4);
      i___1 ++;
    }
  } else
  if (c < 0LL) {
    d___0 = - c;
    vitter((I *)(y->k), y->n, d___0);
    j = n - 1LL;
    while (j > 0LL) {
      tmp___5 = RF();
      k = (I )((F )(1LL + j) * tmp___5);
      s = *((I *)(y->k) + j);
      *((I *)(y->k) + j) = *((I *)(y->k) + k);
      *((I *)(y->k) + k) = s;
      j --;
    }
  }
  z = take_reshape(a, y);
  cd(y);
  return (z);
}
}
static void vitter_a(I *a , I n , I N___0 , I j ) 
{ 
  I S___0 ;
  I i ;
  F top ;
  F Nreal ;
  F V___0 ;
  F quot ;
  I tmp ;
  double tmp___0 ;
  F tmp___1 ;
  double tmp___2 ;
  I tmp___3 ;

  {
  i = (I )0;
  top = (F )(N___0 - n);
  Nreal = (F )N___0;
  while (n >= 2LL) {
    V___0 = RF();
    S___0 = (I )0;
    quot = top / Nreal;
    while (quot > V___0) {
      S___0 ++;
      top -= (F )1;
      Nreal -= (F )1;
      quot = (quot * top) / Nreal;
    }
    j += S___0 + 1LL;
    tmp = i;
    i ++;
    *(a + tmp) = j;
    Nreal -= (F )1;
    n --;
  }
  tmp___0 = round(Nreal);
  tmp___1 = RF();
  tmp___2 = floor(tmp___0 * tmp___1);
  S___0 = (I )tmp___2;
  j += S___0 + 1LL;
  tmp___3 = i;
  i ++;
  *(a + tmp___3) = j;
  return;
}
}
void vitter(I *a , I n , I N___0 ) 
{ 
  I i ;
  I j ;
  I t ;
  I qu1 ;
  I S___0 ;
  I negalphainv ;
  I threshold ;
  F nreal ;
  F Nreal ;
  F ninv ;
  F nmin1inv ;
  F Vprime ;
  F tmp ;
  double tmp___0 ;
  double tmp___1 ;
  F qu1real ;
  F negSreal ;
  F U ;
  F X___0 ;
  F y1___0 ;
  F y2 ;
  F top ;
  F bottom___0 ;
  F limit ;
  double tmp___2 ;
  F tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  F tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  F tmp___10 ;
  double tmp___11 ;
  I tmp___12 ;
  double tmp___13 ;
  I tmp___14 ;

  {
  i = (I )0;
  j = (I )-1;
  qu1 = (- n + 1LL) + N___0;
  negalphainv = (I )-13;
  threshold = - negalphainv * n;
  nreal = (F )n;
  Nreal = (F )N___0;
  ninv = 1.0 / (double )n;
  nmin1inv = 1.0 / (double )(n - 1LL);
  tmp = RF();
  tmp___0 = log(tmp);
  tmp___1 = exp(tmp___0 * ninv);
  Vprime = tmp___1;
  qu1real = (- nreal + 1.0) + Nreal;
  while (1) {
    if (n > 1LL) {
      if (! (threshold < N___0)) {
        break;
      }
    } else {
      break;
    }
    nmin1inv = 1.0 / (- 1.0 + nreal);
    while (1) {
      while (1) {
        X___0 = Nreal * (- Vprime + 1.0);
        tmp___2 = floor(X___0);
        S___0 = (I )tmp___2;
        if (S___0 < qu1) {
          break;
        }
        tmp___3 = RF();
        tmp___4 = log(tmp___3);
        Vprime = exp(tmp___4 * ninv);
      }
      U = RF();
      negSreal = (F )(- S___0);
      tmp___5 = log((U * Nreal) / qu1real);
      y1___0 = exp(tmp___5 * nmin1inv);
      Vprime = (y1___0 * (- X___0 / Nreal + 1.0)) * (qu1real / (negSreal + qu1real));
      if (Vprime <= 1.0) {
        break;
      }
      y2 = 1.0;
      top = - 1.0 + Nreal;
      if (-1LL + n > S___0) {
        bottom___0 = - nreal + Nreal;
        limit = (F )(- S___0 + N___0);
      } else {
        bottom___0 = (- 1.0 + negSreal) + Nreal;
        limit = (F )qu1;
      }
      t = N___0 - 1LL;
      while ((F )t >= limit) {
        y2 = (y2 * top) / bottom___0;
        top -= (F )1;
        bottom___0 -= (F )1;
        t --;
      }
      tmp___8 = log(y2);
      tmp___9 = exp(tmp___8 * nmin1inv);
      if (Nreal / (- X___0 + Nreal) >= y1___0 * tmp___9) {
        tmp___6 = RF();
        tmp___7 = log(tmp___6);
        Vprime = exp(tmp___7 * nmin1inv);
        break;
      }
      tmp___10 = RF();
      tmp___11 = log(tmp___10);
      Vprime = exp(tmp___11 * ninv);
    }
    j += S___0 + 1LL;
    tmp___12 = i;
    i ++;
    *(a + tmp___12) = j;
    N___0 = - S___0 + (-1LL + N___0);
    Nreal = negSreal + (- 1.0 + Nreal);
    n --;
    nreal -= (F )1;
    ninv = nmin1inv;
    qu1 = - S___0 + qu1;
    qu1real = negSreal + qu1real;
    threshold += negalphainv;
  }
  if (n > 1LL) {
    vitter_a(a + i, n, N___0, j);
  } else {
    tmp___13 = floor((F )N___0 * Vprime);
    S___0 = (I )tmp___13;
    j += S___0 + 1LL;
    tmp___14 = i;
    i ++;
    *(a + tmp___14) = j;
  }
  return;
}
}
static void svdcmp(F **a , I m , I n , F *w___0 , F **v , F *t ) ;
K _lsq(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  F TOL ;
  F s ;
  K tmp ;
  K tmp___0 ;
  K x___0 ;
  K y ;
  K z ;
  I r ;
  K tmp___1 ;
  I i ;
  I _i___0 ;
  K tmp___2 ;
  K tmp___3 ;
  I i___0 ;
  I _i___1 ;
  K tmp___4 ;
  K tmp___5 ;
  K tmp___6 ;
  I n ;
  I m ;
  I tmp___7 ;
  F **u ;
  V tmp___8 ;
  V tmp___9 ;
  F *w___0 ;
  V tmp___10 ;
  F **v ;
  V tmp___11 ;
  V tmp___12 ;
  F *t ;
  V tmp___13 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  I i___4 ;
  I _i___5 ;
  I j ;
  I _j ;
  F wmax ;
  I i___5 ;
  I _i___6 ;
  F thresh ;
  I i___6 ;
  I _i___7 ;
  I i___7 ;
  I _i___8 ;
  I k ;
  I _k___0 ;
  I tmp___14 ;
  I i___8 ;
  I _i___9 ;
  I j___0 ;
  I _j___0 ;
  F tmp___15 ;
  I i___9 ;
  I _i___10 ;
  I j___1 ;
  I _j___1 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  TOL = 1.0e-6;
  if (at___0 > 0LL) {
    tmp = kerr("type");
    return (tmp);
  } else
  if (at___0 < -2LL) {
    tmp = kerr("type");
    return (tmp);
  } else
  if (bt) {
    tmp = kerr("type");
    return (tmp);
  }
  if (! an) {
    tmp___0 = kerr("length");
    return (tmp___0);
  } else
  if (! bn) {
    tmp___0 = kerr("length");
    return (tmp___0);
  }
  r = (b___1->k[0])->n;
  if (r <= 0LL) {
    tmp___1 = kerr("length");
    return (tmp___1);
  }
  i = (I )0;
  _i___0 = bn;
  while (i < _i___0) {
    y = b___1->k[i];
    if (y->t != -1LL) {
      if (y->t != -2LL) {
        tmp___2 = kerr("type");
        return (tmp___2);
      }
    }
    if (r != y->n) {
      tmp___3 = kerr("length");
      return (tmp___3);
    }
    i ++;
  }
  if (! at___0) {
    i___0 = (I )0;
    _i___1 = an;
    while (i___0 < _i___1) {
      y = a->k[i___0];
      if (y->t != -1LL) {
        if (y->t != -2LL) {
          tmp___4 = kerr("type");
          return (tmp___4);
        }
      }
      if (r != y->n) {
        tmp___5 = kerr("length");
        return (tmp___5);
      }
      i___0 ++;
    }
  } else
  if (r != an) {
    tmp___6 = kerr("length");
    return (tmp___6);
  }
  n = bn;
  if (r > n) {
    tmp___7 = r;
  } else {
    tmp___7 = n;
  }
  m = tmp___7;
  tmp___8 = alloc((size_t )((unsigned long long )m * (unsigned long long )sizeof(F *)));
  u = (F **)tmp___8;
  tmp___9 = alloc((size_t )((unsigned long long )(n * m) * (unsigned long long )sizeof(F )));
  *(u + 0) = (F *)tmp___9;
  tmp___10 = alloc((size_t )((unsigned long long )n * (unsigned long long )sizeof(F )));
  w___0 = (F *)tmp___10;
  tmp___11 = alloc((size_t )((unsigned long long )n * (unsigned long long )sizeof(F *)));
  v = (F **)tmp___11;
  tmp___12 = alloc((size_t )((unsigned long long )(n * n) * (unsigned long long )sizeof(F )));
  *(v + 0) = (F *)tmp___12;
  tmp___13 = alloc((size_t )((unsigned long long )n * (unsigned long long )sizeof(F )));
  t = (F *)tmp___13;
  i___1 = (I )0;
  _i___2 = m;
  while (i___1 < _i___2) {
    *(u + i___1) = *(u + 0) + n * i___1;
    i___1 ++;
  }
  i___2 = (I )0;
  _i___3 = n;
  while (i___2 < _i___3) {
    *(v + i___2) = *(v + 0) + n * i___2;
    i___2 ++;
  }
  i___3 = (I )0;
  _i___4 = n * m;
  while (i___3 < _i___4) {
    *(*(u + 0) + i___3) = (F )0;
    i___3 ++;
  }
  i___4 = (I )0;
  _i___5 = r;
  while (i___4 < _i___5) {
    j = (I )0;
    _j = n;
    while (j < _j) {
      y = b___1->k[j];
      if (-2LL == y->t) {
        *(*(u + i___4) + j) = *((F *)(y->k) + i___4);
      } else {
        *(*(u + i___4) + j) = (F )*((I *)(y->k) + i___4);
      }
      j ++;
    }
    i___4 ++;
  }
  svdcmp(u, m, n, w___0, v, t);
  wmax = 0.0;
  i___5 = (I )0;
  _i___6 = n;
  while (i___5 < _i___6) {
    if (*(w___0 + i___5) > wmax) {
      wmax = *(w___0 + i___5);
    }
    i___5 ++;
  }
  thresh = TOL * wmax;
  i___6 = (I )0;
  _i___7 = n;
  while (i___6 < _i___7) {
    if (*(w___0 + i___6) < thresh) {
      *(w___0 + i___6) = 0.0;
    }
    i___6 ++;
  }
  if (! at___0) {
    z = newK((I )0, an);
    i___7 = (I )0;
    _i___8 = an;
    while (i___7 < _i___8) {
      z->k[i___7] = newK((I )-2, n);
      i___7 ++;
    }
  } else {
    z = newK((I )-2, n);
  }
  k = (I )0;
  if (at___0) {
    tmp___14 = (I )1;
  } else {
    tmp___14 = an;
  }
  _k___0 = tmp___14;
  while (k < _k___0) {
    if (at___0) {
      y = a;
    } else {
      y = a->k[k];
    }
    if (at___0) {
      x___0 = z;
    } else {
      x___0 = z->k[k];
    }
    i___8 = (I )0;
    _i___9 = n;
    while (i___8 < _i___9) {
      s = 0.;
      if (*(w___0 + i___8)) {
        j___0 = (I )0;
        _j___0 = m;
        while (j___0 < _j___0) {
          if (-2LL == y->t) {
            tmp___15 = *((F *)(y->k) + j___0);
          } else {
            tmp___15 = (F )*((I *)(y->k) + j___0);
          }
          s += *(*(u + j___0) + i___8) * tmp___15;
          j___0 ++;
        }
        s /= *(w___0 + i___8);
      }
      *(t + i___8) = s;
      i___8 ++;
    }
    i___9 = (I )0;
    _i___10 = n;
    while (i___9 < _i___10) {
      s = 0.;
      j___1 = (I )0;
      _j___1 = n;
      while (j___1 < _j___1) {
        s += *(*(v + i___9) + j___1) * *(t + j___1);
        *((F *)(x___0->k) + i___9) = s;
        j___1 ++;
      }
      i___9 ++;
    }
    k ++;
  }
  free((void *)*(u + 0));
  free((void *)u);
  free((void *)w___0);
  free((void *)*(v + 0));
  free((void *)v);
  free((void *)t);
  return (z);
}
}
static F radius(F u , F v ) 
{ 
  F Au ;
  F Av ;
  F Aw ;
  double tmp ;
  double tmp___0 ;

  {
  if (u < (F )0) {
    Au = - u;
  } else {
    Au = u;
  }
  if (v < (F )0) {
    Av = - v;
  } else {
    Av = v;
  }
  if (Au > Av) {
    Aw = Av / Au;
    tmp = sqrt(1. + Aw * Aw);
    return (Au * tmp);
  }
  if (Av != 0.0) {
    Aw = Au / Av;
    tmp___0 = sqrt(1. + Aw * Aw);
    return (Av * tmp___0);
  }
  return (0.0);
}
}
static void svdcmp(F **a , I m , I n , F *w___0 , F **v , F *t ) 
{ 
  I flag ;
  I i ;
  I its ;
  I j ;
  I jj ;
  I k ;
  I l ;
  I nm ;
  I nm1 ;
  I mm1 ;
  F c ;
  F f ;
  F h ;
  F s ;
  F x___0 ;
  F y ;
  F z ;
  F anorm ;
  F g ;
  F scale ;
  F *rv1 ;
  F tmp ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  F tmp___11 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  F tmp___25 ;
  F tmp___26 ;
  F tmp___27 ;
  F tmp___28 ;
  F tmp___29 ;
  F tmp___30 ;
  F tmp___31 ;
  F tmp___32 ;
  F tmp___33 ;
  F tmp___34 ;
  F tmp___35 ;

  {
  nm1 = n - 1LL;
  mm1 = m - 1LL;
  anorm = 0.0;
  g = 0.0;
  scale = 0.0;
  rv1 = t;
  i = (I )0;
  while (i < n) {
    l = i + 1LL;
    *(rv1 + i) = scale * g;
    scale = 0.0;
    s = scale;
    g = s;
    if (i < m) {
      k = i;
      while (k < m) {
        if (*(*(a + k) + i) < (F )0) {
          tmp = - *(*(a + k) + i);
        } else {
          tmp = *(*(a + k) + i);
        }
        scale += tmp;
        k ++;
      }
      if (scale) {
        k = i;
        while (k < m) {
          *(*(a + k) + i) /= scale;
          s += *(*(a + k) + i) * *(*(a + k) + i);
          k ++;
        }
        f = *(*(a + i) + i);
        if (f >= 0.0) {
          tmp___4 = sqrt(s);
          if (tmp___4 < (double )0) {
            tmp___1 = sqrt(s);
            tmp___3 = - tmp___1;
          } else {
            tmp___2 = sqrt(s);
            tmp___3 = tmp___2;
          }
          tmp___10 = tmp___3;
        } else {
          tmp___9 = sqrt(s);
          if (tmp___9 < (double )0) {
            tmp___6 = sqrt(s);
            tmp___8 = - tmp___6;
          } else {
            tmp___7 = sqrt(s);
            tmp___8 = tmp___7;
          }
          tmp___10 = - tmp___8;
        }
        g = - tmp___10;
        h = f * g - s;
        *(*(a + i) + i) = f - g;
        if (i != nm1) {
          j = l;
          while (j < n) {
            s = 0.0;
            k = i;
            while (k < m) {
              s += *(*(a + k) + i) * *(*(a + k) + j);
              k ++;
            }
            f = s / h;
            k = i;
            while (k < m) {
              *(*(a + k) + j) += f * *(*(a + k) + i);
              k ++;
            }
            j ++;
          }
        }
        k = i;
        while (k < m) {
          *(*(a + k) + i) *= scale;
          k ++;
        }
      }
    }
    *(w___0 + i) = scale * g;
    scale = 0.0;
    s = scale;
    g = s;
    if (i < m) {
      if (i != nm1) {
        k = l;
        while (k < n) {
          if (*(*(a + i) + k) < (F )0) {
            tmp___11 = - *(*(a + i) + k);
          } else {
            tmp___11 = *(*(a + i) + k);
          }
          scale += tmp___11;
          k ++;
        }
        if (scale) {
          k = l;
          while (k < n) {
            *(*(a + i) + k) /= scale;
            s += *(*(a + i) + k) * *(*(a + i) + k);
            k ++;
          }
          f = *(*(a + i) + l);
          if (f >= 0.0) {
            tmp___16 = sqrt(s);
            if (tmp___16 < (double )0) {
              tmp___13 = sqrt(s);
              tmp___15 = - tmp___13;
            } else {
              tmp___14 = sqrt(s);
              tmp___15 = tmp___14;
            }
            tmp___22 = tmp___15;
          } else {
            tmp___21 = sqrt(s);
            if (tmp___21 < (double )0) {
              tmp___18 = sqrt(s);
              tmp___20 = - tmp___18;
            } else {
              tmp___19 = sqrt(s);
              tmp___20 = tmp___19;
            }
            tmp___22 = - tmp___20;
          }
          g = - tmp___22;
          h = f * g - s;
          *(*(a + i) + l) = f - g;
          k = l;
          while (k < n) {
            *(rv1 + k) = *(*(a + i) + k) / h;
            k ++;
          }
          if (i != mm1) {
            j = l;
            while (j < m) {
              s = 0.0;
              k = l;
              while (k < n) {
                s += *(*(a + j) + k) * *(*(a + i) + k);
                k ++;
              }
              k = l;
              while (k < n) {
                *(*(a + j) + k) += s * *(rv1 + k);
                k ++;
              }
              j ++;
            }
          }
          k = l;
          while (k < n) {
            *(*(a + i) + k) *= scale;
            k ++;
          }
        }
      }
    }
    if (*(w___0 + i) < (F )0) {
      tmp___27 = - *(w___0 + i);
    } else {
      tmp___27 = *(w___0 + i);
    }
    if (*(rv1 + i) < (F )0) {
      tmp___28 = - *(rv1 + i);
    } else {
      tmp___28 = *(rv1 + i);
    }
    if (anorm > tmp___27 + tmp___28) {
      anorm = anorm;
    } else {
      if (*(w___0 + i) < (F )0) {
        tmp___25 = - *(w___0 + i);
      } else {
        tmp___25 = *(w___0 + i);
      }
      if (*(rv1 + i) < (F )0) {
        tmp___26 = - *(rv1 + i);
      } else {
        tmp___26 = *(rv1 + i);
      }
      anorm = tmp___25 + tmp___26;
    }
    i ++;
  }
  i = n - 1LL;
  while (i >= 0LL) {
    if (i < nm1) {
      if (g) {
        j = l;
        while (j < n) {
          *(*(v + j) + i) = (*(*(a + i) + j) / *(*(a + i) + l)) / g;
          j ++;
        }
        j = l;
        while (j < n) {
          s = 0.0;
          k = l;
          while (k < n) {
            s += *(*(a + i) + k) * *(*(v + k) + j);
            k ++;
          }
          k = l;
          while (k < n) {
            *(*(v + k) + j) += s * *(*(v + k) + i);
            k ++;
          }
          j ++;
        }
      }
      j = l;
      while (j < n) {
        tmp___29 = 0.0;
        *(*(v + j) + i) = tmp___29;
        *(*(v + i) + j) = tmp___29;
        j ++;
      }
    }
    *(*(v + i) + i) = 1.0;
    g = *(rv1 + i);
    l = i;
    i --;
  }
  i = n - 1LL;
  while (i >= 0LL) {
    l = i + 1LL;
    g = *(w___0 + i);
    if (i < nm1) {
      j = l;
      while (j < n) {
        *(*(a + i) + j) = 0.0;
        j ++;
      }
    }
    if (g) {
      g = 1.0 / g;
      if (i != nm1) {
        j = l;
        while (j < n) {
          s = 0.0;
          k = l;
          while (k < m) {
            s += *(*(a + k) + i) * *(*(a + k) + j);
            k ++;
          }
          f = (s / *(*(a + i) + i)) * g;
          k = i;
          while (k < m) {
            *(*(a + k) + j) += f * *(*(a + k) + i);
            k ++;
          }
          j ++;
        }
      }
      j = i;
      while (j < m) {
        *(*(a + j) + i) *= g;
        j ++;
      }
    } else {
      j = i;
      while (j < m) {
        *(*(a + j) + i) = 0.0;
        j ++;
      }
    }
    *(*(a + i) + i) += (F )1;
    i --;
  }
  k = n - 1LL;
  while (k >= 0LL) {
    its = (I )0;
    while (its < 30LL) {
      flag = (I )1;
      l = k;
      while (l >= 0LL) {
        nm = l - 1LL;
        if (*(rv1 + l) < (F )0) {
          tmp___30 = - *(rv1 + l);
        } else {
          tmp___30 = *(rv1 + l);
        }
        if (tmp___30 + anorm == anorm) {
          flag = (I )0;
          break;
        }
        if (*(w___0 + nm) < (F )0) {
          tmp___31 = - *(w___0 + nm);
        } else {
          tmp___31 = *(w___0 + nm);
        }
        if (tmp___31 + anorm == anorm) {
          break;
        }
        l --;
      }
      if (flag) {
        c = 0.0;
        s = 1.0;
        i = l;
        while (i <= k) {
          f = s * *(rv1 + i);
          if (f < (F )0) {
            tmp___32 = - f;
          } else {
            tmp___32 = f;
          }
          if (tmp___32 + anorm != anorm) {
            g = *(w___0 + i);
            h = radius(f, g);
            *(w___0 + i) = h;
            h = 1.0 / h;
            c = g * h;
            s = - f * h;
            j = (I )0;
            while (j < m) {
              y = *(*(a + j) + nm);
              z = *(*(a + j) + i);
              *(*(a + j) + nm) = y * c + z * s;
              *(*(a + j) + i) = z * c - y * s;
              j ++;
            }
          }
          i ++;
        }
      }
      z = *(w___0 + k);
      if (l == k) {
        if (z < 0.0) {
          *(w___0 + k) = - z;
          j = (I )0;
          while (j < n) {
            *(*(v + j) + k) = - *(*(v + j) + k);
            j ++;
          }
        }
        break;
      }
      if (its == 30LL) {
        kerr("limit");
        return;
      }
      x___0 = *(w___0 + l);
      nm = k - 1LL;
      y = *(w___0 + nm);
      g = *(rv1 + nm);
      h = *(rv1 + k);
      f = ((y - z) * (y + z) + (g - h) * (g + h)) / ((2.0 * h) * y);
      g = radius(f, 1.0);
      if (f >= 0.0) {
        if (g < (F )0) {
          tmp___33 = - g;
        } else {
          tmp___33 = g;
        }
        tmp___35 = tmp___33;
      } else {
        if (g < (F )0) {
          tmp___34 = - g;
        } else {
          tmp___34 = g;
        }
        tmp___35 = - tmp___34;
      }
      f = ((x___0 - z) * (x___0 + z) + h * (y / (f + tmp___35) - h)) / x___0;
      s = 1.0;
      c = s;
      j = l;
      while (j <= nm) {
        i = j + 1LL;
        g = *(rv1 + i);
        y = *(w___0 + i);
        h = s * g;
        g = c * g;
        z = radius(f, h);
        *(rv1 + j) = z;
        c = f / z;
        s = h / z;
        f = x___0 * c + g * s;
        g = g * c - x___0 * s;
        h = y * s;
        y *= c;
        jj = (I )0;
        while (jj < n) {
          x___0 = *(*(v + jj) + j);
          z = *(*(v + jj) + i);
          *(*(v + jj) + j) = x___0 * c + z * s;
          *(*(v + jj) + i) = z * c - x___0 * s;
          jj ++;
        }
        z = radius(f, h);
        *(w___0 + j) = z;
        if (z) {
          z = 1.0 / z;
          c = f * z;
          s = h * z;
        }
        f = c * g + s * y;
        x___0 = c * y - s * g;
        jj = (I )0;
        while (jj < m) {
          y = *(*(a + jj) + j);
          z = *(*(a + jj) + i);
          *(*(a + jj) + j) = y * c + z * s;
          *(*(a + jj) + i) = z * c - y * s;
          jj ++;
        }
        j ++;
      }
      *(rv1 + l) = 0.0;
      *(rv1 + k) = f;
      *(w___0 + k) = x___0;
      its ++;
    }
    k --;
  }
  return;
}
}
K _setenv(K a , K b___1 ) 
{ 
  I at___0 ;
  I bt ;
  K tmp ;
  I r ;
  S tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  K tmp___4 ;
  K tmp___5 ;

  {
  at___0 = a->t;
  bt = b___1->t;
  if (at___0 != 4LL) {
    if (bt != -3LL) {
      tmp = kerr("type");
      return (tmp);
    }
  }
  tmp___0 = CSK(b___1);
  tmp___1 = setenv((char const   *)*((S *)(a->k)), (char const   *)tmp___0, 1);
  r = (I )tmp___1;
  if (r) {
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    tmp___4 = kerr((cS )tmp___3);
    return (tmp___4);
  }
  tmp___5 = _n();
  return (tmp___5);
}
}
K _sm(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  K tmp ;
  I tmp___0 ;
  I tmp___1 ;
  K tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I x___0 ;
  int tmp___5 ;
  I y ;
  int tmp___6 ;
  K tmp___7 ;
  K tmp___8 ;
  K tmp___9 ;
  K z ;
  I tmp___10 ;
  K tmp___11 ;
  I i ;
  I _i___0 ;
  struct k0 *tmp___12 ;
  struct k0 *tmp___13 ;
  K tmp___14 ;
  I f ;
  int tmp___18 ;
  S tmp___19 ;
  S tmp___20 ;
  int tmp___21 ;
  K tmp___22 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (0LL != at___0) {
    if (at___0 < 0LL) {
      tmp___0 = - at___0;
    } else {
      tmp___0 = at___0;
    }
    if (3LL != tmp___0) {
      if (at___0 < 0LL) {
        tmp___1 = - at___0;
      } else {
        tmp___1 = at___0;
      }
      if (4LL != tmp___1) {
        tmp = kerr("type");
        return (tmp);
      }
    }
  }
  if (0LL != bt) {
    if (bt < 0LL) {
      tmp___3 = - bt;
    } else {
      tmp___3 = bt;
    }
    if (3LL != tmp___3) {
      if (bt < 0LL) {
        tmp___4 = - bt;
      } else {
        tmp___4 = bt;
      }
      if (4LL != tmp___4) {
        tmp___2 = kerr("type");
        return (tmp___2);
      }
    }
  }
  if (at___0 <= 0LL) {
    if (-3LL != at___0) {
      tmp___5 = 1;
    } else {
      tmp___5 = 0;
    }
  } else {
    tmp___5 = 0;
  }
  x___0 = (I )tmp___5;
  if (bt <= 0LL) {
    if (-3LL != bt) {
      tmp___6 = 1;
    } else {
      tmp___6 = 0;
    }
  } else {
    tmp___6 = 0;
  }
  y = (I )tmp___6;
  if (x___0) {
    if (y) {
      if (an != bn) {
        tmp___7 = kerr("length");
        return (tmp___7);
      }
    }
  }
  if (x___0) {
    goto _L;
  } else
  if (y) {
    _L: /* CIL Label */ 
    if (x___0) {
      tmp___8 = promote(a);
      a = tmp___8;
    } else {
      a = a;
    }
    if (y) {
      tmp___9 = promote(b___1);
      b___1 = tmp___9;
    } else {
      b___1 = b___1;
    }
    if (x___0) {
      tmp___10 = a->n;
    } else {
      tmp___10 = b___1->n;
    }
    tmp___11 = newK((I )0, tmp___10);
    z = tmp___11;
    i = (I )0;
    _i___0 = z->n;
    while (i < _i___0) {
      if (y) {
        tmp___12 = b___1->k[i];
      } else {
        tmp___12 = b___1;
      }
      if (x___0) {
        tmp___13 = a->k[i];
      } else {
        tmp___13 = a;
      }
      z->k[i] = _sm(tmp___13, tmp___12);
      i ++;
    }
    cd(a);
    tmp___14 = demote(z);
    return (tmp___14);
  }
  tmp___19 = CSK(a);
  tmp___20 = CSK(b___1);
  tmp___21 = fnmatch((char const   *)tmp___20, (char const   *)tmp___19, 1 << 1);
  if (tmp___21) {
    tmp___18 = 0;
  } else {
    tmp___18 = 1;
  }
  f = (I )tmp___18;
  tmp___22 = Ki(f);
  return (tmp___22);
}
}
K _ss(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  K tmp ;
  I tmp___0 ;
  I tmp___1 ;
  K tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I x___0 ;
  int tmp___5 ;
  I y ;
  int tmp___6 ;
  K tmp___7 ;
  K tmp___8 ;
  I tmp___9 ;
  K tmp___10 ;
  K tmp___11 ;
  K tmp___12 ;
  K tmp___13 ;
  I tmp___14 ;
  K z ;
  I tmp___15 ;
  K tmp___16 ;
  I i ;
  I _i___0 ;
  struct k0 *tmp___17 ;
  struct k0 *tmp___18 ;
  struct k0 *tmp___19 ;
  I tmp___20 ;
  K tmp___21 ;
  S t ;
  S tmp___22 ;
  S p ;
  S tmp___23 ;
  I lp ;
  size_t tmp___24 ;
  K tmp___25 ;
  I *r ;
  V tmp___26 ;
  I n ;
  size_t tmp___28 ;
  unsigned long long tmp___29 ;
  I tmp___30 ;
  I m ;
  C c ;
  C d___0 ;
  I occ[256] ;
  I i___0 ;
  I _i___1 ;
  C v[256] ;
  C w___0[256] ;
  S q ;
  I i___1 ;
  I _i___2 ;
  S tmp___31 ;
  K tmp___32 ;
  I any ;
  I i___2 ;
  I _i___3 ;
  K tmp___33 ;
  K z___0 ;
  K tmp___34 ;
  I *f ;
  V tmp___35 ;
  I *s ;
  V tmp___36 ;
  I i___3 ;
  I _i___4 ;
  I tmp___37 ;
  I i___4 ;
  I j ;
  I flag ;
  I i___5 ;
  I _i___5 ;
  S tmp___38 ;
  S tmp___39 ;
  I i___6 ;
  I _i___6 ;
  unsigned short const   **tmp___40 ;
  unsigned short const   **tmp___41 ;
  unsigned short const   **tmp___42 ;
  C c___0 ;
  S tmp___43 ;
  I tmp___44 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (0LL != at___0) {
    if (at___0 < 0LL) {
      tmp___0 = - at___0;
    } else {
      tmp___0 = at___0;
    }
    if (3LL != tmp___0) {
      if (at___0 < 0LL) {
        tmp___1 = - at___0;
      } else {
        tmp___1 = at___0;
      }
      if (4LL != tmp___1) {
        tmp = kerr("type");
        return (tmp);
      }
    }
  }
  if (0LL != bt) {
    if (bt < 0LL) {
      tmp___3 = - bt;
    } else {
      tmp___3 = bt;
    }
    if (3LL != tmp___3) {
      if (bt < 0LL) {
        tmp___4 = - bt;
      } else {
        tmp___4 = bt;
      }
      if (4LL != tmp___4) {
        tmp___2 = kerr("type");
        return (tmp___2);
      }
    }
  }
  if (at___0 <= 0LL) {
    if (-3LL != at___0) {
      tmp___5 = 1;
    } else {
      tmp___5 = 0;
    }
  } else {
    tmp___5 = 0;
  }
  x___0 = (I )tmp___5;
  if (bt <= 0LL) {
    if (-3LL != bt) {
      tmp___6 = 1;
    } else {
      tmp___6 = 0;
    }
  } else {
    tmp___6 = 0;
  }
  y = (I )tmp___6;
  if (x___0) {
    if (y) {
      if (an != bn) {
        tmp___7 = kerr("length");
        return (tmp___7);
      }
    }
  }
  if (4LL == at___0) {
    goto _L;
  } else {
    if (at___0 < 0LL) {
      tmp___9 = - at___0;
    } else {
      tmp___9 = at___0;
    }
    if (3LL == tmp___9) {
      _L: /* CIL Label */ 
      if (! an) {
        tmp___8 = kerr("length");
        return (tmp___8);
      }
    }
  }
  if (x___0) {
    goto _L___0;
  } else
  if (y) {
    _L___0: /* CIL Label */ 
    if (x___0) {
      tmp___10 = promote(a);
      a = tmp___10;
    } else {
      tmp___11 = ci(a);
      a = tmp___11;
    }
    if (y) {
      tmp___12 = promote(b___1);
      b___1 = tmp___12;
    } else {
      tmp___13 = ci(b___1);
      b___1 = tmp___13;
    }
    tmp___14 = OOM_CD((I )0, a, b___1, (V )-1);
    if (! tmp___14) {
      return ((K )0);
    }
    if (x___0) {
      tmp___15 = a->n;
    } else {
      tmp___15 = b___1->n;
    }
    tmp___16 = newK((I )0, tmp___15);
    z = tmp___16;
    i = (I )0;
    _i___0 = z->n;
    while (i < _i___0) {
      if (y) {
        tmp___18 = b___1->k[i];
      } else {
        tmp___18 = b___1;
      }
      if (x___0) {
        tmp___19 = a->k[i];
      } else {
        tmp___19 = a;
      }
      tmp___17 = _ss(tmp___19, tmp___18);
      z->k[i] = tmp___17;
      tmp___20 = OOM_CD((I )0, a, b___1, z, tmp___17, (V )-1);
      if (! tmp___20) {
        return ((K )0);
      }
      i ++;
    }
    cd(a);
    cd(b___1);
    tmp___21 = demote(z);
    return (tmp___21);
  }
  tmp___22 = CSK(a);
  t = tmp___22;
  tmp___23 = CSK(b___1);
  p = tmp___23;
  tmp___24 = strlen((char const   *)p);
  lp = (I )tmp___24;
  if (! lp) {
    tmp___25 = kerr("length");
    return (tmp___25);
  }
  tmp___26 = alloc((size_t )((unsigned long long )lp * (unsigned long long )sizeof(I )));
  r = (I *)tmp___26;
  if (a->t < 0LL) {
    tmp___30 = - a->t;
  } else {
    tmp___30 = a->t;
  }
  if (3LL == tmp___30) {
    tmp___29 = (unsigned long long )a->n;
  } else {
    tmp___28 = strlen((char const   *)t);
    tmp___29 = (unsigned long long )tmp___28;
  }
  n = (I )tmp___29;
  m = (I )0;
  i___0 = (I )0;
  _i___1 = (I )256;
  while (i___0 < _i___1) {
    occ[i___0] = (I )-1;
    i___0 ++;
  }
  q = p;
  while (*q) {
    *(r + m) = (I )(q - p);
    if (63 == (int )*q) {
      q ++;
      i___1 = (I )0;
      _i___2 = (I )256;
      while (i___1 < _i___2) {
        occ[i___1] = m;
        i___1 ++;
      }
    } else
    if (91 != (int )*q) {
      tmp___31 = q;
      q ++;
      occ[(I )*tmp___31] = m;
    } else {
      q = rangematch(q + 1, (C )0, v);
      if (! q) {
        free((void *)p);
        tmp___32 = kerr("domain");
        return (tmp___32);
      }
      any = (I )0;
      i___2 = (I )0;
      _i___3 = (I )256;
      while (i___2 < _i___3) {
        if (v[i___2]) {
          occ[i___2] = m;
          any = (I )1;
        }
        i___2 ++;
      }
      if (! any) {
        free((void *)p);
        tmp___33 = newK((I )-1, (I )0);
        return (tmp___33);
      }
    }
    m ++;
  }
  tmp___34 = newK((I )-1, (I )0);
  z___0 = tmp___34;
  tmp___35 = alloc((size_t )((unsigned long long )(m + 1LL) * (unsigned long long )sizeof(I )));
  f = (I *)tmp___35;
  tmp___36 = alloc((size_t )((unsigned long long )(m + 1LL) * (unsigned long long )sizeof(I )));
  s = (I *)tmp___36;
  i___3 = (I )0;
  _i___4 = m + 1LL;
  while (i___3 < _i___4) {
    tmp___37 = (I )0;
    *(s + i___3) = tmp___37;
    *(f + i___3) = tmp___37;
    i___3 ++;
  }
  i___4 = m;
  j = m + 1LL;
  *(f + i___4) = j;
  while (i___4 > 0LL) {
    while (j <= m) {
      flag = (I )0;
      c = *(p + *(r + (i___4 - 1LL)));
      d___0 = *(p + *(r + (j - 1LL)));
      if (63 == (int )c) {
        break;
      } else
      if (63 == (int )d___0) {
        break;
      } else
      if ((int )c == (int )d___0) {
        if (91 != (int )c) {
          if (91 != (int )d___0) {
            break;
          } else {
            goto _L___6;
          }
        } else {
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
      if (91 != (int )c) {
        if (91 == (int )d___0) {
          tmp___39 = rangematch((p + *(r + (j - 1LL))) + 1, c, (S )0);
          if (tmp___39) {
            break;
          } else {
            goto _L___4;
          }
        } else {
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
      if (91 == (int )c) {
        if (91 != (int )d___0) {
          tmp___38 = rangematch((p + *(r + (i___4 - 1LL))) + 1, d___0, (S )0);
          if (tmp___38) {
            break;
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
      if (91 == (int )c) {
        if (91 == (int )d___0) {
          rangematch((p + *(r + (i___4 - 1LL))) + 1, (C )0, v);
          rangematch((p + *(r + (j - 1LL))) + 1, (C )0, w___0);
          i___5 = (I )0;
          _i___5 = (I )256;
          while (i___5 < _i___5) {
            if (v[i___5]) {
              if (w___0[i___5]) {
                flag = (I )1;
                break;
              }
            }
            i___5 ++;
          }
          if (flag) {
            break;
          }
        }
      }
      if (*(s + j) == 0LL) {
        *(s + j) = j - i___4;
      }
      j = *(f + j);
    }
    i___4 --;
    j --;
    *(f + i___4) = j;
  }
  j = *(f + 0);
  i___6 = (I )0;
  _i___6 = m;
  while (i___6 < _i___6) {
    if (*(s + i___6) == 0LL) {
      *(s + i___6) = j;
    }
    if (i___6 == j) {
      j = *(f + j);
    }
    i___6 ++;
  }
  i___4 = (I )0;
  while (i___4 <= n - m) {
    if (4LL == b___1->t) {
      while (1) {
        if (i___4 < n - m) {
          tmp___40 = __ctype_b_loc();
          if (! ((int const   )*(*tmp___40 + (int )*(t + (i___4 + m))) & 8)) {
            if (i___4) {
              tmp___41 = __ctype_b_loc();
              if (! ((int const   )*(*tmp___41 + (int )*(t + (i___4 - 1LL))) & 8)) {
                break;
              }
            } else {
              break;
            }
          }
        } else {
          break;
        }
        i___4 ++;
      }
      if (i___4 == n - m) {
        if (i___4) {
          tmp___42 = __ctype_b_loc();
          if ((int const   )*(*tmp___42 + (int )*(t + (i___4 - 1LL))) & 8) {
            break;
          }
        }
      }
    }
    j = m - 1LL;
    while (j >= 0LL) {
      c___0 = *(p + *(r + j));
      if (! (63 == (int )c___0)) {
        if (91 != (int )c___0) {
          if ((int )c___0 != (int )*(t + (i___4 + j))) {
            break;
          } else {
            goto _L___7;
          }
        } else
        _L___7: /* CIL Label */ 
        if (91 == (int )c___0) {
          tmp___43 = rangematch((p + *(r + j)) + 1, *(t + (i___4 + j)), (S )0);
          if (! tmp___43) {
            break;
          }
        }
      }
      j --;
    }
    if (j < 0LL) {
      kap(& z___0, (V )(& i___4));
      i___4 += m;
    } else {
      if (*(s + (j + 1LL)) > j - occ[(I )*(t + (i___4 + j))]) {
        tmp___44 = *(s + (j + 1LL));
      } else {
        tmp___44 = j - occ[(I )*(t + (i___4 + j))];
      }
      i___4 += tmp___44;
    }
  }
  free((void *)r);
  free((void *)f);
  free((void *)s);
  return (z___0);
}
}
static S rangematch(S p , C t , S r ) 
{ 
  I n ;
  I k ;
  C c ;
  C d___0 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  S tmp ;
  S tmp___0 ;

  {
  k = (I )0;
  n = (I )(94 == (int )*p);
  if (n) {
    p ++;
  }
  if (r) {
    i = (I )0;
    _i___0 = (I )256;
    while (i < _i___0) {
      *(r + i) = (C )n;
      i ++;
    }
  }
  if (93 == (int )*p) {
    if (93 == (int )t) {
      k = (I )1;
    }
    if (r) {
      *(r + (UC )']') = (C )(! n);
    }
    p ++;
  }
  while (1) {
    tmp = p;
    p ++;
    c = *tmp;
    if (! (93 != (int )c)) {
      break;
    }
    if (! c) {
      return ((S )0);
    }
    if (45 == (int )*p) {
      d___0 = *(p + 1);
      if (d___0) {
        if (93 != (int )d___0) {
          p += 2;
          if (! d___0) {
            return ((S )0);
          }
          if ((int )((UC )c) <= (int )((UC )t)) {
            if ((int )((UC )t) <= (int )((UC )d___0)) {
              k = (I )1;
            }
          }
          if (r) {
            i___0 = (I )0;
            _i___1 = (I )((1 + (int )((UC )d___0)) - (int )((UC )c));
            while (i___0 < _i___1) {
              *(r + (i___0 + (I )((UC )c))) = (C )(! n);
              i___0 ++;
            }
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      if ((int )c == (int )t) {
        k = (I )1;
      }
      if (r) {
        *(r + (UC )c) = (C )(! n);
      }
    }
  }
  if (t) {
    if (k == n) {
      tmp___0 = (S )0;
    } else {
      tmp___0 = p;
    }
  } else {
    tmp___0 = p;
  }
  return (tmp___0);
}
}
void Ireverse(K x___0 ) 
{ 
  I i ;
  I _i___0 ;
  I t ;

  {
  i = (I )0;
  _i___0 = x___0->n / 2LL;
  while (i < _i___0) {
    t = *((I *)(x___0->k) + ((x___0->n - i) - 1LL));
    *((I *)(x___0->k) + ((x___0->n - i) - 1LL)) = *((I *)(x___0->k) + i);
    *((I *)(x___0->k) + i) = t;
    i ++;
  }
  return;
}
}
K _vsx(K x___0 , K y ) 
{ 
  K tmp ;
  I tmp___0 ;
  I tmp___1 ;
  K z ;
  I i ;
  I _i___0 ;
  struct k0 *tmp___2 ;
  I tmp___3 ;
  K k ;
  K tmp___4 ;
  I tmp___5 ;
  I i___0 ;
  I _i___1 ;
  struct k0 *tmp___6 ;
  I tmp___7 ;
  K tmp___8 ;
  I a ;
  I b___1 ;
  I c ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  K tmp___9 ;
  I a___0 ;
  I n ;
  I s ;
  I i___3 ;
  I _i___4 ;
  I i___4 ;
  I _i___5 ;
  I i___5 ;
  I _i___6 ;
  I d___0 ;
  I i___6 ;
  I _i___7 ;

  {
  if (y->t < 0LL) {
    tmp___0 = - y->t;
  } else {
    tmp___0 = y->t;
  }
  if (1LL < tmp___0) {
    tmp = kerr("type");
    return (tmp);
  } else {
    if (x___0->t < 0LL) {
      tmp___1 = - x___0->t;
    } else {
      tmp___1 = x___0->t;
    }
    if (1LL != tmp___1) {
      tmp = kerr("type");
      return (tmp);
    }
  }
  z = (K )0;
  if (0LL == y->t) {
    z = newK((I )0, y->n);
    if (! z) {
      return ((K )0);
    }
    i = (I )0;
    _i___0 = y->n;
    while (i < _i___0) {
      tmp___2 = _vsx(x___0, y->k[i]);
      z->k[i] = tmp___2;
      tmp___3 = OOM_CD((I )0, z, tmp___2, (V )-1);
      if (! tmp___3) {
        return ((K )0);
      }
      i ++;
    }
  } else
  if (-1LL == y->t) {
    z = newK((I )0, y->n);
    tmp___4 = Ki((I )0);
    k = tmp___4;
    tmp___5 = OOM_CD((I )0, k, z, (V )-1);
    if (! tmp___5) {
      return ((K )0);
    }
    i___0 = (I )0;
    _i___1 = y->n;
    while (i___0 < _i___1) {
      *((I *)(k->k)) = *((I *)(y->k) + i___0);
      tmp___6 = _vsx(x___0, k);
      z->k[i___0] = tmp___6;
      tmp___7 = OOM_CD((I )0, z, k, tmp___6, (V )-1);
      if (! tmp___7) {
        return ((K )0);
      }
      i___0 ++;
    }
    cd(k);
    z = demote(z);
  } else
  if (1LL == x___0->t) {
    if (*((I *)(x___0->k)) < 2LL) {
      tmp___8 = kerr("domain");
      return (tmp___8);
    }
    z = newK((I )-1, (I )0);
    if (! z) {
      return ((K )0);
    }
    a = *((I *)(x___0->k));
    b___1 = *((I *)(y->k));
    c = b___1 / a;
    while (1) {
      if (! (! z->n)) {
        if (! (b___1 != c)) {
          break;
        }
      }
      kap(& z, (V )(& b___1));
      b___1 = c;
      c = b___1 / a;
    }
    i___1 = (I )0;
    _i___2 = z->n;
    while (i___1 < _i___2) {
      *((I *)(z->k) + i___1) %= a;
      i___1 ++;
    }
    Ireverse(z);
  } else
  if (-1LL == x___0->t) {
    i___2 = (I )0;
    _i___3 = x___0->n;
    while (i___2 < _i___3) {
      if (*((I *)(x___0->k) + i___2) < 1LL) {
        tmp___9 = kerr("domain");
        return (tmp___9);
      }
      i___2 ++;
    }
    z = newK((I )-1, x___0->n);
    if (! z) {
      return ((K )0);
    }
    a___0 = *((I *)(y->k));
    n = z->n;
    if (a___0 < 0LL) {
      s = (I )1;
      i___3 = (I )0;
      _i___4 = x___0->n;
      while (i___3 < _i___4) {
        s *= *((I *)(x___0->k) + i___3);
        i___3 ++;
      }
      a___0 = s - - a___0 % s;
    }
    i___4 = (I )0;
    _i___5 = n;
    while (i___4 < _i___5) {
      *((I *)(z->k) + i___4) = *((I *)(x___0->k) + ((x___0->n - 1LL) - i___4));
      i___4 ++;
    }
    if (n) {
      if (*((I *)(z->k))) {
        *((I *)(z->k)) = a___0 / *((I *)(z->k));
      } else {
        *((I *)(z->k)) = (I )0;
      }
    }
    i___5 = (I )0;
    _i___6 = n - 1LL;
    while (i___5 < _i___6) {
      d___0 = *((I *)(z->k) + (i___5 + 1LL));
      if (d___0) {
        *((I *)(z->k) + (i___5 + 1LL)) = *((I *)(z->k) + i___5) / d___0;
      } else {
        *((I *)(z->k) + (i___5 + 1LL)) = (I )0;
      }
      i___5 ++;
    }
    i___6 = (I )0;
    _i___7 = n - 1LL;
    while (i___6 < _i___7) {
      *((I *)(z->k) + ((n - 1LL) - i___6)) = *((I *)(z->k) + ((n - 2LL) - i___6)) - *((I *)(z->k) + ((n - 1LL) - i___6)) * *((I *)(x___0->k) + i___6);
      i___6 ++;
    }
    if (n) {
      *((I *)(z->k)) = a___0 - *((I *)(z->k)) * *((I *)(x___0->k) + (x___0->n - 1LL));
    }
    Ireverse(z);
    return (z);
  }
  return (z);
}
}
K _vs(K x___0 , K y ) 
{ 
  K tmp ;
  I tmp___0 ;
  I tmp___1 ;
  K z ;
  I i ;
  I _i___0 ;
  struct k0 *tmp___2 ;
  I tmp___3 ;
  K k ;
  K tmp___4 ;
  I tmp___5 ;
  I i___0 ;
  I _i___1 ;
  struct k0 *tmp___6 ;
  I tmp___7 ;
  K tmp___8 ;
  K tmp___9 ;
  I a ;
  I b___1 ;
  I c ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  K tmp___10 ;
  I a___0 ;
  I n ;
  I s ;
  I i___3 ;
  I _i___4 ;
  I tmp___11 ;
  I i___4 ;
  I _i___5 ;
  I i___5 ;
  I _i___6 ;
  I d___0 ;
  I i___6 ;
  I _i___7 ;

  {
  if (y->t < 0LL) {
    tmp___0 = - y->t;
  } else {
    tmp___0 = y->t;
  }
  if (1LL < tmp___0) {
    tmp = kerr("type");
    return (tmp);
  } else {
    if (x___0->t < 0LL) {
      tmp___1 = - x___0->t;
    } else {
      tmp___1 = x___0->t;
    }
    if (1LL != tmp___1) {
      tmp = kerr("type");
      return (tmp);
    }
  }
  z = (K )0;
  if (0LL == y->t) {
    z = newK((I )0, y->n);
    if (! z) {
      return ((K )0);
    }
    i = (I )0;
    _i___0 = y->n;
    while (i < _i___0) {
      tmp___2 = _vs(x___0, y->k[i]);
      z->k[i] = tmp___2;
      tmp___3 = OOM_CD((I )0, z, tmp___2, (V )-1);
      if (! tmp___3) {
        return ((K )0);
      }
      i ++;
    }
  } else
  if (-1LL == y->t) {
    z = newK((I )0, y->n);
    tmp___4 = Ki((I )0);
    k = tmp___4;
    tmp___5 = OOM_CD((I )0, k, z, (V )-1);
    if (! tmp___5) {
      return ((K )0);
    }
    i___0 = (I )0;
    _i___1 = y->n;
    while (i___0 < _i___1) {
      *((I *)(k->k)) = *((I *)(y->k) + i___0);
      tmp___6 = _vs(x___0, k);
      z->k[i___0] = tmp___6;
      tmp___7 = OOM_CD((I )0, z, k, tmp___6, (V )-1);
      if (! tmp___7) {
        return ((K )0);
      }
      i___0 ++;
    }
    cd(k);
    z = demote(z);
  } else
  if (1LL == x___0->t) {
    if (*((I *)(x___0->k)) < 2LL) {
      tmp___8 = kerr("domain");
      return (tmp___8);
    }
    if (*((I *)(y->k)) == 0LL) {
      tmp___9 = X((S )"!0");
      return (tmp___9);
    }
    z = newK((I )-1, (I )0);
    if (! z) {
      return ((K )0);
    }
    a = *((I *)(x___0->k));
    b___1 = *((I *)(y->k));
    c = b___1 / a;
    while (1) {
      if (! (! z->n)) {
        if (! (b___1 != c)) {
          break;
        }
      }
      kap(& z, (V )(& b___1));
      b___1 = c;
      c = b___1 / a;
    }
    i___1 = (I )0;
    _i___2 = z->n;
    while (i___1 < _i___2) {
      *((I *)(z->k) + i___1) %= a;
      i___1 ++;
    }
    Ireverse(z);
  } else
  if (-1LL == x___0->t) {
    i___2 = (I )0;
    _i___3 = x___0->n;
    while (i___2 < _i___3) {
      if (! i___2) {
        if (! *((I *)(x___0->k))) {
          goto __Cont;
        }
      }
      if (*((I *)(x___0->k) + i___2) < 1LL) {
        tmp___10 = kerr("domain");
        return (tmp___10);
      }
      __Cont: /* CIL Label */ 
      i___2 ++;
    }
    z = newK((I )-1, x___0->n);
    if (! z) {
      return ((K )0);
    }
    a___0 = *((I *)(y->k));
    n = z->n;
    if (a___0 < 0LL) {
      s = (I )1;
      i___3 = (I )0;
      _i___4 = x___0->n;
      while (i___3 < _i___4) {
        if (*((I *)(x___0->k) + i___3)) {
          tmp___11 = *((I *)(x___0->k) + i___3);
        } else {
          tmp___11 = (I )-1;
        }
        s *= tmp___11;
        i___3 ++;
      }
      a___0 = s - - a___0 % s;
    }
    i___4 = (I )0;
    _i___5 = n;
    while (i___4 < _i___5) {
      *((I *)(z->k) + i___4) = *((I *)(x___0->k) + ((x___0->n - 1LL) - i___4));
      i___4 ++;
    }
    if (n) {
      if (*((I *)(z->k))) {
        *((I *)(z->k)) = a___0 / *((I *)(z->k));
      } else {
        *((I *)(z->k)) = (I )0;
      }
    }
    i___5 = (I )0;
    _i___6 = n - 1LL;
    while (i___5 < _i___6) {
      d___0 = *((I *)(z->k) + (i___5 + 1LL));
      if (d___0) {
        *((I *)(z->k) + (i___5 + 1LL)) = *((I *)(z->k) + i___5) / d___0;
      } else {
        *((I *)(z->k) + (i___5 + 1LL)) = (I )0;
      }
      i___5 ++;
    }
    i___6 = (I )0;
    _i___7 = n - 1LL;
    while (i___6 < _i___7) {
      *((I *)(z->k) + ((n - 1LL) - i___6)) = *((I *)(z->k) + ((n - 2LL) - i___6)) - *((I *)(z->k) + ((n - 1LL) - i___6)) * *((I *)(x___0->k) + i___6);
      i___6 ++;
    }
    if (n) {
      *((I *)(z->k)) = a___0 - *((I *)(z->k)) * *((I *)(x___0->k) + (x___0->n - 1LL));
    }
    Ireverse(z);
    return (z);
  }
  return (z);
}
}
K _t(void) 
{ 
  time_t tmp ;
  K tmp___0 ;

  {
  tmp = time((time_t *)0);
  tmp___0 = Ki((I )tmp + k_epoch_offset);
  return (tmp___0);
}
}
K _T(void) 
{ 
  struct timeval t ;
  time_t tr ;
  struct tm u ;
  I tmp ;
  K tmp___0 ;

  {
  gettimeofday((struct timeval * __restrict  )(& t), (void * __restrict  )0);
  tr = t.tv_sec;
  gmtime_r((time_t const   * __restrict  )(& tr), (struct tm * __restrict  )(& u));
  tmp = jdn_from_date((I )(1900 + u.tm_year), (I )(1 + u.tm_mon), (I )u.tm_mday);
  tmp___0 = Kf((double )tmp + ((double )(((u.tm_hour * 60) * 60 + u.tm_min * 60) + u.tm_sec) + (double )t.tv_usec / 1.0e6) / 86400.0);
  return (tmp___0);
}
}
K _n(void) 
{ 
  K tmp ;

  {
  tmp = ci(NIL);
  return (tmp);
}
}
K _h(void) 
{ 
  C c[256] ;
  int *tmp ;
  char *tmp___0 ;
  K tmp___1 ;
  int tmp___2 ;
  S tmp___3 ;
  K tmp___4 ;

  {
  tmp___2 = gethostname(c, (size_t )256);
  if (tmp___2) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    tmp___1 = kerr((cS )tmp___0);
    return (tmp___1);
  }
  tmp___3 = sp(c);
  tmp___4 = Ks(tmp___3);
  return (tmp___4);
}
}
K _d(void) 
{ 
  K tmp ;

  {
  tmp = Ks(d_);
  return (tmp);
}
}
K _v(void) 
{ 
  K tmp ;

  {
  tmp = ci(KONA_GSET);
  return (tmp);
}
}
K _i(void) 
{ 
  K tmp ;

  {
  tmp = ci(KONA_IDX);
  return (tmp);
}
}
K _f(void) 
{ 


  {
  return ((K )0);
}
}
K _s(void) 
{ 
  K tmp ;

  {
  tmp = mstat();
  return (tmp);
}
}
K _p(void) 
{ 
  K tmp ;

  {
  tmp = ci(KONA_PORT);
  return (tmp);
}
}
K _w(void) 
{ 
  K tmp ;

  {
  tmp = ci(KONA_WHO);
  return (tmp);
}
}
K _u(void) 
{ 
  K tmp ;

  {
  tmp = kerr("nyi");
  return (tmp);
}
}
K _a(void) 
{ 
  K tmp ;

  {
  tmp = ci(KONA_ARGS);
  return (tmp);
}
}
static K x  =    (K )0;
static S d  =    (S )"2022-08-03";
K _k(void) 
{ 
  size_t tmp ;
  I tmp___0 ;
  K tmp___1 ;

  {
  if (! x) {
    tmp = strlen((char const   *)d);
    x = newK((I )-3, (I )tmp);
    tmp___0 = OOM_CD((I )0, x, (V )-1);
    if (! tmp___0) {
      return ((K )0);
    }
    strcpy((char * __restrict  )((C *)(x->k)), (char const   * __restrict  )d);
  }
  tmp___1 = ci(x);
  return (tmp___1);
}
}
K _m(void) 
{ 
  K tmp ;

  {
  tmp = kerr("nyi");
  return (tmp);
}
}
K _c(void) 
{ 
  K tmp ;

  {
  tmp = ci(KONA_CLIENT);
  return (tmp);
}
}
static I CIX(K a , I i , K x___0 ) 
{ 
  I at___0 ;
  I t ;
  I r ;
  K k ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
  at___0 = a->t;
  t = x___0->t;
  r = (I )0;
  k = (K )0;
  if (! at___0) {
    k = ci(a->k[i]);
  } else {
    k = newK(- at___0, (I )1);
  }
  switch (k->t) {
  case 1LL: 
  *((I *)(k->k)) = *((I *)(a->k) + i);
  break;
  case 2LL: 
  *((F *)(k->k)) = *((F *)(a->k) + i);
  break;
  case 3LL: 
  *((C *)(k->k)) = *((C *)(a->k) + i);
  break;
  case 4LL: 
  *((S *)(k->k)) = *((S *)(a->k) + i);
  break;
  }
  if (1LL == k->t) {
    if (2LL == t) {
      if (9223372036854775807LL == *((I *)(k->k))) {
        tmp___1 = (double )1 / 0.;
      } else {
        if (-9223372036854775807LL == *((I *)(k->k))) {
          tmp___0 = - ((double )1 / 0.);
        } else {
          if ((-0x7FFFFFFFFFFFFFFF-1) == *((I *)(k->k))) {
            tmp = (double )0 / 0.;
          } else {
            tmp = (double )*((I *)(k->k));
          }
          tmp___0 = tmp;
        }
        tmp___1 = tmp___0;
      }
      r = FC(tmp___1, *((F *)(x___0->k)));
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (2LL == k->t) {
    if (1LL == t) {
      if (9223372036854775807LL == *((I *)(x___0->k))) {
        tmp___4 = (double )1 / 0.;
      } else {
        if (-9223372036854775807LL == *((I *)(x___0->k))) {
          tmp___3 = - ((double )1 / 0.);
        } else {
          if ((-0x7FFFFFFFFFFFFFFF-1) == *((I *)(x___0->k))) {
            tmp___2 = (double )0 / 0.;
          } else {
            tmp___2 = (double )*((I *)(x___0->k));
          }
          tmp___3 = tmp___2;
        }
        tmp___4 = tmp___3;
      }
      r = FC(*((F *)(k->k)), tmp___4);
    } else {
      r = KC(k, x___0);
    }
  } else {
    r = KC(k, x___0);
  }
  if (k) {
    cd(k);
  }
  return (r);
}
}
static I binr(K a , I b___1 , I c , K x___0 ) 
{ 
  I i ;
  I r ;
  I tmp ;
  I tmp___0 ;
  I tmp___1 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;

  {
  i = b___1 + (c - b___1) / 2LL;
  tmp = CIX(a, i, x___0);
  r = tmp;
  if (0LL == r) {
    if (i > 0LL) {
      tmp___0 = CIX(a, i - 1LL, x___0);
      if (tmp___0) {
        return (i);
      } else {
        r = (I )1;
      }
    } else {
      return (i);
    }
  }
  if (b___1 >= c) {
    if (-1LL == r) {
      tmp___1 = 1LL + i;
    } else {
      tmp___1 = i;
    }
    return (tmp___1);
  }
  if (0LL < r) {
    tmp___2 = binr(a, b___1, i - 1LL, x___0);
    tmp___4 = tmp___2;
  } else {
    tmp___3 = binr(a, i + 1LL, c, x___0);
    tmp___4 = tmp___3;
  }
  return (tmp___4);
}
}
F RF(void) 
{ 
  double tmp ;

  {
  tmp = genrand64_real2();
  return (tmp);
}
}
I k_epoch_offset  =    (I )-2051222400L;
K _dot_t(void) 
{ 
  struct timeval t ;
  K tmp ;

  {
  gettimeofday((struct timeval * __restrict  )(& t), (void * __restrict  )0);
  tmp = Kf(((F )k_epoch_offset + (F )t.tv_sec) + (F )t.tv_usec / 1.0e6);
  return (tmp);
}
}
static I jdn_from_date(I year , I month , I day ) 
{ 
  I a ;
  I y ;
  I m ;

  {
  a = (14LL - month) / 12LL;
  y = (year + 4800LL) - a;
  m = (month + 12LL * a) - 3LL;
  return (((((((day + (153LL * m + 2LL) / 5LL) + y * 365LL) + y / 4LL) - y / 100LL) + y / 400LL) - 32045LL) - 2464329LL);
}
}
static I date_from_jdn(I j ) 
{ 
  I b___1 ;
  I c ;
  I d___0 ;
  I e ;
  I m ;
  I year ;
  I month ;
  I day ;
  I a ;

  {
  a = (j + 32044LL) + 2464329LL;
  b___1 = (4LL * a + 3LL) / 146097LL;
  c = a - (b___1 * 146097LL) / 4LL;
  d___0 = (4LL * c + 3LL) / 1461LL;
  e = c - (1461LL * d___0) / 4LL;
  m = (5LL * e + 2LL) / 153LL;
  day = (e - (153LL * m + 2LL) / 5LL) + 1LL;
  month = (m + 3LL) - 12LL * (m / 10LL);
  year = ((b___1 * 100LL + d___0) - 4800LL) + m / 10LL;
  return ((year * 10000LL + month * 100LL) + day);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-MppzzL_w.i","-g,-pthread,-O3")
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
void finally(void) ;
I fnci ;
K prnt ;
I check(void) ;
extern K kapn(K *a , V v , I n ) ;
I VA(V p ) ;
I valence(V p ) ;
S IFP[3]  ;
S IFS[3] ;
V offsetSSR  ;
V offsetWhat  ;
V offsetAt  ;
V offsetDot  ;
V offsetColon  ;
K colon_dyadic(K a , K b___1 ) ;
K dot(K a , K b___1 ) ;
K dollar(K a , K b___1 ) ;
K join(K x___0 , K y ) ;
K drop_cut(K a , K b___1 ) ;
K what(K x___0 , K y ) ;
K at(K x___0 , K y ) ;
K equals(K a , K b___1 ) ;
K more(K a , K b___1 ) ;
K less(K a , K b___1 ) ;
K rotate_mod(K a , K b___1 ) ;
K power(K a , K b___1 ) ;
K min_and(K a , K b___1 ) ;
K max_or(K a , K b___1 ) ;
K divide(K a , K b___1 ) ;
K times(K a , K b___1 ) ;
K minus(K a , K b___1 ) ;
K plus(K a , K b___1 ) ;
K colon_monadic(K a ) ;
K dot_monadic(K x___0 ) ;
K format(K a ) ;
K count(K x___0 ) ;
K enlist(K x___0 ) ;
K floor_verb(K a ) ;
K range(K a ) ;
K atom(K a ) ;
K not_attribute(K a ) ;
K group(K x___0 ) ;
K grade_down(K a ) ;
K grade_up(K a ) ;
K shape(K a ) ;
K where(K x___0 ) ;
K reverse(K a ) ;
K reciprocal(K x___0 ) ;
K first(K a ) ;
K negate(K x___0 ) ;
K flip(K a ) ;
C vc[21] ;
K eachpair(void) ;
K eachleft(void) ;
K eachright(void) ;
K each(void) ;
K scan(void) ;
K over(void) ;
C ac[4] ;
F FF(F f ) ;
K KX(K x___0 ) ;
I miN(I a , I b___1 ) ;
S LS  ;
K NIL  ;
S IPC_PORT  ;
S HTTP_PORT  ;
S d_  ;
I SEED  ;
K KTREE  ;
N SYMBOLS  ;
L DT_END_OFFSET  ;
L DT_ADVERB_OFFSET  ;
L DT_VERB_OFFSET  ;
L DT_SPECIAL_VERB_OFFSET  ;
L offsetOver  ;
L offsetScan  ;
L offsetEach  ;
L offsetEachright  ;
L offsetEachleft  ;
L offsetEachpair  ;
K TABLE_END(void) ;
void nfinish(void) ;
I rc(K x___0 ) ;
K _hash(K x___0 ) ;
K _dot(K a , K b___1 ) ;
C errmsg[256]  ;
V offsetJoin  ;
V offset3m  ;
S HOST_IFACE  ;
I kdefClass(I n ) ;
C verbsChar(V p ) ;
C adverbsChar(V p ) ;
K stopDict  =    (K )0;
I fStop  =    (I )0;
extern K kerr(cS s ) 
{ 
  int tmp ;

  {
  tmp = strcmp(s, "(nil)");
  if (tmp) {
    fer = (I )2;
  }
  snprintf((char * __restrict  )(errmsg), (size_t )256, (char const   * __restrict  )"%s",
           s);
  return ((K )0);
}
}
static K XN(S s , I n ) ;
I PP  =    (I )7;
I PPMAX  =    (I )19;
C PPON  =    (C )1;
I maX(I a , I b___1 ) 
{ 
  I tmp ;

  {
  if (a > b___1) {
    tmp = a;
  } else {
    tmp = b___1;
  }
  return (tmp);
}
}
I miN(I a , I b___1 ) 
{ 
  I tmp ;

  {
  if (a < b___1) {
    tmp = a;
  } else {
    tmp = b___1;
  }
  return (tmp);
}
}
K X(S s ) 
{ 
  size_t tmp ;
  K tmp___0 ;

  {
  kerr("(nil)");
  fnci = (I )0;
  tmp = strlen((char const   *)s);
  tmp___0 = XN(s, (I )tmp);
  return (tmp___0);
}
}
static K XN(S s , I n ) 
{ 
  K tmp ;
  K tmp___0 ;

  {
  tmp = wd(s, (int )n);
  tmp___0 = ex(tmp);
  return (tmp___0);
}
}
K KX(K x___0 ) 
{ 
  S tmp ;
  K tmp___0 ;

  {
  tmp = CSK(x___0);
  tmp___0 = XN(tmp, x___0->n);
  return (tmp___0);
}
}
F FF(F f ) 
{ 
  F F___0 ;
  double tmp ;

  {
  tmp = modf(f, & F___0);
  return (tmp);
}
}
I simpleString(S a ) 
{ 
  I n ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  I i ;
  I _i___0 ;
  unsigned short const   **tmp___1 ;
  I i___0 ;
  I _i___1 ;
  unsigned short const   **tmp___2 ;
  I i___1 ;
  I _i___2 ;

  {
  tmp = strlen((char const   *)a);
  n = (I )tmp;
  if (n) {
    tmp___0 = __ctype_b_loc();
    if ((int const   )*(*tmp___0 + (int )*a) & 2048) {
      return ((I )0);
    }
  }
  if (1LL == n) {
    if ((int )*a == 46) {
      return ((I )0);
    }
  }
  if (n > 1LL) {
    if ((int )*(a + (n - 1LL)) == 46) {
      if ((int )*(a + (n - 2LL)) == 46) {
        return ((I )0);
      }
    }
  }
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    tmp___1 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___1 + (int )*(a + i)) & 8)) {
      if ((int )*(a + i) != 95) {
        if ((int )*(a + i) != 46) {
          return ((I )0);
        }
      }
    }
    i ++;
  }
  i___0 = (I )0;
  _i___1 = n - 1LL;
  while (i___0 < _i___1) {
    if ((int )*(a + i___0) == 46) {
      tmp___2 = __ctype_b_loc();
      if ((int const   )*(*tmp___2 + (int )*(a + (i___0 + 1LL))) & 2048) {
        return ((I )0);
      }
    }
    i___0 ++;
  }
  i___1 = (I )0;
  _i___2 = n - 2LL;
  while (i___1 < _i___2) {
    if ((int )*(a + i___1) == 46) {
      if ((int )*(a + (i___1 + 1LL)) == 46) {
        if ((int )*(a + (i___1 + 2LL)) == 46) {
          return ((I )0);
        }
      }
    }
    i___1 ++;
  }
  return ((I )1);
}
}
K end(void) 
{ 


  {
  return ((K )0);
}
}
I bk(V p ) 
{ 


  {
  return ((I )((L )p == DT_END_OFFSET));
}
}
C ac[4]  = {      (C )'/',      (C )'\\',      (C )'\'',      (C )'\000'};
K over(void) 
{ 


  {
  return ((K )0);
}
}
K scan(void) 
{ 


  {
  return ((K )0);
}
}
K each(void) 
{ 


  {
  return ((K )0);
}
}
K tr_st(K x___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  K tmp___1 ;

  {
  tmp = strcmp((char const   *)fBreak, "t");
  if (0 == tmp) {
    show(x___0);
  }
  tmp___0 = strcmp((char const   *)fBreak, "s");
  if (0 == tmp___0) {
    printf((char const   * __restrict  )"stop\n");
    printf((char const   * __restrict  )"%s\n", lineA);
    stopDict = ci((K )*((V *)(prnt->k) + 7));
    fStop = (I )1;
    check();
    cd(stopDict);
    stopDict = (K )0;
    fStop = (I )0;
  }
  tmp___1 = ci(x___0);
  return (tmp___1);
}
}
K rtrn(K x___0 ) 
{ 
  K tmp ;

  {
  fer = (I )1;
  tmp = ci(x___0);
  return (tmp);
}
}
K eachright(void) 
{ 


  {
  return ((K )0);
}
}
K eachleft(void) 
{ 


  {
  return ((K )0);
}
}
K eachpair(void) 
{ 


  {
  return ((K )0);
}
}
K resume(K x___0 ) 
{ 


  {
  return ((K )0);
}
}
C vc[21]  = 
  {      (C )'+',      (C )'-',      (C )'*',      (C )'%', 
        (C )'|',      (C )'&',      (C )'^',      (C )'!', 
        (C )'<',      (C )'>',      (C )'=',      (C )'~', 
        (C )'@',      (C )'?',      (C )'_',      (C )',', 
        (C )'#',      (C )'$',      (C )'.',      (C )':', 
        (C )'\000'};
S IFS[3]  = {      (S )"x",      (S )"y",      (S )"z"};
I stringHasChar(S s , C c ) 
{ 
  I i ;
  I tmp ;

  {
  i = (I )0;
  while (*(s + i)) {
    tmp = i;
    i ++;
    if ((int )c == (int )*(s + tmp)) {
      return ((I )1);
    }
  }
  return ((I )0);
}
}
I charpos(S s , C c ) 
{ 
  I i ;

  {
  i = (I )0;
  while (1) {
    if (*(s + i)) {
      if (! ((int )c != (int )*(s + i))) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  return (i);
}
}
I isCharVerb(C c ) 
{ 
  I tmp ;

  {
  tmp = stringHasChar(vc, c);
  return (tmp);
}
}
L charsVerb(C c ) 
{ 
  I tmp ;

  {
  tmp = charpos(vc, c);
  return (tmp);
}
}
C verbsChar(V p ) 
{ 
  int tmp ;

  {
  if ((L )p >= DT_VERB_OFFSET) {
    if ((L )p < DT_SPECIAL_VERB_OFFSET) {
      tmp = (int )vc[((L )p - DT_VERB_OFFSET) / 2LL];
    } else {
      tmp = '\000';
    }
  } else {
    tmp = '\000';
  }
  return ((C )tmp);
}
}
C adverbsChar(V p ) 
{ 
  int tmp ;

  {
  if ((L )p >= DT_ADVERB_OFFSET) {
    tmp = (int )ac[((L )p - DT_ADVERB_OFFSET) % 3LL];
  } else {
    tmp = '\000';
  }
  return ((C )tmp);
}
}
L charsAdverb(C c ) 
{ 
  I tmp ;

  {
  tmp = charpos(ac, c);
  return (tmp);
}
}
I sva(V p ) 
{ 
  UI q ;

  {
  q = (UI )p;
  if (q < (UI )DT_SIZE) {
    return (DT[q].arity);
  }
  return ((I )0);
}
}
I adverbClass(V p ) 
{ 
  UI q ;

  {
  q = (UI )p;
  if (q < (UI )DT_SIZE) {
    return (DT[q].adverbClass);
  }
  return ((I )0);
}
}
I kdefClass(I n ) 
{ 
  int tmp ;

  {
  if (n == 98LL) {
    tmp = 1;
  } else
  if (n == 101LL) {
    tmp = 1;
  } else
  if (n == 107LL) {
    tmp = 1;
  } else
  if (n == 108LL) {
    tmp = 1;
  } else
  if (n == 111LL) {
    tmp = 1;
  } else
  if (n == 112LL) {
    tmp = 1;
  } else
  if (n == 113LL) {
    tmp = 1;
  } else
  if (n == 114LL) {
    tmp = 1;
  } else
  if (n == 115LL) {
    tmp = 1;
  } else
  if (n == 117LL) {
    tmp = 1;
  } else
  if (n == 121LL) {
    tmp = 1;
  } else
  if (n == 123LL) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return ((I )tmp);
}
}
static I specialValence(V p ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )p == (unsigned long )offsetSSR) {
    tmp___0 = 3;
  } else
  if ((unsigned long )p == (unsigned long )offsetWhat) {
    tmp___0 = 3;
  } else {
    if ((unsigned long )p == (unsigned long )offsetAt) {
      tmp = 4;
    } else
    if ((unsigned long )p == (unsigned long )offsetDot) {
      tmp = 4;
    } else {
      tmp = 0;
    }
    tmp___0 = tmp;
  }
  return ((I )tmp___0);
}
}
I valence(V p ) 
{ 
  I a ;
  I i ;
  I tmp ;
  I tmp___0 ;
  K v ;
  V *w___0 ;
  I t ;
  K b___1 ;
  I c ;
  I i___0 ;
  I _i___0 ;
  V *k ;
  V *q ;
  I j ;
  I s ;
  I tmp___1 ;
  int tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  I tmp___6 ;
  I tmp___7 ;
  I tmp___8 ;
  I tmp___9 ;
  I tmp___10 ;

  {
  a = specialValence(p);
  if (a) {
    a = a;
  } else {
    tmp = sva(p);
    a = tmp;
  }
  if (a) {
    return (a);
  }
  tmp___0 = adverbClass(p);
  if (tmp___0) {
    return ((I )0);
  }
  v = *((K *)p);
  if (! v) {
    return ((I )0);
  } else
  if (v->t != 7LL) {
    return ((I )0);
  }
  w___0 = (V *)((S *)(((K )*((V *)(v->k) + 2))->k));
  t = v->n;
  b___1 = (K )*((V *)(v->k) + 5);
  c = (I )0;
  if (b___1) {
    i___0 = (I )0;
    _i___0 = b___1->n;
    while (i___0 < _i___0) {
      if (b___1->k[i___0]) {
        c ++;
      }
      i___0 ++;
    }
    return (b___1->n - c);
  }
  if (1LL == t) {
    i = ((K )*((V *)(v->k) + 2))->n - 1LL;
    k = (V *)*((V *)((S *)(((K )*((V *)(v->k) + 2))->k)) + (i - 1LL));
    if ((L )k == offsetEachright) {
      return ((I )2);
    } else
    if ((L )k == offsetEachleft) {
      return ((I )2);
    }
    if (i > 1LL) {
      if ((L )k == offsetEach) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if ((L )k == offsetOver) {
      goto _L;
    } else
    if ((L )k == offsetScan) {
      _L: /* CIL Label */ 
      j = (I )0;
      while (1) {
        tmp___1 = j;
        j ++;
        q = (V *)*((V *)((S *)(((K )*((V *)(v->k) + 2))->k)) + ((i - 2LL) - tmp___1));
        if (! ((L )q == offsetEach)) {
          if (! ((L )q == offsetOver)) {
            if (! ((L )q == offsetScan)) {
              break;
            }
          }
        }
      }
      s = sva((V )q);
      if (s) {
        tmp___3 = specialValence((V )q);
        if (! tmp___3) {
          if ((i - 2LL) - j >= 0LL) {
            tmp___2 = 1;
          } else {
            tmp___2 = 0;
          }
          return (s - (I )tmp___2);
        }
      }
      if (j < i - 2LL) {
        tmp___4 = valence((V )q);
        return (tmp___4 - 1LL);
      } else {
        tmp___5 = valence((V )q);
        return (tmp___5);
      }
    }
    tmp___6 = adverbClass((V )k);
    if (tmp___6) {
      return ((I )2);
    }
    tmp___8 = sva((V )k);
    if (tmp___8 > 1LL) {
      if (i > 1LL) {
        tmp___9 = VA(*((V *)((S *)(((K )*((V *)(v->k) + 2))->k)) + (i - 2LL)));
        if (! tmp___9) {
          tmp___7 = valence((V )k);
          return (tmp___7 - 1LL);
        }
      }
    }
    tmp___10 = valence((V )k);
    return (tmp___10);
  }
  if (2LL == t) {
    return ((L )*(w___0 + 0));
  }
  if (3LL == t) {
    return (((K )*((V *)(v->k) + 4))->n);
  }
  return ((I )0);
}
}
I VA(V p ) 
{ 
  I tmp ;
  I tmp___0 ;
  int tmp___1 ;

  {
  tmp = sva(p);
  if (tmp) {
    tmp___1 = 1;
  } else {
    tmp___0 = adverbClass(p);
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  return ((I )tmp___1);
}
}
static I isescape(UC c ) 
{ 
  int tmp ;

  {
  if ((int )c == 34) {
    tmp = 1;
  } else
  if ((int )c == 92) {
    tmp = 1;
  } else
  if ((int )c == 8) {
    tmp = 1;
  } else
  if ((int )c == 10) {
    tmp = 1;
  } else
  if ((int )c == 13) {
    tmp = 1;
  } else
  if ((int )c == 9) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return ((I )tmp);
}
}
extern int ( /* missing proto */  __builtin_isnan)() ;
static C b[512]  ;
static I needspt0(F f ) 
{ 
  int tmp ;
  I tmp___0 ;
  I tmp___1 ;
  int tmp___2 ;

  {
  tmp = __builtin_isnan(f);
  if (tmp) {
    return ((I )0);
  } else
  if (- ((double )1 / 0.) == f) {
    return ((I )0);
  } else
  if ((double )1 / 0. == f) {
    return ((I )0);
  }
  snprintf((char * __restrict  )(b), (size_t )512, (char const   * __restrict  )"%.*g",
           (int )PP, f);
  tmp___0 = stringHasChar(b, (C )'.');
  if (tmp___0) {
    tmp___2 = 0;
  } else {
    tmp___1 = stringHasChar(b, (C )'e');
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
  }
  return ((I )tmp___2);
}
}
static C b___0[512]  ;
static int splitprint(V u , char const   *s  , ...) 
{ 
  va_list___0 args___0 ;
  I n ;
  int tmp ;
  K tmp___0 ;
  int tmp___1 ;

  {
  __builtin_va_start(args___0, s);
  if (! u) {
    vprintf((char const   * __restrict  )s, args___0);
  } else {
    tmp = vsnprintf((char * __restrict  )(b___0), (size_t )512, (char const   * __restrict  )s,
                    args___0);
    n = (I )tmp;
    tmp___0 = kapn((K *)u, (V )(b___0), n);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  }
  __builtin_va_end(args___0);
  return (0);
}
}
void printAtDepth(V u , K a , I d___0 , I x___0 , I vdep , I b___1 ) 
{ 
  I t ;
  I i ;
  I _i___0 ;
  I m ;
  K s ;
  I i___0 ;
  I _i___1 ;
  I enclose ;
  int tmp ;
  char const   *tmp___0 ;
  I f ;
  F g ;
  I i___1 ;
  I _i___2 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  I i___2 ;
  I _i___3 ;
  I tmp___3 ;
  I i___3 ;
  I _i___4 ;
  int tmp___4 ;
  I tmp___5 ;
  I tmp___6 ;
  I i___4 ;
  I _i___5 ;
  UC c ;
  I tmp___7 ;
  unsigned short const   **tmp___8 ;
  I tmp___9 ;
  I tmp___10 ;
  I ss ;
  I sl ;
  S str ;
  I i___5 ;
  I _i___6 ;
  size_t tmp___11 ;
  I j ;
  I _j ;
  char const   *tmp___12 ;
  I tmp___13 ;
  I i___6 ;
  I k ;
  S s___0 ;
  V *v ;
  V *p ;
  I q ;
  size_t tmp___14 ;
  I i___7 ;
  I _i___7 ;
  C tmp___15 ;
  char const   *tmp___16 ;
  C tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;

  {
  if (! a) {
    return;
  }
  t = a->t;
  if (x___0) {
    i = (I )0;
    _i___0 = d___0;
    while (i < _i___0) {
      splitprint(u, " ");
      i ++;
    }
  }
  if (5LL == t) {
    splitprint(u, ".");
    d___0 ++;
    t = (I )0;
  }
  if (t <= 0LL) {
    if (a->n == 1LL) {
      splitprint(u, ",");
    }
  }
  m = (I )0;
  if (0LL == t) {
    if (! b___1) {
      i___0 = (I )0;
      _i___1 = a->n;
      while (i___0 < _i___1) {
        s = a->k[i___0];
        if (s) {
          if (s->t <= 0LL) {
            if (s->n) {
              m = (I )1;
              break;
            } else
            if (-3LL == s->t) {
              m = (I )1;
              break;
            }
          }
        }
        if (s) {
          if (s->t == 5LL) {
            m = (I )1;
            break;
          }
        }
        i___0 ++;
      }
    }
  }
  if (0LL == t) {
    if (a->n != 1LL) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (t == 7LL) {
    if (vdep) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  enclose = (I )tmp;
  if (enclose) {
    if (b___1) {
      tmp___0 = "[";
    } else {
      tmp___0 = "(";
    }
    splitprint(u, tmp___0);
  }
  if (0LL == t) {
    i___1 = (I )0;
    _i___2 = a->n;
    while (i___1 < _i___2) {
      printAtDepth(u, a->k[i___1], d___0 + 1LL, i___1 * m, (I )0, (I )0);
      if (i___1 < _i___2 - 1LL) {
        if (m) {
          tmp___1 = "\n";
        } else {
          tmp___1 = ";";
        }
        tmp___2 = tmp___1;
      } else {
        tmp___2 = "";
      }
      splitprint(u, tmp___2);
      i___1 ++;
    }
  }
  if (t < 0LL) {
    tmp___3 = - t;
  } else {
    tmp___3 = t;
  }
  if (1LL == tmp___3) {
    if (! a->n) {
      splitprint(u, "!0");
    } else {
      i___2 = (I )0;
      _i___3 = a->n;
      while (i___2 < _i___3) {
        f = *((I *)(a->k) + i___2);
        if (f == (-0x7FFFFFFFFFFFFFFF-1)) {
          splitprint(u, "0N");
        } else
        if (f == -9223372036854775807LL) {
          splitprint(u, "-0I");
        } else
        if (f == 9223372036854775807LL) {
          splitprint(u, "0I");
        } else {
          splitprint(u, "%lld", f);
        }
        if (i___2 < _i___3 - 1LL) {
          splitprint(u, " ");
        }
        i___2 ++;
      }
    }
  }
  if (t < 0LL) {
    tmp___6 = - t;
  } else {
    tmp___6 = t;
  }
  if (2LL == tmp___6) {
    if (! a->n) {
      splitprint(u, "0#0.0");
    } else {
      i___3 = (I )0;
      _i___4 = a->n;
      while (i___3 < _i___4) {
        g = *((F *)(a->k) + i___3);
        tmp___4 = __builtin_isnan(g);
        if (tmp___4) {
          splitprint(u, "0n");
        } else
        if (g == - ((double )1 / 0.)) {
          splitprint(u, "-0i");
        } else
        if (g == (double )1 / 0.) {
          splitprint(u, "0i");
        } else {
          splitprint(u, "%.*g", (int )PP, g);
        }
        if (i___3 < _i___4 - 1LL) {
          splitprint(u, " ");
        } else {
          tmp___5 = needspt0(g);
          if (tmp___5) {
            splitprint(u, ".0");
          }
        }
        i___3 ++;
      }
    }
  }
  if (t < 0LL) {
    tmp___10 = - t;
  } else {
    tmp___10 = t;
  }
  if (3LL == tmp___10) {
    splitprint(u, "\"");
    i___4 = (I )0;
    _i___5 = a->n;
    while (i___4 < _i___5) {
      c = (UC )*((C *)(a->k) + i___4);
      tmp___8 = __ctype_b_loc();
      if ((int const   )*(*tmp___8 + (int )c) & 16384) {
        tmp___9 = isescape(c);
        if (tmp___9) {
          goto _L___0;
        } else {
          splitprint(u, "%c", (int )c);
        }
      } else {
        _L___0: /* CIL Label */ 
        tmp___7 = isescape(c);
        if (tmp___7) {
          switch ((int )c) {
          case 34: 
          splitprint(u, "\\\"");
          break;
          case 92: 
          splitprint(u, "\\\\");
          break;
          case 8: 
          splitprint(u, "\\b");
          break;
          case 10: 
          splitprint(u, "\\n");
          break;
          case 13: 
          splitprint(u, "\\r");
          break;
          case 9: 
          splitprint(u, "\\t");
          break;
          }
        } else {
          splitprint(u, "\\%.3o", (int )c);
        }
      }
      i___4 ++;
    }
    splitprint(u, "\"");
  }
  if (t < 0LL) {
    tmp___13 = - t;
  } else {
    tmp___13 = t;
  }
  if (4LL == tmp___13) {
    if (! a->n) {
      splitprint(u, "0#`");
    } else {
      ss = (I )0;
      i___5 = (I )0;
      _i___6 = a->n;
      while (i___5 < _i___6) {
        str = *((S *)(a->k) + i___5);
        if ((double )((L )str) < - 2e9) {
          goto _L___1;
        } else
        if (DT_SIZE < (L )str) {
          _L___1: /* CIL Label */ 
          tmp___11 = strlen((char const   *)str);
          sl = (I )tmp___11;
          ss = simpleString(str);
          splitprint(u, "`");
          if (! ss) {
            splitprint(u, "\"");
          }
          j = (I )0;
          _j = sl;
          while (j < _j) {
            splitprint(u, "%c", (int )*(str + j));
            j ++;
          }
          if (! ss) {
            splitprint(u, "\"");
          }
          if (i___5 < _i___6 - 1LL) {
            tmp___12 = " ";
          } else {
            tmp___12 = "";
          }
          splitprint(u, tmp___12);
        } else
        if (-4LL == t) {
          if ((L )str < 0LL) {
            printf((char const   * __restrict  )"\n%p ", str);
          } else {
            printf((char const   * __restrict  )"%p ", str);
            if (! str) {
              printf((char const   * __restrict  )" ");
            } else
            if (i___5 < a->n) {
              if ((unsigned long )*((S *)(a->k) + (i___5 + 1LL)) < (unsigned long )((S )DT_SIZE)) {
                printf((char const   * __restrict  )"\n");
              }
            }
          }
          if ((L )str < 0LL) {
            printf((char const   * __restrict  )" %p ", *((V *)str));
            if (0LL < (L )*((V *)str)) {
              if (! ((L )*((V *)str) < DT_SIZE)) {
                printf((char const   * __restrict  )"%p\n", *((K *)str));
              }
            } else {
              printf((char const   * __restrict  )"%p\n", *((K *)str));
            }
          }
        }
        i___5 ++;
      }
    }
  }
  if (7LL == t) {
    if (1LL == a->n) {
      v = (V *)((S *)(((K )*((V *)(a->k) + 2))->k));
      i___6 = (I )0;
      while (1) {
        p = (V *)*(v + i___6);
        if (! p) {
          break;
        }
        q = (L )p;
        if (q < DT_SIZE) {
          if (q >= DT_SPECIAL_VERB_OFFSET) {
            s___0 = DT[q].text;
            tmp___14 = strlen((char const   *)s___0);
            k = (I )tmp___14;
            i___7 = (I )0;
            _i___7 = k;
            while (i___7 < _i___7) {
              splitprint(u, "%c", (int )*(s___0 + i___7));
              i___7 ++;
            }
            if ((int )*(s___0 + (k - 1LL)) == 58) {
              if (1LL == DT[q].arity) {
                splitprint(u, "%c", ':');
              }
            }
          } else {
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
          k = sva((V )p);
          if (k) {
            tmp___15 = verbsChar((V )p);
            if (2LL == k) {
              tmp___16 = "%c";
            } else {
              tmp___16 = "%c:";
            }
            splitprint(u, tmp___16, (int )tmp___15);
          } else {
            k = adverbClass((V )p);
            if (k) {
              tmp___17 = adverbsChar((V )p);
              if (1LL == k) {
                tmp___18 = "%c";
              } else {
                tmp___18 = "%c:";
              }
              splitprint(u, tmp___18, (int )tmp___17);
            } else {
              printAtDepth(u, *((K *)p), d___0 + 1LL, (I )0, 1LL + vdep, (I )0);
            }
          }
        }
        i___6 ++;
      }
    } else
    if (2LL == a->n) {
      return;
    } else
    if (3LL == a->n) {
      splitprint(u, "{%s}", (C *)(((K )*((V *)(a->k) + 2))->k));
    }
    if (*((V *)(a->k) + 5)) {
      printAtDepth(u, (K )*((V *)(a->k) + 5), d___0 + 1LL, (I )0, (I )0, (I )1);
    }
  }
  if (enclose) {
    if (b___1) {
      tmp___19 = "]";
    } else {
      tmp___19 = ")";
    }
    splitprint(u, tmp___19);
  }
  return;
}
}
K show(K a ) 
{ 


  {
  printAtDepth((V )0, a, (I )0, (I )0, (I )0, (I )0);
  if (a) {
    if (a->t != 6LL) {
      printf((char const   * __restrict  )"\n");
    }
  }
  return (a);
}
}
K minus_eachpair(K x___0 , K y ) 
{ 
  I tmp ;
  K z ;
  K tmp___0 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  K u ;
  K v ;
  I tmp___1 ;

  {
  if (y->n < 2LL) {
    return ((K )0);
  } else
  if (! y->t) {
    return ((K )0);
  } else {
    if (y->t < 0LL) {
      tmp = - y->t;
    } else {
      tmp = y->t;
    }
    if (tmp > 2LL) {
      return ((K )0);
    }
  }
  tmp___0 = newK(y->t, y->n - 1LL);
  z = tmp___0;
  if (-2LL == y->t) {
    i = (I )0;
    _i___0 = y->n - 1LL;
    while (i < _i___0) {
      *((F *)(z->k) + i) = *((F *)(y->k) + (i + 1LL)) - *((F *)(y->k) + i);
      i ++;
    }
  } else
  if (-1LL == y->t) {
    i___0 = (I )0;
    _i___1 = y->n - 1LL;
    while (i___0 < _i___1) {
      *((I *)(z->k) + i___0) = *((I *)(y->k) + (i___0 + 1LL)) - *((I *)(y->k) + i___0);
      i___0 ++;
    }
  }
  if (x___0) {
    u = enlist(x___0);
    tmp___1 = OOM_CD((I )0, u, z, (V )-1);
    if (! tmp___1) {
      return ((K )0);
    }
    v = join(u, z);
    cd(u);
    cd(z);
    return (v);
  }
  return (z);
}
}
K plus_scan(K x___0 , K y ) 
{ 
  I tmp ;
  I t ;
  I tmp___0 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  I tmp___6 ;
  I tmp___7 ;
  I n ;
  int tmp___8 ;
  K z ;
  I tmp___9 ;
  I j ;
  F tmp___10 ;
  I i ;
  I _i___0 ;
  F tmp___11 ;
  I i___0 ;
  I _i___1 ;
  I tmp___12 ;
  I i___1 ;
  I _i___2 ;

  {
  if (x___0) {
    if (x___0->t != 1LL) {
      if (x___0->t != 2LL) {
        return ((K )0);
      }
    }
  }
  if (y->n < 2LL) {
    return ((K )0);
  } else
  if (! y->t) {
    return ((K )0);
  } else {
    if (y->t < 0LL) {
      tmp = - y->t;
    } else {
      tmp = y->t;
    }
    if (tmp > 2LL) {
      return ((K )0);
    }
  }
  if (y->t < 0LL) {
    tmp___0 = - y->t;
  } else {
    tmp___0 = y->t;
  }
  t = - tmp___0;
  if (x___0) {
    if (x___0->t < 0LL) {
      tmp___6 = - x___0->t;
    } else {
      tmp___6 = x___0->t;
    }
    if (t < 0LL) {
      tmp___7 = - t;
    } else {
      tmp___7 = t;
    }
    if (tmp___6 > tmp___7) {
      if (x___0->t < 0LL) {
        tmp___3 = - x___0->t;
      } else {
        tmp___3 = x___0->t;
      }
      tmp___5 = tmp___3;
    } else {
      if (t < 0LL) {
        tmp___4 = - t;
      } else {
        tmp___4 = t;
      }
      tmp___5 = tmp___4;
    }
    t = - tmp___5;
  }
  if (x___0) {
    tmp___8 = 1;
  } else {
    tmp___8 = 0;
  }
  n = y->n + (I )tmp___8;
  if (! x___0) {
    tmp___9 = rc(y);
    if (1LL == tmp___9) {
      if (y->t == t) {
        z = ci(y);
      } else
      if (sizeof(I ) == sizeof(F )) {
        z = ci(y);
      } else {
        z = newK(t, n);
      }
    } else {
      z = newK(t, n);
    }
  } else {
    z = newK(t, n);
  }
  if (! z) {
    return ((K )0);
  }
  j = (I )0;
  if (x___0) {
    j = (I )1;
    if (-2LL == t) {
      if (2LL == x___0->t) {
        *((F *)(z->k)) = *((F *)(x___0->k));
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (-2LL == t) {
      if (1LL == x___0->t) {
        *((F *)(z->k)) = (F )*((I *)(x___0->k));
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (-1LL == t) {
      if (1LL == x___0->t) {
        *((I *)(z->k)) = *((I *)(x___0->k));
      }
    }
  }
  if (-2LL == t) {
    if (-2LL == y->t) {
      if (j) {
        tmp___10 = *((F *)(z->k));
      } else {
        tmp___10 = (F )0;
      }
      *((F *)(z->k) + j) = *((F *)(y->k)) + tmp___10;
      i = (I )0;
      _i___0 = y->n - 1LL;
      while (i < _i___0) {
        *((F *)(z->k) + ((i + j) + 1LL)) = *((F *)(z->k) + (i + j)) + *((F *)(y->k) + (i + 1LL));
        i ++;
      }
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (-2LL == t) {
    if (-1LL == y->t) {
      if (j) {
        tmp___11 = *((F *)(z->k));
      } else {
        tmp___11 = (F )0;
      }
      *((F *)(z->k) + j) = (F )*((I *)(y->k)) + tmp___11;
      i___0 = (I )0;
      _i___1 = y->n - 1LL;
      while (i___0 < _i___1) {
        *((F *)(z->k) + ((i___0 + j) + 1LL)) = *((F *)(z->k) + (i___0 + j)) + (F )*((I *)(y->k) + (i___0 + 1LL));
        i___0 ++;
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (-1LL == t) {
    if (-1LL == y->t) {
      if (j) {
        tmp___12 = *((I *)(z->k));
      } else {
        tmp___12 = (I )0;
      }
      *((I *)(z->k) + j) = *((I *)(y->k)) + tmp___12;
      i___1 = (I )0;
      _i___2 = y->n - 1LL;
      while (i___1 < _i___2) {
        *((I *)(z->k) + ((i___1 + j) + 1LL)) = *((I *)(z->k) + (i___1 + j)) + *((I *)(y->k) + (i___1 + 1LL));
        i___1 ++;
      }
    }
  }
  return (z);
}
}
K plus_over(K x___0 , K y ) 
{ 
  I accI ;
  F accF ;
  I tmp ;
  K z ;
  K r ;
  I tmp___0 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;

  {
  accI = (I )0;
  accF = (F )0;
  if (! y->t) {
    if (y->n) {
      return ((K )0);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (y->t < 0LL) {
      tmp = - y->t;
    } else {
      tmp = y->t;
    }
    if (tmp > 2LL) {
      return ((K )0);
    } else
    if (x___0) {
      if (x___0->t != 1LL) {
        if (x___0->t != 2LL) {
          return ((K )0);
        }
      }
    }
  }
  if (y->t < 0LL) {
    tmp___0 = - y->t;
  } else {
    tmp___0 = y->t;
  }
  switch (tmp___0) {
  case 2LL: 
  if (y->n) {
    accF = *((F *)(y->k));
  }
  i = (I )0;
  _i___0 = y->n - 1LL;
  while (i < _i___0) {
    accF += *((F *)(y->k) + (i + 1LL));
    i ++;
  }
  z = Kf(accF);
  break;
  default: 
  if (y->n) {
    accI = *((I *)(y->k));
  }
  i___0 = (I )0;
  _i___1 = y->n - 1LL;
  while (i___0 < _i___1) {
    accI += *((I *)(y->k) + (i___0 + 1LL));
    i___0 ++;
  }
  z = Ki(accI);
  }
  if (! z) {
    return ((K )0);
  }
  if (x___0) {
    r = plus(x___0, z);
    cd(z);
    z = r;
  }
  return (z);
}
}
K times_over(K x___0 , K y ) 
{ 
  I accI ;
  F accF ;
  I tmp ;
  K z ;
  K r ;
  I tmp___0 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;

  {
  accI = (I )1;
  accF = (F )1;
  if (! y->t) {
    if (y->n) {
      return ((K )0);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (y->t < 0LL) {
      tmp = - y->t;
    } else {
      tmp = y->t;
    }
    if (tmp > 2LL) {
      return ((K )0);
    } else
    if (x___0) {
      if (x___0->t != 1LL) {
        if (x___0->t != 2LL) {
          return ((K )0);
        }
      }
    }
  }
  if (y->t < 0LL) {
    tmp___0 = - y->t;
  } else {
    tmp___0 = y->t;
  }
  switch (tmp___0) {
  case 2LL: 
  if (y->n) {
    accF = *((F *)(y->k));
  }
  i = (I )0;
  _i___0 = y->n - 1LL;
  while (i < _i___0) {
    accF *= *((F *)(y->k) + (i + 1LL));
    i ++;
  }
  z = Kf(accF);
  break;
  default: 
  if (y->n) {
    accI = *((I *)(y->k));
  }
  i___0 = (I )0;
  _i___1 = y->n - 1LL;
  while (i___0 < _i___1) {
    accI *= *((I *)(y->k) + (i___0 + 1LL));
    i___0 ++;
  }
  z = Ki(accI);
  }
  if (! z) {
    return ((K )0);
  }
  if (x___0) {
    r = times(x___0, z);
    cd(z);
    z = r;
  }
  return (z);
}
}
K max_or_over(K x___0 , K y ) 
{ 
  I accI ;
  F accF ;
  I tmp ;
  K z ;
  K r ;
  I tmp___0 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;

  {
  accI = (I )0;
  accF = - ((double )1 / 0.);
  if (! y->t) {
    if (y->n) {
      return ((K )0);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (y->t < 0LL) {
      tmp = - y->t;
    } else {
      tmp = y->t;
    }
    if (tmp > 2LL) {
      return ((K )0);
    } else
    if (x___0) {
      if (x___0->t != 1LL) {
        if (x___0->t != 2LL) {
          return ((K )0);
        }
      }
    }
  }
  if (y->t < 0LL) {
    tmp___0 = - y->t;
  } else {
    tmp___0 = y->t;
  }
  switch (tmp___0) {
  case 2LL: 
  if (y->n) {
    accF = *((F *)(y->k));
  }
  i = (I )0;
  _i___0 = y->n - 1LL;
  while (i < _i___0) {
    if (accF > *((F *)(y->k) + (i + 1LL))) {
      accF = accF;
    } else {
      accF = *((F *)(y->k) + (i + 1LL));
    }
    i ++;
  }
  z = Kf(accF);
  break;
  default: 
  if (y->n) {
    accI = *((I *)(y->k));
  }
  i___0 = (I )0;
  _i___1 = y->n - 1LL;
  while (i___0 < _i___1) {
    if (accI > *((I *)(y->k) + (i___0 + 1LL))) {
      accI = accI;
    } else {
      accI = *((I *)(y->k) + (i___0 + 1LL));
    }
    i___0 ++;
  }
  z = Ki(accI);
  }
  if (! z) {
    return ((K )0);
  }
  if (x___0) {
    r = max_or(x___0, z);
    cd(z);
    z = r;
  }
  return (z);
}
}
K min_and_over(K x___0 , K y ) 
{ 
  I accI ;
  F accF ;
  I tmp ;
  K z ;
  K r ;
  I tmp___0 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;

  {
  accI = (I )1;
  accF = (double )1 / 0.;
  if (! y->t) {
    if (y->n) {
      return ((K )0);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (y->t < 0LL) {
      tmp = - y->t;
    } else {
      tmp = y->t;
    }
    if (tmp > 2LL) {
      return ((K )0);
    } else
    if (x___0) {
      if (x___0->t != 1LL) {
        if (x___0->t != 2LL) {
          return ((K )0);
        }
      }
    }
  }
  if (y->t < 0LL) {
    tmp___0 = - y->t;
  } else {
    tmp___0 = y->t;
  }
  switch (tmp___0) {
  case 2LL: 
  if (y->n) {
    accF = *((F *)(y->k));
  }
  i = (I )0;
  _i___0 = y->n - 1LL;
  while (i < _i___0) {
    if (accF < *((F *)(y->k) + (i + 1LL))) {
      accF = accF;
    } else {
      accF = *((F *)(y->k) + (i + 1LL));
    }
    i ++;
  }
  z = Kf(accF);
  break;
  default: 
  if (y->n) {
    accI = *((I *)(y->k));
  }
  i___0 = (I )0;
  _i___1 = y->n - 1LL;
  while (i___0 < _i___1) {
    if (accI < *((I *)(y->k) + (i___0 + 1LL))) {
      accI = accI;
    } else {
      accI = *((I *)(y->k) + (i___0 + 1LL));
    }
    i___0 ++;
  }
  z = Ki(accI);
  }
  if (! z) {
    return ((K )0);
  }
  if (x___0) {
    r = min_and(x___0, z);
    cd(z);
    z = r;
  }
  return (z);
}
}
K join_over(K x___0 , K y ) 
{ 
  I i ;
  I j ;
  I k ;
  K z ;
  K tmp ;

  {
  j = (I )0;
  i = (I )0;
  while (i < y->n) {
    j += (y->k[i])->n;
    i ++;
  }
  tmp = newK((I )0, j);
  z = tmp;
  if (! z) {
    return ((K )0);
  }
  i = (I )0;
  j = (I )0;
  while (j < y->n) {
    k = (I )0;
    while (k < (y->k[j])->n) {
      z->k[i] = ci((y->k[j])->k[k]);
      i ++;
      k ++;
    }
    j ++;
  }
  return (z);
}
}
TR DT[130]  = 
  {      {(I )0, (I )0, (V )0, (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )0, (V )(& end), (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )0, (V )0, (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )0, (V )0, (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )0, (V )0, (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )0, (V )0, (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )0, (V )0, (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )1, (I )0, (V )(& over), (S )"/", {(V )0, (void *)0, (void *)0}}, 
        {(I )1, (I )0, (V )(& scan), (S )"\\", {(V )0, (void *)0, (void *)0}}, 
        {(I )1, (I )0, (V )(& each), (S )"\'", {(V )0, (void *)0, (void *)0}}, 
        {(I )2, (I )0, (V )(& eachright), (S )"/:", {(V )0, (void *)0, (void *)0}}, 
        {(I )2, (I )0, (V )(& eachleft), (S )"\\:", {(V )0, (void *)0, (void *)0}}, 
        {(I )2, (I )0, (V )(& eachpair), (S )"\':", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )0, (V )0, (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )0, (V )0, (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )0, (V )0, (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )0, (V )0, (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )0, (V )0, (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )0, (V )0, (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )0, (V )0, (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )0, (V )0, (S )0, {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& flip), (S )"+", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& plus), (S )"+", {(V )(& plus_over), (V )(& plus_scan),
                                            (void *)0}}, 
        {(I )0, (I )1, (V )(& negate), (S )"-", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& minus), (S )"-", {(V )0, (V )0, (V )(& minus_eachpair)}}, 
        {(I )0,
      (I )1, (V )(& first), (S )"*", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& times), (S )"*", {(V )(& times_over), (void *)0, (void *)0}}, 
        {(I )0,
      (I )1, (V )(& reciprocal), (S )"%%", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& divide), (S )"%%", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& reverse), (S )"|", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& max_or), (S )"|", {(V )(& max_or_over), (void *)0, (void *)0}}, 
        {(I )0,
      (I )1, (V )(& where), (S )"&", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& min_and), (S )"&", {(V )(& min_and_over), (void *)0, (void *)0}}, 
        {(I )0,
      (I )1, (V )(& shape), (S )"^", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& power), (S )"^", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& enumerate), (S )"!", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& rotate_mod), (S )"!", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& grade_up), (S )"<", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& less), (S )"<", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& grade_down), (S )">", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& more), (S )">", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& group), (S )"=", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& equals), (S )"=", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& not_attribute), (S )"~", {(V )0, (void *)0, (void *)0}}, 
        {(I )0,
      (I )2, (V )(& match), (S )"~", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& atom), (S )"@", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& at), (S )"@", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& range), (S )"?", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& what), (S )"?", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& floor_verb), (S )"_", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& drop_cut), (S )"_", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& enlist), (S )",", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& join), (S )",", {(V )(& join_over), (void *)0, (void *)0}}, 
        {(I )0,
      (I )1, (V )(& count), (S )"#", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& take_reshape), (S )"#", {(V )0, (void *)0, (void *)0}}, 
        {(I )0,
      (I )1, (V )(& format), (S )"$", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& dollar), (S )"$", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& dot_monadic), (S )".", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& dot), (S )".", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& colon_monadic), (S )":", {(V )0, (void *)0, (void *)0}}, 
        {(I )0,
      (I )2, (V )(& colon_dyadic), (S )":", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _0m), (S )"0:", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _0d), (S )"0:", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _1m), (S )"1:", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _1d), (S )"1:", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _2m), (S )"2:", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _2d), (S )"2:", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _3m), (S )"3:", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _3d), (S )"3:", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _4m), (S )"4:", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _4d), (S )"4:", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _5m), (S )"5:", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _5d), (S )"5:", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _6m), (S )"6:", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _6d), (S )"6:", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _acos), (S )"_acos", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _asin), (S )"_asin", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _atan), (S )"_atan", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _ceil), (S )"_ceil", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _cos), (S )"_cos", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _cosh), (S )"_cosh", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _exp), (S )"_exp", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _floor), (S )"_floor", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _log), (S )"_log", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _sin), (S )"_sin", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _sinh), (S )"_sinh", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _sqr), (S )"_sqr", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _sqrt), (S )"_sqrt", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _tan), (S )"_tan", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _tanh), (S )"_tanh", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _abs), (S )"_abs", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _bd), (S )"_bd", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _ceiling), (S )"_ceiling", {(V )0, (void *)0, (void *)0}}, 
        {(I )0,
      (I )1, (V )(& _ci), (S )"_ci", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _db), (S )"_db", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _dj), (S )"_dj", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _kona_exit), (S )"_exit", {(V )0, (void *)0, (void *)0}}, 
        {(I )0,
      (I )1, (V )(& _getenv), (S )"_getenv", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _gtime), (S )"_gtime", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _host), (S )"_host", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _ic), (S )"_ic", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _inv), (S )"_inv", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _jd), (S )"_jd", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _lt), (S )"_lt", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _ltime), (S )"_ltime", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _size), (S )"_size", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _bin), (S )"_bin", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _binl), (S )"_binl", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _di), (S )"_di", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _dot), (S )"_dot", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _draw), (S )"_draw", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _dv), (S )"_dv", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _dvl), (S )"_dvl", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _hat), (S )"_hat", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _in), (S )"_in", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _lin), (S )"_lin", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _lsq), (S )"_lsq", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _mul), (S )"_mul", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _setenv), (S )"_setenv", {(V )0, (void *)0, (void *)0}}, 
        {(I )0,
      (I )2, (V )(& _sm), (S )"_sm", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _ss), (S )"_ss", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _sv), (S )"_sv", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _vsx), (S )"_vsx", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )3, (V )(& _ssr), (S )"_ssr", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& tr_st), (S )" \\", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& rtrn), (S )":", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )2, (V )(& _vs), (S )"_vs", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& _hash), (S )"_hash", {(V )0, (void *)0, (void *)0}}, 
        {(I )0, (I )1, (V )(& resume), (S )":", {(V )0, (void *)0, (void *)0}}, 
        {(I )-1, (I )-1, (V )(& TABLE_END), (S )0, {(V )0, (void *)0, (void *)0}}};
K TABLE_END(void) 
{ 


  {
  return ((K )0);
}
}
L DT_SIZE  =    (L )0;
L DT_OFFSET(V v ) 
{ 
  I i ;

  {
  i = (I )0;
  while ((unsigned long )v != (unsigned long )DT[i].func) {
    i ++;
  }
  return (i);
}
}
I kreci  =    (I )0;
void finally(void) 
{ 


  {
  nfinish();
  return;
}
}
#pragma merger("0","/tmp/cil-BQhPOK1O.i","-g,-pthread,-O3")
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atexit)(void (*__func)(void) ) ;
extern int fflush(FILE *__stream ) ;
extern int usleep(__useconds_t __useconds ) ;
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
extern char *optarg ;
extern int optind ;
extern int optopt ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt)(int ___argc ,
                                                                                     char * const  *___argv ,
                                                                                     char const   *__shortopts ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutexattr_init)(pthread_mutexattr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutexattr_destroy)(pthread_mutexattr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutexattr_settype)(pthread_mutexattr_t *__attr ,
                                                                                                      int __kind ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
K KFIXED  ;
I attend(void) ;
I kinit(void) ;
I args(int n , S *v ) ;
C cdp[11] ;
F mAlloc ;
S fnc ;
V fncp[128] ;
I fom ;
I fam ;
K cls ;
K Kn(void) ;
N newN(void) ;
fd_set master  ;
I line(FILE *f , S *a , I *n , PDA *p ) ;
I ninit(void) ;
M0 CP[1025] ;
K KONA_GSET  =    (K )0;
K KONA_IDX  =    (K )0;
int volatile   interrupted  =    (sig_atomic_t volatile   )0;
static I randomBits(void) ;
I oerr(void) 
{ 
  int tmp ;

  {
  tmp = printf((char const   * __restrict  )"%s %s\n", errmsg, "error");
  return ((I )tmp);
}
}
I feci  =    (I )0;
I scrLim  =    (I )0;
I fCheck  =    (I )0;
static I ofCheck  =    (I )0;
I fCmplt  =    (I )0;
I fbr  =    (I )0;
static I flc  =    (I )0;
static C lineC[100]  ;
static C ofnc[2]  = {      (C )' ',      (C )'\000'};
static I ocr  =    (I )0;
I prompt(I n ) 
{ 
  I i ;
  I _i___0 ;

  {
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    printf((char const   * __restrict  )">");
    i ++;
  }
  printf((char const   * __restrict  )"  ");
  fflush(stdout);
  return ((I )0);
}
}
I wds(K *a , FILE *f ) 
{ 
  I tmp ;

  {
  tmp = wds_(a, f, (I )0);
  return (tmp);
}
}
I wds_(K *a , FILE *f , I l ) 
{ 
  S s ;
  S t ;
  I b___1 ;
  I c ;
  I m ;
  I n ;
  I v ;
  K z ;
  PDA p ;
  I o ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  I tmp___4 ;

  {
  s = (S )0;
  t = (S )0;
  b___1 = (I )0;
  c = (I )0;
  m = (I )0;
  n = (I )0;
  v = (I )0;
  z = (K )0;
  p = (PDA )0;
  tmp = fileno(stdin);
  tmp___0 = isatty(tmp);
  if (tmp___0) {
    if ((unsigned long )f == (unsigned long )stdin) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  o = (I )tmp___1;
  c = getline_(& s, & n, f);
  if (-1LL == c) {
    goto cleanup;
  }
  appender(& t, & m, s, n);
  while (1) {
    v = complete(t, m, & p, (I *)0);
    if (! (1LL == v)) {
      break;
    }
    b___1 = parsedepth(p);
    if (o) {
      prompt(b___1 + l);
    }
    c = getline_(& s, & n, f);
    if (-1LL == c) {
      goto cleanup;
    }
    appender(& t, & m, s, n);
  }
  switch (v) {
  case 2LL: 
  tmp___2 = kerr("unmatched");
  show(tmp___2);
  goto cleanup;
  break;
  case 3LL: 
  tmp___3 = kerr("nest");
  show(tmp___3);
  goto cleanup;
  break;
  }
  z = newK((I )-3, m - 1LL);
  strncpy((char * __restrict  )((C *)(z->k)), (char const   * __restrict  )t, (size_t )(m - 1LL));
  cleanup: 
  free((void *)s);
  free((void *)t);
  if (p) {
    pdafree(p);
  }
  if (v) {
    goto _L;
  } else
  if (c == -1LL) {
    _L: /* CIL Label */ 
    if (z) {
      cd(z);
      *a = (K )0;
    } else {
      *a = z;
    }
  } else {
    *a = z;
  }
  if (v) {
    tmp___4 = - v;
  } else {
    tmp___4 = c;
  }
  return (tmp___4);
}
}
K KONA_ARGS  ;
static C port[65]  ;
static void multihomeini(S *x___0 ) 
{ 
  S s ;
  S p ;
  char *tmp ;
  K h ;
  K tmp___0 ;

  {
  s = *x___0;
  if (! s) {
    return;
  }
  tmp = strchr((char const   *)s, ':');
  p = tmp;
  if (! p) {
    return;
  }
  strcpy((char * __restrict  )(port), (char const   * __restrict  )(p + 1));
  HOST_IFACE = spn(s, (I )(p - s));
  *x___0 = port;
  tmp___0 = Ks(HOST_IFACE);
  h = tmp___0;
  cd(KONA_CLIENT);
  KONA_CLIENT = _host(h);
  cd(h);
  return;
}
}
I args(int n , S *v ) 
{ 
  K a ;
  K k ;
  I c ;
  I len ;
  I b___1 ;
  I i ;
  I _i___0 ;
  size_t tmp ;
  long tmp___0 ;
  K tmp___1 ;
  int tmp___2 ;
  S *tmp___3 ;
  S h ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  b___1 = (I )1;
  KONA_ARGS = newK((I )0, (I )n);
  if (! KONA_ARGS) {
    return ((I )0);
  }
  i = (I )0;
  _i___0 = (I )n;
  while (i < _i___0) {
    tmp = strlen((char const   *)*(v + i));
    len = (I )tmp;
    a = newK((I )-3, len);
    if (! a) {
      cd(KONA_ARGS);
      return ((I )0);
    }
    strncpy((char * __restrict  )((C *)(a->k)), (char const   * __restrict  )*(v + i),
            (size_t )len);
    KONA_ARGS->k[i] = a;
    i ++;
  }
  while (1) {
    tmp___2 = getopt(n, (char * const  *)v, ":b:h:i:e:x:");
    c = (I )tmp___2;
    if (! (-1LL != c)) {
      break;
    }
    switch (c) {
    case 104LL: 
    if (IPC_PORT) {
      printf((char const   * __restrict  )"-i accepted, cannot also have -h\n");
    } else {
      HTTP_PORT = optarg;
    }
    break;
    case 105LL: 
    if (HTTP_PORT) {
      printf((char const   * __restrict  )"-h accepted, cannot also have -i\n");
    } else {
      IPC_PORT = optarg;
      tmp___0 = atol((char const   *)IPC_PORT);
      *((I *)(KONA_PORT->k)) = (I )tmp___0;
    }
    break;
    case 98LL: 
    b___1 = (I )0;
    break;
    case 101LL: 
    tmp___1 = X(optarg);
    cd(tmp___1);
    exit(0);
    break;
    case 120LL: 
    k = X(optarg);
    printAtDepth((V )0, k, (I )0, (I )0, (I )0, (I )0);
    printf((char const   * __restrict  )"\n");
    cd(k);
    exit(0);
    break;
    case 58LL: ;
    case 63LL: 
    printf((char const   * __restrict  )"%c\nabort", optopt);
    exit(0);
    break;
    }
  }
  if (b___1) {
    boilerplate();
  }
  if (IPC_PORT) {
    tmp___3 = & IPC_PORT;
  } else {
    tmp___3 = & HTTP_PORT;
  }
  multihomeini(tmp___3);
  tmp___4 = getenv("KINIT");
  h = tmp___4;
  if (h) {
    load(h);
  }
  while (optind < n) {
    tmp___5 = optind;
    optind ++;
    load(*(v + tmp___5));
  }
  prompt((I )0);
  return ((I )0);
}
}
pthread_mutex_t execute_mutex  ;
C khome[4097]  ;
static void khinit(void) 
{ 
  I n ;
  S h ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  khome[0] = (C )0;
  h = getenv("KHOME");
  if (h) {
    tmp = strlen((char const   *)h);
    n = (I )tmp;
    if (n + 1LL > 4096LL) {
      return;
    }
    strcpy((char * __restrict  )(khome), (char const   * __restrict  )h);
    strcpy((char * __restrict  )(khome + n), (char const   * __restrict  )"/");
  } else {
    h = getenv("HOME");
    if (h) {
      tmp___0 = strlen((char const   *)h);
      n = (I )tmp___0;
      if (n + 3LL > 4096LL) {
        return;
      }
      strcpy((char * __restrict  )(khome), (char const   * __restrict  )h);
      strcpy((char * __restrict  )(khome + n), (char const   * __restrict  )"/k/");
    }
  }
  return;
}
}
I kinit(void) 
{ 
  long tmp ;
  pthread_mutexattr_t mta ;
  L tmp___0 ;
  L tmp___1 ;
  L tmp___2 ;
  L tmp___3 ;
  L tmp___4 ;
  L tmp___5 ;
  L tmp___6 ;
  I i ;
  I _i___0 ;
  K x___0 ;
  S tmp___7 ;
  K tmp___8 ;
  K tmp___9 ;
  S tmp___10 ;
  K tmp___11 ;

  {
  atexit((void (*)(void))(& finally));
  tmp = sysconf(30);
  PG = (I )tmp;
  if (PG & (PG - 1LL)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%u: %s\n",
            "src/kc.c", 128, "Pagesize not power of 2");
    exit(1);
  }
  ninit();
  pthread_mutexattr_init(& mta);
  pthread_mutexattr_settype(& mta, 1);
  pthread_mutex_init(& execute_mutex, (pthread_mutexattr_t const   *)(& mta));
  pthread_mutexattr_destroy(& mta);
  DT_SIZE = DT_OFFSET((V )(& TABLE_END));
  DT_END_OFFSET = DT_OFFSET((V )(& end));
  DT_ADVERB_OFFSET = DT_OFFSET((V )(& over));
  DT_VERB_OFFSET = DT_OFFSET((V )(& flip));
  DT_SPECIAL_VERB_OFFSET = DT_OFFSET((V )(& _0m));
  offsetOver = DT_OFFSET((V )(& over));
  offsetScan = DT_OFFSET((V )(& scan));
  offsetEach = DT_OFFSET((V )(& each));
  offsetEachright = DT_OFFSET((V )(& eachright));
  offsetEachleft = DT_OFFSET((V )(& eachleft));
  offsetEachpair = DT_OFFSET((V )(& eachpair));
  tmp___0 = DT_OFFSET((V )(& what));
  offsetWhat = (V )tmp___0;
  tmp___1 = DT_OFFSET((V )(& at));
  offsetAt = (V )tmp___1;
  tmp___2 = DT_OFFSET((V )(& dot));
  offsetDot = (V )tmp___2;
  tmp___3 = DT_OFFSET((V )(& colon_dyadic));
  offsetColon = (V )tmp___3;
  tmp___4 = DT_OFFSET((V )(& join));
  offsetJoin = (V )tmp___4;
  tmp___5 = DT_OFFSET((V )(& _ssr));
  offsetSSR = (V )tmp___5;
  tmp___6 = DT_OFFSET((V )(& _3m));
  offset3m = (V )tmp___6;
  kerr("(nil)");
  SYMBOLS = newN();
  seedPRNG((I )-271828);
  NIL = Kn();
  KFIXED = newK((I )0, (I )0);
  kap(& KFIXED, (V )(& NIL));
  cd(NIL);
  d_ = sp((S )".k");
  LS = sp((S )"");
  i = (I )0;
  _i___0 = (I )3;
  while (i < _i___0) {
    IFP[i] = sp(IFS[i]);
    i ++;
  }
  KTREE = Kd();
  tmp___7 = sp((S )"k");
  tmp___8 = newEntry(tmp___7);
  x___0 = tmp___8;
  kap(& KTREE, (V )(& x___0));
  cd(x___0);
  tmp___9 = _dot_t();
  tmp___10 = sp((S )"t");
  x___0 = newE(tmp___10, tmp___9);
  kap(& KTREE, (V )(& x___0));
  cd(x___0);
  KONA_WHO = newK((I )1, (I )1);
  *((I *)(KONA_WHO->k)) = (I )0;
  KONA_PORT = newK((I )1, (I )1);
  *((I *)(KONA_PORT->k)) = (I )0;
  KONA_GSET = _n();
  KONA_IDX = _n();
  tmp___11 = _h();
  KONA_CLIENT = _host(tmp___11);
  khinit();
  return ((I )0);
}
}
static I randomBits(void) 
{ 
  I s ;
  I f ;
  int tmp ;
  I r ;
  ssize_t tmp___0 ;
  K tmp___1 ;
  int tmp___2 ;
  K tmp___3 ;

  {
  tmp = open("/dev/urandom", 0);
  f = (I )tmp;
  tmp___0 = read((int )f, (void *)(& s), sizeof(s));
  r = (I )tmp___0;
  if (! r) {
    tmp___1 = kerr("read");
    show(tmp___1);
  }
  tmp___2 = close((int )f);
  r = (I )tmp___2;
  if (r) {
    tmp___3 = kerr("file");
    show(tmp___3);
  }
  return (s);
}
}
void seedPRNG(I s ) 
{ 
  I tmp ;

  {
  if (s) {
    SEED = s;
  } else {
    tmp = randomBits();
    SEED = tmp;
  }
  init_genrand64((unsigned long long )SEED);
  return;
}
}
static I nodeCount_(N n ) 
{ 
  I l ;
  I r ;
  size_t tmp ;
  I tmp___0 ;
  I tmp___1 ;

  {
  l = (I )0;
  r = (I )0;
  if (n->k) {
    tmp = strlen((char const   *)((S )n->k));
    if (tmp) {
      printf((char const   * __restrict  )"%s ", (S )n->k);
    } else {
      printf((char const   * __restrict  )"(nil) ");
    }
  }
  if (n->c[0]) {
    tmp___0 = nodeCount_(n->c[0]);
    l += tmp___0;
  }
  if (n->c[1]) {
    tmp___1 = nodeCount_(n->c[1]);
    r += tmp___1;
  }
  return ((1LL + l) + r);
}
}
static I nodeCount(N n ) 
{ 
  I tmp ;

  {
  tmp = nodeCount_(n);
  return (tmp - 1LL);
}
}
I check(void) 
{ 
  I ofCheck___0 ;
  S a ;
  I n ;
  PDA q ;

  {
  ofCheck___0 = fCheck;
  if (fnc) {
    ofnc[0] = *fnc;
  }
  kerr("(nil)");
  fCheck ++;
  prompt(fCheck);
  a = (S )0;
  n = (I )0;
  q = (PDA )0;
  while (1) {
    line(stdin, & a, & n, & q);
    if (fCheck == ofCheck___0) {
      return ((I )0);
    }
  }
}
}
static I fln  =    (I )0;
I lines(FILE *f ) 
{ 
  S a ;
  I n ;
  PDA p ;
  I tmp ;

  {
  a = (S )0;
  n = (I )0;
  p = (PDA )0;
  fln = (I )1;
  while (1) {
    tmp = line(f, & a, & n, & p);
    if (! (-1LL != tmp)) {
      break;
    }
    fln = (I )0;
  }
  return ((I )0);
}
}
I line(FILE *f , S *a , I *n , PDA *p ) 
{ 
  S s ;
  I b___1 ;
  I c ;
  I m ;
  I o ;
  I q ;
  K k ;
  F d___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  I i ;
  I j ;
  I jj ;
  size_t tmp___1 ;
  I cfnc ;
  size_t tmp___2 ;
  I cprm ;
  I cfl ;
  I cfc ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  clock_t tmp___5 ;
  K tmp___6 ;
  clock_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  I v ;
  I tmp___10 ;
  K tmp___11 ;
  K tmp___12 ;
  int tmp___13 ;
  clock_t tmp___14 ;
  K tmp___15 ;
  clock_t tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  S ptr ;
  I ctl ;
  I cnt ;
  I i___0 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  I i___1 ;
  I _i___0 ;
  I cnt___0 ;
  I i___2 ;
  size_t tmp___23 ;
  S ptr___0 ;
  char *tmp___24 ;
  I i___3 ;
  I _i___1 ;
  int tmp___25 ;
  I i___4 ;
  size_t tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  I cnt___1 ;
  I tmp___29 ;

  {
  s = (S )0;
  b___1 = (I )0;
  c = (I )0;
  m = (I )0;
  o = (I )1;
  q = (I )1;
  feci = (I )0;
  fer = feci;
  fbr = fer;
  fam = (I )1;
  c = getline_(& s, & m, f);
  if (-1LL == c) {
    goto cleanup;
  }
  if (fCheck) {
    tmp___0 = strlen((char const   *)s);
    if (1UL == tmp___0) {
      if ((int )*(s + 0) == 10) {
        while (1) {
          tmp = strlen((char const   *)s);
          if (1UL == tmp) {
            if (! ((int )*(s + 0) == 10)) {
              break;
            }
          } else {
            break;
          }
          prompt(b___1 + fCheck);
          c = getline_(& s, & m, f);
          if (-1LL == c) {
            goto cleanup;
          }
        }
      }
    }
  }
  if (fln) {
    if ((int )*(s + 0) == 35) {
      if ((int )*(s + 1) == 33) {
        goto cleanup;
      }
    }
  }
  if (fCheck) {
    if ((int )*(s + 0) == 58) {
      tmp___8 = strstr((char const   *)s, "`\"");
      if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
        if (lineA) {
          goto _L___0;
        } else
        if (flc) {
          _L___0: /* CIL Label */ 
          if (*a) {
            j = (I )0;
            while (j < 10LL) {
              if ((int )cdp[j] == (int )ofnc[0]) {
                break;
              }
              j ++;
            }
            i = (I )0;
            while (1) {
              tmp___1 = strlen((char const   *)(lineC));
              if (! ((unsigned long long )i < (unsigned long long )tmp___1)) {
                break;
              }
              if ((int )lineC[i] == (int )cdp[j + 1LL]) {
                break;
              }
              i ++;
            }
            *n = (I )0;
            appender(a, n, lineC, i + 1LL);
          } else {
            cfnc = (I )0;
            i = (I )0;
            while (1) {
              tmp___2 = strlen((char const   *)(lineC));
              if (! ((unsigned long long )i < (unsigned long long )tmp___2)) {
                break;
              }
              if ((int )lineC[i] == (int )*fnc) {
                cfnc ++;
              }
              i ++;
            }
            cprm = (I )0;
            i = (I )0;
            while ((int )cdp[i] != 97) {
              cprm ++;
              i ++;
            }
            if (cfnc != ocr) {
              if (cfnc == ocr) {
                if (! ((int )cdp[cprm - 1LL] == (int )*fnc)) {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
                cfl = (I )0;
                cfc = (I )0;
                tmp___3 = strlen((char const   *)(lineC));
                i = (I )(tmp___3 - 1UL);
                while (i > 0LL) {
                  if ((int )lineC[i] == (int )*fnc) {
                    cfl ++;
                  }
                  if (cfl == ocr) {
                    break;
                  }
                  i --;
                }
                j = (I )0;
                while (j < 10LL) {
                  if ((int )cdp[j] == (int )*fnc) {
                    cfc ++;
                  }
                  if (cfc == ocr) {
                    break;
                  }
                  j ++;
                }
                jj = i - 1LL;
                while (jj > 0LL) {
                  if ((int )lineC[jj] == (int )cdp[j + 1LL]) {
                    break;
                  }
                  jj --;
                }
                appender(a, n, lineC, jj + 1LL);
              }
            }
          }
          tmp___4 = strlen((char const   *)s);
          appender(a, n, s + 1, (I )(tmp___4 - 2UL));
          tmp___5 = clock();
          d___0 = (F )tmp___5;
          tmp___6 = wd(*a, (int )*n);
          k = ex(tmp___6);
          tmp___7 = clock();
          d___0 = ((F )tmp___7 - d___0) / (F )1000000L;
          fCheck --;
          q = (I )0;
          goto next;
        }
      }
    }
  }
  if ((int )*(s + 0) == 92) {
    if ((int )*(s + 1) == 10) {
      if (! fCheck) {
        if (fLoad) {
          c = (I )-1;
          goto cleanup;
        }
      }
      if (fCheck) {
        fCheck --;
        return ((I )0);
      }
      if (*a) {
        goto cleanup;
      }
    }
  }
  if ((int )*(s + 0) == 92) {
    if ((int )*(s + 1) == 92) {
      tmp___9 = strlen((char const   *)s);
      if (2UL == tmp___9) {
        exit(0);
      }
    }
  }
  if (flc) {
    *n = (I )0;
  }
  appender(a, n, s, c);
  tmp___10 = complete(*a, *n, p, (I *)0);
  v = tmp___10;
  b___1 = parsedepth(*p);
  if (v == 3LL) {
    tmp___11 = kerr("nest");
    show(tmp___11);
    goto cleanup;
  }
  if (v == 2LL) {
    tmp___12 = kerr("unmatched");
    show(tmp___12);
    b___1 = (I )0;
    goto cleanup;
  }
  if (v == 1LL) {
    fCmplt = (I )1;
    goto done;
  }
  if (v == 0LL) {
    fCmplt = (I )0;
  }
  if (n) {
    if (10 == (int )*(*a + (*n - 1LL))) {
      (*n) --;
      *(*a + *n) = (C )0;
    }
  }
  tmp___13 = pthread_mutex_lock(& execute_mutex);
  if (tmp___13) {
    perror("Lock mutex in line()");
    abort();
  }
  tmp___14 = clock();
  d___0 = (F )tmp___14;
  tmp___15 = wd(*a, (int )*n);
  k = ex(tmp___15);
  tmp___16 = clock();
  d___0 = ((F )tmp___16 - d___0) / (F )1000000L;
  tmp___17 = pthread_mutex_unlock(& execute_mutex);
  if (tmp___17) {
    perror("Unlock mutex in line()");
    abort();
  }
  next: 
  if (o) {
    if (fam) {
      if (! feci) {
        show(k);
      }
    }
  }
  cd(k);
  cleanup: 
  if (fCheck) {
    tmp___18 = strlen((char const   *)s);
    if (tmp___18 == 0UL) {
      exit(0);
    } else {
      tmp___19 = strlen((char const   *)s);
      if ((int )*(s + (tmp___19 - 1UL)) < 0) {
        exit(0);
      }
    }
  }
  ptr = (S )0;
  tmp___28 = strcmp((char const   *)(errmsg), "value");
  if (tmp___28) {
    tmp___27 = strcmp((char const   *)(errmsg), "(nil)");
    if (tmp___27) {
      if (fer != -1LL) {
        oerr();
        ctl = (I )0;
        if (fError) {
          if (2LL == fError) {
            exit(1);
          }
          if (lineA) {
            if (fnc) {
              cnt = (I )0;
              tmp___22 = strlen((char const   *)fnc);
              if (tmp___22 == 1UL) {
                i___0 = (I )0;
                while (1) {
                  tmp___20 = strlen((char const   *)lineA);
                  if (! ((unsigned long long )i___0 < (unsigned long long )tmp___20)) {
                    break;
                  }
                  if ((int )*(lineA + i___0) == (int )*fnc) {
                    cnt ++;
                  }
                  i___0 ++;
                }
              } else {
                i___0 = (I )0;
                while (1) {
                  tmp___21 = strlen((char const   *)lineA);
                  if (! ((unsigned long long )i___0 < (unsigned long long )(tmp___21 - 1UL))) {
                    break;
                  }
                  if ((int )*(lineA + i___0) == (int )*(fnc + 0)) {
                    if ((int )*(lineA + (i___0 + 1LL)) == (int )*(fnc + 1)) {
                      ptr = lineA + i___0;
                      cnt ++;
                    }
                  }
                  i___0 ++;
                }
              }
              if (cnt == 1LL) {
                ctl = (I )1;
                printf((char const   * __restrict  )"%s\n", lineA);
                if (! ptr) {
                  ptr = strchr((char const   *)lineA, (int )*fnc);
                }
                i___1 = (I )0;
                _i___0 = (I )(ptr - lineA);
                while (i___1 < _i___0) {
                  printf((char const   * __restrict  )" ");
                  i___1 ++;
                }
                printf((char const   * __restrict  )"^\n");
              }
              if (cnt > 1LL) {
                if (fnci) {
                  if (fnci < 127LL) {
                    ocr = (I )0;
                    i___0 = (I )0;
                    while (i___0 < fnci) {
                      if ((unsigned long )fncp[i___0] == (unsigned long )fncp[fnci - 1LL]) {
                        ocr ++;
                      }
                      i___0 ++;
                    }
                    printf((char const   * __restrict  )"%s\n", lineA);
                    printf((char const   * __restrict  )"at execution instance %lld of \"%s\"\n",
                           ocr, fnc);
                    fnci = (I )0;
                  }
                }
              }
            }
          }
          if (lineB) {
            if (! ctl) {
              tmp___25 = strcmp((char const   *)lineA, (char const   *)lineB);
              if (tmp___25) {
                if (fnc) {
                  cnt___0 = (I )0;
                  printf((char const   * __restrict  )"%s\n", lineB);
                  i___2 = (I )0;
                  while (1) {
                    tmp___23 = strlen((char const   *)lineB);
                    if (! ((unsigned long long )i___2 < (unsigned long long )tmp___23)) {
                      break;
                    }
                    if ((int )*(lineB + i___2) == (int )*fnc) {
                      cnt___0 ++;
                    }
                    i___2 ++;
                  }
                  if (cnt___0 == 1LL) {
                    tmp___24 = strchr((char const   *)lineB, (int )*fnc);
                    ptr___0 = tmp___24;
                    i___3 = (I )0;
                    _i___1 = (I )(ptr___0 - lineB);
                    while (i___3 < _i___1) {
                      printf((char const   * __restrict  )" ");
                      i___3 ++;
                    }
                    printf((char const   * __restrict  )"^\n");
                  }
                  if (cnt___0 > 1LL) {
                    if (fnci) {
                      if (fnci < 127LL) {
                        ocr = (I )0;
                        i___2 = (I )0;
                        while (i___2 < fnci) {
                          if ((unsigned long )fncp[i___2] == (unsigned long )fncp[fnci - 1LL]) {
                            ocr ++;
                          }
                          i___2 ++;
                        }
                        printf((char const   * __restrict  )"at execution instance %lld of %s\n",
                               ocr, fnc);
                      }
                    }
                  }
                }
              }
            }
          }
          if (lineA) {
            goto _L___1;
          } else
          if (lineB) {
            _L___1: /* CIL Label */ 
            if (! flc) {
              i___4 = (I )0;
              i___4 = (I )0;
              while (1) {
                tmp___26 = strlen((char const   *)*a);
                if (! ((unsigned long long )i___4 < (unsigned long long )(1UL + tmp___26))) {
                  break;
                }
                lineC[i___4] = *(*a + i___4);
                i___4 ++;
              }
              flc = (I )1;
            }
            check();
          }
        }
      }
    }
  }
  if (*p) {
    pdafree(*p);
  }
  *p = (PDA )0;
  free((void *)*a);
  *a = (S )0;
  *n = (I )0;
  free((void *)s);
  s = (S )0;
  done: 
  if (fWksp) {
    printf((char const   * __restrict  )"used now : %lld (%lld %lld)\n", (I )mUsed,
           (I )mAlloc, (I )mMap);
    printf((char const   * __restrict  )"max used : %lld\n", (I )mMax);
    printf((char const   * __restrict  )"symbols  : ");
    tmp___29 = nodeCount(SYMBOLS);
    cnt___1 = tmp___29;
    printf((char const   * __restrict  )"\n");
    printf((char const   * __restrict  )"count    : %lld\n", cnt___1);
    fWksp = (I )0;
  }
  if (o) {
    if (! fLoad) {
      if (q) {
        prompt(b___1 + fCheck);
      }
    }
  }
  kerr("(nil)");
  feci = (I )0;
  fom = feci;
  fnci = fom;
  fer1 = fnci;
  fer = fer1;
  fll = fer;
  if (! fCheck) {
    lineB = (S )0;
    lineA = lineB;
    fnc = lineA;
  }
  if (cls) {
    cd(cls);
    cls = (K )0;
  }
  return (c);
}
}
I tmr_ival  =    (I )0;
V timer_thread(V arg ) 
{ 
  K a ;
  K tmp ;
  K h ;
  K *tmp___0 ;
  K z ;
  int tmp___1 ;
  int tmp___2 ;
  I tmp___3 ;

  {
  while (1) {
    if (tmr_ival) {
      tmp = _n();
      a = tmp;
      tmp___0 = denameS((S )".", (S )".m.ts", (I )0);
      h = *tmp___0;
      z = (K )0;
      if (6LL != h->t) {
        tmp___1 = pthread_mutex_lock(& execute_mutex);
        if (tmp___1) {
          perror("Lock mutex in timer_thread())");
          abort();
        }
        z = at(h, a);
        tmp___2 = pthread_mutex_unlock(& execute_mutex);
        if (tmp___2) {
          perror("Unlock mutex in timer_thread())");
          abort();
        }
      }
      if (z) {
        cd(z);
      }
      cd(a);
    }
    if (tmr_ival) {
      tmp___3 = 1000LL * tmr_ival;
    } else {
      tmp___3 = (I )10000;
    }
    usleep((__useconds_t )tmp___3);
  }
  return ((V )0);
}
}
static void handle_SIGINT(int sig ) 
{ 


  {
  interrupted = (int volatile   )1;
  return;
}
}
I attend(void) 
{ 
  S a ;
  I n ;
  PDA q ;
  fd_set read_fds ;
  int fdmax ;
  int tmp ;
  int listener ;
  int newfd ;
  struct sockaddr_storage remoteaddr ;
  socklen_t addrlen ;
  int nbytes ;
  I yes ;
  int i ;
  int rv ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *p ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  struct sigaction sa ;
  I res ;
  int tmp___0 ;
  K tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  S tmp___5 ;
  K tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  I tmp___13 ;
  __uint32_t tmp___14 ;
  int tmp___15 ;

  {
  fer = (I )0;
  a = (S )0;
  n = (I )0;
  q = (PDA )0;
  tmp = fileno(stdin);
  fdmax = tmp;
  listener = 0;
  yes = (I )1;
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& master.__fds_bits[0]): "memory");
    break;
  }
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& read_fds.__fds_bits[0]): "memory");
    break;
  }
  sa.__sigaction_handler.sa_handler = & handle_SIGINT;
  sa.sa_flags = 268435456;
  sigemptyset(& sa.sa_mask);
  tmp___0 = sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  res = (I )tmp___0;
  if (res) {
    tmp___1 = kerr("sigaction");
    show(tmp___1);
    return ((I )-1);
  }
  memset((void *)(& hints), 0, sizeof(hints));
  hints.ai_family = 2;
  hints.ai_socktype = 1;
  hints.ai_flags = 1;
  tmp___2 = fileno(stdin);
  tmp___3 = fileno(stdin);
  master.__fds_bits[tmp___2 / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << tmp___3 % (8 * (int )sizeof(__fd_mask )));
  if (IPC_PORT) {
    goto _L;
  } else
  if (HTTP_PORT) {
    _L: /* CIL Label */ 
    if (IPC_PORT) {
      tmp___5 = IPC_PORT;
    } else {
      tmp___5 = HTTP_PORT;
    }
    rv = getaddrinfo((char const   * __restrict  )HOST_IFACE, (char const   * __restrict  )tmp___5,
                     (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& ai));
    if (rv) {
      tmp___4 = gai_strerror(rv);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"server: %s\n",
              tmp___4);
      exit(1);
    }
    p = ai;
    while ((unsigned long )p != (unsigned long )((void *)0)) {
      listener = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
      if (listener < 0) {
        goto __Cont;
      }
      tmp___8 = bind(listener, (struct sockaddr  const  *)p->ai_addr, p->ai_addrlen);
      if (tmp___8 < 0) {
        tmp___7 = close(listener);
        if (tmp___7) {
          tmp___6 = kerr("file");
          show(tmp___6);
        }
        goto __Cont;
      }
      break;
      __Cont: /* CIL Label */ 
      p = p->ai_next;
    }
    if (! p) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"server: failed to bind\n");
      exit(2);
    }
    freeaddrinfo(ai);
    tmp___9 = listen(listener, 10);
    if (-1 == tmp___9) {
      perror("listen");
      exit(3);
    }
    master.__fds_bits[listener / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << listener % (8 * (int )sizeof(__fd_mask )));
    fdmax = listener;
  }
  fln = (I )1;
  while (1) {
    scrLim = (I )0;
    read_fds = master;
    tmp___12 = select(fdmax + 1, (fd_set * __restrict  )(& read_fds), (fd_set * __restrict  )0,
                      (fd_set * __restrict  )0, (struct timeval * __restrict  )0);
    if (-1 == tmp___12) {
      tmp___11 = __errno_location();
      if (*tmp___11 == 4) {
        interrupted = (int volatile   )0;
        tmp___10 = __errno_location();
        *tmp___10 = 0;
      } else {
        perror("select");
        exit(4);
      }
    }
    i = 0;
    while (i <= fdmax) {
      if ((read_fds.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << i % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        tmp___15 = fileno(stdin);
        if (i == tmp___15) {
          ofCheck = (I )0;
          fCheck = ofCheck;
          flc = fCheck;
          tmp___13 = line(stdin, & a, & n, & q);
          nbytes = (int )tmp___13;
          fln = (I )0;
          if (nbytes <= 0) {
            if (! IPC_PORT) {
              if (! HTTP_PORT) {
                exit(0);
              } else {
                master.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] &= ~ ((__fd_mask )(1UL << i % (8 * (int )sizeof(__fd_mask ))));
              }
            } else {
              master.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] &= ~ ((__fd_mask )(1UL << i % (8 * (int )sizeof(__fd_mask ))));
            }
          }
        } else
        if (i == listener) {
          addrlen = (socklen_t )sizeof(remoteaddr);
          newfd = accept(listener, (struct sockaddr * __restrict  )((struct sockaddr *)(& remoteaddr)),
                         (socklen_t * __restrict  )(& addrlen));
          if (newfd == -1) {
            perror("accept");
          } else {
            wipe_tape((I )newfd);
            master.__fds_bits[newfd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << newfd % (8 * (int )sizeof(__fd_mask )));
            if (newfd > fdmax) {
              fdmax = newfd;
            }
            setsockopt(newfd, 6, 1, (void const   *)(& yes), (socklen_t )sizeof(I ));
            tmp___14 = __bswap_32(((struct sockaddr_in *)(& remoteaddr))->sin_addr.s_addr);
            CP[newfd].a = (I )tmp___14;
          }
        } else
        if (a) {
          goto __Cont___0;
        } else {
          read_tape((I )i, (I )i, (I )0);
        }
      }
      __Cont___0: /* CIL Label */ 
      i ++;
    }
  }
}
}
#pragma merger("0","/tmp/cil-rJA8oaAu.i","-g,-pthread,-O3")
V fncp[128]  ;
K collapse(K x___0 ) ;
K delist(K x___0 ) ;
K kcloneI(K a , char const   *f , int n ) ;
K of(K a , K b___1 ) ;
K dot_tetradic_2(K *g , K b___1 , K c , K y ) ;
K itemAtIndex(K a , I i ) ;
K ex1(V *w___0 , K k , I *i , I n , I f ) ;
K dot_tetradic(K a , K b___1 , K c , K y ) ;
K at_tetradic(K a , K b___1 , K c , K y ) ;
K what_triadic(K a , K b___1 , K c ) ;
K drop(K a , K b___1 ) ;
I atomI(K a ) ;
I matchI(K a , K b___1 ) ;
K last(K a ) ;
static K bv_ex(V *p , K k ) ;
K dv_ex(K a , V *p , K b___1 ) ;
static K ex0(V *v , K k , I r ) ;
static K ex2(V *v , K k ) ;
static V ex_(V a , I r ) ;
I cirRef(K x___0 , K y ) ;
I cirRef_(K x___0 , K y , I f ) ;
I fer  =    (I )0;
I fer1  =    (I )0;
I fwh  =    (I )0;
I stk  =    (I )0;
I stk1  =    (I )0;
I prj  =    (I )0;
I prj2  =    (I )0;
K prnt  =    (K )0;
I fsf  =    (I )0;
K grnt  =    (K )0;
K cls  =    (K )0;
K encf  =    (K )0;
I encp  =    (I )0;
I frg  =    (I )0;
S fnc  =    (S )0;
I fnci  =    (I )0;
I fom  =    (I )0;
I fam  =    (I )1;
I ft3  =    (I )0;
C cdp[11]  = 
  {      (C )'a',      (C )'a',      (C )'a',      (C )'a', 
        (C )'a',      (C )'a',      (C )'a',      (C )'a', 
        (C )'a',      (C )'a',      (C )'\000'};
I calf  =    (I )-1;
C *alf  =    (C *)"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
K sd_(K x___0 , I f ) 
{ 
  I tmp ;
  I i ;
  I _i___0 ;
  V *v ;
  I ii ;
  I i___0 ;
  I _i___1 ;

  {
  if (x___0) {
    tmp = bk((V )x___0);
    if (tmp) {
      printf((char const   * __restrict  )" is ; or \\n\n");
      return (x___0);
    } else {
      if (x___0->t == 4LL) {
        printf((char const   * __restrict  )"     %p %p %p  %lld-%lld %lld %lld   ",
               x___0, x___0->k, x___0->k[0], x___0->_c >> 8, (x___0->_c << 56) >> 56,
               x___0->t, x___0->n);
      } else {
        printf((char const   * __restrict  )"     %p %p            %lld-%lld %lld %lld   ",
               x___0, x___0->k, x___0->_c >> 8, (x___0->_c << 56) >> 56, x___0->t,
               x___0->n);
      }
      if (f > 0LL) {
        if (x___0->t == 0LL) {
          printf((char const   * __restrict  )"\n");
        } else
        if (x___0->t == 5LL) {
          printf((char const   * __restrict  )"\n");
        }
      }
      if (x___0->t != 6LL) {
        if (f > 0LL) {
          show(x___0);
        } else {
          printf((char const   * __restrict  )"\n");
        }
      } else {
        printf((char const   * __restrict  )"\n");
      }
    }
  } else {
    printf((char const   * __restrict  )"     ");
    show(x___0);
    printf((char const   * __restrict  )"\n");
    return (x___0);
  }
  if (f < 2LL) {
    return ((K )0);
  }
  switch (x___0->t) {
  case 7LL: 
  calf ++;
  printf((char const   * __restrict  )"     %c0:    %p     %s\n", (int )*(alf + calf),
         (S *)(x___0->k) + 0, *((S *)(x___0->k) + 0));
  printf((char const   * __restrict  )"     %c1:    %p     %p\n", (int )*(alf + calf),
         (V *)(x___0->k) + 1, *((V *)(x___0->k) + 1));
  i = (I )0;
  _i___0 = (I )6;
  while (i < _i___0) {
    printf((char const   * __restrict  )"     %c%lld:   ", (int )*(alf + calf), 2LL + i);
    printf((char const   * __restrict  )" %p", (V *)(x___0->k) + (2LL + i));
    sd_((K )*((V *)(x___0->k) + (2LL + i)), (I )3);
    i ++;
  }
  calf --;
  break;
  case -4LL: 
  v = (V *)(x___0->k);
  if (((unsigned long )*(v + 0) > (unsigned long )((V )16)) & ((unsigned long )*(v + 0) < (unsigned long )((V )83886080))) {
    return ((K )0);
  }
  ii = (I )0;
  while (*(v + ii)) {
    printf((char const   * __restrict  )"     .2%c[%lld]: %p", (int )*(alf + calf),
           ii, *(v + ii));
    if ((unsigned long )*(v + ii) > (unsigned long )((V )DT_SIZE)) {
      if (calf < 1LL) {
        sd_(*((K *)*(v + ii)), (I )2);
      } else {
        sd_(*((K *)*(v + ii)), (I )1);
      }
    } else {
      printf((char const   * __restrict  )"\n");
    }
    ii ++;
  }
  break;
  case 5LL: ;
  case 0LL: 
  i___0 = (I )0;
  _i___1 = x___0->n;
  while (i___0 < _i___1) {
    printf((char const   * __restrict  )" %p", & x___0->k[i___0]);
    sd_(x___0->k[i___0], (I )2);
    i___0 ++;
  }
  break;
  }
  return ((K )0);
}
}
K sd(K x___0 ) 
{ 
  K tmp ;

  {
  tmp = sd_(x___0, (I )1);
  return (tmp);
}
}
static K cjoin(K x___0 , K y ) 
{ 
  K tmp ;
  K tmp___0 ;
  I tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  I zn ;
  K v ;
  I i ;
  I _i___0 ;
  K tmp___4 ;
  I tmp___5 ;
  K z ;
  K tmp___6 ;
  I tmp___7 ;
  S p ;
  I i___0 ;
  I _i___1 ;

  {
  if (3LL != x___0->t) {
    tmp = kerr("type");
    return (tmp);
  }
  if (y->t < 0LL) {
    tmp___1 = - y->t;
  } else {
    tmp___1 = y->t;
  }
  if (3LL == tmp___1) {
    tmp___0 = ci(y);
    return (tmp___0);
  }
  if (y->t) {
    tmp___2 = kerr("type");
    return (tmp___2);
  }
  if (! y->n) {
    tmp___3 = newK((I )-3, (I )0);
    return (tmp___3);
  }
  zn = (I )0;
  i = (I )0;
  _i___0 = y->n;
  while (i < _i___0) {
    v = y->k[i];
    if (-3LL != v->t) {
      tmp___4 = kerr("type");
      return (tmp___4);
    }
    zn += v->n;
    i ++;
  }
  if (y->n) {
    tmp___5 = (y->n - 1LL) * x___0->n;
  } else {
    tmp___5 = (I )0;
  }
  zn += tmp___5;
  tmp___6 = newK((I )-3, zn);
  z = tmp___6;
  tmp___7 = OOM_CD((I )0, z, (V )-1);
  if (! tmp___7) {
    return ((K )0);
  }
  p = (C *)(z->k);
  i___0 = (I )0;
  _i___1 = y->n - 1LL;
  while (i___0 < _i___1) {
    v = y->k[i___0];
    memcpy((void * __restrict  )p, (void const   * __restrict  )((C *)(v->k)), (size_t )v->n);
    p += v->n;
    memcpy((void * __restrict  )p, (void const   * __restrict  )((C *)(x___0->k)),
           (size_t )x___0->n);
    p += x___0->n;
    i___0 ++;
  }
  v = y->k[y->n - 1LL];
  memcpy((void * __restrict  )p, (void const   * __restrict  )((C *)(v->k)), (size_t )v->n);
  return (z);
}
}
static K csplit(K x___0 , K y ) 
{ 
  K tmp ;
  K tmp___0 ;
  I tmp___1 ;
  int delim ;
  S s ;
  I p0 ;
  I p1 ;
  I zn ;
  I i ;
  I j ;
  I n ;
  K tmp___2 ;
  K tmp___3 ;
  K z ;
  K tmp___4 ;
  I tmp___5 ;
  I j___0 ;
  K z___0 ;
  K tmp___6 ;
  I tmp___7 ;
  I i___0 ;
  I _i___0 ;
  K d___0 ;
  K tmp___8 ;
  I tmp___9 ;

  {
  if (3LL != x___0->t) {
    tmp = kerr("type");
    return (tmp);
  }
  if (y->t < 0LL) {
    tmp___1 = - y->t;
  } else {
    tmp___1 = y->t;
  }
  if (3LL != tmp___1) {
    tmp___0 = kerr("type");
    return (tmp___0);
  }
  delim = (int )*((C *)(x___0->k));
  s = (C *)(y->k);
  zn = (I )0;
  i = (I )0;
  while (i < y->n) {
    j = i;
    n = (I )0;
    while (1) {
      if (i < y->n) {
        if (! (delim != (int )*(s + i))) {
          break;
        }
      } else {
        break;
      }
      i ++;
      n ++;
    }
    p0 = j;
    p1 = n;
    zn ++;
    if (i < y->n) {
      if (delim == (int )*(s + i)) {
        i ++;
      }
    }
  }
  if (y->n) {
    if (delim == (int )*(s + (y->n - 1LL))) {
      zn ++;
    }
  }
  if (! zn) {
    tmp___2 = newK((I )0, (I )0);
    return (tmp___2);
  } else
  if (1LL == zn) {
    if (y->n == p1) {
      tmp___3 = enlist(y);
      return (tmp___3);
    }
    tmp___4 = newK((I )-3, p1);
    z = tmp___4;
    tmp___5 = OOM_CD((I )0, z, (V )-1);
    if (! tmp___5) {
      return ((K )0);
    }
    memcpy((void * __restrict  )((C *)(z->k)), (void const   * __restrict  )(s + p0),
           (size_t )p1);
    y = enlist(z);
    cd(z);
    return (y);
  }
  j___0 = (I )0;
  tmp___6 = newK((I )0, zn);
  z___0 = tmp___6;
  tmp___7 = OOM_CD((I )0, z___0, (V )-1);
  if (! tmp___7) {
    return ((K )0);
  }
  i___0 = (I )0;
  _i___0 = zn;
  while (i___0 < _i___0) {
    p0 = j___0;
    p1 = (I )0;
    while (1) {
      if (j___0 < y->n) {
        if (! (delim != (int )*(s + j___0))) {
          break;
        }
      } else {
        break;
      }
      j___0 ++;
      p1 ++;
    }
    tmp___8 = newK((I )-3, p1);
    d___0 = tmp___8;
    tmp___9 = OOM_CD((I )0, d___0, z___0, (V )-1);
    if (! tmp___9) {
      return ((K )0);
    }
    memcpy((void * __restrict  )((C *)(d___0->k)), (void const   * __restrict  )(s + p0),
           (size_t )p1);
    z___0->k[i___0] = d___0;
    if (j___0 < y->n) {
      if (delim == (int )*(s + j___0)) {
        j___0 ++;
      }
    }
    i___0 ++;
  }
  return (z___0);
}
}
K overDyad(K a , V *p , K b___1 ) 
{ 
  V *o ;
  K (*f)(K  , K  ) ;
  K k ;
  I i ;
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;
  I tmp___2 ;
  K g ;
  K u ;
  K v ;
  K z ;
  K y ;
  K tmp___3 ;
  I tmp___4 ;
  K c ;
  K tmp___5 ;
  K d___0 ;
  I i___0 ;
  I _i___0 ;
  I tmp___6 ;
  I tmp___7 ;
  I tmp___8 ;
  I tmp___9 ;
  I i___1 ;
  I _i___1 ;

  {
  o = p - 1;
  k = (K )0;
  i = (I )0;
  if (a) {
    if ((unsigned long )*o == (unsigned long )offsetJoin) {
      if (! b___1->t) {
        if (! b___1->n) {
          if (0LL < a->t) {
            tmp = enlist(a);
            tmp___1 = tmp;
          } else {
            tmp___0 = ci(a);
            tmp___1 = tmp___0;
          }
          return (tmp___1);
        }
      }
    }
  }
  if (b___1->t == 0LL) {
    while (1) {
      if (i < b___1->n) {
        if (! (! (b___1->k[i])->t)) {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
  }
  if ((unsigned long )*o != (unsigned long )offsetJoin) {
    goto _L;
  } else
  if ((unsigned long )*o == (unsigned long )offsetJoin) {
    if (i == b___1->n) {
      _L: /* CIL Label */ 
      tmp___2 = VA(*o);
      if (tmp___2) {
        f = (K (*)(K  , K  ))DT[(L )*o].alt_funcs.verb_over;
        if (f) {
          k = (*f)(a, b___1);
        }
      }
    }
  }
  if (k) {
    return (k);
  }
  g = (K )0;
  u = (K )0;
  v = (K )0;
  z = (K )0;
  if (a) {
    u = enlist(a);
    v = join(u, b___1);
    tmp___3 = v;
  } else {
    tmp___3 = b___1;
  }
  y = tmp___3;
  if (y->t > 0LL) {
    z = ci(y);
    goto cleanup;
  }
  if ((unsigned long )*o == (unsigned long )((V )42)) {
    if (! a) {
      if (y->t == -1LL) {
        if (y->n == 0LL) {
          z = Ki((I )1);
          goto cleanup;
        }
      }
    }
  }
  if (y->n == 0LL) {
    tmp___4 = VA(*o);
    if (tmp___4) {
      z = kerr("length");
    }
    goto cleanup;
  }
  tmp___5 = first(y);
  c = tmp___5;
  if (0LL > y->t) {
    i___0 = (I )0;
    _i___0 = y->n - 1LL;
    while (i___0 < _i___0) {
      d___0 = c;
      if (! g) {
        if (y->t < 0LL) {
          tmp___6 = - y->t;
        } else {
          tmp___6 = y->t;
        }
        g = newK(tmp___6, (I )1);
      }
      tmp___7 = bp(y->t);
      tmp___8 = bp(y->t);
      memcpy((void * __restrict  )(g->k), (void const   * __restrict  )((V )(y->k) + (i___0 + 1LL) * tmp___8),
             (size_t )tmp___7);
      c = dv_ex(d___0, p - 1, g);
      tmp___9 = rc(g);
      if (2LL == tmp___9) {
        cd(g);
        g = (K )0;
      }
      cd(d___0);
      if (! c) {
        goto cleanup;
      }
      i___0 ++;
    }
  }
  if (0LL == y->t) {
    i___1 = (I )0;
    _i___1 = y->n - 1LL;
    while (i___1 < _i___1) {
      d___0 = c;
      c = dv_ex(d___0, p - 1, y->k[i___1 + 1LL]);
      cd(d___0);
      if (! c) {
        goto cleanup;
      }
      i___1 ++;
    }
  }
  z = c;
  cleanup: 
  if (g) {
    cd(g);
  }
  if (u) {
    cd(u);
  }
  if (v) {
    cd(v);
  }
  return (z);
}
}
static K scanDyad(K a , V *p , K b___1 ) 
{ 
  V *o ;
  K (*f)(K  , K  ) ;
  K k ;
  I tmp ;
  K tmp___0 ;
  K u ;
  K y ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  K z ;
  K tmp___4 ;
  K c ;
  K d___0 ;
  K g ;
  I i ;
  I _i___0 ;
  I tmp___5 ;
  I tmp___6 ;
  I tmp___7 ;
  I i___0 ;
  I _i___1 ;
  I tmp___8 ;
  I tmp___9 ;
  I tmp___10 ;
  K tmp___11 ;

  {
  o = p - 1;
  k = (K )0;
  tmp = VA(*o);
  if (tmp) {
    f = (K (*)(K  , K  ))DT[(L )*o].alt_funcs.verb_scan;
    if (f) {
      k = (*f)(a, b___1);
    }
  }
  if (k) {
    return (k);
  }
  if (! a) {
    if (! ((unsigned long )*o < (unsigned long )((V )DT_SIZE))) {
      if (! (7LL == (*((K *)*o))->t)) {
        if (3LL == (*((K *)*o))->t) {
          tmp___0 = csplit(*((K *)*o), b___1);
          return (tmp___0);
        }
      }
    }
  }
  u = (K )0;
  if (a) {
    u = enlist(a);
    tmp___1 = join(u, b___1);
    tmp___3 = tmp___1;
  } else {
    tmp___2 = ci(b___1);
    tmp___3 = tmp___2;
  }
  y = tmp___3;
  cd(u);
  if (y->t > 0LL) {
    return (y);
  } else
  if (y->n == 0LL) {
    return (y);
  }
  tmp___4 = newK((I )0, y->n);
  z = tmp___4;
  z->k[0] = first(y);
  if (0LL > y->t) {
    i = (I )0;
    _i___0 = y->n - 1LL;
    while (i < _i___0) {
      d___0 = z->k[i];
      if (y->t < 0LL) {
        tmp___5 = - y->t;
      } else {
        tmp___5 = y->t;
      }
      g = newK(tmp___5, (I )1);
      tmp___6 = bp(y->t);
      tmp___7 = bp(y->t);
      memcpy((void * __restrict  )(g->k), (void const   * __restrict  )((V )(y->k) + (i + 1LL) * tmp___7),
             (size_t )tmp___6);
      c = dv_ex(d___0, p - 1, g);
      cd(g);
      if (! c) {
        return ((K )0);
      }
      z->k[i + 1LL] = c;
      i ++;
    }
  }
  if (0LL == y->t) {
    i___0 = (I )0;
    _i___1 = y->n - 1LL;
    while (i___0 < _i___1) {
      d___0 = z->k[i___0];
      c = dv_ex(d___0, p - 1, y->k[i___0 + 1LL]);
      if (! c) {
        return ((K )0);
      }
      z->k[i___0 + 1LL] = c;
      i___0 ++;
    }
  }
  cd(y);
  if (a) {
    tmp___10 = atomI(b___1);
    if (tmp___10) {
      y = z;
      u = Ki((I )1);
      tmp___8 = OOM_CD((I )0, z, u, (V )-1);
      if (! tmp___8) {
        return ((K )0);
      }
      z = drop(u, z);
      tmp___9 = OOM_CD((I )0, y, u, z, (V )-1);
      if (! tmp___9) {
        return ((K )0);
      }
      cd(y);
      cd(u);
    }
  }
  tmp___11 = collapse(z);
  return (tmp___11);
}
}
static K overMonad(K a , V *p , K b___1 ) 
{ 
  K u ;
  K c ;
  I flag ;
  I useN ;
  I n ;
  I useB ;
  K tmp ;
  I f ;
  I i ;
  I _i___0 ;
  K tmp___0 ;
  I t ;
  K *aa ;
  K g ;
  K tmp___1 ;
  int tmp___2 ;
  K tmp___3 ;
  V *o ;
  I tmp___4 ;
  I tmp___5 ;
  I tmp___6 ;
  I tmp___7 ;
  I tmp___8 ;
  I tmp___9 ;
  I tmp___10 ;
  I tmp___11 ;
  K tmp___12 ;
  I tmp___13 ;
  I tmp___14 ;
  I tmp___15 ;
  I tmp___16 ;

  {
  u = b___1;
  c = (K )0;
  flag = (I )0;
  useN = (I )0;
  n = (I )0;
  useB = (I )0;
  fsf = (I )0;
  if (a) {
    if (1LL == a->t) {
      useN = (I )1;
      n = *((I *)(a->k));
    } else
    if (7LL == a->t) {
      useB = (I )1;
    } else
    if (6LL == a->t) {
      useB = (I )1;
    }
  }
  if (n < 0LL) {
    tmp = kerr("int");
    return (tmp);
  }
  if (useN) {
    f = (I )0;
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      c = dv_ex((K )0, p - 1, u);
      if ((unsigned long )b___1 != (unsigned long )u) {
        cd(u);
      }
      if (f) {
        if ((unsigned long )b___1 == (unsigned long )c) {
          cd(c);
        }
      }
      f = (I )1;
      u = c;
      if (! u) {
        return ((K )0);
      }
      i ++;
    }
    if (c) {
      c = c;
    } else {
      tmp___0 = ci(b___1);
      c = tmp___0;
    }
  } else
  if (useB) {
    while (1) {
      aa = & a;
      tmp___1 = dv_ex((K )0, (V *)((V )(& aa)), u);
      g = tmp___1;
      if (! g) {
        return ((K )0);
      }
      if (g->t == 1LL) {
        if (*((I *)(g->k))) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
      t = (I )tmp___2;
      cd(g);
      if (! t) {
        break;
      }
      c = dv_ex((K )0, p - 1, u);
      if ((unsigned long )b___1 != (unsigned long )u) {
        cd(u);
      }
      u = c;
      if (! u) {
        return ((K )0);
      }
    }
    if (c) {
      c = c;
    } else {
      tmp___3 = ci(b___1);
      c = tmp___3;
    }
  } else {
    o = p - 1;
    if ((unsigned long )*o == (unsigned long )((V )offsetOver)) {
      while (1) {
        tmp___4 = matchI(b___1, c);
        if (tmp___4) {
          flag = (I )1;
        } else
        if ((unsigned long )u != (unsigned long )b___1) {
          tmp___5 = matchI(u, c);
          if (tmp___5) {
            flag = (I )1;
          }
        }
        if ((unsigned long )u != (unsigned long )b___1) {
          cd(u);
        }
        if (flag) {
          break;
        }
        if (c) {
          u = c;
        } else {
          u = u;
        }
        c = dv_ex((K )0, p - 1, u);
        if (! c) {
          return ((K )0);
        }
        if (b___1->t < 0LL) {
          tmp___6 = - b___1->t;
        } else {
          tmp___6 = b___1->t;
        }
        if (1LL == tmp___6) {
          if (c->t < 0LL) {
            tmp___7 = - c->t;
          } else {
            tmp___7 = c->t;
          }
          if (3LL == tmp___7) {
            flag = (I )1;
          }
        }
      }
    } else
    if ((unsigned long )*o < (unsigned long )((V )DT_SIZE)) {
      goto _L;
    } else
    if (7LL == (*((K *)*o))->t) {
      if (3LL == (*((K *)*o))->n) {
        _L: /* CIL Label */ 
        while (1) {
          tmp___8 = matchI(b___1, c);
          if (tmp___8) {
            flag = (I )1;
          } else
          if ((unsigned long )u != (unsigned long )b___1) {
            tmp___9 = matchI(u, c);
            if (tmp___9) {
              flag = (I )1;
            }
          }
          if (flag) {
            break;
          }
          if ((unsigned long )u != (unsigned long )b___1) {
            cd(u);
          }
          if (c) {
            u = c;
          } else {
            u = u;
          }
          c = dv_ex((K )0, o, u);
          if (! c) {
            return ((K )0);
          }
          if (b___1->t < 0LL) {
            tmp___10 = - b___1->t;
          } else {
            tmp___10 = b___1->t;
          }
          if (1LL == tmp___10) {
            if (c->t < 0LL) {
              tmp___11 = - c->t;
            } else {
              tmp___11 = c->t;
            }
            if (3LL == tmp___11) {
              flag = (I )1;
            }
          }
        }
        cd(c);
        return (u);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      a = *((K *)*o);
      if (3LL == a->t) {
        tmp___12 = cjoin(a, b___1);
        return (tmp___12);
      }
      while (1) {
        tmp___13 = matchI(b___1, c);
        if (tmp___13) {
          flag = (I )1;
        } else
        if ((unsigned long )u != (unsigned long )b___1) {
          tmp___14 = matchI(u, c);
          if (tmp___14) {
            flag = (I )1;
          }
        }
        if ((unsigned long )u != (unsigned long )b___1) {
          cd(u);
        }
        if (flag) {
          break;
        }
        if (c) {
          u = c;
        } else {
          u = u;
        }
        c = dv_ex((K )0, o, u);
        if (! c) {
          return ((K )0);
        }
        if (b___1->t < 0LL) {
          tmp___15 = - b___1->t;
        } else {
          tmp___15 = b___1->t;
        }
        if (1LL == tmp___15) {
          if (c->t < 0LL) {
            tmp___16 = - c->t;
          } else {
            tmp___16 = c->t;
          }
          if (3LL == tmp___16) {
            flag = (I )1;
          }
        }
      }
    }
  }
  return (c);
}
}
static K scanMonad(K a , V *p , K b___1 ) 
{ 
  K u ;
  K tmp ;
  K v ;
  K w___0 ;
  K c ;
  K d___0 ;
  I flag ;
  I useN ;
  I n ;
  I useB ;
  K tmp___0 ;
  I i ;
  I _i___0 ;
  I t ;
  K *aa ;
  K g ;
  K tmp___1 ;
  int tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  K tmp___5 ;

  {
  tmp = enlist(b___1);
  u = tmp;
  c = (K )0;
  flag = (I )0;
  if (! u) {
    return ((K )0);
  }
  useN = (I )0;
  n = (I )0;
  useB = (I )0;
  if (a) {
    if (1LL == a->t) {
      useN = (I )1;
      n = *((I *)(a->k));
    } else
    if (7LL == a->t) {
      useB = (I )1;
    }
  }
  if (n < 0LL) {
    tmp___0 = kerr("int");
    return (tmp___0);
  }
  if (useN) {
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      d___0 = last(u);
      if (! d___0) {
        return ((K )0);
      }
      c = dv_ex((K )0, p - 1, d___0);
      cd(d___0);
      if (! c) {
        return ((K )0);
      }
      v = enlist(c);
      if (! v) {
        return ((K )0);
      }
      cd(c);
      w___0 = u;
      u = join(w___0, v);
      cd(w___0);
      cd(v);
      if (! u) {
        return ((K )0);
      }
      i ++;
    }
  } else
  if (useB) {
    while (1) {
      d___0 = last(u);
      if (! d___0) {
        return ((K )0);
      }
      aa = & a;
      tmp___1 = dv_ex((K )0, (V *)((V )(& aa)), d___0);
      g = tmp___1;
      if (! g) {
        return ((K )0);
      }
      if (1LL == g->t) {
        if (*((I *)(g->k))) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
      t = (I )tmp___2;
      cd(g);
      if (! t) {
        cd(d___0);
        break;
      }
      c = dv_ex((K )0, p - 1, d___0);
      cd(d___0);
      if (! c) {
        return ((K )0);
      }
      v = enlist(c);
      if (! v) {
        return ((K )0);
      }
      cd(c);
      w___0 = u;
      u = join(w___0, v);
      cd(w___0);
      cd(v);
      if (! u) {
        return ((K )0);
      }
    }
  } else {
    while (1) {
      d___0 = last(u);
      if (! d___0) {
        return ((K )0);
      }
      tmp___3 = matchI(b___1, c);
      if (tmp___3) {
        flag = (I )1;
      } else {
        tmp___4 = matchI(c, d___0);
        if (tmp___4) {
          flag = (I )1;
        }
      }
      if (! flag) {
        if (c) {
          w___0 = enlist(c);
          v = u;
          u = join(v, w___0);
          cd(v);
          cd(w___0);
          cd(d___0);
          d___0 = c;
        }
      }
      if (interrupted) {
        interrupted = (sig_atomic_t volatile   )0;
        tmp___5 = kerr("break");
        return (tmp___5);
      }
      if (flag) {
        cd(c);
        cd(d___0);
        break;
      }
      c = dv_ex((K )0, p - 1, d___0);
      cd(d___0);
      if (! c) {
        cd(u);
        return (c);
      }
    }
  }
  return (u);
}
}
static K each2(K a , V *p , K b___1 ) 
{ 
  I bt ;
  I bn ;
  K prnt0 ;
  K grnt0 ;
  K d___0 ;
  K z ;
  K tmp ;
  I i ;
  I _i___0 ;
  I tmp___0 ;
  K z___0 ;
  K tmp___1 ;
  K g ;
  I f ;
  int tmp___2 ;
  I i___0 ;
  I _i___1 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  I tmp___6 ;
  I tmp___7 ;
  I i___1 ;
  I _i___2 ;
  I tmp___8 ;

  {
  bt = b___1->t;
  bn = b___1->n;
  prnt0 = (K )0;
  grnt0 = (K )0;
  d___0 = (K )0;
  if (bt > 0LL) {
    if (a) {
      if (a->n > 0LL) {
        tmp = newK((I )0, a->n);
        z = tmp;
        if (! z) {
          return ((K )0);
        }
        i = (I )0;
        _i___0 = a->n;
        while (i < _i___0) {
          d___0 = dv_ex(a->k[i], p - 1, b___1);
          tmp___0 = OOM_CD((I )0, d___0, z, (V )-1);
          if (! tmp___0) {
            return ((K )0);
          }
          z->k[i] = d___0;
          i ++;
        }
        z = demote(z);
        if (z->t == 1LL) {
          z->t = (I )-1;
        }
        return (z);
      } else {
        d___0 = dv_ex(a, p - 1, b___1);
        return (d___0);
      }
    } else {
      d___0 = dv_ex(a, p - 1, b___1);
      return (d___0);
    }
  } else {
    tmp___1 = newK((I )0, bn);
    z___0 = tmp___1;
    if (! z___0) {
      return ((K )0);
    }
    if ((unsigned long )*p == (unsigned long )((V )offsetEach)) {
      if ((unsigned long )*(p - 1) == (unsigned long )((V )offsetEach)) {
        goto _L;
      } else
      if ((unsigned long )*(p - 1) == (unsigned long )((V )offsetOver)) {
        goto _L;
      } else
      if ((unsigned long )*(p - 1) == (unsigned long )((V )offsetScan)) {
        _L: /* CIL Label */ 
        if ((unsigned long )*(p - 2) < (unsigned long )((V )DT_SIZE)) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
    f = (I )tmp___2;
    if (0LL > bt) {
      i___0 = (I )0;
      _i___1 = bn;
      while (i___0 < _i___1) {
        if (bt < 0LL) {
          tmp___3 = - bt;
        } else {
          tmp___3 = bt;
        }
        g = newK(tmp___3, (I )1);
        tmp___4 = OOM_CD((I )0, g, z___0, (V )-1);
        if (! tmp___4) {
          return ((K )0);
        }
        tmp___5 = bp(bt);
        tmp___6 = bp(bt);
        memcpy((void * __restrict  )(g->k), (void const   * __restrict  )((V )(b___1->k) + i___0 * tmp___6),
               (size_t )tmp___5);
        if (f) {
          d___0 = dv_ex(a, p - 1, g);
        } else {
          d___0 = dv_ex((K )0, p - 1, g);
        }
        cd(g);
        tmp___7 = OOM_CD((I )0, d___0, z___0, (V )-1);
        if (! tmp___7) {
          return ((K )0);
        }
        z___0->k[i___0] = d___0;
        i___0 ++;
      }
    }
    if (0LL == bt) {
      if (prnt) {
        prnt0 = ci(prnt);
      }
      if (grnt) {
        grnt0 = ci(grnt);
      }
      i___1 = (I )0;
      _i___2 = bn;
      while (i___1 < _i___2) {
        if (f) {
          if (a) {
            if (a->n > 1LL) {
              d___0 = dv_ex(a->k[i___1], p - 1, b___1->k[i___1]);
            } else {
              d___0 = dv_ex(a, p - 1, b___1->k[i___1]);
            }
          } else {
            d___0 = dv_ex(a, p - 1, b___1->k[i___1]);
          }
        } else {
          if (prnt0) {
            cd(prnt);
            prnt = ci(prnt0);
          }
          if (grnt0) {
            cd(grnt);
            grnt = ci(grnt0);
          }
          d___0 = dv_ex((K )0, p - 1, b___1->k[i___1]);
        }
        if (! d___0) {
          goto _L___0;
        } else
        if (! z___0) {
          _L___0: /* CIL Label */ 
          if (prnt0) {
            cd(prnt0);
            prnt0 = (K )0;
          }
          if (grnt0) {
            cd(grnt0);
            grnt0 = (K )0;
          }
        }
        if (grnt) {
          if (! prnt) {
            prnt = ci(grnt);
          }
        }
        tmp___8 = OOM_CD((I )0, d___0, z___0, (V )-1);
        if (! tmp___8) {
          return ((K )0);
        }
        z___0->k[i___1] = d___0;
        i___1 ++;
      }
    }
    z___0 = demote(z___0);
    if (z___0->t == 1LL) {
      z___0->t = (I )-1;
    }
    if (prnt0) {
      cd(prnt0);
      prnt0 = (K )0;
    }
    if (grnt0) {
      cd(grnt0);
      grnt0 = (K )0;
    }
    return (z___0);
  }
}
}
static K eachright2(K a , V *p , K b___1 ) 
{ 
  K tmp ;
  I bt ;
  I bn ;
  K tmp___0 ;
  K z ;
  K tmp___1 ;
  K d___0 ;
  K g ;
  I i ;
  I _i___0 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I i___0 ;
  I _i___1 ;
  K tmp___5 ;

  {
  if (ft3) {
    if (! a) {
      tmp = kerr("valence");
      return (tmp);
    }
  }
  bt = b___1->t;
  bn = b___1->n;
  if (bt > 0LL) {
    tmp___0 = dv_ex(a, p - 1, b___1);
    return (tmp___0);
  }
  tmp___1 = newK((I )0, bn);
  z = tmp___1;
  if (0LL > bt) {
    i = (I )0;
    _i___0 = bn;
    while (i < _i___0) {
      if (bt < 0LL) {
        tmp___2 = - bt;
      } else {
        tmp___2 = bt;
      }
      g = newK(tmp___2, (I )1);
      tmp___3 = bp(bt);
      tmp___4 = bp(bt);
      memcpy((void * __restrict  )(g->k), (void const   * __restrict  )((V )(b___1->k) + i * tmp___4),
             (size_t )tmp___3);
      d___0 = dv_ex(a, p - 1, g);
      cd(g);
      if (! d___0) {
        return ((K )0);
      }
      z->k[i] = d___0;
      i ++;
    }
  }
  if (0LL == bt) {
    i___0 = (I )0;
    _i___1 = bn;
    while (i___0 < _i___1) {
      d___0 = dv_ex(a, p - 1, b___1->k[i___0]);
      if (! d___0) {
        return ((K )0);
      }
      z->k[i___0] = d___0;
      i___0 ++;
    }
  }
  tmp___5 = demote(z);
  return (tmp___5);
}
}
static K eachleft2(K a , V *p , K b___1 ) 
{ 
  K tmp ;
  I at___0 ;
  I an ;
  K tmp___0 ;
  K z ;
  K tmp___1 ;
  K d___0 ;
  K g ;
  I i ;
  I _i___0 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I i___0 ;
  I _i___1 ;
  K tmp___5 ;

  {
  if (! a) {
    tmp = kerr("valence");
    return (tmp);
  }
  at___0 = a->t;
  an = a->n;
  if (at___0 > 0LL) {
    tmp___0 = dv_ex(a, p - 1, b___1);
    return (tmp___0);
  }
  tmp___1 = newK((I )0, an);
  z = tmp___1;
  if (0LL > at___0) {
    i = (I )0;
    _i___0 = an;
    while (i < _i___0) {
      if (at___0 < 0LL) {
        tmp___2 = - at___0;
      } else {
        tmp___2 = at___0;
      }
      g = newK(tmp___2, (I )1);
      tmp___3 = bp(at___0);
      tmp___4 = bp(at___0);
      memcpy((void * __restrict  )(g->k), (void const   * __restrict  )((V )(a->k) + i * tmp___4),
             (size_t )tmp___3);
      d___0 = dv_ex(g, p - 1, b___1);
      cd(g);
      if (! d___0) {
        return ((K )0);
      }
      z->k[i] = d___0;
      i ++;
    }
  }
  if (0LL == at___0) {
    i___0 = (I )0;
    _i___1 = an;
    while (i___0 < _i___1) {
      d___0 = dv_ex(a->k[i___0], p - 1, b___1);
      if (! d___0) {
        return ((K )0);
      }
      z->k[i___0] = d___0;
      i___0 ++;
    }
  }
  tmp___5 = demote(z);
  return (tmp___5);
}
}
static K eachpair2(K a , V *p , K b___1 ) 
{ 
  V *o ;
  K (*f)(K  , K  ) ;
  K k ;
  I tmp ;
  I bt ;
  I bn ;
  K u ;
  K v ;
  I tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  K z ;
  K tmp___4 ;
  K d___0 ;
  K g ;
  K h ;
  I i ;
  I _i___0 ;
  I tmp___5 ;
  I tmp___6 ;
  I tmp___7 ;
  I tmp___8 ;
  I tmp___9 ;
  I tmp___10 ;
  I i___0 ;
  I _i___1 ;
  I tmp___11 ;
  I tmp___12 ;
  I tmp___13 ;
  I tmp___14 ;
  I tmp___15 ;
  I tmp___16 ;
  K tmp___17 ;
  K u___0 ;
  K v___0 ;
  I tmp___18 ;
  K u___1 ;

  {
  o = p - 1;
  k = (K )0;
  tmp = VA(*o);
  if (tmp) {
    f = (K (*)(K  , K  ))DT[(L )*o].alt_funcs.verb_eachpair;
    if (f) {
      k = (*f)(a, b___1);
    }
  }
  if (k) {
    return (k);
  }
  bt = b___1->t;
  bn = b___1->n;
  if (a) {
    if (bt > 0LL) {
      if (bn > 1LL) {
        u = enlist(a);
        tmp___0 = OOM_CD((I )0, u, b___1, (V )-1);
        if (! tmp___0) {
          return ((K )0);
        }
        v = join(u, b___1);
        cd(u);
        return (v);
      }
    }
  }
  if (bt <= 0LL) {
    if (bn == 0LL) {
      if (! a) {
        tmp___1 = kerr("length");
        return (tmp___1);
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (bn == 0LL) {
      if (a) {
        tmp___2 = newK((I )0, (I )0);
        return (tmp___2);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (bn < 2LL) {
      tmp___3 = newK((I )0, (I )0);
      return (tmp___3);
    }
  }
  tmp___4 = newK((I )0, bn - 1LL);
  z = tmp___4;
  d___0 = (K )0;
  if (! z) {
    return ((K )0);
  }
  if (bt < 0LL) {
    i = (I )0;
    _i___0 = bn - 1LL;
    while (i < _i___0) {
      if (bt < 0LL) {
        tmp___5 = - bt;
      } else {
        tmp___5 = bt;
      }
      h = newK(tmp___5, (I )1);
      if (bt < 0LL) {
        tmp___6 = - bt;
      } else {
        tmp___6 = bt;
      }
      g = newK(tmp___6, (I )1);
      tmp___7 = bp(bt);
      tmp___8 = bp(bt);
      memcpy((void * __restrict  )(h->k), (void const   * __restrict  )((V )(b___1->k) + i * tmp___8),
             (size_t )tmp___7);
      tmp___9 = bp(bt);
      tmp___10 = bp(bt);
      memcpy((void * __restrict  )(g->k), (void const   * __restrict  )((V )(b___1->k) + (i + 1LL) * tmp___10),
             (size_t )tmp___9);
      d___0 = dv_ex(g, p - 1, h);
      cd(g);
      cd(h);
      if (! d___0) {
        return ((K )0);
      }
      z->k[i] = d___0;
      i ++;
    }
  }
  if (bt == 0LL) {
    i___0 = (I )0;
    _i___1 = bn - 1LL;
    while (i___0 < _i___1) {
      d___0 = dv_ex(b___1->k[i___0 + 1LL], p - 1, b___1->k[i___0]);
      if (! d___0) {
        return ((K )0);
      }
      z->k[i___0] = d___0;
      i___0 ++;
    }
  }
  if (bt > 0LL) {
    if (! a) {
      if (bt < 0LL) {
        tmp___11 = - bt;
      } else {
        tmp___11 = bt;
      }
      h = newK(tmp___11, (I )1);
      if (bt < 0LL) {
        tmp___12 = - bt;
      } else {
        tmp___12 = bt;
      }
      g = newK(tmp___12, (I )1);
      tmp___13 = bp(bt);
      tmp___14 = bp(bt);
      memcpy((void * __restrict  )(h->k), (void const   * __restrict  )((V )(b___1->k) + 0LL),
             (size_t )tmp___13);
      tmp___15 = bp(bt);
      tmp___16 = bp(bt);
      memcpy((void * __restrict  )(g->k), (void const   * __restrict  )((V )(b___1->k) + 0LL),
             (size_t )tmp___15);
      d___0 = dv_ex(g, p - 1, h);
      cd(g);
      cd(h);
      cd(z);
      if (! d___0) {
        return ((K )0);
      }
      z->k[0] = d___0;
      return (d___0);
    }
  }
  z = demote(z);
  if (a) {
    if (bn == 1LL) {
      cd(z);
      tmp___17 = ci(a);
      return (tmp___17);
    }
    u___0 = enlist(a);
    tmp___18 = OOM_CD((I )0, u___0, z, (V )-1);
    if (! tmp___18) {
      return ((K )0);
    }
    v___0 = join(u___0, z);
    cd(u___0);
    cd(z);
    return (v___0);
  } else
  if (z->t == 1LL) {
    u___1 = enlist(z);
    cd(z);
    return (u___1);
  }
  return (z);
}
}
K dv_ex(K a , V *p , K b___1 ) 
{ 
  V *o ;
  I k ;
  K w___0 ;
  I tmp___1 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  V adverb ;
  K tmp___6 ;
  K tmp___7 ;
  K tmp___8 ;
  K tmp___9 ;
  I tmp___10 ;
  K z ;
  K tmp___11 ;
  K k___0 ;
  I tmp___12 ;
  I i ;
  I _i___0 ;
  I tmp___13 ;
  K tmp___14 ;
  K tmp___15 ;
  K tmp___16 ;
  K tmp___17 ;
  K tmp___18 ;
  K tmp___19 ;
  K tmp___20 ;
  K tmp___21 ;
  I gn ;
  V q[4] ;
  K u ;
  K tmp___22 ;
  K v ;
  K tmp___23 ;
  I tmp___24 ;
  K g ;
  K tmp___25 ;
  K tmp___26 ;
  I flag ;
  V *p1 ;
  K p2 ;
  K tmp___27 ;

  {
  if (! p) {
    return ((K )0);
  } else
  if (! *p) {
    return ((K )0);
  }
  if (! b___1) {
    return ((K )0);
  }
  o = p - 1;
  k = (I )0;
  if ((unsigned long )*p == (unsigned long )((V )offsetScan)) {
    if ((unsigned long )*o > (unsigned long )((V )DT_SIZE)) {
      w___0 = *((K *)*o);
      if (7LL == w___0->t) {
        if (3LL == ((K )*((V *)(w___0->k) + 2))->n) {
          if ((unsigned long )*((V *)(((K )*((V *)(w___0->k) + 2))->k) + 0) == (unsigned long )((V )22)) {
            if ((unsigned long )*((V *)(((K )*((V *)(w___0->k) + 2))->k) + 1) == (unsigned long )((V )offsetScan)) {
              k = (I )1;
            }
          }
        }
      }
    }
  }
  if (k == 0LL) {
    tmp___5 = adverbClass(*p);
    if (tmp___5) {
      tmp___3 = adverbClass(*o);
      if (tmp___3) {
        tmp___2 = (I )1;
      } else {
        tmp___1 = valence(*o);
        tmp___2 = tmp___1;
      }
      k = tmp___2;
    } else {
      tmp___4 = valence(*p);
      k = tmp___4;
    }
  }
  adverb = *p;
  if (k > 2LL) {
    k = (I )2;
  }
  if ((unsigned long )*p == (unsigned long )((V )offsetEach)) {
    if (k == 1LL) {
      if (a) {
        if (b___1) {
          if (a->t > 0LL) {
            if (a->t < 5LL) {
              if (b___1->t > 0LL) {
                if (b___1->t < 5LL) {
                  k = (I )2;
                } else {
                  goto _L___1;
                }
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
          if (a->t == -1LL) {
            if (b___1->t == -1LL) {
              k = (I )2;
            }
          }
        }
      }
    }
  }
  if (2LL == k) {
    goto _L___7;
  } else
  if (k == 0LL) {
    if ((UI )adverb == (UI )offsetScan) {
      if (0LL == (*((K *)*(p + -1)))->t) {
        goto _L___7;
      } else
      if (3LL == (*((K *)*(p + -1)))->t) {
        _L___7: /* CIL Label */ 
        if ((UI )adverb == (UI )offsetOver) {
          tmp___6 = overDyad(a, p, b___1);
          return (tmp___6);
        }
        if ((UI )adverb == (UI )offsetScan) {
          tmp___7 = scanDyad(a, p, b___1);
          return (tmp___7);
        }
        if ((UI )adverb == (UI )offsetEach) {
          if (! a) {
            adverb = (V )offsetEachright;
          } else
          if (a->t <= 0LL) {
            if (b___1->t <= 0LL) {
              if (a->n != b___1->n) {
                tmp___8 = kerr("length");
                return (tmp___8);
              } else {
                goto _L___4;
              }
            } else {
              goto _L___4;
            }
          } else
          _L___4: /* CIL Label */ 
          if (a->t > 0LL) {
            if (b___1->t > 0LL) {
              tmp___9 = dv_ex(a, p - 1, b___1);
              return (tmp___9);
            } else {
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
          if (a->t > 0LL) {
            adverb = (V )offsetEachright;
          } else
          if (b___1->t > 0LL) {
            adverb = (V )offsetEachleft;
          } else {
            a = promote(a);
            b___1 = promote(b___1);
            tmp___10 = OOM_CD((I )0, a, b___1, (V )-1);
            if (! tmp___10) {
              return ((K )0);
            }
            tmp___11 = newK((I )0, a->n);
            z = tmp___11;
            tmp___12 = OOM_CD((I )0, z, a, b___1, (V )-1);
            if (! tmp___12) {
              return ((K )0);
            }
            i = (I )0;
            _i___0 = a->n;
            while (i < _i___0) {
              k___0 = dv_ex(a->k[i], p - 1, b___1->k[i]);
              tmp___13 = OOM_CD((I )0, k___0, z, a, b___1, (V )-1);
              if (! tmp___13) {
                return ((K )0);
              }
              z->k[i] = k___0;
              i ++;
            }
            cd(a);
            cd(b___1);
            tmp___14 = demote(z);
            return (tmp___14);
          }
        }
      } else {
        goto _L___8;
      }
    } else {
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
  if (2LL > k) {
    if ((UI )adverb == (UI )offsetOver) {
      if (! fom) {
        tmp___15 = overMonad(a, p, b___1);
        return (tmp___15);
      } else {
        tmp___16 = overMonad(b___1->k[0], p, b___1->k[1]);
        return (tmp___16);
      }
    }
    if ((UI )adverb == (UI )offsetScan) {
      tmp___17 = scanMonad(a, p, b___1);
      return (tmp___17);
    }
    if ((UI )adverb == (UI )offsetEach) {
      tmp___18 = each2(a, p, b___1);
      return (tmp___18);
    }
  }
  if ((UI )adverb == (UI )offsetEachright) {
    tmp___19 = eachright2(a, p, b___1);
    return (tmp___19);
  }
  if ((UI )adverb == (UI )offsetEachleft) {
    tmp___20 = eachleft2(a, p, b___1);
    return (tmp___20);
  }
  if ((UI )adverb == (UI )offsetEachpair) {
    tmp___21 = eachpair2(a, p, b___1);
    return (tmp___21);
  }
  gn = (I )0;
  tmp___24 = valence(*p);
  if (tmp___24 >= 2LL) {
    if (a) {
      if (b___1) {
        gn = (I )2;
      } else {
        goto _L___10;
      }
    } else {
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
  if (a) {
    q[0] = (V )(& a);
    q[1] = (V )1;
    q[2] = (V )(& b___1);
    q[3] = (V )0;
    tmp___22 = ex0(& q[0], (K )0, (I )2);
    u = tmp___22;
    q[0] = *p;
    q[1] = (V )0;
    tmp___23 = ex0(& q[0], u, (I )1);
    v = tmp___23;
    cd(u);
    return (v);
  } else
  if (b___1) {
    gn = (I )1;
  }
  tmp___25 = newK((I )0, gn);
  g = tmp___25;
  if (! g) {
    return ((K )0);
  }
  if (gn > 1LL) {
    g->k[1] = b___1;
  }
  if (gn > 0LL) {
    if (a) {
      g->k[0] = a;
    } else {
      g->k[0] = b___1;
    }
  }
  flag = (I )0;
  if ((UI )*p > (UI )DT_SIZE) {
    if (b___1->n) {
      p1 = (V *)*p;
      if ((UI )*p1 > (UI )DT_SIZE) {
        p2 = (K )*p1;
        if (7LL != p2->t) {
          if (-1LL != p2->t) {
            if (5LL != p2->t) {
              flag = (I )1;
            }
          }
        }
      }
    }
  }
  if (flag) {
    tmp___26 = vf_ex(*p, b___1);
  } else {
    if ((double )stk > 2e6) {
      tmp___27 = kerr("stack");
      return (tmp___27);
    }
    stk ++;
    tmp___26 = vf_ex(*p, g);
    stk --;
    if (grnt) {
      if (! prnt) {
        prnt = ci(grnt);
      }
    }
  }
  memset((void *)(g->k), 0, (size_t )((unsigned long long )g->n * (unsigned long long )sizeof(K )));
  cd(g);
  return (tmp___26);
}
}
K vf_ex(V q , K g ) 
{ 
  K tc ;
  K tmp ;
  K z ;
  I gn ;
  I k ;
  I tmp___0 ;
  I n ;
  I j ;
  I ee ;
  K h ;
  K tmp___1 ;
  K tmp___2 ;
  V w___0[2] ;
  K tmp___3 ;
  I argc ;
  I i ;
  I _i___0 ;
  K a ;
  K b___1 ;
  K c ;
  K d___0 ;
  K (*tmp___4)(K a , K b , K c ) ;
  K (*tmp___5)(K a , K b , K c , K y ) ;
  K v ;
  K tmp___6 ;
  K kb ;
  K tmp___7 ;
  I tmp___8 ;
  K f ;
  I ft ;
  K tmp___9 ;
  I t ;
  K o ;
  K p ;
  K s ;
  K r ;
  I special ;
  int tmp___10 ;
  I ii ;
  V *u ;
  I tmp___11 ;
  I ae ;
  K *m ;
  K *q___0 ;
  I i___0 ;
  I _i___1 ;
  I tmp___12 ;
  V w___1[5] ;
  K zz ;
  K tmp___13 ;
  V v___0 ;
  K tree ;
  K m___0 ;
  K tmp___14 ;
  K *q___1 ;
  I i___1 ;
  I _i___2 ;
  I tmp___15 ;
  V *w___2 ;
  K a___0[7] ;
  I i___2 ;
  I _i___3 ;
  I tmp___16 ;
  I i___3 ;
  I _i___4 ;
  I tmp___17 ;
  I j___0 ;
  K *e ;
  K fw ;
  I i___4 ;
  I _i___5 ;
  struct k0 *tmp___18 ;
  I i___5 ;
  I _i___6 ;
  I j___1 ;
  I _j ;
  K tmp___19 ;
  K tmp___20 ;
  K tmp___21 ;
  K tmp___22 ;
  K j0___0 ;
  K tmp___23 ;
  K j1___0 ;
  K tmp___24 ;
  K j2 ;
  K tmp___25 ;
  K tmp___26 ;
  K tmp___27 ;
  I i___6 ;
  I _i___7 ;
  K tmp___28 ;
  I tmp___29 ;
  I t___0 ;
  K fc ;
  K tmp___30 ;
  I tt ;
  I ttt ;
  I i___7 ;
  int tmp___31 ;
  K tmp___32 ;
  I i___8 ;
  I _i___8 ;
  K tmp___33 ;
  I ff ;
  I i___9 ;
  I _i___9 ;
  int tmp___34 ;
  char *tmp___35 ;
  K d___1 ;
  K w___3 ;
  I i___10 ;
  I _i___10 ;
  int tmp___36 ;
  K p___0 ;
  K we ;
  K tmp___37 ;
  K j0___1 ;
  K tmp___38 ;
  K j2___0 ;
  K tmp___39 ;
  K tmp___40 ;
  I ff___0 ;
  I i___11 ;
  I _i___11 ;
  int tmp___41 ;
  char *tmp___42 ;
  K d___2 ;
  K y ;
  I i___12 ;
  I _i___12 ;
  int tmp___43 ;
  K tmp___44 ;
  K p___1 ;
  K ye ;
  K tmp___45 ;
  K j0___2 ;
  K tmp___46 ;
  K j2___1 ;
  K tmp___47 ;
  K tmp___48 ;
  I ff___1 ;
  I i___13 ;
  I _i___13 ;
  int tmp___49 ;
  char *tmp___50 ;
  K xx ;
  K tmp___51 ;
  S tmp___52 ;
  K x___0 ;
  K tmp___53 ;
  K tmp___54 ;
  K tmp___55 ;
  K p___2 ;
  K xe ;
  K tmp___56 ;
  K j0___3 ;
  K tmp___57 ;
  K j2___2 ;
  K tmp___58 ;
  K tmp___59 ;

  {
  tc = (K )0;
  if (interrupted) {
    interrupted = (sig_atomic_t volatile   )0;
    tmp = kerr("break");
    return (tmp);
  }
  if (! g) {
    return ((K )0);
  }
  z = (K )0;
  g = promote(g);
  if (! g) {
    return ((K )0);
  }
  gn = g->n;
  tmp___0 = sva(q);
  k = tmp___0;
  n = (I )-1;
  j = (I )0;
  if (! k) {
    if (! *((V *)q)) {
      cd(g);
      return ((K )0);
    }
  }
  n = valence(q);
  ee = (I )0;
  if ((unsigned long )q > (unsigned long )((V )DT_SIZE)) {
    h = *((K *)q);
    if (h->t == 7LL) {
      if (h->n == 1LL) {
        if (h->k[2]) {
          if ((UI )(h->k[2])->k[0] > (UI )DT_SIZE) {
            if ((h->k[2])->n == 3LL) {
              if ((*((K *)*((S *)((h->k[2])->k) + 0)))->t == 0LL) {
                z = dot(*((K *)*((S *)((h->k[2])->k) + 0)), g);
                goto cleanup;
              }
            }
            if ((UI )(h->k[2])->k[1] == 58ULL) {
              if (g->t == 0LL) {
                z = dot(*((K *)*((S *)((h->k[2])->k) + 0)), g->k[0]);
                goto cleanup;
              }
            }
          }
        }
        if ((unsigned long )((V )*((S *)((h->k[2])->k) + 0)) > (unsigned long )((V )DT_SIZE)) {
          if ((*((K *)*((S *)((h->k[2])->k) + 0)))->t == 7LL) {
            n = (I )2;
            ee = (I )1;
          }
        }
      }
      if (-4LL == (h->k[2])->t) {
        if (2LL == (h->k[2])->n) {
          if ((unsigned long )*((V *)((h->k[2])->k) + 0) == (unsigned long )((V )58)) {
            if (0LL == g->t) {
              if ((unsigned long )((void *)0) == (unsigned long )*((V *)(g->k) + 0)) {
                z = ci(*((K *)q));
                tmp___1 = ci(g);
                *((V *)(z->k) + 5) = (V )tmp___1;
                goto cleanup;
              }
              if (6LL == (g->k[0])->t) {
                z = ci(*((K *)q));
                tmp___2 = ci(z->k[4]);
                *((V *)(z->k) + 5) = (V )tmp___2;
                *(z->k[2] + 0) = *(z->k[2] + 1);
                ci(z->k[2]);
                goto cleanup;
              }
            }
          }
        }
      }
    }
  }
  if (ee) {
    if (! *((V *)(g->k) + 0)) {
      if (*((V *)(g->k) + 1)) {
        fom = (I )1;
      }
    }
  }
  if (k) {
    goto _L___3;
  } else
  if ((*((K *)q))->t == 7LL) {
    _L___3: /* CIL Label */ 
    if ((UI )q < (UI )DT_SIZE) {
      goto _L___2;
    } else
    if (*((V *)q)) {
      _L___2: /* CIL Label */ 
      if (gn > n) {
        if (! n) {
          if (1LL >= gn) {
            goto _L___1;
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (ee) {
    if (*((V *)(g->k) + 0)) {
      if (*((V *)(g->k) + 1)) {
        _L___0: /* CIL Label */ 
        if ((unsigned long )g->k[0] == (unsigned long )((void *)0)) {
          kerr("valence");
          goto cleanup;
        }
        if (3LL != (g->k[0])->t) {
          goto _L;
        } else
        if (1LL == (*((K *)q))->n) {
          goto _L;
        } else
        if ((unsigned long )g->k[1] == (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
          if (g->t == 0LL) {
            if (gn == 2LL) {
              if (((*((K *)q))->k[2])->t == -4LL) {
                if ((unsigned long )((V )*((S *)(((*((K *)q))->k[2])->k) + 0)) > (unsigned long )((V )DT_SIZE)) {
                  if ((*((K *)*((S *)(((*((K *)q))->k[2])->k) + 0)))->t == 7LL) {
                    w___0[0] = (V )*((S *)(((*((K *)q))->k[2])->k) + 0);
                    w___0[1] = (V )offsetOver;
                    z = overMonad(g->k[0], & w___0[1], g->k[1]);
                    goto cleanup;
                  } else {
                    kerr("valence");
                    goto cleanup;
                  }
                } else {
                  kerr("valence");
                  goto cleanup;
                }
              } else {
                kerr("valence");
                goto cleanup;
              }
            } else {
              kerr("valence");
              goto cleanup;
            }
          } else {
            kerr("valence");
            goto cleanup;
          }
        } else {
          tmp___3 = collapse(g);
          g = enlist(tmp___3);
          gn = g->n;
          cd(g->k[0]);
        }
      }
    }
  }
  argc = (I )0;
  i = (I )0;
  _i___0 = gn;
  while (i < _i___0) {
    if (g->k[i]) {
      argc ++;
    }
    i ++;
  }
  a = (K )0;
  b___1 = (K )0;
  c = (K )0;
  d___0 = (K )0;
  if (gn > 0LL) {
    a = g->k[0];
  }
  if (gn > 1LL) {
    b___1 = g->k[1];
  }
  if (gn > 2LL) {
    c = g->k[2];
  }
  if (gn > 3LL) {
    d___0 = g->k[3];
  }
  if (gn > 2LL) {
    if ((unsigned long )q == (unsigned long )offsetWhat) {
      goto _L___4;
    } else
    if ((unsigned long )q == (unsigned long )offsetSSR) {
      _L___4: /* CIL Label */ 
      if ((unsigned long )q == (unsigned long )offsetWhat) {
        tmp___4 = & what_triadic;
      } else {
        tmp___4 = & _ssr;
      }
      z = (*tmp___4)(a, b___1, c);
      goto cleanup;
    }
  }
  if (gn > 2LL) {
    if ((unsigned long )q == (unsigned long )offsetAt) {
      goto _L___5;
    } else
    if ((unsigned long )q == (unsigned long )offsetDot) {
      _L___5: /* CIL Label */ 
      if ((unsigned long )q == (unsigned long )offsetAt) {
        tmp___5 = & at_tetradic;
      } else {
        tmp___5 = & dot_tetradic;
      }
      z = (*tmp___5)(a, b___1, c, d___0);
      goto cleanup;
    }
  }
  if (2LL == k) {
    if (a) {
      if (b___1) {
        fnc = DT[(L )q].text;
        if (fnci < 127LL) {
          fncp[fnci] = q;
          fnci ++;
        }
        if (cls) {
          if (a->t == 6LL) {
            z = (*((K (*)(K  , K  ))DT[(L )q].func))(cls, b___1);
          } else {
            z = (*((K (*)(K  , K  ))DT[(L )q].func))(a, b___1);
          }
        } else {
          z = (*((K (*)(K  , K  ))DT[(L )q].func))(a, b___1);
        }
        goto cleanup;
      }
    }
  }
  if (2LL == k) {
    if (! a) {
      kerr("valence");
      goto cleanup;
    }
  }
  if (2LL == k) {
    goto _L___6;
  } else
  if ((unsigned long )q == (unsigned long )offsetSSR) {
    _L___6: /* CIL Label */ 
    if (! b___1) {
      tmp___6 = Kv();
      v = tmp___6;
      tmp___7 = newK((I )-4, (I )2);
      kb = tmp___7;
      tmp___8 = OOM_CD((I )0, v, kb, (V )-1);
      if (! tmp___8) {
        return ((K )0);
      }
      kb->k[0] = (struct k0 *)q;
      kb->k[1] = (struct k0 *)0;
      *((V *)(v->k) + 2) = (V )kb;
      z = vf_ex((V )(& v), g);
      cd(v);
      goto cleanup;
    }
  }
  if (1LL == k) {
    if (a) {
      z = (*((K (*)(K  ))DT[(L )q].func))(a);
      goto cleanup;
    }
  }
  if (1LL == k) {
    if (! a) {
      goto cleanup;
    }
  }
  f = (K )*((V *)q);
  ft = f->t;
  if (ft != 7LL) {
    if (g) {
      tmp___9 = dot(f, g);
      z = tmp___9;
    } else {
      z = f;
    }
    goto cleanup;
  }
  t = f->n;
  if (-1LL == n) {
    n = valence((V )f);
  }
  o = (K )*((V *)(f->k) + 2);
  p = (K )*((V *)(f->k) + 4);
  s = (K )*((V *)(f->k) + 3);
  r = (K )*((V *)(f->k) + 5);
  if (1LL == t) {
    if (! r) {
      if ((unsigned long )offsetAt == (unsigned long )*((V *)((S *)(((K )*((V *)(f->k) + 2))->k)))) {
        tmp___10 = 1;
      } else
      if ((unsigned long )offsetDot == (unsigned long )*((V *)((S *)(((K )*((V *)(f->k) + 2))->k)))) {
        tmp___10 = 1;
      } else
      if ((unsigned long )offsetWhat == (unsigned long )*((V *)((S *)(((K )*((V *)(f->k) + 2))->k)))) {
        tmp___10 = 1;
      } else {
        tmp___10 = 0;
      }
    } else {
      tmp___10 = 0;
    }
  } else {
    tmp___10 = 0;
  }
  special = (I )tmp___10;
  if (o->t != -3LL) {
    ii = o->n - 2LL;
    u = (V *)(o->k) + ii;
    if (2LL == n) {
      tmp___11 = adverbClass(*u);
      if (1LL == tmp___11) {
        n = gn;
      }
    }
  }
  if (((*((K *)q))->k[2])->n == 3LL) {
    if ((unsigned long )offsetWhat == (unsigned long )*((V *)(((*((K *)q))->k[2])->k) + 1)) {
      z = what(*((K *)*((V *)(((*((K *)q))->k[2])->k) + 0)), *((K *)((V *)(g->k))));
      goto cleanup;
    }
  }
  if (n) {
    if (argc < gn) {
      goto _L___8;
    } else
    if (gn < n) {
      if (! special) {
        goto _L___8;
      } else
      if (gn <= 1LL) {
        _L___8: /* CIL Label */ 
        z = kcloneI(f, "src/kx.c", 482);
        if (! z) {
          goto cleanup;
        }
        ae = (I )0;
        m = (K *)((V *)(z->k)) + 5;
        if (special) {
          if (gn != 4LL) {
            n = (I )2;
          }
        }
        if (3LL < (z->k[2])->n) {
          if ((unsigned long )((V *)(z->k[2])->k[1]) == (unsigned long )offsetAt) {
            if ((unsigned long )((V *)(z->k[2])->k[2]) == (unsigned long )((V )offsetEach)) {
              ae = (I )1;
              n = (I )1;
            }
          }
        }
        if (! *m) {
          *m = newK((I )0, n);
        }
        if (! *m) {
          cd(z);
          goto cleanup;
        }
        q___0 = (*m)->k;
        i___0 = (I )0;
        _i___1 = (*m)->n;
        while (i___0 < _i___1) {
          if (! *(q___0 + i___0)) {
            if (j < gn) {
              tmp___12 = j;
              j ++;
              *(q___0 + i___0) = ci(g->k[tmp___12]);
            }
          }
          i___0 ++;
        }
        if (ae) {
          w___1[0] = (V )*((S *)((z->k[2])->k) + 0);
          w___1[1] = offsetAt;
          w___1[2] = (V )offsetEach;
          w___1[3] = (V )((z->k[5])->k);
          w___1[4] = (V )0;
          tmp___13 = ex2(& w___1[0], (K )0);
          zz = tmp___13;
          cd(g);
          cd(z);
          return (zz);
        }
        goto cleanup;
      }
    }
  }
  switch (t) {
  case 1LL: 
  if (! r) {
    z = ex2((V *)((S *)(((K )*((V *)(f->k) + 2))->k)), g);
    goto cleanup;
  }
  tmp___14 = newK((I )0, r->n);
  m___0 = tmp___14;
  if (! m___0) {
    goto cleanup;
  }
  q___1 = m___0->k;
  i___1 = (I )0;
  _i___2 = m___0->n;
  while (i___1 < _i___2) {
    *(q___1 + i___1) = ci(r->k[i___1]);
    if (! *(q___1 + i___1)) {
      if (j < gn) {
        tmp___15 = j;
        j ++;
        *(q___1 + i___1) = ci(g->k[tmp___15]);
      }
    }
    i___1 ++;
  }
  if (prj) {
    w___2 = (V *)((S *)(((K )*((V *)(f->k) + 2))->k)) + 1;
    z = bv_ex(w___2, m___0);
  } else {
    z = ex2((V *)((S *)(((K )*((V *)(f->k) + 2))->k)), m___0);
  }
  cd(m___0);
  break;
  case 2LL: 
  v___0 = *((V *)((S *)(((K )*((V *)(f->k) + 2))->k)) + 1);
  i___2 = (I )0;
  _i___3 = (I )7;
  while (i___2 < _i___3) {
    a___0[i___2] = (K )0;
    i___2 ++;
  }
  if (r) {
    if (r->n < 7LL) {
      tmp___16 = r->n;
    } else {
      tmp___16 = (I )7;
    }
    memcpy((void * __restrict  )(a___0), (void const   * __restrict  )(r->k), (size_t )((unsigned long long )tmp___16 * (unsigned long long )sizeof(V )));
  }
  i___3 = (I )0;
  _i___4 = (I )7;
  while (i___3 < _i___4) {
    if (! a___0[i___3]) {
      if (j < gn) {
        tmp___17 = j;
        j ++;
        a___0[i___3] = g->k[tmp___17];
      }
    }
    i___3 ++;
  }
  switch (n) {
  case 0LL: 
  z = (*((K (*)())v___0))();
  break;
  case 1LL: 
  z = (*((K (*)(K  ))v___0))(a___0[0]);
  break;
  case 2LL: 
  z = (*((K (*)(K  , K  ))v___0))(a___0[0], a___0[1]);
  break;
  case 3LL: 
  z = (*((K (*)(K  , K  , K  ))v___0))(a___0[0], a___0[1], a___0[2]);
  break;
  case 4LL: 
  z = (*((K (*)(K  , K  , K  , K  ))v___0))(a___0[0], a___0[1], a___0[2], a___0[3]);
  break;
  case 5LL: 
  z = (*((K (*)(K  , K  , K  , K  , K  ))v___0))(a___0[0], a___0[1], a___0[2], a___0[3],
                                                 a___0[4]);
  break;
  case 6LL: 
  z = (*((K (*)(K  , K  , K  , K  , K  , K  ))v___0))(a___0[0], a___0[1], a___0[2],
                                                      a___0[3], a___0[4], a___0[5]);
  break;
  case 7LL: 
  z = (*((K (*)(K  , K  , K  , K  , K  , K  , K  ))v___0))(a___0[0], a___0[1], a___0[2],
                                                           a___0[3], a___0[4], a___0[5],
                                                           a___0[6]);
  break;
  }
  break;
  case 3LL: 
  if ((L )*((V *)(f->k) + 1) > 500LL) {
    kerr("stack");
    goto cleanup;
  }
  if ((double )stk > 2e6) {
    kerr("stack");
    goto cleanup;
  }
  stk ++;
  j___0 = (I )0;
  tree = (K )*((V *)(f->k) + 7);
  if (! tree) {
    tree = newK((I )5, p->n + s->n);
    if (! tree) {
      stk --;
      goto cleanup;
    }
    i___4 = (I )0;
    _i___5 = tree->n;
    while (i___4 < _i___5) {
      tmp___18 = newK((I )0, (I )3);
      tree->k[i___4] = tmp___18;
      if (! tmp___18) {
        cd(tree);
        stk --;
        goto cleanup;
      }
      i___4 ++;
    }
    i___5 = (I )0;
    _i___6 = tree->n;
    while (i___5 < _i___6) {
      j___1 = (I )0;
      _j = (I )3;
      while (j___1 < _j) {
        tmp___19 = DI(tree, i___5);
        if (i___5 < p->n) {
          tmp___20 = DI(p, i___5);
          tmp___22 = tmp___20;
        } else {
          tmp___21 = DI(s, i___5 - p->n);
          tmp___22 = tmp___21;
        }
        tmp___19->k[j___1] = ci(tmp___22->k[j___1]);
        j___1 ++;
      }
      i___5 ++;
    }
    *((V *)(f->k) + 7) = (V )tree;
  }
  if (fsf) {
    tmp___23 = dot_monadic((K )*((V *)(prnt->k) + 3));
    j0___0 = tmp___23;
    tmp___24 = dot_monadic((K )*((V *)(prnt->k) + 7));
    j1___0 = tmp___24;
    tmp___25 = ci(j0___0);
    tmp___26 = join(tmp___25, j1___0);
    j2 = tmp___26;
    cd(j0___0);
    cd((K )*((V *)(prnt->k) + 7));
    tmp___27 = dot_monadic(j2);
    *((V *)(prnt->k) + 7) = (V )tmp___27;
    cd(j0___0);
    cd(j1___0);
    cd(j2);
    tree = (K )*((V *)(prnt->k) + 7);
    cd((K )*((V *)(prnt->k) + 6));
    *((V *)(prnt->k) + 6) = (V )0;
  }
  i___6 = (I )0;
  _i___7 = p->n;
  while (i___6 < _i___7) {
    tmp___28 = DI(tree, i___6);
    e = EVP(tmp___28);
    cd(*e);
    *e = (K )0;
    if (r) {
      if (i___6 < r->n) {
        *e = ci(r->k[i___6]);
      }
    }
    if (! *e) {
      if (j___0 < g->n) {
        tmp___29 = j___0;
        j___0 ++;
        *e = ci(g->k[tmp___29]);
      }
    }
    i___6 ++;
  }
  fw = (K )*((V *)(f->k) + 6);
  t___0 = (I )0;
  if (! fw) {
    goto _L___9;
  } else {
    if ((UI )*((S *)((fw->k[2])->k) + 0) > (UI )DT_SIZE) {
      tmp___31 = 1;
    } else
    if ((UI )*((S *)((fw->k[2])->k) + 1) > (UI )DT_SIZE) {
      tmp___31 = 1;
    } else {
      tmp___31 = 0;
    }
    t___0 = (I )tmp___31;
    if (t___0) {
      _L___9: /* CIL Label */ 
      if (t___0) {
        cd((K )*((V *)(f->k) + 6));
      }
      tmp___30 = kcloneI(f, "src/kx.c", 539);
      fc = tmp___30;
      cd((K )*((V *)(fc->k) + 5));
      *((V *)(fc->k) + 5) = (V )0;
      (*((V *)(fc->k) + 1)) ++;
      tt = (I )0;
      ttt = (I )0;
      i___7 = (I )0;
      i___7 = (I )0;
      while (i___7 < o->n - 3LL) {
        if ((int )*((C *)(o->k) + i___7) == 123) {
          tt = (I )1;
          if ((int )*((C *)(o->k) + (i___7 + 1LL)) == 58) {
            ttt = (I )1;
            break;
          }
        }
        i___7 ++;
      }
      if (! ttt) {
        if (! grnt) {
          fw = wd_((C *)(o->k), (int )o->n, & tree, fc);
        } else
        if (tt) {
          fw = wd_((C *)(o->k), (int )o->n, & tree, fc);
        } else
        if ((int )*((C *)(o->k) + 0) == 91) {
          fw = wd_((C *)(o->k), (int )o->n, & tree, fc);
        } else {
          tc = kcloneI(tree, "src/kx.c", 547);
          fw = wd_((C *)(o->k), (int )o->n, & tc, fc);
        }
      } else {
        tc = kcloneI(tree, "src/kx.c", 547);
        fw = wd_((C *)(o->k), (int )o->n, & tc, fc);
      }
      *((V *)(f->k) + 6) = (V )fw;
      cd(fc);
    }
  }
  if ((double )stk1 > 1e3) {
    cd(g);
    kerr("stack");
    tmp___32 = _n();
    return (tmp___32);
  }
  ci(fw);
  stk1 ++;
  z = ex(fw);
  stk1 --;
  i___8 = (I )0;
  _i___8 = p->n;
  while (i___8 < _i___8) {
    tmp___33 = DI(tree, i___8);
    e = EVP(tmp___33);
    cd(*e);
    *e = (K )0;
    i___8 ++;
  }
  stk --;
  break;
  }
  if (encp == 2LL) {
    ff = (I )0;
    if (z) {
      if (z->t == 7LL) {
        if (z->n == 3LL) {
          if (*((V *)(z->k) + 2)) {
            tmp___35 = strchr((char const   *)((C *)((z->k[2])->k)), (int )*("z" + 0));
            if (tmp___35) {
              if (*((V *)(z->k) + 4)) {
                if ((z->k[4])->n) {
                  ff = (I )1;
                  i___9 = (I )0;
                  _i___9 = (z->k[4])->n;
                  while (i___9 < _i___9) {
                    tmp___34 = strcmp((char const   *)*((S *)((((z->k[4])->k[i___9])->k[0])->k)),
                                      "z");
                    if (! tmp___34) {
                      ff = (I )0;
                      break;
                    }
                    i___9 ++;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (ff) {
      d___1 = (KTREE->k[0])->k[1];
      w___3 = (K )0;
      i___10 = (I )0;
      _i___10 = d___1->n;
      while (i___10 < _i___10) {
        tmp___36 = strcmp((char const   *)*((S *)(((d___1->k[i___10])->k[0])->k)),
                          "z");
        if (! tmp___36) {
          w___3 = kcloneI(d___1->k[i___10], "src/kx.c", 559);
          break;
        }
        i___10 ++;
      }
      if (w___3) {
        p___0 = g->k[0];
        cd(w___3->k[1]);
        w___3->k[1] = kcloneI(p___0, "src/kx.c", 561);
        tmp___37 = enlist(w___3);
        we = tmp___37;
        tmp___38 = dot_monadic(z->k[7]);
        j0___1 = tmp___38;
        tmp___39 = ci(j0___1);
        tmp___40 = join(tmp___39, we);
        j2___0 = tmp___40;
        cd(j0___1);
        cd(z->k[7]);
        z->k[7] = dot_monadic(j2___0);
        cd(w___3);
        cd(we);
        cd(j0___1);
        cd(j2___0);
        encp = (I )3;
      }
    }
  }
  if (encp == 1LL) {
    ff___0 = (I )0;
    if (z) {
      if (z->t == 7LL) {
        if (z->n == 3LL) {
          if (*((V *)(z->k) + 2)) {
            tmp___42 = strchr((char const   *)((C *)((z->k[2])->k)), (int )*("y" + 0));
            if (tmp___42) {
              if (*((V *)(z->k) + 4)) {
                if ((z->k[4])->n) {
                  ff___0 = (I )1;
                  i___11 = (I )0;
                  _i___11 = (z->k[4])->n;
                  while (i___11 < _i___11) {
                    tmp___41 = strcmp((char const   *)*((S *)((((z->k[4])->k[i___11])->k[0])->k)),
                                      "y");
                    if (! tmp___41) {
                      ff___0 = (I )0;
                      break;
                    }
                    i___11 ++;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (ff___0) {
      d___2 = (KTREE->k[0])->k[1];
      y = (K )0;
      if (6LL != d___2->t) {
        if (5LL == d___2->t) {
          if (6LL == ((d___2->k[0])->k[1])->t) {
            tmp___44 = kerr("nyi");
            return (tmp___44);
          } else {
            goto _L___10;
          }
        } else {
          _L___10: /* CIL Label */ 
          i___12 = (I )0;
          _i___12 = d___2->n;
          while (i___12 < _i___12) {
            tmp___43 = strcmp((char const   *)*((S *)(((d___2->k[i___12])->k[0])->k)),
                              "y");
            if (! tmp___43) {
              y = kcloneI(d___2->k[i___12], "src/kx.c", 571);
              break;
            }
            i___12 ++;
          }
        }
      } else {
        tmp___44 = kerr("nyi");
        return (tmp___44);
      }
      if (y) {
        p___1 = g->k[0];
        cd(y->k[1]);
        y->k[1] = kcloneI(p___1, "src/kx.c", 574);
        tmp___45 = enlist(y);
        ye = tmp___45;
        tmp___46 = dot_monadic(z->k[7]);
        j0___2 = tmp___46;
        tmp___47 = ci(j0___2);
        tmp___48 = join(tmp___47, ye);
        j2___1 = tmp___48;
        cd(j0___2);
        cd(z->k[7]);
        z->k[7] = dot_monadic(j2___1);
        cd(y);
        cd(ye);
        cd(j0___2);
        cd(j2___1);
        encp = (I )2;
      }
    }
  }
  if (encp == 0LL) {
    ff___1 = (I )0;
    if (z) {
      if (z->t == 7LL) {
        if (z->n == 3LL) {
          if (*((V *)(z->k) + 2)) {
            tmp___50 = strchr((char const   *)((C *)((z->k[2])->k)), (int )*("x" + 0));
            if (tmp___50) {
              if (*((V *)(z->k) + 4)) {
                if ((z->k[4])->n) {
                  ff___1 = (I )1;
                  i___13 = (I )0;
                  _i___13 = (z->k[4])->n;
                  while (i___13 < _i___13) {
                    tmp___49 = strcmp((char const   *)*((S *)((((z->k[4])->k[i___13])->k[0])->k)),
                                      "x");
                    if (! tmp___49) {
                      ff___1 = (I )0;
                      break;
                    }
                    i___13 ++;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (ff___1) {
      tmp___51 = newK((I )4, (I )1);
      xx = tmp___51;
      tmp___52 = sp((S )"x");
      xx->k[0] = (struct k0 *)((V )tmp___52);
      tmp___53 = newK((I )0, (I )3);
      x___0 = tmp___53;
      x___0->k[0] = xx;
      tmp___54 = _n();
      x___0->k[1] = tmp___54;
      tmp___55 = _n();
      x___0->k[2] = tmp___55;
      p___2 = g->k[0];
      cd(x___0->k[1]);
      x___0->k[1] = kcloneI(p___2, "src/kx.c", 584);
      tmp___56 = enlist(x___0);
      xe = tmp___56;
      tmp___57 = dot_monadic(z->k[7]);
      j0___3 = tmp___57;
      tmp___58 = ci(j0___3);
      tmp___59 = join(tmp___58, xe);
      j2___2 = tmp___59;
      cd(j0___3);
      cd(z->k[7]);
      z->k[7] = dot_monadic(j2___2);
      cd(x___0);
      cd(xe);
      cd(j0___3);
      cd(j2___2);
      encp = (I )1;
    }
  }
  cleanup: 
  cd(g);
  cd(tc);
  return (z);
}
}
static V ex_(V a , I r ) 
{ 
  K x___0 ;
  K y ;
  K z ;
  K tmp ;
  I tmp___0 ;
  K tmp___1 ;
  V tmp___2 ;

  {
  y = (K )0;
  tmp___0 = VA(a);
  if (tmp___0) {
    return (a);
  }
  x___0 = *((K *)a);
  if (x___0) {
    if (7LL != x___0->t) {
      tmp___1 = ci(x___0);
      return ((V )tmp___1);
    } else
    if (0LL < x___0->n) {
      if (x___0->n < 4LL) {
        tmp___1 = ci(x___0);
        return ((V )tmp___1);
      }
    }
  } else {
    tmp___1 = ci(x___0);
    return ((V )tmp___1);
  }
  if (x___0->n < 4LL) {
    r = r;
  } else {
    r = x___0->n;
  }
  if (*((V *)(x___0->k) + 5)) {
    tmp = *((K *)((V *)(x___0->k) + 5));
    if (tmp) {
      if ((unsigned long )offsetColon == (unsigned long )*((V *)((S *)(((K )*((V *)(tmp->k) + 2))->k)))) {
        if ((UI )*((V *)((S *)(((K )*((V *)(tmp->k) + 2))->k)) + 1) > (UI )DT_SIZE) {
          fer = (I )1;
        }
      }
    }
    tmp___2 = ex_((V )((V *)(x___0->k) + 5), (I )2);
    y = (K )tmp___2;
    if (! y) {
      return ((V )0);
    }
    if (y->t == 0LL) {
      if (y->n == 0LL) {
        cd(y);
        y = _n();
      }
    }
    if (fer > 0LL) {
      if (! fCheck) {
        return ((V )y);
      }
    }
  }
  z = ex0((V *)((S *)(((K )*((V *)(x___0->k) + 2))->k)), y, r);
  cd(y);
  return ((V )z);
}
}
K ex(K a ) 
{ 
  I i ;
  I tmp ;
  I j ;
  I k ;
  K z ;
  V tmp___0 ;

  {
  if (! a) {
    return ((K )0);
  }
  if (a->t == 7LL) {
    if ((unsigned long )((K )*((V *)(a->k) + 2)) > (unsigned long )((K )DT_SIZE)) {
      if (7LL == ((K )*((V *)(a->k) + 2))->t) {
        if (6LL == ((K )*((V *)(a->k) + 2))->n) {
          fwh = (I )1;
        }
      }
    }
  }
  if (a->t == 7LL) {
    if ((unsigned long )prnt == (unsigned long )((K )0)) {
      if ((unsigned long )*((V *)((S *)(((K )*((V *)(a->k) + 2))->k)) + 1) == (unsigned long )offsetColon) {
        if ((unsigned long )*((V *)((S *)(((K )*((V *)(a->k) + 2))->k)) + 2) != (unsigned long )offset3m) {
          fam = (I )0;
        }
      }
      if (((K )*((V *)(a->k) + 2))->n > 3LL) {
        i = (I )3;
        while (*((V *)((S *)(((K )*((V *)(a->k) + 2))->k)) + i)) {
          tmp = i;
          i ++;
          if ((unsigned long )*((V *)((S *)(((K )*((V *)(a->k) + 2))->k)) + tmp) == (unsigned long )((V )1)) {
            fam = (I )1;
          }
          if ((unsigned long )*((V *)((S *)(((K )*((V *)(a->k) + 2))->k)) + (i - 1LL)) == (unsigned long )offsetColon) {
            if ((unsigned long )*((V *)((S *)(((K )*((V *)(a->k) + 2))->k)) + i) != (unsigned long )offset3m) {
              fam = (I )0;
            }
          }
        }
        if (! fCheck) {
          if (i > 2LL) {
            k = (I )0;
            j = i - 1LL;
            while (1) {
              if (j > 0LL) {
                if (! (k < 10LL)) {
                  break;
                }
              } else {
                break;
              }
              if ((unsigned long )*((V *)((S *)(((K )*((V *)(a->k) + 2))->k)) + j) < (unsigned long )((V )DT_SIZE)) {
                if ((unsigned long )*((V *)((S *)(((K )*((V *)(a->k) + 2))->k)) + j) > (unsigned long )((V )1)) {
                  cdp[k] = *(DT[(I )*((V *)((S *)(((K )*((V *)(a->k) + 2))->k)) + j)].text);
                  k ++;
                }
              }
              j --;
            }
          }
        }
      }
    }
  } else {
    fam = (I )1;
  }
  tmp___0 = ex_((V )(& a), (I )0);
  z = (K )tmp___0;
  cd(a);
  if (fer == 1LL) {
    fer1 = (I )0;
    fer = fer1;
  }
  fsf = (I )0;
  prj2 = fsf;
  prj = prj2;
  stk1 = prj;
  stk = stk1;
  fwh = stk;
  if (prnt) {
    cd(prnt);
  }
  prnt = (K )0;
  return (z);
}
}
static K ex0(V *v , K k , I r ) 
{ 
  I n ;
  I e ;
  I i ;
  I a ;
  I b___1 ;
  I tmp ;
  I tmp___0 ;
  K z ;
  K x___0 ;
  K tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  K tmp___7 ;
  I tmp___8 ;
  I tmp___9 ;
  K tmp___10 ;
  I tmp___11 ;
  K tmp___13 ;
  I tmp___14 ;
  I tmp___15 ;
  I tmp___16 ;
  K tmp___17 ;
  I i___0 ;
  K tmp___19 ;
  I tmp___20 ;
  K tmp___21 ;
  I tmp___22 ;
  I tmp___23 ;
  I j ;
  I _j ;
  K tmp___24 ;
  I tmp___25 ;
  I tmp___26 ;
  K tmp___28 ;
  K tmp___29 ;
  I tmp___30 ;
  I tmp___31 ;
  I j___0 ;
  I tmp___32 ;
  I i___1 ;
  I _i___0 ;
  K p ;
  I i___2 ;
  V *q ;
  K t ;
  I i___3 ;
  I _i___1 ;
  I tmp___33 ;
  I tmp___34 ;
  I tmp___35 ;

  {
  n = (I )0;
  e = (I )1;
  while (*(v + n)) {
    tmp = n;
    n ++;
    tmp___0 = bk(*(v + tmp));
    if (tmp___0) {
      e ++;
    }
  }
  b___1 = (I )(e > 1LL);
  z = (K )0;
  switch (r) {
  case 0LL: 
  i = (I )-1;
  while (i < n) {
    if (-1LL == i) {
      goto _L___0;
    } else {
      tmp___5 = bk(*(v + i));
      if (tmp___5) {
        _L___0: /* CIL Label */ 
        cd(z);
        frg ++;
        x___0 = ex1((v + 1) + i, (K )0, & i, n, (I )1);
        frg --;
        if (! frg) {
          encp = (I )0;
          if (encf) {
            cd(encf);
            encf = (K )0;
          }
          if (grnt) {
            cd(grnt);
            grnt = (K )0;
          }
        }
        if (! x___0) {
          return ((K )0);
        }
        tmp___3 = bk((V )x___0);
        if (tmp___3) {
          tmp___2 = _n();
          z = tmp___2;
        } else {
          z = x___0;
        }
        if (fer > 0LL) {
          if (! fCheck) {
            return (z);
          }
        }
        if (grnt) {
          if (! prnt) {
            goto _L;
          } else {
            tmp___4 = rc(prnt);
            if (tmp___4 == 2LL) {
              _L: /* CIL Label */ 
              if (prnt) {
                cd(prnt);
              }
              prnt = ci(grnt);
            }
          }
        }
      }
    }
    i ++;
  }
  break;
  case 4LL: 
  i = (I )-1;
  while (i < n) {
    if (-1LL == i) {
      goto _L___1;
    } else {
      tmp___16 = bk(*(v + i));
      if (tmp___16) {
        _L___1: /* CIL Label */ 
        x___0 = ex1((v + 1) + i, (K )0, & i, n, (I )1);
        if (! x___0) {
          return ((K )0);
        }
        if (fer > 0LL) {
          if (! fCheck) {
            return (x___0);
          }
        }
        tmp___8 = bk((V )x___0);
        if (tmp___8) {
          tmp___7 = _n();
          x___0 = tmp___7;
        } else {
          x___0 = x___0;
        }
        while (1) {
          i ++;
          if (i < n) {
            tmp___9 = bk(*(v + i));
            if (tmp___9) {
              break;
            }
          } else {
            break;
          }
        }
        if (i == n) {
          return (x___0);
        }
        z = delist(x___0);
        if (z->t < 0LL) {
          tmp___11 = - z->t;
        } else {
          tmp___11 = z->t;
        }
        if (tmp___11 != 1LL) {
          cd(z);
          tmp___10 = kerr("type");
          return (tmp___10);
        } else
        if (z->n != 1LL) {
          cd(z);
          tmp___10 = kerr("type");
          return (tmp___10);
        }
        a = *((I *)(z->k));
        cd(z);
        if (a) {
          x___0 = ex1((v + i) + 1, (K )0, & i, n, (I )1);
          tmp___14 = bk((V )x___0);
          if (tmp___14) {
            tmp___13 = _n();
            x___0 = tmp___13;
          } else {
            x___0 = x___0;
          }
          return (x___0);
        } else {
          while (1) {
            if (i < n) {
              tmp___15 = bk(*(v + i));
              if (tmp___15) {
                break;
              }
            } else {
              break;
            }
            i ++;
          }
        }
      }
    }
    i ++;
  }
  tmp___17 = _n();
  return (tmp___17);
  break;
  case 5LL: ;
  case 6LL: ;
  case 7LL: 
  while (1) {
    i___0 = (I )0;
    x___0 = ex1(v, (K )0, & i___0, (I )0, (I )1);
    if (! x___0) {
      return ((K )0);
    }
    if (fer > 0LL) {
      return (x___0);
    }
    tmp___20 = bk((V )x___0);
    if (tmp___20) {
      tmp___19 = _n();
      x___0 = tmp___19;
    } else {
      x___0 = x___0;
    }
    z = delist(x___0);
    if (z->t < 0LL) {
      tmp___22 = - z->t;
    } else {
      tmp___22 = z->t;
    }
    if (tmp___22 != 1LL) {
      cd(z);
      tmp___21 = kerr("type");
      return (tmp___21);
    } else
    if (z->n != 1LL) {
      cd(z);
      tmp___21 = kerr("type");
      return (tmp___21);
    }
    a = *((I *)(z->k));
    cd(z);
    i___0 = (I )0;
    if (b___1) {
      while (1) {
        i___0 ++;
        if (i___0 < n) {
          tmp___23 = bk(*(v + i___0));
          if (tmp___23) {
            break;
          }
        } else {
          break;
        }
      }
      if (i___0 >= n) {
        break;
      }
    }
    switch (r) {
    case 5LL: ;
    case 6LL: 
    if (a) {
      if (b___1) {
        x___0 = ex0((v + i___0) + 1, (K )0, (I )0);
        if (fer > 0LL) {
          return (x___0);
        }
        cd(x___0);
      }
    }
    break;
    case 7LL: 
    j = (I )0;
    _j = a;
    while (j < _j) {
      x___0 = ex0((v + i___0) + 1, (K )0, (I )0);
      if (fer > 0LL) {
        return (x___0);
      }
      cd(x___0);
      j ++;
    }
    break;
    }
    if (6LL == r) {
      if (! a) {
        break;
      }
    } else {
      break;
    }
  }
  tmp___24 = _n();
  return (tmp___24);
  break;
  default: 
  if (n) {
    tmp___25 = e;
  } else {
    tmp___25 = (I )0;
  }
  z = newK((I )0, tmp___25);
  if (n) {
    i = n - 1LL;
    while (i >= -1LL) {
      if (-1LL == i) {
        goto _L___3;
      } else {
        tmp___31 = bk(*(v + i));
        if (tmp___31) {
          _L___3: /* CIL Label */ 
          if ((unsigned long )offsetColon == (unsigned long )*(((v + 1) + i) + 0)) {
            if ((UI )*(((v + 1) + i) + 1) > (UI )DT_SIZE) {
              fer = (I )1;
            }
          }
          x___0 = ex1((v + 1) + i, (K )0, & i, n, (I )0);
          if (fer1) {
            cd(z);
            fer1 = (I )1;
            return (x___0);
          } else
          if (fer > 0LL) {
            if ((unsigned long )*(v + 0) == (unsigned long )offsetColon) {
              goto _L___2;
            } else
            if ((unsigned long )*(v + 2) == (unsigned long )((V )1)) {
              _L___2: /* CIL Label */ 
              if (! fCheck) {
                cd(z);
                fer1 = (I )1;
                return (x___0);
              }
            }
          }
          tmp___26 = OOM_CD((I )0, x___0, z, (V )-1);
          if (! tmp___26) {
            return ((K )0);
          }
          e --;
          tmp___30 = bk((V )x___0);
          if (tmp___30) {
            if (2LL == r) {
              tmp___29 = (K )0;
            } else {
              tmp___28 = _n();
              tmp___29 = tmp___28;
            }
            z->k[e] = tmp___29;
          } else {
            z->k[e] = x___0;
          }
        }
      }
      i --;
    }
  }
  }
  if (1LL == r) {
    z = collapse(z);
  } else
  if ((unsigned long )*(v + 0) == (unsigned long )((V )125)) {
    z = collapse(z);
  }
  if (k) {
    tmp___32 = valence((V )(& z));
    j___0 = tmp___32;
    if (! j___0) {
      if (0LL == k->t) {
        i___1 = (I )0;
        _i___0 = k->n;
        while (i___1 < _i___0) {
          if (! k->k[i___1]) {
            k->k[i___1] = _n();
          }
          i___1 ++;
        }
      }
    }
    if (z->t != 7LL) {
      goto _L___7;
    } else
    if (z->n != 1LL) {
      goto _L___7;
    } else
    if (j___0 < k->n) {
      if (0LL == j___0) {
        if (k->n == 1LL) {
          goto _L___6;
        } else {
          goto _L___7;
        }
      } else {
        _L___7: /* CIL Label */ 
        if (encf) {
          if ((UI )DT_SIZE < (UI )(& z)) {
            x___0 = vf_ex((V )(& encf), k);
          } else {
            x___0 = vf_ex((V )(& z), k);
          }
        } else {
          x___0 = vf_ex((V )(& z), k);
        }
        if (encp != 3LL) {
          cd(z);
        }
        z = x___0;
        return (z);
      }
    } else {
      _L___6: /* CIL Label */ 
      p = (K )*((V *)(z->k) + 2);
      i___2 = p->n - 2LL;
      q = (V *)(p->k) + i___2;
      t = (K )0;
      if (k->n == 1LL) {
        t = first(k);
      }
      if (k->n > 1LL) {
        goto _L___4;
      } else
      if (t) {
        if (t->n == 1LL) {
          _L___4: /* CIL Label */ 
          tmp___33 = sva(*q);
          if (! tmp___33) {
            tmp___34 = adverbClass(*q);
            if (tmp___34) {
              if (k->n == 1LL) {
                if (! prj2) {
                  k->n = (I )2;
                }
              }
              prj2 = (I )1;
              i___3 = (I )0;
              _i___1 = k->n;
              while (i___3 < _i___1) {
                if (! k->k[i___3]) {
                  prj = (I )1;
                }
                i___3 ++;
              }
              if (! prj) {
                x___0 = bv_ex(q, k);
                cd(z);
                return (x___0);
              }
            }
          }
        }
      }
      cd(t);
      if (z->t == 7LL) {
        if (z->n == 1LL) {
          if ((unsigned long )(z->k[2])->k[0] == (unsigned long )offsetSSR) {
            if (k->t == 0LL) {
              if (k->n == 3LL) {
                if ((k->k[2])->t < 0LL) {
                  tmp___35 = - (k->k[2])->t;
                } else {
                  tmp___35 = (k->k[2])->t;
                }
                if (tmp___35 == -3LL) {
                  k->k[2] = enlist(k->k[2]);
                  cd(x___0);
                }
              }
            }
          }
        }
      }
      x___0 = vf_ex((V )(& z), k);
      cd(z);
      z = x___0;
    }
  }
  return (z);
}
}
static K bv_ex(V *p , K k ) 
{ 
  V q ;
  K x___0 ;
  I n ;
  K tmp ;
  K tmp___0 ;
  I tmp___1 ;
  I tmp___2 ;
  I i ;
  I _i___0 ;
  K tmp___3 ;
  K tmp___4 ;
  I tmp___5 ;
  K z ;
  K tmp___6 ;
  K g ;
  K tmp___7 ;
  I tmp___8 ;
  I i___0 ;
  I _i___1 ;
  I j ;
  I _j ;
  I tmp___9 ;
  I tmp___10 ;
  I j___0 ;
  I _j___0 ;
  I i___1 ;
  I _i___2 ;
  K tmp___11 ;
  K tmp___12 ;
  I tmp___13 ;
  K tmp___14 ;
  K z___0 ;
  K tmp___15 ;
  K g___0 ;
  K tmp___16 ;
  I tmp___17 ;
  I i___2 ;
  I _i___3 ;
  I j___1 ;
  I _j___1 ;
  I tmp___18 ;
  I tmp___19 ;
  I j___2 ;
  I _j___2 ;
  I i___3 ;
  I _i___4 ;
  K tmp___20 ;
  K tmp___21 ;
  I tmp___22 ;
  I c ;
  K z___1 ;
  K tmp___23 ;
  K g___1 ;
  K tmp___24 ;
  I tmp___25 ;
  I i___4 ;
  I _i___5 ;
  K x___1 ;
  I j___3 ;
  I _j___3 ;
  I tmp___26 ;
  I tmp___27 ;
  I j___4 ;
  I _j___4 ;
  K tmp___28 ;
  K a ;
  K b___1 ;
  K tmp___29 ;
  K tmp___30 ;
  K a___0 ;
  K b___2 ;
  K tmp___31 ;
  K tmp___32 ;
  K a___1 ;
  K b___3 ;
  K tmp___33 ;
  K tmp___34 ;

  {
  q = *p;
  n = (I )0;
  tmp___1 = adverbClass(*p);
  if (! tmp___1) {
    tmp___2 = valence(*p);
    if (tmp___2 < 3LL) {
      if (k->n < 2LL) {
        tmp = kerr("valence");
        return (tmp);
      }
      tmp___0 = dv_ex(k->k[0], p, k->k[1]);
      return (tmp___0);
    }
  }
  if (offsetOver == (L )q) {
    i = (I )0;
    _i___0 = k->n - 1LL;
    while (i < _i___0) {
      x___0 = k->k[i + 1LL];
      if (! x___0->n) {
        tmp___3 = ci(k->k[0]);
        return (tmp___3);
      }
      tmp___5 = atomI(x___0);
      if (! tmp___5) {
        if (n) {
          if (n != x___0->n) {
            tmp___4 = kerr("length");
            return (tmp___4);
          } else {
            n = x___0->n;
          }
        } else {
          n = x___0->n;
        }
      }
      i ++;
    }
    if (1LL > n) {
      n = (I )1;
    } else {
      n = n;
    }
    tmp___6 = ci(k->k[0]);
    z = tmp___6;
    tmp___7 = newK((I )0, k->n);
    g = tmp___7;
    tmp___8 = OOM_CD((I )0, z, g, (V )-1);
    if (! tmp___8) {
      return ((K )0);
    }
    i___0 = (I )0;
    _i___1 = n;
    while (i___0 < _i___1) {
      g->k[0] = z;
      j = (I )0;
      _j = g->n - 1LL;
      while (j < _j) {
        x___0 = itemAtIndex(k->k[j + 1LL], i___0);
        tmp___9 = OOM_CD((I )0, x___0, g, (V )-1);
        if (! tmp___9) {
          return ((K )0);
        }
        g->k[j + 1LL] = x___0;
        j ++;
      }
      x___0 = bv_ex(p - 1, g);
      tmp___10 = OOM_CD((I )0, x___0, g, (V )-1);
      if (! tmp___10) {
        return ((K )0);
      }
      j___0 = (I )0;
      _j___0 = g->n;
      while (j___0 < _j___0) {
        cd(g->k[j___0]);
        g->k[j___0] = (struct k0 *)0;
        j___0 ++;
      }
      z = x___0;
      i___0 ++;
    }
    cd(g);
    return (z);
  }
  if (offsetScan == (L )q) {
    i___1 = (I )0;
    _i___2 = k->n - 1LL;
    while (i___1 < _i___2) {
      x___0 = k->k[i___1 + 1LL];
      if (! x___0) {
        goto __Cont;
      }
      if (! x___0->n) {
        tmp___11 = ci(k->k[0]);
        return (tmp___11);
      }
      tmp___13 = atomI(x___0);
      if (! tmp___13) {
        if (n) {
          if (n != x___0->n) {
            tmp___12 = kerr("length");
            return (tmp___12);
          } else {
            n = x___0->n;
          }
        } else {
          n = x___0->n;
        }
      }
      __Cont: /* CIL Label */ 
      i___1 ++;
    }
    if (! n) {
      tmp___14 = bv_ex(p - 1, k);
      return (tmp___14);
    }
    if (1LL > n) {
      n = (I )1;
    } else {
      n = n;
    }
    tmp___15 = newK((I )0, (I )1);
    z___0 = tmp___15;
    tmp___16 = newK((I )0, k->n);
    g___0 = tmp___16;
    tmp___17 = OOM_CD((I )0, z___0, g___0, (V )-1);
    if (! tmp___17) {
      return ((K )0);
    }
    z___0->k[0] = ci(k->k[0]);
    i___2 = (I )0;
    _i___3 = n;
    while (i___2 < _i___3) {
      g___0->k[0] = ci(z___0->k[z___0->n - 1LL]);
      j___1 = (I )0;
      _j___1 = g___0->n - 1LL;
      while (j___1 < _j___1) {
        x___0 = itemAtIndex(k->k[j___1 + 1LL], i___2);
        tmp___18 = OOM_CD((I )0, x___0, z___0, g___0, (V )-1);
        if (! tmp___18) {
          return ((K )0);
        }
        g___0->k[j___1 + 1LL] = x___0;
        j___1 ++;
      }
      x___0 = bv_ex(p - 1, g___0);
      tmp___19 = OOM_CD((I )0, x___0, z___0, g___0, (V )-1);
      if (! tmp___19) {
        return ((K )0);
      }
      j___2 = (I )0;
      _j___2 = g___0->n;
      while (j___2 < _j___2) {
        cd(g___0->k[j___2]);
        g___0->k[j___2] = (struct k0 *)0;
        j___2 ++;
      }
      kap(& z___0, (V )(& x___0));
      cd(x___0);
      i___2 ++;
    }
    cd(g___0);
    z___0 = collapse(z___0);
    return (z___0);
  }
  if (offsetEach == (L )q) {
    i___3 = (I )0;
    _i___4 = k->n;
    while (i___3 < _i___4) {
      x___0 = k->k[i___3];
      if (! x___0) {
        goto __Cont___0;
      }
      if (! x___0->n) {
        tmp___20 = newK((I )0, (I )0);
        return (tmp___20);
      }
      tmp___22 = atomI(x___0);
      if (! tmp___22) {
        if (n) {
          if (n != x___0->n) {
            tmp___21 = kerr("length");
            return (tmp___21);
          } else {
            n = x___0->n;
          }
        } else {
          n = x___0->n;
        }
      }
      __Cont___0: /* CIL Label */ 
      i___3 ++;
    }
    c = (I )(! n);
    if (1LL > n) {
      n = (I )1;
    } else {
      n = n;
    }
    tmp___23 = newK((I )0, n);
    z___1 = tmp___23;
    tmp___24 = newK((I )0, k->n);
    g___1 = tmp___24;
    tmp___25 = OOM_CD((I )0, g___1, z___1, (V )-1);
    if (! tmp___25) {
      return ((K )0);
    }
    i___4 = (I )0;
    _i___5 = n;
    while (i___4 < _i___5) {
      j___3 = (I )0;
      _j___3 = k->n;
      while (j___3 < _j___3) {
        x___1 = itemAtIndex(k->k[j___3], i___4);
        tmp___26 = OOM_CD((I )0, x___1, g___1, z___1, (V )-1);
        if (! tmp___26) {
          return ((K )0);
        }
        g___1->k[j___3] = x___1;
        j___3 ++;
      }
      x___1 = bv_ex(p - 1, g___1);
      tmp___27 = OOM_CD((I )0, x___1, z___1, g___1, (V )-1);
      if (! tmp___27) {
        return ((K )0);
      }
      z___1->k[i___4] = x___1;
      j___4 = (I )0;
      _j___4 = k->n;
      while (j___4 < _j___4) {
        cd(g___1->k[j___4]);
        g___1->k[j___4] = (struct k0 *)0;
        j___4 ++;
      }
      i___4 ++;
    }
    cd(g___1);
    if (c) {
      z___1 = collapse(z___1);
    } else {
      z___1 = demote(z___1);
    }
    return (z___1);
  }
  if (offsetEachright == (L )q) {
    if (k->n != 2LL) {
      tmp___28 = kerr("valence");
      return (tmp___28);
    }
    a = k->k[0];
    b___1 = k->k[1];
    tmp___29 = eachright2(a, p, b___1);
    return (tmp___29);
  }
  if (offsetEachleft == (L )q) {
    if (k->n != 2LL) {
      tmp___30 = kerr("valence");
      return (tmp___30);
    }
    a___0 = k->k[0];
    b___2 = k->k[1];
    tmp___31 = eachleft2(a___0, p, b___2);
    return (tmp___31);
  }
  if (offsetEachpair == (L )q) {
    if (k->n != 2LL) {
      tmp___32 = kerr("valence");
      return (tmp___32);
    }
    a___1 = k->k[0];
    b___3 = k->k[1];
    tmp___33 = eachpair2(a___1, p, b___3);
    return (tmp___33);
  }
  tmp___34 = vf_ex(*p, k);
  return (tmp___34);
}
}
K ex1(V *w___0 , K k , I *i , I n , I f ) 
{ 
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;
  int tmp___2 ;
  K tmp___3 ;
  int tmp___4 ;
  K tmp___5 ;
  int tmp___6 ;
  K tmp___7 ;
  K tmp___8 ;
  I tmp___9 ;
  K tmp___10 ;
  I c ;
  I tmp___11 ;
  K tmp___12 ;
  I tmp___13 ;
  I d___0 ;
  I tmp___14 ;
  K a ;
  K tmp___15 ;
  K kb ;
  K tmp___16 ;
  I tmp___17 ;
  V *b___1 ;
  I i___0 ;
  I _i___0 ;
  V x___0 ;
  V tmp___18 ;
  K a___0 ;
  K tmp___19 ;
  K kb___0 ;
  K tmp___20 ;
  I tmp___21 ;
  V *b___2 ;
  I i___1 ;
  I _i___1 ;
  I j ;
  I tmp___22 ;
  K r ;
  V tmp___23 ;
  V q ;
  K tmp___24 ;
  K *tmp___25 ;
  K z ;
  K tmp___26 ;
  I tmp___27 ;

  {
  if ((unsigned long )offsetColon == (unsigned long )*(w___0 + 0)) {
    if ((UI )*(w___0 + 1) > (UI )DT_SIZE) {
      if ((UI )*(w___0 + 2) > (UI )DT_SIZE) {
        if (fwh == 0LL) {
          fer = (I )1;
          if (f) {
            *i = n;
          } else {
            *i = (I )-1;
          }
          tmp = *((K *)*(w___0 + 1));
          tmp___0 = ci(tmp);
          return (tmp___0);
        }
      }
    }
  }
  if (DT_ADVERB_OFFSET <= (L )*w___0) {
    if ((L )*w___0 < DT_VERB_OFFSET) {
      if (offsetScan != (L )*(w___0 + 1)) {
        if ((unsigned long )((void *)0) != (unsigned long )*(w___0 + 1)) {
          if (offsetScan == (L )*w___0) {
            tmp___2 = strcmp((char const   *)fBreak, "n");
            if (0 == tmp___2) {
              tmp___1 = ex2(w___0 + 1, k);
              return (tmp___1);
            }
            tmp___4 = strcmp((char const   *)fBreak, "t");
            if (0 == tmp___4) {
              tmp___3 = ex2(w___0 + 1, k);
              return (tmp___3);
            }
            tmp___6 = strcmp((char const   *)fBreak, "s");
            if (0 == tmp___6) {
              fer = (I )1;
              tmp___5 = ex2(w___0 + 1, k);
              return (tmp___5);
            }
          } else
          if ((unsigned long )((V )offsetEach) == (unsigned long )*w___0) {
            if ((*((K *)*(w___0 + 1)))->t < 0LL) {
              tmp___9 = - (*((K *)*(w___0 + 1)))->t;
            } else {
              tmp___9 = (*((K *)*(w___0 + 1)))->t;
            }
            if (3LL == tmp___9) {
              tmp___7 = ci(*((K *)*(w___0 + 1)));
              return (tmp___7);
            } else {
              tmp___8 = _n();
              return (tmp___8);
            }
          } else {
            tmp___10 = kerr("nyi");
            return (tmp___10);
          }
        }
      }
    }
  }
  c = (I )0;
  while (1) {
    if (*(w___0 + c)) {
      tmp___11 = bk(*(w___0 + c));
      if (tmp___11) {
        break;
      }
    } else {
      break;
    }
    c ++;
    if ((unsigned long )offsetColon == (unsigned long )*(w___0 + (c - 1LL))) {
      break;
    }
  }
  if (! c) {
    tmp___12 = ex2(w___0, k);
    return (tmp___12);
  } else {
    tmp___13 = VA(*(w___0 + (c - 1LL)));
    if (tmp___13) {
      if (c > 1LL) {
        if ((unsigned long )offsetColon == (unsigned long )*(w___0 + (c - 1LL))) {
          tmp___12 = ex2(w___0, k);
          return (tmp___12);
        }
      }
    } else {
      tmp___12 = ex2(w___0, k);
      return (tmp___12);
    }
  }
  if ((unsigned long )*(w___0 + 0) == (unsigned long )offsetColon) {
    if ((UI )*(w___0 + 1) > (UI )DT_SIZE) {
      d___0 = (I )0;
      while (1) {
        if (*(w___0 + d___0)) {
          tmp___14 = bk(*(w___0 + d___0));
          if (tmp___14) {
            break;
          }
        } else {
          break;
        }
        d___0 ++;
      }
      tmp___15 = Kv();
      a = tmp___15;
      a->n = (I )0;
      tmp___16 = newK((I )-4, d___0);
      kb = tmp___16;
      tmp___17 = OOM_CD((I )0, a, kb, (V )-1);
      if (! tmp___17) {
        return ((K )0);
      }
      b___1 = (V *)(kb->k);
      i___0 = (I )0;
      _i___0 = d___0 - 1LL;
      while (i___0 < _i___0) {
        *(b___1 + i___0) = *(w___0 + (i___0 + 1LL));
        i___0 ++;
      }
      *(b___1 + (d___0 - 1LL)) = (V )0;
      *((V *)(a->k) + 2) = (V )kb;
      tmp___18 = ex_((V )(& a), (I )0);
      x___0 = tmp___18;
      cd(a);
      if ((unsigned long )*(w___0 + -1) != (unsigned long )offsetColon) {
        fer = (I )1;
      }
      return ((K )x___0);
    }
  }
  tmp___19 = Kv();
  a___0 = tmp___19;
  tmp___20 = newK((I )-4, 1LL + c);
  kb___0 = tmp___20;
  tmp___21 = OOM_CD((I )0, a___0, kb___0, (V )-1);
  if (! tmp___21) {
    return ((K )0);
  }
  b___2 = (V *)(kb___0->k);
  *(b___2 + c) = (V )0;
  i___1 = (I )0;
  _i___1 = c;
  while (i___1 < _i___1) {
    j = (c - i___1) - 1LL;
    *(b___2 + j) = *(w___0 + j);
    tmp___22 = VA(*(b___2 + j));
    if (tmp___22) {
      goto __Cont;
    }
    tmp___23 = ex_(*(w___0 + j), (I )1);
    r = (K )tmp___23;
    tmp___24 = newE(LS, r);
    q = (V )tmp___24;
    kap((K *)((V *)(a___0->k)) + 3, (V )(& q));
    cd((K )q);
    tmp___25 = EVP((K )q);
    q = (V )tmp___25;
    *(b___2 + j) = q;
    __Cont: /* CIL Label */ 
    i___1 ++;
  }
  *((V *)(a___0->k) + 2) = (V )kb___0;
  if (fll > 0LL) {
    if (2LL == kb___0->n) {
      tmp___27 = kdefClass((I )*((V *)(kb___0->k) + 0));
      if (tmp___27) {
        tmp___26 = kdef((I )*((V *)(kb___0->k) + 0));
        z = tmp___26;
        cd(a___0);
        return (z);
      }
    }
  }
  return (a___0);
}
}
static K ex2(V *v , K k ) 
{ 
  K t0___0 ;
  K t2 ;
  K t3 ;
  K e ;
  K u ;
  I i ;
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  I tmp___3 ;
  K z ;
  V tmp___4 ;
  K j0___0 ;
  K tmp___5 ;
  K j1___0 ;
  K tmp___6 ;
  K j2 ;
  K tmp___7 ;
  K tmp___8 ;
  K tmp___9 ;
  K tmp___10 ;
  char *tmp___11 ;
  K tmp___12 ;
  I tmp___13 ;
  K z___0 ;
  V tmp___14 ;
  K tmp___15 ;
  K j0___1 ;
  K tmp___16 ;
  K j1___1 ;
  K tmp___17 ;
  K j2___0 ;
  K tmp___18 ;
  K tmp___19 ;
  K tmp___20 ;
  K tmp___21 ;
  I tmp___22 ;
  K tmp___23 ;
  I tmp___24 ;
  K a ;
  K b___1 ;
  K c ;
  K d___0 ;
  K p ;
  K *w___0 ;
  int tmp___25 ;
  V tmp___26 ;
  K r ;
  K kc ;
  K tmp___27 ;
  I tmp___28 ;
  int tmp___29 ;
  I tmp___30 ;
  I tmp___32 ;
  K tmp___33 ;
  K tmp___34 ;
  K x___0 ;
  I tmp___35 ;
  K x___1 ;
  I tmp___36 ;
  I tmp___37 ;
  I tmp___38 ;
  K h ;
  K tmp___39 ;
  I tmp___40 ;
  K j ;
  K tmp___41 ;
  I tmp___42 ;
  I tmp___43 ;
  I tmp___44 ;
  int tmp___45 ;
  V tmp___46 ;
  K j0___2 ;
  K tmp___47 ;
  K j1___2 ;
  K tmp___48 ;
  K j2___1 ;
  K tmp___49 ;
  K tmp___50 ;
  K tmp___51 ;
  I tmp___53 ;
  V tmp___54 ;
  int tmp___55 ;
  K j0___3 ;
  K tmp___56 ;
  K j1___3 ;
  K tmp___57 ;
  K j2___2 ;
  K tmp___58 ;
  K tmp___59 ;
  K tmp___60 ;
  K p___0 ;
  I i___0 ;
  V *q ;
  I tmp___61 ;
  I tmp___62 ;
  I tmp___63 ;
  I tmp___64 ;
  V tmp___65 ;
  K j0___4 ;
  K tmp___66 ;
  K j1___4 ;
  K tmp___67 ;
  K j2___3 ;
  K tmp___68 ;
  K tmp___69 ;
  K tmp___70 ;
  K j0___5 ;
  K tmp___71 ;
  K j1___5 ;
  K tmp___72 ;
  K j2___4 ;
  K tmp___73 ;
  K tmp___74 ;
  K tmp___75 ;
  K j0___6 ;
  K tmp___76 ;
  K j1___6 ;
  K tmp___77 ;
  K j2___5 ;
  K tmp___78 ;
  K tmp___79 ;
  K tmp___80 ;
  K j0___7 ;
  K tmp___81 ;
  K j1___7 ;
  K tmp___82 ;
  K j2___6 ;
  K tmp___83 ;
  K tmp___84 ;
  K tmp___85 ;
  I tmp___87 ;
  I tmp___88 ;

  {
  i = (I )0;
  ft3 = (I )0;
  if (! v) {
    goto _L;
  } else
  if (! *v) {
    _L: /* CIL Label */ 
    if (k) {
      if (1LL == k->n) {
        tmp = ci(k->k[0]);
        tmp___1 = tmp;
      } else {
        tmp___0 = ci(k);
        tmp___1 = tmp___0;
      }
      tmp___2 = tmp___1;
    } else {
      tmp___2 = (K )DT_END_OFFSET;
    }
    return (tmp___2);
  }
  tmp___3 = bk(*v);
  if (tmp___3) {
    return ((K )*v);
  }
  if (! *(v + 1)) {
    if (! k) {
      tmp___4 = ex_(*v, (I )1);
      z = (K )tmp___4;
      if ((unsigned long )z > (unsigned long )((K )DT_SIZE)) {
        if (z->t == 7LL) {
          if (z->n == 3LL) {
            if (prnt) {
              if (*((V *)(z->k) + 4)) {
                if (*((V *)(prnt->k) + 7)) {
                  if (! *((V *)(z->k) + 7)) {
                    if (! (z->k[3])->n) {
                      tmp___5 = dot_monadic((K )*((V *)(z->k) + 4));
                      j0___0 = tmp___5;
                      tmp___6 = dot_monadic((K )*((V *)(prnt->k) + 7));
                      j1___0 = tmp___6;
                      tmp___7 = ci(j0___0);
                      tmp___8 = join(tmp___7, j1___0);
                      j2 = tmp___8;
                      cd(j0___0);
                      if (encp == 0LL) {
                        tmp___9 = dot_monadic(j2);
                        *((V *)(z->k) + 7) = (V )tmp___9;
                      }
                      if (encp == 1LL) {
                        tmp___10 = dot_monadic(j1___0);
                        *((V *)(z->k) + 7) = (V )tmp___10;
                      }
                      cd(j0___0);
                      cd(j1___0);
                      cd(j2);
                      cd(prnt->k[6]);
                      *((V *)(prnt->k) + 6) = (V )0;
                    }
                  }
                }
              }
            }
            if (prnt) {
              if (*((V *)(prnt->k) + 2)) {
                if ((prnt->k[2])->t == -3LL) {
                  if ((int )*((C *)((prnt->k[2])->k) + 0) == 123) {
                    if ((int )*((C *)((prnt->k[2])->k) + ((prnt->k[2])->n - 1LL)) == (int )*("}" + 0)) {
                      tmp___11 = strchr((char const   *)((C *)((prnt->k[2])->k)),
                                        (int )*("y" + 0));
                      if (tmp___11) {
                        if (encf) {
                          cd(encf);
                        }
                        encf = ci(prnt);
                      }
                    }
                  }
                }
              }
            }
            if (encp != 2LL) {
              goto _L___0;
            } else
            if (! prnt) {
              _L___0: /* CIL Label */ 
              if (prnt) {
                if (grnt) {
                  cd(grnt);
                }
                grnt = prnt;
              }
              prnt = ci(z);
            } else {
              cd(z);
              return (prnt);
            }
          }
        }
      }
      return (z);
    }
  }
  if (! *(v + 1)) {
    tmp___13 = sva(*v);
    if (tmp___13) {
      tmp___12 = vf_ex(*v, k);
      return (tmp___12);
    }
  }
  tmp___22 = bk(*(v + 1));
  if (tmp___22) {
    tmp___14 = ex_(*v, (I )1);
    z___0 = (K )tmp___14;
    if (fer == 2LL) {
      if (! fCheck) {
        return ((K )0);
      }
    }
    if (prnt) {
      if (z___0) {
        if (z___0->t == 7LL) {
          if (*((V *)(prnt->k) + 4)) {
            if (! (prnt->k[4])->n) {
              if (*((V *)(z___0->k) + 3)) {
                if (! (z___0->k[3])->n) {
                  if (*((V *)(prnt->k) + 3)) {
                    if ((prnt->k[3])->n) {
                      tmp___15 = kcloneI(prnt->k[7], "src/kx.c", 847);
                      *((V *)(z___0->k) + 7) = (V )tmp___15;
                      if (prnt) {
                        cd(prnt);
                      }
                      prnt = ci(z___0);
                    } else {
                      goto _L___5;
                    }
                  } else {
                    goto _L___5;
                  }
                } else {
                  goto _L___5;
                }
              } else {
                goto _L___5;
              }
            } else {
              goto _L___5;
            }
          } else
          _L___5: /* CIL Label */ 
          if (*((V *)(prnt->k) + 3)) {
            if ((prnt->k[3])->n) {
              if (*((V *)(z___0->k) + 4)) {
                if ((z___0->k[4])->n) {
                  if (*((V *)(prnt->k) + 7)) {
                    tmp___16 = dot_monadic((K )*((V *)(z___0->k) + 4));
                    j0___1 = tmp___16;
                    tmp___17 = dot_monadic((K )*((V *)(prnt->k) + 7));
                    j1___1 = tmp___17;
                    tmp___18 = ci(j0___1);
                    tmp___19 = join(tmp___18, j1___1);
                    j2___0 = tmp___19;
                    cd(j0___1);
                    tmp___20 = dot_monadic(j2___0);
                    *((V *)(z___0->k) + 7) = (V )tmp___20;
                    cd(j0___1);
                    cd(j1___1);
                    cd(j2___0);
                  } else {
                    tmp___21 = kcloneI((K )*((V *)(z___0->k) + 4), "src/kx.c", 852);
                    *((V *)(z___0->k) + 7) = (V )tmp___21;
                  }
                }
              }
            }
          }
        }
      }
    }
    return (z___0);
  }
  tmp___42 = VA(*v);
  if (! tmp___42) {
    if ((unsigned long )offsetColon == (unsigned long )*(v + 1)) {
      goto _L___10;
    } else {
      tmp___43 = VA(*(v + 1));
      if (tmp___43) {
        if ((unsigned long )offsetColon == (unsigned long )*(v + 2)) {
          _L___10: /* CIL Label */ 
          tmp___24 = adverbClass(*(v + 1));
          if (tmp___24) {
            tmp___23 = kerr("syntax");
            return (tmp___23);
          }
          a = (K )0;
          b___1 = (K )0;
          c = (K )0;
          d___0 = (K )0;
          p = (K )0;
          w___0 = (K *)*v;
          a = *w___0;
          if (! a) {
            return ((K )0);
          }
          if (7LL == a->t) {
            if (0LL == a->n) {
              b___1 = (K )*((V *)(a->k) + 5);
              if (b___1) {
                if (7LL == b___1->t) {
                  if (0LL == b___1->n) {
                    if ((L )*((V *)((S *)(((K )*((V *)(b___1->k) + 2))->k))) == 1LL) {
                      tmp___25 = 1;
                    } else
                    if ((L )*((V *)((S *)(((K )*((V *)(b___1->k) + 2))->k)) + 1) == 1LL) {
                      tmp___25 = 1;
                    } else {
                      tmp___25 = 2;
                    }
                    tmp___26 = ex_((V )((V *)(a->k) + 5), (I )tmp___25);
                    b___1 = (K )tmp___26;
                    if (! b___1) {
                      return ((K )0);
                    }
                    w___0 = (K *)*((V *)((S *)(((K )*((V *)(a->k) + 2))->k)));
                    if (b___1->t == 0LL) {
                      if (b___1->n == 0LL) {
                        if (1e6 < (double )((UI )w___0)) {
                          r = *w___0;
                          if (r->t == 5LL) {
                            p = enumerate(r);
                            cd(b___1);
                            b___1 = enlist(p);
                            cd(p);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (! b___1) {
            b___1 = newK((I )0, (I )0);
            if (! b___1) {
              return ((K )0);
            }
          }
          c = Kv();
          tmp___27 = newK((I )-4, (I )2);
          kc = tmp___27;
          tmp___28 = OOM_CD((I )0, b___1, c, kc, (V )-1);
          if (! tmp___28) {
            return ((K )0);
          }
          *((V *)(c->k) + 2) = (V )kc;
          *((V *)((S *)(((K )*((V *)(c->k) + 2))->k))) = *(v + 1);
          tmp___30 = sva(*(v + 1));
          if (1LL != tmp___30) {
            if ((unsigned long )offsetColon == (unsigned long )*(v + 1)) {
              tmp___29 = 2;
            } else {
              tmp___29 = 3;
            }
            d___0 = ex1(v + tmp___29, k, (I *)0, (I )0, (I )1);
          }
          tmp___32 = bk((V )d___0);
          if (tmp___32) {
            d___0 = (K )0;
          } else {
            d___0 = d___0;
          }
          if (fer > 0LL) {
            cd(c);
            cd(d___0);
            cd(b___1);
            tmp___33 = _n();
            return (tmp___33);
          }
          if (! *w___0) {
            tmp___34 = kerr("parse");
            return (tmp___34);
          }
          tmp___37 = cirRef(*w___0, d___0);
          if (tmp___37) {
            goto _L___8;
          } else
          if ((*w___0)->t == 6LL) {
            if (d___0) {
              if (d___0->t == 0LL) {
                goto _L___8;
              } else
              if (d___0->t == 5LL) {
                goto _L___8;
              } else {
                if (d___0->t < 0LL) {
                  tmp___38 = - d___0->t;
                } else {
                  tmp___38 = d___0->t;
                }
                if (tmp___38 != d___0->t) {
                  _L___8: /* CIL Label */ 
                  x___0 = d___0;
                  tmp___35 = rc(x___0);
                  if (tmp___35) {
                    d___0 = kcloneI(x___0, "src/kx.c", 871);
                    cd(x___0);
                  }
                } else {
                  goto _L___9;
                }
              }
            } else {
              goto _L___9;
            }
          } else
          _L___9: /* CIL Label */ 
          if ((*w___0)->t != 6LL) {
            x___1 = *w___0;
            tmp___36 = rc(x___1);
            if (tmp___36 > 1LL) {
              *w___0 = kcloneI(x___1, "src/kx.c", 872);
              cd(x___1);
            }
          }
          tmp___39 = dot_tetradic_2(w___0, b___1, c, d___0);
          h = tmp___39;
          cd(c);
          cd(d___0);
          tmp___40 = OOM_CD((I )0, b___1, h, (V )-1);
          if (! tmp___40) {
            return ((K )0);
          }
          tmp___41 = of(h, b___1);
          j = tmp___41;
          cd(b___1);
          return (j);
        }
      }
    }
  }
  while (1) {
    if (*(v + 1)) {
      tmp___44 = adverbClass(*(v + (2LL + i)));
      if (! tmp___44) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  tmp___62 = sva(*(v + 0));
  if (! tmp___62) {
    if (i) {
      goto _L___11;
    } else {
      tmp___63 = sva(*(v + 1));
      if (2LL == tmp___63) {
        _L___11: /* CIL Label */ 
        t2 = ex2((v + 2) + i, k);
        if (fer > 0LL) {
          tmp___45 = strcmp((char const   *)(errmsg), "(nil)");
          if (tmp___45) {
            return (t2);
          }
        }
        tmp___46 = ex_(*(v + 1), (I )1);
        t3 = (K )tmp___46;
        if ((unsigned long )t3 > (unsigned long )((K )DT_SIZE)) {
          if (t3->t == 7LL) {
            if (t3->n == 3LL) {
              if (prnt) {
                if (*((V *)(prnt->k) + 7)) {
                  if (*((V *)(prnt->k) + 6)) {
                    if (! (t3->k[3])->n) {
                      tmp___47 = dot_monadic((K )*((V *)(t3->k) + 4));
                      j0___2 = tmp___47;
                      tmp___48 = dot_monadic((K )*((V *)(prnt->k) + 7));
                      j1___2 = tmp___48;
                      tmp___49 = ci(j0___2);
                      tmp___50 = join(tmp___49, j1___2);
                      j2___1 = tmp___50;
                      cd(j0___2);
                      cd(t3->k[7]);
                      tmp___51 = dot_monadic(j2___1);
                      *((V *)(t3->k) + 7) = (V )tmp___51;
                      cd(j0___2);
                      cd(j1___2);
                      cd(j2___1);
                      if ((prnt->k[7])->n) {
                        fsf = (I )1;
                      }
                    }
                  }
                }
              }
              if (prnt) {
                cd(prnt);
              }
              prnt = ci(t3);
            }
          }
        }
        u = (K )*(v + 1);
        tmp___53 = VA((V )t3);
        if (tmp___53) {
          *(v + 1) = (V )t3;
        } else {
          *(v + 1) = (V )(& t3);
        }
        tmp___54 = ex_(*v, (I )1);
        t0___0 = (K )tmp___54;
        if (fer > 0LL) {
          tmp___55 = strcmp((char const   *)(errmsg), "(nil)");
          if (tmp___55) {
            cd(t2);
            return (t0___0);
          }
        }
        if ((unsigned long )t0___0 > (unsigned long )((K )DT_SIZE)) {
          if (t0___0->t == 7LL) {
            if (t0___0->n == 3LL) {
              if (prnt) {
                if (*((V *)(prnt->k) + 7)) {
                  if (*((V *)(prnt->k) + 6)) {
                    if (! (t0___0->k[3])->n) {
                      tmp___56 = dot_monadic((K )*((V *)(t0___0->k) + 4));
                      j0___3 = tmp___56;
                      tmp___57 = dot_monadic((K )*((V *)(prnt->k) + 7));
                      j1___3 = tmp___57;
                      tmp___58 = ci(j0___3);
                      tmp___59 = join(tmp___58, j1___3);
                      j2___2 = tmp___59;
                      cd(j0___3);
                      cd(t0___0->k[7]);
                      tmp___60 = dot_monadic(j2___2);
                      *((V *)(t0___0->k) + 7) = (V )tmp___60;
                      cd(j0___3);
                      cd(j1___3);
                      cd(j2___2);
                      if ((prnt->k[7])->n) {
                        fsf = (I )1;
                      }
                    }
                  }
                }
              }
              if (prnt) {
                cd(prnt);
              }
              prnt = ci(t0___0);
            }
          }
        }
        if (! prnt) {
          if (t0___0->t == 7LL) {
            if (t0___0->n == 3LL) {
              prnt = ci(t0___0);
            }
          }
        }
        if ((unsigned long )*((v + 1) + i) == (unsigned long )offsetDot) {
          if (t0___0->t == 7LL) {
            if (t0___0->n == 1LL) {
              if ((unsigned long )(t0___0->k[2])->k[1] == (unsigned long )((V )offsetEach)) {
                p___0 = (K )*((V *)(t0___0->k) + 2);
                i___0 = p___0->n - 2LL;
                q = (V *)(p___0->k) + i___0;
                e = bv_ex(q, t2);
              } else
              if ((unsigned long )(t0___0->k[2])->k[1] == (unsigned long )((V )offsetEachright)) {
                p___0 = (K )*((V *)(t0___0->k) + 2);
                i___0 = p___0->n - 2LL;
                q = (V *)(p___0->k) + i___0;
                e = bv_ex(q, t2);
              } else
              if ((unsigned long )(t0___0->k[2])->k[1] == (unsigned long )((V )offsetEachleft)) {
                p___0 = (K )*((V *)(t0___0->k) + 2);
                i___0 = p___0->n - 2LL;
                q = (V *)(p___0->k) + i___0;
                e = bv_ex(q, t2);
              } else
              if ((unsigned long )(t0___0->k[2])->k[1] == (unsigned long )((V )offsetEachpair)) {
                p___0 = (K )*((V *)(t0___0->k) + 2);
                i___0 = p___0->n - 2LL;
                q = (V *)(p___0->k) + i___0;
                e = bv_ex(q, t2);
              } else {
                e = dv_ex(t0___0, (v + 1) + i, t2);
                *(v + 1) = (V )u;
              }
            } else {
              e = dv_ex(t0___0, (v + 1) + i, t2);
              *(v + 1) = (V )u;
            }
          } else {
            e = dv_ex(t0___0, (v + 1) + i, t2);
            *(v + 1) = (V )u;
          }
        } else {
          e = dv_ex(t0___0, (v + 1) + i, t2);
          *(v + 1) = (V )u;
        }
        cd(t0___0);
        cd(t2);
        tmp___61 = VA((V )t3);
        if (! tmp___61) {
          cd(t3);
        }
        return (e);
      }
    }
  }
  i = (I )0;
  while (1) {
    tmp___64 = adverbClass(*(v + (1LL + i)));
    if (! tmp___64) {
      break;
    }
    i ++;
  }
  t2 = ex2((v + 1) + i, k);
  tmp___65 = ex_(*v, (I )1);
  t3 = (K )tmp___65;
  if ((unsigned long )t3 < (unsigned long )((K )DT_SIZE)) {
    ft3 = (I )1;
  }
  if ((unsigned long )t3 > (unsigned long )((K )DT_SIZE)) {
    if (t3->t == 7LL) {
      if (t3->n == 3LL) {
        if ((unsigned long )((V *)(t3->k)) == (unsigned long )((V *)(grnt->k))) {
          if (cls) {
            cd(cls);
          }
          cls = ci(((prnt->k[7])->k[0])->k[1]);
        }
        if (prnt) {
          if (*((V *)(prnt->k) + 6)) {
            if (! (t3->k[3])->n) {
              if ((prnt->k[3])->n) {
                if (*((V *)(t3->k) + 6)) {
                  if (! *((V *)(t3->k) + 7)) {
                    t3->k[7] = prnt->k[7];
                    ci(t3->k[7]);
                  } else {
                    goto _L___13;
                  }
                } else
                _L___13: /* CIL Label */ 
                if ((t3->k[4])->n) {
                  goto _L___12;
                } else
                if (grnt) {
                  _L___12: /* CIL Label */ 
                  tmp___66 = dot_monadic((K )*((V *)(t3->k) + 4));
                  j0___4 = tmp___66;
                  tmp___67 = dot_monadic((K )*((V *)(prnt->k) + 7));
                  j1___4 = tmp___67;
                  tmp___68 = ci(j0___4);
                  tmp___69 = join(tmp___68, j1___4);
                  j2___3 = tmp___69;
                  cd(j0___4);
                  if (*((V *)(t3->k) + 7)) {
                    if ((t3->k[7])->n) {
                      cd(t3->k[7]);
                    }
                  }
                  tmp___70 = dot_monadic(j2___3);
                  *((V *)(t3->k) + 7) = (V )tmp___70;
                  cd(j0___4);
                  cd(j1___4);
                  cd(j2___3);
                }
              } else
              if (*((V *)((prnt->k[6])->k) + 3)) {
                if (((prnt->k[6])->k[3])->n) {
                  if (*((V *)(prnt->k) + 7)) {
                    if ((prnt->k[7])->n) {
                      if (! *((V *)((((prnt->k[6])->k[3])->k[0])->k) + 1)) {
                        goto _L___14;
                      } else
                      if (! *((V *)(((((prnt->k[6])->k[3])->k[0])->k[1])->k) + 5)) {
                        _L___14: /* CIL Label */ 
                        tmp___71 = dot_monadic((K )*((V *)(t3->k) + 4));
                        j0___5 = tmp___71;
                        tmp___72 = dot_monadic((K )*((V *)(prnt->k) + 7));
                        j1___5 = tmp___72;
                        tmp___73 = ci(j0___5);
                        tmp___74 = join(tmp___73, j1___5);
                        j2___4 = tmp___74;
                        cd(j0___5);
                        tmp___75 = dot_monadic(j2___4);
                        *((V *)(t3->k) + 7) = (V )tmp___75;
                        cd(j0___5);
                        cd(j1___5);
                        cd(j2___4);
                      }
                    }
                  }
                }
              }
            } else {
              goto _L___19;
            }
          } else
          _L___19: /* CIL Label */ 
          if (*((V *)(prnt->k) + 7)) {
            if (1LL == (prnt->k[7])->n) {
              if (! *((V *)(prnt->k) + 6)) {
                if (! *((V *)(t3->k) + 7)) {
                  tmp___76 = dot_monadic((K )*((V *)(t3->k) + 4));
                  j0___6 = tmp___76;
                  tmp___77 = dot_monadic((K )*((V *)(prnt->k) + 7));
                  j1___6 = tmp___77;
                  tmp___78 = ci(j0___6);
                  tmp___79 = join(tmp___78, j1___6);
                  j2___5 = tmp___79;
                  cd(j0___6);
                  tmp___80 = dot_monadic(j2___5);
                  *((V *)(t3->k) + 7) = (V )tmp___80;
                  cd(j0___6);
                  cd(j1___6);
                  cd(j2___5);
                } else {
                  goto _L___18;
                }
              } else {
                goto _L___18;
              }
            } else {
              goto _L___18;
            }
          } else
          _L___18: /* CIL Label */ 
          if (*((V *)(t3->k) + 4)) {
            if ((t3->k[4])->n) {
              if (*((V *)(prnt->k) + 7)) {
                if ((prnt->k[7])->n == 1LL) {
                  if (! prnt->k[6]) {
                    goto _L___15;
                  } else
                  if (prnt->k[6]) {
                    if ((prnt->k[6])->n) {
                      _L___15: /* CIL Label */ 
                      tmp___81 = dot_monadic((K )*((V *)(t3->k) + 4));
                      j0___7 = tmp___81;
                      tmp___82 = dot_monadic((K )*((V *)(prnt->k) + 7));
                      j1___7 = tmp___82;
                      tmp___83 = ci(j0___7);
                      tmp___84 = join(tmp___83, j1___7);
                      j2___6 = tmp___84;
                      cd(j0___7);
                      if (*((V *)(t3->k) + 7)) {
                        if ((t3->k[7])->n) {
                          cd(t3->k[7]);
                        }
                      }
                      tmp___85 = dot_monadic(j2___6);
                      *((V *)(t3->k) + 7) = (V )tmp___85;
                      cd(j0___7);
                      cd(j1___7);
                      cd(j2___6);
                    }
                  }
                }
              }
            }
          }
          if (grnt) {
            cd(prnt);
          } else {
            grnt = prnt;
          }
        }
        prnt = ci(t3);
      }
    }
  }
  u = (K )*v;
  tmp___87 = VA((V )t3);
  if (tmp___87) {
    *v = (V )t3;
  } else {
    *v = (V )(& t3);
  }
  if ((unsigned long )*(v + i) == (unsigned long )((V )offsetEach)) {
    if (! grnt) {
      grnt = ci(prnt);
    }
  }
  e = dv_ex((K )0, v + i, t2);
  *v = (V )u;
  if ((unsigned long )*(v + i) == (unsigned long )((V )offsetEach)) {
    if ((unsigned long )prnt == (unsigned long )grnt) {
      cd(grnt);
      grnt = (K )0;
    }
  }
  cd(t2);
  tmp___88 = VA((V )t3);
  if (! tmp___88) {
    if (encp != 3LL) {
      cd(t3);
    } else
    if (encp == 3LL) {
      if (*((V *)(t3->k) + 6)) {
        cd(t3);
      }
    }
  }
  return (e);
}
}
I cirRef(K x___0 , K y ) 
{ 
  I f ;
  I i ;
  I _i___0 ;

  {
  if (x___0) {
    if ((unsigned long )x___0 == (unsigned long )y) {
      return ((I )1);
    }
  }
  f = (I )0;
  if (x___0->t == 6LL) {
    return ((I )0);
  } else
  if (! y) {
    return ((I )0);
  } else
  if (y->t != 0LL) {
    if (y->t != 5LL) {
      return ((I )0);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((UI )x___0 < (UI )DT_SIZE) {
    return ((I )0);
  }
  i = (I )0;
  _i___0 = y->n;
  while (i < _i___0) {
    f = cirRef_(x___0, y->k[(y->n - i) - 1LL], f);
    i ++;
  }
  return (f);
}
}
I cirRef_(K x___0 , K y , I f ) 
{ 
  I i ;
  I _i___0 ;

  {
  if ((unsigned long )x___0 == (unsigned long )y) {
    f = (I )1;
  }
  i = (I )0;
  _i___0 = y->n;
  while (i < _i___0) {
    if (! f) {
      if (y->t == 0LL) {
        f = cirRef_(x___0, y->k[(y->n - i) - 1LL], f);
      } else
      if (y->t == 5LL) {
        f = cirRef_(x___0, y->k[(y->n - i) - 1LL], f);
      }
    }
    i ++;
  }
  return (f);
}
}
#pragma merger("0","/tmp/cil-F5yUB1tA.i","-g,-pthread,-O3")
extern  __attribute__((__nothrow__)) long long llabs(long long __x )  __attribute__((__const__)) ;
K mergeGrade(K a , I r ) ;
K charGrade(K a , I r ) ;
K distributionGrade(K a , I r , uI u , uI v ) ;
K radixGrade(K a , I r , uI h ) ;
K insertGradeU(K a , I r ) ;
void setS(int y , I z ) ;
I wleft(N x___0 , I y , I z ) ;
I wright(N x___0 , I y , I z ) ;
void trst(void) ;
void elapsed(S m ) ;
static I gt  =    (I )0;
static I mergerComparer(K a , I r , I i , I j ) ;
I FC(F a , F b___1 ) 
{ 
  union __anonunion_x_721633472 x___0 ;
  union __anonunion_x_721633472 y ;
  I xu ;
  I ad ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  x___0.f = a;
  y.f = b___1;
  xu = x___0.i | y.i;
  if (9218868437227405312ULL < (9223372036854775807ULL & (unsigned long long )x___0.i)) {
    if (9218868437227405312ULL < (9223372036854775807ULL & (unsigned long long )y.i)) {
      tmp = 0;
    } else {
      tmp = -1;
    }
    return ((I )tmp);
  } else
  if (x___0.i < 0LL) {
    x___0.i = (-0x7FFFFFFFFFFFFFFF-1) - x___0.i;
  }
  if (9218868437227405312ULL < (9223372036854775807ULL & (unsigned long long )y.i)) {
    return ((I )1);
  } else
  if (y.i < 0LL) {
    y.i = (-0x7FFFFFFFFFFFFFFF-1) - y.i;
  }
  ad = llabs(x___0.i - y.i);
  if (ad < 1023LL) {
    if (4503599627370496ULL > (9223372036854775807ULL & (unsigned long long )xu)) {
      if (x___0.i < y.i) {
        tmp___1 = -1;
      } else {
        if (x___0.i != y.i) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
        tmp___1 = tmp___0;
      }
      return ((I )tmp___1);
    }
    if (ad < 513LL) {
      return ((I )0);
    }
    xu = 513LL + ((255LL & (xu >> 44)) << 1);
    if (ad < xu) {
      return ((I )0);
    }
  }
  if (x___0.i < y.i) {
    tmp___2 = -1;
  } else {
    tmp___2 = 1;
  }
  return ((I )tmp___2);
}
}
I KC(K a , K b___1 ) 
{ 
  K tmp ;
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  I A ;
  I tmp___0 ;
  I u ;
  I v ;
  C c ;
  C d___0 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I tmp___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  int tmp___2 ;

  {
  if ((unsigned long )b___1 == (unsigned long )((void *)0)) {
    feci = (I )1;
    tmp = kerr("type");
    return ((I )tmp);
  }
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (at___0 < 0LL) {
    tmp___0 = - at___0;
  } else {
    tmp___0 = at___0;
  }
  A = tmp___0;
  if (at___0 < bt) {
    return ((I )-1);
  }
  if (at___0 > bt) {
    return ((I )1);
  }
  if (3LL != A) {
    if (an < bn) {
      return ((I )-1);
    }
    if (an > bn) {
      return ((I )1);
    }
  }
  if (7LL == A) {
    return ((I )0);
  } else
  if (6LL == A) {
    return ((I )0);
  } else
  if (5LL == A) {
    return ((I )0);
  } else
  if (4LL == A) {
    i = (I )0;
    _i___0 = an;
    while (i < _i___0) {
      u = SC(*((S *)(a->k) + i), *((S *)(b___1->k) + i));
      if (u) {
        return (u);
      }
      i ++;
    }
  } else
  if (3LL == A) {
    i___0 = (I )0;
    if (an < bn) {
      tmp___1 = an;
    } else {
      tmp___1 = bn;
    }
    _i___1 = tmp___1 + 1LL;
    while (i___0 < _i___1) {
      c = *((C *)(a->k) + i___0);
      d___0 = *((C *)(b___1->k) + i___0);
      if ((int )c < (int )d___0) {
        return ((I )-1);
      }
      if ((int )c > (int )d___0) {
        return ((I )1);
      }
      i___0 ++;
    }
  } else
  if (2LL == A) {
    i___1 = (I )0;
    _i___2 = an;
    while (i___1 < _i___2) {
      u = FC(*((F *)(a->k) + i___1), *((F *)(b___1->k) + i___1));
      if (u) {
        return (u);
      }
      i___1 ++;
    }
  } else
  if (1LL == A) {
    i___2 = (I )0;
    _i___3 = an;
    while (i___2 < _i___3) {
      u = *((I *)(a->k) + i___2);
      v = *((I *)(b___1->k) + i___2);
      if (u < v) {
        return ((I )-1);
      }
      if (u > v) {
        return ((I )1);
      }
      i___2 ++;
    }
  } else
  if (0LL == A) {
    i___3 = (I )0;
    _i___4 = an;
    while (i___3 < _i___4) {
      u = KC(a->k[i___3], b___1->k[i___3]);
      if (u) {
        return (u);
      }
      i___3 ++;
    }
  }
  if (3LL == A) {
    if (an != bn) {
      if (an < bn) {
        tmp___2 = -1;
      } else {
        tmp___2 = 1;
      }
      return ((I )tmp___2);
    }
  }
  return ((I )0);
}
}
K distributionGrade(K a , I r , uI u , uI v ) 
{ 
  I n ;
  I b___1 ;
  I *c ;
  K d___0 ;
  K tmp ;
  K s ;
  K tmp___0 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I tmp___1 ;

  {
  if (gt) {
    printf((char const   * __restrict  )"distributionGrade");
  }
  n = a->n;
  b___1 = (I )((v - u) + 1ULL);
  tmp = newK((I )-1, b___1);
  d___0 = tmp;
  if (! d___0) {
    return ((K )0);
  }
  c = (I *)(d___0->k);
  tmp___0 = newK((I )-1, n);
  s = tmp___0;
  if (! s) {
    goto cleanup;
  }
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    (*(c + (*((uI *)(a->k) + i) - u))) ++;
    i ++;
  }
  if (! r) {
    i___0 = (I )0;
    _i___1 = b___1 - 1LL;
    while (i___0 < _i___1) {
      *(c + (i___0 + 1LL)) += *(c + i___0);
      i___0 ++;
    }
  } else {
    i___1 = (I )0;
    _i___2 = b___1 - 1LL;
    while (i___1 < _i___2) {
      *(c + ((_i___2 - i___1) - 1LL)) += *(c + (_i___2 - i___1));
      i___1 ++;
    }
  }
  i___2 = (I )0;
  _i___3 = n;
  while (i___2 < _i___3) {
    tmp___1 = *(c + (*((uI *)(a->k) + ((n - i___2) - 1LL)) - u));
    (*(c + (*((uI *)(a->k) + ((n - i___2) - 1LL)) - u))) --;
    *((I *)(s->k) + (-1LL + tmp___1)) = (n - i___2) - 1LL;
    i___2 ++;
  }
  cleanup: 
  cd(d___0);
  return (s);
}
}
K charGrade(K a , I r ) 
{ 
  I n ;
  I c[256] ;
  K s ;
  K tmp ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I tmp___0 ;

  {
  n = a->n;
  memset((void *)(c), 0, 256UL * sizeof(I ));
  tmp = newK((I )-1, n);
  s = tmp;
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    (c[(UC )*((C *)(a->k) + i)]) ++;
    i ++;
  }
  if (! r) {
    i___0 = (I )0;
    _i___1 = (I )255;
    while (i___0 < _i___1) {
      c[i___0 + 1LL] += c[i___0];
      i___0 ++;
    }
  } else {
    i___1 = (I )0;
    _i___2 = (I )255;
    while (i___1 < _i___2) {
      c[(_i___2 - i___1) - 1LL] += c[_i___2 - i___1];
      i___1 ++;
    }
  }
  i___2 = (I )0;
  _i___3 = n;
  while (i___2 < _i___3) {
    tmp___0 = c[(UC )*((C *)(a->k) + ((n - i___2) - 1LL))];
    (c[(UC )*((C *)(a->k) + ((n - i___2) - 1LL))]) --;
    *((I *)(s->k) + (-1LL + tmp___0)) = (n - i___2) - 1LL;
    i___2 ++;
  }
  return (s);
}
}
static I mergerComparer(K a , I r , I i , I j ) 
{ 
  I t ;
  I tmp ;
  I tmp___0 ;
  I tmp___1 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;

  {
  t = a->t;
  if (-4LL == t) {
    if (0LL == r) {
      tmp___4 = SC(*((S *)(a->k) + i), *((S *)(a->k) + j));
      if (1LL > tmp___4) {
        return ((I )1);
      } else {
        goto _L___12;
      }
    } else {
      goto _L___12;
    }
  } else
  _L___12: /* CIL Label */ 
  if (-4LL == t) {
    if (1LL == r) {
      tmp___3 = SC(*((S *)(a->k) + i), *((S *)(a->k) + j));
      if (-1LL < tmp___3) {
        return ((I )1);
      } else {
        goto _L___10;
      }
    } else {
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
  if (-2LL == t) {
    if (0LL == r) {
      tmp___2 = FC(*((F *)(a->k) + i), *((F *)(a->k) + j));
      if (1LL > tmp___2) {
        return ((I )1);
      } else {
        goto _L___8;
      }
    } else {
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
  if (-2LL == t) {
    if (1LL == r) {
      tmp___1 = FC(*((F *)(a->k) + i), *((F *)(a->k) + j));
      if (-1LL < tmp___1) {
        return ((I )1);
      } else {
        goto _L___6;
      }
    } else {
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
  if (-1LL == t) {
    if (0LL == r) {
      if (*((I *)(a->k) + i) <= *((I *)(a->k) + j)) {
        return ((I )1);
      } else {
        goto _L___4;
      }
    } else {
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
  if (-1LL == t) {
    if (1LL == r) {
      if (*((I *)(a->k) + i) >= *((I *)(a->k) + j)) {
        return ((I )1);
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (0LL == t) {
    if (0LL == r) {
      tmp___0 = KC(a->k[i], a->k[j]);
      if (1LL > tmp___0) {
        return ((I )1);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (0LL == t) {
    if (1LL == r) {
      tmp = KC(a->k[i], a->k[j]);
      if (-1LL < tmp) {
        return ((I )1);
      }
    }
  }
  return ((I )0);
}
}
static void merger(K a , I r , K x___0 , K y , I s , I t , I m ) 
{ 
  I i ;
  I j ;
  I k ;
  I *c ;
  I *d___0 ;
  I tmp ;
  I tmp___0 ;
  I tmp___1 ;
  I tmp___2 ;
  I tmp___3 ;

  {
  c = (I *)(x___0->k);
  d___0 = (I *)(y->k);
  memcpy((void * __restrict  )(d___0 + s), (void const   * __restrict  )(c + s), (size_t )((unsigned long long )((t - s) + 1LL) * (unsigned long long )sizeof(I )));
  i = s;
  j = m + 1LL;
  k = s;
  while (1) {
    if (i <= m) {
      if (! (j <= t)) {
        break;
      }
    } else {
      break;
    }
    tmp___3 = mergerComparer(a, r, *(d___0 + i), *(d___0 + j));
    if (tmp___3) {
      tmp = k;
      k ++;
      tmp___0 = i;
      i ++;
      *(c + tmp) = *(d___0 + tmp___0);
    } else {
      tmp___1 = k;
      k ++;
      tmp___2 = j;
      j ++;
      *(c + tmp___1) = *(d___0 + tmp___2);
    }
  }
  if (i <= m) {
    memcpy((void * __restrict  )(c + k), (void const   * __restrict  )(d___0 + i),
           (size_t )((unsigned long long )((m - i) + 1LL) * (unsigned long long )sizeof(I )));
  }
  return;
}
}
static void insertGrade(K a , I r , K x___0 , K y , I s , I t ) 
{ 
  I i ;
  I *c ;
  I x___1 ;
  I j ;
  I tmp ;

  {
  c = (I *)(x___0->k);
  i = s + 1LL;
  while (i <= t) {
    x___1 = *(c + i);
    j = i;
    while (1) {
      if (s < j) {
        tmp = mergerComparer(a, r, *(c + (j - 1LL)), x___1);
        if (tmp) {
          break;
        }
      } else {
        break;
      }
      *(c + j) = *(c + (j - 1LL));
      j --;
    }
    *(c + j) = x___1;
    i ++;
  }
  return;
}
}
static void doMergeGrade(K a , I r , K x___0 , K y , I s , I t ) 
{ 
  I m ;

  {
  if (s >= t) {
    return;
  }
  m = s + (t - s) / 2LL;
  if (m - s < 7LL) {
    insertGrade(a, r, x___0, y, s, m);
  } else {
    doMergeGrade(a, r, x___0, y, s, m);
  }
  if (t - (m + 1LL) < 7LL) {
    insertGrade(a, r, x___0, y, m + 1LL, t);
  } else {
    doMergeGrade(a, r, x___0, y, m + 1LL, t);
  }
  merger(a, r, x___0, y, s, t, m);
  return;
}
}
static uI StoU(S s , I n , I t ) 
{ 
  uI h ;
  I i ;
  I _i___0 ;
  int tmp ;

  {
  h = (uI )0;
  i = (I )0;
  _i___0 = (I )8;
  while (i < _i___0) {
    h <<= 8;
    if (i < n) {
      tmp = (int )((UC )*(s + i));
    } else {
      tmp = 0;
    }
    h += (uI )tmp;
    i ++;
  }
  return (h);
}
}
static K strGrade(K a , I r ) 
{ 
  uI h ;
  I k ;
  I s ;
  K z ;
  K x___0 ;
  K tmp ;
  I tmp___0 ;
  I i ;
  I _i___0 ;
  K y ;
  uI tmp___1 ;

  {
  h = (uI )0;
  s = (I )1;
  z = (K )0;
  tmp = newK((I )-1, a->n);
  x___0 = tmp;
  tmp___0 = OOM_CD((I )0, x___0, (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  i = (I )0;
  _i___0 = x___0->n;
  while (i < _i___0) {
    y = a->k[i];
    if (-3LL != y->t) {
      s = (I )0;
      break;
    } else
    if (y->n > 8LL) {
      s = (I )0;
      break;
    }
    tmp___1 = StoU((C *)(y->k), y->n, y->t);
    k = (I )tmp___1;
    if (! k) {
      if (y->n) {
        s = (I )0;
        break;
      }
    }
    *((uI *)(x___0->k) + i) = (uI )k;
    h |= (unsigned long long )k;
    i ++;
  }
  if (s) {
    z = radixGrade(x___0, r, h);
  }
  cd(x___0);
  return (z);
}
}
K mergeGrade(K a , I r ) 
{ 
  K x___0 ;
  K y ;
  I n ;
  I tmp ;
  I i ;
  I _i___0 ;

  {
  x___0 = (K )0;
  y = (K )0;
  n = a->n;
  if (gt) {
    printf((char const   * __restrict  )"mergeGrade");
  }
  if (0LL == a->t) {
    x___0 = strGrade(a, r);
    if (x___0) {
      return (x___0);
    }
  }
  x___0 = newK((I )-1, n);
  y = newK((I )-1, n);
  tmp = OOM_CD((I )0, x___0, y, (V )-1);
  if (! tmp) {
    return ((K )0);
  }
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    *((I *)(x___0->k) + i) = i;
    i ++;
  }
  doMergeGrade(a, r, x___0, y, (I )0, n - 1LL);
  cd(y);
  return (x___0);
}
}
K insertGradeU(K a , I r ) 
{ 
  uI *u ;
  I n ;
  I i ;
  I *c ;
  K x___0 ;
  K tmp ;
  I tmp___0 ;
  I i___0 ;
  I _i___0 ;
  I k ;
  I j ;
  I k___0 ;
  I j___0 ;

  {
  if (gt) {
    printf((char const   * __restrict  )"insertGrade");
  }
  u = (uI *)(a->k);
  n = a->n;
  tmp = newK((I )-1, n);
  x___0 = tmp;
  tmp___0 = OOM_CD((I )0, x___0, (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  i___0 = (I )0;
  _i___0 = n;
  while (i___0 < _i___0) {
    *((I *)(x___0->k) + i___0) = i___0;
    i___0 ++;
  }
  c = (I *)(x___0->k);
  if (! r) {
    i = (I )1;
    while (i <= n - 1LL) {
      k = *(c + i);
      j = i;
      while (1) {
        if (0LL < j) {
          if (! (*(u + *(c + (j - 1LL))) > *(u + k))) {
            break;
          }
        } else {
          break;
        }
        *(c + j) = *(c + (j - 1LL));
        j --;
      }
      *(c + j) = k;
      i ++;
    }
  } else {
    i = (I )1;
    while (i <= n - 1LL) {
      k___0 = *(c + i);
      j___0 = i;
      while (1) {
        if (0LL < j___0) {
          if (! (*(u + *(c + (j___0 - 1LL))) < *(u + k___0))) {
            break;
          }
        } else {
          break;
        }
        *(c + j___0) = *(c + (j___0 - 1LL));
        j___0 --;
      }
      *(c + j___0) = k___0;
      i ++;
    }
  }
  return (x___0);
}
}
static clock_t t0  ;
void trst(void) 
{ 


  {
  t0 = clock();
  return;
}
}
void elapsed(S m ) 
{ 
  clock_t e ;
  clock_t tmp ;
  I ms ;

  {
  tmp = clock();
  e = tmp - t0;
  ms = (I )((1000.0 * (double )e) / (double )1000000L);
  if (ms) {
    printf((char const   * __restrict  )"%s %lld\n", m, ms);
  }
  trst();
  return;
}
}
static void dGU(uI *a , I r , I *x___0 , I *y , I n , I *c , I d___0 ) 
{ 
  I sa ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I k ;
  I tmp ;

  {
  sa = 16LL * d___0;
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    (*(c + (65535ULL & (*(a + i) >> sa)))) ++;
    i ++;
  }
  i___0 = (I )0;
  _i___1 = (I )65535;
  while (i___0 < _i___1) {
    *(c + (i___0 + 1LL)) += *(c + i___0);
    i___0 ++;
  }
  i___1 = (I )0;
  _i___2 = n;
  while (i___1 < _i___2) {
    k = *(x___0 + ((n - i___1) - 1LL));
    tmp = *(c + (65535ULL & (*(a + ((n - i___1) - 1LL)) >> sa)));
    (*(c + (65535ULL & (*(a + ((n - i___1) - 1LL)) >> sa)))) --;
    *(y + (-1LL + tmp)) = k;
    i___1 ++;
  }
  return;
}
}
static void radixGradeI(uI *a , uI *w___0 , I r , I *u , I *v , I *c , I n , uI h ) 
{ 
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;

  {
  if (r) {
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      *(a + i) = ~ *(a + i);
      i ++;
    }
    r = (I )0;
  }
  dGU(a, r, u, v, n, c, (I )0);
  if (65536ULL > h) {
    goto v2u;
  }
  i___0 = (I )0;
  _i___1 = n;
  while (i___0 < _i___1) {
    *(w___0 + i___0) = *(a + *(v + i___0));
    i___0 ++;
  }
  c += 65536;
  dGU(w___0, r, v, u, n, c, (I )1);
  if (4294967296ULL > h) {
    return;
  }
  i___1 = (I )0;
  _i___2 = n;
  while (i___1 < _i___2) {
    *(w___0 + i___1) = *(a + *(u + i___1));
    i___1 ++;
  }
  c += 65536;
  dGU(w___0, r, u, v, n, c, (I )2);
  if (281474976710656ULL > h) {
    goto v2u;
  }
  i___2 = (I )0;
  _i___3 = n;
  while (i___2 < _i___3) {
    *(w___0 + i___2) = *(a + *(v + i___2));
    i___2 ++;
  }
  c += 65536;
  dGU(w___0, r, v, u, n, c, (I )3);
  return;
  v2u: 
  memcpy((void * __restrict  )u, (void const   * __restrict  )v, (size_t )((unsigned long long )n * (unsigned long long )sizeof(I )));
  return;
}
}
K radixGrade(K a , I r , uI h ) 
{ 
  I n ;
  K x___0 ;
  K tmp ;
  K y ;
  K tmp___0 ;
  K z ;
  K tmp___1 ;
  K w___0 ;
  K tmp___2 ;
  I tmp___3 ;
  I i ;
  I _i___0 ;

  {
  if (gt) {
    printf((char const   * __restrict  )"radixGrade");
  }
  n = a->n;
  tmp = newK((I )-1, n);
  x___0 = tmp;
  tmp___0 = newK((I )-1, n);
  y = tmp___0;
  tmp___1 = newK((I )-1, (I )262144);
  z = tmp___1;
  tmp___2 = newK((I )-1, n);
  w___0 = tmp___2;
  tmp___3 = OOM_CD((I )0, x___0, y, z, w___0, (V )-1);
  if (! tmp___3) {
    return ((K )0);
  }
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    *((I *)(x___0->k) + i) = i;
    i ++;
  }
  radixGradeI((uI *)(a->k), (uI *)(w___0->k), r, (I *)(x___0->k), (I *)(y->k), (I *)(z->k),
              n, h);
  cd(w___0);
  cd(z);
  cd(y);
  return (x___0);
}
}
K symGrade(K x___0 , I r ) 
{ 
  K z ;
  K tmp ;
  I tmp___0 ;
  I i ;
  I _i___0 ;
  S s ;
  I i___0 ;
  I _i___1 ;
  S s___0 ;
  I y ;
  I tmp___1 ;

  {
  tmp = newK((I )-1, x___0->n);
  z = tmp;
  tmp___0 = OOM_CD((I )0, x___0, (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  setS(1, (I )0);
  i = (I )0;
  _i___0 = x___0->n;
  while (i < _i___0) {
    s = *((S *)(x___0->k) + i);
    (*((I *)s + -1)) ++;
    i ++;
  }
  if (! r) {
    wleft(SYMBOLS, (I )1, (I )0);
  } else {
    wright(SYMBOLS, (I )1, (I )0);
  }
  i___0 = (I )0;
  _i___1 = x___0->n;
  while (i___0 < _i___1) {
    s___0 = *((S *)(x___0->k) + i___0);
    y = *((I *)s___0 + -1);
    tmp___1 = y;
    y ++;
    *((I *)(z->k) + tmp___1) = i___0;
    *((I *)s___0 + -1) = y;
    i___0 ++;
  }
  return (z);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#pragma merger("0","/tmp/cil-jSpxJmwj.i","-g,-pthread,-O3")
extern  __attribute__((__nothrow__)) void *mremap(void *__addr , size_t __old_len ,
                                                  size_t __new_len , int __flags 
                                                  , ...) ;
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat64)(int __ver ,
                                                                                       int __fildes ,
                                                                                       struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat64)(int __ver ,
                                                                                        char const   *__filename ,
                                                                                        struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat64)(int __ver ,
                                                                                         char const   *__filename ,
                                                                                         struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat64)(int __ver ,
                                                                                           int __fildes ,
                                                                                           char const   *__filename ,
                                                                                           struct stat64 *__stat_buf ,
                                                                                           int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat64)(char const   * __restrict  __path ,
                                                                                struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat64)(char const   * __restrict  __path ,
                                                                                 struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat64)(int __fd ,
                                                                               struct stat64 *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat64(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat64)(int __fd ,
                                                                                   char const   * __restrict  __filename ,
                                                                                   struct stat64 * __restrict  __statbuf ,
                                                                                   int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  return (tmp);
}
}
I PG  ;
I repool(V v , I r ) ;
I rp2(I v ) ;
K Kc(C x___0 ) ;
I cl2(I v ) ;
V KP[27]  ;
F mUsed  =    0.0;
F mAlloc  =    0.0;
F mMap  =    0.0;
F mMax  =    0.0;
static I kexpander(K *p , I n ) ;
static K kapn_(K *a , V v , I n ) ;
static V amem(I k , I r ) ;
static V kalloc(I k , I *r ) ;
static V unpool(I r ) ;
V alloc(size_t sz___0 ) 
{ 
  V r ;
  void *tmp ;

  {
  tmp = malloc(sz___0);
  r = tmp;
  if (! r) {
    fputs((char const   * __restrict  )"out of memory\n", (FILE * __restrict  )stderr);
    exit(1);
  }
  return (r);
}
}
I OOM_CD(I g  , ...) 
{ 
  va_list___0 a ;
  V v ;
  V o ;
  V tmp ;
  V tmp___0 ;

  {
  o = (V )-1;
  __builtin_va_start(a, g);
  while (1) {
    tmp = __builtin_va_arg(a, V );
    v = tmp;
    if (! ((unsigned long )o != (unsigned long )v)) {
      break;
    }
    if (! v) {
      g = (I )1;
    }
  }
  __builtin_va_end(a);
  if (! g) {
    return ((I )1);
  }
  __builtin_va_start(a, g);
  while (1) {
    tmp___0 = __builtin_va_arg(a, V );
    v = tmp___0;
    if (! ((unsigned long )o != (unsigned long )v)) {
      break;
    }
    cd((K )v);
  }
  __builtin_va_end(a);
  return ((I )0);
}
}
I rc(K x___0 ) 
{ 


  {
  return (x___0->_c >> 8);
}
}
static K ic(K x___0 ) 
{ 


  {
  x___0->_c += 256LL;
  return (x___0);
}
}
static K dc(K x___0 ) 
{ 


  {
  x___0->_c -= 256LL;
  return (x___0);
}
}
static I glsz(K x___0 ) 
{ 


  {
  return (255LL & x___0->_c);
}
}
static K slsz(K x___0 , I r ) 
{ 


  {
  x___0->_c = (I )((unsigned long long )x___0->_c & 18446744073709551360);
  x___0->_c |= r;
  return (x___0);
}
}
K mrc(K x___0 , I c ) 
{ 
  I k ;
  I tmp ;
  I r ;
  I tmp___0 ;

  {
  tmp = sz(x___0->t, x___0->n);
  k = tmp;
  tmp___0 = lsz(k);
  r = tmp___0;
  x___0->_c = (c << 8) | r;
  return (x___0);
}
}
K cd(K x___0 ) 
{ 
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I o ;
  I r ;
  I tmp ;
  I k ;
  I tmp___0 ;
  I s ;
  I res ;
  int tmp___1 ;
  K tmp___2 ;

  {
  if (! x___0) {
    return ((K )0);
  }
  dc(x___0);
  switch (x___0->t) {
  case 5LL: ;
  case 0LL: 
  i = (I )0;
  _i___0 = x___0->n;
  while (i < _i___0) {
    cd(x___0->k[(x___0->n - i) - 1LL]);
    i ++;
  }
  break;
  }
  if (x___0->_c > 255LL) {
    return (x___0);
  }
  switch (x___0->t) {
  case 7LL: 
  i___0 = (I )0;
  _i___1 = (I )6;
  while (i___0 < _i___1) {
    cd((K )*((V *)(x___0->k) + (2LL + i___0)));
    i___0 ++;
  }
  break;
  }
  o = (I )((unsigned long long )((size_t )x___0) & (unsigned long long )(PG - 1LL));
  tmp = glsz(x___0);
  r = tmp;
  if (o == 8LL) {
    goto _L;
  } else
  if (r > 26LL) {
    _L: /* CIL Label */ 
    tmp___0 = sz(x___0->t, x___0->n);
    k = tmp___0;
    s = k + o;
    tmp___1 = munmap((V )x___0 - o, (size_t )s);
    res = (I )tmp___1;
    if (res) {
      tmp___2 = kerr("munmap");
      return (tmp___2);
    }
    if (o == 8LL) {
      mMap -= (F )s;
    } else
    if (r > 26LL) {
      mAlloc -= (F )s;
    }
    mUsed -= (F )s;
  } else {
    repool((V )x___0, r);
  }
  return ((K )0);
}
}
K ci(K x___0 ) 
{ 
  I i ;
  I _i___0 ;

  {
  if (! x___0) {
    return ((K )0);
  }
  ic(x___0);
  switch (x___0->t) {
  case 5LL: ;
  case 0LL: 
  i = (I )0;
  _i___0 = x___0->n;
  while (i < _i___0) {
    ci(x___0->k[i]);
    i ++;
  }
  break;
  }
  return (x___0);
}
}
I bp(I t ) 
{ 
  I tmp ;

  {
  if (t < 0LL) {
    tmp = - t;
  } else {
    tmp = t;
  }
  switch (tmp) {
  case 1LL: 
  return ((I )sizeof(I ));
  case 2LL: 
  return ((I )sizeof(F ));
  case 3LL: 
  return ((I )sizeof(C ));
  default: 
  return ((I )sizeof(V ));
  }
}
}
I sz(I t , I n ) 
{ 
  I tmp ;
  I tmp___0 ;
  I tmp___1 ;

  {
  if (7LL == t) {
    tmp = (I )8;
  } else {
    tmp = n;
  }
  tmp___0 = bp(t);
  if (t < 0LL) {
    tmp___1 = - t;
  } else {
    tmp___1 = t;
  }
  return ((I )(((unsigned long long )(3UL * sizeof(I )) + (unsigned long long )(tmp * tmp___0)) + (unsigned long long )(3LL == tmp___1)));
}
}
static I nearPG(I i ) 
{ 
  I k ;
  I tmp ;

  {
  k = (I )((unsigned long long )((size_t )i) & (unsigned long long )(PG - 1LL));
  if (k) {
    tmp = (i + PG) - k;
  } else {
    tmp = i;
  }
  return (tmp);
}
}
K newK(I t , I n ) 
{ 
  K z ;
  K tmp ;
  I k ;
  I tmp___0 ;
  I r ;
  V tmp___1 ;
  K tmp___2 ;

  {
  if (n > 0LL) {
    if (n > 9223372036854775806LL) {
      tmp = kerr("wsfull");
      return (tmp);
    }
  }
  tmp___0 = sz(t, n);
  k = tmp___0;
  tmp___1 = kalloc(k, & r);
  z = (K )tmp___1;
  if (! z) {
    return ((K )0);
  }
  tmp___2 = slsz(z, r);
  ic(tmp___2);
  z->t = t;
  z->n = n;
  if (t == 6LL) {
    z->n = (I )0;
  }
  if (z->_c == 0LL) {
    z->_c = (I )256;
  }
  return (z);
}
}
static V kallocI(I k , I r ) 
{ 
  V tmp ;
  V tmp___0 ;

  {
  if (r > 26LL) {
    tmp = amem(k, r);
    return (tmp);
  }
  tmp___0 = unpool(r);
  return (tmp___0);
}
}
static V kalloc(I k , I *r ) 
{ 
  V tmp ;

  {
  *r = lsz(k);
  tmp = kallocI(k, *r);
  return (tmp);
}
}
static V amem(I k , I r ) 
{ 
  K z ;
  K tmp ;
  void *tmp___0 ;
  I tmp___1 ;

  {
  tmp___0 = mmap((void *)0, (size_t )k, 3, 34, -1, (__off_t )0);
  z = (K )tmp___0;
  if ((unsigned long )((void *)-1) == (unsigned long )z) {
    tmp = kerr("wsfull");
    return ((V )tmp);
  }
  if (k < PG) {
    tmp___1 = PG;
  } else {
    tmp___1 = k;
  }
  mAlloc += (F )tmp___1;
  if (r > 26LL) {
    mUsed += (F )k;
    if (mUsed > mMax) {
      mMax = mUsed;
    }
  }
  return ((V )z);
}
}
static V unpool(I r ) 
{ 
  V *z ;
  V *L___0 ;
  I k ;
  V tmp ;
  V y ;

  {
  L___0 = KP + r;
  k = 1LL << r;
  if (! *L___0) {
    goto _L;
  } else
  if ((unsigned long )((V )262) == (unsigned long )*L___0) {
    _L: /* CIL Label */ 
    tmp = amem(k, r);
    z = (V *)tmp;
    if (! z) {
      return ((V )0);
    }
    if (k < PG) {
      y = (V )z;
      while ((unsigned long )y < (unsigned long )(((V )z + PG) + - k)) {
        *((V *)y) = y + k;
        y += k;
      }
    }
    *L___0 = (V )z;
  }
  z = (V *)*L___0;
  *L___0 = *z;
  *z = (V )0;
  mUsed += (F )k;
  if (mUsed > mMax) {
    mMax = mUsed;
  }
  return ((V )z);
}
}
I cl2(I v ) 
{ 
  I e ;

  {
  if (! v) {
    return ((I )-1);
  }
  e = (I )0;
  if ((unsigned long long )v & ((unsigned long long )v - 1ULL)) {
    e = (I )1;
  }
  if ((unsigned long long )v & 4294901760ULL) {
    e += 16LL;
    v >>= 16;
  }
  if ((unsigned long long )v & 65280ULL) {
    e += 8LL;
    v >>= 8;
  }
  if ((unsigned long long )v & 240ULL) {
    e += 4LL;
    v >>= 4;
  }
  if ((unsigned long long )v & 12ULL) {
    e += 2LL;
    v >>= 2;
  }
  if ((unsigned long long )v & 2ULL) {
    e ++;
    v >>= 1;
  }
  return (e);
}
}
I lsz(I k ) 
{ 
  I tmp ;
  I tmp___0 ;

  {
  if (k <= 1LL << 6) {
    tmp___0 = (I )6;
  } else {
    tmp = cl2(k);
    tmp___0 = tmp;
  }
  return (tmp___0);
}
}
I repool(V v , I r ) 
{ 
  I k ;

  {
  k = 1LL << r;
  memset(v, 0, (size_t )k);
  *((V *)v) = KP[r];
  KP[r] = v;
  mUsed -= (F )k;
  return ((I )0);
}
}
static I kexpander(K *p , I n ) 
{ 
  K a ;
  I r ;
  I tmp ;
  V v ;
  I c ;
  I tmp___0 ;
  I d___0 ;
  I tmp___1 ;
  I e ;
  I tmp___2 ;
  I f ;
  V *w___0 ;
  void *tmp___3 ;
  I res ;
  int tmp___4 ;
  K tmp___5 ;
  I d___1 ;
  I tmp___6 ;
  I s ;
  I tmp___7 ;
  K x___0 ;
  V tmp___8 ;
  I c___0 ;
  I tmp___9 ;

  {
  a = *p;
  tmp = glsz(a);
  r = tmp;
  if (r > 26LL) {
    tmp___0 = sz(a->t, a->n);
    c = tmp___0;
    tmp___1 = sz(a->t, n);
    d___0 = tmp___1;
    tmp___2 = nearPG(c);
    e = tmp___2;
    f = d___0 - e;
    if (f <= 0LL) {
      return ((I )1);
    }
    tmp___3 = mremap((void *)a, (size_t )c, (size_t )d___0, 1);
    w___0 = (V *)tmp___3;
    if ((unsigned long )((void *)-1) != (unsigned long )w___0) {
      mAlloc += (F )(d___0 - c);
      mUsed += (F )(d___0 - c);
      if (mUsed > mMax) {
        mMax = mUsed;
      }
      *p = (K )w___0;
      return ((I )1);
    }
    v = amem(d___0, r);
    if (! v) {
      return ((I )0);
    }
    memcpy((void * __restrict  )v, (void const   * __restrict  )a, (size_t )c);
    *p = (K )v;
    tmp___4 = munmap((void *)a, (size_t )c);
    res = (I )tmp___4;
    if (res) {
      tmp___5 = kerr("munmap");
      show(tmp___5);
      return ((I )0);
    }
    mAlloc -= (F )c;
    mUsed -= (F )c;
    return ((I )1);
  }
  tmp___6 = sz(a->t, n);
  d___1 = tmp___6;
  if (d___1 <= (I )(1 << r)) {
    return ((I )1);
  }
  tmp___7 = lsz(d___1);
  s = tmp___7;
  tmp___8 = kallocI(d___1, s);
  x___0 = (K )tmp___8;
  if (! x___0) {
    return ((I )0);
  }
  tmp___9 = sz(a->t, a->n);
  c___0 = tmp___9;
  memcpy((void * __restrict  )x___0, (void const   * __restrict  )a, (size_t )c___0);
  *p = x___0;
  slsz(*p, s);
  repool((V )a, r);
  return ((I )1);
}
}
static K kap1_(K *a , V v ) 
{ 
  K k ;
  I t ;
  I m ;
  I p ;
  I tmp ;

  {
  k = *a;
  t = k->t;
  m = k->n;
  p = m + 1LL;
  tmp = kexpander(& k, p);
  if (! tmp) {
    return ((K )0);
  }
  if ((unsigned long )k != (unsigned long )*a) {
    *a = k;
  }
  k->n = p;
  switch (- t) {
  case 0LL: 
  k->k[m] = ci(*((K *)v + 0));
  break;
  case 1LL: 
  *((I *)(k->k) + m) = *((I *)v);
  break;
  case 2LL: 
  *((F *)(k->k) + m) = *((F *)v);
  break;
  case 3LL: 
  *((C *)(k->k) + m) = *((C *)v);
  *((C *)(k->k) + p) = (C )0;
  break;
  case 4LL: 
  *((S *)(k->k) + m) = *((S *)v);
  break;
  default: 
  return ((K )0);
  }
  return (k);
}
}
static K kapn_(K *a , V v , I n ) 
{ 
  K k ;
  I t ;
  I m ;
  I p ;
  K z ;
  K tmp ;
  K *zv ;
  K *tmp___0 ;
  I i ;
  I _i___0 ;
  I tmp___1 ;
  I tmp___2 ;
  I i___0 ;
  I _i___1 ;

  {
  if (! a) {
    return ((K )0);
  } else
  if (! n) {
    return ((K )0);
  }
  k = *a;
  t = k->t;
  m = k->n;
  p = m + n;
  if (6LL == t) {
    tmp = newK((I )0, p);
    z = tmp;
    if (! z) {
      return ((K )0);
    }
    zv = z->k;
    tmp___0 = zv;
    zv ++;
    *tmp___0 = _n();
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      *(zv + i) = _n();
      i ++;
    }
    cd(k);
    *a = z;
    return (z);
  }
  tmp___1 = kexpander(& k, p);
  if (! tmp___1) {
    return ((K )0);
  }
  if ((unsigned long )k != (unsigned long )*a) {
    *a = k;
  }
  k->n = p;
  if (t < 0LL) {
    tmp___2 = - t;
  } else {
    tmp___2 = t;
  }
  switch (tmp___2) {
  case 0LL: ;
  case 5LL: 
  i___0 = (I )0;
  _i___1 = n;
  while (i___0 < _i___1) {
    k->k[i___0 + m] = ci(*((K *)v + i___0));
    i___0 ++;
  }
  break;
  case 1LL: 
  memcpy((void * __restrict  )((I *)(k->k) + m), (void const   * __restrict  )v, (size_t )((unsigned long long )n * (unsigned long long )sizeof(I )));
  break;
  case 2LL: 
  memcpy((void * __restrict  )((F *)(k->k) + m), (void const   * __restrict  )v, (size_t )((unsigned long long )n * (unsigned long long )sizeof(F )));
  break;
  case 3LL: 
  strncpy((char * __restrict  )((C *)(k->k) + m), (char const   * __restrict  )((S )v),
          (size_t )n);
  *((C *)(k->k) + p) = (C )0;
  break;
  case 4LL: 
  memcpy((void * __restrict  )((S *)(k->k) + m), (void const   * __restrict  )v, (size_t )((unsigned long long )n * (unsigned long long )sizeof(S )));
  break;
  default: 
  return ((K )0);
  }
  if (t > 0LL) {
    if (t < 5LL) {
      if (p > 1LL) {
        k->t *= -1LL;
      }
    }
  }
  return (*a);
}
}
extern K kapn(K *a , V v , I n ) 
{ 
  K tmp ;

  {
  tmp = kapn_(a, v, n);
  return (tmp);
}
}
extern K kap(K *a , V v ) 
{ 
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;

  {
  if (! a) {
    return ((K )0);
  }
  if (0LL < (*a)->t) {
    tmp = kapn_(a, v, (I )1);
    tmp___1 = tmp;
  } else {
    tmp___0 = kap1_(a, v);
    tmp___1 = tmp___0;
  }
  return (tmp___1);
}
}
N newN(void) 
{ 
  I tmp ;
  V tmp___0 ;

  {
  tmp = lsz((I )sizeof(Node ));
  tmp___0 = unpool(tmp);
  return ((N )tmp___0);
}
}
PDA newPDA(void) 
{ 
  PDA p ;
  I tmp ;
  V tmp___0 ;
  V tmp___1 ;

  {
  tmp = lsz((I )sizeof(Pda ));
  tmp___0 = unpool(tmp);
  p = (PDA )tmp___0;
  if (! p) {
    return ((PDA )0);
  }
  tmp___1 = alloc((size_t )1);
  p->c = (S )tmp___1;
  if (! p->c) {
    kerr("wsfull");
    return ((PDA )0);
  }
  return (p);
}
}
I push(PDA p , C c ) 
{ 
  I tmp ;

  {
  tmp = appender(& p->c, & p->n, & c, (I )1);
  return (tmp);
}
}
C peek(PDA p ) 
{ 
  I n ;
  int tmp ;

  {
  n = p->n;
  if (n) {
    tmp = (int )*(p->c + (n - 1LL));
  } else {
    tmp = 0;
  }
  return ((C )tmp);
}
}
C pop(PDA p ) 
{ 
  int tmp ;

  {
  if (p->n > 0LL) {
    (p->n) --;
    tmp = (int )*(p->c + p->n);
  } else {
    tmp = 0;
  }
  return ((C )tmp);
}
}
C bottom(PDA p ) 
{ 
  int tmp ;

  {
  if (p->n > 0LL) {
    tmp = (int )*(p->c + 0);
  } else {
    tmp = 0;
  }
  return ((C )tmp);
}
}
void pdafree(PDA p ) 
{ 
  I tmp ;

  {
  free((void *)p->c);
  tmp = lsz((I )sizeof(PDA ));
  repool((V )p, tmp);
  return;
}
}
K Ki(I x___0 ) 
{ 
  K z ;
  K tmp ;

  {
  tmp = newK((I )1, (I )1);
  z = tmp;
  *((I *)(z->k)) = x___0;
  return (z);
}
}
K Kf(F x___0 ) 
{ 
  K z ;
  K tmp ;

  {
  tmp = newK((I )2, (I )1);
  z = tmp;
  *((F *)(z->k)) = x___0;
  return (z);
}
}
K Kc(C x___0 ) 
{ 
  K z ;
  K tmp ;

  {
  tmp = newK((I )3, (I )1);
  z = tmp;
  *((C *)(z->k)) = x___0;
  return (z);
}
}
K Ks(S x___0 ) 
{ 
  K z ;
  K tmp ;

  {
  if (! x___0) {
    return ((K )0);
  }
  tmp = newK((I )4, (I )1);
  z = tmp;
  *((S *)(z->k)) = x___0;
  return (z);
}
}
K Kd(void) 
{ 
  K tmp ;

  {
  tmp = newK((I )5, (I )0);
  return (tmp);
}
}
K Kn(void) 
{ 
  K tmp ;

  {
  tmp = newK((I )6, (I )1);
  return (tmp);
}
}
K Kv(void) 
{ 
  K z ;
  K tmp ;
  V tmp___0 ;
  K tmp___1 ;
  V tmp___2 ;
  K tmp___3 ;
  I tmp___4 ;

  {
  tmp = newK((I )7, (I )8);
  z = tmp;
  if (! z) {
    return ((K )0);
  }
  z->n = (I )1;
  *((V *)(z->k) + 0) = (V )d_;
  tmp___1 = Kd();
  tmp___0 = (V )tmp___1;
  *((V *)(z->k) + 3) = tmp___0;
  tmp___3 = Kd();
  tmp___2 = (V )tmp___3;
  *((V *)(z->k) + 4) = tmp___2;
  tmp___4 = OOM_CD((I )0, z, tmp___2, tmp___0, (V )-1);
  if (! tmp___4) {
    return ((K )0);
  }
  return (z);
}
}
K newEntry(S s ) 
{ 
  K tmp ;
  K tmp___0 ;

  {
  tmp = _n();
  tmp___0 = newE(s, tmp);
  return (tmp___0);
}
}
K newE(S s , K k ) 
{ 
  K z ;
  K tmp ;
  I tmp___0 ;

  {
  tmp = newK((I )0, (I )3);
  z = tmp;
  if (! z) {
    return ((K )0);
  }
  z->k[0] = Ks(s);
  z->k[1] = k;
  z->k[2] = _n();
  tmp___0 = OOM_CD((I )0, z, z->k[0], z->k[2], (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  return (z);
}
}
I rp2(I v ) 
{ 
  I tmp ;

  {
  v --;
  v |= v >> 1;
  v |= v >> 2;
  v |= v >> 4;
  v |= v >> 8;
  v |= v >> 16;
  if (sizeof(V ) >= 8UL) {
    v |= v >> 32;
  }
  v ++;
  if (1LL > v) {
    tmp = (I )1;
  } else {
    tmp = v;
  }
  return (tmp);
}
}
K mstat(void) 
{ 
  K ks ;
  K tmp ;
  I tmp___0 ;
  I *s ;

  {
  tmp = newK((I )-1, (I )4);
  ks = tmp;
  tmp___0 = OOM_CD((I )0, ks, (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  s = (I *)(ks->k);
  *(s + 0) = (I )mUsed;
  *(s + 1) = (I )mAlloc;
  *(s + 2) = (I )mMap;
  *(s + 3) = (I )mMax;
  return (ks);
}
}
#pragma merger("0","/tmp/cil-clU6Szro.i","-g,-pthread,-O3")
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
void *get_in_addr(struct sockaddr *sa ) ;
M0 CP[1025]  ;
static I close_tape(I i , I sockfd ) ;
static K modified_execute(K x___0 ) ;
K KONA_WHO  ;
K KONA_PORT  ;
K KONA_CLIENT  ;
void nfinish(void) 
{ 


  {
  return;
}
}
static I _done  =    (I )0;
I ninit(void) 
{ 


  {
  if (! _done) {
    _done = (I )1;
  }
  return (_done);
}
}
void *get_in_addr(struct sockaddr *sa ) 
{ 


  {
  if ((int )sa->sa_family == 2) {
    return ((void *)(& ((struct sockaddr_in *)sa)->sin_addr));
  }
  return ((void *)(& ((struct sockaddr_in6 *)sa)->sin6_addr));
}
}
static I _oldw  ;
static I _oldc  ;
static void mhbegin(I i ) 
{ 


  {
  _oldw = *((I *)(KONA_WHO->k));
  _oldc = *((I *)(KONA_CLIENT->k));
  *((I *)(KONA_WHO->k)) = i;
  *((I *)(KONA_CLIENT->k)) = CP[i].a;
  return;
}
}
static void mhend(void) 
{ 


  {
  *((I *)(KONA_WHO->k)) = _oldw;
  *((I *)(KONA_CLIENT->k)) = _oldc;
  return;
}
}
I wipe_tape(I i ) 
{ 
  I a ;

  {
  a = CP[i].a;
  if (CP[i].k) {
    cd(CP[i].k);
  }
  memset((void *)(& CP[i]), 0, sizeof(CP[0]));
  CP[i].a = a;
  return ((I )0);
}
}
static I close_tape(I i , I sockfd ) 
{ 
  I r ;
  int tmp ;
  K tmp___0 ;
  K x___0 ;
  K *tmp___1 ;
  I tmp___2 ;

  {
  mhbegin(i);
  wipe_tape(i);
  CP[i].a = (I )0;
  tmp = close((int )sockfd);
  r = (I )tmp;
  if (r) {
    tmp___0 = kerr("file");
    show(tmp___0);
    r = (I )0;
  }
  master.__fds_bits[sockfd / (I )(8 * (int )sizeof(__fd_mask ))] &= ~ ((__fd_mask )(1UL << sockfd % (long long )(8 * (int )sizeof(__fd_mask ))));
  tmp___1 = denameS((S )".", (S )".m.c", (I )0);
  x___0 = *tmp___1;
  if (6LL == x___0->t) {
    r = (I )0;
    goto cleanup;
  }
  if (x___0->t < 0LL) {
    tmp___2 = - x___0->t;
  } else {
    tmp___2 = x___0->t;
  }
  if (3LL != tmp___2) {
    r = (I )1;
    printf((char const   * __restrict  )"type error");
    goto cleanup;
  }
  KX(x___0);
  cleanup: 
  mhend();
  return (r);
}
}
C bx[128]  = {      (C )0};
C by[128]  = {      (C )0};
static K modified_execute(K x___0 ) 
{ 
  int tmp ;
  K a ;
  S tmp___0 ;
  I tmp___1 ;
  int tmp___2 ;
  K tmp___3 ;

  {
  tmp = pthread_mutex_lock(& execute_mutex);
  if (tmp) {
    perror("Lock mutex in mod_ex()");
    abort();
  }
  a = (K )-1;
  if (4LL == x___0->t) {
    tmp___0 = CSK(x___0);
    a = X(tmp___0);
  } else {
    if (x___0->t < 0LL) {
      tmp___1 = - x___0->t;
    } else {
      tmp___1 = x___0->t;
    }
    if (3LL == tmp___1) {
      tmp___0 = CSK(x___0);
      a = X(tmp___0);
    }
  }
  if (! x___0->t) {
    if (x___0->n > 0LL) {
      a = vf_ex(offsetDot, x___0);
    }
  }
  if ((unsigned long )((K )-1) != (unsigned long )a) {
    tmp___2 = pthread_mutex_unlock(& execute_mutex);
    if (tmp___2) {
      perror("Unlock mutex in mod_ex()");
      abort();
    }
    return (a);
  }
  tmp___3 = ci(x___0);
  return (tmp___3);
}
}
K read_tape(I i , I j , I type ) 
{ 
  I nbytes ;
  I n ;
  C bz[128] ;
  unsigned int tmp ;
  C bn[1] ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  K h ;
  K *tmp___3 ;
  I n___0 ;
  int tmp___4 ;
  K tmp___5 ;
  size_t tmp___6 ;
  S f ;
  I ax ;
  I ay ;
  I az ;
  I sf ;
  size_t tmp___7 ;
  I i___0 ;
  I _i___0 ;
  I na ;
  I tmp___8 ;
  I sbx ;
  size_t tmp___9 ;
  I sby ;
  size_t tmp___10 ;
  I sbz ;
  size_t tmp___11 ;
  C tmp___12 ;
  C tmp___13 ;
  C tmp___14 ;
  C tmp___15 ;
  C tmp___16 ;
  C tmp___17 ;
  I i___1 ;
  I _i___1 ;
  I i___2 ;
  I _i___2 ;
  I i___3 ;
  I _i___3 ;
  I i___4 ;
  I _i___4 ;
  K r ;
  K tmp___18 ;
  I w___0 ;
  int tmp___19 ;
  C tmp___20 ;
  C tmp___21 ;
  int tmp___22 ;
  C tmp___23 ;
  C tmp___24 ;
  int tmp___25 ;
  C tmp___26 ;
  C tmp___27 ;
  int tmp___28 ;
  C tmp___29 ;
  C tmp___30 ;
  int tmp___31 ;
  K tmp___32 ;
  size_t tmp___33 ;
  I sbx___0 ;
  size_t tmp___34 ;
  I sby___0 ;
  size_t tmp___35 ;
  C tmp___36 ;
  C tmp___37 ;
  C tmp___38 ;
  I i___5 ;
  I _i___5 ;
  I i___6 ;
  I _i___6 ;
  I i___7 ;
  I _i___7 ;
  K r___0 ;
  K tmp___39 ;
  I w___1 ;
  int tmp___40 ;
  C tmp___41 ;
  C tmp___42 ;
  int tmp___43 ;
  C tmp___44 ;
  C tmp___45 ;
  int tmp___46 ;
  C tmp___47 ;
  C tmp___48 ;
  int tmp___49 ;
  C tmp___50 ;
  C tmp___51 ;
  int tmp___52 ;
  K tmp___53 ;
  size_t tmp___54 ;
  I sbx___1 ;
  size_t tmp___55 ;
  C tmp___56 ;
  I i___8 ;
  I _i___8 ;
  I i___9 ;
  I _i___9 ;
  K r___1 ;
  K tmp___57 ;
  int tmp___58 ;
  I w___2 ;
  int tmp___59 ;
  C tmp___60 ;
  C tmp___61 ;
  int tmp___62 ;
  C tmp___63 ;
  C tmp___64 ;
  int tmp___65 ;
  C tmp___66 ;
  C tmp___67 ;
  int tmp___68 ;
  C tmp___69 ;
  C tmp___70 ;
  int tmp___71 ;
  K tmp___72 ;
  size_t tmp___73 ;
  I u ;
  I a ;
  I c___2 ;
  I m ;
  I g ;
  K z ;
  S b___1 ;
  S tmp___74 ;
  ssize_t tmp___75 ;
  K k ;
  K tmp___76 ;
  K tmp___77 ;
  M1 *p ;
  I msg_type ;
  K h___0 ;
  K tmp___78 ;
  K tmp___79 ;
  K s ;
  K r___2 ;
  K tmp___80 ;
  K tmp___81 ;
  I tmp___82 ;
  K m___0 ;
  char const   *tmp___83 ;
  K *tmp___84 ;
  K tmp___85 ;
  K u___0 ;
  K tmp___86 ;
  K s___0 ;
  K tmp___87 ;
  I tmp___88 ;
  size_t tmp___89 ;
  I tmp___90 ;

  {
  nbytes = (I )0;
  n = (I )0;
  bz[0] = (C )0;
  tmp = 1U;
  while (! (tmp >= 128U)) {
    bz[tmp] = (char)0;
    tmp ++;
  }
  bn[0] = (C )0;
  if (HTTP_PORT) {
    if ((int )bx[0] == 0) {
      tmp___0 = recv((int )j, (void *)(bx), (size_t )128, 0);
      nbytes = (I )tmp___0;
    } else
    if ((int )by[0] == 0) {
      tmp___1 = recv((int )j, (void *)(by), (size_t )128, 0);
      nbytes = (I )tmp___1;
    } else {
      tmp___2 = recv((int )j, (void *)(bz), (size_t )128, 0);
      nbytes = (I )tmp___2;
    }
    if (nbytes <= 0LL) {
      if (nbytes == 0LL) {
        printf((char const   * __restrict  )"server: socket %lld hung up\n", j);
      } else {
        perror("recv");
      }
      goto cleanup;
    }
    tmp___3 = denameS((S )".", (S )".m.h", (I )0);
    h = *tmp___3;
    if (6LL == h->t) {
      send((int )j, (void const   *)(bx), (size_t )nbytes, 0);
      bx[0] = (C )'\000';
      close_tape(i, j);
      return ((K )0);
    } else
    if (7LL != h->t) {
      if (3LL != h->n) {
        tmp___4 = snprintf((char * __restrict  )(bx), (size_t )128, (char const   * __restrict  )"%s",
                           ".m.h is not type 7-3");
        n___0 = (I )tmp___4;
        if (n___0 >= 128LL) {
          tmp___5 = kerr("write");
          return (tmp___5);
        }
        tmp___6 = strlen((char const   *)(bx));
        send((int )j, (void const   *)(bx), tmp___6, 0);
        bx[0] = (C )'\000';
        close_tape(i, j);
        return ((K )0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      f = (C *)((h->k[2])->k);
      ax = (I )0;
      ay = (I )0;
      az = (I )0;
      tmp___7 = strlen((char const   *)f);
      sf = (I )tmp___7;
      i___0 = (I )0;
      _i___0 = sf;
      while (i___0 < _i___0) {
        if ((int )*(f + i___0) == 120) {
          ax = (I )1;
        } else
        if ((int )*(f + i___0) == 121) {
          ay = (I )1;
        } else
        if ((int )*(f + i___0) == 122) {
          az = (I )1;
        }
        i___0 ++;
      }
      tmp___8 = maX((I )1, (ax + ay) + az);
      na = tmp___8;
      if (na == 3LL) {
        if ((int )bz[0] == 0) {
          send((int )j, (void const   *)(bn), (size_t )1, 0);
          close_tape(i, j);
          return ((K )0);
        } else {
          n = (I )0;
          while (n < 128LL) {
            if ((int )bx[n] == 13) {
              break;
            } else
            if ((int )bx[n] == 0) {
              break;
            }
            n ++;
          }
          bx[n] = (C )'\000';
          n = (I )0;
          while (n < 128LL) {
            if ((int )by[n] == 13) {
              break;
            } else
            if ((int )by[n] == 0) {
              break;
            }
            n ++;
          }
          by[n] = (C )'\000';
          n = (I )0;
          while (n < 128LL) {
            if ((int )bz[n] == 13) {
              break;
            }
            n ++;
          }
          bz[n] = (C )'\000';
          tmp___9 = strlen((char const   *)(bx));
          sbx = (I )tmp___9;
          tmp___10 = strlen((char const   *)(by));
          sby = (I )tmp___10;
          tmp___11 = strlen((char const   *)(bz));
          sbz = (I )tmp___11;
          C c[(((13LL + sf) + sbx) + sby) + sbz] ;
          c[0] = (C )'{';
          c[1LL + sf] = (C )'}';
          c[2LL + sf] = (C )'[';
          c[(((11LL + sf) + sbx) + sby) + sbz] = (C )']';
          tmp___16 = (C )'\"';
          c[(((10LL + sf) + sbx) + sby) + sbz] = tmp___16;
          tmp___15 = tmp___16;
          c[((9LL + sf) + sbx) + sby] = tmp___15;
          tmp___14 = tmp___15;
          c[((7LL + sf) + sbx) + sby] = tmp___14;
          tmp___13 = tmp___14;
          c[(6LL + sf) + sbx] = tmp___13;
          tmp___12 = tmp___13;
          c[(4LL + sf) + sbx] = tmp___12;
          c[3LL + sf] = tmp___12;
          tmp___17 = (C )';';
          c[((8LL + sf) + sbx) + sby] = tmp___17;
          c[(5LL + sf) + sbx] = tmp___17;
          c[(((12LL + sf) + sbx) + sby) + sbz] = (C )'\000';
          i___1 = (I )0;
          _i___1 = sf;
          while (i___1 < _i___1) {
            c[1LL + i___1] = *(f + i___1);
            i___1 ++;
          }
          i___2 = (I )0;
          _i___2 = sbx;
          while (i___2 < _i___2) {
            c[(4LL + sf) + i___2] = bx[i___2];
            i___2 ++;
          }
          i___3 = (I )0;
          _i___3 = sby;
          while (i___3 < _i___3) {
            c[((7LL + sf) + sbx) + i___3] = by[i___3];
            i___3 ++;
          }
          i___4 = (I )0;
          _i___4 = sbz;
          while (i___4 < _i___4) {
            c[(((10LL + sf) + sbx) + sby) + i___4] = bz[i___4];
            i___4 ++;
          }
          tmp___18 = X(c);
          r = tmp___18;
          w___0 = (I )128;
          C bck[w___0] ;
          switch (r->t) {
          case 1LL: 
          tmp___19 = snprintf((char * __restrict  )(bck), (size_t )w___0, (char const   * __restrict  )"%lld",
                              *((I *)(r->k)));
          n = (I )tmp___19;
          if (n >= w___0) {
            tmp___21 = (C )'.';
            bck[w___0 - 2LL] = tmp___21;
            tmp___20 = tmp___21;
            bck[w___0 - 3LL] = tmp___20;
            bck[w___0 - 4LL] = tmp___20;
          }
          break;
          case 2LL: 
          tmp___22 = snprintf((char * __restrict  )(bck), (size_t )w___0, (char const   * __restrict  )"%f",
                              *((F *)(r->k)));
          n = (I )tmp___22;
          if (n >= w___0) {
            tmp___24 = (C )'.';
            bck[w___0 - 2LL] = tmp___24;
            tmp___23 = tmp___24;
            bck[w___0 - 3LL] = tmp___23;
            bck[w___0 - 4LL] = tmp___23;
          }
          break;
          case 3LL: 
          tmp___25 = snprintf((char * __restrict  )(bck), (size_t )w___0, (char const   * __restrict  )"%s",
                              (C *)(r->k));
          n = (I )tmp___25;
          if (n >= w___0) {
            tmp___27 = (C )'.';
            bck[w___0 - 2LL] = tmp___27;
            tmp___26 = tmp___27;
            bck[w___0 - 3LL] = tmp___26;
            bck[w___0 - 4LL] = tmp___26;
          }
          break;
          case -3LL: 
          tmp___28 = snprintf((char * __restrict  )(bck), (size_t )w___0, (char const   * __restrict  )"%s",
                              (C *)(r->k));
          n = (I )tmp___28;
          if (n >= w___0) {
            tmp___30 = (C )'.';
            bck[w___0 - 2LL] = tmp___30;
            tmp___29 = tmp___30;
            bck[w___0 - 3LL] = tmp___29;
            bck[w___0 - 4LL] = tmp___29;
          }
          break;
          default: 
          tmp___31 = snprintf((char * __restrict  )(bck), (size_t )w___0, (char const   * __restrict  )"%s",
                              "NYI: .m.h result of that type and count");
          n = (I )tmp___31;
          if (n >= w___0) {
            tmp___32 = kerr("write");
            return (tmp___32);
          }
          }
          tmp___33 = strlen((char const   *)(bck));
          send((int )j, (void const   *)(bck), tmp___33, 0);
          bx[0] = (C )'\000';
          by[0] = (C )'\000';
          close_tape(i, j);
          return ((K )0);
        }
      }
      if (na == 2LL) {
        if ((int )by[0] == 0) {
          send((int )j, (void const   *)(bn), (size_t )1, 0);
          close_tape(i, j);
          return ((K )0);
        } else {
          n = (I )0;
          while (n < 128LL) {
            if ((int )bx[n] == 13) {
              break;
            }
            n ++;
          }
          bx[n] = (C )'\000';
          n = (I )0;
          while (n < 128LL) {
            if ((int )by[n] == 13) {
              break;
            }
            n ++;
          }
          by[n] = (C )'\000';
          tmp___34 = strlen((char const   *)(bx));
          sbx___0 = (I )tmp___34;
          tmp___35 = strlen((char const   *)(by));
          sby___0 = (I )tmp___35;
          C c___0[((10LL + sf) + sbx___0) + sby___0] ;
          c___0[0] = (C )'{';
          c___0[1LL + sf] = (C )'}';
          c___0[2LL + sf] = (C )'[';
          c___0[((8LL + sf) + sbx___0) + sby___0] = (C )']';
          tmp___38 = (C )'\"';
          c___0[((7LL + sf) + sbx___0) + sby___0] = tmp___38;
          tmp___37 = tmp___38;
          c___0[(6LL + sf) + sbx___0] = tmp___37;
          tmp___36 = tmp___37;
          c___0[(4LL + sf) + sbx___0] = tmp___36;
          c___0[3LL + sf] = tmp___36;
          c___0[(5LL + sf) + sbx___0] = (C )';';
          c___0[((9LL + sf) + sbx___0) + sby___0] = (C )'\000';
          i___5 = (I )0;
          _i___5 = sf;
          while (i___5 < _i___5) {
            c___0[1LL + i___5] = *(f + i___5);
            i___5 ++;
          }
          i___6 = (I )0;
          _i___6 = sbx___0;
          while (i___6 < _i___6) {
            c___0[(4LL + sf) + i___6] = bx[i___6];
            i___6 ++;
          }
          i___7 = (I )0;
          _i___7 = sby___0;
          while (i___7 < _i___7) {
            c___0[((7LL + sf) + sbx___0) + i___7] = by[i___7];
            i___7 ++;
          }
          tmp___39 = X(c___0);
          r___0 = tmp___39;
          w___1 = (I )128;
          C bck___0[w___1] ;
          switch (r___0->t) {
          case 1LL: 
          tmp___40 = snprintf((char * __restrict  )(bck___0), (size_t )w___1, (char const   * __restrict  )"%lld",
                              *((I *)(r___0->k)));
          n = (I )tmp___40;
          if (n >= w___1) {
            tmp___42 = (C )'.';
            bck___0[w___1 - 2LL] = tmp___42;
            tmp___41 = tmp___42;
            bck___0[w___1 - 3LL] = tmp___41;
            bck___0[w___1 - 4LL] = tmp___41;
          }
          break;
          case 2LL: 
          tmp___43 = snprintf((char * __restrict  )(bck___0), (size_t )w___1, (char const   * __restrict  )"%f",
                              *((F *)(r___0->k)));
          n = (I )tmp___43;
          if (n >= w___1) {
            tmp___45 = (C )'.';
            bck___0[w___1 - 2LL] = tmp___45;
            tmp___44 = tmp___45;
            bck___0[w___1 - 3LL] = tmp___44;
            bck___0[w___1 - 4LL] = tmp___44;
          }
          break;
          case 3LL: 
          tmp___46 = snprintf((char * __restrict  )(bck___0), (size_t )w___1, (char const   * __restrict  )"%s",
                              (C *)(r___0->k));
          n = (I )tmp___46;
          if (n >= w___1) {
            tmp___48 = (C )'.';
            bck___0[w___1 - 2LL] = tmp___48;
            tmp___47 = tmp___48;
            bck___0[w___1 - 3LL] = tmp___47;
            bck___0[w___1 - 4LL] = tmp___47;
          }
          break;
          case -3LL: 
          tmp___49 = snprintf((char * __restrict  )(bck___0), (size_t )w___1, (char const   * __restrict  )"%s",
                              (C *)(r___0->k));
          n = (I )tmp___49;
          if (n >= w___1) {
            tmp___51 = (C )'.';
            bck___0[w___1 - 2LL] = tmp___51;
            tmp___50 = tmp___51;
            bck___0[w___1 - 3LL] = tmp___50;
            bck___0[w___1 - 4LL] = tmp___50;
          }
          break;
          default: 
          tmp___52 = snprintf((char * __restrict  )(bck___0), (size_t )w___1, (char const   * __restrict  )"%s",
                              "NYI: .m.h result of that type and count");
          n = (I )tmp___52;
          if (n >= w___1) {
            tmp___53 = kerr("write");
            return (tmp___53);
          }
          }
          tmp___54 = strlen((char const   *)(bck___0));
          send((int )j, (void const   *)(bck___0), tmp___54, 0);
          bx[0] = (C )'\000';
          by[0] = (C )'\000';
          close_tape(i, j);
          return ((K )0);
        }
      }
      n = (I )0;
      while (n < 128LL) {
        if ((int )bx[n] == 13) {
          break;
        } else
        if ((int )bx[n] == 0) {
          break;
        }
        n ++;
      }
      bx[n] = (C )'\000';
      tmp___55 = strlen((char const   *)(bx));
      sbx___1 = (I )tmp___55;
      C c___1[(7LL + sf) + sbx___1] ;
      c___1[0] = (C )'{';
      c___1[1LL + sf] = (C )'}';
      c___1[2LL + sf] = (C )'[';
      c___1[(5LL + sf) + sbx___1] = (C )']';
      tmp___56 = (C )'\"';
      c___1[(4LL + sf) + sbx___1] = tmp___56;
      c___1[3LL + sf] = tmp___56;
      c___1[(6LL + sf) + sbx___1] = (C )'\000';
      i___8 = (I )0;
      _i___8 = sf;
      while (i___8 < _i___8) {
        c___1[1LL + i___8] = *(f + i___8);
        i___8 ++;
      }
      i___9 = (I )0;
      _i___9 = sbx___1;
      while (i___9 < _i___9) {
        c___1[(4LL + sf) + i___9] = bx[i___9];
        i___9 ++;
      }
      tmp___57 = X(c___1);
      r___1 = tmp___57;
      tmp___58 = strcmp((char const   *)(errmsg), "(nil)");
      if (tmp___58) {
        oerr();
        goto cleanup;
      }
      w___2 = (I )128;
      C bck___1[w___2] ;
      switch (r___1->t) {
      case 1LL: 
      tmp___59 = snprintf((char * __restrict  )(bck___1), (size_t )w___2, (char const   * __restrict  )"%lld",
                          *((I *)(r___1->k)));
      n = (I )tmp___59;
      if (n >= w___2) {
        tmp___61 = (C )'.';
        bck___1[w___2 - 2LL] = tmp___61;
        tmp___60 = tmp___61;
        bck___1[w___2 - 3LL] = tmp___60;
        bck___1[w___2 - 4LL] = tmp___60;
      }
      break;
      case 2LL: 
      tmp___62 = snprintf((char * __restrict  )(bck___1), (size_t )w___2, (char const   * __restrict  )"%f",
                          *((F *)(r___1->k)));
      n = (I )tmp___62;
      if (n >= w___2) {
        tmp___64 = (C )'.';
        bck___1[w___2 - 2LL] = tmp___64;
        tmp___63 = tmp___64;
        bck___1[w___2 - 3LL] = tmp___63;
        bck___1[w___2 - 4LL] = tmp___63;
      }
      break;
      case 3LL: 
      tmp___65 = snprintf((char * __restrict  )(bck___1), (size_t )w___2, (char const   * __restrict  )"%s",
                          (C *)(r___1->k));
      n = (I )tmp___65;
      if (n >= w___2) {
        tmp___67 = (C )'.';
        bck___1[w___2 - 2LL] = tmp___67;
        tmp___66 = tmp___67;
        bck___1[w___2 - 3LL] = tmp___66;
        bck___1[w___2 - 4LL] = tmp___66;
      }
      break;
      case -3LL: 
      tmp___68 = snprintf((char * __restrict  )(bck___1), (size_t )w___2, (char const   * __restrict  )"%s",
                          (C *)(r___1->k));
      n = (I )tmp___68;
      if (n >= w___2) {
        tmp___70 = (C )'.';
        bck___1[w___2 - 2LL] = tmp___70;
        tmp___69 = tmp___70;
        bck___1[w___2 - 3LL] = tmp___69;
        bck___1[w___2 - 4LL] = tmp___69;
      }
      break;
      default: 
      tmp___71 = snprintf((char * __restrict  )(bck___1), (size_t )w___2, (char const   * __restrict  )"%s",
                          "NYI: .m.h result of that type and count");
      n = (I )tmp___71;
      if (n >= w___2) {
        tmp___72 = kerr("write");
        return (tmp___72);
      }
      }
      tmp___73 = strlen((char const   *)(bck___1));
      send((int )j, (void const   *)(bck___1), tmp___73, 0);
      bx[0] = (C )'\000';
      by[0] = (C )'\000';
      close_tape(i, j);
      return ((K )0);
    }
  }
  u = (I )1;
  a = (I )*((S )(& u));
  c___2 = CP[i].r;
  m = (I )sizeof(M1 );
  z = (K )0;
  if (c___2 < m) {
    tmp___74 = (S )(& CP[i].m1) + c___2;
  } else {
    tmp___74 = (C *)((CP[i].k)->k) + c___2;
  }
  b___1 = tmp___74;
  if (c___2 < m) {
    g = m - c___2;
  } else {
    g = CP[i].m1.n;
  }
  tmp___75 = recv((int )j, (void *)b___1, (size_t )g, 0);
  nbytes = (I )tmp___75;
  if (nbytes <= 0LL) {
    if (! (nbytes == 0LL)) {
      perror("recv");
    }
    goto cleanup;
  }
  CP[i].r += nbytes;
  if (m == CP[i].r) {
    if (a != (I )CP[i].m1.a) {
      CP[i].m1.n = bswapI(CP[i].m1.n);
    }
    tmp___76 = newK((I )-3, m + CP[i].m1.n);
    k = tmp___76;
    tmp___77 = k;
    CP[i].k = tmp___77;
    if (! tmp___77) {
      goto cleanup;
    }
    memcpy((void * __restrict  )((C *)(k->k)), (void const   * __restrict  )(& CP[i].m1),
           (size_t )m);
  }
  if (CP[i].r == m + CP[i].m1.n) {
    p = (M1 *)((V )((C *)((CP[i].k)->k)));
    msg_type = (I )p->d;
    tmp___78 = _db(CP[i].k);
    h___0 = tmp___78;
    if (! h___0) {
      goto cleanup;
    }
    wipe_tape(i);
    if (2LL == msg_type) {
      if (1LL == type) {
        if (h___0->t) {
          tmp___79 = kerr("nonce");
          return (tmp___79);
        } else
        if (2LL != h___0->n) {
          tmp___79 = kerr("nonce");
          return (tmp___79);
        }
        s = h___0->k[0];
        r___2 = h___0->k[1];
        if (1LL != s->t) {
          tmp___80 = kerr("nonce");
          return (tmp___80);
        }
        if (*((I *)(s->k))) {
          if (r___2->t < 0LL) {
            tmp___82 = - r___2->t;
          } else {
            tmp___82 = r___2->t;
          }
          if (3LL != tmp___82) {
            tmp___81 = kerr("nonce");
            return (tmp___81);
          }
          r___2 = kerr((cS )((C *)(r___2->k)));
        } else {
          ci(r___2);
        }
        cd(h___0);
        return (r___2);
      }
    }
    if (2LL > msg_type) {
      if (msg_type) {
        tmp___83 = ".m.g";
      } else {
        tmp___83 = ".m.s";
      }
      tmp___84 = denameS((S )".", (S )tmp___83, (I )0);
      tmp___85 = *tmp___84;
    } else {
      tmp___85 = (K )0;
    }
    m___0 = tmp___85;
    if (! m___0) {
      z = modified_execute(h___0);
    } else
    if (6LL == m___0->t) {
      z = modified_execute(h___0);
    } else {
      mhbegin(i);
      z = at(m___0, h___0);
      mhend();
    }
    if (msg_type) {
      tmp___86 = newK((I )0, (I )2);
      u___0 = tmp___86;
      tmp___87 = Ki((I )0);
      s___0 = tmp___87;
      tmp___88 = OOM_CD((I )0, u___0, s___0, (V )-1);
      if (! tmp___88) {
        return ((K )0);
      }
      if (! z) {
        *((I *)(s___0->k)) = (I )1;
        tmp___89 = strlen((char const   *)(errmsg));
        z = newK((I )-3, (I )tmp___89);
        tmp___90 = OOM_CD((I )0, u___0, z, (V )-1);
        if (! tmp___90) {
          return ((K )0);
        }
        strcpy((char * __restrict  )((C *)(z->k)), (char const   * __restrict  )(errmsg));
        kerr("(nil)");
      }
      u___0->k[0] = s___0;
      u___0->k[1] = z;
      z = u___0;
    } else
    if (! z) {
      printf((char const   * __restrict  )"%s error\n", errmsg);
      kerr("(nil)");
    }
    cd(h___0);
    if (z) {
      if (1LL == msg_type) {
        if (0LL == type) {
          ksender(j, z, (I )2);
        }
      }
    }
    cd(z);
    z = (K )0;
  }
  return (z);
  cleanup: 
  close_tape(i, j);
  return ((K )-1);
}
}
#pragma merger("0","/tmp/cil-RcO13ogJ.i","-g,-pthread,-O3")
static I w  =    (I )0;
K _kclone(K a ) ;
K kcloneI(K a , char const   *f , int n ) 
{ 
  K tmp ;

  {
  if (w) {
    printf((char const   * __restrict  )"kclone %s:%d ", f, n);
  }
  tmp = _kclone(a);
  return (tmp);
}
}
K _kclone(K a ) 
{ 
  I t ;
  I n ;
  K z ;
  K tmp ;
  I tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  I i___4 ;
  I _i___5 ;
  I k ;
  I vt ;
  I tmp___3 ;
  K kv ;
  V *v ;
  I tmp___4 ;
  I i___5 ;
  I _i___6 ;
  V w___0 ;
  K r ;
  K tmp___5 ;
  V q ;
  K tmp___6 ;
  K *tmp___7 ;
  I tmp___8 ;
  I tmp___9 ;
  I tmp___10 ;
  K tmp___11 ;
  K tmp___12 ;
  K tmp___13 ;
  I tmp___14 ;
  I tmp___15 ;
  I tmp___16 ;
  I tmp___17 ;

  {
  if (! a) {
    return ((K )0);
  }
  t = a->t;
  n = a->n;
  if (7LL == t) {
    tmp = Kv();
    tmp___2 = tmp;
  } else {
    if (-5LL == t) {
      tmp___0 = (I )-1;
    } else {
      tmp___0 = t;
    }
    tmp___1 = newK(tmp___0, n);
    tmp___2 = tmp___1;
  }
  z = tmp___2;
  z->t = t;
  if (t < 0LL) {
    tmp___17 = - t;
  } else {
    tmp___17 = t;
  }
  if (4LL == tmp___17) {
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      *((S *)(z->k) + i) = *((S *)(a->k) + i);
      i ++;
    }
  } else {
    if (t < 0LL) {
      tmp___16 = - t;
    } else {
      tmp___16 = t;
    }
    if (3LL == tmp___16) {
      i___0 = (I )0;
      _i___1 = n;
      while (i___0 < _i___1) {
        *((C *)(z->k) + i___0) = *((C *)(a->k) + i___0);
        i___0 ++;
      }
    } else {
      if (t < 0LL) {
        tmp___15 = - t;
      } else {
        tmp___15 = t;
      }
      if (2LL == tmp___15) {
        i___1 = (I )0;
        _i___2 = n;
        while (i___1 < _i___2) {
          *((F *)(z->k) + i___1) = *((F *)(a->k) + i___1);
          i___1 ++;
        }
      } else
      if (-5LL == t) {
        goto _L;
      } else {
        if (t < 0LL) {
          tmp___14 = - t;
        } else {
          tmp___14 = t;
        }
        if (1LL == tmp___14) {
          _L: /* CIL Label */ 
          i___2 = (I )0;
          _i___3 = n;
          while (i___2 < _i___3) {
            *((I *)(z->k) + i___2) = *((I *)(a->k) + i___2);
            i___2 ++;
          }
        } else
        if (0LL == t) {
          i___3 = (I )0;
          _i___4 = n;
          while (i___3 < _i___4) {
            z->k[i___3] = _kclone(a->k[i___3]);
            i___3 ++;
          }
        } else
        if (5LL == t) {
          i___4 = (I )0;
          _i___5 = n;
          while (i___4 < _i___5) {
            z->k[i___4] = _kclone(a->k[i___4]);
            i___4 ++;
          }
        } else
        if (7LL == t) {
          k = (I )0;
          z->t = a->t;
          tmp___3 = a->n;
          z->n = tmp___3;
          vt = tmp___3;
          kv = (K )0;
          switch (vt) {
          case 1LL: 
          k = ((K )*((V *)(a->k) + 2))->n - 1LL;
          kv = newK((I )-4, k + 1LL);
          tmp___4 = OOM_CD((I )0, z, kv, (V )-1);
          if (! tmp___4) {
            return ((K )0);
          }
          v = (V *)(kv->k);
          i___5 = (I )0;
          _i___6 = k;
          while (i___5 < _i___6) {
            w___0 = *((V *)((S *)(((K )*((V *)(a->k) + 2))->k)) + i___5);
            tmp___8 = VA(w___0);
            if (tmp___8) {
              *(v + i___5) = w___0;
            } else {
              tmp___5 = _kclone(*((K *)w___0));
              r = tmp___5;
              tmp___6 = newE(LS, r);
              q = (V )tmp___6;
              kap((K *)((V *)(z->k)) + 3, (V )(& q));
              cd((K )q);
              tmp___7 = EVP((K )q);
              q = (V )tmp___7;
              *(v + i___5) = q;
            }
            i___5 ++;
          }
          break;
          case 2LL: 
          kv = newK((I )-4, (I )3);
          tmp___9 = OOM_CD((I )0, z, kv, (V )-1);
          if (! tmp___9) {
            return ((K )0);
          }
          v = (V *)(kv->k);
          memcpy((void * __restrict  )v, (void const   * __restrict  )((V *)((S *)(((K )*((V *)(a->k) + 2))->k))),
                 sizeof(V ));
          break;
          case 3LL: 
          kv = _kclone((K )*((V *)(a->k) + 2));
          tmp___10 = OOM_CD((I )0, z, kv, (V )-1);
          if (! tmp___10) {
            return ((K )0);
          }
          break;
          }
          *((V *)(z->k) + 2) = (V )kv;
          *((V *)(z->k) + 1) = *((V *)(a->k) + 1);
          *((V *)(z->k) + 0) = *((V *)(a->k) + 0);
          cd((K )*((V *)(z->k) + 4));
          tmp___11 = _kclone((K )*((V *)(a->k) + 4));
          *((V *)(z->k) + 4) = (V )tmp___11;
          cd((K )*((V *)(z->k) + 3));
          tmp___12 = _kclone((K )*((V *)(a->k) + 3));
          *((V *)(z->k) + 3) = (V )tmp___12;
          tmp___13 = _kclone((K )*((V *)(a->k) + 5));
          *((V *)(z->k) + 5) = (V )tmp___13;
        }
      }
    }
  }
  return (z);
}
}
K collapse(K x___0 ) 
{ 
  K z ;

  {
  if (x___0->t == 1LL) {
    if (x___0->n == 1LL) {
      return (x___0);
    }
  }
  if (x___0->t < 0LL) {
    if (x___0->n == 1LL) {
      if (x___0->t < 0LL) {
        x___0->t = - x___0->t;
      } else {
        x___0->t = x___0->t;
      }
      return (x___0);
    }
  }
  if (1LL == x___0->n) {
    z = ci(x___0->k[0]);
    cd(x___0);
  } else {
    z = demote(x___0);
  }
  return (z);
}
}
K delist(K x___0 ) 
{ 
  K z ;
  K t ;

  {
  z = (K )0;
  t = x___0;
  while (1) {
    if (t->t == 0LL) {
      if (! (t->n == 1LL)) {
        break;
      }
    } else {
      break;
    }
    z = t->k[0];
    t = z;
  }
  z = ci(t);
  cd(x___0);
  return (z);
}
}
K demote(K a ) 
{ 
  I t ;
  I n ;
  I p ;
  I i ;
  I _i___0 ;
  K z ;
  K tmp ;
  I tmp___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;

  {
  if (! a) {
    return (a);
  }
  t = a->t;
  n = a->n;
  if (0LL != t) {
    return (a);
  } else
  if (1LL > n) {
    return (a);
  }
  p = (a->k[0])->t;
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    if (p != (a->k[i])->t) {
      p = (I )0;
    }
    i ++;
  }
  if (1LL <= p) {
    if (! (p <= 4LL)) {
      return (a);
    }
  } else {
    return (a);
  }
  tmp = newK(- p, n);
  z = tmp;
  tmp___0 = OOM_CD((I )0, a, z, (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  if (4LL == p) {
    i___0 = (I )0;
    _i___1 = n;
    while (i___0 < _i___1) {
      *((S *)(z->k) + i___0) = *((S *)((a->k[i___0])->k));
      i___0 ++;
    }
  } else
  if (3LL == p) {
    i___1 = (I )0;
    _i___2 = n;
    while (i___1 < _i___2) {
      *((C *)(z->k) + i___1) = *((C *)((a->k[i___1])->k));
      i___1 ++;
    }
  } else
  if (2LL == p) {
    i___2 = (I )0;
    _i___3 = n;
    while (i___2 < _i___3) {
      *((F *)(z->k) + i___2) = *((F *)((a->k[i___2])->k));
      i___2 ++;
    }
  } else
  if (1LL == p) {
    i___3 = (I )0;
    _i___4 = n;
    while (i___3 < _i___4) {
      *((I *)(z->k) + i___3) = *((I *)((a->k[i___3])->k));
      i___3 ++;
    }
  }
  cd(a);
  if (z->t == -1LL) {
    if (z->n == 1LL) {
      z->t = (I )1;
    }
  }
  return (z);
}
}
K promote(K a ) 
{ 
  I at___0 ;
  K tmp ;
  K z ;
  K tmp___0 ;
  K z___0 ;
  K tmp___1 ;
  K x___0 ;
  I v ;
  I tmp___2 ;
  I i ;
  I _i___0 ;
  I tmp___3 ;
  I i___0 ;
  I _i___1 ;
  I tmp___4 ;
  I i___1 ;
  I _i___2 ;
  I tmp___5 ;
  I i___2 ;
  I _i___3 ;
  I tmp___6 ;

  {
  at___0 = a->t;
  if (0LL == at___0) {
    tmp = ci(a);
    return (tmp);
  }
  if (4LL < at___0) {
    tmp___0 = newK((I )0, (I )1);
    z = tmp___0;
    if (! z) {
      return ((K )0);
    }
    z->k[0] = ci(a);
    return (z);
  }
  tmp___1 = newK((I )0, a->n);
  z___0 = tmp___1;
  if (! z___0) {
    return ((K )0);
  }
  if (at___0 < 0LL) {
    tmp___2 = - at___0;
  } else {
    tmp___2 = at___0;
  }
  v = tmp___2;
  if (4LL == v) {
    i = (I )0;
    _i___0 = a->n;
    while (i < _i___0) {
      x___0 = newK(v, (I )1);
      tmp___3 = OOM_CD((I )0, x___0, z___0, (V )-1);
      if (! tmp___3) {
        return ((K )0);
      }
      *((S *)(x___0->k)) = *((S *)(a->k) + i);
      z___0->k[i] = x___0;
      i ++;
    }
  } else
  if (3LL == v) {
    i___0 = (I )0;
    _i___1 = a->n;
    while (i___0 < _i___1) {
      x___0 = newK(v, (I )1);
      tmp___4 = OOM_CD((I )0, x___0, z___0, (V )-1);
      if (! tmp___4) {
        return ((K )0);
      }
      *((C *)(x___0->k)) = *((C *)(a->k) + i___0);
      z___0->k[i___0] = x___0;
      i___0 ++;
    }
  } else
  if (2LL == v) {
    i___1 = (I )0;
    _i___2 = a->n;
    while (i___1 < _i___2) {
      x___0 = newK(v, (I )1);
      tmp___5 = OOM_CD((I )0, x___0, z___0, (V )-1);
      if (! tmp___5) {
        return ((K )0);
      }
      *((F *)(x___0->k)) = *((F *)(a->k) + i___1);
      z___0->k[i___1] = x___0;
      i___1 ++;
    }
  } else
  if (1LL == v) {
    i___2 = (I )0;
    _i___3 = a->n;
    while (i___2 < _i___3) {
      x___0 = newK(v, (I )1);
      tmp___6 = OOM_CD((I )0, x___0, z___0, (V )-1);
      if (! tmp___6) {
        return ((K )0);
      }
      *((I *)(x___0->k)) = *((I *)(a->k) + i___2);
      z___0->k[i___2] = x___0;
      i___2 ++;
    }
  }
  return (z___0);
}
}
#pragma merger("0","/tmp/cil-fHMefjwk.i","-g,-pthread,-O3")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
void OS(N x___0 , I y ) ;
static I ns  =    (I )0;
static I sdd  =    (I )0;
static S sdupI(S s ) 
{ 
  I k ;
  S d___0 ;
  size_t tmp ;
  V tmp___0 ;
  void *tmp___1 ;

  {
  tmp = strlen((char const   *)s);
  k = (I )tmp;
  tmp___0 = alloc((size_t )(((unsigned long long )(2UL * sizeof(I )) + (unsigned long long )k) + 1ULL));
  d___0 = (S )tmp___0;
  if (! d___0) {
    return ((S )0);
  }
  ns ++;
  sdd = (I )1;
  d___0 += 2UL * sizeof(I );
  *(d___0 + k) = (C )0;
  tmp___1 = memcpy((void * __restrict  )d___0, (void const   * __restrict  )s, (size_t )k);
  return ((S )tmp___1);
}
}
S strdupn(S s , I k ) 
{ 
  S d___0 ;
  V tmp ;
  void *tmp___0 ;

  {
  tmp = alloc((size_t )(k + 1LL));
  d___0 = (S )tmp;
  if (! d___0) {
    return ((S )0);
  }
  *(d___0 + k) = (C )0;
  tmp___0 = memcpy((void * __restrict  )d___0, (void const   * __restrict  )s, (size_t )k);
  return ((S )tmp___0);
}
}
I strlenn(S s , I k ) 
{ 
  S t ;
  void *tmp ;
  I tmp___0 ;

  {
  tmp = memchr((void const   *)s, '\000', (size_t )k);
  t = (S )tmp;
  if (t) {
    tmp___0 = (I )(t - s);
  } else {
    tmp___0 = k;
  }
  return (tmp___0);
}
}
I StoI(S s , I *n ) 
{ 
  S t ;
  int *tmp ;
  long tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  tmp = __errno_location();
  *tmp = 0;
  tmp___0 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& t), 10);
  *n = (I )tmp___0;
  tmp___1 = __errno_location();
  if (*tmp___1 != 0) {
    tmp___2 = 0;
  } else
  if ((unsigned long )t == (unsigned long )s) {
    tmp___2 = 0;
  } else
  if ((int )*t != 0) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  return ((I )tmp___2);
}
}
I SC(S a , S b___1 ) 
{ 
  I x___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = strcmp((char const   *)a, (char const   *)b___1);
  x___0 = (I )tmp;
  if (x___0 < 0LL) {
    tmp___1 = -1;
  } else {
    if (x___0 > 0LL) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    tmp___1 = tmp___0;
  }
  return ((I )tmp___1);
}
}
S sp(S k ) 
{ 
  N t ;
  N s ;
  N p ;
  N q ;
  N r ;
  I a ;
  I x___0 ;
  struct node *tmp ;
  K tmp___0 ;
  S tmp___1 ;
  K tmp___2 ;
  S tmp___3 ;
  I tmp___5 ;
  I tmp___6 ;
  int tmp___7 ;

  {
  if (! k) {
    return ((S )0);
  }
  t = SYMBOLS;
  s = t->c[1];
  p = s;
  q = p;
  if (! s) {
    tmp = newN();
    t->c[1] = tmp;
    s = tmp;
    if (! s) {
      tmp___0 = kerr("wsfull");
      return ((S )tmp___0);
    }
    tmp___1 = sdupI(k);
    s->k = (V )tmp___1;
    if (! s->k) {
      free((void *)s);
      t->c[1] = (struct node *)0;
      kerr("wsfull");
    }
    return ((S )s->k);
  }
  while (q) {
    a = SC(k, (S )p->k);
    if (! a) {
      return ((S )p->k);
    }
    q = p->c[(a + 1LL) / 2LL];
    if (q) {
      if (q->b) {
        t = p;
        s = q;
      }
    } else {
      q = newN();
      if (! q) {
        tmp___2 = kerr("wsfull");
        return ((S )tmp___2);
      }
      tmp___3 = sdupI(k);
      q->k = (V )tmp___3;
      if (! q->k) {
        free((void *)q);
        kerr("wsfull");
        return ((S )0);
      }
      p->c[(a + 1LL) / 2LL] = q;
      break;
    }
    p = q;
  }
  tmp___5 = SC(k, (S )s->k);
  if (0LL > tmp___5) {
    a = (I )-1;
  } else {
    a = (I )1;
  }
  p = s->c[(a + 1LL) / 2LL];
  r = p;
  while ((unsigned long )p != (unsigned long )q) {
    x___0 = SC(k, (S )p->k);
    p->b = x___0;
    p = p->c[(x___0 + 1LL) / 2LL];
  }
  if (! s->b) {
    s->b = a;
    return ((S )p->k);
  } else
  if (s->b == - a) {
    s->b = (I )0;
    return ((S )p->k);
  }
  if (r->b == a) {
    p = r;
    s->c[(a + 1LL) / 2LL] = r->c[(- a + 1LL) / 2LL];
    r->c[(- a + 1LL) / 2LL] = s;
    tmp___6 = (I )0;
    r->b = tmp___6;
    s->b = tmp___6;
  } else
  if (r->b == - a) {
    p = r->c[(- a + 1LL) / 2LL];
    r->c[(- a + 1LL) / 2LL] = p->c[(a + 1LL) / 2LL];
    p->c[(a + 1LL) / 2LL] = r;
    s->c[(a + 1LL) / 2LL] = p->c[(- a + 1LL) / 2LL];
    p->c[(- a + 1LL) / 2LL] = s;
    if (p->b == a) {
      s->b = - a;
      r->b = (I )0;
    } else
    if (p->b == 0LL) {
      s->b = (I )0;
      r->b = (I )0;
    } else
    if (p->b == - a) {
      s->b = (I )0;
      r->b = a;
    }
    p->b = (I )0;
  }
  if ((unsigned long )s == (unsigned long )t->c[1]) {
    tmp___7 = 1;
  } else {
    tmp___7 = 0;
  }
  t->c[tmp___7] = p;
  return ((S )q->k);
}
}
S spn(S s , I n ) 
{ 
  I k ;
  S u ;
  S tmp ;
  S v ;
  S tmp___0 ;

  {
  k = (I )0;
  while (1) {
    if (k < n) {
      if (! *(s + k)) {
        break;
      }
    } else {
      break;
    }
    k ++;
  }
  tmp = strdupn(s, k);
  u = tmp;
  if (! u) {
    return ((S )0);
  }
  tmp___0 = sp(u);
  v = tmp___0;
  free((void *)u);
  return (v);
}
}
I wleft(N x___0 , I y , I z ) 
{ 
  I o ;
  I tmp ;

  {
  if (! x___0) {
    return (z);
  }
  z = wleft(x___0->c[0], y, z);
  if (x___0->k) {
    if (*((I *)x___0->k + - y)) {
      o = *((I *)x___0->k + - y);
      *((I *)x___0->k + - y) = z;
      z += o;
    }
  }
  tmp = wleft(x___0->c[1], y, z);
  return (tmp);
}
}
I wright(N x___0 , I y , I z ) 
{ 
  I o ;
  I tmp ;

  {
  if (! x___0) {
    return (z);
  }
  z = wright(x___0->c[1], y, z);
  if (x___0->k) {
    if (*((I *)x___0->k + - y)) {
      o = *((I *)x___0->k + - y);
      *((I *)x___0->k + - y) = z;
      z += o;
    }
  }
  tmp = wright(x___0->c[0], y, z);
  return (tmp);
}
}
static void ssI(N x___0 , int y , I z ) 
{ 
  I i ;
  I _i___0 ;

  {
  if (x___0) {
    i = (I )0;
    _i___0 = (I )2;
    while (i < _i___0) {
      ssI(x___0->c[i], y, z);
      i ++;
    }
    if (x___0->k) {
      *((I *)x___0->k + - y) = z;
    }
  }
  return;
}
}
void setS(int y , I z ) 
{ 


  {
  ssI(SYMBOLS, y, z);
  return;
}
}
void OS(N x___0 , I y ) 
{ 


  {
  if (! x___0) {
    return;
  }
  OS(x___0->c[0], y);
  if (x___0->k) {
    if (*((I *)x___0->k + - y)) {
      printf((char const   * __restrict  )"%p: %lld\n", x___0->k, *((I *)x___0->k + - y));
    }
  }
  OS(x___0->c[1], y);
  return;
}
}
#pragma merger("0","/tmp/cil-WSef_xZA.i","-g,-pthread,-O3")
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
K mod(K a , K b___1 ) ;
K rotate(K a , K b___1 ) ;
K itemAtIndex(K a , I i ) 
{ 
  I at___0 ;
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  K tmp___4 ;

  {
  at___0 = a->t;
  if (0LL < at___0) {
    tmp = ci(a);
    return (tmp);
  }
  if (-4LL == at___0) {
    tmp___0 = Ks(*((S *)(a->k) + i));
    return (tmp___0);
  }
  if (-3LL == at___0) {
    tmp___1 = Kc(*((C *)(a->k) + i));
    return (tmp___1);
  }
  if (-2LL == at___0) {
    tmp___2 = Kf(*((F *)(a->k) + i));
    return (tmp___2);
  }
  if (-1LL == at___0) {
    tmp___3 = Ki(*((I *)(a->k) + i));
    return (tmp___3);
  }
  tmp___4 = ci(a->k[i]);
  return (tmp___4);
}
}
S glueSS(S c , S d___0 ) 
{ 
  I x___0 ;
  size_t tmp ;
  I y ;
  size_t tmp___0 ;
  S m ;
  V tmp___1 ;

  {
  tmp = strlen((char const   *)c);
  x___0 = (I )tmp;
  tmp___0 = strlen((char const   *)d___0);
  y = (I )tmp___0;
  tmp___1 = alloc((size_t )((x___0 + y) + 2LL));
  m = (S )tmp___1;
  sprintf((char * __restrict  )m, (char const   * __restrict  )"%s.%s", c, d___0);
  return (m);
}
}
K glue(K a , K b___1 ) 
{ 
  S tmp ;
  S tmp___0 ;
  K tmp___1 ;

  {
  tmp = glueSS(*((S *)(a->k)), *((S *)(b___1->k)));
  tmp___0 = sp(tmp);
  tmp___1 = Ks(tmp___0);
  return (tmp___1);
}
}
K DI(K d___0 , I i ) 
{ 


  {
  return (d___0->k[i]);
}
}
S ES(K d___0 ) 
{ 


  {
  return (*((S *)((d___0->k[0])->k)));
}
}
K DE(K d___0 , S b___1 ) 
{ 
  I i ;
  I _i___0 ;
  K x___0 ;
  K tmp ;
  S tmp___0 ;

  {
  i = (I )0;
  _i___0 = d___0->n;
  while (i < _i___0) {
    tmp = DI(d___0, i);
    x___0 = tmp;
    tmp___0 = ES(x___0);
    if ((unsigned long )b___1 == (unsigned long )tmp___0) {
      return (x___0);
    }
    i ++;
  }
  return ((K )0);
}
}
static K *EIA(K a , I i ) 
{ 


  {
  return (a->k + i);
}
}
K *EVP(K e ) 
{ 
  K *tmp ;

  {
  tmp = EIA(e, (I )1);
  return (tmp);
}
}
K *EAP(K e ) 
{ 
  K *tmp ;

  {
  tmp = EIA(e, (I )2);
  return (tmp);
}
}
K EV(K e ) 
{ 
  K *tmp ;

  {
  tmp = EVP(e);
  return (*tmp);
}
}
K lookupEntryOrCreate(K *p , S k ) 
{ 
  K a ;
  K x___0 ;
  K tmp ;
  size_t tmp___0 ;
  K tmp___1 ;
  char *tmp___2 ;

  {
  a = *p;
  if (5LL == a->t) {
    x___0 = DE(a, k);
    if (x___0) {
      return (x___0);
    }
  }
  tmp___0 = strlen((char const   *)k);
  if (! tmp___0) {
    tmp = kerr("type");
    return (tmp);
  }
  tmp___2 = strchr((char const   *)k, '.');
  if (tmp___2) {
    tmp___1 = kerr("domain");
    return (tmp___1);
  }
  x___0 = newEntry(k);
  if (6LL == a->t) {
    cd(*p);
    *p = newK((I )5, (I )0);
  }
  kap(p, (V )(& x___0));
  cd(x___0);
  return (x___0);
}
}
static K *denameRecurse(K *p , S t , I create ) 
{ 
  I c ;
  I a ;
  S u ;
  S tmp ;
  S k ;
  S tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K e ;
  K tmp___3 ;
  K a___0 ;
  K *tmp___4 ;

  {
  if (! *t) {
    return (p);
  }
  if (46 == (int )*t) {
    t ++;
  }
  c = (I )0;
  a = (*p)->t;
  while (1) {
    if (*(t + c)) {
      if (! (46 != (int )*(t + c))) {
        break;
      }
    } else {
      break;
    }
    c ++;
  }
  tmp = strdupn(t, c);
  u = tmp;
  tmp___0 = sp(u);
  k = tmp___0;
  free((void *)u);
  t += c;
  if (95 == (int )*k) {
    tmp___1 = kerr("reserved");
    return ((K *)tmp___1);
  }
  if (! (6LL == a)) {
    if (! (5LL == a)) {
      tmp___2 = kerr("type");
      return ((K *)tmp___2);
    }
  }
  e = (K )0;
  if (create) {
    e = lookupEntryOrCreate(p, k);
    if (! e) {
      tmp___3 = kerr("wsfull");
      return ((K *)tmp___3);
    }
  } else {
    a___0 = *p;
    if (5LL == a___0->t) {
      e = DE(a___0, k);
    }
    if (! e) {
      return (& NIL);
    }
  }
  if (46 == (int )*t) {
    if (! *(t + 1)) {
      t ++;
      p = EAP(e);
    } else
    if (46 == (int )*(t + 1)) {
      t ++;
      p = EAP(e);
    } else {
      p = EVP(e);
    }
  } else {
    p = EVP(e);
  }
  tmp___4 = denameRecurse(p, t, create);
  return (tmp___4);
}
}
K *denameD(K *d___0 , S t , I create ) 
{ 
  I tmp ;
  K *tmp___0 ;
  K *tmp___1 ;

  {
  tmp = simpleString(t);
  if (! tmp) {
    return ((K *)0);
  }
  if (46 == (int )*t) {
    tmp___0 = & KTREE;
  } else
  if (! *t) {
    tmp___0 = & KTREE;
  } else {
    tmp___0 = d___0;
  }
  tmp___1 = denameRecurse(tmp___0, t, create);
  return (tmp___1);
}
}
K *denameS(S dir_string , S t , I create ) 
{ 
  K *tmp ;
  K *tmp___0 ;
  K *tmp___1 ;

  {
  if (46 == (int )*t) {
    tmp___0 = & KTREE;
  } else
  if (! *t) {
    tmp___0 = & KTREE;
  } else {
    tmp = denameD(& KTREE, dir_string, create);
    tmp___0 = tmp;
  }
  tmp___1 = denameD(tmp___0, t, create);
  return (tmp___1);
}
}
K *lookupEVOrCreate(K *p , S k ) 
{ 
  K x___0 ;
  K tmp ;
  K *tmp___0 ;
  K *tmp___1 ;

  {
  tmp = lookupEntryOrCreate(p, k);
  x___0 = tmp;
  if (x___0) {
    tmp___0 = EVP(x___0);
    tmp___1 = tmp___0;
  } else {
    tmp___1 = (K *)0;
  }
  return (tmp___1);
}
}
K lookup(K a , S b___1 ) 
{ 
  K x___0 ;
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;

  {
  tmp = DE(a, b___1);
  x___0 = tmp;
  if (x___0) {
    tmp___0 = EV(x___0);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = _n();
    tmp___2 = tmp___1;
  }
  return (tmp___2);
}
}
static I isVerbDyadic(K x___0 , V v ) 
{ 
  int tmp ;

  {
  if (x___0->t == 7LL) {
    if ((unsigned long )*((V *)((S *)(((K )*((V *)(x___0->k) + 2))->k)) + 0) == (unsigned long )v) {
      if (! *((V *)((S *)(((K )*((V *)(x___0->k) + 2))->k)) + 1)) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((I )tmp);
}
}
I isColonDyadic(K x___0 ) 
{ 
  I tmp ;

  {
  tmp = isVerbDyadic(x___0, offsetColon);
  return (tmp);
}
}
static I isDotDyadic(K x___0 ) 
{ 
  I tmp ;

  {
  tmp = isVerbDyadic(x___0, offsetDot);
  return (tmp);
}
}
K at_verb(K a , K b___1 ) 
{ 
  K tmp ;
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  K z ;
  K tmp___0 ;
  I tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  I i ;
  I _i___0 ;
  K tmp___4 ;
  K *p ;
  K tmp___5 ;
  K tmp___6 ;
  I x___0 ;
  I i___0 ;
  I _i___1 ;
  K tmp___7 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  I i___4 ;
  I _i___5 ;
  I i___5 ;
  I _i___6 ;
  I tmp___8 ;
  K tmp___9 ;
  K tmp___10 ;
  K tmp___11 ;
  I i___6 ;
  I _i___7 ;
  K tmp___12 ;
  K zz ;
  K tmp___13 ;
  I i___7 ;
  I _i___8 ;
  K tmp___14 ;
  K tmp___15 ;
  K tmp___16 ;
  I i___8 ;
  I _i___9 ;
  struct k0 *tmp___17 ;
  I tmp___18 ;
  I i___9 ;
  I _i___10 ;
  K tmp___19 ;
  K *tmp___20 ;
  K tmp___21 ;
  I tmp___22 ;
  I tmp___23 ;
  I tmp___24 ;
  I tmp___25 ;

  {
  if (! b___1) {
    return (b___1);
  }
  if (0LL == b___1->t) {
    if (0LL == b___1->n) {
      tmp = newK((I )0, (I )0);
      return (tmp);
    }
  }
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (at___0 == 6LL) {
    if (bt < 0LL) {
      tmp___1 = - bt;
    } else {
      tmp___1 = bt;
    }
    if (1LL == tmp___1) {
      tmp___0 = ci(b___1);
      return (tmp___0);
    }
    if (6LL == bt) {
      tmp___2 = newK((I )0, (I )0);
      return (tmp___2);
    } else
    if (0LL >= bt) {
      if (0LL == bn) {
        tmp___2 = newK((I )0, (I )0);
        return (tmp___2);
      }
    }
    if (4LL == bt) {
      tmp___3 = _n();
      return (tmp___3);
    }
    if (-4LL == bt) {
      z = newK((I )0, bn);
      i = (I )0;
      _i___0 = bn;
      while (i < _i___0) {
        z->k[i] = _n();
        i ++;
      }
      return (z);
    }
    tmp___4 = kerr("type");
    return (tmp___4);
  }
  if (bt < 0LL) {
    tmp___25 = - bt;
  } else {
    tmp___25 = bt;
  }
  if (1LL == tmp___25) {
    if (at___0 == 7LL) {
      if (an == 3LL) {
        p = & a;
        tmp___5 = dv_ex((K )0, (V *)(& p), b___1);
        return (tmp___5);
      }
    }
    if (0LL < at___0) {
      tmp___6 = kerr("type");
      return (tmp___6);
    }
    i___0 = (I )0;
    _i___1 = bn;
    while (i___0 < _i___1) {
      x___0 = *((I *)(b___1->k) + i___0);
      if (x___0 >= an) {
        tmp___7 = kerr("index");
        return (tmp___7);
      } else
      if (x___0 < 0LL) {
        tmp___7 = kerr("index");
        return (tmp___7);
      }
      i___0 ++;
    }
    z = newK(at___0 * - bt, bn);
    if (-4LL == at___0) {
      i___1 = (I )0;
      _i___2 = bn;
      while (i___1 < _i___2) {
        *((S *)(z->k) + i___1) = *((S *)(a->k) + *((I *)(b___1->k) + i___1));
        i___1 ++;
      }
    } else
    if (-3LL == at___0) {
      i___2 = (I )0;
      _i___3 = bn;
      while (i___2 < _i___3) {
        *((C *)(z->k) + i___2) = *((C *)(a->k) + *((I *)(b___1->k) + i___2));
        i___2 ++;
      }
    } else
    if (-2LL == at___0) {
      i___3 = (I )0;
      _i___4 = bn;
      while (i___3 < _i___4) {
        *((F *)(z->k) + i___3) = *((F *)(a->k) + *((I *)(b___1->k) + i___3));
        i___3 ++;
      }
    } else
    if (-1LL == at___0) {
      i___4 = (I )0;
      _i___5 = bn;
      while (i___4 < _i___5) {
        *((I *)(z->k) + i___4) = *((I *)(a->k) + *((I *)(b___1->k) + i___4));
        i___4 ++;
      }
    } else
    if (0LL == at___0) {
      i___5 = (I )0;
      _i___6 = bn;
      while (i___5 < _i___6) {
        z->k[i___5] = ci(a->k[*((I *)(b___1->k) + i___5)]);
        i___5 ++;
      }
      if (bt < 0LL) {
        tmp___8 = - bt;
      } else {
        tmp___8 = bt;
      }
      if (bt == tmp___8) {
        z = collapse(z);
      } else
      if (bn != 1LL) {
        z = collapse(z);
      }
    }
  } else {
    if (bt < 0LL) {
      tmp___24 = - bt;
    } else {
      tmp___24 = bt;
    }
    if (3LL == tmp___24) {
      if (5LL != at___0) {
        tmp___9 = kerr("type");
        return (tmp___9);
      }
      tmp___10 = wd_((C *)(b___1->k), (int )bn, & a, (K )0);
      z = ex(tmp___10);
    } else {
      if (bt < 0LL) {
        tmp___23 = - bt;
      } else {
        tmp___23 = bt;
      }
      if (4LL == tmp___23) {
        if (5LL != at___0) {
          tmp___11 = kerr("type");
          return (tmp___11);
        }
        z = newK((I )0, bn);
        i___6 = (I )0;
        _i___7 = bn;
        while (i___6 < _i___7) {
          tmp___12 = lookup(a, *((S *)(b___1->k) + i___6));
          z->k[i___6] = ci(tmp___12);
          i___6 ++;
        }
        if (bt < 0LL) {
          if (! (bn == 1LL)) {
            z = collapse(z);
          }
        } else {
          z = collapse(z);
        }
        if (z->t == 0LL) {
          if (z->n == 1LL) {
            if ((z->k[0])->t == 1LL) {
              tmp___13 = enlist(z->k[0]);
              zz = tmp___13;
              cd(z);
              return (zz);
            }
          }
        }
      } else
      if (6LL == bt) {
        if (0LL >= at___0) {
          z = ci(a);
        } else
        if (5LL == at___0) {
          z = newK((I )0, an);
          i___7 = (I )0;
          _i___8 = an;
          while (i___7 < _i___8) {
            tmp___14 = DI(a, i___7);
            tmp___15 = EV(tmp___14);
            z->k[i___7] = ci(tmp___15);
            i___7 ++;
          }
          z = collapse(z);
        } else {
          tmp___16 = kerr("type");
          return (tmp___16);
        }
      } else
      if (0LL == bt) {
        z = newK((I )0, bn);
        if (! z) {
          return ((K )0);
        }
        i___8 = (I )0;
        _i___9 = bn;
        while (i___8 < _i___9) {
          tmp___17 = at_verb(a, b___1->k[i___8]);
          z->k[i___8] = tmp___17;
          tmp___18 = OOM_CD((I )0, z, tmp___17, (V )-1);
          if (! tmp___18) {
            return ((K )0);
          }
          i___8 ++;
        }
      } else {
        tmp___22 = isDotDyadic(b___1);
        if (tmp___22) {
          if (at___0 == 5LL) {
            z = newK((I )0, an);
            i___9 = (I )0;
            _i___10 = an;
            while (i___9 < _i___10) {
              tmp___19 = DI(a, i___9);
              tmp___20 = EAP(tmp___19);
              z->k[i___9] = ci(*tmp___20);
              i___9 ++;
            }
          } else {
            tmp___21 = kerr("type");
            return (tmp___21);
          }
        } else {
          tmp___21 = kerr("type");
          return (tmp___21);
        }
      }
    }
  }
  return (z);
}
}
K at(K x___0 , K y ) 
{ 
  K a ;
  K z ;
  C s[256] ;
  K *xx ;
  S tmp ;
  K *tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  I tmp___4 ;
  K tmp___5 ;
  I tmp___6 ;

  {
  if (x___0->t == 4LL) {
    if (y->t < 0LL) {
      tmp___4 = - y->t;
    } else {
      tmp___4 = y->t;
    }
    if (1LL == tmp___4) {
      strcpy((char * __restrict  )(s), (char const   * __restrict  )d_);
      strcat((char * __restrict  )(s), (char const   * __restrict  )".");
      strcat((char * __restrict  )(s), (char const   * __restrict  )*((S *)(x___0->k)));
      tmp = sp(s);
      tmp___0 = denameD(& KTREE, tmp, (I )1);
      xx = tmp___0;
      if (6LL == (*xx)->t) {
        tmp___1 = ci(y);
        return (tmp___1);
      } else {
        tmp___2 = of(*xx, y);
        return (tmp___2);
      }
    } else {
      tmp___3 = kerr("nyi");
      return (tmp___3);
    }
  }
  if (7LL != x___0->t) {
    tmp___5 = at_verb(x___0, y);
    return (tmp___5);
  }
  a = enlist(y);
  tmp___6 = OOM_CD((I )0, a, (V )-1);
  if (! tmp___6) {
    return ((K )0);
  }
  z = dot(x___0, a);
  cd(a);
  return (z);
}
}
static I updateIndex(K *p , I x___0 , K r ) 
{ 
  I pt ;
  I rt ;
  K t ;
  K tmp ;

  {
  pt = (*p)->t;
  rt = r->t;
  if (0LL == pt) {
    cd((*p)->k[x___0]);
    (*p)->k[x___0] = ci(r);
    *p = demote(*p);
  } else
  if (pt != - rt) {
    tmp = promote(*p);
    t = tmp;
    cd(*p);
    *p = t;
    cd((*p)->k[x___0]);
    (*p)->k[x___0] = ci(r);
  } else {
    if (-4LL == pt) {
      *((S *)((*p)->k) + x___0) = *((S *)(r->k));
    }
    if (-3LL == pt) {
      *((C *)((*p)->k) + x___0) = *((C *)(r->k));
    }
    if (-2LL == pt) {
      *((F *)((*p)->k) + x___0) = *((F *)(r->k));
    }
    if (-1LL == pt) {
      *((I *)((*p)->k) + x___0) = *((I *)(r->k));
    }
  }
  return ((I )0);
}
}
K specialAmendDot(K c , K args___0 ) 
{ 
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;
  I tmp___2 ;
  K tmp___3 ;

  {
  tmp___2 = isColonDyadic(c);
  if (tmp___2) {
    if (! *((V *)(c->k) + 5)) {
      if (2LL == args___0->n) {
        tmp = ci(args___0->k[1]);
        tmp___1 = tmp;
      } else {
        tmp___0 = _n();
        tmp___1 = tmp___0;
      }
      return (tmp___1);
    }
  }
  tmp___3 = vf_ex((V )(& c), args___0);
  return (tmp___3);
}
}
I atomI(K a ) 
{ 
  int tmp ;

  {
  if (a->t > 0LL) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return ((I )tmp);
}
}
K atom(K a ) 
{ 
  I tmp ;
  K tmp___0 ;

  {
  tmp = atomI(a);
  tmp___0 = Ki(tmp);
  return (tmp___0);
}
}
K at_ref(K *p , K b___1 , K c , K y ) 
{ 
  I pt ;
  I pn ;
  K tmp ;
  I bt ;
  I bn ;
  K tmp___0 ;
  I tmp___1 ;
  I tmp___2 ;
  I n ;
  I tmp___4 ;
  I tmp___5 ;
  I argc ;
  int tmp___6 ;
  K tmp___7 ;
  I i ;
  I _i___0 ;
  I x___0 ;
  K tmp___8 ;
  I i___0 ;
  I _i___1 ;
  I tmp___10 ;
  I tmp___11 ;
  K args___0 ;
  K tmp___12 ;
  K tmp___14 ;
  K tmp___15 ;
  I tmp___16 ;
  K r ;
  K tmp___17 ;
  I tmp___18 ;
  K tmp___19 ;
  I i___1 ;
  I _i___2 ;
  I tmp___21 ;
  I tmp___22 ;
  K args___1 ;
  K tmp___23 ;
  S u ;
  K tmp___24 ;
  size_t tmp___25 ;
  K *tmp___26 ;
  K tmp___28 ;
  K tmp___29 ;
  I tmp___30 ;
  K r___0 ;
  K tmp___31 ;
  I tmp___32 ;
  K *v ;
  K tmp___33 ;
  K *tmp___34 ;
  K tmp___35 ;
  I tmp___36 ;
  K k ;
  K tmp___37 ;
  K tmp___38 ;
  K tmp___39 ;
  I tmp___40 ;
  I i___2 ;
  I _i___3 ;
  K tmp___41 ;
  struct k0 *tmp___42 ;
  I i___3 ;
  I _i___4 ;
  struct k0 *tmp___43 ;
  I i___4 ;
  I _i___5 ;
  K e ;
  K tmp___44 ;
  I tmp___45 ;
  I tmp___46 ;

  {
  pt = (*p)->t;
  pn = (*p)->n;
  if (pt > 0LL) {
    if (pt != 5LL) {
      if (pt != 6LL) {
        tmp = kerr("rank");
        return (tmp);
      }
    }
  }
  bt = b___1->t;
  bn = b___1->n;
  if (0LL == bn) {
    if (-1LL == bt) {
      return ((K )0);
    } else
    if (0LL == bt) {
      return ((K )0);
    } else
    if (6LL == pt) {
      return ((K )0);
    }
  }
  if (0LL == bn) {
    if (bt <= 0LL) {
      tmp___0 = kerr("int");
      return (tmp___0);
    }
  }
  if (y) {
    tmp___1 = atomI(b___1);
    if (! tmp___1) {
      tmp___2 = atomI(y);
      if (! tmp___2) {
        if (bn != y->n) {
          return ((K )0);
        }
      }
    }
  }
  if (y) {
    tmp___5 = atomI(b___1);
    if (tmp___5) {
      tmp___4 = y->n;
    } else {
      tmp___4 = bn;
    }
  } else {
    tmp___4 = bn;
  }
  n = tmp___4;
  if (y) {
    tmp___6 = 2;
  } else {
    tmp___6 = 1;
  }
  argc = (I )tmp___6;
  if (bt < 0LL) {
    tmp___46 = - bt;
  } else {
    tmp___46 = bt;
  }
  if (1LL == tmp___46) {
    if (5LL == pt) {
      tmp___7 = kerr("type");
      return (tmp___7);
    } else
    if (6LL == pt) {
      tmp___7 = kerr("type");
      return (tmp___7);
    }
    i = (I )0;
    _i___0 = bn;
    while (i < _i___0) {
      x___0 = *((I *)(b___1->k) + i);
      if (x___0 < 0LL) {
        tmp___8 = kerr("index");
        return (tmp___8);
      } else
      if (x___0 >= pn) {
        tmp___8 = kerr("index");
        return (tmp___8);
      }
      i ++;
    }
    i___0 = (I )0;
    tmp___11 = atomI(b___1);
    if (tmp___11) {
      tmp___10 = (I )1;
    } else {
      tmp___10 = n;
    }
    _i___1 = tmp___10;
    while (i___0 < _i___1) {
      tmp___12 = newK((I )0, argc);
      args___0 = tmp___12;
      if (! args___0) {
        return ((K )0);
      }
      args___0->k[0] = itemAtIndex(*p, *((I *)(b___1->k) + i___0 % bn));
      if (argc > 1LL) {
        tmp___16 = atomI(b___1);
        if (tmp___16) {
          tmp___14 = ci(y);
          args___0->k[1] = tmp___14;
        } else {
          tmp___15 = itemAtIndex(y, i___0 % y->n);
          args___0->k[1] = tmp___15;
        }
      }
      tmp___17 = specialAmendDot(c, args___0);
      r = tmp___17;
      tmp___18 = OOM_CD((I )0, r, args___0, (V )-1);
      if (! tmp___18) {
        return ((K )0);
      }
      updateIndex(p, *((I *)(b___1->k) + i___0 % bn), r);
      cd(r);
      cd(args___0);
      i___0 ++;
    }
  } else {
    if (bt < 0LL) {
      tmp___45 = - bt;
    } else {
      tmp___45 = bt;
    }
    if (4LL == tmp___45) {
      if (5LL != pt) {
        if (6LL != pt) {
          tmp___19 = kerr("type");
          return (tmp___19);
        }
      }
      i___1 = (I )0;
      tmp___22 = atomI(b___1);
      if (tmp___22) {
        tmp___21 = (I )1;
      } else {
        tmp___21 = n;
      }
      _i___2 = tmp___21;
      while (i___1 < _i___2) {
        tmp___23 = newK((I )0, argc);
        args___1 = tmp___23;
        if (! args___1) {
          return ((K )0);
        }
        u = *((S *)(b___1->k) + i___1 % bn);
        tmp___25 = strlen((char const   *)u);
        if (! tmp___25) {
          tmp___24 = kerr("domain");
          return (tmp___24);
        }
        tmp___26 = lookupEVOrCreate(p, u);
        args___1->k[0] = ci(*tmp___26);
        if (argc > 1LL) {
          tmp___30 = atomI(b___1);
          if (tmp___30) {
            tmp___28 = ci(y);
            args___1->k[1] = tmp___28;
          } else {
            tmp___29 = itemAtIndex(y, i___1 % y->n);
            args___1->k[1] = tmp___29;
          }
        }
        tmp___31 = specialAmendDot(c, args___1);
        r___0 = tmp___31;
        tmp___32 = OOM_CD((I )0, r___0, args___1, (V )-1);
        if (! tmp___32) {
          return ((K )0);
        }
        tmp___33 = DE(*p, u);
        tmp___34 = EVP(tmp___33);
        v = tmp___34;
        cd(*v);
        *v = r___0;
        cd(args___1);
        i___1 ++;
      }
    } else
    if (6LL == bt) {
      if (y) {
        tmp___36 = atomI(y);
        if (! tmp___36) {
          if (y->n != pn) {
            tmp___35 = kerr("length");
            return (tmp___35);
          }
        }
      }
      if (6LL == pt) {
        return ((K )0);
      }
      if (5LL == pt) {
        tmp___37 = Ks(LS);
        tmp___39 = tmp___37;
      } else {
        tmp___38 = Ki((I )0);
        tmp___39 = tmp___38;
      }
      k = tmp___39;
      if (! k) {
        return ((K )0);
      }
      if (y) {
        y = promote(y);
        tmp___40 = OOM_CD((I )0, k, y, (V )-1);
        if (! tmp___40) {
          return ((K )0);
        }
      }
      if (5LL == pt) {
        i___2 = (I )0;
        _i___3 = pn;
        while (i___2 < _i___3) {
          tmp___41 = DI(*p, i___2);
          *((S *)(k->k)) = ES(tmp___41);
          if (y) {
            tmp___42 = y->k[i___2 % y->n];
          } else {
            tmp___42 = (struct k0 *)0;
          }
          at_ref(p, k, c, tmp___42);
          i___2 ++;
        }
      } else {
        i___3 = (I )0;
        _i___4 = pn;
        while (i___3 < _i___4) {
          *((I *)(k->k)) = i___3;
          if (y) {
            tmp___43 = y->k[i___3 % y->n];
          } else {
            tmp___43 = (struct k0 *)0;
          }
          at_ref(p, k, c, tmp___43);
          i___3 ++;
        }
      }
      cd(k);
      cd(y);
    } else
    if (0LL == bt) {
      i___4 = (I )0;
      _i___5 = n;
      while (i___4 < _i___5) {
        e = (K )0;
        if (y) {
          e = itemAtIndex(y, i___4 % y->n);
          if (! e) {
            return ((K )0);
          }
        }
        at_ref(p, b___1->k[i___4 % bn], c, e);
        cd(e);
        i___4 ++;
      }
    } else {
      tmp___44 = kerr("type");
      return (tmp___44);
    }
  }
  return ((K )0);
}
}
K at_tetradic(K a , K b___1 , K c , K y ) 
{ 
  K d___0 ;
  K tmp ;
  K e ;
  K tmp___0 ;

  {
  tmp = enlist(b___1);
  d___0 = tmp;
  if (! d___0) {
    return ((K )0);
  }
  tmp___0 = dot_tetradic(a, d___0, c, y);
  e = tmp___0;
  cd(d___0);
  return (e);
}
}
K colon_monadic(K a ) 
{ 
  K tmp ;

  {
  tmp = ci(a);
  return (tmp);
}
}
K colon_dyadic(K a , K b___1 ) 
{ 
  K tmp ;

  {
  tmp = ci(b___1);
  return (tmp);
}
}
static S notsp(S a ) 
{ 
  I b___1 ;
  size_t tmp ;
  S c ;
  V tmp___0 ;
  char *tmp___1 ;
  S d___0 ;
  S tmp___2 ;

  {
  tmp = strlen((char const   *)a);
  b___1 = (I )tmp;
  tmp___0 = alloc((size_t )(b___1 + 2LL));
  tmp___1 = strcpy((char * __restrict  )tmp___0, (char const   * __restrict  )a);
  c = tmp___1;
  if (! c) {
    return ((S )0);
  }
  *(c + b___1) = (C )'.';
  *(c + (b___1 + 1LL)) = (C )'\000';
  tmp___2 = sp(c);
  d___0 = tmp___2;
  free((void *)c);
  return (d___0);
}
}
K not_attribute(K a ) 
{ 
  I t ;
  I n ;
  K z ;
  I i ;
  I _i___0 ;
  S tmp ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  struct k0 *tmp___0 ;
  K tmp___1 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;

  {
  t = a->t;
  n = a->n;
  if (t < 0LL) {
    tmp___5 = - t;
  } else {
    tmp___5 = t;
  }
  if (4LL == tmp___5) {
    z = newK(t, n);
    if (! z) {
      return ((K )0);
    }
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      tmp = notsp(*((S *)(a->k) + i));
      *((S *)(z->k) + i) = tmp;
      if (! tmp) {
        cd(z);
        return ((K )0);
      }
      i ++;
    }
  } else {
    if (t < 0LL) {
      tmp___4 = - t;
    } else {
      tmp___4 = t;
    }
    if (2LL == tmp___4) {
      z = newK(t / 2LL, n);
      if (! z) {
        return ((K )0);
      }
      i___0 = (I )0;
      _i___1 = n;
      while (i___0 < _i___1) {
        if ((F )0 == *((F *)(a->k) + i___0)) {
          *((I *)(z->k) + i___0) = (I )1;
        } else {
          *((I *)(z->k) + i___0) = (I )0;
        }
        i___0 ++;
      }
    } else {
      if (t < 0LL) {
        tmp___3 = - t;
      } else {
        tmp___3 = t;
      }
      if (1LL == tmp___3) {
        z = newK(t, n);
        if (! z) {
          return ((K )0);
        }
        i___1 = (I )0;
        _i___2 = n;
        while (i___1 < _i___2) {
          if (0LL == *((I *)(a->k) + i___1)) {
            *((I *)(z->k) + i___1) = (I )1;
          } else {
            *((I *)(z->k) + i___1) = (I )0;
          }
          i___1 ++;
        }
      } else {
        if (t < 0LL) {
          tmp___2 = - t;
        } else {
          tmp___2 = t;
        }
        if (0LL == tmp___2) {
          z = newK(t, n);
          if (! z) {
            return ((K )0);
          }
          i___2 = (I )0;
          _i___3 = n;
          while (i___2 < _i___3) {
            tmp___0 = not_attribute(a->k[i___2]);
            z->k[i___2] = tmp___0;
            if (! tmp___0) {
              cd(z);
              return ((K )0);
            }
            i___2 ++;
          }
        } else {
          tmp___1 = kerr("type");
          return (tmp___1);
        }
      }
    }
  }
  return (z);
}
}
static K excl_mkdict(K a , K b___1 ) 
{ 
  I n ;
  K k ;
  K v ;
  K t ;
  K z ;
  I i ;
  I _i___0 ;
  I tmp ;

  {
  n = a->n;
  z = newK((I )5, n);
  if (! z) {
    return ((K )0);
  }
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    v = ci(b___1->k[i]);
    t = newK((I )0, (I )3);
    k = Ks(*((S *)(a->k) + i));
    tmp = OOM_CD((I )0, z, k, t, v, (V )-1);
    if (! tmp) {
      return ((K )0);
    }
    t->k[0] = k;
    t->k[1] = v;
    t->k[2] = _n();
    z->k[i] = t;
    i ++;
  }
  return (z);
}
}
K rotate_mod(K a , K b___1 ) 
{ 
  K tmp ;
  K tmp___0 ;
  I tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  K tmp___4 ;
  K tmp___5 ;

  {
  if (b___1->t > 2LL) {
    tmp = kerr("type");
    return (tmp);
  }
  if (a->t < 0LL) {
    tmp___1 = - a->t;
  } else {
    tmp___1 = a->t;
  }
  if (4LL == tmp___1) {
    if (0LL == b___1->t) {
      if (a->n == b___1->n) {
        tmp___0 = excl_mkdict(a, b___1);
        return (tmp___0);
      }
    }
  }
  if (! (1LL == a->t)) {
    if (! (b___1->t > 0LL)) {
      tmp___2 = kerr("int");
      return (tmp___2);
    }
  }
  if (b___1->t < 1LL) {
    tmp___3 = rotate(a, b___1);
    tmp___5 = tmp___3;
  } else {
    tmp___4 = mod(a, b___1);
    tmp___5 = tmp___4;
  }
  return (tmp___5);
}
}
static K enumerate_charvec(C *pth ) 
{ 
  K z ;
  I len ;
  size_t tmp ;
  K p ;
  K tmp___0 ;

  {
  tmp = strlen((char const   *)pth);
  len = (I )(tmp + 3UL);
  tmp___0 = newK((I )-3, len);
  p = tmp___0;
  snprintf((char * __restrict  )((C *)(p->k)), (size_t )len, (char const   * __restrict  )"ls %s",
           pth);
  z = popen_charvec((C *)(p->k));
  cd(p);
  return (z);
}
}
K enumerate(K a ) 
{ 
  I t ;
  K z ;
  I n ;
  I i ;
  I _i___0 ;
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;
  I n___0 ;
  I x___0 ;
  I p ;
  K e ;
  K r ;
  K s ;
  I i___0 ;
  I _i___1 ;
  K tmp___2 ;
  I i___1 ;
  I _i___2 ;
  I tmp___3 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  I carry ;
  I j ;
  I _j ;
  I n___1 ;
  I tmp___4 ;
  K tmp___5 ;
  I i___4 ;
  I _i___5 ;
  K tmp___6 ;

  {
  t = a->t;
  if (6LL == t) {
    z = newK((I )-4, (I )0);
  } else
  if (5LL == t) {
    n = a->n;
    z = newK((I )-4, n);
    if (! z) {
      return ((K )0);
    }
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      tmp = DI(a, i);
      *((S *)(z->k) + i) = ES(tmp);
      i ++;
    }
  } else
  if (-3LL == t) {
    tmp___0 = enumerate_charvec((C *)(a->k));
    return (tmp___0);
  } else
  if (3LL == t) {
    tmp___0 = enumerate_charvec((C *)(a->k));
    return (tmp___0);
  } else
  if (4LL == t) {
    tmp___1 = kerr("nyi");
    return (tmp___1);
  } else
  if (-1LL == t) {
    n___0 = a->n;
    p = (I )1;
    i___0 = (I )0;
    _i___1 = n___0;
    while (i___0 < _i___1) {
      x___0 = *((I *)(a->k) + i___0);
      p *= x___0;
      if (x___0 < 0LL) {
        tmp___2 = kerr("int");
        return (tmp___2);
      } else
      if (p < 0LL) {
        tmp___2 = kerr("int");
        return (tmp___2);
      }
      i___0 ++;
    }
    if (n___0 == 0LL) {
      p = (I )0;
    }
    z = newK((I )0, p);
    if (! z) {
      return ((K )0);
    }
    if (p > 0LL) {
      i___1 = (I )0;
      _i___2 = p;
      while (i___1 < _i___2) {
        e = newK((I )-1, a->n);
        tmp___3 = OOM_CD((I )0, e, z, (V )-1);
        if (! tmp___3) {
          return ((K )0);
        }
        z->k[i___1] = e;
        i___1 ++;
      }
      r = z->k[0];
      i___2 = (I )0;
      _i___3 = r->n;
      while (i___2 < _i___3) {
        *((I *)(r->k) + i___2) = (I )0;
        i___2 ++;
      }
      i___3 = (I )0;
      _i___4 = p - 1LL;
      while (i___3 < _i___4) {
        r = z->k[i___3];
        s = z->k[i___3 + 1LL];
        carry = (I )1;
        j = (I )0;
        _j = s->n;
        while (j < _j) {
          x___0 = (-1LL + s->n) - j;
          *((I *)(s->k) + x___0) = *((I *)(r->k) + x___0);
          if (carry) {
            (*((I *)(s->k) + x___0)) ++;
            carry = (I )0;
          }
          if (*((I *)(s->k) + x___0) >= *((I *)(a->k) + x___0)) {
            *((I *)(s->k) + x___0) = (I )0;
            carry = (I )1;
          }
          j ++;
        }
        i___3 ++;
      }
    }
    return (z);
  } else
  if (1LL == t) {
    goto _L;
  } else
  if (2LL == t) {
    _L: /* CIL Label */ 
    if (t == 1LL) {
      tmp___4 = *((I *)(a->k));
    } else {
      tmp___4 = (I )*((F *)(a->k));
    }
    n___1 = tmp___4;
    if (n___1 < 0LL) {
      tmp___5 = kerr("domain");
      return (tmp___5);
    }
    z = newK((I )-1, n___1);
    if (! z) {
      return ((K )0);
    }
    i___4 = (I )0;
    _i___5 = n___1;
    while (i___4 < _i___5) {
      *((I *)(z->k) + i___4) = i___4;
      i___4 ++;
    }
  } else {
    tmp___6 = kerr("domain");
    return (tmp___6);
  }
  return (z);
}
}
#pragma merger("0","/tmp/cil-hnUTrN57.i","-g,-pthread,-O3")
K dp(K *z , K (*f)(K  , K  ) , K x___0 , K y ) ;
K power(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  I type ;
  I tmp___1 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  I zt ;
  I tmp___8 ;
  I zn ;
  I tmp___9 ;
  K z ;
  K tmp___10 ;
  F x___0 ;
  F y ;
  I i ;
  I _i___0 ;
  double tmp___11 ;
  double tmp___12 ;
  I i___0 ;
  I _i___1 ;
  double tmp___13 ;
  double tmp___14 ;
  I i___1 ;
  I _i___2 ;
  double tmp___15 ;
  double tmp___16 ;
  I i___2 ;
  I _i___3 ;
  double tmp___17 ;
  double tmp___18 ;
  I i___3 ;
  I _i___4 ;
  double tmp___19 ;
  double tmp___20 ;
  I i___4 ;
  I _i___5 ;
  double tmp___21 ;
  double tmp___22 ;
  I i___5 ;
  I _i___6 ;
  double tmp___23 ;
  double tmp___24 ;
  I i___6 ;
  I _i___7 ;
  double tmp___25 ;
  double tmp___26 ;
  I i___7 ;
  I _i___8 ;
  double tmp___27 ;
  double tmp___28 ;
  I i___8 ;
  I _i___9 ;
  double tmp___29 ;
  double tmp___30 ;
  I i___9 ;
  I _i___10 ;
  double tmp___31 ;
  double tmp___32 ;
  I i___10 ;
  I _i___11 ;
  double tmp___33 ;
  double tmp___34 ;
  I tmp___35 ;
  I tmp___36 ;
  I tmp___37 ;
  I tmp___38 ;
  I tmp___39 ;
  I tmp___40 ;
  I tmp___41 ;
  I tmp___42 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (at___0 < 0LL) {
    tmp___4 = - at___0;
  } else {
    tmp___4 = at___0;
  }
  if (bt < 0LL) {
    tmp___5 = - bt;
  } else {
    tmp___5 = bt;
  }
  if (tmp___4 > tmp___5) {
    if (at___0 < 0LL) {
      tmp___1 = - at___0;
    } else {
      tmp___1 = at___0;
    }
    tmp___3 = tmp___1;
  } else {
    if (bt < 0LL) {
      tmp___2 = - bt;
    } else {
      tmp___2 = bt;
    }
    tmp___3 = tmp___2;
  }
  type = tmp___3;
  if (at___0 <= 0LL) {
    if (bt <= 0LL) {
      if (an != bn) {
        tmp___6 = kerr("length");
        return (tmp___6);
      }
    }
  }
  if (type > 2LL) {
    tmp___7 = kerr("type");
    return (tmp___7);
  }
  zt = type;
  if (at___0 < bt) {
    tmp___8 = at___0;
  } else {
    tmp___8 = bt;
  }
  if (tmp___8 < 1LL) {
    zt = - zt;
  }
  if (! at___0) {
    zt = (I )0;
  } else
  if (! bt) {
    zt = (I )0;
  }
  if (1LL == zt * zt) {
    zt *= 2LL;
  }
  if (at___0 > 0LL) {
    tmp___9 = bn;
  } else {
    tmp___9 = an;
  }
  zn = tmp___9;
  tmp___10 = newK(zt, zn);
  z = tmp___10;
  if (! z) {
    return ((K )0);
  }
  if (at___0 < 0LL) {
    tmp___41 = - at___0;
  } else {
    tmp___41 = at___0;
  }
  if (2LL == tmp___41) {
    if (bt < 0LL) {
      tmp___42 = - bt;
    } else {
      tmp___42 = bt;
    }
    if (2LL == tmp___42) {
      if (an == bn) {
        i = (I )0;
        _i___0 = zn;
        while (i < _i___0) {
          x___0 = *((F *)(a->k) + i);
          y = *((F *)(b___1->k) + i);
          if ((F )0 == y) {
            *((F *)(z->k) + i) = (F )1;
          } else {
            if ((F )0 == x___0) {
              tmp___12 = (double )0;
            } else {
              tmp___11 = pow(x___0, y);
              tmp___12 = tmp___11;
            }
            *((F *)(z->k) + i) = tmp___12;
          }
          i ++;
        }
      } else
      if (an == 1LL) {
        x___0 = *((F *)(a->k) + 0);
        i___0 = (I )0;
        _i___1 = zn;
        while (i___0 < _i___1) {
          y = *((F *)(b___1->k) + i___0);
          if ((F )0 == y) {
            *((F *)(z->k) + i___0) = (F )1;
          } else {
            if ((F )0 == x___0) {
              tmp___14 = (double )0;
            } else {
              tmp___13 = pow(x___0, y);
              tmp___14 = tmp___13;
            }
            *((F *)(z->k) + i___0) = tmp___14;
          }
          i___0 ++;
        }
      } else {
        y = *((F *)(b___1->k) + 0);
        i___1 = (I )0;
        _i___2 = zn;
        while (i___1 < _i___2) {
          x___0 = *((F *)(a->k) + i___1);
          if ((F )0 == y) {
            *((F *)(z->k) + i___1) = (F )1;
          } else {
            if ((F )0 == x___0) {
              tmp___16 = (double )0;
            } else {
              tmp___15 = pow(x___0, y);
              tmp___16 = tmp___15;
            }
            *((F *)(z->k) + i___1) = tmp___16;
          }
          i___1 ++;
        }
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    if (at___0 < 0LL) {
      tmp___39 = - at___0;
    } else {
      tmp___39 = at___0;
    }
    if (2LL == tmp___39) {
      if (bt < 0LL) {
        tmp___40 = - bt;
      } else {
        tmp___40 = bt;
      }
      if (1LL == tmp___40) {
        if (an == bn) {
          i___2 = (I )0;
          _i___3 = zn;
          while (i___2 < _i___3) {
            x___0 = *((F *)(a->k) + i___2);
            y = (F )*((I *)(b___1->k) + i___2);
            if ((F )0 == y) {
              *((F *)(z->k) + i___2) = (F )1;
            } else {
              if ((F )0 == x___0) {
                tmp___18 = (double )0;
              } else {
                tmp___17 = pow(x___0, y);
                tmp___18 = tmp___17;
              }
              *((F *)(z->k) + i___2) = tmp___18;
            }
            i___2 ++;
          }
        } else
        if (an == 1LL) {
          x___0 = *((F *)(a->k) + 0);
          i___3 = (I )0;
          _i___4 = zn;
          while (i___3 < _i___4) {
            y = (F )*((I *)(b___1->k) + i___3);
            if ((F )0 == y) {
              *((F *)(z->k) + i___3) = (F )1;
            } else {
              if ((F )0 == x___0) {
                tmp___20 = (double )0;
              } else {
                tmp___19 = pow(x___0, y);
                tmp___20 = tmp___19;
              }
              *((F *)(z->k) + i___3) = tmp___20;
            }
            i___3 ++;
          }
        } else {
          y = (F )*((I *)(b___1->k) + 0);
          i___4 = (I )0;
          _i___5 = zn;
          while (i___4 < _i___5) {
            x___0 = *((F *)(a->k) + i___4);
            if ((F )0 == y) {
              *((F *)(z->k) + i___4) = (F )1;
            } else {
              if ((F )0 == x___0) {
                tmp___22 = (double )0;
              } else {
                tmp___21 = pow(x___0, y);
                tmp___22 = tmp___21;
              }
              *((F *)(z->k) + i___4) = tmp___22;
            }
            i___4 ++;
          }
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (at___0 < 0LL) {
        tmp___37 = - at___0;
      } else {
        tmp___37 = at___0;
      }
      if (1LL == tmp___37) {
        if (bt < 0LL) {
          tmp___38 = - bt;
        } else {
          tmp___38 = bt;
        }
        if (2LL == tmp___38) {
          if (an == bn) {
            i___5 = (I )0;
            _i___6 = zn;
            while (i___5 < _i___6) {
              x___0 = (F )*((I *)(a->k) + i___5);
              y = *((F *)(b___1->k) + i___5);
              if ((F )0 == y) {
                *((F *)(z->k) + i___5) = (F )1;
              } else {
                if ((F )0 == x___0) {
                  tmp___24 = (double )0;
                } else {
                  tmp___23 = pow(x___0, y);
                  tmp___24 = tmp___23;
                }
                *((F *)(z->k) + i___5) = tmp___24;
              }
              i___5 ++;
            }
          } else
          if (an == 1LL) {
            x___0 = (F )*((I *)(a->k) + 0);
            i___6 = (I )0;
            _i___7 = zn;
            while (i___6 < _i___7) {
              y = *((F *)(b___1->k) + i___6);
              if ((F )0 == y) {
                *((F *)(z->k) + i___6) = (F )1;
              } else {
                if ((F )0 == x___0) {
                  tmp___26 = (double )0;
                } else {
                  tmp___25 = pow(x___0, y);
                  tmp___26 = tmp___25;
                }
                *((F *)(z->k) + i___6) = tmp___26;
              }
              i___6 ++;
            }
          } else {
            y = *((F *)(b___1->k) + 0);
            i___7 = (I )0;
            _i___8 = zn;
            while (i___7 < _i___8) {
              x___0 = (F )*((I *)(a->k) + i___7);
              if ((F )0 == y) {
                *((F *)(z->k) + i___7) = (F )1;
              } else {
                if ((F )0 == x___0) {
                  tmp___28 = (double )0;
                } else {
                  tmp___27 = pow(x___0, y);
                  tmp___28 = tmp___27;
                }
                *((F *)(z->k) + i___7) = tmp___28;
              }
              i___7 ++;
            }
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if (at___0 < 0LL) {
          tmp___35 = - at___0;
        } else {
          tmp___35 = at___0;
        }
        if (1LL == tmp___35) {
          if (bt < 0LL) {
            tmp___36 = - bt;
          } else {
            tmp___36 = bt;
          }
          if (1LL == tmp___36) {
            if (an == bn) {
              i___8 = (I )0;
              _i___9 = zn;
              while (i___8 < _i___9) {
                x___0 = (F )*((I *)(a->k) + i___8);
                y = (F )*((I *)(b___1->k) + i___8);
                if ((F )0 == y) {
                  *((F *)(z->k) + i___8) = (F )1;
                } else {
                  if ((F )0 == x___0) {
                    tmp___30 = (double )0;
                  } else {
                    tmp___29 = pow(x___0, y);
                    tmp___30 = tmp___29;
                  }
                  *((F *)(z->k) + i___8) = tmp___30;
                }
                i___8 ++;
              }
            } else
            if (an == 1LL) {
              x___0 = (F )*((I *)(a->k) + 0);
              i___9 = (I )0;
              _i___10 = zn;
              while (i___9 < _i___10) {
                y = (F )*((I *)(b___1->k) + i___9);
                if ((F )0 == y) {
                  *((F *)(z->k) + i___9) = (F )1;
                } else {
                  if ((F )0 == x___0) {
                    tmp___32 = (double )0;
                  } else {
                    tmp___31 = pow(x___0, y);
                    tmp___32 = tmp___31;
                  }
                  *((F *)(z->k) + i___9) = tmp___32;
                }
                i___9 ++;
              }
            } else {
              y = (F )*((I *)(b___1->k) + 0);
              i___10 = (I )0;
              _i___11 = zn;
              while (i___10 < _i___11) {
                x___0 = (F )*((I *)(a->k) + i___10);
                if ((F )0 == y) {
                  *((F *)(z->k) + i___10) = (F )1;
                } else {
                  if ((F )0 == x___0) {
                    tmp___34 = (double )0;
                  } else {
                    tmp___33 = pow(x___0, y);
                    tmp___34 = tmp___33;
                  }
                  *((F *)(z->k) + i___10) = tmp___34;
                }
                i___10 ++;
              }
            }
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (0LL == at___0) {
          dp(& z, & power, a, b___1);
        } else
        if (0LL == bt) {
          dp(& z, & power, a, b___1);
        }
      }
    }
  }
  return (z);
}
}
K plus(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  I type ;
  I tmp___1 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  I zt ;
  I tmp___8 ;
  I zn ;
  I tmp___9 ;
  K z ;
  K tmp___10 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  I i___4 ;
  I _i___5 ;
  I i___5 ;
  I _i___6 ;
  I i___6 ;
  I _i___7 ;
  I i___7 ;
  I _i___8 ;
  I i___8 ;
  I _i___9 ;
  I i___9 ;
  I _i___10 ;
  I i___10 ;
  I _i___11 ;
  I tmp___11 ;
  I tmp___12 ;
  I tmp___13 ;
  I tmp___14 ;
  I tmp___15 ;
  I tmp___16 ;
  I tmp___17 ;
  I tmp___18 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (at___0 < 0LL) {
    tmp___4 = - at___0;
  } else {
    tmp___4 = at___0;
  }
  if (bt < 0LL) {
    tmp___5 = - bt;
  } else {
    tmp___5 = bt;
  }
  if (tmp___4 > tmp___5) {
    if (at___0 < 0LL) {
      tmp___1 = - at___0;
    } else {
      tmp___1 = at___0;
    }
    tmp___3 = tmp___1;
  } else {
    if (bt < 0LL) {
      tmp___2 = - bt;
    } else {
      tmp___2 = bt;
    }
    tmp___3 = tmp___2;
  }
  type = tmp___3;
  if (at___0 <= 0LL) {
    if (bt <= 0LL) {
      if (an != bn) {
        tmp___6 = kerr("length");
        return (tmp___6);
      }
    }
  }
  if (type > 2LL) {
    tmp___7 = kerr("type");
    return (tmp___7);
  }
  zt = type;
  if (at___0 < bt) {
    tmp___8 = at___0;
  } else {
    tmp___8 = bt;
  }
  if (tmp___8 < 1LL) {
    zt = - zt;
  }
  if (! at___0) {
    zt = (I )0;
  } else
  if (! bt) {
    zt = (I )0;
  }
  if (at___0 > 0LL) {
    tmp___9 = bn;
  } else {
    tmp___9 = an;
  }
  zn = tmp___9;
  tmp___10 = newK(zt, zn);
  z = tmp___10;
  if (! z) {
    return ((K )0);
  }
  if (at___0 < 0LL) {
    tmp___17 = - at___0;
  } else {
    tmp___17 = at___0;
  }
  if (2LL == tmp___17) {
    if (bt < 0LL) {
      tmp___18 = - bt;
    } else {
      tmp___18 = bt;
    }
    if (2LL == tmp___18) {
      if (an == bn) {
        i = (I )0;
        _i___0 = zn;
        while (i < _i___0) {
          *((F *)(z->k) + i) = *((F *)(a->k) + i) + *((F *)(b___1->k) + i);
          i ++;
        }
      } else
      if (an == 1LL) {
        i___0 = (I )0;
        _i___1 = zn;
        while (i___0 < _i___1) {
          *((F *)(z->k) + i___0) = *((F *)(a->k) + 0) + *((F *)(b___1->k) + i___0);
          i___0 ++;
        }
      } else {
        i___1 = (I )0;
        _i___2 = zn;
        while (i___1 < _i___2) {
          *((F *)(z->k) + i___1) = *((F *)(a->k) + i___1) + *((F *)(b___1->k) + 0);
          i___1 ++;
        }
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    if (at___0 < 0LL) {
      tmp___15 = - at___0;
    } else {
      tmp___15 = at___0;
    }
    if (2LL == tmp___15) {
      if (bt < 0LL) {
        tmp___16 = - bt;
      } else {
        tmp___16 = bt;
      }
      if (1LL == tmp___16) {
        if (an == bn) {
          i___2 = (I )0;
          _i___3 = zn;
          while (i___2 < _i___3) {
            *((F *)(z->k) + i___2) = *((F *)(a->k) + i___2) + (F )*((I *)(b___1->k) + i___2);
            i___2 ++;
          }
        } else
        if (an == 1LL) {
          i___3 = (I )0;
          _i___4 = zn;
          while (i___3 < _i___4) {
            *((F *)(z->k) + i___3) = *((F *)(a->k) + 0) + (F )*((I *)(b___1->k) + i___3);
            i___3 ++;
          }
        } else {
          i___4 = (I )0;
          _i___5 = zn;
          while (i___4 < _i___5) {
            *((F *)(z->k) + i___4) = *((F *)(a->k) + i___4) + (F )*((I *)(b___1->k) + 0);
            i___4 ++;
          }
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (at___0 < 0LL) {
        tmp___13 = - at___0;
      } else {
        tmp___13 = at___0;
      }
      if (1LL == tmp___13) {
        if (bt < 0LL) {
          tmp___14 = - bt;
        } else {
          tmp___14 = bt;
        }
        if (2LL == tmp___14) {
          if (an == bn) {
            i___5 = (I )0;
            _i___6 = zn;
            while (i___5 < _i___6) {
              *((F *)(z->k) + i___5) = (F )*((I *)(a->k) + i___5) + *((F *)(b___1->k) + i___5);
              i___5 ++;
            }
          } else
          if (an == 1LL) {
            i___6 = (I )0;
            _i___7 = zn;
            while (i___6 < _i___7) {
              *((F *)(z->k) + i___6) = (F )*((I *)(a->k) + 0) + *((F *)(b___1->k) + i___6);
              i___6 ++;
            }
          } else {
            i___7 = (I )0;
            _i___8 = zn;
            while (i___7 < _i___8) {
              *((F *)(z->k) + i___7) = (F )*((I *)(a->k) + i___7) + *((F *)(b___1->k) + 0);
              i___7 ++;
            }
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if (at___0 < 0LL) {
          tmp___11 = - at___0;
        } else {
          tmp___11 = at___0;
        }
        if (1LL == tmp___11) {
          if (bt < 0LL) {
            tmp___12 = - bt;
          } else {
            tmp___12 = bt;
          }
          if (1LL == tmp___12) {
            if (an == bn) {
              i___8 = (I )0;
              _i___9 = zn;
              while (i___8 < _i___9) {
                *((I *)(z->k) + i___8) = *((I *)(a->k) + i___8) + *((I *)(b___1->k) + i___8);
                i___8 ++;
              }
            } else
            if (an == 1LL) {
              i___9 = (I )0;
              _i___10 = zn;
              while (i___9 < _i___10) {
                *((I *)(z->k) + i___9) = *((I *)(a->k) + 0) + *((I *)(b___1->k) + i___9);
                i___9 ++;
              }
            } else {
              i___10 = (I )0;
              _i___11 = zn;
              while (i___10 < _i___11) {
                *((I *)(z->k) + i___10) = *((I *)(a->k) + i___10) + *((I *)(b___1->k) + 0);
                i___10 ++;
              }
            }
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (0LL == at___0) {
          dp(& z, & plus, a, b___1);
        } else
        if (0LL == bt) {
          dp(& z, & plus, a, b___1);
        }
      }
    }
  }
  return (z);
}
}
K times(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  I type ;
  I tmp___1 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  I zt ;
  I tmp___8 ;
  I zn ;
  I tmp___9 ;
  K z ;
  K tmp___10 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  I i___4 ;
  I _i___5 ;
  I i___5 ;
  I _i___6 ;
  I i___6 ;
  I _i___7 ;
  I i___7 ;
  I _i___8 ;
  I i___8 ;
  I _i___9 ;
  I i___9 ;
  I _i___10 ;
  I i___10 ;
  I _i___11 ;
  I tmp___11 ;
  I tmp___12 ;
  I tmp___13 ;
  I tmp___14 ;
  I tmp___15 ;
  I tmp___16 ;
  I tmp___17 ;
  I tmp___18 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (at___0 < 0LL) {
    tmp___4 = - at___0;
  } else {
    tmp___4 = at___0;
  }
  if (bt < 0LL) {
    tmp___5 = - bt;
  } else {
    tmp___5 = bt;
  }
  if (tmp___4 > tmp___5) {
    if (at___0 < 0LL) {
      tmp___1 = - at___0;
    } else {
      tmp___1 = at___0;
    }
    tmp___3 = tmp___1;
  } else {
    if (bt < 0LL) {
      tmp___2 = - bt;
    } else {
      tmp___2 = bt;
    }
    tmp___3 = tmp___2;
  }
  type = tmp___3;
  if (at___0 <= 0LL) {
    if (bt <= 0LL) {
      if (an != bn) {
        tmp___6 = kerr("length");
        return (tmp___6);
      }
    }
  }
  if (type > 2LL) {
    tmp___7 = kerr("type");
    return (tmp___7);
  }
  zt = type;
  if (at___0 < bt) {
    tmp___8 = at___0;
  } else {
    tmp___8 = bt;
  }
  if (tmp___8 < 1LL) {
    zt = - zt;
  }
  if (! at___0) {
    zt = (I )0;
  } else
  if (! bt) {
    zt = (I )0;
  }
  if (at___0 > 0LL) {
    tmp___9 = bn;
  } else {
    tmp___9 = an;
  }
  zn = tmp___9;
  tmp___10 = newK(zt, zn);
  z = tmp___10;
  if (! z) {
    return ((K )0);
  }
  if (at___0 < 0LL) {
    tmp___17 = - at___0;
  } else {
    tmp___17 = at___0;
  }
  if (2LL == tmp___17) {
    if (bt < 0LL) {
      tmp___18 = - bt;
    } else {
      tmp___18 = bt;
    }
    if (2LL == tmp___18) {
      if (an == bn) {
        i = (I )0;
        _i___0 = zn;
        while (i < _i___0) {
          *((F *)(z->k) + i) = *((F *)(a->k) + i) * *((F *)(b___1->k) + i);
          i ++;
        }
      } else
      if (an == 1LL) {
        i___0 = (I )0;
        _i___1 = zn;
        while (i___0 < _i___1) {
          *((F *)(z->k) + i___0) = *((F *)(a->k) + 0) * *((F *)(b___1->k) + i___0);
          i___0 ++;
        }
      } else {
        i___1 = (I )0;
        _i___2 = zn;
        while (i___1 < _i___2) {
          *((F *)(z->k) + i___1) = *((F *)(a->k) + i___1) * *((F *)(b___1->k) + 0);
          i___1 ++;
        }
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    if (at___0 < 0LL) {
      tmp___15 = - at___0;
    } else {
      tmp___15 = at___0;
    }
    if (2LL == tmp___15) {
      if (bt < 0LL) {
        tmp___16 = - bt;
      } else {
        tmp___16 = bt;
      }
      if (1LL == tmp___16) {
        if (an == bn) {
          i___2 = (I )0;
          _i___3 = zn;
          while (i___2 < _i___3) {
            *((F *)(z->k) + i___2) = *((F *)(a->k) + i___2) * (F )*((I *)(b___1->k) + i___2);
            i___2 ++;
          }
        } else
        if (an == 1LL) {
          i___3 = (I )0;
          _i___4 = zn;
          while (i___3 < _i___4) {
            *((F *)(z->k) + i___3) = *((F *)(a->k) + 0) * (F )*((I *)(b___1->k) + i___3);
            i___3 ++;
          }
        } else {
          i___4 = (I )0;
          _i___5 = zn;
          while (i___4 < _i___5) {
            *((F *)(z->k) + i___4) = *((F *)(a->k) + i___4) * (F )*((I *)(b___1->k) + 0);
            i___4 ++;
          }
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (at___0 < 0LL) {
        tmp___13 = - at___0;
      } else {
        tmp___13 = at___0;
      }
      if (1LL == tmp___13) {
        if (bt < 0LL) {
          tmp___14 = - bt;
        } else {
          tmp___14 = bt;
        }
        if (2LL == tmp___14) {
          if (an == bn) {
            i___5 = (I )0;
            _i___6 = zn;
            while (i___5 < _i___6) {
              *((F *)(z->k) + i___5) = (F )*((I *)(a->k) + i___5) * *((F *)(b___1->k) + i___5);
              i___5 ++;
            }
          } else
          if (an == 1LL) {
            i___6 = (I )0;
            _i___7 = zn;
            while (i___6 < _i___7) {
              *((F *)(z->k) + i___6) = (F )*((I *)(a->k) + 0) * *((F *)(b___1->k) + i___6);
              i___6 ++;
            }
          } else {
            i___7 = (I )0;
            _i___8 = zn;
            while (i___7 < _i___8) {
              *((F *)(z->k) + i___7) = (F )*((I *)(a->k) + i___7) * *((F *)(b___1->k) + 0);
              i___7 ++;
            }
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if (at___0 < 0LL) {
          tmp___11 = - at___0;
        } else {
          tmp___11 = at___0;
        }
        if (1LL == tmp___11) {
          if (bt < 0LL) {
            tmp___12 = - bt;
          } else {
            tmp___12 = bt;
          }
          if (1LL == tmp___12) {
            if (an == bn) {
              i___8 = (I )0;
              _i___9 = zn;
              while (i___8 < _i___9) {
                *((I *)(z->k) + i___8) = *((I *)(a->k) + i___8) * *((I *)(b___1->k) + i___8);
                i___8 ++;
              }
            } else
            if (an == 1LL) {
              i___9 = (I )0;
              _i___10 = zn;
              while (i___9 < _i___10) {
                *((I *)(z->k) + i___9) = *((I *)(a->k) + 0) * *((I *)(b___1->k) + i___9);
                i___9 ++;
              }
            } else {
              i___10 = (I )0;
              _i___11 = zn;
              while (i___10 < _i___11) {
                *((I *)(z->k) + i___10) = *((I *)(a->k) + i___10) * *((I *)(b___1->k) + 0);
                i___10 ++;
              }
            }
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (0LL == at___0) {
          dp(& z, & times, a, b___1);
        } else
        if (0LL == bt) {
          dp(& z, & times, a, b___1);
        }
      }
    }
  }
  return (z);
}
}
K _dot(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  I type ;
  I tmp___1 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  I zt ;
  I tmp___8 ;
  I zn ;
  I tmp___9 ;
  I A ;
  I tmp___10 ;
  I B ;
  I tmp___11 ;
  I accI ;
  F accF ;
  F x___0 ;
  F y ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  F x___1 ;
  I y___0 ;
  I i___2 ;
  I _i___3 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  I i___3 ;
  I _i___4 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  I i___4 ;
  I _i___5 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  I x___2 ;
  F y___1 ;
  I i___5 ;
  I _i___6 ;
  double tmp___21 ;
  double tmp___22 ;
  double tmp___23 ;
  I i___6 ;
  I _i___7 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  I i___7 ;
  I _i___8 ;
  double tmp___27 ;
  double tmp___28 ;
  double tmp___29 ;
  I x___3 ;
  I y___2 ;
  I i___8 ;
  I _i___9 ;
  I i___9 ;
  I _i___10 ;
  I i___10 ;
  I _i___11 ;
  V p[2] ;
  K x___4 ;
  K y___3 ;
  K tmp___30 ;
  K tmp___32 ;
  K tmp___33 ;
  K tmp___34 ;
  I tmp___35 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (at___0 < 0LL) {
    tmp___4 = - at___0;
  } else {
    tmp___4 = at___0;
  }
  if (bt < 0LL) {
    tmp___5 = - bt;
  } else {
    tmp___5 = bt;
  }
  if (tmp___4 > tmp___5) {
    if (at___0 < 0LL) {
      tmp___1 = - at___0;
    } else {
      tmp___1 = at___0;
    }
    tmp___3 = tmp___1;
  } else {
    if (bt < 0LL) {
      tmp___2 = - bt;
    } else {
      tmp___2 = bt;
    }
    tmp___3 = tmp___2;
  }
  type = tmp___3;
  if (at___0 <= 0LL) {
    if (bt <= 0LL) {
      if (an != bn) {
        tmp___6 = kerr("length");
        return (tmp___6);
      }
    }
  }
  if (type > 2LL) {
    tmp___7 = kerr("type");
    return (tmp___7);
  }
  zt = type;
  if (at___0 < bt) {
    tmp___8 = at___0;
  } else {
    tmp___8 = bt;
  }
  if (tmp___8 < 1LL) {
    zt = - zt;
  }
  if (! at___0) {
    zt = (I )0;
  } else
  if (! bt) {
    zt = (I )0;
  }
  if (at___0 > 0LL) {
    tmp___9 = bn;
  } else {
    tmp___9 = an;
  }
  zn = tmp___9;
  if (at___0 < 0LL) {
    tmp___10 = - at___0;
  } else {
    tmp___10 = at___0;
  }
  A = tmp___10;
  if (bt < 0LL) {
    tmp___11 = - bt;
  } else {
    tmp___11 = bt;
  }
  B = tmp___11;
  accI = (I )0;
  accF = 0.0;
  if (2LL == A) {
    if (2LL == B) {
      if (an == bn) {
        i = (I )0;
        _i___0 = zn;
        while (i < _i___0) {
          x___0 = *((F *)(a->k) + i);
          y = *((F *)(b___1->k) + i);
          accF += x___0 * y;
          i ++;
        }
      } else
      if (an == 1LL) {
        x___0 = *((F *)(a->k) + 0);
        i___0 = (I )0;
        _i___1 = zn;
        while (i___0 < _i___1) {
          y = *((F *)(b___1->k) + i___0);
          accF += x___0 * y;
          i___0 ++;
        }
      } else {
        y = *((F *)(b___1->k) + 0);
        i___1 = (I )0;
        _i___2 = zn;
        while (i___1 < _i___2) {
          x___0 = *((F *)(a->k) + i___1);
          accF += x___0 * y;
          i___1 ++;
        }
      }
    } else {
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
  if (2LL == A) {
    if (1LL == B) {
      if (an == bn) {
        i___2 = (I )0;
        _i___3 = zn;
        while (i___2 < _i___3) {
          x___1 = *((F *)(a->k) + i___2);
          y___0 = *((I *)(b___1->k) + i___2);
          if (9223372036854775807LL == y___0) {
            tmp___14 = (double )1 / 0.;
          } else {
            if (-9223372036854775807LL == y___0) {
              tmp___13 = - ((double )1 / 0.);
            } else {
              if ((-0x7FFFFFFFFFFFFFFF-1) == y___0) {
                tmp___12 = (double )0 / 0.;
              } else {
                tmp___12 = (double )y___0;
              }
              tmp___13 = tmp___12;
            }
            tmp___14 = tmp___13;
          }
          accF += x___1 * tmp___14;
          i___2 ++;
        }
      } else
      if (an == 1LL) {
        x___1 = *((F *)(a->k) + 0);
        i___3 = (I )0;
        _i___4 = zn;
        while (i___3 < _i___4) {
          y___0 = *((I *)(b___1->k) + i___3);
          if (9223372036854775807LL == y___0) {
            tmp___17 = (double )1 / 0.;
          } else {
            if (-9223372036854775807LL == y___0) {
              tmp___16 = - ((double )1 / 0.);
            } else {
              if ((-0x7FFFFFFFFFFFFFFF-1) == y___0) {
                tmp___15 = (double )0 / 0.;
              } else {
                tmp___15 = (double )y___0;
              }
              tmp___16 = tmp___15;
            }
            tmp___17 = tmp___16;
          }
          accF += x___1 * tmp___17;
          i___3 ++;
        }
      } else {
        y___0 = *((I *)(b___1->k) + 0);
        i___4 = (I )0;
        _i___5 = zn;
        while (i___4 < _i___5) {
          x___1 = *((F *)(a->k) + i___4);
          if (9223372036854775807LL == y___0) {
            tmp___20 = (double )1 / 0.;
          } else {
            if (-9223372036854775807LL == y___0) {
              tmp___19 = - ((double )1 / 0.);
            } else {
              if ((-0x7FFFFFFFFFFFFFFF-1) == y___0) {
                tmp___18 = (double )0 / 0.;
              } else {
                tmp___18 = (double )y___0;
              }
              tmp___19 = tmp___18;
            }
            tmp___20 = tmp___19;
          }
          accF += x___1 * tmp___20;
          i___4 ++;
        }
      }
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (1LL == A) {
    if (2LL == B) {
      if (an == bn) {
        i___5 = (I )0;
        _i___6 = zn;
        while (i___5 < _i___6) {
          x___2 = *((I *)(a->k) + i___5);
          y___1 = *((F *)(b___1->k) + i___5);
          if (9223372036854775807LL == x___2) {
            tmp___23 = (double )1 / 0.;
          } else {
            if (-9223372036854775807LL == x___2) {
              tmp___22 = - ((double )1 / 0.);
            } else {
              if ((-0x7FFFFFFFFFFFFFFF-1) == x___2) {
                tmp___21 = (double )0 / 0.;
              } else {
                tmp___21 = (double )x___2;
              }
              tmp___22 = tmp___21;
            }
            tmp___23 = tmp___22;
          }
          accF += tmp___23 * y___1;
          i___5 ++;
        }
      } else
      if (an == 1LL) {
        x___2 = *((I *)(a->k) + 0);
        i___6 = (I )0;
        _i___7 = zn;
        while (i___6 < _i___7) {
          y___1 = *((F *)(b___1->k) + i___6);
          if (9223372036854775807LL == x___2) {
            tmp___26 = (double )1 / 0.;
          } else {
            if (-9223372036854775807LL == x___2) {
              tmp___25 = - ((double )1 / 0.);
            } else {
              if ((-0x7FFFFFFFFFFFFFFF-1) == x___2) {
                tmp___24 = (double )0 / 0.;
              } else {
                tmp___24 = (double )x___2;
              }
              tmp___25 = tmp___24;
            }
            tmp___26 = tmp___25;
          }
          accF += tmp___26 * y___1;
          i___6 ++;
        }
      } else {
        y___1 = *((F *)(b___1->k) + 0);
        i___7 = (I )0;
        _i___8 = zn;
        while (i___7 < _i___8) {
          x___2 = *((I *)(a->k) + i___7);
          if (9223372036854775807LL == x___2) {
            tmp___29 = (double )1 / 0.;
          } else {
            if (-9223372036854775807LL == x___2) {
              tmp___28 = - ((double )1 / 0.);
            } else {
              if ((-0x7FFFFFFFFFFFFFFF-1) == x___2) {
                tmp___27 = (double )0 / 0.;
              } else {
                tmp___27 = (double )x___2;
              }
              tmp___28 = tmp___27;
            }
            tmp___29 = tmp___28;
          }
          accF += tmp___29 * y___1;
          i___7 ++;
        }
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (1LL == A) {
    if (1LL == B) {
      if (an == bn) {
        i___8 = (I )0;
        _i___9 = zn;
        while (i___8 < _i___9) {
          x___3 = *((I *)(a->k) + i___8);
          y___2 = *((I *)(b___1->k) + i___8);
          accI += x___3 * y___2;
          i___8 ++;
        }
      } else
      if (an == 1LL) {
        x___3 = *((I *)(a->k) + 0);
        i___9 = (I )0;
        _i___10 = zn;
        while (i___9 < _i___10) {
          y___2 = *((I *)(b___1->k) + i___9);
          accI += x___3 * y___2;
          i___9 ++;
        }
      } else {
        y___2 = *((I *)(b___1->k) + 0);
        i___10 = (I )0;
        _i___11 = zn;
        while (i___10 < _i___11) {
          x___3 = *((I *)(a->k) + i___10);
          accI += x___3 * y___2;
          i___10 ++;
        }
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (0LL == A) {
    goto _L;
  } else
  if (0LL == B) {
    _L: /* CIL Label */ 
    p[0] = (V )0;
    p[1] = (V )22;
    x___4 = times(a, b___1);
    tmp___30 = overDyad((K )0, p + 2, x___4);
    y___3 = tmp___30;
    cd(x___4);
    return (y___3);
  }
  if (zt < 0LL) {
    tmp___35 = - zt;
  } else {
    tmp___35 = zt;
  }
  if (1LL == tmp___35) {
    tmp___32 = Ki(accI);
    tmp___34 = tmp___32;
  } else {
    tmp___33 = Kf(accF);
    tmp___34 = tmp___33;
  }
  return (tmp___34);
}
}
K mod(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  K tmp ;
  I tmp___0 ;
  I t ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  I tmp___6 ;
  I tmp___7 ;
  int tmp___8 ;
  I tmp___9 ;
  K z ;
  K tmp___10 ;
  I c ;
  I d___0 ;
  I e ;
  F f ;
  F g ;
  F h ;
  F ct ;
  I i ;
  I _i___0 ;
  double tmp___11 ;
  F tmp___13 ;
  I i___0 ;
  I _i___1 ;
  double tmp___14 ;
  F tmp___16 ;
  I i___1 ;
  I _i___2 ;
  double tmp___17 ;
  F tmp___19 ;
  I i___2 ;
  I _i___3 ;
  double tmp___20 ;
  I i___3 ;
  I _i___4 ;
  struct k0 *tmp___21 ;
  I tmp___22 ;
  I tmp___23 ;
  I tmp___24 ;
  I tmp___25 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  if (at___0 < 0LL) {
    tmp___0 = - at___0;
  } else {
    tmp___0 = at___0;
  }
  if (tmp___0 > 2LL) {
    tmp = kerr("type");
    return (tmp);
  }
  if (0LL == at___0) {
    tmp___9 = (I )0;
  } else {
    if (at___0 < 0LL) {
      tmp___6 = - at___0;
    } else {
      tmp___6 = at___0;
    }
    if (bt < 0LL) {
      tmp___7 = - bt;
    } else {
      tmp___7 = bt;
    }
    if (tmp___6 > tmp___7) {
      if (at___0 < 0LL) {
        tmp___3 = - at___0;
      } else {
        tmp___3 = at___0;
      }
      tmp___5 = tmp___3;
    } else {
      if (bt < 0LL) {
        tmp___4 = - bt;
      } else {
        tmp___4 = bt;
      }
      tmp___5 = tmp___4;
    }
    if (at___0 > 0LL) {
      tmp___8 = 1;
    } else {
      tmp___8 = -1;
    }
    tmp___9 = tmp___5 * (I )tmp___8;
  }
  t = tmp___9;
  tmp___10 = newK(t, an);
  z = tmp___10;
  if (! z) {
    return ((K )0);
  }
  ct = 1e-13;
  if (at___0 < 0LL) {
    tmp___25 = - at___0;
  } else {
    tmp___25 = at___0;
  }
  if (2LL == tmp___25) {
    if (2LL == bt) {
      g = *((F *)(b___1->k));
      i = (I )0;
      _i___0 = an;
      while (i < _i___0) {
        f = *((F *)(a->k) + i);
        if (g) {
          tmp___11 = floor(ct + f / g);
          h = f - g * tmp___11;
        } else {
          h = f;
        }
        if (h < (F )0) {
          tmp___13 = - h;
        } else {
          tmp___13 = h;
        }
        if (tmp___13 > ct) {
          *((F *)(z->k) + i) = h;
        } else {
          *((F *)(z->k) + i) = (F )0;
        }
        i ++;
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    if (at___0 < 0LL) {
      tmp___24 = - at___0;
    } else {
      tmp___24 = at___0;
    }
    if (2LL == tmp___24) {
      if (1LL == bt) {
        g = (F )*((I *)(b___1->k));
        i___0 = (I )0;
        _i___1 = an;
        while (i___0 < _i___1) {
          f = *((F *)(a->k) + i___0);
          if (g) {
            tmp___14 = floor(ct + f / g);
            h = f - g * tmp___14;
          } else {
            h = f;
          }
          if (h < (F )0) {
            tmp___16 = - h;
          } else {
            tmp___16 = h;
          }
          if (tmp___16 > ct) {
            *((F *)(z->k) + i___0) = h;
          } else {
            *((F *)(z->k) + i___0) = (F )0;
          }
          i___0 ++;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (at___0 < 0LL) {
        tmp___23 = - at___0;
      } else {
        tmp___23 = at___0;
      }
      if (1LL == tmp___23) {
        if (2LL == bt) {
          g = *((F *)(b___1->k));
          i___1 = (I )0;
          _i___2 = an;
          while (i___1 < _i___2) {
            f = (F )*((I *)(a->k) + i___1);
            if (g) {
              tmp___17 = floor(ct + f / g);
              h = f - g * tmp___17;
            } else {
              h = f;
            }
            if (h < (F )0) {
              tmp___19 = - h;
            } else {
              tmp___19 = h;
            }
            if (tmp___19 > ct) {
              *((F *)(z->k) + i___1) = h;
            } else {
              *((F *)(z->k) + i___1) = (F )0;
            }
            i___1 ++;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if (at___0 < 0LL) {
          tmp___22 = - at___0;
        } else {
          tmp___22 = at___0;
        }
        if (1LL == tmp___22) {
          if (1LL == bt) {
            d___0 = *((I *)(b___1->k));
            g = (F )d___0;
            i___2 = (I )0;
            _i___3 = an;
            while (i___2 < _i___3) {
              c = *((I *)(a->k) + i___2);
              if (d___0) {
                tmp___20 = floor((F )c / g);
                e = (I )((double )c - (double )d___0 * tmp___20);
              } else {
                e = c;
              }
              *((I *)(z->k) + i___2) = e;
              i___2 ++;
            }
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (0LL == at___0) {
          i___3 = (I )0;
          _i___4 = an;
          while (i___3 < _i___4) {
            tmp___21 = mod(a->k[i___3], b___1);
            z->k[i___3] = tmp___21;
            if (! tmp___21) {
              cd(z);
              return ((K )0);
            }
            i___3 ++;
          }
        }
      }
    }
  }
  return (z);
}
}
K minus(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  I type ;
  I tmp___1 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  I zt ;
  I tmp___8 ;
  I zn ;
  I tmp___9 ;
  K z ;
  K tmp___10 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  I i___4 ;
  I _i___5 ;
  I i___5 ;
  I _i___6 ;
  I i___6 ;
  I _i___7 ;
  I i___7 ;
  I _i___8 ;
  I i___8 ;
  I _i___9 ;
  I i___9 ;
  I _i___10 ;
  I i___10 ;
  I _i___11 ;
  I tmp___11 ;
  I tmp___12 ;
  I tmp___13 ;
  I tmp___14 ;
  I tmp___15 ;
  I tmp___16 ;
  I tmp___17 ;
  I tmp___18 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (at___0 < 0LL) {
    tmp___4 = - at___0;
  } else {
    tmp___4 = at___0;
  }
  if (bt < 0LL) {
    tmp___5 = - bt;
  } else {
    tmp___5 = bt;
  }
  if (tmp___4 > tmp___5) {
    if (at___0 < 0LL) {
      tmp___1 = - at___0;
    } else {
      tmp___1 = at___0;
    }
    tmp___3 = tmp___1;
  } else {
    if (bt < 0LL) {
      tmp___2 = - bt;
    } else {
      tmp___2 = bt;
    }
    tmp___3 = tmp___2;
  }
  type = tmp___3;
  if (at___0 <= 0LL) {
    if (bt <= 0LL) {
      if (an != bn) {
        tmp___6 = kerr("length");
        return (tmp___6);
      }
    }
  }
  if (type > 2LL) {
    tmp___7 = kerr("type");
    return (tmp___7);
  }
  zt = type;
  if (at___0 < bt) {
    tmp___8 = at___0;
  } else {
    tmp___8 = bt;
  }
  if (tmp___8 < 1LL) {
    zt = - zt;
  }
  if (! at___0) {
    zt = (I )0;
  } else
  if (! bt) {
    zt = (I )0;
  }
  if (at___0 > 0LL) {
    tmp___9 = bn;
  } else {
    tmp___9 = an;
  }
  zn = tmp___9;
  tmp___10 = newK(zt, zn);
  z = tmp___10;
  if (! z) {
    return ((K )0);
  }
  if (at___0 < 0LL) {
    tmp___17 = - at___0;
  } else {
    tmp___17 = at___0;
  }
  if (2LL == tmp___17) {
    if (bt < 0LL) {
      tmp___18 = - bt;
    } else {
      tmp___18 = bt;
    }
    if (2LL == tmp___18) {
      if (an == bn) {
        i = (I )0;
        _i___0 = zn;
        while (i < _i___0) {
          *((F *)(z->k) + i) = *((F *)(a->k) + i) - *((F *)(b___1->k) + i);
          i ++;
        }
      } else
      if (an == 1LL) {
        i___0 = (I )0;
        _i___1 = zn;
        while (i___0 < _i___1) {
          *((F *)(z->k) + i___0) = *((F *)(a->k) + 0) - *((F *)(b___1->k) + i___0);
          i___0 ++;
        }
      } else {
        i___1 = (I )0;
        _i___2 = zn;
        while (i___1 < _i___2) {
          *((F *)(z->k) + i___1) = *((F *)(a->k) + i___1) - *((F *)(b___1->k) + 0);
          i___1 ++;
        }
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    if (at___0 < 0LL) {
      tmp___15 = - at___0;
    } else {
      tmp___15 = at___0;
    }
    if (2LL == tmp___15) {
      if (bt < 0LL) {
        tmp___16 = - bt;
      } else {
        tmp___16 = bt;
      }
      if (1LL == tmp___16) {
        if (an == bn) {
          i___2 = (I )0;
          _i___3 = zn;
          while (i___2 < _i___3) {
            *((F *)(z->k) + i___2) = *((F *)(a->k) + i___2) - (F )*((I *)(b___1->k) + i___2);
            i___2 ++;
          }
        } else
        if (an == 1LL) {
          i___3 = (I )0;
          _i___4 = zn;
          while (i___3 < _i___4) {
            *((F *)(z->k) + i___3) = *((F *)(a->k) + 0) - (F )*((I *)(b___1->k) + i___3);
            i___3 ++;
          }
        } else {
          i___4 = (I )0;
          _i___5 = zn;
          while (i___4 < _i___5) {
            *((F *)(z->k) + i___4) = *((F *)(a->k) + i___4) - (F )*((I *)(b___1->k) + 0);
            i___4 ++;
          }
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (at___0 < 0LL) {
        tmp___13 = - at___0;
      } else {
        tmp___13 = at___0;
      }
      if (1LL == tmp___13) {
        if (bt < 0LL) {
          tmp___14 = - bt;
        } else {
          tmp___14 = bt;
        }
        if (2LL == tmp___14) {
          if (an == bn) {
            i___5 = (I )0;
            _i___6 = zn;
            while (i___5 < _i___6) {
              *((F *)(z->k) + i___5) = (F )*((I *)(a->k) + i___5) - *((F *)(b___1->k) + i___5);
              i___5 ++;
            }
          } else
          if (an == 1LL) {
            i___6 = (I )0;
            _i___7 = zn;
            while (i___6 < _i___7) {
              *((F *)(z->k) + i___6) = (F )*((I *)(a->k) + 0) - *((F *)(b___1->k) + i___6);
              i___6 ++;
            }
          } else {
            i___7 = (I )0;
            _i___8 = zn;
            while (i___7 < _i___8) {
              *((F *)(z->k) + i___7) = (F )*((I *)(a->k) + i___7) - *((F *)(b___1->k) + 0);
              i___7 ++;
            }
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if (at___0 < 0LL) {
          tmp___11 = - at___0;
        } else {
          tmp___11 = at___0;
        }
        if (1LL == tmp___11) {
          if (bt < 0LL) {
            tmp___12 = - bt;
          } else {
            tmp___12 = bt;
          }
          if (1LL == tmp___12) {
            if (an == bn) {
              i___8 = (I )0;
              _i___9 = zn;
              while (i___8 < _i___9) {
                *((I *)(z->k) + i___8) = *((I *)(a->k) + i___8) - *((I *)(b___1->k) + i___8);
                i___8 ++;
              }
            } else
            if (an == 1LL) {
              i___9 = (I )0;
              _i___10 = zn;
              while (i___9 < _i___10) {
                *((I *)(z->k) + i___9) = *((I *)(a->k) + 0) - *((I *)(b___1->k) + i___9);
                i___9 ++;
              }
            } else {
              i___10 = (I )0;
              _i___11 = zn;
              while (i___10 < _i___11) {
                *((I *)(z->k) + i___10) = *((I *)(a->k) + i___10) - *((I *)(b___1->k) + 0);
                i___10 ++;
              }
            }
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (0LL == at___0) {
          dp(& z, & minus, a, b___1);
        } else
        if (0LL == bt) {
          dp(& z, & minus, a, b___1);
        }
      }
    }
  }
  return (z);
}
}
K negate(K x___0 ) 
{ 
  K y ;
  K z ;

  {
  y = Ki((I )0);
  if (! y) {
    return ((K )0);
  }
  z = minus(y, x___0);
  cd(y);
  return (z);
}
}
K divide(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  I type ;
  I tmp___1 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  I zt ;
  I tmp___8 ;
  I zn ;
  I tmp___9 ;
  K z ;
  K tmp___10 ;
  F u ;
  F d___0 ;
  F y ;
  I s ;
  I t ;
  I w___0 ;
  I i ;
  I _i___0 ;
  I tmp___11 ;
  long long tmp___12 ;
  I i___0 ;
  I _i___1 ;
  I tmp___13 ;
  long long tmp___14 ;
  I i___1 ;
  I _i___2 ;
  I tmp___15 ;
  long long tmp___16 ;
  I tmp___17 ;
  I tmp___18 ;
  I i___2 ;
  I _i___3 ;
  F tmp___19 ;
  double tmp___20 ;
  I i___3 ;
  I _i___4 ;
  F tmp___21 ;
  double tmp___22 ;
  I i___4 ;
  I _i___5 ;
  F tmp___23 ;
  double tmp___24 ;
  I i___5 ;
  I _i___6 ;
  F tmp___25 ;
  double tmp___26 ;
  I i___6 ;
  I _i___7 ;
  F tmp___27 ;
  double tmp___28 ;
  I i___7 ;
  I _i___8 ;
  F tmp___29 ;
  double tmp___30 ;
  I i___8 ;
  I _i___9 ;
  F tmp___31 ;
  double tmp___32 ;
  I i___9 ;
  I _i___10 ;
  F tmp___33 ;
  double tmp___34 ;
  I i___10 ;
  I _i___11 ;
  F tmp___35 ;
  double tmp___36 ;
  I i___11 ;
  I _i___12 ;
  F tmp___37 ;
  double tmp___38 ;
  I i___12 ;
  I _i___13 ;
  F tmp___39 ;
  double tmp___40 ;
  I i___13 ;
  I _i___14 ;
  F tmp___41 ;
  double tmp___42 ;
  I tmp___43 ;
  I tmp___44 ;
  I tmp___45 ;
  I tmp___46 ;
  I tmp___47 ;
  I tmp___48 ;
  I tmp___49 ;
  I tmp___50 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (at___0 < 0LL) {
    tmp___4 = - at___0;
  } else {
    tmp___4 = at___0;
  }
  if (bt < 0LL) {
    tmp___5 = - bt;
  } else {
    tmp___5 = bt;
  }
  if (tmp___4 > tmp___5) {
    if (at___0 < 0LL) {
      tmp___1 = - at___0;
    } else {
      tmp___1 = at___0;
    }
    tmp___3 = tmp___1;
  } else {
    if (bt < 0LL) {
      tmp___2 = - bt;
    } else {
      tmp___2 = bt;
    }
    tmp___3 = tmp___2;
  }
  type = tmp___3;
  if (at___0 <= 0LL) {
    if (bt <= 0LL) {
      if (an != bn) {
        tmp___6 = kerr("length");
        return (tmp___6);
      }
    }
  }
  if (type > 2LL) {
    tmp___7 = kerr("type");
    return (tmp___7);
  }
  zt = type;
  if (at___0 < bt) {
    tmp___8 = at___0;
  } else {
    tmp___8 = bt;
  }
  if (tmp___8 < 1LL) {
    zt = - zt;
  }
  if (! at___0) {
    zt = (I )0;
  } else
  if (! bt) {
    zt = (I )0;
  }
  if (at___0 > 0LL) {
    tmp___9 = bn;
  } else {
    tmp___9 = an;
  }
  zn = tmp___9;
  tmp___10 = newK(zt, zn);
  z = tmp___10;
  if (! z) {
    return ((K )0);
  }
  y = (double )1 / 0.;
  w___0 = 9223372036854775807LL;
  if (at___0 < 0LL) {
    tmp___17 = - at___0;
  } else {
    tmp___17 = at___0;
  }
  if (1LL == tmp___17) {
    if (bt < 0LL) {
      tmp___18 = - bt;
    } else {
      tmp___18 = bt;
    }
    if (1LL == tmp___18) {
      if (an == bn) {
        i = (I )0;
        _i___0 = zn;
        while (i < _i___0) {
          s = *((I *)(a->k) + i);
          t = *((I *)(b___1->k) + i);
          if (! t) {
            if (! s) {
              tmp___12 = (-0x7FFFFFFFFFFFFFFF-1);
            } else {
              if (s > 0LL) {
                tmp___11 = w___0;
              } else {
                tmp___11 = - w___0;
              }
              tmp___12 = tmp___11;
            }
            *((I *)(z->k) + i) = tmp___12;
          } else {
            *((I *)(z->k) + i) = s / t;
          }
          i ++;
        }
      } else
      if (an == 1LL) {
        i___0 = (I )0;
        _i___1 = zn;
        while (i___0 < _i___1) {
          s = *((I *)(a->k) + 0);
          t = *((I *)(b___1->k) + i___0);
          if (! t) {
            if (! s) {
              tmp___14 = (-0x7FFFFFFFFFFFFFFF-1);
            } else {
              if (s > 0LL) {
                tmp___13 = w___0;
              } else {
                tmp___13 = - w___0;
              }
              tmp___14 = tmp___13;
            }
            *((I *)(z->k) + i___0) = tmp___14;
          } else {
            *((I *)(z->k) + i___0) = s / t;
          }
          i___0 ++;
        }
      } else {
        i___1 = (I )0;
        _i___2 = zn;
        while (i___1 < _i___2) {
          s = *((I *)(a->k) + i___1);
          t = *((I *)(b___1->k) + 0);
          if (! t) {
            if (! s) {
              tmp___16 = (-0x7FFFFFFFFFFFFFFF-1);
            } else {
              if (s > 0LL) {
                tmp___15 = w___0;
              } else {
                tmp___15 = - w___0;
              }
              tmp___16 = tmp___15;
            }
            *((I *)(z->k) + i___1) = tmp___16;
          } else {
            *((I *)(z->k) + i___1) = s / t;
          }
          i___1 ++;
        }
      }
      return (z);
    }
  }
  if (at___0 < 0LL) {
    tmp___49 = - at___0;
  } else {
    tmp___49 = at___0;
  }
  if (2LL == tmp___49) {
    if (bt < 0LL) {
      tmp___50 = - bt;
    } else {
      tmp___50 = bt;
    }
    if (2LL == tmp___50) {
      if (an == bn) {
        i___2 = (I )0;
        _i___3 = zn;
        while (i___2 < _i___3) {
          u = *((F *)(a->k) + i___2);
          d___0 = *((F *)(b___1->k) + i___2);
          if (! d___0) {
            if (! u) {
              tmp___20 = (double )0 / 0.;
            } else {
              if (u > (F )0) {
                tmp___19 = y;
              } else {
                tmp___19 = - y;
              }
              tmp___20 = tmp___19;
            }
            *((F *)(z->k) + i___2) = tmp___20;
          } else {
            *((F *)(z->k) + i___2) = u / d___0;
          }
          i___2 ++;
        }
      } else
      if (an == 1LL) {
        u = *((F *)(a->k) + 0);
        i___3 = (I )0;
        _i___4 = zn;
        while (i___3 < _i___4) {
          d___0 = *((F *)(b___1->k) + i___3);
          if (! d___0) {
            if (! u) {
              tmp___22 = (double )0 / 0.;
            } else {
              if (u > (F )0) {
                tmp___21 = y;
              } else {
                tmp___21 = - y;
              }
              tmp___22 = tmp___21;
            }
            *((F *)(z->k) + i___3) = tmp___22;
          } else {
            *((F *)(z->k) + i___3) = u / d___0;
          }
          i___3 ++;
        }
      } else {
        d___0 = *((F *)(b___1->k) + 0);
        i___4 = (I )0;
        _i___5 = zn;
        while (i___4 < _i___5) {
          u = *((F *)(a->k) + i___4);
          if (! d___0) {
            if (! u) {
              tmp___24 = (double )0 / 0.;
            } else {
              if (u > (F )0) {
                tmp___23 = y;
              } else {
                tmp___23 = - y;
              }
              tmp___24 = tmp___23;
            }
            *((F *)(z->k) + i___4) = tmp___24;
          } else {
            *((F *)(z->k) + i___4) = u / d___0;
          }
          i___4 ++;
        }
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    if (at___0 < 0LL) {
      tmp___47 = - at___0;
    } else {
      tmp___47 = at___0;
    }
    if (2LL == tmp___47) {
      if (bt < 0LL) {
        tmp___48 = - bt;
      } else {
        tmp___48 = bt;
      }
      if (1LL == tmp___48) {
        if (an == bn) {
          i___5 = (I )0;
          _i___6 = zn;
          while (i___5 < _i___6) {
            u = *((F *)(a->k) + i___5);
            d___0 = (F )*((I *)(b___1->k) + i___5);
            if (! d___0) {
              if (! u) {
                tmp___26 = (double )0 / 0.;
              } else {
                if (u > (F )0) {
                  tmp___25 = y;
                } else {
                  tmp___25 = - y;
                }
                tmp___26 = tmp___25;
              }
              *((F *)(z->k) + i___5) = tmp___26;
            } else {
              *((F *)(z->k) + i___5) = u / d___0;
            }
            i___5 ++;
          }
        } else
        if (an == 1LL) {
          u = *((F *)(a->k) + 0);
          i___6 = (I )0;
          _i___7 = zn;
          while (i___6 < _i___7) {
            d___0 = (F )*((I *)(b___1->k) + i___6);
            if (! d___0) {
              if (! u) {
                tmp___28 = (double )0 / 0.;
              } else {
                if (u > (F )0) {
                  tmp___27 = y;
                } else {
                  tmp___27 = - y;
                }
                tmp___28 = tmp___27;
              }
              *((F *)(z->k) + i___6) = tmp___28;
            } else {
              *((F *)(z->k) + i___6) = u / d___0;
            }
            i___6 ++;
          }
        } else {
          d___0 = (F )*((I *)(b___1->k) + 0);
          i___7 = (I )0;
          _i___8 = zn;
          while (i___7 < _i___8) {
            u = *((F *)(a->k) + i___7);
            if (! d___0) {
              if (! u) {
                tmp___30 = (double )0 / 0.;
              } else {
                if (u > (F )0) {
                  tmp___29 = y;
                } else {
                  tmp___29 = - y;
                }
                tmp___30 = tmp___29;
              }
              *((F *)(z->k) + i___7) = tmp___30;
            } else {
              *((F *)(z->k) + i___7) = u / d___0;
            }
            i___7 ++;
          }
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (at___0 < 0LL) {
        tmp___45 = - at___0;
      } else {
        tmp___45 = at___0;
      }
      if (1LL == tmp___45) {
        if (bt < 0LL) {
          tmp___46 = - bt;
        } else {
          tmp___46 = bt;
        }
        if (2LL == tmp___46) {
          if (an == bn) {
            i___8 = (I )0;
            _i___9 = zn;
            while (i___8 < _i___9) {
              u = (F )*((I *)(a->k) + i___8);
              d___0 = *((F *)(b___1->k) + i___8);
              if (! d___0) {
                if (! u) {
                  tmp___32 = (double )0 / 0.;
                } else {
                  if (u > (F )0) {
                    tmp___31 = y;
                  } else {
                    tmp___31 = - y;
                  }
                  tmp___32 = tmp___31;
                }
                *((F *)(z->k) + i___8) = tmp___32;
              } else {
                *((F *)(z->k) + i___8) = u / d___0;
              }
              i___8 ++;
            }
          } else
          if (an == 1LL) {
            u = (F )*((I *)(a->k) + 0);
            i___9 = (I )0;
            _i___10 = zn;
            while (i___9 < _i___10) {
              d___0 = *((F *)(b___1->k) + i___9);
              if (! d___0) {
                if (! u) {
                  tmp___34 = (double )0 / 0.;
                } else {
                  if (u > (F )0) {
                    tmp___33 = y;
                  } else {
                    tmp___33 = - y;
                  }
                  tmp___34 = tmp___33;
                }
                *((F *)(z->k) + i___9) = tmp___34;
              } else {
                *((F *)(z->k) + i___9) = u / d___0;
              }
              i___9 ++;
            }
          } else {
            d___0 = *((F *)(b___1->k) + 0);
            i___10 = (I )0;
            _i___11 = zn;
            while (i___10 < _i___11) {
              u = (F )*((I *)(a->k) + i___10);
              if (! d___0) {
                if (! u) {
                  tmp___36 = (double )0 / 0.;
                } else {
                  if (u > (F )0) {
                    tmp___35 = y;
                  } else {
                    tmp___35 = - y;
                  }
                  tmp___36 = tmp___35;
                }
                *((F *)(z->k) + i___10) = tmp___36;
              } else {
                *((F *)(z->k) + i___10) = u / d___0;
              }
              i___10 ++;
            }
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if (at___0 < 0LL) {
          tmp___43 = - at___0;
        } else {
          tmp___43 = at___0;
        }
        if (1LL == tmp___43) {
          if (bt < 0LL) {
            tmp___44 = - bt;
          } else {
            tmp___44 = bt;
          }
          if (1LL == tmp___44) {
            if (an == bn) {
              i___11 = (I )0;
              _i___12 = zn;
              while (i___11 < _i___12) {
                u = (F )*((I *)(a->k) + i___11);
                d___0 = (F )*((I *)(b___1->k) + i___11);
                if (! d___0) {
                  if (! u) {
                    tmp___38 = (double )0 / 0.;
                  } else {
                    if (u > (F )0) {
                      tmp___37 = y;
                    } else {
                      tmp___37 = - y;
                    }
                    tmp___38 = tmp___37;
                  }
                  *((F *)(z->k) + i___11) = tmp___38;
                } else {
                  *((F *)(z->k) + i___11) = u / d___0;
                }
                i___11 ++;
              }
            } else
            if (an == 1LL) {
              u = (F )*((I *)(a->k) + 0);
              i___12 = (I )0;
              _i___13 = zn;
              while (i___12 < _i___13) {
                d___0 = (F )*((I *)(b___1->k) + i___12);
                if (! d___0) {
                  if (! u) {
                    tmp___40 = (double )0 / 0.;
                  } else {
                    if (u > (F )0) {
                      tmp___39 = y;
                    } else {
                      tmp___39 = - y;
                    }
                    tmp___40 = tmp___39;
                  }
                  *((F *)(z->k) + i___12) = tmp___40;
                } else {
                  *((F *)(z->k) + i___12) = u / d___0;
                }
                i___12 ++;
              }
            } else {
              d___0 = (F )*((I *)(b___1->k) + 0);
              i___13 = (I )0;
              _i___14 = zn;
              while (i___13 < _i___14) {
                u = (F )*((I *)(a->k) + i___13);
                if (! d___0) {
                  if (! u) {
                    tmp___42 = (double )0 / 0.;
                  } else {
                    if (u > (F )0) {
                      tmp___41 = y;
                    } else {
                      tmp___41 = - y;
                    }
                    tmp___42 = tmp___41;
                  }
                  *((F *)(z->k) + i___13) = tmp___42;
                } else {
                  *((F *)(z->k) + i___13) = u / d___0;
                }
                i___13 ++;
              }
            }
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (0LL == at___0) {
          dp(& z, & divide, a, b___1);
        } else
        if (0LL == bt) {
          dp(& z, & divide, a, b___1);
        }
      }
    }
  }
  return (z);
}
}
K reciprocal(K x___0 ) 
{ 
  K y ;
  K z ;

  {
  y = Kf((F )1);
  if (! y) {
    return ((K )0);
  }
  z = divide(y, x___0);
  cd(y);
  return (z);
}
}
K min_and(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  I type ;
  I tmp___1 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  I zt ;
  I tmp___8 ;
  I zn ;
  I tmp___9 ;
  K z ;
  K tmp___10 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  I i___4 ;
  I _i___5 ;
  I i___5 ;
  I _i___6 ;
  I i___6 ;
  I _i___7 ;
  I i___7 ;
  I _i___8 ;
  I i___8 ;
  I _i___9 ;
  I i___9 ;
  I _i___10 ;
  I i___10 ;
  I _i___11 ;
  I tmp___11 ;
  I tmp___12 ;
  I tmp___13 ;
  I tmp___14 ;
  I tmp___15 ;
  I tmp___16 ;
  I tmp___17 ;
  I tmp___18 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (at___0 < 0LL) {
    tmp___4 = - at___0;
  } else {
    tmp___4 = at___0;
  }
  if (bt < 0LL) {
    tmp___5 = - bt;
  } else {
    tmp___5 = bt;
  }
  if (tmp___4 > tmp___5) {
    if (at___0 < 0LL) {
      tmp___1 = - at___0;
    } else {
      tmp___1 = at___0;
    }
    tmp___3 = tmp___1;
  } else {
    if (bt < 0LL) {
      tmp___2 = - bt;
    } else {
      tmp___2 = bt;
    }
    tmp___3 = tmp___2;
  }
  type = tmp___3;
  if (at___0 <= 0LL) {
    if (bt <= 0LL) {
      if (an != bn) {
        tmp___6 = kerr("length");
        return (tmp___6);
      }
    }
  }
  if (type > 2LL) {
    tmp___7 = kerr("type");
    return (tmp___7);
  }
  zt = type;
  if (at___0 < bt) {
    tmp___8 = at___0;
  } else {
    tmp___8 = bt;
  }
  if (tmp___8 < 1LL) {
    zt = - zt;
  }
  if (! at___0) {
    zt = (I )0;
  } else
  if (! bt) {
    zt = (I )0;
  }
  if (at___0 > 0LL) {
    tmp___9 = bn;
  } else {
    tmp___9 = an;
  }
  zn = tmp___9;
  tmp___10 = newK(zt, zn);
  z = tmp___10;
  if (! z) {
    return ((K )0);
  }
  if (at___0 < 0LL) {
    tmp___17 = - at___0;
  } else {
    tmp___17 = at___0;
  }
  if (2LL == tmp___17) {
    if (bt < 0LL) {
      tmp___18 = - bt;
    } else {
      tmp___18 = bt;
    }
    if (2LL == tmp___18) {
      if (an == bn) {
        i = (I )0;
        _i___0 = zn;
        while (i < _i___0) {
          if (*((F *)(a->k) + i) < *((F *)(b___1->k) + i)) {
            *((F *)(z->k) + i) = *((F *)(a->k) + i);
          } else {
            *((F *)(z->k) + i) = *((F *)(b___1->k) + i);
          }
          i ++;
        }
      } else
      if (an == 1LL) {
        i___0 = (I )0;
        _i___1 = zn;
        while (i___0 < _i___1) {
          if (*((F *)(a->k) + 0) < *((F *)(b___1->k) + i___0)) {
            *((F *)(z->k) + i___0) = *((F *)(a->k) + 0);
          } else {
            *((F *)(z->k) + i___0) = *((F *)(b___1->k) + i___0);
          }
          i___0 ++;
        }
      } else {
        i___1 = (I )0;
        _i___2 = zn;
        while (i___1 < _i___2) {
          if (*((F *)(a->k) + i___1) < *((F *)(b___1->k) + 0)) {
            *((F *)(z->k) + i___1) = *((F *)(a->k) + i___1);
          } else {
            *((F *)(z->k) + i___1) = *((F *)(b___1->k) + 0);
          }
          i___1 ++;
        }
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    if (at___0 < 0LL) {
      tmp___15 = - at___0;
    } else {
      tmp___15 = at___0;
    }
    if (2LL == tmp___15) {
      if (bt < 0LL) {
        tmp___16 = - bt;
      } else {
        tmp___16 = bt;
      }
      if (1LL == tmp___16) {
        if (an == bn) {
          i___2 = (I )0;
          _i___3 = zn;
          while (i___2 < _i___3) {
            if (*((F *)(a->k) + i___2) < (F )*((I *)(b___1->k) + i___2)) {
              *((F *)(z->k) + i___2) = *((F *)(a->k) + i___2);
            } else {
              *((F *)(z->k) + i___2) = (F )*((I *)(b___1->k) + i___2);
            }
            i___2 ++;
          }
        } else
        if (an == 1LL) {
          i___3 = (I )0;
          _i___4 = zn;
          while (i___3 < _i___4) {
            if (*((F *)(a->k) + 0) < (F )*((I *)(b___1->k) + i___3)) {
              *((F *)(z->k) + i___3) = *((F *)(a->k) + 0);
            } else {
              *((F *)(z->k) + i___3) = (F )*((I *)(b___1->k) + i___3);
            }
            i___3 ++;
          }
        } else {
          i___4 = (I )0;
          _i___5 = zn;
          while (i___4 < _i___5) {
            if (*((F *)(a->k) + i___4) < (F )*((I *)(b___1->k) + 0)) {
              *((F *)(z->k) + i___4) = *((F *)(a->k) + i___4);
            } else {
              *((F *)(z->k) + i___4) = (F )*((I *)(b___1->k) + 0);
            }
            i___4 ++;
          }
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (at___0 < 0LL) {
        tmp___13 = - at___0;
      } else {
        tmp___13 = at___0;
      }
      if (1LL == tmp___13) {
        if (bt < 0LL) {
          tmp___14 = - bt;
        } else {
          tmp___14 = bt;
        }
        if (2LL == tmp___14) {
          if (an == bn) {
            i___5 = (I )0;
            _i___6 = zn;
            while (i___5 < _i___6) {
              if ((F )*((I *)(a->k) + i___5) < *((F *)(b___1->k) + i___5)) {
                *((F *)(z->k) + i___5) = (F )*((I *)(a->k) + i___5);
              } else {
                *((F *)(z->k) + i___5) = *((F *)(b___1->k) + i___5);
              }
              i___5 ++;
            }
          } else
          if (an == 1LL) {
            i___6 = (I )0;
            _i___7 = zn;
            while (i___6 < _i___7) {
              if ((F )*((I *)(a->k) + 0) < *((F *)(b___1->k) + i___6)) {
                *((F *)(z->k) + i___6) = (F )*((I *)(a->k) + 0);
              } else {
                *((F *)(z->k) + i___6) = *((F *)(b___1->k) + i___6);
              }
              i___6 ++;
            }
          } else {
            i___7 = (I )0;
            _i___8 = zn;
            while (i___7 < _i___8) {
              if ((F )*((I *)(a->k) + i___7) < *((F *)(b___1->k) + 0)) {
                *((F *)(z->k) + i___7) = (F )*((I *)(a->k) + i___7);
              } else {
                *((F *)(z->k) + i___7) = *((F *)(b___1->k) + 0);
              }
              i___7 ++;
            }
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if (at___0 < 0LL) {
          tmp___11 = - at___0;
        } else {
          tmp___11 = at___0;
        }
        if (1LL == tmp___11) {
          if (bt < 0LL) {
            tmp___12 = - bt;
          } else {
            tmp___12 = bt;
          }
          if (1LL == tmp___12) {
            if (an == bn) {
              i___8 = (I )0;
              _i___9 = zn;
              while (i___8 < _i___9) {
                if (*((I *)(a->k) + i___8) < *((I *)(b___1->k) + i___8)) {
                  *((I *)(z->k) + i___8) = *((I *)(a->k) + i___8);
                } else {
                  *((I *)(z->k) + i___8) = *((I *)(b___1->k) + i___8);
                }
                i___8 ++;
              }
            } else
            if (an == 1LL) {
              i___9 = (I )0;
              _i___10 = zn;
              while (i___9 < _i___10) {
                if (*((I *)(a->k) + 0) < *((I *)(b___1->k) + i___9)) {
                  *((I *)(z->k) + i___9) = *((I *)(a->k) + 0);
                } else {
                  *((I *)(z->k) + i___9) = *((I *)(b___1->k) + i___9);
                }
                i___9 ++;
              }
            } else {
              i___10 = (I )0;
              _i___11 = zn;
              while (i___10 < _i___11) {
                if (*((I *)(a->k) + i___10) < *((I *)(b___1->k) + 0)) {
                  *((I *)(z->k) + i___10) = *((I *)(a->k) + i___10);
                } else {
                  *((I *)(z->k) + i___10) = *((I *)(b___1->k) + 0);
                }
                i___10 ++;
              }
            }
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (0LL == at___0) {
          dp(& z, & min_and, a, b___1);
        } else
        if (0LL == bt) {
          dp(& z, & min_and, a, b___1);
        }
      }
    }
  }
  return (z);
}
}
K max_or(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  I type ;
  I tmp___1 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  I zt ;
  I tmp___8 ;
  I zn ;
  I tmp___9 ;
  K z ;
  K tmp___10 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  I i___4 ;
  I _i___5 ;
  I i___5 ;
  I _i___6 ;
  I i___6 ;
  I _i___7 ;
  I i___7 ;
  I _i___8 ;
  I i___8 ;
  I _i___9 ;
  I i___9 ;
  I _i___10 ;
  I i___10 ;
  I _i___11 ;
  I tmp___11 ;
  I tmp___12 ;
  I tmp___13 ;
  I tmp___14 ;
  I tmp___15 ;
  I tmp___16 ;
  I tmp___17 ;
  I tmp___18 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (at___0 < 0LL) {
    tmp___4 = - at___0;
  } else {
    tmp___4 = at___0;
  }
  if (bt < 0LL) {
    tmp___5 = - bt;
  } else {
    tmp___5 = bt;
  }
  if (tmp___4 > tmp___5) {
    if (at___0 < 0LL) {
      tmp___1 = - at___0;
    } else {
      tmp___1 = at___0;
    }
    tmp___3 = tmp___1;
  } else {
    if (bt < 0LL) {
      tmp___2 = - bt;
    } else {
      tmp___2 = bt;
    }
    tmp___3 = tmp___2;
  }
  type = tmp___3;
  if (at___0 <= 0LL) {
    if (bt <= 0LL) {
      if (an != bn) {
        tmp___6 = kerr("length");
        return (tmp___6);
      }
    }
  }
  if (type > 2LL) {
    tmp___7 = kerr("type");
    return (tmp___7);
  }
  zt = type;
  if (at___0 < bt) {
    tmp___8 = at___0;
  } else {
    tmp___8 = bt;
  }
  if (tmp___8 < 1LL) {
    zt = - zt;
  }
  if (! at___0) {
    zt = (I )0;
  } else
  if (! bt) {
    zt = (I )0;
  }
  if (at___0 > 0LL) {
    tmp___9 = bn;
  } else {
    tmp___9 = an;
  }
  zn = tmp___9;
  tmp___10 = newK(zt, zn);
  z = tmp___10;
  if (! z) {
    return ((K )0);
  }
  if (at___0 < 0LL) {
    tmp___17 = - at___0;
  } else {
    tmp___17 = at___0;
  }
  if (2LL == tmp___17) {
    if (bt < 0LL) {
      tmp___18 = - bt;
    } else {
      tmp___18 = bt;
    }
    if (2LL == tmp___18) {
      if (an == bn) {
        i = (I )0;
        _i___0 = zn;
        while (i < _i___0) {
          if (*((F *)(a->k) + i) > *((F *)(b___1->k) + i)) {
            *((F *)(z->k) + i) = *((F *)(a->k) + i);
          } else {
            *((F *)(z->k) + i) = *((F *)(b___1->k) + i);
          }
          i ++;
        }
      } else
      if (an == 1LL) {
        i___0 = (I )0;
        _i___1 = zn;
        while (i___0 < _i___1) {
          if (*((F *)(a->k) + 0) > *((F *)(b___1->k) + i___0)) {
            *((F *)(z->k) + i___0) = *((F *)(a->k) + 0);
          } else {
            *((F *)(z->k) + i___0) = *((F *)(b___1->k) + i___0);
          }
          i___0 ++;
        }
      } else {
        i___1 = (I )0;
        _i___2 = zn;
        while (i___1 < _i___2) {
          if (*((F *)(a->k) + i___1) > *((F *)(b___1->k) + 0)) {
            *((F *)(z->k) + i___1) = *((F *)(a->k) + i___1);
          } else {
            *((F *)(z->k) + i___1) = *((F *)(b___1->k) + 0);
          }
          i___1 ++;
        }
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    if (at___0 < 0LL) {
      tmp___15 = - at___0;
    } else {
      tmp___15 = at___0;
    }
    if (2LL == tmp___15) {
      if (bt < 0LL) {
        tmp___16 = - bt;
      } else {
        tmp___16 = bt;
      }
      if (1LL == tmp___16) {
        if (an == bn) {
          i___2 = (I )0;
          _i___3 = zn;
          while (i___2 < _i___3) {
            if (*((F *)(a->k) + i___2) > (F )*((I *)(b___1->k) + i___2)) {
              *((F *)(z->k) + i___2) = *((F *)(a->k) + i___2);
            } else {
              *((F *)(z->k) + i___2) = (F )*((I *)(b___1->k) + i___2);
            }
            i___2 ++;
          }
        } else
        if (an == 1LL) {
          i___3 = (I )0;
          _i___4 = zn;
          while (i___3 < _i___4) {
            if (*((F *)(a->k) + 0) > (F )*((I *)(b___1->k) + i___3)) {
              *((F *)(z->k) + i___3) = *((F *)(a->k) + 0);
            } else {
              *((F *)(z->k) + i___3) = (F )*((I *)(b___1->k) + i___3);
            }
            i___3 ++;
          }
        } else {
          i___4 = (I )0;
          _i___5 = zn;
          while (i___4 < _i___5) {
            if (*((F *)(a->k) + i___4) > (F )*((I *)(b___1->k) + 0)) {
              *((F *)(z->k) + i___4) = *((F *)(a->k) + i___4);
            } else {
              *((F *)(z->k) + i___4) = (F )*((I *)(b___1->k) + 0);
            }
            i___4 ++;
          }
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (at___0 < 0LL) {
        tmp___13 = - at___0;
      } else {
        tmp___13 = at___0;
      }
      if (1LL == tmp___13) {
        if (bt < 0LL) {
          tmp___14 = - bt;
        } else {
          tmp___14 = bt;
        }
        if (2LL == tmp___14) {
          if (an == bn) {
            i___5 = (I )0;
            _i___6 = zn;
            while (i___5 < _i___6) {
              if ((F )*((I *)(a->k) + i___5) > *((F *)(b___1->k) + i___5)) {
                *((F *)(z->k) + i___5) = (F )*((I *)(a->k) + i___5);
              } else {
                *((F *)(z->k) + i___5) = *((F *)(b___1->k) + i___5);
              }
              i___5 ++;
            }
          } else
          if (an == 1LL) {
            i___6 = (I )0;
            _i___7 = zn;
            while (i___6 < _i___7) {
              if ((F )*((I *)(a->k) + 0) > *((F *)(b___1->k) + i___6)) {
                *((F *)(z->k) + i___6) = (F )*((I *)(a->k) + 0);
              } else {
                *((F *)(z->k) + i___6) = *((F *)(b___1->k) + i___6);
              }
              i___6 ++;
            }
          } else {
            i___7 = (I )0;
            _i___8 = zn;
            while (i___7 < _i___8) {
              if ((F )*((I *)(a->k) + i___7) > *((F *)(b___1->k) + 0)) {
                *((F *)(z->k) + i___7) = (F )*((I *)(a->k) + i___7);
              } else {
                *((F *)(z->k) + i___7) = *((F *)(b___1->k) + 0);
              }
              i___7 ++;
            }
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if (at___0 < 0LL) {
          tmp___11 = - at___0;
        } else {
          tmp___11 = at___0;
        }
        if (1LL == tmp___11) {
          if (bt < 0LL) {
            tmp___12 = - bt;
          } else {
            tmp___12 = bt;
          }
          if (1LL == tmp___12) {
            if (an == bn) {
              i___8 = (I )0;
              _i___9 = zn;
              while (i___8 < _i___9) {
                if (*((I *)(a->k) + i___8) > *((I *)(b___1->k) + i___8)) {
                  *((I *)(z->k) + i___8) = *((I *)(a->k) + i___8);
                } else {
                  *((I *)(z->k) + i___8) = *((I *)(b___1->k) + i___8);
                }
                i___8 ++;
              }
            } else
            if (an == 1LL) {
              i___9 = (I )0;
              _i___10 = zn;
              while (i___9 < _i___10) {
                if (*((I *)(a->k) + 0) > *((I *)(b___1->k) + i___9)) {
                  *((I *)(z->k) + i___9) = *((I *)(a->k) + 0);
                } else {
                  *((I *)(z->k) + i___9) = *((I *)(b___1->k) + i___9);
                }
                i___9 ++;
              }
            } else {
              i___10 = (I )0;
              _i___11 = zn;
              while (i___10 < _i___11) {
                if (*((I *)(a->k) + i___10) > *((I *)(b___1->k) + 0)) {
                  *((I *)(z->k) + i___10) = *((I *)(a->k) + i___10);
                } else {
                  *((I *)(z->k) + i___10) = *((I *)(b___1->k) + 0);
                }
                i___10 ++;
              }
            }
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (0LL == at___0) {
          dp(& z, & max_or, a, b___1);
        } else
        if (0LL == bt) {
          dp(& z, & max_or, a, b___1);
        }
      }
    }
  }
  return (z);
}
}
extern int ( /* missing proto */  __builtin_isinf_sign)() ;
K floor_ceil(K a , F (*g)(F  ) ) 
{ 
  int tmp ;
  I at___0 ;
  I an ;
  F (*h)(F  ) ;
  double (*tmp___0)(double __x ) ;
  K tmp___1 ;
  I tmp___2 ;
  K tmp___3 ;
  I tmp___4 ;
  K z ;
  int tmp___5 ;
  int tmp___6 ;
  K tmp___7 ;
  F e ;
  F f ;
  I r ;
  I i ;
  I _i___0 ;
  F tmp___10 ;
  F tmp___11 ;
  I tmp___12 ;
  I tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  I i___0 ;
  I _i___1 ;
  I tmp___16 ;

  {
  tmp = strcmp((char const   *)(errmsg), "(nil)");
  if (tmp) {
    return ((K )0);
  }
  at___0 = a->t;
  an = a->n;
  if ((unsigned long )g == (unsigned long )(& ceil)) {
    tmp___0 = & floor;
  } else {
    tmp___0 = & ceil;
  }
  h = tmp___0;
  if (at___0 < 0LL) {
    tmp___2 = - at___0;
  } else {
    tmp___2 = at___0;
  }
  if (2LL < tmp___2) {
    tmp___1 = kerr("type");
    return (tmp___1);
  } else
  if (0LL == at___0) {
    if (7LL == (a->k[0])->t) {
      tmp___1 = kerr("type");
      return (tmp___1);
    }
  }
  if (at___0 < 0LL) {
    tmp___4 = - at___0;
  } else {
    tmp___4 = at___0;
  }
  if (1LL == tmp___4) {
    tmp___3 = ci(a);
    return (tmp___3);
  }
  if (at___0) {
    if (at___0 < 0LL) {
      tmp___5 = -1;
    } else {
      tmp___5 = 1;
    }
    tmp___6 = tmp___5;
  } else {
    tmp___6 = 0;
  }
  tmp___7 = newK((I )tmp___6, an);
  z = tmp___7;
  if (at___0 < 0LL) {
    tmp___16 = - at___0;
  } else {
    tmp___16 = at___0;
  }
  if (2LL == tmp___16) {
    i = (I )0;
    _i___0 = an;
    while (i < _i___0) {
      e = *((F *)(a->k) + i);
      tmp___15 = __builtin_isnan(e);
      if (tmp___15) {
        r = (-0x7FFFFFFFFFFFFFFF-1);
      } else {
        tmp___14 = __builtin_isinf_sign(e);
        if (tmp___14) {
          goto _L___0;
        } else
        if (e <= (F )-9223372036854775807LL) {
          goto _L___0;
        } else
        if (e >= (F )9223372036854775807LL) {
          _L___0: /* CIL Label */ 
          if (e < (F )0) {
            r = -9223372036854775807LL;
          } else {
            r = 9223372036854775807LL;
          }
        } else {
          f = FF(e);
          if (f > (F )0) {
            tmp___12 = FC(f, (F )1);
            if (tmp___12) {
              goto _L;
            } else {
              tmp___10 = (*h)(e);
              r = (I )tmp___10;
            }
          } else
          _L: /* CIL Label */ 
          if (f < (F )0) {
            tmp___13 = FC(f, (F )0);
            if (tmp___13) {
              tmp___11 = (*g)(e);
              r = (I )tmp___11;
            } else {
              tmp___10 = (*h)(e);
              r = (I )tmp___10;
            }
          } else {
            tmp___11 = (*g)(e);
            r = (I )tmp___11;
          }
        }
      }
      *((I *)(z->k) + i) = r;
      i ++;
    }
  } else
  if (! at___0) {
    i___0 = (I )0;
    _i___1 = an;
    while (i___0 < _i___1) {
      z->k[i___0] = floor_ceil(a->k[i___0], g);
      i___0 ++;
    }
  }
  return (z);
}
}
K floor_verb(K a ) 
{ 
  K tmp ;

  {
  tmp = floor_ceil(a, & floor);
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-NI5qkyxs.i","-g,-pthread,-O3")
I FC_IF(I a , F b___1 ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  I tmp___2 ;

  {
  if (9223372036854775807LL == a) {
    tmp___1 = (double )1 / 0.;
  } else {
    if (-9223372036854775807LL == a) {
      tmp___0 = - ((double )1 / 0.);
    } else {
      if ((-0x7FFFFFFFFFFFFFFF-1) == a) {
        tmp = (double )0 / 0.;
      } else {
        tmp = (double )a;
      }
      tmp___0 = tmp;
    }
    tmp___1 = tmp___0;
  }
  tmp___2 = FC(tmp___1, b___1);
  return (tmp___2);
}
}
I FC_FI(F a , I b___1 ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  I tmp___2 ;

  {
  if (9223372036854775807LL == b___1) {
    tmp___1 = (double )1 / 0.;
  } else {
    if (-9223372036854775807LL == b___1) {
      tmp___0 = - ((double )1 / 0.);
    } else {
      if ((-0x7FFFFFFFFFFFFFFF-1) == b___1) {
        tmp = (double )0 / 0.;
      } else {
        tmp = (double )b___1;
      }
      tmp___0 = tmp;
    }
    tmp___1 = tmp___0;
  }
  tmp___2 = FC(a, tmp___1);
  return (tmp___2);
}
}
static K lessmore(K a , K b___1 , I x___0 ) ;
K dp(K *z , K (*f)(K  , K  ) , K x___0 , K y ) 
{ 
  I tmp ;
  I i ;
  I _i___0 ;
  struct k0 *tmp___0 ;

  {
  x___0 = promote(x___0);
  y = promote(y);
  tmp = OOM_CD((I )0, x___0, y, *z, (V )-1);
  if (! tmp) {
    return ((K )0);
  }
  i = (I )0;
  _i___0 = (*z)->n;
  while (i < _i___0) {
    tmp___0 = (*f)(x___0->k[i % x___0->n], y->k[i % y->n]);
    (*z)->k[i] = tmp___0;
    if (! tmp___0) {
      cd(*z);
      *z = kerr("type");
      break;
    }
    i ++;
  }
  cd(x___0);
  cd(y);
  return ((K )0);
}
}
K equals(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  K tmp ;
  I AT ;
  I tmp___0 ;
  I BT ;
  I tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  I t ;
  int tmp___5 ;
  I tmp___6 ;
  int tmp___7 ;
  I zn ;
  I tmp___8 ;
  K z ;
  K tmp___9 ;
  I i ;
  I _i___0 ;
  I tmp___11 ;
  I i___0 ;
  I _i___1 ;
  I tmp___13 ;
  I i___1 ;
  I _i___2 ;
  I tmp___15 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  I tmp___17 ;
  I i___4 ;
  I _i___5 ;
  I tmp___19 ;
  I i___5 ;
  I _i___6 ;
  I tmp___21 ;
  I i___6 ;
  I _i___7 ;
  I tmp___23 ;
  I i___7 ;
  I _i___8 ;
  I tmp___25 ;
  I i___8 ;
  I _i___9 ;
  I tmp___27 ;
  I i___9 ;
  I _i___10 ;
  I i___10 ;
  I _i___11 ;
  I i___11 ;
  I _i___12 ;
  I i___12 ;
  I _i___13 ;
  I i___13 ;
  I _i___14 ;
  I i___14 ;
  I _i___15 ;
  I i___15 ;
  I _i___16 ;
  I i___16 ;
  I _i___17 ;
  I i___17 ;
  I _i___18 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (at___0 <= 0LL) {
    if (bt <= 0LL) {
      if (an != bn) {
        tmp = kerr("length");
        return (tmp);
      }
    }
  }
  if (at___0 < 0LL) {
    tmp___0 = - at___0;
  } else {
    tmp___0 = at___0;
  }
  AT = tmp___0;
  if (bt < 0LL) {
    tmp___1 = - bt;
  } else {
    tmp___1 = bt;
  }
  BT = tmp___1;
  if (4LL < AT) {
    tmp___2 = kerr("type");
    return (tmp___2);
  } else
  if (4LL < BT) {
    tmp___2 = kerr("type");
    return (tmp___2);
  }
  if (at___0) {
    if (bt) {
      if (2LL >= AT) {
        if (! (2LL >= BT)) {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if (3LL == AT) {
        if (! (3LL == BT)) {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (4LL == AT) {
        if (! (4LL == BT)) {
          tmp___3 = kerr("type");
          return (tmp___3);
        }
      } else {
        tmp___3 = kerr("type");
        return (tmp___3);
      }
    }
  }
  if (! at___0) {
    tmp___7 = 0;
  } else
  if (! bt) {
    tmp___7 = 0;
  } else {
    if (at___0 < bt) {
      tmp___6 = at___0;
    } else {
      tmp___6 = bt;
    }
    if (tmp___6 < 0LL) {
      tmp___5 = -1;
    } else {
      tmp___5 = 1;
    }
    tmp___7 = tmp___5;
  }
  t = (I )tmp___7;
  if (at___0 > 0LL) {
    tmp___8 = bn;
  } else {
    tmp___8 = an;
  }
  zn = tmp___8;
  tmp___9 = newK(t, zn);
  z = tmp___9;
  if (2LL == AT) {
    if (2LL == BT) {
      if (an == bn) {
        i = (I )0;
        _i___0 = zn;
        while (i < _i___0) {
          tmp___11 = FC(*((F *)(a->k) + i), *((F *)(b___1->k) + i));
          if (tmp___11) {
            *((I *)(z->k) + i) = (I )0;
          } else {
            *((I *)(z->k) + i) = (I )1;
          }
          i ++;
        }
      } else
      if (an == 1LL) {
        i___0 = (I )0;
        _i___1 = zn;
        while (i___0 < _i___1) {
          tmp___13 = FC(*((F *)(a->k) + 0), *((F *)(b___1->k) + i___0));
          if (tmp___13) {
            *((I *)(z->k) + i___0) = (I )0;
          } else {
            *((I *)(z->k) + i___0) = (I )1;
          }
          i___0 ++;
        }
      } else {
        i___1 = (I )0;
        _i___2 = zn;
        while (i___1 < _i___2) {
          tmp___15 = FC(*((F *)(a->k) + i___1), *((F *)(b___1->k) + 0));
          if (tmp___15) {
            *((I *)(z->k) + i___1) = (I )0;
          } else {
            *((I *)(z->k) + i___1) = (I )1;
          }
          i___1 ++;
        }
      }
      i___2 = (I )0;
      _i___3 = zn;
      while (i___2 < _i___3) {
        if (*((F *)(a->k) + i___2) != *((F *)(a->k) + i___2)) {
          if (*((F *)(b___1->k) + i___2) != *((F *)(b___1->k) + i___2)) {
            *((I *)(z->k) + i___2) = (I )1;
          }
        }
        i___2 ++;
      }
    } else {
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
  if (2LL == AT) {
    if (1LL == BT) {
      if (an == bn) {
        i___3 = (I )0;
        _i___4 = zn;
        while (i___3 < _i___4) {
          tmp___17 = FC_FI(*((F *)(a->k) + i___3), *((I *)(b___1->k) + i___3));
          if (tmp___17) {
            *((I *)(z->k) + i___3) = (I )0;
          } else {
            *((I *)(z->k) + i___3) = (I )1;
          }
          i___3 ++;
        }
      } else
      if (an == 1LL) {
        i___4 = (I )0;
        _i___5 = zn;
        while (i___4 < _i___5) {
          tmp___19 = FC_FI(*((F *)(a->k) + 0), *((I *)(b___1->k) + i___4));
          if (tmp___19) {
            *((I *)(z->k) + i___4) = (I )0;
          } else {
            *((I *)(z->k) + i___4) = (I )1;
          }
          i___4 ++;
        }
      } else {
        i___5 = (I )0;
        _i___6 = zn;
        while (i___5 < _i___6) {
          tmp___21 = FC_FI(*((F *)(a->k) + i___5), *((I *)(b___1->k) + 0));
          if (tmp___21) {
            *((I *)(z->k) + i___5) = (I )0;
          } else {
            *((I *)(z->k) + i___5) = (I )1;
          }
          i___5 ++;
        }
      }
    } else {
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
  if (1LL == AT) {
    if (2LL == BT) {
      if (an == bn) {
        i___6 = (I )0;
        _i___7 = zn;
        while (i___6 < _i___7) {
          tmp___23 = FC_IF(*((I *)(a->k) + i___6), *((F *)(b___1->k) + i___6));
          if (tmp___23) {
            *((I *)(z->k) + i___6) = (I )0;
          } else {
            *((I *)(z->k) + i___6) = (I )1;
          }
          i___6 ++;
        }
      } else
      if (an == 1LL) {
        i___7 = (I )0;
        _i___8 = zn;
        while (i___7 < _i___8) {
          tmp___25 = FC_IF(*((I *)(a->k) + 0), *((F *)(b___1->k) + i___7));
          if (tmp___25) {
            *((I *)(z->k) + i___7) = (I )0;
          } else {
            *((I *)(z->k) + i___7) = (I )1;
          }
          i___7 ++;
        }
      } else {
        i___8 = (I )0;
        _i___9 = zn;
        while (i___8 < _i___9) {
          tmp___27 = FC_IF(*((I *)(a->k) + i___8), *((F *)(b___1->k) + 0));
          if (tmp___27) {
            *((I *)(z->k) + i___8) = (I )0;
          } else {
            *((I *)(z->k) + i___8) = (I )1;
          }
          i___8 ++;
        }
      }
    } else {
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
  if (1LL == AT) {
    if (1LL == BT) {
      if (an == bn) {
        i___9 = (I )0;
        _i___10 = zn;
        while (i___9 < _i___10) {
          *((I *)(z->k) + i___9) = (I )(*((I *)(a->k) + i___9) == *((I *)(b___1->k) + i___9));
          i___9 ++;
        }
      } else
      if (an == 1LL) {
        i___10 = (I )0;
        _i___11 = zn;
        while (i___10 < _i___11) {
          *((I *)(z->k) + i___10) = (I )(*((I *)(a->k) + 0) == *((I *)(b___1->k) + i___10));
          i___10 ++;
        }
      } else {
        i___11 = (I )0;
        _i___12 = zn;
        while (i___11 < _i___12) {
          *((I *)(z->k) + i___11) = (I )(*((I *)(a->k) + i___11) == *((I *)(b___1->k) + 0));
          i___11 ++;
        }
      }
    } else {
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
  if (3LL == AT) {
    if (3LL == BT) {
      if (an == bn) {
        i___12 = (I )0;
        _i___13 = zn;
        while (i___12 < _i___13) {
          *((I *)(z->k) + i___12) = (I )((int )*((C *)(a->k) + i___12) == (int )*((C *)(b___1->k) + i___12));
          i___12 ++;
        }
      } else
      if (an == 1LL) {
        i___13 = (I )0;
        _i___14 = zn;
        while (i___13 < _i___14) {
          *((I *)(z->k) + i___13) = (I )((int )*((C *)(a->k) + 0) == (int )*((C *)(b___1->k) + i___13));
          i___13 ++;
        }
      } else {
        i___14 = (I )0;
        _i___15 = zn;
        while (i___14 < _i___15) {
          *((I *)(z->k) + i___14) = (I )((int )*((C *)(a->k) + i___14) == (int )*((C *)(b___1->k) + 0));
          i___14 ++;
        }
      }
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (4LL == AT) {
    if (4LL == BT) {
      if (an == bn) {
        i___15 = (I )0;
        _i___16 = zn;
        while (i___15 < _i___16) {
          *((I *)(z->k) + i___15) = (I )((unsigned long )*((S *)(a->k) + i___15) == (unsigned long )*((S *)(b___1->k) + i___15));
          i___15 ++;
        }
      } else
      if (an == 1LL) {
        i___16 = (I )0;
        _i___17 = zn;
        while (i___16 < _i___17) {
          *((I *)(z->k) + i___16) = (I )((unsigned long )*((S *)(a->k) + 0) == (unsigned long )*((S *)(b___1->k) + i___16));
          i___16 ++;
        }
      } else {
        i___17 = (I )0;
        _i___18 = zn;
        while (i___17 < _i___18) {
          *((I *)(z->k) + i___17) = (I )((unsigned long )*((S *)(a->k) + i___17) == (unsigned long )*((S *)(b___1->k) + 0));
          i___17 ++;
        }
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (0LL == at___0) {
    dp(& z, & equals, a, b___1);
  } else
  if (0LL == bt) {
    dp(& z, & equals, a, b___1);
  }
  return (z);
}
}
I matchI(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  I AT ;
  I tmp ;
  I BT ;
  I tmp___0 ;
  K *c ;
  K *d___0 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I tmp___1 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  I tmp___2 ;
  I i___4 ;
  I _i___5 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  I tmp___6 ;

  {
  if (! a) {
    return ((I )0);
  } else
  if (! b___1) {
    return ((I )0);
  }
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (at___0 < 0LL) {
    tmp = - at___0;
  } else {
    tmp = at___0;
  }
  AT = tmp;
  if (bt < 0LL) {
    tmp___0 = - bt;
  } else {
    tmp___0 = bt;
  }
  BT = tmp___0;
  if (an != bn) {
    return ((I )0);
  } else
  if (at___0 != bt) {
    return ((I )0);
  }
  if (4LL == AT) {
    i = (I )0;
    _i___0 = an;
    while (i < _i___0) {
      if ((unsigned long )*((S *)(a->k) + i) != (unsigned long )*((S *)(b___1->k) + i)) {
        return ((I )0);
      }
      i ++;
    }
  }
  if (3LL == AT) {
    i___0 = (I )0;
    _i___1 = an;
    while (i___0 < _i___1) {
      if ((int )*((C *)(a->k) + i___0) != (int )*((C *)(b___1->k) + i___0)) {
        return ((I )0);
      }
      i___0 ++;
    }
  }
  if (2LL == AT) {
    if (2LL == BT) {
      i___1 = (I )0;
      _i___2 = an;
      while (i___1 < _i___2) {
        tmp___1 = FC(*((F *)(a->k) + i___1), *((F *)(b___1->k) + i___1));
        if (tmp___1) {
          return ((I )0);
        }
        i___1 ++;
      }
    }
  }
  if (1LL == AT) {
    if (1LL == BT) {
      i___2 = (I )0;
      _i___3 = an;
      while (i___2 < _i___3) {
        if (*((I *)(a->k) + i___2) != *((I *)(b___1->k) + i___2)) {
          return ((I )0);
        }
        i___2 ++;
      }
    }
  }
  if (0LL == AT) {
    goto _L;
  } else
  if (5LL == AT) {
    _L: /* CIL Label */ 
    i___3 = (I )0;
    _i___4 = an;
    while (i___3 < _i___4) {
      tmp___2 = matchI(a->k[i___3], b___1->k[i___3]);
      if (! tmp___2) {
        return ((I )0);
      }
      i___3 ++;
    }
  }
  if (7LL == AT) {
    if (a->n != b___1->n) {
      return ((I )0);
    }
    switch (a->n) {
    case 1LL: 
    an = ((K )*((V *)(a->k) + 2))->n - 1LL;
    bn = ((K )*((V *)(b___1->k) + 2))->n - 1LL;
    if (an != bn) {
      return ((I )0);
    }
    i___4 = (I )0;
    _i___5 = an;
    while (i___4 < _i___5) {
      c = (K *)*((V *)((S *)(((K )*((V *)(a->k) + 2))->k)) + i___4);
      d___0 = (K *)*((V *)((S *)(((K )*((V *)(b___1->k) + 2))->k)) + i___4);
      tmp___4 = VA((V )c);
      if (tmp___4) {
        goto _L___0;
      } else {
        tmp___5 = VA((V )d___0);
        if (tmp___5) {
          _L___0: /* CIL Label */ 
          if ((unsigned long )c != (unsigned long )d___0) {
            return ((I )0);
          }
        } else {
          tmp___3 = matchI(*c, *d___0);
          if (! tmp___3) {
            return ((I )0);
          }
        }
      }
      i___4 ++;
    }
    break;
    case 2LL: ;
    break;
    case 3LL: 
    if ((unsigned long )*((V *)(a->k) + 0) != (unsigned long )*((V *)(b___1->k) + 0)) {
      return ((I )0);
    }
    tmp___6 = matchI((K )*((V *)(a->k) + 2), (K )*((V *)(b___1->k) + 2));
    return (tmp___6);
    break;
    }
  }
  return ((I )1);
}
}
K match(K a , K b___1 ) 
{ 
  I tmp ;
  K tmp___0 ;

  {
  tmp = matchI(a, b___1);
  tmp___0 = Ki(tmp);
  return (tmp___0);
}
}
static K lessmore(K a , K b___1 , I x___0 ) 
{ 
  K c ;
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  K tmp ;
  I AT ;
  I tmp___0 ;
  I BT ;
  I tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  I t ;
  int tmp___5 ;
  I tmp___6 ;
  int tmp___7 ;
  I zn ;
  I tmp___8 ;
  K z ;
  K tmp___9 ;
  I *h ;
  I tmp___10 ;
  I i ;
  I _i___0 ;
  struct k0 *tmp___11 ;
  I i___0 ;
  I _i___1 ;
  I tmp___12 ;
  I i___1 ;
  I _i___2 ;
  I tmp___13 ;
  I i___2 ;
  I _i___3 ;
  I tmp___14 ;
  I i___3 ;
  I _i___4 ;
  I tmp___15 ;
  I i___4 ;
  I _i___5 ;
  I tmp___16 ;
  I i___5 ;
  I _i___6 ;
  I tmp___17 ;
  I i___6 ;
  I _i___7 ;
  I tmp___18 ;
  I i___7 ;
  I _i___8 ;
  I tmp___19 ;
  I i___8 ;
  I _i___9 ;
  I tmp___20 ;
  I i___9 ;
  I _i___10 ;
  I i___10 ;
  I _i___11 ;
  I i___11 ;
  I _i___12 ;
  I i___12 ;
  I _i___13 ;
  I i___13 ;
  I _i___14 ;
  I i___14 ;
  I _i___15 ;
  I i___15 ;
  I _i___16 ;
  I tmp___21 ;
  I i___16 ;
  I _i___17 ;
  I tmp___22 ;
  I i___17 ;
  I _i___18 ;
  I tmp___23 ;

  {
  if (! x___0) {
    if (0LL != b___1->t) {
      c = a;
      a = b___1;
      b___1 = c;
    }
  }
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (at___0 <= 0LL) {
    if (bt <= 0LL) {
      if (an != bn) {
        tmp = kerr("length");
        return (tmp);
      }
    }
  }
  if (at___0 < 0LL) {
    tmp___0 = - at___0;
  } else {
    tmp___0 = at___0;
  }
  AT = tmp___0;
  if (bt < 0LL) {
    tmp___1 = - bt;
  } else {
    tmp___1 = bt;
  }
  BT = tmp___1;
  if (4LL < AT) {
    tmp___2 = kerr("type");
    return (tmp___2);
  } else
  if (4LL < BT) {
    tmp___2 = kerr("type");
    return (tmp___2);
  }
  if (at___0) {
    if (bt) {
      if (2LL >= AT) {
        if (! (2LL >= BT)) {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if (3LL == AT) {
        if (! (3LL == BT)) {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (4LL == AT) {
        if (! (4LL == BT)) {
          tmp___3 = kerr("type");
          return (tmp___3);
        }
      } else {
        tmp___3 = kerr("type");
        return (tmp___3);
      }
    }
  }
  if (! at___0) {
    tmp___7 = 0;
  } else
  if (! bt) {
    tmp___7 = 0;
  } else {
    if (at___0 < bt) {
      tmp___6 = at___0;
    } else {
      tmp___6 = bt;
    }
    if (tmp___6 < 0LL) {
      tmp___5 = -1;
    } else {
      tmp___5 = 1;
    }
    tmp___7 = tmp___5;
  }
  t = (I )tmp___7;
  if (at___0 > 0LL) {
    tmp___8 = bn;
  } else {
    tmp___8 = an;
  }
  zn = tmp___8;
  tmp___9 = newK(t, zn);
  z = tmp___9;
  if (! z) {
    return ((K )0);
  }
  h = (I *)(z->k);
  if (0LL == at___0) {
    goto _L___6;
  } else
  if (0LL == bt) {
    _L___6: /* CIL Label */ 
    a = promote(a);
    b___1 = promote(b___1);
    tmp___10 = OOM_CD((I )0, a, b___1, z, (V )-1);
    if (! tmp___10) {
      return ((K )0);
    }
    i = (I )0;
    _i___0 = zn;
    while (i < _i___0) {
      tmp___11 = lessmore(a->k[i % an], b___1->k[i % b___1->n], x___0);
      z->k[i] = tmp___11;
      if (! tmp___11) {
        cd(z);
        z = kerr("wsfull");
        break;
      }
      i ++;
    }
    cd(a);
    cd(b___1);
  } else
  if (2LL == AT) {
    if (2LL == BT) {
      if (an == bn) {
        i___0 = (I )0;
        _i___1 = zn;
        while (i___0 < _i___1) {
          tmp___12 = FC(*((F *)(a->k) + i___0), *((F *)(b___1->k) + i___0));
          *(h + i___0) = (I )(tmp___12 > 0LL);
          i___0 ++;
        }
      } else
      if (an == 1LL) {
        i___1 = (I )0;
        _i___2 = zn;
        while (i___1 < _i___2) {
          tmp___13 = FC(*((F *)(a->k) + 0), *((F *)(b___1->k) + i___1));
          *(h + i___1) = (I )(tmp___13 > 0LL);
          i___1 ++;
        }
      } else {
        i___2 = (I )0;
        _i___3 = zn;
        while (i___2 < _i___3) {
          tmp___14 = FC(*((F *)(a->k) + i___2), *((F *)(b___1->k) + 0));
          *(h + i___2) = (I )(tmp___14 > 0LL);
          i___2 ++;
        }
      }
    } else {
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
  if (2LL == AT) {
    if (1LL == BT) {
      if (an == bn) {
        i___3 = (I )0;
        _i___4 = zn;
        while (i___3 < _i___4) {
          tmp___15 = FC_FI(*((F *)(a->k) + i___3), *((I *)(b___1->k) + i___3));
          *(h + i___3) = (I )(tmp___15 > 0LL);
          i___3 ++;
        }
      } else
      if (an == 1LL) {
        i___4 = (I )0;
        _i___5 = zn;
        while (i___4 < _i___5) {
          tmp___16 = FC_FI(*((F *)(a->k) + 0), *((I *)(b___1->k) + i___4));
          *(h + i___4) = (I )(tmp___16 > 0LL);
          i___4 ++;
        }
      } else {
        i___5 = (I )0;
        _i___6 = zn;
        while (i___5 < _i___6) {
          tmp___17 = FC_FI(*((F *)(a->k) + i___5), *((I *)(b___1->k) + 0));
          *(h + i___5) = (I )(tmp___17 > 0LL);
          i___5 ++;
        }
      }
    } else {
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
  if (1LL == AT) {
    if (2LL == BT) {
      if (an == bn) {
        i___6 = (I )0;
        _i___7 = zn;
        while (i___6 < _i___7) {
          tmp___18 = FC_IF(*((I *)(a->k) + i___6), *((F *)(b___1->k) + i___6));
          *(h + i___6) = (I )(tmp___18 > 0LL);
          i___6 ++;
        }
      } else
      if (an == 1LL) {
        i___7 = (I )0;
        _i___8 = zn;
        while (i___7 < _i___8) {
          tmp___19 = FC_IF(*((I *)(a->k) + 0), *((F *)(b___1->k) + i___7));
          *(h + i___7) = (I )(tmp___19 > 0LL);
          i___7 ++;
        }
      } else {
        i___8 = (I )0;
        _i___9 = zn;
        while (i___8 < _i___9) {
          tmp___20 = FC_IF(*((I *)(a->k) + i___8), *((F *)(b___1->k) + 0));
          *(h + i___8) = (I )(tmp___20 > 0LL);
          i___8 ++;
        }
      }
    } else {
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
  if (1LL == AT) {
    if (1LL == BT) {
      if (an == bn) {
        i___9 = (I )0;
        _i___10 = zn;
        while (i___9 < _i___10) {
          *((I *)(z->k) + i___9) = (I )(*((I *)(a->k) + i___9) > *((I *)(b___1->k) + i___9));
          i___9 ++;
        }
      } else
      if (an == 1LL) {
        i___10 = (I )0;
        _i___11 = zn;
        while (i___10 < _i___11) {
          *((I *)(z->k) + i___10) = (I )(*((I *)(a->k) + 0) > *((I *)(b___1->k) + i___10));
          i___10 ++;
        }
      } else {
        i___11 = (I )0;
        _i___12 = zn;
        while (i___11 < _i___12) {
          *((I *)(z->k) + i___11) = (I )(*((I *)(a->k) + i___11) > *((I *)(b___1->k) + 0));
          i___11 ++;
        }
      }
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (3LL == AT) {
    if (3LL == BT) {
      if (an == bn) {
        i___12 = (I )0;
        _i___13 = zn;
        while (i___12 < _i___13) {
          *((I *)(z->k) + i___12) = (I )((int )*((C *)(a->k) + i___12) > (int )*((C *)(b___1->k) + i___12));
          i___12 ++;
        }
      } else
      if (an == 1LL) {
        i___13 = (I )0;
        _i___14 = zn;
        while (i___13 < _i___14) {
          *((I *)(z->k) + i___13) = (I )((int )*((C *)(a->k) + 0) > (int )*((C *)(b___1->k) + i___13));
          i___13 ++;
        }
      } else {
        i___14 = (I )0;
        _i___15 = zn;
        while (i___14 < _i___15) {
          *((I *)(z->k) + i___14) = (I )((int )*((C *)(a->k) + i___14) > (int )*((C *)(b___1->k) + 0));
          i___14 ++;
        }
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (4LL == AT) {
    if (4LL == BT) {
      if (an == bn) {
        i___15 = (I )0;
        _i___16 = zn;
        while (i___15 < _i___16) {
          tmp___21 = SC(*((S *)(a->k) + i___15), *((S *)(b___1->k) + i___15));
          *(h + i___15) = (I )(tmp___21 > 0LL);
          i___15 ++;
        }
      } else
      if (an == 1LL) {
        i___16 = (I )0;
        _i___17 = zn;
        while (i___16 < _i___17) {
          tmp___22 = SC(*((S *)(a->k) + 0), *((S *)(b___1->k) + i___16));
          *(h + i___16) = (I )(tmp___22 > 0LL);
          i___16 ++;
        }
      } else {
        i___17 = (I )0;
        _i___18 = zn;
        while (i___17 < _i___18) {
          tmp___23 = SC(*((S *)(a->k) + i___17), *((S *)(b___1->k) + 0));
          *(h + i___17) = (I )(tmp___23 > 0LL);
          i___17 ++;
        }
      }
    }
  }
  return (z);
}
}
K less(K a , K b___1 ) 
{ 
  K tmp ;

  {
  tmp = lessmore(a, b___1, (I )0);
  return (tmp);
}
}
K more(K a , K b___1 ) 
{ 
  K tmp ;

  {
  tmp = lessmore(a, b___1, (I )1);
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-YaA6HDlE.i","-g,-pthread,-O3")
K make(K a ) ;
I countI(K x___0 ) ;
static K dot_ref(K *p , K *x___0 , K *z , I s , K c , K y ) ;
static K makeable(K a ) ;
static K of2(K d___0 , K *x___0 , K *y , I s ) 
{ 
  K f ;
  K tmp ;
  I dt ;
  I dn ;
  I ft ;
  I fn ;
  K tmp___0 ;
  K z ;
  I i ;
  I _i___0 ;
  struct k0 *tmp___1 ;
  I tmp___2 ;
  I k ;
  I i___0 ;
  I _i___1 ;
  K tmp___3 ;
  K tmp___4 ;
  I i___1 ;
  I _i___2 ;
  struct k0 *tmp___5 ;
  I tmp___6 ;
  K tmp___7 ;
  K tmp___8 ;
  I i___2 ;
  I _i___3 ;
  struct k0 *tmp___9 ;
  K tmp___10 ;
  I tmp___11 ;
  I i___3 ;
  I _i___4 ;
  struct k0 *tmp___12 ;
  I tmp___13 ;
  I i___4 ;
  I _i___5 ;
  struct k0 *tmp___14 ;
  I tmp___15 ;
  K tmp___16 ;
  K tmp___17 ;
  I tmp___18 ;
  I tmp___19 ;

  {
  f = *x___0;
  if (! f) {
    tmp = kerr("nyi");
    return (tmp);
  }
  dt = d___0->t;
  dn = d___0->n;
  ft = f->t;
  fn = f->n;
  if (0LL >= s) {
    tmp___0 = at_verb(d___0, f);
    return (tmp___0);
  }
  if (0LL == ft) {
    z = newK((I )0, fn);
    if (! z) {
      return ((K )0);
    }
    i = (I )0;
    _i___0 = fn;
    while (i < _i___0) {
      tmp___1 = of2(d___0, & f->k[i], y, s);
      z->k[i] = tmp___1;
      tmp___2 = OOM_CD((I )0, z, tmp___1, (V )-1);
      if (! tmp___2) {
        return ((K )0);
      }
      i ++;
    }
  } else {
    if (ft < 0LL) {
      tmp___19 = - ft;
    } else {
      tmp___19 = ft;
    }
    if (1LL == tmp___19) {
      if (dt != 0LL) {
        return ((K )0);
      }
      i___0 = (I )0;
      _i___1 = fn;
      while (i___0 < _i___1) {
        k = *((I *)(f->k) + i___0);
        if (k < 0LL) {
          tmp___3 = kerr("index");
          return (tmp___3);
        } else
        if (k >= dn) {
          tmp___3 = kerr("index");
          return (tmp___3);
        }
        i___0 ++;
      }
      if (1LL == ft) {
        tmp___4 = of2(d___0->k[*((I *)(f->k))], y, y + 1, s - 1LL);
        return (tmp___4);
      }
      z = newK((I )0, fn);
      if (! z) {
        return ((K )0);
      }
      i___1 = (I )0;
      _i___2 = fn;
      while (i___1 < _i___2) {
        tmp___5 = of2(d___0->k[*((I *)(f->k) + i___1)], y, y + 1, s - 1LL);
        z->k[i___1] = tmp___5;
        tmp___6 = OOM_CD((I )0, z, tmp___5, (V )-1);
        if (! tmp___6) {
          return ((K )0);
        }
        i___1 ++;
      }
    } else {
      if (ft < 0LL) {
        tmp___18 = - ft;
      } else {
        tmp___18 = ft;
      }
      if (4LL == tmp___18) {
        if (dt != 5LL) {
          return ((K )0);
        }
        if (4LL == ft) {
          tmp___7 = lookup(d___0, *((S *)(f->k)));
          tmp___8 = of2(tmp___7, y, y + 1, s - 1LL);
          return (tmp___8);
        }
        z = newK((I )0, fn);
        if (! z) {
          return ((K )0);
        }
        i___2 = (I )0;
        _i___3 = fn;
        while (i___2 < _i___3) {
          tmp___10 = lookup(d___0, *((S *)(f->k) + i___2));
          tmp___9 = of2(tmp___10, y, y + 1, s - 1LL);
          z->k[i___2] = tmp___9;
          tmp___11 = OOM_CD((I )0, z, tmp___9, (V )-1);
          if (! tmp___11) {
            return ((K )0);
          }
          i___2 ++;
        }
      } else
      if (6LL == ft) {
        if (0LL == dt) {
          z = newK((I )0, dn);
          if (! z) {
            return ((K )0);
          }
          i___3 = (I )0;
          _i___4 = dn;
          while (i___3 < _i___4) {
            tmp___12 = of2(d___0->k[i___3], y, y + 1, s - 1LL);
            z->k[i___3] = tmp___12;
            tmp___13 = OOM_CD((I )0, z, tmp___12, (V )-1);
            if (! tmp___13) {
              return ((K )0);
            }
            i___3 ++;
          }
        } else
        if (5LL == dt) {
          z = newK((I )0, dn);
          if (! z) {
            return ((K )0);
          }
          i___4 = (I )0;
          _i___5 = dn;
          while (i___4 < _i___5) {
            tmp___14 = of2((d___0->k[i___4])->k[1], y, y + 1, s - 1LL);
            z->k[i___4] = tmp___14;
            tmp___15 = OOM_CD((I )0, z, tmp___14, (V )-1);
            if (! tmp___15) {
              return ((K )0);
            }
            i___4 ++;
          }
        } else {
          tmp___16 = kerr("rank");
          return (tmp___16);
        }
      } else {
        tmp___17 = kerr("type");
        return (tmp___17);
      }
    }
  }
  if (z) {
    z = demote(z);
  }
  return (z);
}
}
K of(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  K tmp ;
  K z ;
  C s[256] ;
  S ss ;
  I i ;
  K tmp___0 ;
  size_t tmp___1 ;
  K *aa ;
  S tmp___2 ;
  K *tmp___3 ;
  K *f ;
  K tmp___4 ;
  K *tmp___5 ;
  K tmp___6 ;
  C s___0[256] ;
  K *aa___0 ;
  S tmp___7 ;
  K *tmp___8 ;
  K tmp___9 ;
  K tmp___10 ;
  K tmp___11 ;
  K tmp___12 ;
  I tmp___13 ;
  I i___0 ;
  I _i___0 ;
  K tmp___14 ;
  K *f___0 ;
  K *tmp___15 ;
  K k ;
  K tmp___16 ;
  K *f___1 ;
  K f___2 ;
  K tmp___17 ;
  K k___0 ;
  I i___1 ;
  I _i___1 ;
  I tmp___18 ;
  K tmp___19 ;
  I tmp___20 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (0LL == b___1->t) {
    if (0LL == b___1->n) {
      tmp = ci(a);
      return (tmp);
    }
  }
  z = (K )0;
  if (at___0 == 4LL) {
    if (bt == 0LL) {
      strcpy((char * __restrict  )(s), (char const   * __restrict  )d_);
      strcat((char * __restrict  )(s), (char const   * __restrict  )".");
      strcat((char * __restrict  )(s), (char const   * __restrict  )*((S *)(a->k)));
      ss = *((S *)(a->k));
      i = (I )0;
      while (1) {
        tmp___1 = strlen((char const   *)ss);
        if (! ((unsigned long long )i < (unsigned long long )tmp___1)) {
          break;
        }
        if ((int )*(ss + i) == 95) {
          tmp___0 = kerr("domain");
          return (tmp___0);
        } else
        if ((int )*(ss + i) == 26) {
          tmp___0 = kerr("domain");
          return (tmp___0);
        }
        i ++;
      }
      tmp___2 = sp(s);
      tmp___3 = denameD(& KTREE, tmp___2, (I )1);
      aa = tmp___3;
      f = & b___1->k[0];
      if ((unsigned long )((void *)0) == (unsigned long )aa) {
        tmp___4 = kerr("domain");
        return (tmp___4);
      }
      if (bn > 0LL) {
        tmp___5 = f + 1;
      } else {
        tmp___5 = (K *)0;
      }
      tmp___6 = of2(*aa, f, tmp___5, bn - 1LL);
      return (tmp___6);
    }
  }
  if (at___0 == 4LL) {
    if (bt == 1LL) {
      strcpy((char * __restrict  )(s___0), (char const   * __restrict  )d_);
      strcat((char * __restrict  )(s___0), (char const   * __restrict  )".");
      strcat((char * __restrict  )(s___0), (char const   * __restrict  )*((S *)(a->k)));
      tmp___7 = sp(s___0);
      tmp___8 = denameD(& KTREE, tmp___7, (I )1);
      aa___0 = tmp___8;
      tmp___9 = of(*aa___0, b___1);
      return (tmp___9);
    }
  }
  if (0LL < at___0) {
    if (at___0 < 5LL) {
      if (6LL != bt) {
        tmp___10 = kerr("rank");
        return (tmp___10);
      }
    }
  }
  if (6LL == at___0) {
    if (1LL == bt) {
      z = ci(b___1);
    } else {
      if (bt < 0LL) {
        tmp___13 = - bt;
      } else {
        tmp___13 = bt;
      }
      if (4LL == tmp___13) {
        z = _n();
      } else
      if (0LL == bn) {
        if (-1LL == bt) {
          z = _n();
        } else
        if (-2LL == bt) {
          z = _n();
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if (0LL == bt) {
        if (1LL == bn) {
          z = ci(b___1->k[0]);
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (0LL == bt) {
        tmp___11 = ci(b___1);
        z = demote(tmp___11);
      } else
      if (6LL == bt) {
        z = newK((I )0, (I )0);
      } else
      if (-3LL == bt) {
        if (0LL == bn) {
          z = newK((I )0, (I )0);
        } else {
          tmp___12 = kerr("type");
          return (tmp___12);
        }
      } else {
        tmp___12 = kerr("type");
        return (tmp___12);
      }
    }
  } else
  if (6LL == bt) {
    if (5LL == at___0) {
      z = newK((I )0, an);
      i___0 = (I )0;
      _i___0 = an;
      while (i___0 < _i___0) {
        z->k[i___0] = ci((a->k[i___0])->k[1]);
        i___0 ++;
      }
      z = demote(z);
    } else
    if (0LL >= at___0) {
      z = ci(a);
    } else {
      tmp___14 = kerr("rank");
      return (tmp___14);
    }
  } else
  if (0LL > bt) {
    if (0LL == bn) {
      if (-3LL != bt) {
        z = ci(a);
      } else {
        goto _L___4;
      }
    } else {
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
  if (5LL == at___0) {
    goto _L___2;
  } else
  if (0LL == at___0) {
    _L___2: /* CIL Label */ 
    if (0LL == bt) {
      f___0 = & b___1->k[0];
      if (bn > 0LL) {
        tmp___15 = f___0 + 1;
      } else {
        tmp___15 = (K *)0;
      }
      z = of2(a, f___0, tmp___15, bn - 1LL);
    } else
    if (-1LL == bt) {
      tmp___16 = promote(b___1);
      k = tmp___16;
      f___1 = & k->k[0];
      z = of2(a, f___1, f___1 + 1, bn - 1LL);
      cd(k);
    } else
    if (-4LL == bt) {
      tmp___16 = promote(b___1);
      k = tmp___16;
      f___1 = & k->k[0];
      z = of2(a, f___1, f___1 + 1, bn - 1LL);
      cd(k);
    } else {
      z = at_verb(a, b___1);
    }
  } else
  if (0LL > at___0) {
    if (-1LL == bt) {
      if (1LL == bn) {
        tmp___17 = newK((I )1, (I )1);
        f___2 = tmp___17;
        *((I *)(f___2->k)) = *((I *)(b___1->k));
        z = at_verb(a, f___2);
        cd(f___2);
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (bt < 0LL) {
        tmp___20 = - bt;
      } else {
        tmp___20 = bt;
      }
      if (1LL == tmp___20) {
        z = at_verb(a, b___1);
      } else
      if (0LL == bt) {
        z = newK((I )0, bn);
        i___1 = (I )0;
        _i___1 = bn;
        while (i___1 < _i___1) {
          k___0 = at_verb(a, b___1->k[i___1]);
          tmp___18 = OOM_CD((I )0, k___0, z, (V )-1);
          if (! tmp___18) {
            return ((K )0);
          }
          z->k[i___1] = k___0;
          i___1 ++;
        }
        z = collapse(z);
      } else {
        tmp___19 = kerr("type");
        return (tmp___19);
      }
    }
  }
  return (z);
}
}
K dot(K a , K b___1 ) 
{ 
  S s ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  K *tmp___2 ;
  K tmp___3 ;
  K tmp___4 ;
  K tmp___5 ;

  {
  if (4LL == a->t) {
    if (4LL == b___1->t) {
      tmp = strlen((char const   *)*((S *)(a->k)));
      tmp___0 = strlen((char const   *)*((S *)(b___1->k)));
      tmp___1 = malloc((2UL + tmp) + tmp___0);
      s = (S )tmp___1;
      s = strcpy((char * __restrict  )s, (char const   * __restrict  )*((S *)(a->k)));
      strcat((char * __restrict  )s, (char const   * __restrict  )".");
      strcat((char * __restrict  )s, (char const   * __restrict  )*((S *)(b___1->k)));
      tmp___2 = inKtree(& (KTREE->k[0])->k[1], s, (I )0);
      tmp___3 = ci(*tmp___2);
      return (tmp___3);
    }
  }
  if (7LL == a->t) {
    tmp___4 = vf_ex((V )(& a), b___1);
    return (tmp___4);
  }
  tmp___5 = of(a, b___1);
  return (tmp___5);
}
}
static K dot_ref(K *p , K *x___0 , K *z , I s , K c , K y ) 
{ 
  K d___0 ;
  K f ;
  K tmp ;
  I dt ;
  I dn ;
  I tmp___0 ;
  I ft ;
  I fn ;
  I yn0 ;
  K tmp___1 ;
  I argc ;
  int tmp___2 ;
  K args___0 ;
  K tmp___3 ;
  K r ;
  K tmp___4 ;
  K tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  I tmp___8 ;
  K tmp___9 ;
  I tmp___10 ;
  I tmp___11 ;
  I n ;
  I tmp___13 ;
  I tmp___14 ;
  I i ;
  I _i___0 ;
  K tmp___15 ;
  I tmp___16 ;
  I tmp___17 ;
  K tmp___18 ;
  I tmp___19 ;
  K tmp___20 ;
  I i___0 ;
  I _i___1 ;
  I e ;
  K tmp___21 ;
  I i___1 ;
  I _i___2 ;
  K py ;
  I tmp___23 ;
  K tmp___24 ;
  I tmp___25 ;
  I tmp___26 ;
  K tmp___27 ;
  K tmp___28 ;
  I tmp___29 ;
  I i___2 ;
  I _i___3 ;
  K py___0 ;
  I tmp___31 ;
  S u ;
  K *tmp___32 ;
  K tmp___33 ;
  I tmp___34 ;
  I i___3 ;
  I _i___4 ;
  struct k0 *tmp___35 ;
  K tmp___36 ;
  K *tmp___37 ;
  K k ;
  K tmp___38 ;
  K tmp___39 ;
  I tmp___40 ;
  I i___4 ;
  I _i___5 ;
  I tmp___41 ;
  struct k0 *tmp___42 ;
  I tmp___43 ;
  I tmp___44 ;

  {
  d___0 = *p;
  if (x___0) {
    tmp = *x___0;
  } else {
    tmp = (K )0;
  }
  f = tmp;
  dt = d___0->t;
  tmp___0 = countI(d___0);
  dn = tmp___0;
  ft = (I )999;
  yn0 = (I )0;
  if (f) {
    ft = f->t;
    fn = countI(f);
  } else {
    tmp___1 = kerr("nyi");
    return (tmp___1);
  }
  if (y) {
    yn0 = countI(y);
  }
  if (-1LL == s) {
    if (0LL == fn) {
      if (-3LL != ft) {
        if (y) {
          tmp___2 = 2;
        } else {
          tmp___2 = 1;
        }
        argc = (I )tmp___2;
        tmp___3 = newK((I )0, argc);
        args___0 = tmp___3;
        if (! args___0) {
          return ((K )0);
        }
        args___0->k[0] = ci(*p);
        if (argc > 1LL) {
          args___0->k[1] = ci(y);
        }
        tmp___4 = specialAmendDot(c, args___0);
        r = tmp___4;
        cd(args___0);
        if (! r) {
          return ((K )0);
        }
        cd(*p);
        if (5LL == r->t) {
          *p = kcloneI(r, "src/vd.c", 157);
          cd(r);
        } else
        if (0LL == r->t) {
          *p = kcloneI(r, "src/vd.c", 157);
          cd(r);
        } else {
          *p = r;
        }
        return ((K )((void *)0));
      }
    }
  }
  if (1LL <= dt) {
    if (dt <= 4LL) {
      tmp___5 = kerr("rank");
      return (tmp___5);
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (7LL == dt) {
    tmp___5 = kerr("rank");
    return (tmp___5);
  } else
  if (7LL == ft) {
    tmp___5 = kerr("rank");
    return (tmp___5);
  } else
  if (6LL == dt) {
    if (0LL >= ft) {
      if (-4LL != ft) {
        tmp___6 = kerr("index");
        return (tmp___6);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (6LL == dt) {
    if (6LL != ft) {
      if (ft < 0LL) {
        tmp___8 = - ft;
      } else {
        tmp___8 = ft;
      }
      if (4LL != tmp___8) {
        tmp___7 = kerr("type");
        return (tmp___7);
      }
    }
  }
  if (5LL == dt) {
    if (123LL == ft) {
      return ((K )((void *)0));
    }
  }
  if (0LL >= s) {
    at_ref(p, f, c, y);
  } else
  if (0LL == ft) {
    tmp___10 = atomI(f);
    if (! tmp___10) {
      if (y) {
        tmp___11 = atomI(y);
        if (! tmp___11) {
          if (fn != yn0) {
            tmp___9 = kerr("length");
            return (tmp___9);
          }
        }
      }
    }
    tmp___14 = atomI(f);
    if (tmp___14) {
      if (y) {
        tmp___13 = yn0;
      } else {
        tmp___13 = fn;
      }
    } else {
      tmp___13 = fn;
    }
    n = tmp___13;
    if (y) {
      y = promote(y);
      if (! y) {
        return ((K )0);
      }
    }
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      dot_ref(p, f->k + i % fn, z, s, c, y->k[i % yn0]);
      i ++;
    }
    cd(y);
  } else {
    if (ft < 0LL) {
      tmp___44 = - ft;
    } else {
      tmp___44 = ft;
    }
    if (1LL == tmp___44) {
      if (f) {
        tmp___16 = atomI(f);
        if (! tmp___16) {
          if (y) {
            tmp___17 = atomI(y);
            if (! tmp___17) {
              if (fn != yn0) {
                tmp___15 = kerr("length");
                return (tmp___15);
              }
            }
          }
        }
      }
      if (1LL == ft) {
        if (dt > 0LL) {
          tmp___18 = kerr("type");
          return (tmp___18);
        }
      }
      if (y) {
        if (y->t != 0LL) {
          if (f) {
            tmp___19 = atomI(f);
            if (tmp___19) {
              ci(y);
            } else {
              y = promote(y);
              if (! y) {
                return ((K )0);
              }
            }
          } else {
            ci(y);
          }
        } else {
          ci(y);
        }
      } else {
        ci(y);
      }
      if (dt != 0LL) {
        tmp___20 = kerr("rank");
        return (tmp___20);
      }
      if (f) {
        i___0 = (I )0;
        _i___1 = fn;
        while (i___0 < _i___1) {
          e = *((I *)(f->k) + i___0);
          if (e < 0LL) {
            tmp___21 = kerr("index");
            return (tmp___21);
          } else
          if (dn <= e) {
            tmp___21 = kerr("index");
            return (tmp___21);
          }
          i___0 ++;
        }
      }
      if (f) {
        i___1 = (I )0;
        _i___2 = fn;
        while (i___1 < _i___2) {
          py = (K )0;
          if (y) {
            tmp___23 = atomI(f);
            if (tmp___23) {
              py = y;
            } else {
              py = y->k[i___1 % yn0];
            }
          }
          dot_ref(d___0->k + *((I *)(f->k) + i___1), z, z + 1, s - 1LL, c, py);
          i___1 ++;
        }
      }
      cd(y);
    } else {
      if (ft < 0LL) {
        tmp___43 = - ft;
      } else {
        tmp___43 = ft;
      }
      if (4LL == tmp___43) {
        tmp___25 = atomI(f);
        if (! tmp___25) {
          if (y) {
            tmp___26 = atomI(y);
            if (! tmp___26) {
              if (fn != yn0) {
                tmp___24 = kerr("length");
                return (tmp___24);
              }
            }
          }
        }
        if (4LL == ft) {
          if (0LL >= dt) {
            tmp___27 = kerr("type");
            return (tmp___27);
          }
        }
        if (-4LL == ft) {
          if (0LL >= dt) {
            tmp___28 = kerr("int");
            return (tmp___28);
          }
        }
        if (y) {
          if (y->t != 0LL) {
            tmp___29 = atomI(f);
            if (tmp___29) {
              ci(y);
            } else {
              y = promote(y);
              if (! y) {
                return ((K )0);
              }
            }
          } else {
            ci(y);
          }
        } else {
          ci(y);
        }
        i___2 = (I )0;
        _i___3 = fn;
        while (i___2 < _i___3) {
          py___0 = (K )0;
          if (y) {
            tmp___31 = atomI(f);
            if (tmp___31) {
              py___0 = y;
            } else {
              py___0 = y->k[i___2 % yn0];
            }
          }
          u = *((S *)(f->k) + i___2);
          tmp___32 = lookupEVOrCreate(p, u);
          dot_ref(tmp___32, z, z + 1, s - 1LL, c, py___0);
          i___2 ++;
        }
        cd(y);
      } else
      if (6LL == ft) {
        if (6LL == dt) {
          return ((K )((void *)0));
        }
        if (y) {
          tmp___34 = atomI(y);
          if (! tmp___34) {
            if (yn0 != d___0->n) {
              tmp___33 = kerr("length");
              return (tmp___33);
            }
          }
        }
        if (y) {
          y = promote(y);
          if (! y) {
            return ((K )0);
          }
        }
        if (5LL == dt) {
          i___3 = (I )0;
          _i___4 = d___0->n;
          while (i___3 < _i___4) {
            if (y) {
              tmp___35 = y->k[i___3 % yn0];
            } else {
              tmp___35 = (struct k0 *)0;
            }
            tmp___36 = DI(d___0, i___3);
            tmp___37 = EVP(tmp___36);
            dot_ref(tmp___37, z, z + 1, s - 1LL, c, tmp___35);
            i___3 ++;
          }
        }
        if (0LL >= dt) {
          tmp___38 = Ki((I )0);
          k = tmp___38;
          if (y) {
            tmp___39 = y;
          } else {
            tmp___39 = k;
          }
          tmp___40 = OOM_CD((I )0, k, tmp___39, (V )-1);
          if (! tmp___40) {
            return ((K )0);
          }
          i___4 = (I )0;
          tmp___41 = countI(d___0);
          _i___5 = tmp___41;
          while (i___4 < _i___5) {
            *((I *)(k->k)) = i___4;
            if (y) {
              tmp___42 = y->k[i___4 % yn0];
            } else {
              tmp___42 = (struct k0 *)0;
            }
            dot_ref(p, & k, z, s, c, tmp___42);
            i___4 ++;
          }
          cd(k);
        }
        cd(y);
      }
    }
  }
  return ((K )0);
}
}
K dot_tetradic_2(K *g , K b___1 , K c , K y ) 
{ 
  V q ;
  K tmp ;
  I bt ;
  I bn ;
  I tmp___0 ;
  K *f ;
  K *tmp___1 ;
  K tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;

  {
  if (c->t == 7LL) {
    if ((c->k[2])->t == -4LL) {
      q = *((V *)(((K )*((S *)(c->k) + 2))->k) + 0);
      if ((unsigned long )q > (unsigned long )((V )500)) {
        tmp = kerr("syntax");
        return (tmp);
      }
      fnc = DT[(L )q].text;
      if (fnci < 127LL) {
        fncp[fnci] = q;
        fnci ++;
      }
    }
  }
  bt = b___1->t;
  tmp___0 = countI(b___1);
  bn = tmp___0;
  if (0LL == bn) {
    dot_ref(g, & b___1, (K *)0, bn - 1LL, c, y);
  } else
  if (6LL == bt) {
    dot_ref(g, & b___1, (K *)0, bn - 1LL, c, y);
  } else
  if (0LL == bt) {
    goto _L;
  } else {
    if (bt < 0LL) {
      tmp___3 = - bt;
    } else {
      tmp___3 = bt;
    }
    if (1LL == tmp___3) {
      goto _L;
    } else {
      if (bt < 0LL) {
        tmp___4 = - bt;
      } else {
        tmp___4 = bt;
      }
      if (4LL == tmp___4) {
        _L: /* CIL Label */ 
        b___1 = promote(b___1);
        bt = (I )0;
        bn = countI(b___1);
        f = b___1->k;
        if (bn > 0LL) {
          tmp___1 = f + 1;
        } else {
          tmp___1 = (K *)0;
        }
        dot_ref(g, f, tmp___1, bn - 1LL, c, y);
        cd(b___1);
      } else {
        tmp___2 = kerr("type");
        return (tmp___2);
      }
    }
  }
  return (*g);
}
}
K dot_tetradic(K a , K b___1 , K c , K y ) 
{ 
  K d___0 ;
  K tmp ;
  K i ;
  K tmp___0 ;
  I tmp___1 ;
  K z ;
  K tmp___2 ;
  K e ;
  size_t tmp___3 ;
  K tmp___4 ;
  I tmp___5 ;
  K tmp___6 ;
  I tmp___7 ;
  K q ;
  K *p ;
  K *g ;
  K *tmp___8 ;
  K tmp___9 ;
  K tmp___10 ;
  K tmp___11 ;

  {
  tmp___7 = isColonDyadic(c);
  if (tmp___7) {
    if (! y) {
      if (! *((V *)(c->k) + 5)) {
        tmp = newK((I )0, (I )2);
        d___0 = tmp;
        tmp___0 = Ki((I )0);
        i = tmp___0;
        tmp___1 = OOM_CD((I )0, d___0, i, (V )-1);
        if (! tmp___1) {
          return ((K )0);
        }
        d___0->k[0] = i;
        tmp___2 = vf_ex((V )(& a), b___1);
        z = tmp___2;
        d___0->k[1] = z;
        if (! z) {
          *((I *)(i->k)) = (I )1;
          tmp___3 = strlen((char const   *)(errmsg));
          tmp___4 = newK((I )-3, (I )tmp___3);
          e = tmp___4;
          tmp___5 = OOM_CD((I )0, d___0, e, (V )-1);
          if (! tmp___5) {
            return ((K )0);
          }
          strcpy((char * __restrict  )((C *)(e->k)), (char const   * __restrict  )(errmsg));
          d___0->k[1] = e;
        }
        fer = (I )-1;
        tmp___6 = demote(d___0);
        return (tmp___6);
      }
    }
  }
  if (KONA_GSET) {
    if ((unsigned long )a != (unsigned long )KONA_GSET) {
      ci(a);
      cd(KONA_GSET);
      KONA_GSET = a;
    }
  }
  if (KONA_IDX) {
    if ((unsigned long )b___1 != (unsigned long )KONA_IDX) {
      ci(b___1);
      cd(KONA_IDX);
      KONA_IDX = b___1;
    }
  }
  q = (K )0;
  p = (K *)0;
  if (a->t == 4LL) {
    p = denameS(d_, *((S *)(a->k)), (I )1);
    if (! p) {
      return ((K )0);
    }
  } else {
    q = kcloneI(a, "src/vd.c", 295);
  }
  if (q) {
    tmp___8 = & q;
  } else {
    tmp___8 = p;
  }
  g = tmp___8;
  tmp___9 = dot_tetradic_2(g, b___1, c, y);
  if (! tmp___9) {
    return ((K )0);
  }
  if (q) {
    tmp___11 = q;
  } else {
    tmp___10 = ci(a);
    tmp___11 = tmp___10;
  }
  return (tmp___11);
}
}
K make(K a ) 
{ 
  K tmp ;
  K tmp___0 ;
  I n ;
  K x___0 ;
  K y ;
  K z ;
  K tmp___1 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I j ;
  I _j ;
  K tmp___2 ;
  K tmp___3 ;

  {
  tmp___0 = makeable(a);
  if (! tmp___0) {
    tmp = kerr("rank");
    return (tmp);
  }
  n = a->n;
  tmp___1 = newK((I )5, n);
  z = tmp___1;
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    z->k[i] = newK((I )0, (I )3);
    i ++;
  }
  i___0 = (I )0;
  _i___1 = n;
  while (i___0 < _i___1) {
    x___0 = z->k[i___0];
    y = a->k[i___0];
    j = (I )0;
    _j = y->n;
    while (j < _j) {
      if (y->t) {
        tmp___2 = Ks(*((S *)(y->k) + j));
        x___0->k[j] = tmp___2;
      } else {
        tmp___3 = ci(y->k[j]);
        x___0->k[j] = tmp___3;
      }
      j ++;
    }
    if (y->n < 3LL) {
      x___0->k[2] = _n();
    }
    i___0 ++;
  }
  return (z);
}
}
static K unmake(K a ) 
{ 
  K z ;
  K tmp ;

  {
  tmp = kcloneI(a, "src/vd.c", 321);
  z = tmp;
  z->t = (I )0;
  return (z);
}
}
static K makeable(K a ) 
{ 
  I t ;
  I n ;
  K x___0 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;

  {
  t = a->t;
  n = a->n;
  if (0LL != t) {
    return ((K )0);
  }
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    x___0 = a->k[i];
    if (0LL != x___0->t) {
      if (-4LL != x___0->t) {
        return ((K )0);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (x___0->n < 2LL) {
      return ((K )0);
    } else
    if (3LL < x___0->n) {
      return ((K )0);
    } else
    if (-4LL == x___0->t) {
      if (x___0->n != 2LL) {
        return ((K )0);
      }
    }
    i ++;
  }
  i___0 = (I )0;
  _i___1 = n;
  while (i___0 < _i___1) {
    x___0 = a->k[i___0];
    if (0LL == x___0->t) {
      if (4LL != (x___0->k[0])->t) {
        return ((K )0);
      } else
      if (3LL == x___0->n) {
        if (5LL != (x___0->k[2])->t) {
          if (6LL != (x___0->k[2])->t) {
            return ((K )0);
          }
        }
      }
    }
    i___0 ++;
  }
  return ((K )1);
}
}
K dot_monadic(K x___0 ) 
{ 
  K tmp ;
  K tmp___0 ;
  I tmp___1 ;
  K *p ;
  K *tmp___2 ;
  K tmp___3 ;
  K tmp___4 ;
  K tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  K tmp___8 ;

  {
  if (x___0->t == 0LL) {
    if (x___0->n == 1LL) {
      if ((x___0->k[0])->t == -3LL) {
        tmp = kerr("valence");
        return (tmp);
      }
    }
  }
  if (x___0->t < 0LL) {
    tmp___1 = - x___0->t;
  } else {
    tmp___1 = x___0->t;
  }
  if (3LL == tmp___1) {
    tmp___0 = KX(x___0);
    return (tmp___0);
  }
  if (4LL == x___0->t) {
    tmp___2 = denameS(d_, *((S *)(x___0->k)), (I )0);
    p = tmp___2;
    if (! p) {
      tmp___3 = kerr("domain");
      return (tmp___3);
    }
    tmp___4 = ci(*p);
    return (tmp___4);
  }
  if (5LL == x___0->t) {
    tmp___5 = unmake(x___0);
    return (tmp___5);
  }
  tmp___7 = makeable(x___0);
  if (tmp___7) {
    tmp___6 = make(x___0);
    return (tmp___6);
  }
  tmp___8 = vf_ex(offsetDot, x___0);
  return (tmp___8);
}
}
#pragma merger("0","/tmp/cil-X4btHrVW.i","-g,-pthread,-O3")
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
F ni[7] ;
I NI[7] ;
static I TNI(I p , C h ) ;
static I parseNI(S s , I n ) ;
S CSK(K x___0 ) 
{ 
  C *tmp___0 ;
  I tmp___1 ;
  S tmp___2 ;
  S tmp___3 ;

  {
  if (! x___0) {
    tmp___3 = (S )0;
  } else {
    if (4LL == x___0->t) {
      tmp___2 = *((S *)(x___0->k));
    } else {
      if (x___0->t < 0LL) {
        tmp___1 = - x___0->t;
      } else {
        tmp___1 = x___0->t;
      }
      if (3LL == tmp___1) {
        tmp___0 = (C *)(x___0->k);
      } else {
        tmp___0 = (C *)0;
      }
      tmp___2 = tmp___0;
    }
    tmp___3 = tmp___2;
  }
  return (tmp___3);
}
}
static K formKsCS(S s ) 
{ 
  S t ;
  S tmp ;
  K z ;
  K tmp___0 ;

  {
  tmp = sp(s);
  t = tmp;
  if (! t) {
    return ((K )0);
  }
  tmp___0 = Ks(t);
  z = tmp___0;
  if (! z) {
    return ((K )0);
  }
  return (z);
}
}
K formKiCS(S s ) 
{ 
  C *p ;
  C q ;
  I r ;
  I w___0 ;
  size_t tmp ;
  I tmp___0 ;
  int *tmp___1 ;
  unsigned short const   **tmp___2 ;
  K tmp___3 ;

  {
  q = (C )0;
  r = (-0x7FFFFFFFFFFFFFFF-1);
  tmp = strlen((char const   *)s);
  tmp___0 = parseNI(s, (I )tmp);
  w___0 = tmp___0;
  if (w___0) {
    r = NI[w___0];
  } else
  if (*s) {
    r = strtoll((char const   * __restrict  )s, (char ** __restrict  )(& p), 10);
    tmp___1 = __errno_location();
    *tmp___1 = 0;
    q = *p;
    if ((-0x7FFFFFFFFFFFFFFF-1) == r) {
      r = -9223372036854775807LL;
    }
  }
  if (q) {
    tmp___2 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___2 + (int )q) & 1)) {
      return ((K )0);
    }
  }
  tmp___3 = Ki(r);
  return (tmp___3);
}
}
K formKfCS(S s ) 
{ 
  C *p ;
  C q ;
  F r ;
  I w___0 ;
  size_t tmp ;
  I tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  K tmp___4 ;

  {
  q = (C )0;
  r = (double )0 / 0.;
  tmp = strlen((char const   *)s);
  tmp___0 = parseNI(s, (I )tmp);
  w___0 = tmp___0;
  if (w___0) {
    r = ni[w___0];
  } else
  if (*s) {
    r = strtod((char const   * __restrict  )s, (char ** __restrict  )(& p));
    tmp___1 = __errno_location();
    *tmp___1 = 0;
    q = *p;
    tmp___2 = __builtin_isnan(r);
    if (tmp___2) {
      r = - ((double )1 / 0.);
    }
  }
  if (q) {
    tmp___3 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___3 + (int )q) & 1)) {
      return ((K )0);
    }
  }
  tmp___4 = Kf(r);
  return (tmp___4);
}
}
static K formatFn(K a ) 
{ 
  V *v ;
  V p ;
  I i ;
  I k ;
  I n ;
  I r ;
  K z ;
  C t[256] ;
  unsigned int tmp ;
  S s ;
  L q ;
  S u ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  S f ;
  I n___0 ;
  size_t tmp___2 ;

  {
  v = (V *)((S *)(((K )*((V *)(a->k) + 2))->k));
  r = (I )0;
  z = (K )0;
  t[0] = (C )'\000';
  tmp = 1U;
  while (! (tmp >= 256U)) {
    t[tmp] = (char)0;
    tmp ++;
  }
  s = t;
  switch (a->n) {
  case 1LL: 
  i = (I )0;
  while (1) {
    p = *(v + i);
    if (! p) {
      break;
    }
    q = (L )p;
    if (q < DT_SIZE) {
      if (q >= DT_SPECIAL_VERB_OFFSET) {
        u = DT[q].text;
        tmp___0 = strlen((char const   *)u);
        n = (I )tmp___0;
        strcpy((char * __restrict  )(s + r), (char const   * __restrict  )u);
        r += n;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      k = adverbClass(p);
      if (k) {
        t[r] = adverbsChar(p);
        if (k != 1LL) {
          t[r + 1LL] = (C )':';
        }
        r ++;
      } else {
        k = sva(p);
        if (k) {
          t[r] = verbsChar(p);
          if (k != 2LL) {
            t[r + 1LL] = (C )':';
          }
          r ++;
        }
      }
    }
    i ++;
  }
  tmp___1 = strlen((char const   *)s);
  n = (I )tmp___1;
  z = newK((I )-3, n);
  memcpy((void * __restrict  )((C *)(z->k)), (void const   * __restrict  )s, (size_t )(n + 1LL));
  break;
  case 2LL: ;
  break;
  case 3LL: 
  f = (C *)(((K )*((V *)(a->k) + 2))->k);
  tmp___2 = strlen((char const   *)f);
  n___0 = (I )tmp___2;
  z = newK((I )-3, n___0 + 2LL);
  *((C *)(z->k) + 0) = (C )'{';
  memcpy((void * __restrict  )((C *)(z->k) + 1), (void const   * __restrict  )f, (size_t )n___0);
  *((C *)(z->k) + (n___0 + 1LL)) = (C )'}';
  *((C *)(z->k) + (n___0 + 2LL)) = (C )0;
  break;
  }
  return (z);
}
}
static K formatS(S x___0 ) 
{ 
  I n ;
  size_t tmp ;
  K z ;
  K tmp___0 ;

  {
  tmp = strlen((char const   *)x___0);
  n = (I )tmp;
  tmp___0 = newK((I )-3, n);
  z = tmp___0;
  if (z) {
    sprintf((char * __restrict  )((C *)(z->k)), (char const   * __restrict  )"%s",
            x___0);
  }
  return (z);
}
}
static C buf[32]  ;
static K formatF(F x___0 , I y , I c ) 
{ 
  int k ;
  S b___1 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  I n ;
  size_t tmp___1 ;
  K z ;
  K tmp___2 ;

  {
  k = (int )y;
  if (0LL == c) {
    tmp___0 = "%.*g";
  } else {
    if (1LL == c) {
      tmp = "%.*f";
    } else {
      tmp = "%.*e";
    }
    tmp___0 = tmp;
  }
  b___1 = (S )tmp___0;
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )b___1, k, x___0);
  tmp___1 = strlen((char const   *)(buf));
  n = (I )tmp___1;
  tmp___2 = newK((I )-3, n);
  z = tmp___2;
  if (z) {
    memcpy((void * __restrict  )((C *)(z->k)), (void const   * __restrict  )(buf),
           (size_t )n);
  }
  return (z);
}
}
static C buf___0[72]  ;
static K formatI(I x___0 ) 
{ 
  I n ;
  size_t tmp ;
  K z ;
  K tmp___0 ;

  {
  sprintf((char * __restrict  )(buf___0), (char const   * __restrict  )"%lld", x___0);
  tmp = strlen((char const   *)(buf___0));
  n = (I )tmp;
  tmp___0 = newK((I )-3, n);
  z = tmp___0;
  if (z) {
    memcpy((void * __restrict  )((C *)(z->k)), (void const   * __restrict  )(buf___0),
           (size_t )n);
  }
  return (z);
}
}
K format(K a ) 
{ 
  I at___0 ;
  I an ;
  K z ;
  K tmp ;
  K tmp___0 ;
  S tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  K tmp___4 ;
  K tmp___5 ;
  I tmp___6 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;

  {
  at___0 = a->t;
  an = a->n;
  if (at___0 < 0LL) {
    tmp___6 = - at___0;
  } else {
    tmp___6 = at___0;
  }
  if (3LL == tmp___6) {
    z = kcloneI(a, "src/vf.c", 100);
    z->t = (I )-3;
    return (z);
  } else
  if (7LL == at___0) {
    tmp = formatFn(a);
    return (tmp);
  } else
  if (6LL == at___0) {
    tmp___0 = newK((I )-3, (I )0);
    return (tmp___0);
  } else
  if (5LL == at___0) {
    tmp___1 = sp((S )".(..)");
    tmp___2 = formatS(tmp___1);
    return (tmp___2);
  } else
  if (4LL == at___0) {
    tmp___3 = formatS(*((S *)(a->k)));
    return (tmp___3);
  } else
  if (2LL == at___0) {
    tmp___4 = formatF(*((F *)(a->k)), PP, (I )0);
    return (tmp___4);
  } else
  if (1LL == at___0) {
    tmp___5 = formatI(*((I *)(a->k)));
    return (tmp___5);
  }
  z = newK((I )0, an);
  if (0LL == at___0) {
    i = (I )0;
    _i___0 = an;
    while (i < _i___0) {
      z->k[i] = format(a->k[i]);
      i ++;
    }
  } else
  if (-1LL == at___0) {
    i___0 = (I )0;
    _i___1 = an;
    while (i___0 < _i___1) {
      z->k[i___0] = formatI(*((I *)(a->k) + i___0));
      i___0 ++;
    }
  } else
  if (-2LL == at___0) {
    i___1 = (I )0;
    _i___2 = an;
    while (i___1 < _i___2) {
      z->k[i___1] = formatF(*((F *)(a->k) + i___1), PP, (I )0);
      i___1 ++;
    }
  } else
  if (-4LL == at___0) {
    i___2 = (I )0;
    _i___3 = an;
    while (i___2 < _i___3) {
      z->k[i___2] = formatS(*((S *)(a->k) + i___2));
      i___2 ++;
    }
  }
  return (z);
}
}
I NI[7]  = {      (I )0,      (-0x7FFFFFFFFFFFFFFF-1),      -9223372036854775807LL,      9223372036854775807LL, 
        9223372036854775807LL,      -9223372036854775807LL,      9223372036854775807LL};
F ni[7]  = {      (F )0,      (double )0 / 0.,      - ((double )1 / 0.),      (double )1 / 0., 
        (double )0 / 0.,      - ((double )1 / 0.),      (double )1 / 0.};
static I TNI(I p , C h ) 
{ 
  I c ;
  I tmp___0 ;
  I tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  tmp___2 = __ctype_b_loc();
  if ((int const   )*(*tmp___2 + (int )h) & 1) {
    tmp___1 = (I )0;
  } else {
    tmp___0 = charpos((S )" -0NIni", h);
    tmp___1 = tmp___0;
  }
  c = tmp___1;
  if (0LL == c) {
    if (7LL >= p) {
      return (p);
    }
  }
  if (1LL == c) {
    if (0LL == p) {
      return (7LL - p);
    } else
    if (7LL == p) {
      return (7LL - p);
    }
  }
  if (2LL == c) {
    if (0LL == p) {
      return ((I )9);
    }
  }
  if (2LL == c) {
    if (7LL == p) {
      return ((I )8);
    }
  }
  if (3LL == c) {
    if (8LL == p) {
      return ((I )1);
    } else
    if (9LL == p) {
      return ((I )1);
    }
  }
  if (4LL == c) {
    if (8LL == p) {
      return (p - 6LL);
    } else
    if (9LL == p) {
      return (p - 6LL);
    }
  }
  if (5LL == c) {
    if (8LL == p) {
      return ((I )4);
    } else
    if (9LL == p) {
      return ((I )4);
    }
  }
  if (6LL == c) {
    if (8LL == p) {
      return (p - 3LL);
    } else
    if (9LL == p) {
      return (p - 3LL);
    }
  }
  return ((I )10);
}
}
static I parseNI(S s , I n ) 
{ 
  I i ;
  I p ;
  S tmp ;
  I tmp___0 ;

  {
  i = (I )0;
  p = (I )0;
  while (1) {
    if (i < n) {
      if (! *s) {
        break;
      }
    } else {
      break;
    }
    tmp = s;
    s ++;
    p = TNI(p, *tmp);
  }
  if (p < 7LL) {
    tmp___0 = p;
  } else {
    tmp___0 = (I )0;
  }
  return (tmp___0);
}
}
static F tround(F f ) 
{ 
  F d___0 ;
  F tmp ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  I tmp___5 ;
  I tmp___6 ;

  {
  tmp = FF(f);
  d___0 = tmp;
  if (d___0 > (F )0) {
    tmp___5 = FC(d___0, (F )1);
    if (tmp___5) {
      goto _L;
    } else {
      tmp___2 = ceil(f);
      tmp___4 = tmp___2;
    }
  } else
  _L: /* CIL Label */ 
  if (d___0 < (F )0) {
    tmp___6 = FC(d___0, (F )0);
    if (tmp___6) {
      tmp___3 = floor(f);
      tmp___4 = tmp___3;
    } else {
      tmp___2 = ceil(f);
      tmp___4 = tmp___2;
    }
  } else {
    tmp___3 = floor(f);
    tmp___4 = tmp___3;
  }
  return (tmp___4);
}
}
extern int ( /* missing proto */  __builtin_signbit)() ;
K dollar(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  K z ;
  I x___0 ;
  int tmp ;
  I y ;
  int tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  K tmp___4 ;
  K tmp___5 ;
  I tmp___6 ;
  K tmp___7 ;
  I i ;
  I _i___0 ;
  K q ;
  struct k0 *tmp___8 ;
  struct k0 *tmp___9 ;
  K tmp___10 ;
  I tmp___11 ;
  K tmp___12 ;
  K c ;
  I m ;
  I tmp___13 ;
  I tmp___14 ;
  I i___0 ;
  I _i___1 ;
  I k ;
  I tmp___15 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  F f ;
  K c___0 ;
  K d___0 ;
  int tmp___17 ;
  int tmp___18 ;
  double tmp___19 ;
  F tmp___20 ;
  F tmp___21 ;
  S tmp___22 ;
  K tmp___23 ;
  size_t tmp___24 ;
  K tmp___25 ;
  I tmp___26 ;
  S tmp___27 ;
  K tmp___28 ;
  S tmp___29 ;
  K tmp___30 ;
  I tmp___31 ;
  K tmp___32 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  z = (K )0;
  if (at___0 <= 0LL) {
    if (-3LL != at___0) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  x___0 = (I )tmp;
  if (bt <= 0LL) {
    if (-3LL != bt) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  y = (I )tmp___0;
  if (x___0) {
    if (y) {
      if (an != bn) {
        tmp___1 = kerr("length");
        return (tmp___1);
      }
    }
  }
  if (x___0) {
    goto _L;
  } else
  if (y) {
    _L: /* CIL Label */ 
    if (x___0) {
      tmp___2 = promote(a);
      a = tmp___2;
    } else {
      tmp___3 = ci(a);
      a = tmp___3;
    }
    if (y) {
      tmp___4 = promote(b___1);
      b___1 = tmp___4;
    } else {
      tmp___5 = ci(b___1);
      b___1 = tmp___5;
    }
    if (a) {
      if (b___1) {
        if (x___0) {
          tmp___6 = a->n;
        } else {
          tmp___6 = b___1->n;
        }
        tmp___7 = newK((I )0, tmp___6);
        z = tmp___7;
      } else {
        z = (K )0;
      }
    } else {
      z = (K )0;
    }
    if (z) {
      i = (I )0;
      _i___0 = z->n;
      while (i < _i___0) {
        if (y) {
          tmp___8 = b___1->k[i];
        } else {
          tmp___8 = b___1;
        }
        if (x___0) {
          tmp___9 = a->k[i];
        } else {
          tmp___9 = a;
        }
        tmp___10 = dollar(tmp___9, tmp___8);
        q = tmp___10;
        tmp___11 = OOM_CD((I )0, q, z, a, b___1, (V )-1);
        if (! tmp___11) {
          return ((K )0);
        }
        z->k[i] = q;
        i ++;
      }
    }
    cd(a);
    cd(b___1);
    tmp___12 = demote(z);
    return (tmp___12);
  }
  if (1LL == at___0) {
    if (*((I *)(a->k))) {
      c = format(b___1);
      if (! c) {
        return ((K )0);
      }
      m = *((I *)(a->k));
      if (m < 0LL) {
        tmp___13 = - m;
      } else {
        tmp___13 = m;
      }
      z = newK((I )-3, tmp___13);
      tmp___14 = OOM_CD((I )0, c, z, (V )-1);
      if (! tmp___14) {
        return ((K )0);
      }
      if (z->n < c->n) {
        i___0 = (I )0;
        _i___1 = z->n;
        while (i___0 < _i___1) {
          *((C *)(z->k) + i___0) = (C )'*';
          i___0 ++;
        }
      } else {
        if (m > 0LL) {
          tmp___15 = m - c->n;
        } else {
          tmp___15 = (I )0;
        }
        k = tmp___15;
        i___1 = (I )0;
        _i___2 = z->n;
        while (i___1 < _i___2) {
          *((C *)(z->k) + i___1) = (C )' ';
          i___1 ++;
        }
        i___2 = (I )0;
        _i___3 = c->n;
        while (i___2 < _i___3) {
          *((C *)(z->k) + (i___2 + k)) = *((C *)(c->k) + i___2);
          i___2 ++;
        }
      }
      cd(c);
      return (z);
    }
  }
  if (2LL == at___0) {
    f = *((F *)(a->k));
    if (2LL == bt) {
      goto _L___0;
    } else
    if (1LL == bt) {
      _L___0: /* CIL Label */ 
      c___0 = Ki((I )f);
      if (! c___0) {
        return ((K )0);
      }
      tmp___18 = __builtin_signbit(f);
      if (tmp___18) {
        tmp___17 = 2;
      } else {
        tmp___17 = 1;
      }
      tmp___19 = fabs(f);
      tmp___20 = tround(tmp___19 * (double )10);
      if (2LL == bt) {
        tmp___21 = *((F *)(b___1->k));
      } else {
        tmp___21 = (F )*((I *)(b___1->k));
      }
      d___0 = formatF(tmp___21, (I )tmp___20 % 10LL, (I )tmp___17);
      if (d___0) {
        z = dollar(c___0, d___0);
      }
      cd(c___0);
      cd(d___0);
      return (z);
    }
  }
  if (bt < 0LL) {
    tmp___31 = - bt;
  } else {
    tmp___31 = bt;
  }
  if (3LL == tmp___31) {
    if (3LL == bt) {
      b___1 = enlist(b___1);
    }
    if (4LL == at___0) {
      tmp___24 = strlen((char const   *)*((S *)(a->k)));
      if (! tmp___24) {
        tmp___22 = CSK(b___1);
        tmp___23 = formKsCS(tmp___22);
        return (tmp___23);
      }
    }
    if (at___0 < 0LL) {
      tmp___26 = - at___0;
    } else {
      tmp___26 = at___0;
    }
    if (3LL == tmp___26) {
      tmp___25 = ci(b___1);
      return (tmp___25);
    }
    if (2LL == at___0) {
      tmp___27 = CSK(b___1);
      tmp___28 = formKfCS(tmp___27);
      return (tmp___28);
    }
    if (1LL == at___0) {
      if (! *((I *)(a->k))) {
        tmp___29 = CSK(b___1);
        tmp___30 = formKiCS(tmp___29);
        return (tmp___30);
      }
    }
    return ((K )0);
  }
  tmp___32 = kerr("type");
  return (tmp___32);
}
}
#pragma merger("0","/tmp/cil-vZk5UkHp.i","-g,-pthread,-O3")
K cut(K a , K b___1 ) ;
K take(K a , K b___1 ) ;
K reshape(K a , K b___1 ) ;
I VAT(I i ) ;
static I FtoI(F a ) 
{ 
  union __anonunion_u_554368621 u ;
  int tmp ;
  long long tmp___0 ;

  {
  tmp = __builtin_isnan(a);
  if (tmp) {
    return ((-0x7FFFFFFFFFFFFFFF-1));
  }
  u.f = a;
  if (0LL > u.i) {
    tmp___0 = (-0x7FFFFFFFFFFFFFFF-1) - u.i;
  } else {
    tmp___0 = u.i;
  }
  return (tmp___0);
}
}
static uI ItoU(I a ) 
{ 


  {
  return (9223372036854775808 ^ (uI )a);
}
}
K grade_updown(K a , I r ) 
{ 
  I at___0 ;
  I an ;
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;
  K z ;
  I tmp___2 ;
  I i ;
  I _i___0 ;
  K x___0 ;
  uI y ;
  uI u ;
  uI v ;
  uI h ;
  uI k ;
  I tmp___3 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I tmp___4 ;
  I tmp___5 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  I tmp___6 ;
  I i___4 ;
  I _i___5 ;
  K tmp___7 ;
  K tmp___8 ;
  K tmp___9 ;
  K tmp___10 ;

  {
  at___0 = a->t;
  an = a->n;
  if (0LL < at___0) {
    tmp = kerr("rank");
    return (tmp);
  }
  if (-4LL == at___0) {
    tmp___0 = symGrade(a, r);
    return (tmp___0);
  }
  if (-3LL == at___0) {
    tmp___1 = charGrade(a, r);
    return (tmp___1);
  }
  if (-1LL == at___0) {
    goto _L___2;
  } else
  if (-2LL == at___0) {
    _L___2: /* CIL Label */ 
    if (an < 2LL) {
      z = newK((I )-1, an);
      tmp___2 = OOM_CD((I )0, z, (V )-1);
      if (! tmp___2) {
        return ((K )0);
      }
      i = (I )0;
      _i___0 = an;
      while (i < _i___0) {
        *((I *)(z->k) + i) = i;
        i ++;
      }
      return (z);
    } else {
      x___0 = (K )0;
      u = (uI )-1;
      v = (uI )0;
      h = (uI )0;
      if (-2LL == at___0) {
        x___0 = newK((I )-1, an);
        tmp___3 = OOM_CD((I )0, x___0, (V )-1);
        if (! tmp___3) {
          return ((K )0);
        }
      }
      if (-1LL == at___0) {
        i___0 = (I )0;
        _i___1 = an;
        while (i___0 < _i___1) {
          y = (uI )*((I *)(a->k) + i___0);
          h |= y;
          if (y < u) {
            u = y;
          }
          if (y > v) {
            v = y;
          }
          i___0 ++;
        }
      } else {
        i___1 = (I )0;
        _i___2 = an;
        while (i___1 < _i___2) {
          tmp___4 = FtoI(*((F *)(a->k) + i___1));
          y = (uI )tmp___4;
          *((uI *)(x___0->k) + i___1) = y;
          h |= y;
          if (y < u) {
            u = y;
          }
          if (y > v) {
            v = y;
          }
          i___1 ++;
        }
      }
      if (r) {
        if (-1LL == at___0) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if ((u & 0x8000000000000000ULL) != (v & 0x8000000000000000ULL)) {
        _L: /* CIL Label */ 
        u = (uI )-1;
        v = (uI )0;
        h = (uI )0;
        if (-1LL == at___0) {
          x___0 = newK((I )-1, an);
          tmp___5 = OOM_CD((I )0, x___0, (V )-1);
          if (! tmp___5) {
            return ((K )0);
          }
          i___2 = (I )0;
          _i___3 = an;
          while (i___2 < _i___3) {
            y = ItoU(*((I *)(a->k) + i___2));
            *((uI *)(x___0->k) + i___2) = y;
            h |= y;
            if (y < u) {
              u = y;
            }
            if (y > v) {
              v = y;
            }
            i___2 ++;
          }
        } else {
          i___3 = (I )0;
          _i___4 = an;
          while (i___3 < _i___4) {
            y = ItoU(*((I *)(x___0->k) + i___3));
            *((uI *)(x___0->k) + i___3) = y;
            h |= y;
            if (y < u) {
              u = y;
            }
            if (y > v) {
              v = y;
            }
            i___3 ++;
          }
        }
      }
      k = v - u;
      if (! k) {
        z = newK((I )-1, an);
        tmp___6 = OOM_CD((I )0, z, (V )-1);
        if (! tmp___6) {
          return ((K )0);
        }
        i___4 = (I )0;
        _i___5 = an;
        while (i___4 < _i___5) {
          *((I *)(z->k) + i___4) = i___4;
          i___4 ++;
        }
      } else
      if (an < 7LL) {
        if (x___0) {
          tmp___7 = x___0;
        } else {
          tmp___7 = a;
        }
        z = insertGradeU(tmp___7, r);
      } else
      if (k < (uI )(1 << 26)) {
        if ((uI )(9LL * an + 18LL) > 2ULL * k) {
          if (x___0) {
            tmp___8 = x___0;
          } else {
            tmp___8 = a;
          }
          z = distributionGrade(tmp___8, r, u, v);
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        if (x___0) {
          tmp___9 = x___0;
        } else {
          tmp___9 = a;
        }
        z = radixGrade(tmp___9, r, h);
      }
      cd(x___0);
    }
    return (z);
  }
  tmp___10 = mergeGrade(a, r);
  return (tmp___10);
}
}
K grade_up(K a ) 
{ 
  K tmp ;

  {
  tmp = grade_updown(a, (I )0);
  return (tmp);
}
}
K grade_down(K a ) 
{ 
  K tmp ;

  {
  tmp = grade_updown(a, (I )1);
  return (tmp);
}
}
K enlist(K x___0 ) 
{ 
  I t ;
  I tmp ;
  K z ;
  K tmp___0 ;

  {
  if (1LL <= x___0->t) {
    if (x___0->t <= 4LL) {
      tmp = - x___0->t;
    } else {
      tmp = (I )0;
    }
  } else {
    tmp = (I )0;
  }
  t = tmp;
  tmp___0 = newK(t, (I )1);
  z = tmp___0;
  if (-4LL == t) {
    *((S *)(z->k)) = *((S *)(x___0->k));
  }
  if (-3LL == t) {
    *((C *)(z->k)) = *((C *)(x___0->k));
  }
  if (-2LL == t) {
    *((F *)(z->k)) = *((F *)(x___0->k));
  }
  if (-1LL == t) {
    *((I *)(z->k)) = *((I *)(x___0->k));
  }
  if (0LL == t) {
    z->k[0] = ci(x___0);
  }
  return (z);
}
}
static K charRange(K a ) 
{ 
  I n ;
  I c[256] ;
  I j ;
  K z ;
  K tmp ;
  I tmp___0 ;
  I i ;
  I _i___0 ;
  UC x___0 ;
  I tmp___1 ;
  K y ;
  K tmp___2 ;
  I tmp___3 ;

  {
  n = a->n;
  j = (I )0;
  memset((void *)(c), 0, 256UL * sizeof(I ));
  tmp = newK((I )-3, n);
  z = tmp;
  tmp___0 = OOM_CD((I )0, z, (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    x___0 = (UC )*((C *)(a->k) + i);
    if (! c[x___0]) {
      c[x___0] = (I )-1;
      tmp___1 = j;
      j ++;
      *((C *)(z->k) + tmp___1) = *((C *)(a->k) + i);
    }
    i ++;
  }
  if (n == j) {
    return (z);
  }
  tmp___2 = newK((I )-3, j);
  y = tmp___2;
  tmp___3 = OOM_CD((I )0, z, y, (V )-1);
  if (! tmp___3) {
    return ((K )0);
  }
  memcpy((void * __restrict  )((C *)(y->k)), (void const   * __restrict  )((C *)(z->k)),
         (size_t )((unsigned long long )j * (unsigned long long )sizeof(C )));
  cd(z);
  return (y);
}
}
static K symRange(K x___0 ) 
{ 
  I j ;
  K z ;
  K tmp ;
  I tmp___0 ;
  I i ;
  I _i___0 ;
  S s ;
  I tmp___1 ;
  K y ;
  K tmp___2 ;
  I tmp___3 ;

  {
  j = (I )0;
  tmp = newK((I )-4, x___0->n);
  z = tmp;
  tmp___0 = OOM_CD((I )0, z, (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  setS(2, (I )0);
  i = (I )0;
  _i___0 = x___0->n;
  while (i < _i___0) {
    s = *((S *)(x___0->k) + i);
    if (! *((I *)s + -2)) {
      *((I *)s + -2) = (I )-1;
      tmp___1 = j;
      j ++;
      *((S *)(z->k) + tmp___1) = s;
    }
    i ++;
  }
  if (x___0->n == j) {
    return (z);
  }
  tmp___2 = newK((I )-4, j);
  y = tmp___2;
  tmp___3 = OOM_CD((I )0, z, y, (V )-1);
  if (! tmp___3) {
    return ((K )0);
  }
  memcpy((void * __restrict  )((S *)(y->k)), (void const   * __restrict  )((S *)(z->k)),
         (size_t )((unsigned long long )j * (unsigned long long )sizeof(S )));
  cd(z);
  return (y);
}
}
static K newH(I n ) 
{ 
  I m ;
  I tmp ;
  K h ;
  K tmp___0 ;
  I tmp___1 ;

  {
  tmp = cl2(n);
  m = (I )(1 << (1LL + tmp));
  tmp___0 = newK((I )-1, m);
  h = tmp___0;
  tmp___1 = OOM_CD((I )0, h, (V )-1);
  if (! tmp___1) {
    return ((K )0);
  }
  return (h);
}
}
static I hg(K h , uI hk , I k , uI *p ) 
{ 
  I n ;
  I *d___0 ;
  uI u ;

  {
  n = h->n;
  d___0 = (I *)(h->k);
  u = hk & (unsigned long long )(n - 1LL);
  while (*(d___0 + u)) {
    if (k == *(d___0 + u)) {
      *p = u;
      return (k);
    }
    u ++;
    if (u == (uI )n) {
      u = (uI )0;
    }
  }
  *p = u;
  return ((I )0);
}
}
static uI hcc[8]  = 
  {      (uI )0,      (uI )0,      (uI )0,      (uI )0, 
        (uI )0,      (uI )0,      (uI )0,      (uI )0};
static void hcinit(void) 
{ 
  I i ;
  I _i___0 ;

  {
  if (! hcc[0]) {
    i = (I )0;
    _i___0 = (I )8;
    while (i < _i___0) {
      hcc[i] = genrand64_int64();
      i ++;
    }
  }
  return;
}
}
static uint32_t hc(uI u ) 
{ 
  I i ;
  I _i___0 ;

  {
  i = (I )0;
  _i___0 = (I )8;
  while (i < _i___0) {
    u ^= hcc[i];
    u += u >> 8;
    i ++;
  }
  return ((uint32_t )((unsigned long long )((uint32_t )u) ^ (u >> 32)));
}
}
static K intRange(K x___0 ) 
{ 
  I j ;
  I h0 ;
  I sa ;
  uI m ;
  K h ;
  K tmp ;
  I tmp___0 ;
  K z ;
  K tmp___1 ;
  I tmp___2 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  uI v ;
  I tmp___3 ;
  uI vsa ;
  uI u ;
  uint32_t tmp___4 ;
  uI tmp___5 ;
  uI p ;
  I tmp___6 ;
  I tmp___7 ;
  K y ;
  K tmp___8 ;

  {
  hcinit();
  j = (I )0;
  h0 = (I )0;
  sa = (I )0;
  m = (uI )0;
  tmp = newH(x___0->n);
  h = tmp;
  tmp___0 = OOM_CD((I )0, h, (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  tmp___1 = newK(x___0->t, x___0->n);
  z = tmp___1;
  tmp___2 = OOM_CD((I )0, h, z, (V )-1);
  if (! tmp___2) {
    return ((K )0);
  }
  i = (I )0;
  _i___0 = x___0->n;
  while (i < _i___0) {
    m |= *((uI *)(x___0->k) + i);
    i ++;
  }
  if (m) {
    while (! (m & 1ULL)) {
      m >>= 1;
      sa ++;
    }
  }
  i___0 = (I )0;
  _i___1 = x___0->n;
  while (i___0 < _i___1) {
    v = *((uI *)(x___0->k) + i___0);
    if (! v) {
      if (! h0) {
        h0 = (I )1;
        tmp___3 = j;
        j ++;
        *((I *)(z->k) + tmp___3) = (I )0;
      }
    } else {
      vsa = v >> sa;
      if (m < (uI )h->n) {
        tmp___5 = vsa;
      } else {
        tmp___4 = hc(vsa);
        tmp___5 = (uI )tmp___4;
      }
      u = tmp___5;
      tmp___7 = hg(h, u, (I )vsa, & p);
      if (! tmp___7) {
        *((I *)(h->k) + p) = (I )vsa;
        tmp___6 = j;
        j ++;
        *((I *)(z->k) + tmp___6) = (I )v;
      }
    }
    i___0 ++;
  }
  if (x___0->n == j) {
    goto cleanup;
  }
  tmp___8 = newK(x___0->t, j);
  y = tmp___8;
  if (! y) {
    goto cleanup;
  }
  memcpy((void * __restrict  )((I *)(y->k)), (void const   * __restrict  )((I *)(z->k)),
         (size_t )((unsigned long long )j * (unsigned long long )sizeof(I )));
  cd(z);
  z = y;
  cleanup: 
  cd(h);
  return (z);
}
}
static I KEQ(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  I A ;
  I tmp ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I tmp___0 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  I tmp___1 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (at___0 < 0LL) {
    tmp = - at___0;
  } else {
    tmp = at___0;
  }
  A = tmp;
  if (at___0 != bt) {
    return ((I )0);
  }
  if (an != bn) {
    return ((I )0);
  }
  if (7LL == A) {
    return ((I )0);
  } else
  if (6LL == A) {
    return ((I )1);
  } else
  if (5LL == A) {
    return ((I )0);
  } else
  if (4LL == A) {
    i = (I )0;
    _i___0 = an;
    while (i < _i___0) {
      if ((unsigned long )*((S *)(a->k) + i) != (unsigned long )*((S *)(b___1->k) + i)) {
        return ((I )0);
      }
      i ++;
    }
  } else
  if (3LL == A) {
    i___0 = (I )0;
    _i___1 = an;
    while (i___0 < _i___1) {
      if ((int )*((C *)(a->k) + i___0) != (int )*((C *)(b___1->k) + i___0)) {
        return ((I )0);
      }
      i___0 ++;
    }
  } else
  if (2LL == A) {
    i___1 = (I )0;
    _i___2 = an;
    while (i___1 < _i___2) {
      tmp___0 = FC(*((F *)(a->k) + i___1), *((F *)(b___1->k) + i___1));
      if (tmp___0) {
        return ((I )0);
      }
      i___1 ++;
    }
  } else
  if (1LL == A) {
    i___2 = (I )0;
    _i___3 = an;
    while (i___2 < _i___3) {
      if (*((I *)(a->k) + i___2) != *((I *)(b___1->k) + i___2)) {
        return ((I )0);
      }
      i___2 ++;
    }
  } else
  if (0LL == A) {
    i___3 = (I )0;
    _i___4 = an;
    while (i___3 < _i___4) {
      tmp___1 = KEQ(a->k[i___3], b___1->k[i___3]);
      if (! tmp___1) {
        return ((I )0);
      }
      i___3 ++;
    }
  }
  return ((I )1);
}
}
static K shg(K sh , uI hk , K k , uI *p ) 
{ 
  I n ;
  K *d___0 ;
  uI u ;
  I tmp ;

  {
  n = sh->n;
  d___0 = sh->k;
  u = hk & (unsigned long long )(n - 1LL);
  while (*(d___0 + u)) {
    tmp = KEQ(k, *(d___0 + u));
    if (tmp) {
      *p = u;
      return (k);
    }
    u ++;
    if (u == (uI )n) {
      u = (uI )0;
    }
  }
  *p = u;
  return ((K )0);
}
}
uint32_t fnv1a(UC *x___0 , I n ) 
{ 
  uint32_t h ;
  I i ;
  I _i___0 ;

  {
  h = (uint32_t )2166136261UL;
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    h ^= (unsigned int )*(x___0 + i);
    h = (uint32_t )((unsigned long )h * 16777619UL);
    i ++;
  }
  return (h);
}
}
static UI hcode(K x___0 ) 
{ 
  I t ;
  I tmp ;
  uI u ;
  I i ;
  I _i___0 ;
  S v ;
  size_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  I i___0 ;
  I _i___1 ;
  uI v___0 ;
  uint32_t tmp___3 ;
  I i___1 ;
  I _i___2 ;
  K v___1 ;
  UI tmp___4 ;

  {
  if (x___0->t < 0LL) {
    tmp = - x___0->t;
  } else {
    tmp = x___0->t;
  }
  t = tmp;
  u = (uI )0;
  switch (t) {
  case 7LL: 
  return ((UI )t);
  case 6LL: 
  return ((UI )(& NIL));
  case 5LL: 
  return ((UI )t);
  case 4LL: 
  i = (I )0;
  _i___0 = x___0->n;
  while (i < _i___0) {
    v = *((S *)(x___0->k) + i);
    if (! *((I *)v + -1)) {
      tmp___0 = strlen((char const   *)v);
      tmp___1 = fnv1a((UC *)v, (I )tmp___0);
      *((I *)v + -1) = (I )tmp___1;
    }
    u += (uI )*((I *)v + -1);
    i ++;
  }
  return ((uI )x___0->t + u);
  case 3LL: 
  tmp___2 = fnv1a((UC *)((C *)(x___0->k)), x___0->n);
  return ((UI )(x___0->t + (I )tmp___2));
  case 2LL: ;
  case 1LL: 
  i___0 = (I )0;
  _i___1 = x___0->n;
  while (i___0 < _i___1) {
    v___0 = (uI )*((I *)(x___0->k) + i___0);
    tmp___3 = hc(v___0);
    u += (uI )tmp___3;
    i___0 ++;
  }
  return ((uI )x___0->t + u);
  case 0LL: 
  i___1 = (I )0;
  _i___2 = x___0->n;
  while (i___1 < _i___2) {
    v___1 = x___0->k[i___1];
    tmp___4 = hcode(v___1);
    u += tmp___4;
    i___1 ++;
  }
  return (u);
  }
  return ((UI )0);
}
}
static K listRange(K x___0 ) 
{ 
  I j ;
  K sh ;
  K tmp ;
  I tmp___0 ;
  K z ;
  K tmp___1 ;
  I tmp___2 ;
  I i ;
  I _i___0 ;
  uI p ;
  K kv ;
  uI u ;
  UI tmp___3 ;
  I tmp___4 ;
  K tmp___5 ;
  K y ;
  K tmp___6 ;
  I i___0 ;
  I _i___1 ;

  {
  hcinit();
  j = (I )0;
  setS(1, (I )0);
  tmp = newH(x___0->n);
  sh = tmp;
  tmp___0 = OOM_CD((I )0, sh, (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  tmp___1 = newK(x___0->t, x___0->n);
  z = tmp___1;
  tmp___2 = OOM_CD((I )0, sh, z, (V )-1);
  if (! tmp___2) {
    return ((K )0);
  }
  i = (I )0;
  _i___0 = x___0->n;
  while (i < _i___0) {
    kv = x___0->k[i];
    tmp___3 = hcode(kv);
    u = tmp___3;
    tmp___5 = shg(sh, u, kv, & p);
    if (! tmp___5) {
      sh->k[p] = kv;
      tmp___4 = j;
      j ++;
      z->k[tmp___4] = ci(kv);
    }
    i ++;
  }
  if (x___0->n == j) {
    goto cleanup;
  }
  tmp___6 = newK(x___0->t, j);
  y = tmp___6;
  if (! y) {
    goto cleanup;
  }
  i___0 = (I )0;
  _i___1 = j;
  while (i___0 < _i___1) {
    y->k[i___0] = ci(z->k[i___0]);
    i___0 ++;
  }
  cd(z);
  z = y;
  cleanup: 
  cd(sh);
  return (z);
}
}
K range(K a ) 
{ 
  I t ;
  I n ;
  K z ;
  K g ;
  K k ;
  I u ;
  I *h ;
  I *m ;
  K tmp ;
  K tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I tmp___4 ;
  I x___0 ;
  I i___1 ;
  I _i___2 ;
  I tmp___5 ;

  {
  t = a->t;
  n = a->n;
  z = (K )0;
  g = (K )0;
  k = (K )0;
  u = n;
  h = (I *)0;
  m = (I *)0;
  if (t > 0LL) {
    tmp = kerr("rank");
    return (tmp);
  }
  switch (- t) {
  case 0LL: 
  tmp___0 = listRange(a);
  return (tmp___0);
  case 1LL: ;
  case 2LL: 
  tmp___1 = intRange(a);
  return (tmp___1);
  case 3LL: 
  tmp___2 = charRange(a);
  return (tmp___2);
  case 4LL: 
  tmp___3 = symRange(a);
  return (tmp___3);
  }
  g = grade_up(a);
  if (! g) {
    goto cleanup;
  }
  h = (I *)(g->k);
  k = newK((I )-1, n);
  if (! k) {
    goto cleanup;
  }
  m = (I *)(k->k);
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    *(m + *(h + i)) = i;
    i ++;
  }
  i___0 = (I )0;
  _i___1 = n - 1LL;
  while (i___0 < _i___1) {
    tmp___4 = matchI(a->k[*(h + ((n - i___0) - 1LL))], a->k[*(h + ((n - i___0) - 2LL))]);
    if (tmp___4) {
      *(h + ((n - i___0) - 1LL)) = (I )-1;
      u --;
    }
    i___0 ++;
  }
  z = newK(t, u);
  if (! z) {
    goto cleanup;
  }
  x___0 = (I )0;
  i___1 = (I )0;
  _i___2 = n;
  while (i___1 < _i___2) {
    if (*(h + *(m + i___1)) > -1LL) {
      tmp___5 = x___0;
      x___0 ++;
      z->k[tmp___5] = ci(a->k[*(h + *(m + i___1))]);
    }
    i___1 ++;
  }
  cleanup: 
  cd(k);
  cd(g);
  return (z);
}
}
static K charGroup(K x___0 ) 
{ 
  I h[256] ;
  I c[256] ;
  I j ;
  I i ;
  I _i___0 ;
  UC u ;
  I w___0 ;
  K y ;
  K tmp ;
  I tmp___0 ;
  I i___0 ;
  I _i___1 ;
  K z ;
  K tmp___1 ;
  I tmp___2 ;
  I i___1 ;
  I _i___2 ;
  UC u___0 ;
  I w___1 ;
  K z___0 ;
  I tmp___3 ;

  {
  trst();
  j = (I )0;
  memset((void *)(h), 0, 256UL * sizeof(I ));
  memset((void *)(c), 0, 256UL * sizeof(I ));
  i = (I )0;
  _i___0 = x___0->n;
  while (i < _i___0) {
    u = (UC )*((C *)(x___0->k) + i);
    if (! h[u]) {
      j ++;
      h[u] = j;
    }
    w___0 = h[u] - 1LL;
    (c[w___0]) ++;
    i ++;
  }
  tmp = newK((I )0, j);
  y = tmp;
  tmp___0 = OOM_CD((I )0, y, (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  i___0 = (I )0;
  _i___1 = j;
  while (i___0 < _i___1) {
    tmp___1 = newK((I )-1, c[i___0]);
    z = tmp___1;
    tmp___2 = OOM_CD((I )0, z, y, (V )-1);
    if (! tmp___2) {
      return ((K )0);
    }
    y->k[i___0] = z;
    c[i___0] = (I )0;
    i___0 ++;
  }
  i___1 = (I )0;
  _i___2 = x___0->n;
  while (i___1 < _i___2) {
    u___0 = (UC )*((C *)(x___0->k) + i___1);
    w___1 = h[u___0] - 1LL;
    z___0 = y->k[w___1];
    tmp___3 = c[w___1];
    (c[w___1]) ++;
    *((I *)(z___0->k) + tmp___3) = i___1;
    i___1 ++;
  }
  return (y);
}
}
static K symGroup(K x___0 ) 
{ 
  I j ;
  K uk ;
  K tmp ;
  I tmp___0 ;
  I *u ;
  I i ;
  I _i___0 ;
  S s ;
  K y ;
  K tmp___1 ;
  I tmp___2 ;
  I i___0 ;
  I _i___1 ;
  S s___0 ;
  K z ;
  K tmp___3 ;
  I tmp___4 ;
  I i___1 ;
  I _i___2 ;
  S s___1 ;
  I w___0 ;
  K z___0 ;
  I tmp___5 ;

  {
  j = (I )0;
  tmp = newK((I )-1, x___0->n);
  uk = tmp;
  tmp___0 = OOM_CD((I )0, uk, (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  u = (I *)(uk->k);
  setS(1, (I )0);
  setS(2, (I )0);
  i = (I )0;
  _i___0 = x___0->n;
  while (i < _i___0) {
    s = *((S *)(x___0->k) + i);
    if (! *((I *)s + -2)) {
      *(u + j) = (L )s;
      j ++;
      *((I *)s + -2) = j;
    }
    (*((I *)s + -1)) ++;
    i ++;
  }
  tmp___1 = newK((I )0, j);
  y = tmp___1;
  tmp___2 = OOM_CD((I )0, y, uk, (V )-1);
  if (! tmp___2) {
    return ((K )0);
  }
  i___0 = (I )0;
  _i___1 = j;
  while (i___0 < _i___1) {
    s___0 = (S )*(u + i___0);
    tmp___3 = newK((I )-1, *((I *)s___0 + -1));
    z = tmp___3;
    tmp___4 = OOM_CD((I )0, z, y, uk, (V )-1);
    if (! tmp___4) {
      return ((K )0);
    }
    y->k[i___0] = z;
    *(u + i___0) = (I )0;
    i___0 ++;
  }
  i___1 = (I )0;
  _i___2 = x___0->n;
  while (i___1 < _i___2) {
    s___1 = *((S *)(x___0->k) + i___1);
    w___0 = *((I *)s___1 + -2) - 1LL;
    z___0 = y->k[w___0];
    tmp___5 = *(u + w___0);
    (*(u + w___0)) ++;
    *((I *)(z___0->k) + tmp___5) = i___1;
    i___1 ++;
  }
  cd(uk);
  return (y);
}
}
static K groupI(K x___0 , K y , I n ) 
{ 
  K z ;
  K tmp ;
  I tmp___0 ;
  I *c ;
  I i ;
  I _i___0 ;
  K v ;
  K tmp___1 ;
  I tmp___2 ;
  I i___0 ;
  I _i___1 ;
  I w___0 ;
  K v___0 ;
  I tmp___3 ;
  I i___1 ;
  I _i___2 ;
  K v___1 ;
  K tmp___4 ;
  I tmp___5 ;
  I i___2 ;
  I _i___3 ;
  I w___1 ;
  K v___2 ;
  I tmp___6 ;

  {
  tmp = newK((I )0, n);
  z = tmp;
  tmp___0 = OOM_CD((I )0, z, (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  c = (I *)(y->k);
  if (n < 65537LL) {
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      tmp___1 = newK((I )-1, *(c + i));
      v = tmp___1;
      tmp___2 = OOM_CD((I )0, v, z, (V )-1);
      if (! tmp___2) {
        return ((K )0);
      }
      z->k[i] = v;
      *(c + i) = (I )0;
      i ++;
    }
    i___0 = (I )0;
    _i___1 = x___0->n;
    while (i___0 < _i___1) {
      w___0 = *((I *)(x___0->k) + i___0);
      v___0 = z->k[w___0];
      tmp___3 = *(c + w___0);
      (*(c + w___0)) ++;
      *((I *)(v___0->k) + tmp___3) = i___0;
      i___0 ++;
    }
  } else {
    i___1 = (I )0;
    _i___2 = n;
    while (i___1 < _i___2) {
      tmp___4 = newK((I )-1, *(c + i___1));
      v___1 = tmp___4;
      tmp___5 = OOM_CD((I )0, v___1, z, (V )-1);
      if (! tmp___5) {
        return ((K )0);
      }
      z->k[i___1] = v___1;
      v___1->n = (I )0;
      i___1 ++;
    }
    i___2 = (I )0;
    _i___3 = x___0->n;
    while (i___2 < _i___3) {
      w___1 = *((I *)(x___0->k) + i___2);
      v___2 = z->k[w___1];
      tmp___6 = v___2->n;
      (v___2->n) ++;
      *((I *)(v___2->k) + tmp___6) = i___2;
      i___2 ++;
    }
  }
  cd(y);
  cd(x___0);
  return (z);
}
}
static K intGroup(K x___0 ) 
{ 
  I j ;
  I h0 ;
  I sa ;
  uI m ;
  K h ;
  K tmp ;
  I tmp___0 ;
  K ok ;
  K tmp___1 ;
  I tmp___2 ;
  I *o ;
  K xok ;
  K tmp___3 ;
  I tmp___4 ;
  I *xo ;
  K ck ;
  K tmp___5 ;
  I tmp___6 ;
  I *c ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  uI v ;
  uI u ;
  uint32_t tmp___7 ;
  uI tmp___8 ;
  uI p ;
  I tmp___9 ;
  I tmp___10 ;
  I w___0 ;
  K z ;
  K tmp___11 ;

  {
  hcinit();
  j = (I )0;
  h0 = (I )0;
  sa = (I )0;
  m = (uI )0;
  tmp = newH(x___0->n);
  h = tmp;
  tmp___0 = OOM_CD((I )0, h, (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  tmp___1 = newK((I )-1, h->n);
  ok = tmp___1;
  tmp___2 = OOM_CD((I )0, ok, h, (V )-1);
  if (! tmp___2) {
    return ((K )0);
  }
  o = (I *)(ok->k);
  tmp___3 = newK((I )-1, x___0->n);
  xok = tmp___3;
  tmp___4 = OOM_CD((I )0, xok, ok, h, (V )-1);
  if (! tmp___4) {
    return ((K )0);
  }
  xo = (I *)(xok->k);
  tmp___5 = newK((I )-1, x___0->n);
  ck = tmp___5;
  tmp___6 = OOM_CD((I )0, ck, xok, ok, h, (V )-1);
  if (! tmp___6) {
    return ((K )0);
  }
  c = (I *)(ck->k);
  i = (I )0;
  _i___0 = x___0->n;
  while (i < _i___0) {
    m |= *((uI *)(x___0->k) + i);
    i ++;
  }
  if (m) {
    while (! (m & 1ULL)) {
      m >>= 1;
      sa ++;
    }
  }
  i___0 = (I )0;
  _i___1 = x___0->n;
  while (i___0 < _i___1) {
    v = *((uI *)(x___0->k) + i___0);
    if (! v) {
      if (! h0) {
        j ++;
        h0 = j;
      }
      *(xo + i___0) = h0 - 1LL;
      (*(c + (h0 - 1LL))) ++;
    } else {
      v >>= sa;
      if (m < (uI )h->n) {
        tmp___8 = v;
      } else {
        tmp___7 = hc(v);
        tmp___8 = (uI )tmp___7;
      }
      u = tmp___8;
      tmp___10 = hg(h, u, (I )v, & p);
      if (! tmp___10) {
        *((I *)(h->k) + p) = (I )v;
        tmp___9 = j;
        j ++;
        *(o + p) = tmp___9;
      }
      w___0 = *(o + p);
      *(xo + i___0) = w___0;
      (*(c + w___0)) ++;
    }
    i___0 ++;
  }
  cd(ok);
  cd(h);
  tmp___11 = groupI(xok, ck, j);
  z = tmp___11;
  return (z);
}
}
static K listGroup(K x___0 ) 
{ 
  I j ;
  K h ;
  K tmp ;
  I tmp___0 ;
  K ok ;
  K tmp___1 ;
  I tmp___2 ;
  I *o ;
  K xok ;
  K tmp___3 ;
  I tmp___4 ;
  I *xo ;
  K ck ;
  K tmp___5 ;
  I tmp___6 ;
  I *c ;
  I i ;
  I _i___0 ;
  K v ;
  uI u ;
  UI tmp___7 ;
  uI p ;
  I tmp___8 ;
  K tmp___9 ;
  I w___0 ;
  K z ;
  K tmp___10 ;

  {
  hcinit();
  j = (I )0;
  tmp = newH(x___0->n);
  h = tmp;
  tmp___0 = OOM_CD((I )0, h, (V )-1);
  if (! tmp___0) {
    return ((K )0);
  }
  tmp___1 = newK((I )-1, h->n);
  ok = tmp___1;
  tmp___2 = OOM_CD((I )0, ok, h, (V )-1);
  if (! tmp___2) {
    return ((K )0);
  }
  o = (I *)(ok->k);
  tmp___3 = newK((I )-1, x___0->n);
  xok = tmp___3;
  tmp___4 = OOM_CD((I )0, xok, ok, h, (V )-1);
  if (! tmp___4) {
    return ((K )0);
  }
  xo = (I *)(xok->k);
  tmp___5 = newK((I )-1, x___0->n);
  ck = tmp___5;
  tmp___6 = OOM_CD((I )0, ck, xok, ok, h, (V )-1);
  if (! tmp___6) {
    return ((K )0);
  }
  c = (I *)(ck->k);
  i = (I )0;
  _i___0 = x___0->n;
  while (i < _i___0) {
    v = x___0->k[i];
    tmp___7 = hcode(v);
    u = tmp___7;
    tmp___9 = shg(h, u, v, & p);
    if (! tmp___9) {
      h->k[p] = v;
      tmp___8 = j;
      j ++;
      *(o + p) = tmp___8;
    }
    w___0 = *(o + p);
    *(xo + i) = w___0;
    (*(c + w___0)) ++;
    i ++;
  }
  cd(ok);
  cd(h);
  tmp___10 = groupI(xok, ck, j);
  z = tmp___10;
  return (z);
}
}
K group(K x___0 ) 
{ 
  I t ;
  I n ;
  K tmp ;
  I u ;
  I *g ;
  I *h ;
  K z ;
  K b___1 ;
  K c ;
  K tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I tmp___6 ;
  I tmp___7 ;
  I k ;
  I p ;
  I v ;
  K s ;
  K tmp___8 ;
  I tmp___9 ;
  I i___1 ;
  I _i___2 ;

  {
  t = x___0->t;
  n = x___0->n;
  if (t > 0LL) {
    tmp = kerr("rank");
    return (tmp);
  }
  u = n;
  z = (K )0;
  b___1 = (K )0;
  c = (K )0;
  switch (- t) {
  case 0LL: 
  tmp___0 = listGroup(x___0);
  return (tmp___0);
  case 1LL: ;
  case 2LL: 
  tmp___1 = intGroup(x___0);
  return (tmp___1);
  case 3LL: 
  tmp___2 = charGroup(x___0);
  return (tmp___2);
  case 4LL: 
  tmp___3 = symGroup(x___0);
  return (tmp___3);
  }
  b___1 = grade_up(x___0);
  tmp___4 = OOM_CD((I )0, b___1, (V )-1);
  if (! tmp___4) {
    return ((K )0);
  }
  g = (I *)(b___1->k);
  c = newK((I )-1, n);
  tmp___5 = OOM_CD((I )0, b___1, c, (V )-1);
  if (! tmp___5) {
    return ((K )0);
  }
  h = (I *)(c->k);
  i = (I )0;
  _i___0 = n;
  while (i < _i___0) {
    *(h + *(g + i)) = i;
    i ++;
  }
  if (0LL == t) {
    i___0 = (I )0;
    _i___1 = n - 1LL;
    while (i___0 < _i___1) {
      tmp___6 = matchI(x___0->k[*(g + ((n - i___0) - 1LL))], x___0->k[*(g + ((n - i___0) - 2LL))]);
      if (tmp___6) {
        u --;
        *(g + ((n - i___0) - 1LL)) *= -1LL;
      }
      i___0 ++;
    }
  }
  z = newK((I )0, u);
  tmp___7 = OOM_CD((I )0, b___1, c, z, (V )-1);
  if (! tmp___7) {
    return ((K )0);
  }
  k = (I )0;
  p = (I )0;
  while (1) {
    if (p < n) {
      if (! (k < u)) {
        break;
      }
    } else {
      break;
    }
    v = (I )1;
    while (1) {
      if (p + v < n) {
        if (! (*(g + (*(h + p) + v)) < 0LL)) {
          break;
        }
      } else {
        break;
      }
      v ++;
    }
    tmp___8 = newK((I )-1, v);
    s = tmp___8;
    tmp___9 = OOM_CD((I )0, b___1, c, z, s, (V )-1);
    if (! tmp___9) {
      return ((K )0);
    }
    i___1 = (I )0;
    _i___2 = v;
    while (i___1 < _i___2) {
      if (*(g + (*(h + p) + i___1)) < 0LL) {
        *((I *)(s->k) + i___1) = - *(g + (*(h + p) + i___1));
      } else {
        *((I *)(s->k) + i___1) = *(g + (*(h + p) + i___1));
      }
      i___1 ++;
    }
    z->k[k] = s;
    while (1) {
      p ++;
      if (p < n) {
        if (! (*(g + *(h + p)) < 0LL)) {
          break;
        }
      } else {
        break;
      }
    }
    k ++;
  }
  cd(b___1);
  cd(c);
  return (z);
}
}
I VAT(I i ) 
{ 
  I tmp ;

  {
  if (1LL <= i) {
    if (i <= 4LL) {
      tmp = i;
    } else {
      tmp = (I )0;
    }
  } else {
    tmp = (I )0;
  }
  return (tmp);
}
}
K flip(K a ) 
{ 
  K x___0 ;
  I i ;
  I p ;
  I q ;
  K tmp ;
  I i___0 ;
  I _i___0 ;
  K tmp___0 ;
  I i___1 ;
  I _i___1 ;
  K tmp___1 ;
  K z ;
  K tmp___2 ;
  K *c ;
  K d___0 ;
  I u ;
  I t ;
  I tmp___8 ;
  I tmp___9 ;
  I tmp___10 ;
  I tmp___12 ;
  I tmp___13 ;
  I tmp___14 ;
  I tmp___15 ;
  I tmp___17 ;
  I tmp___18 ;
  I tmp___19 ;
  I j ;
  I _j ;
  I tmp___42 ;
  I tmp___43 ;
  I tmp___44 ;
  I tmp___46 ;
  I tmp___47 ;
  I tmp___48 ;
  I tmp___49 ;
  I tmp___51 ;
  I tmp___52 ;
  I tmp___53 ;
  K y ;
  struct k0 *tmp___54 ;
  I j___0 ;
  I _j___0 ;
  I j___1 ;
  I _j___1 ;
  I j___2 ;
  I _j___2 ;
  I j___3 ;
  I _j___3 ;
  I j___4 ;
  I _j___4 ;

  {
  p = a->n;
  q = (I )-1;
  if (a->t) {
    tmp = ci(a);
    return (tmp);
  } else
  if (! p) {
    tmp = ci(a);
    return (tmp);
  }
  i___0 = (I )0;
  _i___0 = p;
  while (i___0 < _i___0) {
    x___0 = a->k[i___0];
    if (x___0->t < 1LL) {
      q = x___0->n;
    }
    i___0 ++;
  }
  if (-1LL == q) {
    tmp___0 = ci(a);
    return (tmp___0);
  }
  i___1 = (I )0;
  _i___1 = p;
  while (i___1 < _i___1) {
    x___0 = a->k[i___1];
    if (x___0->t < 1LL) {
      if (x___0->n != q) {
        tmp___1 = kerr("length");
        return (tmp___1);
      }
    }
    i___1 ++;
  }
  tmp___2 = newK((I )0, q);
  z = tmp___2;
  i = (I )0;
  while (i < q) {
    c = a->k;
    d___0 = *(c + 0);
    if (d___0->t) {
      tmp___19 = d___0->t;
    } else {
      u = (d___0->k[i])->t;
      tmp___18 = VAT(u);
      if (tmp___18) {
        tmp___17 = u;
      } else {
        tmp___17 = (I )0;
      }
      tmp___19 = tmp___17;
    }
    if (tmp___19 < 0LL) {
      if (d___0->t) {
        tmp___10 = d___0->t;
      } else {
        u = (d___0->k[i])->t;
        tmp___9 = VAT(u);
        if (tmp___9) {
          tmp___8 = u;
        } else {
          tmp___8 = (I )0;
        }
        tmp___10 = tmp___8;
      }
      tmp___15 = - tmp___10;
    } else {
      if (d___0->t) {
        tmp___14 = d___0->t;
      } else {
        u = (d___0->k[i])->t;
        tmp___13 = VAT(u);
        if (tmp___13) {
          tmp___12 = u;
        } else {
          tmp___12 = (I )0;
        }
        tmp___14 = tmp___12;
      }
      tmp___15 = tmp___14;
    }
    t = - tmp___15;
    j = (I )0;
    _j = p;
    while (j < _j) {
      d___0 = *(c + j);
      if (d___0->t) {
        tmp___53 = d___0->t;
      } else {
        u = (d___0->k[i])->t;
        tmp___52 = VAT(u);
        if (tmp___52) {
          tmp___51 = u;
        } else {
          tmp___51 = (I )0;
        }
        tmp___53 = tmp___51;
      }
      if (tmp___53 < 0LL) {
        if (d___0->t) {
          tmp___44 = d___0->t;
        } else {
          u = (d___0->k[i])->t;
          tmp___43 = VAT(u);
          if (tmp___43) {
            tmp___42 = u;
          } else {
            tmp___42 = (I )0;
          }
          tmp___44 = tmp___42;
        }
        tmp___49 = - tmp___44;
      } else {
        if (d___0->t) {
          tmp___48 = d___0->t;
        } else {
          u = (d___0->k[i])->t;
          tmp___47 = VAT(u);
          if (tmp___47) {
            tmp___46 = u;
          } else {
            tmp___46 = (I )0;
          }
          tmp___48 = tmp___46;
        }
        tmp___49 = tmp___48;
      }
      if (t == - tmp___49) {
        t = t;
      } else {
        t = (I )0;
      }
      j ++;
    }
    tmp___54 = newK(t, p);
    z->k[i] = tmp___54;
    y = tmp___54;
    if (-4LL == t) {
      j___0 = (I )0;
      _j___0 = p;
      while (j___0 < _j___0) {
        d___0 = *(c + j___0);
        if (d___0->t) {
          *((S *)(y->k) + j___0) = *((S *)(d___0->k) + i % d___0->n);
        } else {
          *((S *)(y->k) + j___0) = *((S *)((d___0->k[i])->k));
        }
        j___0 ++;
      }
    } else
    if (-3LL == t) {
      j___1 = (I )0;
      _j___1 = p;
      while (j___1 < _j___1) {
        d___0 = *(c + j___1);
        if (d___0->t) {
          *((C *)(y->k) + j___1) = *((C *)(d___0->k) + i % d___0->n);
        } else {
          *((C *)(y->k) + j___1) = *((C *)((d___0->k[i])->k));
        }
        j___1 ++;
      }
    } else
    if (-2LL == t) {
      j___2 = (I )0;
      _j___2 = p;
      while (j___2 < _j___2) {
        d___0 = *(c + j___2);
        if (d___0->t) {
          *((F *)(y->k) + j___2) = *((F *)(d___0->k) + i % d___0->n);
        } else {
          *((F *)(y->k) + j___2) = *((F *)((d___0->k[i])->k));
        }
        j___2 ++;
      }
    } else
    if (-1LL == t) {
      j___3 = (I )0;
      _j___3 = p;
      while (j___3 < _j___3) {
        d___0 = *(c + j___3);
        if (d___0->t) {
          *((I *)(y->k) + j___3) = *((I *)(d___0->k) + i % d___0->n);
        } else {
          *((I *)(y->k) + j___3) = *((I *)((d___0->k[i])->k));
        }
        j___3 ++;
      }
    } else
    if (0LL == t) {
      j___4 = (I )0;
      _j___4 = p;
      while (j___4 < _j___4) {
        d___0 = *(c + j___4);
        y->k[j___4] = itemAtIndex(d___0, i);
        j___4 ++;
      }
    }
    i ++;
  }
  return (z);
}
}
K first(K a ) 
{ 
  I at___0 ;
  I an ;
  S tmp ;
  K tmp___0 ;
  int tmp___1 ;
  K tmp___2 ;
  F tmp___3 ;
  K tmp___4 ;
  I tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  K tmp___8 ;
  K tmp___9 ;
  K tmp___10 ;

  {
  at___0 = a->t;
  an = a->n;
  if (-4LL == at___0) {
    if (an) {
      tmp = *((S *)(a->k));
    } else {
      tmp = LS;
    }
    tmp___0 = Ks(tmp);
    return (tmp___0);
  }
  if (-3LL == at___0) {
    if (an) {
      tmp___1 = (int )*((C *)(a->k));
    } else {
      tmp___1 = ' ';
    }
    tmp___2 = Kc((C )tmp___1);
    return (tmp___2);
  }
  if (-2LL == at___0) {
    if (an) {
      tmp___3 = *((F *)(a->k));
    } else {
      tmp___3 = 0.0;
    }
    tmp___4 = Kf(tmp___3);
    return (tmp___4);
  }
  if (-1LL == at___0) {
    if (an) {
      tmp___5 = *((I *)(a->k));
    } else {
      tmp___5 = (I )0;
    }
    tmp___6 = Ki(tmp___5);
    return (tmp___6);
  }
  if (0LL == at___0) {
    if (an) {
      tmp___7 = ci(a->k[0]);
      tmp___9 = tmp___7;
    } else {
      tmp___8 = _n();
      tmp___9 = tmp___8;
    }
    return (tmp___9);
  }
  tmp___10 = ci(a);
  return (tmp___10);
}
}
K last(K a ) 
{ 
  I at___0 ;
  I an ;
  S tmp ;
  K tmp___0 ;
  int tmp___1 ;
  K tmp___2 ;
  F tmp___3 ;
  K tmp___4 ;
  I tmp___5 ;
  K tmp___6 ;
  K tmp___7 ;
  K tmp___8 ;
  K tmp___9 ;
  K tmp___10 ;

  {
  at___0 = a->t;
  an = a->n;
  if (-4LL == at___0) {
    if (an) {
      tmp = *((S *)(a->k) + (an - 1LL));
    } else {
      tmp = LS;
    }
    tmp___0 = Ks(tmp);
    return (tmp___0);
  }
  if (-3LL == at___0) {
    if (an) {
      tmp___1 = (int )*((C *)(a->k) + (an - 1LL));
    } else {
      tmp___1 = ' ';
    }
    tmp___2 = Kc((C )tmp___1);
    return (tmp___2);
  }
  if (-2LL == at___0) {
    if (an) {
      tmp___3 = *((F *)(a->k) + (an - 1LL));
    } else {
      tmp___3 = 0.0;
    }
    tmp___4 = Kf(tmp___3);
    return (tmp___4);
  }
  if (-1LL == at___0) {
    if (an) {
      tmp___5 = *((I *)(a->k) + (an - 1LL));
    } else {
      tmp___5 = (I )0;
    }
    tmp___6 = Ki(tmp___5);
    return (tmp___6);
  }
  if (0LL == at___0) {
    if (an) {
      tmp___7 = ci(a->k[an - 1LL]);
      tmp___9 = tmp___7;
    } else {
      tmp___8 = _n();
      tmp___9 = tmp___8;
    }
    return (tmp___9);
  }
  tmp___10 = ci(a);
  return (tmp___10);
}
}
static K reshaper(K a , K b___1 , I d___0 , I f , I *p ) 
{ 
  I bt ;
  I bn ;
  I v ;
  I g ;
  int tmp ;
  I t ;
  I tmp___0 ;
  I tmp___1 ;
  I n ;
  I tmp___2 ;
  K z ;
  K tmp___3 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  I i___4 ;
  I _i___5 ;
  K tmp___4 ;
  K tmp___5 ;
  I i___5 ;
  I _i___6 ;
  I tmp___6 ;
  I tmp___7 ;
  I tmp___8 ;
  I tmp___9 ;
  I tmp___10 ;

  {
  bt = b___1->t;
  bn = b___1->n;
  v = *((I *)(a->k) + d___0);
  if (! v) {
    tmp = 1;
  } else
  if (a->n == d___0 + 1LL) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  g = (I )tmp;
  if (g) {
    if (bt < 5LL) {
      if (bt < 0LL) {
        tmp___0 = - bt;
      } else {
        tmp___0 = bt;
      }
      tmp___1 = - tmp___0;
    } else {
      tmp___1 = (I )0;
    }
  } else {
    tmp___1 = (I )0;
  }
  t = tmp___1;
  if (-1LL == v) {
    tmp___2 = f;
  } else {
    tmp___2 = v;
  }
  n = tmp___2;
  tmp___3 = newK(t, n);
  z = tmp___3;
  if (! z) {
    return ((K )0);
  }
  if (! g) {
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      z->k[i] = reshaper(a, b___1, d___0 + 1LL, f, p);
      i ++;
    }
  } else {
    if (bt < 0LL) {
      tmp___10 = - bt;
    } else {
      tmp___10 = bt;
    }
    if (4LL == tmp___10) {
      i___0 = (I )0;
      _i___1 = n;
      while (i___0 < _i___1) {
        if (bn) {
          (*p) ++;
          *((S *)(z->k) + i___0) = *((S *)(b___1->k) + *p % bn);
        } else {
          *((S *)(z->k) + i___0) = LS;
        }
        i___0 ++;
      }
    } else {
      if (bt < 0LL) {
        tmp___9 = - bt;
      } else {
        tmp___9 = bt;
      }
      if (3LL == tmp___9) {
        i___1 = (I )0;
        _i___2 = n;
        while (i___1 < _i___2) {
          if (bn) {
            (*p) ++;
            *((C *)(z->k) + i___1) = *((C *)(b___1->k) + *p % bn);
          } else {
            *((C *)(z->k) + i___1) = (C )' ';
          }
          i___1 ++;
        }
      } else {
        if (bt < 0LL) {
          tmp___8 = - bt;
        } else {
          tmp___8 = bt;
        }
        if (2LL == tmp___8) {
          i___2 = (I )0;
          _i___3 = n;
          while (i___2 < _i___3) {
            if (bn) {
              (*p) ++;
              *((F *)(z->k) + i___2) = *((F *)(b___1->k) + *p % bn);
            } else {
              *((F *)(z->k) + i___2) = 0.0;
            }
            i___2 ++;
          }
        } else {
          if (bt < 0LL) {
            tmp___7 = - bt;
          } else {
            tmp___7 = bt;
          }
          if (1LL == tmp___7) {
            i___3 = (I )0;
            _i___4 = n;
            while (i___3 < _i___4) {
              if (bn) {
                (*p) ++;
                *((I *)(z->k) + i___3) = *((I *)(b___1->k) + *p % bn);
              } else {
                *((I *)(z->k) + i___3) = (I )0;
              }
              i___3 ++;
            }
          } else {
            if (bt < 0LL) {
              tmp___6 = - bt;
            } else {
              tmp___6 = bt;
            }
            if (0LL == tmp___6) {
              i___4 = (I )0;
              _i___5 = n;
              while (i___4 < _i___5) {
                if (bn) {
                  (*p) ++;
                  tmp___4 = ci(b___1->k[*p % bn]);
                  z->k[i___4] = tmp___4;
                } else {
                  tmp___5 = _n();
                  z->k[i___4] = tmp___5;
                }
                i___4 ++;
              }
            } else
            if (5LL <= bt) {
              i___5 = (I )0;
              _i___6 = n;
              while (i___5 < _i___6) {
                z->k[i___5] = ci(b___1);
                i___5 ++;
              }
            }
          }
        }
      }
    }
  }
  return (z);
}
}
K reshape(K a , K b___1 ) 
{ 
  I an ;
  I bn ;
  K tmp ;
  I ns___0 ;
  I x___0 ;
  I y ;
  I i ;
  I _i___0 ;
  K tmp___0 ;
  K tmp___1 ;
  I p ;
  I i___0 ;
  I _i___1 ;
  K tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  K tmp___5 ;

  {
  an = a->n;
  bn = b___1->n;
  if (! an) {
    tmp = first(b___1);
    return (tmp);
  }
  ns___0 = (I )0;
  y = (I )-1;
  i = (I )0;
  _i___0 = an;
  while (i < _i___0) {
    x___0 = *((I *)(a->k) + i);
    if (50000000LL < x___0) {
      tmp___0 = kerr("limit");
      return (tmp___0);
    }
    if (0LL > x___0) {
      ns___0 -= x___0;
    }
    i ++;
  }
  if (ns___0 < -1LL) {
    tmp___1 = kerr("domain");
    return (tmp___1);
  }
  p = (I )1;
  i___0 = (I )0;
  _i___1 = an;
  while (i___0 < _i___1) {
    p *= *((I *)(a->k) + i___0);
    i___0 ++;
  }
  if (ns___0 < 0LL) {
    if (! p) {
      tmp___2 = kerr("length");
      return (tmp___2);
    } else
    if (! bn) {
      tmp___2 = kerr("length");
      return (tmp___2);
    } else
    if (bn % p) {
      tmp___2 = kerr("length");
      return (tmp___2);
    }
  }
  if (p) {
    if (bn / p < 0LL) {
      tmp___3 = - (bn / p);
    } else {
      tmp___3 = bn / p;
    }
    tmp___4 = tmp___3;
  } else {
    tmp___4 = (I )0;
  }
  tmp___5 = reshaper(a, b___1, (I )0, tmp___4, & y);
  return (tmp___5);
}
}
K take(K a , K b___1 ) 
{ 
  I bt ;
  I bn ;
  I n ;
  I tmp ;
  I m ;
  I tmp___0 ;
  I k ;
  I t ;
  I tmp___1 ;
  I tmp___2 ;
  K z ;
  K tmp___3 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  K tmp___4 ;
  K tmp___5 ;
  I i___4 ;
  I _i___5 ;
  I tmp___6 ;
  I tmp___7 ;
  I tmp___8 ;
  I tmp___9 ;
  K tmp___10 ;

  {
  bt = b___1->t;
  bn = b___1->n;
  if (*((I *)(a->k)) < 0LL) {
    tmp = - *((I *)(a->k));
  } else {
    tmp = *((I *)(a->k));
  }
  n = tmp;
  if (1LL > bn) {
    tmp___0 = (I )1;
  } else {
    tmp___0 = bn;
  }
  m = tmp___0;
  k = *((I *)(a->k)) % m;
  if (k < 0LL) {
    k = bn + k;
  } else {
    k = (I )0;
  }
  if (bt < 5LL) {
    if (bt < 0LL) {
      tmp___1 = - bt;
    } else {
      tmp___1 = bt;
    }
    tmp___2 = - tmp___1;
  } else {
    tmp___2 = (I )0;
  }
  t = tmp___2;
  tmp___3 = newK(t, n);
  z = tmp___3;
  if (! z) {
    return ((K )0);
  }
  if (bt < 0LL) {
    tmp___9 = - bt;
  } else {
    tmp___9 = bt;
  }
  if (4LL == tmp___9) {
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      if (bn) {
        *((S *)(z->k) + i) = *((S *)(b___1->k) + (i + k) % m);
      } else {
        *((S *)(z->k) + i) = LS;
      }
      i ++;
    }
  } else {
    if (bt < 0LL) {
      tmp___8 = - bt;
    } else {
      tmp___8 = bt;
    }
    if (3LL == tmp___8) {
      i___0 = (I )0;
      _i___1 = n;
      while (i___0 < _i___1) {
        if (bn) {
          *((C *)(z->k) + i___0) = *((C *)(b___1->k) + (i___0 + k) % m);
        } else {
          *((C *)(z->k) + i___0) = (C )' ';
        }
        i___0 ++;
      }
    } else {
      if (bt < 0LL) {
        tmp___7 = - bt;
      } else {
        tmp___7 = bt;
      }
      if (2LL == tmp___7) {
        i___1 = (I )0;
        _i___2 = n;
        while (i___1 < _i___2) {
          if (bn) {
            *((F *)(z->k) + i___1) = *((F *)(b___1->k) + (i___1 + k) % m);
          } else {
            *((F *)(z->k) + i___1) = 0.0;
          }
          i___1 ++;
        }
      } else {
        if (bt < 0LL) {
          tmp___6 = - bt;
        } else {
          tmp___6 = bt;
        }
        if (1LL == tmp___6) {
          i___2 = (I )0;
          _i___3 = n;
          while (i___2 < _i___3) {
            if (bn) {
              *((I *)(z->k) + i___2) = *((I *)(b___1->k) + (i___2 + k) % m);
            } else {
              *((I *)(z->k) + i___2) = (I )0;
            }
            i___2 ++;
          }
        } else
        if (0LL == bt) {
          i___3 = (I )0;
          _i___4 = n;
          while (i___3 < _i___4) {
            if (bn) {
              tmp___4 = ci(b___1->k[(i___3 + k) % m]);
              z->k[i___3] = tmp___4;
            } else {
              tmp___5 = _n();
              z->k[i___3] = tmp___5;
            }
            i___3 ++;
          }
        } else
        if (5LL <= bt) {
          i___4 = (I )0;
          _i___5 = n;
          while (i___4 < _i___5) {
            z->k[i___4] = ci(b___1);
            i___4 ++;
          }
        }
      }
    }
  }
  tmp___10 = demote(z);
  return (tmp___10);
}
}
K take_reshape(K a , K b___1 ) 
{ 
  K tmp ;
  I tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;

  {
  if (a->n) {
    if (a->t < 0LL) {
      tmp___0 = - a->t;
    } else {
      tmp___0 = a->t;
    }
    if (1LL != tmp___0) {
      tmp = kerr("int");
      return (tmp);
    }
  }
  if (0LL < a->t) {
    tmp___1 = take(a, b___1);
    tmp___3 = tmp___1;
  } else {
    tmp___2 = reshape(a, b___1);
    tmp___3 = tmp___2;
  }
  return (tmp___3);
}
}
static void shapeCheck(K a , K p , I d___0 ) 
{ 
  I at___0 ;
  I an ;
  I i ;
  I _i___0 ;

  {
  at___0 = a->t;
  an = a->n;
  if (at___0 > 0LL) {
    *((I *)(p->k) + d___0) = (I )-1;
  } else
  if (an != *((I *)(p->k) + d___0)) {
    *((I *)(p->k) + d___0) = (I )-1;
  } else
  if (at___0) {
    if (d___0 < p->n - 1LL) {
      *((I *)(p->k) + (d___0 + 1LL)) = (I )-1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (! at___0) {
    if (an) {
      if (*((I *)(p->k) + d___0) != -1LL) {
        if (d___0 < p->n - 1LL) {
          i = (I )0;
          _i___0 = an;
          while (i < _i___0) {
            shapeCheck(a->k[i], p, d___0 + 1LL);
            i ++;
          }
        }
      }
    }
  }
  return;
}
}
static I firstDepth(K x___0 ) 
{ 
  I tmp ;
  int tmp___0 ;
  I tmp___1 ;

  {
  if (! x___0->t) {
    if (x___0->n) {
      tmp = firstDepth(x___0->k[0]);
      tmp___1 = 1LL + tmp;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (x___0->t > 0LL) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    tmp___1 = (I )tmp___0;
  }
  return (tmp___1);
}
}
K shape(K a ) 
{ 
  K b___1 ;
  K p ;
  I tmp ;
  K tmp___0 ;
  I i ;
  I _i___0 ;
  I n ;
  I i___0 ;
  I _i___1 ;
  K z ;
  K tmp___1 ;
  I i___1 ;
  I _i___2 ;

  {
  b___1 = a;
  tmp = firstDepth(a);
  tmp___0 = newK((I )-1, tmp);
  p = tmp___0;
  i = (I )0;
  _i___0 = p->n;
  while (i < _i___0) {
    *((I *)(p->k) + i) = b___1->n;
    if (i < _i___0 - 1LL) {
      b___1 = b___1->k[0];
    }
    i ++;
  }
  shapeCheck(a, p, (I )0);
  n = (I )0;
  i___0 = (I )0;
  _i___1 = p->n;
  while (i___0 < _i___1) {
    if (*((I *)(p->k) + i___0) == -1LL) {
      break;
    }
    n ++;
    i___0 ++;
  }
  tmp___1 = newK((I )-1, n);
  z = tmp___1;
  i___1 = (I )0;
  _i___2 = n;
  while (i___1 < _i___2) {
    *((I *)(z->k) + i___1) = *((I *)(p->k) + i___1);
    i___1 ++;
  }
  cd(p);
  return (z);
}
}
K rotate(K a , K b___1 ) 
{ 
  I bt ;
  I bn ;
  I r ;
  I tmp ;
  K z ;
  K tmp___0 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;

  {
  bt = b___1->t;
  bn = b___1->n;
  if (1LL > bn) {
    tmp = (I )1;
  } else {
    tmp = bn;
  }
  r = *((I *)(a->k)) % tmp;
  if (r > 0LL) {
    r = r;
  } else {
    r = bn + r;
  }
  tmp___0 = newK(bt, bn);
  z = tmp___0;
  if (! z) {
    return ((K )0);
  }
  if (-4LL == bt) {
    i = (I )0;
    _i___0 = bn;
    while (i < _i___0) {
      *((S *)(z->k) + i) = *((S *)(b___1->k) + (i + r) % bn);
      i ++;
    }
  } else
  if (-3LL == bt) {
    i___0 = (I )0;
    _i___1 = bn;
    while (i___0 < _i___1) {
      *((C *)(z->k) + i___0) = *((C *)(b___1->k) + (i___0 + r) % bn);
      i___0 ++;
    }
  } else
  if (-2LL == bt) {
    i___1 = (I )0;
    _i___2 = bn;
    while (i___1 < _i___2) {
      *((F *)(z->k) + i___1) = *((F *)(b___1->k) + (i___1 + r) % bn);
      i___1 ++;
    }
  } else
  if (-1LL == bt) {
    i___2 = (I )0;
    _i___3 = bn;
    while (i___2 < _i___3) {
      *((I *)(z->k) + i___2) = *((I *)(b___1->k) + (i___2 + r) % bn);
      i___2 ++;
    }
  } else
  if (0LL == bt) {
    i___3 = (I )0;
    _i___4 = bn;
    while (i___3 < _i___4) {
      z->k[i___3] = ci(b___1->k[(i___3 + r) % bn]);
      i___3 ++;
    }
  }
  return (z);
}
}
K drop(K a , K b___1 ) 
{ 
  I at___0 ;
  I bt ;
  I bn ;
  K tmp ;
  K tmp___0 ;
  I v ;
  I zn ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  K z ;
  K tmp___5 ;
  I c ;
  I tmp___6 ;
  I tmp___7 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  I i___1 ;
  I _i___2 ;
  I i___2 ;
  I _i___3 ;
  I i___3 ;
  I _i___4 ;
  K tmp___8 ;

  {
  at___0 = a->t;
  bt = b___1->t;
  bn = b___1->n;
  if (1LL != at___0) {
    tmp = kerr("int");
    return (tmp);
  }
  if (bt > 0LL) {
    tmp___0 = ci(b___1);
    return (tmp___0);
  }
  v = *((I *)(a->k));
  if (v < 0LL) {
    tmp___4 = - v;
  } else {
    tmp___4 = v;
  }
  if (0LL > bn - tmp___4) {
    tmp___3 = (I )0;
  } else {
    if (v < 0LL) {
      tmp___2 = - v;
    } else {
      tmp___2 = v;
    }
    tmp___3 = bn - tmp___2;
  }
  zn = tmp___3;
  tmp___5 = newK(bt, zn);
  z = tmp___5;
  if (! z) {
    return ((K )0);
  }
  if (v < 1LL) {
    tmp___7 = (I )0;
  } else {
    if (v < bn) {
      tmp___6 = v;
    } else {
      tmp___6 = bn;
    }
    tmp___7 = tmp___6;
  }
  c = tmp___7;
  if (-4LL == bt) {
    i = (I )0;
    _i___0 = zn;
    while (i < _i___0) {
      *((S *)(z->k) + i) = *((S *)(b___1->k) + (i + c));
      i ++;
    }
  } else
  if (-3LL == bt) {
    i___0 = (I )0;
    _i___1 = zn;
    while (i___0 < _i___1) {
      *((C *)(z->k) + i___0) = *((C *)(b___1->k) + (i___0 + c));
      i___0 ++;
    }
  } else
  if (-2LL == bt) {
    i___1 = (I )0;
    _i___2 = zn;
    while (i___1 < _i___2) {
      *((F *)(z->k) + i___1) = *((F *)(b___1->k) + (i___1 + c));
      i___1 ++;
    }
  } else
  if (-1LL == bt) {
    i___2 = (I )0;
    _i___3 = zn;
    while (i___2 < _i___3) {
      *((I *)(z->k) + i___2) = *((I *)(b___1->k) + (i___2 + c));
      i___2 ++;
    }
  } else
  if (0LL == bt) {
    i___3 = (I )0;
    _i___4 = zn;
    while (i___3 < _i___4) {
      z->k[i___3] = ci(b___1->k[i___3 + c]);
      i___3 ++;
    }
  }
  tmp___8 = demote(z);
  return (tmp___8);
}
}
K cut(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  I bn ;
  K tmp ;
  I i ;
  I _i___0 ;
  I x___0 ;
  K tmp___0 ;
  K tmp___1 ;
  I tmp___2 ;
  K z ;
  K tmp___3 ;
  I zn ;
  I i___0 ;
  I _i___1 ;
  I x___1 ;
  I y ;
  I tmp___4 ;
  K w___0 ;
  K tmp___5 ;
  I j ;
  I _j ;
  I i___1 ;
  I _i___2 ;
  I x___2 ;
  I y___0 ;
  I tmp___6 ;
  K w___1 ;
  K tmp___7 ;
  I j___0 ;
  I _j___0 ;
  I i___2 ;
  I _i___3 ;
  I x___3 ;
  I y___1 ;
  I tmp___8 ;
  K w___2 ;
  K tmp___9 ;
  I j___1 ;
  I _j___1 ;
  I i___3 ;
  I _i___4 ;
  I x___4 ;
  I y___2 ;
  I tmp___10 ;
  K w___3 ;
  K tmp___11 ;
  I j___2 ;
  I _j___2 ;
  I i___4 ;
  I x___5 ;
  I y___3 ;
  I tmp___12 ;
  I sn ;
  I t ;
  I j___3 ;
  I _j___3 ;
  I tmp___13 ;
  K s ;
  K tmp___14 ;
  I j___4 ;
  I _j___4 ;
  I j___5 ;
  I _j___5 ;
  I j___6 ;
  I _j___6 ;
  I j___7 ;
  I _j___7 ;
  I j___8 ;
  I _j___8 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  bn = b___1->n;
  if (-1LL != at___0) {
    tmp = kerr("int");
    return (tmp);
  }
  i = (I )0;
  _i___0 = an;
  while (i < _i___0) {
    x___0 = *((I *)(a->k) + i);
    if (x___0 < 0LL) {
      tmp___0 = kerr("domain");
      return (tmp___0);
    } else {
      if (i > 0LL) {
        tmp___2 = i - 1LL;
      } else {
        tmp___2 = (I )0;
      }
      if (x___0 < *((I *)(a->k) + tmp___2)) {
        tmp___0 = kerr("domain");
        return (tmp___0);
      } else
      if (x___0 > bn) {
        tmp___1 = kerr("length");
        return (tmp___1);
      }
    }
    i ++;
  }
  tmp___3 = newK((I )0, an);
  z = tmp___3;
  if (! z) {
    return ((K )0);
  }
  zn = z->n;
  if (-4LL == bt) {
    i___0 = (I )0;
    _i___1 = zn;
    while (i___0 < _i___1) {
      x___1 = *((I *)(a->k) + i___0);
      if (i___0 == z->n - 1LL) {
        tmp___4 = bn;
      } else {
        tmp___4 = *((I *)(a->k) + (i___0 + 1LL));
      }
      y = tmp___4;
      tmp___5 = newK((I )-4, y - x___1);
      w___0 = tmp___5;
      j = (I )0;
      _j = w___0->n;
      while (j < _j) {
        *((S *)(w___0->k) + j) = *((S *)(b___1->k) + (x___1 + j));
        j ++;
      }
      z->k[i___0] = w___0;
      i___0 ++;
    }
  } else
  if (-3LL == bt) {
    i___1 = (I )0;
    _i___2 = zn;
    while (i___1 < _i___2) {
      x___2 = *((I *)(a->k) + i___1);
      if (i___1 == z->n - 1LL) {
        tmp___6 = bn;
      } else {
        tmp___6 = *((I *)(a->k) + (i___1 + 1LL));
      }
      y___0 = tmp___6;
      tmp___7 = newK((I )-3, y___0 - x___2);
      w___1 = tmp___7;
      j___0 = (I )0;
      _j___0 = w___1->n;
      while (j___0 < _j___0) {
        *((C *)(w___1->k) + j___0) = *((C *)(b___1->k) + (x___2 + j___0));
        j___0 ++;
      }
      z->k[i___1] = w___1;
      i___1 ++;
    }
  } else
  if (-2LL == bt) {
    i___2 = (I )0;
    _i___3 = zn;
    while (i___2 < _i___3) {
      x___3 = *((I *)(a->k) + i___2);
      if (i___2 == z->n - 1LL) {
        tmp___8 = bn;
      } else {
        tmp___8 = *((I *)(a->k) + (i___2 + 1LL));
      }
      y___1 = tmp___8;
      tmp___9 = newK((I )-2, y___1 - x___3);
      w___2 = tmp___9;
      j___1 = (I )0;
      _j___1 = w___2->n;
      while (j___1 < _j___1) {
        *((F *)(w___2->k) + j___1) = *((F *)(b___1->k) + (x___3 + j___1));
        j___1 ++;
      }
      z->k[i___2] = w___2;
      i___2 ++;
    }
  } else
  if (-1LL == bt) {
    i___3 = (I )0;
    _i___4 = zn;
    while (i___3 < _i___4) {
      x___4 = *((I *)(a->k) + i___3);
      if (i___3 == z->n - 1LL) {
        tmp___10 = bn;
      } else {
        tmp___10 = *((I *)(a->k) + (i___3 + 1LL));
      }
      y___2 = tmp___10;
      tmp___11 = newK((I )-1, y___2 - x___4);
      w___3 = tmp___11;
      j___2 = (I )0;
      _j___2 = w___3->n;
      while (j___2 < _j___2) {
        *((I *)(w___3->k) + j___2) = *((I *)(b___1->k) + (x___4 + j___2));
        j___2 ++;
      }
      z->k[i___3] = w___3;
      i___3 ++;
    }
  } else
  if (0LL == bt) {
    i___4 = (I )0;
    while (i___4 < zn) {
      x___5 = *((I *)(a->k) + i___4);
      if (i___4 == z->n - 1LL) {
        tmp___12 = bn;
      } else {
        tmp___12 = *((I *)(a->k) + (i___4 + 1LL));
      }
      y___3 = tmp___12;
      sn = y___3 - x___5;
      t = bt;
      if (sn) {
        if (x___5 < bn) {
          t = (b___1->k[x___5])->t;
        }
      }
      j___3 = (I )0;
      _j___3 = sn;
      while (j___3 < _j___3) {
        if (t != (b___1->k[x___5 + j___3])->t) {
          t = (I )0;
          break;
        }
        j___3 ++;
      }
      if (0LL > t) {
        tmp___13 = (I )0;
      } else {
        tmp___13 = t;
      }
      t = - tmp___13;
      tmp___14 = newK(t, sn);
      s = tmp___14;
      if (-4LL == t) {
        j___4 = (I )0;
        _j___4 = sn;
        while (j___4 < _j___4) {
          *((S *)(s->k) + j___4) = *((S *)((b___1->k[x___5 + j___4])->k));
          j___4 ++;
        }
      } else
      if (-3LL == t) {
        j___5 = (I )0;
        _j___5 = sn;
        while (j___5 < _j___5) {
          *((C *)(s->k) + j___5) = *((C *)((b___1->k[x___5 + j___5])->k));
          j___5 ++;
        }
      } else
      if (-2LL == t) {
        j___6 = (I )0;
        _j___6 = sn;
        while (j___6 < _j___6) {
          *((F *)(s->k) + j___6) = *((F *)((b___1->k[x___5 + j___6])->k));
          j___6 ++;
        }
      } else
      if (-1LL == t) {
        j___7 = (I )0;
        _j___7 = sn;
        while (j___7 < _j___7) {
          *((I *)(s->k) + j___7) = *((I *)((b___1->k[x___5 + j___7])->k));
          j___7 ++;
        }
      } else
      if (0LL == t) {
        j___8 = (I )0;
        _j___8 = sn;
        while (j___8 < _j___8) {
          s->k[j___8] = ci(b___1->k[x___5 + j___8]);
          j___8 ++;
        }
      }
      z->k[i___4] = s;
      i___4 ++;
    }
  }
  return (z);
}
}
K drop_cut(K a , K b___1 ) 
{ 
  K tmp ;
  I tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;

  {
  if (a->t < 0LL) {
    tmp___0 = - a->t;
  } else {
    tmp___0 = a->t;
  }
  if (1LL != tmp___0) {
    tmp = kerr("int");
    return (tmp);
  } else
  if (-1LL == a->t) {
    if (0LL < b___1->t) {
      tmp = kerr("int");
      return (tmp);
    }
  }
  if (1LL == a->t) {
    tmp___1 = drop(a, b___1);
    tmp___3 = tmp___1;
  } else {
    tmp___2 = cut(a, b___1);
    tmp___3 = tmp___2;
  }
  return (tmp___3);
}
}
K where(K x___0 ) 
{ 
  K tmp ;
  K tmp___0 ;
  I tmp___1 ;
  I i ;
  I _i___0 ;
  K tmp___2 ;
  I zn ;
  I y ;
  I j ;
  I t ;
  I i___0 ;
  I _i___1 ;
  K z ;
  K tmp___3 ;
  I i___1 ;
  I _i___2 ;
  I tmp___4 ;

  {
  if (! x___0->n) {
    tmp = newK((I )-1, (I )0);
    return (tmp);
  }
  if (x___0->t < 0LL) {
    tmp___1 = - x___0->t;
  } else {
    tmp___1 = x___0->t;
  }
  if (1LL != tmp___1) {
    tmp___0 = kerr("int");
    return (tmp___0);
  }
  i = (I )0;
  _i___0 = x___0->n;
  while (i < _i___0) {
    if (*((I *)(x___0->k) + i) == 9223372036854775807LL) {
      tmp___2 = kerr("int");
      return (tmp___2);
    }
    i ++;
  }
  zn = (I )0;
  t = (I )0;
  i___0 = (I )0;
  _i___1 = x___0->n;
  while (i___0 < _i___1) {
    y = *((I *)(x___0->k) + i___0);
    if (y < 0LL) {
      goto __Cont;
    }
    zn += y;
    __Cont: /* CIL Label */ 
    i___0 ++;
  }
  tmp___3 = newK((I )-1, zn);
  z = tmp___3;
  if (! z) {
    return ((K )0);
  }
  i___1 = (I )0;
  _i___2 = x___0->n;
  while (i___1 < _i___2) {
    j = (I )0;
    while (j < *((I *)(x___0->k) + i___1)) {
      tmp___4 = t;
      t ++;
      *((I *)(z->k) + tmp___4) = i___1;
      j ++;
    }
    i___1 ++;
  }
  return (z);
}
}
K reverse(K a ) 
{ 
  I at___0 ;
  I an ;
  K tmp ;
  K z ;
  I n ;
  I i ;
  I _i___0 ;
  S _t___0 ;
  I i___0 ;
  I _i___1 ;
  C _t___1 ;
  I i___1 ;
  I _i___2 ;
  F _t___2 ;
  I i___2 ;
  I _i___3 ;
  I _t___3 ;
  I i___3 ;
  I _i___4 ;
  K _t___4 ;
  I i___4 ;
  I _i___5 ;
  I i___5 ;
  I _i___6 ;
  I i___6 ;
  I _i___7 ;
  I i___7 ;
  I _i___8 ;
  I i___8 ;
  I _i___9 ;
  I tmp___0 ;

  {
  at___0 = a->t;
  an = a->n;
  if (0LL < at___0) {
    tmp = ci(a);
    return (tmp);
  }
  tmp___0 = rc(a);
  if (1LL == tmp___0) {
    n = an >> 1;
    z = ci(a);
    if (! n) {
      return (z);
    }
    if (-4LL == at___0) {
      i = (I )0;
      _i___0 = n;
      while (i < _i___0) {
        _t___0 = *((S *)(z->k) + i);
        *((S *)(z->k) + i) = *((S *)(z->k) + ((an - i) - 1LL));
        *((S *)(z->k) + ((an - i) - 1LL)) = _t___0;
        i ++;
      }
    } else
    if (-3LL == at___0) {
      i___0 = (I )0;
      _i___1 = n;
      while (i___0 < _i___1) {
        _t___1 = *((C *)(z->k) + i___0);
        *((C *)(z->k) + i___0) = *((C *)(z->k) + ((an - i___0) - 1LL));
        *((C *)(z->k) + ((an - i___0) - 1LL)) = _t___1;
        i___0 ++;
      }
    } else
    if (-2LL == at___0) {
      i___1 = (I )0;
      _i___2 = n;
      while (i___1 < _i___2) {
        _t___2 = *((F *)(z->k) + i___1);
        *((F *)(z->k) + i___1) = *((F *)(z->k) + ((an - i___1) - 1LL));
        *((F *)(z->k) + ((an - i___1) - 1LL)) = _t___2;
        i___1 ++;
      }
    } else
    if (-1LL == at___0) {
      i___2 = (I )0;
      _i___3 = n;
      while (i___2 < _i___3) {
        _t___3 = *((I *)(z->k) + i___2);
        *((I *)(z->k) + i___2) = *((I *)(z->k) + ((an - i___2) - 1LL));
        *((I *)(z->k) + ((an - i___2) - 1LL)) = _t___3;
        i___2 ++;
      }
    } else
    if (0LL == at___0) {
      i___3 = (I )0;
      _i___4 = n;
      while (i___3 < _i___4) {
        _t___4 = z->k[i___3];
        z->k[i___3] = z->k[(an - i___3) - 1LL];
        z->k[(an - i___3) - 1LL] = _t___4;
        i___3 ++;
      }
    }
  } else {
    z = newK(at___0, an);
    if (! z) {
      return ((K )0);
    }
    if (-4LL == at___0) {
      i___4 = (I )0;
      _i___5 = an;
      while (i___4 < _i___5) {
        *((S *)(z->k) + i___4) = *((S *)(a->k) + ((an - i___4) - 1LL));
        i___4 ++;
      }
    } else
    if (-3LL == at___0) {
      i___5 = (I )0;
      _i___6 = an;
      while (i___5 < _i___6) {
        *((C *)(z->k) + i___5) = *((C *)(a->k) + ((an - i___5) - 1LL));
        i___5 ++;
      }
    } else
    if (-2LL == at___0) {
      i___6 = (I )0;
      _i___7 = an;
      while (i___6 < _i___7) {
        *((F *)(z->k) + i___6) = *((F *)(a->k) + ((an - i___6) - 1LL));
        i___6 ++;
      }
    } else
    if (-1LL == at___0) {
      i___7 = (I )0;
      _i___8 = an;
      while (i___7 < _i___8) {
        *((I *)(z->k) + i___7) = *((I *)(a->k) + ((an - i___7) - 1LL));
        i___7 ++;
      }
    } else
    if (0LL == at___0) {
      i___8 = (I )0;
      _i___9 = an;
      while (i___8 < _i___9) {
        z->k[i___8] = ci(a->k[(an - i___8) - 1LL]);
        i___8 ++;
      }
    }
  }
  return (z);
}
}
I countI(K x___0 ) 
{ 
  I tmp ;

  {
  if (x___0->t > 0LL) {
    tmp = (I )1;
  } else {
    tmp = x___0->n;
  }
  return (tmp);
}
}
K count(K x___0 ) 
{ 
  I tmp ;
  K tmp___0 ;

  {
  tmp = countI(x___0);
  tmp___0 = Ki(tmp);
  return (tmp___0);
}
}
K join(K x___0 , K y ) 
{ 
  I xk ;
  I tmp ;
  I yk ;
  I tmp___0 ;
  I zt ;
  I tmp___1 ;
  I tmp___2 ;
  I tmp___3 ;
  I tmp___4 ;
  I tmp___5 ;
  I zn ;
  K z ;
  K tmp___6 ;
  K c ;
  K tmp___7 ;
  K d___0 ;
  K tmp___8 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;

  {
  tmp = countI(x___0);
  xk = tmp;
  tmp___0 = countI(y);
  yk = tmp___0;
  zt = (I )0;
  if (x___0->t < 0LL) {
    tmp___2 = - x___0->t;
  } else {
    tmp___2 = x___0->t;
  }
  if (y->t < 0LL) {
    tmp___3 = - y->t;
  } else {
    tmp___3 = y->t;
  }
  if (tmp___2 == tmp___3) {
    if (x___0->t < 0LL) {
      tmp___1 = - x___0->t;
    } else {
      tmp___1 = x___0->t;
    }
    zt = - tmp___1;
  }
  if (! xk) {
    if (y->t < 0LL) {
      tmp___4 = - y->t;
    } else {
      tmp___4 = y->t;
    }
    zt = - tmp___4;
  } else
  if (! yk) {
    if (x___0->t < 0LL) {
      tmp___5 = - x___0->t;
    } else {
      tmp___5 = x___0->t;
    }
    zt = - tmp___5;
  }
  if (zt < -4LL) {
    zt = (I )0;
  }
  zn = xk + yk;
  tmp___6 = newK(zt, zn);
  z = tmp___6;
  if (! z) {
    return ((K )0);
  }
  if (-4LL == zt) {
    memcpy((void * __restrict  )((S *)(z->k)), (void const   * __restrict  )((S *)(x___0->k)),
           (size_t )((unsigned long long )xk * (unsigned long long )sizeof(S )));
    memcpy((void * __restrict  )((S *)(z->k) + xk), (void const   * __restrict  )((S *)(y->k)),
           (size_t )((unsigned long long )yk * (unsigned long long )sizeof(S )));
  } else
  if (-3LL == zt) {
    memcpy((void * __restrict  )((C *)(z->k)), (void const   * __restrict  )((C *)(x___0->k)),
           (size_t )((unsigned long long )xk * (unsigned long long )sizeof(C )));
    memcpy((void * __restrict  )((C *)(z->k) + xk), (void const   * __restrict  )((C *)(y->k)),
           (size_t )((unsigned long long )yk * (unsigned long long )sizeof(C )));
  } else
  if (-2LL == zt) {
    memcpy((void * __restrict  )((F *)(z->k)), (void const   * __restrict  )((F *)(x___0->k)),
           (size_t )((unsigned long long )xk * (unsigned long long )sizeof(F )));
    memcpy((void * __restrict  )((F *)(z->k) + xk), (void const   * __restrict  )((F *)(y->k)),
           (size_t )((unsigned long long )yk * (unsigned long long )sizeof(F )));
  } else
  if (-1LL == zt) {
    memcpy((void * __restrict  )((I *)(z->k)), (void const   * __restrict  )((I *)(x___0->k)),
           (size_t )((unsigned long long )xk * (unsigned long long )sizeof(I )));
    memcpy((void * __restrict  )((I *)(z->k) + xk), (void const   * __restrict  )((I *)(y->k)),
           (size_t )((unsigned long long )yk * (unsigned long long )sizeof(I )));
  } else
  if (0LL == zt) {
    tmp___7 = promote(x___0);
    c = tmp___7;
    tmp___8 = promote(y);
    d___0 = tmp___8;
    i = (I )0;
    _i___0 = xk;
    while (i < _i___0) {
      z->k[i] = ci(c->k[i]);
      i ++;
    }
    i___0 = (I )0;
    _i___1 = yk;
    while (i___0 < _i___1) {
      z->k[xk + i___0] = ci(d___0->k[i___0]);
      i___0 ++;
    }
    cd(c);
    cd(d___0);
  }
  return (z);
}
}
static I _hg(K h , uI k , I v , K x___0 , uI *p ) 
{ 
  I n ;
  I *d___0 ;
  I i ;
  uI u ;

  {
  n = h->n;
  d___0 = (I *)(h->k);
  u = k & (unsigned long long )(n - 1LL);
  while (1) {
    i = *(d___0 + u);
    if (! (-1LL != i)) {
      break;
    }
    if (v == *((I *)(x___0->k) + i)) {
      *p = u;
      return (i);
    }
    u ++;
    if (u == (uI )n) {
      u = (uI )0;
    }
  }
  *p = u;
  return (x___0->n);
}
}
static I _hgk(K h , uI k , K v , K x___0 , uI *p ) 
{ 
  I n ;
  I *d___0 ;
  I i ;
  uI u ;
  I tmp ;

  {
  n = h->n;
  d___0 = (I *)(h->k);
  u = k & (unsigned long long )(n - 1LL);
  while (1) {
    i = *(d___0 + u);
    if (! (-1LL != i)) {
      break;
    }
    tmp = KEQ(v, x___0->k[i]);
    if (tmp) {
      *p = u;
      return (i);
    }
    u ++;
    if (u == (uI )n) {
      u = (uI )0;
    }
  }
  *p = u;
  return (x___0->n);
}
}
static I _hgv(K h , uI k , V v , K x___0 , uI *p ) 
{ 
  I n ;
  I *d___0 ;
  I i ;
  uI u ;

  {
  n = h->n;
  d___0 = (I *)(h->k);
  u = k & (unsigned long long )(n - 1LL);
  while (1) {
    i = *(d___0 + u);
    if (! (-1LL != i)) {
      break;
    }
    if ((unsigned long )v == (unsigned long )*((V *)(x___0->k) + i)) {
      *p = u;
      return (i);
    }
    u ++;
    if (u == (uI )n) {
      u = (uI )0;
    }
  }
  *p = u;
  return (x___0->n);
}
}
K _hash(K x___0 ) 
{ 
  K tmp ;
  uI p ;
  K y ;
  K tmp___0 ;
  K tmp___1 ;
  K tmp___2 ;
  I tmp___3 ;
  I i ;
  I _i___0 ;
  I i___0 ;
  I _i___1 ;
  K v ;
  UI tmp___4 ;
  I tmp___5 ;
  I i___1 ;
  I _i___2 ;
  uI v___0 ;
  uint32_t tmp___6 ;
  I tmp___7 ;
  I i___2 ;
  I _i___3 ;
  uI k ;
  I i___3 ;
  I _i___4 ;
  S v___1 ;
  size_t tmp___8 ;
  uint32_t tmp___9 ;
  I tmp___10 ;

  {
  if (x___0->t > 0LL) {
    tmp = kerr("rank");
    return (tmp);
  }
  if (-3LL == x___0->t) {
    tmp___0 = newK((I )-1, (I )256);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = newH(x___0->n);
    tmp___2 = tmp___1;
  }
  y = tmp___2;
  tmp___3 = OOM_CD((I )0, y, (V )-1);
  if (! tmp___3) {
    return ((K )0);
  }
  hcinit();
  i = (I )0;
  _i___0 = y->n;
  while (i < _i___0) {
    *((I *)(y->k) + i) = (I )-1;
    i ++;
  }
  switch (- x___0->t) {
  case 0LL: 
  i___0 = (I )0;
  _i___1 = x___0->n;
  while (i___0 < _i___1) {
    v = x___0->k[i___0];
    tmp___4 = hcode(v);
    tmp___5 = _hgk(y, tmp___4, v, x___0, & p);
    if (x___0->n == tmp___5) {
      *((I *)(y->k) + p) = i___0;
    }
    i___0 ++;
  }
  break;
  case 1LL: ;
  case 2LL: 
  i___1 = (I )0;
  _i___2 = x___0->n;
  while (i___1 < _i___2) {
    v___0 = *((uI *)(x___0->k) + i___1);
    tmp___6 = hc(v___0);
    tmp___7 = _hg(y, (uI )tmp___6, (I )v___0, x___0, & p);
    if (x___0->n == tmp___7) {
      *((I *)(y->k) + p) = i___1;
    }
    i___1 ++;
  }
  break;
  case 3LL: 
  i___2 = (I )0;
  _i___3 = x___0->n;
  while (i___2 < _i___3) {
    k = (uI )((UC )*((C *)(x___0->k) + i___2));
    if (x___0->n == *((I *)(y->k) + k)) {
      *((I *)(y->k) + k) = i___2;
    }
    i___2 ++;
  }
  break;
  case 4LL: 
  setS(1, (I )0);
  i___3 = (I )0;
  _i___4 = x___0->n;
  while (i___3 < _i___4) {
    v___1 = *((S *)(x___0->k) + i___3);
    if (! *((I *)v___1 + -1)) {
      tmp___8 = strlen((char const   *)v___1);
      tmp___9 = fnv1a((UC *)v___1, (I )tmp___8);
      *((I *)v___1 + -1) = (I )tmp___9;
    }
    tmp___10 = _hgv(y, (uI )*((I *)v___1 + -1), (V )v___1, x___0, & p);
    if (x___0->n == tmp___10) {
      *((I *)(y->k) + p) = i___3;
    }
    i___3 ++;
  }
  break;
  }
  y->t = (I )-5;
  return (y);
}
}
K hash_find(K a , K b___1 ) 
{ 
  K x___0 ;
  K y ;
  uI k ;
  uI p ;
  I i ;
  K tmp ;
  K tmp___0 ;
  UI tmp___1 ;
  uI v ;
  uint32_t tmp___2 ;
  S v___0 ;
  size_t tmp___3 ;
  uint32_t tmp___4 ;
  K tmp___5 ;

  {
  x___0 = a->k[0];
  y = a->k[1];
  if (x___0->t > 0LL) {
    tmp = kerr("domain");
    return (tmp);
  }
  if (x___0->t) {
    if (x___0->t + b___1->t) {
      tmp___0 = Ki(x___0->n);
      return (tmp___0);
    }
  }
  hcinit();
  switch (- x___0->t) {
  case 0LL: 
  tmp___1 = hcode(b___1);
  i = _hgk(y, tmp___1, b___1, x___0, & p);
  break;
  case 1LL: ;
  case 2LL: 
  v = *((uI *)(b___1->k));
  tmp___2 = hc(v);
  i = _hg(y, (uI )tmp___2, (I )v, x___0, & p);
  break;
  case 3LL: 
  k = (uI )((UC )*((C *)(b___1->k)));
  i = *((I *)(y->k) + k);
  if (i < 0LL) {
    i = x___0->n;
  }
  break;
  case 4LL: 
  v___0 = *((S *)(b___1->k));
  tmp___3 = strlen((char const   *)v___0);
  tmp___4 = fnv1a((UC *)v___0, (I )tmp___3);
  k = (uI )tmp___4;
  i = _hgv(y, k, (V )v___0, x___0, & p);
  break;
  }
  tmp___5 = Ki(i);
  return (tmp___5);
}
}
#pragma merger("0","/tmp/cil-hYvz_euh.i","-g,-pthread,-O3")
K sample(K x___0 , K y ) ;
K find(K a , K b___1 ) ;
K find(K a , K b___1 ) 
{ 
  I at___0 ;
  I an ;
  I bt ;
  K tmp ;
  I i ;
  I _i___0 ;
  K tmp___0 ;
  I i___0 ;
  I _i___1 ;
  K tmp___1 ;
  I i___1 ;
  I _i___2 ;
  K tmp___2 ;
  I tmp___3 ;
  F fb ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  I i___2 ;
  I _i___3 ;
  K tmp___7 ;
  I tmp___8 ;
  I i___3 ;
  I _i___4 ;
  K tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  I tmp___13 ;
  I i___4 ;
  I _i___5 ;
  K tmp___14 ;
  K tmp___15 ;
  I i___5 ;
  I _i___6 ;
  K tmp___16 ;
  I tmp___17 ;
  K tmp___18 ;

  {
  at___0 = a->t;
  an = a->n;
  bt = b___1->t;
  if (at___0 > 0LL) {
    tmp = kerr("domain");
    return (tmp);
  }
  if (-4LL == at___0) {
    if (4LL == bt) {
      i = (I )0;
      _i___0 = an;
      while (i < _i___0) {
        if ((unsigned long )*((S *)(a->k) + i) == (unsigned long )*((S *)(b___1->k))) {
          tmp___0 = Ki(i);
          return (tmp___0);
        }
        i ++;
      }
    }
  }
  if (-3LL == at___0) {
    if (3LL == bt) {
      i___0 = (I )0;
      _i___1 = an;
      while (i___0 < _i___1) {
        if ((int )*((C *)(a->k) + i___0) == (int )*((C *)(b___1->k))) {
          tmp___1 = Ki(i___0);
          return (tmp___1);
        }
        i___0 ++;
      }
    }
  }
  if (-2LL == at___0) {
    if (2LL == bt) {
      i___1 = (I )0;
      _i___2 = an;
      while (i___1 < _i___2) {
        tmp___3 = FC(*((F *)(a->k) + i___1), *((F *)(b___1->k)));
        if (! tmp___3) {
          tmp___2 = Ki(i___1);
          return (tmp___2);
        }
        i___1 ++;
      }
    }
  }
  if (-2LL == at___0) {
    if (1LL == bt) {
      if (9223372036854775807LL == *((I *)(b___1->k))) {
        tmp___6 = (double )1 / 0.;
      } else {
        if (-9223372036854775807LL == *((I *)(b___1->k))) {
          tmp___5 = - ((double )1 / 0.);
        } else {
          if ((-0x7FFFFFFFFFFFFFFF-1) == *((I *)(b___1->k))) {
            tmp___4 = (double )0 / 0.;
          } else {
            tmp___4 = (double )*((I *)(b___1->k));
          }
          tmp___5 = tmp___4;
        }
        tmp___6 = tmp___5;
      }
      fb = tmp___6;
      i___2 = (I )0;
      _i___3 = an;
      while (i___2 < _i___3) {
        tmp___8 = FC(*((F *)(a->k) + i___2), fb);
        if (! tmp___8) {
          tmp___7 = Ki(i___2);
          return (tmp___7);
        }
        i___2 ++;
      }
    }
  }
  if (-1LL == at___0) {
    if (2LL == bt) {
      i___3 = (I )0;
      _i___4 = an;
      while (i___3 < _i___4) {
        if (9223372036854775807LL == *((I *)(a->k) + i___3)) {
          tmp___12 = (double )1 / 0.;
        } else {
          if (-9223372036854775807LL == *((I *)(a->k) + i___3)) {
            tmp___11 = - ((double )1 / 0.);
          } else {
            if ((-0x7FFFFFFFFFFFFFFF-1) == *((I *)(a->k) + i___3)) {
              tmp___10 = (double )0 / 0.;
            } else {
              tmp___10 = (double )*((I *)(a->k) + i___3);
            }
            tmp___11 = tmp___10;
          }
          tmp___12 = tmp___11;
        }
        tmp___13 = FC(tmp___12, *((F *)(b___1->k)));
        if (! tmp___13) {
          tmp___9 = Ki(i___3);
          return (tmp___9);
        }
        i___3 ++;
      }
    }
  }
  if (-1LL == at___0) {
    if (1LL == bt) {
      i___4 = (I )0;
      _i___5 = an;
      while (i___4 < _i___5) {
        if (*((I *)(a->k) + i___4) == *((I *)(b___1->k))) {
          tmp___14 = Ki(i___4);
          return (tmp___14);
        }
        i___4 ++;
      }
    }
  }
  if (! at___0) {
    if (2LL == an) {
      if (-5LL == (a->k[1])->t) {
        tmp___15 = hash_find(a, b___1);
        return (tmp___15);
      }
    }
    i___5 = (I )0;
    _i___6 = an;
    while (i___5 < _i___6) {
      tmp___17 = matchI(a->k[i___5], b___1);
      if (tmp___17) {
        tmp___16 = Ki(i___5);
        return (tmp___16);
      }
      i___5 ++;
    }
  }
  tmp___18 = Ki(an);
  return (tmp___18);
}
}
static F num_ex(K a , F x___0 ) 
{ 
  F y ;
  K b___1 ;
  K g ;
  K k ;
  K tmp ;

  {
  y = (F )0;
  b___1 = Kf(x___0);
  if (! b___1) {
    return ((double )0 / 0.);
  }
  g = newK((I )0, (I )1);
  if (! g) {
    cd(b___1);
    return ((double )0 / 0.);
  }
  g->k[0] = ci(b___1);
  tmp = vf_ex((V )(& a), g);
  k = tmp;
  if (! k) {
    y = (double )0 / 0.;
  } else
  if (k->t != 1LL) {
    if (k->t != 2LL) {
      y = (double )0 / 0.;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (k->t == 1LL) {
    y = (F )*((I *)(k->k));
  } else {
    y = *((F *)(k->k));
  }
  cd(b___1);
  cd(k);
  cd(g);
  return (y);
}
}
static I isShallowNumeric(K k ) 
{ 
  I tmp ;
  I i ;
  I _i___0 ;
  I t ;

  {
  if (k->t < 0LL) {
    tmp = - k->t;
  } else {
    tmp = k->t;
  }
  if (tmp > 2LL) {
    return ((I )0);
  }
  if (0LL == k->t) {
    i = (I )0;
    _i___0 = k->n;
    while (i < _i___0) {
      t = (k->k[i])->t;
      if (t != 1LL) {
        if (t != 2LL) {
          return ((I )0);
        }
      }
      i ++;
    }
  }
  return ((I )1);
}
}
static F ithFloat(K k , I i ) 
{ 
  I n ;
  I tmp ;

  {
  if (! k) {
    return ((F )0);
  }
  n = k->n;
  if (! k->t) {
    k = k->k[i % n];
    i = (I )0;
  }
  if (k->t < 0LL) {
    tmp = - k->t;
  } else {
    tmp = k->t;
  }
  if (1LL == tmp) {
    return ((F )*((I *)(k->k) + i % n));
  }
  return (*((F *)(k->k) + i % n));
}
}
static F inverter(K a , K b___1 , K c , I index___0 ) 
{ 
  F y ;
  F tmp ;
  I i ;
  I m ;
  F r ;
  F tmp___0 ;
  I i___0 ;
  I _i___0 ;
  F tmp___1 ;
  F d___0 ;
  F e ;
  F tmp___2 ;
  F tmp___3 ;
  F tmp___4 ;
  I tmp___5 ;

  {
  tmp = ithFloat(b___1, index___0);
  y = tmp;
  m = (I )20;
  F x___0[m + 2LL] ;
  F f[m + 2LL] ;
  x___0[0] = 0.9998;
  x___0[1] = 0.9999;
  if (c) {
    tmp___0 = ithFloat(c, index___0);
    r = tmp___0;
    x___0[0] = 0.9999 * r;
    x___0[1] = r;
  }
  i___0 = (I )0;
  _i___0 = (I )2;
  while (i___0 < _i___0) {
    tmp___1 = num_ex(a, x___0[i___0]);
    f[i___0] = tmp___1 - y;
    i___0 ++;
  }
  if (y) {
    tmp___2 = y * 0.000001;
  } else {
    tmp___2 = 0.000001;
  }
  e = tmp___2;
  i = (I )0;
  while (i < m) {
    d___0 = ((x___0[i + 1LL] - x___0[i]) / (f[i + 1LL] - f[i])) * f[i + 1LL];
    x___0[i + 2LL] = x___0[i + 1LL] - d___0;
    tmp___3 = num_ex(a, x___0[i + 2LL]);
    f[i + 2LL] = tmp___3 - y;
    if (d___0 < (F )0) {
      tmp___4 = - d___0;
    } else {
      tmp___4 = d___0;
    }
    if (tmp___4 < e) {
      break;
    } else {
      tmp___5 = FC(f[i + 2LL], 0.);
      if (! tmp___5) {
        break;
      }
    }
    i ++;
  }
  if (i >= m) {
    kerr("limit");
    return ((F )0);
  }
  return (x___0[i + 2LL]);
}
}
K what_triadic(K a , K b___1 , K c ) 
{ 
  I bt ;
  I bn ;
  K tmp ;
  I tmp___0 ;
  I tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  K tmp___4 ;
  I zn ;
  I zt ;
  K z ;
  K tmp___5 ;
  I i ;
  I _i___0 ;

  {
  bt = b___1->t;
  bn = b___1->n;
  tmp___0 = isShallowNumeric(b___1);
  if (tmp___0) {
    if (c) {
      tmp___1 = isShallowNumeric(c);
      if (! tmp___1) {
        tmp = kerr("type");
        return (tmp);
      }
    }
  } else {
    tmp = kerr("type");
    return (tmp);
  }
  if (! bt) {
    if (! bn) {
      tmp___2 = newK((I )0, (I )0);
      return (tmp___2);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (c) {
    if (! c->t) {
      if (! c->n) {
        tmp___2 = newK((I )0, (I )0);
        return (tmp___2);
      }
    }
  }
  if (0LL == bn) {
    tmp___3 = newK((I )-2, (I )0);
    return (tmp___3);
  } else
  if (c) {
    if (0LL == c->n) {
      tmp___3 = newK((I )-2, (I )0);
      return (tmp___3);
    }
  }
  if (c) {
    if (c->t < 1LL) {
      if (bt < 1LL) {
        if (c->n != b___1->n) {
          tmp___4 = kerr("length");
          return (tmp___4);
        }
      }
    }
  }
  zn = bn;
  zt = (I )2;
  if (bt < 1LL) {
    zt = (I )-2;
  } else
  if (c) {
    if (c->t < 1LL) {
      zt = (I )-2;
    }
  }
  if (c) {
    if (zn > c->n) {
      zn = zn;
    } else {
      zn = c->n;
    }
  }
  tmp___5 = newK(zt, zn);
  z = tmp___5;
  if (! z) {
    return ((K )0);
  }
  i = (I )0;
  _i___0 = zn;
  while (i < _i___0) {
    *((F *)(z->k) + i) = inverter(a, b___1, c, i);
    i ++;
  }
  return (z);
}
}
static K qrand(K a , K b___1 ) 
{ 
  I at___0 ;
  I bt ;
  K y ;
  K tmp ;
  I tmp___0 ;
  I c ;
  I n ;
  I tmp___1 ;
  K tmp___2 ;
  K tmp___3 ;
  I j ;
  I k ;
  I s ;
  int tmp___4 ;
  F f ;
  I i ;
  I _i___0 ;
  F tmp___5 ;
  I d___0 ;
  I i___0 ;
  I _i___1 ;
  F tmp___6 ;
  F tmp___7 ;

  {
  at___0 = a->t;
  bt = b___1->t;
  if (at___0 < 0LL) {
    tmp___0 = - at___0;
  } else {
    tmp___0 = at___0;
  }
  if (1LL != tmp___0) {
    tmp = kerr("int");
    return (tmp);
  } else
  if (1LL != bt) {
    if (2LL != bt) {
      tmp = kerr("int");
      return (tmp);
    }
  }
  c = *((I *)(a->k));
  if (c < 0LL) {
    tmp___1 = - c;
  } else {
    tmp___1 = c;
  }
  n = tmp___1;
  if (1LL == bt) {
    if (c < 0LL) {
      if (*((I *)(b___1->k)) < - c) {
        tmp___2 = kerr("length");
        return (tmp___2);
      }
    }
  }
  if (1LL == bt) {
    if (*((I *)(b___1->k)) < 0LL) {
      tmp___3 = kerr("domain");
      return (tmp___3);
    }
  }
  j = (I )0;
  if (1LL == bt) {
    tmp___4 = -1;
  } else {
    tmp___4 = -2;
  }
  y = newK((I )tmp___4, n);
  if (! y) {
    return ((K )0);
  }
  if (2LL == bt) {
    f = *((F *)(b___1->k));
    i = (I )0;
    _i___0 = n;
    while (i < _i___0) {
      tmp___5 = RF();
      *((F *)(y->k) + i) = tmp___5 * f;
      i ++;
    }
    return (y);
  }
  d___0 = *((I *)(b___1->k));
  if (c >= 0LL) {
    i___0 = (I )0;
    _i___1 = n;
    while (i___0 < _i___1) {
      tmp___6 = RF();
      *((I *)(y->k) + i___0) = (I )((F )d___0 * tmp___6);
      i___0 ++;
    }
  } else {
    vitter((I *)(y->k), y->n, d___0);
    j = n - 1LL;
    while (j > 0LL) {
      tmp___7 = RF();
      k = (I )((F )(1LL + j) * tmp___7);
      s = *((I *)(y->k) + j);
      *((I *)(y->k) + j) = *((I *)(y->k) + k);
      *((I *)(y->k) + k) = s;
      j --;
    }
  }
  return (y);
}
}
K sample(K x___0 , K y ) 
{ 
  K a ;
  K b___1 ;
  K z ;
  K tmp ;
  I tmp___0 ;
  I tmp___1 ;

  {
  if (! y->n) {
    tmp = take(x___0, y);
    return (tmp);
  }
  tmp___0 = countI(y);
  b___1 = Ki(tmp___0);
  if (! b___1) {
    return ((K )0);
  }
  a = qrand(x___0, b___1);
  tmp___1 = OOM_CD((I )0, a, b___1, (V )-1);
  if (! tmp___1) {
    return ((K )0);
  }
  cd(b___1);
  z = at_verb(y, a);
  cd(a);
  return (z);
}
}
K what(K x___0 , K y ) 
{ 
  K tmp ;
  K tmp___0 ;
  K tmp___2 ;
  K tmp___3 ;
  K tmp___4 ;
  I tmp___5 ;
  K tmp___6 ;

  {
  if (1LL == x___0->t) {
    tmp = kerr("domain");
    return (tmp);
  }
  if (7LL == x___0->t) {
    tmp___0 = what_triadic(x___0, y, (K )0);
    return (tmp___0);
  }
  if (1LL == x___0->t) {
    tmp___5 = atomI(y);
    if (tmp___5) {
      tmp___2 = qrand(x___0, y);
      tmp___4 = tmp___2;
    } else {
      tmp___3 = sample(x___0, y);
      tmp___4 = tmp___3;
    }
    return (tmp___4);
  }
  tmp___6 = find(x___0, y);
  return (tmp___6);
}
}
#pragma merger("0","/tmp/cil-1YEQqgsg.i","-g,-pthread,-O3")
int main(int argc , S *argv ) ;
int main(int argc , S *argv ) 
{ 


  {
  kinit();
  args(argc, argv);
  attend();
  return (0);
}
}
