/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __syscall_slong_t;
typedef __time_t time_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef __mode_t mode_t;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
typedef struct stat fs_stats;
typedef unsigned int __uint32_t;
typedef long __off64_t;
typedef long __intptr_t;
typedef unsigned long size_t;
typedef __intptr_t intptr_t;
typedef __uint32_t uint32_t;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
enum __anonenum_list_direction_t_372799795 {
    LIST_HEAD = 0,
    LIST_TAIL = 1
} ;
typedef enum __anonenum_list_direction_t_372799795 list_direction_t;
struct list_node {
   struct list_node *prev ;
   struct list_node *next ;
   void *val ;
};
typedef struct list_node list_node_t;
struct __anonstruct_list_t_617949005 {
   list_node_t *head ;
   list_node_t *tail ;
   unsigned int len ;
   void (*free)(void *val ) ;
   int (*match)(void *a , void *b ) ;
};
typedef struct __anonstruct_list_t_617949005 list_t;
struct __anonstruct_list_iterator_t_912695439 {
   list_node_t *next ;
   list_direction_t direction ;
};
typedef struct __anonstruct_list_iterator_t_912695439 list_iterator_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef void CURL;
typedef void CURLSH;
enum __anonenum_curl_lock_data_171524127 {
    CURL_LOCK_DATA_NONE = 0,
    CURL_LOCK_DATA_SHARE = 1,
    CURL_LOCK_DATA_COOKIE = 2,
    CURL_LOCK_DATA_DNS = 3,
    CURL_LOCK_DATA_SSL_SESSION = 4,
    CURL_LOCK_DATA_CONNECT = 5,
    CURL_LOCK_DATA_PSL = 6,
    CURL_LOCK_DATA_LAST = 7
} ;
typedef enum __anonenum_curl_lock_data_171524127 curl_lock_data;
enum __anonenum_curl_lock_access_244776063 {
    CURL_LOCK_ACCESS_NONE = 0,
    CURL_LOCK_ACCESS_SHARED = 1,
    CURL_LOCK_ACCESS_SINGLE = 2,
    CURL_LOCK_ACCESS_LAST = 3
} ;
typedef enum __anonenum_curl_lock_access_244776063 curl_lock_access;
enum __anonenum_CURLSHcode_60028028 {
    CURLSHE_OK = 0,
    CURLSHE_BAD_OPTION = 1,
    CURLSHE_IN_USE = 2,
    CURLSHE_INVALID = 3,
    CURLSHE_NOMEM = 4,
    CURLSHE_NOT_BUILT_IN = 5,
    CURLSHE_LAST = 6
} ;
typedef enum __anonenum_CURLSHcode_60028028 CURLSHcode;
enum __anonenum_CURLSHoption_958986232 {
    CURLSHOPT_NONE = 0,
    CURLSHOPT_SHARE = 1,
    CURLSHOPT_UNSHARE = 2,
    CURLSHOPT_LOCKFUNC = 3,
    CURLSHOPT_UNLOCKFUNC = 4,
    CURLSHOPT_USERDATA = 5,
    CURLSHOPT_LAST = 6
} ;
typedef enum __anonenum_CURLSHoption_958986232 CURLSHoption;
struct __anonstruct_clib_package_dependency_t_474234288 {
   char *name ;
   char *author ;
   char *version ;
};
typedef struct __anonstruct_clib_package_dependency_t_474234288 clib_package_dependency_t;
struct __anonstruct_clib_package_t_687707428 {
   char *author ;
   char *description ;
   char *install ;
   char *configure ;
   char *json ;
   char *license ;
   char *name ;
   char *repo ;
   char *repo_name ;
   char *url ;
   char *version ;
   char *makefile ;
   char *filename ;
   char *flags ;
   char *prefix ;
   list_t *dependencies ;
   list_t *development ;
   list_t *src ;
   void *data ;
   unsigned int refs ;
};
typedef struct __anonstruct_clib_package_t_687707428 clib_package_t;
struct __anonstruct_clib_package_opts_t_1001569764 {
   int skip_cache ;
   int force ;
   int global ;
   char *prefix ;
   int concurrency ;
   char *token ;
};
typedef struct __anonstruct_clib_package_opts_t_1001569764 clib_package_opts_t;
struct __anonstruct_debug_t_712518223 {
   char const   *name ;
   int color ;
   int enabled ;
   FILE *stream ;
};
typedef struct __anonstruct_debug_t_712518223 debug_t;
typedef uint32_t khint_t;
typedef khint_t khiter_t;
typedef char const   *kh_cstr_t;
struct __anonstruct_kh_ptr_t_1041758266 {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   uint32_t *flags ;
   kh_cstr_t *keys ;
   void **vals ;
};
typedef struct __anonstruct_kh_ptr_t_1041758266 kh_ptr_t;
typedef kh_ptr_t hash_t;
struct __anonstruct_http_get_response_t_664041846 {
   char *data ;
   size_t size ;
   long status ;
   int ok ;
};
typedef struct __anonstruct_http_get_response_t_664041846 http_get_response_t;
enum __anonenum_cc_color_t_911620310 {
    CC_FG_NONE = 0,
    CC_FG_BLACK = 1,
    CC_FG_DARK_RED = 2,
    CC_FG_DARK_GREEN = 3,
    CC_FG_DARK_YELLOW = 4,
    CC_FG_DARK_BLUE = 5,
    CC_FG_DARK_MAGENTA = 6,
    CC_FG_DARK_CYAN = 7,
    CC_FG_GRAY = 8,
    CC_FG_DARK_GRAY = 9,
    CC_FG_RED = 10,
    CC_FG_GREEN = 11,
    CC_FG_YELLOW = 12,
    CC_FG_BLUE = 13,
    CC_FG_MAGENTA = 14,
    CC_FG_CYAN = 15,
    CC_FG_WHITE = 16,
    CC_BG_NONE = 0,
    CC_BG_BLACK = 32,
    CC_BG_DARK_RED = 64,
    CC_BG_DARK_GREEN = 96,
    CC_BG_DARK_YELLOW = 128,
    CC_BG_DARK_BLUE = 160,
    CC_BG_DARK_MAGENTA = 192,
    CC_BG_DARK_CYAN = 224,
    CC_BG_GRAY = 256,
    CC_BG_DARK_GRAY = 288,
    CC_BG_RED = 320,
    CC_BG_GREEN = 352,
    CC_BG_YELLOW = 384,
    CC_BG_BLUE = 416,
    CC_BG_MAGENTA = 448,
    CC_BG_CYAN = 480,
    CC_BG_WHITE = 512
} ;
typedef enum __anonenum_cc_color_t_911620310 cc_color_t;
struct json_object_t ;
typedef struct json_object_t JSON_Object;
struct json_array_t ;
typedef struct json_array_t JSON_Array;
struct json_value_t ;
typedef struct json_value_t JSON_Value;
struct fetch_package_file_thread_data ;
typedef struct fetch_package_file_thread_data fetch_package_file_thread_data_t;
struct fetch_package_file_thread_data {
   clib_package_t *pkg ;
   char const   *dir ;
   char *file ;
   int verbose ;
   pthread_t thread ;
   pthread_attr_t attr ;
   void *data ;
};
struct clib_package_lock ;
typedef struct clib_package_lock clib_package_lock_t;
struct clib_package_lock {
   pthread_mutex_t mutex ;
};
typedef int JSON_Value_Type;
typedef unsigned int __useconds_t;
enum __anonenum_CURLcode_1040171027 {
    CURLE_OK = 0,
    CURLE_UNSUPPORTED_PROTOCOL = 1,
    CURLE_FAILED_INIT = 2,
    CURLE_URL_MALFORMAT = 3,
    CURLE_NOT_BUILT_IN = 4,
    CURLE_COULDNT_RESOLVE_PROXY = 5,
    CURLE_COULDNT_RESOLVE_HOST = 6,
    CURLE_COULDNT_CONNECT = 7,
    CURLE_WEIRD_SERVER_REPLY = 8,
    CURLE_REMOTE_ACCESS_DENIED = 9,
    CURLE_FTP_ACCEPT_FAILED = 10,
    CURLE_FTP_WEIRD_PASS_REPLY = 11,
    CURLE_FTP_ACCEPT_TIMEOUT = 12,
    CURLE_FTP_WEIRD_PASV_REPLY = 13,
    CURLE_FTP_WEIRD_227_FORMAT = 14,
    CURLE_FTP_CANT_GET_HOST = 15,
    CURLE_HTTP2 = 16,
    CURLE_FTP_COULDNT_SET_TYPE = 17,
    CURLE_PARTIAL_FILE = 18,
    CURLE_FTP_COULDNT_RETR_FILE = 19,
    CURLE_OBSOLETE20 = 20,
    CURLE_QUOTE_ERROR = 21,
    CURLE_HTTP_RETURNED_ERROR = 22,
    CURLE_WRITE_ERROR = 23,
    CURLE_OBSOLETE24 = 24,
    CURLE_UPLOAD_FAILED = 25,
    CURLE_READ_ERROR = 26,
    CURLE_OUT_OF_MEMORY = 27,
    CURLE_OPERATION_TIMEDOUT = 28,
    CURLE_OBSOLETE29 = 29,
    CURLE_FTP_PORT_FAILED = 30,
    CURLE_FTP_COULDNT_USE_REST = 31,
    CURLE_OBSOLETE32 = 32,
    CURLE_RANGE_ERROR = 33,
    CURLE_HTTP_POST_ERROR = 34,
    CURLE_SSL_CONNECT_ERROR = 35,
    CURLE_BAD_DOWNLOAD_RESUME = 36,
    CURLE_FILE_COULDNT_READ_FILE = 37,
    CURLE_LDAP_CANNOT_BIND = 38,
    CURLE_LDAP_SEARCH_FAILED = 39,
    CURLE_OBSOLETE40 = 40,
    CURLE_FUNCTION_NOT_FOUND = 41,
    CURLE_ABORTED_BY_CALLBACK = 42,
    CURLE_BAD_FUNCTION_ARGUMENT = 43,
    CURLE_OBSOLETE44 = 44,
    CURLE_INTERFACE_FAILED = 45,
    CURLE_OBSOLETE46 = 46,
    CURLE_TOO_MANY_REDIRECTS = 47,
    CURLE_UNKNOWN_OPTION = 48,
    CURLE_TELNET_OPTION_SYNTAX = 49,
    CURLE_OBSOLETE50 = 50,
    CURLE_OBSOLETE51 = 51,
    CURLE_GOT_NOTHING = 52,
    CURLE_SSL_ENGINE_NOTFOUND = 53,
    CURLE_SSL_ENGINE_SETFAILED = 54,
    CURLE_SEND_ERROR = 55,
    CURLE_RECV_ERROR = 56,
    CURLE_OBSOLETE57 = 57,
    CURLE_SSL_CERTPROBLEM = 58,
    CURLE_SSL_CIPHER = 59,
    CURLE_PEER_FAILED_VERIFICATION = 60,
    CURLE_BAD_CONTENT_ENCODING = 61,
    CURLE_LDAP_INVALID_URL = 62,
    CURLE_FILESIZE_EXCEEDED = 63,
    CURLE_USE_SSL_FAILED = 64,
    CURLE_SEND_FAIL_REWIND = 65,
    CURLE_SSL_ENGINE_INITFAILED = 66,
    CURLE_LOGIN_DENIED = 67,
    CURLE_TFTP_NOTFOUND = 68,
    CURLE_TFTP_PERM = 69,
    CURLE_REMOTE_DISK_FULL = 70,
    CURLE_TFTP_ILLEGAL = 71,
    CURLE_TFTP_UNKNOWNID = 72,
    CURLE_REMOTE_FILE_EXISTS = 73,
    CURLE_TFTP_NOSUCHUSER = 74,
    CURLE_CONV_FAILED = 75,
    CURLE_CONV_REQD = 76,
    CURLE_SSL_CACERT_BADFILE = 77,
    CURLE_REMOTE_FILE_NOT_FOUND = 78,
    CURLE_SSH = 79,
    CURLE_SSL_SHUTDOWN_FAILED = 80,
    CURLE_AGAIN = 81,
    CURLE_SSL_CRL_BADFILE = 82,
    CURLE_SSL_ISSUER_ERROR = 83,
    CURLE_FTP_PRET_FAILED = 84,
    CURLE_RTSP_CSEQ_ERROR = 85,
    CURLE_RTSP_SESSION_ERROR = 86,
    CURLE_FTP_BAD_FILE_LIST = 87,
    CURLE_CHUNK_FAILED = 88,
    CURLE_NO_CONNECTION_AVAILABLE = 89,
    CURLE_SSL_PINNEDPUBKEYNOTMATCH = 90,
    CURLE_SSL_INVALIDCERTSTATUS = 91,
    CURLE_HTTP2_STREAM = 92,
    CURLE_RECURSIVE_API_CALL = 93,
    CURLE_AUTH_ERROR = 94,
    CURLE_HTTP3 = 95,
    CURL_LAST = 96
} ;
typedef enum __anonenum_CURLcode_1040171027 CURLcode;
struct command ;
struct __anonstruct_command_option_t_246293268 {
   int optional_arg ;
   int required_arg ;
   char *argname ;
   char *large ;
   char const   *small ;
   char const   *large_with_arg ;
   char const   *description ;
   void (*cb)(struct command *self ) ;
};
typedef struct __anonstruct_command_option_t_246293268 command_option_t;
struct command {
   void *data ;
   char const   *usage ;
   char const   *arg ;
   char const   *name ;
   char const   *version ;
   int option_count ;
   command_option_t options[32] ;
   int argc ;
   char *argv[32] ;
   char **nargv ;
};
typedef struct command command_t;
struct options ;
typedef struct options options_t;
struct options {
   char const   *dir ;
   char *prefix ;
   int force ;
   int verbose ;
   int dev ;
   int skip_cache ;
   int global ;
   char *clean ;
   char *test ;
   unsigned int concurrency ;
};
struct clib_package_thread ;
typedef struct clib_package_thread clib_package_thread_t;
struct clib_package_thread {
   char const   *dir ;
};
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream ;
typedef struct __dirstream DIR;
struct tinydir_file {
   char path[4096] ;
   char name[256] ;
   char *extension ;
   int is_dir ;
   int is_reg ;
   struct stat _s ;
};
typedef struct tinydir_file tinydir_file;
struct tinydir_dir {
   char path[4096] ;
   int has_next ;
   size_t n_files ;
   tinydir_file *_files ;
   DIR *_d ;
   struct dirent *_e ;
};
typedef struct tinydir_dir tinydir_dir;
typedef int JSON_Status;
union json_value_value {
   char *string ;
   double number ;
   JSON_Object *object ;
   JSON_Array *array ;
   int boolean ;
   int null ;
};
typedef union json_value_value JSON_Value_Value;
struct json_value_t {
   JSON_Value_Type type ;
   JSON_Value_Value value ;
};
struct json_object_t {
   char **names ;
   JSON_Value **values ;
   size_t count ;
   size_t capacity ;
};
struct json_array_t {
   JSON_Value **items ;
   size_t count ;
   size_t capacity ;
};
enum __anonenum_CURLoption_714703655 {
    CURLOPT_WRITEDATA = 10001,
    CURLOPT_URL = 10002,
    CURLOPT_PORT = 3,
    CURLOPT_PROXY = 10004,
    CURLOPT_USERPWD = 10005,
    CURLOPT_PROXYUSERPWD = 10006,
    CURLOPT_RANGE = 10007,
    CURLOPT_READDATA = 10009,
    CURLOPT_ERRORBUFFER = 10010,
    CURLOPT_WRITEFUNCTION = 20011,
    CURLOPT_READFUNCTION = 20012,
    CURLOPT_TIMEOUT = 13,
    CURLOPT_INFILESIZE = 14,
    CURLOPT_POSTFIELDS = 10015,
    CURLOPT_REFERER = 10016,
    CURLOPT_FTPPORT = 10017,
    CURLOPT_USERAGENT = 10018,
    CURLOPT_LOW_SPEED_LIMIT = 19,
    CURLOPT_LOW_SPEED_TIME = 20,
    CURLOPT_RESUME_FROM = 21,
    CURLOPT_COOKIE = 10022,
    CURLOPT_HTTPHEADER = 10023,
    CURLOPT_HTTPPOST = 10024,
    CURLOPT_SSLCERT = 10025,
    CURLOPT_KEYPASSWD = 10026,
    CURLOPT_CRLF = 27,
    CURLOPT_QUOTE = 10028,
    CURLOPT_HEADERDATA = 10029,
    CURLOPT_COOKIEFILE = 10031,
    CURLOPT_SSLVERSION = 32,
    CURLOPT_TIMECONDITION = 33,
    CURLOPT_TIMEVALUE = 34,
    CURLOPT_CUSTOMREQUEST = 10036,
    CURLOPT_STDERR = 10037,
    CURLOPT_POSTQUOTE = 10039,
    CURLOPT_OBSOLETE40 = 10040,
    CURLOPT_VERBOSE = 41,
    CURLOPT_HEADER = 42,
    CURLOPT_NOPROGRESS = 43,
    CURLOPT_NOBODY = 44,
    CURLOPT_FAILONERROR = 45,
    CURLOPT_UPLOAD = 46,
    CURLOPT_POST = 47,
    CURLOPT_DIRLISTONLY = 48,
    CURLOPT_APPEND = 50,
    CURLOPT_NETRC = 51,
    CURLOPT_FOLLOWLOCATION = 52,
    CURLOPT_TRANSFERTEXT = 53,
    CURLOPT_PUT = 54,
    CURLOPT_PROGRESSFUNCTION = 20056,
    CURLOPT_PROGRESSDATA = 10057,
    CURLOPT_AUTOREFERER = 58,
    CURLOPT_PROXYPORT = 59,
    CURLOPT_POSTFIELDSIZE = 60,
    CURLOPT_HTTPPROXYTUNNEL = 61,
    CURLOPT_INTERFACE = 10062,
    CURLOPT_KRBLEVEL = 10063,
    CURLOPT_SSL_VERIFYPEER = 64,
    CURLOPT_CAINFO = 10065,
    CURLOPT_MAXREDIRS = 68,
    CURLOPT_FILETIME = 69,
    CURLOPT_TELNETOPTIONS = 10070,
    CURLOPT_MAXCONNECTS = 71,
    CURLOPT_OBSOLETE72 = 72,
    CURLOPT_FRESH_CONNECT = 74,
    CURLOPT_FORBID_REUSE = 75,
    CURLOPT_RANDOM_FILE = 10076,
    CURLOPT_EGDSOCKET = 10077,
    CURLOPT_CONNECTTIMEOUT = 78,
    CURLOPT_HEADERFUNCTION = 20079,
    CURLOPT_HTTPGET = 80,
    CURLOPT_SSL_VERIFYHOST = 81,
    CURLOPT_COOKIEJAR = 10082,
    CURLOPT_SSL_CIPHER_LIST = 10083,
    CURLOPT_HTTP_VERSION = 84,
    CURLOPT_FTP_USE_EPSV = 85,
    CURLOPT_SSLCERTTYPE = 10086,
    CURLOPT_SSLKEY = 10087,
    CURLOPT_SSLKEYTYPE = 10088,
    CURLOPT_SSLENGINE = 10089,
    CURLOPT_SSLENGINE_DEFAULT = 90,
    CURLOPT_DNS_USE_GLOBAL_CACHE = 91,
    CURLOPT_DNS_CACHE_TIMEOUT = 92,
    CURLOPT_PREQUOTE = 10093,
    CURLOPT_DEBUGFUNCTION = 20094,
    CURLOPT_DEBUGDATA = 10095,
    CURLOPT_COOKIESESSION = 96,
    CURLOPT_CAPATH = 10097,
    CURLOPT_BUFFERSIZE = 98,
    CURLOPT_NOSIGNAL = 99,
    CURLOPT_SHARE = 10100,
    CURLOPT_PROXYTYPE = 101,
    CURLOPT_ACCEPT_ENCODING = 10102,
    CURLOPT_PRIVATE = 10103,
    CURLOPT_HTTP200ALIASES = 10104,
    CURLOPT_UNRESTRICTED_AUTH = 105,
    CURLOPT_FTP_USE_EPRT = 106,
    CURLOPT_HTTPAUTH = 107,
    CURLOPT_SSL_CTX_FUNCTION = 20108,
    CURLOPT_SSL_CTX_DATA = 10109,
    CURLOPT_FTP_CREATE_MISSING_DIRS = 110,
    CURLOPT_PROXYAUTH = 111,
    CURLOPT_FTP_RESPONSE_TIMEOUT = 112,
    CURLOPT_IPRESOLVE = 113,
    CURLOPT_MAXFILESIZE = 114,
    CURLOPT_INFILESIZE_LARGE = 30115,
    CURLOPT_RESUME_FROM_LARGE = 30116,
    CURLOPT_MAXFILESIZE_LARGE = 30117,
    CURLOPT_NETRC_FILE = 10118,
    CURLOPT_USE_SSL = 119,
    CURLOPT_POSTFIELDSIZE_LARGE = 30120,
    CURLOPT_TCP_NODELAY = 121,
    CURLOPT_FTPSSLAUTH = 129,
    CURLOPT_IOCTLFUNCTION = 20130,
    CURLOPT_IOCTLDATA = 10131,
    CURLOPT_FTP_ACCOUNT = 10134,
    CURLOPT_COOKIELIST = 10135,
    CURLOPT_IGNORE_CONTENT_LENGTH = 136,
    CURLOPT_FTP_SKIP_PASV_IP = 137,
    CURLOPT_FTP_FILEMETHOD = 138,
    CURLOPT_LOCALPORT = 139,
    CURLOPT_LOCALPORTRANGE = 140,
    CURLOPT_CONNECT_ONLY = 141,
    CURLOPT_CONV_FROM_NETWORK_FUNCTION = 20142,
    CURLOPT_CONV_TO_NETWORK_FUNCTION = 20143,
    CURLOPT_CONV_FROM_UTF8_FUNCTION = 20144,
    CURLOPT_MAX_SEND_SPEED_LARGE = 30145,
    CURLOPT_MAX_RECV_SPEED_LARGE = 30146,
    CURLOPT_FTP_ALTERNATIVE_TO_USER = 10147,
    CURLOPT_SOCKOPTFUNCTION = 20148,
    CURLOPT_SOCKOPTDATA = 10149,
    CURLOPT_SSL_SESSIONID_CACHE = 150,
    CURLOPT_SSH_AUTH_TYPES = 151,
    CURLOPT_SSH_PUBLIC_KEYFILE = 10152,
    CURLOPT_SSH_PRIVATE_KEYFILE = 10153,
    CURLOPT_FTP_SSL_CCC = 154,
    CURLOPT_TIMEOUT_MS = 155,
    CURLOPT_CONNECTTIMEOUT_MS = 156,
    CURLOPT_HTTP_TRANSFER_DECODING = 157,
    CURLOPT_HTTP_CONTENT_DECODING = 158,
    CURLOPT_NEW_FILE_PERMS = 159,
    CURLOPT_NEW_DIRECTORY_PERMS = 160,
    CURLOPT_POSTREDIR = 161,
    CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 = 10162,
    CURLOPT_OPENSOCKETFUNCTION = 20163,
    CURLOPT_OPENSOCKETDATA = 10164,
    CURLOPT_COPYPOSTFIELDS = 10165,
    CURLOPT_PROXY_TRANSFER_MODE = 166,
    CURLOPT_SEEKFUNCTION = 20167,
    CURLOPT_SEEKDATA = 10168,
    CURLOPT_CRLFILE = 10169,
    CURLOPT_ISSUERCERT = 10170,
    CURLOPT_ADDRESS_SCOPE = 171,
    CURLOPT_CERTINFO = 172,
    CURLOPT_USERNAME = 10173,
    CURLOPT_PASSWORD = 10174,
    CURLOPT_PROXYUSERNAME = 10175,
    CURLOPT_PROXYPASSWORD = 10176,
    CURLOPT_NOPROXY = 10177,
    CURLOPT_TFTP_BLKSIZE = 178,
    CURLOPT_SOCKS5_GSSAPI_SERVICE = 10179,
    CURLOPT_SOCKS5_GSSAPI_NEC = 180,
    CURLOPT_PROTOCOLS = 181,
    CURLOPT_REDIR_PROTOCOLS = 182,
    CURLOPT_SSH_KNOWNHOSTS = 10183,
    CURLOPT_SSH_KEYFUNCTION = 20184,
    CURLOPT_SSH_KEYDATA = 10185,
    CURLOPT_MAIL_FROM = 10186,
    CURLOPT_MAIL_RCPT = 10187,
    CURLOPT_FTP_USE_PRET = 188,
    CURLOPT_RTSP_REQUEST = 189,
    CURLOPT_RTSP_SESSION_ID = 10190,
    CURLOPT_RTSP_STREAM_URI = 10191,
    CURLOPT_RTSP_TRANSPORT = 10192,
    CURLOPT_RTSP_CLIENT_CSEQ = 193,
    CURLOPT_RTSP_SERVER_CSEQ = 194,
    CURLOPT_INTERLEAVEDATA = 10195,
    CURLOPT_INTERLEAVEFUNCTION = 20196,
    CURLOPT_WILDCARDMATCH = 197,
    CURLOPT_CHUNK_BGN_FUNCTION = 20198,
    CURLOPT_CHUNK_END_FUNCTION = 20199,
    CURLOPT_FNMATCH_FUNCTION = 20200,
    CURLOPT_CHUNK_DATA = 10201,
    CURLOPT_FNMATCH_DATA = 10202,
    CURLOPT_RESOLVE = 10203,
    CURLOPT_TLSAUTH_USERNAME = 10204,
    CURLOPT_TLSAUTH_PASSWORD = 10205,
    CURLOPT_TLSAUTH_TYPE = 10206,
    CURLOPT_TRANSFER_ENCODING = 207,
    CURLOPT_CLOSESOCKETFUNCTION = 20208,
    CURLOPT_CLOSESOCKETDATA = 10209,
    CURLOPT_GSSAPI_DELEGATION = 210,
    CURLOPT_DNS_SERVERS = 10211,
    CURLOPT_ACCEPTTIMEOUT_MS = 212,
    CURLOPT_TCP_KEEPALIVE = 213,
    CURLOPT_TCP_KEEPIDLE = 214,
    CURLOPT_TCP_KEEPINTVL = 215,
    CURLOPT_SSL_OPTIONS = 216,
    CURLOPT_MAIL_AUTH = 10217,
    CURLOPT_SASL_IR = 218,
    CURLOPT_XFERINFOFUNCTION = 20219,
    CURLOPT_XOAUTH2_BEARER = 10220,
    CURLOPT_DNS_INTERFACE = 10221,
    CURLOPT_DNS_LOCAL_IP4 = 10222,
    CURLOPT_DNS_LOCAL_IP6 = 10223,
    CURLOPT_LOGIN_OPTIONS = 10224,
    CURLOPT_SSL_ENABLE_NPN = 225,
    CURLOPT_SSL_ENABLE_ALPN = 226,
    CURLOPT_EXPECT_100_TIMEOUT_MS = 227,
    CURLOPT_PROXYHEADER = 10228,
    CURLOPT_HEADEROPT = 229,
    CURLOPT_PINNEDPUBLICKEY = 10230,
    CURLOPT_UNIX_SOCKET_PATH = 10231,
    CURLOPT_SSL_VERIFYSTATUS = 232,
    CURLOPT_SSL_FALSESTART = 233,
    CURLOPT_PATH_AS_IS = 234,
    CURLOPT_PROXY_SERVICE_NAME = 10235,
    CURLOPT_SERVICE_NAME = 10236,
    CURLOPT_PIPEWAIT = 237,
    CURLOPT_DEFAULT_PROTOCOL = 10238,
    CURLOPT_STREAM_WEIGHT = 239,
    CURLOPT_STREAM_DEPENDS = 10240,
    CURLOPT_STREAM_DEPENDS_E = 10241,
    CURLOPT_TFTP_NO_OPTIONS = 242,
    CURLOPT_CONNECT_TO = 10243,
    CURLOPT_TCP_FASTOPEN = 244,
    CURLOPT_KEEP_SENDING_ON_ERROR = 245,
    CURLOPT_PROXY_CAINFO = 10246,
    CURLOPT_PROXY_CAPATH = 10247,
    CURLOPT_PROXY_SSL_VERIFYPEER = 248,
    CURLOPT_PROXY_SSL_VERIFYHOST = 249,
    CURLOPT_PROXY_SSLVERSION = 250,
    CURLOPT_PROXY_TLSAUTH_USERNAME = 10251,
    CURLOPT_PROXY_TLSAUTH_PASSWORD = 10252,
    CURLOPT_PROXY_TLSAUTH_TYPE = 10253,
    CURLOPT_PROXY_SSLCERT = 10254,
    CURLOPT_PROXY_SSLCERTTYPE = 10255,
    CURLOPT_PROXY_SSLKEY = 10256,
    CURLOPT_PROXY_SSLKEYTYPE = 10257,
    CURLOPT_PROXY_KEYPASSWD = 10258,
    CURLOPT_PROXY_SSL_CIPHER_LIST = 10259,
    CURLOPT_PROXY_CRLFILE = 10260,
    CURLOPT_PROXY_SSL_OPTIONS = 261,
    CURLOPT_PRE_PROXY = 10262,
    CURLOPT_PROXY_PINNEDPUBLICKEY = 10263,
    CURLOPT_ABSTRACT_UNIX_SOCKET = 10264,
    CURLOPT_SUPPRESS_CONNECT_HEADERS = 265,
    CURLOPT_REQUEST_TARGET = 10266,
    CURLOPT_SOCKS5_AUTH = 267,
    CURLOPT_SSH_COMPRESSION = 268,
    CURLOPT_MIMEPOST = 10269,
    CURLOPT_TIMEVALUE_LARGE = 30270,
    CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS = 271,
    CURLOPT_RESOLVER_START_FUNCTION = 20272,
    CURLOPT_RESOLVER_START_DATA = 10273,
    CURLOPT_HAPROXYPROTOCOL = 274,
    CURLOPT_DNS_SHUFFLE_ADDRESSES = 275,
    CURLOPT_TLS13_CIPHERS = 10276,
    CURLOPT_PROXY_TLS13_CIPHERS = 10277,
    CURLOPT_DISALLOW_USERNAME_IN_URL = 278,
    CURLOPT_DOH_URL = 10279,
    CURLOPT_UPLOAD_BUFFERSIZE = 280,
    CURLOPT_UPKEEP_INTERVAL_MS = 281,
    CURLOPT_CURLU = 10282,
    CURLOPT_TRAILERFUNCTION = 20283,
    CURLOPT_TRAILERDATA = 10284,
    CURLOPT_HTTP09_ALLOWED = 285,
    CURLOPT_ALTSVC_CTRL = 286,
    CURLOPT_ALTSVC = 10287,
    CURLOPT_MAXAGE_CONN = 288,
    CURLOPT_SASL_AUTHZID = 10289,
    CURLOPT_LASTENTRY = 10290
} ;
typedef enum __anonenum_CURLoption_714703655 CURLoption;
enum __anonenum_CURLINFO_948637033 {
    CURLINFO_NONE = 0,
    CURLINFO_EFFECTIVE_URL = 1048577,
    CURLINFO_RESPONSE_CODE = 2097154,
    CURLINFO_TOTAL_TIME = 3145731,
    CURLINFO_NAMELOOKUP_TIME = 3145732,
    CURLINFO_CONNECT_TIME = 3145733,
    CURLINFO_PRETRANSFER_TIME = 3145734,
    CURLINFO_SIZE_UPLOAD = 3145735,
    CURLINFO_SIZE_UPLOAD_T = 6291463,
    CURLINFO_SIZE_DOWNLOAD = 3145736,
    CURLINFO_SIZE_DOWNLOAD_T = 6291464,
    CURLINFO_SPEED_DOWNLOAD = 3145737,
    CURLINFO_SPEED_DOWNLOAD_T = 6291465,
    CURLINFO_SPEED_UPLOAD = 3145738,
    CURLINFO_SPEED_UPLOAD_T = 6291466,
    CURLINFO_HEADER_SIZE = 2097163,
    CURLINFO_REQUEST_SIZE = 2097164,
    CURLINFO_SSL_VERIFYRESULT = 2097165,
    CURLINFO_FILETIME = 2097166,
    CURLINFO_FILETIME_T = 6291470,
    CURLINFO_CONTENT_LENGTH_DOWNLOAD = 3145743,
    CURLINFO_CONTENT_LENGTH_DOWNLOAD_T = 6291471,
    CURLINFO_CONTENT_LENGTH_UPLOAD = 3145744,
    CURLINFO_CONTENT_LENGTH_UPLOAD_T = 6291472,
    CURLINFO_STARTTRANSFER_TIME = 3145745,
    CURLINFO_CONTENT_TYPE = 1048594,
    CURLINFO_REDIRECT_TIME = 3145747,
    CURLINFO_REDIRECT_COUNT = 2097172,
    CURLINFO_PRIVATE = 1048597,
    CURLINFO_HTTP_CONNECTCODE = 2097174,
    CURLINFO_HTTPAUTH_AVAIL = 2097175,
    CURLINFO_PROXYAUTH_AVAIL = 2097176,
    CURLINFO_OS_ERRNO = 2097177,
    CURLINFO_NUM_CONNECTS = 2097178,
    CURLINFO_SSL_ENGINES = 4194331,
    CURLINFO_COOKIELIST = 4194332,
    CURLINFO_LASTSOCKET = 2097181,
    CURLINFO_FTP_ENTRY_PATH = 1048606,
    CURLINFO_REDIRECT_URL = 1048607,
    CURLINFO_PRIMARY_IP = 1048608,
    CURLINFO_APPCONNECT_TIME = 3145761,
    CURLINFO_CERTINFO = 4194338,
    CURLINFO_CONDITION_UNMET = 2097187,
    CURLINFO_RTSP_SESSION_ID = 1048612,
    CURLINFO_RTSP_CLIENT_CSEQ = 2097189,
    CURLINFO_RTSP_SERVER_CSEQ = 2097190,
    CURLINFO_RTSP_CSEQ_RECV = 2097191,
    CURLINFO_PRIMARY_PORT = 2097192,
    CURLINFO_LOCAL_IP = 1048617,
    CURLINFO_LOCAL_PORT = 2097194,
    CURLINFO_TLS_SESSION = 4194347,
    CURLINFO_ACTIVESOCKET = 5242924,
    CURLINFO_TLS_SSL_PTR = 4194349,
    CURLINFO_HTTP_VERSION = 2097198,
    CURLINFO_PROXY_SSL_VERIFYRESULT = 2097199,
    CURLINFO_PROTOCOL = 2097200,
    CURLINFO_SCHEME = 1048625,
    CURLINFO_TOTAL_TIME_T = 6291506,
    CURLINFO_NAMELOOKUP_TIME_T = 6291507,
    CURLINFO_CONNECT_TIME_T = 6291508,
    CURLINFO_PRETRANSFER_TIME_T = 6291509,
    CURLINFO_STARTTRANSFER_TIME_T = 6291510,
    CURLINFO_REDIRECT_TIME_T = 6291511,
    CURLINFO_APPCONNECT_TIME_T = 6291512,
    CURLINFO_RETRY_AFTER = 6291513,
    CURLINFO_LASTONE = 57
} ;
typedef enum __anonenum_CURLINFO_948637033 CURLINFO;
struct __anonstruct_GumboSourcePosition_891927932 {
   unsigned int line ;
   unsigned int column ;
   unsigned int offset ;
};
typedef struct __anonstruct_GumboSourcePosition_891927932 GumboSourcePosition;
struct __anonstruct_GumboStringPiece_673951369 {
   char const   *data ;
   size_t length ;
};
typedef struct __anonstruct_GumboStringPiece_673951369 GumboStringPiece;
struct __anonstruct_GumboVector_216886465 {
   void **data ;
   unsigned int length ;
   unsigned int capacity ;
};
typedef struct __anonstruct_GumboVector_216886465 GumboVector;
enum __anonenum_GumboTag_341509449 {
    GUMBO_TAG_HTML = 0,
    GUMBO_TAG_HEAD = 1,
    GUMBO_TAG_TITLE = 2,
    GUMBO_TAG_BASE = 3,
    GUMBO_TAG_LINK = 4,
    GUMBO_TAG_META = 5,
    GUMBO_TAG_STYLE = 6,
    GUMBO_TAG_SCRIPT = 7,
    GUMBO_TAG_NOSCRIPT = 8,
    GUMBO_TAG_TEMPLATE = 9,
    GUMBO_TAG_BODY = 10,
    GUMBO_TAG_ARTICLE = 11,
    GUMBO_TAG_SECTION = 12,
    GUMBO_TAG_NAV = 13,
    GUMBO_TAG_ASIDE = 14,
    GUMBO_TAG_H1 = 15,
    GUMBO_TAG_H2 = 16,
    GUMBO_TAG_H3 = 17,
    GUMBO_TAG_H4 = 18,
    GUMBO_TAG_H5 = 19,
    GUMBO_TAG_H6 = 20,
    GUMBO_TAG_HGROUP = 21,
    GUMBO_TAG_HEADER = 22,
    GUMBO_TAG_FOOTER = 23,
    GUMBO_TAG_ADDRESS = 24,
    GUMBO_TAG_P = 25,
    GUMBO_TAG_HR = 26,
    GUMBO_TAG_PRE = 27,
    GUMBO_TAG_BLOCKQUOTE = 28,
    GUMBO_TAG_OL = 29,
    GUMBO_TAG_UL = 30,
    GUMBO_TAG_LI = 31,
    GUMBO_TAG_DL = 32,
    GUMBO_TAG_DT = 33,
    GUMBO_TAG_DD = 34,
    GUMBO_TAG_FIGURE = 35,
    GUMBO_TAG_FIGCAPTION = 36,
    GUMBO_TAG_MAIN = 37,
    GUMBO_TAG_DIV = 38,
    GUMBO_TAG_A = 39,
    GUMBO_TAG_EM = 40,
    GUMBO_TAG_STRONG = 41,
    GUMBO_TAG_SMALL = 42,
    GUMBO_TAG_S = 43,
    GUMBO_TAG_CITE = 44,
    GUMBO_TAG_Q = 45,
    GUMBO_TAG_DFN = 46,
    GUMBO_TAG_ABBR = 47,
    GUMBO_TAG_DATA = 48,
    GUMBO_TAG_TIME = 49,
    GUMBO_TAG_CODE = 50,
    GUMBO_TAG_VAR = 51,
    GUMBO_TAG_SAMP = 52,
    GUMBO_TAG_KBD = 53,
    GUMBO_TAG_SUB = 54,
    GUMBO_TAG_SUP = 55,
    GUMBO_TAG_I = 56,
    GUMBO_TAG_B = 57,
    GUMBO_TAG_U = 58,
    GUMBO_TAG_MARK = 59,
    GUMBO_TAG_RUBY = 60,
    GUMBO_TAG_RT = 61,
    GUMBO_TAG_RP = 62,
    GUMBO_TAG_BDI = 63,
    GUMBO_TAG_BDO = 64,
    GUMBO_TAG_SPAN = 65,
    GUMBO_TAG_BR = 66,
    GUMBO_TAG_WBR = 67,
    GUMBO_TAG_INS = 68,
    GUMBO_TAG_DEL = 69,
    GUMBO_TAG_IMAGE = 70,
    GUMBO_TAG_IMG = 71,
    GUMBO_TAG_IFRAME = 72,
    GUMBO_TAG_EMBED = 73,
    GUMBO_TAG_OBJECT = 74,
    GUMBO_TAG_PARAM = 75,
    GUMBO_TAG_VIDEO = 76,
    GUMBO_TAG_AUDIO = 77,
    GUMBO_TAG_SOURCE = 78,
    GUMBO_TAG_TRACK = 79,
    GUMBO_TAG_CANVAS = 80,
    GUMBO_TAG_MAP = 81,
    GUMBO_TAG_AREA = 82,
    GUMBO_TAG_MATH = 83,
    GUMBO_TAG_MI = 84,
    GUMBO_TAG_MO = 85,
    GUMBO_TAG_MN = 86,
    GUMBO_TAG_MS = 87,
    GUMBO_TAG_MTEXT = 88,
    GUMBO_TAG_MGLYPH = 89,
    GUMBO_TAG_MALIGNMARK = 90,
    GUMBO_TAG_ANNOTATION_XML = 91,
    GUMBO_TAG_SVG = 92,
    GUMBO_TAG_FOREIGNOBJECT = 93,
    GUMBO_TAG_DESC = 94,
    GUMBO_TAG_TABLE = 95,
    GUMBO_TAG_CAPTION = 96,
    GUMBO_TAG_COLGROUP = 97,
    GUMBO_TAG_COL = 98,
    GUMBO_TAG_TBODY = 99,
    GUMBO_TAG_THEAD = 100,
    GUMBO_TAG_TFOOT = 101,
    GUMBO_TAG_TR = 102,
    GUMBO_TAG_TD = 103,
    GUMBO_TAG_TH = 104,
    GUMBO_TAG_FORM = 105,
    GUMBO_TAG_FIELDSET = 106,
    GUMBO_TAG_LEGEND = 107,
    GUMBO_TAG_LABEL = 108,
    GUMBO_TAG_INPUT = 109,
    GUMBO_TAG_BUTTON = 110,
    GUMBO_TAG_SELECT = 111,
    GUMBO_TAG_DATALIST = 112,
    GUMBO_TAG_OPTGROUP = 113,
    GUMBO_TAG_OPTION = 114,
    GUMBO_TAG_TEXTAREA = 115,
    GUMBO_TAG_KEYGEN = 116,
    GUMBO_TAG_OUTPUT = 117,
    GUMBO_TAG_PROGRESS = 118,
    GUMBO_TAG_METER = 119,
    GUMBO_TAG_DETAILS = 120,
    GUMBO_TAG_SUMMARY = 121,
    GUMBO_TAG_MENU = 122,
    GUMBO_TAG_MENUITEM = 123,
    GUMBO_TAG_APPLET = 124,
    GUMBO_TAG_ACRONYM = 125,
    GUMBO_TAG_BGSOUND = 126,
    GUMBO_TAG_DIR = 127,
    GUMBO_TAG_FRAME = 128,
    GUMBO_TAG_FRAMESET = 129,
    GUMBO_TAG_NOFRAMES = 130,
    GUMBO_TAG_ISINDEX = 131,
    GUMBO_TAG_LISTING = 132,
    GUMBO_TAG_XMP = 133,
    GUMBO_TAG_NEXTID = 134,
    GUMBO_TAG_NOEMBED = 135,
    GUMBO_TAG_PLAINTEXT = 136,
    GUMBO_TAG_RB = 137,
    GUMBO_TAG_STRIKE = 138,
    GUMBO_TAG_BASEFONT = 139,
    GUMBO_TAG_BIG = 140,
    GUMBO_TAG_BLINK = 141,
    GUMBO_TAG_CENTER = 142,
    GUMBO_TAG_FONT = 143,
    GUMBO_TAG_MARQUEE = 144,
    GUMBO_TAG_MULTICOL = 145,
    GUMBO_TAG_NOBR = 146,
    GUMBO_TAG_SPACER = 147,
    GUMBO_TAG_TT = 148,
    GUMBO_TAG_UNKNOWN = 149,
    GUMBO_TAG_LAST = 150
} ;
typedef enum __anonenum_GumboTag_341509449 GumboTag;
enum __anonenum_GumboNodeType_685978054 {
    GUMBO_NODE_DOCUMENT = 0,
    GUMBO_NODE_ELEMENT = 1,
    GUMBO_NODE_TEXT = 2,
    GUMBO_NODE_CDATA = 3,
    GUMBO_NODE_COMMENT = 4,
    GUMBO_NODE_WHITESPACE = 5
} ;
typedef enum __anonenum_GumboNodeType_685978054 GumboNodeType;
struct GumboInternalNode ;
typedef struct GumboInternalNode GumboNode;
enum __anonenum_GumboQuirksModeEnum_135775851 {
    GUMBO_DOCTYPE_NO_QUIRKS = 0,
    GUMBO_DOCTYPE_QUIRKS = 1,
    GUMBO_DOCTYPE_LIMITED_QUIRKS = 2
} ;
typedef enum __anonenum_GumboQuirksModeEnum_135775851 GumboQuirksModeEnum;
enum __anonenum_GumboNamespaceEnum_690435942 {
    GUMBO_NAMESPACE_HTML = 0,
    GUMBO_NAMESPACE_SVG = 1,
    GUMBO_NAMESPACE_MATHML = 2
} ;
typedef enum __anonenum_GumboNamespaceEnum_690435942 GumboNamespaceEnum;
enum __anonenum_GumboParseFlags_984900602 {
    GUMBO_INSERTION_NORMAL = 0,
    GUMBO_INSERTION_BY_PARSER = 1,
    GUMBO_INSERTION_IMPLICIT_END_TAG = 2,
    GUMBO_INSERTION_IMPLIED = 8,
    GUMBO_INSERTION_CONVERTED_FROM_END_TAG = 16,
    GUMBO_INSERTION_FROM_ISINDEX = 32,
    GUMBO_INSERTION_FROM_IMAGE = 64,
    GUMBO_INSERTION_RECONSTRUCTED_FORMATTING_ELEMENT = 128,
    GUMBO_INSERTION_ADOPTION_AGENCY_CLONED = 256,
    GUMBO_INSERTION_ADOPTION_AGENCY_MOVED = 512,
    GUMBO_INSERTION_FOSTER_PARENTED = 1024
} ;
typedef enum __anonenum_GumboParseFlags_984900602 GumboParseFlags;
struct __anonstruct_GumboDocument_1013988508 {
   GumboVector children ;
   _Bool has_doctype ;
   char const   *name ;
   char const   *public_identifier ;
   char const   *system_identifier ;
   GumboQuirksModeEnum doc_type_quirks_mode ;
};
typedef struct __anonstruct_GumboDocument_1013988508 GumboDocument;
struct __anonstruct_GumboText_318129021 {
   char const   *text ;
   GumboStringPiece original_text ;
   GumboSourcePosition start_pos ;
};
typedef struct __anonstruct_GumboText_318129021 GumboText;
struct __anonstruct_GumboElement_456828804 {
   GumboVector children ;
   GumboTag tag ;
   GumboNamespaceEnum tag_namespace ;
   GumboStringPiece original_tag ;
   GumboStringPiece original_end_tag ;
   GumboSourcePosition start_pos ;
   GumboSourcePosition end_pos ;
   GumboVector attributes ;
};
typedef struct __anonstruct_GumboElement_456828804 GumboElement;
union __anonunion_v_889275138 {
   GumboDocument document ;
   GumboElement element ;
   GumboText text ;
};
struct GumboInternalNode {
   GumboNodeType type ;
   GumboNode *parent ;
   size_t index_within_parent ;
   GumboParseFlags parse_flags ;
   union __anonunion_v_889275138 v ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef long __clock_t;
typedef __gnuc_va_list va_list___0;
typedef __clock_t clock_t;
struct GumboInternalOptions {
   void *(*allocator)(void *userdata , size_t size ) ;
   void (*deallocator)(void *userdata , void *ptr ) ;
   void *userdata ;
   int tab_stop ;
   _Bool stop_on_first_error ;
   int max_errors ;
};
typedef struct GumboInternalOptions GumboOptions;
struct GumboInternalOutput {
   GumboNode *document ;
   GumboNode *root ;
   GumboVector errors ;
};
typedef struct GumboInternalOutput GumboOutput;
struct __anonstruct_wiki_package_t_343724373 {
   char *repo ;
   char *href ;
   char *description ;
   char *category ;
};
typedef struct __anonstruct_wiki_package_t_343724373 wiki_package_t;
typedef __off_t off_t;
typedef __gid_t gid_t;
typedef __uid_t uid_t;
struct GumboInternalParser ;
enum __anonenum_GumboAttributeNamespaceEnum_553922390 {
    GUMBO_ATTR_NAMESPACE_NONE = 0,
    GUMBO_ATTR_NAMESPACE_XLINK = 1,
    GUMBO_ATTR_NAMESPACE_XML = 2,
    GUMBO_ATTR_NAMESPACE_XMLNS = 3
} ;
typedef enum __anonenum_GumboAttributeNamespaceEnum_553922390 GumboAttributeNamespaceEnum;
struct __anonstruct_GumboAttribute_303260898 {
   GumboAttributeNamespaceEnum attr_namespace ;
   char const   *name ;
   GumboStringPiece original_name ;
   char const   *value ;
   GumboStringPiece original_value ;
   GumboSourcePosition name_start ;
   GumboSourcePosition name_end ;
   GumboSourcePosition value_start ;
   GumboSourcePosition value_end ;
};
typedef struct __anonstruct_GumboAttribute_303260898 GumboAttribute;
struct GumboInternalParserState ;
struct GumboInternalTokenizerState ;
struct GumboInternalParser {
   struct GumboInternalOptions  const  *_options ;
   struct GumboInternalOutput *_output ;
   struct GumboInternalTokenizerState *_tokenizer_state ;
   struct GumboInternalParserState *_parser_state ;
};
typedef unsigned long __uint64_t;
typedef __builtin_va_list va_list;
typedef __uint64_t uint64_t;
enum __anonenum_GumboInsertionMode_448368103 {
    GUMBO_INSERTION_MODE_INITIAL = 0,
    GUMBO_INSERTION_MODE_BEFORE_HTML = 1,
    GUMBO_INSERTION_MODE_BEFORE_HEAD = 2,
    GUMBO_INSERTION_MODE_IN_HEAD = 3,
    GUMBO_INSERTION_MODE_IN_HEAD_NOSCRIPT = 4,
    GUMBO_INSERTION_MODE_AFTER_HEAD = 5,
    GUMBO_INSERTION_MODE_IN_BODY = 6,
    GUMBO_INSERTION_MODE_TEXT = 7,
    GUMBO_INSERTION_MODE_IN_TABLE = 8,
    GUMBO_INSERTION_MODE_IN_TABLE_TEXT = 9,
    GUMBO_INSERTION_MODE_IN_CAPTION = 10,
    GUMBO_INSERTION_MODE_IN_COLUMN_GROUP = 11,
    GUMBO_INSERTION_MODE_IN_TABLE_BODY = 12,
    GUMBO_INSERTION_MODE_IN_ROW = 13,
    GUMBO_INSERTION_MODE_IN_CELL = 14,
    GUMBO_INSERTION_MODE_IN_SELECT = 15,
    GUMBO_INSERTION_MODE_IN_SELECT_IN_TABLE = 16,
    GUMBO_INSERTION_MODE_IN_TEMPLATE = 17,
    GUMBO_INSERTION_MODE_AFTER_BODY = 18,
    GUMBO_INSERTION_MODE_IN_FRAMESET = 19,
    GUMBO_INSERTION_MODE_AFTER_FRAMESET = 20,
    GUMBO_INSERTION_MODE_AFTER_AFTER_BODY = 21,
    GUMBO_INSERTION_MODE_AFTER_AFTER_FRAMESET = 22
} ;
typedef enum __anonenum_GumboInsertionMode_448368103 GumboInsertionMode;
struct __anonstruct_GumboStringBuffer_483684869 {
   char *data ;
   size_t length ;
   size_t capacity ;
};
typedef struct __anonstruct_GumboStringBuffer_483684869 GumboStringBuffer;
enum __anonenum_GumboTokenType_789931907 {
    GUMBO_TOKEN_DOCTYPE = 0,
    GUMBO_TOKEN_START_TAG = 1,
    GUMBO_TOKEN_END_TAG = 2,
    GUMBO_TOKEN_COMMENT = 3,
    GUMBO_TOKEN_WHITESPACE = 4,
    GUMBO_TOKEN_CHARACTER = 5,
    GUMBO_TOKEN_NULL = 6,
    GUMBO_TOKEN_EOF = 7
} ;
typedef enum __anonenum_GumboTokenType_789931907 GumboTokenType;
enum __anonenum_GumboErrorType_322425127 {
    GUMBO_ERR_UTF8_INVALID = 0,
    GUMBO_ERR_UTF8_TRUNCATED = 1,
    GUMBO_ERR_UTF8_NULL = 2,
    GUMBO_ERR_NUMERIC_CHAR_REF_NO_DIGITS = 3,
    GUMBO_ERR_NUMERIC_CHAR_REF_WITHOUT_SEMICOLON = 4,
    GUMBO_ERR_NUMERIC_CHAR_REF_INVALID = 5,
    GUMBO_ERR_NAMED_CHAR_REF_WITHOUT_SEMICOLON = 6,
    GUMBO_ERR_NAMED_CHAR_REF_INVALID = 7,
    GUMBO_ERR_TAG_STARTS_WITH_QUESTION = 8,
    GUMBO_ERR_TAG_EOF = 9,
    GUMBO_ERR_TAG_INVALID = 10,
    GUMBO_ERR_CLOSE_TAG_EMPTY = 11,
    GUMBO_ERR_CLOSE_TAG_EOF = 12,
    GUMBO_ERR_CLOSE_TAG_INVALID = 13,
    GUMBO_ERR_SCRIPT_EOF = 14,
    GUMBO_ERR_ATTR_NAME_EOF = 15,
    GUMBO_ERR_ATTR_NAME_INVALID = 16,
    GUMBO_ERR_ATTR_DOUBLE_QUOTE_EOF = 17,
    GUMBO_ERR_ATTR_SINGLE_QUOTE_EOF = 18,
    GUMBO_ERR_ATTR_UNQUOTED_EOF = 19,
    GUMBO_ERR_ATTR_UNQUOTED_RIGHT_BRACKET = 20,
    GUMBO_ERR_ATTR_UNQUOTED_EQUALS = 21,
    GUMBO_ERR_ATTR_AFTER_EOF = 22,
    GUMBO_ERR_ATTR_AFTER_INVALID = 23,
    GUMBO_ERR_DUPLICATE_ATTR = 24,
    GUMBO_ERR_SOLIDUS_EOF = 25,
    GUMBO_ERR_SOLIDUS_INVALID = 26,
    GUMBO_ERR_DASHES_OR_DOCTYPE = 27,
    GUMBO_ERR_COMMENT_EOF = 28,
    GUMBO_ERR_COMMENT_INVALID = 29,
    GUMBO_ERR_COMMENT_BANG_AFTER_DOUBLE_DASH = 30,
    GUMBO_ERR_COMMENT_DASH_AFTER_DOUBLE_DASH = 31,
    GUMBO_ERR_COMMENT_SPACE_AFTER_DOUBLE_DASH = 32,
    GUMBO_ERR_COMMENT_END_BANG_EOF = 33,
    GUMBO_ERR_DOCTYPE_EOF = 34,
    GUMBO_ERR_DOCTYPE_INVALID = 35,
    GUMBO_ERR_DOCTYPE_SPACE = 36,
    GUMBO_ERR_DOCTYPE_RIGHT_BRACKET = 37,
    GUMBO_ERR_DOCTYPE_SPACE_OR_RIGHT_BRACKET = 38,
    GUMBO_ERR_DOCTYPE_END = 39,
    GUMBO_ERR_PARSER = 40,
    GUMBO_ERR_UNACKNOWLEDGED_SELF_CLOSING_TAG = 41
} ;
typedef enum __anonenum_GumboErrorType_322425127 GumboErrorType;
struct GumboInternalDuplicateAttrError {
   char const   *name ;
   unsigned int original_index ;
   unsigned int new_index ;
};
typedef struct GumboInternalDuplicateAttrError GumboDuplicateAttrError;
enum __anonenum_GumboTokenizerErrorState_429635956 {
    GUMBO_ERR_TOKENIZER_DATA = 0,
    GUMBO_ERR_TOKENIZER_CHAR_REF = 1,
    GUMBO_ERR_TOKENIZER_RCDATA = 2,
    GUMBO_ERR_TOKENIZER_RAWTEXT = 3,
    GUMBO_ERR_TOKENIZER_PLAINTEXT = 4,
    GUMBO_ERR_TOKENIZER_SCRIPT = 5,
    GUMBO_ERR_TOKENIZER_TAG = 6,
    GUMBO_ERR_TOKENIZER_SELF_CLOSING_TAG = 7,
    GUMBO_ERR_TOKENIZER_ATTR_NAME = 8,
    GUMBO_ERR_TOKENIZER_ATTR_VALUE = 9,
    GUMBO_ERR_TOKENIZER_MARKUP_DECLARATION = 10,
    GUMBO_ERR_TOKENIZER_COMMENT = 11,
    GUMBO_ERR_TOKENIZER_DOCTYPE = 12,
    GUMBO_ERR_TOKENIZER_CDATA = 13
} ;
typedef enum __anonenum_GumboTokenizerErrorState_429635956 GumboTokenizerErrorState;
struct GumboInternalTokenizerError {
   int codepoint ;
   GumboTokenizerErrorState state ;
};
typedef struct GumboInternalTokenizerError GumboTokenizerError;
struct GumboInternalParserError {
   GumboTokenType input_type ;
   GumboTag input_tag ;
   GumboInsertionMode parser_state ;
   GumboVector tag_stack ;
};
typedef struct GumboInternalParserError GumboParserError;
union __anonunion_v_15840015 {
   uint64_t codepoint ;
   GumboTokenizerError tokenizer ;
   GumboStringPiece text ;
   GumboDuplicateAttrError duplicate_attr ;
   struct GumboInternalParserError parser ;
};
struct GumboInternalError {
   GumboErrorType type ;
   GumboSourcePosition position ;
   char const   *original_text ;
   union __anonunion_v_15840015 v ;
};
typedef struct GumboInternalError GumboError;
typedef struct GumboInternalParser GumboParser;
enum __anonenum_GumboTokenizerEnum_1043861041 {
    GUMBO_LEX_DATA = 0,
    GUMBO_LEX_CHAR_REF_IN_DATA = 1,
    GUMBO_LEX_RCDATA = 2,
    GUMBO_LEX_CHAR_REF_IN_RCDATA = 3,
    GUMBO_LEX_RAWTEXT = 4,
    GUMBO_LEX_SCRIPT = 5,
    GUMBO_LEX_PLAINTEXT = 6,
    GUMBO_LEX_TAG_OPEN = 7,
    GUMBO_LEX_END_TAG_OPEN = 8,
    GUMBO_LEX_TAG_NAME = 9,
    GUMBO_LEX_RCDATA_LT = 10,
    GUMBO_LEX_RCDATA_END_TAG_OPEN = 11,
    GUMBO_LEX_RCDATA_END_TAG_NAME = 12,
    GUMBO_LEX_RAWTEXT_LT = 13,
    GUMBO_LEX_RAWTEXT_END_TAG_OPEN = 14,
    GUMBO_LEX_RAWTEXT_END_TAG_NAME = 15,
    GUMBO_LEX_SCRIPT_LT = 16,
    GUMBO_LEX_SCRIPT_END_TAG_OPEN = 17,
    GUMBO_LEX_SCRIPT_END_TAG_NAME = 18,
    GUMBO_LEX_SCRIPT_ESCAPED_START = 19,
    GUMBO_LEX_SCRIPT_ESCAPED_START_DASH = 20,
    GUMBO_LEX_SCRIPT_ESCAPED = 21,
    GUMBO_LEX_SCRIPT_ESCAPED_DASH = 22,
    GUMBO_LEX_SCRIPT_ESCAPED_DASH_DASH = 23,
    GUMBO_LEX_SCRIPT_ESCAPED_LT = 24,
    GUMBO_LEX_SCRIPT_ESCAPED_END_TAG_OPEN = 25,
    GUMBO_LEX_SCRIPT_ESCAPED_END_TAG_NAME = 26,
    GUMBO_LEX_SCRIPT_DOUBLE_ESCAPED_START = 27,
    GUMBO_LEX_SCRIPT_DOUBLE_ESCAPED = 28,
    GUMBO_LEX_SCRIPT_DOUBLE_ESCAPED_DASH = 29,
    GUMBO_LEX_SCRIPT_DOUBLE_ESCAPED_DASH_DASH = 30,
    GUMBO_LEX_SCRIPT_DOUBLE_ESCAPED_LT = 31,
    GUMBO_LEX_SCRIPT_DOUBLE_ESCAPED_END = 32,
    GUMBO_LEX_BEFORE_ATTR_NAME = 33,
    GUMBO_LEX_ATTR_NAME = 34,
    GUMBO_LEX_AFTER_ATTR_NAME = 35,
    GUMBO_LEX_BEFORE_ATTR_VALUE = 36,
    GUMBO_LEX_ATTR_VALUE_DOUBLE_QUOTED = 37,
    GUMBO_LEX_ATTR_VALUE_SINGLE_QUOTED = 38,
    GUMBO_LEX_ATTR_VALUE_UNQUOTED = 39,
    GUMBO_LEX_CHAR_REF_IN_ATTR_VALUE = 40,
    GUMBO_LEX_AFTER_ATTR_VALUE_QUOTED = 41,
    GUMBO_LEX_SELF_CLOSING_START_TAG = 42,
    GUMBO_LEX_BOGUS_COMMENT = 43,
    GUMBO_LEX_MARKUP_DECLARATION = 44,
    GUMBO_LEX_COMMENT_START = 45,
    GUMBO_LEX_COMMENT_START_DASH = 46,
    GUMBO_LEX_COMMENT = 47,
    GUMBO_LEX_COMMENT_END_DASH = 48,
    GUMBO_LEX_COMMENT_END = 49,
    GUMBO_LEX_COMMENT_END_BANG = 50,
    GUMBO_LEX_DOCTYPE = 51,
    GUMBO_LEX_BEFORE_DOCTYPE_NAME = 52,
    GUMBO_LEX_DOCTYPE_NAME = 53,
    GUMBO_LEX_AFTER_DOCTYPE_NAME = 54,
    GUMBO_LEX_AFTER_DOCTYPE_PUBLIC_KEYWORD = 55,
    GUMBO_LEX_BEFORE_DOCTYPE_PUBLIC_ID = 56,
    GUMBO_LEX_DOCTYPE_PUBLIC_ID_DOUBLE_QUOTED = 57,
    GUMBO_LEX_DOCTYPE_PUBLIC_ID_SINGLE_QUOTED = 58,
    GUMBO_LEX_AFTER_DOCTYPE_PUBLIC_ID = 59,
    GUMBO_LEX_BETWEEN_DOCTYPE_PUBLIC_SYSTEM_ID = 60,
    GUMBO_LEX_AFTER_DOCTYPE_SYSTEM_KEYWORD = 61,
    GUMBO_LEX_BEFORE_DOCTYPE_SYSTEM_ID = 62,
    GUMBO_LEX_DOCTYPE_SYSTEM_ID_DOUBLE_QUOTED = 63,
    GUMBO_LEX_DOCTYPE_SYSTEM_ID_SINGLE_QUOTED = 64,
    GUMBO_LEX_AFTER_DOCTYPE_SYSTEM_ID = 65,
    GUMBO_LEX_BOGUS_DOCTYPE = 66,
    GUMBO_LEX_CDATA = 67
} ;
typedef enum __anonenum_GumboTokenizerEnum_1043861041 GumboTokenizerEnum;
struct GumboInternalTokenDocType {
   char const   *name ;
   char const   *public_identifier ;
   char const   *system_identifier ;
   _Bool force_quirks ;
   _Bool has_public_identifier ;
   _Bool has_system_identifier ;
};
typedef struct GumboInternalTokenDocType GumboTokenDocType;
struct GumboInternalTokenStartTag {
   GumboTag tag ;
   GumboVector attributes ;
   _Bool is_self_closing ;
};
typedef struct GumboInternalTokenStartTag GumboTokenStartTag;
union __anonunion_v_147506068 {
   GumboTokenDocType doc_type ;
   GumboTokenStartTag start_tag ;
   GumboTag end_tag ;
   char const   *text ;
   int character ;
};
struct GumboInternalToken {
   GumboTokenType type ;
   GumboSourcePosition position ;
   GumboStringPiece original_text ;
   union __anonunion_v_147506068 v ;
};
typedef struct GumboInternalToken GumboToken;
struct _ReplacementEntry {
   GumboStringPiece const   from ;
   GumboStringPiece const   to ;
};
typedef struct _ReplacementEntry ReplacementEntry;
struct _NamespacedAttributeReplacement {
   char const   *from ;
   char const   *local_name ;
   GumboAttributeNamespaceEnum const   attr_namespace ;
};
typedef struct _NamespacedAttributeReplacement NamespacedAttributeReplacement;
struct _TextNodeBufferState {
   GumboStringBuffer _buffer ;
   char const   *_start_original_text ;
   GumboSourcePosition _start_position ;
   GumboNodeType _type ;
};
typedef struct _TextNodeBufferState TextNodeBufferState;
struct GumboInternalParserState {
   GumboInsertionMode _insertion_mode ;
   GumboInsertionMode _original_insertion_mode ;
   GumboVector _open_elements ;
   GumboVector _active_formatting_elements ;
   GumboVector _template_insertion_modes ;
   GumboNode *_head_element ;
   GumboNode *_form_element ;
   _Bool _reprocess_current_token ;
   _Bool _self_closing_flag_acknowledged ;
   _Bool _frameset_ok ;
   _Bool _ignore_next_linefeed ;
   _Bool _foster_parent_insertions ;
   TextNodeBufferState _text_node ;
   GumboToken *_current_token ;
   _Bool _closed_body_tag ;
   _Bool _closed_html_tag ;
};
typedef struct GumboInternalParserState GumboParserState;
typedef _Bool (*TokenHandler)(GumboParser *parser , GumboToken *token );
struct GumboInternalUtf8Iterator {
   char const   *_start ;
   char const   *_mark ;
   char const   *_end ;
   int _current ;
   int _width ;
   GumboSourcePosition _pos ;
   GumboSourcePosition _mark_pos ;
   struct GumboInternalParser *_parser ;
};
typedef struct GumboInternalUtf8Iterator Utf8Iterator;
struct __anonstruct_OneOrTwoCodepoints_773697287 {
   int first ;
   int second ;
};
typedef struct __anonstruct_OneOrTwoCodepoints_773697287 OneOrTwoCodepoints;
struct __anonstruct_NamedCharRef_549011883 {
   char const   *name ;
   size_t length ;
   OneOrTwoCodepoints codepoints ;
};
typedef struct __anonstruct_NamedCharRef_549011883 NamedCharRef;
struct __anonstruct_CharReplacement_1013988509 {
   int from_char ;
   int to_char ;
};
typedef struct __anonstruct_CharReplacement_1013988509 CharReplacement;
enum __anonenum_StateResult_162585644 {
    RETURN_ERROR = 0,
    RETURN_SUCCESS = 1,
    NEXT_CHAR = 2
} ;
typedef enum __anonenum_StateResult_162585644 StateResult;
struct GumboInternalTagState {
   GumboStringBuffer _buffer ;
   char const   *_original_text ;
   GumboTag _tag ;
   GumboSourcePosition _start_pos ;
   GumboVector _attributes ;
   _Bool _drop_next_attr_value ;
   GumboTokenizerEnum _attr_value_state ;
   GumboTag _last_start_tag ;
   _Bool _is_start_tag ;
   _Bool _is_self_closing ;
};
typedef struct GumboInternalTagState GumboTagState;
struct GumboInternalTokenizerState {
   GumboTokenizerEnum _state ;
   _Bool _reconsume_current_input ;
   _Bool _is_current_node_foreign ;
   int _buffered_emit_char ;
   GumboStringBuffer _temporary_buffer ;
   char const   *_temporary_buffer_emit ;
   GumboStringBuffer _script_data_buffer ;
   char const   *_token_start ;
   GumboSourcePosition _token_start_pos ;
   GumboTagState _tag_state ;
   GumboTokenDocType _doc_type_state ;
   Utf8Iterator _input ;
};
typedef struct GumboInternalTokenizerState GumboTokenizerState;
typedef StateResult (*GumboLexerStateFunction)(GumboParser * , GumboTokenizerState * ,
                                               int  , GumboToken * );
struct __anonstruct_text_nodes_t_1013988509 {
   char const   *nodes[1024] ;
   size_t length ;
};
typedef struct __anonstruct_text_nodes_t_1013988509 text_nodes_t;
#pragma merger("0","/tmp/cil-x711bYbC.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
int clib_cache_init(time_t exp ) ;
int clib_cache_meta_init(void) ;
char const   *clib_cache_meta_dir(void) ;
char const   *clib_cache_dir(void) ;
int clib_cache_has_json(char *author , char *name , char *version ) ;
char *clib_cache_read_json(char *author , char *name , char *version ) ;
int clib_cache_save_json(char *author , char *name , char *version , char *content ) ;
int clib_cache_delete_json(char *author , char *name , char *version ) ;
int clib_cache_has_search(void) ;
char *clib_cache_read_search(void) ;
int clib_cache_save_search(char *content ) ;
int clib_cache_delete_search(void) ;
int clib_cache_has_package(char *author , char *name , char *version ) ;
int clib_cache_is_expired_package(char *author , char *name , char *version ) ;
int clib_cache_load_package(char *author , char *name , char *version , char *target_dir ) ;
int clib_cache_save_package(char *author , char *name , char *version , char *pkg_dir ) ;
int clib_cache_delete_package(char *author , char *name , char *version ) ;
int copy_dir(char *dir_path , char *target_dir ) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
fs_stats *fs_stat(char const   *path ) ;
char *fs_read(char const   *path ) ;
int fs_write(char const   *path , char const   *buffer ) ;
int fs_exists(char const   *path ) ;
int rimraf(char const   *path ) ;
int mkdirp(char const   *path , mode_t mode ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
static char package_cache_dir[8192]  ;
static char search_cache[8192]  ;
static char json_cache_dir[8192]  ;
static char meta_cache_dir[8192]  ;
static time_t expiration  ;
static void json_cache_path(char *pkg_cache , char *author , char *name , char *version ) 
{ 


  {
  sprintf((char * __restrict  )pkg_cache, (char const   * __restrict  )"%s/%s_%s_%s.json",
          json_cache_dir, author, name, version);
  return;
}
}
static void package_cache_path(char *json_cache , char *author , char *name , char *version ) 
{ 


  {
  sprintf((char * __restrict  )json_cache, (char const   * __restrict  )"%s/%s_%s_%s",
          package_cache_dir, author, name, version);
  return;
}
}
char const   *clib_cache_dir(void) 
{ 


  {
  return ((char const   *)(package_cache_dir));
}
}
static int check_dir(char *dir ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = fs_exists((char const   *)dir);
  if (0 != tmp___0) {
    tmp = mkdirp((char const   *)dir, (mode_t )448);
    return (tmp);
  }
  return (0);
}
}
int clib_cache_meta_init(void) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  tmp = getenv("HOME");
  sprintf((char * __restrict  )(meta_cache_dir), (char const   * __restrict  )"%s/.cache/clib/meta",
          tmp);
  tmp___0 = check_dir(meta_cache_dir);
  if (0 != tmp___0) {
    return (-1);
  }
  return (0);
}
}
char const   *clib_cache_meta_dir(void) 
{ 


  {
  return ((char const   *)(meta_cache_dir));
}
}
int clib_cache_init(time_t exp ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  expiration = exp;
  tmp = getenv("HOME");
  sprintf((char * __restrict  )(package_cache_dir), (char const   * __restrict  )"%s/.cache/clib/packages",
          tmp);
  tmp___0 = getenv("HOME");
  sprintf((char * __restrict  )(json_cache_dir), (char const   * __restrict  )"%s/.cache/clib/json",
          tmp___0);
  tmp___1 = getenv("HOME");
  sprintf((char * __restrict  )(search_cache), (char const   * __restrict  )"%s/.cache/clib/search.html",
          tmp___1);
  tmp___2 = check_dir(package_cache_dir);
  if (0 != tmp___2) {
    return (-1);
  }
  tmp___3 = check_dir(json_cache_dir);
  if (0 != tmp___3) {
    return (-1);
  }
  return (0);
}
}
static int is_expired(char *cache ) 
{ 
  fs_stats *stat___0 ;
  fs_stats *tmp ;
  time_t modified ;
  time_t now ;
  time_t tmp___0 ;

  {
  tmp = fs_stat((char const   *)cache);
  stat___0 = tmp;
  if (! stat___0) {
    return (-1);
  }
  modified = stat___0->st_mtim.tv_sec;
  tmp___0 = time((time_t *)((void *)0));
  now = tmp___0;
  free((void *)stat___0);
  return (now - modified >= expiration);
}
}
int clib_cache_has_json(char *author , char *name , char *version ) 
{ 
  char json_cache[8192] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  json_cache_path(json_cache, author, name, version);
  tmp = fs_exists((char const   *)(json_cache));
  if (0 == tmp) {
    tmp___0 = is_expired(json_cache);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
char *clib_cache_read_json(char *author , char *name , char *version ) 
{ 
  char json_cache[8192] ;
  int tmp ;
  char *tmp___0 ;

  {
  json_cache_path(json_cache, author, name, version);
  tmp = is_expired(json_cache);
  if (tmp) {
    return ((char *)((void *)0));
  }
  tmp___0 = fs_read((char const   *)(json_cache));
  return (tmp___0);
}
}
int clib_cache_save_json(char *author , char *name , char *version , char *content ) 
{ 
  char json_cache[8192] ;
  int tmp ;

  {
  json_cache_path(json_cache, author, name, version);
  tmp = fs_write((char const   *)(json_cache), (char const   *)content);
  return (tmp);
}
}
int clib_cache_delete_json(char *author , char *name , char *version ) 
{ 
  char json_cache[8192] ;
  int tmp ;

  {
  json_cache_path(json_cache, author, name, version);
  tmp = unlink((char const   *)(json_cache));
  return (tmp);
}
}
int clib_cache_has_search(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = fs_exists((char const   *)(search_cache));
  if (0 == tmp) {
    tmp___0 = is_expired(search_cache);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
char *clib_cache_read_search(void) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
  tmp = clib_cache_has_search();
  if (! tmp) {
    return ((char *)((void *)0));
  }
  tmp___0 = fs_read((char const   *)(search_cache));
  return (tmp___0);
}
}
int clib_cache_save_search(char *content ) 
{ 
  int tmp ;

  {
  tmp = fs_write((char const   *)(search_cache), (char const   *)content);
  return (tmp);
}
}
int clib_cache_delete_search(void) 
{ 
  int tmp ;

  {
  tmp = unlink((char const   *)(search_cache));
  return (tmp);
}
}
int clib_cache_has_package(char *author , char *name , char *version ) 
{ 
  char pkg_cache[8192] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  package_cache_path(pkg_cache, author, name, version);
  tmp = fs_exists((char const   *)(pkg_cache));
  if (0 == tmp) {
    tmp___0 = is_expired(pkg_cache);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
int clib_cache_is_expired_package(char *author , char *name , char *version ) 
{ 
  char pkg_cache[8192] ;
  int tmp ;

  {
  package_cache_path(pkg_cache, author, name, version);
  tmp = is_expired(pkg_cache);
  return (tmp);
}
}
int clib_cache_save_package(char *author , char *name , char *version , char *pkg_dir ) 
{ 
  char pkg_cache[8192] ;
  int tmp ;
  int tmp___0 ;

  {
  package_cache_path(pkg_cache, author, name, version);
  tmp = fs_exists((char const   *)(pkg_cache));
  if (0 == tmp) {
    rimraf((char const   *)(pkg_cache));
  }
  tmp___0 = copy_dir(pkg_dir, pkg_cache);
  return (tmp___0);
}
}
int clib_cache_load_package(char *author , char *name , char *version , char *target_dir ) 
{ 
  char pkg_cache[8192] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  package_cache_path(pkg_cache, author, name, version);
  tmp = fs_exists((char const   *)(pkg_cache));
  if (-1 == tmp) {
    return (-1);
  }
  tmp___0 = is_expired(pkg_cache);
  if (tmp___0) {
    rimraf((char const   *)(pkg_cache));
    return (-2);
  }
  tmp___1 = copy_dir(pkg_cache, target_dir);
  return (tmp___1);
}
}
int clib_cache_delete_package(char *author , char *name , char *version ) 
{ 
  char pkg_cache[8192] ;
  int tmp ;

  {
  package_cache_path(pkg_cache, author, name, version);
  tmp = rimraf((char const   *)(pkg_cache));
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-cryEFeT5.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
int asprintf(char **str , char const   *fmt  , ...) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) setenv)(char const   *__name ,
                                                                                   char const   *__value ,
                                                                                   int __replace ) ;
extern int system(char const   *__command ) ;
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
list_node_t *list_node_new(void *val ) ;
list_t *list_new(void) ;
list_node_t *list_rpush(list_t *self , list_node_t *node ) ;
void list_destroy(list_t *self ) ;
list_iterator_t *list_iterator_new(list_t *list , list_direction_t direction ) ;
list_node_t *list_iterator_next(list_iterator_t *self ) ;
void list_iterator_destroy(list_iterator_t *self ) ;
extern FILE *stdout ;
extern FILE *stderr ;
extern int fflush(FILE *__stream ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern CURLSH *curl_share_init(void) ;
extern CURLSHcode curl_share_setopt(CURLSH * , CURLSHoption option  , ...) ;
extern CURLSHcode curl_share_cleanup(CURLSH * ) ;
CURLSH *clib_package_curl_share  ;
void clib_package_set_opts(clib_package_opts_t o ) ;
clib_package_t *clib_package_new(char const   *json , int verbose ) ;
clib_package_t *clib_package_new_from_slug(char const   *slug , int verbose ) ;
clib_package_t *clib_package_load_from_manifest(char const   *manifest , int verbose ) ;
clib_package_t *clib_package_load_local_manifest(int verbose ) ;
char *clib_package_url(char const   *author , char const   *name , char const   *version ) ;
char *clib_package_url_from_repo(char const   *repo , char const   *version ) ;
char *clib_package_parse_version(char const   *slug ) ;
char *clib_package_parse_author(char const   *slug ) ;
char *clib_package_parse_name(char const   *slug ) ;
clib_package_dependency_t *clib_package_dependency_new(char const   *repo , char const   *version ) ;
int clib_package_install_executable(clib_package_t *pkg , char const   *dir , int verbose ) ;
int clib_package_install(clib_package_t *pkg , char const   *dir , int verbose ) ;
int clib_package_install_dependencies(clib_package_t *pkg , char const   *dir , int verbose ) ;
int clib_package_install_development(clib_package_t *pkg , char const   *dir , int verbose ) ;
void clib_package_free(clib_package_t *pkg ) ;
void clib_package_dependency_free(void *_dep ) ;
void clib_package_cleanup(void) ;
char const   *manifest_names[3] ;
void debug(debug_t *debugger___1 , char const   *fmt  , ...) ;
int debug_init(debug_t *debugger___1 , char const   *name ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
 __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *str )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
__inline static kh_ptr_t *kh_init_ptr(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(kh_ptr_t ));
  return ((kh_ptr_t *)tmp);
}
}
__inline static void kh_destroy_ptr(kh_ptr_t *h ) 
{ 


  {
  if (h) {
    free((void *)h->keys);
    free((void *)h->flags);
    free((void *)h->vals);
    free((void *)h);
  }
  return;
}
}
void hash_set(hash_t *self , char *key , void *val ) ;
int hash_has(hash_t *self , char *key ) ;
http_get_response_t *http_get_shared(char const   *url , void *share ) ;
int http_get_file_shared(char const   *url , char const   *file , void *share ) ;
void http_get_free(http_get_response_t *res ) ;
int cc_fprintf(cc_color_t color , FILE *stream , char const   *format  , ...) ;
char *parse_repo_owner(char const   *slug , char const   *fallback ) ;
char *parse_repo_name(char const   *slug ) ;
char *parse_repo_version(char const   *slug , char const   *fallback ) ;
JSON_Value *json_parse_string(char const   *string ) ;
char const   *json_object_get_string(JSON_Object const   *object , char const   *name ) ;
JSON_Object *json_object_get_object(JSON_Object const   *object , char const   *name ) ;
JSON_Array *json_object_get_array(JSON_Object const   *object , char const   *name ) ;
size_t json_object_get_count(JSON_Object const   *object ) ;
char const   *json_object_get_name(JSON_Object const   *object , size_t index___0 ) ;
char const   *json_array_get_string(JSON_Array const   *array , size_t index___0 ) ;
size_t json_array_get_count(JSON_Array const   *array ) ;
void json_value_free(JSON_Value *value ) ;
JSON_Object *json_value_get_object(JSON_Value const   *value ) ;
char *path_join(char const   *dir , char const   *file ) ;
char *gettempdir(void) ;
extern  __attribute__((__nothrow__)) char *__xpg_basename(char *__path ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_init)(pthread_attr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_destroy)(pthread_attr_t *__attr ) ;
extern int pthread_cancel(pthread_t __th ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
static hash_t *visited_packages  =    (hash_t *)0;
static clib_package_lock_t lock  =    {{{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}}};
debug_t _debugger  ;
static clib_package_opts_t opts___0  =    {1, 0, 0, (char *)0, 12, (char *)0};
__inline static char *json_object_get_string_safe(JSON_Object *obj , char const   *key ) ;
__inline static char *json_array_get_string_safe(JSON_Array *array , int index___0 ) ;
__inline static char *clib_package_file_url(char const   *url , char const   *file ) ;
__inline static char *clib_package_slug(char const   *author , char const   *name ,
                                        char const   *version ) ;
__inline static char *clib_package_repo(char const   *author , char const   *name ) ;
__inline static list_t *parse_package_deps(JSON_Object *obj ) ;
__inline static int install_packages(list_t *list , char const   *dir , int verbose ) ;
void clib_package_set_opts(clib_package_opts_t o ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  if (1 == opts___0.skip_cache) {
    if (0 == o.skip_cache) {
      opts___0.skip_cache = 0;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (0 == opts___0.skip_cache) {
    if (1 == o.skip_cache) {
      opts___0.skip_cache = 1;
    }
  }
  if (1 == opts___0.global) {
    if (0 == o.global) {
      opts___0.global = 0;
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (0 == opts___0.global) {
    if (1 == o.global) {
      opts___0.global = 1;
    }
  }
  if (1 == opts___0.force) {
    if (0 == o.force) {
      opts___0.force = 0;
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (0 == opts___0.force) {
    if (1 == o.force) {
      opts___0.force = 1;
    }
  }
  if ((unsigned long )((char *)0) != (unsigned long )o.prefix) {
    tmp = strlen((char const   *)o.prefix);
    if (0UL == tmp) {
      opts___0.prefix = (char *)0;
    } else {
      opts___0.prefix = o.prefix;
    }
  }
  if ((unsigned long )((char *)0) != (unsigned long )o.token) {
    tmp___0 = strlen((char const   *)o.token);
    if (0UL == tmp___0) {
      opts___0.token = (char *)0;
    } else {
      opts___0.token = o.token;
    }
  }
  if (o.concurrency) {
    opts___0.concurrency = o.concurrency;
  } else
  if (o.concurrency < 0) {
    opts___0.concurrency = 0;
  }
  if (opts___0.concurrency < 0) {
    opts___0.concurrency = 0;
  }
  return;
}
}
__inline static char *json_object_get_string_safe(JSON_Object *obj , char const   *key ) 
{ 
  char const   *val ;
  char const   *tmp ;
  char *tmp___0 ;

  {
  tmp = json_object_get_string((JSON_Object const   *)obj, key);
  val = tmp;
  if (! val) {
    return ((char *)((void *)0));
  }
  tmp___0 = strdup(val);
  return (tmp___0);
}
}
__inline static char *json_array_get_string_safe(JSON_Array *array , int index___0 ) 
{ 
  char const   *val ;
  char const   *tmp ;
  char *tmp___0 ;

  {
  tmp = json_array_get_string((JSON_Array const   *)array, (size_t )index___0);
  val = tmp;
  if (! val) {
    return ((char *)((void *)0));
  }
  tmp___0 = strdup(val);
  return (tmp___0);
}
}
__inline static char *clib_package_file_url(char const   *url , char const   *file ) 
{ 
  int size ;
  size_t tmp ;
  size_t tmp___0 ;
  char *res ;
  void *tmp___1 ;

  {
  if (! url) {
    return ((char *)((void *)0));
  } else
  if (! file) {
    return ((char *)((void *)0));
  }
  tmp = strlen(url);
  tmp___0 = strlen(file);
  size = (int )(((tmp + 1UL) + tmp___0) + 1UL);
  tmp___1 = malloc((size_t )size);
  res = (char *)tmp___1;
  if (res) {
    memset((void *)res, 0, (size_t )size);
    sprintf((char * __restrict  )res, (char const   * __restrict  )"%s/%s", url, file);
  }
  return (res);
}
}
__inline static char *clib_package_slug(char const   *author , char const   *name ,
                                        char const   *version ) 
{ 
  int size ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *slug ;
  void *tmp___2 ;

  {
  tmp = strlen(author);
  tmp___0 = strlen(name);
  tmp___1 = strlen(version);
  size = (int )(((((tmp + 1UL) + tmp___0) + 1UL) + tmp___1) + 1UL);
  tmp___2 = malloc((size_t )size);
  slug = (char *)tmp___2;
  if (slug) {
    memset((void *)slug, '\000', (size_t )size);
    sprintf((char * __restrict  )slug, (char const   * __restrict  )"%s/%s@%s", author,
            name, version);
  }
  return (slug);
}
}
clib_package_t *clib_package_load_from_manifest(char const   *manifest , int verbose ) 
{ 
  clib_package_t *pkg ;
  int tmp ;
  char *json ;
  char *tmp___0 ;

  {
  pkg = (clib_package_t *)((void *)0);
  tmp = fs_exists(manifest);
  if (-1 == tmp) {
    cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
    cc_fprintf((cc_color_t )9, stderr, "Missing %s", manifest);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    return ((clib_package_t *)((void *)0));
  }
  cc_fprintf((cc_color_t )15, stdout, "  %10s", "info");
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
  cc_fprintf((cc_color_t )9, stdout, "reading local %s", manifest);
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
  tmp___0 = fs_read(manifest);
  json = tmp___0;
  if ((unsigned long )((void *)0) == (unsigned long )json) {
    goto e1;
  }
  pkg = clib_package_new((char const   *)json, verbose);
  e1: 
  free((void *)json);
  return (pkg);
}
}
clib_package_t *clib_package_load_local_manifest(int verbose ) 
{ 
  clib_package_t *pkg ;
  int i ;
  char const   *name ;

  {
  pkg = (clib_package_t *)((void *)0);
  i = 0;
  while (1) {
    name = (char const   *)((void *)0);
    name = manifest_names[i];
    pkg = clib_package_load_from_manifest(name, verbose);
    if ((unsigned long )pkg == (unsigned long )((void *)0)) {
      i ++;
      if (! ((unsigned long )((void *)0) != (unsigned long )manifest_names[i])) {
        break;
      }
    } else {
      break;
    }
  }
  return (pkg);
}
}
__inline static char *clib_package_repo(char const   *author , char const   *name ) 
{ 
  int size ;
  size_t tmp ;
  size_t tmp___0 ;
  char *repo ;
  void *tmp___1 ;

  {
  tmp = strlen(author);
  tmp___0 = strlen(name);
  size = (int )(((tmp + 1UL) + tmp___0) + 1UL);
  tmp___1 = malloc((size_t )size);
  repo = (char *)tmp___1;
  if (repo) {
    memset((void *)repo, '\000', (size_t )size);
    sprintf((char * __restrict  )repo, (char const   * __restrict  )"%s/%s", author,
            name);
  }
  return (repo);
}
}
__inline static list_t *parse_package_deps(JSON_Object *obj ) 
{ 
  list_t *list ;
  unsigned int i ;
  char const   *name ;
  char *version ;
  clib_package_dependency_t *dep ;
  int error___0 ;
  list_node_t *tmp ;
  list_node_t *tmp___0 ;
  size_t tmp___1 ;

  {
  list = (list_t *)((void *)0);
  if (! obj) {
    goto done;
  }
  list = list_new();
  if (! list) {
    goto done;
  }
  list->free = & clib_package_dependency_free;
  i = 0U;
  while (1) {
    tmp___1 = json_object_get_count((JSON_Object const   *)obj);
    if (! ((size_t )i < tmp___1)) {
      break;
    }
    name = (char const   *)((void *)0);
    version = (char *)((void *)0);
    dep = (clib_package_dependency_t *)((void *)0);
    error___0 = 1;
    name = json_object_get_name((JSON_Object const   *)obj, (size_t )i);
    if (! name) {
      goto loop_cleanup;
    }
    version = json_object_get_string_safe(obj, name);
    if (! version) {
      goto loop_cleanup;
    }
    dep = clib_package_dependency_new(name, (char const   *)version);
    if (! dep) {
      goto loop_cleanup;
    }
    tmp = list_node_new((void *)dep);
    tmp___0 = list_rpush(list, tmp);
    if (! tmp___0) {
      goto loop_cleanup;
    }
    error___0 = 0;
    loop_cleanup: 
    if (version) {
      free((void *)version);
    }
    if (error___0) {
      list_destroy(list);
      list = (list_t *)((void *)0);
      break;
    }
    i ++;
  }
  done: 
  return (list);
}
}
__inline static int install_packages(list_t *list , char const   *dir , int verbose ) 
{ 
  list_node_t *node ;
  list_iterator_t *iterator ;
  int rc ;
  list_t *freelist ;
  clib_package_dependency_t *dep ;
  char *slug ;
  clib_package_t *pkg ;
  int error___0 ;
  int tmp ;
  list_node_t *tmp___0 ;
  clib_package_t *pkg___0 ;

  {
  node = (list_node_t *)((void *)0);
  iterator = (list_iterator_t *)((void *)0);
  rc = -1;
  freelist = (list_t *)((void *)0);
  if (! list) {
    goto cleanup;
  } else
  if (! dir) {
    goto cleanup;
  }
  iterator = list_iterator_new(list, (list_direction_t )0);
  if ((unsigned long )((void *)0) == (unsigned long )iterator) {
    goto cleanup;
  }
  freelist = list_new();
  while (1) {
    node = list_iterator_next(iterator);
    if (! node) {
      break;
    }
    dep = (clib_package_dependency_t *)((void *)0);
    slug = (char *)((void *)0);
    pkg = (clib_package_t *)((void *)0);
    error___0 = 1;
    dep = (clib_package_dependency_t *)node->val;
    slug = clib_package_slug((char const   *)dep->author, (char const   *)dep->name,
                             (char const   *)dep->version);
    if ((unsigned long )((void *)0) == (unsigned long )slug) {
      goto loop_cleanup;
    }
    pkg = clib_package_new_from_slug((char const   *)slug, verbose);
    if ((unsigned long )((void *)0) == (unsigned long )pkg) {
      goto loop_cleanup;
    }
    tmp = clib_package_install(pkg, dir, verbose);
    if (-1 == tmp) {
      goto loop_cleanup;
    }
    tmp___0 = list_node_new((void *)pkg);
    list_rpush(freelist, tmp___0);
    error___0 = 0;
    loop_cleanup: 
    if (slug) {
      free((void *)slug);
    }
    if (error___0) {
      list_iterator_destroy(iterator);
      iterator = (list_iterator_t *)((void *)0);
      rc = -1;
      goto cleanup;
    }
  }
  rc = 0;
  cleanup: 
  if (iterator) {
    list_iterator_destroy(iterator);
  }
  if (freelist) {
    iterator = list_iterator_new(freelist, (list_direction_t )0);
    while (1) {
      node = list_iterator_next(iterator);
      if (! node) {
        break;
      }
      pkg___0 = (clib_package_t *)node->val;
      if (pkg___0) {
        clib_package_free(pkg___0);
      }
    }
    list_iterator_destroy(iterator);
    list_destroy(freelist);
  }
  return (rc);
}
}
static void curl_lock_callback(CURL *handle , curl_lock_data data , curl_lock_access access___0 ,
                               void *userptr ) 
{ 


  {
  pthread_mutex_lock(& lock.mutex);
  return;
}
}
static void curl_unlock_callback(CURL *handle , curl_lock_data data , curl_lock_access access___0 ,
                                 void *userptr ) 
{ 


  {
  pthread_mutex_unlock(& lock.mutex);
  return;
}
}
static void init_curl_share(void) 
{ 


  {
  if ((unsigned long )((CURLSH *)0) == (unsigned long )clib_package_curl_share) {
    pthread_mutex_lock(& lock.mutex);
    clib_package_curl_share = curl_share_init();
    curl_share_setopt(clib_package_curl_share, (CURLSHoption )1, 5);
    curl_share_setopt(clib_package_curl_share, (CURLSHoption )3, & curl_lock_callback);
    curl_share_setopt(clib_package_curl_share, (CURLSHoption )4, & curl_unlock_callback);
    curl_share_setopt(clib_package_curl_share, (CURLSHoption )51, 1);
    pthread_mutex_unlock(& lock.mutex);
  }
  return;
}
}
clib_package_t *clib_package_new(char const   *json , int verbose ) 
{ 
  clib_package_t *pkg ;
  JSON_Value *root ;
  JSON_Object *json_object___0 ;
  JSON_Array *src ;
  JSON_Object *deps ;
  JSON_Object *devs ;
  int error___0 ;
  void *tmp ;
  JSON_Array *flags ;
  JSON_Array *tmp___0 ;
  unsigned int i ;
  char *flag ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  list_t *tmp___4 ;
  unsigned int i___0 ;
  char *file ;
  char *tmp___5 ;
  list_node_t *tmp___6 ;
  list_node_t *tmp___7 ;
  size_t tmp___8 ;
  list_t *tmp___9 ;
  list_t *tmp___10 ;

  {
  pkg = (clib_package_t *)((void *)0);
  root = (JSON_Value *)((void *)0);
  json_object___0 = (JSON_Object *)((void *)0);
  src = (JSON_Array *)((void *)0);
  deps = (JSON_Object *)((void *)0);
  devs = (JSON_Object *)((void *)0);
  error___0 = 1;
  if (! json) {
    if (verbose) {
      cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stderr, "missing JSON to parse");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
    goto cleanup;
  }
  root = json_parse_string(json);
  if (! root) {
    if (verbose) {
      cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stderr, "unable to parse JSON");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
    goto cleanup;
  }
  json_object___0 = json_value_get_object((JSON_Value const   *)root);
  if (! json_object___0) {
    if (verbose) {
      cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stderr, "invalid clib.json or package.json file");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
    goto cleanup;
  }
  tmp = malloc(sizeof(clib_package_t ));
  pkg = (clib_package_t *)tmp;
  if (! pkg) {
    goto cleanup;
  }
  memset((void *)pkg, 0, sizeof(clib_package_t ));
  pkg->json = strdup(json);
  pkg->name = json_object_get_string_safe(json_object___0, "name");
  pkg->repo = json_object_get_string_safe(json_object___0, "repo");
  pkg->version = json_object_get_string_safe(json_object___0, "version");
  pkg->license = json_object_get_string_safe(json_object___0, "license");
  pkg->description = json_object_get_string_safe(json_object___0, "description");
  pkg->configure = json_object_get_string_safe(json_object___0, "configure");
  pkg->install = json_object_get_string_safe(json_object___0, "install");
  pkg->makefile = json_object_get_string_safe(json_object___0, "makefile");
  pkg->prefix = json_object_get_string_safe(json_object___0, "prefix");
  pkg->flags = json_object_get_string_safe(json_object___0, "flags");
  if (! pkg->flags) {
    pkg->flags = json_object_get_string_safe(json_object___0, "cflags");
  }
  if (! pkg->flags) {
    tmp___0 = json_object_get_array((JSON_Object const   *)json_object___0, "flags");
    flags = tmp___0;
    if (! flags) {
      flags = json_object_get_array((JSON_Object const   *)json_object___0, "cflags");
    }
    if (flags) {
      i = 0U;
      while (1) {
        tmp___3 = json_array_get_count((JSON_Array const   *)flags);
        if (! ((size_t )i < tmp___3)) {
          break;
        }
        tmp___1 = json_array_get_string_safe(flags, (int )i);
        flag = tmp___1;
        if (flag) {
          if (! pkg->flags) {
            pkg->flags = (char *)"";
          }
          tmp___2 = asprintf(& pkg->flags, "%s %s", pkg->flags, flag);
          if (-1 == tmp___2) {
            goto cleanup;
          }
          free((void *)flag);
        }
        i ++;
      }
    }
  }
  if (! pkg->repo) {
    if (pkg->author) {
      if (pkg->name) {
        asprintf(& pkg->repo, "%s/%s", pkg->author, pkg->name);
        if (! _debugger.name) {
          debug_init(& _debugger, "clib-package");
        }
        debug(& _debugger, "creating package: %s", pkg->repo);
      }
    }
  }
  if (! pkg->author) {
    if (! _debugger.name) {
      debug_init(& _debugger, "clib-package");
    }
    debug(& _debugger, "unable to determine package author for: %s", pkg->name);
  }
  if (pkg->repo) {
    pkg->author = parse_repo_owner((char const   *)pkg->repo, "clibs");
    pkg->repo_name = parse_repo_name((char const   *)pkg->repo);
  } else {
    if (verbose) {
      cc_fprintf((cc_color_t )4, stdout, "  %10s", "warning");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stdout, "missing repo in clib.json or package.json file for %s",
                 pkg->name);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
    }
    pkg->author = (char *)((void *)0);
    pkg->repo_name = (char *)((void *)0);
  }
  src = json_object_get_array((JSON_Object const   *)json_object___0, "src");
  if (! src) {
    src = json_object_get_array((JSON_Object const   *)json_object___0, "files");
  }
  if (src) {
    tmp___4 = list_new();
    pkg->src = tmp___4;
    if (! tmp___4) {
      goto cleanup;
    }
    (pkg->src)->free = & free;
    i___0 = 0U;
    while (1) {
      tmp___8 = json_array_get_count((JSON_Array const   *)src);
      if (! ((size_t )i___0 < tmp___8)) {
        break;
      }
      tmp___5 = json_array_get_string_safe(src, (int )i___0);
      file = tmp___5;
      if (! _debugger.name) {
        debug_init(& _debugger, "clib-package");
      }
      debug(& _debugger, "file: %s", file);
      if (! file) {
        goto cleanup;
      }
      tmp___6 = list_node_new((void *)file);
      tmp___7 = list_rpush(pkg->src, tmp___6);
      if (! tmp___7) {
        goto cleanup;
      }
      i___0 ++;
    }
  } else {
    if (! _debugger.name) {
      debug_init(& _debugger, "clib-package");
    }
    debug(& _debugger, "no src files listed in clib.json or package.json file");
    pkg->src = (list_t *)((void *)0);
  }
  deps = json_object_get_object((JSON_Object const   *)json_object___0, "dependencies");
  if (deps) {
    tmp___9 = parse_package_deps(deps);
    pkg->dependencies = tmp___9;
    if (! tmp___9) {
      goto cleanup;
    }
  } else {
    if (! _debugger.name) {
      debug_init(& _debugger, "clib-package");
    }
    debug(& _debugger, "no dependencies listed in clib.json or package.json file");
    pkg->dependencies = (list_t *)((void *)0);
  }
  devs = json_object_get_object((JSON_Object const   *)json_object___0, "development");
  if (devs) {
    tmp___10 = parse_package_deps(devs);
    pkg->development = tmp___10;
    if (! tmp___10) {
      goto cleanup;
    }
  } else {
    if (! _debugger.name) {
      debug_init(& _debugger, "clib-package");
    }
    debug(& _debugger, "no development dependencies listed in clib.json or package.json file");
    pkg->development = (list_t *)((void *)0);
  }
  error___0 = 0;
  cleanup: 
  if (root) {
    json_value_free(root);
  }
  if (error___0) {
    if (pkg) {
      clib_package_free(pkg);
      pkg = (clib_package_t *)((void *)0);
    }
  }
  return (pkg);
}
}
static clib_package_t *clib_package_new_from_slug_with_package_name(char const   *slug ,
                                                                    int verbose ,
                                                                    char const   *file ) 
{ 
  char *author ;
  char *name ;
  char *version ;
  char *url ;
  char *json_url ;
  char *repo ;
  char *json ;
  char *log ;
  http_get_response_t *res ;
  clib_package_t *pkg ;
  int retries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  author = (char *)((void *)0);
  name = (char *)((void *)0);
  version = (char *)((void *)0);
  url = (char *)((void *)0);
  json_url = (char *)((void *)0);
  repo = (char *)((void *)0);
  json = (char *)((void *)0);
  log = (char *)((void *)0);
  res = (http_get_response_t *)((void *)0);
  pkg = (clib_package_t *)((void *)0);
  retries = 3;
  if (! slug) {
    goto error;
  }
  if (! _debugger.name) {
    debug_init(& _debugger, "clib-package");
  }
  debug(& _debugger, "creating package: %s", slug);
  author = parse_repo_owner(slug, "clibs");
  if (! author) {
    goto error;
  }
  name = parse_repo_name(slug);
  if (! name) {
    goto error;
  }
  version = parse_repo_version(slug, "master");
  if (! version) {
    goto error;
  }
  url = clib_package_url((char const   *)author, (char const   *)name, (char const   *)version);
  if (! url) {
    goto error;
  }
  json_url = clib_package_file_url((char const   *)url, file);
  if (! json_url) {
    goto error;
  }
  if (! _debugger.name) {
    debug_init(& _debugger, "clib-package");
  }
  debug(& _debugger, "author: %s", author);
  if (! _debugger.name) {
    debug_init(& _debugger, "clib-package");
  }
  debug(& _debugger, "name: %s", name);
  if (! _debugger.name) {
    debug_init(& _debugger, "clib-package");
  }
  debug(& _debugger, "version: %s", version);
  pthread_mutex_lock(& lock.mutex);
  tmp___0 = clib_cache_has_json(author, name, version);
  if (tmp___0) {
    if (opts___0.skip_cache) {
      clib_cache_delete_json(author, name, version);
      goto download;
    }
    json = clib_cache_read_json(author, name, version);
    if (! json) {
      goto download;
    }
    log = (char *)"cache";
    pthread_mutex_unlock(& lock.mutex);
  } else {
    download: 
    pthread_mutex_unlock(& lock.mutex);
    tmp = retries;
    retries --;
    if (tmp <= 0) {
      goto error;
    } else {
      init_curl_share();
      if (! _debugger.name) {
        debug_init(& _debugger, "clib-package");
      }
      debug(& _debugger, "GET %s", json_url);
      http_get_free(res);
      res = http_get_shared((char const   *)json_url, clib_package_curl_share);
      json = res->data;
      if (! _debugger.name) {
        debug_init(& _debugger, "clib-package");
      }
      debug(& _debugger, "status: %d", res->status);
      if (! res) {
        goto download;
      } else
      if (! res->ok) {
        goto download;
      }
      log = (char *)"fetch";
    }
  }
  if (verbose) {
    cc_fprintf((cc_color_t )15, stdout, "  %10s", log);
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
    cc_fprintf((cc_color_t )9, stdout, "%s/%s:%s", author, name, file);
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
  }
  free((void *)json_url);
  json_url = (char *)((void *)0);
  free((void *)name);
  name = (char *)((void *)0);
  if (json) {
    pkg = clib_package_new((char const   *)json, verbose);
  }
  if (! pkg) {
    goto error;
  }
  if (pkg->version) {
    if (version) {
      tmp___1 = strcmp((char const   *)version, "master");
      if (0 != tmp___1) {
        if (! _debugger.name) {
          debug_init(& _debugger, "clib-package");
        }
        debug(& _debugger, "forcing version number: %s (%s)", version, pkg->version);
        free((void *)pkg->version);
        pkg->version = version;
      } else {
        free((void *)version);
      }
    }
  } else {
    pkg->version = version;
  }
  if (author) {
    if (pkg->author) {
      tmp___2 = strcmp((char const   *)author, (char const   *)pkg->author);
      if (0 != tmp___2) {
        free((void *)pkg->author);
        pkg->author = author;
      } else {
        free((void *)author);
      }
    } else {
      pkg->author = strdup((char const   *)author);
    }
  } else {
    pkg->author = strdup((char const   *)author);
  }
  repo = clib_package_repo((char const   *)pkg->author, (char const   *)pkg->name);
  if (! repo) {
    goto error;
  }
  if (pkg->repo) {
    tmp___3 = strcmp((char const   *)repo, (char const   *)pkg->repo);
    if (0 != tmp___3) {
      free((void *)url);
      url = clib_package_url_from_repo((char const   *)pkg->repo, (char const   *)pkg->version);
      if (! url) {
        goto error;
      }
    }
    free((void *)repo);
    repo = (char *)((void *)0);
  } else {
    pkg->repo = repo;
  }
  pkg->url = url;
  pthread_mutex_lock(& lock.mutex);
  if (pkg) {
    if (pkg->author) {
      if (pkg->name) {
        if (pkg->version) {
          tmp___4 = clib_cache_save_json(pkg->author, pkg->name, pkg->version, json);
          if (-1 == tmp___4) {
            if (! _debugger.name) {
              debug_init(& _debugger, "clib-package");
            }
            debug(& _debugger, "failed to cache JSON for: %s/%s@%s", pkg->author,
                  pkg->name, pkg->version);
          } else {
            if (! _debugger.name) {
              debug_init(& _debugger, "clib-package");
            }
            debug(& _debugger, "cached: %s/%s@%s", pkg->author, pkg->name, pkg->version);
          }
        }
      }
    }
  }
  pthread_mutex_unlock(& lock.mutex);
  if (res) {
    http_get_free(res);
    json = (char *)((void *)0);
    res = (http_get_response_t *)((void *)0);
  } else {
    free((void *)json);
    json = (char *)((void *)0);
  }
  return (pkg);
  error: 
  if (0 == retries) {
    if (verbose) {
      if (author) {
        if (name) {
          if (file) {
            cc_fprintf((cc_color_t )4, stdout, "  %10s", "warning");
            fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
            cc_fprintf((cc_color_t )9, stdout, "unable to fetch %s/%s:%s", author,
                       name, file);
            fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
          }
        }
      }
    }
  }
  free((void *)author);
  free((void *)name);
  free((void *)version);
  free((void *)url);
  free((void *)json_url);
  free((void *)repo);
  if (! res) {
    if (json) {
      free((void *)json);
    }
  }
  if (res) {
    http_get_free(res);
  }
  if (pkg) {
    clib_package_free(pkg);
  }
  return ((clib_package_t *)((void *)0));
}
}
clib_package_t *clib_package_new_from_slug(char const   *slug , int verbose ) 
{ 
  clib_package_t *package ;
  char const   *name ;
  unsigned int i ;

  {
  package = (clib_package_t *)((void *)0);
  name = (char const   *)((void *)0);
  i = 0U;
  while (1) {
    name = manifest_names[i];
    package = clib_package_new_from_slug_with_package_name(slug, verbose, name);
    if ((unsigned long )((void *)0) != (unsigned long )package) {
      package->filename = (char *)name;
    }
    i ++;
    if ((unsigned long )((void *)0) != (unsigned long )manifest_names[i]) {
      if (! ((unsigned long )((void *)0) == (unsigned long )package)) {
        break;
      }
    } else {
      break;
    }
  }
  return (package);
}
}
char *clib_package_url(char const   *author , char const   *name , char const   *version ) 
{ 
  int size ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *slug ;
  void *tmp___4 ;

  {
  if (! author) {
    return ((char *)((void *)0));
  } else
  if (! name) {
    return ((char *)((void *)0));
  } else
  if (! version) {
    return ((char *)((void *)0));
  }
  tmp = strlen("https://raw.githubusercontent.com/");
  tmp___0 = strlen(author);
  tmp___1 = strlen(name);
  tmp___2 = strlen(version);
  size = (int )((((((tmp + tmp___0) + 1UL) + tmp___1) + 1UL) + tmp___2) + 1UL);
  if ((unsigned long )((char *)0) != (unsigned long )opts___0.token) {
    tmp___3 = strlen((char const   *)opts___0.token);
    size = (int )((size_t )size + tmp___3);
    size ++;
  }
  tmp___4 = malloc((size_t )size);
  slug = (char *)tmp___4;
  if (slug) {
    memset((void *)slug, '\000', (size_t )size);
    if ((unsigned long )((char *)0) != (unsigned long )opts___0.token) {
      sprintf((char * __restrict  )slug, (char const   * __restrict  )"https://%s@raw.githubusercontent.com/%s/%s/%s",
              opts___0.token, author, name, version);
    } else {
      sprintf((char * __restrict  )slug, (char const   * __restrict  )"https://raw.githubusercontent.com/%s/%s/%s",
              author, name, version);
    }
  }
  return (slug);
}
}
char *clib_package_url_from_repo(char const   *repo , char const   *version ) 
{ 
  int size ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *slug ;
  void *tmp___3 ;

  {
  if (! repo) {
    return ((char *)((void *)0));
  } else
  if (! version) {
    return ((char *)((void *)0));
  }
  tmp = strlen("https://raw.githubusercontent.com/");
  tmp___0 = strlen(repo);
  tmp___1 = strlen(version);
  size = (int )((((tmp + tmp___0) + 1UL) + tmp___1) + 1UL);
  if ((unsigned long )((char *)0) != (unsigned long )opts___0.token) {
    tmp___2 = strlen((char const   *)opts___0.token);
    size = (int )((size_t )size + tmp___2);
    size ++;
  }
  tmp___3 = malloc((size_t )size);
  slug = (char *)tmp___3;
  if (slug) {
    memset((void *)slug, '\000', (size_t )size);
    if ((unsigned long )((char *)0) != (unsigned long )opts___0.token) {
      sprintf((char * __restrict  )slug, (char const   * __restrict  )"https://%s@raw.githubusercontent.com/%s/%s",
              opts___0.token, repo, version);
    } else {
      sprintf((char * __restrict  )slug, (char const   * __restrict  )"https://raw.githubusercontent.com/%s/%s",
              repo, version);
    }
  }
  return (slug);
}
}
char *clib_package_parse_author(char const   *slug ) 
{ 
  char *tmp ;

  {
  tmp = parse_repo_owner(slug, "clibs");
  return (tmp);
}
}
char *clib_package_parse_version(char const   *slug ) 
{ 
  char *tmp ;

  {
  tmp = parse_repo_version(slug, "master");
  return (tmp);
}
}
char *clib_package_parse_name(char const   *slug ) 
{ 
  char *tmp ;

  {
  tmp = parse_repo_name(slug);
  return (tmp);
}
}
clib_package_dependency_t *clib_package_dependency_new(char const   *repo , char const   *version ) 
{ 
  clib_package_dependency_t *dep ;
  void *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  if (! repo) {
    return ((clib_package_dependency_t *)((void *)0));
  } else
  if (! version) {
    return ((clib_package_dependency_t *)((void *)0));
  }
  tmp = malloc(sizeof(clib_package_dependency_t ));
  dep = (clib_package_dependency_t *)tmp;
  if (! dep) {
    return ((clib_package_dependency_t *)((void *)0));
  }
  tmp___3 = strcmp("*", version);
  if (0 == tmp___3) {
    tmp___1 = strdup("master");
    dep->version = tmp___1;
  } else {
    tmp___2 = strdup(version);
    dep->version = tmp___2;
  }
  dep->name = clib_package_parse_name(repo);
  dep->author = clib_package_parse_author(repo);
  if (! _debugger.name) {
    debug_init(& _debugger, "clib-package");
  }
  debug(& _debugger, "dependency: %s/%s@%s", dep->author, dep->name, dep->version);
  return (dep);
}
}
static int fetch_package_file_work(clib_package_t *pkg , char const   *dir , char *file ,
                                   int verbose ) 
{ 
  char *url ;
  char *path ;
  int saved ;
  int rc ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  url = (char *)((void *)0);
  path = (char *)((void *)0);
  saved = 0;
  rc = 0;
  if (! _debugger.name) {
    debug_init(& _debugger, "clib-package");
  }
  debug(& _debugger, "fetch file: %s/%s", pkg->repo, file);
  if ((unsigned long )((void *)0) == (unsigned long )pkg) {
    return (1);
  }
  if ((unsigned long )((void *)0) == (unsigned long )pkg->url) {
    return (1);
  }
  tmp = strncmp((char const   *)file, "http", (size_t )4);
  if (0 == tmp) {
    url = strdup((char const   *)file);
  } else {
    url = clib_package_file_url((char const   *)pkg->url, (char const   *)file);
    if (! url) {
      return (1);
    }
  }
  if (! _debugger.name) {
    debug_init(& _debugger, "clib-package");
  }
  debug(& _debugger, "file URL: %s", url);
  tmp___0 = __xpg_basename(file);
  path = path_join(dir, (char const   *)tmp___0);
  if (! path) {
    rc = 1;
    goto cleanup;
  }
  pthread_mutex_lock(& lock.mutex);
  if (1 == opts___0.force) {
    goto _L;
  } else {
    tmp___1 = fs_exists((char const   *)path);
    if (-1 == tmp___1) {
      _L: /* CIL Label */ 
      if (verbose) {
        cc_fprintf((cc_color_t )15, stdout, "  %10s", "fetch");
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
        cc_fprintf((cc_color_t )9, stdout, "%s:%s", pkg->repo, file);
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
        fflush(stdout);
      }
      pthread_mutex_unlock(& lock.mutex);
      rc = http_get_file_shared((char const   *)url, (char const   *)path, clib_package_curl_share);
      saved = 1;
    } else {
      pthread_mutex_unlock(& lock.mutex);
    }
  }
  if (-1 == rc) {
    if (verbose) {
      pthread_mutex_lock(& lock.mutex);
      cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stderr, "unable to fetch %s:%s", pkg->repo, file);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
      fflush(stderr);
      rc = 1;
      pthread_mutex_unlock(& lock.mutex);
      goto cleanup;
    }
  }
  if (saved) {
    if (verbose) {
      pthread_mutex_lock(& lock.mutex);
      cc_fprintf((cc_color_t )15, stdout, "  %10s", "save");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stdout, (char const   *)path);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      fflush(stdout);
      pthread_mutex_unlock(& lock.mutex);
    }
  }
  cleanup: 
  free((void *)url);
  free((void *)path);
  return (rc);
}
}
static void *fetch_package_file_thread(void *arg ) 
{ 
  fetch_package_file_thread_data_t *data ;
  int *status ;
  void *tmp ;
  int rc ;
  int tmp___0 ;

  {
  data = (fetch_package_file_thread_data_t *)arg;
  tmp = malloc(sizeof(int ));
  status = (int *)tmp;
  tmp___0 = fetch_package_file_work(data->pkg, data->dir, data->file, data->verbose);
  rc = tmp___0;
  *status = rc;
  ((data->pkg)->refs) --;
  pthread_exit((void *)status);
  return ((void *)((intptr_t )rc));
}
}
static int fetch_package_file(clib_package_t *pkg , char const   *dir , char *file ,
                              int verbose , void **data ) 
{ 
  fetch_package_file_thread_data_t *fetch ;
  void *tmp ;
  int rc ;

  {
  tmp = malloc(sizeof(*fetch));
  fetch = (fetch_package_file_thread_data_t *)tmp;
  rc = 0;
  if ((unsigned long )((fetch_package_file_thread_data_t *)0) == (unsigned long )fetch) {
    return (-1);
  }
  *data = (void *)0;
  memset((void *)fetch, 0, sizeof(*fetch));
  fetch->pkg = pkg;
  fetch->dir = dir;
  fetch->file = file;
  fetch->verbose = verbose;
  rc = pthread_attr_init(& fetch->attr);
  if (0 != rc) {
    free((void *)fetch);
    return (rc);
  }
  (pkg->refs) ++;
  rc = pthread_create((pthread_t * __restrict  )(& fetch->thread), (pthread_attr_t const   * __restrict  )((void *)0),
                      & fetch_package_file_thread, (void * __restrict  )fetch);
  if (0 != rc) {
    pthread_attr_destroy(& fetch->attr);
    free((void *)fetch);
    return (rc);
  }
  rc = pthread_attr_destroy(& fetch->attr);
  if (0 != rc) {
    pthread_cancel(fetch->thread);
    free((void *)fetch);
    return (rc);
  }
  *data = (void *)fetch;
  return (rc);
}
}
static void set_prefix(clib_package_t *pkg , long path_max ) 
{ 


  {
  if ((unsigned long )((void *)0) != (unsigned long )opts___0.prefix) {
    goto _L;
  } else
  if ((unsigned long )((void *)0) != (unsigned long )pkg->prefix) {
    _L: /* CIL Label */ ;
    char path[path_max] ;
    memset((void *)(path), 0, (size_t )path_max);
    if (opts___0.prefix) {
      realpath((char const   * __restrict  )opts___0.prefix, (char * __restrict  )(path));
    } else {
      realpath((char const   * __restrict  )pkg->prefix, (char * __restrict  )(path));
    }
    if (! _debugger.name) {
      debug_init(& _debugger, "clib-package");
    }
    debug(& _debugger, "env: PREFIX: %s", path);
    setenv("PREFIX", (char const   *)(path), 1);
    mkdirp((char const   *)(path), (mode_t )511);
  }
  return;
}
}
int clib_package_install_executable(clib_package_t *pkg , char const   *dir , int verbose ) 
{ 
  long path_max ;
  int rc ;
  char *url ;
  char *file ;
  char *tarball ;
  char *command ;
  char *unpack_dir ;
  char *deps ;
  char *tmp ;
  char *reponame ;
  char const   *configure ;
  char *version ;
  char *tmp___0 ;
  char *flags ;
  char *cflags ;
  char *tmp___1 ;

  {
  path_max = 4096L;
  url = (char *)((void *)0);
  file = (char *)((void *)0);
  tarball = (char *)((void *)0);
  command = (char *)((void *)0);
  unpack_dir = (char *)((void *)0);
  deps = (char *)((void *)0);
  tmp = (char *)((void *)0);
  reponame = (char *)((void *)0);
  char dir_path[path_max] ;
  if (! _debugger.name) {
    debug_init(& _debugger, "clib-package");
  }
  debug(& _debugger, "install executable %s", pkg->repo);
  tmp = gettempdir();
  if ((unsigned long )((void *)0) == (unsigned long )tmp) {
    if (verbose) {
      cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stderr, "gettempdir() out of memory");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
    return (-1);
  }
  if (! pkg->repo) {
    if (verbose) {
      cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stderr, "repo field required to install executable");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
    return (-1);
  }
  reponame = strrchr((char const   *)pkg->repo, '/');
  if (reponame) {
    if ((int )*reponame != 0) {
      reponame ++;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (verbose) {
      cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stderr, "malformed repo field, must be in the form user/pkg");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
    return (-1);
  }
  rc = asprintf(& url, "https://github.com/%s/archive/%s.tar.gz", pkg->repo, pkg->version);
  if (-1 == rc) {
    goto cleanup;
  }
  rc = asprintf(& file, "%s-%s.tar.gz", reponame, pkg->version);
  if (-1 == rc) {
    goto cleanup;
  }
  rc = asprintf(& tarball, "%s/%s", tmp, file);
  if (-1 == rc) {
    goto cleanup;
  }
  rc = http_get_file_shared((char const   *)url, (char const   *)tarball, clib_package_curl_share);
  if (0 != rc) {
    if (verbose) {
      cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stderr, "download failed for \'%s@%s\' - HTTP GET \'%s\'",
                 pkg->repo, pkg->version, url);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
    goto cleanup;
  }
  rc = asprintf(& command, "cd %s && gzip -dc %s | tar x", tmp, file);
  if (-1 == rc) {
    goto cleanup;
  }
  if (! _debugger.name) {
    debug_init(& _debugger, "clib-package");
  }
  debug(& _debugger, "download url: %s", url);
  if (! _debugger.name) {
    debug_init(& _debugger, "clib-package");
  }
  debug(& _debugger, "file: %s", file);
  if (! _debugger.name) {
    debug_init(& _debugger, "clib-package");
  }
  debug(& _debugger, "tarball: %s", tarball);
  if (! _debugger.name) {
    debug_init(& _debugger, "clib-package");
  }
  debug(& _debugger, "command(extract): %s", command);
  rc = system((char const   *)command);
  if (0 != rc) {
    goto cleanup;
  }
  free((void *)command);
  command = (char *)((void *)0);
  set_prefix(pkg, path_max);
  configure = (char const   *)pkg->configure;
  if ((unsigned long )((char const   *)0) == (unsigned long )configure) {
    configure = ":";
  }
  memset((void *)(dir_path), 0, (size_t )path_max);
  realpath((char const   * __restrict  )dir, (char * __restrict  )(dir_path));
  version = pkg->version;
  if (118 == (int )*(version + 0)) {
    version ++;
  }
  rc = asprintf(& unpack_dir, "%s/%s-%s", tmp, reponame, version);
  if (-1 == rc) {
    goto cleanup;
  }
  if (! _debugger.name) {
    debug_init(& _debugger, "clib-package");
  }
  debug(& _debugger, "dir: %s", unpack_dir);
  if (pkg->dependencies) {
    rc = asprintf(& deps, "%s/deps", unpack_dir);
    if (-1 == rc) {
      goto cleanup;
    }
    if (! _debugger.name) {
      debug_init(& _debugger, "clib-package");
    }
    debug(& _debugger, "deps: %s", deps);
    rc = clib_package_install_dependencies(pkg, (char const   *)deps, verbose);
    if (-1 == rc) {
      goto cleanup;
    }
  }
  if (! opts___0.global) {
    if (pkg->makefile) {
      tmp___0 = __xpg_basename(pkg->makefile);
      rc = asprintf(& command, "cp -fr %s/%s/%s %s", dir_path, pkg->name, tmp___0,
                    unpack_dir);
      if (-1 == rc) {
        goto cleanup;
      }
      rc = system((char const   *)command);
      if (0 != rc) {
        goto cleanup;
      }
      free((void *)command);
    }
  }
  if (pkg->flags) {
    flags = (char *)((void *)0);
    tmp___1 = getenv("CFLAGS");
    cflags = tmp___1;
    if (cflags) {
      asprintf(& flags, "%s %s", cflags, pkg->flags);
    } else {
      asprintf(& flags, "%s", pkg->flags);
    }
    setenv("CFLAGS", (char const   *)cflags, 1);
  }
  rc = asprintf(& command, "cd %s && %s", unpack_dir, pkg->install);
  if (-1 == rc) {
    goto cleanup;
  }
  if (! _debugger.name) {
    debug_init(& _debugger, "clib-package");
  }
  debug(& _debugger, "command(install): %s", command);
  rc = system((char const   *)command);
  cleanup: 
  free((void *)tmp);
  free((void *)command);
  free((void *)tarball);
  free((void *)file);
  free((void *)url);
  return (rc);
}
}
int clib_package_install(clib_package_t *pkg , char const   *dir , int verbose ) 
{ 
  list_iterator_t *iterator ;
  char *package_json ;
  char *pkg_dir ;
  char *command ;
  int pending ;
  int rc ;
  int i ;
  long path_max ;
  int max ;
  char *prefix ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  fetch_package_file_thread_data_t **fetchs ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  void *fetch ;
  fetch_package_file_thread_data_t *data ;
  int *status ;
  int tmp___7 ;
  int tmp___8 ;
  list_node_t *source ;
  void *fetch___0 ;
  int j ;
  fetch_package_file_thread_data_t *data___0 ;
  int *status___0 ;
  int j___0 ;
  fetch_package_file_thread_data_t *data___1 ;
  int *status___1 ;

  {
  iterator = (list_iterator_t *)((void *)0);
  package_json = (char *)((void *)0);
  pkg_dir = (char *)((void *)0);
  command = (char *)((void *)0);
  pending = 0;
  rc = 0;
  i = 0;
  path_max = 4096L;
  max = opts___0.concurrency;
  if ((unsigned long )((char *)0) == (unsigned long )opts___0.prefix) {
    pthread_mutex_lock(& lock.mutex);
    tmp = getenv("PREFIX");
    prefix = tmp;
    if (prefix) {
      opts___0.prefix = prefix;
    }
    pthread_mutex_unlock(& lock.mutex);
  }
  if ((unsigned long )((hash_t *)0) == (unsigned long )visited_packages) {
    pthread_mutex_lock(& lock.mutex);
    visited_packages = kh_init_ptr();
    tmp___0 = strdup("");
    hash_set(visited_packages, tmp___0, (void *)"");
    pthread_mutex_unlock(& lock.mutex);
  }
  if (0 == opts___0.force) {
    if (pkg) {
      if (pkg->name) {
        pthread_mutex_lock(& lock.mutex);
        tmp___1 = hash_has(visited_packages, pkg->name);
        if (tmp___1) {
          pthread_mutex_unlock(& lock.mutex);
          return (0);
        }
        pthread_mutex_unlock(& lock.mutex);
      }
    }
  }
  fetchs = (fetch_package_file_thread_data_t **)0;
  if ((unsigned long )((void *)0) != (unsigned long )pkg) {
    if ((unsigned long )((void *)0) != (unsigned long )pkg->src) {
      if ((pkg->src)->len > 0U) {
        tmp___2 = malloc((unsigned long )(pkg->src)->len * sizeof(fetch_package_file_thread_data_t ));
        fetchs = (fetch_package_file_thread_data_t **)tmp___2;
      }
    }
  }
  if (fetchs) {
    memset((void *)fetchs, 0, (unsigned long )(pkg->src)->len * sizeof(fetch_package_file_thread_data_t ));
  }
  if (! pkg) {
    rc = -1;
    goto cleanup;
  } else
  if (! dir) {
    rc = -1;
    goto cleanup;
  }
  set_prefix(pkg, path_max);
  pkg_dir = path_join(dir, (char const   *)pkg->name);
  if (! pkg_dir) {
    rc = -1;
    goto cleanup;
  }
  if (! opts___0.global) {
    if (! _debugger.name) {
      debug_init(& _debugger, "clib-package");
    }
    debug(& _debugger, "mkdir -p %s", pkg_dir);
    tmp___3 = mkdirp((char const   *)pkg_dir, (mode_t )511);
    if (-1 == tmp___3) {
      rc = -1;
      goto cleanup;
    }
  }
  if ((unsigned long )((void *)0) == (unsigned long )pkg->url) {
    pkg->url = clib_package_url((char const   *)pkg->author, (char const   *)pkg->repo_name,
                                (char const   *)pkg->version);
    if ((unsigned long )((void *)0) == (unsigned long )pkg->url) {
      rc = -1;
      goto cleanup;
    }
  }
  package_json = path_join((char const   *)pkg_dir, (char const   *)pkg->filename);
  if (! package_json) {
    rc = -1;
    goto cleanup;
  }
  if (! opts___0.global) {
    if ((unsigned long )((void *)0) != (unsigned long )pkg->src) {
      if (! _debugger.name) {
        debug_init(& _debugger, "clib-package");
      }
      debug(& _debugger, "write: %s", package_json);
      tmp___4 = fs_write((char const   *)package_json, (char const   *)pkg->json);
      if (-1 == tmp___4) {
        if (verbose) {
          cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
          cc_fprintf((cc_color_t )9, stderr, "Failed to write %s", package_json);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
        }
        rc = -1;
        goto cleanup;
      }
    }
  }
  if (pkg->name) {
    pthread_mutex_lock(& lock.mutex);
    tmp___6 = hash_has(visited_packages, pkg->name);
    if (! tmp___6) {
      tmp___5 = strdup((char const   *)pkg->name);
      hash_set(visited_packages, tmp___5, (void *)"t");
    }
    pthread_mutex_unlock(& lock.mutex);
  }
  if (! opts___0.global) {
    if (pkg->makefile) {
      if (! _debugger.name) {
        debug_init(& _debugger, "clib-package");
      }
      debug(& _debugger, "fetch: %s/%s", pkg->repo, pkg->makefile);
      fetch = (void *)0;
      rc = fetch_package_file(pkg, (char const   *)pkg_dir, pkg->makefile, verbose,
                              & fetch);
      if (0 != rc) {
        goto cleanup;
      }
      if ((unsigned long )((void *)0) != (unsigned long )fetch) {
        data = (fetch_package_file_thread_data_t *)fetch;
        pthread_join(data->thread, (void **)(& status));
        if ((unsigned long )((void *)0) != (unsigned long )status) {
          rc = *status;
          free((void *)status);
          status = (int *)0;
          if (0 != rc) {
            rc = 0;
            cc_fprintf((cc_color_t )4, stdout, "  %10s", "warning");
            fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
            cc_fprintf((cc_color_t )9, stdout, "unable to fetch Makefile (%s) for \'%s\'",
                       pkg->makefile, pkg->name);
            fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
          }
        }
      }
    }
  }
  if (opts___0.global) {
    goto install;
  } else
  if ((unsigned long )((void *)0) == (unsigned long )pkg->src) {
    goto install;
  }
  pthread_mutex_lock(& lock.mutex);
  tmp___8 = clib_cache_has_package(pkg->author, pkg->name, pkg->version);
  if (tmp___8) {
    if (opts___0.skip_cache) {
      clib_cache_delete_package(pkg->author, pkg->name, pkg->version);
      pthread_mutex_unlock(& lock.mutex);
      goto download;
    }
    tmp___7 = clib_cache_load_package(pkg->author, pkg->name, pkg->version, pkg_dir);
    if (0 != tmp___7) {
      pthread_mutex_unlock(& lock.mutex);
      goto download;
    }
    if (verbose) {
      cc_fprintf((cc_color_t )15, stdout, "  %10s", "cache");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stdout, (char const   *)pkg->repo);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
    }
    pthread_mutex_unlock(& lock.mutex);
    goto install;
  }
  pthread_mutex_unlock(& lock.mutex);
  download: 
  iterator = list_iterator_new(pkg->src, (list_direction_t )0);
  while (1) {
    source = list_iterator_next(iterator);
    if (! source) {
      break;
    }
    fetch___0 = (void *)0;
    rc = fetch_package_file(pkg, (char const   *)pkg_dir, (char *)source->val, verbose,
                            & fetch___0);
    if (0 != rc) {
      list_iterator_destroy(iterator);
      iterator = (list_iterator_t *)((void *)0);
      rc = -1;
      goto cleanup;
    }
    if (i < 0) {
      i = 0;
    }
    *(fetchs + i) = (fetch_package_file_thread_data_t *)fetch___0;
    pending ++;
    if (i < max - 1) {
      i ++;
    } else {
      j = 0;
      while (j <= i) {
        data___0 = *(fetchs + j);
        pthread_join(data___0->thread, (void **)(& status___0));
        free((void *)data___0);
        *(fetchs + j) = (fetch_package_file_thread_data_t *)((void *)0);
        pending --;
        if ((unsigned long )((void *)0) != (unsigned long )status___0) {
          rc = *status___0;
          free((void *)status___0);
          status___0 = (int *)0;
        }
        if (0 != rc) {
          rc = -1;
          goto cleanup;
        }
        j ++;
      }
      i = 0;
    }
  }
  j___0 = 0;
  while (j___0 < i) {
    data___1 = *(fetchs + j___0);
    pthread_join(data___1->thread, (void **)(& status___1));
    pending --;
    free((void *)data___1);
    *(fetchs + j___0) = (fetch_package_file_thread_data_t *)((void *)0);
    if ((unsigned long )((void *)0) != (unsigned long )status___1) {
      rc = *status___1;
      free((void *)status___1);
      status___1 = (int *)0;
    }
    if (0 != rc) {
      rc = -1;
      goto cleanup;
    }
    j___0 ++;
  }
  pthread_mutex_lock(& lock.mutex);
  clib_cache_save_package(pkg->author, pkg->name, pkg->version, pkg_dir);
  pthread_mutex_unlock(& lock.mutex);
  install: 
  if (pkg->configure) {
    rc = asprintf(& command, "cd %s/%s && %s", dir, pkg->name, pkg->configure);
    if (-1 == rc) {
      goto cleanup;
    }
    if (! _debugger.name) {
      debug_init(& _debugger, "clib-package");
    }
    debug(& _debugger, "command(configure): %s", command);
    rc = system((char const   *)command);
    if (0 != rc) {
      goto cleanup;
    }
  }
  if (0 == rc) {
    if (pkg->install) {
      rc = clib_package_install_executable(pkg, dir, verbose);
    }
  }
  if (0 == rc) {
    rc = clib_package_install_dependencies(pkg, dir, verbose);
  }
  cleanup: 
  if (pkg_dir) {
    free((void *)pkg_dir);
  }
  if (package_json) {
    free((void *)package_json);
  }
  if (iterator) {
    list_iterator_destroy(iterator);
  }
  if (command) {
    free((void *)command);
  }
  if ((unsigned long )((void *)0) != (unsigned long )pkg) {
    if ((unsigned long )((void *)0) != (unsigned long )pkg->src) {
      if ((pkg->src)->len > 0U) {
        if (fetchs) {
          free((void *)fetchs);
        }
      }
    }
  }
  fetchs = (fetch_package_file_thread_data_t **)((void *)0);
  return (rc);
}
}
int clib_package_install_dependencies(clib_package_t *pkg , char const   *dir , int verbose ) 
{ 
  int tmp ;

  {
  if (! pkg) {
    return (-1);
  } else
  if (! dir) {
    return (-1);
  }
  if ((unsigned long )((void *)0) == (unsigned long )pkg->dependencies) {
    return (0);
  }
  tmp = install_packages(pkg->dependencies, dir, verbose);
  return (tmp);
}
}
int clib_package_install_development(clib_package_t *pkg , char const   *dir , int verbose ) 
{ 
  int tmp ;

  {
  if (! pkg) {
    return (-1);
  } else
  if (! dir) {
    return (-1);
  }
  if ((unsigned long )((void *)0) == (unsigned long )pkg->development) {
    return (0);
  }
  tmp = install_packages(pkg->development, dir, verbose);
  return (tmp);
}
}
void clib_package_free(clib_package_t *pkg ) 
{ 


  {
  if ((unsigned long )((void *)0) == (unsigned long )pkg) {
    return;
  }
  if (0U != pkg->refs) {
    return;
  }
  if (pkg->author) {
    free((void *)pkg->author);
    pkg->author = (char *)0;
  }
  if (pkg->description) {
    free((void *)pkg->description);
    pkg->description = (char *)0;
  }
  if (pkg->install) {
    free((void *)pkg->install);
    pkg->install = (char *)0;
  }
  if (pkg->json) {
    free((void *)pkg->json);
    pkg->json = (char *)0;
  }
  if (pkg->license) {
    free((void *)pkg->license);
    pkg->license = (char *)0;
  }
  if (pkg->name) {
    free((void *)pkg->name);
    pkg->name = (char *)0;
  }
  if (pkg->makefile) {
    free((void *)pkg->makefile);
    pkg->makefile = (char *)0;
  }
  if (pkg->configure) {
    free((void *)pkg->configure);
    pkg->configure = (char *)0;
  }
  if (pkg->repo) {
    free((void *)pkg->repo);
    pkg->repo = (char *)0;
  }
  if (pkg->repo_name) {
    free((void *)pkg->repo_name);
    pkg->repo_name = (char *)0;
  }
  if (pkg->url) {
    free((void *)pkg->url);
    pkg->url = (char *)0;
  }
  if (pkg->version) {
    free((void *)pkg->version);
    pkg->version = (char *)0;
  }
  if (pkg->flags) {
    free((void *)pkg->flags);
    pkg->flags = (char *)0;
  }
  if (pkg->src) {
    list_destroy(pkg->src);
  }
  pkg->src = (list_t *)0;
  if (pkg->dependencies) {
    list_destroy(pkg->dependencies);
  }
  pkg->dependencies = (list_t *)0;
  if (pkg->development) {
    list_destroy(pkg->development);
  }
  pkg->development = (list_t *)0;
  free((void *)pkg);
  pkg = (clib_package_t *)0;
  return;
}
}
void clib_package_dependency_free(void *_dep ) 
{ 
  clib_package_dependency_t *dep ;

  {
  dep = (clib_package_dependency_t *)_dep;
  free((void *)dep->name);
  free((void *)dep->author);
  free((void *)dep->version);
  free((void *)dep);
  return;
}
}
void clib_package_cleanup(void) 
{ 
  char const   *key ;
  void *val ;
  khiter_t k ;

  {
  if ((unsigned long )((hash_t *)0) != (unsigned long )visited_packages) {
    k = (khint_t )0;
    while (k < visited_packages->n_buckets) {
      if (! (! ((*(visited_packages->flags + (k >> 4)) >> ((k & 15U) << 1)) & 3U))) {
        goto __Cont;
      }
      key = *(visited_packages->keys + k);
      val = *(visited_packages->vals + k);
      free((void *)key);
      __Cont: /* CIL Label */ 
      k ++;
    }
    kh_destroy_ptr(visited_packages);
    visited_packages = (hash_t *)0;
  }
  curl_share_cleanup(clib_package_curl_share);
  return;
}
}
#pragma merger("0","/tmp/cil-6iBwWrlc.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
http_get_response_t *http_get(char const   *url ) ;
static debug_t debugger___0  ;
char const   *clib_release_get_latest_tag(void) 
{ 
  http_get_response_t *res ;
  http_get_response_t *tmp ;
  JSON_Value *root_json ;
  JSON_Object *json_object___0 ;
  char *tag_name ;
  char const   *tmp___0 ;

  {
  debug_init(& debugger___0, "clib-release-info");
  tmp = http_get("https://api.github.com/repos/clibs/clib/releases/latest");
  res = tmp;
  root_json = (JSON_Value *)((void *)0);
  json_object___0 = (JSON_Object *)((void *)0);
  tag_name = (char *)((void *)0);
  if (! res->ok) {
    debug(& debugger___0, "Couldn\'t lookup latest release");
    goto cleanup;
  }
  root_json = json_parse_string((char const   *)res->data);
  if (! root_json) {
    debug(& debugger___0, "Unable to parse release JSON response");
    goto cleanup;
  }
  json_object___0 = json_value_get_object((JSON_Value const   *)root_json);
  if (! json_object___0) {
    debug(& debugger___0, "Unable to parse release JSON response object");
    goto cleanup;
  }
  tmp___0 = json_object_get_string((JSON_Object const   *)json_object___0, "tag_name");
  tag_name = strdup(tmp___0);
  if (! tag_name) {
    debug(& debugger___0, "strudp(tag_name) failed");
    goto cleanup;
  }
  cleanup: 
  if (root_json) {
    json_value_free(root_json);
  }
  http_get_free(res);
  return ((char const   *)tag_name);
}
}
#pragma merger("0","/tmp/cil-Q1Wi84y5.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
JSON_Value *json_parse_file(char const   *filename ) ;
JSON_Value *json_object_get_value(JSON_Object const   *object , char const   *name ) ;
JSON_Value_Type json_value_get_type(JSON_Value const   *value ) ;
int clib_validate(char const   *file ) 
{ 
  char const   *repo ;
  char *repo_owner ;
  char *repo_name ;
  int rc ;
  JSON_Value *root ;
  JSON_Object *obj ;
  JSON_Value *src ;
  int tmp ;
  char const   *__name ;
  char const   *tmp___0 ;
  char const   *__version ;
  char const   *tmp___1 ;
  char const   *__description ;
  char const   *tmp___2 ;
  char const   *__license ;
  char const   *tmp___3 ;
  JSON_Array *tmp___4 ;
  char const   *tmp___5 ;
  JSON_Value_Type tmp___6 ;

  {
  repo = (char const   *)((void *)0);
  repo_owner = (char *)((void *)0);
  repo_name = (char *)((void *)0);
  rc = 0;
  root = (JSON_Value *)((void *)0);
  obj = (JSON_Object *)((void *)0);
  src = (JSON_Value *)((void *)0);
  tmp = fs_exists(file);
  if (-1 == tmp) {
    rc = 1;
    cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
    cc_fprintf((cc_color_t )9, stderr, "no such file: %s", file);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    goto done;
  }
  root = json_parse_file(file);
  if (! root) {
    rc = 1;
    cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
    cc_fprintf((cc_color_t )9, stderr, "malformed file: %s", file);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    goto done;
  }
  obj = json_value_get_object((JSON_Value const   *)root);
  if (! obj) {
    rc = 1;
    cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
    cc_fprintf((cc_color_t )9, stderr, "malformed file: %s", file);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    goto done;
  }
  tmp___0 = json_object_get_string((JSON_Object const   *)obj, "name");
  __name = tmp___0;
  if (! __name) {
    cc_fprintf((cc_color_t )4, stdout, "  %10s", "warning");
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
    cc_fprintf((cc_color_t )9, stdout, "missing \"name\" in  %s", file);
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
  }
  tmp___1 = json_object_get_string((JSON_Object const   *)obj, "version");
  __version = tmp___1;
  if (! __version) {
    cc_fprintf((cc_color_t )4, stdout, "  %10s", "warning");
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
    cc_fprintf((cc_color_t )9, stdout, "missing \"version\" in  %s", file);
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
  }
  repo = json_object_get_string((JSON_Object const   *)obj, "repo");
  if (! repo) {
    cc_fprintf((cc_color_t )4, stdout, "  %10s", "warning");
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
    cc_fprintf((cc_color_t )9, stdout, "missing \"repo\" in  %s", file);
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
  } else {
    repo_name = parse_repo_name(repo);
    if (! repo_name) {
      cc_fprintf((cc_color_t )4, stdout, "  %10s", "warning");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stdout, "invalid repo");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
    }
    repo_owner = parse_repo_owner(repo, (char const   *)((void *)0));
    if (! repo_owner) {
      cc_fprintf((cc_color_t )4, stdout, "  %10s", "warning");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stdout, "invalid repo");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
    }
  }
  tmp___2 = json_object_get_string((JSON_Object const   *)obj, "description");
  __description = tmp___2;
  if (! __description) {
    cc_fprintf((cc_color_t )4, stdout, "  %10s", "warning");
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
    cc_fprintf((cc_color_t )9, stdout, "missing \"description\" in  %s", file);
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
  }
  tmp___3 = json_object_get_string((JSON_Object const   *)obj, "license");
  __license = tmp___3;
  if (! __license) {
    cc_fprintf((cc_color_t )4, stdout, "  %10s", "warning");
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
    cc_fprintf((cc_color_t )9, stdout, "missing \"license\" in  %s", file);
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
  }
  tmp___4 = json_object_get_array((JSON_Object const   *)obj, "keywords");
  if (! tmp___4) {
    cc_fprintf((cc_color_t )4, stdout, "  %10s", "warning");
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
    cc_fprintf((cc_color_t )9, stdout, "missing \"keywords\" in  %s", file);
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
  }
  src = json_object_get_value((JSON_Object const   *)obj, "src");
  if (! src) {
    tmp___5 = json_object_get_string((JSON_Object const   *)obj, "install");
    if (! tmp___5) {
      rc = 1;
      cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stderr, "Must have either src or install defined in %s",
                 file);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
      goto done;
    }
  } else {
    tmp___6 = json_value_get_type((JSON_Value const   *)src);
    if (tmp___6 != 5) {
      cc_fprintf((cc_color_t )4, stdout, "  %10s", "warning");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stdout, "src should be an array");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
    }
  }
  done: 
  if (root) {
    json_value_free(root);
  }
  return (rc);
}
}
#pragma merger("0","/tmp/cil-tSAnHBse.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
char const   *manifest_names[3]  = {      "clib.json",      "package.json",      (char const   *)0};
#pragma merger("0","/tmp/cil-FOSvivvK.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern int printf(char const   * __restrict  __format  , ...) ;
extern CURLcode curl_global_init(long flags ) ;
extern void curl_global_cleanup(void) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) char *dirname(char *__path ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern int usleep(__useconds_t __useconds ) ;
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
void command_init(command_t *self , char const   *name , char const   *version ) ;
void command_free(command_t *self ) ;
void command_option(command_t *self , char const   *small , char const   *large ,
                    char const   *desc , void (*cb)(struct command *self ) ) ;
void command_parse(command_t *self , int argc , char **argv ) ;
char *str_flatten(char const   **array , int start , int end ) ;
clib_package_opts_t package_opts  =    {0, 0, 0, (char *)0, 0, (char *)0};
clib_package_t *root_package  =    (clib_package_t *)0;
command_t program  = 
     {(void *)0, (char const   *)0, (char const   *)0, (char const   *)0, (char const   *)0,
    0, {{0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0},
        {0, 0, (char *)0, (char *)0, (char const   *)0, (char const   *)0, (char const   *)0,
         (void (*)(struct command *self ))0}, {0, 0, (char *)0, (char *)0, (char const   *)0,
                                               (char const   *)0, (char const   *)0,
                                               (void (*)(struct command *self ))0}},
    0, {(char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0,
        (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0,
        (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0,
        (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0, (char *)0,
        (char *)0, (char *)0, (char *)0, (char *)0}, (char **)0};
debug_t debugger  =    {(char const   *)0, 0, 0, (FILE *)0};
hash_t *built  =    (hash_t *)0;
char **rest_argv  =    (char **)0;
int rest_offset  =    0;
int rest_argc  =    0;
options_t opts  = 
     {"./deps", (char *)0, 0, 1, 0, 0, 0, (char *)0, (char *)0, 12U};
int build_package(char const   *dir ) ;
pthread_mutex_t mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
void *build_package_with_manifest_name_thread(void *arg ) 
{ 
  clib_package_thread_t *wrap ;
  char const   *dir ;

  {
  wrap = (clib_package_thread_t *)arg;
  dir = wrap->dir;
  build_package(dir);
  return ((void *)0);
}
}
int build_package_with_manifest_name(char const   *dir , char const   *file ) 
{ 
  clib_package_t *package ;
  char *json ;
  int ok ;
  int rc ;
  long path_max ;
  char *path ;
  char *tmp ;
  char const   *name ;
  char *json___0 ;
  unsigned int i ;
  unsigned long size ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *makefile ;
  char *tmp___4 ;
  char *command ;
  char *args ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *clean ;
  char *flags ;
  char *cflags ;
  char *tmp___7 ;
  unsigned long size___0 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  char *clean___0 ;
  char *make ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  list_iterator_t *iterator ;
  list_node_t *node ;
  unsigned int i___0 ;
  clib_package_dependency_t *dep ;
  char *slug ;
  char *dep_dir ;
  clib_package_t *dependency ;
  clib_package_t *tmp___12 ;
  clib_package_thread_t *wrap ;
  pthread_t *thread ;
  int j ;
  int j___0 ;
  list_iterator_t *iterator___0 ;
  list_node_t *node___0 ;
  unsigned int i___1 ;
  clib_package_dependency_t *dep___0 ;
  char *slug___0 ;
  clib_package_t *dependency___0 ;
  clib_package_t *tmp___13 ;
  char *dep_dir___0 ;
  char *tmp___14 ;
  clib_package_thread_t *wrap___0 ;
  pthread_t *thread___0 ;
  int j___1 ;
  int j___2 ;

  {
  package = (clib_package_t *)0;
  json = (char *)0;
  ok = 0;
  rc = 0;
  path_max = 4096L;
  tmp = path_join(dir, file);
  path = tmp;
  if ((unsigned long )((char *)0) == (unsigned long )path) {
    return (-12);
  }
  pthread_mutex_lock(& mutex);
  if (! root_package) {
    name = (char const   *)((void *)0);
    json___0 = (char *)((void *)0);
    i = 0U;
    while (1) {
      name = manifest_names[i];
      json___0 = fs_read(name);
      i ++;
      if ((unsigned long )((void *)0) != (unsigned long )manifest_names[i]) {
        if (! (! json___0)) {
          break;
        }
      } else {
        break;
      }
    }
    if (json___0) {
      root_package = clib_package_new((char const   *)json___0, opts.verbose);
    }
    if (root_package) {
      if (root_package->prefix) {
        char prefix[path_max] ;
        memset((void *)(prefix), 0, (size_t )path_max);
        realpath((char const   * __restrict  )root_package->prefix, (char * __restrict  )(prefix));
        tmp___0 = strlen((char const   *)(prefix));
        size = tmp___0 + 1UL;
        free((void *)root_package->prefix);
        tmp___1 = malloc(size);
        root_package->prefix = (char *)tmp___1;
        memset((void *)root_package->prefix, 0, size);
        memcpy((void * __restrict  )((void *)root_package->prefix), (void const   * __restrict  )(prefix),
               size);
      }
    }
  }
  tmp___2 = hash_has(built, path);
  if (tmp___2) {
    pthread_mutex_unlock(& mutex);
    goto cleanup;
  }
  pthread_mutex_unlock(& mutex);
  tmp___3 = fs_exists((char const   *)path);
  if (0 == tmp___3) {
    debug(& debugger, "read %s", path);
    json = fs_read((char const   *)path);
  }
  if ((unsigned long )((char *)0) != (unsigned long )json) {
    package = clib_package_new((char const   *)json, 0);
  } else {
    package = clib_package_new_from_slug(dir, 0);
  }
  if ((unsigned long )((clib_package_t *)0) == (unsigned long )package) {
    rc = -12;
    goto cleanup;
  }
  if ((unsigned long )((char *)0) != (unsigned long )package->makefile) {
    tmp___4 = path_join(dir, (char const   *)package->makefile);
    makefile = tmp___4;
    command = (char *)0;
    if (rest_argc > 0) {
      tmp___5 = str_flatten((char const   **)rest_argv, 0, rest_argc);
      tmp___6 = (char const   *)tmp___5;
    } else {
      tmp___6 = "";
    }
    args = (char *)tmp___6;
    clean = (char *)0;
    flags = (char *)0;
    tmp___7 = getenv("CFLAGS");
    cflags = tmp___7;
    if (cflags) {
      asprintf(& flags, "%s -I %s", cflags, opts.dir);
    } else {
      asprintf(& flags, "-I %s", opts.dir);
    }
    if (root_package) {
      if (root_package->prefix) {
        package_opts.prefix = root_package->prefix;
        clib_package_set_opts(package_opts);
        setenv("PREFIX", (char const   *)package_opts.prefix, 1);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (opts.prefix) {
      setenv("PREFIX", (char const   *)opts.prefix, 1);
    } else
    if (package->prefix) {
      char prefix___0[path_max] ;
      memset((void *)(prefix___0), 0, (size_t )path_max);
      realpath((char const   * __restrict  )package->prefix, (char * __restrict  )(prefix___0));
      tmp___8 = strlen((char const   *)(prefix___0));
      size___0 = tmp___8 + 1UL;
      free((void *)package->prefix);
      tmp___9 = malloc(size___0);
      package->prefix = (char *)tmp___9;
      memset((void *)package->prefix, 0, size___0);
      memcpy((void * __restrict  )((void *)package->prefix), (void const   * __restrict  )(prefix___0),
             size___0);
      setenv("PREFIX", (char const   *)package->prefix, 1);
    }
    setenv("CFLAGS", (char const   *)flags, 1);
    if (opts.clean) {
      clean___0 = (char *)0;
      asprintf(& clean___0, "make -C %s -f %s %s", dir, makefile, opts.clean);
    }
    make = (char *)0;
    if (opts.test) {
      asprintf(& make, "make -n -C %s -f %s %s >/dev/null 2>&1 && make -C %s -f %s %s",
               dir, makefile, opts.test, dir, makefile, opts.test);
    } else {
      asprintf(& make, "make -n -C %s -f %s >/dev/null 2>&1 && make -C %s -f %s",
               dir, makefile, dir, makefile);
    }
    if (opts.force) {
      tmp___10 = "-B";
    } else {
      tmp___10 = "";
    }
    if (clean) {
      tmp___11 = (char const   *)clean;
    } else {
      tmp___11 = ":";
    }
    asprintf(& command, "%s && %s %s %s", tmp___11, make, tmp___10, args);
    if (0 != opts.verbose) {
      cc_fprintf((cc_color_t )4, stdout, "  %10s", "build");
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
      cc_fprintf((cc_color_t )9, stdout, "%s: %s", package->name, package->makefile);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
    }
    debug(& debugger, "system: %s", command);
    rc = system((char const   *)command);
    free((void *)command);
    if (clean) {
      free((void *)clean);
    }
    free((void *)makefile);
    free((void *)make);
    free((void *)flags);
    if (rest_argc > 0) {
      free((void *)args);
    }
    command = (char *)0;
    rc = pthread_mutex_lock(& mutex);
    hash_set(built, path, (void *)"t");
    ok = 1;
  } else {
    rc = pthread_mutex_lock(& mutex);
    hash_set(built, path, (void *)"f");
    ok = 1;
  }
  if (0 != rc) {
    goto cleanup;
  }
  pthread_mutex_unlock(& mutex);
  if ((unsigned long )((list_t *)0) != (unsigned long )package->dependencies) {
    iterator = (list_iterator_t *)0;
    node = (list_node_t *)0;
    clib_package_thread_t wraps[opts.concurrency] ;
    pthread_t threads[opts.concurrency] ;
    i___0 = 0U;
    iterator = list_iterator_new(package->dependencies, (list_direction_t )0);
    while (1) {
      node = list_iterator_next(iterator);
      if (! node) {
        break;
      }
      dep = (clib_package_dependency_t *)node->val;
      slug = (char *)0;
      dep_dir = (char *)0;
      asprintf(& slug, "%s/%s@%s", dep->author, dep->name, dep->version);
      tmp___12 = clib_package_new_from_slug((char const   *)slug, 0);
      dependency = tmp___12;
      if (opts.dir) {
        if (dependency) {
          if (dependency->name) {
            dep_dir = path_join(opts.dir, (char const   *)dependency->name);
          }
        }
      }
      free((void *)slug);
      clib_package_free(dependency);
      if ((unsigned long )((char *)0) == (unsigned long )dep_dir) {
        rc = -12;
        goto cleanup;
      }
      wrap = & wraps[i___0];
      thread = & threads[i___0];
      wrap->dir = (char const   *)dep_dir;
      rc = pthread_create((pthread_t * __restrict  )thread, (pthread_attr_t const   * __restrict  )0,
                          & build_package_with_manifest_name_thread, (void * __restrict  )wrap);
      i___0 ++;
      if (i___0 >= opts.concurrency) {
        j = 0;
        while ((unsigned int )j < i___0) {
          pthread_join(threads[j], (void **)0);
          free((void *)wraps[j].dir);
          j ++;
        }
        i___0 = 0U;
      }
      usleep((__useconds_t )10240);
    }
    j___0 = 0;
    while ((unsigned int )j___0 < i___0) {
      pthread_join(threads[j___0], (void **)0);
      free((void *)wraps[j___0].dir);
      j___0 ++;
    }
    if ((unsigned long )((list_iterator_t *)0) != (unsigned long )iterator) {
      list_iterator_destroy(iterator);
    }
  }
  if (opts.dev) {
    if ((unsigned long )((list_t *)0) != (unsigned long )package->development) {
      iterator___0 = (list_iterator_t *)0;
      node___0 = (list_node_t *)0;
      clib_package_thread_t wraps___0[opts.concurrency] ;
      pthread_t threads___0[opts.concurrency] ;
      i___1 = 0U;
      iterator___0 = list_iterator_new(package->development, (list_direction_t )0);
      while (1) {
        node___0 = list_iterator_next(iterator___0);
        if (! node___0) {
          break;
        }
        dep___0 = (clib_package_dependency_t *)node___0->val;
        slug___0 = (char *)0;
        asprintf(& slug___0, "%s/%s@%s", dep___0->author, dep___0->name, dep___0->version);
        tmp___13 = clib_package_new_from_slug((char const   *)slug___0, 0);
        dependency___0 = tmp___13;
        tmp___14 = path_join(opts.dir, (char const   *)dependency___0->name);
        dep_dir___0 = tmp___14;
        free((void *)slug___0);
        clib_package_free(dependency___0);
        wrap___0 = & wraps___0[i___1];
        thread___0 = & threads___0[i___1];
        wrap___0->dir = (char const   *)dep_dir___0;
        rc = pthread_create((pthread_t * __restrict  )thread___0, (pthread_attr_t const   * __restrict  )0,
                            & build_package_with_manifest_name_thread, (void * __restrict  )wrap___0);
        i___1 ++;
        if (i___1 >= opts.concurrency) {
          j___1 = 0;
          while ((unsigned int )j___1 < i___1) {
            pthread_join(threads___0[j___1], (void **)0);
            free((void *)wraps___0[j___1].dir);
            j___1 ++;
          }
          i___1 = 0U;
        }
        usleep((__useconds_t )10240);
      }
      j___2 = 0;
      while ((unsigned int )j___2 < i___1) {
        pthread_join(threads___0[j___2], (void **)0);
        free((void *)wraps___0[j___2].dir);
        j___2 ++;
      }
      if ((unsigned long )((list_iterator_t *)0) != (unsigned long )iterator___0) {
        list_iterator_destroy(iterator___0);
      }
    }
  }
  cleanup: 
  if ((unsigned long )((clib_package_t *)0) != (unsigned long )package) {
    clib_package_free(package);
  }
  if ((unsigned long )((char *)0) != (unsigned long )json) {
    free((void *)json);
  }
  if (0 == ok) {
    if ((unsigned long )((char *)0) != (unsigned long )path) {
      free((void *)path);
    }
  }
  return (rc);
}
}
int build_package(char const   *dir ) 
{ 
  char const   *name ;
  unsigned int i ;
  int rc ;

  {
  name = (char const   *)((void *)0);
  i = 0U;
  rc = 0;
  while (1) {
    name = manifest_names[i];
    rc = build_package_with_manifest_name(dir, name);
    i ++;
    if ((unsigned long )((void *)0) != (unsigned long )manifest_names[i]) {
      if (! (0 != rc)) {
        break;
      }
    } else {
      break;
    }
  }
  return (rc);
}
}
static void setopt_skip_cache(command_t *self ) 
{ 


  {
  opts.skip_cache = 1;
  debug(& debugger, "set skip cache flag");
  return;
}
}
static void setopt_dev(command_t *self ) 
{ 


  {
  opts.dev = 1;
  debug(& debugger, "set dev flag");
  return;
}
}
static void setopt_force(command_t *self ) 
{ 


  {
  opts.force = 1;
  debug(& debugger, "set force flag");
  return;
}
}
static void setopt_global(command_t *self ) 
{ 


  {
  opts.global = 1;
  debug(& debugger, "set global flag");
  return;
}
}
static void setopt_clean(command_t *self ) 
{ 


  {
  if (self->arg) {
    if (45 != (int )*(self->arg + 0)) {
      opts.clean = (char *)self->arg;
    } else {
      opts.clean = (char *)"clean";
    }
  } else {
    opts.clean = (char *)"clean";
  }
  debug(& debugger, "set clean flag");
  return;
}
}
static void setopt_test(command_t *self ) 
{ 


  {
  if (self->arg) {
    if (45 != (int )*(self->arg + 0)) {
      opts.test = (char *)self->arg;
    } else {
      opts.test = (char *)"test";
    }
  } else {
    opts.test = (char *)"test";
  }
  debug(& debugger, "set test flag");
  return;
}
}
static void setopt_prefix(command_t *self ) 
{ 


  {
  if (self->arg) {
    if (45 != (int )*(self->arg + 0)) {
      opts.prefix = (char *)self->arg;
    }
  }
  debug(& debugger, "set prefix: %s", opts.prefix);
  return;
}
}
static void setopt_dir(command_t *self ) 
{ 


  {
  opts.dir = (char const   *)((char *)self->arg);
  debug(& debugger, "set dir: %s", opts.dir);
  return;
}
}
static void setopt_quiet(command_t *self ) 
{ 


  {
  opts.verbose = 0;
  debug(& debugger, "set quiet flag");
  return;
}
}
static void setopt_concurrency(command_t *self ) 
{ 
  long tmp ;

  {
  if (self->arg) {
    tmp = atol(self->arg);
    opts.concurrency = (unsigned int )tmp;
    debug(& debugger, "set concurrency: %lu", opts.concurrency);
  }
  return;
}
}
int main(int argc , char **argv ) 
{ 
  int rc ;
  long path_max ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned long size ;
  size_t tmp___2 ;
  void *tmp___3 ;
  unsigned long size___0 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int rest ;
  int i ;
  char *arg ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int j ;
  int i___0 ;
  int tmp___8 ;
  int tmp___9 ;
  CURLcode tmp___10 ;
  int i___1 ;
  char *dep ;
  fs_stats *stats ;
  fs_stats *tmp___11 ;
  fs_stats *stats___0 ;
  fs_stats *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int total_built ;
  char const   *key ;
  void *val ;
  khiter_t k ;
  int tmp___15 ;
  char *context ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;

  {
  rc = 0;
  path_max = 4096L;
  char CWD[path_max] ;
  memset((void *)(CWD), 0, (size_t )path_max);
  tmp___0 = getcwd(CWD, (size_t )path_max);
  if ((unsigned long )((char *)0) == (unsigned long )tmp___0) {
    tmp = __errno_location();
    return (- *tmp);
  }
  built = kh_init_ptr();
  tmp___1 = strdup("__clib-build__");
  hash_set(built, tmp___1, (void *)"2.8.0");
  command_init(& program, "clib-build", "2.8.0");
  debug_init(& debugger, "clib-build");
  program.usage = "[options] [name ...]";
  command_option(& program, "-o", "--out <dir>", "change the output directory [deps]",
                 & setopt_dir);
  command_option(& program, "-P", "--prefix <dir>", "change the prefix directory (usually \'/usr/local\')",
                 & setopt_prefix);
  command_option(& program, "-q", "--quiet", "disable verbose output", & setopt_quiet);
  command_option(& program, "-g", "--global", "use global target", & setopt_global);
  command_option(& program, "-C", "--clean [clean_target]", "clean target before building (default: clean)",
                 & setopt_clean);
  command_option(& program, "-T", "--test [test_target]", "test target instead of building (default: test)",
                 & setopt_test);
  command_option(& program, "-d", "--dev", "build development dependencies", & setopt_dev);
  command_option(& program, "-f", "--force", "force the action of something, like overwriting a file",
                 & setopt_force);
  command_option(& program, "-c", "--skip-cache", "skip cache when configuring", & setopt_skip_cache);
  command_option(& program, "-C", "--concurrency <number>", "Set concurrency (default: 12)",
                 & setopt_concurrency);
  command_parse(& program, argc, argv);
  if (opts.dir) {
    char dir[path_max] ;
    memset((void *)(dir), 0, (size_t )path_max);
    realpath((char const   * __restrict  )opts.dir, (char * __restrict  )(dir));
    tmp___2 = strlen((char const   *)(dir));
    size = tmp___2 + 1UL;
    tmp___3 = malloc(size);
    opts.dir = (char const   *)tmp___3;
    memset((void *)opts.dir, 0, size);
    memcpy((void * __restrict  )((void *)opts.dir), (void const   * __restrict  )(dir),
           size);
  }
  if (opts.prefix) {
    char prefix[path_max] ;
    memset((void *)(prefix), 0, (size_t )path_max);
    realpath((char const   * __restrict  )opts.prefix, (char * __restrict  )(prefix));
    tmp___4 = strlen((char const   *)(prefix));
    size___0 = tmp___4 + 1UL;
    tmp___5 = malloc(size___0);
    opts.prefix = (char *)tmp___5;
    memset((void *)opts.prefix, 0, size___0);
    memcpy((void * __restrict  )((void *)opts.prefix), (void const   * __restrict  )(prefix),
           size___0);
  }
  rest_offset = program.argc;
  if (argc > 0) {
    rest = 0;
    i = 0;
    while (1) {
      arg = *(program.nargv + i);
      if (arg) {
        if (45 == (int )*(arg + 0)) {
          if (45 == (int )*(arg + 1)) {
            tmp___6 = strlen((char const   *)arg);
            if (2UL == tmp___6) {
              rest = 1;
              rest_offset = i + 1;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
      if (arg) {
        if (rest) {
          rest_argc ++;
        }
      }
      i ++;
      if (! *(program.nargv + i)) {
        break;
      }
    }
  }
  if (rest_argc > 0) {
    tmp___7 = malloc((unsigned long )rest_argc * sizeof(char *));
    rest_argv = (char **)tmp___7;
    memset((void *)rest_argv, 0, (unsigned long )rest_argc * sizeof(char *));
    j = 0;
    i___0 = rest_offset;
    while (1) {
      tmp___8 = j;
      j ++;
      tmp___9 = i___0;
      i___0 ++;
      *(rest_argv + tmp___8) = *(program.nargv + tmp___9);
      if (! *(program.nargv + i___0)) {
        break;
      }
    }
  }
  tmp___10 = curl_global_init((long )(1 | (1 << 1)));
  if (0U != (unsigned int )tmp___10) {
    cc_fprintf((cc_color_t )2, stderr, "  %10s", "error");
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" : ");
    cc_fprintf((cc_color_t )9, stderr, "Failed to initialize cURL");
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    return (1);
  }
  clib_cache_init((time_t )2592000);
  package_opts.skip_cache = opts.skip_cache;
  package_opts.prefix = opts.prefix;
  package_opts.global = opts.global;
  package_opts.force = opts.force;
  clib_package_set_opts(package_opts);
  if (0 == program.argc) {
    rc = build_package((char const   *)(CWD));
  } else
  if (argc == rest_offset + rest_argc) {
    rc = build_package((char const   *)(CWD));
  } else {
    i___1 = 1;
    while (i___1 <= rest_offset) {
      dep = *(program.nargv + i___1);
      if (46 == (int )*(dep + 0)) {
        char dir___0[path_max] ;
        memset((void *)(dir___0), 0, (size_t )path_max);
        dep = realpath((char const   * __restrict  )dep, (char * __restrict  )(dir___0));
      } else {
        tmp___11 = fs_stat((char const   *)dep);
        stats = tmp___11;
        if (! stats) {
          dep = path_join(opts.dir, (char const   *)dep);
        } else {
          free((void *)stats);
        }
      }
      tmp___12 = fs_stat((char const   *)dep);
      stats___0 = tmp___12;
      if (stats___0) {
        if (32768U == (stats___0->st_mode & 61440U)) {
          dep = __xpg_basename(dep);
          tmp___13 = __xpg_basename(dep);
          tmp___14 = dirname(dep);
          rc = build_package_with_manifest_name((char const   *)tmp___14, (char const   *)tmp___13);
        } else
        if (40960U == (stats___0->st_mode & 61440U)) {
          dep = __xpg_basename(dep);
          tmp___13 = __xpg_basename(dep);
          tmp___14 = dirname(dep);
          rc = build_package_with_manifest_name((char const   *)tmp___14, (char const   *)tmp___13);
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        rc = build_package((char const   *)dep);
        if (0 != rc) {
          rc = build_package((char const   *)*(program.nargv + i___1));
        }
      }
      if (stats___0) {
        free((void *)stats___0);
        stats___0 = (fs_stats *)0;
      }
      i___1 ++;
    }
  }
  total_built = 0;
  k = (khint_t )0;
  while (k < built->n_buckets) {
    if (! (! ((*(built->flags + (k >> 4)) >> ((k & 15U) << 1)) & 3U))) {
      goto __Cont;
    }
    key = *(built->keys + k);
    val = *(built->vals + k);
    tmp___15 = strncmp("t", (char const   *)val, (size_t )1);
    if (0 == tmp___15) {
      total_built ++;
    }
    if ((unsigned long )((char const   *)0) != (unsigned long )key) {
      free((void *)key);
    }
    __Cont: /* CIL Label */ 
    k ++;
  }
  kh_destroy_ptr(built);
  command_free(& program);
  curl_global_cleanup();
  clib_package_cleanup();
  if (opts.dir) {
    free((void *)opts.dir);
  }
  if (opts.prefix) {
    free((void *)opts.prefix);
  }
  if (rest_argc > 0) {
    free((void *)rest_argv);
    rest_offset = 0;
    rest_argc = 0;
    rest_argv = (char **)0;
  }
  if (0 == rc) {
    if (total_built > 0) {
      printf((char const   * __restrict  )"\n");
    }
    if (opts.verbose) {
      context = (char *)"";
      if (opts.clean) {
        goto _L___4;
      } else
      if (opts.test) {
        _L___4: /* CIL Label */ 
        context = (char *)0;
        if (opts.clean) {
          if (opts.test) {
            tmp___17 = "clean test";
          } else {
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
          if (opts.clean) {
            tmp___16 = "clean";
          } else {
            tmp___16 = "test";
          }
          tmp___17 = tmp___16;
        }
        asprintf(& context, " (%s) ", tmp___17);
      }
      if (total_built > 1) {
        cc_fprintf((cc_color_t )15, stdout, "  %10s", "info");
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
        cc_fprintf((cc_color_t )9, stdout, "built %d packages%s", total_built, context);
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      } else
      if (1 == total_built) {
        cc_fprintf((cc_color_t )15, stdout, "  %10s", "info");
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
        cc_fprintf((cc_color_t )9, stdout, "built 1 package%s", context);
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      } else {
        cc_fprintf((cc_color_t )15, stdout, "  %10s", "info");
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" : ");
        cc_fprintf((cc_color_t )9, stdout, "built 0 packages%s", context);
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
      }
      if (opts.clean) {
        free((void *)context);
      } else
      if (opts.test) {
        free((void *)context);
      }
    }
  }
  return (rc);
}
}
#pragma merger("0","/tmp/cil-8uY_h7M1.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
size_t occurrences(char const   *needle , char const   *haystack ) ;
char *str_replace(char const   *str , char const   *sub , char const   *replace ) ;
char *str_replace(char const   *str , char const   *sub , char const   *replace ) 
{ 
  char *pos ;
  int count ;
  size_t tmp ;
  char *tmp___0 ;
  int size ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *result ;
  void *tmp___4 ;
  char *current ;
  int len ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
  pos = (char *)str;
  tmp = occurrences(sub, str);
  count = (int )tmp;
  if (0 >= count) {
    tmp___0 = strdup(str);
    return (tmp___0);
  }
  tmp___1 = strlen(str);
  tmp___2 = strlen(sub);
  tmp___3 = strlen(replace);
  size = (int )(((tmp___1 - tmp___2 * (size_t )count) + tmp___3 * (size_t )count) + 1UL);
  tmp___4 = malloc((size_t )size);
  result = (char *)tmp___4;
  if ((unsigned long )((void *)0) == (unsigned long )result) {
    return ((char *)((void *)0));
  }
  memset((void *)result, '\000', (size_t )size);
  while (1) {
    current = strstr((char const   *)pos, sub);
    if (! current) {
      break;
    }
    len = (int )(current - pos);
    strncat((char * __restrict  )result, (char const   * __restrict  )pos, (size_t )len);
    tmp___5 = strlen(replace);
    strncat((char * __restrict  )result, (char const   * __restrict  )replace, tmp___5);
    tmp___6 = strlen(sub);
    pos = current + tmp___6;
  }
  tmp___7 = strlen(str);
  if ((unsigned long )pos != (unsigned long )(str + tmp___7)) {
    strncat((char * __restrict  )result, (char const   * __restrict  )pos, (size_t )(str - (char const   *)pos));
  }
  return (result);
}
}
#pragma merger("0","/tmp/cil-qx2ZvyoX.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
char *substr(char const   *str , int start , int end ) ;
char *substr(char const   *str , int start , int end ) 
{ 
  int len ;
  size_t tmp ;
  int diff ;
  char *tmp___0 ;
  char *res ;
  void *tmp___1 ;

  {
  if (0 > start) {
    return ((char *)((void *)0));
  }
  tmp = strlen(str);
  len = (int )tmp;
  if (-1 == end) {
    end = len;
  }
  if (end <= start) {
    return ((char *)((void *)0));
  }
  diff = end - start;
  if (len == diff) {
    tmp___0 = strdup(str);
    return (tmp___0);
  }
  if (len < start) {
    return ((char *)((void *)0));
  }
  if (len + 1 < end) {
    return ((char *)((void *)0));
  }
  tmp___1 = malloc(sizeof(char ) * (unsigned long )diff + 1UL);
  res = (char *)tmp___1;
  if ((unsigned long )((void *)0) == (unsigned long )res) {
    return ((char *)((void *)0));
  }
  memset((void *)res, '\000', (size_t )(diff + 1));
  strncpy((char * __restrict  )res, (char const   * __restrict  )(str + start), (size_t )diff);
  return (res);
}
}
#pragma merger("0","/tmp/cil-AXbfoYWd.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
list_node_t *list_lpush(list_t *self , list_node_t *node ) ;
list_node_t *list_find(list_t *self , void *val ) ;
list_node_t *list_at(list_t *self , int index ) ;
list_node_t *list_rpop(list_t *self ) ;
list_node_t *list_lpop(list_t *self ) ;
void list_remove(list_t *self , list_node_t *node ) ;
list_t *list_new(void) 
{ 
  list_t *self ;
  void *tmp ;

  {
  tmp = malloc(sizeof(list_t ));
  self = (list_t *)tmp;
  if (! self) {
    return ((list_t *)((void *)0));
  }
  self->head = (list_node_t *)((void *)0);
  self->tail = (list_node_t *)((void *)0);
  self->free = (void (*)(void *val ))((void *)0);
  self->match = (int (*)(void *a , void *b ))((void *)0);
  self->len = 0U;
  return (self);
}
}
void list_destroy(list_t *self ) 
{ 
  unsigned int len ;
  list_node_t *next ;
  list_node_t *curr ;
  unsigned int tmp ;

  {
  len = self->len;
  curr = self->head;
  while (1) {
    tmp = len;
    len --;
    if (! tmp) {
      break;
    }
    next = curr->next;
    if (self->free) {
      (*(self->free))(curr->val);
    }
    free((void *)curr);
    curr = next;
  }
  free((void *)self);
  return;
}
}
list_node_t *list_rpush(list_t *self , list_node_t *node ) 
{ 
  list_node_t *tmp ;
  struct list_node *tmp___0 ;

  {
  if (! node) {
    return ((list_node_t *)((void *)0));
  }
  if (self->len) {
    node->prev = self->tail;
    node->next = (struct list_node *)((void *)0);
    (self->tail)->next = node;
    self->tail = node;
  } else {
    tmp = node;
    self->tail = tmp;
    self->head = tmp;
    tmp___0 = (struct list_node *)((void *)0);
    node->next = tmp___0;
    node->prev = tmp___0;
  }
  (self->len) ++;
  return (node);
}
}
list_node_t *list_rpop(list_t *self ) 
{ 
  list_node_t *node ;
  list_node_t *tmp ;
  list_node_t *tmp___0 ;
  struct list_node *tmp___1 ;

  {
  if (! self->len) {
    return ((list_node_t *)((void *)0));
  }
  node = self->tail;
  (self->len) --;
  if (self->len) {
    tmp = node->prev;
    self->tail = tmp;
    tmp->next = (struct list_node *)((void *)0);
  } else {
    tmp___0 = (list_node_t *)((void *)0);
    self->head = tmp___0;
    self->tail = tmp___0;
  }
  tmp___1 = (struct list_node *)((void *)0);
  node->prev = tmp___1;
  node->next = tmp___1;
  return (node);
}
}
list_node_t *list_lpop(list_t *self ) 
{ 
  list_node_t *node ;
  list_node_t *tmp ;
  list_node_t *tmp___0 ;
  struct list_node *tmp___1 ;

  {
  if (! self->len) {
    return ((list_node_t *)((void *)0));
  }
  node = self->head;
  (self->len) --;
  if (self->len) {
    tmp = node->next;
    self->head = tmp;
    tmp->prev = (struct list_node *)((void *)0);
  } else {
    tmp___0 = (list_node_t *)((void *)0);
    self->tail = tmp___0;
    self->head = tmp___0;
  }
  tmp___1 = (struct list_node *)((void *)0);
  node->prev = tmp___1;
  node->next = tmp___1;
  return (node);
}
}
list_node_t *list_lpush(list_t *self , list_node_t *node ) 
{ 
  list_node_t *tmp ;
  struct list_node *tmp___0 ;

  {
  if (! node) {
    return ((list_node_t *)((void *)0));
  }
  if (self->len) {
    node->next = self->head;
    node->prev = (struct list_node *)((void *)0);
    (self->head)->prev = node;
    self->head = node;
  } else {
    tmp = node;
    self->tail = tmp;
    self->head = tmp;
    tmp___0 = (struct list_node *)((void *)0);
    node->next = tmp___0;
    node->prev = tmp___0;
  }
  (self->len) ++;
  return (node);
}
}
list_node_t *list_find(list_t *self , void *val ) 
{ 
  list_iterator_t *it ;
  list_iterator_t *tmp ;
  list_node_t *node ;
  int tmp___0 ;

  {
  tmp = list_iterator_new(self, (list_direction_t )0);
  it = tmp;
  while (1) {
    node = list_iterator_next(it);
    if (! node) {
      break;
    }
    if (self->match) {
      tmp___0 = (*(self->match))(val, node->val);
      if (tmp___0) {
        list_iterator_destroy(it);
        return (node);
      }
    } else
    if ((unsigned long )val == (unsigned long )node->val) {
      list_iterator_destroy(it);
      return (node);
    }
  }
  list_iterator_destroy(it);
  return ((list_node_t *)((void *)0));
}
}
list_node_t *list_at(list_t *self , int index ) 
{ 
  list_direction_t direction ;
  list_iterator_t *it ;
  list_iterator_t *tmp ;
  list_node_t *node ;
  list_node_t *tmp___0 ;
  int tmp___1 ;

  {
  direction = (list_direction_t )0;
  if (index < 0) {
    direction = (list_direction_t )1;
    index = ~ index;
  }
  if ((unsigned int )index < self->len) {
    tmp = list_iterator_new(self, direction);
    it = tmp;
    tmp___0 = list_iterator_next(it);
    node = tmp___0;
    while (1) {
      tmp___1 = index;
      index --;
      if (! tmp___1) {
        break;
      }
      node = list_iterator_next(it);
    }
    list_iterator_destroy(it);
    return (node);
  }
  return ((list_node_t *)((void *)0));
}
}
void list_remove(list_t *self , list_node_t *node ) 
{ 


  {
  if (node->prev) {
    (node->prev)->next = node->next;
  } else {
    self->head = node->next;
  }
  if (node->next) {
    (node->next)->prev = node->prev;
  } else {
    self->tail = node->prev;
  }
  if (self->free) {
    (*(self->free))(node->val);
  }
  free((void *)node);
  (self->len) --;
  return;
}
}
#pragma merger("0","/tmp/cil-glu3NnSZ.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
list_node_t *list_node_new(void *val ) 
{ 
  list_node_t *self ;
  void *tmp ;

  {
  tmp = malloc(sizeof(list_node_t ));
  self = (list_node_t *)tmp;
  if (! self) {
    return ((list_node_t *)((void *)0));
  }
  self->prev = (struct list_node *)((void *)0);
  self->next = (struct list_node *)((void *)0);
  self->val = val;
  return (self);
}
}
#pragma merger("0","/tmp/cil-_HF2FAjD.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
list_iterator_t *list_iterator_new_from_node(list_node_t *node , list_direction_t direction ) ;
list_iterator_t *list_iterator_new(list_t *list , list_direction_t direction ) 
{ 
  list_node_t *node ;
  list_node_t *tmp ;
  list_iterator_t *tmp___0 ;

  {
  if ((unsigned int )direction == 0U) {
    tmp = list->head;
  } else {
    tmp = list->tail;
  }
  node = tmp;
  tmp___0 = list_iterator_new_from_node(node, direction);
  return (tmp___0);
}
}
list_iterator_t *list_iterator_new_from_node(list_node_t *node , list_direction_t direction ) 
{ 
  list_iterator_t *self ;
  void *tmp ;

  {
  tmp = malloc(sizeof(list_iterator_t ));
  self = (list_iterator_t *)tmp;
  if (! self) {
    return ((list_iterator_t *)((void *)0));
  }
  self->next = node;
  self->direction = direction;
  return (self);
}
}
list_node_t *list_iterator_next(list_iterator_t *self ) 
{ 
  list_node_t *curr ;

  {
  curr = self->next;
  if (curr) {
    if ((unsigned int )self->direction == 0U) {
      self->next = curr->next;
    } else {
      self->next = curr->prev;
    }
  }
  return (curr);
}
}
void list_iterator_destroy(list_iterator_t *self ) 
{ 


  {
  free((void *)self);
  self = (list_iterator_t *)((void *)0);
  return;
}
}
#pragma merger("0","/tmp/cil-R8eJrCBh.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __file ,
                                                                                    struct stat * __restrict  __buf ) ;
int fs_mkdir(char const   *path , int mode ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
__inline static int tinydir_open(tinydir_dir *dir , char const   *path ) ;
__inline static void tinydir_close(tinydir_dir *dir ) ;
__inline static int tinydir_next(tinydir_dir *dir ) ;
__inline static int tinydir_readfile(tinydir_dir const   *dir , tinydir_file *file ) ;
__inline static void _tinydir_get_ext(tinydir_file *file ) ;
__inline static int tinydir_open(tinydir_dir *dir , char const   *path ) 
{ 
  char *pathp ;
  int *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  } else
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  } else {
    tmp___0 = strlen(path);
    if (tmp___0 == 0UL) {
      tmp = __errno_location();
      *tmp = 22;
      return (-1);
    }
  }
  tmp___2 = strlen(path);
  if (tmp___2 >= 4096UL) {
    tmp___1 = __errno_location();
    *tmp___1 = 36;
    return (-1);
  }
  dir->_files = (tinydir_file *)((void *)0);
  dir->_d = (DIR *)((void *)0);
  tinydir_close(dir);
  strcpy((char * __restrict  )(dir->path), (char const   * __restrict  )path);
  tmp___3 = strlen((char const   *)(dir->path));
  pathp = & dir->path[tmp___3 - 1UL];
  while (1) {
    if ((unsigned long )pathp != (unsigned long )(dir->path)) {
      if (! ((int )*pathp == 92)) {
        if (! ((int )*pathp == 47)) {
          break;
        }
      }
    } else {
      break;
    }
    *pathp = (char )'\000';
    pathp ++;
  }
  dir->_d = opendir(path);
  if ((unsigned long )dir->_d == (unsigned long )((void *)0)) {
    goto bail;
  }
  dir->has_next = 1;
  dir->_e = readdir(dir->_d);
  if ((unsigned long )dir->_e == (unsigned long )((void *)0)) {
    dir->has_next = 0;
  }
  return (0);
  bail: 
  tinydir_close(dir);
  return (-1);
}
}
__inline static void tinydir_close(tinydir_dir *dir ) 
{ 


  {
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    return;
  }
  memset((void *)(dir->path), 0, sizeof(dir->path));
  dir->has_next = 0;
  dir->n_files = (size_t )0;
  free((void *)dir->_files);
  dir->_files = (tinydir_file *)((void *)0);
  if (dir->_d) {
    closedir(dir->_d);
  }
  dir->_d = (DIR *)((void *)0);
  dir->_e = (struct dirent *)((void *)0);
  return;
}
}
__inline static int tinydir_next(tinydir_dir *dir ) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  if (! dir->has_next) {
    tmp___0 = __errno_location();
    *tmp___0 = 2;
    return (-1);
  }
  dir->_e = readdir(dir->_d);
  if ((unsigned long )dir->_e == (unsigned long )((void *)0)) {
    dir->has_next = 0;
  }
  return (0);
}
}
__inline static int tinydir_readfile(tinydir_dir const   *dir , tinydir_file *file ) 
{ 
  char const   *filename ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  } else
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  if ((unsigned long )dir->_e == (unsigned long )((void *)0)) {
    tmp___0 = __errno_location();
    *tmp___0 = 2;
    return (-1);
  }
  filename = (char const   *)((dir->_e)->d_name);
  tmp___2 = strlen((char const   *)(dir->path));
  tmp___3 = strlen(filename);
  if ((tmp___2 + tmp___3) + 1UL >= 4096UL) {
    tmp___1 = __errno_location();
    *tmp___1 = 36;
    return (-1);
  }
  tmp___5 = strlen(filename);
  if (tmp___5 >= 256UL) {
    tmp___4 = __errno_location();
    *tmp___4 = 36;
    return (-1);
  }
  strcpy((char * __restrict  )(file->path), (char const   * __restrict  )(dir->path));
  tmp___6 = strcmp((char const   *)(dir->path), "/");
  if (tmp___6 != 0) {
    strcat((char * __restrict  )(file->path), (char const   * __restrict  )"/");
  }
  strcpy((char * __restrict  )(file->name), (char const   * __restrict  )filename);
  strcat((char * __restrict  )(file->path), (char const   * __restrict  )filename);
  tmp___7 = lstat((char const   * __restrict  )(file->path), (struct stat * __restrict  )(& file->_s));
  if (tmp___7 == -1) {
    return (-1);
  }
  _tinydir_get_ext(file);
  file->is_dir = (file->_s.st_mode & 61440U) == 16384U;
  file->is_reg = (file->_s.st_mode & 61440U) == 32768U;
  return (0);
}
}
__inline static void _tinydir_get_ext(tinydir_file *file ) 
{ 
  char *period ;
  char *tmp ;
  size_t tmp___0 ;

  {
  tmp = strrchr((char const   *)(file->name), '.');
  period = tmp;
  if ((unsigned long )period == (unsigned long )((void *)0)) {
    tmp___0 = strlen((char const   *)(file->name));
    file->extension = & file->name[tmp___0];
  } else {
    file->extension = period + 1;
  }
  return;
}
}
int copy_file(char *from , char *to ) ;
int copy_file(char *from , char *to ) 
{ 
  char *content ;
  char *tmp ;

  {
  tmp = fs_read((char const   *)from);
  content = tmp;
  if (! content) {
    return (-1);
  }
  fs_write((char const   *)to, (char const   *)content);
  free((void *)content);
  return (0);
}
}
static void check_dir___0(char *dir ) 
{ 
  int tmp ;

  {
  tmp = fs_exists((char const   *)dir);
  if (0 != tmp) {
    fs_mkdir((char const   *)dir, 448);
  }
  return;
}
}
static int copy(tinydir_file file , char *target_dir ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  tmp = strlen((char const   *)target_dir);
  tmp___0 = strlen((char const   *)(file.name));
  char target_path[(tmp + tmp___0) + 2UL] ;
  sprintf((char * __restrict  )(target_path), (char const   * __restrict  )"%s/%s",
          target_dir, file.name);
  if (file.is_dir) {
    tmp___5 = copy_dir(file.path, target_path);
    return (tmp___5);
  }
  tmp___6 = copy_file(file.path, target_path);
  return (tmp___6);
}
}
int copy_dir(char *dir_path , char *target_dir ) 
{ 
  int err ;
  tinydir_dir dir ;
  tinydir_file file ;
  int tmp ;
  int tmp___0 ;

  {
  err = 0;
  tinydir_open(& dir, (char const   *)dir_path);
  check_dir___0(target_dir);
  while (dir.has_next) {
    err = tinydir_readfile((tinydir_dir const   *)(& dir), & file);
    if (0 != err) {
      break;
    }
    tmp = strcmp(".", (char const   *)(file.name));
    if (0 == tmp) {
      goto next;
    } else {
      tmp___0 = strcmp("..", (char const   *)(file.name));
      if (0 == tmp___0) {
        goto next;
      }
    }
    err = copy(file, target_dir);
    if (0 != err) {
      break;
    }
    next: 
    err = tinydir_next(& dir);
    if (0 != err) {
      break;
    }
  }
  tinydir_close(& dir);
  return (err);
}
}
#pragma merger("0","/tmp/cil-3K3K2bOA.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
void json_set_allocation_functions(void *(*malloc_fun)(size_t  ) , void (*free_fun)(void * ) ) ;
JSON_Value *json_parse_file_with_comments(char const   *filename ) ;
JSON_Value *json_parse_string_with_comments(char const   *string ) ;
size_t json_serialization_size(JSON_Value const   *value ) ;
JSON_Status json_serialize_to_buffer(JSON_Value const   *value , char *buf , size_t buf_size_in_bytes ) ;
JSON_Status json_serialize_to_file(JSON_Value const   *value , char const   *filename ) ;
char *json_serialize_to_string(JSON_Value const   *value ) ;
size_t json_serialization_size_pretty(JSON_Value const   *value ) ;
JSON_Status json_serialize_to_buffer_pretty(JSON_Value const   *value , char *buf ,
                                            size_t buf_size_in_bytes ) ;
JSON_Status json_serialize_to_file_pretty(JSON_Value const   *value , char const   *filename ) ;
char *json_serialize_to_string_pretty(JSON_Value const   *value ) ;
void json_free_serialized_string(char *string ) ;
int json_value_equals(JSON_Value const   *a , JSON_Value const   *b ) ;
JSON_Status json_validate(JSON_Value const   *schema , JSON_Value const   *value ) ;
double json_object_get_number(JSON_Object const   *object , char const   *name ) ;
int json_object_get_boolean(JSON_Object const   *object , char const   *name ) ;
JSON_Value *json_object_dotget_value(JSON_Object const   *object , char const   *name ) ;
char const   *json_object_dotget_string(JSON_Object const   *object , char const   *name ) ;
JSON_Object *json_object_dotget_object(JSON_Object const   *object , char const   *name ) ;
JSON_Array *json_object_dotget_array(JSON_Object const   *object , char const   *name ) ;
double json_object_dotget_number(JSON_Object const   *object , char const   *name ) ;
int json_object_dotget_boolean(JSON_Object const   *object , char const   *name ) ;
JSON_Status json_object_set_value(JSON_Object *object , char const   *name , JSON_Value *value ) ;
JSON_Status json_object_set_string(JSON_Object *object , char const   *name , char const   *string ) ;
JSON_Status json_object_set_number(JSON_Object *object , char const   *name , double number ) ;
JSON_Status json_object_set_boolean(JSON_Object *object , char const   *name , int boolean ) ;
JSON_Status json_object_set_null(JSON_Object *object , char const   *name ) ;
JSON_Status json_object_dotset_value(JSON_Object *object , char const   *name , JSON_Value *value ) ;
JSON_Status json_object_dotset_string(JSON_Object *object , char const   *name , char const   *string ) ;
JSON_Status json_object_dotset_number(JSON_Object *object , char const   *name , double number ) ;
JSON_Status json_object_dotset_boolean(JSON_Object *object , char const   *name ,
                                       int boolean ) ;
JSON_Status json_object_dotset_null(JSON_Object *object , char const   *name ) ;
JSON_Status json_object_remove(JSON_Object *object , char const   *name ) ;
JSON_Status json_object_dotremove(JSON_Object *object , char const   *name ) ;
JSON_Status json_object_clear(JSON_Object *object ) ;
JSON_Value *json_array_get_value(JSON_Array const   *array , size_t index___0 ) ;
JSON_Object *json_array_get_object(JSON_Array const   *array , size_t index___0 ) ;
JSON_Array *json_array_get_array(JSON_Array const   *array , size_t index___0 ) ;
double json_array_get_number(JSON_Array const   *array , size_t index___0 ) ;
int json_array_get_boolean(JSON_Array const   *array , size_t index___0 ) ;
JSON_Status json_array_remove(JSON_Array *array , size_t ix ) ;
JSON_Status json_array_replace_value(JSON_Array *array , size_t ix , JSON_Value *value ) ;
JSON_Status json_array_replace_string(JSON_Array *array , size_t i , char const   *string ) ;
JSON_Status json_array_replace_number(JSON_Array *array , size_t i , double number ) ;
JSON_Status json_array_replace_boolean(JSON_Array *array , size_t i , int boolean ) ;
JSON_Status json_array_replace_null(JSON_Array *array , size_t i ) ;
JSON_Status json_array_clear(JSON_Array *array ) ;
JSON_Status json_array_append_value(JSON_Array *array , JSON_Value *value ) ;
JSON_Status json_array_append_string(JSON_Array *array , char const   *string ) ;
JSON_Status json_array_append_number(JSON_Array *array , double number ) ;
JSON_Status json_array_append_boolean(JSON_Array *array , int boolean ) ;
JSON_Status json_array_append_null(JSON_Array *array ) ;
JSON_Value *json_value_init_object(void) ;
JSON_Value *json_value_init_array(void) ;
JSON_Value *json_value_init_string(char const   *string ) ;
JSON_Value *json_value_init_number(double number ) ;
JSON_Value *json_value_init_boolean(int boolean ) ;
JSON_Value *json_value_init_null(void) ;
JSON_Value *json_value_deep_copy(JSON_Value const   *value ) ;
JSON_Array *json_value_get_array(JSON_Value const   *value ) ;
char const   *json_value_get_string(JSON_Value const   *value ) ;
double json_value_get_number(JSON_Value const   *value ) ;
int json_value_get_boolean(JSON_Value const   *value ) ;
JSON_Value_Type json_type(JSON_Value const   *value ) ;
JSON_Object *json_object(JSON_Value const   *value ) ;
JSON_Array *json_array(JSON_Value const   *value ) ;
char const   *json_string(JSON_Value const   *value ) ;
double json_number(JSON_Value const   *value ) ;
int json_boolean(JSON_Value const   *value ) ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern long ftell(FILE *__stream ) ;
extern void rewind(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
static void *(*parson_malloc)(size_t  )  =    & malloc;
static void (*parson_free)(void * )  =    & free;
static char *read_file(char const   *filename ) ;
static void remove_comments(char *string , char const   *start_token , char const   *end_token ) ;
static char *parson_strndup(char const   *string , size_t n ) ;
static char *parson_strdup(char const   *string ) ;
static int is_utf16_hex(unsigned char const   *s ) ;
static int num_bytes_in_utf8_sequence(unsigned char c ) ;
static int verify_utf8_sequence(unsigned char const   *string , int *len ) ;
static int is_valid_utf8(char const   *string , size_t string_len ) ;
static int is_decimal(char const   *string , size_t length ) ;
static JSON_Object *json_object_init(void) ;
static JSON_Status json_object_add(JSON_Object *object , char const   *name , JSON_Value *value ) ;
static JSON_Status json_object_resize(JSON_Object *object , size_t new_capacity ) ;
static JSON_Value *json_object_nget_value(JSON_Object const   *object , char const   *name ,
                                          size_t n ) ;
static void json_object_free(JSON_Object *object ) ;
static JSON_Array *json_array_init(void) ;
static JSON_Status json_array_add(JSON_Array *array , JSON_Value *value ) ;
static JSON_Status json_array_resize(JSON_Array *array , size_t new_capacity ) ;
static void json_array_free(JSON_Array *array ) ;
static JSON_Value *json_value_init_string_no_copy(char *string ) ;
static void skip_quotes(char const   **string ) ;
static int parse_utf_16(char const   **unprocessed , char **processed ) ;
static char *process_string(char const   *input , size_t len ) ;
static char *get_quoted_string(char const   **string ) ;
static JSON_Value *parse_object_value(char const   **string , size_t nesting ) ;
static JSON_Value *parse_array_value(char const   **string , size_t nesting ) ;
static JSON_Value *parse_string_value(char const   **string ) ;
static JSON_Value *parse_boolean_value(char const   **string ) ;
static JSON_Value *parse_number_value(char const   **string ) ;
static JSON_Value *parse_null_value(char const   **string ) ;
static JSON_Value *parse_value(char const   **string , size_t nesting ) ;
static int json_serialize_to_buffer_r(JSON_Value const   *value , char *buf , int level ,
                                      int is_pretty , char *num_buf ) ;
static int json_serialize_string(char const   *string , char *buf ) ;
static int append_indent(char *buf , int level ) ;
static int append_string(char *buf , char const   *string ) ;
static char *parson_strndup(char const   *string , size_t n ) 
{ 
  char *output_string ;
  void *tmp ;

  {
  tmp = (*parson_malloc)(n + 1UL);
  output_string = (char *)tmp;
  if (! output_string) {
    return ((char *)((void *)0));
  }
  *(output_string + n) = (char )'\000';
  strncpy((char * __restrict  )output_string, (char const   * __restrict  )string,
          n);
  return (output_string);
}
}
static char *parson_strdup(char const   *string ) 
{ 
  size_t tmp ;
  char *tmp___0 ;

  {
  tmp = strlen(string);
  tmp___0 = parson_strndup(string, tmp);
  return (tmp___0);
}
}
static int is_utf16_hex(unsigned char const   *s ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;

  {
  tmp = __ctype_b_loc();
  if ((int const   )*(*tmp + (int )*(s + 0)) & 4096) {
    tmp___0 = __ctype_b_loc();
    if ((int const   )*(*tmp___0 + (int )*(s + 1)) & 4096) {
      tmp___1 = __ctype_b_loc();
      if ((int const   )*(*tmp___1 + (int )*(s + 2)) & 4096) {
        tmp___2 = __ctype_b_loc();
        if ((int const   )*(*tmp___2 + (int )*(s + 3)) & 4096) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
    } else {
      tmp___3 = 0;
    }
  } else {
    tmp___3 = 0;
  }
  return (tmp___3);
}
}
static int num_bytes_in_utf8_sequence(unsigned char c ) 
{ 


  {
  if ((int )c == 192) {
    return (0);
  } else
  if ((int )c == 193) {
    return (0);
  } else
  if ((int )c > 244) {
    return (0);
  } else
  if (((int )c & 192) == 128) {
    return (0);
  } else
  if (((int )c & 128) == 0) {
    return (1);
  } else
  if (((int )c & 224) == 192) {
    return (2);
  } else
  if (((int )c & 240) == 224) {
    return (3);
  } else
  if (((int )c & 248) == 240) {
    return (4);
  }
  return (0);
}
}
static int verify_utf8_sequence(unsigned char const   *string , int *len ) 
{ 
  unsigned int cp ;

  {
  cp = 0U;
  *len = num_bytes_in_utf8_sequence((unsigned char )*(string + 0));
  if (*len == 1) {
    cp = (unsigned int )*(string + 0);
  } else
  if (*len == 2) {
    if (((int )((unsigned char )*(string + 1)) & 192) == 128) {
      cp = (unsigned int )((int const   )*(string + 0) & 31);
      cp = (cp << 6) | (unsigned int )((int const   )*(string + 1) & 63);
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (*len == 3) {
    if (((int )((unsigned char )*(string + 1)) & 192) == 128) {
      if (((int )((unsigned char )*(string + 2)) & 192) == 128) {
        cp = (unsigned int )((int )((unsigned char )*(string + 0)) & 15);
        cp = (cp << 6) | (unsigned int )((int const   )*(string + 1) & 63);
        cp = (cp << 6) | (unsigned int )((int const   )*(string + 2) & 63);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (*len == 4) {
    if (((int )((unsigned char )*(string + 1)) & 192) == 128) {
      if (((int )((unsigned char )*(string + 2)) & 192) == 128) {
        if (((int )((unsigned char )*(string + 3)) & 192) == 128) {
          cp = (unsigned int )((int const   )*(string + 0) & 7);
          cp = (cp << 6) | (unsigned int )((int const   )*(string + 1) & 63);
          cp = (cp << 6) | (unsigned int )((int const   )*(string + 2) & 63);
          cp = (cp << 6) | (unsigned int )((int const   )*(string + 3) & 63);
        } else {
          return (0);
        }
      } else {
        return (0);
      }
    } else {
      return (0);
    }
  } else {
    return (0);
  }
  if (cp < 128U) {
    if (*len > 1) {
      return (0);
    } else {
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
  if (cp < 2048U) {
    if (*len > 2) {
      return (0);
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (cp < 65536U) {
    if (*len > 3) {
      return (0);
    }
  }
  if (cp > 1114111U) {
    return (0);
  }
  if (cp >= 55296U) {
    if (cp <= 57343U) {
      return (0);
    }
  }
  return (1);
}
}
static int is_valid_utf8(char const   *string , size_t string_len ) 
{ 
  int len ;
  char const   *string_end ;
  int tmp ;

  {
  len = 0;
  string_end = string + string_len;
  while ((unsigned long )string < (unsigned long )string_end) {
    tmp = verify_utf8_sequence((unsigned char const   *)string, & len);
    if (! tmp) {
      return (0);
    }
    string += len;
  }
  return (1);
}
}
static int is_decimal(char const   *string , size_t length ) 
{ 
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  if (length > 1UL) {
    if ((int const   )*(string + 0) == 48) {
      if ((int const   )*(string + 1) != 46) {
        return (0);
      }
    }
  }
  if (length > 2UL) {
    tmp = strncmp(string, "-0", (size_t )2);
    if (! tmp) {
      if ((int const   )*(string + 2) != 46) {
        return (0);
      }
    }
  }
  while (1) {
    tmp___1 = length;
    length --;
    if (! tmp___1) {
      break;
    }
    tmp___0 = strchr("xX", (int )*(string + length));
    if (tmp___0) {
      return (0);
    }
  }
  return (1);
}
}
static char *read_file(char const   *filename ) 
{ 
  FILE *fp ;
  FILE *tmp ;
  size_t file_size ;
  long pos ;
  char *file_contents ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  tmp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
  fp = tmp;
  if (! fp) {
    return ((char *)((void *)0));
  }
  fseek(fp, 0L, 2);
  pos = ftell(fp);
  if (pos < 0L) {
    fclose(fp);
    return ((char *)((void *)0));
  }
  file_size = (size_t )pos;
  rewind(fp);
  tmp___0 = (*parson_malloc)(sizeof(char ) * (file_size + 1UL));
  file_contents = (char *)tmp___0;
  if (! file_contents) {
    fclose(fp);
    return ((char *)((void *)0));
  }
  tmp___2 = fread((void * __restrict  )file_contents, file_size, (size_t )1, (FILE * __restrict  )fp);
  if (tmp___2 < 1UL) {
    tmp___1 = ferror(fp);
    if (tmp___1) {
      fclose(fp);
      (*parson_free)((void *)file_contents);
      return ((char *)((void *)0));
    }
  }
  fclose(fp);
  *(file_contents + file_size) = (char )'\000';
  return (file_contents);
}
}
static void remove_comments(char *string , char const   *start_token , char const   *end_token ) 
{ 
  int in_string ;
  int escaped ;
  size_t i ;
  char *ptr ;
  char current_char ;
  size_t start_token_len ;
  size_t tmp ;
  size_t end_token_len ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  in_string = 0;
  escaped = 0;
  ptr = (char *)((void *)0);
  tmp = strlen(start_token);
  start_token_len = tmp;
  tmp___0 = strlen(end_token);
  end_token_len = tmp___0;
  if (start_token_len == 0UL) {
    return;
  } else
  if (end_token_len == 0UL) {
    return;
  }
  while (1) {
    current_char = *string;
    if (! ((int )current_char != 0)) {
      break;
    }
    if ((int )current_char == 92) {
      if (! escaped) {
        escaped = 1;
        string ++;
        continue;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if ((int )current_char == 34) {
      if (! escaped) {
        in_string = ! in_string;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (! in_string) {
      tmp___1 = strncmp((char const   *)string, start_token, start_token_len);
      if (tmp___1 == 0) {
        i = (size_t )0;
        while (i < start_token_len) {
          *(string + i) = (char )' ';
          i ++;
        }
        string += start_token_len;
        ptr = strstr((char const   *)string, end_token);
        if (! ptr) {
          return;
        }
        i = (size_t )0;
        while (i < (size_t )(ptr - string) + end_token_len) {
          *(string + i) = (char )' ';
          i ++;
        }
        string = (ptr + end_token_len) - 1;
      }
    }
    escaped = 0;
    string ++;
  }
  return;
}
}
static JSON_Object *json_object_init(void) 
{ 
  JSON_Object *new_obj ;
  void *tmp ;

  {
  tmp = (*parson_malloc)(sizeof(JSON_Object ));
  new_obj = (JSON_Object *)tmp;
  if (! new_obj) {
    return ((JSON_Object *)((void *)0));
  }
  new_obj->names = (char **)((void *)0);
  new_obj->values = (JSON_Value **)((void *)0);
  new_obj->capacity = (size_t )0;
  new_obj->count = (size_t )0;
  return (new_obj);
}
}
static JSON_Status json_object_add(JSON_Object *object , char const   *name , JSON_Value *value ) 
{ 
  size_t index___0 ;
  size_t new_capacity ;
  size_t tmp ;
  JSON_Status tmp___0 ;
  JSON_Value *tmp___1 ;

  {
  index___0 = (size_t )0;
  if ((unsigned long )object == (unsigned long )((void *)0)) {
    return (-1);
  } else
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    return (-1);
  } else
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  if (object->count >= object->capacity) {
    if (object->capacity * 2UL > 15UL) {
      tmp = object->capacity * 2UL;
    } else {
      tmp = (size_t )15;
    }
    new_capacity = tmp;
    if (new_capacity > 960UL) {
      return (-1);
    }
    tmp___0 = json_object_resize(object, new_capacity);
    if (tmp___0 == -1) {
      return (-1);
    }
  }
  tmp___1 = json_object_get_value((JSON_Object const   *)object, name);
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
    return (-1);
  }
  index___0 = object->count;
  *(object->names + index___0) = parson_strdup(name);
  if ((unsigned long )*(object->names + index___0) == (unsigned long )((void *)0)) {
    return (-1);
  }
  *(object->values + index___0) = value;
  (object->count) ++;
  return (0);
}
}
static JSON_Status json_object_resize(JSON_Object *object , size_t new_capacity ) 
{ 
  char **temp_names ;
  JSON_Value **temp_values ;
  void *tmp ;
  void *tmp___0 ;

  {
  temp_names = (char **)((void *)0);
  temp_values = (JSON_Value **)((void *)0);
  if ((unsigned long )object->names == (unsigned long )((void *)0)) {
    if ((unsigned long )object->values != (unsigned long )((void *)0)) {
      return (-1);
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if ((unsigned long )object->names != (unsigned long )((void *)0)) {
    if ((unsigned long )object->values == (unsigned long )((void *)0)) {
      return (-1);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (new_capacity == 0UL) {
    return (-1);
  }
  tmp = (*parson_malloc)(new_capacity * sizeof(char *));
  temp_names = (char **)tmp;
  if ((unsigned long )temp_names == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp___0 = (*parson_malloc)(new_capacity * sizeof(JSON_Value *));
  temp_values = (JSON_Value **)tmp___0;
  if ((unsigned long )temp_names == (unsigned long )((void *)0)) {
    (*parson_free)((void *)temp_names);
    return (-1);
  }
  if ((unsigned long )object->names != (unsigned long )((void *)0)) {
    if ((unsigned long )object->values != (unsigned long )((void *)0)) {
      if (object->count > 0UL) {
        memcpy((void * __restrict  )temp_names, (void const   * __restrict  )object->names,
               object->count * sizeof(char *));
        memcpy((void * __restrict  )temp_values, (void const   * __restrict  )object->values,
               object->count * sizeof(JSON_Value *));
      }
    }
  }
  (*parson_free)((void *)object->names);
  (*parson_free)((void *)object->values);
  object->names = temp_names;
  object->values = temp_values;
  object->capacity = new_capacity;
  return (0);
}
}
static JSON_Value *json_object_nget_value(JSON_Object const   *object , char const   *name ,
                                          size_t n ) 
{ 
  size_t i ;
  size_t name_length ;
  int tmp ;
  size_t tmp___0 ;

  {
  i = (size_t )0;
  while (1) {
    tmp___0 = json_object_get_count(object);
    if (! (i < tmp___0)) {
      break;
    }
    name_length = strlen((char const   *)*(object->names + i));
    if (name_length != n) {
      goto __Cont;
    }
    tmp = strncmp((char const   *)*(object->names + i), name, n);
    if (tmp == 0) {
      return (*(object->values + i));
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return ((JSON_Value *)((void *)0));
}
}
static void json_object_free(JSON_Object *object ) 
{ 
  size_t tmp ;

  {
  while (1) {
    tmp = object->count;
    (object->count) --;
    if (! tmp) {
      break;
    }
    (*parson_free)((void *)*(object->names + object->count));
    json_value_free(*(object->values + object->count));
  }
  (*parson_free)((void *)object->names);
  (*parson_free)((void *)object->values);
  (*parson_free)((void *)object);
  return;
}
}
static JSON_Array *json_array_init(void) 
{ 
  JSON_Array *new_array ;
  void *tmp ;

  {
  tmp = (*parson_malloc)(sizeof(JSON_Array ));
  new_array = (JSON_Array *)tmp;
  if (! new_array) {
    return ((JSON_Array *)((void *)0));
  }
  new_array->items = (JSON_Value **)((void *)0);
  new_array->capacity = (size_t )0;
  new_array->count = (size_t )0;
  return (new_array);
}
}
static JSON_Status json_array_add(JSON_Array *array , JSON_Value *value ) 
{ 
  size_t new_capacity ;
  size_t tmp ;
  JSON_Status tmp___0 ;

  {
  if (array->count >= array->capacity) {
    if (array->capacity * 2UL > 15UL) {
      tmp = array->capacity * 2UL;
    } else {
      tmp = (size_t )15;
    }
    new_capacity = tmp;
    if (new_capacity > 122880UL) {
      return (-1);
    }
    tmp___0 = json_array_resize(array, new_capacity);
    if (tmp___0 == -1) {
      return (-1);
    }
  }
  *(array->items + array->count) = value;
  (array->count) ++;
  return (0);
}
}
static JSON_Status json_array_resize(JSON_Array *array , size_t new_capacity ) 
{ 
  JSON_Value **new_items ;
  void *tmp ;

  {
  new_items = (JSON_Value **)((void *)0);
  if (new_capacity == 0UL) {
    return (-1);
  }
  tmp = (*parson_malloc)(new_capacity * sizeof(JSON_Value *));
  new_items = (JSON_Value **)tmp;
  if ((unsigned long )new_items == (unsigned long )((void *)0)) {
    return (-1);
  }
  if ((unsigned long )array->items != (unsigned long )((void *)0)) {
    if (array->count > 0UL) {
      memcpy((void * __restrict  )new_items, (void const   * __restrict  )array->items,
             array->count * sizeof(JSON_Value *));
    }
  }
  (*parson_free)((void *)array->items);
  array->items = new_items;
  array->capacity = new_capacity;
  return (0);
}
}
static void json_array_free(JSON_Array *array ) 
{ 
  size_t tmp ;

  {
  while (1) {
    tmp = array->count;
    (array->count) --;
    if (! tmp) {
      break;
    }
    json_value_free(*(array->items + array->count));
  }
  (*parson_free)((void *)array->items);
  (*parson_free)((void *)array);
  return;
}
}
static JSON_Value *json_value_init_string_no_copy(char *string ) 
{ 
  JSON_Value *new_value ;
  void *tmp ;

  {
  tmp = (*parson_malloc)(sizeof(JSON_Value ));
  new_value = (JSON_Value *)tmp;
  if (! new_value) {
    return ((JSON_Value *)((void *)0));
  }
  new_value->type = 2;
  new_value->value.string = string;
  return (new_value);
}
}
static void skip_quotes(char const   **string ) 
{ 


  {
  (*string) ++;
  while ((int const   )*(*string) != 34) {
    if ((int const   )*(*string) == 0) {
      return;
    }
    if ((int const   )*(*string) == 92) {
      (*string) ++;
      if ((int const   )*(*string) == 0) {
        return;
      }
    }
    (*string) ++;
  }
  (*string) ++;
  return;
}
}
static int parse_utf_16(char const   **unprocessed , char **processed ) 
{ 
  unsigned int cp ;
  unsigned int lead ;
  unsigned int trail ;
  char *processed_ptr ;
  char const   *unprocessed_ptr ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  processed_ptr = *processed;
  unprocessed_ptr = *unprocessed;
  unprocessed_ptr ++;
  tmp = is_utf16_hex((unsigned char const   *)unprocessed_ptr);
  if (tmp) {
    tmp___0 = sscanf((char const   * __restrict  )unprocessed_ptr, (char const   * __restrict  )"%4x",
                     & cp);
    if (tmp___0 == -1) {
      return (-1);
    }
  } else {
    return (-1);
  }
  if (cp < 128U) {
    *processed_ptr = (char )cp;
  } else
  if (cp < 2048U) {
    tmp___1 = processed_ptr;
    processed_ptr ++;
    *tmp___1 = (char )(((cp >> 6) & 31U) | 192U);
    *processed_ptr = (char )((cp & 63U) | 128U);
  } else
  if (cp < 55296U) {
    goto _L;
  } else
  if (cp > 57343U) {
    _L: /* CIL Label */ 
    tmp___2 = processed_ptr;
    processed_ptr ++;
    *tmp___2 = (char )(((cp >> 12) & 15U) | 224U);
    tmp___3 = processed_ptr;
    processed_ptr ++;
    *tmp___3 = (char )(((cp >> 6) & 63U) | 128U);
    *processed_ptr = (char )((cp & 63U) | 128U);
  } else
  if (cp >= 55296U) {
    if (cp <= 56319U) {
      lead = cp;
      unprocessed_ptr += 4;
      tmp___4 = unprocessed_ptr;
      unprocessed_ptr ++;
      if ((int const   )*tmp___4 != 92) {
        return (-1);
      } else {
        tmp___5 = unprocessed_ptr;
        unprocessed_ptr ++;
        if ((int const   )*tmp___5 != 117) {
          return (-1);
        } else {
          tmp___6 = is_utf16_hex((unsigned char const   *)unprocessed_ptr);
          if (tmp___6) {
            tmp___7 = sscanf((char const   * __restrict  )unprocessed_ptr, (char const   * __restrict  )"%4x",
                             & trail);
            if (tmp___7 == -1) {
              return (-1);
            } else
            if (trail < 56320U) {
              return (-1);
            } else
            if (trail > 57343U) {
              return (-1);
            }
          } else {
            return (-1);
          }
        }
      }
      cp = ((((lead - 55296U) & 1023U) << 10) | ((trail - 56320U) & 1023U)) + 65536U;
      tmp___8 = processed_ptr;
      processed_ptr ++;
      *tmp___8 = (char )(((cp >> 18) & 7U) | 240U);
      tmp___9 = processed_ptr;
      processed_ptr ++;
      *tmp___9 = (char )(((cp >> 12) & 63U) | 128U);
      tmp___10 = processed_ptr;
      processed_ptr ++;
      *tmp___10 = (char )(((cp >> 6) & 63U) | 128U);
      *processed_ptr = (char )((cp & 63U) | 128U);
    } else {
      return (-1);
    }
  } else {
    return (-1);
  }
  unprocessed_ptr += 3;
  *processed = processed_ptr;
  *unprocessed = unprocessed_ptr;
  return (0);
}
}
static char *process_string(char const   *input , size_t len ) 
{ 
  char const   *input_ptr ;
  size_t initial_size ;
  size_t final_size ;
  char *output ;
  void *tmp ;
  char *output_ptr ;
  char *resized_output ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  input_ptr = input;
  initial_size = (len + 1UL) * sizeof(char );
  final_size = (size_t )0;
  tmp = (*parson_malloc)(initial_size);
  output = (char *)tmp;
  output_ptr = output;
  resized_output = (char *)((void *)0);
  while (1) {
    if ((int const   )*input_ptr != 0) {
      if (! ((size_t )(input_ptr - input) < len)) {
        break;
      }
    } else {
      break;
    }
    if ((int const   )*input_ptr == 92) {
      input_ptr ++;
      switch ((int const   )*input_ptr) {
      case 34: 
      *output_ptr = (char )'\"';
      break;
      case 92: 
      *output_ptr = (char )'\\';
      break;
      case 47: 
      *output_ptr = (char )'/';
      break;
      case 98: 
      *output_ptr = (char )'\b';
      break;
      case 102: 
      *output_ptr = (char )'\f';
      break;
      case 110: 
      *output_ptr = (char )'\n';
      break;
      case 114: 
      *output_ptr = (char )'\r';
      break;
      case 116: 
      *output_ptr = (char )'\t';
      break;
      case 117: 
      tmp___0 = parse_utf_16(& input_ptr, & output_ptr);
      if (tmp___0 == -1) {
        goto error;
      }
      break;
      default: 
      goto error;
      }
    } else
    if ((int )((unsigned char )*input_ptr) < 32) {
      goto error;
    } else {
      *output_ptr = (char )*input_ptr;
    }
    output_ptr ++;
    input_ptr ++;
  }
  *output_ptr = (char )'\000';
  final_size = (size_t )(output_ptr - output) + 1UL;
  tmp___1 = (*parson_malloc)(final_size);
  resized_output = (char *)tmp___1;
  if ((unsigned long )resized_output == (unsigned long )((void *)0)) {
    goto error;
  }
  memcpy((void * __restrict  )resized_output, (void const   * __restrict  )output,
         final_size);
  (*parson_free)((void *)output);
  return (resized_output);
  error: 
  (*parson_free)((void *)output);
  return ((char *)((void *)0));
}
}
static char *get_quoted_string(char const   **string ) 
{ 
  char const   *string_start ;
  size_t string_len ;
  char *tmp ;

  {
  string_start = *string;
  string_len = (size_t )0;
  skip_quotes(string);
  if ((int const   )*(*string) == 0) {
    return ((char *)((void *)0));
  }
  string_len = (size_t )((*string - string_start) - 2L);
  tmp = process_string(string_start + 1, string_len);
  return (tmp);
}
}
static JSON_Value *parse_value(char const   **string , size_t nesting ) 
{ 
  unsigned short const   **tmp ;
  JSON_Value *tmp___0 ;
  JSON_Value *tmp___1 ;
  JSON_Value *tmp___2 ;
  JSON_Value *tmp___3 ;
  JSON_Value *tmp___4 ;
  JSON_Value *tmp___5 ;

  {
  if (nesting > 19UL) {
    return ((JSON_Value *)((void *)0));
  }
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )*(*tmp + (int )*(*string)) & 8192)) {
      break;
    }
    (*string) ++;
  }
  switch ((int const   )*(*string)) {
  case 123: 
  tmp___0 = parse_object_value(string, nesting + 1UL);
  return (tmp___0);
  case 91: 
  tmp___1 = parse_array_value(string, nesting + 1UL);
  return (tmp___1);
  case 34: 
  tmp___2 = parse_string_value(string);
  return (tmp___2);
  case 116: 
  case 102: 
  tmp___3 = parse_boolean_value(string);
  return (tmp___3);
  case 57: 
  case 56: 
  case 55: 
  case 54: 
  case 53: 
  case 52: 
  case 51: 
  case 50: 
  case 49: 
  case 48: 
  case 45: 
  tmp___4 = parse_number_value(string);
  return (tmp___4);
  case 110: 
  tmp___5 = parse_null_value(string);
  return (tmp___5);
  default: 
  return ((JSON_Value *)((void *)0));
  }
}
}
static JSON_Value *parse_object_value(char const   **string , size_t nesting ) 
{ 
  JSON_Value *output_value ;
  JSON_Value *tmp ;
  JSON_Value *new_value ;
  JSON_Object *output_object ;
  JSON_Object *tmp___0 ;
  char *new_key ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  JSON_Status tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  size_t tmp___7 ;
  JSON_Status tmp___8 ;

  {
  tmp = json_value_init_object();
  output_value = tmp;
  new_value = (JSON_Value *)((void *)0);
  tmp___0 = json_value_get_object((JSON_Value const   *)output_value);
  output_object = tmp___0;
  new_key = (char *)((void *)0);
  if ((unsigned long )output_value == (unsigned long )((void *)0)) {
    return ((JSON_Value *)((void *)0));
  }
  (*string) ++;
  while (1) {
    tmp___1 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___1 + (int )*(*string)) & 8192)) {
      break;
    }
    (*string) ++;
  }
  if ((int const   )*(*string) == 125) {
    (*string) ++;
    return (output_value);
  }
  while ((int const   )*(*string) != 0) {
    new_key = get_quoted_string(string);
    while (1) {
      tmp___2 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___2 + (int )*(*string)) & 8192)) {
        break;
      }
      (*string) ++;
    }
    if ((unsigned long )new_key == (unsigned long )((void *)0)) {
      json_value_free(output_value);
      return ((JSON_Value *)((void *)0));
    } else
    if ((int const   )*(*string) != 58) {
      json_value_free(output_value);
      return ((JSON_Value *)((void *)0));
    }
    (*string) ++;
    new_value = parse_value(string, nesting);
    if ((unsigned long )new_value == (unsigned long )((void *)0)) {
      (*parson_free)((void *)new_key);
      json_value_free(output_value);
      return ((JSON_Value *)((void *)0));
    }
    tmp___3 = json_object_add(output_object, (char const   *)new_key, new_value);
    if (tmp___3 == -1) {
      (*parson_free)((void *)new_key);
      (*parson_free)((void *)new_value);
      json_value_free(output_value);
      return ((JSON_Value *)((void *)0));
    }
    (*parson_free)((void *)new_key);
    while (1) {
      tmp___4 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___4 + (int )*(*string)) & 8192)) {
        break;
      }
      (*string) ++;
    }
    if ((int const   )*(*string) != 44) {
      break;
    }
    (*string) ++;
    while (1) {
      tmp___5 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___5 + (int )*(*string)) & 8192)) {
        break;
      }
      (*string) ++;
    }
  }
  while (1) {
    tmp___6 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___6 + (int )*(*string)) & 8192)) {
      break;
    }
    (*string) ++;
  }
  if ((int const   )*(*string) != 125) {
    json_value_free(output_value);
    return ((JSON_Value *)((void *)0));
  } else {
    tmp___7 = json_object_get_count((JSON_Object const   *)output_object);
    tmp___8 = json_object_resize(output_object, tmp___7);
    if (tmp___8 == -1) {
      json_value_free(output_value);
      return ((JSON_Value *)((void *)0));
    }
  }
  (*string) ++;
  return (output_value);
}
}
static JSON_Value *parse_array_value(char const   **string , size_t nesting ) 
{ 
  JSON_Value *output_value ;
  JSON_Value *tmp ;
  JSON_Value *new_array_value ;
  JSON_Array *output_array ;
  JSON_Array *tmp___0 ;
  unsigned short const   **tmp___1 ;
  JSON_Status tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  size_t tmp___6 ;
  JSON_Status tmp___7 ;

  {
  tmp = json_value_init_array();
  output_value = tmp;
  new_array_value = (JSON_Value *)((void *)0);
  tmp___0 = json_value_get_array((JSON_Value const   *)output_value);
  output_array = tmp___0;
  if (! output_value) {
    return ((JSON_Value *)((void *)0));
  }
  (*string) ++;
  while (1) {
    tmp___1 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___1 + (int )*(*string)) & 8192)) {
      break;
    }
    (*string) ++;
  }
  if ((int const   )*(*string) == 93) {
    (*string) ++;
    return (output_value);
  }
  while ((int const   )*(*string) != 0) {
    new_array_value = parse_value(string, nesting);
    if (! new_array_value) {
      json_value_free(output_value);
      return ((JSON_Value *)((void *)0));
    }
    tmp___2 = json_array_add(output_array, new_array_value);
    if (tmp___2 == -1) {
      (*parson_free)((void *)new_array_value);
      json_value_free(output_value);
      return ((JSON_Value *)((void *)0));
    }
    while (1) {
      tmp___3 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___3 + (int )*(*string)) & 8192)) {
        break;
      }
      (*string) ++;
    }
    if ((int const   )*(*string) != 44) {
      break;
    }
    (*string) ++;
    while (1) {
      tmp___4 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___4 + (int )*(*string)) & 8192)) {
        break;
      }
      (*string) ++;
    }
  }
  while (1) {
    tmp___5 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___5 + (int )*(*string)) & 8192)) {
      break;
    }
    (*string) ++;
  }
  if ((int const   )*(*string) != 93) {
    json_value_free(output_value);
    return ((JSON_Value *)((void *)0));
  } else {
    tmp___6 = json_array_get_count((JSON_Array const   *)output_array);
    tmp___7 = json_array_resize(output_array, tmp___6);
    if (tmp___7 == -1) {
      json_value_free(output_value);
      return ((JSON_Value *)((void *)0));
    }
  }
  (*string) ++;
  return (output_value);
}
}
static JSON_Value *parse_string_value(char const   **string ) 
{ 
  JSON_Value *value ;
  char *new_string ;
  char *tmp ;

  {
  value = (JSON_Value *)((void *)0);
  tmp = get_quoted_string(string);
  new_string = tmp;
  if ((unsigned long )new_string == (unsigned long )((void *)0)) {
    return ((JSON_Value *)((void *)0));
  }
  value = json_value_init_string_no_copy(new_string);
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    (*parson_free)((void *)new_string);
    return ((JSON_Value *)((void *)0));
  }
  return (value);
}
}
static JSON_Value *parse_boolean_value(char const   **string ) 
{ 
  size_t true_token_size ;
  size_t false_token_size ;
  JSON_Value *tmp ;
  JSON_Value *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  true_token_size = sizeof("true") - 1UL;
  false_token_size = sizeof("false") - 1UL;
  tmp___2 = strncmp("true", *string, true_token_size);
  if (tmp___2 == 0) {
    *string += true_token_size;
    tmp = json_value_init_boolean(1);
    return (tmp);
  } else {
    tmp___1 = strncmp("false", *string, false_token_size);
    if (tmp___1 == 0) {
      *string += false_token_size;
      tmp___0 = json_value_init_boolean(0);
      return (tmp___0);
    }
  }
  return ((JSON_Value *)((void *)0));
}
}
static JSON_Value *parse_number_value(char const   **string ) 
{ 
  char *end ;
  double number ;
  double tmp ;
  JSON_Value *output_value ;
  int tmp___0 ;

  {
  tmp = strtod((char const   * __restrict  )*string, (char ** __restrict  )(& end));
  number = tmp;
  tmp___0 = is_decimal(*string, (size_t )(end - (char *)*string));
  if (tmp___0) {
    *string = (char const   *)end;
    output_value = json_value_init_number(number);
  } else {
    output_value = (JSON_Value *)((void *)0);
  }
  return (output_value);
}
}
static JSON_Value *parse_null_value(char const   **string ) 
{ 
  size_t token_size ;
  JSON_Value *tmp ;
  int tmp___0 ;

  {
  token_size = sizeof("null") - 1UL;
  tmp___0 = strncmp("null", *string, token_size);
  if (tmp___0 == 0) {
    *string += token_size;
    tmp = json_value_init_null();
    return (tmp);
  }
  return ((JSON_Value *)((void *)0));
}
}
static int json_serialize_to_buffer_r(JSON_Value const   *value , char *buf , int level ,
                                      int is_pretty , char *num_buf ) 
{ 
  char const   *key ;
  char const   *string ;
  JSON_Value *temp_value ;
  JSON_Array *array ;
  JSON_Object *object ;
  size_t i ;
  size_t count ;
  double num ;
  int written ;
  int written_total ;
  JSON_Value_Type tmp ;
  int tmp___0 ;

  {
  key = (char const   *)((void *)0);
  string = (char const   *)((void *)0);
  temp_value = (JSON_Value *)((void *)0);
  array = (JSON_Array *)((void *)0);
  object = (JSON_Object *)((void *)0);
  i = (size_t )0;
  count = (size_t )0;
  num = 0.0;
  written = -1;
  written_total = 0;
  tmp = json_value_get_type(value);
  switch (tmp) {
  case 5: 
  array = json_value_get_array(value);
  count = json_array_get_count((JSON_Array const   *)array);
  while (1) {
    written = append_string(buf, "[");
    if (written < 0) {
      return (-1);
    }
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      buf += written;
    }
    written_total += written;
    break;
  }
  if (count > 0UL) {
    if (is_pretty) {
      while (1) {
        written = append_string(buf, "\n");
        if (written < 0) {
          return (-1);
        }
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          buf += written;
        }
        written_total += written;
        break;
      }
    }
  }
  i = (size_t )0;
  while (i < count) {
    if (is_pretty) {
      while (1) {
        written = append_indent(buf, level + 1);
        if (written < 0) {
          return (-1);
        }
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          buf += written;
        }
        written_total += written;
        break;
      }
    }
    temp_value = json_array_get_value((JSON_Array const   *)array, i);
    written = json_serialize_to_buffer_r((JSON_Value const   *)temp_value, buf, level + 1,
                                         is_pretty, num_buf);
    if (written < 0) {
      return (-1);
    }
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      buf += written;
    }
    written_total += written;
    if (i < count - 1UL) {
      while (1) {
        written = append_string(buf, ",");
        if (written < 0) {
          return (-1);
        }
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          buf += written;
        }
        written_total += written;
        break;
      }
    }
    if (is_pretty) {
      while (1) {
        written = append_string(buf, "\n");
        if (written < 0) {
          return (-1);
        }
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          buf += written;
        }
        written_total += written;
        break;
      }
    }
    i ++;
  }
  if (count > 0UL) {
    if (is_pretty) {
      while (1) {
        written = append_indent(buf, level);
        if (written < 0) {
          return (-1);
        }
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          buf += written;
        }
        written_total += written;
        break;
      }
    }
  }
  while (1) {
    written = append_string(buf, "]");
    if (written < 0) {
      return (-1);
    }
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      buf += written;
    }
    written_total += written;
    break;
  }
  return (written_total);
  case 4: 
  object = json_value_get_object(value);
  count = json_object_get_count((JSON_Object const   *)object);
  while (1) {
    written = append_string(buf, "{");
    if (written < 0) {
      return (-1);
    }
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      buf += written;
    }
    written_total += written;
    break;
  }
  if (count > 0UL) {
    if (is_pretty) {
      while (1) {
        written = append_string(buf, "\n");
        if (written < 0) {
          return (-1);
        }
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          buf += written;
        }
        written_total += written;
        break;
      }
    }
  }
  i = (size_t )0;
  while (i < count) {
    key = json_object_get_name((JSON_Object const   *)object, i);
    if (is_pretty) {
      while (1) {
        written = append_indent(buf, level + 1);
        if (written < 0) {
          return (-1);
        }
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          buf += written;
        }
        written_total += written;
        break;
      }
    }
    written = json_serialize_string(key, buf);
    if (written < 0) {
      return (-1);
    }
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      buf += written;
    }
    written_total += written;
    while (1) {
      written = append_string(buf, ":");
      if (written < 0) {
        return (-1);
      }
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
        buf += written;
      }
      written_total += written;
      break;
    }
    if (is_pretty) {
      while (1) {
        written = append_string(buf, " ");
        if (written < 0) {
          return (-1);
        }
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          buf += written;
        }
        written_total += written;
        break;
      }
    }
    temp_value = json_object_get_value((JSON_Object const   *)object, key);
    written = json_serialize_to_buffer_r((JSON_Value const   *)temp_value, buf, level + 1,
                                         is_pretty, num_buf);
    if (written < 0) {
      return (-1);
    }
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      buf += written;
    }
    written_total += written;
    if (i < count - 1UL) {
      while (1) {
        written = append_string(buf, ",");
        if (written < 0) {
          return (-1);
        }
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          buf += written;
        }
        written_total += written;
        break;
      }
    }
    if (is_pretty) {
      while (1) {
        written = append_string(buf, "\n");
        if (written < 0) {
          return (-1);
        }
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          buf += written;
        }
        written_total += written;
        break;
      }
    }
    i ++;
  }
  if (count > 0UL) {
    if (is_pretty) {
      while (1) {
        written = append_indent(buf, level);
        if (written < 0) {
          return (-1);
        }
        if ((unsigned long )buf != (unsigned long )((void *)0)) {
          buf += written;
        }
        written_total += written;
        break;
      }
    }
  }
  while (1) {
    written = append_string(buf, "}");
    if (written < 0) {
      return (-1);
    }
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      buf += written;
    }
    written_total += written;
    break;
  }
  return (written_total);
  case 2: 
  string = json_value_get_string(value);
  written = json_serialize_string(string, buf);
  if (written < 0) {
    return (-1);
  }
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    buf += written;
  }
  written_total += written;
  return (written_total);
  case 6: 
  tmp___0 = json_value_get_boolean(value);
  if (tmp___0) {
    while (1) {
      written = append_string(buf, "true");
      if (written < 0) {
        return (-1);
      }
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
        buf += written;
      }
      written_total += written;
      break;
    }
  } else {
    while (1) {
      written = append_string(buf, "false");
      if (written < 0) {
        return (-1);
      }
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
        buf += written;
      }
      written_total += written;
      break;
    }
  }
  return (written_total);
  case 3: 
  num = json_value_get_number(value);
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    num_buf = buf;
  }
  if (num == (double )((int )num)) {
    written = sprintf((char * __restrict  )num_buf, (char const   * __restrict  )"%d",
                      (int )num);
  } else {
    written = sprintf((char * __restrict  )num_buf, (char const   * __restrict  )"%f",
                      num);
  }
  if (written < 0) {
    return (-1);
  }
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    buf += written;
  }
  written_total += written;
  return (written_total);
  case 1: 
  while (1) {
    written = append_string(buf, "null");
    if (written < 0) {
      return (-1);
    }
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      buf += written;
    }
    written_total += written;
    break;
  }
  return (written_total);
  case -1: 
  return (-1);
  default: 
  return (-1);
  }
}
}
static int json_serialize_string(char const   *string , char *buf ) 
{ 
  size_t i ;
  size_t len ;
  size_t tmp ;
  char c ;
  int written ;
  int written_total ;

  {
  i = (size_t )0;
  tmp = strlen(string);
  len = tmp;
  c = (char )'\000';
  written = -1;
  written_total = 0;
  while (1) {
    written = append_string(buf, "\"");
    if (written < 0) {
      return (-1);
    }
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      buf += written;
    }
    written_total += written;
    break;
  }
  i = (size_t )0;
  while (i < len) {
    c = (char )*(string + i);
    switch ((int )c) {
    case 34: 
    while (1) {
      written = append_string(buf, "\\\"");
      if (written < 0) {
        return (-1);
      }
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
        buf += written;
      }
      written_total += written;
      break;
    }
    break;
    case 92: 
    while (1) {
      written = append_string(buf, "\\\\");
      if (written < 0) {
        return (-1);
      }
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
        buf += written;
      }
      written_total += written;
      break;
    }
    break;
    case 8: 
    while (1) {
      written = append_string(buf, "\\b");
      if (written < 0) {
        return (-1);
      }
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
        buf += written;
      }
      written_total += written;
      break;
    }
    break;
    case 12: 
    while (1) {
      written = append_string(buf, "\\f");
      if (written < 0) {
        return (-1);
      }
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
        buf += written;
      }
      written_total += written;
      break;
    }
    break;
    case 10: 
    while (1) {
      written = append_string(buf, "\\n");
      if (written < 0) {
        return (-1);
      }
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
        buf += written;
      }
      written_total += written;
      break;
    }
    break;
    case 13: 
    while (1) {
      written = append_string(buf, "\\r");
      if (written < 0) {
        return (-1);
      }
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
        buf += written;
      }
      written_total += written;
      break;
    }
    break;
    case 9: 
    while (1) {
      written = append_string(buf, "\\t");
      if (written < 0) {
        return (-1);
      }
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
        buf += written;
      }
      written_total += written;
      break;
    }
    break;
    default: 
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      *(buf + 0) = c;
      buf ++;
    }
    written_total ++;
    break;
    }
    i ++;
  }
  while (1) {
    written = append_string(buf, "\"");
    if (written < 0) {
      return (-1);
    }
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      buf += written;
    }
    written_total += written;
    break;
  }
  return (written_total);
}
}
static int append_indent(char *buf , int level ) 
{ 
  int i ;
  int written ;
  int written_total ;

  {
  written = -1;
  written_total = 0;
  i = 0;
  while (i < level) {
    while (1) {
      written = append_string(buf, "  ");
      if (written < 0) {
        return (-1);
      }
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
        buf += written;
      }
      written_total += written;
      break;
    }
    i ++;
  }
  return (written_total);
}
}
static int append_string(char *buf , char const   *string ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    tmp = strlen(string);
    return ((int )tmp);
  }
  tmp___0 = sprintf((char * __restrict  )buf, (char const   * __restrict  )"%s", string);
  return (tmp___0);
}
}
JSON_Value *json_parse_file(char const   *filename ) 
{ 
  char *file_contents ;
  char *tmp ;
  JSON_Value *output_value ;

  {
  tmp = read_file(filename);
  file_contents = tmp;
  output_value = (JSON_Value *)((void *)0);
  if ((unsigned long )file_contents == (unsigned long )((void *)0)) {
    return ((JSON_Value *)((void *)0));
  }
  output_value = json_parse_string((char const   *)file_contents);
  (*parson_free)((void *)file_contents);
  return (output_value);
}
}
JSON_Value *json_parse_file_with_comments(char const   *filename ) 
{ 
  char *file_contents ;
  char *tmp ;
  JSON_Value *output_value ;

  {
  tmp = read_file(filename);
  file_contents = tmp;
  output_value = (JSON_Value *)((void *)0);
  if ((unsigned long )file_contents == (unsigned long )((void *)0)) {
    return ((JSON_Value *)((void *)0));
  }
  output_value = json_parse_string_with_comments((char const   *)file_contents);
  (*parson_free)((void *)file_contents);
  return (output_value);
}
}
JSON_Value *json_parse_string(char const   *string ) 
{ 
  unsigned short const   **tmp ;
  JSON_Value *tmp___0 ;

  {
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    return ((JSON_Value *)((void *)0));
  }
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )*(*tmp + (int )*string) & 8192)) {
      break;
    }
    string ++;
  }
  if ((int const   )*string != 123) {
    if ((int const   )*string != 91) {
      return ((JSON_Value *)((void *)0));
    }
  }
  tmp___0 = parse_value(& string, (size_t )0);
  return (tmp___0);
}
}
JSON_Value *json_parse_string_with_comments(char const   *string ) 
{ 
  JSON_Value *result ;
  char *string_mutable_copy ;
  char *string_mutable_copy_ptr ;
  unsigned short const   **tmp ;

  {
  result = (JSON_Value *)((void *)0);
  string_mutable_copy = (char *)((void *)0);
  string_mutable_copy_ptr = (char *)((void *)0);
  string_mutable_copy = parson_strdup(string);
  if ((unsigned long )string_mutable_copy == (unsigned long )((void *)0)) {
    return ((JSON_Value *)((void *)0));
  }
  remove_comments(string_mutable_copy, "/*", "*/");
  remove_comments(string_mutable_copy, "//", "\n");
  string_mutable_copy_ptr = string_mutable_copy;
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )*(*tmp + (int )*string_mutable_copy_ptr) & 8192)) {
      break;
    }
    string_mutable_copy_ptr ++;
  }
  if ((int )*string_mutable_copy_ptr != 123) {
    if ((int )*string_mutable_copy_ptr != 91) {
      (*parson_free)((void *)string_mutable_copy);
      return ((JSON_Value *)((void *)0));
    }
  }
  result = parse_value((char const   **)(& string_mutable_copy_ptr), (size_t )0);
  (*parson_free)((void *)string_mutable_copy);
  return (result);
}
}
JSON_Value *json_object_get_value(JSON_Object const   *object , char const   *name ) 
{ 
  size_t tmp ;
  JSON_Value *tmp___0 ;

  {
  if ((unsigned long )object == (unsigned long )((void *)0)) {
    return ((JSON_Value *)((void *)0));
  } else
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    return ((JSON_Value *)((void *)0));
  }
  tmp = strlen(name);
  tmp___0 = json_object_nget_value(object, name, tmp);
  return (tmp___0);
}
}
char const   *json_object_get_string(JSON_Object const   *object , char const   *name ) 
{ 
  JSON_Value *tmp ;
  char const   *tmp___0 ;

  {
  tmp = json_object_get_value(object, name);
  tmp___0 = json_value_get_string((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
double json_object_get_number(JSON_Object const   *object , char const   *name ) 
{ 
  JSON_Value *tmp ;
  double tmp___0 ;

  {
  tmp = json_object_get_value(object, name);
  tmp___0 = json_value_get_number((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
JSON_Object *json_object_get_object(JSON_Object const   *object , char const   *name ) 
{ 
  JSON_Value *tmp ;
  JSON_Object *tmp___0 ;

  {
  tmp = json_object_get_value(object, name);
  tmp___0 = json_value_get_object((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
JSON_Array *json_object_get_array(JSON_Object const   *object , char const   *name ) 
{ 
  JSON_Value *tmp ;
  JSON_Array *tmp___0 ;

  {
  tmp = json_object_get_value(object, name);
  tmp___0 = json_value_get_array((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
int json_object_get_boolean(JSON_Object const   *object , char const   *name ) 
{ 
  JSON_Value *tmp ;
  int tmp___0 ;

  {
  tmp = json_object_get_value(object, name);
  tmp___0 = json_value_get_boolean((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
JSON_Value *json_object_dotget_value(JSON_Object const   *object , char const   *name ) 
{ 
  char const   *dot_position ;
  char *tmp ;
  JSON_Value *tmp___0 ;
  JSON_Value *tmp___1 ;
  JSON_Object *tmp___2 ;
  JSON_Value *tmp___3 ;

  {
  tmp = strchr(name, '.');
  dot_position = (char const   *)tmp;
  if (! dot_position) {
    tmp___0 = json_object_get_value(object, name);
    return (tmp___0);
  }
  tmp___1 = json_object_nget_value(object, name, (size_t )(dot_position - name));
  tmp___2 = json_value_get_object((JSON_Value const   *)tmp___1);
  object = (JSON_Object const   *)tmp___2;
  tmp___3 = json_object_dotget_value(object, dot_position + 1);
  return (tmp___3);
}
}
char const   *json_object_dotget_string(JSON_Object const   *object , char const   *name ) 
{ 
  JSON_Value *tmp ;
  char const   *tmp___0 ;

  {
  tmp = json_object_dotget_value(object, name);
  tmp___0 = json_value_get_string((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
double json_object_dotget_number(JSON_Object const   *object , char const   *name ) 
{ 
  JSON_Value *tmp ;
  double tmp___0 ;

  {
  tmp = json_object_dotget_value(object, name);
  tmp___0 = json_value_get_number((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
JSON_Object *json_object_dotget_object(JSON_Object const   *object , char const   *name ) 
{ 
  JSON_Value *tmp ;
  JSON_Object *tmp___0 ;

  {
  tmp = json_object_dotget_value(object, name);
  tmp___0 = json_value_get_object((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
JSON_Array *json_object_dotget_array(JSON_Object const   *object , char const   *name ) 
{ 
  JSON_Value *tmp ;
  JSON_Array *tmp___0 ;

  {
  tmp = json_object_dotget_value(object, name);
  tmp___0 = json_value_get_array((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
int json_object_dotget_boolean(JSON_Object const   *object , char const   *name ) 
{ 
  JSON_Value *tmp ;
  int tmp___0 ;

  {
  tmp = json_object_dotget_value(object, name);
  tmp___0 = json_value_get_boolean((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
size_t json_object_get_count(JSON_Object const   *object ) 
{ 
  size_t tmp ;

  {
  if (object) {
    tmp = object->count;
  } else {
    tmp = (size_t const   )0;
  }
  return ((size_t )tmp);
}
}
char const   *json_object_get_name(JSON_Object const   *object , size_t index___0 ) 
{ 
  size_t tmp ;

  {
  tmp = json_object_get_count(object);
  if (index___0 >= tmp) {
    return ((char const   *)((void *)0));
  }
  return ((char const   *)*(object->names + index___0));
}
}
JSON_Value *json_array_get_value(JSON_Array const   *array , size_t index___0 ) 
{ 
  size_t tmp ;

  {
  tmp = json_array_get_count(array);
  if (index___0 >= tmp) {
    return ((JSON_Value *)((void *)0));
  }
  return (*(array->items + index___0));
}
}
char const   *json_array_get_string(JSON_Array const   *array , size_t index___0 ) 
{ 
  JSON_Value *tmp ;
  char const   *tmp___0 ;

  {
  tmp = json_array_get_value(array, index___0);
  tmp___0 = json_value_get_string((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
double json_array_get_number(JSON_Array const   *array , size_t index___0 ) 
{ 
  JSON_Value *tmp ;
  double tmp___0 ;

  {
  tmp = json_array_get_value(array, index___0);
  tmp___0 = json_value_get_number((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
JSON_Object *json_array_get_object(JSON_Array const   *array , size_t index___0 ) 
{ 
  JSON_Value *tmp ;
  JSON_Object *tmp___0 ;

  {
  tmp = json_array_get_value(array, index___0);
  tmp___0 = json_value_get_object((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
JSON_Array *json_array_get_array(JSON_Array const   *array , size_t index___0 ) 
{ 
  JSON_Value *tmp ;
  JSON_Array *tmp___0 ;

  {
  tmp = json_array_get_value(array, index___0);
  tmp___0 = json_value_get_array((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
int json_array_get_boolean(JSON_Array const   *array , size_t index___0 ) 
{ 
  JSON_Value *tmp ;
  int tmp___0 ;

  {
  tmp = json_array_get_value(array, index___0);
  tmp___0 = json_value_get_boolean((JSON_Value const   *)tmp);
  return (tmp___0);
}
}
size_t json_array_get_count(JSON_Array const   *array ) 
{ 
  size_t tmp ;

  {
  if (array) {
    tmp = array->count;
  } else {
    tmp = (size_t const   )0;
  }
  return ((size_t )tmp);
}
}
JSON_Value_Type json_value_get_type(JSON_Value const   *value ) 
{ 
  JSON_Value_Type tmp ;

  {
  if (value) {
    tmp = value->type;
  } else {
    tmp = (JSON_Value_Type const   )-1;
  }
  return ((JSON_Value_Type )tmp);
}
}
JSON_Object *json_value_get_object(JSON_Value const   *value ) 
{ 
  JSON_Object *tmp___0 ;
  JSON_Value_Type tmp___1 ;

  {
  tmp___1 = json_value_get_type(value);
  if (tmp___1 == 4) {
    tmp___0 = value->value.object;
  } else {
    tmp___0 = (JSON_Object * const  )((void *)0);
  }
  return ((JSON_Object *)tmp___0);
}
}
JSON_Array *json_value_get_array(JSON_Value const   *value ) 
{ 
  JSON_Array *tmp___0 ;
  JSON_Value_Type tmp___1 ;

  {
  tmp___1 = json_value_get_type(value);
  if (tmp___1 == 5) {
    tmp___0 = value->value.array;
  } else {
    tmp___0 = (JSON_Array * const  )((void *)0);
  }
  return ((JSON_Array *)tmp___0);
}
}
char const   *json_value_get_string(JSON_Value const   *value ) 
{ 
  char *tmp___0 ;
  JSON_Value_Type tmp___1 ;

  {
  tmp___1 = json_value_get_type(value);
  if (tmp___1 == 2) {
    tmp___0 = value->value.string;
  } else {
    tmp___0 = (char * const  )((void *)0);
  }
  return ((char const   *)tmp___0);
}
}
double json_value_get_number(JSON_Value const   *value ) 
{ 
  double tmp___0 ;
  JSON_Value_Type tmp___1 ;

  {
  tmp___1 = json_value_get_type(value);
  if (tmp___1 == 3) {
    tmp___0 = value->value.number;
  } else {
    tmp___0 = (double const   )0;
  }
  return ((double )tmp___0);
}
}
int json_value_get_boolean(JSON_Value const   *value ) 
{ 
  int tmp___0 ;
  JSON_Value_Type tmp___1 ;

  {
  tmp___1 = json_value_get_type(value);
  if (tmp___1 == 6) {
    tmp___0 = value->value.boolean;
  } else {
    tmp___0 = (int const   )-1;
  }
  return ((int )tmp___0);
}
}
void json_value_free(JSON_Value *value ) 
{ 
  JSON_Value_Type tmp ;

  {
  tmp = json_value_get_type((JSON_Value const   *)value);
  switch (tmp) {
  case 4: 
  json_object_free(value->value.object);
  break;
  case 2: 
  if (value->value.string) {
    (*parson_free)((void *)value->value.string);
  }
  break;
  case 5: 
  json_array_free(value->value.array);
  break;
  default: 
  break;
  }
  (*parson_free)((void *)value);
  return;
}
}
JSON_Value *json_value_init_object(void) 
{ 
  JSON_Value *new_value ;
  void *tmp ;

  {
  tmp = (*parson_malloc)(sizeof(JSON_Value ));
  new_value = (JSON_Value *)tmp;
  if (! new_value) {
    return ((JSON_Value *)((void *)0));
  }
  new_value->type = 4;
  new_value->value.object = json_object_init();
  if (! new_value->value.object) {
    (*parson_free)((void *)new_value);
    return ((JSON_Value *)((void *)0));
  }
  return (new_value);
}
}
JSON_Value *json_value_init_array(void) 
{ 
  JSON_Value *new_value ;
  void *tmp ;

  {
  tmp = (*parson_malloc)(sizeof(JSON_Value ));
  new_value = (JSON_Value *)tmp;
  if (! new_value) {
    return ((JSON_Value *)((void *)0));
  }
  new_value->type = 5;
  new_value->value.array = json_array_init();
  if (! new_value->value.array) {
    (*parson_free)((void *)new_value);
    return ((JSON_Value *)((void *)0));
  }
  return (new_value);
}
}
JSON_Value *json_value_init_string(char const   *string ) 
{ 
  char *copy___0 ;
  JSON_Value *value ;
  size_t string_len ;
  int tmp ;

  {
  copy___0 = (char *)((void *)0);
  string_len = (size_t )0;
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    return ((JSON_Value *)((void *)0));
  }
  string_len = strlen(string);
  tmp = is_valid_utf8(string, string_len);
  if (! tmp) {
    return ((JSON_Value *)((void *)0));
  }
  copy___0 = parson_strndup(string, string_len);
  if ((unsigned long )copy___0 == (unsigned long )((void *)0)) {
    return ((JSON_Value *)((void *)0));
  }
  value = json_value_init_string_no_copy(copy___0);
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    (*parson_free)((void *)copy___0);
  }
  return (value);
}
}
JSON_Value *json_value_init_number(double number ) 
{ 
  JSON_Value *new_value ;
  void *tmp ;

  {
  tmp = (*parson_malloc)(sizeof(JSON_Value ));
  new_value = (JSON_Value *)tmp;
  if (! new_value) {
    return ((JSON_Value *)((void *)0));
  }
  new_value->type = 3;
  new_value->value.number = number;
  return (new_value);
}
}
JSON_Value *json_value_init_boolean(int boolean ) 
{ 
  JSON_Value *new_value ;
  void *tmp ;

  {
  tmp = (*parson_malloc)(sizeof(JSON_Value ));
  new_value = (JSON_Value *)tmp;
  if (! new_value) {
    return ((JSON_Value *)((void *)0));
  }
  new_value->type = 6;
  if (boolean) {
    new_value->value.boolean = 1;
  } else {
    new_value->value.boolean = 0;
  }
  return (new_value);
}
}
JSON_Value *json_value_init_null(void) 
{ 
  JSON_Value *new_value ;
  void *tmp ;

  {
  tmp = (*parson_malloc)(sizeof(JSON_Value ));
  new_value = (JSON_Value *)tmp;
  if (! new_value) {
    return ((JSON_Value *)((void *)0));
  }
  new_value->type = 1;
  return (new_value);
}
}
JSON_Value *json_value_deep_copy(JSON_Value const   *value ) 
{ 
  size_t i ;
  JSON_Value *return_value ;
  JSON_Value *temp_value_copy ;
  JSON_Value *temp_value ;
  char const   *temp_string ;
  char const   *temp_key ;
  char *temp_string_copy ;
  JSON_Array *temp_array ;
  JSON_Array *temp_array_copy ;
  JSON_Object *temp_object ;
  JSON_Object *temp_object_copy ;
  JSON_Value_Type tmp ;
  JSON_Status tmp___0 ;
  size_t tmp___1 ;
  JSON_Status tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  JSON_Value *tmp___5 ;
  double tmp___6 ;
  JSON_Value *tmp___7 ;
  JSON_Value *tmp___8 ;

  {
  i = (size_t )0;
  return_value = (JSON_Value *)((void *)0);
  temp_value_copy = (JSON_Value *)((void *)0);
  temp_value = (JSON_Value *)((void *)0);
  temp_string = (char const   *)((void *)0);
  temp_key = (char const   *)((void *)0);
  temp_string_copy = (char *)((void *)0);
  temp_array = (JSON_Array *)((void *)0);
  temp_array_copy = (JSON_Array *)((void *)0);
  temp_object = (JSON_Object *)((void *)0);
  temp_object_copy = (JSON_Object *)((void *)0);
  tmp = json_value_get_type(value);
  switch (tmp) {
  case 5: 
  temp_array = json_value_get_array(value);
  return_value = json_value_init_array();
  if ((unsigned long )return_value == (unsigned long )((void *)0)) {
    return ((JSON_Value *)((void *)0));
  }
  temp_array_copy = json_value_get_array((JSON_Value const   *)return_value);
  i = (size_t )0;
  while (1) {
    tmp___1 = json_array_get_count((JSON_Array const   *)temp_array);
    if (! (i < tmp___1)) {
      break;
    }
    temp_value = json_array_get_value((JSON_Array const   *)temp_array, i);
    temp_value_copy = json_value_deep_copy((JSON_Value const   *)temp_value);
    if ((unsigned long )temp_value_copy == (unsigned long )((void *)0)) {
      json_value_free(return_value);
      return ((JSON_Value *)((void *)0));
    }
    tmp___0 = json_array_add(temp_array_copy, temp_value_copy);
    if (tmp___0 == -1) {
      json_value_free(return_value);
      json_value_free(temp_value_copy);
      return ((JSON_Value *)((void *)0));
    }
    i ++;
  }
  return (return_value);
  case 4: 
  temp_object = json_value_get_object(value);
  return_value = json_value_init_object();
  if ((unsigned long )return_value == (unsigned long )((void *)0)) {
    return ((JSON_Value *)((void *)0));
  }
  temp_object_copy = json_value_get_object((JSON_Value const   *)return_value);
  i = (size_t )0;
  while (1) {
    tmp___3 = json_object_get_count((JSON_Object const   *)temp_object);
    if (! (i < tmp___3)) {
      break;
    }
    temp_key = json_object_get_name((JSON_Object const   *)temp_object, i);
    temp_value = json_object_get_value((JSON_Object const   *)temp_object, temp_key);
    temp_value_copy = json_value_deep_copy((JSON_Value const   *)temp_value);
    if ((unsigned long )temp_value_copy == (unsigned long )((void *)0)) {
      json_value_free(return_value);
      return ((JSON_Value *)((void *)0));
    }
    tmp___2 = json_object_add(temp_object_copy, temp_key, temp_value_copy);
    if (tmp___2 == -1) {
      json_value_free(return_value);
      json_value_free(temp_value_copy);
      return ((JSON_Value *)((void *)0));
    }
    i ++;
  }
  return (return_value);
  case 6: 
  tmp___4 = json_value_get_boolean(value);
  tmp___5 = json_value_init_boolean(tmp___4);
  return (tmp___5);
  case 3: 
  tmp___6 = json_value_get_number(value);
  tmp___7 = json_value_init_number(tmp___6);
  return (tmp___7);
  case 2: 
  temp_string = json_value_get_string(value);
  temp_string_copy = parson_strdup(temp_string);
  if ((unsigned long )temp_string_copy == (unsigned long )((void *)0)) {
    return ((JSON_Value *)((void *)0));
  }
  return_value = json_value_init_string_no_copy(temp_string_copy);
  if ((unsigned long )return_value == (unsigned long )((void *)0)) {
    (*parson_free)((void *)temp_string_copy);
  }
  return (return_value);
  case 1: 
  tmp___8 = json_value_init_null();
  return (tmp___8);
  case -1: 
  return ((JSON_Value *)((void *)0));
  default: 
  return ((JSON_Value *)((void *)0));
  }
}
}
size_t json_serialization_size(JSON_Value const   *value ) 
{ 
  char num_buf[1100] ;
  int res ;
  int tmp ;
  size_t tmp___0 ;

  {
  tmp = json_serialize_to_buffer_r(value, (char *)((void *)0), 0, 0, num_buf);
  res = tmp;
  if (res < 0) {
    tmp___0 = (size_t )0;
  } else {
    tmp___0 = (size_t )(res + 1);
  }
  return (tmp___0);
}
}
JSON_Status json_serialize_to_buffer(JSON_Value const   *value , char *buf , size_t buf_size_in_bytes ) 
{ 
  int written ;
  size_t needed_size_in_bytes ;
  size_t tmp ;

  {
  written = -1;
  tmp = json_serialization_size(value);
  needed_size_in_bytes = tmp;
  if (needed_size_in_bytes == 0UL) {
    return (-1);
  } else
  if (buf_size_in_bytes < needed_size_in_bytes) {
    return (-1);
  }
  written = json_serialize_to_buffer_r(value, buf, 0, 0, (char *)((void *)0));
  if (written < 0) {
    return (-1);
  }
  return (0);
}
}
JSON_Status json_serialize_to_file(JSON_Value const   *value , char const   *filename ) 
{ 
  JSON_Status return_code ;
  FILE *fp ;
  char *serialized_string ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  return_code = 0;
  fp = (FILE *)((void *)0);
  tmp = json_serialize_to_string(value);
  serialized_string = tmp;
  if ((unsigned long )serialized_string == (unsigned long )((void *)0)) {
    return (-1);
  }
  fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"w");
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    tmp___0 = fputs((char const   * __restrict  )serialized_string, (FILE * __restrict  )fp);
    if (tmp___0 == -1) {
      return_code = -1;
    }
    tmp___1 = fclose(fp);
    if (tmp___1 == -1) {
      return_code = -1;
    }
  }
  json_free_serialized_string(serialized_string);
  return (return_code);
}
}
char *json_serialize_to_string(JSON_Value const   *value ) 
{ 
  JSON_Status serialization_result ;
  size_t buf_size_bytes ;
  size_t tmp ;
  char *buf ;
  void *tmp___0 ;

  {
  serialization_result = -1;
  tmp = json_serialization_size(value);
  buf_size_bytes = tmp;
  buf = (char *)((void *)0);
  if (buf_size_bytes == 0UL) {
    return ((char *)((void *)0));
  }
  tmp___0 = (*parson_malloc)(buf_size_bytes);
  buf = (char *)tmp___0;
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  serialization_result = json_serialize_to_buffer(value, buf, buf_size_bytes);
  if (serialization_result == -1) {
    json_free_serialized_string(buf);
    return ((char *)((void *)0));
  }
  return (buf);
}
}
size_t json_serialization_size_pretty(JSON_Value const   *value ) 
{ 
  char num_buf[1100] ;
  int res ;
  int tmp ;
  size_t tmp___0 ;

  {
  tmp = json_serialize_to_buffer_r(value, (char *)((void *)0), 0, 1, num_buf);
  res = tmp;
  if (res < 0) {
    tmp___0 = (size_t )0;
  } else {
    tmp___0 = (size_t )(res + 1);
  }
  return (tmp___0);
}
}
JSON_Status json_serialize_to_buffer_pretty(JSON_Value const   *value , char *buf ,
                                            size_t buf_size_in_bytes ) 
{ 
  int written ;
  size_t needed_size_in_bytes ;
  size_t tmp ;

  {
  written = -1;
  tmp = json_serialization_size_pretty(value);
  needed_size_in_bytes = tmp;
  if (needed_size_in_bytes == 0UL) {
    return (-1);
  } else
  if (buf_size_in_bytes < needed_size_in_bytes) {
    return (-1);
  }
  written = json_serialize_to_buffer_r(value, buf, 0, 1, (char *)((void *)0));
  if (written < 0) {
    return (-1);
  }
  return (0);
}
}
JSON_Status json_serialize_to_file_pretty(JSON_Value const   *value , char const   *filename ) 
{ 
  JSON_Status return_code ;
  FILE *fp ;
  char *serialized_string ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  return_code = 0;
  fp = (FILE *)((void *)0);
  tmp = json_serialize_to_string_pretty(value);
  serialized_string = tmp;
  if ((unsigned long )serialized_string == (unsigned long )((void *)0)) {
    return (-1);
  }
  fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"w");
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    tmp___0 = fputs((char const   * __restrict  )serialized_string, (FILE * __restrict  )fp);
    if (tmp___0 == -1) {
      return_code = -1;
    }
    tmp___1 = fclose(fp);
    if (tmp___1 == -1) {
      return_code = -1;
    }
  }
  json_free_serialized_string(serialized_string);
  return (return_code);
}
}
char *json_serialize_to_string_pretty(JSON_Value const   *value ) 
{ 
  JSON_Status serialization_result ;
  size_t buf_size_bytes ;
  size_t tmp ;
  char *buf ;
  void *tmp___0 ;

  {
  serialization_result = -1;
  tmp = json_serialization_size_pretty(value);
  buf_size_bytes = tmp;
  buf = (char *)((void *)0);
  if (buf_size_bytes == 0UL) {
    return ((char *)((void *)0));
  }
  tmp___0 = (*parson_malloc)(buf_size_bytes);
  buf = (char *)tmp___0;
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  serialization_result = json_serialize_to_buffer_pretty(value, buf, buf_size_bytes);
  if (serialization_result == -1) {
    json_free_serialized_string(buf);
    return ((char *)((void *)0));
  }
  return (buf);
}
}
void json_free_serialized_string(char *string ) 
{ 


  {
  (*parson_free)((void *)string);
  return;
}
}
JSON_Status json_array_remove(JSON_Array *array , size_t ix ) 
{ 
  size_t last_element_ix ;
  size_t tmp ;
  size_t tmp___0 ;
  JSON_Value *tmp___1 ;

  {
  last_element_ix = (size_t )0;
  if ((unsigned long )array == (unsigned long )((void *)0)) {
    return (-1);
  } else {
    tmp = json_array_get_count((JSON_Array const   *)array);
    if (ix >= tmp) {
      return (-1);
    }
  }
  tmp___0 = json_array_get_count((JSON_Array const   *)array);
  last_element_ix = tmp___0 - 1UL;
  tmp___1 = json_array_get_value((JSON_Array const   *)array, ix);
  json_value_free(tmp___1);
  (array->count) --;
  if (ix != last_element_ix) {
    *(array->items + ix) = json_array_get_value((JSON_Array const   *)array, last_element_ix);
  }
  return (0);
}
}
JSON_Status json_array_replace_value(JSON_Array *array , size_t ix , JSON_Value *value ) 
{ 
  size_t tmp ;
  JSON_Value *tmp___0 ;

  {
  if ((unsigned long )array == (unsigned long )((void *)0)) {
    return (-1);
  } else
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  } else {
    tmp = json_array_get_count((JSON_Array const   *)array);
    if (ix >= tmp) {
      return (-1);
    }
  }
  tmp___0 = json_array_get_value((JSON_Array const   *)array, ix);
  json_value_free(tmp___0);
  *(array->items + ix) = value;
  return (0);
}
}
JSON_Status json_array_replace_string(JSON_Array *array , size_t i , char const   *string ) 
{ 
  JSON_Value *value ;
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_string(string);
  value = tmp;
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp___0 = json_array_replace_value(array, i, value);
  if (tmp___0 == -1) {
    json_value_free(value);
    return (-1);
  }
  return (0);
}
}
JSON_Status json_array_replace_number(JSON_Array *array , size_t i , double number ) 
{ 
  JSON_Value *value ;
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_number(number);
  value = tmp;
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp___0 = json_array_replace_value(array, i, value);
  if (tmp___0 == -1) {
    json_value_free(value);
    return (-1);
  }
  return (0);
}
}
JSON_Status json_array_replace_boolean(JSON_Array *array , size_t i , int boolean ) 
{ 
  JSON_Value *value ;
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_boolean(boolean);
  value = tmp;
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp___0 = json_array_replace_value(array, i, value);
  if (tmp___0 == -1) {
    json_value_free(value);
    return (-1);
  }
  return (0);
}
}
JSON_Status json_array_replace_null(JSON_Array *array , size_t i ) 
{ 
  JSON_Value *value ;
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_null();
  value = tmp;
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp___0 = json_array_replace_value(array, i, value);
  if (tmp___0 == -1) {
    json_value_free(value);
    return (-1);
  }
  return (0);
}
}
JSON_Status json_array_clear(JSON_Array *array ) 
{ 
  size_t i ;
  JSON_Value *tmp ;
  size_t tmp___0 ;

  {
  i = (size_t )0;
  if ((unsigned long )array == (unsigned long )((void *)0)) {
    return (-1);
  }
  i = (size_t )0;
  while (1) {
    tmp___0 = json_array_get_count((JSON_Array const   *)array);
    if (! (i < tmp___0)) {
      break;
    }
    tmp = json_array_get_value((JSON_Array const   *)array, i);
    json_value_free(tmp);
    i ++;
  }
  array->count = (size_t )0;
  return (0);
}
}
JSON_Status json_array_append_value(JSON_Array *array , JSON_Value *value ) 
{ 
  JSON_Status tmp ;

  {
  if ((unsigned long )array == (unsigned long )((void *)0)) {
    return (-1);
  } else
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp = json_array_add(array, value);
  return (tmp);
}
}
JSON_Status json_array_append_string(JSON_Array *array , char const   *string ) 
{ 
  JSON_Value *value ;
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_string(string);
  value = tmp;
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp___0 = json_array_append_value(array, value);
  if (tmp___0 == -1) {
    json_value_free(value);
    return (-1);
  }
  return (0);
}
}
JSON_Status json_array_append_number(JSON_Array *array , double number ) 
{ 
  JSON_Value *value ;
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_number(number);
  value = tmp;
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp___0 = json_array_append_value(array, value);
  if (tmp___0 == -1) {
    json_value_free(value);
    return (-1);
  }
  return (0);
}
}
JSON_Status json_array_append_boolean(JSON_Array *array , int boolean ) 
{ 
  JSON_Value *value ;
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_boolean(boolean);
  value = tmp;
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp___0 = json_array_append_value(array, value);
  if (tmp___0 == -1) {
    json_value_free(value);
    return (-1);
  }
  return (0);
}
}
JSON_Status json_array_append_null(JSON_Array *array ) 
{ 
  JSON_Value *value ;
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_null();
  value = tmp;
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp___0 = json_array_append_value(array, value);
  if (tmp___0 == -1) {
    json_value_free(value);
    return (-1);
  }
  return (0);
}
}
JSON_Status json_object_set_value(JSON_Object *object , char const   *name , JSON_Value *value ) 
{ 
  size_t i ;
  JSON_Value *old_value ;
  int tmp ;
  size_t tmp___0 ;
  JSON_Status tmp___1 ;

  {
  i = (size_t )0;
  if ((unsigned long )object == (unsigned long )((void *)0)) {
    return (-1);
  } else
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    return (-1);
  } else
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  old_value = json_object_get_value((JSON_Object const   *)object, name);
  if ((unsigned long )old_value != (unsigned long )((void *)0)) {
    json_value_free(old_value);
    i = (size_t )0;
    while (1) {
      tmp___0 = json_object_get_count((JSON_Object const   *)object);
      if (! (i < tmp___0)) {
        break;
      }
      tmp = strcmp((char const   *)*(object->names + i), name);
      if (tmp == 0) {
        *(object->values + i) = value;
        return (0);
      }
      i ++;
    }
  }
  tmp___1 = json_object_add(object, name, value);
  return (tmp___1);
}
}
JSON_Status json_object_set_string(JSON_Object *object , char const   *name , char const   *string ) 
{ 
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_string(string);
  tmp___0 = json_object_set_value(object, name, tmp);
  return (tmp___0);
}
}
JSON_Status json_object_set_number(JSON_Object *object , char const   *name , double number ) 
{ 
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_number(number);
  tmp___0 = json_object_set_value(object, name, tmp);
  return (tmp___0);
}
}
JSON_Status json_object_set_boolean(JSON_Object *object , char const   *name , int boolean ) 
{ 
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_boolean(boolean);
  tmp___0 = json_object_set_value(object, name, tmp);
  return (tmp___0);
}
}
JSON_Status json_object_set_null(JSON_Object *object , char const   *name ) 
{ 
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_null();
  tmp___0 = json_object_set_value(object, name, tmp);
  return (tmp___0);
}
}
JSON_Status json_object_dotset_value(JSON_Object *object , char const   *name , JSON_Value *value ) 
{ 
  char const   *dot_pos ;
  char *current_name ;
  JSON_Object *temp_obj ;
  JSON_Value *new_value ;
  char *tmp ;
  JSON_Status tmp___0 ;
  JSON_Status tmp___1 ;
  JSON_Status tmp___2 ;

  {
  dot_pos = (char const   *)((void *)0);
  current_name = (char *)((void *)0);
  temp_obj = (JSON_Object *)((void *)0);
  new_value = (JSON_Value *)((void *)0);
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  } else
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    return (-1);
  } else
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp = strchr(name, '.');
  dot_pos = (char const   *)tmp;
  if ((unsigned long )dot_pos == (unsigned long )((void *)0)) {
    tmp___0 = json_object_set_value(object, name, value);
    return (tmp___0);
  } else {
    current_name = parson_strndup(name, (size_t )(dot_pos - name));
    temp_obj = json_object_get_object((JSON_Object const   *)object, (char const   *)current_name);
    if ((unsigned long )temp_obj == (unsigned long )((void *)0)) {
      new_value = json_value_init_object();
      if ((unsigned long )new_value == (unsigned long )((void *)0)) {
        (*parson_free)((void *)current_name);
        return (-1);
      }
      tmp___1 = json_object_add(object, (char const   *)current_name, new_value);
      if (tmp___1 == -1) {
        json_value_free(new_value);
        (*parson_free)((void *)current_name);
        return (-1);
      }
      temp_obj = json_object_get_object((JSON_Object const   *)object, (char const   *)current_name);
    }
    (*parson_free)((void *)current_name);
    tmp___2 = json_object_dotset_value(temp_obj, dot_pos + 1, value);
    return (tmp___2);
  }
}
}
JSON_Status json_object_dotset_string(JSON_Object *object , char const   *name , char const   *string ) 
{ 
  JSON_Value *value ;
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_string(string);
  value = tmp;
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp___0 = json_object_dotset_value(object, name, value);
  if (tmp___0 == -1) {
    json_value_free(value);
    return (-1);
  }
  return (0);
}
}
JSON_Status json_object_dotset_number(JSON_Object *object , char const   *name , double number ) 
{ 
  JSON_Value *value ;
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_number(number);
  value = tmp;
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp___0 = json_object_dotset_value(object, name, value);
  if (tmp___0 == -1) {
    json_value_free(value);
    return (-1);
  }
  return (0);
}
}
JSON_Status json_object_dotset_boolean(JSON_Object *object , char const   *name ,
                                       int boolean ) 
{ 
  JSON_Value *value ;
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_boolean(boolean);
  value = tmp;
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp___0 = json_object_dotset_value(object, name, value);
  if (tmp___0 == -1) {
    json_value_free(value);
    return (-1);
  }
  return (0);
}
}
JSON_Status json_object_dotset_null(JSON_Object *object , char const   *name ) 
{ 
  JSON_Value *value ;
  JSON_Value *tmp ;
  JSON_Status tmp___0 ;

  {
  tmp = json_value_init_null();
  value = tmp;
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp___0 = json_object_dotset_value(object, name, value);
  if (tmp___0 == -1) {
    json_value_free(value);
    return (-1);
  }
  return (0);
}
}
JSON_Status json_object_remove(JSON_Object *object , char const   *name ) 
{ 
  size_t i ;
  size_t last_item_index ;
  JSON_Value *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  i = (size_t )0;
  last_item_index = (size_t )0;
  if ((unsigned long )object == (unsigned long )((void *)0)) {
    return (-1);
  } else {
    tmp = json_object_get_value((JSON_Object const   *)object, name);
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      return (-1);
    }
  }
  tmp___0 = json_object_get_count((JSON_Object const   *)object);
  last_item_index = tmp___0 - 1UL;
  i = (size_t )0;
  while (1) {
    tmp___2 = json_object_get_count((JSON_Object const   *)object);
    if (! (i < tmp___2)) {
      break;
    }
    tmp___1 = strcmp((char const   *)*(object->names + i), name);
    if (tmp___1 == 0) {
      (*parson_free)((void *)*(object->names + i));
      json_value_free(*(object->values + i));
      if (i != last_item_index) {
        *(object->names + i) = *(object->names + last_item_index);
        *(object->values + i) = *(object->values + last_item_index);
      }
      (object->count) --;
      return (0);
    }
    i ++;
  }
  return (-1);
}
}
JSON_Status json_object_dotremove(JSON_Object *object , char const   *name ) 
{ 
  char const   *dot_pos ;
  char *tmp ;
  char *current_name ;
  JSON_Object *temp_obj ;
  JSON_Status tmp___0 ;
  JSON_Status tmp___1 ;

  {
  tmp = strchr(name, '.');
  dot_pos = (char const   *)tmp;
  current_name = (char *)((void *)0);
  temp_obj = (JSON_Object *)((void *)0);
  if ((unsigned long )dot_pos == (unsigned long )((void *)0)) {
    tmp___0 = json_object_remove(object, name);
    return (tmp___0);
  } else {
    current_name = parson_strndup(name, (size_t )(dot_pos - name));
    temp_obj = json_object_get_object((JSON_Object const   *)object, (char const   *)current_name);
    if ((unsigned long )temp_obj == (unsigned long )((void *)0)) {
      (*parson_free)((void *)current_name);
      return (-1);
    }
    (*parson_free)((void *)current_name);
    tmp___1 = json_object_dotremove(temp_obj, dot_pos + 1);
    return (tmp___1);
  }
}
}
JSON_Status json_object_clear(JSON_Object *object ) 
{ 
  size_t i ;
  size_t tmp ;

  {
  i = (size_t )0;
  if ((unsigned long )object == (unsigned long )((void *)0)) {
    return (-1);
  }
  i = (size_t )0;
  while (1) {
    tmp = json_object_get_count((JSON_Object const   *)object);
    if (! (i < tmp)) {
      break;
    }
    (*parson_free)((void *)*(object->names + i));
    json_value_free(*(object->values + i));
    i ++;
  }
  object->count = (size_t )0;
  return (0);
}
}
JSON_Status json_validate(JSON_Value const   *schema , JSON_Value const   *value ) 
{ 
  JSON_Value *temp_schema_value ;
  JSON_Value *temp_value ;
  JSON_Array *schema_array ;
  JSON_Array *value_array ;
  JSON_Object *schema_object ;
  JSON_Object *value_object ;
  JSON_Value_Type schema_type ;
  JSON_Value_Type value_type ;
  char const   *key ;
  size_t i ;
  size_t count ;
  JSON_Status tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  JSON_Status tmp___2 ;

  {
  temp_schema_value = (JSON_Value *)((void *)0);
  temp_value = (JSON_Value *)((void *)0);
  schema_array = (JSON_Array *)((void *)0);
  value_array = (JSON_Array *)((void *)0);
  schema_object = (JSON_Object *)((void *)0);
  value_object = (JSON_Object *)((void *)0);
  schema_type = -1;
  value_type = -1;
  key = (char const   *)((void *)0);
  i = (size_t )0;
  count = (size_t )0;
  if ((unsigned long )schema == (unsigned long )((void *)0)) {
    return (-1);
  } else
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return (-1);
  }
  schema_type = json_value_get_type(schema);
  value_type = json_value_get_type(value);
  if (schema_type != value_type) {
    if (schema_type != 1) {
      return (-1);
    }
  }
  switch (schema_type) {
  case 5: 
  schema_array = json_value_get_array(schema);
  value_array = json_value_get_array(value);
  count = json_array_get_count((JSON_Array const   *)schema_array);
  if (count == 0UL) {
    return (0);
  }
  temp_schema_value = json_array_get_value((JSON_Array const   *)schema_array, (size_t )0);
  i = (size_t )0;
  while (1) {
    tmp___0 = json_array_get_count((JSON_Array const   *)value_array);
    if (! (i < tmp___0)) {
      break;
    }
    temp_value = json_array_get_value((JSON_Array const   *)value_array, i);
    tmp = json_validate((JSON_Value const   *)temp_schema_value, (JSON_Value const   *)temp_value);
    if (tmp == 0) {
      return (-1);
    }
    i ++;
  }
  return (0);
  case 4: 
  schema_object = json_value_get_object(schema);
  value_object = json_value_get_object(value);
  count = json_object_get_count((JSON_Object const   *)schema_object);
  if (count == 0UL) {
    return (0);
  } else {
    tmp___1 = json_object_get_count((JSON_Object const   *)value_object);
    if (tmp___1 < count) {
      return (-1);
    }
  }
  i = (size_t )0;
  while (i < count) {
    key = json_object_get_name((JSON_Object const   *)schema_object, i);
    temp_schema_value = json_object_get_value((JSON_Object const   *)schema_object,
                                              key);
    temp_value = json_object_get_value((JSON_Object const   *)value_object, key);
    if ((unsigned long )temp_value == (unsigned long )((void *)0)) {
      return (-1);
    }
    tmp___2 = json_validate((JSON_Value const   *)temp_schema_value, (JSON_Value const   *)temp_value);
    if (tmp___2 == -1) {
      return (-1);
    }
    i ++;
  }
  return (0);
  case 1: 
  case 6: 
  case 3: 
  case 2: 
  return (0);
  default: 
  return (-1);
  }
}
}
int json_value_equals(JSON_Value const   *a , JSON_Value const   *b ) 
{ 
  JSON_Object *a_object ;
  JSON_Object *b_object ;
  JSON_Array *a_array ;
  JSON_Array *b_array ;
  char const   *a_string ;
  char const   *b_string ;
  char const   *key ;
  size_t a_count ;
  size_t b_count ;
  size_t i ;
  JSON_Value_Type a_type ;
  JSON_Value_Type b_type ;
  JSON_Value *tmp ;
  JSON_Value *tmp___0 ;
  int tmp___1 ;
  JSON_Value *tmp___2 ;
  JSON_Value *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;

  {
  a_object = (JSON_Object *)((void *)0);
  b_object = (JSON_Object *)((void *)0);
  a_array = (JSON_Array *)((void *)0);
  b_array = (JSON_Array *)((void *)0);
  a_string = (char const   *)((void *)0);
  b_string = (char const   *)((void *)0);
  key = (char const   *)((void *)0);
  a_count = (size_t )0;
  b_count = (size_t )0;
  i = (size_t )0;
  a_type = json_value_get_type(a);
  b_type = json_value_get_type(b);
  if (a_type != b_type) {
    return (0);
  }
  switch (a_type) {
  case 5: 
  a_array = json_value_get_array(a);
  b_array = json_value_get_array(b);
  a_count = json_array_get_count((JSON_Array const   *)a_array);
  b_count = json_array_get_count((JSON_Array const   *)b_array);
  if (a_count != b_count) {
    return (0);
  }
  i = (size_t )0;
  while (i < a_count) {
    tmp = json_array_get_value((JSON_Array const   *)b_array, i);
    tmp___0 = json_array_get_value((JSON_Array const   *)a_array, i);
    tmp___1 = json_value_equals((JSON_Value const   *)tmp___0, (JSON_Value const   *)tmp);
    if (! tmp___1) {
      return (0);
    }
    i ++;
  }
  return (1);
  case 4: 
  a_object = json_value_get_object(a);
  b_object = json_value_get_object(b);
  a_count = json_object_get_count((JSON_Object const   *)a_object);
  b_count = json_object_get_count((JSON_Object const   *)b_object);
  if (a_count != b_count) {
    return (0);
  }
  i = (size_t )0;
  while (i < a_count) {
    key = json_object_get_name((JSON_Object const   *)a_object, i);
    tmp___2 = json_object_get_value((JSON_Object const   *)b_object, key);
    tmp___3 = json_object_get_value((JSON_Object const   *)a_object, key);
    tmp___4 = json_value_equals((JSON_Value const   *)tmp___3, (JSON_Value const   *)tmp___2);
    if (! tmp___4) {
      return (0);
    }
    i ++;
  }
  return (1);
  case 2: 
  a_string = json_value_get_string(a);
  b_string = json_value_get_string(b);
  tmp___5 = strcmp(a_string, b_string);
  return (tmp___5 == 0);
  case 6: 
  tmp___6 = json_value_get_boolean(a);
  tmp___7 = json_value_get_boolean(b);
  return (tmp___6 == tmp___7);
  case 3: 
  tmp___8 = json_value_get_number(a);
  tmp___9 = json_value_get_number(b);
  tmp___10 = fabs(tmp___8 - tmp___9);
  return (tmp___10 < 0.000001);
  case -1: 
  return (1);
  case 1: 
  return (1);
  default: 
  return (1);
  }
}
}
JSON_Value_Type json_type(JSON_Value const   *value ) 
{ 
  JSON_Value_Type tmp ;

  {
  tmp = json_value_get_type(value);
  return (tmp);
}
}
JSON_Object *json_object(JSON_Value const   *value ) 
{ 
  JSON_Object *tmp ;

  {
  tmp = json_value_get_object(value);
  return (tmp);
}
}
JSON_Array *json_array(JSON_Value const   *value ) 
{ 
  JSON_Array *tmp ;

  {
  tmp = json_value_get_array(value);
  return (tmp);
}
}
char const   *json_string(JSON_Value const   *value ) 
{ 
  char const   *tmp ;

  {
  tmp = json_value_get_string(value);
  return (tmp);
}
}
double json_number(JSON_Value const   *value ) 
{ 
  double tmp ;

  {
  tmp = json_value_get_number(value);
  return (tmp);
}
}
int json_boolean(JSON_Value const   *value ) 
{ 
  int tmp ;

  {
  tmp = json_value_get_boolean(value);
  return (tmp);
}
}
void json_set_allocation_functions(void *(*malloc_fun)(size_t  ) , void (*free_fun)(void * ) ) 
{ 


  {
  parson_malloc = malloc_fun;
  parson_free = free_fun;
  return;
}
}
#pragma merger("0","/tmp/cil-O6Q7tJxX.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
_Bool str_ends_with(char const   *str , char const   *end ) ;
_Bool str_starts_with(char const   *str , char const   *start ) ;
char *path_join(char const   *dir , char const   *file ) 
{ 
  int size ;
  size_t tmp ;
  size_t tmp___0 ;
  char *buf ;
  void *tmp___1 ;
  _Bool tmp___2 ;
  char *filecopy ;
  char *tmp___3 ;
  _Bool tmp___4 ;

  {
  tmp = strlen(dir);
  tmp___0 = strlen(file);
  size = (int )((tmp + tmp___0) + 2UL);
  tmp___1 = malloc((unsigned long )size * sizeof(char ));
  buf = (char *)tmp___1;
  if ((unsigned long )((void *)0) == (unsigned long )buf) {
    return ((char *)((void *)0));
  }
  strcpy((char * __restrict  )buf, (char const   * __restrict  )dir);
  tmp___2 = str_ends_with(dir, "/");
  if (! tmp___2) {
    strcat((char * __restrict  )buf, (char const   * __restrict  )"/");
  }
  tmp___4 = str_starts_with(file, "/");
  if (tmp___4) {
    tmp___3 = strdup(file);
    filecopy = tmp___3;
    if ((unsigned long )((void *)0) == (unsigned long )filecopy) {
      free((void *)buf);
      return ((char *)((void *)0));
    }
    filecopy ++;
    strcat((char * __restrict  )buf, (char const   * __restrict  )filecopy);
    filecopy --;
    free((void *)filecopy);
  } else {
    strcat((char * __restrict  )buf, (char const   * __restrict  )file);
  }
  return (buf);
}
}
#pragma merger("0","/tmp/cil-wIbLGowy.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern CURL *curl_easy_init(void) ;
extern CURLcode curl_easy_setopt(CURL *curl , CURLoption option  , ...) ;
extern CURLcode curl_easy_perform(CURL *curl ) ;
extern void curl_easy_cleanup(CURL *curl ) ;
extern CURLcode curl_easy_getinfo(CURL *curl , CURLINFO info  , ...) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
int http_get_file(char const   *url , char const   *file ) ;
static size_t http_get_cb(void *contents , size_t size , size_t nmemb , void *userp ) 
{ 
  size_t realsize ;
  http_get_response_t *res ;
  void *tmp ;
  void *ptr ;
  void *tmp___0 ;

  {
  realsize = size * nmemb;
  res = (http_get_response_t *)userp;
  if ((unsigned long )((char *)0) == (unsigned long )res->data) {
    tmp = malloc(realsize + 1UL);
    res->data = (char *)tmp;
  } else {
    tmp___0 = realloc((void *)res->data, (res->size + realsize) + 1UL);
    ptr = tmp___0;
    if ((unsigned long )((void *)0) == (unsigned long )ptr) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"not enough memory!");
      return ((size_t )0);
    }
    res->data = (char *)ptr;
  }
  memset((void *)(res->data + res->size), 0, realsize);
  memcpy((void * __restrict  )(res->data + res->size), (void const   * __restrict  )contents,
         realsize);
  res->size += realsize;
  *(res->data + res->size) = (char)0;
  return (realsize);
}
}
http_get_response_t *http_get_shared(char const   *url , void *share ) 
{ 
  CURL *req ;
  CURL *tmp ;
  http_get_response_t *res ;
  void *tmp___0 ;
  int c ;
  CURLcode tmp___1 ;

  {
  tmp = curl_easy_init();
  req = tmp;
  tmp___0 = malloc(sizeof(http_get_response_t ));
  res = (http_get_response_t *)tmp___0;
  memset((void *)res, 0, sizeof(http_get_response_t ));
  if (share) {
    curl_easy_setopt(req, (CURLoption )10100, share);
  }
  curl_easy_setopt(req, (CURLoption )10002, url);
  curl_easy_setopt(req, (CURLoption )80, 1);
  curl_easy_setopt(req, (CURLoption )52, 1);
  curl_easy_setopt(req, (CURLoption )20011, & http_get_cb);
  curl_easy_setopt(req, (CURLoption )10001, (void *)res);
  curl_easy_setopt(req, (CURLoption )10018, "http-get.c/0.4.0");
  tmp___1 = curl_easy_perform(req);
  c = (int )tmp___1;
  curl_easy_getinfo(req, (CURLINFO )2097154, & res->status);
  if (200L == res->status) {
    if (42 != c) {
      res->ok = 1;
    } else {
      res->ok = 0;
    }
  } else {
    res->ok = 0;
  }
  curl_easy_cleanup(req);
  return (res);
}
}
http_get_response_t *http_get(char const   *url ) 
{ 
  http_get_response_t *tmp ;

  {
  tmp = http_get_shared(url, (void *)0);
  return (tmp);
}
}
static size_t http_get_file_cb(void *ptr , size_t size , size_t nmemb , void *stream ) 
{ 
  size_t n ;
  size_t tmp ;

  {
  fflush((FILE *)stream);
  tmp = fwrite((void const   * __restrict  )ptr, size, nmemb, (FILE * __restrict  )stream);
  n = tmp;
  return (n);
}
}
int http_get_file_shared(char const   *url , char const   *file , void *share ) 
{ 
  CURL *req ;
  CURL *tmp ;
  FILE *fp ;
  FILE *tmp___0 ;
  int res ;
  CURLcode tmp___1 ;
  long status ;
  int tmp___2 ;

  {
  tmp = curl_easy_init();
  req = tmp;
  if (! req) {
    return (-1);
  }
  tmp___0 = fopen((char const   * __restrict  )file, (char const   * __restrict  )"wb");
  fp = tmp___0;
  if (! fp) {
    return (-1);
  }
  if (share) {
    curl_easy_setopt(req, (CURLoption )10100, share);
  }
  curl_easy_setopt(req, (CURLoption )10002, url);
  curl_easy_setopt(req, (CURLoption )80, 1);
  curl_easy_setopt(req, (CURLoption )52, 1);
  curl_easy_setopt(req, (CURLoption )20011, & http_get_file_cb);
  curl_easy_setopt(req, (CURLoption )10001, fp);
  tmp___1 = curl_easy_perform(req);
  res = (int )tmp___1;
  curl_easy_getinfo(req, (CURLINFO )2097154, & status);
  curl_easy_cleanup(req);
  fclose(fp);
  if (200L == status) {
    if (42 != res) {
      tmp___2 = 0;
    } else {
      tmp___2 = -1;
    }
  } else {
    tmp___2 = -1;
  }
  return (tmp___2);
}
}
int http_get_file(char const   *url , char const   *file ) 
{ 
  int tmp ;

  {
  tmp = http_get_file_shared(url, file, (void *)0);
  return (tmp);
}
}
void http_get_free(http_get_response_t *res ) 
{ 


  {
  if ((unsigned long )((void *)0) == (unsigned long )res) {
    return;
  }
  if ((unsigned long )((void *)0) != (unsigned long )res->data) {
    free((void *)res->data);
  }
  res->data = (char *)((void *)0);
  res->size = (size_t )0;
  free((void *)res);
  return;
}
}
#pragma merger("0","/tmp/cil-ht9wCkWK.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
char *str_flatten(char const   **array , int start , int end ) 
{ 
  int count ;
  size_t size ;
  size_t pos ;
  int i ;
  int j ;
  char *str ;
  void *tmp ;
  int i___0 ;
  int j___0 ;

  {
  count = end - start;
  size_t lengths[count] ;
  size = (size_t )0;
  pos = (size_t )0;
  i = start;
  j = 0;
  while (i < end) {
    lengths[j] = strlen(*(array + i));
    size += lengths[j];
    i ++;
    j ++;
  }
  tmp = malloc(size + (size_t )count);
  str = (char *)tmp;
  *(str + ((size + (size_t )count) - 1UL)) = (char )'\000';
  i___0 = start;
  j___0 = 0;
  while (i___0 < end - 1) {
    memcpy((void * __restrict  )((str + pos) + j___0), (void const   * __restrict  )*(array + i___0),
           lengths[j___0]);
    *(str + ((pos + lengths[j___0]) + (size_t )j___0)) = (char )' ';
    pos += lengths[j___0];
    i___0 ++;
    j___0 ++;
  }
  memcpy((void * __restrict  )(((str + pos) + count) - 1), (void const   * __restrict  )*(array + (end - 1)),
         lengths[count - 1]);
  return (str);
}
}
#pragma merger("0","/tmp/cil-M7dVnHGu.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
GumboTag gumbo_tag_enum(char const   *tagname ) ;
static void crawl(GumboTag tag , list_t *elements , GumboNode *node ) 
{ 
  list_node_t *tmp ;
  GumboVector *children ;
  unsigned int i ;

  {
  if (0U != (unsigned int )node->type) {
    if (1U != (unsigned int )node->type) {
      return;
    }
  }
  if ((unsigned int )tag == (unsigned int )node->v.element.tag) {
    tmp = list_node_new((void *)node);
    list_rpush(elements, tmp);
  }
  children = & node->v.element.children;
  i = 0U;
  while (i < children->length) {
    crawl(tag, elements, (GumboNode *)*(children->data + i));
    i ++;
  }
  return;
}
}
list_t *gumbo_get_elements_by_tag_name(char const   *tag_name , GumboNode *root ) 
{ 
  GumboTag tag ;
  list_t *elements ;

  {
  elements = (list_t *)((void *)0);
  if (! tag_name) {
    return ((list_t *)((void *)0));
  } else {
    tag = gumbo_tag_enum(tag_name);
    if (149U == (unsigned int )tag) {
      return ((list_t *)((void *)0));
    }
  }
  elements = list_new();
  if (! elements) {
    return ((list_t *)((void *)0));
  }
  crawl(tag, elements, root);
  return (elements);
}
}
#pragma merger("0","/tmp/cil-_yBNrTk9.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
int wildcardcmp(char const   *pattern , char const   *string ) ;
int wildcardcmp(char const   *pattern , char const   *string ) 
{ 
  char const   *w ;
  char const   *s ;
  char const   *tmp ;

  {
  w = (char const   *)((void *)0);
  s = (char const   *)((void *)0);
  if (! pattern) {
    return (0);
  } else
  if (! string) {
    return (0);
  }
  while (1) {
    if (! *string) {
      if (! *pattern) {
        return (1);
      }
      if (42 == (int )*pattern) {
        pattern ++;
        continue;
      }
      if (! *s) {
        return (0);
      }
      tmp = s;
      s ++;
      string = tmp;
      pattern = w;
      continue;
    } else
    if ((int const   )*pattern != (int const   )*string) {
      if (42 == (int )*pattern) {
        pattern ++;
        w = pattern;
        s = string;
        if (*pattern) {
          continue;
        }
        return (1);
      } else
      if (w) {
        string ++;
        continue;
      }
      return (0);
    }
    string ++;
    pattern ++;
  }
  return (1);
}
}
#pragma merger("0","/tmp/cil-Iuiunto1.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
void command_help(command_t *self ) ;
static void error(char *msg ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", msg);
  exit(1);
}
}
static void command_version(command_t *self ) 
{ 


  {
  printf((char const   * __restrict  )"%s\n", self->version);
  command_free(self);
  exit(0);
}
}
void command_help(command_t *self ) 
{ 
  int i ;
  command_option_t *option ;

  {
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"  Usage: %s %s\n", self->name, self->usage);
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"  Options:\n");
  printf((char const   * __restrict  )"\n");
  i = 0;
  while (i < self->option_count) {
    option = & self->options[i];
    printf((char const   * __restrict  )"    %s, %-25s %s\n", option->small, option->large_with_arg,
           option->description);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  command_free(self);
  exit(0);
}
}
void command_init(command_t *self , char const   *name , char const   *version ) 
{ 
  int tmp ;

  {
  self->arg = (char const   *)((void *)0);
  self->name = name;
  self->version = version;
  tmp = 0;
  self->argc = tmp;
  self->option_count = tmp;
  self->usage = "[options]";
  self->nargv = (char **)((void *)0);
  command_option(self, "-V", "--version", "output program version", & command_version);
  command_option(self, "-h", "--help", "output help information", & command_help);
  return;
}
}
void command_free(command_t *self ) 
{ 
  int i ;
  command_option_t *option ;

  {
  i = 0;
  while (i < self->option_count) {
    option = & self->options[i];
    free((void *)option->argname);
    free((void *)option->large);
    i ++;
  }
  if (self->nargv) {
    i = 0;
    while (*(self->nargv + i)) {
      free((void *)*(self->nargv + i));
      i ++;
    }
    free((void *)self->nargv);
  }
  return;
}
}
static void parse_argname(char const   *str , char *flag , char *arg ) 
{ 
  int buffer ;
  size_t flagpos ;
  size_t argpos ;
  size_t len ;
  size_t tmp ;
  size_t i ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  buffer = 0;
  flagpos = (size_t )0;
  argpos = (size_t )0;
  tmp = strlen(str);
  len = tmp;
  i = (size_t )0;
  while (i < len) {
    if (buffer) {
      buffer = 1;
      tmp___0 = argpos;
      argpos ++;
      *(arg + tmp___0) = (char )*(str + i);
    } else
    if (91 == (int )*(str + i)) {
      buffer = 1;
      tmp___0 = argpos;
      argpos ++;
      *(arg + tmp___0) = (char )*(str + i);
    } else
    if (60 == (int )*(str + i)) {
      buffer = 1;
      tmp___0 = argpos;
      argpos ++;
      *(arg + tmp___0) = (char )*(str + i);
    } else {
      if (32 == (int )*(str + i)) {
        goto __Cont;
      }
      tmp___1 = flagpos;
      flagpos ++;
      *(flag + tmp___1) = (char )*(str + i);
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  *(arg + argpos) = (char )'\000';
  *(flag + flagpos) = (char )'\000';
  return;
}
}
static char **normalize_args(int *argc , char **argv ) 
{ 
  int size ;
  int alloc ;
  char **nargv ;
  void *tmp ;
  int i ;
  char const   *arg ;
  size_t len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t j ;
  void *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;

  {
  size = 0;
  alloc = *argc + 1;
  tmp = malloc((unsigned long )alloc * sizeof(char *));
  nargv = (char **)tmp;
  i = 0;
  while (*(argv + i)) {
    arg = (char const   *)*(argv + i);
    tmp___0 = strlen(arg);
    len = tmp___0;
    if (len > 2UL) {
      if (45 == (int )*(arg + 0)) {
        tmp___3 = strchr(arg + 1, '-');
        if (! tmp___3) {
          alloc = (int )((size_t )alloc + (len - 2UL));
          tmp___1 = realloc((void *)nargv, (unsigned long )alloc * sizeof(char *));
          nargv = (char **)tmp___1;
          j = (size_t )1;
          while (j < len) {
            tmp___2 = malloc((size_t )3);
            *(nargv + size) = (char *)tmp___2;
            sprintf((char * __restrict  )*(nargv + size), (char const   * __restrict  )"-%c",
                    (int const   )*(arg + j));
            size ++;
            j ++;
          }
          goto __Cont;
        }
      }
    }
    tmp___4 = malloc(len + 1UL);
    *(nargv + size) = (char *)tmp___4;
    strcpy((char * __restrict  )*(nargv + size), (char const   * __restrict  )arg);
    size ++;
    __Cont: /* CIL Label */ 
    i ++;
  }
  *(nargv + size) = (char *)((void *)0);
  *argc = size;
  return (nargv);
}
}
void command_option(command_t *self , char const   *small , char const   *large ,
                    char const   *desc , void (*cb)(struct command *self ) ) 
{ 
  int n ;
  int tmp ;
  command_option_t *option ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
  if (self->option_count == 32) {
    command_free(self);
    error((char *)"Maximum option definitions exceeded");
  }
  tmp = self->option_count;
  (self->option_count) ++;
  n = tmp;
  option = & self->options[n];
  option->cb = cb;
  option->small = small;
  option->description = desc;
  tmp___0 = 0;
  option->optional_arg = tmp___0;
  option->required_arg = tmp___0;
  option->large_with_arg = large;
  tmp___1 = strlen(large);
  tmp___2 = malloc(tmp___1 + 1UL);
  option->argname = (char *)tmp___2;
  if (! option->argname) {
    __assert_fail("option->argname", "deps/commander/commander.c", 185U, "command_option");
  }
  tmp___4 = strlen(large);
  tmp___5 = malloc(tmp___4 + 1UL);
  option->large = (char *)tmp___5;
  if (! option->large) {
    __assert_fail("option->large", "deps/commander/commander.c", 187U, "command_option");
  }
  parse_argname(large, option->large, option->argname);
  if (91 == (int )*(option->argname + 0)) {
    option->optional_arg = 1;
  }
  if (60 == (int )*(option->argname + 0)) {
    option->required_arg = 1;
  }
  return;
}
}
static void command_parse_args(command_t *self , int argc , char **argv ) 
{ 
  int literal ;
  int i ;
  int j ;
  char const   *arg ;
  command_option_t *option ;
  int tmp ;
  int tmp___0 ;
  int n ;
  int tmp___1 ;

  {
  literal = 0;
  i = 1;
  while (i < argc) {
    arg = (char const   *)*(argv + i);
    j = 0;
    while (j < self->option_count) {
      option = & self->options[j];
      tmp = strcmp(arg, option->small);
      if (tmp) {
        tmp___0 = strcmp(arg, (char const   *)option->large);
        if (! tmp___0) {
          _L: /* CIL Label */ 
          self->arg = (char const   *)((void *)0);
          if (option->required_arg) {
            i ++;
            arg = (char const   *)*(argv + i);
            if (! arg) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s %s argument required\n",
                      option->large, option->argname);
              command_free(self);
              exit(1);
            } else
            if (45 == (int )*(arg + 0)) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s %s argument required\n",
                      option->large, option->argname);
              command_free(self);
              exit(1);
            }
            self->arg = arg;
          }
          if (option->optional_arg) {
            if (*(argv + (i + 1))) {
              if (45 != (int )*(*(argv + (i + 1)) + 0)) {
                i ++;
                self->arg = (char const   *)*(argv + i);
              }
            }
          }
          (*(option->cb))(self);
          goto match;
        }
      } else {
        goto _L;
      }
      j ++;
    }
    if (45 == (int )*(arg + 0)) {
      if (45 == (int )*(arg + 1)) {
        if (0 == (int )*(arg + 2)) {
          literal = 1;
          goto match;
        }
      }
    }
    if (45 == (int )*(arg + 0)) {
      if (! literal) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unrecognized flag %s\n",
                arg);
        command_free(self);
        exit(1);
      }
    }
    tmp___1 = self->argc;
    (self->argc) ++;
    n = tmp___1;
    if (n == 32) {
      command_free(self);
      error((char *)"Maximum number of arguments exceeded");
    }
    self->argv[n] = (char *)arg;
    match: 
    i ++;
  }
  return;
}
}
void command_parse(command_t *self , int argc , char **argv ) 
{ 


  {
  self->nargv = normalize_args(& argc, argv);
  command_parse_args(self, argc, self->nargv);
  self->argv[self->argc] = (char *)((void *)0);
  return;
}
}
#pragma merger("0","/tmp/cil-ng42_6Z0.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
static uint32_t const   __ac_prime_list[32]  = 
  {      (uint32_t const   )0UL,      (uint32_t const   )3UL,      (uint32_t const   )11UL,      (uint32_t const   )23UL, 
        (uint32_t const   )53UL,      (uint32_t const   )97UL,      (uint32_t const   )193UL,      (uint32_t const   )389UL, 
        (uint32_t const   )769UL,      (uint32_t const   )1543UL,      (uint32_t const   )3079UL,      (uint32_t const   )6151UL, 
        (uint32_t const   )12289UL,      (uint32_t const   )24593UL,      (uint32_t const   )49157UL,      (uint32_t const   )98317UL, 
        (uint32_t const   )196613UL,      (uint32_t const   )393241UL,      (uint32_t const   )786433UL,      (uint32_t const   )1572869UL, 
        (uint32_t const   )3145739UL,      (uint32_t const   )6291469UL,      (uint32_t const   )12582917UL,      (uint32_t const   )25165843UL, 
        (uint32_t const   )50331653UL,      (uint32_t const   )100663319UL,      (uint32_t const   )201326611UL,      (uint32_t const   )402653189UL, 
        (uint32_t const   )805306457UL,      (uint32_t const   )1610612741UL,      (uint32_t const   )3221225473UL,      (uint32_t const   )4294967291UL};
static double const   __ac_HASH_UPPER  =    (double const   )0.77;
__inline static khint_t __ac_X31_hash_string(char const   *s ) 
{ 
  khint_t h ;

  {
  h = (khint_t )*s;
  if (h) {
    s ++;
    while (*s) {
      h = ((h << 5) - h) + (khint_t )*s;
      s ++;
    }
  }
  return (h);
}
}
__inline static khint_t kh_get_ptr(kh_ptr_t *h , kh_cstr_t key ) 
{ 
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t last ;
  int tmp ;
  khint_t tmp___0 ;

  {
  if (h->n_buckets) {
    k = __ac_X31_hash_string(key);
    i = k % h->n_buckets;
    inc = 1U + k % (h->n_buckets - 1U);
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          tmp = strcmp(*(h->keys + i), key);
          if (tmp == 0) {
            break;
          }
        }
      } else {
        break;
      }
      if (i + inc >= h->n_buckets) {
        i = (i + inc) - h->n_buckets;
      } else {
        i += inc;
      }
      if (i == last) {
        return (h->n_buckets);
      }
    }
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) {
      tmp___0 = h->n_buckets;
    } else {
      tmp___0 = i;
    }
    return (tmp___0);
  } else {
    return ((khint_t )0);
  }
}
}
__inline static void kh_resize_ptr(kh_ptr_t *h , khint_t new_n_buckets ) 
{ 
  uint32_t *new_flags ;
  khint_t j ;
  khint_t t ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  kh_cstr_t key ;
  void *val ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  kh_cstr_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  new_flags = (uint32_t *)0;
  j = (khint_t )1;
  t = (khint_t )31;
  while (__ac_prime_list[t] > (uint32_t const   )new_n_buckets) {
    t --;
  }
  new_n_buckets = (khint_t )__ac_prime_list[t + 1U];
  if (h->size >= (khint_t )((double const   )new_n_buckets * __ac_HASH_UPPER + (double const   )0.5)) {
    j = (khint_t )0;
  } else {
    tmp = malloc((unsigned long )((new_n_buckets >> 4) + 1U) * sizeof(uint32_t ));
    new_flags = (uint32_t *)tmp;
    memset((void *)new_flags, 170, (unsigned long )((new_n_buckets >> 4) + 1U) * sizeof(uint32_t ));
    if (h->n_buckets < new_n_buckets) {
      tmp___0 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(kh_cstr_t ));
      h->keys = (kh_cstr_t *)tmp___0;
      tmp___1 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(void *));
      h->vals = (void **)tmp___1;
    }
  }
  if (j) {
    j = (khint_t )0;
    while (j != h->n_buckets) {
      if (((*(h->flags + (j >> 4)) >> ((j & 15U) << 1)) & 3U) == 0U) {
        key = *(h->keys + j);
        val = *(h->vals + j);
        *(h->flags + (j >> 4)) = (uint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1UL << ((j & 15U) << 1)));
        while (1) {
          k = __ac_X31_hash_string(key);
          i = k % new_n_buckets;
          inc = 1U + k % (new_n_buckets - 1U);
          while (! ((*(new_flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
            if (i + inc >= new_n_buckets) {
              i = (i + inc) - new_n_buckets;
            } else {
              i += inc;
            }
          }
          *(new_flags + (i >> 4)) = (uint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2UL << ((i & 15U) << 1)));
          if (i < h->n_buckets) {
            if (((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) == 0U) {
              tmp___2 = *(h->keys + i);
              *(h->keys + i) = key;
              key = tmp___2;
              tmp___3 = *(h->vals + i);
              *(h->vals + i) = val;
              val = tmp___3;
              *(h->flags + (i >> 4)) = (uint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1UL << ((i & 15U) << 1)));
            } else {
              *(h->keys + i) = key;
              *(h->vals + i) = val;
              break;
            }
          } else {
            *(h->keys + i) = key;
            *(h->vals + i) = val;
            break;
          }
        }
      }
      j ++;
    }
    if (h->n_buckets > new_n_buckets) {
      tmp___4 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(kh_cstr_t ));
      h->keys = (kh_cstr_t *)tmp___4;
      tmp___5 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(void *));
      h->vals = (void **)tmp___5;
    }
    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (khint_t )((double const   )h->n_buckets * __ac_HASH_UPPER + (double const   )0.5);
  }
  return;
}
}
__inline static khint_t kh_put_ptr(kh_ptr_t *h , kh_cstr_t key , int *ret ) 
{ 
  khint_t x ;
  khint_t inc ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  int tmp ;

  {
  if (h->n_occupied >= h->upper_bound) {
    if (h->n_buckets > h->size << 1) {
      kh_resize_ptr(h, h->n_buckets - 1U);
    } else {
      kh_resize_ptr(h, h->n_buckets + 1U);
    }
  }
  site = h->n_buckets;
  x = site;
  k = __ac_X31_hash_string(key);
  i = k % h->n_buckets;
  if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
    x = i;
  } else {
    inc = 1U + k % (h->n_buckets - 1U);
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          tmp = strcmp(*(h->keys + i), key);
          if (tmp == 0) {
            break;
          }
        }
      } else {
        break;
      }
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U) {
        site = i;
      }
      if (i + inc >= h->n_buckets) {
        i = (i + inc) - h->n_buckets;
      } else {
        i += inc;
      }
      if (i == last) {
        x = site;
        break;
      }
    }
    if (x == h->n_buckets) {
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
        if (site != h->n_buckets) {
          x = site;
        } else {
          x = i;
        }
      } else {
        x = i;
      }
    }
  }
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 2U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (uint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    (h->n_occupied) ++;
    *ret = 1;
  } else
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 1U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (uint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    *ret = 2;
  } else {
    *ret = 0;
  }
  return (x);
}
}
__inline static void kh_del_ptr(kh_ptr_t *h , khint_t x ) 
{ 


  {
  if (x != h->n_buckets) {
    if (! ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 3U)) {
      *(h->flags + (x >> 4)) = (uint32_t )((unsigned long )*(h->flags + (x >> 4)) | (1UL << ((x & 15U) << 1)));
      (h->size) --;
    }
  }
  return;
}
}
__inline void *hash_get(hash_t *self , char *key ) ;
void hash_del(hash_t *self , char *key ) ;
void hash_set(hash_t *self , char *key , void *val ) 
{ 
  int ret ;
  khiter_t k ;
  khint_t tmp ;

  {
  tmp = kh_put_ptr(self, (kh_cstr_t )key, & ret);
  k = tmp;
  *(self->vals + k) = val;
  return;
}
}
__inline void *hash_get(hash_t *self , char *key ) 
{ 
  khiter_t k ;
  khint_t tmp ;
  void *tmp___0 ;

  {
  tmp = kh_get_ptr(self, (kh_cstr_t )key);
  k = tmp;
  if (k == self->n_buckets) {
    tmp___0 = (void *)0;
  } else {
    tmp___0 = *(self->vals + k);
  }
  return (tmp___0);
}
}
int hash_has(hash_t *self , char *key ) 
{ 
  khiter_t k ;
  khint_t tmp ;

  {
  tmp = kh_get_ptr(self, (kh_cstr_t )key);
  k = tmp;
  return (! ((*(self->flags + (k >> 4)) >> ((k & 15U) << 1)) & 3U));
}
}
void hash_del(hash_t *self , char *key ) 
{ 
  khiter_t k ;
  khint_t tmp ;

  {
  tmp = kh_get_ptr(self, (kh_cstr_t )key);
  k = tmp;
  kh_del_ptr(self, k);
  return;
}
}
#pragma merger("0","/tmp/cil-Jdc8zTS0.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) rmdir)(char const   *__path ) ;
int rimraf(char const   *path ) 
{ 
  DIR *dir ;
  DIR *tmp ;
  struct dirent *dp ;
  int tmp___0 ;
  int tmp___1 ;
  char *f ;
  char *tmp___2 ;
  struct stat s ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  tmp = opendir(path);
  dir = tmp;
  if ((unsigned long )((void *)0) == (unsigned long )dir) {
    return (-1);
  }
  dp = (struct dirent *)((void *)0);
  while (1) {
    dp = readdir(dir);
    if (! ((unsigned long )((void *)0) != (unsigned long )dp)) {
      break;
    }
    tmp___0 = strcmp(".", (char const   *)(dp->d_name));
    if (0 == tmp___0) {
      continue;
    } else {
      tmp___1 = strcmp("..", (char const   *)(dp->d_name));
      if (0 == tmp___1) {
        continue;
      }
    }
    tmp___2 = path_join(path, (char const   *)(dp->d_name));
    f = tmp___2;
    if ((unsigned long )((void *)0) == (unsigned long )f) {
      return (-1);
    }
    tmp___3 = stat((char const   * __restrict  )f, (struct stat * __restrict  )(& s));
    if (0 != tmp___3) {
      return (-1);
    }
    if (s.st_mode & 16384U) {
      tmp___4 = rimraf((char const   *)f);
      if (-1 == tmp___4) {
        return (-1);
      }
    } else {
      tmp___5 = unlink((char const   *)f);
      if (-1 == tmp___5) {
        return (-1);
      }
    }
    free((void *)f);
  }
  free((void *)dp);
  closedir(dir);
  tmp___6 = rmdir(path);
  return (tmp___6);
}
}
#pragma merger("0","/tmp/cil-i0C7PA7A.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
char *trim(char *str ) ;
char *trim_right(char *str ) ;
char *trim_left(char *str ) ;
char *trim_left(char *str ) 
{ 
  int len ;
  size_t tmp ;
  char *cur ;
  unsigned short const   **tmp___0 ;

  {
  tmp = strlen((char const   *)str);
  len = (int )tmp;
  cur = str;
  while (1) {
    if (*cur) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___0 + (int )*cur) & 8192)) {
        break;
      }
    } else {
      break;
    }
    cur ++;
    len --;
  }
  if ((unsigned long )str != (unsigned long )cur) {
    memmove((void *)str, (void const   *)cur, (size_t )(len + 1));
  }
  return (str);
}
}
char *trim_right(char *str ) 
{ 
  int len ;
  size_t tmp ;
  char *cur ;
  unsigned short const   **tmp___0 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  tmp = strlen((char const   *)str);
  len = (int )tmp;
  cur = (str + len) - 1;
  while (1) {
    if ((unsigned long )cur != (unsigned long )str) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___0 + (int )*cur) & 8192)) {
        break;
      }
    } else {
      break;
    }
    cur --;
    len --;
  }
  tmp___3 = __ctype_b_loc();
  if ((int const   )*(*tmp___3 + (int )*cur) & 8192) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  *(cur + tmp___2) = (char )'\000';
  return (str);
}
}
char *trim(char *str ) 
{ 


  {
  trim_right(str);
  trim_left(str);
  return (str);
}
}
#pragma merger("0","/tmp/cil-prAsU_L2.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
_Bool str_starts_with(char const   *str , char const   *start ) 
{ 


  {
  while (1) {
    if (! *start) {
      return ((_Bool)1);
    } else
    if ((int const   )*str != (int const   )*start) {
      return ((_Bool)0);
    }
    str ++;
    start ++;
  }
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-QGPmYqqp.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int rand(void) ;
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
int vasprintf(char **str , char const   *fmt , va_list___0 args ) ;
int debug_is_enabled(char const   *name ) ;
static int seeded  =    0;
static int use_colors(FILE *stream ) 
{ 
  int tty ;
  int tmp ;
  int tmp___0 ;
  char *colors ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  tmp = fileno(stream);
  tmp___0 = isatty(tmp);
  tty = tmp___0;
  if (0 == tty) {
    return (0);
  }
  tmp___1 = getenv("DEBUG_COLORS");
  colors = tmp___1;
  if (! colors) {
    return (1);
  }
  tmp___2 = strcmp("0", (char const   *)colors);
  if (0 == tmp___2) {
    return (0);
  }
  tmp___3 = strncmp("no", (char const   *)colors, (size_t )2);
  if (0 == tmp___3) {
    return (0);
  }
  tmp___4 = strncmp("false", (char const   *)colors, (size_t )5);
  if (0 == tmp___4) {
    return (0);
  }
  tmp___5 = strncmp("disabled", (char const   *)colors, (size_t )8);
  if (0 == tmp___5) {
    return (0);
  }
  return (1);
}
}
int debug_is_enabled(char const   *name ) 
{ 
  char *env ;
  char *tmp ;
  char *debugger___1 ;
  int enabled ;
  int tmp___0 ;

  {
  env = (char *)((void *)0);
  tmp = (char *)((void *)0);
  debugger___1 = (char *)((void *)0);
  enabled = 0;
  env = getenv("DEBUG");
  if (! env) {
    return (0);
  }
  tmp = strdup((char const   *)env);
  if (! tmp) {
    return (0);
  }
  debugger___1 = strtok((char * __restrict  )tmp, (char const   * __restrict  )",");
  while (debugger___1) {
    tmp___0 = wildcardcmp((char const   *)debugger___1, name);
    if (1 == tmp___0) {
      enabled = 1;
      break;
    }
    debugger___1 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )",");
  }
  free((void *)tmp);
  return (enabled);
}
}
int debug_init(debug_t *debugger___1 , char const   *name ) 
{ 
  clock_t tmp ;
  int tmp___0 ;

  {
  if (0 == seeded) {
    tmp = clock();
    srand((unsigned int )tmp);
    seeded = 1;
  }
  tmp___0 = rand();
  debugger___1->color = 1 + tmp___0 % 6;
  debugger___1->enabled = debug_is_enabled(name);
  debugger___1->name = name;
  debugger___1->stream = stderr;
  return (0);
}
}
void debug(debug_t *debugger___1 , char const   *fmt  , ...) 
{ 
  char *pre ;
  char *post ;
  va_list___0 args ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (0 == debugger___1->enabled) {
    return;
  }
  pre = (char *)((void *)0);
  post = (char *)((void *)0);
  __builtin_va_start(args, fmt);
  tmp___0 = use_colors(debugger___1->stream);
  if (tmp___0) {
    tmp = asprintf(& pre, "\033[3%dm%s\033[0m", debugger___1->color, debugger___1->name);
    if (-1 == tmp) {
      __builtin_va_end(args);
      return;
    }
  } else {
    pre = strdup(debugger___1->name);
    if (! pre) {
      __builtin_va_end(args);
      return;
    }
  }
  tmp___1 = vasprintf(& post, fmt, args);
  if (-1 == tmp___1) {
    free((void *)pre);
    __builtin_va_end(args);
    return;
  }
  fprintf((FILE * __restrict  )debugger___1->stream, (char const   * __restrict  )" %s : %s\n",
          pre, post);
  free((void *)pre);
  free((void *)post);
  return;
}
}
#pragma merger("0","/tmp/cil-Nne59VDP.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
size_t occurrences(char const   *needle , char const   *haystack ) 
{ 
  char *pos ;
  size_t i ;
  size_t l ;
  size_t tmp ;

  {
  if ((unsigned long )((void *)0) == (unsigned long )needle) {
    return ((size_t )-1);
  } else
  if ((unsigned long )((void *)0) == (unsigned long )haystack) {
    return ((size_t )-1);
  }
  pos = (char *)haystack;
  i = (size_t )0;
  tmp = strlen(needle);
  l = tmp;
  while (1) {
    pos = strstr((char const   *)pos, needle);
    if (! pos) {
      break;
    }
    pos += l;
    i ++;
  }
  return (i);
}
}
#pragma merger("0","/tmp/cil-13Oyffgt.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
char *path_normalize(char const   *path ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
int mkdirp(char const   *path , mode_t mode ) 
{ 
  char *pathname ;
  char *parent ;
  char *p ;
  size_t tmp ;
  int tmp___0 ;
  int rc ;
  int tmp___1 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  pathname = (char *)((void *)0);
  parent = (char *)((void *)0);
  if ((unsigned long )((void *)0) == (unsigned long )path) {
    return (-1);
  }
  pathname = path_normalize(path);
  if ((unsigned long )((void *)0) == (unsigned long )pathname) {
    goto fail;
  }
  parent = strdup((char const   *)pathname);
  if ((unsigned long )((void *)0) == (unsigned long )parent) {
    goto fail;
  }
  tmp = strlen((char const   *)parent);
  p = parent + tmp;
  while (1) {
    if (47 != (int )*p) {
      if (! ((unsigned long )p != (unsigned long )parent)) {
        break;
      }
    } else {
      break;
    }
    p --;
  }
  *p = (char )'\000';
  if ((unsigned long )p != (unsigned long )parent) {
    tmp___0 = mkdirp((char const   *)parent, mode);
    if (0 != tmp___0) {
      goto fail;
    }
  }
  free((void *)parent);
  tmp___1 = mkdir((char const   *)pathname, mode);
  rc = tmp___1;
  free((void *)pathname);
  if (0 == rc) {
    tmp___3 = 0;
  } else {
    tmp___4 = __errno_location();
    if (17 == *tmp___4) {
      tmp___3 = 0;
    } else {
      tmp___3 = -1;
    }
  }
  return (tmp___3);
  fail: 
  free((void *)pathname);
  free((void *)parent);
  return (-1);
}
}
#pragma merger("0","/tmp/cil-vOacvzGk.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
struct GumboInternalOptions  const  kGumboDefaultOptions ;
GumboOutput *gumbo_parse(char const   *buffer ) ;
void gumbo_destroy_output(GumboOptions const   *options , GumboOutput *output ) ;
char *gumbo_text_content(GumboNode *node ) ;
GumboNode *gumbo_get_element_by_id(char const   *id , GumboNode *document ) ;
char *case_lower(char *str ) ;
list_t *wiki_registry(char const   *url ) ;
list_t *wiki_registry_parse(char const   *html ) ;
void wiki_package_free(wiki_package_t *pkg ) ;
static wiki_package_t *wiki_package_new(void) 
{ 
  wiki_package_t *pkg ;
  void *tmp ;

  {
  tmp = malloc(sizeof(wiki_package_t ));
  pkg = (wiki_package_t *)tmp;
  if (pkg) {
    pkg->repo = (char *)((void *)0);
    pkg->href = (char *)((void *)0);
    pkg->description = (char *)((void *)0);
    pkg->category = (char *)((void *)0);
  }
  return (pkg);
}
}
static void add_package_href(wiki_package_t *self ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)self->repo);
  len = tmp + 20UL;
  tmp___0 = malloc(len);
  self->href = (char *)tmp___0;
  if (self->href) {
    sprintf((char * __restrict  )self->href, (char const   * __restrict  )"https://github.com/%s",
            self->repo);
  }
  return;
}
}
static wiki_package_t *parse_li(GumboNode *li ) 
{ 
  wiki_package_t *self ;
  wiki_package_t *tmp ;
  char *text ;
  char *tok ;
  char *tmp___0 ;
  int pos ;

  {
  tmp = wiki_package_new();
  self = tmp;
  text = (char *)((void *)0);
  if (! self) {
    goto cleanup;
  }
  text = gumbo_text_content(li);
  if (! text) {
    goto cleanup;
  }
  tmp___0 = strstr((char const   *)text, " - ");
  tok = tmp___0;
  if (! tok) {
    goto cleanup;
  }
  pos = (int )(tok - text);
  self->repo = substr((char const   *)text, 0, pos);
  self->description = substr((char const   *)text, pos + 3, -1);
  if (! self->repo) {
    goto cleanup;
  } else
  if (! self->description) {
    goto cleanup;
  }
  trim(self->description);
  trim(self->repo);
  add_package_href(self);
  cleanup: 
  free((void *)text);
  return (self);
}
}
list_t *wiki_registry_parse(char const   *html ) 
{ 
  GumboOutput *output ;
  GumboOutput *tmp ;
  list_t *pkgs ;
  list_t *tmp___0 ;
  GumboNode *body ;
  GumboNode *tmp___1 ;
  list_t *h2s ;
  list_t *tmp___2 ;
  list_node_t *heading_node ;
  list_iterator_t *heading_iterator ;
  list_iterator_t *tmp___3 ;
  GumboNode *heading ;
  char *category ;
  char *tmp___4 ;
  char *tmp___5 ;
  GumboVector *siblings ;
  size_t pos ;
  GumboNode *ul ;
  list_t *lis ;
  list_t *tmp___6 ;
  list_iterator_t *li_iterator ;
  list_iterator_t *tmp___7 ;
  list_node_t *li_node ;
  wiki_package_t *package ;
  wiki_package_t *tmp___8 ;
  list_node_t *tmp___9 ;

  {
  tmp = gumbo_parse(html);
  output = tmp;
  tmp___0 = list_new();
  pkgs = tmp___0;
  tmp___1 = gumbo_get_element_by_id("wiki-body", output->root);
  body = tmp___1;
  if (body) {
    tmp___2 = gumbo_get_elements_by_tag_name("h2", body);
    h2s = tmp___2;
    tmp___3 = list_iterator_new(h2s, (list_direction_t )0);
    heading_iterator = tmp___3;
    while (1) {
      heading_node = list_iterator_next(heading_iterator);
      if (! heading_node) {
        break;
      }
      heading = (GumboNode *)heading_node->val;
      tmp___4 = gumbo_text_content(heading);
      category = tmp___4;
      if (! category) {
        break;
      }
      tmp___5 = case_lower(category);
      trim(tmp___5);
      siblings = & (heading->parent)->v.element.children;
      pos = heading->index_within_parent;
      ul = (GumboNode *)*(siblings->data + (pos + 2UL));
      if (30U != (unsigned int )ul->v.element.tag) {
        free((void *)category);
        continue;
      }
      tmp___6 = gumbo_get_elements_by_tag_name("li", ul);
      lis = tmp___6;
      tmp___7 = list_iterator_new(lis, (list_direction_t )0);
      li_iterator = tmp___7;
      while (1) {
        li_node = list_iterator_next(li_iterator);
        if (! li_node) {
          break;
        }
        tmp___8 = parse_li((GumboNode *)li_node->val);
        package = tmp___8;
        if (package) {
          if (package->description) {
            package->category = strdup((char const   *)category);
            tmp___9 = list_node_new((void *)package);
            list_rpush(pkgs, tmp___9);
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (package) {
          wiki_package_free(package);
        }
      }
      list_iterator_destroy(li_iterator);
      list_destroy(lis);
      free((void *)category);
    }
    list_iterator_destroy(heading_iterator);
    list_destroy(h2s);
  }
  gumbo_destroy_output(& kGumboDefaultOptions, output);
  return (pkgs);
}
}
list_t *wiki_registry(char const   *url ) 
{ 
  http_get_response_t *res ;
  http_get_response_t *tmp ;
  list_t *list ;
  list_t *tmp___0 ;

  {
  tmp = http_get(url);
  res = tmp;
  if (! res->ok) {
    return ((list_t *)((void *)0));
  }
  tmp___0 = wiki_registry_parse((char const   *)res->data);
  list = tmp___0;
  http_get_free(res);
  return (list);
}
}
void wiki_package_free(wiki_package_t *pkg ) 
{ 


  {
  free((void *)pkg->repo);
  free((void *)pkg->href);
  free((void *)pkg->description);
  free((void *)pkg->category);
  free((void *)pkg);
  return;
}
}
#pragma merger("0","/tmp/cil-y23r6nPU.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
char *which(char const   *name ) ;
char *which_path(char const   *name , char const   *_path ) ;
char *which(char const   *name ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  tmp = getenv("PATH");
  tmp___0 = which_path(name, (char const   *)tmp);
  return (tmp___0);
}
}
char *which_path(char const   *name , char const   *_path ) 
{ 
  char *path ;
  char *tmp ;
  char *tok ;
  char *tmp___0 ;
  int len ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *file ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  tmp = strdup(_path);
  path = tmp;
  if ((unsigned long )((void *)0) == (unsigned long )path) {
    return ((char *)((void *)0));
  }
  tmp___0 = strtok((char * __restrict  )path, (char const   * __restrict  )":");
  tok = tmp___0;
  while (tok) {
    tmp___1 = strlen((char const   *)tok);
    tmp___2 = strlen(name);
    len = (int )((tmp___1 + 2UL) + tmp___2);
    tmp___3 = malloc((size_t )len);
    file = (char *)tmp___3;
    if (! file) {
      free((void *)path);
      return ((char *)((void *)0));
    }
    sprintf((char * __restrict  )file, (char const   * __restrict  )"%s/%s", tok,
            name);
    tmp___4 = access((char const   *)file, 1);
    if (0 == tmp___4) {
      free((void *)path);
      return (file);
    }
    tok = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )":");
    free((void *)file);
  }
  free((void *)path);
  return ((char *)((void *)0));
}
}
#pragma merger("0","/tmp/cil-zhV2uuJc.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
char *path_normalize(char const   *path ) 
{ 
  char *copy___0 ;
  char *tmp ;
  char *ptr ;
  int i ;
  char *tmp___0 ;

  {
  if (! path) {
    return ((char *)((void *)0));
  }
  tmp = strdup(path);
  copy___0 = tmp;
  if ((unsigned long )((void *)0) == (unsigned long )copy___0) {
    return ((char *)((void *)0));
  }
  ptr = copy___0;
  i = 0;
  while (*(copy___0 + i)) {
    tmp___0 = ptr;
    ptr ++;
    *tmp___0 = (char )*(path + i);
    if (47 == (int )*(path + i)) {
      i ++;
      while (47 == (int )*(path + i)) {
        i ++;
      }
      i --;
    }
    i ++;
  }
  *ptr = (char )'\000';
  return (copy___0);
}
}
#pragma merger("0","/tmp/cil-HoH1ReQi.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chown)(char const   *__file ,
                                                                                  __uid_t __owner ,
                                                                                  __gid_t __group ) ;
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) lchown)(char const   *__file ,
                                                                                   __uid_t __owner ,
                                                                                   __gid_t __group ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) truncate)(char const   *__file ,
                                                                                     __off_t __length ) ;
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
void fs_error(char const   *prefix ) ;
FILE *fs_open(char const   *path , char const   *flags ) ;
int fs_close(FILE *file ) ;
int fs_rename(char const   *from , char const   *to ) ;
fs_stats *fs_fstat(FILE *file ) ;
fs_stats *fs_lstat(char const   *path ) ;
int fs_ftruncate(FILE *file , int len ) ;
int fs_truncate(char const   *path , int len ) ;
int fs_chown(char const   *path , int uid , int gid ) ;
int fs_fchown(FILE *file , int uid , int gid ) ;
size_t fs_size(char const   *path ) ;
size_t fs_fsize(FILE *file ) ;
int fs_lchown(char const   *path , int uid , int gid ) ;
char *fs_nread(char const   *path , int len ) ;
char *fs_fread(FILE *file ) ;
char *fs_fnread(FILE *file , int len ) ;
int fs_nwrite(char const   *path , char const   *buffer , int len ) ;
int fs_fwrite(FILE *file , char const   *buffer ) ;
int fs_fnwrite(FILE *file , char const   *buffer , int len ) ;
int fs_rmdir(char const   *path ) ;
void fs_error(char const   *prefix ) 
{ 
  char fmt[256] ;

  {
  sprintf((char * __restrict  )(fmt), (char const   * __restrict  )"fs: %s: error",
          prefix);
  perror((char const   *)(fmt));
  return;
}
}
FILE *fs_open(char const   *path , char const   *flags ) 
{ 
  FILE *tmp ;

  {
  tmp = fopen((char const   * __restrict  )path, (char const   * __restrict  )flags);
  return (tmp);
}
}
int fs_close(FILE *file ) 
{ 
  int tmp ;

  {
  tmp = fclose(file);
  return (tmp);
}
}
int fs_rename(char const   *from , char const   *to ) 
{ 
  int tmp ;

  {
  tmp = rename(from, to);
  return (tmp);
}
}
fs_stats *fs_stat(char const   *path ) 
{ 
  fs_stats *stats ;
  void *tmp ;
  int e ;
  int tmp___0 ;

  {
  tmp = malloc(sizeof(fs_stats ));
  stats = (fs_stats *)tmp;
  tmp___0 = stat((char const   * __restrict  )path, (struct stat * __restrict  )stats);
  e = tmp___0;
  if (-1 == e) {
    free((void *)stats);
    return ((fs_stats *)((void *)0));
  }
  return (stats);
}
}
fs_stats *fs_fstat(FILE *file ) 
{ 
  fs_stats *stats ;
  void *tmp ;
  int fd ;
  int tmp___0 ;
  int e ;
  int tmp___1 ;

  {
  if ((unsigned long )((void *)0) == (unsigned long )file) {
    return ((fs_stats *)((void *)0));
  }
  tmp = malloc(sizeof(fs_stats ));
  stats = (fs_stats *)tmp;
  tmp___0 = fileno(file);
  fd = tmp___0;
  tmp___1 = fstat(fd, stats);
  e = tmp___1;
  if (-1 == e) {
    free((void *)stats);
    return ((fs_stats *)((void *)0));
  }
  return (stats);
}
}
fs_stats *fs_lstat(char const   *path ) 
{ 
  fs_stats *stats ;
  void *tmp ;
  int e ;
  int tmp___0 ;

  {
  tmp = malloc(sizeof(fs_stats ));
  stats = (fs_stats *)tmp;
  tmp___0 = lstat((char const   * __restrict  )path, (struct stat * __restrict  )stats);
  e = tmp___0;
  if (-1 == e) {
    free((void *)stats);
    return ((fs_stats *)((void *)0));
  }
  return (stats);
}
}
int fs_ftruncate(FILE *file , int len ) 
{ 
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = fileno(file);
  fd = tmp;
  tmp___0 = ftruncate(fd, (off_t )len);
  return (tmp___0);
}
}
int fs_truncate(char const   *path , int len ) 
{ 
  int tmp ;

  {
  tmp = truncate(path, (off_t )len);
  return (tmp);
}
}
int fs_chown(char const   *path , int uid , int gid ) 
{ 
  int tmp ;

  {
  tmp = chown(path, (uid_t )uid, (gid_t )gid);
  return (tmp);
}
}
int fs_fchown(FILE *file , int uid , int gid ) 
{ 
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = fileno(file);
  fd = tmp;
  tmp___0 = fchown(fd, (uid_t )uid, (gid_t )gid);
  return (tmp___0);
}
}
int fs_lchown(char const   *path , int uid , int gid ) 
{ 
  int tmp ;

  {
  tmp = lchown(path, (uid_t )uid, (gid_t )gid);
  return (tmp);
}
}
size_t fs_size(char const   *path ) 
{ 
  size_t size ;
  FILE *file ;
  FILE *tmp ;
  long tmp___0 ;

  {
  tmp = fs_open(path, "r");
  file = tmp;
  if ((unsigned long )((void *)0) == (unsigned long )file) {
    return ((size_t )-1);
  }
  fseek(file, 0L, 2);
  tmp___0 = ftell(file);
  size = (size_t )tmp___0;
  fs_close(file);
  return (size);
}
}
size_t fs_fsize(FILE *file ) 
{ 
  unsigned long pos ;
  long tmp ;
  size_t size ;
  long tmp___0 ;

  {
  tmp = ftell(file);
  pos = (unsigned long )tmp;
  rewind(file);
  fseek(file, 0L, 2);
  tmp___0 = ftell(file);
  size = (size_t )tmp___0;
  fseek(file, (long )pos, 0);
  return (size);
}
}
char *fs_read(char const   *path ) 
{ 
  FILE *file ;
  FILE *tmp ;
  char *data ;
  char *tmp___0 ;

  {
  tmp = fs_open(path, "r");
  file = tmp;
  if ((unsigned long )((void *)0) == (unsigned long )file) {
    return ((char *)((void *)0));
  }
  tmp___0 = fs_fread(file);
  data = tmp___0;
  fclose(file);
  return (data);
}
}
char *fs_nread(char const   *path , int len ) 
{ 
  FILE *file ;
  FILE *tmp ;
  char *buffer ;
  char *tmp___0 ;

  {
  tmp = fs_open(path, "r");
  file = tmp;
  if ((unsigned long )((void *)0) == (unsigned long )file) {
    return ((char *)((void *)0));
  }
  tmp___0 = fs_fnread(file, len);
  buffer = tmp___0;
  fs_close(file);
  return (buffer);
}
}
char *fs_fread(FILE *file ) 
{ 
  size_t fsize ;
  size_t tmp ;
  char *tmp___0 ;

  {
  tmp = fs_fsize(file);
  fsize = tmp;
  tmp___0 = fs_fnread(file, (int )fsize);
  return (tmp___0);
}
}
char *fs_fnread(FILE *file , int len ) 
{ 
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t tmp___0 ;

  {
  tmp = malloc(sizeof(char ) * (unsigned long )(len + 1));
  buffer = (char *)tmp;
  tmp___0 = fread((void * __restrict  )buffer, (size_t )1, (size_t )len, (FILE * __restrict  )file);
  n = tmp___0;
  *(buffer + n) = (char )'\000';
  return (buffer);
}
}
int fs_write(char const   *path , char const   *buffer ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen(buffer);
  tmp___0 = fs_nwrite(path, buffer, (int )tmp);
  return (tmp___0);
}
}
int fs_nwrite(char const   *path , char const   *buffer , int len ) 
{ 
  FILE *file ;
  FILE *tmp ;
  int result ;
  int tmp___0 ;

  {
  tmp = fs_open(path, "w");
  file = tmp;
  if ((unsigned long )((void *)0) == (unsigned long )file) {
    return (-1);
  }
  tmp___0 = fs_fnwrite(file, buffer, len);
  result = tmp___0;
  fclose(file);
  return (result);
}
}
int fs_fwrite(FILE *file , char const   *buffer ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen(buffer);
  tmp___0 = fs_fnwrite(file, buffer, (int )tmp);
  return (tmp___0);
}
}
int fs_fnwrite(FILE *file , char const   *buffer , int len ) 
{ 
  size_t tmp ;

  {
  tmp = fwrite((void const   * __restrict  )buffer, (size_t )1, (size_t )len, (FILE * __restrict  )file);
  return ((int )tmp);
}
}
int fs_mkdir(char const   *path , int mode ) 
{ 
  int tmp ;

  {
  tmp = mkdir(path, (mode_t )mode);
  return (tmp);
}
}
int fs_rmdir(char const   *path ) 
{ 
  int tmp ;

  {
  tmp = rmdir(path);
  return (tmp);
}
}
int fs_exists(char const   *path ) 
{ 
  struct stat b ;
  int tmp ;

  {
  tmp = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& b));
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-Vhlt31KR.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
char *parse_repo_owner(char const   *slug , char const   *fallback ) 
{ 
  char *copy___0 ;
  char *owner ;
  size_t tmp ;
  int delta ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
  copy___0 = (char *)((void *)0);
  owner = (char *)((void *)0);
  if ((unsigned long )((void *)0) == (unsigned long )slug) {
    return ((char *)((void *)0));
  }
  tmp = strlen(slug);
  if (0UL == tmp) {
    return ((char *)((void *)0));
  }
  copy___0 = strdup(slug);
  if (! copy___0) {
    return ((char *)((void *)0));
  }
  owner = strchr((char const   *)copy___0, '/');
  if (owner) {
    delta = (int )(owner - copy___0);
    if (! delta) {
      free((void *)copy___0);
      return ((char *)((void *)0));
    }
    tmp___1 = substr((char const   *)copy___0, 0, delta);
    tmp___0 = tmp___1;
    free((void *)copy___0);
    return (tmp___0);
  }
  if (fallback) {
    tmp___2 = strlen((char const   *)copy___0);
    if (0UL < tmp___2) {
      if (64 != (int )*(copy___0 + 0)) {
        owner = strdup(fallback);
      }
    }
  }
  free((void *)copy___0);
  return (owner);
}
}
char *parse_repo_name(char const   *slug ) 
{ 
  char *owner ;
  char *copy___0 ;
  char *name ;
  char *version ;
  size_t tmp ;
  int delta ;
  char *tmp___0 ;
  char *tmp___1 ;
  int delta___0 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  owner = (char *)((void *)0);
  copy___0 = (char *)((void *)0);
  name = (char *)((void *)0);
  version = (char *)((void *)0);
  if ((unsigned long )((void *)0) == (unsigned long )slug) {
    return ((char *)((void *)0));
  }
  tmp = strlen(slug);
  if (0UL == tmp) {
    return ((char *)((void *)0));
  }
  copy___0 = strdup(slug);
  if (! copy___0) {
    return ((char *)((void *)0));
  }
  version = strchr((char const   *)copy___0, '@');
  if (version) {
    delta = (int )(version - copy___0);
    tmp___1 = substr((char const   *)copy___0, 0, delta);
    tmp___0 = tmp___1;
    free((void *)copy___0);
    if (! tmp___0) {
      return ((char *)((void *)0));
    }
    copy___0 = tmp___0;
  }
  owner = strchr((char const   *)copy___0, '/');
  if (owner) {
    delta___0 = (int )(owner - copy___0);
    if (! delta___0) {
      free((void *)copy___0);
      return ((char *)((void *)0));
    }
    tmp___3 = substr((char const   *)copy___0, delta___0 + 1, -1);
    tmp___2 = tmp___3;
    free((void *)copy___0);
    copy___0 = tmp___2;
  }
  if (copy___0) {
    name = strdup((char const   *)copy___0);
  }
  free((void *)copy___0);
  return (name);
}
}
char *parse_repo_version(char const   *slug , char const   *fallback ) 
{ 
  size_t tmp ;
  char *name ;
  char *tmp___0 ;
  char *version ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  if ((unsigned long )((void *)0) == (unsigned long )slug) {
    return ((char *)((void *)0));
  }
  tmp = strlen(slug);
  if (0UL == tmp) {
    return ((char *)((void *)0));
  }
  tmp___0 = parse_repo_name(slug);
  name = tmp___0;
  if ((unsigned long )((void *)0) == (unsigned long )name) {
    return ((char *)((void *)0));
  }
  free((void *)name);
  tmp___1 = strchr(slug, '@');
  version = tmp___1;
  if (version) {
    version ++;
    tmp___2 = strlen((char const   *)version);
    if (0UL == tmp___2) {
      return ((char *)((void *)0));
    }
    if (42 == (int )*(version + 0)) {
      tmp___3 = strdup("master");
      return (tmp___3);
    }
    tmp___4 = strdup((char const   *)version);
    return (tmp___4);
  }
  version = (char *)((void *)0);
  if (fallback) {
    version = strdup(fallback);
  }
  return (version);
}
}
#pragma merger("0","/tmp/cil-ijTPa6ro.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
struct __anonstruct_GumboVector_216886465  const  kGumboEmptyVector ;
int gumbo_vector_index_of(GumboVector *vector , void *element ) ;
void gumbo_vector_init(struct GumboInternalParser *parser , size_t initial_capacity ,
                       GumboVector *vector ) ;
void gumbo_vector_destroy(struct GumboInternalParser *parser , GumboVector *vector ) ;
void gumbo_vector_add(struct GumboInternalParser *parser , void *element , GumboVector *vector ) ;
void *gumbo_vector_pop(struct GumboInternalParser *parser , GumboVector *vector ) ;
void gumbo_vector_insert_at(struct GumboInternalParser *parser , void *element , int index___0 ,
                            GumboVector *vector ) ;
void gumbo_vector_remove(struct GumboInternalParser *parser , void *node , GumboVector *vector ) ;
void *gumbo_vector_remove_at(struct GumboInternalParser *parser , int index___0 ,
                             GumboVector *vector ) ;
void *gumbo_parser_allocate(struct GumboInternalParser *parser , size_t num_bytes ) ;
void gumbo_parser_deallocate(struct GumboInternalParser *parser , void *ptr ) ;
struct __anonstruct_GumboVector_216886465  const  kGumboEmptyVector  =    {(void **)((void *)0), 0U, 0U};
void gumbo_vector_init(struct GumboInternalParser *parser , size_t initial_capacity ,
                       GumboVector *vector ) 
{ 
  void *tmp ;

  {
  vector->length = 0U;
  vector->capacity = (unsigned int )initial_capacity;
  if (initial_capacity > 0UL) {
    tmp = gumbo_parser_allocate(parser, sizeof(void *) * initial_capacity);
    vector->data = (void **)tmp;
  } else {
    vector->data = (void **)((void *)0);
  }
  return;
}
}
void gumbo_vector_destroy(struct GumboInternalParser *parser , GumboVector *vector ) 
{ 


  {
  if (vector->capacity > 0U) {
    gumbo_parser_deallocate(parser, (void *)vector->data);
  }
  return;
}
}
static void enlarge_vector_if_full(struct GumboInternalParser *parser , GumboVector *vector ) 
{ 
  size_t old_num_bytes ;
  size_t num_bytes ;
  void **temp ;
  void *tmp ;
  void *tmp___0 ;

  {
  if (vector->length >= vector->capacity) {
    if (vector->capacity) {
      old_num_bytes = sizeof(void *) * (unsigned long )vector->capacity;
      vector->capacity *= 2U;
      num_bytes = sizeof(void *) * (unsigned long )vector->capacity;
      tmp = gumbo_parser_allocate(parser, num_bytes);
      temp = (void **)tmp;
      memcpy((void * __restrict  )temp, (void const   * __restrict  )vector->data,
             old_num_bytes);
      gumbo_parser_deallocate(parser, (void *)vector->data);
      vector->data = temp;
    } else {
      vector->capacity = 2U;
      tmp___0 = gumbo_parser_allocate(parser, sizeof(void *) * (unsigned long )vector->capacity);
      vector->data = (void **)tmp___0;
    }
  }
  return;
}
}
void gumbo_vector_add(struct GumboInternalParser *parser , void *element , GumboVector *vector ) 
{ 
  unsigned int tmp___1 ;

  {
  enlarge_vector_if_full(parser, vector);
  if (! vector->data) {
    __assert_fail("vector->data", "deps/gumbo-parser/vector.c", 71U, "gumbo_vector_add");
  }
  if (! (vector->length < vector->capacity)) {
    __assert_fail("vector->length < vector->capacity", "deps/gumbo-parser/vector.c",
                  72U, "gumbo_vector_add");
  }
  tmp___1 = vector->length;
  (vector->length) ++;
  *(vector->data + tmp___1) = element;
  return;
}
}
void *gumbo_vector_pop(struct GumboInternalParser *parser , GumboVector *vector ) 
{ 


  {
  if (vector->length == 0U) {
    return ((void *)0);
  }
  (vector->length) --;
  return (*(vector->data + vector->length));
}
}
int gumbo_vector_index_of(GumboVector *vector , void *element ) 
{ 
  int i ;

  {
  i = 0;
  while ((unsigned int )i < vector->length) {
    if ((unsigned long )*(vector->data + i) == (unsigned long )element) {
      return (i);
    }
    i ++;
  }
  return (-1);
}
}
void gumbo_vector_insert_at(struct GumboInternalParser *parser , void *element , int index___0 ,
                            GumboVector *vector ) 
{ 


  {
  if (! (index___0 >= 0)) {
    __assert_fail("index >= 0", "deps/gumbo-parser/vector.c", 96U, "gumbo_vector_insert_at");
  }
  if (! ((unsigned int )index___0 <= vector->length)) {
    __assert_fail("index <= vector->length", "deps/gumbo-parser/vector.c", 97U, "gumbo_vector_insert_at");
  }
  enlarge_vector_if_full(parser, vector);
  (vector->length) ++;
  memmove((void *)(vector->data + (index___0 + 1)), (void const   *)(vector->data + index___0),
          sizeof(void *) * (unsigned long )((vector->length - (unsigned int )index___0) - 1U));
  *(vector->data + index___0) = element;
  return;
}
}
void gumbo_vector_remove(struct GumboInternalParser *parser , void *node , GumboVector *vector ) 
{ 
  int index___0 ;
  int tmp ;

  {
  tmp = gumbo_vector_index_of(vector, node);
  index___0 = tmp;
  if (index___0 == -1) {
    return;
  }
  gumbo_vector_remove_at(parser, index___0, vector);
  return;
}
}
void *gumbo_vector_remove_at(struct GumboInternalParser *parser , int index___0 ,
                             GumboVector *vector ) 
{ 
  void *result ;

  {
  if (! (index___0 >= 0)) {
    __assert_fail("index >= 0", "deps/gumbo-parser/vector.c", 116U, "gumbo_vector_remove_at");
  }
  if (! ((unsigned int )index___0 < vector->length)) {
    __assert_fail("index < vector->length", "deps/gumbo-parser/vector.c", 117U, "gumbo_vector_remove_at");
  }
  result = *(vector->data + index___0);
  memmove((void *)(vector->data + index___0), (void const   *)(vector->data + (index___0 + 1)),
          sizeof(void *) * (unsigned long )((vector->length - (unsigned int )index___0) - 1U));
  (vector->length) --;
  return (result);
}
}
#pragma merger("0","/tmp/cil-xxTq0VTb.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
GumboAttribute *gumbo_get_attribute(GumboVector const   *attributes , char const   *name ) ;
void gumbo_destroy_attribute(struct GumboInternalParser *parser , GumboAttribute *attribute ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
GumboAttribute *gumbo_get_attribute(GumboVector const   *attributes , char const   *name ) 
{ 
  int i ;
  GumboAttribute *attr ;
  int tmp ;

  {
  i = 0;
  while ((unsigned int const   )i < attributes->length) {
    attr = (GumboAttribute *)*(attributes->data + i);
    tmp = strcasecmp(attr->name, name);
    if (! tmp) {
      return (attr);
    }
    i ++;
  }
  return ((GumboAttribute *)((void *)0));
}
}
void gumbo_destroy_attribute(struct GumboInternalParser *parser , GumboAttribute *attribute ) 
{ 


  {
  gumbo_parser_deallocate(parser, (void *)attribute->name);
  gumbo_parser_deallocate(parser, (void *)attribute->value);
  gumbo_parser_deallocate(parser, (void *)attribute);
  return;
}
}
#pragma merger("0","/tmp/cil-lY76dpVQ.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
char const   *gumbo_normalized_tagname(GumboTag tag ) ;
void gumbo_tag_from_original_text(GumboStringPiece *text ) ;
char const   *kGumboTagNames[151]  = 
  {      "html",      "head",      "title",      "base", 
        "link",      "meta",      "style",      "script", 
        "noscript",      "template",      "body",      "article", 
        "section",      "nav",      "aside",      "h1", 
        "h2",      "h3",      "h4",      "h5", 
        "h6",      "hgroup",      "header",      "footer", 
        "address",      "p",      "hr",      "pre", 
        "blockquote",      "ol",      "ul",      "li", 
        "dl",      "dt",      "dd",      "figure", 
        "figcaption",      "main",      "div",      "a", 
        "em",      "strong",      "small",      "s", 
        "cite",      "q",      "dfn",      "abbr", 
        "data",      "time",      "code",      "var", 
        "samp",      "kbd",      "sub",      "sup", 
        "i",      "b",      "u",      "mark", 
        "ruby",      "rt",      "rp",      "bdi", 
        "bdo",      "span",      "br",      "wbr", 
        "ins",      "del",      "image",      "img", 
        "iframe",      "embed",      "object",      "param", 
        "video",      "audio",      "source",      "track", 
        "canvas",      "map",      "area",      "math", 
        "mi",      "mo",      "mn",      "ms", 
        "mtext",      "mglyph",      "malignmark",      "annotation-xml", 
        "svg",      "foreignobject",      "desc",      "table", 
        "caption",      "colgroup",      "col",      "tbody", 
        "thead",      "tfoot",      "tr",      "td", 
        "th",      "form",      "fieldset",      "legend", 
        "label",      "input",      "button",      "select", 
        "datalist",      "optgroup",      "option",      "textarea", 
        "keygen",      "output",      "progress",      "meter", 
        "details",      "summary",      "menu",      "menuitem", 
        "applet",      "acronym",      "bgsound",      "dir", 
        "frame",      "frameset",      "noframes",      "isindex", 
        "listing",      "xmp",      "nextid",      "noembed", 
        "plaintext",      "rb",      "strike",      "basefont", 
        "big",      "blink",      "center",      "font", 
        "marquee",      "multicol",      "nobr",      "spacer", 
        "tt",      "",      ""};
char const   *gumbo_normalized_tagname(GumboTag tag ) 
{ 


  {
  if (! ((unsigned int )tag <= 150U)) {
    __assert_fail("tag <= GUMBO_TAG_LAST", "deps/gumbo-parser/tag.c", 182U, "gumbo_normalized_tagname");
  }
  return (kGumboTagNames[tag]);
}
}
void gumbo_tag_from_original_text(GumboStringPiece *text ) 
{ 
  char const   *c ;
  unsigned short const   **tmp___3 ;

  {
  if ((unsigned long )text->data == (unsigned long )((void *)0)) {
    return;
  }
  if (! (text->length >= 2UL)) {
    __assert_fail("text->length >= 2", "deps/gumbo-parser/tag.c", 192U, "gumbo_tag_from_original_text");
  }
  if (! ((int const   )*(text->data + 0) == 60)) {
    __assert_fail("text->data[0] == \'<\'", "deps/gumbo-parser/tag.c", 193U, "gumbo_tag_from_original_text");
  }
  if (! ((int const   )*(text->data + (text->length - 1UL)) == 62)) {
    __assert_fail("text->data[text->length - 1] == \'>\'", "deps/gumbo-parser/tag.c",
                  194U, "gumbo_tag_from_original_text");
  }
  if ((int const   )*(text->data + 1) == 47) {
    if (! (text->length >= 3UL)) {
      __assert_fail("text->length >= 3", "deps/gumbo-parser/tag.c", 197U, "gumbo_tag_from_original_text");
    }
    text->data += 2;
    text->length -= 3UL;
  } else {
    (text->data) ++;
    text->length -= 2UL;
    c = text->data;
    while ((unsigned long )c != (unsigned long )(text->data + text->length)) {
      tmp___3 = __ctype_b_loc();
      if ((int const   )*(*tmp___3 + (int )*c) & 8192) {
        text->length = (size_t )(c - text->data);
        break;
      } else
      if ((int const   )*c == 47) {
        text->length = (size_t )(c - text->data);
        break;
      }
      c ++;
    }
  }
  return;
}
}
GumboTag gumbo_tag_enum(char const   *tagname ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < 150) {
    tmp = strcasecmp(tagname, kGumboTagNames[i]);
    if (tmp == 0) {
      return ((GumboTag )i);
    }
    i ++;
  }
  return ((GumboTag )149);
}
}
#pragma merger("0","/tmp/cil-pe6QBhVh.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
char *gumbo_copy_stringz(struct GumboInternalParser *parser , char const   *str ) ;
void gumbo_debug(char const   *format  , ...) ;
struct __anonstruct_GumboSourcePosition_891927932  const  kGumboEmptySourcePosition ;
struct __anonstruct_GumboSourcePosition_891927932  const  kGumboEmptySourcePosition  =    {0U,
    0U, 0U};
void *gumbo_parser_allocate(struct GumboInternalParser *parser , size_t num_bytes ) 
{ 
  void *tmp ;

  {
  tmp = (*((parser->_options)->allocator))((void *)(parser->_options)->userdata, num_bytes);
  return (tmp);
}
}
void gumbo_parser_deallocate(struct GumboInternalParser *parser , void *ptr ) 
{ 


  {
  (*((parser->_options)->deallocator))((void *)(parser->_options)->userdata, ptr);
  return;
}
}
char *gumbo_copy_stringz(struct GumboInternalParser *parser , char const   *str ) 
{ 
  char *buffer ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen(str);
  tmp___0 = gumbo_parser_allocate(parser, tmp + 1UL);
  buffer = (char *)tmp___0;
  strcpy((char * __restrict  )buffer, (char const   * __restrict  )str);
  return (buffer);
}
}
void gumbo_debug(char const   *format  , ...) 
{ 


  {
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#pragma merger("0","/tmp/cil-jhuEFhzr.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
struct __anonstruct_GumboStringPiece_673951369  const  kGumboEmptyString ;
_Bool gumbo_string_equals_ignore_case(GumboStringPiece const   *str1 , GumboStringPiece const   *str2 ) ;
char const   *gumbo_normalize_svg_tagname(GumboStringPiece const   *tag ) ;
GumboOutput *gumbo_parse_with_options(GumboOptions const   *options , char const   *buffer ,
                                      size_t length ) ;
void gumbo_string_buffer_init(struct GumboInternalParser *parser , GumboStringBuffer *output ) ;
void gumbo_string_buffer_append_codepoint(struct GumboInternalParser *parser , int c ,
                                          GumboStringBuffer *output ) ;
void gumbo_string_buffer_append_string(struct GumboInternalParser *parser , GumboStringPiece *str ,
                                       GumboStringBuffer *output ) ;
char *gumbo_string_buffer_to_string(struct GumboInternalParser *parser , GumboStringBuffer *input ) ;
void gumbo_string_buffer_destroy(struct GumboInternalParser *parser , GumboStringBuffer *buffer ) ;
GumboError *gumbo_add_error(struct GumboInternalParser *parser ) ;
void gumbo_init_errors(struct GumboInternalParser *parser ) ;
void gumbo_error_destroy(struct GumboInternalParser *parser , GumboError *error___0 ) ;
void gumbo_tokenizer_state_init(struct GumboInternalParser *parser , char const   *text ,
                                size_t text_length ) ;
void gumbo_tokenizer_state_destroy(struct GumboInternalParser *parser ) ;
void gumbo_tokenizer_set_state(struct GumboInternalParser *parser , GumboTokenizerEnum state ) ;
void gumbo_tokenizer_set_is_current_node_foreign(struct GumboInternalParser *parser ,
                                                 _Bool is_foreign ) ;
_Bool gumbo_lex(struct GumboInternalParser *parser , GumboToken *output ) ;
void gumbo_token_destroy(struct GumboInternalParser *parser , GumboToken *token ) ;
int const   kUtf8ReplacementChar ;
static void *malloc_wrapper(void *unused , size_t size ) 
{ 
  void *tmp ;

  {
  tmp = malloc(size);
  return (tmp);
}
}
static void free_wrapper(void *unused , void *ptr ) 
{ 


  {
  free(ptr);
  return;
}
}
struct GumboInternalOptions  const  kGumboDefaultOptions  =    {& malloc_wrapper, & free_wrapper, (void *)0, 8, (_Bool)0, -1};
static struct __anonstruct_GumboStringPiece_673951369  const  kDoctypeHtml  =    {"html", sizeof("html") - 1UL};
static struct __anonstruct_GumboStringPiece_673951369  const  kPublicIdHtml4_0  =    {"-//W3C//DTD HTML 4.0//EN",
    sizeof("-//W3C//DTD HTML 4.0//EN") - 1UL};
static struct __anonstruct_GumboStringPiece_673951369  const  kPublicIdHtml4_01  =    {"-//W3C//DTD HTML 4.01//EN",
    sizeof("-//W3C//DTD HTML 4.01//EN") - 1UL};
static struct __anonstruct_GumboStringPiece_673951369  const  kPublicIdXhtml1_0  =    {"-//W3C//DTD XHTML 1.0 Strict//EN",
    sizeof("-//W3C//DTD XHTML 1.0 Strict//EN") - 1UL};
static struct __anonstruct_GumboStringPiece_673951369  const  kPublicIdXhtml1_1  =    {"-//W3C//DTD XHTML 1.1//EN",
    sizeof("-//W3C//DTD XHTML 1.1//EN") - 1UL};
static struct __anonstruct_GumboStringPiece_673951369  const  kSystemIdRecHtml4_0  =    {"http://www.w3.org/TR/REC-html40/strict.dtd",
    sizeof("http://www.w3.org/TR/REC-html40/strict.dtd") - 1UL};
static struct __anonstruct_GumboStringPiece_673951369  const  kSystemIdHtml4  =    {"http://www.w3.org/TR/html4/strict.dtd", sizeof("http://www.w3.org/TR/html4/strict.dtd") - 1UL};
static struct __anonstruct_GumboStringPiece_673951369  const  kSystemIdXhtmlStrict1_1  =    {"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd",
    sizeof("http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd") - 1UL};
static struct __anonstruct_GumboStringPiece_673951369  const  kSystemIdXhtml1_1  =    {"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd",
    sizeof("http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd") - 1UL};
static struct __anonstruct_GumboStringPiece_673951369  const  kSystemIdLegacyCompat  =    {"about:legacy-compat",
    sizeof("about:legacy-compat") - 1UL};
static GumboStringPiece const   kQuirksModePublicIdPrefixes[56]  = 
  {      {"+//Silmaril//dtd html Pro v0r11 19970101//", sizeof("+//Silmaril//dtd html Pro v0r11 19970101//") - 1UL}, 
        {"-//AdvaSoft Ltd//DTD HTML 3.0 asWedit + extensions//",
      sizeof("-//AdvaSoft Ltd//DTD HTML 3.0 asWedit + extensions//") - 1UL}, 
        {"-//AS//DTD HTML 3.0 asWedit + extensions//", sizeof("-//AS//DTD HTML 3.0 asWedit + extensions//") - 1UL}, 
        {"-//IETF//DTD HTML 2.0 Level 1//",
      sizeof("-//IETF//DTD HTML 2.0 Level 1//") - 1UL}, 
        {"-//IETF//DTD HTML 2.0 Level 2//", sizeof("-//IETF//DTD HTML 2.0 Level 2//") - 1UL}, 
        {"-//IETF//DTD HTML 2.0 Strict Level 1//",
      sizeof("-//IETF//DTD HTML 2.0 Strict Level 1//") - 1UL}, 
        {"-//IETF//DTD HTML 2.0 Strict Level 2//", sizeof("-//IETF//DTD HTML 2.0 Strict Level 2//") - 1UL}, 
        {"-//IETF//DTD HTML 2.0 Strict//",
      sizeof("-//IETF//DTD HTML 2.0 Strict//") - 1UL}, 
        {"-//IETF//DTD HTML 2.0//", sizeof("-//IETF//DTD HTML 2.0//") - 1UL}, 
        {"-//IETF//DTD HTML 2.1E//", sizeof("-//IETF//DTD HTML 2.1E//") - 1UL}, 
        {"-//IETF//DTD HTML 3.0//", sizeof("-//IETF//DTD HTML 3.0//") - 1UL}, 
        {"-//IETF//DTD HTML 3.2 Final//", sizeof("-//IETF//DTD HTML 3.2 Final//") - 1UL}, 
        {"-//IETF//DTD HTML 3.2//",
      sizeof("-//IETF//DTD HTML 3.2//") - 1UL}, 
        {"-//IETF//DTD HTML 3//", sizeof("-//IETF//DTD HTML 3//") - 1UL}, 
        {"-//IETF//DTD HTML Level 0//", sizeof("-//IETF//DTD HTML Level 0//") - 1UL}, 
        {"-//IETF//DTD HTML Level 1//",
      sizeof("-//IETF//DTD HTML Level 1//") - 1UL}, 
        {"-//IETF//DTD HTML Level 2//", sizeof("-//IETF//DTD HTML Level 2//") - 1UL}, 
        {"-//IETF//DTD HTML Level 3//",
      sizeof("-//IETF//DTD HTML Level 3//") - 1UL}, 
        {"-//IETF//DTD HTML Strict Level 0//", sizeof("-//IETF//DTD HTML Strict Level 0//") - 1UL}, 
        {"-//IETF//DTD HTML Strict Level 1//",
      sizeof("-//IETF//DTD HTML Strict Level 1//") - 1UL}, 
        {"-//IETF//DTD HTML Strict Level 2//", sizeof("-//IETF//DTD HTML Strict Level 2//") - 1UL}, 
        {"-//IETF//DTD HTML Strict Level 3//",
      sizeof("-//IETF//DTD HTML Strict Level 3//") - 1UL}, 
        {"-//IETF//DTD HTML Strict//", sizeof("-//IETF//DTD HTML Strict//") - 1UL}, 
        {"-//IETF//DTD HTML//", sizeof("-//IETF//DTD HTML//") - 1UL}, 
        {"-//Metrius//DTD Metrius Presentational//", sizeof("-//Metrius//DTD Metrius Presentational//") - 1UL}, 
        {"-//Microsoft//DTD Internet Explorer 2.0 HTML Strict//",
      sizeof("-//Microsoft//DTD Internet Explorer 2.0 HTML Strict//") - 1UL}, 
        {"-//Microsoft//DTD Internet Explorer 2.0 HTML//", sizeof("-//Microsoft//DTD Internet Explorer 2.0 HTML//") - 1UL}, 
        {"-//Microsoft//DTD Internet Explorer 2.0 Tables//",
      sizeof("-//Microsoft//DTD Internet Explorer 2.0 Tables//") - 1UL}, 
        {"-//Microsoft//DTD Internet Explorer 3.0 HTML Strict//", sizeof("-//Microsoft//DTD Internet Explorer 3.0 HTML Strict//") - 1UL}, 
        {"-//Microsoft//DTD Internet Explorer 3.0 HTML//",
      sizeof("-//Microsoft//DTD Internet Explorer 3.0 HTML//") - 1UL}, 
        {"-//Microsoft//DTD Internet Explorer 3.0 Tables//", sizeof("-//Microsoft//DTD Internet Explorer 3.0 Tables//") - 1UL}, 
        {"-//Netscape Comm. Corp.//DTD HTML//",
      sizeof("-//Netscape Comm. Corp.//DTD HTML//") - 1UL}, 
        {"-//Netscape Comm. Corp.//DTD Strict HTML//", sizeof("-//Netscape Comm. Corp.//DTD Strict HTML//") - 1UL}, 
        {"-//O\'Reilly and Associates//DTD HTML 2.0//",
      sizeof("-//O\'Reilly and Associates//DTD HTML 2.0//") - 1UL}, 
        {"-//O\'Reilly and Associates//DTD HTML Extended 1.0//", sizeof("-//O\'Reilly and Associates//DTD HTML Extended 1.0//") - 1UL}, 
        {"-//O\'Reilly and Associates//DTD HTML Extended Relaxed 1.0//",
      sizeof("-//O\'Reilly and Associates//DTD HTML Extended Relaxed 1.0//") - 1UL}, 
        {"-//SoftQuad Software//DTD HoTMetaL PRO 6.0::19990601::)extensions to HTML 4.0//",
      sizeof("-//SoftQuad Software//DTD HoTMetaL PRO 6.0::19990601::)extensions to HTML 4.0//") - 1UL}, 
        {"-//SoftQuad//DTD HoTMetaL PRO 4.0::19971010::extensions to HTML 4.0//",
      sizeof("-//SoftQuad//DTD HoTMetaL PRO 4.0::19971010::extensions to HTML 4.0//") - 1UL}, 
        {"-//Spyglass//DTD HTML 2.0 Extended//",
      sizeof("-//Spyglass//DTD HTML 2.0 Extended//") - 1UL}, 
        {"-//SQ//DTD HTML 2.0 HoTMetaL + extensions//", sizeof("-//SQ//DTD HTML 2.0 HoTMetaL + extensions//") - 1UL}, 
        {"-//Sun Microsystems Corp.//DTD HotJava HTML//",
      sizeof("-//Sun Microsystems Corp.//DTD HotJava HTML//") - 1UL}, 
        {"-//Sun Microsystems Corp.//DTD HotJava Strict HTML//", sizeof("-//Sun Microsystems Corp.//DTD HotJava Strict HTML//") - 1UL}, 
        {"-//W3C//DTD HTML 3 1995-03-24//",
      sizeof("-//W3C//DTD HTML 3 1995-03-24//") - 1UL}, 
        {"-//W3C//DTD HTML 3.2 Draft//", sizeof("-//W3C//DTD HTML 3.2 Draft//") - 1UL}, 
        {"-//W3C//DTD HTML 3.2 Final//",
      sizeof("-//W3C//DTD HTML 3.2 Final//") - 1UL}, 
        {"-//W3C//DTD HTML 3.2//", sizeof("-//W3C//DTD HTML 3.2//") - 1UL}, 
        {"-//W3C//DTD HTML 3.2S Draft//", sizeof("-//W3C//DTD HTML 3.2S Draft//") - 1UL}, 
        {"-//W3C//DTD HTML 4.0 Frameset//",
      sizeof("-//W3C//DTD HTML 4.0 Frameset//") - 1UL}, 
        {"-//W3C//DTD HTML 4.0 Transitional//", sizeof("-//W3C//DTD HTML 4.0 Transitional//") - 1UL}, 
        {"-//W3C//DTD HTML Experimental 19960712//",
      sizeof("-//W3C//DTD HTML Experimental 19960712//") - 1UL}, 
        {"-//W3C//DTD HTML Experimental 970421//", sizeof("-//W3C//DTD HTML Experimental 970421//") - 1UL}, 
        {"-//W3C//DTD W3 HTML//",
      sizeof("-//W3C//DTD W3 HTML//") - 1UL}, 
        {"-//W3O//DTD W3 HTML 3.0//", sizeof("-//W3O//DTD W3 HTML 3.0//") - 1UL}, 
        {"-//WebTechs//DTD Mozilla HTML 2.0//", sizeof("-//WebTechs//DTD Mozilla HTML 2.0//") - 1UL}, 
        {"-//WebTechs//DTD Mozilla HTML//",
      sizeof("-//WebTechs//DTD Mozilla HTML//") - 1UL}, 
        {"", (size_t )0}};
static GumboStringPiece const   kQuirksModePublicIdExactMatches[4]  = {      {"-//W3O//DTD W3 HTML Strict 3.0//EN//", sizeof("-//W3O//DTD W3 HTML Strict 3.0//EN//") - 1UL}, 
        {"-/W3C/DTD HTML 4.0 Transitional/EN",
      sizeof("-/W3C/DTD HTML 4.0 Transitional/EN") - 1UL}, 
        {"HTML", sizeof("HTML") - 1UL}, 
        {"", (size_t )0}};
static GumboStringPiece const   kQuirksModeSystemIdExactMatches[2]  = {      {"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", sizeof("http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd") - 1UL}, 
        {"",
      (size_t )0}};
static GumboStringPiece const   kLimitedQuirksPublicIdPrefixes[3]  = {      {"-//W3C//DTD XHTML 1.0 Frameset//", sizeof("-//W3C//DTD XHTML 1.0 Frameset//") - 1UL}, 
        {"-//W3C//DTD XHTML 1.0 Transitional//",
      sizeof("-//W3C//DTD XHTML 1.0 Transitional//") - 1UL}, 
        {"", (size_t )0}};
static GumboStringPiece const   kLimitedQuirksRequiresSystemIdPublicIdPrefixes[3]  = {      {"-//W3C//DTD HTML 4.01 Frameset//",
      sizeof("-//W3C//DTD HTML 4.01 Frameset//") - 1UL}, 
        {"-//W3C//DTD HTML 4.01 Transitional//", sizeof("-//W3C//DTD HTML 4.01 Transitional//") - 1UL}, 
        {"",
      (size_t )0}};
static char const   *kLegalXmlns[3]  = {      "http://www.w3.org/1999/xhtml",      "http://www.w3.org/2000/svg",      "http://www.w3.org/1998/Math/MathML"};
static ReplacementEntry const   kSvgAttributeReplacements[62]  = 
  {      {{"attributename", sizeof("attributename") - 1UL}, {"attributeName", sizeof("attributeName") - 1UL}}, 
        {{"attributetype",
       sizeof("attributetype") - 1UL}, {"attributeType", sizeof("attributeType") - 1UL}}, 
        {{"basefrequency",
       sizeof("basefrequency") - 1UL}, {"baseFrequency", sizeof("baseFrequency") - 1UL}}, 
        {{"baseprofile",
       sizeof("baseprofile") - 1UL}, {"baseProfile", sizeof("baseProfile") - 1UL}}, 
        {{"calcmode",
       sizeof("calcmode") - 1UL}, {"calcMode", sizeof("calcMode") - 1UL}}, 
        {{"clippathunits", sizeof("clippathunits") - 1UL}, {"clipPathUnits", sizeof("clipPathUnits") - 1UL}}, 
        {{"contentscripttype",
       sizeof("contentscripttype") - 1UL}, {"contentScriptType", sizeof("contentScriptType") - 1UL}}, 
        {{"contentstyletype",
       sizeof("contentstyletype") - 1UL}, {"contentStyleType", sizeof("contentStyleType") - 1UL}}, 
        {{"diffuseconstant",
       sizeof("diffuseconstant") - 1UL}, {"diffuseConstant", sizeof("diffuseConstant") - 1UL}}, 
        {{"edgemode",
       sizeof("edgemode") - 1UL}, {"edgeMode", sizeof("edgeMode") - 1UL}}, 
        {{"externalresourcesrequired", sizeof("externalresourcesrequired") - 1UL}, {"externalResourcesRequired",
                                                                                 sizeof("externalResourcesRequired") - 1UL}}, 
        {{"filterres",
       sizeof("filterres") - 1UL}, {"filterRes", sizeof("filterRes") - 1UL}}, 
        {{"filterunits", sizeof("filterunits") - 1UL}, {"filterUnits", sizeof("filterUnits") - 1UL}}, 
        {{"glyphref",
       sizeof("glyphref") - 1UL}, {"glyphRef", sizeof("glyphRef") - 1UL}}, 
        {{"gradienttransform", sizeof("gradienttransform") - 1UL}, {"gradientTransform",
                                                                 sizeof("gradientTransform") - 1UL}}, 
        {{"gradientunits",
       sizeof("gradientunits") - 1UL}, {"gradientUnits", sizeof("gradientUnits") - 1UL}}, 
        {{"kernelmatrix",
       sizeof("kernelmatrix") - 1UL}, {"kernelMatrix", sizeof("kernelMatrix") - 1UL}}, 
        {{"kernelunitlength",
       sizeof("kernelunitlength") - 1UL}, {"kernelUnitLength", sizeof("kernelUnitLength") - 1UL}}, 
        {{"keypoints",
       sizeof("keypoints") - 1UL}, {"keyPoints", sizeof("keyPoints") - 1UL}}, 
        {{"keysplines", sizeof("keysplines") - 1UL}, {"keySplines", sizeof("keySplines") - 1UL}}, 
        {{"keytimes",
       sizeof("keytimes") - 1UL}, {"keyTimes", sizeof("keyTimes") - 1UL}}, 
        {{"lengthadjust", sizeof("lengthadjust") - 1UL}, {"lengthAdjust", sizeof("lengthAdjust") - 1UL}}, 
        {{"limitingconeangle",
       sizeof("limitingconeangle") - 1UL}, {"limitingConeAngle", sizeof("limitingConeAngle") - 1UL}}, 
        {{"markerheight",
       sizeof("markerheight") - 1UL}, {"markerHeight", sizeof("markerHeight") - 1UL}}, 
        {{"markerunits",
       sizeof("markerunits") - 1UL}, {"markerUnits", sizeof("markerUnits") - 1UL}}, 
        {{"markerwidth",
       sizeof("markerwidth") - 1UL}, {"markerWidth", sizeof("markerWidth") - 1UL}}, 
        {{"maskcontentunits",
       sizeof("maskcontentunits") - 1UL}, {"maskContentUnits", sizeof("maskContentUnits") - 1UL}}, 
        {{"maskunits",
       sizeof("maskunits") - 1UL}, {"maskUnits", sizeof("maskUnits") - 1UL}}, 
        {{"numoctaves", sizeof("numoctaves") - 1UL}, {"numOctaves", sizeof("numOctaves") - 1UL}}, 
        {{"pathlength",
       sizeof("pathlength") - 1UL}, {"pathLength", sizeof("pathLength") - 1UL}}, 
        {{"patterncontentunits", sizeof("patterncontentunits") - 1UL}, {"patternContentUnits",
                                                                     sizeof("patternContentUnits") - 1UL}}, 
        {{"patterntransform",
       sizeof("patterntransform") - 1UL}, {"patternTransform", sizeof("patternTransform") - 1UL}}, 
        {{"patternunits",
       sizeof("patternunits") - 1UL}, {"patternUnits", sizeof("patternUnits") - 1UL}}, 
        {{"pointsatx",
       sizeof("pointsatx") - 1UL}, {"pointsAtX", sizeof("pointsAtX") - 1UL}}, 
        {{"pointsaty", sizeof("pointsaty") - 1UL}, {"pointsAtY", sizeof("pointsAtY") - 1UL}}, 
        {{"pointsatz",
       sizeof("pointsatz") - 1UL}, {"pointsAtZ", sizeof("pointsAtZ") - 1UL}}, 
        {{"preservealpha", sizeof("preservealpha") - 1UL}, {"preserveAlpha", sizeof("preserveAlpha") - 1UL}}, 
        {{"preserveaspectratio",
       sizeof("preserveaspectratio") - 1UL}, {"preserveAspectRatio", sizeof("preserveAspectRatio") - 1UL}}, 
        {{"primitiveunits",
       sizeof("primitiveunits") - 1UL}, {"primitiveUnits", sizeof("primitiveUnits") - 1UL}}, 
        {{"refx",
       sizeof("refx") - 1UL}, {"refX", sizeof("refX") - 1UL}}, 
        {{"refy", sizeof("refy") - 1UL}, {"refY", sizeof("refY") - 1UL}}, 
        {{"repeatcount", sizeof("repeatcount") - 1UL}, {"repeatCount", sizeof("repeatCount") - 1UL}}, 
        {{"repeatdur",
       sizeof("repeatdur") - 1UL}, {"repeatDur", sizeof("repeatDur") - 1UL}}, 
        {{"requiredextensions", sizeof("requiredextensions") - 1UL}, {"requiredExtensions",
                                                                   sizeof("requiredExtensions") - 1UL}}, 
        {{"requiredfeatures",
       sizeof("requiredfeatures") - 1UL}, {"requiredFeatures", sizeof("requiredFeatures") - 1UL}}, 
        {{"specularconstant",
       sizeof("specularconstant") - 1UL}, {"specularConstant", sizeof("specularConstant") - 1UL}}, 
        {{"specularexponent",
       sizeof("specularexponent") - 1UL}, {"specularExponent", sizeof("specularExponent") - 1UL}}, 
        {{"spreadmethod",
       sizeof("spreadmethod") - 1UL}, {"spreadMethod", sizeof("spreadMethod") - 1UL}}, 
        {{"startoffset",
       sizeof("startoffset") - 1UL}, {"startOffset", sizeof("startOffset") - 1UL}}, 
        {{"stddeviation",
       sizeof("stddeviation") - 1UL}, {"stdDeviation", sizeof("stdDeviation") - 1UL}}, 
        {{"stitchtiles",
       sizeof("stitchtiles") - 1UL}, {"stitchTiles", sizeof("stitchTiles") - 1UL}}, 
        {{"surfacescale",
       sizeof("surfacescale") - 1UL}, {"surfaceScale", sizeof("surfaceScale") - 1UL}}, 
        {{"systemlanguage",
       sizeof("systemlanguage") - 1UL}, {"systemLanguage", sizeof("systemLanguage") - 1UL}}, 
        {{"tablevalues",
       sizeof("tablevalues") - 1UL}, {"tableValues", sizeof("tableValues") - 1UL}}, 
        {{"targetx",
       sizeof("targetx") - 1UL}, {"targetX", sizeof("targetX") - 1UL}}, 
        {{"targety", sizeof("targety") - 1UL}, {"targetY", sizeof("targetY") - 1UL}}, 
        {{"textlength",
       sizeof("textlength") - 1UL}, {"textLength", sizeof("textLength") - 1UL}}, 
        {{"viewbox", sizeof("viewbox") - 1UL}, {"viewBox", sizeof("viewBox") - 1UL}}, 
        {{"viewtarget",
       sizeof("viewtarget") - 1UL}, {"viewTarget", sizeof("viewTarget") - 1UL}}, 
        {{"xchannelselector", sizeof("xchannelselector") - 1UL}, {"xChannelSelector",
                                                               sizeof("xChannelSelector") - 1UL}}, 
        {{"ychannelselector",
       sizeof("ychannelselector") - 1UL}, {"yChannelSelector", sizeof("yChannelSelector") - 1UL}}, 
        {{"zoomandpan",
       sizeof("zoomandpan") - 1UL}, {"zoomAndPan", sizeof("zoomAndPan") - 1UL}}};
static ReplacementEntry const   kSvgTagReplacements[36]  = 
  {      {{"altglyph", sizeof("altglyph") - 1UL}, {"altGlyph", sizeof("altGlyph") - 1UL}}, 
        {{"altglyphdef",
       sizeof("altglyphdef") - 1UL}, {"altGlyphDef", sizeof("altGlyphDef") - 1UL}}, 
        {{"altglyphitem",
       sizeof("altglyphitem") - 1UL}, {"altGlyphItem", sizeof("altGlyphItem") - 1UL}}, 
        {{"animatecolor",
       sizeof("animatecolor") - 1UL}, {"animateColor", sizeof("animateColor") - 1UL}}, 
        {{"animatemotion",
       sizeof("animatemotion") - 1UL}, {"animateMotion", sizeof("animateMotion") - 1UL}}, 
        {{"animatetransform",
       sizeof("animatetransform") - 1UL}, {"animateTransform", sizeof("animateTransform") - 1UL}}, 
        {{"clippath",
       sizeof("clippath") - 1UL}, {"clipPath", sizeof("clipPath") - 1UL}}, 
        {{"feblend", sizeof("feblend") - 1UL}, {"feBlend", sizeof("feBlend") - 1UL}}, 
        {{"fecolormatrix",
       sizeof("fecolormatrix") - 1UL}, {"feColorMatrix", sizeof("feColorMatrix") - 1UL}}, 
        {{"fecomponenttransfer",
       sizeof("fecomponenttransfer") - 1UL}, {"feComponentTransfer", sizeof("feComponentTransfer") - 1UL}}, 
        {{"fecomposite",
       sizeof("fecomposite") - 1UL}, {"feComposite", sizeof("feComposite") - 1UL}}, 
        {{"feconvolvematrix",
       sizeof("feconvolvematrix") - 1UL}, {"feConvolveMatrix", sizeof("feConvolveMatrix") - 1UL}}, 
        {{"fediffuselighting",
       sizeof("fediffuselighting") - 1UL}, {"feDiffuseLighting", sizeof("feDiffuseLighting") - 1UL}}, 
        {{"fedisplacementmap",
       sizeof("fedisplacementmap") - 1UL}, {"feDisplacementMap", sizeof("feDisplacementMap") - 1UL}}, 
        {{"fedistantlight",
       sizeof("fedistantlight") - 1UL}, {"feDistantLight", sizeof("feDistantLight") - 1UL}}, 
        {{"feflood",
       sizeof("feflood") - 1UL}, {"feFlood", sizeof("feFlood") - 1UL}}, 
        {{"fefunca", sizeof("fefunca") - 1UL}, {"feFuncA", sizeof("feFuncA") - 1UL}}, 
        {{"fefuncb",
       sizeof("fefuncb") - 1UL}, {"feFuncB", sizeof("feFuncB") - 1UL}}, 
        {{"fefuncg", sizeof("fefuncg") - 1UL}, {"feFuncG", sizeof("feFuncG") - 1UL}}, 
        {{"fefuncr",
       sizeof("fefuncr") - 1UL}, {"feFuncR", sizeof("feFuncR") - 1UL}}, 
        {{"fegaussianblur", sizeof("fegaussianblur") - 1UL}, {"feGaussianBlur", sizeof("feGaussianBlur") - 1UL}}, 
        {{"feimage",
       sizeof("feimage") - 1UL}, {"feImage", sizeof("feImage") - 1UL}}, 
        {{"femerge", sizeof("femerge") - 1UL}, {"feMerge", sizeof("feMerge") - 1UL}}, 
        {{"femergenode",
       sizeof("femergenode") - 1UL}, {"feMergeNode", sizeof("feMergeNode") - 1UL}}, 
        {{"femorphology",
       sizeof("femorphology") - 1UL}, {"feMorphology", sizeof("feMorphology") - 1UL}}, 
        {{"feoffset",
       sizeof("feoffset") - 1UL}, {"feOffset", sizeof("feOffset") - 1UL}}, 
        {{"fepointlight", sizeof("fepointlight") - 1UL}, {"fePointLight", sizeof("fePointLight") - 1UL}}, 
        {{"fespecularlighting",
       sizeof("fespecularlighting") - 1UL}, {"feSpecularLighting", sizeof("feSpecularLighting") - 1UL}}, 
        {{"fespotlight",
       sizeof("fespotlight") - 1UL}, {"feSpotLight", sizeof("feSpotLight") - 1UL}}, 
        {{"fetile",
       sizeof("fetile") - 1UL}, {"feTile", sizeof("feTile") - 1UL}}, 
        {{"feturbulence", sizeof("feturbulence") - 1UL}, {"feTurbulence", sizeof("feTurbulence") - 1UL}}, 
        {{"foreignobject",
       sizeof("foreignobject") - 1UL}, {"foreignObject", sizeof("foreignObject") - 1UL}}, 
        {{"glyphref",
       sizeof("glyphref") - 1UL}, {"glyphRef", sizeof("glyphRef") - 1UL}}, 
        {{"lineargradient", sizeof("lineargradient") - 1UL}, {"linearGradient", sizeof("linearGradient") - 1UL}}, 
        {{"radialgradient",
       sizeof("radialgradient") - 1UL}, {"radialGradient", sizeof("radialGradient") - 1UL}}, 
        {{"textpath",
       sizeof("textpath") - 1UL}, {"textPath", sizeof("textPath") - 1UL}}};
static NamespacedAttributeReplacement const   kForeignAttributeReplacements[12]  = 
  {      {"xlink:actuate", "actuate", (GumboAttributeNamespaceEnum const   )1}, 
        {"xlink:actuate", "actuate", (GumboAttributeNamespaceEnum const   )1}, 
        {"xlink:href", "href", (GumboAttributeNamespaceEnum const   )1}, 
        {"xlink:role", "role", (GumboAttributeNamespaceEnum const   )1}, 
        {"xlink:show", "show", (GumboAttributeNamespaceEnum const   )1}, 
        {"xlink:title", "title", (GumboAttributeNamespaceEnum const   )1}, 
        {"xlink:type", "type", (GumboAttributeNamespaceEnum const   )1}, 
        {"xml:base", "base", (GumboAttributeNamespaceEnum const   )2}, 
        {"xml:lang", "lang", (GumboAttributeNamespaceEnum const   )2}, 
        {"xml:space", "space", (GumboAttributeNamespaceEnum const   )2}, 
        {"xmlns", "xmlns", (GumboAttributeNamespaceEnum const   )3}, 
        {"xmlns:xlink", "xlink", (GumboAttributeNamespaceEnum const   )3}};
static GumboNode const   kActiveFormattingScopeMarker  ;
static _Bool const   kStartTag  =    (_Bool const   )1;
static _Bool const   kEndTag  =    (_Bool const   )0;
static _Bool token_has_attribute(GumboToken const   *token , char const   *name ) 
{ 
  GumboAttribute *tmp___0 ;

  {
  if (! ((unsigned int const   )token->type == 1U)) {
    __assert_fail("token->type == GUMBO_TOKEN_START_TAG", "deps/gumbo-parser/parser.c",
                  404U, "token_has_attribute");
  }
  tmp___0 = gumbo_get_attribute(& token->v.start_tag.attributes, name);
  return ((_Bool )((unsigned long )tmp___0 != (unsigned long )((void *)0)));
}
}
static _Bool attribute_matches(GumboVector const   *attributes , char const   *name ,
                               char const   *value ) 
{ 
  GumboAttribute const   *attr ;
  GumboAttribute *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = gumbo_get_attribute(attributes, name);
  attr = (GumboAttribute const   *)tmp;
  if (attr) {
    tmp___0 = strcasecmp(value, (char const   *)attr->value);
    tmp___1 = tmp___0 == 0;
  } else {
    tmp___1 = 0;
  }
  return ((_Bool )tmp___1);
}
}
static _Bool attribute_matches_case_sensitive(GumboVector const   *attributes , char const   *name ,
                                              char const   *value ) 
{ 
  GumboAttribute const   *attr ;
  GumboAttribute *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = gumbo_get_attribute(attributes, name);
  attr = (GumboAttribute const   *)tmp;
  if (attr) {
    tmp___0 = strcmp(value, (char const   *)attr->value);
    tmp___1 = tmp___0 == 0;
  } else {
    tmp___1 = 0;
  }
  return ((_Bool )tmp___1);
}
}
static _Bool all_attributes_match(GumboVector const   *attr1 , GumboVector const   *attr2 ) 
{ 
  int num_unmatched_attr2_elements ;
  int i ;
  GumboAttribute const   *attr ;
  _Bool tmp ;

  {
  num_unmatched_attr2_elements = (int )attr2->length;
  i = 0;
  while ((unsigned int const   )i < attr1->length) {
    attr = (GumboAttribute const   *)*(attr1->data + i);
    tmp = attribute_matches_case_sensitive(attr2, (char const   *)attr->name, (char const   *)attr->value);
    if (tmp) {
      num_unmatched_attr2_elements --;
    } else {
      return ((_Bool)0);
    }
    i ++;
  }
  return ((_Bool )(num_unmatched_attr2_elements == 0));
}
}
static void set_frameset_not_ok(GumboParser *parser ) 
{ 


  {
  gumbo_debug("Setting frameset_ok to false.\n");
  (parser->_parser_state)->_frameset_ok = (_Bool)0;
  return;
}
}
static GumboNode *create_node(GumboParser *parser , GumboNodeType type ) 
{ 
  GumboNode *node ;
  void *tmp ;

  {
  tmp = gumbo_parser_allocate(parser, sizeof(GumboNode ));
  node = (GumboNode *)tmp;
  node->parent = (GumboNode *)((void *)0);
  node->index_within_parent = (size_t )-1;
  node->type = type;
  node->parse_flags = (GumboParseFlags )0;
  return (node);
}
}
static GumboNode *new_document_node(GumboParser *parser ) 
{ 
  GumboNode *document_node ;
  GumboNode *tmp ;
  GumboDocument *document ;

  {
  tmp = create_node(parser, (GumboNodeType )0);
  document_node = tmp;
  document_node->parse_flags = (GumboParseFlags )1;
  gumbo_vector_init(parser, (size_t )1, & document_node->v.document.children);
  document = & document_node->v.document;
  document->has_doctype = (_Bool)0;
  document->name = (char const   *)((void *)0);
  document->public_identifier = (char const   *)((void *)0);
  document->system_identifier = (char const   *)((void *)0);
  return (document_node);
}
}
static void output_init(GumboParser *parser ) 
{ 
  GumboOutput *output ;
  void *tmp ;

  {
  tmp = gumbo_parser_allocate(parser, sizeof(GumboOutput ));
  output = (GumboOutput *)tmp;
  output->root = (GumboNode *)((void *)0);
  output->document = new_document_node(parser);
  parser->_output = output;
  gumbo_init_errors(parser);
  return;
}
}
static void parser_state_init(GumboParser *parser ) 
{ 
  GumboParserState *parser_state ;
  void *tmp ;

  {
  tmp = gumbo_parser_allocate(parser, sizeof(GumboParserState ));
  parser_state = (GumboParserState *)tmp;
  parser_state->_insertion_mode = (GumboInsertionMode )0;
  parser_state->_reprocess_current_token = (_Bool)0;
  parser_state->_frameset_ok = (_Bool)1;
  parser_state->_ignore_next_linefeed = (_Bool)0;
  parser_state->_foster_parent_insertions = (_Bool)0;
  parser_state->_text_node._type = (GumboNodeType )5;
  gumbo_string_buffer_init(parser, & parser_state->_text_node._buffer);
  gumbo_vector_init(parser, (size_t )10, & parser_state->_open_elements);
  gumbo_vector_init(parser, (size_t )5, & parser_state->_active_formatting_elements);
  gumbo_vector_init(parser, (size_t )5, & parser_state->_template_insertion_modes);
  parser_state->_head_element = (GumboNode *)((void *)0);
  parser_state->_form_element = (GumboNode *)((void *)0);
  parser_state->_current_token = (GumboToken *)((void *)0);
  parser_state->_closed_body_tag = (_Bool)0;
  parser_state->_closed_html_tag = (_Bool)0;
  parser->_parser_state = parser_state;
  return;
}
}
static void parser_state_destroy(GumboParser *parser ) 
{ 
  GumboParserState *state ;

  {
  state = parser->_parser_state;
  gumbo_vector_destroy(parser, & state->_active_formatting_elements);
  gumbo_vector_destroy(parser, & state->_open_elements);
  gumbo_vector_destroy(parser, & state->_template_insertion_modes);
  gumbo_string_buffer_destroy(parser, & state->_text_node._buffer);
  gumbo_parser_deallocate(parser, (void *)state);
  return;
}
}
static GumboNode *get_document_node(GumboParser *parser ) 
{ 


  {
  return ((parser->_output)->document);
}
}
static GumboNode *get_current_node(GumboParser *parser ) 
{ 
  GumboVector *open_elements ;

  {
  open_elements = & (parser->_parser_state)->_open_elements;
  if (open_elements->length == 0U) {
    if (! (! (parser->_output)->root)) {
      __assert_fail("!parser->_output->root", "deps/gumbo-parser/parser.c", 516U,
                    "get_current_node");
    }
    return ((GumboNode *)((void *)0));
  }
  if (! (open_elements->length > 0U)) {
    __assert_fail("open_elements->length > 0", "deps/gumbo-parser/parser.c", 519U,
                  "get_current_node");
  }
  if (! ((unsigned long )open_elements->data != (unsigned long )((void *)0))) {
    __assert_fail("open_elements->data != NULL", "deps/gumbo-parser/parser.c", 520U,
                  "get_current_node");
  }
  return ((GumboNode *)*(open_elements->data + (open_elements->length - 1U)));
}
}
static _Bool is_in_static_list(char const   *needle , GumboStringPiece const   *haystack ,
                               _Bool exact_match ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  i = 0;
  while ((haystack + i)->length > 0UL) {
    if (exact_match) {
      tmp = strcmp(needle, (char const   *)(haystack + i)->data);
      if (tmp) {
        goto _L;
      } else {
        return ((_Bool)1);
      }
    } else
    _L: /* CIL Label */ 
    if (! exact_match) {
      tmp___0 = strcasecmp(needle, (char const   *)(haystack + i)->data);
      if (! tmp___0) {
        return ((_Bool)1);
      }
    }
    i ++;
  }
  return ((_Bool)0);
}
}
static void set_insertion_mode(GumboParser *parser , GumboInsertionMode mode ) 
{ 


  {
  (parser->_parser_state)->_insertion_mode = mode;
  return;
}
}
static GumboInsertionMode get_appropriate_insertion_mode(GumboNode const   *node ,
                                                         _Bool is_last ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! ((unsigned int const   )node->type == 1U)) {
    __assert_fail("node->type == GUMBO_NODE_ELEMENT", "deps/gumbo-parser/parser.c",
                  570U, "get_appropriate_insertion_mode");
  }
  switch ((unsigned int const   )node->v.element.tag) {
  case 111U: 
  return ((GumboInsertionMode )15);
  case 104U: 
  case 103U: 
  if (is_last) {
    tmp___0 = 6;
  } else {
    tmp___0 = 14;
  }
  return ((GumboInsertionMode )tmp___0);
  case 102U: 
  return ((GumboInsertionMode )13);
  case 101U: 
  case 100U: 
  case 99U: 
  return ((GumboInsertionMode )12);
  case 96U: 
  return ((GumboInsertionMode )10);
  case 97U: 
  return ((GumboInsertionMode )11);
  case 95U: 
  return ((GumboInsertionMode )8);
  case 10U: 
  case 1U: 
  return ((GumboInsertionMode )6);
  case 129U: 
  return ((GumboInsertionMode )19);
  case 0U: 
  return ((GumboInsertionMode )2);
  default: 
  if (is_last) {
    tmp___1 = 6;
  } else {
    tmp___1 = 0;
  }
  return ((GumboInsertionMode )tmp___1);
  }
}
}
static void reset_insertion_mode_appropriately(GumboParser *parser ) 
{ 
  GumboVector const   *open_elements ;
  int i ;
  GumboInsertionMode mode ;
  GumboInsertionMode tmp ;

  {
  open_elements = (GumboVector const   *)(& (parser->_parser_state)->_open_elements);
  i = (int )open_elements->length;
  while (1) {
    i --;
    if (! (i >= 0)) {
      break;
    }
    tmp = get_appropriate_insertion_mode((GumboNode const   *)*(open_elements->data + i),
                                         (_Bool )(i == 0));
    mode = tmp;
    if ((unsigned int )mode != 0U) {
      set_insertion_mode(parser, mode);
      return;
    }
  }
  __assert_fail("0", "deps/gumbo-parser/parser.c", 616U, "reset_insertion_mode_appropriately");
}
}
static GumboError *add_parse_error(GumboParser *parser , GumboToken const   *token ) 
{ 
  GumboError *error___0 ;
  GumboError *tmp ;
  GumboParserError *extra_data ;
  GumboParserState *state ;
  int i ;
  GumboNode const   *node ;

  {
  gumbo_debug("Adding parse error.\n");
  tmp = gumbo_add_error(parser);
  error___0 = tmp;
  if (! error___0) {
    return ((GumboError *)((void *)0));
  }
  error___0->type = (GumboErrorType )40;
  error___0->position = (GumboSourcePosition )token->position;
  error___0->original_text = (char const   *)token->original_text.data;
  extra_data = & error___0->v.parser;
  extra_data->input_type = (GumboTokenType )token->type;
  extra_data->input_tag = (GumboTag )149;
  if ((unsigned int const   )token->type == 1U) {
    extra_data->input_tag = (GumboTag )token->v.start_tag.tag;
  } else
  if ((unsigned int const   )token->type == 2U) {
    extra_data->input_tag = (GumboTag )token->v.end_tag;
  }
  state = parser->_parser_state;
  extra_data->parser_state = state->_insertion_mode;
  gumbo_vector_init(parser, (size_t )state->_open_elements.length, & extra_data->tag_stack);
  i = 0;
  while ((unsigned int )i < state->_open_elements.length) {
    node = (GumboNode const   *)*(state->_open_elements.data + i);
    if (! ((unsigned int const   )node->type == 1U)) {
      __assert_fail("node->type == GUMBO_NODE_ELEMENT", "deps/gumbo-parser/parser.c",
                    642U, "add_parse_error");
    }
    gumbo_vector_add(parser, (void *)node->v.element.tag, & extra_data->tag_stack);
    i ++;
  }
  return (error___0);
}
}
static _Bool tag_in(GumboToken const   *token , _Bool is_start  , ...) 
{ 
  GumboTag token_tag ;
  va_list tags ;
  _Bool result ;
  GumboTag tag ;
  GumboTag tmp___0 ;
  GumboTag tmp___1 ;

  {
  if (is_start) {
    if ((unsigned int const   )token->type == 1U) {
      token_tag = (GumboTag )token->v.start_tag.tag;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (! is_start) {
    if ((unsigned int const   )token->type == 2U) {
      token_tag = (GumboTag )token->v.end_tag;
    } else {
      return ((_Bool)0);
    }
  } else {
    return ((_Bool)0);
  }
  __builtin_va_start(tags, is_start);
  result = (_Bool)0;
  tmp___0 = __builtin_va_arg(tags, GumboTag );
  tag = tmp___0;
  while ((unsigned int )tag != 150U) {
    if ((unsigned int )tag == (unsigned int )token_tag) {
      result = (_Bool)1;
      break;
    }
    tmp___1 = __builtin_va_arg(tags, GumboTag );
    tag = tmp___1;
  }
  __builtin_va_end(tags);
  return (result);
}
}
static _Bool tag_is(GumboToken const   *token , _Bool is_start , GumboTag tag ) 
{ 


  {
  if (is_start) {
    if ((unsigned int const   )token->type == 1U) {
      return ((_Bool )((unsigned int const   )token->v.start_tag.tag == (unsigned int const   )tag));
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (! is_start) {
    if ((unsigned int const   )token->type == 2U) {
      return ((_Bool )((unsigned int const   )token->v.end_tag == (unsigned int const   )tag));
    } else {
      return ((_Bool)0);
    }
  } else {
    return ((_Bool)0);
  }
}
}
static _Bool node_tag_in(GumboNode const   *node  , ...) 
{ 
  GumboTag node_tag ;
  va_list tags ;
  _Bool result ;
  GumboTag tag ;
  GumboTag tmp___1 ;
  GumboTag tmp___2 ;

  {
  if (! ((unsigned long )node != (unsigned long )((void *)0))) {
    __assert_fail("node != NULL", "deps/gumbo-parser/parser.c", 696U, "node_tag_in");
  }
  if ((unsigned int const   )node->type != 1U) {
    return ((_Bool)0);
  }
  node_tag = (GumboTag )node->v.element.tag;
  __builtin_va_start(tags, node);
  result = (_Bool)0;
  tmp___1 = __builtin_va_arg(tags, GumboTag );
  tag = tmp___1;
  while ((unsigned int )tag != 150U) {
    if (! ((unsigned int )tag <= 150U)) {
      __assert_fail("tag <= GUMBO_TAG_LAST", "deps/gumbo-parser/parser.c", 707U, "node_tag_in");
    }
    if ((unsigned int )tag == (unsigned int )node_tag) {
      result = (_Bool)1;
      break;
    }
    tmp___2 = __builtin_va_arg(tags, GumboTag );
    tag = tmp___2;
  }
  __builtin_va_end(tags);
  return (result);
}
}
static _Bool node_tag_is(GumboNode const   *node , GumboTag tag ) 
{ 
  int tmp ;

  {
  if ((unsigned int const   )node->type == 1U) {
    if ((unsigned int const   )node->v.element.tag == (unsigned int const   )tag) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
static _Bool is_mathml_integration_point(GumboNode const   *node ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
  tmp = node_tag_in(node, 84, 85, 86, 87, 88, 150);
  if (tmp) {
    if ((unsigned int const   )node->v.element.tag_namespace == 2U) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return ((_Bool )tmp___0);
}
}
static _Bool is_html_integration_point(GumboNode const   *node ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;

  {
  tmp = node_tag_in(node, 93, 94, 2, 150);
  if (tmp) {
    if ((unsigned int const   )node->v.element.tag_namespace == 1U) {
      tmp___3 = 1;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___0 = node_tag_is(node, (GumboTag )91);
    if (tmp___0) {
      tmp___1 = attribute_matches(& node->v.element.attributes, "encoding", "text/html");
      if (tmp___1) {
        tmp___3 = 1;
      } else {
        tmp___2 = attribute_matches(& node->v.element.attributes, "encoding", "application/xhtml+xml");
        if (tmp___2) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      }
    } else {
      tmp___3 = 0;
    }
  }
  return ((_Bool )tmp___3);
}
}
static void append_node(GumboParser *parser , GumboNode *parent , GumboNode *node ) 
{ 
  GumboVector *children ;

  {
  if (! ((unsigned long )node->parent == (unsigned long )((void *)0))) {
    __assert_fail("node->parent == NULL", "deps/gumbo-parser/parser.c", 745U, "append_node");
  }
  if (! (node->index_within_parent == 0xffffffffffffffffUL)) {
    __assert_fail("node->index_within_parent == -1", "deps/gumbo-parser/parser.c",
                  746U, "append_node");
  }
  if ((unsigned int )parent->type == 1U) {
    children = & parent->v.element.children;
  } else {
    if (! ((unsigned int )parent->type == 0U)) {
      __assert_fail("parent->type == GUMBO_NODE_DOCUMENT", "deps/gumbo-parser/parser.c",
                    751U, "append_node");
    }
    children = & parent->v.document.children;
  }
  node->parent = parent;
  node->index_within_parent = (size_t )children->length;
  gumbo_vector_add(parser, (void *)node, children);
  if (! (node->index_within_parent < (size_t )children->length)) {
    __assert_fail("node->index_within_parent < children->length", "deps/gumbo-parser/parser.c",
                  757U, "append_node");
  }
  return;
}
}
static void insert_node(GumboParser *parser , GumboNode *parent , int index___0 ,
                        GumboNode *node ) 
{ 
  GumboVector *children ;
  int i ;
  GumboNode *sibling ;

  {
  if (! ((unsigned long )node->parent == (unsigned long )((void *)0))) {
    __assert_fail("node->parent == NULL", "deps/gumbo-parser/parser.c", 764U, "insert_node");
  }
  if (! (node->index_within_parent == 0xffffffffffffffffUL)) {
    __assert_fail("node->index_within_parent == -1", "deps/gumbo-parser/parser.c",
                  765U, "insert_node");
  }
  if (! ((unsigned int )parent->type == 1U)) {
    __assert_fail("parent->type == GUMBO_NODE_ELEMENT", "deps/gumbo-parser/parser.c",
                  766U, "insert_node");
  }
  children = & parent->v.element.children;
  if (! (index___0 >= 0)) {
    __assert_fail("index >= 0", "deps/gumbo-parser/parser.c", 768U, "insert_node");
  }
  if (! ((unsigned int )index___0 < children->length)) {
    __assert_fail("index < children->length", "deps/gumbo-parser/parser.c", 769U,
                  "insert_node");
  }
  node->parent = parent;
  node->index_within_parent = (size_t )index___0;
  gumbo_vector_insert_at(parser, (void *)node, index___0, children);
  if (! (node->index_within_parent < (size_t )children->length)) {
    __assert_fail("node->index_within_parent < children->length", "deps/gumbo-parser/parser.c",
                  773U, "insert_node");
  }
  i = index___0 + 1;
  while ((unsigned int )i < children->length) {
    sibling = (GumboNode *)*(children->data + i);
    sibling->index_within_parent = (size_t )i;
    if (! (sibling->index_within_parent < (size_t )children->length)) {
      __assert_fail("sibling->index_within_parent < children->length", "deps/gumbo-parser/parser.c",
                    777U, "insert_node");
    }
    i ++;
  }
  return;
}
}
static void foster_parent_element(GumboParser *parser , GumboNode *node ) 
{ 
  GumboVector *open_elements ;
  GumboNode *foster_parent_element___0 ;
  _Bool tmp___4 ;
  int i ;
  GumboNode *table_element ;
  char const   *tmp___6 ;
  _Bool tmp___8 ;

  {
  open_elements = & (parser->_parser_state)->_open_elements;
  if (! (open_elements->length > 2U)) {
    __assert_fail("open_elements->length > 2", "deps/gumbo-parser/parser.c", 784U,
                  "foster_parent_element");
  }
  node->parse_flags = (GumboParseFlags )((unsigned int )node->parse_flags | 1024U);
  foster_parent_element___0 = (GumboNode *)*(open_elements->data + 0);
  if (! ((unsigned int )foster_parent_element___0->type == 1U)) {
    __assert_fail("foster_parent_element->type == GUMBO_NODE_ELEMENT", "deps/gumbo-parser/parser.c",
                  788U, "foster_parent_element");
  }
  tmp___4 = node_tag_is((GumboNode const   *)foster_parent_element___0, (GumboTag )0);
  if (! tmp___4) {
    __assert_fail("node_tag_is(foster_parent_element, GUMBO_TAG_HTML)", "deps/gumbo-parser/parser.c",
                  789U, "foster_parent_element");
  }
  i = (int )open_elements->length;
  while (1) {
    i --;
    if (! (i > 1)) {
      break;
    }
    table_element = (GumboNode *)*(open_elements->data + i);
    tmp___8 = node_tag_is((GumboNode const   *)table_element, (GumboTag )95);
    if (tmp___8) {
      foster_parent_element___0 = table_element->parent;
      if (! foster_parent_element___0) {
        gumbo_debug("Table has no parent.\n");
        foster_parent_element___0 = (GumboNode *)*(open_elements->data + (i - 1));
        break;
      } else
      if ((unsigned int )foster_parent_element___0->type != 1U) {
        gumbo_debug("Table has no parent.\n");
        foster_parent_element___0 = (GumboNode *)*(open_elements->data + (i - 1));
        break;
      }
      if (! ((unsigned int )foster_parent_element___0->type == 1U)) {
        __assert_fail("foster_parent_element->type == GUMBO_NODE_ELEMENT", "deps/gumbo-parser/parser.c",
                      802U, "foster_parent_element");
      }
      tmp___6 = gumbo_normalized_tagname(foster_parent_element___0->v.element.tag);
      gumbo_debug("Found enclosing table (%x) at %d; parent=%s, index=%d.\n", table_element,
                  i, tmp___6, table_element->index_within_parent);
      if (! ((unsigned long )*(foster_parent_element___0->v.element.children.data + table_element->index_within_parent) == (unsigned long )table_element)) {
        __assert_fail("foster_parent_element->v.element.children.data[ table_element->index_within_parent] == table_element",
                      "deps/gumbo-parser/parser.c", 808U, "foster_parent_element");
      }
      insert_node(parser, foster_parent_element___0, (int )table_element->index_within_parent,
                  node);
      return;
    }
  }
  if ((unsigned int )node->type == 1U) {
    gumbo_vector_add(parser, (void *)node, open_elements);
  }
  append_node(parser, foster_parent_element___0, node);
  return;
}
}
static void maybe_flush_text_node_buffer(GumboParser *parser ) 
{ 
  GumboParserState *state ;
  TextNodeBufferState *buffer_state ;
  GumboNode *text_node ;
  GumboNode *tmp___0 ;
  GumboText *text_node_data ;
  char *tmp___1 ;
  GumboNode *tmp___2 ;
  GumboNode *tmp___3 ;
  GumboNode *tmp___4 ;
  _Bool tmp___5 ;

  {
  state = parser->_parser_state;
  buffer_state = & state->_text_node;
  if (buffer_state->_buffer.length == 0UL) {
    return;
  }
  if (! ((unsigned int )buffer_state->_type == 5U)) {
    if (! ((unsigned int )buffer_state->_type == 2U)) {
      __assert_fail("buffer_state->_type == GUMBO_NODE_WHITESPACE || buffer_state->_type == GUMBO_NODE_TEXT",
                    "deps/gumbo-parser/parser.c", 828U, "maybe_flush_text_node_buffer");
    }
  }
  tmp___0 = create_node(parser, buffer_state->_type);
  text_node = tmp___0;
  text_node_data = & text_node->v.text;
  tmp___1 = gumbo_string_buffer_to_string(parser, & buffer_state->_buffer);
  text_node_data->text = (char const   *)tmp___1;
  text_node_data->original_text.data = buffer_state->_start_original_text;
  text_node_data->original_text.length = (size_t )((state->_current_token)->original_text.data - buffer_state->_start_original_text);
  text_node_data->start_pos = buffer_state->_start_position;
  if (state->_foster_parent_insertions) {
    tmp___4 = get_current_node(parser);
    tmp___5 = node_tag_in((GumboNode const   *)tmp___4, 95, 99, 101, 100, 102, 150);
    if (tmp___5) {
      foster_parent_element(parser, text_node);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if ((parser->_output)->root) {
      tmp___2 = get_current_node(parser);
      tmp___3 = tmp___2;
    } else {
      tmp___3 = (parser->_output)->document;
    }
    append_node(parser, tmp___3, text_node);
  }
  gumbo_debug("Flushing text node buffer of %.*s.\n", (int )buffer_state->_buffer.length,
              buffer_state->_buffer.data);
  gumbo_string_buffer_destroy(parser, & buffer_state->_buffer);
  gumbo_string_buffer_init(parser, & buffer_state->_buffer);
  buffer_state->_type = (GumboNodeType )5;
  if (! (buffer_state->_buffer.length == 0UL)) {
    __assert_fail("buffer_state->_buffer.length == 0", "deps/gumbo-parser/parser.c",
                  853U, "maybe_flush_text_node_buffer");
  }
  return;
}
}
static void record_end_of_element(GumboToken *current_token , GumboElement *element ) 
{ 


  {
  element->end_pos = current_token->position;
  if ((unsigned int )current_token->type == 2U) {
    element->original_end_tag = current_token->original_text;
  } else {
    element->original_end_tag = (GumboStringPiece )kGumboEmptyString;
  }
  return;
}
}
static GumboNode *pop_current_node(GumboParser *parser ) 
{ 
  GumboParserState *state ;
  _Bool tmp___2 ;
  GumboNode *tmp___3 ;
  char const   *tmp___4 ;
  GumboNode *current_node ;
  void *tmp___5 ;
  _Bool is_closed_body_or_html_tag ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;

  {
  state = parser->_parser_state;
  maybe_flush_text_node_buffer(parser);
  if (state->_open_elements.length > 0U) {
    tmp___2 = node_tag_is((GumboNode const   *)*(state->_open_elements.data + 0),
                          (GumboTag )0);
    if (! tmp___2) {
      __assert_fail("node_tag_is(state->_open_elements.data[0], GUMBO_TAG_HTML)",
                    "deps/gumbo-parser/parser.c", 868U, "pop_current_node");
    }
    tmp___3 = get_current_node(parser);
    tmp___4 = gumbo_normalized_tagname(tmp___3->v.element.tag);
    gumbo_debug("Popping %s node.\n", tmp___4);
  }
  tmp___5 = gumbo_vector_pop(parser, & state->_open_elements);
  current_node = (GumboNode *)tmp___5;
  if (! current_node) {
    if (! (state->_open_elements.length == 0U)) {
      __assert_fail("state->_open_elements.length == 0", "deps/gumbo-parser/parser.c",
                    875U, "pop_current_node");
    }
    return ((GumboNode *)((void *)0));
  }
  if (! ((unsigned int )current_node->type == 1U)) {
    __assert_fail("current_node->type == GUMBO_NODE_ELEMENT", "deps/gumbo-parser/parser.c",
                  878U, "pop_current_node");
  }
  tmp___8 = node_tag_is((GumboNode const   *)current_node, (GumboTag )10);
  if (tmp___8) {
    if (state->_closed_body_tag) {
      tmp___10 = 1;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___9 = node_tag_is((GumboNode const   *)current_node, (GumboTag )0);
    if (tmp___9) {
      if (state->_closed_html_tag) {
        tmp___10 = 1;
      } else {
        tmp___10 = 0;
      }
    } else {
      tmp___10 = 0;
    }
  }
  is_closed_body_or_html_tag = (_Bool )tmp___10;
  if ((unsigned int )(state->_current_token)->type != 2U) {
    goto _L___0;
  } else {
    tmp___11 = node_tag_is((GumboNode const   *)current_node, (state->_current_token)->v.end_tag);
    if (! tmp___11) {
      _L___0: /* CIL Label */ 
      if (! is_closed_body_or_html_tag) {
        current_node->parse_flags = (GumboParseFlags )((unsigned int )current_node->parse_flags | 2U);
      }
    }
  }
  if (! is_closed_body_or_html_tag) {
    record_end_of_element(state->_current_token, & current_node->v.element);
  }
  return (current_node);
}
}
static void append_comment_node(GumboParser *parser , GumboNode *node , GumboToken const   *token ) 
{ 
  GumboNode *comment ;
  GumboNode *tmp ;

  {
  maybe_flush_text_node_buffer(parser);
  tmp = create_node(parser, (GumboNodeType )4);
  comment = tmp;
  comment->type = (GumboNodeType )4;
  comment->parse_flags = (GumboParseFlags )0;
  comment->v.text.text = (char const   *)token->v.text;
  comment->v.text.original_text = (GumboStringPiece )token->original_text;
  comment->v.text.start_pos = (GumboSourcePosition )token->position;
  append_node(parser, node, comment);
  return;
}
}
static void clear_stack_to_table_row_context(GumboParser *parser ) 
{ 
  GumboNode *tmp ;
  _Bool tmp___0 ;

  {
  while (1) {
    tmp = get_current_node(parser);
    tmp___0 = node_tag_in((GumboNode const   *)tmp, 0, 102, 150);
    if (tmp___0) {
      break;
    }
    pop_current_node(parser);
  }
  return;
}
}
static void clear_stack_to_table_context(GumboParser *parser ) 
{ 
  GumboNode *tmp ;
  _Bool tmp___0 ;

  {
  while (1) {
    tmp = get_current_node(parser);
    tmp___0 = node_tag_in((GumboNode const   *)tmp, 0, 95, 150);
    if (tmp___0) {
      break;
    }
    pop_current_node(parser);
  }
  return;
}
}
void clear_stack_to_table_body_context(GumboParser *parser ) 
{ 
  GumboNode *tmp ;
  _Bool tmp___0 ;

  {
  while (1) {
    tmp = get_current_node(parser);
    tmp___0 = node_tag_in((GumboNode const   *)tmp, 0, 99, 101, 100, 150);
    if (tmp___0) {
      break;
    }
    pop_current_node(parser);
  }
  return;
}
}
static GumboNode *create_element(GumboParser *parser , GumboTag tag ) 
{ 
  GumboNode *node ;
  GumboNode *tmp ;
  GumboElement *element ;

  {
  tmp = create_node(parser, (GumboNodeType )1);
  node = tmp;
  element = & node->v.element;
  gumbo_vector_init(parser, (size_t )1, & element->children);
  gumbo_vector_init(parser, (size_t )0, & element->attributes);
  element->tag = tag;
  element->tag_namespace = (GumboNamespaceEnum )0;
  element->original_tag = (GumboStringPiece )kGumboEmptyString;
  element->original_end_tag = (GumboStringPiece )kGumboEmptyString;
  element->start_pos = ((parser->_parser_state)->_current_token)->position;
  element->end_pos = (GumboSourcePosition )kGumboEmptySourcePosition;
  return (node);
}
}
static GumboNode *create_element_from_token(GumboParser *parser , GumboToken *token ,
                                            GumboNamespaceEnum tag_namespace ) 
{ 
  GumboTokenStartTag *start_tag ;
  GumboNode *node ;
  GumboNode *tmp___0 ;
  GumboElement *element ;

  {
  if (! ((unsigned int )token->type == 1U)) {
    __assert_fail("token->type == GUMBO_TOKEN_START_TAG", "deps/gumbo-parser/parser.c",
                  948U, "create_element_from_token");
  }
  start_tag = & token->v.start_tag;
  tmp___0 = create_node(parser, (GumboNodeType )1);
  node = tmp___0;
  element = & node->v.element;
  gumbo_vector_init(parser, (size_t )1, & element->children);
  element->attributes = start_tag->attributes;
  element->tag = start_tag->tag;
  element->tag_namespace = tag_namespace;
  if (! (token->original_text.length >= 2UL)) {
    __assert_fail("token->original_text.length >= 2", "deps/gumbo-parser/parser.c",
                  958U, "create_element_from_token");
  }
  if (! ((int const   )*(token->original_text.data + 0) == 60)) {
    __assert_fail("token->original_text.data[0] == \'<\'", "deps/gumbo-parser/parser.c",
                  959U, "create_element_from_token");
  }
  if (! ((int const   )*(token->original_text.data + (token->original_text.length - 1UL)) == 62)) {
    __assert_fail("token->original_text.data[token->original_text.length - 1] == \'>\'",
                  "deps/gumbo-parser/parser.c", 960U, "create_element_from_token");
  }
  element->original_tag = token->original_text;
  element->start_pos = token->position;
  element->original_end_tag = (GumboStringPiece )kGumboEmptyString;
  element->end_pos = (GumboSourcePosition )kGumboEmptySourcePosition;
  start_tag->attributes = (GumboVector )kGumboEmptyVector;
  return (node);
}
}
static void insert_element(GumboParser *parser , GumboNode *node , _Bool is_reconstructing_formatting_elements ) 
{ 
  GumboParserState *state ;
  GumboNode *tmp ;
  _Bool tmp___0 ;
  GumboNode *tmp___1 ;
  GumboNode *tmp___2 ;

  {
  state = parser->_parser_state;
  if (! is_reconstructing_formatting_elements) {
    maybe_flush_text_node_buffer(parser);
  }
  if (state->_foster_parent_insertions) {
    tmp = get_current_node(parser);
    tmp___0 = node_tag_in((GumboNode const   *)tmp, 95, 99, 101, 100, 102, 150);
    if (tmp___0) {
      foster_parent_element(parser, node);
      gumbo_vector_add(parser, (void *)node, & state->_open_elements);
      return;
    }
  }
  if ((parser->_output)->root) {
    tmp___1 = get_current_node(parser);
    tmp___2 = tmp___1;
  } else {
    tmp___2 = (parser->_output)->document;
  }
  append_node(parser, tmp___2, node);
  gumbo_vector_add(parser, (void *)node, & state->_open_elements);
  return;
}
}
static GumboNode *insert_element_from_token(GumboParser *parser , GumboToken *token ) 
{ 
  GumboNode *element ;
  GumboNode *tmp ;
  char const   *tmp___0 ;

  {
  tmp = create_element_from_token(parser, token, (GumboNamespaceEnum )0);
  element = tmp;
  insert_element(parser, element, (_Bool)0);
  tmp___0 = gumbo_normalized_tagname(element->v.element.tag);
  gumbo_debug("Inserting <%s> element (@%x) from token.\n", tmp___0, element);
  return (element);
}
}
static GumboNode *insert_element_of_tag_type(GumboParser *parser , GumboTag tag ,
                                             GumboParseFlags reason ) 
{ 
  GumboNode *element ;
  GumboNode *tmp ;
  char const   *tmp___0 ;

  {
  tmp = create_element(parser, tag);
  element = tmp;
  element->parse_flags = (GumboParseFlags )((unsigned int )element->parse_flags | (1U | (unsigned int )reason));
  insert_element(parser, element, (_Bool)0);
  tmp___0 = gumbo_normalized_tagname(tag);
  gumbo_debug("Inserting %s element (@%x) from tag type.\n", tmp___0, element);
  return (element);
}
}
static GumboNode *insert_foreign_element(GumboParser *parser , GumboToken *token ,
                                         GumboNamespaceEnum tag_namespace ) 
{ 
  GumboNode *element ;
  GumboNode *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  if (! ((unsigned int )token->type == 1U)) {
    __assert_fail("token->type == GUMBO_TOKEN_START_TAG", "deps/gumbo-parser/parser.c",
                  1035U, "insert_foreign_element");
  }
  tmp___0 = create_element_from_token(parser, token, tag_namespace);
  element = tmp___0;
  insert_element(parser, element, (_Bool)0);
  tmp___1 = token_has_attribute((GumboToken const   *)token, "xmlns");
  if (tmp___1) {
    tmp___2 = attribute_matches_case_sensitive((GumboVector const   *)(& token->v.start_tag.attributes),
                                               "xmlns", kLegalXmlns[tag_namespace]);
    if (! tmp___2) {
      add_parse_error(parser, (GumboToken const   *)token);
    }
  }
  tmp___3 = token_has_attribute((GumboToken const   *)token, "xmlns:xlink");
  if (tmp___3) {
    tmp___4 = attribute_matches_case_sensitive((GumboVector const   *)(& token->v.start_tag.attributes),
                                               "xmlns:xlink", "http://www.w3.org/1999/xlink");
    if (! tmp___4) {
      add_parse_error(parser, (GumboToken const   *)token);
    }
  }
  return (element);
}
}
static void insert_text_token(GumboParser *parser , GumboToken *token ) 
{ 
  TextNodeBufferState *buffer_state ;

  {
  if (! ((unsigned int )token->type == 4U)) {
    if (! ((unsigned int )token->type == 5U)) {
      __assert_fail("token->type == GUMBO_TOKEN_WHITESPACE || token->type == GUMBO_TOKEN_CHARACTER",
                    "deps/gumbo-parser/parser.c", 1057U, "insert_text_token");
    }
  }
  buffer_state = & (parser->_parser_state)->_text_node;
  if (buffer_state->_buffer.length == 0UL) {
    buffer_state->_start_original_text = token->original_text.data;
    buffer_state->_start_position = token->position;
  }
  gumbo_string_buffer_append_codepoint(parser, token->v.character, & buffer_state->_buffer);
  if ((unsigned int )token->type == 5U) {
    buffer_state->_type = (GumboNodeType )2;
  }
  gumbo_debug("Inserting text token \'%c\'.\n", token->v.character);
  return;
}
}
static void run_generic_parsing_algorithm(GumboParser *parser , GumboToken *token ,
                                          GumboTokenizerEnum lexer_state ) 
{ 


  {
  insert_element_from_token(parser, token);
  gumbo_tokenizer_set_state(parser, lexer_state);
  (parser->_parser_state)->_original_insertion_mode = (parser->_parser_state)->_insertion_mode;
  (parser->_parser_state)->_insertion_mode = (GumboInsertionMode )7;
  return;
}
}
static void acknowledge_self_closing_tag(GumboParser *parser ) 
{ 


  {
  (parser->_parser_state)->_self_closing_flag_acknowledged = (_Bool)1;
  return;
}
}
static _Bool find_last_anchor_index(GumboParser *parser , int *anchor_index ) 
{ 
  GumboVector *elements ;
  int i ;
  GumboNode *node ;
  _Bool tmp ;

  {
  elements = & (parser->_parser_state)->_active_formatting_elements;
  i = (int )elements->length;
  while (1) {
    i --;
    if (! (i >= 0)) {
      break;
    }
    node = (GumboNode *)*(elements->data + i);
    if ((unsigned long )node == (unsigned long )(& kActiveFormattingScopeMarker)) {
      return ((_Bool)0);
    }
    tmp = node_tag_is((GumboNode const   *)node, (GumboTag )39);
    if (tmp) {
      *anchor_index = i;
      return ((_Bool)1);
    }
  }
  return ((_Bool)0);
}
}
static int count_formatting_elements_of_tag(GumboParser *parser , GumboNode const   *desired_node ,
                                            int *earliest_matching_index ) 
{ 
  GumboElement const   *desired_element ;
  GumboVector *elements ;
  int num_identical_elements ;
  int i ;
  GumboNode *node ;
  GumboElement *element ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  desired_element = & desired_node->v.element;
  elements = & (parser->_parser_state)->_active_formatting_elements;
  num_identical_elements = 0;
  i = (int )elements->length;
  while (1) {
    i --;
    if (! (i >= 0)) {
      break;
    }
    node = (GumboNode *)*(elements->data + i);
    if ((unsigned long )node == (unsigned long )(& kActiveFormattingScopeMarker)) {
      break;
    }
    if (! ((unsigned int )node->type == 1U)) {
      __assert_fail("node->type == GUMBO_NODE_ELEMENT", "deps/gumbo-parser/parser.c",
                    1118U, "count_formatting_elements_of_tag");
    }
    element = & node->v.element;
    tmp___0 = node_tag_is((GumboNode const   *)node, (GumboTag )desired_element->tag);
    if (tmp___0) {
      if ((unsigned int )element->tag_namespace == (unsigned int )desired_element->tag_namespace) {
        tmp___1 = all_attributes_match((GumboVector const   *)(& element->attributes),
                                       & desired_element->attributes);
        if (tmp___1) {
          num_identical_elements ++;
          *earliest_matching_index = i;
        }
      }
    }
  }
  return (num_identical_elements);
}
}
static void add_formatting_element(GumboParser *parser , GumboNode const   *node ) 
{ 
  GumboVector *elements ;
  int earliest_identical_element ;
  int num_identical_elements ;
  int tmp___0 ;

  {
  if (! ((unsigned long )node == (unsigned long )(& kActiveFormattingScopeMarker))) {
    if (! ((unsigned int const   )node->type == 1U)) {
      __assert_fail("node == &kActiveFormattingScopeMarker || node->type == GUMBO_NODE_ELEMENT",
                    "deps/gumbo-parser/parser.c", 1134U, "add_formatting_element");
    }
  }
  elements = & (parser->_parser_state)->_active_formatting_elements;
  if ((unsigned long )node == (unsigned long )(& kActiveFormattingScopeMarker)) {
    gumbo_debug("Adding a scope marker.\n");
  } else {
    gumbo_debug("Adding a formatting element.\n");
  }
  earliest_identical_element = (int )elements->length;
  tmp___0 = count_formatting_elements_of_tag(parser, node, & earliest_identical_element);
  num_identical_elements = tmp___0;
  if (num_identical_elements >= 3) {
    gumbo_debug("Noah\'s ark clause: removing element at %d.\n", earliest_identical_element);
    gumbo_vector_remove_at(parser, earliest_identical_element, elements);
  }
  gumbo_vector_add(parser, (void *)node, elements);
  return;
}
}
static _Bool is_open_element(GumboParser *parser , GumboNode const   *node ) 
{ 
  GumboVector *open_elements ;
  int i ;

  {
  open_elements = & (parser->_parser_state)->_open_elements;
  i = 0;
  while ((unsigned int )i < open_elements->length) {
    if ((unsigned long )*(open_elements->data + i) == (unsigned long )node) {
      return ((_Bool)1);
    }
    i ++;
  }
  return ((_Bool)0);
}
}
GumboNode *clone_node(GumboParser *parser , GumboNode const   *node , GumboParseFlags reason ) 
{ 
  GumboNode *new_node ;
  void *tmp___0 ;
  GumboElement *element ;
  GumboVector const   *old_attributes ;
  int i ;
  GumboAttribute const   *old_attr ;
  GumboAttribute *attr ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  if (! ((unsigned int const   )node->type == 1U)) {
    __assert_fail("node->type == GUMBO_NODE_ELEMENT", "deps/gumbo-parser/parser.c",
                  1172U, "clone_node");
  }
  tmp___0 = gumbo_parser_allocate(parser, sizeof(GumboNode ));
  new_node = (GumboNode *)tmp___0;
  *new_node = (GumboNode )*node;
  new_node->parent = (GumboNode *)((void *)0);
  new_node->index_within_parent = (size_t )-1;
  new_node->parse_flags = (GumboParseFlags )((unsigned int )new_node->parse_flags & 4294967293U);
  new_node->parse_flags = (GumboParseFlags )((unsigned int )new_node->parse_flags | ((unsigned int )reason | 1U));
  element = & new_node->v.element;
  gumbo_vector_init(parser, (size_t )1, & element->children);
  old_attributes = & node->v.element.attributes;
  gumbo_vector_init(parser, (size_t )old_attributes->length, & element->attributes);
  i = 0;
  while ((unsigned int const   )i < old_attributes->length) {
    old_attr = (GumboAttribute const   *)*(old_attributes->data + i);
    tmp___1 = gumbo_parser_allocate(parser, sizeof(GumboAttribute ));
    attr = (GumboAttribute *)tmp___1;
    *attr = (GumboAttribute )*old_attr;
    tmp___2 = gumbo_copy_stringz(parser, (char const   *)old_attr->name);
    attr->name = (char const   *)tmp___2;
    tmp___3 = gumbo_copy_stringz(parser, (char const   *)old_attr->value);
    attr->value = (char const   *)tmp___3;
    gumbo_vector_add(parser, (void *)attr, & element->attributes);
    i ++;
  }
  return (new_node);
}
}
static void reconstruct_active_formatting_elements(GumboParser *parser ) 
{ 
  GumboVector *elements ;
  int i ;
  GumboNode const   *element ;
  _Bool tmp ;
  _Bool tmp___0 ;
  GumboNode *tmp___1 ;
  char const   *tmp___2 ;
  GumboNode *clone ;
  GumboNode *tmp___6 ;
  char const   *tmp___7 ;

  {
  elements = & (parser->_parser_state)->_active_formatting_elements;
  if (elements->length == 0U) {
    return;
  }
  i = (int )(elements->length - 1U);
  element = (GumboNode const   *)*(elements->data + i);
  if ((unsigned long )element == (unsigned long )(& kActiveFormattingScopeMarker)) {
    return;
  } else {
    tmp = is_open_element(parser, element);
    if (tmp) {
      return;
    }
  }
  while (1) {
    if (i == 0) {
      i = -1;
      break;
    }
    i --;
    element = (GumboNode const   *)*(elements->data + i);
    if ((unsigned long )element != (unsigned long )(& kActiveFormattingScopeMarker)) {
      tmp___0 = is_open_element(parser, element);
      if (tmp___0) {
        break;
      }
    } else {
      break;
    }
  }
  i ++;
  tmp___1 = get_current_node(parser);
  tmp___2 = gumbo_normalized_tagname(tmp___1->v.element.tag);
  gumbo_debug("Reconstructing elements from %d on %s parent.\n", i, tmp___2);
  while ((unsigned int )i < elements->length) {
    if (! (elements->length > 0U)) {
      __assert_fail("elements->length > 0", "deps/gumbo-parser/parser.c", 1235U, "reconstruct_active_formatting_elements");
    }
    if (! ((unsigned int )i < elements->length)) {
      __assert_fail("i < elements->length", "deps/gumbo-parser/parser.c", 1236U, "reconstruct_active_formatting_elements");
    }
    element = (GumboNode const   *)*(elements->data + i);
    if (! ((unsigned long )element != (unsigned long )(& kActiveFormattingScopeMarker))) {
      __assert_fail("element != &kActiveFormattingScopeMarker", "deps/gumbo-parser/parser.c",
                    1238U, "reconstruct_active_formatting_elements");
    }
    tmp___6 = clone_node(parser, element, (GumboParseFlags )128);
    clone = tmp___6;
    insert_element(parser, clone, (_Bool)1);
    *(elements->data + i) = (void *)clone;
    tmp___7 = gumbo_normalized_tagname(clone->v.element.tag);
    gumbo_debug("Reconstructed %s element at %d.\n", tmp___7, i);
    i ++;
  }
  return;
}
}
static void clear_active_formatting_elements(GumboParser *parser ) 
{ 
  GumboVector *elements ;
  int num_elements_cleared ;
  GumboNode const   *node ;
  void *tmp ;

  {
  elements = & (parser->_parser_state)->_active_formatting_elements;
  num_elements_cleared = 0;
  while (1) {
    tmp = gumbo_vector_pop(parser, elements);
    node = (GumboNode const   *)tmp;
    num_elements_cleared ++;
    if (node) {
      if (! ((unsigned long )node != (unsigned long )(& kActiveFormattingScopeMarker))) {
        break;
      }
    } else {
      break;
    }
  }
  gumbo_debug("Cleared %d elements from active formatting list.\n", num_elements_cleared);
  return;
}
}
static GumboQuirksModeEnum compute_quirks_mode(GumboTokenDocType const   *doctype ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
  if (doctype->force_quirks) {
    return ((GumboQuirksModeEnum )1);
  } else {
    tmp___1 = strcmp((char const   *)doctype->name, (char const   *)kDoctypeHtml.data);
    if (tmp___1) {
      return ((GumboQuirksModeEnum )1);
    } else {
      tmp___2 = is_in_static_list((char const   *)doctype->public_identifier, kQuirksModePublicIdPrefixes,
                                  (_Bool)0);
      if (tmp___2) {
        return ((GumboQuirksModeEnum )1);
      } else {
        tmp___3 = is_in_static_list((char const   *)doctype->public_identifier, kQuirksModePublicIdExactMatches,
                                    (_Bool)1);
        if (tmp___3) {
          return ((GumboQuirksModeEnum )1);
        } else {
          tmp___4 = is_in_static_list((char const   *)doctype->system_identifier,
                                      kQuirksModeSystemIdExactMatches, (_Bool)1);
          if (tmp___4) {
            return ((GumboQuirksModeEnum )1);
          } else {
            tmp___5 = is_in_static_list((char const   *)doctype->public_identifier,
                                        kLimitedQuirksRequiresSystemIdPublicIdPrefixes,
                                        (_Bool)0);
            if (tmp___5) {
              if (! doctype->has_system_identifier) {
                return ((GumboQuirksModeEnum )1);
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              tmp = is_in_static_list((char const   *)doctype->public_identifier,
                                      kLimitedQuirksPublicIdPrefixes, (_Bool)0);
              if (tmp) {
                return ((GumboQuirksModeEnum )2);
              } else {
                tmp___0 = is_in_static_list((char const   *)doctype->public_identifier,
                                            kLimitedQuirksRequiresSystemIdPublicIdPrefixes,
                                            (_Bool)0);
                if (tmp___0) {
                  if (doctype->has_system_identifier) {
                    return ((GumboQuirksModeEnum )2);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return ((GumboQuirksModeEnum )0);
}
}
static _Bool has_an_element_in_specific_scope(GumboParser *parser , GumboVector *expected ,
                                              _Bool negate  , ...) 
{ 
  GumboVector *open_elements ;
  va_list args ;
  GumboVector tags ;
  GumboTag tag ;
  GumboTag tmp___0 ;
  GumboTag tmp___1 ;
  _Bool result ;
  int i ;
  GumboNode const   *node ;
  GumboTag node_tag ;
  int j ;
  GumboTag expected_tag ;
  _Bool found_tag ;
  int j___0 ;
  GumboTag tag___0 ;

  {
  open_elements = & (parser->_parser_state)->_open_elements;
  __builtin_va_start(args, negate);
  gumbo_vector_init(parser, (size_t )10, & tags);
  tmp___0 = __builtin_va_arg(args, GumboTag );
  tag = tmp___0;
  while ((unsigned int )tag != 150U) {
    gumbo_vector_add(parser, (void *)tag, & tags);
    tmp___1 = __builtin_va_arg(args, GumboTag );
    tag = tmp___1;
  }
  __builtin_va_end(args);
  result = (_Bool)0;
  i = (int )open_elements->length;
  while (1) {
    i --;
    if (! (i >= 0)) {
      break;
    }
    node = (GumboNode const   *)*(open_elements->data + i);
    if ((unsigned int const   )node->type != 1U) {
      goto __Cont;
    }
    node_tag = (GumboTag )node->v.element.tag;
    j = 0;
    while ((unsigned int )j < expected->length) {
      expected_tag = (GumboTag )*(expected->data + j);
      if ((unsigned int )node_tag == (unsigned int )expected_tag) {
        result = (_Bool)1;
        goto cleanup;
      }
      j ++;
    }
    found_tag = (_Bool)0;
    j___0 = 0;
    while ((unsigned int )j___0 < tags.length) {
      tag___0 = (GumboTag )*(tags.data + j___0);
      if ((unsigned int )tag___0 == (unsigned int )node_tag) {
        found_tag = (_Bool)1;
        break;
      }
      j___0 ++;
    }
    if ((int )negate != (int )found_tag) {
      result = (_Bool)0;
      goto cleanup;
    }
    __Cont: /* CIL Label */ ;
  }
  cleanup: 
  gumbo_vector_destroy(parser, & tags);
  return (result);
}
}
static _Bool has_an_element_in_scope(GumboParser *parser , GumboTag tag ) 
{ 
  void *tags_tmp_array[1] ;
  GumboVector tags ;
  _Bool tmp ;

  {
  tags_tmp_array[0] = (void *)tag;
  tags.data = tags_tmp_array;
  tags.length = 1U;
  tags.capacity = 1U;
  tmp = has_an_element_in_specific_scope(parser, & tags, (_Bool)0, 124, 96, 0, 95,
                                         103, 104, 144, 74, 84, 85, 86, 87, 88, 91,
                                         93, 94, 2, 150);
  return (tmp);
}
}
static _Bool has_node_in_scope(GumboParser *parser , GumboNode const   *node ) 
{ 
  GumboVector *open_elements ;
  int i ;
  GumboNode const   *current ;
  _Bool tmp ;

  {
  open_elements = & (parser->_parser_state)->_open_elements;
  i = (int )open_elements->length;
  while (1) {
    i --;
    if (! (i >= 0)) {
      break;
    }
    current = (GumboNode const   *)*(open_elements->data + i);
    if ((unsigned long )current == (unsigned long )node) {
      return ((_Bool)1);
    }
    if ((unsigned int const   )current->type != 1U) {
      goto __Cont;
    }
    tmp = node_tag_in(current, 124, 96, 0, 95, 103, 104, 144, 74, 84, 85, 86, 87,
                      88, 91, 93, 94, 2, 150);
    if (tmp) {
      return ((_Bool)0);
    }
    __Cont: /* CIL Label */ ;
  }
  __assert_fail("false", "deps/gumbo-parser/parser.c", 1396U, "has_node_in_scope");
  return ((_Bool)0);
}
}
static _Bool has_an_element_in_scope_with_tagname(GumboParser *parser  , ...) 
{ 
  GumboVector tags ;
  va_list args ;
  GumboTag tag ;
  GumboTag tmp___0 ;
  GumboTag tmp___1 ;
  _Bool found ;
  _Bool tmp___2 ;

  {
  gumbo_vector_init(parser, (size_t )6, & tags);
  __builtin_va_start(args, parser);
  tmp___0 = __builtin_va_arg(args, GumboTag );
  tag = tmp___0;
  while ((unsigned int )tag != 150U) {
    gumbo_vector_add(parser, (void *)tag, & tags);
    tmp___1 = __builtin_va_arg(args, GumboTag );
    tag = tmp___1;
  }
  tmp___2 = has_an_element_in_specific_scope(parser, & tags, (_Bool)0, 124, 96, 0,
                                             95, 103, 104, 144, 74, 84, 85, 86, 87,
                                             88, 91, 93, 94, 2, 150);
  found = tmp___2;
  gumbo_vector_destroy(parser, & tags);
  __builtin_va_end(args);
  return (found);
}
}
static _Bool has_an_element_in_list_scope(GumboParser *parser , GumboTag tag ) 
{ 
  void *tags_tmp_array[1] ;
  GumboVector tags ;
  _Bool tmp ;

  {
  tags_tmp_array[0] = (void *)tag;
  tags.data = tags_tmp_array;
  tags.length = 1U;
  tags.capacity = 1U;
  tmp = has_an_element_in_specific_scope(parser, & tags, (_Bool)0, 124, 96, 0, 95,
                                         103, 104, 144, 74, 84, 85, 86, 87, 88, 91,
                                         93, 94, 2, 29, 30, 150);
  return (tmp);
}
}
static _Bool has_an_element_in_button_scope(GumboParser *parser , GumboTag tag ) 
{ 
  void *tags_tmp_array[1] ;
  GumboVector tags ;
  _Bool tmp ;

  {
  tags_tmp_array[0] = (void *)tag;
  tags.data = tags_tmp_array;
  tags.length = 1U;
  tags.capacity = 1U;
  tmp = has_an_element_in_specific_scope(parser, & tags, (_Bool)0, 124, 96, 0, 95,
                                         103, 104, 144, 74, 84, 85, 86, 87, 88, 91,
                                         93, 94, 2, 110, 150);
  return (tmp);
}
}
static _Bool has_an_element_in_table_scope(GumboParser *parser , GumboTag tag ) 
{ 
  void *tags_tmp_array[1] ;
  GumboVector tags ;
  _Bool tmp ;

  {
  tags_tmp_array[0] = (void *)tag;
  tags.data = tags_tmp_array;
  tags.length = 1U;
  tags.capacity = 1U;
  tmp = has_an_element_in_specific_scope(parser, & tags, (_Bool)0, 0, 95, 150);
  return (tmp);
}
}
static _Bool has_an_element_in_select_scope(GumboParser *parser , GumboTag tag ) 
{ 
  void *tags_tmp_array[1] ;
  GumboVector tags ;
  _Bool tmp ;

  {
  tags_tmp_array[0] = (void *)tag;
  tags.data = tags_tmp_array;
  tags.length = 1U;
  tags.capacity = 1U;
  tmp = has_an_element_in_specific_scope(parser, & tags, (_Bool)1, 113, 114, 150);
  return (tmp);
}
}
static void generate_implied_end_tags(GumboParser *parser , GumboTag exception ) 
{ 
  GumboNode *tmp ;
  _Bool tmp___0 ;
  GumboNode *tmp___1 ;
  _Bool tmp___2 ;

  {
  while (1) {
    tmp = get_current_node(parser);
    tmp___0 = node_tag_in((GumboNode const   *)tmp, 34, 33, 31, 114, 113, 25, 62,
                          61, 150);
    if (tmp___0) {
      tmp___1 = get_current_node(parser);
      tmp___2 = node_tag_is((GumboNode const   *)tmp___1, exception);
      if (tmp___2) {
        break;
      }
    } else {
      break;
    }
    pop_current_node(parser);
  }
  return;
}
}
static _Bool close_table(GumboParser *parser ) 
{ 
  _Bool tmp ;
  GumboNode *node ;
  GumboNode *tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = has_an_element_in_table_scope(parser, (GumboTag )95);
  if (! tmp) {
    return ((_Bool)0);
  }
  tmp___0 = pop_current_node(parser);
  node = tmp___0;
  while (1) {
    tmp___1 = node_tag_is((GumboNode const   *)node, (GumboTag )95);
    if (tmp___1) {
      break;
    }
    node = pop_current_node(parser);
  }
  reset_insertion_mode_appropriately(parser);
  return ((_Bool)1);
}
}
static _Bool close_table_cell(GumboParser *parser , GumboToken const   *token , GumboTag cell_tag ) 
{ 
  _Bool result ;
  GumboNode const   *node ;
  GumboNode *tmp ;
  _Bool tmp___0 ;
  GumboNode *tmp___1 ;
  _Bool tmp___2 ;

  {
  result = (_Bool)1;
  generate_implied_end_tags(parser, (GumboTag )150);
  tmp = get_current_node(parser);
  node = (GumboNode const   *)tmp;
  tmp___0 = node_tag_is(node, cell_tag);
  if (! tmp___0) {
    add_parse_error(parser, token);
    result = (_Bool)0;
  }
  while (1) {
    tmp___1 = pop_current_node(parser);
    node = (GumboNode const   *)tmp___1;
    tmp___2 = node_tag_is(node, cell_tag);
    if (tmp___2) {
      break;
    }
  }
  clear_active_formatting_elements(parser);
  set_insertion_mode(parser, (GumboInsertionMode )13);
  return (result);
}
}
static _Bool close_current_cell(GumboParser *parser , GumboToken const   *token ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;

  {
  tmp___9 = has_an_element_in_table_scope(parser, (GumboTag )103);
  if (tmp___9) {
    tmp___2 = has_an_element_in_table_scope(parser, (GumboTag )104);
    if (tmp___2) {
      __assert_fail("!has_an_element_in_table_scope(parser, GUMBO_TAG_TH)", "deps/gumbo-parser/parser.c",
                    1516U, "close_current_cell");
    }
    tmp___3 = close_table_cell(parser, token, (GumboTag )103);
    return (tmp___3);
  } else {
    tmp___7 = has_an_element_in_table_scope(parser, (GumboTag )104);
    if (! tmp___7) {
      __assert_fail("has_an_element_in_table_scope(parser, GUMBO_TAG_TH)", "deps/gumbo-parser/parser.c",
                    1519U, "close_current_cell");
    }
    tmp___8 = close_table_cell(parser, token, (GumboTag )104);
    return (tmp___8);
  }
}
}
static void close_current_select(GumboParser *parser ) 
{ 
  GumboNode *node ;
  GumboNode *tmp ;
  _Bool tmp___0 ;

  {
  tmp = pop_current_node(parser);
  node = tmp;
  while (1) {
    tmp___0 = node_tag_is((GumboNode const   *)node, (GumboTag )111);
    if (tmp___0) {
      break;
    }
    node = pop_current_node(parser);
  }
  reset_insertion_mode_appropriately(parser);
  return;
}
}
static _Bool is_special_node(GumboNode const   *node ) 
{ 
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  if (! ((unsigned int const   )node->type == 1U)) {
    __assert_fail("node->type == GUMBO_NODE_ELEMENT", "deps/gumbo-parser/parser.c",
                  1539U, "is_special_node");
  }
  switch ((unsigned int const   )node->v.element.tag_namespace) {
  case 0U: 
  tmp___0 = node_tag_in(node, 24, 124, 82, 11, 14, 3, 139, 126, 28, 10, 66, 110, 96,
                        142, 98, 97, 123, 34, 120, 127, 38, 32, 33, 73, 106, 36, 35,
                        23, 105, 128, 129, 15, 16, 17, 18, 19, 20, 1, 22, 21, 26,
                        0, 72, 71, 109, 131, 31, 4, 132, 144, 122, 5, 13, 135, 130,
                        8, 74, 29, 25, 75, 136, 27, 7, 12, 111, 6, 121, 95, 99, 103,
                        115, 101, 104, 100, 2, 102, 30, 67, 133, 150);
  return (tmp___0);
  case 2U: 
  tmp___1 = node_tag_in(node, 84, 85, 86, 87, 88, 91, 150);
  return (tmp___1);
  case 1U: 
  tmp___2 = node_tag_in(node, 93, 94, 150);
  return (tmp___2);
  }
  abort();
  return ((_Bool)0);
}
}
static _Bool implicitly_close_tags(GumboParser *parser , GumboToken *token , GumboTag target ) 
{ 
  _Bool result ;
  GumboNode *tmp ;
  _Bool tmp___0 ;
  GumboNode *tmp___1 ;
  _Bool tmp___2 ;
  GumboNode *tmp___8 ;
  _Bool tmp___9 ;

  {
  result = (_Bool)1;
  generate_implied_end_tags(parser, target);
  tmp___1 = get_current_node(parser);
  tmp___2 = node_tag_is((GumboNode const   *)tmp___1, target);
  if (! tmp___2) {
    add_parse_error(parser, (GumboToken const   *)token);
    while (1) {
      tmp = get_current_node(parser);
      tmp___0 = node_tag_is((GumboNode const   *)tmp, target);
      if (tmp___0) {
        break;
      }
      pop_current_node(parser);
    }
    result = (_Bool)0;
  }
  tmp___8 = get_current_node(parser);
  tmp___9 = node_tag_is((GumboNode const   *)tmp___8, target);
  if (! tmp___9) {
    __assert_fail("node_tag_is(get_current_node(parser), target)", "deps/gumbo-parser/parser.c",
                  1592U, "implicitly_close_tags");
  }
  pop_current_node(parser);
  return (result);
}
}
static _Bool maybe_implicitly_close_p_tag(GumboParser *parser , GumboToken *token ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  tmp___0 = has_an_element_in_button_scope(parser, (GumboTag )25);
  if (tmp___0) {
    tmp = implicitly_close_tags(parser, token, (GumboTag )25);
    return (tmp);
  }
  return ((_Bool)1);
}
}
static void maybe_implicitly_close_list_tag(GumboParser *parser , GumboToken *token ,
                                            _Bool is_li ) 
{ 
  GumboParserState *state ;
  int i ;
  GumboNode const   *node ;
  _Bool is_list_tag ;
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  state = parser->_parser_state;
  state->_frameset_ok = (_Bool)0;
  i = (int )state->_open_elements.length;
  while (1) {
    i --;
    if (! (i >= 0)) {
      break;
    }
    node = (GumboNode const   *)*(state->_open_elements.data + i);
    if (is_li) {
      tmp = node_tag_is(node, (GumboTag )31);
      tmp___1 = (int )tmp;
    } else {
      tmp___0 = node_tag_in(node, 34, 33, 150);
      tmp___1 = (int )tmp___0;
    }
    is_list_tag = (_Bool )tmp___1;
    if (is_list_tag) {
      implicitly_close_tags(parser, token, (GumboTag )node->v.element.tag);
      return;
    }
    tmp___2 = is_special_node(node);
    if (tmp___2) {
      tmp___3 = node_tag_in(node, 24, 38, 25, 150);
      if (! tmp___3) {
        return;
      }
    }
  }
  return;
}
}
static void merge_attributes(GumboParser *parser , GumboToken *token , GumboNode *node ) 
{ 
  GumboVector const   *token_attr ;
  GumboVector *node_attr ;
  int i ;
  GumboAttribute *attr ;
  GumboAttribute *tmp___1 ;

  {
  if (! ((unsigned int )token->type == 1U)) {
    __assert_fail("token->type == GUMBO_TOKEN_START_TAG", "deps/gumbo-parser/parser.c",
                  1633U, "merge_attributes");
  }
  if (! ((unsigned int )node->type == 1U)) {
    __assert_fail("node->type == GUMBO_NODE_ELEMENT", "deps/gumbo-parser/parser.c",
                  1634U, "merge_attributes");
  }
  token_attr = (GumboVector const   *)(& token->v.start_tag.attributes);
  node_attr = & node->v.element.attributes;
  i = 0;
  while ((unsigned int const   )i < token_attr->length) {
    attr = (GumboAttribute *)*(token_attr->data + i);
    tmp___1 = gumbo_get_attribute((GumboVector const   *)node_attr, attr->name);
    if (! tmp___1) {
      gumbo_vector_add(parser, (void *)attr, node_attr);
      *(token_attr->data + i) = (void *)0;
    }
    i ++;
  }
  gumbo_token_destroy(parser, token);
  token->v.start_tag.attributes = (GumboVector )kGumboEmptyVector;
  return;
}
}
char const   *gumbo_normalize_svg_tagname(GumboStringPiece const   *tag ) 
{ 
  int i ;
  ReplacementEntry const   *entry ;
  _Bool tmp ;

  {
  i = 0;
  while ((unsigned long )i < sizeof(kSvgTagReplacements) / sizeof(ReplacementEntry )) {
    entry = & kSvgTagReplacements[i];
    tmp = gumbo_string_equals_ignore_case(tag, & entry->from);
    if (tmp) {
      return ((char const   *)entry->to.data);
    }
    i ++;
  }
  return ((char const   *)((void *)0));
}
}
static void adjust_foreign_attributes(GumboParser *parser , GumboToken *token ) 
{ 
  GumboVector const   *attributes ;
  int i ;
  NamespacedAttributeReplacement const   *entry ;
  GumboAttribute *attr ;
  GumboAttribute *tmp___0 ;
  char *tmp___1 ;

  {
  if (! ((unsigned int )token->type == 1U)) {
    __assert_fail("token->type == GUMBO_TOKEN_START_TAG", "deps/gumbo-parser/parser.c",
                  1676U, "adjust_foreign_attributes");
  }
  attributes = (GumboVector const   *)(& token->v.start_tag.attributes);
  i = 0;
  while ((unsigned long )i < sizeof(kForeignAttributeReplacements) / sizeof(NamespacedAttributeReplacement )) {
    entry = & kForeignAttributeReplacements[i];
    tmp___0 = gumbo_get_attribute(attributes, (char const   *)entry->from);
    attr = tmp___0;
    if (! attr) {
      goto __Cont;
    }
    gumbo_parser_deallocate(parser, (void *)attr->name);
    attr->attr_namespace = (GumboAttributeNamespaceEnum )entry->attr_namespace;
    tmp___1 = gumbo_copy_stringz(parser, (char const   *)entry->local_name);
    attr->name = (char const   *)tmp___1;
    __Cont: /* CIL Label */ 
    i ++;
  }
  return;
}
}
static void adjust_svg_attributes(GumboParser *parser , GumboToken *token ) 
{ 
  GumboVector const   *attributes ;
  int i ;
  ReplacementEntry const   *entry ;
  GumboAttribute *attr ;
  GumboAttribute *tmp___0 ;
  char *tmp___1 ;

  {
  if (! ((unsigned int )token->type == 1U)) {
    __assert_fail("token->type == GUMBO_TOKEN_START_TAG", "deps/gumbo-parser/parser.c",
                  1696U, "adjust_svg_attributes");
  }
  attributes = (GumboVector const   *)(& token->v.start_tag.attributes);
  i = 0;
  while ((unsigned long )i < sizeof(kSvgAttributeReplacements) / sizeof(ReplacementEntry )) {
    entry = & kSvgAttributeReplacements[i];
    tmp___0 = gumbo_get_attribute(attributes, (char const   *)entry->from.data);
    attr = tmp___0;
    if (! attr) {
      goto __Cont;
    }
    gumbo_parser_deallocate(parser, (void *)attr->name);
    tmp___1 = gumbo_copy_stringz(parser, (char const   *)entry->to.data);
    attr->name = (char const   *)tmp___1;
    __Cont: /* CIL Label */ 
    i ++;
  }
  return;
}
}
static void adjust_mathml_attributes(GumboParser *parser , GumboToken *token ) 
{ 
  GumboAttribute *attr ;
  GumboAttribute *tmp___0 ;
  char *tmp___1 ;

  {
  if (! ((unsigned int )token->type == 1U)) {
    __assert_fail("token->type == GUMBO_TOKEN_START_TAG", "deps/gumbo-parser/parser.c",
                  1714U, "adjust_mathml_attributes");
  }
  tmp___0 = gumbo_get_attribute((GumboVector const   *)(& token->v.start_tag.attributes),
                                "definitionurl");
  attr = tmp___0;
  if (! attr) {
    return;
  }
  gumbo_parser_deallocate(parser, (void *)attr->name);
  tmp___1 = gumbo_copy_stringz(parser, "definitionURL");
  attr->name = (char const   *)tmp___1;
  return;
}
}
static _Bool doctype_matches(GumboTokenDocType const   *doctype , GumboStringPiece const   *public_id ,
                             GumboStringPiece const   *system_id , _Bool allow_missing_system_id ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = strcmp((char const   *)doctype->public_identifier, (char const   *)public_id->data);
  if (tmp) {
    tmp___1 = 0;
  } else
  if (allow_missing_system_id) {
    goto _L;
  } else
  if (doctype->has_system_identifier) {
    _L: /* CIL Label */ 
    tmp___0 = strcmp((char const   *)doctype->system_identifier, (char const   *)system_id->data);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  } else {
    tmp___1 = 0;
  }
  return ((_Bool )tmp___1);
}
}
static _Bool maybe_add_doctype_error(GumboParser *parser , GumboToken const   *token ) 
{ 
  GumboTokenDocType const   *doctype ;
  _Bool html_doctype ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
  doctype = & token->v.doc_type;
  tmp = strcmp((char const   *)doctype->name, (char const   *)kDoctypeHtml.data);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  html_doctype = (_Bool )tmp___0;
  if (! html_doctype) {
    add_parse_error(parser, token);
    return ((_Bool)0);
  } else
  if (doctype->has_public_identifier) {
    add_parse_error(parser, token);
    return ((_Bool)0);
  } else
  if (doctype->has_system_identifier) {
    tmp___1 = strcmp((char const   *)doctype->system_identifier, (char const   *)kSystemIdLegacyCompat.data);
    if (tmp___1) {
      goto _L;
    } else {
      add_parse_error(parser, token);
      return ((_Bool)0);
    }
  } else
  _L: /* CIL Label */ 
  if (html_doctype) {
    tmp___2 = doctype_matches(doctype, & kPublicIdHtml4_0, & kSystemIdRecHtml4_0,
                              (_Bool)1);
    if (! tmp___2) {
      tmp___3 = doctype_matches(doctype, & kPublicIdHtml4_01, & kSystemIdHtml4, (_Bool)1);
      if (! tmp___3) {
        tmp___4 = doctype_matches(doctype, & kPublicIdXhtml1_0, & kSystemIdXhtmlStrict1_1,
                                  (_Bool)0);
        if (! tmp___4) {
          tmp___5 = doctype_matches(doctype, & kPublicIdXhtml1_1, & kSystemIdXhtml1_1,
                                    (_Bool)0);
          if (! tmp___5) {
            add_parse_error(parser, token);
            return ((_Bool)0);
          }
        }
      }
    }
  } else {
    add_parse_error(parser, token);
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
static void remove_from_parent(GumboParser *parser , GumboNode *node ) 
{ 
  GumboVector *children ;
  int index___0 ;
  int tmp___0 ;
  int i ;
  GumboNode *child ;

  {
  if (! node->parent) {
    return;
  }
  if (! ((unsigned int )(node->parent)->type == 1U)) {
    __assert_fail("node->parent->type == GUMBO_NODE_ELEMENT", "deps/gumbo-parser/parser.c",
                  1764U, "remove_from_parent");
  }
  children = & (node->parent)->v.element.children;
  tmp___0 = gumbo_vector_index_of(children, (void *)node);
  index___0 = tmp___0;
  if (! (index___0 != -1)) {
    __assert_fail("index != -1", "deps/gumbo-parser/parser.c", 1767U, "remove_from_parent");
  }
  gumbo_vector_remove_at(parser, index___0, children);
  node->parent = (GumboNode *)((void *)0);
  node->index_within_parent = (size_t )-1;
  i = index___0;
  while ((unsigned int )i < children->length) {
    child = (GumboNode *)*(children->data + i);
    child->index_within_parent = (size_t )i;
    i ++;
  }
  return;
}
}
static _Bool adoption_agency_algorithm(GumboParser *parser , GumboToken *token , GumboTag closing_tag ) 
{ 
  GumboParserState *state ;
  int i ;
  GumboNode *formatting_node ;
  int formatting_node_in_open_elements ;
  int j ;
  GumboNode *current_node ;
  char const   *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  GumboNode *tmp___2 ;
  _Bool tmp___7 ;
  _Bool tmp___11 ;
  GumboNode *furthest_block ;
  int j___0 ;
  GumboNode *current ;
  _Bool tmp___13 ;
  GumboNode *tmp___14 ;
  _Bool tmp___18 ;
  GumboNode *common_ancestor ;
  int tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  int bookmark ;
  int tmp___23 ;
  GumboNode *node ;
  GumboNode *last_node ;
  int saved_node_index ;
  int tmp___24 ;
  int j___1 ;
  int node_index ;
  int tmp___26 ;
  int tmp___30 ;
  int formatting_index ;
  int tmp___31 ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  _Bool tmp___35 ;
  GumboNode *new_formatting_node ;
  GumboNode *tmp___36 ;
  GumboVector temp ;
  int i___0 ;
  GumboNode *child ;
  int formatting_node_index ;
  int tmp___37 ;
  int insert_at ;
  int tmp___41 ;

  {
  state = parser->_parser_state;
  gumbo_debug("Entering adoption agency algorithm.\n");
  i = 0;
  while (i < 8) {
    formatting_node = (GumboNode *)((void *)0);
    formatting_node_in_open_elements = -1;
    j = (int )state->_active_formatting_elements.length;
    while (1) {
      j --;
      if (! (j >= 0)) {
        break;
      }
      current_node = (GumboNode *)*(state->_active_formatting_elements.data + j);
      if ((unsigned long )current_node == (unsigned long )(& kActiveFormattingScopeMarker)) {
        gumbo_debug("Broke on scope marker; aborting.\n");
        return ((_Bool)0);
      }
      tmp___0 = node_tag_is((GumboNode const   *)current_node, closing_tag);
      if (tmp___0) {
        formatting_node = current_node;
        formatting_node_in_open_elements = gumbo_vector_index_of(& state->_open_elements,
                                                                 (void *)formatting_node);
        tmp = gumbo_normalized_tagname(closing_tag);
        gumbo_debug("Formatting element of tag %s at %d.\n", tmp, formatting_node_in_open_elements);
        break;
      }
    }
    if (! formatting_node) {
      gumbo_debug("No active formatting elements; aborting.\n");
      return ((_Bool)0);
    }
    if (formatting_node_in_open_elements == -1) {
      gumbo_debug("Formatting node not on stack of open elements.\n");
      gumbo_vector_remove(parser, (void *)formatting_node, & state->_active_formatting_elements);
      return ((_Bool)0);
    }
    tmp___1 = has_an_element_in_scope(parser, formatting_node->v.element.tag);
    if (! tmp___1) {
      add_parse_error(parser, (GumboToken const   *)token);
      gumbo_debug("Element not in scope.\n");
      return ((_Bool)0);
    }
    tmp___2 = get_current_node(parser);
    if ((unsigned long )formatting_node != (unsigned long )tmp___2) {
      add_parse_error(parser, (GumboToken const   *)token);
    }
    if (! formatting_node) {
      __assert_fail("formatting_node", "deps/gumbo-parser/parser.c", 1830U, "adoption_agency_algorithm");
    }
    tmp___7 = node_tag_is((GumboNode const   *)formatting_node, (GumboTag )0);
    if (tmp___7) {
      __assert_fail("!node_tag_is(formatting_node, GUMBO_TAG_HTML)", "deps/gumbo-parser/parser.c",
                    1831U, "adoption_agency_algorithm");
    }
    tmp___11 = node_tag_is((GumboNode const   *)formatting_node, (GumboTag )10);
    if (tmp___11) {
      __assert_fail("!node_tag_is(formatting_node, GUMBO_TAG_BODY)", "deps/gumbo-parser/parser.c",
                    1832U, "adoption_agency_algorithm");
    }
    furthest_block = (GumboNode *)((void *)0);
    j___0 = formatting_node_in_open_elements;
    while ((unsigned int )j___0 < state->_open_elements.length) {
      if (! (j___0 > 0)) {
        __assert_fail("j > 0", "deps/gumbo-parser/parser.c", 1838U, "adoption_agency_algorithm");
      }
      current = (GumboNode *)*(state->_open_elements.data + j___0);
      tmp___13 = is_special_node((GumboNode const   *)current);
      if (tmp___13) {
        furthest_block = current;
        break;
      }
      j___0 ++;
    }
    if (! furthest_block) {
      while (1) {
        tmp___14 = get_current_node(parser);
        if (! ((unsigned long )tmp___14 != (unsigned long )formatting_node)) {
          break;
        }
        pop_current_node(parser);
      }
      pop_current_node(parser);
      gumbo_vector_remove(parser, (void *)formatting_node, & state->_active_formatting_elements);
      return ((_Bool)0);
    }
    tmp___18 = node_tag_is((GumboNode const   *)furthest_block, (GumboTag )0);
    if (tmp___18) {
      __assert_fail("!node_tag_is(furthest_block, GUMBO_TAG_HTML)", "deps/gumbo-parser/parser.c",
                    1857U, "adoption_agency_algorithm");
    }
    if (! furthest_block) {
      __assert_fail("furthest_block", "deps/gumbo-parser/parser.c", 1858U, "adoption_agency_algorithm");
    }
    tmp___20 = gumbo_vector_index_of(& state->_open_elements, (void *)formatting_node);
    common_ancestor = (GumboNode *)*(state->_open_elements.data + (tmp___20 - 1));
    tmp___21 = gumbo_normalized_tagname(furthest_block->v.element.tag);
    tmp___22 = gumbo_normalized_tagname(common_ancestor->v.element.tag);
    gumbo_debug("Common ancestor tag = %s, furthest block tag = %s.\n", tmp___22,
                tmp___21);
    tmp___23 = gumbo_vector_index_of(& state->_active_formatting_elements, (void *)formatting_node);
    bookmark = tmp___23;
    node = furthest_block;
    last_node = furthest_block;
    tmp___24 = gumbo_vector_index_of(& state->_open_elements, (void *)node);
    saved_node_index = tmp___24;
    if (! (saved_node_index > 0)) {
      __assert_fail("saved_node_index > 0", "deps/gumbo-parser/parser.c", 1879U, "adoption_agency_algorithm");
    }
    j___1 = 0;
    while (j___1 < 3) {
      tmp___26 = gumbo_vector_index_of(& state->_open_elements, (void *)node);
      node_index = tmp___26;
      gumbo_debug("Current index: %d, last index: %d.\n", node_index, saved_node_index);
      if (node_index == -1) {
        node_index = saved_node_index;
      }
      node_index --;
      saved_node_index = node_index;
      if (! (node_index > 0)) {
        __assert_fail("node_index > 0", "deps/gumbo-parser/parser.c", 1890U, "adoption_agency_algorithm");
      }
      if (! ((unsigned int )node_index < state->_open_elements.capacity)) {
        __assert_fail("node_index < state->_open_elements.capacity", "deps/gumbo-parser/parser.c",
                      1891U, "adoption_agency_algorithm");
      }
      node = (GumboNode *)*(state->_open_elements.data + node_index);
      if (! node->parent) {
        __assert_fail("node->parent", "deps/gumbo-parser/parser.c", 1893U, "adoption_agency_algorithm");
      }
      tmp___30 = gumbo_vector_index_of(& state->_active_formatting_elements, (void *)node);
      if (tmp___30 == -1) {
        gumbo_vector_remove_at(parser, node_index, & state->_open_elements);
        goto __Cont;
      } else
      if ((unsigned long )node == (unsigned long )formatting_node) {
        break;
      }
      tmp___31 = gumbo_vector_index_of(& state->_active_formatting_elements, (void *)node);
      formatting_index = tmp___31;
      node = clone_node(parser, (GumboNode const   *)node, (GumboParseFlags )256);
      *(state->_active_formatting_elements.data + formatting_index) = (void *)node;
      *(state->_open_elements.data + node_index) = (void *)node;
      if ((unsigned long )last_node == (unsigned long )furthest_block) {
        bookmark = formatting_index + 1;
        if (! ((unsigned int )bookmark <= state->_active_formatting_elements.length)) {
          __assert_fail("bookmark <= state->_active_formatting_elements.length", "deps/gumbo-parser/parser.c",
                        1912U, "adoption_agency_algorithm");
        }
      }
      last_node->parse_flags = (GumboParseFlags )((unsigned int )last_node->parse_flags | 512U);
      remove_from_parent(parser, last_node);
      append_node(parser, node, last_node);
      last_node = node;
      __Cont: /* CIL Label */ 
      j___1 ++;
    }
    tmp___33 = gumbo_normalized_tagname(last_node->v.element.tag);
    gumbo_debug("Removing %s node from parent ", tmp___33);
    remove_from_parent(parser, last_node);
    last_node->parse_flags = (GumboParseFlags )((unsigned int )last_node->parse_flags | 512U);
    tmp___35 = node_tag_in((GumboNode const   *)common_ancestor, 95, 99, 101, 100,
                           102, 150);
    if (tmp___35) {
      gumbo_debug("and foster-parenting it.\n");
      foster_parent_element(parser, last_node);
    } else {
      tmp___34 = gumbo_normalized_tagname(common_ancestor->v.element.tag);
      gumbo_debug("and inserting it into %s.\n", tmp___34);
      append_node(parser, common_ancestor, last_node);
    }
    tmp___36 = clone_node(parser, (GumboNode const   *)formatting_node, (GumboParseFlags )256);
    new_formatting_node = tmp___36;
    formatting_node->parse_flags = (GumboParseFlags )((unsigned int )formatting_node->parse_flags | 2U);
    temp = new_formatting_node->v.element.children;
    new_formatting_node->v.element.children = furthest_block->v.element.children;
    furthest_block->v.element.children = temp;
    temp = new_formatting_node->v.element.children;
    i___0 = 0;
    while ((unsigned int )i___0 < temp.length) {
      child = (GumboNode *)*(temp.data + i___0);
      child->parent = new_formatting_node;
      i___0 ++;
    }
    append_node(parser, furthest_block, new_formatting_node);
    tmp___37 = gumbo_vector_index_of(& state->_active_formatting_elements, (void *)formatting_node);
    formatting_node_index = tmp___37;
    if (! (formatting_node_index != -1)) {
      __assert_fail("formatting_node_index != -1", "deps/gumbo-parser/parser.c", 1967U,
                    "adoption_agency_algorithm");
    }
    if (formatting_node_index < bookmark) {
      bookmark --;
    }
    gumbo_vector_remove_at(parser, formatting_node_index, & state->_active_formatting_elements);
    if (! (bookmark >= 0)) {
      __assert_fail("bookmark >= 0", "deps/gumbo-parser/parser.c", 1973U, "adoption_agency_algorithm");
    }
    if (! ((unsigned int )bookmark <= state->_active_formatting_elements.length)) {
      __assert_fail("bookmark <= state->_active_formatting_elements.length", "deps/gumbo-parser/parser.c",
                    1974U, "adoption_agency_algorithm");
    }
    gumbo_vector_insert_at(parser, (void *)new_formatting_node, bookmark, & state->_active_formatting_elements);
    gumbo_vector_remove(parser, (void *)formatting_node, & state->_open_elements);
    tmp___41 = gumbo_vector_index_of(& state->_open_elements, (void *)furthest_block);
    insert_at = tmp___41 + 1;
    if (! (insert_at >= 0)) {
      __assert_fail("insert_at >= 0", "deps/gumbo-parser/parser.c", 1983U, "adoption_agency_algorithm");
    }
    if (! ((unsigned int )insert_at <= state->_open_elements.length)) {
      __assert_fail("insert_at <= state->_open_elements.length", "deps/gumbo-parser/parser.c",
                    1984U, "adoption_agency_algorithm");
    }
    gumbo_vector_insert_at(parser, (void *)new_formatting_node, insert_at, & state->_open_elements);
    i ++;
  }
  return ((_Bool)1);
}
}
static void ignore_token(GumboParser *parser ) 
{ 
  GumboToken *token ;

  {
  token = (parser->_parser_state)->_current_token;
  gumbo_token_destroy(parser, token);
  if ((unsigned int )token->type == 1U) {
    token->v.start_tag.attributes = (GumboVector )kGumboEmptyVector;
  }
  return;
}
}
static void finish_parsing(GumboParser *parser ) 
{ 
  GumboParserState *state ;
  GumboNode *node ;
  GumboNode *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  GumboNode *tmp___2 ;

  {
  maybe_flush_text_node_buffer(parser);
  state = parser->_parser_state;
  tmp = pop_current_node(parser);
  node = tmp;
  while (node) {
    tmp___0 = node_tag_is((GumboNode const   *)node, (GumboTag )10);
    if (tmp___0) {
      if (state->_closed_body_tag) {
        goto __Cont;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      tmp___1 = node_tag_is((GumboNode const   *)node, (GumboTag )0);
      if (tmp___1) {
        if (state->_closed_html_tag) {
          goto __Cont;
        }
      }
    }
    node->parse_flags = (GumboParseFlags )((unsigned int )node->parse_flags | 2U);
    __Cont: /* CIL Label */ 
    node = pop_current_node(parser);
  }
  while (1) {
    tmp___2 = pop_current_node(parser);
    if (! tmp___2) {
      break;
    }
  }
  return;
}
}
static _Bool handle_initial(GumboParser *parser , GumboToken *token ) 
{ 
  GumboDocument *document ;
  GumboNode *tmp ;
  GumboNode *tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = get_document_node(parser);
  document = & tmp->v.document;
  if ((unsigned int )token->type == 4U) {
    ignore_token(parser);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 3U) {
    tmp___0 = get_document_node(parser);
    append_comment_node(parser, tmp___0, (GumboToken const   *)token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 0U) {
    document->has_doctype = (_Bool)1;
    document->name = token->v.doc_type.name;
    document->public_identifier = token->v.doc_type.public_identifier;
    document->system_identifier = token->v.doc_type.system_identifier;
    document->doc_type_quirks_mode = compute_quirks_mode((GumboTokenDocType const   *)(& token->v.doc_type));
    set_insertion_mode(parser, (GumboInsertionMode )1);
    tmp___1 = maybe_add_doctype_error(parser, (GumboToken const   *)token);
    return (tmp___1);
  }
  add_parse_error(parser, (GumboToken const   *)token);
  document->doc_type_quirks_mode = (GumboQuirksModeEnum )1;
  set_insertion_mode(parser, (GumboInsertionMode )1);
  (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
  return ((_Bool)1);
}
}
static _Bool handle_before_html(GumboParser *parser , GumboToken *token ) 
{ 
  GumboNode *tmp ;
  GumboNode *html_node ;
  GumboNode *tmp___0 ;
  GumboNode *html_node___0 ;
  GumboNode *tmp___1 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  if ((unsigned int )token->type == 0U) {
    add_parse_error(parser, (GumboToken const   *)token);
    ignore_token(parser);
    return ((_Bool)0);
  } else
  if ((unsigned int )token->type == 3U) {
    tmp = get_document_node(parser);
    append_comment_node(parser, tmp, (GumboToken const   *)token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 4U) {
    ignore_token(parser);
    return ((_Bool)1);
  } else {
    tmp___4 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )0);
    if (tmp___4) {
      tmp___0 = insert_element_from_token(parser, token);
      html_node = tmp___0;
      (parser->_output)->root = html_node;
      set_insertion_mode(parser, (GumboInsertionMode )2);
      return ((_Bool)1);
    } else
    if ((unsigned int )token->type == 2U) {
      tmp___3 = tag_in((GumboToken const   *)token, (_Bool)0, 1, 10, 0, 66, 150);
      if (tmp___3) {
        goto _L;
      } else {
        add_parse_error(parser, (GumboToken const   *)token);
        ignore_token(parser);
        return ((_Bool)0);
      }
    } else {
      _L: /* CIL Label */ 
      tmp___1 = insert_element_of_tag_type(parser, (GumboTag )0, (GumboParseFlags )8);
      html_node___0 = tmp___1;
      if (! html_node___0) {
        __assert_fail("html_node", "deps/gumbo-parser/parser.c", 2073U, "handle_before_html");
      }
      (parser->_output)->root = html_node___0;
      set_insertion_mode(parser, (GumboInsertionMode )2);
      (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
      return ((_Bool)1);
    }
  }
}
}
static _Bool handle_before_head(GumboParser *parser , GumboToken *token ) 
{ 
  GumboNode *tmp ;
  GumboNode *node ;
  GumboNode *tmp___0 ;
  GumboNode *node___0 ;
  GumboNode *tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  if ((unsigned int )token->type == 0U) {
    add_parse_error(parser, (GumboToken const   *)token);
    ignore_token(parser);
    return ((_Bool)0);
  } else
  if ((unsigned int )token->type == 3U) {
    tmp = get_current_node(parser);
    append_comment_node(parser, tmp, (GumboToken const   *)token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 4U) {
    ignore_token(parser);
    return ((_Bool)1);
  } else {
    tmp___3 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )1);
    if (tmp___3) {
      tmp___0 = insert_element_from_token(parser, token);
      node = tmp___0;
      set_insertion_mode(parser, (GumboInsertionMode )3);
      (parser->_parser_state)->_head_element = node;
      return ((_Bool)1);
    } else
    if ((unsigned int )token->type == 2U) {
      tmp___2 = tag_in((GumboToken const   *)token, (_Bool)0, 1, 10, 0, 66, 150);
      if (tmp___2) {
        goto _L;
      } else {
        add_parse_error(parser, (GumboToken const   *)token);
        ignore_token(parser);
        return ((_Bool)0);
      }
    } else {
      _L: /* CIL Label */ 
      tmp___1 = insert_element_of_tag_type(parser, (GumboTag )1, (GumboParseFlags )8);
      node___0 = tmp___1;
      set_insertion_mode(parser, (GumboInsertionMode )3);
      (parser->_parser_state)->_head_element = node___0;
      (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
      return ((_Bool)1);
    }
  }
}
}
static _Bool handle_token(GumboParser *parser , GumboToken *token ) ;
static _Bool handle_in_body(GumboParser *parser , GumboToken *token ) ;
static _Bool handle_in_head(GumboParser *parser , GumboToken *token ) 
{ 
  GumboNode *tmp ;
  _Bool tmp___0 ;
  GumboNode *head ;
  GumboNode *tmp___1 ;
  _Bool tmp___5 ;
  GumboNode const   *node ;
  GumboNode *tmp___6 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  _Bool tmp___18 ;
  _Bool tmp___19 ;
  _Bool tmp___20 ;
  _Bool tmp___21 ;

  {
  if ((unsigned int )token->type == 4U) {
    insert_text_token(parser, token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 0U) {
    add_parse_error(parser, (GumboToken const   *)token);
    ignore_token(parser);
    return ((_Bool)0);
  } else
  if ((unsigned int )token->type == 3U) {
    tmp = get_current_node(parser);
    append_comment_node(parser, tmp, (GumboToken const   *)token);
    return ((_Bool)1);
  } else {
    tmp___21 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )0);
    if (tmp___21) {
      tmp___0 = handle_in_body(parser, token);
      return (tmp___0);
    } else {
      tmp___20 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 3, 139, 126,
                        123, 4, 150);
      if (tmp___20) {
        insert_element_from_token(parser, token);
        pop_current_node(parser);
        acknowledge_self_closing_tag(parser);
        return ((_Bool)1);
      } else {
        tmp___19 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )5);
        if (tmp___19) {
          insert_element_from_token(parser, token);
          pop_current_node(parser);
          acknowledge_self_closing_tag(parser);
          return ((_Bool)1);
        } else {
          tmp___18 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )2);
          if (tmp___18) {
            run_generic_parsing_algorithm(parser, token, (GumboTokenizerEnum )2);
            return ((_Bool)1);
          } else {
            tmp___17 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 130,
                              6, 150);
            if (tmp___17) {
              run_generic_parsing_algorithm(parser, token, (GumboTokenizerEnum )4);
              return ((_Bool)1);
            } else {
              tmp___16 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )8);
              if (tmp___16) {
                insert_element_from_token(parser, token);
                set_insertion_mode(parser, (GumboInsertionMode )4);
                return ((_Bool)1);
              } else {
                tmp___15 = tag_is((GumboToken const   *)token, (_Bool )kStartTag,
                                  (GumboTag )7);
                if (tmp___15) {
                  run_generic_parsing_algorithm(parser, token, (GumboTokenizerEnum )5);
                  return ((_Bool)1);
                } else {
                  tmp___14 = tag_is((GumboToken const   *)token, (_Bool )kEndTag,
                                    (GumboTag )1);
                  if (tmp___14) {
                    tmp___1 = pop_current_node(parser);
                    head = tmp___1;
                    tmp___5 = node_tag_is((GumboNode const   *)head, (GumboTag )1);
                    if (! tmp___5) {
                      __assert_fail("node_tag_is(head, GUMBO_TAG_HEAD)", "deps/gumbo-parser/parser.c",
                                    2165U, "handle_in_head");
                    }
                    set_insertion_mode(parser, (GumboInsertionMode )5);
                    return ((_Bool)1);
                  } else {
                    tmp___13 = tag_is((GumboToken const   *)token, (_Bool )kStartTag,
                                      (GumboTag )1);
                    if (tmp___13) {
                      add_parse_error(parser, (GumboToken const   *)token);
                      ignore_token(parser);
                      return ((_Bool)0);
                    } else {
                      tmp___11 = tag_is((GumboToken const   *)token, (_Bool )kStartTag,
                                        (GumboTag )1);
                      if (tmp___11) {
                        add_parse_error(parser, (GumboToken const   *)token);
                        return ((_Bool)0);
                      } else
                      if ((unsigned int )token->type == 2U) {
                        tmp___12 = tag_in((GumboToken const   *)token, (_Bool )kEndTag,
                                          10, 0, 66, 150);
                        if (tmp___12) {
                          goto _L;
                        } else {
                          add_parse_error(parser, (GumboToken const   *)token);
                          return ((_Bool)0);
                        }
                      } else {
                        _L: /* CIL Label */ 
                        tmp___6 = pop_current_node(parser);
                        node = (GumboNode const   *)tmp___6;
                        tmp___10 = node_tag_is(node, (GumboTag )1);
                        if (! tmp___10) {
                          __assert_fail("node_tag_is(node, GUMBO_TAG_HEAD)", "deps/gumbo-parser/parser.c",
                                        2180U, "handle_in_head");
                        }
                        set_insertion_mode(parser, (GumboInsertionMode )5);
                        (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
                        return ((_Bool)1);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return ((_Bool)1);
}
}
static _Bool handle_in_head_noscript(GumboParser *parser , GumboToken *token ) 
{ 
  _Bool tmp ;
  GumboNode const   *node ;
  GumboNode *tmp___0 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  GumboNode const   *node___0 ;
  GumboNode *tmp___6 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;

  {
  if ((unsigned int )token->type == 0U) {
    add_parse_error(parser, (GumboToken const   *)token);
    return ((_Bool)0);
  } else {
    tmp___15 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )0);
    if (tmp___15) {
      tmp = handle_in_body(parser, token);
      return (tmp);
    } else {
      tmp___14 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )8);
      if (tmp___14) {
        tmp___0 = pop_current_node(parser);
        node = (GumboNode const   *)tmp___0;
        tmp___4 = node_tag_is(node, (GumboTag )8);
        if (! tmp___4) {
          __assert_fail("node_tag_is(node, GUMBO_TAG_NOSCRIPT)", "deps/gumbo-parser/parser.c",
                        2199U, "handle_in_head_noscript");
        }
        set_insertion_mode(parser, (GumboInsertionMode )3);
        return ((_Bool)1);
      } else
      if ((unsigned int )token->type == 4U) {
        tmp___5 = handle_in_head(parser, token);
        return (tmp___5);
      } else
      if ((unsigned int )token->type == 3U) {
        tmp___5 = handle_in_head(parser, token);
        return (tmp___5);
      } else {
        tmp___13 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 139, 126,
                          4, 5, 130, 6, 150);
        if (tmp___13) {
          tmp___5 = handle_in_head(parser, token);
          return (tmp___5);
        } else {
          tmp___11 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 1, 8,
                            150);
          if (tmp___11) {
            add_parse_error(parser, (GumboToken const   *)token);
            ignore_token(parser);
            return ((_Bool)0);
          } else
          if ((unsigned int )token->type == 2U) {
            tmp___12 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )66);
            if (tmp___12) {
              goto _L;
            } else {
              add_parse_error(parser, (GumboToken const   *)token);
              ignore_token(parser);
              return ((_Bool)0);
            }
          } else {
            _L: /* CIL Label */ 
            add_parse_error(parser, (GumboToken const   *)token);
            tmp___6 = pop_current_node(parser);
            node___0 = (GumboNode const   *)tmp___6;
            tmp___10 = node_tag_is(node___0, (GumboTag )8);
            if (! tmp___10) {
              __assert_fail("node_tag_is(node, GUMBO_TAG_NOSCRIPT)", "deps/gumbo-parser/parser.c",
                            2219U, "handle_in_head_noscript");
            }
            set_insertion_mode(parser, (GumboInsertionMode )3);
            (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
            return ((_Bool)0);
          }
        }
      }
    }
  }
}
}
static _Bool handle_after_head(GumboParser *parser , GumboToken *token ) 
{ 
  GumboParserState *state ;
  GumboNode *tmp ;
  _Bool tmp___0 ;
  _Bool result ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
  state = parser->_parser_state;
  if ((unsigned int )token->type == 4U) {
    insert_text_token(parser, token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 0U) {
    add_parse_error(parser, (GumboToken const   *)token);
    ignore_token(parser);
    return ((_Bool)0);
  } else
  if ((unsigned int )token->type == 3U) {
    tmp = get_current_node(parser);
    append_comment_node(parser, tmp, (GumboToken const   *)token);
    return ((_Bool)1);
  } else {
    tmp___8 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )0);
    if (tmp___8) {
      tmp___0 = handle_in_body(parser, token);
      return (tmp___0);
    } else {
      tmp___7 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )10);
      if (tmp___7) {
        insert_element_from_token(parser, token);
        state->_frameset_ok = (_Bool)0;
        set_insertion_mode(parser, (GumboInsertionMode )6);
        return ((_Bool)1);
      } else {
        tmp___6 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )129);
        if (tmp___6) {
          insert_element_from_token(parser, token);
          set_insertion_mode(parser, (GumboInsertionMode )19);
          return ((_Bool)1);
        } else {
          tmp___5 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 3, 139,
                           126, 4, 5, 130, 7, 6, 2, 150);
          if (tmp___5) {
            add_parse_error(parser, (GumboToken const   *)token);
            if (! ((unsigned long )state->_head_element != (unsigned long )((void *)0))) {
              __assert_fail("state->_head_element != NULL", "deps/gumbo-parser/parser.c",
                            2256U, "handle_after_head");
            }
            maybe_flush_text_node_buffer(parser);
            gumbo_vector_add(parser, (void *)state->_head_element, & state->_open_elements);
            tmp___2 = handle_in_head(parser, token);
            result = tmp___2;
            gumbo_vector_remove(parser, (void *)state->_head_element, & state->_open_elements);
            return (result);
          } else {
            tmp___3 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )1);
            if (tmp___3) {
              add_parse_error(parser, (GumboToken const   *)token);
              ignore_token(parser);
              return ((_Bool)0);
            } else
            if ((unsigned int )token->type == 2U) {
              tmp___4 = tag_in((GumboToken const   *)token, (_Bool )kEndTag, 10, 0,
                               66, 150);
              if (tmp___4) {
                insert_element_of_tag_type(parser, (GumboTag )10, (GumboParseFlags )8);
                set_insertion_mode(parser, (GumboInsertionMode )6);
                state->_reprocess_current_token = (_Bool)1;
                return ((_Bool)1);
              } else {
                add_parse_error(parser, (GumboToken const   *)token);
                ignore_token(parser);
                return ((_Bool)0);
              }
            } else {
              insert_element_of_tag_type(parser, (GumboTag )10, (GumboParseFlags )8);
              set_insertion_mode(parser, (GumboInsertionMode )6);
              state->_reprocess_current_token = (_Bool)1;
              return ((_Bool)1);
            }
          }
        }
      }
    }
  }
}
}
static void destroy_node(GumboParser *parser , GumboNode *node ) 
{ 
  GumboDocument *doc ;
  int i ;
  int i___0 ;
  int i___1 ;

  {
  switch ((unsigned int )node->type) {
  case 0U: 
  doc = & node->v.document;
  i = 0;
  while ((unsigned int )i < doc->children.length) {
    destroy_node(parser, (GumboNode *)*(doc->children.data + i));
    i ++;
  }
  gumbo_parser_deallocate(parser, (void *)doc->children.data);
  gumbo_parser_deallocate(parser, (void *)doc->name);
  gumbo_parser_deallocate(parser, (void *)doc->public_identifier);
  gumbo_parser_deallocate(parser, (void *)doc->system_identifier);
  break;
  case 1U: 
  i___0 = 0;
  while ((unsigned int )i___0 < node->v.element.attributes.length) {
    gumbo_destroy_attribute(parser, (GumboAttribute *)*(node->v.element.attributes.data + i___0));
    i___0 ++;
  }
  gumbo_parser_deallocate(parser, (void *)node->v.element.attributes.data);
  i___1 = 0;
  while ((unsigned int )i___1 < node->v.element.children.length) {
    destroy_node(parser, (GumboNode *)*(node->v.element.children.data + i___1));
    i___1 ++;
  }
  gumbo_parser_deallocate(parser, (void *)node->v.element.children.data);
  break;
  case 5U: 
  case 4U: 
  case 3U: 
  case 2U: 
  gumbo_parser_deallocate(parser, (void *)node->v.text.text);
  break;
  }
  gumbo_parser_deallocate(parser, (void *)node);
  return;
}
}
static _Bool handle_in_body(GumboParser *parser , GumboToken *token ) 
{ 
  GumboParserState *state ;
  GumboNode *tmp___0 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  GumboNode *body_node ;
  GumboNode *node ;
  GumboVector *children ;
  int i ;
  int i___0 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool success ;
  int i___1 ;
  _Bool tmp___8 ;
  GumboNode *body ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  _Bool result ;
  _Bool tmp___14 ;
  _Bool result___0 ;
  _Bool tmp___15 ;
  GumboNode *tmp___16 ;
  _Bool tmp___17 ;
  _Bool result___1 ;
  _Bool tmp___18 ;
  _Bool result___2 ;
  _Bool tmp___19 ;
  _Bool result___3 ;
  _Bool tmp___20 ;
  _Bool result___4 ;
  _Bool tmp___21 ;
  _Bool result___5 ;
  _Bool tmp___22 ;
  _Bool tmp___23 ;
  GumboTag tag ;
  _Bool tmp___24 ;
  _Bool result___6 ;
  GumboNode const   *node___0 ;
  _Bool tmp___26 ;
  GumboNode *tmp___27 ;
  GumboVector *open_elements ;
  int index___0 ;
  _Bool tmp___29 ;
  _Bool tmp___30 ;
  _Bool tmp___31 ;
  _Bool tmp___32 ;
  GumboTag token_tag ;
  _Bool tmp___34 ;
  _Bool tmp___35 ;
  GumboNode const   *current_node ;
  GumboNode *tmp___36 ;
  _Bool success___0 ;
  _Bool tmp___37 ;
  GumboNode *tmp___38 ;
  _Bool tmp___39 ;
  _Bool tmp___40 ;
  _Bool success___1 ;
  int last_a ;
  int has_matching_a ;
  _Bool tmp___41 ;
  void *last_element ;
  void *tmp___43 ;
  _Bool tmp___44 ;
  GumboNode *tmp___45 ;
  GumboNode *tmp___46 ;
  _Bool result___7 ;
  _Bool tmp___47 ;
  GumboNode *tmp___48 ;
  _Bool tmp___49 ;
  GumboTag token_tag___0 ;
  _Bool tmp___50 ;
  GumboNode *tmp___51 ;
  _Bool success___2 ;
  _Bool tmp___52 ;
  GumboNode *node___1 ;
  GumboNode *tmp___53 ;
  _Bool tmp___54 ;
  _Bool tmp___55 ;
  _Bool result___8 ;
  _Bool tmp___56 ;
  GumboVector *token_attrs ;
  GumboAttribute *prompt_attr ;
  GumboAttribute *tmp___57 ;
  GumboAttribute *action_attr ;
  GumboAttribute *tmp___58 ;
  GumboAttribute *name_attr ;
  GumboAttribute *tmp___59 ;
  GumboNode *form ;
  GumboNode *tmp___60 ;
  TextNodeBufferState *text_state ;
  int prompt_attr_length ;
  size_t tmp___61 ;
  GumboStringPiece prompt_text ;
  GumboNode *input ;
  GumboNode *tmp___62 ;
  int i___2 ;
  GumboAttribute *attr ;
  GumboAttribute *name ;
  void *tmp___63 ;
  GumboStringPiece name_str ;
  GumboStringPiece isindex_str ;
  char *tmp___64 ;
  char *tmp___65 ;
  _Bool result___9 ;
  _Bool tmp___66 ;
  GumboInsertionMode state___0 ;
  GumboNode *tmp___67 ;
  _Bool tmp___68 ;
  _Bool success___3 ;
  _Bool tmp___69 ;
  GumboNode *tmp___70 ;
  _Bool tmp___71 ;
  GumboTag end_tag ;
  _Bool tmp___77 ;
  int i___3 ;
  GumboNode const   *node___2 ;
  GumboNode *tmp___78 ;
  _Bool tmp___79 ;
  _Bool tmp___80 ;
  _Bool tmp___81 ;
  _Bool tmp___82 ;
  _Bool tmp___83 ;
  _Bool tmp___84 ;
  _Bool tmp___85 ;
  _Bool tmp___86 ;
  _Bool tmp___87 ;
  _Bool tmp___88 ;
  _Bool tmp___89 ;
  _Bool tmp___90 ;
  _Bool tmp___91 ;
  _Bool tmp___92 ;
  _Bool tmp___93 ;
  _Bool tmp___94 ;
  _Bool tmp___95 ;
  _Bool tmp___96 ;
  _Bool tmp___97 ;
  _Bool tmp___98 ;
  _Bool tmp___99 ;
  _Bool tmp___100 ;
  _Bool tmp___101 ;
  _Bool tmp___102 ;
  _Bool tmp___103 ;
  _Bool tmp___104 ;
  _Bool tmp___105 ;
  _Bool tmp___106 ;
  _Bool tmp___107 ;
  _Bool tmp___108 ;
  _Bool tmp___109 ;
  _Bool tmp___110 ;
  _Bool tmp___111 ;
  _Bool tmp___112 ;
  _Bool tmp___113 ;
  _Bool tmp___114 ;
  _Bool tmp___115 ;
  _Bool tmp___116 ;
  _Bool tmp___117 ;
  _Bool tmp___118 ;
  _Bool tmp___119 ;
  _Bool tmp___120 ;
  _Bool tmp___121 ;
  _Bool tmp___122 ;

  {
  state = parser->_parser_state;
  if (! (state->_open_elements.length > 0U)) {
    __assert_fail("state->_open_elements.length > 0", "deps/gumbo-parser/parser.c",
                  2316U, "handle_in_body");
  }
  if ((unsigned int )token->type == 6U) {
    add_parse_error(parser, (GumboToken const   *)token);
    ignore_token(parser);
    return ((_Bool)0);
  } else
  if ((unsigned int )token->type == 4U) {
    reconstruct_active_formatting_elements(parser);
    insert_text_token(parser, token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 5U) {
    reconstruct_active_formatting_elements(parser);
    insert_text_token(parser, token);
    set_frameset_not_ok(parser);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 3U) {
    tmp___0 = get_current_node(parser);
    append_comment_node(parser, tmp___0, (GumboToken const   *)token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 0U) {
    add_parse_error(parser, (GumboToken const   *)token);
    ignore_token(parser);
    return ((_Bool)0);
  } else {
    tmp___122 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )0);
    if (tmp___122) {
      if (! ((unsigned long )(parser->_output)->root != (unsigned long )((void *)0))) {
        __assert_fail("parser->_output->root != NULL", "deps/gumbo-parser/parser.c",
                      2338U, "handle_in_body");
      }
      if (! ((unsigned int )((parser->_output)->root)->type == 1U)) {
        __assert_fail("parser->_output->root->type == GUMBO_NODE_ELEMENT", "deps/gumbo-parser/parser.c",
                      2339U, "handle_in_body");
      }
      add_parse_error(parser, (GumboToken const   *)token);
      merge_attributes(parser, token, (parser->_output)->root);
      return ((_Bool)0);
    } else {
      tmp___121 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 3, 139, 126,
                         123, 4, 5, 130, 7, 6, 2, 150);
      if (tmp___121) {
        tmp___3 = handle_in_head(parser, token);
        return (tmp___3);
      } else {
        tmp___120 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )10);
        if (tmp___120) {
          add_parse_error(parser, (GumboToken const   *)token);
          if (state->_open_elements.length < 2U) {
            ignore_token(parser);
            return ((_Bool)0);
          } else {
            tmp___4 = node_tag_is((GumboNode const   *)*(state->_open_elements.data + 1),
                                  (GumboTag )10);
            if (! tmp___4) {
              ignore_token(parser);
              return ((_Bool)0);
            }
          }
          state->_frameset_ok = (_Bool)0;
          merge_attributes(parser, token, (GumboNode *)*(state->_open_elements.data + 1));
          return ((_Bool)0);
        } else {
          tmp___119 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )129);
          if (tmp___119) {
            add_parse_error(parser, (GumboToken const   *)token);
            if (state->_open_elements.length < 2U) {
              ignore_token(parser);
              return ((_Bool)0);
            } else {
              tmp___5 = node_tag_is((GumboNode const   *)*(state->_open_elements.data + 1),
                                    (GumboTag )10);
              if (tmp___5) {
                if (! state->_frameset_ok) {
                  ignore_token(parser);
                  return ((_Bool)0);
                }
              } else {
                ignore_token(parser);
                return ((_Bool)0);
              }
            }
            body_node = (GumboNode *)*(state->_open_elements.data + 1);
            while (1) {
              node = pop_current_node(parser);
              if (! ((unsigned long )node != (unsigned long )*(state->_open_elements.data + 1))) {
                break;
              }
            }
            children = & ((parser->_output)->root)->v.element.children;
            i = 0;
            while ((unsigned int )i < children->length) {
              if ((unsigned long )*(children->data + i) == (unsigned long )body_node) {
                gumbo_vector_remove_at(parser, i, children);
                break;
              }
              i ++;
            }
            destroy_node(parser, body_node);
            insert_element_from_token(parser, token);
            set_insertion_mode(parser, (GumboInsertionMode )19);
            return ((_Bool)1);
          } else
          if ((unsigned int )token->type == 7U) {
            i___0 = 0;
            while ((unsigned int )i___0 < state->_open_elements.length) {
              tmp___6 = node_tag_in((GumboNode const   *)*(state->_open_elements.data + i___0),
                                    34, 33, 31, 25, 99, 103, 101, 104, 100, 102, 10,
                                    0, 150);
              if (! tmp___6) {
                add_parse_error(parser, (GumboToken const   *)token);
                return ((_Bool)0);
              }
              i___0 ++;
            }
            return ((_Bool)1);
          } else {
            tmp___118 = tag_in((GumboToken const   *)token, (_Bool )kEndTag, 10, 0,
                               150);
            if (tmp___118) {
              tmp___7 = has_an_element_in_scope(parser, (GumboTag )10);
              if (! tmp___7) {
                add_parse_error(parser, (GumboToken const   *)token);
                ignore_token(parser);
                return ((_Bool)0);
              }
              success = (_Bool)1;
              i___1 = 0;
              while ((unsigned int )i___1 < state->_open_elements.length) {
                tmp___8 = node_tag_in((GumboNode const   *)*(state->_open_elements.data + i___1),
                                      34, 33, 31, 113, 114, 25, 62, 61, 99, 103, 101,
                                      104, 100, 102, 10, 0, 150);
                if (! tmp___8) {
                  add_parse_error(parser, (GumboToken const   *)token);
                  success = (_Bool)0;
                  break;
                }
                i___1 ++;
              }
              set_insertion_mode(parser, (GumboInsertionMode )18);
              tmp___13 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )0);
              if (tmp___13) {
                (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
              } else {
                body = (GumboNode *)*(state->_open_elements.data + 1);
                tmp___12 = node_tag_is((GumboNode const   *)body, (GumboTag )10);
                if (! tmp___12) {
                  __assert_fail("node_tag_is(body, GUMBO_TAG_BODY)", "deps/gumbo-parser/parser.c",
                                2428U, "handle_in_body");
                }
                record_end_of_element(state->_current_token, & body->v.element);
              }
              return (success);
            } else {
              tmp___117 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 24,
                                 11, 14, 28, 142, 120, 127, 38, 32, 106, 36, 35, 23,
                                 22, 21, 122, 13, 29, 25, 12, 121, 30, 150);
              if (tmp___117) {
                tmp___14 = maybe_implicitly_close_p_tag(parser, token);
                result = tmp___14;
                insert_element_from_token(parser, token);
                return (result);
              } else {
                tmp___116 = tag_in((GumboToken const   *)token, (_Bool )kStartTag,
                                   15, 16, 17, 18, 19, 20, 150);
                if (tmp___116) {
                  tmp___15 = maybe_implicitly_close_p_tag(parser, token);
                  result___0 = tmp___15;
                  tmp___16 = get_current_node(parser);
                  tmp___17 = node_tag_in((GumboNode const   *)tmp___16, 15, 16, 17,
                                         18, 19, 20, 150);
                  if (tmp___17) {
                    add_parse_error(parser, (GumboToken const   *)token);
                    pop_current_node(parser);
                    result___0 = (_Bool)0;
                  }
                  insert_element_from_token(parser, token);
                  return (result___0);
                } else {
                  tmp___115 = tag_in((GumboToken const   *)token, (_Bool )kStartTag,
                                     27, 132, 150);
                  if (tmp___115) {
                    tmp___18 = maybe_implicitly_close_p_tag(parser, token);
                    result___1 = tmp___18;
                    insert_element_from_token(parser, token);
                    state->_ignore_next_linefeed = (_Bool)1;
                    state->_frameset_ok = (_Bool)0;
                    return (result___1);
                  } else {
                    tmp___114 = tag_is((GumboToken const   *)token, (_Bool )kStartTag,
                                       (GumboTag )105);
                    if (tmp___114) {
                      if ((unsigned long )state->_form_element != (unsigned long )((void *)0)) {
                        gumbo_debug("Ignoring nested form.\n");
                        add_parse_error(parser, (GumboToken const   *)token);
                        ignore_token(parser);
                        return ((_Bool)0);
                      }
                      tmp___19 = maybe_implicitly_close_p_tag(parser, token);
                      result___2 = tmp___19;
                      state->_form_element = insert_element_from_token(parser, token);
                      return (result___2);
                    } else {
                      tmp___113 = tag_is((GumboToken const   *)token, (_Bool )kStartTag,
                                         (GumboTag )31);
                      if (tmp___113) {
                        maybe_implicitly_close_list_tag(parser, token, (_Bool)1);
                        tmp___20 = maybe_implicitly_close_p_tag(parser, token);
                        result___3 = tmp___20;
                        insert_element_from_token(parser, token);
                        return (result___3);
                      } else {
                        tmp___112 = tag_in((GumboToken const   *)token, (_Bool )kStartTag,
                                           34, 33, 150);
                        if (tmp___112) {
                          maybe_implicitly_close_list_tag(parser, token, (_Bool)0);
                          tmp___21 = maybe_implicitly_close_p_tag(parser, token);
                          result___4 = tmp___21;
                          insert_element_from_token(parser, token);
                          return (result___4);
                        } else {
                          tmp___111 = tag_is((GumboToken const   *)token, (_Bool )kStartTag,
                                             (GumboTag )136);
                          if (tmp___111) {
                            tmp___22 = maybe_implicitly_close_p_tag(parser, token);
                            result___5 = tmp___22;
                            insert_element_from_token(parser, token);
                            gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )6);
                            return (result___5);
                          } else {
                            tmp___110 = tag_is((GumboToken const   *)token, (_Bool )kStartTag,
                                               (GumboTag )110);
                            if (tmp___110) {
                              tmp___23 = has_an_element_in_scope(parser, (GumboTag )110);
                              if (tmp___23) {
                                add_parse_error(parser, (GumboToken const   *)token);
                                implicitly_close_tags(parser, token, (GumboTag )110);
                                state->_reprocess_current_token = (_Bool)1;
                                return ((_Bool)0);
                              }
                              reconstruct_active_formatting_elements(parser);
                              insert_element_from_token(parser, token);
                              state->_frameset_ok = (_Bool)0;
                              return ((_Bool)1);
                            } else {
                              tmp___109 = tag_in((GumboToken const   *)token, (_Bool )kEndTag,
                                                 24, 11, 14, 28, 110, 142, 120, 127,
                                                 38, 32, 106, 36, 35, 23, 22, 21,
                                                 132, 122, 13, 29, 27, 12, 121, 30,
                                                 150);
                              if (tmp___109) {
                                tag = token->v.end_tag;
                                tmp___24 = has_an_element_in_scope(parser, tag);
                                if (! tmp___24) {
                                  add_parse_error(parser, (GumboToken const   *)token);
                                  ignore_token(parser);
                                  return ((_Bool)0);
                                }
                                implicitly_close_tags(parser, token, token->v.end_tag);
                                return ((_Bool)1);
                              } else {
                                tmp___108 = tag_is((GumboToken const   *)token, (_Bool )kEndTag,
                                                   (GumboTag )105);
                                if (tmp___108) {
                                  result___6 = (_Bool)1;
                                  node___0 = (GumboNode const   *)state->_form_element;
                                  if (! (! node___0)) {
                                    if (! ((unsigned int const   )node___0->type == 1U)) {
                                      __assert_fail("!node || node->type == GUMBO_NODE_ELEMENT",
                                                    "deps/gumbo-parser/parser.c",
                                                    2520U, "handle_in_body");
                                    }
                                  }
                                  state->_form_element = (GumboNode *)((void *)0);
                                  if (! node___0) {
                                    gumbo_debug("Closing an unopened form.\n");
                                    add_parse_error(parser, (GumboToken const   *)token);
                                    ignore_token(parser);
                                    return ((_Bool)0);
                                  } else {
                                    tmp___26 = has_node_in_scope(parser, node___0);
                                    if (! tmp___26) {
                                      gumbo_debug("Closing an unopened form.\n");
                                      add_parse_error(parser, (GumboToken const   *)token);
                                      ignore_token(parser);
                                      return ((_Bool)0);
                                    }
                                  }
                                  generate_implied_end_tags(parser, (GumboTag )150);
                                  tmp___27 = get_current_node(parser);
                                  if ((unsigned long )tmp___27 != (unsigned long )node___0) {
                                    add_parse_error(parser, (GumboToken const   *)token);
                                    result___6 = (_Bool)0;
                                  }
                                  open_elements = & state->_open_elements;
                                  index___0 = (int )(open_elements->length - 1U);
                                  while (1) {
                                    if (index___0 >= 0) {
                                      if (! ((unsigned long )*(open_elements->data + index___0) != (unsigned long )node___0)) {
                                        break;
                                      }
                                    } else {
                                      break;
                                    }
                                    index___0 --;
                                  }
                                  if (! (index___0 >= 0)) {
                                    __assert_fail("index >= 0", "deps/gumbo-parser/parser.c",
                                                  2539U, "handle_in_body");
                                  }
                                  gumbo_vector_remove_at(parser, index___0, open_elements);
                                  return (result___6);
                                } else {
                                  tmp___107 = tag_is((GumboToken const   *)token,
                                                     (_Bool )kEndTag, (GumboTag )25);
                                  if (tmp___107) {
                                    tmp___29 = has_an_element_in_button_scope(parser,
                                                                              (GumboTag )25);
                                    if (! tmp___29) {
                                      add_parse_error(parser, (GumboToken const   *)token);
                                      reconstruct_active_formatting_elements(parser);
                                      insert_element_of_tag_type(parser, (GumboTag )25,
                                                                 (GumboParseFlags )16);
                                      state->_reprocess_current_token = (_Bool)1;
                                      return ((_Bool)0);
                                    }
                                    tmp___30 = implicitly_close_tags(parser, token,
                                                                     (GumboTag )25);
                                    return (tmp___30);
                                  } else {
                                    tmp___106 = tag_is((GumboToken const   *)token,
                                                       (_Bool )kEndTag, (GumboTag )31);
                                    if (tmp___106) {
                                      tmp___31 = has_an_element_in_list_scope(parser,
                                                                              (GumboTag )31);
                                      if (! tmp___31) {
                                        add_parse_error(parser, (GumboToken const   *)token);
                                        ignore_token(parser);
                                        return ((_Bool)0);
                                      }
                                      tmp___32 = implicitly_close_tags(parser, token,
                                                                       (GumboTag )31);
                                      return (tmp___32);
                                    } else {
                                      tmp___105 = tag_in((GumboToken const   *)token,
                                                         (_Bool )kEndTag, 34, 33,
                                                         150);
                                      if (tmp___105) {
                                        if (! ((unsigned int )token->type == 2U)) {
                                          __assert_fail("token->type == GUMBO_TOKEN_END_TAG",
                                                        "deps/gumbo-parser/parser.c",
                                                        2561U, "handle_in_body");
                                        }
                                        token_tag = token->v.end_tag;
                                        tmp___34 = has_an_element_in_scope(parser,
                                                                           token_tag);
                                        if (! tmp___34) {
                                          add_parse_error(parser, (GumboToken const   *)token);
                                          ignore_token(parser);
                                          return ((_Bool)0);
                                        }
                                        tmp___35 = implicitly_close_tags(parser, token,
                                                                         token_tag);
                                        return (tmp___35);
                                      } else {
                                        tmp___104 = tag_in((GumboToken const   *)token,
                                                           (_Bool )kEndTag, 15, 16,
                                                           17, 18, 19, 20, 150);
                                        if (tmp___104) {
                                          tmp___40 = has_an_element_in_scope_with_tagname(parser,
                                                                                          15,
                                                                                          16,
                                                                                          17,
                                                                                          18,
                                                                                          19,
                                                                                          20,
                                                                                          150);
                                          if (tmp___40) {
                                            generate_implied_end_tags(parser, (GumboTag )150);
                                            tmp___36 = get_current_node(parser);
                                            current_node = (GumboNode const   *)tmp___36;
                                            tmp___37 = node_tag_is(current_node, token->v.end_tag);
                                            success___0 = tmp___37;
                                            if (! success___0) {
                                              add_parse_error(parser, (GumboToken const   *)token);
                                            }
                                            while (1) {
                                              tmp___38 = pop_current_node(parser);
                                              current_node = (GumboNode const   *)tmp___38;
                                              tmp___39 = node_tag_in(current_node,
                                                                     15, 16, 17, 18,
                                                                     19, 20, 150);
                                              if (tmp___39) {
                                                break;
                                              }
                                            }
                                            return (success___0);
                                          } else {
                                            add_parse_error(parser, (GumboToken const   *)token);
                                            ignore_token(parser);
                                            return ((_Bool)0);
                                          }
                                        } else {
                                          tmp___103 = tag_is((GumboToken const   *)token,
                                                             (_Bool )kStartTag, (GumboTag )39);
                                          if (tmp___103) {
                                            success___1 = (_Bool)1;
                                            tmp___41 = find_last_anchor_index(parser,
                                                                              & last_a);
                                            has_matching_a = (int )tmp___41;
                                            if (has_matching_a) {
                                              if (! (has_matching_a == 1)) {
                                                __assert_fail("has_matching_a == 1",
                                                              "deps/gumbo-parser/parser.c",
                                                              2601U, "handle_in_body");
                                              }
                                              add_parse_error(parser, (GumboToken const   *)token);
                                              adoption_agency_algorithm(parser, token,
                                                                        (GumboTag )39);
                                              tmp___44 = find_last_anchor_index(parser,
                                                                                & last_a);
                                              if (tmp___44) {
                                                tmp___43 = gumbo_vector_remove_at(parser,
                                                                                  last_a,
                                                                                  & state->_active_formatting_elements);
                                                last_element = tmp___43;
                                                gumbo_vector_remove(parser, last_element,
                                                                    & state->_open_elements);
                                              }
                                              success___1 = (_Bool)0;
                                            }
                                            reconstruct_active_formatting_elements(parser);
                                            tmp___45 = insert_element_from_token(parser,
                                                                                 token);
                                            add_formatting_element(parser, (GumboNode const   *)tmp___45);
                                            return (success___1);
                                          } else {
                                            tmp___102 = tag_in((GumboToken const   *)token,
                                                               (_Bool )kStartTag,
                                                               57, 140, 50, 40, 143,
                                                               56, 43, 42, 138, 41,
                                                               148, 58, 150);
                                            if (tmp___102) {
                                              reconstruct_active_formatting_elements(parser);
                                              tmp___46 = insert_element_from_token(parser,
                                                                                   token);
                                              add_formatting_element(parser, (GumboNode const   *)tmp___46);
                                              return ((_Bool)1);
                                            } else {
                                              tmp___101 = tag_is((GumboToken const   *)token,
                                                                 (_Bool )kStartTag,
                                                                 (GumboTag )146);
                                              if (tmp___101) {
                                                result___7 = (_Bool)1;
                                                reconstruct_active_formatting_elements(parser);
                                                tmp___47 = has_an_element_in_scope(parser,
                                                                                   (GumboTag )146);
                                                if (tmp___47) {
                                                  result___7 = (_Bool)0;
                                                  add_parse_error(parser, (GumboToken const   *)token);
                                                  adoption_agency_algorithm(parser,
                                                                            token,
                                                                            (GumboTag )146);
                                                  reconstruct_active_formatting_elements(parser);
                                                }
                                                insert_element_from_token(parser,
                                                                          token);
                                                tmp___48 = get_current_node(parser);
                                                add_formatting_element(parser, (GumboNode const   *)tmp___48);
                                                return (result___7);
                                              } else {
                                                tmp___100 = tag_in((GumboToken const   *)token,
                                                                   (_Bool )kEndTag,
                                                                   39, 57, 140, 50,
                                                                   40, 143, 56, 146,
                                                                   43, 42, 138, 41,
                                                                   148, 58, 150);
                                                if (tmp___100) {
                                                  tmp___49 = adoption_agency_algorithm(parser,
                                                                                       token,
                                                                                       token->v.end_tag);
                                                  return (tmp___49);
                                                } else {
                                                  tmp___99 = tag_in((GumboToken const   *)token,
                                                                    (_Bool )kStartTag,
                                                                    124, 144, 74,
                                                                    150);
                                                  if (tmp___99) {
                                                    reconstruct_active_formatting_elements(parser);
                                                    insert_element_from_token(parser,
                                                                              token);
                                                    add_formatting_element(parser,
                                                                           & kActiveFormattingScopeMarker);
                                                    set_frameset_not_ok(parser);
                                                    return ((_Bool)1);
                                                  } else {
                                                    tmp___98 = tag_in((GumboToken const   *)token,
                                                                      (_Bool )kEndTag,
                                                                      124, 144, 74,
                                                                      150);
                                                    if (tmp___98) {
                                                      token_tag___0 = token->v.end_tag;
                                                      tmp___50 = has_an_element_in_table_scope(parser,
                                                                                               token_tag___0);
                                                      if (! tmp___50) {
                                                        add_parse_error(parser, (GumboToken const   *)token);
                                                        ignore_token(parser);
                                                        return ((_Bool)0);
                                                      }
                                                      implicitly_close_tags(parser,
                                                                            token,
                                                                            token_tag___0);
                                                      clear_active_formatting_elements(parser);
                                                      return ((_Bool)1);
                                                    } else {
                                                      tmp___97 = tag_is((GumboToken const   *)token,
                                                                        (_Bool )kStartTag,
                                                                        (GumboTag )95);
                                                      if (tmp___97) {
                                                        tmp___51 = get_document_node(parser);
                                                        if ((unsigned int )tmp___51->v.document.doc_type_quirks_mode != 1U) {
                                                          maybe_implicitly_close_p_tag(parser,
                                                                                       token);
                                                        }
                                                        insert_element_from_token(parser,
                                                                                  token);
                                                        set_frameset_not_ok(parser);
                                                        set_insertion_mode(parser,
                                                                           (GumboInsertionMode )8);
                                                        return ((_Bool)1);
                                                      } else {
                                                        tmp___96 = tag_in((GumboToken const   *)token,
                                                                          (_Bool )kStartTag,
                                                                          82, 66,
                                                                          73, 71,
                                                                          70, 116,
                                                                          67, 150);
                                                        if (tmp___96) {
                                                          success___2 = (_Bool)1;
                                                          tmp___52 = tag_is((GumboToken const   *)token,
                                                                            (_Bool )kStartTag,
                                                                            (GumboTag )70);
                                                          if (tmp___52) {
                                                            success___2 = (_Bool)0;
                                                            add_parse_error(parser,
                                                                            (GumboToken const   *)token);
                                                            token->v.start_tag.tag = (GumboTag )71;
                                                          }
                                                          reconstruct_active_formatting_elements(parser);
                                                          tmp___53 = insert_element_from_token(parser,
                                                                                               token);
                                                          node___1 = tmp___53;
                                                          tmp___54 = tag_is((GumboToken const   *)token,
                                                                            (_Bool )kStartTag,
                                                                            (GumboTag )70);
                                                          if (tmp___54) {
                                                            success___2 = (_Bool)0;
                                                            add_parse_error(parser,
                                                                            (GumboToken const   *)token);
                                                            node___1->v.element.tag = (GumboTag )71;
                                                            node___1->parse_flags = (GumboParseFlags )((unsigned int )node___1->parse_flags | 64U);
                                                          }
                                                          pop_current_node(parser);
                                                          acknowledge_self_closing_tag(parser);
                                                          set_frameset_not_ok(parser);
                                                          return (success___2);
                                                        } else {
                                                          tmp___95 = tag_is((GumboToken const   *)token,
                                                                            (_Bool )kStartTag,
                                                                            (GumboTag )109);
                                                          if (tmp___95) {
                                                            tmp___55 = attribute_matches((GumboVector const   *)(& token->v.start_tag.attributes),
                                                                                         "type",
                                                                                         "hidden");
                                                            if (! tmp___55) {
                                                              set_frameset_not_ok(parser);
                                                            }
                                                            reconstruct_active_formatting_elements(parser);
                                                            insert_element_from_token(parser,
                                                                                      token);
                                                            pop_current_node(parser);
                                                            acknowledge_self_closing_tag(parser);
                                                            return ((_Bool)1);
                                                          } else {
                                                            tmp___94 = tag_in((GumboToken const   *)token,
                                                                              (_Bool )kStartTag,
                                                                              75,
                                                                              78,
                                                                              79,
                                                                              150);
                                                            if (tmp___94) {
                                                              insert_element_from_token(parser,
                                                                                        token);
                                                              pop_current_node(parser);
                                                              acknowledge_self_closing_tag(parser);
                                                              return ((_Bool)1);
                                                            } else {
                                                              tmp___93 = tag_is((GumboToken const   *)token,
                                                                                (_Bool )kStartTag,
                                                                                (GumboTag )26);
                                                              if (tmp___93) {
                                                                tmp___56 = maybe_implicitly_close_p_tag(parser,
                                                                                                        token);
                                                                result___8 = tmp___56;
                                                                insert_element_from_token(parser,
                                                                                          token);
                                                                pop_current_node(parser);
                                                                acknowledge_self_closing_tag(parser);
                                                                set_frameset_not_ok(parser);
                                                                return (result___8);
                                                              } else {
                                                                tmp___92 = tag_is((GumboToken const   *)token,
                                                                                  (_Bool )kStartTag,
                                                                                  (GumboTag )131);
                                                                if (tmp___92) {
                                                                  add_parse_error(parser,
                                                                                  (GumboToken const   *)token);
                                                                  if ((unsigned long )(parser->_parser_state)->_form_element != (unsigned long )((void *)0)) {
                                                                    ignore_token(parser);
                                                                    return ((_Bool)0);
                                                                  }
                                                                  acknowledge_self_closing_tag(parser);
                                                                  maybe_implicitly_close_p_tag(parser,
                                                                                               token);
                                                                  set_frameset_not_ok(parser);
                                                                  token_attrs = & token->v.start_tag.attributes;
                                                                  tmp___57 = gumbo_get_attribute((GumboVector const   *)token_attrs,
                                                                                                 "prompt");
                                                                  prompt_attr = tmp___57;
                                                                  tmp___58 = gumbo_get_attribute((GumboVector const   *)token_attrs,
                                                                                                 "action");
                                                                  action_attr = tmp___58;
                                                                  tmp___59 = gumbo_get_attribute((GumboVector const   *)token_attrs,
                                                                                                 "isindex");
                                                                  name_attr = tmp___59;
                                                                  tmp___60 = insert_element_of_tag_type(parser,
                                                                                                        (GumboTag )105,
                                                                                                        (GumboParseFlags )32);
                                                                  form = tmp___60;
                                                                  if (action_attr) {
                                                                    gumbo_vector_add(parser,
                                                                                     (void *)action_attr,
                                                                                     & form->v.element.attributes);
                                                                  }
                                                                  insert_element_of_tag_type(parser,
                                                                                             (GumboTag )26,
                                                                                             (GumboParseFlags )32);
                                                                  pop_current_node(parser);
                                                                  insert_element_of_tag_type(parser,
                                                                                             (GumboTag )108,
                                                                                             (GumboParseFlags )32);
                                                                  text_state = & (parser->_parser_state)->_text_node;
                                                                  text_state->_start_original_text = token->original_text.data;
                                                                  text_state->_start_position = token->position;
                                                                  text_state->_type = (GumboNodeType )2;
                                                                  if (prompt_attr) {
                                                                    tmp___61 = strlen(prompt_attr->value);
                                                                    prompt_attr_length = (int )tmp___61;
                                                                    gumbo_string_buffer_destroy(parser,
                                                                                                & text_state->_buffer);
                                                                    text_state->_buffer.data = gumbo_copy_stringz(parser,
                                                                                                                  prompt_attr->value);
                                                                    text_state->_buffer.length = (size_t )prompt_attr_length;
                                                                    text_state->_buffer.capacity = (size_t )(prompt_attr_length + 1);
                                                                    gumbo_destroy_attribute(parser,
                                                                                            prompt_attr);
                                                                  } else {
                                                                    prompt_text.data = "This is a searchable index. Enter search keywords: ";
                                                                    prompt_text.length = sizeof("This is a searchable index. Enter search keywords: ") - 1UL;
                                                                    gumbo_string_buffer_append_string(parser,
                                                                                                      & prompt_text,
                                                                                                      & text_state->_buffer);
                                                                  }
                                                                  tmp___62 = insert_element_of_tag_type(parser,
                                                                                                        (GumboTag )109,
                                                                                                        (GumboParseFlags )32);
                                                                  input = tmp___62;
                                                                  i___2 = 0;
                                                                  while ((unsigned int )i___2 < token_attrs->length) {
                                                                    attr = (GumboAttribute *)*(token_attrs->data + i___2);
                                                                    if ((unsigned long )attr != (unsigned long )prompt_attr) {
                                                                      if ((unsigned long )attr != (unsigned long )action_attr) {
                                                                        if ((unsigned long )attr != (unsigned long )name_attr) {
                                                                          gumbo_vector_add(parser,
                                                                                           (void *)attr,
                                                                                           & input->v.element.attributes);
                                                                        }
                                                                      }
                                                                    }
                                                                    *(token_attrs->data + i___2) = (void *)0;
                                                                    i___2 ++;
                                                                  }
                                                                  ignore_token(parser);
                                                                  tmp___63 = gumbo_parser_allocate(parser,
                                                                                                   sizeof(GumboAttribute ));
                                                                  name = (GumboAttribute *)tmp___63;
                                                                  name_str.data = "name";
                                                                  name_str.length = sizeof("name") - 1UL;
                                                                  isindex_str.data = "isindex";
                                                                  isindex_str.length = sizeof("isindex") - 1UL;
                                                                  name->attr_namespace = (GumboAttributeNamespaceEnum )0;
                                                                  tmp___64 = gumbo_copy_stringz(parser,
                                                                                                "name");
                                                                  name->name = (char const   *)tmp___64;
                                                                  tmp___65 = gumbo_copy_stringz(parser,
                                                                                                "isindex");
                                                                  name->value = (char const   *)tmp___65;
                                                                  name->original_name = name_str;
                                                                  name->original_value = isindex_str;
                                                                  name->name_start = (GumboSourcePosition )kGumboEmptySourcePosition;
                                                                  name->name_end = (GumboSourcePosition )kGumboEmptySourcePosition;
                                                                  name->value_start = (GumboSourcePosition )kGumboEmptySourcePosition;
                                                                  name->value_end = (GumboSourcePosition )kGumboEmptySourcePosition;
                                                                  gumbo_vector_add(parser,
                                                                                   (void *)name,
                                                                                   & input->v.element.attributes);
                                                                  pop_current_node(parser);
                                                                  pop_current_node(parser);
                                                                  insert_element_of_tag_type(parser,
                                                                                             (GumboTag )26,
                                                                                             (GumboParseFlags )32);
                                                                  pop_current_node(parser);
                                                                  pop_current_node(parser);
                                                                  return ((_Bool)0);
                                                                } else {
                                                                  tmp___91 = tag_is((GumboToken const   *)token,
                                                                                    (_Bool )kStartTag,
                                                                                    (GumboTag )115);
                                                                  if (tmp___91) {
                                                                    run_generic_parsing_algorithm(parser,
                                                                                                  token,
                                                                                                  (GumboTokenizerEnum )2);
                                                                    (parser->_parser_state)->_ignore_next_linefeed = (_Bool)1;
                                                                    set_frameset_not_ok(parser);
                                                                    return ((_Bool)1);
                                                                  } else {
                                                                    tmp___90 = tag_is((GumboToken const   *)token,
                                                                                      (_Bool )kStartTag,
                                                                                      (GumboTag )133);
                                                                    if (tmp___90) {
                                                                      tmp___66 = maybe_implicitly_close_p_tag(parser,
                                                                                                              token);
                                                                      result___9 = tmp___66;
                                                                      reconstruct_active_formatting_elements(parser);
                                                                      set_frameset_not_ok(parser);
                                                                      run_generic_parsing_algorithm(parser,
                                                                                                    token,
                                                                                                    (GumboTokenizerEnum )4);
                                                                      return (result___9);
                                                                    } else {
                                                                      tmp___89 = tag_is((GumboToken const   *)token,
                                                                                        (_Bool )kStartTag,
                                                                                        (GumboTag )72);
                                                                      if (tmp___89) {
                                                                        set_frameset_not_ok(parser);
                                                                        run_generic_parsing_algorithm(parser,
                                                                                                      token,
                                                                                                      (GumboTokenizerEnum )4);
                                                                        return ((_Bool)1);
                                                                      } else {
                                                                        tmp___88 = tag_is((GumboToken const   *)token,
                                                                                          (_Bool )kStartTag,
                                                                                          (GumboTag )135);
                                                                        if (tmp___88) {
                                                                          run_generic_parsing_algorithm(parser,
                                                                                                        token,
                                                                                                        (GumboTokenizerEnum )4);
                                                                          return ((_Bool)1);
                                                                        } else {
                                                                          tmp___87 = tag_is((GumboToken const   *)token,
                                                                                            (_Bool )kStartTag,
                                                                                            (GumboTag )111);
                                                                          if (tmp___87) {
                                                                            reconstruct_active_formatting_elements(parser);
                                                                            insert_element_from_token(parser,
                                                                                                      token);
                                                                            set_frameset_not_ok(parser);
                                                                            state___0 = (parser->_parser_state)->_insertion_mode;
                                                                            if ((unsigned int )state___0 == 8U) {
                                                                              set_insertion_mode(parser,
                                                                                                 (GumboInsertionMode )16);
                                                                            } else
                                                                            if ((unsigned int )state___0 == 10U) {
                                                                              set_insertion_mode(parser,
                                                                                                 (GumboInsertionMode )16);
                                                                            } else
                                                                            if ((unsigned int )state___0 == 12U) {
                                                                              set_insertion_mode(parser,
                                                                                                 (GumboInsertionMode )16);
                                                                            } else
                                                                            if ((unsigned int )state___0 == 13U) {
                                                                              set_insertion_mode(parser,
                                                                                                 (GumboInsertionMode )16);
                                                                            } else
                                                                            if ((unsigned int )state___0 == 14U) {
                                                                              set_insertion_mode(parser,
                                                                                                 (GumboInsertionMode )16);
                                                                            } else {
                                                                              set_insertion_mode(parser,
                                                                                                 (GumboInsertionMode )15);
                                                                            }
                                                                            return ((_Bool)1);
                                                                          } else {
                                                                            tmp___86 = tag_in((GumboToken const   *)token,
                                                                                              (_Bool )kStartTag,
                                                                                              114,
                                                                                              113,
                                                                                              150);
                                                                            if (tmp___86) {
                                                                              tmp___67 = get_current_node(parser);
                                                                              tmp___68 = node_tag_is((GumboNode const   *)tmp___67,
                                                                                                     (GumboTag )114);
                                                                              if (tmp___68) {
                                                                                pop_current_node(parser);
                                                                              }
                                                                              reconstruct_active_formatting_elements(parser);
                                                                              insert_element_from_token(parser,
                                                                                                        token);
                                                                              return ((_Bool)1);
                                                                            } else {
                                                                              tmp___85 = tag_in((GumboToken const   *)token,
                                                                                                (_Bool )kStartTag,
                                                                                                62,
                                                                                                61,
                                                                                                150);
                                                                              if (tmp___85) {
                                                                                success___3 = (_Bool)1;
                                                                                tmp___69 = has_an_element_in_scope(parser,
                                                                                                                   (GumboTag )60);
                                                                                if (tmp___69) {
                                                                                  generate_implied_end_tags(parser,
                                                                                                            (GumboTag )150);
                                                                                }
                                                                                tmp___70 = get_current_node(parser);
                                                                                tmp___71 = node_tag_is((GumboNode const   *)tmp___70,
                                                                                                       (GumboTag )60);
                                                                                if (! tmp___71) {
                                                                                  add_parse_error(parser,
                                                                                                  (GumboToken const   *)token);
                                                                                  success___3 = (_Bool)0;
                                                                                }
                                                                                insert_element_from_token(parser,
                                                                                                          token);
                                                                                return (success___3);
                                                                              } else {
                                                                                tmp___84 = tag_is((GumboToken const   *)token,
                                                                                                  (_Bool )kEndTag,
                                                                                                  (GumboTag )66);
                                                                                if (tmp___84) {
                                                                                  add_parse_error(parser,
                                                                                                  (GumboToken const   *)token);
                                                                                  reconstruct_active_formatting_elements(parser);
                                                                                  insert_element_of_tag_type(parser,
                                                                                                             (GumboTag )66,
                                                                                                             (GumboParseFlags )16);
                                                                                  pop_current_node(parser);
                                                                                  return ((_Bool)0);
                                                                                } else {
                                                                                  tmp___83 = tag_is((GumboToken const   *)token,
                                                                                                    (_Bool )kStartTag,
                                                                                                    (GumboTag )83);
                                                                                  if (tmp___83) {
                                                                                    reconstruct_active_formatting_elements(parser);
                                                                                    adjust_mathml_attributes(parser,
                                                                                                             token);
                                                                                    adjust_foreign_attributes(parser,
                                                                                                              token);
                                                                                    insert_foreign_element(parser,
                                                                                                           token,
                                                                                                           (GumboNamespaceEnum )2);
                                                                                    if (token->v.start_tag.is_self_closing) {
                                                                                      pop_current_node(parser);
                                                                                      acknowledge_self_closing_tag(parser);
                                                                                    }
                                                                                    return ((_Bool)1);
                                                                                  } else {
                                                                                    tmp___82 = tag_is((GumboToken const   *)token,
                                                                                                      (_Bool )kStartTag,
                                                                                                      (GumboTag )92);
                                                                                    if (tmp___82) {
                                                                                      reconstruct_active_formatting_elements(parser);
                                                                                      adjust_svg_attributes(parser,
                                                                                                            token);
                                                                                      adjust_foreign_attributes(parser,
                                                                                                                token);
                                                                                      insert_foreign_element(parser,
                                                                                                             token,
                                                                                                             (GumboNamespaceEnum )1);
                                                                                      if (token->v.start_tag.is_self_closing) {
                                                                                        pop_current_node(parser);
                                                                                        acknowledge_self_closing_tag(parser);
                                                                                      }
                                                                                      return ((_Bool)1);
                                                                                    } else {
                                                                                      tmp___81 = tag_in((GumboToken const   *)token,
                                                                                                        (_Bool )kStartTag,
                                                                                                        96,
                                                                                                        98,
                                                                                                        97,
                                                                                                        128,
                                                                                                        1,
                                                                                                        99,
                                                                                                        103,
                                                                                                        101,
                                                                                                        104,
                                                                                                        100,
                                                                                                        102,
                                                                                                        150);
                                                                                      if (tmp___81) {
                                                                                        add_parse_error(parser,
                                                                                                        (GumboToken const   *)token);
                                                                                        ignore_token(parser);
                                                                                        return ((_Bool)0);
                                                                                      } else
                                                                                      if ((unsigned int )token->type == 1U) {
                                                                                        reconstruct_active_formatting_elements(parser);
                                                                                        insert_element_from_token(parser,
                                                                                                                  token);
                                                                                        return ((_Bool)1);
                                                                                      } else {
                                                                                        if (! ((unsigned int )token->type == 2U)) {
                                                                                          __assert_fail("token->type == GUMBO_TOKEN_END_TAG",
                                                                                                        "deps/gumbo-parser/parser.c",
                                                                                                        2891U,
                                                                                                        "handle_in_body");
                                                                                        }
                                                                                        end_tag = token->v.end_tag;
                                                                                        if (! (state->_open_elements.length > 0U)) {
                                                                                          __assert_fail("state->_open_elements.length > 0",
                                                                                                        "deps/gumbo-parser/parser.c",
                                                                                                        2893U,
                                                                                                        "handle_in_body");
                                                                                        }
                                                                                        tmp___77 = node_tag_is((GumboNode const   *)*(state->_open_elements.data + 0),
                                                                                                               (GumboTag )0);
                                                                                        if (! tmp___77) {
                                                                                          __assert_fail("node_tag_is(state->_open_elements.data[0], GUMBO_TAG_HTML)",
                                                                                                        "deps/gumbo-parser/parser.c",
                                                                                                        2894U,
                                                                                                        "handle_in_body");
                                                                                        }
                                                                                        i___3 = (int )state->_open_elements.length;
                                                                                        while (1) {
                                                                                          i___3 --;
                                                                                          if (! (i___3 >= 0)) {
                                                                                            break;
                                                                                          }
                                                                                          node___2 = (GumboNode const   *)*(state->_open_elements.data + i___3);
                                                                                          if ((unsigned int const   )node___2->v.element.tag_namespace == 0U) {
                                                                                            tmp___80 = node_tag_is(node___2,
                                                                                                                   end_tag);
                                                                                            if (tmp___80) {
                                                                                              generate_implied_end_tags(parser,
                                                                                                                        end_tag);
                                                                                              while (1) {
                                                                                                tmp___78 = pop_current_node(parser);
                                                                                                if (! ((unsigned long )node___2 != (unsigned long )tmp___78)) {
                                                                                                  break;
                                                                                                }
                                                                                              }
                                                                                              return ((_Bool)1);
                                                                                            } else {
                                                                                              goto _L;
                                                                                            }
                                                                                          } else {
                                                                                            _L: /* CIL Label */ 
                                                                                            tmp___79 = is_special_node(node___2);
                                                                                            if (tmp___79) {
                                                                                              add_parse_error(parser,
                                                                                                              (GumboToken const   *)token);
                                                                                              ignore_token(parser);
                                                                                              return ((_Bool)0);
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                        __assert_fail("0",
                                                                                                      "deps/gumbo-parser/parser.c",
                                                                                                      2918U,
                                                                                                      "handle_in_body");
                                                                                        return ((_Bool)0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
}
static _Bool handle_text(GumboParser *parser , GumboToken *token ) 
{ 


  {
  if ((unsigned int )token->type == 5U) {
    insert_text_token(parser, token);
  } else
  if ((unsigned int )token->type == 4U) {
    insert_text_token(parser, token);
  } else {
    if ((unsigned int )token->type == 7U) {
      add_parse_error(parser, (GumboToken const   *)token);
      (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
    }
    pop_current_node(parser);
    set_insertion_mode(parser, (parser->_parser_state)->_original_insertion_mode);
  }
  return ((_Bool)1);
}
}
static _Bool handle_in_table(GumboParser *parser , GumboToken *token ) 
{ 
  GumboParserState *state ;
  GumboNode *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  GumboNode *tmp___5 ;
  _Bool tmp___6 ;
  _Bool result ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  _Bool tmp___18 ;

  {
  state = parser->_parser_state;
  if ((unsigned int )token->type == 5U) {
    goto _L___0;
  } else
  if ((unsigned int )token->type == 4U) {
    _L___0: /* CIL Label */ 
    if (! (state->_text_node._buffer.length == 0UL)) {
      __assert_fail("state->_text_node._buffer.length == 0", "deps/gumbo-parser/parser.c",
                    2955U, "handle_in_table");
    }
    state->_original_insertion_mode = state->_insertion_mode;
    state->_reprocess_current_token = (_Bool)1;
    set_insertion_mode(parser, (GumboInsertionMode )9);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 0U) {
    add_parse_error(parser, (GumboToken const   *)token);
    ignore_token(parser);
    return ((_Bool)0);
  } else
  if ((unsigned int )token->type == 3U) {
    tmp___0 = get_current_node(parser);
    append_comment_node(parser, tmp___0, (GumboToken const   *)token);
    return ((_Bool)1);
  } else {
    tmp___18 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )96);
    if (tmp___18) {
      clear_stack_to_table_context(parser);
      add_formatting_element(parser, & kActiveFormattingScopeMarker);
      insert_element_from_token(parser, token);
      set_insertion_mode(parser, (GumboInsertionMode )10);
      return ((_Bool)1);
    } else {
      tmp___17 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )97);
      if (tmp___17) {
        clear_stack_to_table_context(parser);
        insert_element_from_token(parser, token);
        set_insertion_mode(parser, (GumboInsertionMode )11);
        return ((_Bool)1);
      } else {
        tmp___16 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )98);
        if (tmp___16) {
          clear_stack_to_table_context(parser);
          insert_element_of_tag_type(parser, (GumboTag )97, (GumboParseFlags )8);
          (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
          set_insertion_mode(parser, (GumboInsertionMode )11);
          return ((_Bool)1);
        } else {
          tmp___15 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 99, 101,
                            100, 103, 104, 102, 150);
          if (tmp___15) {
            clear_stack_to_table_context(parser);
            set_insertion_mode(parser, (GumboInsertionMode )12);
            tmp___1 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 103,
                             104, 102, 150);
            if (tmp___1) {
              insert_element_of_tag_type(parser, (GumboTag )99, (GumboParseFlags )8);
              state->_reprocess_current_token = (_Bool)1;
            } else {
              insert_element_from_token(parser, token);
            }
            return ((_Bool)1);
          } else {
            tmp___14 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )95);
            if (tmp___14) {
              add_parse_error(parser, (GumboToken const   *)token);
              tmp___2 = close_table(parser);
              if (tmp___2) {
                (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
              } else {
                ignore_token(parser);
              }
              return ((_Bool)0);
            } else {
              tmp___13 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )95);
              if (tmp___13) {
                tmp___3 = close_table(parser);
                if (! tmp___3) {
                  add_parse_error(parser, (GumboToken const   *)token);
                  return ((_Bool)0);
                }
                return ((_Bool)1);
              } else {
                tmp___12 = tag_in((GumboToken const   *)token, (_Bool )kEndTag, 10,
                                  96, 98, 97, 0, 99, 103, 101, 104, 100, 102, 150);
                if (tmp___12) {
                  add_parse_error(parser, (GumboToken const   *)token);
                  ignore_token(parser);
                  return ((_Bool)0);
                } else {
                  tmp___11 = tag_in((GumboToken const   *)token, (_Bool )kStartTag,
                                    6, 7, 150);
                  if (tmp___11) {
                    tmp___4 = handle_in_head(parser, token);
                    return (tmp___4);
                  } else {
                    tmp___9 = tag_is((GumboToken const   *)token, (_Bool )kStartTag,
                                     (GumboTag )109);
                    if (tmp___9) {
                      tmp___10 = attribute_matches((GumboVector const   *)(& token->v.start_tag.attributes),
                                                   "type", "hidden");
                      if (tmp___10) {
                        add_parse_error(parser, (GumboToken const   *)token);
                        insert_element_from_token(parser, token);
                        pop_current_node(parser);
                        return ((_Bool)0);
                      } else {
                        goto _L;
                      }
                    } else {
                      _L: /* CIL Label */ 
                      tmp___8 = tag_is((GumboToken const   *)token, (_Bool )kStartTag,
                                       (GumboTag )105);
                      if (tmp___8) {
                        add_parse_error(parser, (GumboToken const   *)token);
                        if (state->_form_element) {
                          ignore_token(parser);
                          return ((_Bool)0);
                        }
                        state->_form_element = insert_element_from_token(parser, token);
                        pop_current_node(parser);
                        return ((_Bool)0);
                      } else
                      if ((unsigned int )token->type == 7U) {
                        tmp___5 = get_current_node(parser);
                        tmp___6 = node_tag_is((GumboNode const   *)tmp___5, (GumboTag )0);
                        if (! tmp___6) {
                          add_parse_error(parser, (GumboToken const   *)token);
                          return ((_Bool)0);
                        }
                        return ((_Bool)1);
                      } else {
                        add_parse_error(parser, (GumboToken const   *)token);
                        state->_foster_parent_insertions = (_Bool)1;
                        tmp___7 = handle_in_body(parser, token);
                        result = tmp___7;
                        state->_foster_parent_insertions = (_Bool)0;
                        return (result);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
}
static _Bool handle_in_table_text(GumboParser *parser , GumboToken *token ) 
{ 
  GumboParserState *state ;
  GumboStringBuffer *buffer ;
  int i ;
  unsigned short const   **tmp ;

  {
  if ((unsigned int )token->type == 6U) {
    add_parse_error(parser, (GumboToken const   *)token);
    ignore_token(parser);
    return ((_Bool)0);
  } else
  if ((unsigned int )token->type == 5U) {
    insert_text_token(parser, token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 4U) {
    insert_text_token(parser, token);
    return ((_Bool)1);
  } else {
    state = parser->_parser_state;
    buffer = & state->_text_node._buffer;
    i = 0;
    while ((size_t )i < buffer->length) {
      tmp = __ctype_b_loc();
      if ((int const   )*(*tmp + (int )*(buffer->data + i)) & 8192) {
        if ((int )*(buffer->data + i) == 11) {
          state->_foster_parent_insertions = (_Bool)1;
          reconstruct_active_formatting_elements(parser);
          break;
        }
      } else {
        state->_foster_parent_insertions = (_Bool)1;
        reconstruct_active_formatting_elements(parser);
        break;
      }
      i ++;
    }
    maybe_flush_text_node_buffer(parser);
    state->_foster_parent_insertions = (_Bool)0;
    state->_reprocess_current_token = (_Bool)1;
    state->_insertion_mode = state->_original_insertion_mode;
    return ((_Bool)1);
  }
}
}
static _Bool handle_in_caption(GumboParser *parser , GumboToken *token ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool result ;
  GumboNode *tmp___1 ;
  _Bool tmp___2 ;
  GumboNode *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
  tmp___7 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 96, 98, 97, 99,
                   103, 101, 104, 100, 102, 150);
  if (tmp___7) {
    goto _L;
  } else {
    tmp___8 = tag_in((GumboToken const   *)token, (_Bool )kEndTag, 96, 95, 150);
    if (tmp___8) {
      _L: /* CIL Label */ 
      tmp = has_an_element_in_table_scope(parser, (GumboTag )96);
      if (! tmp) {
        add_parse_error(parser, (GumboToken const   *)token);
        ignore_token(parser);
        return ((_Bool)0);
      }
      tmp___0 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )96);
      if (! tmp___0) {
        add_parse_error(parser, (GumboToken const   *)token);
        (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
      }
      generate_implied_end_tags(parser, (GumboTag )150);
      result = (_Bool)1;
      tmp___3 = get_current_node(parser);
      tmp___4 = node_tag_is((GumboNode const   *)tmp___3, (GumboTag )96);
      if (! tmp___4) {
        add_parse_error(parser, (GumboToken const   *)token);
        while (1) {
          tmp___1 = get_current_node(parser);
          tmp___2 = node_tag_is((GumboNode const   *)tmp___1, (GumboTag )96);
          if (tmp___2) {
            break;
          }
          pop_current_node(parser);
        }
        result = (_Bool)0;
      }
      pop_current_node(parser);
      clear_active_formatting_elements(parser);
      set_insertion_mode(parser, (GumboInsertionMode )8);
      return (result);
    } else {
      tmp___6 = tag_in((GumboToken const   *)token, (_Bool )kEndTag, 10, 98, 97, 0,
                       99, 103, 101, 104, 100, 102, 150);
      if (tmp___6) {
        add_parse_error(parser, (GumboToken const   *)token);
        ignore_token(parser);
        return ((_Bool)0);
      } else {
        tmp___5 = handle_in_body(parser, token);
        return (tmp___5);
      }
    }
  }
}
}
static _Bool handle_in_column_group(GumboParser *parser , GumboToken *token ) 
{ 
  GumboNode *tmp ;
  _Bool tmp___0 ;
  GumboNode *tmp___1 ;
  GumboNode *tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  GumboNode *tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;

  {
  if ((unsigned int )token->type == 4U) {
    insert_text_token(parser, token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 0U) {
    add_parse_error(parser, (GumboToken const   *)token);
    ignore_token(parser);
    return ((_Bool)0);
  } else
  if ((unsigned int )token->type == 3U) {
    tmp = get_current_node(parser);
    append_comment_node(parser, tmp, (GumboToken const   *)token);
    return ((_Bool)1);
  } else {
    tmp___13 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )0);
    if (tmp___13) {
      tmp___0 = handle_in_body(parser, token);
      return (tmp___0);
    } else {
      tmp___12 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )98);
      if (tmp___12) {
        insert_element_from_token(parser, token);
        pop_current_node(parser);
        acknowledge_self_closing_tag(parser);
        return ((_Bool)1);
      } else {
        tmp___11 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )98);
        if (tmp___11) {
          add_parse_error(parser, (GumboToken const   *)token);
          ignore_token(parser);
          return ((_Bool)0);
        } else
        if ((unsigned int )token->type == 7U) {
          tmp___10 = get_current_node(parser);
          if ((unsigned long )tmp___10 == (unsigned long )(parser->_output)->root) {
            return ((_Bool)1);
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          tmp___1 = get_current_node(parser);
          if ((unsigned long )tmp___1 == (unsigned long )(parser->_output)->root) {
            add_parse_error(parser, (GumboToken const   *)token);
            return ((_Bool)0);
          }
          tmp___7 = get_current_node(parser);
          tmp___8 = node_tag_is((GumboNode const   *)tmp___7, (GumboTag )97);
          if (! tmp___8) {
            __assert_fail("node_tag_is(get_current_node(parser), GUMBO_TAG_COLGROUP)",
                          "deps/gumbo-parser/parser.c", 3161U, "handle_in_column_group");
          }
          pop_current_node(parser);
          set_insertion_mode(parser, (GumboInsertionMode )8);
          tmp___9 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )97);
          if (! tmp___9) {
            (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
          }
          return ((_Bool)1);
        }
      }
    }
  }
}
}
static _Bool handle_in_table_body(GumboParser *parser , GumboToken *token ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;

  {
  tmp___9 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )102);
  if (tmp___9) {
    clear_stack_to_table_body_context(parser);
    insert_element_from_token(parser, token);
    set_insertion_mode(parser, (GumboInsertionMode )13);
    return ((_Bool)1);
  } else {
    tmp___8 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 103, 104, 150);
    if (tmp___8) {
      add_parse_error(parser, (GumboToken const   *)token);
      clear_stack_to_table_body_context(parser);
      insert_element_of_tag_type(parser, (GumboTag )102, (GumboParseFlags )8);
      (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
      set_insertion_mode(parser, (GumboInsertionMode )13);
      return ((_Bool)0);
    } else {
      tmp___7 = tag_in((GumboToken const   *)token, (_Bool )kEndTag, 99, 101, 100,
                       150);
      if (tmp___7) {
        tmp = has_an_element_in_table_scope(parser, token->v.end_tag);
        if (! tmp) {
          add_parse_error(parser, (GumboToken const   *)token);
          ignore_token(parser);
          return ((_Bool)0);
        }
        clear_stack_to_table_body_context(parser);
        pop_current_node(parser);
        set_insertion_mode(parser, (GumboInsertionMode )8);
        return ((_Bool)1);
      } else {
        tmp___5 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 96, 98, 97,
                         99, 101, 100, 150);
        if (tmp___5) {
          goto _L;
        } else {
          tmp___6 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )95);
          if (tmp___6) {
            _L: /* CIL Label */ 
            tmp___0 = has_an_element_in_table_scope(parser, (GumboTag )99);
            if (! tmp___0) {
              tmp___1 = has_an_element_in_table_scope(parser, (GumboTag )100);
              if (! tmp___1) {
                tmp___2 = has_an_element_in_table_scope(parser, (GumboTag )101);
                if (! tmp___2) {
                  add_parse_error(parser, (GumboToken const   *)token);
                  ignore_token(parser);
                  return ((_Bool)0);
                }
              }
            }
            clear_stack_to_table_body_context(parser);
            pop_current_node(parser);
            set_insertion_mode(parser, (GumboInsertionMode )8);
            (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
            return ((_Bool)1);
          } else {
            tmp___4 = tag_in((GumboToken const   *)token, (_Bool )kEndTag, 10, 96,
                             98, 102, 97, 0, 103, 104, 150);
            if (tmp___4) {
              add_parse_error(parser, (GumboToken const   *)token);
              ignore_token(parser);
              return ((_Bool)0);
            } else {
              tmp___3 = handle_in_table(parser, token);
              return (tmp___3);
            }
          }
        }
      }
    }
  }
}
}
static _Bool handle_in_row(GumboParser *parser , GumboToken *token ) 
{ 
  GumboTag desired_tag ;
  unsigned int tmp___0 ;
  _Bool tmp___1 ;
  char const   *tmp___2 ;
  int i ;
  GumboNode const   *node ;
  char const   *tmp___3 ;
  _Bool tmp___4 ;
  GumboNode *last_element ;
  GumboNode *tmp___5 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;

  {
  tmp___15 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 104, 103, 150);
  if (tmp___15) {
    clear_stack_to_table_row_context(parser);
    insert_element_from_token(parser, token);
    set_insertion_mode(parser, (GumboInsertionMode )14);
    add_formatting_element(parser, & kActiveFormattingScopeMarker);
    return ((_Bool)1);
  } else {
    tmp___13 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 96, 97, 99,
                      101, 100, 102, 150);
    if (tmp___13) {
      goto _L;
    } else {
      tmp___14 = tag_in((GumboToken const   *)token, (_Bool )kEndTag, 102, 95, 99,
                        101, 100, 150);
      if (tmp___14) {
        _L: /* CIL Label */ 
        tmp___1 = tag_in((GumboToken const   *)token, (_Bool )kEndTag, 99, 101, 100,
                         150);
        if (tmp___1) {
          tmp___0 = (unsigned int )token->v.end_tag;
        } else {
          tmp___0 = 102U;
        }
        desired_tag = (GumboTag )tmp___0;
        tmp___4 = has_an_element_in_table_scope(parser, desired_tag);
        if (! tmp___4) {
          tmp___2 = gumbo_normalized_tagname(desired_tag);
          gumbo_debug("Bailing because there is no tag %s in table scope.\nOpen elements:",
                      tmp___2);
          i = 0;
          while ((unsigned int )i < (parser->_parser_state)->_open_elements.length) {
            node = (GumboNode const   *)*((parser->_parser_state)->_open_elements.data + i);
            tmp___3 = gumbo_normalized_tagname((GumboTag )node->v.element.tag);
            gumbo_debug("%s\n", tmp___3);
            i ++;
          }
          add_parse_error(parser, (GumboToken const   *)token);
          ignore_token(parser);
          return ((_Bool)0);
        }
        clear_stack_to_table_row_context(parser);
        tmp___5 = pop_current_node(parser);
        last_element = tmp___5;
        tmp___9 = node_tag_is((GumboNode const   *)last_element, (GumboTag )102);
        if (! tmp___9) {
          __assert_fail("node_tag_is(last_element, GUMBO_TAG_TR)", "deps/gumbo-parser/parser.c",
                        3259U, "handle_in_row");
        }
        set_insertion_mode(parser, (GumboInsertionMode )12);
        tmp___10 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )102);
        if (! tmp___10) {
          (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
        }
        return ((_Bool)1);
      } else {
        tmp___12 = tag_in((GumboToken const   *)token, (_Bool )kEndTag, 10, 96, 98,
                          97, 0, 103, 104, 150);
        if (tmp___12) {
          add_parse_error(parser, (GumboToken const   *)token);
          ignore_token(parser);
          return ((_Bool)0);
        } else {
          tmp___11 = handle_in_table(parser, token);
          return (tmp___11);
        }
      }
    }
  }
}
}
static _Bool handle_in_cell(GumboParser *parser , GumboToken *token ) 
{ 
  GumboTag token_tag ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;

  {
  tmp___10 = tag_in((GumboToken const   *)token, (_Bool )kEndTag, 103, 104, 150);
  if (tmp___10) {
    token_tag = token->v.end_tag;
    tmp = has_an_element_in_table_scope(parser, token_tag);
    if (! tmp) {
      add_parse_error(parser, (GumboToken const   *)token);
      return ((_Bool)0);
    }
    tmp___0 = close_table_cell(parser, (GumboToken const   *)token, token_tag);
    return (tmp___0);
  } else {
    tmp___9 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 96, 98, 97, 99,
                     103, 101, 104, 100, 102, 150);
    if (tmp___9) {
      gumbo_debug("Handling <td> in cell.\n");
      tmp___1 = has_an_element_in_table_scope(parser, (GumboTag )104);
      if (! tmp___1) {
        tmp___2 = has_an_element_in_table_scope(parser, (GumboTag )103);
        if (! tmp___2) {
          gumbo_debug("Bailing out because there\'s no <td> or <th> in scope.\n");
          add_parse_error(parser, (GumboToken const   *)token);
          ignore_token(parser);
          return ((_Bool)0);
        }
      }
      (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
      tmp___3 = close_current_cell(parser, (GumboToken const   *)token);
      return (tmp___3);
    } else {
      tmp___8 = tag_in((GumboToken const   *)token, (_Bool )kEndTag, 10, 96, 98, 97,
                       0, 150);
      if (tmp___8) {
        add_parse_error(parser, (GumboToken const   *)token);
        ignore_token(parser);
        return ((_Bool)0);
      } else {
        tmp___7 = tag_in((GumboToken const   *)token, (_Bool )kEndTag, 95, 99, 101,
                         100, 102, 150);
        if (tmp___7) {
          tmp___4 = has_an_element_in_table_scope(parser, token->v.end_tag);
          if (! tmp___4) {
            add_parse_error(parser, (GumboToken const   *)token);
            ignore_token(parser);
            return ((_Bool)0);
          }
          (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
          tmp___5 = close_current_cell(parser, (GumboToken const   *)token);
          return (tmp___5);
        } else {
          tmp___6 = handle_in_body(parser, token);
          return (tmp___6);
        }
      }
    }
  }
}
}
static _Bool handle_in_select(GumboParser *parser , GumboToken *token ) 
{ 
  GumboNode *tmp ;
  _Bool tmp___0 ;
  GumboNode *tmp___1 ;
  _Bool tmp___2 ;
  GumboNode *tmp___3 ;
  _Bool tmp___4 ;
  GumboNode *tmp___5 ;
  _Bool tmp___6 ;
  GumboVector *open_elements ;
  GumboNode *tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  GumboNode *tmp___10 ;
  _Bool tmp___11 ;
  GumboNode *tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  GumboNode *tmp___17 ;
  _Bool tmp___18 ;
  _Bool tmp___19 ;
  _Bool tmp___20 ;
  _Bool tmp___21 ;
  _Bool tmp___22 ;
  _Bool tmp___23 ;
  _Bool tmp___24 ;
  _Bool tmp___25 ;
  _Bool tmp___26 ;

  {
  if ((unsigned int )token->type == 6U) {
    add_parse_error(parser, (GumboToken const   *)token);
    ignore_token(parser);
    return ((_Bool)0);
  } else
  if ((unsigned int )token->type == 5U) {
    insert_text_token(parser, token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 4U) {
    insert_text_token(parser, token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 0U) {
    add_parse_error(parser, (GumboToken const   *)token);
    ignore_token(parser);
    return ((_Bool)0);
  } else
  if ((unsigned int )token->type == 3U) {
    tmp = get_current_node(parser);
    append_comment_node(parser, tmp, (GumboToken const   *)token);
    return ((_Bool)1);
  } else {
    tmp___26 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )0);
    if (tmp___26) {
      tmp___0 = handle_in_body(parser, token);
      return (tmp___0);
    } else {
      tmp___25 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )114);
      if (tmp___25) {
        tmp___1 = get_current_node(parser);
        tmp___2 = node_tag_is((GumboNode const   *)tmp___1, (GumboTag )114);
        if (tmp___2) {
          pop_current_node(parser);
        }
        insert_element_from_token(parser, token);
        return ((_Bool)1);
      } else {
        tmp___24 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )113);
        if (tmp___24) {
          tmp___3 = get_current_node(parser);
          tmp___4 = node_tag_is((GumboNode const   *)tmp___3, (GumboTag )114);
          if (tmp___4) {
            pop_current_node(parser);
          }
          tmp___5 = get_current_node(parser);
          tmp___6 = node_tag_is((GumboNode const   *)tmp___5, (GumboTag )113);
          if (tmp___6) {
            pop_current_node(parser);
          }
          insert_element_from_token(parser, token);
          return ((_Bool)1);
        } else {
          tmp___23 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )113);
          if (tmp___23) {
            open_elements = & (parser->_parser_state)->_open_elements;
            tmp___7 = get_current_node(parser);
            tmp___8 = node_tag_is((GumboNode const   *)tmp___7, (GumboTag )114);
            if (tmp___8) {
              tmp___9 = node_tag_is((GumboNode const   *)*(open_elements->data + (open_elements->length - 2U)),
                                    (GumboTag )113);
              if (tmp___9) {
                pop_current_node(parser);
              }
            }
            tmp___10 = get_current_node(parser);
            tmp___11 = node_tag_is((GumboNode const   *)tmp___10, (GumboTag )113);
            if (tmp___11) {
              pop_current_node(parser);
              return ((_Bool)1);
            } else {
              add_parse_error(parser, (GumboToken const   *)token);
              ignore_token(parser);
              return ((_Bool)0);
            }
          } else {
            tmp___22 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )114);
            if (tmp___22) {
              tmp___12 = get_current_node(parser);
              tmp___13 = node_tag_is((GumboNode const   *)tmp___12, (GumboTag )114);
              if (tmp___13) {
                pop_current_node(parser);
                return ((_Bool)1);
              } else {
                add_parse_error(parser, (GumboToken const   *)token);
                ignore_token(parser);
                return ((_Bool)0);
              }
            } else {
              tmp___21 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )111);
              if (tmp___21) {
                tmp___14 = has_an_element_in_select_scope(parser, (GumboTag )111);
                if (! tmp___14) {
                  add_parse_error(parser, (GumboToken const   *)token);
                  ignore_token(parser);
                  return ((_Bool)0);
                }
                close_current_select(parser);
                return ((_Bool)1);
              } else {
                tmp___20 = tag_is((GumboToken const   *)token, (_Bool )kStartTag,
                                  (GumboTag )111);
                if (tmp___20) {
                  add_parse_error(parser, (GumboToken const   *)token);
                  ignore_token(parser);
                  close_current_select(parser);
                  return ((_Bool)0);
                } else {
                  tmp___19 = tag_in((GumboToken const   *)token, (_Bool )kStartTag,
                                    109, 116, 115, 150);
                  if (tmp___19) {
                    add_parse_error(parser, (GumboToken const   *)token);
                    tmp___15 = has_an_element_in_select_scope(parser, (GumboTag )111);
                    if (tmp___15) {
                      close_current_select(parser);
                      (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
                    } else {
                      ignore_token(parser);
                    }
                    return ((_Bool)0);
                  } else {
                    tmp___18 = tag_is((GumboToken const   *)token, (_Bool )kStartTag,
                                      (GumboTag )7);
                    if (tmp___18) {
                      tmp___16 = handle_in_head(parser, token);
                      return (tmp___16);
                    } else
                    if ((unsigned int )token->type == 7U) {
                      tmp___17 = get_current_node(parser);
                      if ((unsigned long )tmp___17 != (unsigned long )(parser->_output)->root) {
                        add_parse_error(parser, (GumboToken const   *)token);
                        return ((_Bool)0);
                      }
                      return ((_Bool)1);
                    } else {
                      add_parse_error(parser, (GumboToken const   *)token);
                      ignore_token(parser);
                      return ((_Bool)0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
}
static _Bool handle_in_select_in_table(GumboParser *parser , GumboToken *token ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  tmp___2 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 96, 95, 99, 101,
                   100, 102, 103, 104, 150);
  if (tmp___2) {
    add_parse_error(parser, (GumboToken const   *)token);
    close_current_select(parser);
    (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
    return ((_Bool)0);
  } else {
    tmp___1 = tag_in((GumboToken const   *)token, (_Bool )kEndTag, 96, 95, 99, 101,
                     100, 102, 103, 104, 150);
    if (tmp___1) {
      add_parse_error(parser, (GumboToken const   *)token);
      tmp = has_an_element_in_table_scope(parser, token->v.end_tag);
      if (tmp) {
        close_current_select(parser);
        reset_insertion_mode_appropriately(parser);
        (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
      } else {
        ignore_token(parser);
      }
      return ((_Bool)0);
    } else {
      tmp___0 = handle_in_select(parser, token);
      return (tmp___0);
    }
  }
}
}
static _Bool handle_in_template(GumboParser *parser , GumboToken *token ) 
{ 


  {
  return ((_Bool)1);
}
}
static _Bool handle_after_body(GumboParser *parser , GumboToken *token ) 
{ 
  _Bool tmp ;
  GumboNode *html_node ;
  GumboNode *html ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;

  {
  if ((unsigned int )token->type == 4U) {
    tmp = handle_in_body(parser, token);
    return (tmp);
  } else {
    tmp___6 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )0);
    if (tmp___6) {
      tmp = handle_in_body(parser, token);
      return (tmp);
    } else
    if ((unsigned int )token->type == 3U) {
      html_node = (parser->_output)->root;
      if (! ((unsigned long )html_node != (unsigned long )((void *)0))) {
        __assert_fail("html_node != NULL", "deps/gumbo-parser/parser.c", 3456U, "handle_after_body");
      }
      append_comment_node(parser, html_node, (GumboToken const   *)token);
      return ((_Bool)1);
    } else
    if ((unsigned int )token->type == 0U) {
      add_parse_error(parser, (GumboToken const   *)token);
      ignore_token(parser);
      return ((_Bool)0);
    } else {
      tmp___5 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )0);
      if (tmp___5) {
        set_insertion_mode(parser, (GumboInsertionMode )21);
        html = (GumboNode *)*((parser->_parser_state)->_open_elements.data + 0);
        tmp___4 = node_tag_is((GumboNode const   *)html, (GumboTag )0);
        if (! tmp___4) {
          __assert_fail("node_tag_is(html, GUMBO_TAG_HTML)", "deps/gumbo-parser/parser.c",
                        3467U, "handle_after_body");
        }
        record_end_of_element((parser->_parser_state)->_current_token, & html->v.element);
        return ((_Bool)1);
      } else
      if ((unsigned int )token->type == 7U) {
        return ((_Bool)1);
      } else {
        add_parse_error(parser, (GumboToken const   *)token);
        set_insertion_mode(parser, (GumboInsertionMode )6);
        (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
        return ((_Bool)0);
      }
    }
  }
}
}
static _Bool handle_in_frameset(GumboParser *parser , GumboToken *token ) 
{ 
  GumboNode *tmp ;
  _Bool tmp___0 ;
  GumboNode *tmp___1 ;
  _Bool tmp___2 ;
  GumboNode *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  GumboNode *tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;

  {
  if ((unsigned int )token->type == 4U) {
    insert_text_token(parser, token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 3U) {
    tmp = get_current_node(parser);
    append_comment_node(parser, tmp, (GumboToken const   *)token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 0U) {
    add_parse_error(parser, (GumboToken const   *)token);
    ignore_token(parser);
    return ((_Bool)0);
  } else {
    tmp___12 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )0);
    if (tmp___12) {
      tmp___0 = handle_in_body(parser, token);
      return (tmp___0);
    } else {
      tmp___11 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )129);
      if (tmp___11) {
        insert_element_from_token(parser, token);
        return ((_Bool)1);
      } else {
        tmp___10 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )129);
        if (tmp___10) {
          tmp___1 = get_current_node(parser);
          tmp___2 = node_tag_is((GumboNode const   *)tmp___1, (GumboTag )0);
          if (tmp___2) {
            add_parse_error(parser, (GumboToken const   *)token);
            ignore_token(parser);
            return ((_Bool)0);
          }
          pop_current_node(parser);
          tmp___3 = get_current_node(parser);
          tmp___4 = node_tag_is((GumboNode const   *)tmp___3, (GumboTag )129);
          if (! tmp___4) {
            set_insertion_mode(parser, (GumboInsertionMode )20);
          }
          return ((_Bool)1);
        } else {
          tmp___9 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )128);
          if (tmp___9) {
            insert_element_from_token(parser, token);
            pop_current_node(parser);
            acknowledge_self_closing_tag(parser);
            return ((_Bool)1);
          } else {
            tmp___8 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )130);
            if (tmp___8) {
              tmp___5 = handle_in_head(parser, token);
              return (tmp___5);
            } else
            if ((unsigned int )token->type == 7U) {
              tmp___6 = get_current_node(parser);
              tmp___7 = node_tag_is((GumboNode const   *)tmp___6, (GumboTag )0);
              if (! tmp___7) {
                add_parse_error(parser, (GumboToken const   *)token);
                return ((_Bool)0);
              }
              return ((_Bool)1);
            } else {
              add_parse_error(parser, (GumboToken const   *)token);
              ignore_token(parser);
              return ((_Bool)0);
            }
          }
        }
      }
    }
  }
}
}
static _Bool handle_after_frameset(GumboParser *parser , GumboToken *token ) 
{ 
  GumboNode *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  if ((unsigned int )token->type == 4U) {
    insert_text_token(parser, token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 3U) {
    tmp = get_current_node(parser);
    append_comment_node(parser, tmp, (GumboToken const   *)token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 0U) {
    add_parse_error(parser, (GumboToken const   *)token);
    ignore_token(parser);
    return ((_Bool)0);
  } else {
    tmp___4 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )0);
    if (tmp___4) {
      tmp___0 = handle_in_body(parser, token);
      return (tmp___0);
    } else {
      tmp___3 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )0);
      if (tmp___3) {
        set_insertion_mode(parser, (GumboInsertionMode )22);
        return ((_Bool)1);
      } else {
        tmp___2 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )130);
        if (tmp___2) {
          tmp___1 = handle_in_head(parser, token);
          return (tmp___1);
        } else
        if ((unsigned int )token->type == 7U) {
          return ((_Bool)1);
        } else {
          add_parse_error(parser, (GumboToken const   *)token);
          ignore_token(parser);
          return ((_Bool)0);
        }
      }
    }
  }
}
}
static _Bool handle_after_after_body(GumboParser *parser , GumboToken *token ) 
{ 
  GumboNode *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  if ((unsigned int )token->type == 3U) {
    tmp = get_document_node(parser);
    append_comment_node(parser, tmp, (GumboToken const   *)token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 0U) {
    tmp___0 = handle_in_body(parser, token);
    return (tmp___0);
  } else
  if ((unsigned int )token->type == 4U) {
    tmp___0 = handle_in_body(parser, token);
    return (tmp___0);
  } else {
    tmp___1 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )0);
    if (tmp___1) {
      tmp___0 = handle_in_body(parser, token);
      return (tmp___0);
    } else
    if ((unsigned int )token->type == 7U) {
      return ((_Bool)1);
    } else {
      add_parse_error(parser, (GumboToken const   *)token);
      set_insertion_mode(parser, (GumboInsertionMode )6);
      (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
      return ((_Bool)0);
    }
  }
}
}
static _Bool handle_after_after_frameset(GumboParser *parser , GumboToken *token ) 
{ 
  GumboNode *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  if ((unsigned int )token->type == 3U) {
    tmp = get_document_node(parser);
    append_comment_node(parser, tmp, (GumboToken const   *)token);
    return ((_Bool)1);
  } else
  if ((unsigned int )token->type == 0U) {
    tmp___0 = handle_in_body(parser, token);
    return (tmp___0);
  } else
  if ((unsigned int )token->type == 4U) {
    tmp___0 = handle_in_body(parser, token);
    return (tmp___0);
  } else {
    tmp___3 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )0);
    if (tmp___3) {
      tmp___0 = handle_in_body(parser, token);
      return (tmp___0);
    } else
    if ((unsigned int )token->type == 7U) {
      return ((_Bool)1);
    } else {
      tmp___2 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )130);
      if (tmp___2) {
        tmp___1 = handle_in_head(parser, token);
        return (tmp___1);
      } else {
        add_parse_error(parser, (GumboToken const   *)token);
        ignore_token(parser);
        return ((_Bool)0);
      }
    }
  }
}
}
static TokenHandler const   kTokenHandlers[23]  = 
  {      (TokenHandler const   )(& handle_initial),      (TokenHandler const   )(& handle_before_html),      (TokenHandler const   )(& handle_before_head),      (TokenHandler const   )(& handle_in_head), 
        (TokenHandler const   )(& handle_in_head_noscript),      (TokenHandler const   )(& handle_after_head),      (TokenHandler const   )(& handle_in_body),      (TokenHandler const   )(& handle_text), 
        (TokenHandler const   )(& handle_in_table),      (TokenHandler const   )(& handle_in_table_text),      (TokenHandler const   )(& handle_in_caption),      (TokenHandler const   )(& handle_in_column_group), 
        (TokenHandler const   )(& handle_in_table_body),      (TokenHandler const   )(& handle_in_row),      (TokenHandler const   )(& handle_in_cell),      (TokenHandler const   )(& handle_in_select), 
        (TokenHandler const   )(& handle_in_select_in_table),      (TokenHandler const   )(& handle_in_template),      (TokenHandler const   )(& handle_after_body),      (TokenHandler const   )(& handle_in_frameset), 
        (TokenHandler const   )(& handle_after_frameset),      (TokenHandler const   )(& handle_after_after_body),      (TokenHandler const   )(& handle_after_after_frameset)};
static _Bool handle_html_content(GumboParser *parser , GumboToken *token ) 
{ 
  _Bool tmp ;

  {
  tmp = (*(kTokenHandlers[(unsigned int )(parser->_parser_state)->_insertion_mode]))(parser,
                                                                                     token);
  return (tmp);
}
}
static _Bool handle_in_foreign_content(GumboParser *parser , GumboToken *token ) 
{ 
  GumboNode *tmp ;
  GumboNode *tmp___0 ;
  _Bool tmp___1 ;
  GumboNode *tmp___2 ;
  _Bool tmp___3 ;
  GumboNode *tmp___4 ;
  GumboNamespaceEnum current_namespace ;
  GumboNode *tmp___5 ;
  GumboNode *node ;
  GumboNode *tmp___7 ;
  GumboStringPiece token_tagname ;
  GumboStringPiece node_tagname ;
  _Bool is_success ;
  _Bool tmp___9 ;
  int i ;
  GumboNode *tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  _Bool tmp___18 ;
  _Bool tmp___19 ;

  {
  switch ((unsigned int )token->type) {
  case 6U: 
  add_parse_error(parser, (GumboToken const   *)token);
  token->type = (GumboTokenType )5;
  token->v.character = (int )kUtf8ReplacementChar;
  insert_text_token(parser, token);
  return ((_Bool)0);
  case 4U: 
  insert_text_token(parser, token);
  return ((_Bool)1);
  case 5U: 
  insert_text_token(parser, token);
  set_frameset_not_ok(parser);
  return ((_Bool)1);
  case 3U: 
  tmp = get_current_node(parser);
  append_comment_node(parser, tmp, (GumboToken const   *)token);
  return ((_Bool)1);
  case 0U: 
  add_parse_error(parser, (GumboToken const   *)token);
  ignore_token(parser);
  return ((_Bool)0);
  default: 
  break;
  }
  tmp___15 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 57, 140, 28, 10,
                    66, 142, 50, 34, 38, 32, 33, 40, 73, 15, 16, 17, 18, 19, 20, 1,
                    26, 56, 71, 31, 132, 122, 5, 146, 29, 25, 27, 60, 43, 42, 65,
                    41, 138, 54, 55, 95, 148, 58, 30, 51, 150);
  if (tmp___15) {
    goto _L___1;
  } else {
    tmp___16 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )143);
    if (tmp___16) {
      tmp___17 = token_has_attribute((GumboToken const   *)token, "color");
      if (tmp___17) {
        goto _L___1;
      } else {
        tmp___18 = token_has_attribute((GumboToken const   *)token, "face");
        if (tmp___18) {
          goto _L___1;
        } else {
          tmp___19 = token_has_attribute((GumboToken const   *)token, "size");
          if (tmp___19) {
            _L___1: /* CIL Label */ 
            add_parse_error(parser, (GumboToken const   *)token);
            while (1) {
              pop_current_node(parser);
              tmp___0 = get_current_node(parser);
              tmp___1 = is_mathml_integration_point((GumboNode const   *)tmp___0);
              if (tmp___1) {
                break;
              } else {
                tmp___2 = get_current_node(parser);
                tmp___3 = is_html_integration_point((GumboNode const   *)tmp___2);
                if (tmp___3) {
                  break;
                } else {
                  tmp___4 = get_current_node(parser);
                  if ((unsigned int )tmp___4->v.element.tag_namespace == 0U) {
                    break;
                  }
                }
              }
            }
            (parser->_parser_state)->_reprocess_current_token = (_Bool)1;
            return ((_Bool)0);
          } else {
            goto _L___0;
          }
        }
      }
    } else
    _L___0: /* CIL Label */ 
    if ((unsigned int )token->type == 1U) {
      tmp___5 = get_current_node(parser);
      current_namespace = tmp___5->v.element.tag_namespace;
      if ((unsigned int )current_namespace == 2U) {
        adjust_mathml_attributes(parser, token);
      }
      if ((unsigned int )current_namespace == 1U) {
        adjust_svg_attributes(parser, token);
      }
      adjust_foreign_attributes(parser, token);
      insert_foreign_element(parser, token, current_namespace);
      if (token->v.start_tag.is_self_closing) {
        pop_current_node(parser);
        acknowledge_self_closing_tag(parser);
      }
      return ((_Bool)1);
    } else {
      if (! ((unsigned int )token->type == 2U)) {
        __assert_fail("token->type == GUMBO_TOKEN_END_TAG", "deps/gumbo-parser/parser.c",
                      3708U, "handle_in_foreign_content");
      }
      tmp___7 = get_current_node(parser);
      node = tmp___7;
      if (! ((unsigned long )node != (unsigned long )((void *)0))) {
        __assert_fail("node != NULL", "deps/gumbo-parser/parser.c", 3710U, "handle_in_foreign_content");
      }
      token_tagname = token->original_text;
      node_tagname = node->v.element.original_tag;
      gumbo_tag_from_original_text(& token_tagname);
      gumbo_tag_from_original_text(& node_tagname);
      is_success = (_Bool)1;
      tmp___9 = gumbo_string_equals_ignore_case((GumboStringPiece const   *)(& node_tagname),
                                                (GumboStringPiece const   *)(& token_tagname));
      if (! tmp___9) {
        add_parse_error(parser, (GumboToken const   *)token);
        is_success = (_Bool)0;
      }
      i = (int )(parser->_parser_state)->_open_elements.length;
      i --;
      while (i > 0) {
        gumbo_debug("Foreign %.*s node at %d.\n", node_tagname.length, node_tagname.data,
                    i);
        tmp___11 = gumbo_string_equals_ignore_case((GumboStringPiece const   *)(& node_tagname),
                                                   (GumboStringPiece const   *)(& token_tagname));
        if (tmp___11) {
          gumbo_debug("Matches.\n");
          while (1) {
            tmp___10 = pop_current_node(parser);
            if (! ((unsigned long )tmp___10 != (unsigned long )node)) {
              break;
            }
          }
          return (is_success);
        }
        i --;
        node = (GumboNode *)*((parser->_parser_state)->_open_elements.data + i);
        if ((unsigned int )node->v.element.tag_namespace == 0U) {
          break;
        }
        node_tagname = node->v.element.original_tag;
        gumbo_tag_from_original_text(& node_tagname);
      }
      if (! ((unsigned int )node->v.element.tag_namespace == 0U)) {
        __assert_fail("node->v.element.tag_namespace == GUMBO_NAMESPACE_HTML", "deps/gumbo-parser/parser.c",
                      3748U, "handle_in_foreign_content");
      }
      tmp___13 = handle_html_content(parser, token);
      if (tmp___13) {
        if (is_success) {
          tmp___14 = 1;
        } else {
          tmp___14 = 0;
        }
      } else {
        tmp___14 = 0;
      }
      return ((_Bool )tmp___14);
    }
  }
}
}
static _Bool handle_token(GumboParser *parser , GumboToken *token ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  GumboNode const   *current_node ;
  GumboNode *tmp___1 ;
  char const   *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;

  {
  if ((parser->_parser_state)->_ignore_next_linefeed) {
    if ((unsigned int )token->type == 4U) {
      if (token->v.character == 10) {
        (parser->_parser_state)->_ignore_next_linefeed = (_Bool)0;
        ignore_token(parser);
        return ((_Bool)1);
      }
    }
  }
  (parser->_parser_state)->_ignore_next_linefeed = (_Bool)0;
  tmp = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )10);
  if (tmp) {
    (parser->_parser_state)->_closed_body_tag = (_Bool)1;
  }
  tmp___0 = tag_is((GumboToken const   *)token, (_Bool )kEndTag, (GumboTag )0);
  if (tmp___0) {
    (parser->_parser_state)->_closed_html_tag = (_Bool)1;
  }
  tmp___1 = get_current_node(parser);
  current_node = (GumboNode const   *)tmp___1;
  if (! (! current_node)) {
    if (! ((unsigned int const   )current_node->type == 1U)) {
      __assert_fail("!current_node || current_node->type == GUMBO_NODE_ELEMENT", "deps/gumbo-parser/parser.c",
                    3779U, "handle_token");
    }
  }
  if (current_node) {
    tmp___3 = gumbo_normalized_tagname((GumboTag )current_node->v.element.tag);
    gumbo_debug("Current node: <%s>.\n", tmp___3);
  }
  if (! current_node) {
    tmp___4 = handle_html_content(parser, token);
    return (tmp___4);
  } else
  if ((unsigned int const   )current_node->v.element.tag_namespace == 0U) {
    tmp___4 = handle_html_content(parser, token);
    return (tmp___4);
  } else {
    tmp___6 = is_mathml_integration_point(current_node);
    if (tmp___6) {
      if ((unsigned int )token->type == 5U) {
        tmp___4 = handle_html_content(parser, token);
        return (tmp___4);
      } else
      if ((unsigned int )token->type == 4U) {
        tmp___4 = handle_html_content(parser, token);
        return (tmp___4);
      } else
      if ((unsigned int )token->type == 6U) {
        tmp___4 = handle_html_content(parser, token);
        return (tmp___4);
      } else
      if ((unsigned int )token->type == 1U) {
        tmp___7 = tag_in((GumboToken const   *)token, (_Bool )kStartTag, 89, 90, 150);
        if (tmp___7) {
          goto _L___2;
        } else {
          tmp___4 = handle_html_content(parser, token);
          return (tmp___4);
        }
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    if ((unsigned int const   )current_node->v.element.tag_namespace == 2U) {
      tmp___8 = node_tag_is(current_node, (GumboTag )91);
      if (tmp___8) {
        tmp___9 = tag_is((GumboToken const   *)token, (_Bool )kStartTag, (GumboTag )92);
        if (tmp___9) {
          tmp___4 = handle_html_content(parser, token);
          return (tmp___4);
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      tmp___10 = is_html_integration_point(current_node);
      if (tmp___10) {
        if ((unsigned int )token->type == 1U) {
          tmp___4 = handle_html_content(parser, token);
          return (tmp___4);
        } else
        if ((unsigned int )token->type == 5U) {
          tmp___4 = handle_html_content(parser, token);
          return (tmp___4);
        } else
        if ((unsigned int )token->type == 6U) {
          tmp___4 = handle_html_content(parser, token);
          return (tmp___4);
        } else
        if ((unsigned int )token->type == 4U) {
          tmp___4 = handle_html_content(parser, token);
          return (tmp___4);
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if ((unsigned int )token->type == 7U) {
        tmp___4 = handle_html_content(parser, token);
        return (tmp___4);
      } else {
        tmp___5 = handle_in_foreign_content(parser, token);
        return (tmp___5);
      }
    }
  }
}
}
GumboOutput *gumbo_parse(char const   *buffer ) 
{ 
  size_t tmp ;
  GumboOutput *tmp___0 ;

  {
  tmp = strlen(buffer);
  tmp___0 = gumbo_parse_with_options(& kGumboDefaultOptions, buffer, tmp);
  return (tmp___0);
}
}
GumboOutput *gumbo_parse_with_options(GumboOptions const   *options , char const   *buffer ,
                                      size_t length ) 
{ 
  GumboParser parser ;
  GumboParserState *state ;
  int loop_count ;
  GumboToken token ;
  _Bool has_error ;
  GumboNode *current_node ;
  GumboNode *tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  char const   *token_type ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  GumboError *error___0 ;
  GumboError *tmp___7 ;
  GumboDocument *doc_type ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  parser._options = options;
  output_init(& parser);
  gumbo_tokenizer_state_init(& parser, buffer, length);
  parser_state_init(& parser);
  state = parser._parser_state;
  gumbo_debug("Parsing %.*s.\n", length, buffer);
  loop_count = 0;
  has_error = (_Bool)0;
  while (1) {
    if (state->_reprocess_current_token) {
      state->_reprocess_current_token = (_Bool)0;
    } else {
      tmp = get_current_node(& parser);
      current_node = tmp;
      if (current_node) {
        if ((unsigned int )current_node->v.element.tag_namespace != 0U) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
      gumbo_tokenizer_set_is_current_node_foreign(& parser, (_Bool )tmp___0);
      tmp___1 = gumbo_lex(& parser, & token);
      if (tmp___1) {
        if (has_error) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 1;
      }
      has_error = (_Bool )tmp___2;
    }
    token_type = "text";
    switch ((unsigned int )token.type) {
    case 0U: 
    token_type = "doctype";
    break;
    case 1U: 
    token_type = gumbo_normalized_tagname(token.v.start_tag.tag);
    break;
    case 2U: 
    token_type = gumbo_normalized_tagname(token.v.end_tag);
    break;
    case 3U: 
    token_type = "comment";
    break;
    default: 
    break;
    }
    gumbo_debug("Handling %s token @%d:%d in state %d.\n", (char *)token_type, token.position.line,
                token.position.column, (unsigned int )state->_insertion_mode);
    state->_current_token = & token;
    if ((unsigned int )token.type == 1U) {
      if (token.v.start_tag.is_self_closing) {
        tmp___3 = 0;
      } else {
        tmp___3 = 1;
      }
    } else {
      tmp___3 = 1;
    }
    state->_self_closing_flag_acknowledged = (_Bool )tmp___3;
    tmp___4 = handle_token(& parser, & token);
    if (tmp___4) {
      if (has_error) {
        tmp___5 = 1;
      } else {
        tmp___5 = 0;
      }
    } else {
      tmp___5 = 1;
    }
    has_error = (_Bool )tmp___5;
    if (! state->_reprocess_current_token) {
      if (! ((unsigned int )token.type != 1U)) {
        if (! ((unsigned long )token.v.start_tag.attributes.data == (unsigned long )((void *)0))) {
          __assert_fail("state->_reprocess_current_token || token.type != GUMBO_TOKEN_START_TAG || token.v.start_tag.attributes.data == NULL",
                        "deps/gumbo-parser/parser.c", 3872U, "gumbo_parse_with_options");
        }
      }
    }
    if (! state->_self_closing_flag_acknowledged) {
      tmp___7 = add_parse_error(& parser, (GumboToken const   *)(& token));
      error___0 = tmp___7;
      if (error___0) {
        error___0->type = (GumboErrorType )41;
      }
    }
    loop_count ++;
    if (! (loop_count < 1000000000)) {
      __assert_fail("loop_count < 1000000000", "deps/gumbo-parser/parser.c", 3882U,
                    "gumbo_parse_with_options");
    }
    if ((unsigned int )token.type != 7U) {
      goto _L;
    } else
    if (state->_reprocess_current_token) {
      _L: /* CIL Label */ 
      if (options->stop_on_first_error) {
        if (has_error) {
          break;
        }
      }
    } else {
      break;
    }
  }
  finish_parsing(& parser);
  doc_type = & ((parser._output)->document)->v.document;
  if ((unsigned long )doc_type->name == (unsigned long )((void *)0)) {
    tmp___9 = gumbo_copy_stringz(& parser, "");
    doc_type->name = (char const   *)tmp___9;
  }
  if ((unsigned long )doc_type->public_identifier == (unsigned long )((void *)0)) {
    tmp___10 = gumbo_copy_stringz(& parser, "");
    doc_type->public_identifier = (char const   *)tmp___10;
  }
  if ((unsigned long )doc_type->system_identifier == (unsigned long )((void *)0)) {
    tmp___11 = gumbo_copy_stringz(& parser, "");
    doc_type->system_identifier = (char const   *)tmp___11;
  }
  parser_state_destroy(& parser);
  gumbo_tokenizer_state_destroy(& parser);
  return (parser._output);
}
}
void gumbo_destroy_node(GumboOptions *options , GumboNode *node ) 
{ 
  GumboParser parser ;

  {
  parser._options = (struct GumboInternalOptions  const  *)options;
  destroy_node(& parser, node);
  return;
}
}
void gumbo_destroy_output(GumboOptions const   *options , GumboOutput *output ) 
{ 
  GumboParser parser ;
  int i ;

  {
  parser._options = options;
  destroy_node(& parser, output->document);
  i = 0;
  while ((unsigned int )i < output->errors.length) {
    gumbo_error_destroy(& parser, (GumboError *)*(output->errors.data + i));
    i ++;
  }
  gumbo_vector_destroy(& parser, & output->errors);
  gumbo_parser_deallocate(& parser, (void *)output);
  return;
}
}
#pragma merger("0","/tmp/cil-8Ock61Cv.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
void gumbo_string_buffer_reserve(struct GumboInternalParser *parser , size_t min_capacity ,
                                 GumboStringBuffer *output ) ;
void gumbo_destroy_errors(struct GumboInternalParser *parser ) ;
void gumbo_error_to_string(struct GumboInternalParser *parser , GumboError const   *error___0 ,
                           GumboStringBuffer *output ) ;
void gumbo_caret_diagnostic_to_string(struct GumboInternalParser *parser , GumboError const   *error___0 ,
                                      char const   *source_text , GumboStringBuffer *output ) ;
void gumbo_print_caret_diagnostic(struct GumboInternalParser *parser , GumboError const   *error___0 ,
                                  char const   *source_text ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
static int print_message(GumboParser *parser , GumboStringBuffer *output , char const   *format 
                         , ...) 
{ 
  va_list___0 args ;
  int remaining_capacity ;
  int bytes_written ;
  int tmp ;

  {
  __builtin_va_start(args, format);
  remaining_capacity = (int )(output->capacity - output->length);
  tmp = vsnprintf((char * __restrict  )(output->data + output->length), (size_t )remaining_capacity,
                  (char const   * __restrict  )format, args);
  bytes_written = tmp;
  if (bytes_written > remaining_capacity) {
    gumbo_string_buffer_reserve(parser, output->capacity + (size_t )bytes_written,
                                output);
    remaining_capacity = (int )(output->capacity - output->length);
    bytes_written = vsnprintf((char * __restrict  )(output->data + output->length),
                              (size_t )remaining_capacity, (char const   * __restrict  )format,
                              args);
  }
  output->length += (size_t )bytes_written;
  __builtin_va_end(args);
  return (bytes_written);
}
}
static void print_tag_stack(GumboParser *parser , GumboParserError const   *error___0 ,
                            GumboStringBuffer *output ) 
{ 
  int i ;
  GumboTag tag ;
  char const   *tmp ;

  {
  print_message(parser, output, "  Currently open tags: ");
  i = 0;
  while ((unsigned int const   )i < error___0->tag_stack.length) {
    if (i) {
      print_message(parser, output, ", ");
    }
    tag = (GumboTag )*(error___0->tag_stack.data + i);
    tmp = gumbo_normalized_tagname(tag);
    print_message(parser, output, tmp);
    i ++;
  }
  gumbo_string_buffer_append_codepoint(parser, '.', output);
  return;
}
}
static void handle_parser_error(GumboParser *parser , GumboParserError const   *error___0 ,
                                GumboStringBuffer *output ) 
{ 


  {
  if ((unsigned int const   )error___0->parser_state == 0U) {
    if ((unsigned int const   )error___0->input_type != 0U) {
      print_message(parser, output, "The doctype must be the first token in the document");
      return;
    }
  }
  switch ((unsigned int const   )error___0->input_type) {
  case 0U: 
  print_message(parser, output, "This is not a legal doctype");
  return;
  case 3U: 
  __assert_fail("0", "deps/gumbo-parser/error.c", 84U, "handle_parser_error");
  print_message(parser, output, "Comments aren\'t legal here");
  return;
  case 5U: 
  case 4U: 
  print_message(parser, output, "Character tokens aren\'t legal here");
  return;
  case 6U: 
  print_message(parser, output, "Null bytes are not allowed in HTML5");
  return;
  case 7U: 
  if ((unsigned int const   )error___0->parser_state == 0U) {
    print_message(parser, output, "You must provide a doctype");
  } else {
    print_message(parser, output, "Premature end of file");
    print_tag_stack(parser, error___0, output);
  }
  return;
  case 2U: 
  case 1U: 
  print_message(parser, output, "That tag isn\'t allowed here");
  print_tag_stack(parser, error___0, output);
  return;
  }
  return;
}
}
static char const   *find_last_newline(char const   *original_text , char const   *error_location ) 
{ 
  char const   *c ;
  char const   *tmp___1 ;

  {
  if (! ((unsigned long )error_location >= (unsigned long )original_text)) {
    __assert_fail("error_location >= original_text", "deps/gumbo-parser/error.c",
                  117U, "find_last_newline");
  }
  c = error_location;
  while (1) {
    if ((unsigned long )c != (unsigned long )original_text) {
      if (! ((int const   )*c != 10)) {
        break;
      }
    } else {
      break;
    }
    if (! *c) {
      if (! ((unsigned long )c == (unsigned long )error_location)) {
        __assert_fail("*c || c == error_location", "deps/gumbo-parser/error.c", 121U,
                      "find_last_newline");
      }
    }
    c --;
  }
  if ((unsigned long )c == (unsigned long )original_text) {
    tmp___1 = c;
  } else {
    tmp___1 = c + 1;
  }
  return (tmp___1);
}
}
static char const   *find_next_newline(char const   *original_text , char const   *error_location ) 
{ 
  char const   *c ;

  {
  c = error_location;
  while (1) {
    if (*c) {
      if (! ((int const   )*c != 10)) {
        break;
      }
    } else {
      break;
    }
    c ++;
  }
  return (c);
}
}
GumboError *gumbo_add_error(struct GumboInternalParser *parser ) 
{ 
  int max_errors ;
  GumboError *error___0 ;
  void *tmp ;

  {
  max_errors = (int )(parser->_options)->max_errors;
  if (max_errors < 0) {
    if ((parser->_output)->errors.length >= (unsigned int )max_errors) {
      return ((GumboError *)((void *)0));
    }
  }
  tmp = gumbo_parser_allocate(parser, sizeof(GumboError ));
  error___0 = (GumboError *)tmp;
  gumbo_vector_add(parser, (void *)error___0, & (parser->_output)->errors);
  return (error___0);
}
}
void gumbo_error_to_string(struct GumboInternalParser *parser , GumboError const   *error___0 ,
                           GumboStringBuffer *output ) 
{ 


  {
  print_message(parser, output, "@%d:%d: ", error___0->position.line, error___0->position.column);
  switch ((unsigned int const   )error___0->type) {
  case 0U: 
  print_message(parser, output, "Invalid UTF8 character 0x%x", error___0->v.codepoint);
  break;
  case 1U: 
  print_message(parser, output, "Input stream ends with a truncated UTF8 character 0x%x",
                error___0->v.codepoint);
  break;
  case 3U: 
  print_message(parser, output, "No digits after &# in numeric character reference");
  break;
  case 4U: 
  print_message(parser, output, "The numeric character reference &#%d should be followed by a semicolon",
                error___0->v.codepoint);
  break;
  case 5U: 
  print_message(parser, output, "The numeric character reference &#%d; encodes an invalid unicode codepoint",
                error___0->v.codepoint);
  break;
  case 6U: 
  print_message(parser, output, "The named character reference &%.*s should be followed by a semicolon",
                (int )error___0->v.text.length, error___0->v.text.data);
  break;
  case 7U: 
  print_message(parser, output, "The named character reference &%.*s; is not a valid entity name",
                (int )error___0->v.text.length, error___0->v.text.data);
  break;
  case 24U: 
  print_message(parser, output, "Attribute %s occurs multiple times, at positions %d and %d",
                error___0->v.duplicate_attr.name, error___0->v.duplicate_attr.original_index,
                error___0->v.duplicate_attr.new_index);
  break;
  case 41U: 
  case 40U: 
  handle_parser_error(parser, & error___0->v.parser, output);
  break;
  default: 
  print_message(parser, output, "Tokenizer error with an unimplemented error message");
  break;
  }
  gumbo_string_buffer_append_codepoint(parser, '.', output);
  return;
}
}
void gumbo_caret_diagnostic_to_string(struct GumboInternalParser *parser , GumboError const   *error___0 ,
                                      char const   *source_text , GumboStringBuffer *output ) 
{ 
  char const   *line_start ;
  char const   *tmp ;
  char const   *line_end ;
  char const   *tmp___0 ;
  GumboStringPiece original_line ;
  int num_spaces ;

  {
  gumbo_error_to_string(parser, error___0, output);
  tmp = find_last_newline(source_text, (char const   *)error___0->original_text);
  line_start = tmp;
  tmp___0 = find_next_newline(source_text, (char const   *)error___0->original_text);
  line_end = tmp___0;
  original_line.data = line_start;
  original_line.length = (size_t )(line_end - line_start);
  gumbo_string_buffer_append_codepoint(parser, '\n', output);
  gumbo_string_buffer_append_string(parser, & original_line, output);
  gumbo_string_buffer_append_codepoint(parser, '\n', output);
  gumbo_string_buffer_reserve(parser, output->length + (size_t )error___0->position.column,
                              output);
  num_spaces = (int )(error___0->position.column - 1U);
  memset((void *)(output->data + output->length), ' ', (size_t )num_spaces);
  output->length += (size_t )num_spaces;
  gumbo_string_buffer_append_codepoint(parser, '^', output);
  gumbo_string_buffer_append_codepoint(parser, '\n', output);
  return;
}
}
void gumbo_print_caret_diagnostic(struct GumboInternalParser *parser , GumboError const   *error___0 ,
                                  char const   *source_text ) 
{ 
  GumboStringBuffer text ;

  {
  gumbo_string_buffer_init(parser, & text);
  gumbo_caret_diagnostic_to_string(parser, error___0, source_text, & text);
  printf((char const   * __restrict  )"%.*s", (int )text.length, text.data);
  gumbo_string_buffer_destroy(parser, & text);
  return;
}
}
void gumbo_error_destroy(struct GumboInternalParser *parser , GumboError *error___0 ) 
{ 


  {
  if ((unsigned int )error___0->type == 40U) {
    gumbo_vector_destroy(parser, & error___0->v.parser.tag_stack);
  } else
  if ((unsigned int )error___0->type == 41U) {
    gumbo_vector_destroy(parser, & error___0->v.parser.tag_stack);
  } else
  if ((unsigned int )error___0->type == 24U) {
    gumbo_parser_deallocate(parser, (void *)error___0->v.duplicate_attr.name);
  }
  gumbo_parser_deallocate(parser, (void *)error___0);
  return;
}
}
void gumbo_init_errors(struct GumboInternalParser *parser ) 
{ 


  {
  gumbo_vector_init(parser, (size_t )5, & (parser->_output)->errors);
  return;
}
}
void gumbo_destroy_errors(struct GumboInternalParser *parser ) 
{ 
  int i ;

  {
  i = 0;
  while ((unsigned int )i < (parser->_output)->errors.length) {
    gumbo_error_destroy(parser, (GumboError *)*((parser->_output)->errors.data + i));
    i ++;
  }
  gumbo_vector_destroy(parser, & (parser->_output)->errors);
  return;
}
}
#pragma merger("0","/tmp/cil-QiwA5E3Q.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
_Bool utf8_is_invalid_code_point(int c ) ;
void utf8iterator_init(struct GumboInternalParser *parser , char const   *source ,
                       size_t source_length , Utf8Iterator *iter ) ;
void utf8iterator_next(Utf8Iterator *iter ) ;
int utf8iterator_current(Utf8Iterator const   *iter ) ;
void utf8iterator_get_position(Utf8Iterator const   *iter , GumboSourcePosition *output ) ;
char const   *utf8iterator_get_char_pointer(Utf8Iterator const   *iter ) ;
_Bool utf8iterator_maybe_consume_match(Utf8Iterator *iter , char const   *prefix ,
                                       size_t length , _Bool case_sensitive ) ;
void utf8iterator_mark(Utf8Iterator *iter ) ;
void utf8iterator_reset(Utf8Iterator *iter ) ;
void utf8iterator_fill_error_at_mark(Utf8Iterator *iter , struct GumboInternalError *error___0 ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
int const   kUtf8ReplacementChar  =    (int const   )65533;
static void add_error(Utf8Iterator *iter , GumboErrorType type ) 
{ 
  GumboParser *parser ;
  GumboError *error___0 ;
  GumboError *tmp ;
  uint64_t code_point ;
  int i ;

  {
  parser = iter->_parser;
  tmp = gumbo_add_error(parser);
  error___0 = tmp;
  if (! error___0) {
    return;
  }
  error___0->type = type;
  error___0->position = iter->_pos;
  error___0->original_text = iter->_start;
  code_point = (uint64_t )0;
  i = 0;
  while (i < iter->_width) {
    code_point = (code_point << 8) | (unsigned long )((unsigned char )*(iter->_start + i));
    i ++;
  }
  error___0->v.codepoint = code_point;
  return;
}
}
static void read_char(Utf8Iterator *iter ) 
{ 
  unsigned char c ;
  unsigned char mask ;
  int is_bad_char ;
  uint64_t code_point ;
  int i ;
  _Bool tmp___0 ;
  char const   *next ;

  {
  mask = (unsigned char )'\000';
  is_bad_char = 0;
  c = (unsigned char )*(iter->_start);
  if ((int )c < 128) {
    iter->_width = 1;
    mask = (unsigned char)255;
  } else
  if ((int )c < 192) {
    iter->_width = 1;
    is_bad_char = 1;
  } else
  if ((int )c < 224) {
    iter->_width = 2;
    mask = (unsigned char)31;
    if ((int )c < 194) {
      is_bad_char = 1;
    }
  } else
  if ((int )c < 240) {
    iter->_width = 3;
    mask = (unsigned char)15;
  } else
  if ((int )c < 245) {
    iter->_width = 4;
    mask = (unsigned char)7;
  } else
  if ((int )c < 248) {
    iter->_width = 5;
    is_bad_char = 1;
  } else
  if ((int )c < 252) {
    iter->_width = 6;
    is_bad_char = 1;
  } else
  if ((int )c < 254) {
    iter->_width = 7;
    is_bad_char = 1;
  } else {
    iter->_width = 1;
    is_bad_char = 1;
  }
  code_point = (uint64_t )((int )c & (int )mask);
  if ((unsigned long )(iter->_start + iter->_width) > (unsigned long )iter->_end) {
    iter->_width = (int )(iter->_end - iter->_start);
    add_error(iter, (GumboErrorType )1);
    is_bad_char = 1;
  }
  if (! (iter->_width < 8)) {
    __assert_fail("iter->_width < 8", "deps/gumbo-parser/utf8.c", 127U, "read_char");
  }
  i = 1;
  while (i < iter->_width) {
    c = (unsigned char )*(iter->_start + i);
    if ((int )c < 128) {
      iter->_width = i;
      is_bad_char = 1;
      break;
    } else
    if ((int )c > 191) {
      iter->_width = i;
      is_bad_char = 1;
      break;
    }
    code_point = (code_point << 6) | (unsigned long )((int )c & -129);
    i ++;
  }
  if (code_point > 1114111UL) {
    is_bad_char = 1;
  }
  if (is_bad_char) {
    add_error(iter, (GumboErrorType )0);
    code_point = (uint64_t )kUtf8ReplacementChar;
  } else {
    tmp___0 = utf8_is_invalid_code_point((int )code_point);
    if (tmp___0) {
      add_error(iter, (GumboErrorType )0);
      code_point = (uint64_t )kUtf8ReplacementChar;
    }
  }
  if (code_point == 13UL) {
    next = iter->_start + iter->_width;
    if ((unsigned long )next < (unsigned long )iter->_end) {
      if ((int const   )*next == 10) {
        (iter->_start) ++;
        (iter->_pos.offset) ++;
      }
    }
    code_point = (uint64_t )'\n';
  }
  iter->_current = (int )code_point;
  return;
}
}
static void update_position(Utf8Iterator *iter ) 
{ 
  int tab_stop ;

  {
  iter->_pos.offset += (unsigned int )iter->_width;
  if (iter->_current == 10) {
    (iter->_pos.line) ++;
    iter->_pos.column = 1U;
  } else
  if (iter->_current == 9) {
    tab_stop = (int )((iter->_parser)->_options)->tab_stop;
    iter->_pos.column = (iter->_pos.column / (unsigned int )tab_stop + 1U) * (unsigned int )tab_stop;
  } else {
    (iter->_pos.column) ++;
  }
  return;
}
}
_Bool utf8_is_invalid_code_point(int c ) 
{ 
  int tmp ;

  {
  if (c >= 1) {
    if (c <= 8) {
      tmp = 1;
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (c == 11) {
    tmp = 1;
  } else
  if (c >= 14) {
    if (c <= 31) {
      tmp = 1;
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (c >= 127) {
    if (c <= 159) {
      tmp = 1;
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (c >= 64976) {
    if (c <= 65007) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((c & 65535) == 65534) {
    tmp = 1;
  } else
  if ((c & 65535) == 65535) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
void utf8iterator_init(struct GumboInternalParser *parser , char const   *source ,
                       size_t source_length , Utf8Iterator *iter ) 
{ 


  {
  iter->_start = source;
  iter->_end = source + source_length;
  iter->_width = 0;
  iter->_pos.line = 1U;
  iter->_pos.column = 1U;
  iter->_pos.offset = 0U;
  iter->_parser = parser;
  if (source_length) {
    read_char(iter);
  } else {
    iter->_current = -1;
  }
  return;
}
}
void utf8iterator_next(Utf8Iterator *iter ) 
{ 


  {
  iter->_start += iter->_width;
  update_position(iter);
  if ((unsigned long )iter->_start < (unsigned long )iter->_end) {
    read_char(iter);
  } else {
    iter->_current = -1;
  }
  return;
}
}
int utf8iterator_current(Utf8Iterator const   *iter ) 
{ 


  {
  return ((int )iter->_current);
}
}
void utf8iterator_get_position(Utf8Iterator const   *iter , GumboSourcePosition *output ) 
{ 


  {
  *output = (GumboSourcePosition )iter->_pos;
  return;
}
}
char const   *utf8iterator_get_char_pointer(Utf8Iterator const   *iter ) 
{ 


  {
  return ((char const   *)iter->_start);
}
}
_Bool utf8iterator_maybe_consume_match(Utf8Iterator *iter , char const   *prefix ,
                                       size_t length , _Bool case_sensitive ) 
{ 
  _Bool matched ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int i ;

  {
  if ((unsigned long )(iter->_start + length) <= (unsigned long )iter->_end) {
    if (case_sensitive) {
      tmp = strncmp(iter->_start, prefix, length);
      if (tmp) {
        tmp___0 = 0;
      } else {
        tmp___0 = 1;
      }
      tmp___3 = tmp___0;
    } else {
      tmp___1 = strncasecmp(iter->_start, prefix, length);
      if (tmp___1) {
        tmp___2 = 0;
      } else {
        tmp___2 = 1;
      }
      tmp___3 = tmp___2;
    }
    if (tmp___3) {
      tmp___4 = 1;
    } else {
      tmp___4 = 0;
    }
  } else {
    tmp___4 = 0;
  }
  matched = (_Bool )tmp___4;
  if (matched) {
    i = 0;
    while ((size_t )i < length) {
      utf8iterator_next(iter);
      i ++;
    }
    return ((_Bool)1);
  } else {
    return ((_Bool)0);
  }
}
}
void utf8iterator_mark(Utf8Iterator *iter ) 
{ 


  {
  iter->_mark = iter->_start;
  iter->_mark_pos = iter->_pos;
  return;
}
}
void utf8iterator_reset(Utf8Iterator *iter ) 
{ 


  {
  iter->_start = iter->_mark;
  iter->_pos = iter->_mark_pos;
  read_char(iter);
  return;
}
}
void utf8iterator_fill_error_at_mark(Utf8Iterator *iter , struct GumboInternalError *error___0 ) 
{ 


  {
  error___0->position = iter->_mark_pos;
  error___0->original_text = iter->_mark;
  return;
}
}
#pragma merger("0","/tmp/cil-xO0DiomS.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
static unsigned long const   kDefaultStringBufferSize  =    (size_t const   )10;
static void maybe_resize_string_buffer(struct GumboInternalParser *parser , size_t additional_chars ,
                                       GumboStringBuffer *buffer ) 
{ 
  size_t new_length ;
  size_t new_capacity ;
  char *new_data ;
  void *tmp ;

  {
  new_length = buffer->length + additional_chars;
  new_capacity = buffer->capacity;
  while (new_capacity < new_length) {
    new_capacity *= 2UL;
  }
  if (new_capacity != buffer->capacity) {
    tmp = gumbo_parser_allocate(parser, new_capacity);
    new_data = (char *)tmp;
    memcpy((void * __restrict  )new_data, (void const   * __restrict  )buffer->data,
           buffer->length);
    gumbo_parser_deallocate(parser, (void *)buffer->data);
    buffer->data = new_data;
    buffer->capacity = new_capacity;
  }
  return;
}
}
void gumbo_string_buffer_init(struct GumboInternalParser *parser , GumboStringBuffer *output ) 
{ 
  void *tmp ;

  {
  tmp = gumbo_parser_allocate(parser, (size_t )kDefaultStringBufferSize);
  output->data = (char *)tmp;
  output->length = (size_t )0;
  output->capacity = (size_t )kDefaultStringBufferSize;
  return;
}
}
void gumbo_string_buffer_reserve(struct GumboInternalParser *parser , size_t min_capacity ,
                                 GumboStringBuffer *output ) 
{ 


  {
  maybe_resize_string_buffer(parser, min_capacity - output->length, output);
  return;
}
}
void gumbo_string_buffer_append_codepoint(struct GumboInternalParser *parser , int c ,
                                          GumboStringBuffer *output ) 
{ 
  int num_bytes ;
  int prefix ;
  size_t tmp ;
  int i ;
  size_t tmp___0 ;

  {
  if (c <= 127) {
    num_bytes = 0;
    prefix = 0;
  } else
  if (c <= 2047) {
    num_bytes = 1;
    prefix = 192;
  } else
  if (c <= 65535) {
    num_bytes = 2;
    prefix = 224;
  } else {
    num_bytes = 3;
    prefix = 240;
  }
  maybe_resize_string_buffer(parser, (size_t )(num_bytes + 1), output);
  tmp = output->length;
  (output->length) ++;
  *(output->data + tmp) = (char )(prefix | (c >> num_bytes * 6));
  i = num_bytes - 1;
  while (i >= 0) {
    tmp___0 = output->length;
    (output->length) ++;
    *(output->data + tmp___0) = (char )(128 | (63 & (c >> i * 6)));
    i --;
  }
  return;
}
}
void gumbo_string_buffer_append_string(struct GumboInternalParser *parser , GumboStringPiece *str ,
                                       GumboStringBuffer *output ) 
{ 


  {
  maybe_resize_string_buffer(parser, str->length, output);
  memcpy((void * __restrict  )(output->data + output->length), (void const   * __restrict  )str->data,
         str->length);
  output->length += str->length;
  return;
}
}
char *gumbo_string_buffer_to_string(struct GumboInternalParser *parser , GumboStringBuffer *input ) 
{ 
  char *buffer ;
  void *tmp ;

  {
  tmp = gumbo_parser_allocate(parser, input->length + 1UL);
  buffer = (char *)tmp;
  memcpy((void * __restrict  )buffer, (void const   * __restrict  )input->data, input->length);
  *(buffer + input->length) = (char )'\000';
  return (buffer);
}
}
void gumbo_string_buffer_destroy(struct GumboInternalParser *parser , GumboStringBuffer *buffer ) 
{ 


  {
  gumbo_parser_deallocate(parser, (void *)buffer->data);
  return;
}
}
#pragma merger("0","/tmp/cil-P94ZfpzF.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
_Bool gumbo_string_equals(GumboStringPiece const   *str1 , GumboStringPiece const   *str2 ) ;
void gumbo_string_copy(struct GumboInternalParser *parser , GumboStringPiece *dest ,
                       GumboStringPiece const   *source ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
struct __anonstruct_GumboStringPiece_673951369  const  kGumboEmptyString  =    {(char const   *)((void *)0), (size_t )0};
_Bool gumbo_string_equals(GumboStringPiece const   *str1 , GumboStringPiece const   *str2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (str1->length == str2->length) {
    tmp = memcmp((void const   *)str1->data, (void const   *)str2->data, (size_t )str1->length);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  return ((_Bool )tmp___0);
}
}
_Bool gumbo_string_equals_ignore_case(GumboStringPiece const   *str1 , GumboStringPiece const   *str2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (str1->length == str2->length) {
    tmp = strncasecmp((char const   *)str1->data, (char const   *)str2->data, (size_t )str1->length);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  return ((_Bool )tmp___0);
}
}
void gumbo_string_copy(struct GumboInternalParser *parser , GumboStringPiece *dest ,
                       GumboStringPiece const   *source ) 
{ 
  char *buffer ;
  void *tmp ;

  {
  dest->length = (size_t )source->length;
  tmp = gumbo_parser_allocate(parser, (size_t )source->length);
  buffer = (char *)tmp;
  memcpy((void * __restrict  )buffer, (void const   * __restrict  )source->data, (size_t )source->length);
  dest->data = (char const   *)buffer;
  return;
}
}
#pragma merger("0","/tmp/cil-5SOWPqg4.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
int const   kGumboNoChar ;
_Bool consume_char_ref(struct GumboInternalParser *parser , struct GumboInternalUtf8Iterator *input ,
                       int additional_allowed_char , _Bool is_in_attribute , OneOrTwoCodepoints *output ) ;
int const   kGumboNoChar  =    (int const   )-1;
static NamedCharRef const   kNamedEntities[2231]  = 
  {      {"AElig", sizeof("AElig") - 1UL, {198, -1}}, 
        {"AMP;", sizeof("AMP;") - 1UL, {38, -1}}, 
        {"AMP", sizeof("AMP") - 1UL, {38, -1}}, 
        {"Aacute;", sizeof("Aacute;") - 1UL, {193, -1}}, 
        {"Aacute", sizeof("Aacute") - 1UL, {193, -1}}, 
        {"Abreve;", sizeof("Abreve;") - 1UL, {258, -1}}, 
        {"Acirc;", sizeof("Acirc;") - 1UL, {194, -1}}, 
        {"Acirc", sizeof("Acirc") - 1UL, {194, -1}}, 
        {"Acy;", sizeof("Acy;") - 1UL, {1040, -1}}, 
        {"Afr;", sizeof("Afr;") - 1UL, {120068, -1}}, 
        {"Agrave", sizeof("Agrave") - 1UL, {192, -1}}, 
        {"Agrave;", sizeof("Agrave;") - 1UL, {192, -1}}, 
        {"Alpha;", sizeof("Alpha;") - 1UL, {913, -1}}, 
        {"Amacr;", sizeof("Amacr;") - 1UL, {256, -1}}, 
        {"And;", sizeof("And;") - 1UL, {10835, -1}}, 
        {"Aogon;", sizeof("Aogon;") - 1UL, {260, -1}}, 
        {"Aopf;", sizeof("Aopf;") - 1UL, {120120, -1}}, 
        {"ApplyFunction;", sizeof("ApplyFunction;") - 1UL, {8289, -1}}, 
        {"Aring;", sizeof("Aring;") - 1UL, {197, -1}}, 
        {"Aring", sizeof("Aring") - 1UL, {197, -1}}, 
        {"Ascr;", sizeof("Ascr;") - 1UL, {119964, -1}}, 
        {"Assign;", sizeof("Assign;") - 1UL, {8788, -1}}, 
        {"Atilde;", sizeof("Atilde;") - 1UL, {195, -1}}, 
        {"Atilde", sizeof("Atilde") - 1UL, {195, -1}}, 
        {"Auml;", sizeof("Auml;") - 1UL, {196, -1}}, 
        {"Auml", sizeof("Auml") - 1UL, {196, -1}}, 
        {"Backslash;", sizeof("Backslash;") - 1UL, {8726, -1}}, 
        {"Barv;", sizeof("Barv;") - 1UL, {10983, -1}}, 
        {"Barwed;", sizeof("Barwed;") - 1UL, {8966, -1}}, 
        {"Bcy;", sizeof("Bcy;") - 1UL, {1041, -1}}, 
        {"Because;", sizeof("Because;") - 1UL, {8757, -1}}, 
        {"Bernoullis;", sizeof("Bernoullis;") - 1UL, {8492, -1}}, 
        {"Beta;", sizeof("Beta;") - 1UL, {914, -1}}, 
        {"Bfr;", sizeof("Bfr;") - 1UL, {120069, -1}}, 
        {"Bopf;", sizeof("Bopf;") - 1UL, {120121, -1}}, 
        {"Breve;", sizeof("Breve;") - 1UL, {728, -1}}, 
        {"Bscr;", sizeof("Bscr;") - 1UL, {8492, -1}}, 
        {"Bumpeq;", sizeof("Bumpeq;") - 1UL, {8782, -1}}, 
        {"CHcy;", sizeof("CHcy;") - 1UL, {1063, -1}}, 
        {"COPY;", sizeof("COPY;") - 1UL, {169, -1}}, 
        {"COPY", sizeof("COPY") - 1UL, {169, -1}}, 
        {"Cacute;", sizeof("Cacute;") - 1UL, {262, -1}}, 
        {"Cap;", sizeof("Cap;") - 1UL, {8914, -1}}, 
        {"CapitalDifferentialD;", sizeof("CapitalDifferentialD;") - 1UL, {8517, -1}}, 
        {"Cayleys;",
      sizeof("Cayleys;") - 1UL, {8493, -1}}, 
        {"Ccaron;", sizeof("Ccaron;") - 1UL, {268, -1}}, 
        {"Ccedil;", sizeof("Ccedil;") - 1UL, {199, -1}}, 
        {"Ccedil", sizeof("Ccedil") - 1UL, {199, -1}}, 
        {"Ccirc;", sizeof("Ccirc;") - 1UL, {264, -1}}, 
        {"Cconint;", sizeof("Cconint;") - 1UL, {8752, -1}}, 
        {"Cdot;", sizeof("Cdot;") - 1UL, {266, -1}}, 
        {"Cedilla;", sizeof("Cedilla;") - 1UL, {184, -1}}, 
        {"CenterDot;", sizeof("CenterDot;") - 1UL, {183, -1}}, 
        {"Cfr;", sizeof("Cfr;") - 1UL, {8493, -1}}, 
        {"Chi;", sizeof("Chi;") - 1UL, {935, -1}}, 
        {"CircleDot;", sizeof("CircleDot;") - 1UL, {8857, -1}}, 
        {"CircleMinus;", sizeof("CircleMinus;") - 1UL, {8854, -1}}, 
        {"CirclePlus;", sizeof("CirclePlus;") - 1UL, {8853, -1}}, 
        {"CircleTimes;", sizeof("CircleTimes;") - 1UL, {8855, -1}}, 
        {"ClockwiseContourIntegral;", sizeof("ClockwiseContourIntegral;") - 1UL, {8754,
                                                                               -1}}, 
        {"CloseCurlyDoubleQuote;",
      sizeof("CloseCurlyDoubleQuote;") - 1UL, {8221, -1}}, 
        {"CloseCurlyQuote;", sizeof("CloseCurlyQuote;") - 1UL, {8217, -1}}, 
        {"Colon;", sizeof("Colon;") - 1UL, {8759, -1}}, 
        {"Colone;", sizeof("Colone;") - 1UL, {10868, -1}}, 
        {"Congruent;", sizeof("Congruent;") - 1UL, {8801, -1}}, 
        {"Conint;", sizeof("Conint;") - 1UL, {8751, -1}}, 
        {"ContourIntegral;", sizeof("ContourIntegral;") - 1UL, {8750, -1}}, 
        {"Copf;", sizeof("Copf;") - 1UL, {8450, -1}}, 
        {"Coproduct;", sizeof("Coproduct;") - 1UL, {8720, -1}}, 
        {"CounterClockwiseContourIntegral;", sizeof("CounterClockwiseContourIntegral;") - 1UL,
      {8755, -1}}, 
        {"Cross;", sizeof("Cross;") - 1UL, {10799, -1}}, 
        {"Cscr;", sizeof("Cscr;") - 1UL, {119966, -1}}, 
        {"Cup;", sizeof("Cup;") - 1UL, {8915, -1}}, 
        {"CupCap;", sizeof("CupCap;") - 1UL, {8781, -1}}, 
        {"DD;", sizeof("DD;") - 1UL, {8517, -1}}, 
        {"DDotrahd;", sizeof("DDotrahd;") - 1UL, {10513, -1}}, 
        {"DJcy;", sizeof("DJcy;") - 1UL, {1026, -1}}, 
        {"DScy;", sizeof("DScy;") - 1UL, {1029, -1}}, 
        {"DZcy;", sizeof("DZcy;") - 1UL, {1039, -1}}, 
        {"Dagger;", sizeof("Dagger;") - 1UL, {8225, -1}}, 
        {"Darr;", sizeof("Darr;") - 1UL, {8609, -1}}, 
        {"Dashv;", sizeof("Dashv;") - 1UL, {10980, -1}}, 
        {"Dcaron;", sizeof("Dcaron;") - 1UL, {270, -1}}, 
        {"Dcy;", sizeof("Dcy;") - 1UL, {1044, -1}}, 
        {"Del;", sizeof("Del;") - 1UL, {8711, -1}}, 
        {"Delta;", sizeof("Delta;") - 1UL, {916, -1}}, 
        {"Dfr;", sizeof("Dfr;") - 1UL, {120071, -1}}, 
        {"DiacriticalAcute;", sizeof("DiacriticalAcute;") - 1UL, {180, -1}}, 
        {"DiacriticalDot;", sizeof("DiacriticalDot;") - 1UL, {729, -1}}, 
        {"DiacriticalDoubleAcute;", sizeof("DiacriticalDoubleAcute;") - 1UL, {733, -1}}, 
        {"DiacriticalGrave;",
      sizeof("DiacriticalGrave;") - 1UL, {96, -1}}, 
        {"DiacriticalTilde;", sizeof("DiacriticalTilde;") - 1UL, {732, -1}}, 
        {"Diamond;", sizeof("Diamond;") - 1UL, {8900, -1}}, 
        {"DifferentialD;", sizeof("DifferentialD;") - 1UL, {8518, -1}}, 
        {"Dopf;", sizeof("Dopf;") - 1UL, {120123, -1}}, 
        {"Dot;", sizeof("Dot;") - 1UL, {168, -1}}, 
        {"DotDot;", sizeof("DotDot;") - 1UL, {8412, -1}}, 
        {"DotEqual;", sizeof("DotEqual;") - 1UL, {8784, -1}}, 
        {"DoubleContourIntegral;", sizeof("DoubleContourIntegral;") - 1UL, {8751, -1}}, 
        {"DoubleDot;",
      sizeof("DoubleDot;") - 1UL, {168, -1}}, 
        {"DoubleDownArrow;", sizeof("DoubleDownArrow;") - 1UL, {8659, -1}}, 
        {"DoubleLeftArrow;", sizeof("DoubleLeftArrow;") - 1UL, {8656, -1}}, 
        {"DoubleLeftRightArrow;", sizeof("DoubleLeftRightArrow;") - 1UL, {8660, -1}}, 
        {"DoubleLeftTee;",
      sizeof("DoubleLeftTee;") - 1UL, {10980, -1}}, 
        {"DoubleLongLeftArrow;", sizeof("DoubleLongLeftArrow;") - 1UL, {10232, -1}}, 
        {"DoubleLongLeftRightArrow;", sizeof("DoubleLongLeftRightArrow;") - 1UL, {10234,
                                                                               -1}}, 
        {"DoubleLongRightArrow;",
      sizeof("DoubleLongRightArrow;") - 1UL, {10233, -1}}, 
        {"DoubleRightArrow;", sizeof("DoubleRightArrow;") - 1UL, {8658, -1}}, 
        {"DoubleRightTee;", sizeof("DoubleRightTee;") - 1UL, {8872, -1}}, 
        {"DoubleUpArrow;", sizeof("DoubleUpArrow;") - 1UL, {8657, -1}}, 
        {"DoubleUpDownArrow;", sizeof("DoubleUpDownArrow;") - 1UL, {8661, -1}}, 
        {"DoubleVerticalBar;", sizeof("DoubleVerticalBar;") - 1UL, {8741, -1}}, 
        {"DownArrow;", sizeof("DownArrow;") - 1UL, {8595, -1}}, 
        {"DownArrowBar;", sizeof("DownArrowBar;") - 1UL, {10515, -1}}, 
        {"DownArrowUpArrow;", sizeof("DownArrowUpArrow;") - 1UL, {8693, -1}}, 
        {"DownBreve;", sizeof("DownBreve;") - 1UL, {785, -1}}, 
        {"DownLeftRightVector;", sizeof("DownLeftRightVector;") - 1UL, {10576, -1}}, 
        {"DownLeftTeeVector;", sizeof("DownLeftTeeVector;") - 1UL, {10590, -1}}, 
        {"DownLeftVector;", sizeof("DownLeftVector;") - 1UL, {8637, -1}}, 
        {"DownLeftVectorBar;", sizeof("DownLeftVectorBar;") - 1UL, {10582, -1}}, 
        {"DownRightTeeVector;", sizeof("DownRightTeeVector;") - 1UL, {10591, -1}}, 
        {"DownRightVector;", sizeof("DownRightVector;") - 1UL, {8641, -1}}, 
        {"DownRightVectorBar;", sizeof("DownRightVectorBar;") - 1UL, {10583, -1}}, 
        {"DownTee;", sizeof("DownTee;") - 1UL, {8868, -1}}, 
        {"DownTeeArrow;", sizeof("DownTeeArrow;") - 1UL, {8615, -1}}, 
        {"Downarrow;", sizeof("Downarrow;") - 1UL, {8659, -1}}, 
        {"Dscr;", sizeof("Dscr;") - 1UL, {119967, -1}}, 
        {"Dstrok;", sizeof("Dstrok;") - 1UL, {272, -1}}, 
        {"ENG;", sizeof("ENG;") - 1UL, {330, -1}}, 
        {"ETH;", sizeof("ETH;") - 1UL, {208, -1}}, 
        {"ETH", sizeof("ETH") - 1UL, {208, -1}}, 
        {"Eacute;", sizeof("Eacute;") - 1UL, {201, -1}}, 
        {"Eacute", sizeof("Eacute") - 1UL, {201, -1}}, 
        {"Ecaron;", sizeof("Ecaron;") - 1UL, {282, -1}}, 
        {"Ecirc;", sizeof("Ecirc;") - 1UL, {202, -1}}, 
        {"Ecirc", sizeof("Ecirc") - 1UL, {202, -1}}, 
        {"Ecy;", sizeof("Ecy;") - 1UL, {1069, -1}}, 
        {"Edot;", sizeof("Edot;") - 1UL, {278, -1}}, 
        {"Efr;", sizeof("Efr;") - 1UL, {120072, -1}}, 
        {"Egrave;", sizeof("Egrave;") - 1UL, {200, -1}}, 
        {"Egrave", sizeof("Egrave") - 1UL, {200, -1}}, 
        {"Element;", sizeof("Element;") - 1UL, {8712, -1}}, 
        {"Emacr;", sizeof("Emacr;") - 1UL, {274, -1}}, 
        {"EmptySmallSquare;", sizeof("EmptySmallSquare;") - 1UL, {9723, -1}}, 
        {"EmptyVerySmallSquare;", sizeof("EmptyVerySmallSquare;") - 1UL, {9643, -1}}, 
        {"Eogon;",
      sizeof("Eogon;") - 1UL, {280, -1}}, 
        {"Eopf;", sizeof("Eopf;") - 1UL, {120124, -1}}, 
        {"Epsilon;", sizeof("Epsilon;") - 1UL, {917, -1}}, 
        {"Equal;", sizeof("Equal;") - 1UL, {10869, -1}}, 
        {"EqualTilde;", sizeof("EqualTilde;") - 1UL, {8770, -1}}, 
        {"Equilibrium;", sizeof("Equilibrium;") - 1UL, {8652, -1}}, 
        {"Escr;", sizeof("Escr;") - 1UL, {8496, -1}}, 
        {"Esim;", sizeof("Esim;") - 1UL, {10867, -1}}, 
        {"Eta;", sizeof("Eta;") - 1UL, {919, -1}}, 
        {"Euml;", sizeof("Euml;") - 1UL, {203, -1}}, 
        {"Euml", sizeof("Euml") - 1UL, {203, -1}}, 
        {"Exists;", sizeof("Exists;") - 1UL, {8707, -1}}, 
        {"ExponentialE;", sizeof("ExponentialE;") - 1UL, {8519, -1}}, 
        {"Fcy;", sizeof("Fcy;") - 1UL, {1060, -1}}, 
        {"Ffr;", sizeof("Ffr;") - 1UL, {120073, -1}}, 
        {"FilledSmallSquare;", sizeof("FilledSmallSquare;") - 1UL, {9724, -1}}, 
        {"FilledVerySmallSquare;", sizeof("FilledVerySmallSquare;") - 1UL, {9642, -1}}, 
        {"Fopf;",
      sizeof("Fopf;") - 1UL, {120125, -1}}, 
        {"ForAll;", sizeof("ForAll;") - 1UL, {8704, -1}}, 
        {"Fouriertrf;", sizeof("Fouriertrf;") - 1UL, {8497, -1}}, 
        {"Fscr;", sizeof("Fscr;") - 1UL, {8497, -1}}, 
        {"GJcy;", sizeof("GJcy;") - 1UL, {1027, -1}}, 
        {"GT;", sizeof("GT;") - 1UL, {62, -1}}, 
        {"GT", sizeof("GT") - 1UL, {62, -1}}, 
        {"Gamma;", sizeof("Gamma;") - 1UL, {915, -1}}, 
        {"Gammad;", sizeof("Gammad;") - 1UL, {988, -1}}, 
        {"Gbreve;", sizeof("Gbreve;") - 1UL, {286, -1}}, 
        {"Gcedil;", sizeof("Gcedil;") - 1UL, {290, -1}}, 
        {"Gcirc;", sizeof("Gcirc;") - 1UL, {284, -1}}, 
        {"Gcy;", sizeof("Gcy;") - 1UL, {1043, -1}}, 
        {"Gdot;", sizeof("Gdot;") - 1UL, {288, -1}}, 
        {"Gfr;", sizeof("Gfr;") - 1UL, {120074, -1}}, 
        {"Gg;", sizeof("Gg;") - 1UL, {8921, -1}}, 
        {"Gopf;", sizeof("Gopf;") - 1UL, {120126, -1}}, 
        {"GreaterEqual;", sizeof("GreaterEqual;") - 1UL, {8805, -1}}, 
        {"GreaterEqualLess;", sizeof("GreaterEqualLess;") - 1UL, {8923, -1}}, 
        {"GreaterFullEqual;", sizeof("GreaterFullEqual;") - 1UL, {8807, -1}}, 
        {"GreaterGreater;", sizeof("GreaterGreater;") - 1UL, {10914, -1}}, 
        {"GreaterLess;", sizeof("GreaterLess;") - 1UL, {8823, -1}}, 
        {"GreaterSlantEqual;", sizeof("GreaterSlantEqual;") - 1UL, {10878, -1}}, 
        {"GreaterTilde;", sizeof("GreaterTilde;") - 1UL, {8819, -1}}, 
        {"Gscr;", sizeof("Gscr;") - 1UL, {119970, -1}}, 
        {"Gt;", sizeof("Gt;") - 1UL, {8811, -1}}, 
        {"HARDcy;", sizeof("HARDcy;") - 1UL, {1066, -1}}, 
        {"Hacek;", sizeof("Hacek;") - 1UL, {711, -1}}, 
        {"Hat;", sizeof("Hat;") - 1UL, {94, -1}}, 
        {"Hcirc;", sizeof("Hcirc;") - 1UL, {292, -1}}, 
        {"Hfr;", sizeof("Hfr;") - 1UL, {8460, -1}}, 
        {"HilbertSpace;", sizeof("HilbertSpace;") - 1UL, {8459, -1}}, 
        {"Hopf;", sizeof("Hopf;") - 1UL, {8461, -1}}, 
        {"HorizontalLine;", sizeof("HorizontalLine;") - 1UL, {9472, -1}}, 
        {"Hscr;", sizeof("Hscr;") - 1UL, {8459, -1}}, 
        {"Hstrok;", sizeof("Hstrok;") - 1UL, {294, -1}}, 
        {"HumpDownHump;", sizeof("HumpDownHump;") - 1UL, {8782, -1}}, 
        {"HumpEqual;", sizeof("HumpEqual;") - 1UL, {8783, -1}}, 
        {"IEcy;", sizeof("IEcy;") - 1UL, {1045, -1}}, 
        {"IJlig;", sizeof("IJlig;") - 1UL, {306, -1}}, 
        {"IOcy;", sizeof("IOcy;") - 1UL, {1025, -1}}, 
        {"Iacute;", sizeof("Iacute;") - 1UL, {205, -1}}, 
        {"Iacute", sizeof("Iacute") - 1UL, {205, -1}}, 
        {"Icirc;", sizeof("Icirc;") - 1UL, {206, -1}}, 
        {"Icirc", sizeof("Icirc") - 1UL, {206, -1}}, 
        {"Icy;", sizeof("Icy;") - 1UL, {1048, -1}}, 
        {"Idot;", sizeof("Idot;") - 1UL, {304, -1}}, 
        {"Ifr;", sizeof("Ifr;") - 1UL, {8465, -1}}, 
        {"Igrave;", sizeof("Igrave;") - 1UL, {204, -1}}, 
        {"Igrave", sizeof("Igrave") - 1UL, {204, -1}}, 
        {"Im;", sizeof("Im;") - 1UL, {8465, -1}}, 
        {"Imacr;", sizeof("Imacr;") - 1UL, {298, -1}}, 
        {"ImaginaryI;", sizeof("ImaginaryI;") - 1UL, {8520, -1}}, 
        {"Implies;", sizeof("Implies;") - 1UL, {8658, -1}}, 
        {"Int;", sizeof("Int;") - 1UL, {8748, -1}}, 
        {"Integral;", sizeof("Integral;") - 1UL, {8747, -1}}, 
        {"Intersection;", sizeof("Intersection;") - 1UL, {8898, -1}}, 
        {"InvisibleComma;", sizeof("InvisibleComma;") - 1UL, {8291, -1}}, 
        {"InvisibleTimes;", sizeof("InvisibleTimes;") - 1UL, {8290, -1}}, 
        {"Iogon;", sizeof("Iogon;") - 1UL, {302, -1}}, 
        {"Iopf;", sizeof("Iopf;") - 1UL, {120128, -1}}, 
        {"Iota;", sizeof("Iota;") - 1UL, {921, -1}}, 
        {"Iscr;", sizeof("Iscr;") - 1UL, {8464, -1}}, 
        {"Itilde;", sizeof("Itilde;") - 1UL, {296, -1}}, 
        {"Iukcy;", sizeof("Iukcy;") - 1UL, {1030, -1}}, 
        {"Iuml;", sizeof("Iuml;") - 1UL, {207, -1}}, 
        {"Iuml", sizeof("Iuml") - 1UL, {207, -1}}, 
        {"Jcirc;", sizeof("Jcirc;") - 1UL, {308, -1}}, 
        {"Jcy;", sizeof("Jcy;") - 1UL, {1049, -1}}, 
        {"Jfr;", sizeof("Jfr;") - 1UL, {120077, -1}}, 
        {"Jopf;", sizeof("Jopf;") - 1UL, {120129, -1}}, 
        {"Jscr;", sizeof("Jscr;") - 1UL, {119973, -1}}, 
        {"Jsercy;", sizeof("Jsercy;") - 1UL, {1032, -1}}, 
        {"Jukcy;", sizeof("Jukcy;") - 1UL, {1028, -1}}, 
        {"KHcy;", sizeof("KHcy;") - 1UL, {1061, -1}}, 
        {"KJcy;", sizeof("KJcy;") - 1UL, {1036, -1}}, 
        {"Kappa;", sizeof("Kappa;") - 1UL, {922, -1}}, 
        {"Kcedil;", sizeof("Kcedil;") - 1UL, {310, -1}}, 
        {"Kcy;", sizeof("Kcy;") - 1UL, {1050, -1}}, 
        {"Kfr;", sizeof("Kfr;") - 1UL, {120078, -1}}, 
        {"Kopf;", sizeof("Kopf;") - 1UL, {120130, -1}}, 
        {"Kscr;", sizeof("Kscr;") - 1UL, {119974, -1}}, 
        {"LJcy;", sizeof("LJcy;") - 1UL, {1033, -1}}, 
        {"LT;", sizeof("LT;") - 1UL, {60, -1}}, 
        {"LT", sizeof("LT") - 1UL, {60, -1}}, 
        {"Lacute;", sizeof("Lacute;") - 1UL, {313, -1}}, 
        {"Lambda;", sizeof("Lambda;") - 1UL, {923, -1}}, 
        {"Lang;", sizeof("Lang;") - 1UL, {10218, -1}}, 
        {"Laplacetrf;", sizeof("Laplacetrf;") - 1UL, {8466, -1}}, 
        {"Larr;", sizeof("Larr;") - 1UL, {8606, -1}}, 
        {"Lcaron;", sizeof("Lcaron;") - 1UL, {317, -1}}, 
        {"Lcedil;", sizeof("Lcedil;") - 1UL, {315, -1}}, 
        {"Lcy;", sizeof("Lcy;") - 1UL, {1051, -1}}, 
        {"LeftAngleBracket;", sizeof("LeftAngleBracket;") - 1UL, {10216, -1}}, 
        {"LeftArrow;", sizeof("LeftArrow;") - 1UL, {8592, -1}}, 
        {"LeftArrowBar;", sizeof("LeftArrowBar;") - 1UL, {8676, -1}}, 
        {"LeftArrowRightArrow;", sizeof("LeftArrowRightArrow;") - 1UL, {8646, -1}}, 
        {"LeftCeiling;", sizeof("LeftCeiling;") - 1UL, {8968, -1}}, 
        {"LeftDoubleBracket;", sizeof("LeftDoubleBracket;") - 1UL, {10214, -1}}, 
        {"LeftDownTeeVector;", sizeof("LeftDownTeeVector;") - 1UL, {10593, -1}}, 
        {"LeftDownVector;", sizeof("LeftDownVector;") - 1UL, {8643, -1}}, 
        {"LeftDownVectorBar;", sizeof("LeftDownVectorBar;") - 1UL, {10585, -1}}, 
        {"LeftFloor;", sizeof("LeftFloor;") - 1UL, {8970, -1}}, 
        {"LeftRightArrow;", sizeof("LeftRightArrow;") - 1UL, {8596, -1}}, 
        {"LeftRightVector;", sizeof("LeftRightVector;") - 1UL, {10574, -1}}, 
        {"LeftTee;", sizeof("LeftTee;") - 1UL, {8867, -1}}, 
        {"LeftTeeArrow;", sizeof("LeftTeeArrow;") - 1UL, {8612, -1}}, 
        {"LeftTeeVector;", sizeof("LeftTeeVector;") - 1UL, {10586, -1}}, 
        {"LeftTriangle;", sizeof("LeftTriangle;") - 1UL, {8882, -1}}, 
        {"LeftTriangleBar;", sizeof("LeftTriangleBar;") - 1UL, {10703, -1}}, 
        {"LeftTriangleEqual;", sizeof("LeftTriangleEqual;") - 1UL, {8884, -1}}, 
        {"LeftUpDownVector;", sizeof("LeftUpDownVector;") - 1UL, {10577, -1}}, 
        {"LeftUpTeeVector;", sizeof("LeftUpTeeVector;") - 1UL, {10592, -1}}, 
        {"LeftUpVector;", sizeof("LeftUpVector;") - 1UL, {8639, -1}}, 
        {"LeftUpVectorBar;", sizeof("LeftUpVectorBar;") - 1UL, {10584, -1}}, 
        {"LeftVector;", sizeof("LeftVector;") - 1UL, {8636, -1}}, 
        {"LeftVectorBar;", sizeof("LeftVectorBar;") - 1UL, {10578, -1}}, 
        {"Leftarrow;", sizeof("Leftarrow;") - 1UL, {8656, -1}}, 
        {"Leftrightarrow;", sizeof("Leftrightarrow;") - 1UL, {8660, -1}}, 
        {"LessEqualGreater;", sizeof("LessEqualGreater;") - 1UL, {8922, -1}}, 
        {"LessFullEqual;", sizeof("LessFullEqual;") - 1UL, {8806, -1}}, 
        {"LessGreater;", sizeof("LessGreater;") - 1UL, {8822, -1}}, 
        {"LessLess;", sizeof("LessLess;") - 1UL, {10913, -1}}, 
        {"LessSlantEqual;", sizeof("LessSlantEqual;") - 1UL, {10877, -1}}, 
        {"LessTilde;", sizeof("LessTilde;") - 1UL, {8818, -1}}, 
        {"Lfr;", sizeof("Lfr;") - 1UL, {120079, -1}}, 
        {"Ll;", sizeof("Ll;") - 1UL, {8920, -1}}, 
        {"Lleftarrow;", sizeof("Lleftarrow;") - 1UL, {8666, -1}}, 
        {"Lmidot;", sizeof("Lmidot;") - 1UL, {319, -1}}, 
        {"LongLeftArrow;", sizeof("LongLeftArrow;") - 1UL, {10229, -1}}, 
        {"LongLeftRightArrow;", sizeof("LongLeftRightArrow;") - 1UL, {10231, -1}}, 
        {"LongRightArrow;", sizeof("LongRightArrow;") - 1UL, {10230, -1}}, 
        {"Longleftarrow;", sizeof("Longleftarrow;") - 1UL, {10232, -1}}, 
        {"Longleftrightarrow;", sizeof("Longleftrightarrow;") - 1UL, {10234, -1}}, 
        {"Longrightarrow;", sizeof("Longrightarrow;") - 1UL, {10233, -1}}, 
        {"Lopf;", sizeof("Lopf;") - 1UL, {120131, -1}}, 
        {"LowerLeftArrow;", sizeof("LowerLeftArrow;") - 1UL, {8601, -1}}, 
        {"LowerRightArrow;", sizeof("LowerRightArrow;") - 1UL, {8600, -1}}, 
        {"Lscr;", sizeof("Lscr;") - 1UL, {8466, -1}}, 
        {"Lsh;", sizeof("Lsh;") - 1UL, {8624, -1}}, 
        {"Lstrok;", sizeof("Lstrok;") - 1UL, {321, -1}}, 
        {"Lt;", sizeof("Lt;") - 1UL, {8810, -1}}, 
        {"Map;", sizeof("Map;") - 1UL, {10501, -1}}, 
        {"Mcy;", sizeof("Mcy;") - 1UL, {1052, -1}}, 
        {"MediumSpace;", sizeof("MediumSpace;") - 1UL, {8287, -1}}, 
        {"Mellintrf;", sizeof("Mellintrf;") - 1UL, {8499, -1}}, 
        {"Mfr;", sizeof("Mfr;") - 1UL, {120080, -1}}, 
        {"MinusPlus;", sizeof("MinusPlus;") - 1UL, {8723, -1}}, 
        {"Mopf;", sizeof("Mopf;") - 1UL, {120132, -1}}, 
        {"Mscr;", sizeof("Mscr;") - 1UL, {8499, -1}}, 
        {"Mu;", sizeof("Mu;") - 1UL, {924, -1}}, 
        {"NJcy;", sizeof("NJcy;") - 1UL, {1034, -1}}, 
        {"Nacute;", sizeof("Nacute;") - 1UL, {323, -1}}, 
        {"Ncaron;", sizeof("Ncaron;") - 1UL, {327, -1}}, 
        {"Ncedil;", sizeof("Ncedil;") - 1UL, {325, -1}}, 
        {"Ncy;", sizeof("Ncy;") - 1UL, {1053, -1}}, 
        {"NegativeMediumSpace;", sizeof("NegativeMediumSpace;") - 1UL, {8203, -1}}, 
        {"NegativeThickSpace;", sizeof("NegativeThickSpace;") - 1UL, {8203, -1}}, 
        {"NegativeThinSpace;", sizeof("NegativeThinSpace;") - 1UL, {8203, -1}}, 
        {"NegativeVeryThinSpace;", sizeof("NegativeVeryThinSpace;") - 1UL, {8203, -1}}, 
        {"NestedGreaterGreater;",
      sizeof("NestedGreaterGreater;") - 1UL, {8811, -1}}, 
        {"NestedLessLess;", sizeof("NestedLessLess;") - 1UL, {8810, -1}}, 
        {"NewLine;", sizeof("NewLine;") - 1UL, {10, -1}}, 
        {"Nfr;", sizeof("Nfr;") - 1UL, {120081, -1}}, 
        {"NoBreak;", sizeof("NoBreak;") - 1UL, {8288, -1}}, 
        {"NonBreakingSpace;", sizeof("NonBreakingSpace;") - 1UL, {160, -1}}, 
        {"Nopf;", sizeof("Nopf;") - 1UL, {8469, -1}}, 
        {"Not;", sizeof("Not;") - 1UL, {10988, -1}}, 
        {"NotCongruent;", sizeof("NotCongruent;") - 1UL, {8802, -1}}, 
        {"NotCupCap;", sizeof("NotCupCap;") - 1UL, {8813, -1}}, 
        {"NotDoubleVerticalBar;", sizeof("NotDoubleVerticalBar;") - 1UL, {8742, -1}}, 
        {"NotElement;",
      sizeof("NotElement;") - 1UL, {8713, -1}}, 
        {"NotEqual;", sizeof("NotEqual;") - 1UL, {8800, -1}}, 
        {"NotEqualTilde;", sizeof("NotEqualTilde;") - 1UL, {8770, 824}}, 
        {"NotExists;", sizeof("NotExists;") - 1UL, {8708, -1}}, 
        {"NotGreater;", sizeof("NotGreater;") - 1UL, {8815, -1}}, 
        {"NotGreaterEqual;", sizeof("NotGreaterEqual;") - 1UL, {8817, -1}}, 
        {"NotGreaterFullEqual;", sizeof("NotGreaterFullEqual;") - 1UL, {8807, 824}}, 
        {"NotGreaterGreater;", sizeof("NotGreaterGreater;") - 1UL, {8811, 824}}, 
        {"NotGreaterLess;", sizeof("NotGreaterLess;") - 1UL, {8825, -1}}, 
        {"NotGreaterSlantEqual;", sizeof("NotGreaterSlantEqual;") - 1UL, {10878, 824}}, 
        {"NotGreaterTilde;",
      sizeof("NotGreaterTilde;") - 1UL, {8821, -1}}, 
        {"NotHumpDownHump;", sizeof("NotHumpDownHump;") - 1UL, {8782, 824}}, 
        {"NotHumpEqual;", sizeof("NotHumpEqual;") - 1UL, {8783, 824}}, 
        {"NotLeftTriangle;", sizeof("NotLeftTriangle;") - 1UL, {8938, -1}}, 
        {"NotLeftTriangleBar;", sizeof("NotLeftTriangleBar;") - 1UL, {10703, 824}}, 
        {"NotLeftTriangleEqual;", sizeof("NotLeftTriangleEqual;") - 1UL, {8940, -1}}, 
        {"NotLess;",
      sizeof("NotLess;") - 1UL, {8814, -1}}, 
        {"NotLessEqual;", sizeof("NotLessEqual;") - 1UL, {8816, -1}}, 
        {"NotLessGreater;", sizeof("NotLessGreater;") - 1UL, {8824, -1}}, 
        {"NotLessLess;", sizeof("NotLessLess;") - 1UL, {8810, 824}}, 
        {"NotLessSlantEqual;", sizeof("NotLessSlantEqual;") - 1UL, {10877, 824}}, 
        {"NotLessTilde;", sizeof("NotLessTilde;") - 1UL, {8820, -1}}, 
        {"NotNestedGreaterGreater;", sizeof("NotNestedGreaterGreater;") - 1UL, {10914,
                                                                             824}}, 
        {"NotNestedLessLess;",
      sizeof("NotNestedLessLess;") - 1UL, {10913, 824}}, 
        {"NotPrecedes;", sizeof("NotPrecedes;") - 1UL, {8832, -1}}, 
        {"NotPrecedesEqual;", sizeof("NotPrecedesEqual;") - 1UL, {10927, 824}}, 
        {"NotPrecedesSlantEqual;", sizeof("NotPrecedesSlantEqual;") - 1UL, {8928, -1}}, 
        {"NotReverseElement;",
      sizeof("NotReverseElement;") - 1UL, {8716, -1}}, 
        {"NotRightTriangle;", sizeof("NotRightTriangle;") - 1UL, {8939, -1}}, 
        {"NotRightTriangleBar;", sizeof("NotRightTriangleBar;") - 1UL, {10704, 824}}, 
        {"NotRightTriangleEqual;",
      sizeof("NotRightTriangleEqual;") - 1UL, {8941, -1}}, 
        {"NotSquareSubset;", sizeof("NotSquareSubset;") - 1UL, {8847, 824}}, 
        {"NotSquareSubsetEqual;", sizeof("NotSquareSubsetEqual;") - 1UL, {8930, -1}}, 
        {"NotSquareSuperset;",
      sizeof("NotSquareSuperset;") - 1UL, {8848, 824}}, 
        {"NotSquareSupersetEqual;", sizeof("NotSquareSupersetEqual;") - 1UL, {8931, -1}}, 
        {"NotSubset;",
      sizeof("NotSubset;") - 1UL, {8834, 8402}}, 
        {"NotSubsetEqual;", sizeof("NotSubsetEqual;") - 1UL, {8840, -1}}, 
        {"NotSucceeds;", sizeof("NotSucceeds;") - 1UL, {8833, -1}}, 
        {"NotSucceedsEqual;", sizeof("NotSucceedsEqual;") - 1UL, {10928, 824}}, 
        {"NotSucceedsSlantEqual;", sizeof("NotSucceedsSlantEqual;") - 1UL, {8929, -1}}, 
        {"NotSucceedsTilde;",
      sizeof("NotSucceedsTilde;") - 1UL, {8831, 824}}, 
        {"NotSuperset;", sizeof("NotSuperset;") - 1UL, {8835, 8402}}, 
        {"NotSupersetEqual;", sizeof("NotSupersetEqual;") - 1UL, {8841, -1}}, 
        {"NotTilde;", sizeof("NotTilde;") - 1UL, {8769, -1}}, 
        {"NotTildeEqual;", sizeof("NotTildeEqual;") - 1UL, {8772, -1}}, 
        {"NotTildeFullEqual;", sizeof("NotTildeFullEqual;") - 1UL, {8775, -1}}, 
        {"NotTildeTilde;", sizeof("NotTildeTilde;") - 1UL, {8777, -1}}, 
        {"NotVerticalBar;", sizeof("NotVerticalBar;") - 1UL, {8740, -1}}, 
        {"Nscr;", sizeof("Nscr;") - 1UL, {119977, -1}}, 
        {"Ntilde;", sizeof("Ntilde;") - 1UL, {209, -1}}, 
        {"Ntilde", sizeof("Ntilde") - 1UL, {209, -1}}, 
        {"Nu;", sizeof("Nu;") - 1UL, {925, -1}}, 
        {"OElig;", sizeof("OElig;") - 1UL, {338, -1}}, 
        {"Oacute;", sizeof("Oacute;") - 1UL, {211, -1}}, 
        {"Oacute", sizeof("Oacute") - 1UL, {211, -1}}, 
        {"Ocirc;", sizeof("Ocirc;") - 1UL, {212, -1}}, 
        {"Ocirc", sizeof("Ocirc") - 1UL, {212, -1}}, 
        {"Ocy;", sizeof("Ocy;") - 1UL, {1054, -1}}, 
        {"Odblac;", sizeof("Odblac;") - 1UL, {336, -1}}, 
        {"Ofr;", sizeof("Ofr;") - 1UL, {120082, -1}}, 
        {"Ograve;", sizeof("Ograve;") - 1UL, {210, -1}}, 
        {"Ograve", sizeof("Ograve") - 1UL, {210, -1}}, 
        {"Omacr;", sizeof("Omacr;") - 1UL, {332, -1}}, 
        {"Omega;", sizeof("Omega;") - 1UL, {937, -1}}, 
        {"Omicron;", sizeof("Omicron;") - 1UL, {927, -1}}, 
        {"Oopf;", sizeof("Oopf;") - 1UL, {120134, -1}}, 
        {"OpenCurlyDoubleQuote;", sizeof("OpenCurlyDoubleQuote;") - 1UL, {8220, -1}}, 
        {"OpenCurlyQuote;",
      sizeof("OpenCurlyQuote;") - 1UL, {8216, -1}}, 
        {"Or;", sizeof("Or;") - 1UL, {10836, -1}}, 
        {"Oscr;", sizeof("Oscr;") - 1UL, {119978, -1}}, 
        {"Oslash;", sizeof("Oslash;") - 1UL, {216, -1}}, 
        {"Oslash", sizeof("Oslash") - 1UL, {216, -1}}, 
        {"Otilde;", sizeof("Otilde;") - 1UL, {213, -1}}, 
        {"Otilde", sizeof("Otilde") - 1UL, {213, -1}}, 
        {"Otimes;", sizeof("Otimes;") - 1UL, {10807, -1}}, 
        {"Ouml", sizeof("Ouml") - 1UL, {214, -1}}, 
        {"Ouml;", sizeof("Ouml;") - 1UL, {214, -1}}, 
        {"OverBar;", sizeof("OverBar;") - 1UL, {8254, -1}}, 
        {"OverBrace;", sizeof("OverBrace;") - 1UL, {9182, -1}}, 
        {"OverBracket;", sizeof("OverBracket;") - 1UL, {9140, -1}}, 
        {"OverParenthesis;", sizeof("OverParenthesis;") - 1UL, {9180, -1}}, 
        {"PartialD;", sizeof("PartialD;") - 1UL, {8706, -1}}, 
        {"Pcy;", sizeof("Pcy;") - 1UL, {1055, -1}}, 
        {"Pfr;", sizeof("Pfr;") - 1UL, {120083, -1}}, 
        {"Phi;", sizeof("Phi;") - 1UL, {934, -1}}, 
        {"Pi;", sizeof("Pi;") - 1UL, {928, -1}}, 
        {"PlusMinus;", sizeof("PlusMinus;") - 1UL, {177, -1}}, 
        {"Poincareplane;", sizeof("Poincareplane;") - 1UL, {8460, -1}}, 
        {"Popf;", sizeof("Popf;") - 1UL, {8473, -1}}, 
        {"Pr;", sizeof("Pr;") - 1UL, {10939, -1}}, 
        {"Precedes;", sizeof("Precedes;") - 1UL, {8826, -1}}, 
        {"PrecedesEqual;", sizeof("PrecedesEqual;") - 1UL, {10927, -1}}, 
        {"PrecedesSlantEqual;", sizeof("PrecedesSlantEqual;") - 1UL, {8828, -1}}, 
        {"PrecedesTilde;", sizeof("PrecedesTilde;") - 1UL, {8830, -1}}, 
        {"Prime;", sizeof("Prime;") - 1UL, {8243, -1}}, 
        {"Product;", sizeof("Product;") - 1UL, {8719, -1}}, 
        {"Proportion;", sizeof("Proportion;") - 1UL, {8759, -1}}, 
        {"Proportional;", sizeof("Proportional;") - 1UL, {8733, -1}}, 
        {"Pscr;", sizeof("Pscr;") - 1UL, {119979, -1}}, 
        {"Psi;", sizeof("Psi;") - 1UL, {936, -1}}, 
        {"QUOT;", sizeof("QUOT;") - 1UL, {34, -1}}, 
        {"QUOT", sizeof("QUOT") - 1UL, {34, -1}}, 
        {"Qfr;", sizeof("Qfr;") - 1UL, {120084, -1}}, 
        {"Qopf;", sizeof("Qopf;") - 1UL, {8474, -1}}, 
        {"Qscr;", sizeof("Qscr;") - 1UL, {119980, -1}}, 
        {"RBarr;", sizeof("RBarr;") - 1UL, {10512, -1}}, 
        {"REG;", sizeof("REG;") - 1UL, {174, -1}}, 
        {"REG", sizeof("REG") - 1UL, {174, -1}}, 
        {"Racute;", sizeof("Racute;") - 1UL, {340, -1}}, 
        {"Rang;", sizeof("Rang;") - 1UL, {10219, -1}}, 
        {"Rarr;", sizeof("Rarr;") - 1UL, {8608, -1}}, 
        {"Rarrtl;", sizeof("Rarrtl;") - 1UL, {10518, -1}}, 
        {"Rcaron;", sizeof("Rcaron;") - 1UL, {344, -1}}, 
        {"Rcedil;", sizeof("Rcedil;") - 1UL, {342, -1}}, 
        {"Rcy;", sizeof("Rcy;") - 1UL, {1056, -1}}, 
        {"Re;", sizeof("Re;") - 1UL, {8476, -1}}, 
        {"ReverseElement;", sizeof("ReverseElement;") - 1UL, {8715, -1}}, 
        {"ReverseEquilibrium;", sizeof("ReverseEquilibrium;") - 1UL, {8651, -1}}, 
        {"ReverseUpEquilibrium;", sizeof("ReverseUpEquilibrium;") - 1UL, {10607, -1}}, 
        {"Rfr;",
      sizeof("Rfr;") - 1UL, {8476, -1}}, 
        {"Rho;", sizeof("Rho;") - 1UL, {929, -1}}, 
        {"RightAngleBracket;", sizeof("RightAngleBracket;") - 1UL, {10217, -1}}, 
        {"RightArrow;", sizeof("RightArrow;") - 1UL, {8594, -1}}, 
        {"RightArrowBar;", sizeof("RightArrowBar;") - 1UL, {8677, -1}}, 
        {"RightArrowLeftArrow;", sizeof("RightArrowLeftArrow;") - 1UL, {8644, -1}}, 
        {"RightCeiling;", sizeof("RightCeiling;") - 1UL, {8969, -1}}, 
        {"RightDoubleBracket;", sizeof("RightDoubleBracket;") - 1UL, {10215, -1}}, 
        {"RightDownTeeVector;", sizeof("RightDownTeeVector;") - 1UL, {10589, -1}}, 
        {"RightDownVector;", sizeof("RightDownVector;") - 1UL, {8642, -1}}, 
        {"RightDownVectorBar;", sizeof("RightDownVectorBar;") - 1UL, {10581, -1}}, 
        {"RightFloor;", sizeof("RightFloor;") - 1UL, {8971, -1}}, 
        {"RightTee;", sizeof("RightTee;") - 1UL, {8866, -1}}, 
        {"RightTeeArrow;", sizeof("RightTeeArrow;") - 1UL, {8614, -1}}, 
        {"RightTeeVector;", sizeof("RightTeeVector;") - 1UL, {10587, -1}}, 
        {"RightTriangle;", sizeof("RightTriangle;") - 1UL, {8883, -1}}, 
        {"RightTriangleBar;", sizeof("RightTriangleBar;") - 1UL, {10704, -1}}, 
        {"RightTriangleEqual;", sizeof("RightTriangleEqual;") - 1UL, {8885, -1}}, 
        {"RightUpDownVector;", sizeof("RightUpDownVector;") - 1UL, {10575, -1}}, 
        {"RightUpTeeVector;", sizeof("RightUpTeeVector;") - 1UL, {10588, -1}}, 
        {"RightUpVector;", sizeof("RightUpVector;") - 1UL, {8638, -1}}, 
        {"RightUpVectorBar;", sizeof("RightUpVectorBar;") - 1UL, {10580, -1}}, 
        {"RightVector;", sizeof("RightVector;") - 1UL, {8640, -1}}, 
        {"RightVectorBar;", sizeof("RightVectorBar;") - 1UL, {10579, -1}}, 
        {"Rightarrow;", sizeof("Rightarrow;") - 1UL, {8658, -1}}, 
        {"Ropf;", sizeof("Ropf;") - 1UL, {8477, -1}}, 
        {"RoundImplies;", sizeof("RoundImplies;") - 1UL, {10608, -1}}, 
        {"Rrightarrow;", sizeof("Rrightarrow;") - 1UL, {8667, -1}}, 
        {"Rscr;", sizeof("Rscr;") - 1UL, {8475, -1}}, 
        {"Rsh;", sizeof("Rsh;") - 1UL, {8625, -1}}, 
        {"RuleDelayed;", sizeof("RuleDelayed;") - 1UL, {10740, -1}}, 
        {"SHCHcy;", sizeof("SHCHcy;") - 1UL, {1065, -1}}, 
        {"SHcy;", sizeof("SHcy;") - 1UL, {1064, -1}}, 
        {"SOFTcy;", sizeof("SOFTcy;") - 1UL, {1068, -1}}, 
        {"Sacute;", sizeof("Sacute;") - 1UL, {346, -1}}, 
        {"Sc;", sizeof("Sc;") - 1UL, {10940, -1}}, 
        {"Scaron;", sizeof("Scaron;") - 1UL, {352, -1}}, 
        {"Scedil;", sizeof("Scedil;") - 1UL, {350, -1}}, 
        {"Scirc;", sizeof("Scirc;") - 1UL, {348, -1}}, 
        {"Scy;", sizeof("Scy;") - 1UL, {1057, -1}}, 
        {"Sfr;", sizeof("Sfr;") - 1UL, {120086, -1}}, 
        {"ShortDownArrow;", sizeof("ShortDownArrow;") - 1UL, {8595, -1}}, 
        {"ShortLeftArrow;", sizeof("ShortLeftArrow;") - 1UL, {8592, -1}}, 
        {"ShortRightArrow;", sizeof("ShortRightArrow;") - 1UL, {8594, -1}}, 
        {"ShortUpArrow;", sizeof("ShortUpArrow;") - 1UL, {8593, -1}}, 
        {"Sigma;", sizeof("Sigma;") - 1UL, {931, -1}}, 
        {"SmallCircle;", sizeof("SmallCircle;") - 1UL, {8728, -1}}, 
        {"Sopf;", sizeof("Sopf;") - 1UL, {120138, -1}}, 
        {"Sqrt;", sizeof("Sqrt;") - 1UL, {8730, -1}}, 
        {"Square;", sizeof("Square;") - 1UL, {9633, -1}}, 
        {"SquareIntersection;", sizeof("SquareIntersection;") - 1UL, {8851, -1}}, 
        {"SquareSubset;", sizeof("SquareSubset;") - 1UL, {8847, -1}}, 
        {"SquareSubsetEqual;", sizeof("SquareSubsetEqual;") - 1UL, {8849, -1}}, 
        {"SquareSuperset;", sizeof("SquareSuperset;") - 1UL, {8848, -1}}, 
        {"SquareSupersetEqual;", sizeof("SquareSupersetEqual;") - 1UL, {8850, -1}}, 
        {"SquareUnion;", sizeof("SquareUnion;") - 1UL, {8852, -1}}, 
        {"Sscr;", sizeof("Sscr;") - 1UL, {119982, -1}}, 
        {"Star;", sizeof("Star;") - 1UL, {8902, -1}}, 
        {"Sub;", sizeof("Sub;") - 1UL, {8912, -1}}, 
        {"Subset;", sizeof("Subset;") - 1UL, {8912, -1}}, 
        {"SubsetEqual;", sizeof("SubsetEqual;") - 1UL, {8838, -1}}, 
        {"Succeeds;", sizeof("Succeeds;") - 1UL, {8827, -1}}, 
        {"SucceedsEqual;", sizeof("SucceedsEqual;") - 1UL, {10928, -1}}, 
        {"SucceedsSlantEqual;", sizeof("SucceedsSlantEqual;") - 1UL, {8829, -1}}, 
        {"SucceedsTilde;", sizeof("SucceedsTilde;") - 1UL, {8831, -1}}, 
        {"SuchThat;", sizeof("SuchThat;") - 1UL, {8715, -1}}, 
        {"Sum;", sizeof("Sum;") - 1UL, {8721, -1}}, 
        {"Sup;", sizeof("Sup;") - 1UL, {8913, -1}}, 
        {"Superset;", sizeof("Superset;") - 1UL, {8835, -1}}, 
        {"SupersetEqual;", sizeof("SupersetEqual;") - 1UL, {8839, -1}}, 
        {"Supset;", sizeof("Supset;") - 1UL, {8913, -1}}, 
        {"THORN;", sizeof("THORN;") - 1UL, {222, -1}}, 
        {"THORN", sizeof("THORN") - 1UL, {222, -1}}, 
        {"TRADE;", sizeof("TRADE;") - 1UL, {8482, -1}}, 
        {"TSHcy;", sizeof("TSHcy;") - 1UL, {1035, -1}}, 
        {"TScy;", sizeof("TScy;") - 1UL, {1062, -1}}, 
        {"Tab;", sizeof("Tab;") - 1UL, {9, -1}}, 
        {"Tau;", sizeof("Tau;") - 1UL, {932, -1}}, 
        {"Tcaron;", sizeof("Tcaron;") - 1UL, {356, -1}}, 
        {"Tcedil;", sizeof("Tcedil;") - 1UL, {354, -1}}, 
        {"Tcy;", sizeof("Tcy;") - 1UL, {1058, -1}}, 
        {"Tfr;", sizeof("Tfr;") - 1UL, {120087, -1}}, 
        {"Therefore;", sizeof("Therefore;") - 1UL, {8756, -1}}, 
        {"Theta;", sizeof("Theta;") - 1UL, {920, -1}}, 
        {"ThickSpace;", sizeof("ThickSpace;") - 1UL, {8287, 8202}}, 
        {"ThinSpace;", sizeof("ThinSpace;") - 1UL, {8201, -1}}, 
        {"Tilde;", sizeof("Tilde;") - 1UL, {8764, -1}}, 
        {"TildeEqual;", sizeof("TildeEqual;") - 1UL, {8771, -1}}, 
        {"TildeFullEqual;", sizeof("TildeFullEqual;") - 1UL, {8773, -1}}, 
        {"TildeTilde;", sizeof("TildeTilde;") - 1UL, {8776, -1}}, 
        {"Topf;", sizeof("Topf;") - 1UL, {120139, -1}}, 
        {"TripleDot;", sizeof("TripleDot;") - 1UL, {8411, -1}}, 
        {"Tscr;", sizeof("Tscr;") - 1UL, {119983, -1}}, 
        {"Tstrok;", sizeof("Tstrok;") - 1UL, {358, -1}}, 
        {"Uacute;", sizeof("Uacute;") - 1UL, {218, -1}}, 
        {"Uacute", sizeof("Uacute") - 1UL, {218, -1}}, 
        {"Uarr;", sizeof("Uarr;") - 1UL, {8607, -1}}, 
        {"Uarrocir;", sizeof("Uarrocir;") - 1UL, {10569, -1}}, 
        {"Ubrcy;", sizeof("Ubrcy;") - 1UL, {1038, -1}}, 
        {"Ubreve;", sizeof("Ubreve;") - 1UL, {364, -1}}, 
        {"Ucirc;", sizeof("Ucirc;") - 1UL, {219, -1}}, 
        {"Ucirc", sizeof("Ucirc") - 1UL, {219, -1}}, 
        {"Ucy;", sizeof("Ucy;") - 1UL, {1059, -1}}, 
        {"Udblac;", sizeof("Udblac;") - 1UL, {368, -1}}, 
        {"Ufr;", sizeof("Ufr;") - 1UL, {120088, -1}}, 
        {"Ugrave;", sizeof("Ugrave;") - 1UL, {217, -1}}, 
        {"Ugrave", sizeof("Ugrave") - 1UL, {217, -1}}, 
        {"Umacr;", sizeof("Umacr;") - 1UL, {362, -1}}, 
        {"UnderBar;", sizeof("UnderBar;") - 1UL, {95, -1}}, 
        {"UnderBrace;", sizeof("UnderBrace;") - 1UL, {9183, -1}}, 
        {"UnderBracket;", sizeof("UnderBracket;") - 1UL, {9141, -1}}, 
        {"UnderParenthesis;", sizeof("UnderParenthesis;") - 1UL, {9181, -1}}, 
        {"Union;", sizeof("Union;") - 1UL, {8899, -1}}, 
        {"UnionPlus;", sizeof("UnionPlus;") - 1UL, {8846, -1}}, 
        {"Uogon;", sizeof("Uogon;") - 1UL, {370, -1}}, 
        {"Uopf;", sizeof("Uopf;") - 1UL, {120140, -1}}, 
        {"UpArrow;", sizeof("UpArrow;") - 1UL, {8593, -1}}, 
        {"UpArrowBar;", sizeof("UpArrowBar;") - 1UL, {10514, -1}}, 
        {"UpArrowDownArrow;", sizeof("UpArrowDownArrow;") - 1UL, {8645, -1}}, 
        {"UpDownArrow;", sizeof("UpDownArrow;") - 1UL, {8597, -1}}, 
        {"UpEquilibrium;", sizeof("UpEquilibrium;") - 1UL, {10606, -1}}, 
        {"UpTee;", sizeof("UpTee;") - 1UL, {8869, -1}}, 
        {"UpTeeArrow;", sizeof("UpTeeArrow;") - 1UL, {8613, -1}}, 
        {"Uparrow;", sizeof("Uparrow;") - 1UL, {8657, -1}}, 
        {"Updownarrow;", sizeof("Updownarrow;") - 1UL, {8661, -1}}, 
        {"UpperLeftArrow;", sizeof("UpperLeftArrow;") - 1UL, {8598, -1}}, 
        {"UpperRightArrow;", sizeof("UpperRightArrow;") - 1UL, {8599, -1}}, 
        {"Upsi;", sizeof("Upsi;") - 1UL, {978, -1}}, 
        {"Upsilon;", sizeof("Upsilon;") - 1UL, {933, -1}}, 
        {"Uring;", sizeof("Uring;") - 1UL, {366, -1}}, 
        {"Uscr;", sizeof("Uscr;") - 1UL, {119984, -1}}, 
        {"Utilde;", sizeof("Utilde;") - 1UL, {360, -1}}, 
        {"Uuml;", sizeof("Uuml;") - 1UL, {220, -1}}, 
        {"Uuml", sizeof("Uuml") - 1UL, {220, -1}}, 
        {"VDash;", sizeof("VDash;") - 1UL, {8875, -1}}, 
        {"Vbar;", sizeof("Vbar;") - 1UL, {10987, -1}}, 
        {"Vcy;", sizeof("Vcy;") - 1UL, {1042, -1}}, 
        {"Vdash;", sizeof("Vdash;") - 1UL, {8873, -1}}, 
        {"Vdashl;", sizeof("Vdashl;") - 1UL, {10982, -1}}, 
        {"Vee;", sizeof("Vee;") - 1UL, {8897, -1}}, 
        {"Verbar;", sizeof("Verbar;") - 1UL, {8214, -1}}, 
        {"Vert;", sizeof("Vert;") - 1UL, {8214, -1}}, 
        {"VerticalBar;", sizeof("VerticalBar;") - 1UL, {8739, -1}}, 
        {"VerticalLine;", sizeof("VerticalLine;") - 1UL, {124, -1}}, 
        {"VerticalSeparator;", sizeof("VerticalSeparator;") - 1UL, {10072, -1}}, 
        {"VerticalTilde;", sizeof("VerticalTilde;") - 1UL, {8768, -1}}, 
        {"VeryThinSpace;", sizeof("VeryThinSpace;") - 1UL, {8202, -1}}, 
        {"Vfr;", sizeof("Vfr;") - 1UL, {120089, -1}}, 
        {"Vopf;", sizeof("Vopf;") - 1UL, {120141, -1}}, 
        {"Vscr;", sizeof("Vscr;") - 1UL, {119985, -1}}, 
        {"Vvdash;", sizeof("Vvdash;") - 1UL, {8874, -1}}, 
        {"Wcirc;", sizeof("Wcirc;") - 1UL, {372, -1}}, 
        {"Wedge;", sizeof("Wedge;") - 1UL, {8896, -1}}, 
        {"Wfr;", sizeof("Wfr;") - 1UL, {120090, -1}}, 
        {"Wopf;", sizeof("Wopf;") - 1UL, {120142, -1}}, 
        {"Wscr;", sizeof("Wscr;") - 1UL, {119986, -1}}, 
        {"Xfr;", sizeof("Xfr;") - 1UL, {120091, -1}}, 
        {"Xi;", sizeof("Xi;") - 1UL, {926, -1}}, 
        {"Xopf;", sizeof("Xopf;") - 1UL, {120143, -1}}, 
        {"Xscr;", sizeof("Xscr;") - 1UL, {119987, -1}}, 
        {"YAcy;", sizeof("YAcy;") - 1UL, {1071, -1}}, 
        {"YIcy;", sizeof("YIcy;") - 1UL, {1031, -1}}, 
        {"YUcy;", sizeof("YUcy;") - 1UL, {1070, -1}}, 
        {"Yacute", sizeof("Yacute") - 1UL, {221, -1}}, 
        {"Yacute;", sizeof("Yacute;") - 1UL, {221, -1}}, 
        {"Ycirc;", sizeof("Ycirc;") - 1UL, {374, -1}}, 
        {"Ycy;", sizeof("Ycy;") - 1UL, {1067, -1}}, 
        {"Yfr;", sizeof("Yfr;") - 1UL, {120092, -1}}, 
        {"Yopf;", sizeof("Yopf;") - 1UL, {120144, -1}}, 
        {"Yscr;", sizeof("Yscr;") - 1UL, {119988, -1}}, 
        {"Yuml;", sizeof("Yuml;") - 1UL, {376, -1}}, 
        {"ZHcy;", sizeof("ZHcy;") - 1UL, {1046, -1}}, 
        {"Zacute;", sizeof("Zacute;") - 1UL, {377, -1}}, 
        {"Zcaron;", sizeof("Zcaron;") - 1UL, {381, -1}}, 
        {"Zcy;", sizeof("Zcy;") - 1UL, {1047, -1}}, 
        {"Zdot;", sizeof("Zdot;") - 1UL, {379, -1}}, 
        {"ZeroWidthSpace;", sizeof("ZeroWidthSpace;") - 1UL, {8203, -1}}, 
        {"Zeta;", sizeof("Zeta;") - 1UL, {918, -1}}, 
        {"Zfr;", sizeof("Zfr;") - 1UL, {8488, -1}}, 
        {"Zopf;", sizeof("Zopf;") - 1UL, {8484, -1}}, 
        {"Zscr;", sizeof("Zscr;") - 1UL, {119989, -1}}, 
        {"aacute;", sizeof("aacute;") - 1UL, {225, -1}}, 
        {"aacute", sizeof("aacute") - 1UL, {225, -1}}, 
        {"abreve;", sizeof("abreve;") - 1UL, {259, -1}}, 
        {"ac;", sizeof("ac;") - 1UL, {8766, -1}}, 
        {"acE;", sizeof("acE;") - 1UL, {8766, 819}}, 
        {"acd;", sizeof("acd;") - 1UL, {8767, -1}}, 
        {"acirc;", sizeof("acirc;") - 1UL, {226, -1}}, 
        {"acirc", sizeof("acirc") - 1UL, {226, -1}}, 
        {"acute;", sizeof("acute;") - 1UL, {180, -1}}, 
        {"acute", sizeof("acute") - 1UL, {180, -1}}, 
        {"acy;", sizeof("acy;") - 1UL, {1072, -1}}, 
        {"aelig;", sizeof("aelig;") - 1UL, {230, -1}}, 
        {"aelig", sizeof("aelig") - 1UL, {230, -1}}, 
        {"af;", sizeof("af;") - 1UL, {8289, -1}}, 
        {"afr;", sizeof("afr;") - 1UL, {120094, -1}}, 
        {"agrave;", sizeof("agrave;") - 1UL, {224, -1}}, 
        {"agrave", sizeof("agrave") - 1UL, {224, -1}}, 
        {"alefsym;", sizeof("alefsym;") - 1UL, {8501, -1}}, 
        {"aleph;", sizeof("aleph;") - 1UL, {8501, -1}}, 
        {"alpha;", sizeof("alpha;") - 1UL, {945, -1}}, 
        {"amacr;", sizeof("amacr;") - 1UL, {257, -1}}, 
        {"amalg;", sizeof("amalg;") - 1UL, {10815, -1}}, 
        {"amp;", sizeof("amp;") - 1UL, {38, -1}}, 
        {"amp", sizeof("amp") - 1UL, {38, -1}}, 
        {"and;", sizeof("and;") - 1UL, {8743, -1}}, 
        {"andand;", sizeof("andand;") - 1UL, {10837, -1}}, 
        {"andd;", sizeof("andd;") - 1UL, {10844, -1}}, 
        {"andslope;", sizeof("andslope;") - 1UL, {10840, -1}}, 
        {"andv;", sizeof("andv;") - 1UL, {10842, -1}}, 
        {"ang;", sizeof("ang;") - 1UL, {8736, -1}}, 
        {"ange;", sizeof("ange;") - 1UL, {10660, -1}}, 
        {"angle;", sizeof("angle;") - 1UL, {8736, -1}}, 
        {"angmsd;", sizeof("angmsd;") - 1UL, {8737, -1}}, 
        {"angmsdaa;", sizeof("angmsdaa;") - 1UL, {10664, -1}}, 
        {"angmsdab;", sizeof("angmsdab;") - 1UL, {10665, -1}}, 
        {"angmsdac;", sizeof("angmsdac;") - 1UL, {10666, -1}}, 
        {"angmsdad;", sizeof("angmsdad;") - 1UL, {10667, -1}}, 
        {"angmsdae;", sizeof("angmsdae;") - 1UL, {10668, -1}}, 
        {"angmsdaf;", sizeof("angmsdaf;") - 1UL, {10669, -1}}, 
        {"angmsdag;", sizeof("angmsdag;") - 1UL, {10670, -1}}, 
        {"angmsdah;", sizeof("angmsdah;") - 1UL, {10671, -1}}, 
        {"angrt;", sizeof("angrt;") - 1UL, {8735, -1}}, 
        {"angrtvb;", sizeof("angrtvb;") - 1UL, {8894, -1}}, 
        {"angrtvbd;", sizeof("angrtvbd;") - 1UL, {10653, -1}}, 
        {"angsph;", sizeof("angsph;") - 1UL, {8738, -1}}, 
        {"angst;", sizeof("angst;") - 1UL, {197, -1}}, 
        {"angzarr;", sizeof("angzarr;") - 1UL, {9084, -1}}, 
        {"aogon;", sizeof("aogon;") - 1UL, {261, -1}}, 
        {"aopf;", sizeof("aopf;") - 1UL, {120146, -1}}, 
        {"ap;", sizeof("ap;") - 1UL, {8776, -1}}, 
        {"apE;", sizeof("apE;") - 1UL, {10864, -1}}, 
        {"apacir;", sizeof("apacir;") - 1UL, {10863, -1}}, 
        {"ape;", sizeof("ape;") - 1UL, {8778, -1}}, 
        {"apid;", sizeof("apid;") - 1UL, {8779, -1}}, 
        {"apos;", sizeof("apos;") - 1UL, {39, -1}}, 
        {"approx;", sizeof("approx;") - 1UL, {8776, -1}}, 
        {"approxeq;", sizeof("approxeq;") - 1UL, {8778, -1}}, 
        {"aring;", sizeof("aring;") - 1UL, {229, -1}}, 
        {"aring", sizeof("aring") - 1UL, {229, -1}}, 
        {"ascr;", sizeof("ascr;") - 1UL, {119990, -1}}, 
        {"ast;", sizeof("ast;") - 1UL, {42, -1}}, 
        {"asymp;", sizeof("asymp;") - 1UL, {8776, -1}}, 
        {"asympeq;", sizeof("asympeq;") - 1UL, {8781, -1}}, 
        {"atilde;", sizeof("atilde;") - 1UL, {227, -1}}, 
        {"atilde", sizeof("atilde") - 1UL, {227, -1}}, 
        {"auml;", sizeof("auml;") - 1UL, {228, -1}}, 
        {"auml", sizeof("auml") - 1UL, {228, -1}}, 
        {"awconint;", sizeof("awconint;") - 1UL, {8755, -1}}, 
        {"awint;", sizeof("awint;") - 1UL, {10769, -1}}, 
        {"bNot;", sizeof("bNot;") - 1UL, {10989, -1}}, 
        {"backcong;", sizeof("backcong;") - 1UL, {8780, -1}}, 
        {"backepsilon;", sizeof("backepsilon;") - 1UL, {1014, -1}}, 
        {"backprime;", sizeof("backprime;") - 1UL, {8245, -1}}, 
        {"backsim;", sizeof("backsim;") - 1UL, {8765, -1}}, 
        {"backsimeq;", sizeof("backsimeq;") - 1UL, {8909, -1}}, 
        {"barvee;", sizeof("barvee;") - 1UL, {8893, -1}}, 
        {"barwed;", sizeof("barwed;") - 1UL, {8965, -1}}, 
        {"barwedge;", sizeof("barwedge;") - 1UL, {8965, -1}}, 
        {"bbrk;", sizeof("bbrk;") - 1UL, {9141, -1}}, 
        {"bbrktbrk;", sizeof("bbrktbrk;") - 1UL, {9142, -1}}, 
        {"bcong;", sizeof("bcong;") - 1UL, {8780, -1}}, 
        {"bcy;", sizeof("bcy;") - 1UL, {1073, -1}}, 
        {"bdquo;", sizeof("bdquo;") - 1UL, {8222, -1}}, 
        {"becaus;", sizeof("becaus;") - 1UL, {8757, -1}}, 
        {"because;", sizeof("because;") - 1UL, {8757, -1}}, 
        {"bemptyv;", sizeof("bemptyv;") - 1UL, {10672, -1}}, 
        {"bepsi;", sizeof("bepsi;") - 1UL, {1014, -1}}, 
        {"bernou;", sizeof("bernou;") - 1UL, {8492, -1}}, 
        {"beta;", sizeof("beta;") - 1UL, {946, -1}}, 
        {"beth;", sizeof("beth;") - 1UL, {8502, -1}}, 
        {"between;", sizeof("between;") - 1UL, {8812, -1}}, 
        {"bfr;", sizeof("bfr;") - 1UL, {120095, -1}}, 
        {"bigcap;", sizeof("bigcap;") - 1UL, {8898, -1}}, 
        {"bigcirc;", sizeof("bigcirc;") - 1UL, {9711, -1}}, 
        {"bigcup;", sizeof("bigcup;") - 1UL, {8899, -1}}, 
        {"bigodot;", sizeof("bigodot;") - 1UL, {10752, -1}}, 
        {"bigoplus;", sizeof("bigoplus;") - 1UL, {10753, -1}}, 
        {"bigotimes;", sizeof("bigotimes;") - 1UL, {10754, -1}}, 
        {"bigsqcup;", sizeof("bigsqcup;") - 1UL, {10758, -1}}, 
        {"bigstar;", sizeof("bigstar;") - 1UL, {9733, -1}}, 
        {"bigtriangledown;", sizeof("bigtriangledown;") - 1UL, {9661, -1}}, 
        {"bigtriangleup;", sizeof("bigtriangleup;") - 1UL, {9651, -1}}, 
        {"biguplus;", sizeof("biguplus;") - 1UL, {10756, -1}}, 
        {"bigvee;", sizeof("bigvee;") - 1UL, {8897, -1}}, 
        {"bigwedge;", sizeof("bigwedge;") - 1UL, {8896, -1}}, 
        {"bkarow;", sizeof("bkarow;") - 1UL, {10509, -1}}, 
        {"blacklozenge;", sizeof("blacklozenge;") - 1UL, {10731, -1}}, 
        {"blacksquare;", sizeof("blacksquare;") - 1UL, {9642, -1}}, 
        {"blacktriangle;", sizeof("blacktriangle;") - 1UL, {9652, -1}}, 
        {"blacktriangledown;", sizeof("blacktriangledown;") - 1UL, {9662, -1}}, 
        {"blacktriangleleft;", sizeof("blacktriangleleft;") - 1UL, {9666, -1}}, 
        {"blacktriangleright;", sizeof("blacktriangleright;") - 1UL, {9656, -1}}, 
        {"blank;", sizeof("blank;") - 1UL, {9251, -1}}, 
        {"blk12;", sizeof("blk12;") - 1UL, {9618, -1}}, 
        {"blk14;", sizeof("blk14;") - 1UL, {9617, -1}}, 
        {"blk34;", sizeof("blk34;") - 1UL, {9619, -1}}, 
        {"block;", sizeof("block;") - 1UL, {9608, -1}}, 
        {"bne;", sizeof("bne;") - 1UL, {61, 8421}}, 
        {"bnequiv;", sizeof("bnequiv;") - 1UL, {8801, 8421}}, 
        {"bnot;", sizeof("bnot;") - 1UL, {8976, -1}}, 
        {"bopf;", sizeof("bopf;") - 1UL, {120147, -1}}, 
        {"bot;", sizeof("bot;") - 1UL, {8869, -1}}, 
        {"bottom;", sizeof("bottom;") - 1UL, {8869, -1}}, 
        {"bowtie;", sizeof("bowtie;") - 1UL, {8904, -1}}, 
        {"boxDL;", sizeof("boxDL;") - 1UL, {9559, -1}}, 
        {"boxDR;", sizeof("boxDR;") - 1UL, {9556, -1}}, 
        {"boxDl;", sizeof("boxDl;") - 1UL, {9558, -1}}, 
        {"boxDr;", sizeof("boxDr;") - 1UL, {9555, -1}}, 
        {"boxH;", sizeof("boxH;") - 1UL, {9552, -1}}, 
        {"boxHD;", sizeof("boxHD;") - 1UL, {9574, -1}}, 
        {"boxHU;", sizeof("boxHU;") - 1UL, {9577, -1}}, 
        {"boxHd;", sizeof("boxHd;") - 1UL, {9572, -1}}, 
        {"boxHu;", sizeof("boxHu;") - 1UL, {9575, -1}}, 
        {"boxUL;", sizeof("boxUL;") - 1UL, {9565, -1}}, 
        {"boxUR;", sizeof("boxUR;") - 1UL, {9562, -1}}, 
        {"boxUl;", sizeof("boxUl;") - 1UL, {9564, -1}}, 
        {"boxUr;", sizeof("boxUr;") - 1UL, {9561, -1}}, 
        {"boxV;", sizeof("boxV;") - 1UL, {9553, -1}}, 
        {"boxVH;", sizeof("boxVH;") - 1UL, {9580, -1}}, 
        {"boxVL;", sizeof("boxVL;") - 1UL, {9571, -1}}, 
        {"boxVR;", sizeof("boxVR;") - 1UL, {9568, -1}}, 
        {"boxVh;", sizeof("boxVh;") - 1UL, {9579, -1}}, 
        {"boxVl;", sizeof("boxVl;") - 1UL, {9570, -1}}, 
        {"boxVr;", sizeof("boxVr;") - 1UL, {9567, -1}}, 
        {"boxbox;", sizeof("boxbox;") - 1UL, {10697, -1}}, 
        {"boxdL;", sizeof("boxdL;") - 1UL, {9557, -1}}, 
        {"boxdR;", sizeof("boxdR;") - 1UL, {9554, -1}}, 
        {"boxdl;", sizeof("boxdl;") - 1UL, {9488, -1}}, 
        {"boxdr;", sizeof("boxdr;") - 1UL, {9484, -1}}, 
        {"boxh;", sizeof("boxh;") - 1UL, {9472, -1}}, 
        {"boxhD;", sizeof("boxhD;") - 1UL, {9573, -1}}, 
        {"boxhU;", sizeof("boxhU;") - 1UL, {9576, -1}}, 
        {"boxhd;", sizeof("boxhd;") - 1UL, {9516, -1}}, 
        {"boxhu;", sizeof("boxhu;") - 1UL, {9524, -1}}, 
        {"boxminus;", sizeof("boxminus;") - 1UL, {8863, -1}}, 
        {"boxplus;", sizeof("boxplus;") - 1UL, {8862, -1}}, 
        {"boxtimes;", sizeof("boxtimes;") - 1UL, {8864, -1}}, 
        {"boxuL;", sizeof("boxuL;") - 1UL, {9563, -1}}, 
        {"boxuR;", sizeof("boxuR;") - 1UL, {9560, -1}}, 
        {"boxul;", sizeof("boxul;") - 1UL, {9496, -1}}, 
        {"boxur;", sizeof("boxur;") - 1UL, {9492, -1}}, 
        {"boxv;", sizeof("boxv;") - 1UL, {9474, -1}}, 
        {"boxvH;", sizeof("boxvH;") - 1UL, {9578, -1}}, 
        {"boxvL;", sizeof("boxvL;") - 1UL, {9569, -1}}, 
        {"boxvR;", sizeof("boxvR;") - 1UL, {9566, -1}}, 
        {"boxvh;", sizeof("boxvh;") - 1UL, {9532, -1}}, 
        {"boxvl;", sizeof("boxvl;") - 1UL, {9508, -1}}, 
        {"boxvr;", sizeof("boxvr;") - 1UL, {9500, -1}}, 
        {"bprime;", sizeof("bprime;") - 1UL, {8245, -1}}, 
        {"breve;", sizeof("breve;") - 1UL, {728, -1}}, 
        {"brvbar;", sizeof("brvbar;") - 1UL, {166, -1}}, 
        {"brvbar", sizeof("brvbar") - 1UL, {166, -1}}, 
        {"bscr;", sizeof("bscr;") - 1UL, {119991, -1}}, 
        {"bsemi;", sizeof("bsemi;") - 1UL, {8271, -1}}, 
        {"bsim;", sizeof("bsim;") - 1UL, {8765, -1}}, 
        {"bsime;", sizeof("bsime;") - 1UL, {8909, -1}}, 
        {"bsol;", sizeof("bsol;") - 1UL, {92, -1}}, 
        {"bsolb;", sizeof("bsolb;") - 1UL, {10693, -1}}, 
        {"bsolhsub;", sizeof("bsolhsub;") - 1UL, {10184, -1}}, 
        {"bull;", sizeof("bull;") - 1UL, {8226, -1}}, 
        {"bullet;", sizeof("bullet;") - 1UL, {8226, -1}}, 
        {"bump;", sizeof("bump;") - 1UL, {8782, -1}}, 
        {"bumpE;", sizeof("bumpE;") - 1UL, {10926, -1}}, 
        {"bumpe;", sizeof("bumpe;") - 1UL, {8783, -1}}, 
        {"bumpeq;", sizeof("bumpeq;") - 1UL, {8783, -1}}, 
        {"cacute;", sizeof("cacute;") - 1UL, {263, -1}}, 
        {"cap;", sizeof("cap;") - 1UL, {8745, -1}}, 
        {"capand;", sizeof("capand;") - 1UL, {10820, -1}}, 
        {"capbrcup;", sizeof("capbrcup;") - 1UL, {10825, -1}}, 
        {"capcap;", sizeof("capcap;") - 1UL, {10827, -1}}, 
        {"capcup;", sizeof("capcup;") - 1UL, {10823, -1}}, 
        {"capdot;", sizeof("capdot;") - 1UL, {10816, -1}}, 
        {"caps;", sizeof("caps;") - 1UL, {8745, 65024}}, 
        {"caret;", sizeof("caret;") - 1UL, {8257, -1}}, 
        {"caron;", sizeof("caron;") - 1UL, {711, -1}}, 
        {"ccaps;", sizeof("ccaps;") - 1UL, {10829, -1}}, 
        {"ccaron;", sizeof("ccaron;") - 1UL, {269, -1}}, 
        {"ccedil;", sizeof("ccedil;") - 1UL, {231, -1}}, 
        {"ccedil", sizeof("ccedil") - 1UL, {231, -1}}, 
        {"ccirc;", sizeof("ccirc;") - 1UL, {265, -1}}, 
        {"ccups;", sizeof("ccups;") - 1UL, {10828, -1}}, 
        {"ccupssm;", sizeof("ccupssm;") - 1UL, {10832, -1}}, 
        {"cdot;", sizeof("cdot;") - 1UL, {267, -1}}, 
        {"cedil;", sizeof("cedil;") - 1UL, {184, -1}}, 
        {"cedil", sizeof("cedil") - 1UL, {184, -1}}, 
        {"cemptyv;", sizeof("cemptyv;") - 1UL, {10674, -1}}, 
        {"cent;", sizeof("cent;") - 1UL, {162, -1}}, 
        {"cent", sizeof("cent") - 1UL, {162, -1}}, 
        {"centerdot;", sizeof("centerdot;") - 1UL, {183, -1}}, 
        {"cfr;", sizeof("cfr;") - 1UL, {120096, -1}}, 
        {"chcy;", sizeof("chcy;") - 1UL, {1095, -1}}, 
        {"check;", sizeof("check;") - 1UL, {10003, -1}}, 
        {"checkmark;", sizeof("checkmark;") - 1UL, {10003, -1}}, 
        {"chi;", sizeof("chi;") - 1UL, {967, -1}}, 
        {"cir;", sizeof("cir;") - 1UL, {9675, -1}}, 
        {"cirE;", sizeof("cirE;") - 1UL, {10691, -1}}, 
        {"circ;", sizeof("circ;") - 1UL, {710, -1}}, 
        {"circeq;", sizeof("circeq;") - 1UL, {8791, -1}}, 
        {"circlearrowleft;", sizeof("circlearrowleft;") - 1UL, {8634, -1}}, 
        {"circlearrowright;", sizeof("circlearrowright;") - 1UL, {8635, -1}}, 
        {"circledR;", sizeof("circledR;") - 1UL, {174, -1}}, 
        {"circledS;", sizeof("circledS;") - 1UL, {9416, -1}}, 
        {"circledast;", sizeof("circledast;") - 1UL, {8859, -1}}, 
        {"circledcirc;", sizeof("circledcirc;") - 1UL, {8858, -1}}, 
        {"circleddash;", sizeof("circleddash;") - 1UL, {8861, -1}}, 
        {"cire;", sizeof("cire;") - 1UL, {8791, -1}}, 
        {"cirfnint;", sizeof("cirfnint;") - 1UL, {10768, -1}}, 
        {"cirmid;", sizeof("cirmid;") - 1UL, {10991, -1}}, 
        {"cirscir;", sizeof("cirscir;") - 1UL, {10690, -1}}, 
        {"clubs;", sizeof("clubs;") - 1UL, {9827, -1}}, 
        {"clubsuit;", sizeof("clubsuit;") - 1UL, {9827, -1}}, 
        {"colon;", sizeof("colon;") - 1UL, {58, -1}}, 
        {"colone;", sizeof("colone;") - 1UL, {8788, -1}}, 
        {"coloneq;", sizeof("coloneq;") - 1UL, {8788, -1}}, 
        {"comma;", sizeof("comma;") - 1UL, {44, -1}}, 
        {"commat;", sizeof("commat;") - 1UL, {64, -1}}, 
        {"comp;", sizeof("comp;") - 1UL, {8705, -1}}, 
        {"compfn;", sizeof("compfn;") - 1UL, {8728, -1}}, 
        {"complement;", sizeof("complement;") - 1UL, {8705, -1}}, 
        {"complexes;", sizeof("complexes;") - 1UL, {8450, -1}}, 
        {"cong;", sizeof("cong;") - 1UL, {8773, -1}}, 
        {"congdot;", sizeof("congdot;") - 1UL, {10861, -1}}, 
        {"conint;", sizeof("conint;") - 1UL, {8750, -1}}, 
        {"copf;", sizeof("copf;") - 1UL, {120148, -1}}, 
        {"coprod;", sizeof("coprod;") - 1UL, {8720, -1}}, 
        {"copy;", sizeof("copy;") - 1UL, {169, -1}}, 
        {"copy", sizeof("copy") - 1UL, {169, -1}}, 
        {"copysr;", sizeof("copysr;") - 1UL, {8471, -1}}, 
        {"crarr;", sizeof("crarr;") - 1UL, {8629, -1}}, 
        {"cross;", sizeof("cross;") - 1UL, {10007, -1}}, 
        {"cscr;", sizeof("cscr;") - 1UL, {119992, -1}}, 
        {"csub;", sizeof("csub;") - 1UL, {10959, -1}}, 
        {"csube;", sizeof("csube;") - 1UL, {10961, -1}}, 
        {"csup;", sizeof("csup;") - 1UL, {10960, -1}}, 
        {"csupe;", sizeof("csupe;") - 1UL, {10962, -1}}, 
        {"ctdot;", sizeof("ctdot;") - 1UL, {8943, -1}}, 
        {"cudarrl;", sizeof("cudarrl;") - 1UL, {10552, -1}}, 
        {"cudarrr;", sizeof("cudarrr;") - 1UL, {10549, -1}}, 
        {"cuepr;", sizeof("cuepr;") - 1UL, {8926, -1}}, 
        {"cuesc;", sizeof("cuesc;") - 1UL, {8927, -1}}, 
        {"cularr;", sizeof("cularr;") - 1UL, {8630, -1}}, 
        {"cularrp;", sizeof("cularrp;") - 1UL, {10557, -1}}, 
        {"cup;", sizeof("cup;") - 1UL, {8746, -1}}, 
        {"cupbrcap;", sizeof("cupbrcap;") - 1UL, {10824, -1}}, 
        {"cupcap;", sizeof("cupcap;") - 1UL, {10822, -1}}, 
        {"cupcup;", sizeof("cupcup;") - 1UL, {10826, -1}}, 
        {"cupdot;", sizeof("cupdot;") - 1UL, {8845, -1}}, 
        {"cupor;", sizeof("cupor;") - 1UL, {10821, -1}}, 
        {"cups;", sizeof("cups;") - 1UL, {8746, 65024}}, 
        {"curarr;", sizeof("curarr;") - 1UL, {8631, -1}}, 
        {"curarrm;", sizeof("curarrm;") - 1UL, {10556, -1}}, 
        {"curlyeqprec;", sizeof("curlyeqprec;") - 1UL, {8926, -1}}, 
        {"curlyeqsucc;", sizeof("curlyeqsucc;") - 1UL, {8927, -1}}, 
        {"curlyvee;", sizeof("curlyvee;") - 1UL, {8910, -1}}, 
        {"curlywedge;", sizeof("curlywedge;") - 1UL, {8911, -1}}, 
        {"curren;", sizeof("curren;") - 1UL, {164, -1}}, 
        {"curren", sizeof("curren") - 1UL, {164, -1}}, 
        {"curvearrowleft;", sizeof("curvearrowleft;") - 1UL, {8630, -1}}, 
        {"curvearrowright;", sizeof("curvearrowright;") - 1UL, {8631, -1}}, 
        {"cuvee;", sizeof("cuvee;") - 1UL, {8910, -1}}, 
        {"cuwed;", sizeof("cuwed;") - 1UL, {8911, -1}}, 
        {"cwconint;", sizeof("cwconint;") - 1UL, {8754, -1}}, 
        {"cwint;", sizeof("cwint;") - 1UL, {8753, -1}}, 
        {"cylcty;", sizeof("cylcty;") - 1UL, {9005, -1}}, 
        {"dArr;", sizeof("dArr;") - 1UL, {8659, -1}}, 
        {"dHar;", sizeof("dHar;") - 1UL, {10597, -1}}, 
        {"dagger;", sizeof("dagger;") - 1UL, {8224, -1}}, 
        {"daleth;", sizeof("daleth;") - 1UL, {8504, -1}}, 
        {"darr;", sizeof("darr;") - 1UL, {8595, -1}}, 
        {"dash;", sizeof("dash;") - 1UL, {8208, -1}}, 
        {"dashv;", sizeof("dashv;") - 1UL, {8867, -1}}, 
        {"dbkarow;", sizeof("dbkarow;") - 1UL, {10511, -1}}, 
        {"dblac;", sizeof("dblac;") - 1UL, {733, -1}}, 
        {"dcaron;", sizeof("dcaron;") - 1UL, {271, -1}}, 
        {"dcy;", sizeof("dcy;") - 1UL, {1076, -1}}, 
        {"dd;", sizeof("dd;") - 1UL, {8518, -1}}, 
        {"ddagger;", sizeof("ddagger;") - 1UL, {8225, -1}}, 
        {"ddarr;", sizeof("ddarr;") - 1UL, {8650, -1}}, 
        {"ddotseq;", sizeof("ddotseq;") - 1UL, {10871, -1}}, 
        {"deg;", sizeof("deg;") - 1UL, {176, -1}}, 
        {"deg", sizeof("deg") - 1UL, {176, -1}}, 
        {"delta;", sizeof("delta;") - 1UL, {948, -1}}, 
        {"demptyv;", sizeof("demptyv;") - 1UL, {10673, -1}}, 
        {"dfisht;", sizeof("dfisht;") - 1UL, {10623, -1}}, 
        {"dfr;", sizeof("dfr;") - 1UL, {120097, -1}}, 
        {"dharl;", sizeof("dharl;") - 1UL, {8643, -1}}, 
        {"dharr;", sizeof("dharr;") - 1UL, {8642, -1}}, 
        {"diam;", sizeof("diam;") - 1UL, {8900, -1}}, 
        {"diamond;", sizeof("diamond;") - 1UL, {8900, -1}}, 
        {"diamondsuit;", sizeof("diamondsuit;") - 1UL, {9830, -1}}, 
        {"diams;", sizeof("diams;") - 1UL, {9830, -1}}, 
        {"die;", sizeof("die;") - 1UL, {168, -1}}, 
        {"digamma;", sizeof("digamma;") - 1UL, {989, -1}}, 
        {"disin;", sizeof("disin;") - 1UL, {8946, -1}}, 
        {"div;", sizeof("div;") - 1UL, {247, -1}}, 
        {"divide;", sizeof("divide;") - 1UL, {247, -1}}, 
        {"divide", sizeof("divide") - 1UL, {247, -1}}, 
        {"divideontimes;", sizeof("divideontimes;") - 1UL, {8903, -1}}, 
        {"divonx;", sizeof("divonx;") - 1UL, {8903, -1}}, 
        {"djcy;", sizeof("djcy;") - 1UL, {1106, -1}}, 
        {"dlcorn;", sizeof("dlcorn;") - 1UL, {8990, -1}}, 
        {"dlcrop;", sizeof("dlcrop;") - 1UL, {8973, -1}}, 
        {"dollar;", sizeof("dollar;") - 1UL, {36, -1}}, 
        {"dopf;", sizeof("dopf;") - 1UL, {120149, -1}}, 
        {"dot;", sizeof("dot;") - 1UL, {729, -1}}, 
        {"doteq;", sizeof("doteq;") - 1UL, {8784, -1}}, 
        {"doteqdot;", sizeof("doteqdot;") - 1UL, {8785, -1}}, 
        {"dotminus;", sizeof("dotminus;") - 1UL, {8760, -1}}, 
        {"dotplus;", sizeof("dotplus;") - 1UL, {8724, -1}}, 
        {"dotsquare;", sizeof("dotsquare;") - 1UL, {8865, -1}}, 
        {"doublebarwedge;", sizeof("doublebarwedge;") - 1UL, {8966, -1}}, 
        {"downarrow;", sizeof("downarrow;") - 1UL, {8595, -1}}, 
        {"downdownarrows;", sizeof("downdownarrows;") - 1UL, {8650, -1}}, 
        {"downharpoonleft;", sizeof("downharpoonleft;") - 1UL, {8643, -1}}, 
        {"downharpoonright;", sizeof("downharpoonright;") - 1UL, {8642, -1}}, 
        {"drbkarow;", sizeof("drbkarow;") - 1UL, {10512, -1}}, 
        {"drcorn;", sizeof("drcorn;") - 1UL, {8991, -1}}, 
        {"drcrop;", sizeof("drcrop;") - 1UL, {8972, -1}}, 
        {"dscr;", sizeof("dscr;") - 1UL, {119993, -1}}, 
        {"dscy;", sizeof("dscy;") - 1UL, {1109, -1}}, 
        {"dsol;", sizeof("dsol;") - 1UL, {10742, -1}}, 
        {"dstrok;", sizeof("dstrok;") - 1UL, {273, -1}}, 
        {"dtdot;", sizeof("dtdot;") - 1UL, {8945, -1}}, 
        {"dtri;", sizeof("dtri;") - 1UL, {9663, -1}}, 
        {"dtrif;", sizeof("dtrif;") - 1UL, {9662, -1}}, 
        {"duarr;", sizeof("duarr;") - 1UL, {8693, -1}}, 
        {"duhar;", sizeof("duhar;") - 1UL, {10607, -1}}, 
        {"dwangle;", sizeof("dwangle;") - 1UL, {10662, -1}}, 
        {"dzcy;", sizeof("dzcy;") - 1UL, {1119, -1}}, 
        {"dzigrarr;", sizeof("dzigrarr;") - 1UL, {10239, -1}}, 
        {"eDDot;", sizeof("eDDot;") - 1UL, {10871, -1}}, 
        {"eDot;", sizeof("eDot;") - 1UL, {8785, -1}}, 
        {"eacute;", sizeof("eacute;") - 1UL, {233, -1}}, 
        {"eacute", sizeof("eacute") - 1UL, {233, -1}}, 
        {"easter;", sizeof("easter;") - 1UL, {10862, -1}}, 
        {"ecaron;", sizeof("ecaron;") - 1UL, {283, -1}}, 
        {"ecir;", sizeof("ecir;") - 1UL, {8790, -1}}, 
        {"ecirc;", sizeof("ecirc;") - 1UL, {234, -1}}, 
        {"ecirc", sizeof("ecirc") - 1UL, {234, -1}}, 
        {"ecolon;", sizeof("ecolon;") - 1UL, {8789, -1}}, 
        {"ecy;", sizeof("ecy;") - 1UL, {1101, -1}}, 
        {"edot;", sizeof("edot;") - 1UL, {279, -1}}, 
        {"ee;", sizeof("ee;") - 1UL, {8519, -1}}, 
        {"efDot;", sizeof("efDot;") - 1UL, {8786, -1}}, 
        {"efr;", sizeof("efr;") - 1UL, {120098, -1}}, 
        {"eg;", sizeof("eg;") - 1UL, {10906, -1}}, 
        {"egrave;", sizeof("egrave;") - 1UL, {232, -1}}, 
        {"egrave", sizeof("egrave") - 1UL, {232, -1}}, 
        {"egs;", sizeof("egs;") - 1UL, {10902, -1}}, 
        {"egsdot;", sizeof("egsdot;") - 1UL, {10904, -1}}, 
        {"el;", sizeof("el;") - 1UL, {10905, -1}}, 
        {"elinters;", sizeof("elinters;") - 1UL, {9191, -1}}, 
        {"ell;", sizeof("ell;") - 1UL, {8467, -1}}, 
        {"els;", sizeof("els;") - 1UL, {10901, -1}}, 
        {"elsdot;", sizeof("elsdot;") - 1UL, {10903, -1}}, 
        {"emacr;", sizeof("emacr;") - 1UL, {275, -1}}, 
        {"empty;", sizeof("empty;") - 1UL, {8709, -1}}, 
        {"emptyset;", sizeof("emptyset;") - 1UL, {8709, -1}}, 
        {"emptyv;", sizeof("emptyv;") - 1UL, {8709, -1}}, 
        {"emsp13;", sizeof("emsp13;") - 1UL, {8196, -1}}, 
        {"emsp14;", sizeof("emsp14;") - 1UL, {8197, -1}}, 
        {"emsp;", sizeof("emsp;") - 1UL, {8195, -1}}, 
        {"eng;", sizeof("eng;") - 1UL, {331, -1}}, 
        {"ensp;", sizeof("ensp;") - 1UL, {8194, -1}}, 
        {"eogon;", sizeof("eogon;") - 1UL, {281, -1}}, 
        {"eopf;", sizeof("eopf;") - 1UL, {120150, -1}}, 
        {"epar;", sizeof("epar;") - 1UL, {8917, -1}}, 
        {"eparsl;", sizeof("eparsl;") - 1UL, {10723, -1}}, 
        {"eplus;", sizeof("eplus;") - 1UL, {10865, -1}}, 
        {"epsi;", sizeof("epsi;") - 1UL, {949, -1}}, 
        {"epsilon;", sizeof("epsilon;") - 1UL, {949, -1}}, 
        {"epsiv;", sizeof("epsiv;") - 1UL, {1013, -1}}, 
        {"eqcirc;", sizeof("eqcirc;") - 1UL, {8790, -1}}, 
        {"eqcolon;", sizeof("eqcolon;") - 1UL, {8789, -1}}, 
        {"eqsim;", sizeof("eqsim;") - 1UL, {8770, -1}}, 
        {"eqslantgtr;", sizeof("eqslantgtr;") - 1UL, {10902, -1}}, 
        {"eqslantless;", sizeof("eqslantless;") - 1UL, {10901, -1}}, 
        {"equals;", sizeof("equals;") - 1UL, {61, -1}}, 
        {"equest;", sizeof("equest;") - 1UL, {8799, -1}}, 
        {"equiv;", sizeof("equiv;") - 1UL, {8801, -1}}, 
        {"equivDD;", sizeof("equivDD;") - 1UL, {10872, -1}}, 
        {"eqvparsl;", sizeof("eqvparsl;") - 1UL, {10725, -1}}, 
        {"erDot;", sizeof("erDot;") - 1UL, {8787, -1}}, 
        {"erarr;", sizeof("erarr;") - 1UL, {10609, -1}}, 
        {"escr;", sizeof("escr;") - 1UL, {8495, -1}}, 
        {"esdot;", sizeof("esdot;") - 1UL, {8784, -1}}, 
        {"esim;", sizeof("esim;") - 1UL, {8770, -1}}, 
        {"eta;", sizeof("eta;") - 1UL, {951, -1}}, 
        {"eth;", sizeof("eth;") - 1UL, {240, -1}}, 
        {"eth", sizeof("eth") - 1UL, {240, -1}}, 
        {"euml;", sizeof("euml;") - 1UL, {235, -1}}, 
        {"euml", sizeof("euml") - 1UL, {235, -1}}, 
        {"euro;", sizeof("euro;") - 1UL, {8364, -1}}, 
        {"excl;", sizeof("excl;") - 1UL, {33, -1}}, 
        {"exist;", sizeof("exist;") - 1UL, {8707, -1}}, 
        {"expectation;", sizeof("expectation;") - 1UL, {8496, -1}}, 
        {"exponentiale;", sizeof("exponentiale;") - 1UL, {8519, -1}}, 
        {"fallingdotseq;", sizeof("fallingdotseq;") - 1UL, {8786, -1}}, 
        {"fcy;", sizeof("fcy;") - 1UL, {1092, -1}}, 
        {"female;", sizeof("female;") - 1UL, {9792, -1}}, 
        {"ffilig;", sizeof("ffilig;") - 1UL, {64259, -1}}, 
        {"fflig;", sizeof("fflig;") - 1UL, {64256, -1}}, 
        {"ffllig;", sizeof("ffllig;") - 1UL, {64260, -1}}, 
        {"ffr;", sizeof("ffr;") - 1UL, {120099, -1}}, 
        {"filig;", sizeof("filig;") - 1UL, {64257, -1}}, 
        {"fjlig;", sizeof("fjlig;") - 1UL, {102, 106}}, 
        {"flat;", sizeof("flat;") - 1UL, {9837, -1}}, 
        {"fllig;", sizeof("fllig;") - 1UL, {64258, -1}}, 
        {"fltns;", sizeof("fltns;") - 1UL, {9649, -1}}, 
        {"fnof;", sizeof("fnof;") - 1UL, {402, -1}}, 
        {"fopf;", sizeof("fopf;") - 1UL, {120151, -1}}, 
        {"forall;", sizeof("forall;") - 1UL, {8704, -1}}, 
        {"fork;", sizeof("fork;") - 1UL, {8916, -1}}, 
        {"forkv;", sizeof("forkv;") - 1UL, {10969, -1}}, 
        {"fpartint;", sizeof("fpartint;") - 1UL, {10765, -1}}, 
        {"frac12", sizeof("frac12") - 1UL, {189, -1}}, 
        {"frac12;", sizeof("frac12;") - 1UL, {189, -1}}, 
        {"frac13;", sizeof("frac13;") - 1UL, {8531, -1}}, 
        {"frac14", sizeof("frac14") - 1UL, {188, -1}}, 
        {"frac14;", sizeof("frac14;") - 1UL, {188, -1}}, 
        {"frac15;", sizeof("frac15;") - 1UL, {8533, -1}}, 
        {"frac16;", sizeof("frac16;") - 1UL, {8537, -1}}, 
        {"frac18;", sizeof("frac18;") - 1UL, {8539, -1}}, 
        {"frac23;", sizeof("frac23;") - 1UL, {8532, -1}}, 
        {"frac25;", sizeof("frac25;") - 1UL, {8534, -1}}, 
        {"frac34", sizeof("frac34") - 1UL, {190, -1}}, 
        {"frac34;", sizeof("frac34;") - 1UL, {190, -1}}, 
        {"frac35;", sizeof("frac35;") - 1UL, {8535, -1}}, 
        {"frac38;", sizeof("frac38;") - 1UL, {8540, -1}}, 
        {"frac45;", sizeof("frac45;") - 1UL, {8536, -1}}, 
        {"frac56;", sizeof("frac56;") - 1UL, {8538, -1}}, 
        {"frac58;", sizeof("frac58;") - 1UL, {8541, -1}}, 
        {"frac78;", sizeof("frac78;") - 1UL, {8542, -1}}, 
        {"frasl;", sizeof("frasl;") - 1UL, {8260, -1}}, 
        {"frown;", sizeof("frown;") - 1UL, {8994, -1}}, 
        {"fscr;", sizeof("fscr;") - 1UL, {119995, -1}}, 
        {"gE;", sizeof("gE;") - 1UL, {8807, -1}}, 
        {"gEl;", sizeof("gEl;") - 1UL, {10892, -1}}, 
        {"gacute;", sizeof("gacute;") - 1UL, {501, -1}}, 
        {"gamma;", sizeof("gamma;") - 1UL, {947, -1}}, 
        {"gammad;", sizeof("gammad;") - 1UL, {989, -1}}, 
        {"gap;", sizeof("gap;") - 1UL, {10886, -1}}, 
        {"gbreve;", sizeof("gbreve;") - 1UL, {287, -1}}, 
        {"gcirc;", sizeof("gcirc;") - 1UL, {285, -1}}, 
        {"gcy;", sizeof("gcy;") - 1UL, {1075, -1}}, 
        {"gdot;", sizeof("gdot;") - 1UL, {289, -1}}, 
        {"ge;", sizeof("ge;") - 1UL, {8805, -1}}, 
        {"gel;", sizeof("gel;") - 1UL, {8923, -1}}, 
        {"geq;", sizeof("geq;") - 1UL, {8805, -1}}, 
        {"geqq;", sizeof("geqq;") - 1UL, {8807, -1}}, 
        {"geqslant;", sizeof("geqslant;") - 1UL, {10878, -1}}, 
        {"ges;", sizeof("ges;") - 1UL, {10878, -1}}, 
        {"gescc;", sizeof("gescc;") - 1UL, {10921, -1}}, 
        {"gesdot;", sizeof("gesdot;") - 1UL, {10880, -1}}, 
        {"gesdoto;", sizeof("gesdoto;") - 1UL, {10882, -1}}, 
        {"gesdotol;", sizeof("gesdotol;") - 1UL, {10884, -1}}, 
        {"gesl;", sizeof("gesl;") - 1UL, {8923, 65024}}, 
        {"gesles;", sizeof("gesles;") - 1UL, {10900, -1}}, 
        {"gfr;", sizeof("gfr;") - 1UL, {120100, -1}}, 
        {"gg;", sizeof("gg;") - 1UL, {8811, -1}}, 
        {"ggg;", sizeof("ggg;") - 1UL, {8921, -1}}, 
        {"gimel;", sizeof("gimel;") - 1UL, {8503, -1}}, 
        {"gjcy;", sizeof("gjcy;") - 1UL, {1107, -1}}, 
        {"gl;", sizeof("gl;") - 1UL, {8823, -1}}, 
        {"glE;", sizeof("glE;") - 1UL, {10898, -1}}, 
        {"gla;", sizeof("gla;") - 1UL, {10917, -1}}, 
        {"glj;", sizeof("glj;") - 1UL, {10916, -1}}, 
        {"gnE;", sizeof("gnE;") - 1UL, {8809, -1}}, 
        {"gnap;", sizeof("gnap;") - 1UL, {10890, -1}}, 
        {"gnapprox;", sizeof("gnapprox;") - 1UL, {10890, -1}}, 
        {"gne;", sizeof("gne;") - 1UL, {10888, -1}}, 
        {"gneq;", sizeof("gneq;") - 1UL, {10888, -1}}, 
        {"gneqq;", sizeof("gneqq;") - 1UL, {8809, -1}}, 
        {"gnsim;", sizeof("gnsim;") - 1UL, {8935, -1}}, 
        {"gopf;", sizeof("gopf;") - 1UL, {120152, -1}}, 
        {"grave;", sizeof("grave;") - 1UL, {96, -1}}, 
        {"gscr;", sizeof("gscr;") - 1UL, {8458, -1}}, 
        {"gsim;", sizeof("gsim;") - 1UL, {8819, -1}}, 
        {"gsime;", sizeof("gsime;") - 1UL, {10894, -1}}, 
        {"gsiml;", sizeof("gsiml;") - 1UL, {10896, -1}}, 
        {"gt;", sizeof("gt;") - 1UL, {62, -1}}, 
        {"gt", sizeof("gt") - 1UL, {62, -1}}, 
        {"gtcc;", sizeof("gtcc;") - 1UL, {10919, -1}}, 
        {"gtcir;", sizeof("gtcir;") - 1UL, {10874, -1}}, 
        {"gtdot;", sizeof("gtdot;") - 1UL, {8919, -1}}, 
        {"gtlPar;", sizeof("gtlPar;") - 1UL, {10645, -1}}, 
        {"gtquest;", sizeof("gtquest;") - 1UL, {10876, -1}}, 
        {"gtrapprox;", sizeof("gtrapprox;") - 1UL, {10886, -1}}, 
        {"gtrarr;", sizeof("gtrarr;") - 1UL, {10616, -1}}, 
        {"gtrdot;", sizeof("gtrdot;") - 1UL, {8919, -1}}, 
        {"gtreqless;", sizeof("gtreqless;") - 1UL, {8923, -1}}, 
        {"gtreqqless;", sizeof("gtreqqless;") - 1UL, {10892, -1}}, 
        {"gtrless;", sizeof("gtrless;") - 1UL, {8823, -1}}, 
        {"gtrsim;", sizeof("gtrsim;") - 1UL, {8819, -1}}, 
        {"gvertneqq;", sizeof("gvertneqq;") - 1UL, {8809, 65024}}, 
        {"gvnE;", sizeof("gvnE;") - 1UL, {8809, 65024}}, 
        {"hArr;", sizeof("hArr;") - 1UL, {8660, -1}}, 
        {"hairsp;", sizeof("hairsp;") - 1UL, {8202, -1}}, 
        {"half;", sizeof("half;") - 1UL, {189, -1}}, 
        {"hamilt;", sizeof("hamilt;") - 1UL, {8459, -1}}, 
        {"hardcy;", sizeof("hardcy;") - 1UL, {1098, -1}}, 
        {"harr;", sizeof("harr;") - 1UL, {8596, -1}}, 
        {"harrcir;", sizeof("harrcir;") - 1UL, {10568, -1}}, 
        {"harrw;", sizeof("harrw;") - 1UL, {8621, -1}}, 
        {"hbar;", sizeof("hbar;") - 1UL, {8463, -1}}, 
        {"hcirc;", sizeof("hcirc;") - 1UL, {293, -1}}, 
        {"hearts;", sizeof("hearts;") - 1UL, {9829, -1}}, 
        {"heartsuit;", sizeof("heartsuit;") - 1UL, {9829, -1}}, 
        {"hellip;", sizeof("hellip;") - 1UL, {8230, -1}}, 
        {"hercon;", sizeof("hercon;") - 1UL, {8889, -1}}, 
        {"hfr;", sizeof("hfr;") - 1UL, {120101, -1}}, 
        {"hksearow;", sizeof("hksearow;") - 1UL, {10533, -1}}, 
        {"hkswarow;", sizeof("hkswarow;") - 1UL, {10534, -1}}, 
        {"hoarr;", sizeof("hoarr;") - 1UL, {8703, -1}}, 
        {"homtht;", sizeof("homtht;") - 1UL, {8763, -1}}, 
        {"hookleftarrow;", sizeof("hookleftarrow;") - 1UL, {8617, -1}}, 
        {"hookrightarrow;", sizeof("hookrightarrow;") - 1UL, {8618, -1}}, 
        {"hopf;", sizeof("hopf;") - 1UL, {120153, -1}}, 
        {"horbar;", sizeof("horbar;") - 1UL, {8213, -1}}, 
        {"hscr;", sizeof("hscr;") - 1UL, {119997, -1}}, 
        {"hslash;", sizeof("hslash;") - 1UL, {8463, -1}}, 
        {"hstrok;", sizeof("hstrok;") - 1UL, {295, -1}}, 
        {"hybull;", sizeof("hybull;") - 1UL, {8259, -1}}, 
        {"hyphen;", sizeof("hyphen;") - 1UL, {8208, -1}}, 
        {"iacute;", sizeof("iacute;") - 1UL, {237, -1}}, 
        {"iacute", sizeof("iacute") - 1UL, {237, -1}}, 
        {"ic;", sizeof("ic;") - 1UL, {8291, -1}}, 
        {"icirc;", sizeof("icirc;") - 1UL, {238, -1}}, 
        {"icirc", sizeof("icirc") - 1UL, {238, -1}}, 
        {"icy;", sizeof("icy;") - 1UL, {1080, -1}}, 
        {"iecy;", sizeof("iecy;") - 1UL, {1077, -1}}, 
        {"iexcl;", sizeof("iexcl;") - 1UL, {161, -1}}, 
        {"iexcl", sizeof("iexcl") - 1UL, {161, -1}}, 
        {"iff;", sizeof("iff;") - 1UL, {8660, -1}}, 
        {"ifr;", sizeof("ifr;") - 1UL, {120102, -1}}, 
        {"igrave;", sizeof("igrave;") - 1UL, {236, -1}}, 
        {"igrave", sizeof("igrave") - 1UL, {236, -1}}, 
        {"ii;", sizeof("ii;") - 1UL, {8520, -1}}, 
        {"iiiint;", sizeof("iiiint;") - 1UL, {10764, -1}}, 
        {"iiint;", sizeof("iiint;") - 1UL, {8749, -1}}, 
        {"iinfin;", sizeof("iinfin;") - 1UL, {10716, -1}}, 
        {"iiota;", sizeof("iiota;") - 1UL, {8489, -1}}, 
        {"ijlig;", sizeof("ijlig;") - 1UL, {307, -1}}, 
        {"imacr;", sizeof("imacr;") - 1UL, {299, -1}}, 
        {"image;", sizeof("image;") - 1UL, {8465, -1}}, 
        {"imagline;", sizeof("imagline;") - 1UL, {8464, -1}}, 
        {"imagpart;", sizeof("imagpart;") - 1UL, {8465, -1}}, 
        {"imath;", sizeof("imath;") - 1UL, {305, -1}}, 
        {"imof;", sizeof("imof;") - 1UL, {8887, -1}}, 
        {"imped;", sizeof("imped;") - 1UL, {437, -1}}, 
        {"in;", sizeof("in;") - 1UL, {8712, -1}}, 
        {"incare;", sizeof("incare;") - 1UL, {8453, -1}}, 
        {"infin;", sizeof("infin;") - 1UL, {8734, -1}}, 
        {"infintie;", sizeof("infintie;") - 1UL, {10717, -1}}, 
        {"inodot;", sizeof("inodot;") - 1UL, {305, -1}}, 
        {"int;", sizeof("int;") - 1UL, {8747, -1}}, 
        {"intcal;", sizeof("intcal;") - 1UL, {8890, -1}}, 
        {"integers;", sizeof("integers;") - 1UL, {8484, -1}}, 
        {"intercal;", sizeof("intercal;") - 1UL, {8890, -1}}, 
        {"intlarhk;", sizeof("intlarhk;") - 1UL, {10775, -1}}, 
        {"intprod;", sizeof("intprod;") - 1UL, {10812, -1}}, 
        {"iocy;", sizeof("iocy;") - 1UL, {1105, -1}}, 
        {"iogon;", sizeof("iogon;") - 1UL, {303, -1}}, 
        {"iopf;", sizeof("iopf;") - 1UL, {120154, -1}}, 
        {"iota;", sizeof("iota;") - 1UL, {953, -1}}, 
        {"iprod;", sizeof("iprod;") - 1UL, {10812, -1}}, 
        {"iquest;", sizeof("iquest;") - 1UL, {191, -1}}, 
        {"iquest", sizeof("iquest") - 1UL, {191, -1}}, 
        {"iscr;", sizeof("iscr;") - 1UL, {119998, -1}}, 
        {"isin;", sizeof("isin;") - 1UL, {8712, -1}}, 
        {"isinE;", sizeof("isinE;") - 1UL, {8953, -1}}, 
        {"isindot;", sizeof("isindot;") - 1UL, {8949, -1}}, 
        {"isins;", sizeof("isins;") - 1UL, {8948, -1}}, 
        {"isinsv;", sizeof("isinsv;") - 1UL, {8947, -1}}, 
        {"isinv;", sizeof("isinv;") - 1UL, {8712, -1}}, 
        {"it;", sizeof("it;") - 1UL, {8290, -1}}, 
        {"itilde;", sizeof("itilde;") - 1UL, {297, -1}}, 
        {"iukcy;", sizeof("iukcy;") - 1UL, {1110, -1}}, 
        {"iuml;", sizeof("iuml;") - 1UL, {239, -1}}, 
        {"iuml", sizeof("iuml") - 1UL, {239, -1}}, 
        {"jcirc;", sizeof("jcirc;") - 1UL, {309, -1}}, 
        {"jcy;", sizeof("jcy;") - 1UL, {1081, -1}}, 
        {"jfr;", sizeof("jfr;") - 1UL, {120103, -1}}, 
        {"jmath;", sizeof("jmath;") - 1UL, {567, -1}}, 
        {"jopf;", sizeof("jopf;") - 1UL, {120155, -1}}, 
        {"jscr;", sizeof("jscr;") - 1UL, {119999, -1}}, 
        {"jsercy;", sizeof("jsercy;") - 1UL, {1112, -1}}, 
        {"jukcy;", sizeof("jukcy;") - 1UL, {1108, -1}}, 
        {"kappa;", sizeof("kappa;") - 1UL, {954, -1}}, 
        {"kappav;", sizeof("kappav;") - 1UL, {1008, -1}}, 
        {"kcedil;", sizeof("kcedil;") - 1UL, {311, -1}}, 
        {"kcy;", sizeof("kcy;") - 1UL, {1082, -1}}, 
        {"kfr;", sizeof("kfr;") - 1UL, {120104, -1}}, 
        {"kgreen;", sizeof("kgreen;") - 1UL, {312, -1}}, 
        {"khcy;", sizeof("khcy;") - 1UL, {1093, -1}}, 
        {"kjcy;", sizeof("kjcy;") - 1UL, {1116, -1}}, 
        {"kopf;", sizeof("kopf;") - 1UL, {120156, -1}}, 
        {"kscr;", sizeof("kscr;") - 1UL, {120000, -1}}, 
        {"lAarr;", sizeof("lAarr;") - 1UL, {8666, -1}}, 
        {"lArr;", sizeof("lArr;") - 1UL, {8656, -1}}, 
        {"lAtail;", sizeof("lAtail;") - 1UL, {10523, -1}}, 
        {"lBarr;", sizeof("lBarr;") - 1UL, {10510, -1}}, 
        {"lE;", sizeof("lE;") - 1UL, {8806, -1}}, 
        {"lEg;", sizeof("lEg;") - 1UL, {10891, -1}}, 
        {"lHar;", sizeof("lHar;") - 1UL, {10594, -1}}, 
        {"lacute;", sizeof("lacute;") - 1UL, {314, -1}}, 
        {"laemptyv;", sizeof("laemptyv;") - 1UL, {10676, -1}}, 
        {"lagran;", sizeof("lagran;") - 1UL, {8466, -1}}, 
        {"lambda;", sizeof("lambda;") - 1UL, {955, -1}}, 
        {"lang;", sizeof("lang;") - 1UL, {10216, -1}}, 
        {"langd;", sizeof("langd;") - 1UL, {10641, -1}}, 
        {"langle;", sizeof("langle;") - 1UL, {10216, -1}}, 
        {"lap;", sizeof("lap;") - 1UL, {10885, -1}}, 
        {"laquo;", sizeof("laquo;") - 1UL, {171, -1}}, 
        {"laquo", sizeof("laquo") - 1UL, {171, -1}}, 
        {"larr;", sizeof("larr;") - 1UL, {8592, -1}}, 
        {"larrb;", sizeof("larrb;") - 1UL, {8676, -1}}, 
        {"larrbfs;", sizeof("larrbfs;") - 1UL, {10527, -1}}, 
        {"larrfs;", sizeof("larrfs;") - 1UL, {10525, -1}}, 
        {"larrhk;", sizeof("larrhk;") - 1UL, {8617, -1}}, 
        {"larrlp;", sizeof("larrlp;") - 1UL, {8619, -1}}, 
        {"larrpl;", sizeof("larrpl;") - 1UL, {10553, -1}}, 
        {"larrsim;", sizeof("larrsim;") - 1UL, {10611, -1}}, 
        {"larrtl;", sizeof("larrtl;") - 1UL, {8610, -1}}, 
        {"lat;", sizeof("lat;") - 1UL, {10923, -1}}, 
        {"latail;", sizeof("latail;") - 1UL, {10521, -1}}, 
        {"late;", sizeof("late;") - 1UL, {10925, -1}}, 
        {"lates;", sizeof("lates;") - 1UL, {10925, 65024}}, 
        {"lbarr;", sizeof("lbarr;") - 1UL, {10508, -1}}, 
        {"lbbrk;", sizeof("lbbrk;") - 1UL, {10098, -1}}, 
        {"lbrace;", sizeof("lbrace;") - 1UL, {123, -1}}, 
        {"lbrack;", sizeof("lbrack;") - 1UL, {91, -1}}, 
        {"lbrke;", sizeof("lbrke;") - 1UL, {10635, -1}}, 
        {"lbrksld;", sizeof("lbrksld;") - 1UL, {10639, -1}}, 
        {"lbrkslu;", sizeof("lbrkslu;") - 1UL, {10637, -1}}, 
        {"lcaron;", sizeof("lcaron;") - 1UL, {318, -1}}, 
        {"lcedil;", sizeof("lcedil;") - 1UL, {316, -1}}, 
        {"lceil;", sizeof("lceil;") - 1UL, {8968, -1}}, 
        {"lcub;", sizeof("lcub;") - 1UL, {123, -1}}, 
        {"lcy;", sizeof("lcy;") - 1UL, {1083, -1}}, 
        {"ldca;", sizeof("ldca;") - 1UL, {10550, -1}}, 
        {"ldquo;", sizeof("ldquo;") - 1UL, {8220, -1}}, 
        {"ldquor;", sizeof("ldquor;") - 1UL, {8222, -1}}, 
        {"ldrdhar;", sizeof("ldrdhar;") - 1UL, {10599, -1}}, 
        {"ldrushar;", sizeof("ldrushar;") - 1UL, {10571, -1}}, 
        {"ldsh;", sizeof("ldsh;") - 1UL, {8626, -1}}, 
        {"le;", sizeof("le;") - 1UL, {8804, -1}}, 
        {"leftarrow;", sizeof("leftarrow;") - 1UL, {8592, -1}}, 
        {"leftarrowtail;", sizeof("leftarrowtail;") - 1UL, {8610, -1}}, 
        {"leftharpoondown;", sizeof("leftharpoondown;") - 1UL, {8637, -1}}, 
        {"leftharpoonup;", sizeof("leftharpoonup;") - 1UL, {8636, -1}}, 
        {"leftleftarrows;", sizeof("leftleftarrows;") - 1UL, {8647, -1}}, 
        {"leftrightarrow;", sizeof("leftrightarrow;") - 1UL, {8596, -1}}, 
        {"leftrightarrows;", sizeof("leftrightarrows;") - 1UL, {8646, -1}}, 
        {"leftrightharpoons;", sizeof("leftrightharpoons;") - 1UL, {8651, -1}}, 
        {"leftrightsquigarrow;", sizeof("leftrightsquigarrow;") - 1UL, {8621, -1}}, 
        {"leftthreetimes;", sizeof("leftthreetimes;") - 1UL, {8907, -1}}, 
        {"leg;", sizeof("leg;") - 1UL, {8922, -1}}, 
        {"leq;", sizeof("leq;") - 1UL, {8804, -1}}, 
        {"leqq;", sizeof("leqq;") - 1UL, {8806, -1}}, 
        {"leqslant;", sizeof("leqslant;") - 1UL, {10877, -1}}, 
        {"les;", sizeof("les;") - 1UL, {10877, -1}}, 
        {"lescc;", sizeof("lescc;") - 1UL, {10920, -1}}, 
        {"lesdot;", sizeof("lesdot;") - 1UL, {10879, -1}}, 
        {"lesdoto;", sizeof("lesdoto;") - 1UL, {10881, -1}}, 
        {"lesdotor;", sizeof("lesdotor;") - 1UL, {10883, -1}}, 
        {"lesg;", sizeof("lesg;") - 1UL, {8922, 65024}}, 
        {"lesges;", sizeof("lesges;") - 1UL, {10899, -1}}, 
        {"lessapprox;", sizeof("lessapprox;") - 1UL, {10885, -1}}, 
        {"lessdot;", sizeof("lessdot;") - 1UL, {8918, -1}}, 
        {"lesseqgtr;", sizeof("lesseqgtr;") - 1UL, {8922, -1}}, 
        {"lesseqqgtr;", sizeof("lesseqqgtr;") - 1UL, {10891, -1}}, 
        {"lessgtr;", sizeof("lessgtr;") - 1UL, {8822, -1}}, 
        {"lesssim;", sizeof("lesssim;") - 1UL, {8818, -1}}, 
        {"lfisht;", sizeof("lfisht;") - 1UL, {10620, -1}}, 
        {"lfloor;", sizeof("lfloor;") - 1UL, {8970, -1}}, 
        {"lfr;", sizeof("lfr;") - 1UL, {120105, -1}}, 
        {"lg;", sizeof("lg;") - 1UL, {8822, -1}}, 
        {"lgE;", sizeof("lgE;") - 1UL, {10897, -1}}, 
        {"lhard;", sizeof("lhard;") - 1UL, {8637, -1}}, 
        {"lharu;", sizeof("lharu;") - 1UL, {8636, -1}}, 
        {"lharul;", sizeof("lharul;") - 1UL, {10602, -1}}, 
        {"lhblk;", sizeof("lhblk;") - 1UL, {9604, -1}}, 
        {"ljcy;", sizeof("ljcy;") - 1UL, {1113, -1}}, 
        {"ll;", sizeof("ll;") - 1UL, {8810, -1}}, 
        {"llarr;", sizeof("llarr;") - 1UL, {8647, -1}}, 
        {"llcorner;", sizeof("llcorner;") - 1UL, {8990, -1}}, 
        {"llhard;", sizeof("llhard;") - 1UL, {10603, -1}}, 
        {"lltri;", sizeof("lltri;") - 1UL, {9722, -1}}, 
        {"lmidot;", sizeof("lmidot;") - 1UL, {320, -1}}, 
        {"lmoust;", sizeof("lmoust;") - 1UL, {9136, -1}}, 
        {"lmoustache;", sizeof("lmoustache;") - 1UL, {9136, -1}}, 
        {"lnE;", sizeof("lnE;") - 1UL, {8808, -1}}, 
        {"lnap;", sizeof("lnap;") - 1UL, {10889, -1}}, 
        {"lnapprox;", sizeof("lnapprox;") - 1UL, {10889, -1}}, 
        {"lne;", sizeof("lne;") - 1UL, {10887, -1}}, 
        {"lneq;", sizeof("lneq;") - 1UL, {10887, -1}}, 
        {"lneqq;", sizeof("lneqq;") - 1UL, {8808, -1}}, 
        {"lnsim;", sizeof("lnsim;") - 1UL, {8934, -1}}, 
        {"loang;", sizeof("loang;") - 1UL, {10220, -1}}, 
        {"loarr;", sizeof("loarr;") - 1UL, {8701, -1}}, 
        {"lobrk;", sizeof("lobrk;") - 1UL, {10214, -1}}, 
        {"longleftarrow;", sizeof("longleftarrow;") - 1UL, {10229, -1}}, 
        {"longleftrightarrow;", sizeof("longleftrightarrow;") - 1UL, {10231, -1}}, 
        {"longmapsto;", sizeof("longmapsto;") - 1UL, {10236, -1}}, 
        {"longrightarrow;", sizeof("longrightarrow;") - 1UL, {10230, -1}}, 
        {"looparrowleft;", sizeof("looparrowleft;") - 1UL, {8619, -1}}, 
        {"looparrowright;", sizeof("looparrowright;") - 1UL, {8620, -1}}, 
        {"lopar;", sizeof("lopar;") - 1UL, {10629, -1}}, 
        {"lopf;", sizeof("lopf;") - 1UL, {120157, -1}}, 
        {"loplus;", sizeof("loplus;") - 1UL, {10797, -1}}, 
        {"lotimes;", sizeof("lotimes;") - 1UL, {10804, -1}}, 
        {"lowast;", sizeof("lowast;") - 1UL, {8727, -1}}, 
        {"lowbar;", sizeof("lowbar;") - 1UL, {95, -1}}, 
        {"loz;", sizeof("loz;") - 1UL, {9674, -1}}, 
        {"lozenge;", sizeof("lozenge;") - 1UL, {9674, -1}}, 
        {"lozf;", sizeof("lozf;") - 1UL, {10731, -1}}, 
        {"lpar;", sizeof("lpar;") - 1UL, {40, -1}}, 
        {"lparlt;", sizeof("lparlt;") - 1UL, {10643, -1}}, 
        {"lrarr;", sizeof("lrarr;") - 1UL, {8646, -1}}, 
        {"lrcorner;", sizeof("lrcorner;") - 1UL, {8991, -1}}, 
        {"lrhar;", sizeof("lrhar;") - 1UL, {8651, -1}}, 
        {"lrhard;", sizeof("lrhard;") - 1UL, {10605, -1}}, 
        {"lrm;", sizeof("lrm;") - 1UL, {8206, -1}}, 
        {"lrtri;", sizeof("lrtri;") - 1UL, {8895, -1}}, 
        {"lsaquo;", sizeof("lsaquo;") - 1UL, {8249, -1}}, 
        {"lscr;", sizeof("lscr;") - 1UL, {120001, -1}}, 
        {"lsh;", sizeof("lsh;") - 1UL, {8624, -1}}, 
        {"lsim;", sizeof("lsim;") - 1UL, {8818, -1}}, 
        {"lsime;", sizeof("lsime;") - 1UL, {10893, -1}}, 
        {"lsimg;", sizeof("lsimg;") - 1UL, {10895, -1}}, 
        {"lsqb;", sizeof("lsqb;") - 1UL, {91, -1}}, 
        {"lsquo;", sizeof("lsquo;") - 1UL, {8216, -1}}, 
        {"lsquor;", sizeof("lsquor;") - 1UL, {8218, -1}}, 
        {"lstrok;", sizeof("lstrok;") - 1UL, {322, -1}}, 
        {"lt;", sizeof("lt;") - 1UL, {60, -1}}, 
        {"lt", sizeof("lt") - 1UL, {60, -1}}, 
        {"ltcc;", sizeof("ltcc;") - 1UL, {10918, -1}}, 
        {"ltcir;", sizeof("ltcir;") - 1UL, {10873, -1}}, 
        {"ltdot;", sizeof("ltdot;") - 1UL, {8918, -1}}, 
        {"lthree;", sizeof("lthree;") - 1UL, {8907, -1}}, 
        {"ltimes;", sizeof("ltimes;") - 1UL, {8905, -1}}, 
        {"ltlarr;", sizeof("ltlarr;") - 1UL, {10614, -1}}, 
        {"ltquest;", sizeof("ltquest;") - 1UL, {10875, -1}}, 
        {"ltrPar;", sizeof("ltrPar;") - 1UL, {10646, -1}}, 
        {"ltri;", sizeof("ltri;") - 1UL, {9667, -1}}, 
        {"ltrie;", sizeof("ltrie;") - 1UL, {8884, -1}}, 
        {"ltrif;", sizeof("ltrif;") - 1UL, {9666, -1}}, 
        {"lurdshar;", sizeof("lurdshar;") - 1UL, {10570, -1}}, 
        {"luruhar;", sizeof("luruhar;") - 1UL, {10598, -1}}, 
        {"lvertneqq;", sizeof("lvertneqq;") - 1UL, {8808, 65024}}, 
        {"lvnE;", sizeof("lvnE;") - 1UL, {8808, 65024}}, 
        {"mDDot;", sizeof("mDDot;") - 1UL, {8762, -1}}, 
        {"macr;", sizeof("macr;") - 1UL, {175, -1}}, 
        {"macr", sizeof("macr") - 1UL, {175, -1}}, 
        {"male;", sizeof("male;") - 1UL, {9794, -1}}, 
        {"malt;", sizeof("malt;") - 1UL, {10016, -1}}, 
        {"maltese;", sizeof("maltese;") - 1UL, {10016, -1}}, 
        {"map;", sizeof("map;") - 1UL, {8614, -1}}, 
        {"mapsto;", sizeof("mapsto;") - 1UL, {8614, -1}}, 
        {"mapstodown;", sizeof("mapstodown;") - 1UL, {8615, -1}}, 
        {"mapstoleft;", sizeof("mapstoleft;") - 1UL, {8612, -1}}, 
        {"mapstoup;", sizeof("mapstoup;") - 1UL, {8613, -1}}, 
        {"marker;", sizeof("marker;") - 1UL, {9646, -1}}, 
        {"mcomma;", sizeof("mcomma;") - 1UL, {10793, -1}}, 
        {"mcy;", sizeof("mcy;") - 1UL, {1084, -1}}, 
        {"mdash;", sizeof("mdash;") - 1UL, {8212, -1}}, 
        {"measuredangle;", sizeof("measuredangle;") - 1UL, {8737, -1}}, 
        {"mfr;", sizeof("mfr;") - 1UL, {120106, -1}}, 
        {"mho;", sizeof("mho;") - 1UL, {8487, -1}}, 
        {"micro;", sizeof("micro;") - 1UL, {181, -1}}, 
        {"micro", sizeof("micro") - 1UL, {181, -1}}, 
        {"mid;", sizeof("mid;") - 1UL, {8739, -1}}, 
        {"midast;", sizeof("midast;") - 1UL, {42, -1}}, 
        {"midcir;", sizeof("midcir;") - 1UL, {10992, -1}}, 
        {"middot;", sizeof("middot;") - 1UL, {183, -1}}, 
        {"middot", sizeof("middot") - 1UL, {183, -1}}, 
        {"minus;", sizeof("minus;") - 1UL, {8722, -1}}, 
        {"minusb;", sizeof("minusb;") - 1UL, {8863, -1}}, 
        {"minusd;", sizeof("minusd;") - 1UL, {8760, -1}}, 
        {"minusdu;", sizeof("minusdu;") - 1UL, {10794, -1}}, 
        {"mlcp;", sizeof("mlcp;") - 1UL, {10971, -1}}, 
        {"mldr;", sizeof("mldr;") - 1UL, {8230, -1}}, 
        {"mnplus;", sizeof("mnplus;") - 1UL, {8723, -1}}, 
        {"models;", sizeof("models;") - 1UL, {8871, -1}}, 
        {"mopf;", sizeof("mopf;") - 1UL, {120158, -1}}, 
        {"mp;", sizeof("mp;") - 1UL, {8723, -1}}, 
        {"mscr;", sizeof("mscr;") - 1UL, {120002, -1}}, 
        {"mstpos;", sizeof("mstpos;") - 1UL, {8766, -1}}, 
        {"mu;", sizeof("mu;") - 1UL, {956, -1}}, 
        {"multimap;", sizeof("multimap;") - 1UL, {8888, -1}}, 
        {"mumap;", sizeof("mumap;") - 1UL, {8888, -1}}, 
        {"nGg;", sizeof("nGg;") - 1UL, {8921, 824}}, 
        {"nGt;", sizeof("nGt;") - 1UL, {8811, 8402}}, 
        {"nGtv;", sizeof("nGtv;") - 1UL, {8811, 824}}, 
        {"nLeftarrow;", sizeof("nLeftarrow;") - 1UL, {8653, -1}}, 
        {"nLeftrightarrow;", sizeof("nLeftrightarrow;") - 1UL, {8654, -1}}, 
        {"nLl;", sizeof("nLl;") - 1UL, {8920, 824}}, 
        {"nLt;", sizeof("nLt;") - 1UL, {8810, 8402}}, 
        {"nLtv;", sizeof("nLtv;") - 1UL, {8810, 824}}, 
        {"nRightarrow;", sizeof("nRightarrow;") - 1UL, {8655, -1}}, 
        {"nVDash;", sizeof("nVDash;") - 1UL, {8879, -1}}, 
        {"nVdash;", sizeof("nVdash;") - 1UL, {8878, -1}}, 
        {"nabla;", sizeof("nabla;") - 1UL, {8711, -1}}, 
        {"nacute;", sizeof("nacute;") - 1UL, {324, -1}}, 
        {"nang;", sizeof("nang;") - 1UL, {8736, 8402}}, 
        {"nap;", sizeof("nap;") - 1UL, {8777, -1}}, 
        {"napE;", sizeof("napE;") - 1UL, {10864, 824}}, 
        {"napid;", sizeof("napid;") - 1UL, {8779, 824}}, 
        {"napos;", sizeof("napos;") - 1UL, {329, -1}}, 
        {"napprox;", sizeof("napprox;") - 1UL, {8777, -1}}, 
        {"natur;", sizeof("natur;") - 1UL, {9838, -1}}, 
        {"natural;", sizeof("natural;") - 1UL, {9838, -1}}, 
        {"naturals;", sizeof("naturals;") - 1UL, {8469, -1}}, 
        {"nbsp;", sizeof("nbsp;") - 1UL, {160, -1}}, 
        {"nbsp", sizeof("nbsp") - 1UL, {160, -1}}, 
        {"nbump;", sizeof("nbump;") - 1UL, {8782, 824}}, 
        {"nbumpe;", sizeof("nbumpe;") - 1UL, {8783, 824}}, 
        {"ncap;", sizeof("ncap;") - 1UL, {10819, -1}}, 
        {"ncaron;", sizeof("ncaron;") - 1UL, {328, -1}}, 
        {"ncedil;", sizeof("ncedil;") - 1UL, {326, -1}}, 
        {"ncong;", sizeof("ncong;") - 1UL, {8775, -1}}, 
        {"ncongdot;", sizeof("ncongdot;") - 1UL, {10861, 824}}, 
        {"ncup;", sizeof("ncup;") - 1UL, {10818, -1}}, 
        {"ncy;", sizeof("ncy;") - 1UL, {1085, -1}}, 
        {"ndash;", sizeof("ndash;") - 1UL, {8211, -1}}, 
        {"ne;", sizeof("ne;") - 1UL, {8800, -1}}, 
        {"neArr;", sizeof("neArr;") - 1UL, {8663, -1}}, 
        {"nearhk;", sizeof("nearhk;") - 1UL, {10532, -1}}, 
        {"nearr;", sizeof("nearr;") - 1UL, {8599, -1}}, 
        {"nearrow;", sizeof("nearrow;") - 1UL, {8599, -1}}, 
        {"nedot;", sizeof("nedot;") - 1UL, {8784, 824}}, 
        {"nequiv;", sizeof("nequiv;") - 1UL, {8802, -1}}, 
        {"nesear;", sizeof("nesear;") - 1UL, {10536, -1}}, 
        {"nesim;", sizeof("nesim;") - 1UL, {8770, 824}}, 
        {"nexist;", sizeof("nexist;") - 1UL, {8708, -1}}, 
        {"nexists;", sizeof("nexists;") - 1UL, {8708, -1}}, 
        {"nfr;", sizeof("nfr;") - 1UL, {120107, -1}}, 
        {"ngE;", sizeof("ngE;") - 1UL, {8807, 824}}, 
        {"nge;", sizeof("nge;") - 1UL, {8817, -1}}, 
        {"ngeq;", sizeof("ngeq;") - 1UL, {8817, -1}}, 
        {"ngeqq;", sizeof("ngeqq;") - 1UL, {8807, 824}}, 
        {"ngeqslant;", sizeof("ngeqslant;") - 1UL, {10878, 824}}, 
        {"nges;", sizeof("nges;") - 1UL, {10878, 824}}, 
        {"ngsim;", sizeof("ngsim;") - 1UL, {8821, -1}}, 
        {"ngt;", sizeof("ngt;") - 1UL, {8815, -1}}, 
        {"ngtr;", sizeof("ngtr;") - 1UL, {8815, -1}}, 
        {"nhArr;", sizeof("nhArr;") - 1UL, {8654, -1}}, 
        {"nharr;", sizeof("nharr;") - 1UL, {8622, -1}}, 
        {"nhpar;", sizeof("nhpar;") - 1UL, {10994, -1}}, 
        {"ni;", sizeof("ni;") - 1UL, {8715, -1}}, 
        {"nis;", sizeof("nis;") - 1UL, {8956, -1}}, 
        {"nisd;", sizeof("nisd;") - 1UL, {8954, -1}}, 
        {"niv;", sizeof("niv;") - 1UL, {8715, -1}}, 
        {"njcy;", sizeof("njcy;") - 1UL, {1114, -1}}, 
        {"nlArr;", sizeof("nlArr;") - 1UL, {8653, -1}}, 
        {"nlE;", sizeof("nlE;") - 1UL, {8806, 824}}, 
        {"nlarr;", sizeof("nlarr;") - 1UL, {8602, -1}}, 
        {"nldr;", sizeof("nldr;") - 1UL, {8229, -1}}, 
        {"nle;", sizeof("nle;") - 1UL, {8816, -1}}, 
        {"nleftarrow;", sizeof("nleftarrow;") - 1UL, {8602, -1}}, 
        {"nleftrightarrow;", sizeof("nleftrightarrow;") - 1UL, {8622, -1}}, 
        {"nleq;", sizeof("nleq;") - 1UL, {8816, -1}}, 
        {"nleqq;", sizeof("nleqq;") - 1UL, {8806, 824}}, 
        {"nleqslant;", sizeof("nleqslant;") - 1UL, {10877, 824}}, 
        {"nles;", sizeof("nles;") - 1UL, {10877, 824}}, 
        {"nless;", sizeof("nless;") - 1UL, {8814, -1}}, 
        {"nlsim;", sizeof("nlsim;") - 1UL, {8820, -1}}, 
        {"nlt;", sizeof("nlt;") - 1UL, {8814, -1}}, 
        {"nltri;", sizeof("nltri;") - 1UL, {8938, -1}}, 
        {"nltrie;", sizeof("nltrie;") - 1UL, {8940, -1}}, 
        {"nmid;", sizeof("nmid;") - 1UL, {8740, -1}}, 
        {"nopf;", sizeof("nopf;") - 1UL, {120159, -1}}, 
        {"not;", sizeof("not;") - 1UL, {172, -1}}, 
        {"notin;", sizeof("notin;") - 1UL, {8713, -1}}, 
        {"notinE;", sizeof("notinE;") - 1UL, {8953, 824}}, 
        {"notindot;", sizeof("notindot;") - 1UL, {8949, 824}}, 
        {"notinva;", sizeof("notinva;") - 1UL, {8713, -1}}, 
        {"notinvb;", sizeof("notinvb;") - 1UL, {8951, -1}}, 
        {"notinvc;", sizeof("notinvc;") - 1UL, {8950, -1}}, 
        {"notni;", sizeof("notni;") - 1UL, {8716, -1}}, 
        {"notniva;", sizeof("notniva;") - 1UL, {8716, -1}}, 
        {"notnivb;", sizeof("notnivb;") - 1UL, {8958, -1}}, 
        {"notnivc;", sizeof("notnivc;") - 1UL, {8957, -1}}, 
        {"not", sizeof("not") - 1UL, {172, -1}}, 
        {"npar;", sizeof("npar;") - 1UL, {8742, -1}}, 
        {"nparallel;", sizeof("nparallel;") - 1UL, {8742, -1}}, 
        {"nparsl;", sizeof("nparsl;") - 1UL, {11005, 8421}}, 
        {"npart;", sizeof("npart;") - 1UL, {8706, 824}}, 
        {"npolint;", sizeof("npolint;") - 1UL, {10772, -1}}, 
        {"npr;", sizeof("npr;") - 1UL, {8832, -1}}, 
        {"nprcue;", sizeof("nprcue;") - 1UL, {8928, -1}}, 
        {"npre;", sizeof("npre;") - 1UL, {10927, 824}}, 
        {"nprec;", sizeof("nprec;") - 1UL, {8832, -1}}, 
        {"npreceq;", sizeof("npreceq;") - 1UL, {10927, 824}}, 
        {"nrArr;", sizeof("nrArr;") - 1UL, {8655, -1}}, 
        {"nrarr;", sizeof("nrarr;") - 1UL, {8603, -1}}, 
        {"nrarrc;", sizeof("nrarrc;") - 1UL, {10547, 824}}, 
        {"nrarrw;", sizeof("nrarrw;") - 1UL, {8605, 824}}, 
        {"nrightarrow;", sizeof("nrightarrow;") - 1UL, {8603, -1}}, 
        {"nrtri;", sizeof("nrtri;") - 1UL, {8939, -1}}, 
        {"nrtrie;", sizeof("nrtrie;") - 1UL, {8941, -1}}, 
        {"nsc;", sizeof("nsc;") - 1UL, {8833, -1}}, 
        {"nsccue;", sizeof("nsccue;") - 1UL, {8929, -1}}, 
        {"nsce;", sizeof("nsce;") - 1UL, {10928, 824}}, 
        {"nscr;", sizeof("nscr;") - 1UL, {120003, -1}}, 
        {"nshortmid;", sizeof("nshortmid;") - 1UL, {8740, -1}}, 
        {"nshortparallel;", sizeof("nshortparallel;") - 1UL, {8742, -1}}, 
        {"nsim;", sizeof("nsim;") - 1UL, {8769, -1}}, 
        {"nsime;", sizeof("nsime;") - 1UL, {8772, -1}}, 
        {"nsimeq;", sizeof("nsimeq;") - 1UL, {8772, -1}}, 
        {"nsmid;", sizeof("nsmid;") - 1UL, {8740, -1}}, 
        {"nspar;", sizeof("nspar;") - 1UL, {8742, -1}}, 
        {"nsqsube;", sizeof("nsqsube;") - 1UL, {8930, -1}}, 
        {"nsqsupe;", sizeof("nsqsupe;") - 1UL, {8931, -1}}, 
        {"nsub;", sizeof("nsub;") - 1UL, {8836, -1}}, 
        {"nsubE;", sizeof("nsubE;") - 1UL, {10949, 824}}, 
        {"nsube;", sizeof("nsube;") - 1UL, {8840, -1}}, 
        {"nsubset;", sizeof("nsubset;") - 1UL, {8834, 8402}}, 
        {"nsubseteq;", sizeof("nsubseteq;") - 1UL, {8840, -1}}, 
        {"nsubseteqq;", sizeof("nsubseteqq;") - 1UL, {10949, 824}}, 
        {"nsucc;", sizeof("nsucc;") - 1UL, {8833, -1}}, 
        {"nsucceq;", sizeof("nsucceq;") - 1UL, {10928, 824}}, 
        {"nsup;", sizeof("nsup;") - 1UL, {8837, -1}}, 
        {"nsupE;", sizeof("nsupE;") - 1UL, {10950, 824}}, 
        {"nsupe;", sizeof("nsupe;") - 1UL, {8841, -1}}, 
        {"nsupset;", sizeof("nsupset;") - 1UL, {8835, 8402}}, 
        {"nsupseteq;", sizeof("nsupseteq;") - 1UL, {8841, -1}}, 
        {"nsupseteqq;", sizeof("nsupseteqq;") - 1UL, {10950, 824}}, 
        {"ntgl;", sizeof("ntgl;") - 1UL, {8825, -1}}, 
        {"ntilde;", sizeof("ntilde;") - 1UL, {241, -1}}, 
        {"ntilde", sizeof("ntilde") - 1UL, {241, -1}}, 
        {"ntlg;", sizeof("ntlg;") - 1UL, {8824, -1}}, 
        {"ntriangleleft;", sizeof("ntriangleleft;") - 1UL, {8938, -1}}, 
        {"ntrianglelefteq;", sizeof("ntrianglelefteq;") - 1UL, {8940, -1}}, 
        {"ntriangleright;", sizeof("ntriangleright;") - 1UL, {8939, -1}}, 
        {"ntrianglerighteq;", sizeof("ntrianglerighteq;") - 1UL, {8941, -1}}, 
        {"nu;", sizeof("nu;") - 1UL, {957, -1}}, 
        {"num;", sizeof("num;") - 1UL, {35, -1}}, 
        {"numero;", sizeof("numero;") - 1UL, {8470, -1}}, 
        {"numsp;", sizeof("numsp;") - 1UL, {8199, -1}}, 
        {"nvDash;", sizeof("nvDash;") - 1UL, {8877, -1}}, 
        {"nvHarr;", sizeof("nvHarr;") - 1UL, {10500, -1}}, 
        {"nvap;", sizeof("nvap;") - 1UL, {8781, 8402}}, 
        {"nvdash;", sizeof("nvdash;") - 1UL, {8876, -1}}, 
        {"nvge;", sizeof("nvge;") - 1UL, {8805, 8402}}, 
        {"nvgt;", sizeof("nvgt;") - 1UL, {62, 8402}}, 
        {"nvinfin;", sizeof("nvinfin;") - 1UL, {10718, -1}}, 
        {"nvlArr;", sizeof("nvlArr;") - 1UL, {10498, -1}}, 
        {"nvle;", sizeof("nvle;") - 1UL, {8804, 8402}}, 
        {"nvlt;", sizeof("nvlt;") - 1UL, {60, 8402}}, 
        {"nvltrie;", sizeof("nvltrie;") - 1UL, {8884, 8402}}, 
        {"nvrArr;", sizeof("nvrArr;") - 1UL, {10499, -1}}, 
        {"nvrtrie;", sizeof("nvrtrie;") - 1UL, {8885, 8402}}, 
        {"nvsim;", sizeof("nvsim;") - 1UL, {8764, 8402}}, 
        {"nwArr;", sizeof("nwArr;") - 1UL, {8662, -1}}, 
        {"nwarhk;", sizeof("nwarhk;") - 1UL, {10531, -1}}, 
        {"nwarr;", sizeof("nwarr;") - 1UL, {8598, -1}}, 
        {"nwarrow;", sizeof("nwarrow;") - 1UL, {8598, -1}}, 
        {"nwnear;", sizeof("nwnear;") - 1UL, {10535, -1}}, 
        {"oS;", sizeof("oS;") - 1UL, {9416, -1}}, 
        {"oacute;", sizeof("oacute;") - 1UL, {243, -1}}, 
        {"oacute", sizeof("oacute") - 1UL, {243, -1}}, 
        {"oast;", sizeof("oast;") - 1UL, {8859, -1}}, 
        {"ocir;", sizeof("ocir;") - 1UL, {8858, -1}}, 
        {"ocirc;", sizeof("ocirc;") - 1UL, {244, -1}}, 
        {"ocirc", sizeof("ocirc") - 1UL, {244, -1}}, 
        {"ocy;", sizeof("ocy;") - 1UL, {1086, -1}}, 
        {"odash;", sizeof("odash;") - 1UL, {8861, -1}}, 
        {"odblac;", sizeof("odblac;") - 1UL, {337, -1}}, 
        {"odiv;", sizeof("odiv;") - 1UL, {10808, -1}}, 
        {"odot;", sizeof("odot;") - 1UL, {8857, -1}}, 
        {"odsold;", sizeof("odsold;") - 1UL, {10684, -1}}, 
        {"oelig;", sizeof("oelig;") - 1UL, {339, -1}}, 
        {"ofcir;", sizeof("ofcir;") - 1UL, {10687, -1}}, 
        {"ofr;", sizeof("ofr;") - 1UL, {120108, -1}}, 
        {"ogon;", sizeof("ogon;") - 1UL, {731, -1}}, 
        {"ograve;", sizeof("ograve;") - 1UL, {242, -1}}, 
        {"ograve", sizeof("ograve") - 1UL, {242, -1}}, 
        {"ogt;", sizeof("ogt;") - 1UL, {10689, -1}}, 
        {"ohbar;", sizeof("ohbar;") - 1UL, {10677, -1}}, 
        {"ohm;", sizeof("ohm;") - 1UL, {937, -1}}, 
        {"oint;", sizeof("oint;") - 1UL, {8750, -1}}, 
        {"olarr;", sizeof("olarr;") - 1UL, {8634, -1}}, 
        {"olcir;", sizeof("olcir;") - 1UL, {10686, -1}}, 
        {"olcross;", sizeof("olcross;") - 1UL, {10683, -1}}, 
        {"oline;", sizeof("oline;") - 1UL, {8254, -1}}, 
        {"olt;", sizeof("olt;") - 1UL, {10688, -1}}, 
        {"omacr;", sizeof("omacr;") - 1UL, {333, -1}}, 
        {"omega;", sizeof("omega;") - 1UL, {969, -1}}, 
        {"omicron;", sizeof("omicron;") - 1UL, {959, -1}}, 
        {"omid;", sizeof("omid;") - 1UL, {10678, -1}}, 
        {"ominus;", sizeof("ominus;") - 1UL, {8854, -1}}, 
        {"oopf;", sizeof("oopf;") - 1UL, {120160, -1}}, 
        {"opar;", sizeof("opar;") - 1UL, {10679, -1}}, 
        {"operp;", sizeof("operp;") - 1UL, {10681, -1}}, 
        {"oplus;", sizeof("oplus;") - 1UL, {8853, -1}}, 
        {"or;", sizeof("or;") - 1UL, {8744, -1}}, 
        {"orarr;", sizeof("orarr;") - 1UL, {8635, -1}}, 
        {"ord;", sizeof("ord;") - 1UL, {10845, -1}}, 
        {"order;", sizeof("order;") - 1UL, {8500, -1}}, 
        {"orderof;", sizeof("orderof;") - 1UL, {8500, -1}}, 
        {"ordf;", sizeof("ordf;") - 1UL, {170, -1}}, 
        {"ordf", sizeof("ordf") - 1UL, {170, -1}}, 
        {"ordm;", sizeof("ordm;") - 1UL, {186, -1}}, 
        {"ordm", sizeof("ordm") - 1UL, {186, -1}}, 
        {"origof;", sizeof("origof;") - 1UL, {8886, -1}}, 
        {"oror;", sizeof("oror;") - 1UL, {10838, -1}}, 
        {"orslope;", sizeof("orslope;") - 1UL, {10839, -1}}, 
        {"orv;", sizeof("orv;") - 1UL, {10843, -1}}, 
        {"oscr;", sizeof("oscr;") - 1UL, {8500, -1}}, 
        {"oslash;", sizeof("oslash;") - 1UL, {248, -1}}, 
        {"oslash", sizeof("oslash") - 1UL, {248, -1}}, 
        {"osol;", sizeof("osol;") - 1UL, {8856, -1}}, 
        {"otilde;", sizeof("otilde;") - 1UL, {245, -1}}, 
        {"otilde", sizeof("otilde") - 1UL, {245, -1}}, 
        {"otimes;", sizeof("otimes;") - 1UL, {8855, -1}}, 
        {"otimesas;", sizeof("otimesas;") - 1UL, {10806, -1}}, 
        {"ouml;", sizeof("ouml;") - 1UL, {246, -1}}, 
        {"ouml", sizeof("ouml") - 1UL, {246, -1}}, 
        {"ovbar;", sizeof("ovbar;") - 1UL, {9021, -1}}, 
        {"par;", sizeof("par;") - 1UL, {8741, -1}}, 
        {"para;", sizeof("para;") - 1UL, {182, -1}}, 
        {"para", sizeof("para") - 1UL, {182, -1}}, 
        {"parallel;", sizeof("parallel;") - 1UL, {8741, -1}}, 
        {"parsim;", sizeof("parsim;") - 1UL, {10995, -1}}, 
        {"parsl;", sizeof("parsl;") - 1UL, {11005, -1}}, 
        {"part;", sizeof("part;") - 1UL, {8706, -1}}, 
        {"pcy;", sizeof("pcy;") - 1UL, {1087, -1}}, 
        {"percnt;", sizeof("percnt;") - 1UL, {37, -1}}, 
        {"period;", sizeof("period;") - 1UL, {46, -1}}, 
        {"permil;", sizeof("permil;") - 1UL, {8240, -1}}, 
        {"perp;", sizeof("perp;") - 1UL, {8869, -1}}, 
        {"pertenk;", sizeof("pertenk;") - 1UL, {8241, -1}}, 
        {"pfr;", sizeof("pfr;") - 1UL, {120109, -1}}, 
        {"phi;", sizeof("phi;") - 1UL, {966, -1}}, 
        {"phiv;", sizeof("phiv;") - 1UL, {981, -1}}, 
        {"phmmat;", sizeof("phmmat;") - 1UL, {8499, -1}}, 
        {"phone;", sizeof("phone;") - 1UL, {9742, -1}}, 
        {"pi;", sizeof("pi;") - 1UL, {960, -1}}, 
        {"pitchfork;", sizeof("pitchfork;") - 1UL, {8916, -1}}, 
        {"piv;", sizeof("piv;") - 1UL, {982, -1}}, 
        {"planck;", sizeof("planck;") - 1UL, {8463, -1}}, 
        {"planckh;", sizeof("planckh;") - 1UL, {8462, -1}}, 
        {"plankv;", sizeof("plankv;") - 1UL, {8463, -1}}, 
        {"plus;", sizeof("plus;") - 1UL, {43, -1}}, 
        {"plusacir;", sizeof("plusacir;") - 1UL, {10787, -1}}, 
        {"plusb;", sizeof("plusb;") - 1UL, {8862, -1}}, 
        {"pluscir;", sizeof("pluscir;") - 1UL, {10786, -1}}, 
        {"plusdo;", sizeof("plusdo;") - 1UL, {8724, -1}}, 
        {"plusdu;", sizeof("plusdu;") - 1UL, {10789, -1}}, 
        {"pluse;", sizeof("pluse;") - 1UL, {10866, -1}}, 
        {"plusmn;", sizeof("plusmn;") - 1UL, {177, -1}}, 
        {"plusmn", sizeof("plusmn") - 1UL, {177, -1}}, 
        {"plussim;", sizeof("plussim;") - 1UL, {10790, -1}}, 
        {"plustwo;", sizeof("plustwo;") - 1UL, {10791, -1}}, 
        {"pm;", sizeof("pm;") - 1UL, {177, -1}}, 
        {"pointint;", sizeof("pointint;") - 1UL, {10773, -1}}, 
        {"popf;", sizeof("popf;") - 1UL, {120161, -1}}, 
        {"pound;", sizeof("pound;") - 1UL, {163, -1}}, 
        {"pound", sizeof("pound") - 1UL, {163, -1}}, 
        {"pr;", sizeof("pr;") - 1UL, {8826, -1}}, 
        {"prE;", sizeof("prE;") - 1UL, {10931, -1}}, 
        {"prap;", sizeof("prap;") - 1UL, {10935, -1}}, 
        {"prcue;", sizeof("prcue;") - 1UL, {8828, -1}}, 
        {"pre;", sizeof("pre;") - 1UL, {10927, -1}}, 
        {"prec;", sizeof("prec;") - 1UL, {8826, -1}}, 
        {"precapprox;", sizeof("precapprox;") - 1UL, {10935, -1}}, 
        {"preccurlyeq;", sizeof("preccurlyeq;") - 1UL, {8828, -1}}, 
        {"preceq;", sizeof("preceq;") - 1UL, {10927, -1}}, 
        {"precnapprox;", sizeof("precnapprox;") - 1UL, {10937, -1}}, 
        {"precneqq;", sizeof("precneqq;") - 1UL, {10933, -1}}, 
        {"precnsim;", sizeof("precnsim;") - 1UL, {8936, -1}}, 
        {"precsim;", sizeof("precsim;") - 1UL, {8830, -1}}, 
        {"prime;", sizeof("prime;") - 1UL, {8242, -1}}, 
        {"primes;", sizeof("primes;") - 1UL, {8473, -1}}, 
        {"prnE;", sizeof("prnE;") - 1UL, {10933, -1}}, 
        {"prnap;", sizeof("prnap;") - 1UL, {10937, -1}}, 
        {"prnsim;", sizeof("prnsim;") - 1UL, {8936, -1}}, 
        {"prod;", sizeof("prod;") - 1UL, {8719, -1}}, 
        {"profalar;", sizeof("profalar;") - 1UL, {9006, -1}}, 
        {"profline;", sizeof("profline;") - 1UL, {8978, -1}}, 
        {"profsurf;", sizeof("profsurf;") - 1UL, {8979, -1}}, 
        {"prop;", sizeof("prop;") - 1UL, {8733, -1}}, 
        {"propto;", sizeof("propto;") - 1UL, {8733, -1}}, 
        {"prsim;", sizeof("prsim;") - 1UL, {8830, -1}}, 
        {"prurel;", sizeof("prurel;") - 1UL, {8880, -1}}, 
        {"pscr;", sizeof("pscr;") - 1UL, {120005, -1}}, 
        {"psi;", sizeof("psi;") - 1UL, {968, -1}}, 
        {"puncsp;", sizeof("puncsp;") - 1UL, {8200, -1}}, 
        {"qfr;", sizeof("qfr;") - 1UL, {120110, -1}}, 
        {"qint;", sizeof("qint;") - 1UL, {10764, -1}}, 
        {"qopf;", sizeof("qopf;") - 1UL, {120162, -1}}, 
        {"qprime;", sizeof("qprime;") - 1UL, {8279, -1}}, 
        {"qscr;", sizeof("qscr;") - 1UL, {120006, -1}}, 
        {"quaternions;", sizeof("quaternions;") - 1UL, {8461, -1}}, 
        {"quatint;", sizeof("quatint;") - 1UL, {10774, -1}}, 
        {"quest;", sizeof("quest;") - 1UL, {63, -1}}, 
        {"questeq;", sizeof("questeq;") - 1UL, {8799, -1}}, 
        {"quot;", sizeof("quot;") - 1UL, {34, -1}}, 
        {"quot", sizeof("quot") - 1UL, {34, -1}}, 
        {"rAarr;", sizeof("rAarr;") - 1UL, {8667, -1}}, 
        {"rArr;", sizeof("rArr;") - 1UL, {8658, -1}}, 
        {"rAtail;", sizeof("rAtail;") - 1UL, {10524, -1}}, 
        {"rBarr;", sizeof("rBarr;") - 1UL, {10511, -1}}, 
        {"rHar;", sizeof("rHar;") - 1UL, {10596, -1}}, 
        {"race;", sizeof("race;") - 1UL, {8765, 817}}, 
        {"racute;", sizeof("racute;") - 1UL, {341, -1}}, 
        {"radic;", sizeof("radic;") - 1UL, {8730, -1}}, 
        {"raemptyv;", sizeof("raemptyv;") - 1UL, {10675, -1}}, 
        {"rang;", sizeof("rang;") - 1UL, {10217, -1}}, 
        {"rangd;", sizeof("rangd;") - 1UL, {10642, -1}}, 
        {"range;", sizeof("range;") - 1UL, {10661, -1}}, 
        {"rangle;", sizeof("rangle;") - 1UL, {10217, -1}}, 
        {"raquo;", sizeof("raquo;") - 1UL, {187, -1}}, 
        {"raquo", sizeof("raquo") - 1UL, {187, -1}}, 
        {"rarr;", sizeof("rarr;") - 1UL, {8594, -1}}, 
        {"rarrap;", sizeof("rarrap;") - 1UL, {10613, -1}}, 
        {"rarrb;", sizeof("rarrb;") - 1UL, {8677, -1}}, 
        {"rarrbfs;", sizeof("rarrbfs;") - 1UL, {10528, -1}}, 
        {"rarrc;", sizeof("rarrc;") - 1UL, {10547, -1}}, 
        {"rarrfs;", sizeof("rarrfs;") - 1UL, {10526, -1}}, 
        {"rarrhk;", sizeof("rarrhk;") - 1UL, {8618, -1}}, 
        {"rarrlp;", sizeof("rarrlp;") - 1UL, {8620, -1}}, 
        {"rarrpl;", sizeof("rarrpl;") - 1UL, {10565, -1}}, 
        {"rarrsim;", sizeof("rarrsim;") - 1UL, {10612, -1}}, 
        {"rarrtl;", sizeof("rarrtl;") - 1UL, {8611, -1}}, 
        {"rarrw;", sizeof("rarrw;") - 1UL, {8605, -1}}, 
        {"ratail;", sizeof("ratail;") - 1UL, {10522, -1}}, 
        {"ratio;", sizeof("ratio;") - 1UL, {8758, -1}}, 
        {"rationals;", sizeof("rationals;") - 1UL, {8474, -1}}, 
        {"rbarr;", sizeof("rbarr;") - 1UL, {10509, -1}}, 
        {"rbbrk;", sizeof("rbbrk;") - 1UL, {10099, -1}}, 
        {"rbrace;", sizeof("rbrace;") - 1UL, {125, -1}}, 
        {"rbrack;", sizeof("rbrack;") - 1UL, {93, -1}}, 
        {"rbrke;", sizeof("rbrke;") - 1UL, {10636, -1}}, 
        {"rbrksld;", sizeof("rbrksld;") - 1UL, {10638, -1}}, 
        {"rbrkslu;", sizeof("rbrkslu;") - 1UL, {10640, -1}}, 
        {"rcaron;", sizeof("rcaron;") - 1UL, {345, -1}}, 
        {"rcedil;", sizeof("rcedil;") - 1UL, {343, -1}}, 
        {"rceil;", sizeof("rceil;") - 1UL, {8969, -1}}, 
        {"rcub;", sizeof("rcub;") - 1UL, {125, -1}}, 
        {"rcy;", sizeof("rcy;") - 1UL, {1088, -1}}, 
        {"rdca;", sizeof("rdca;") - 1UL, {10551, -1}}, 
        {"rdldhar;", sizeof("rdldhar;") - 1UL, {10601, -1}}, 
        {"rdquo;", sizeof("rdquo;") - 1UL, {8221, -1}}, 
        {"rdquor;", sizeof("rdquor;") - 1UL, {8221, -1}}, 
        {"rdsh;", sizeof("rdsh;") - 1UL, {8627, -1}}, 
        {"real;", sizeof("real;") - 1UL, {8476, -1}}, 
        {"realine;", sizeof("realine;") - 1UL, {8475, -1}}, 
        {"realpart;", sizeof("realpart;") - 1UL, {8476, -1}}, 
        {"reals;", sizeof("reals;") - 1UL, {8477, -1}}, 
        {"rect;", sizeof("rect;") - 1UL, {9645, -1}}, 
        {"reg;", sizeof("reg;") - 1UL, {174, -1}}, 
        {"reg", sizeof("reg") - 1UL, {174, -1}}, 
        {"rfisht;", sizeof("rfisht;") - 1UL, {10621, -1}}, 
        {"rfloor;", sizeof("rfloor;") - 1UL, {8971, -1}}, 
        {"rfr;", sizeof("rfr;") - 1UL, {120111, -1}}, 
        {"rhard;", sizeof("rhard;") - 1UL, {8641, -1}}, 
        {"rharu;", sizeof("rharu;") - 1UL, {8640, -1}}, 
        {"rharul;", sizeof("rharul;") - 1UL, {10604, -1}}, 
        {"rho;", sizeof("rho;") - 1UL, {961, -1}}, 
        {"rhov;", sizeof("rhov;") - 1UL, {1009, -1}}, 
        {"rightarrow;", sizeof("rightarrow;") - 1UL, {8594, -1}}, 
        {"rightarrowtail;", sizeof("rightarrowtail;") - 1UL, {8611, -1}}, 
        {"rightharpoondown;", sizeof("rightharpoondown;") - 1UL, {8641, -1}}, 
        {"rightharpoonup;", sizeof("rightharpoonup;") - 1UL, {8640, -1}}, 
        {"rightleftarrows;", sizeof("rightleftarrows;") - 1UL, {8644, -1}}, 
        {"rightleftharpoons;", sizeof("rightleftharpoons;") - 1UL, {8652, -1}}, 
        {"rightrightarrows;", sizeof("rightrightarrows;") - 1UL, {8649, -1}}, 
        {"rightsquigarrow;", sizeof("rightsquigarrow;") - 1UL, {8605, -1}}, 
        {"rightthreetimes;", sizeof("rightthreetimes;") - 1UL, {8908, -1}}, 
        {"ring;", sizeof("ring;") - 1UL, {730, -1}}, 
        {"risingdotseq;", sizeof("risingdotseq;") - 1UL, {8787, -1}}, 
        {"rlarr;", sizeof("rlarr;") - 1UL, {8644, -1}}, 
        {"rlhar;", sizeof("rlhar;") - 1UL, {8652, -1}}, 
        {"rlm;", sizeof("rlm;") - 1UL, {8207, -1}}, 
        {"rmoust;", sizeof("rmoust;") - 1UL, {9137, -1}}, 
        {"rmoustache;", sizeof("rmoustache;") - 1UL, {9137, -1}}, 
        {"rnmid;", sizeof("rnmid;") - 1UL, {10990, -1}}, 
        {"roang;", sizeof("roang;") - 1UL, {10221, -1}}, 
        {"roarr;", sizeof("roarr;") - 1UL, {8702, -1}}, 
        {"robrk;", sizeof("robrk;") - 1UL, {10215, -1}}, 
        {"ropar;", sizeof("ropar;") - 1UL, {10630, -1}}, 
        {"ropf;", sizeof("ropf;") - 1UL, {120163, -1}}, 
        {"roplus;", sizeof("roplus;") - 1UL, {10798, -1}}, 
        {"rotimes;", sizeof("rotimes;") - 1UL, {10805, -1}}, 
        {"rpar;", sizeof("rpar;") - 1UL, {41, -1}}, 
        {"rpargt;", sizeof("rpargt;") - 1UL, {10644, -1}}, 
        {"rppolint;", sizeof("rppolint;") - 1UL, {10770, -1}}, 
        {"rrarr;", sizeof("rrarr;") - 1UL, {8649, -1}}, 
        {"rsaquo;", sizeof("rsaquo;") - 1UL, {8250, -1}}, 
        {"rscr;", sizeof("rscr;") - 1UL, {120007, -1}}, 
        {"rsh;", sizeof("rsh;") - 1UL, {8625, -1}}, 
        {"rsqb;", sizeof("rsqb;") - 1UL, {93, -1}}, 
        {"rsquo;", sizeof("rsquo;") - 1UL, {8217, -1}}, 
        {"rsquor;", sizeof("rsquor;") - 1UL, {8217, -1}}, 
        {"rthree;", sizeof("rthree;") - 1UL, {8908, -1}}, 
        {"rtimes;", sizeof("rtimes;") - 1UL, {8906, -1}}, 
        {"rtri;", sizeof("rtri;") - 1UL, {9657, -1}}, 
        {"rtrie;", sizeof("rtrie;") - 1UL, {8885, -1}}, 
        {"rtrif;", sizeof("rtrif;") - 1UL, {9656, -1}}, 
        {"rtriltri;", sizeof("rtriltri;") - 1UL, {10702, -1}}, 
        {"ruluhar;", sizeof("ruluhar;") - 1UL, {10600, -1}}, 
        {"rx;", sizeof("rx;") - 1UL, {8478, -1}}, 
        {"sacute;", sizeof("sacute;") - 1UL, {347, -1}}, 
        {"sbquo;", sizeof("sbquo;") - 1UL, {8218, -1}}, 
        {"sc;", sizeof("sc;") - 1UL, {8827, -1}}, 
        {"scE;", sizeof("scE;") - 1UL, {10932, -1}}, 
        {"scap;", sizeof("scap;") - 1UL, {10936, -1}}, 
        {"scaron;", sizeof("scaron;") - 1UL, {353, -1}}, 
        {"sccue;", sizeof("sccue;") - 1UL, {8829, -1}}, 
        {"sce;", sizeof("sce;") - 1UL, {10928, -1}}, 
        {"scedil;", sizeof("scedil;") - 1UL, {351, -1}}, 
        {"scirc;", sizeof("scirc;") - 1UL, {349, -1}}, 
        {"scnE;", sizeof("scnE;") - 1UL, {10934, -1}}, 
        {"scnap;", sizeof("scnap;") - 1UL, {10938, -1}}, 
        {"scnsim;", sizeof("scnsim;") - 1UL, {8937, -1}}, 
        {"scpolint;", sizeof("scpolint;") - 1UL, {10771, -1}}, 
        {"scsim;", sizeof("scsim;") - 1UL, {8831, -1}}, 
        {"scy;", sizeof("scy;") - 1UL, {1089, -1}}, 
        {"sdot;", sizeof("sdot;") - 1UL, {8901, -1}}, 
        {"sdotb;", sizeof("sdotb;") - 1UL, {8865, -1}}, 
        {"sdote;", sizeof("sdote;") - 1UL, {10854, -1}}, 
        {"seArr;", sizeof("seArr;") - 1UL, {8664, -1}}, 
        {"searhk;", sizeof("searhk;") - 1UL, {10533, -1}}, 
        {"searr;", sizeof("searr;") - 1UL, {8600, -1}}, 
        {"searrow;", sizeof("searrow;") - 1UL, {8600, -1}}, 
        {"sect;", sizeof("sect;") - 1UL, {167, -1}}, 
        {"sect", sizeof("sect") - 1UL, {167, -1}}, 
        {"semi;", sizeof("semi;") - 1UL, {59, -1}}, 
        {"seswar;", sizeof("seswar;") - 1UL, {10537, -1}}, 
        {"setminus;", sizeof("setminus;") - 1UL, {8726, -1}}, 
        {"setmn;", sizeof("setmn;") - 1UL, {8726, -1}}, 
        {"sext;", sizeof("sext;") - 1UL, {10038, -1}}, 
        {"sfr;", sizeof("sfr;") - 1UL, {120112, -1}}, 
        {"sfrown;", sizeof("sfrown;") - 1UL, {8994, -1}}, 
        {"sharp;", sizeof("sharp;") - 1UL, {9839, -1}}, 
        {"shchcy;", sizeof("shchcy;") - 1UL, {1097, -1}}, 
        {"shcy;", sizeof("shcy;") - 1UL, {1096, -1}}, 
        {"shortmid;", sizeof("shortmid;") - 1UL, {8739, -1}}, 
        {"shortparallel;", sizeof("shortparallel;") - 1UL, {8741, -1}}, 
        {"shy;", sizeof("shy;") - 1UL, {173, -1}}, 
        {"shy", sizeof("shy") - 1UL, {173, -1}}, 
        {"sigma;", sizeof("sigma;") - 1UL, {963, -1}}, 
        {"sigmaf;", sizeof("sigmaf;") - 1UL, {962, -1}}, 
        {"sigmav;", sizeof("sigmav;") - 1UL, {962, -1}}, 
        {"sim;", sizeof("sim;") - 1UL, {8764, -1}}, 
        {"simdot;", sizeof("simdot;") - 1UL, {10858, -1}}, 
        {"sime;", sizeof("sime;") - 1UL, {8771, -1}}, 
        {"simeq;", sizeof("simeq;") - 1UL, {8771, -1}}, 
        {"simg;", sizeof("simg;") - 1UL, {10910, -1}}, 
        {"simgE;", sizeof("simgE;") - 1UL, {10912, -1}}, 
        {"siml;", sizeof("siml;") - 1UL, {10909, -1}}, 
        {"simlE;", sizeof("simlE;") - 1UL, {10911, -1}}, 
        {"simne;", sizeof("simne;") - 1UL, {8774, -1}}, 
        {"simplus;", sizeof("simplus;") - 1UL, {10788, -1}}, 
        {"simrarr;", sizeof("simrarr;") - 1UL, {10610, -1}}, 
        {"slarr;", sizeof("slarr;") - 1UL, {8592, -1}}, 
        {"smallsetminus;", sizeof("smallsetminus;") - 1UL, {8726, -1}}, 
        {"smashp;", sizeof("smashp;") - 1UL, {10803, -1}}, 
        {"smeparsl;", sizeof("smeparsl;") - 1UL, {10724, -1}}, 
        {"smid;", sizeof("smid;") - 1UL, {8739, -1}}, 
        {"smile;", sizeof("smile;") - 1UL, {8995, -1}}, 
        {"smt;", sizeof("smt;") - 1UL, {10922, -1}}, 
        {"smte;", sizeof("smte;") - 1UL, {10924, -1}}, 
        {"smtes;", sizeof("smtes;") - 1UL, {10924, 65024}}, 
        {"softcy;", sizeof("softcy;") - 1UL, {1100, -1}}, 
        {"sol;", sizeof("sol;") - 1UL, {47, -1}}, 
        {"solb;", sizeof("solb;") - 1UL, {10692, -1}}, 
        {"solbar;", sizeof("solbar;") - 1UL, {9023, -1}}, 
        {"sopf;", sizeof("sopf;") - 1UL, {120164, -1}}, 
        {"spades;", sizeof("spades;") - 1UL, {9824, -1}}, 
        {"spadesuit;", sizeof("spadesuit;") - 1UL, {9824, -1}}, 
        {"spar;", sizeof("spar;") - 1UL, {8741, -1}}, 
        {"sqcap;", sizeof("sqcap;") - 1UL, {8851, -1}}, 
        {"sqcaps;", sizeof("sqcaps;") - 1UL, {8851, 65024}}, 
        {"sqcup;", sizeof("sqcup;") - 1UL, {8852, -1}}, 
        {"sqcups;", sizeof("sqcups;") - 1UL, {8852, 65024}}, 
        {"sqsub;", sizeof("sqsub;") - 1UL, {8847, -1}}, 
        {"sqsube;", sizeof("sqsube;") - 1UL, {8849, -1}}, 
        {"sqsubset;", sizeof("sqsubset;") - 1UL, {8847, -1}}, 
        {"sqsubseteq;", sizeof("sqsubseteq;") - 1UL, {8849, -1}}, 
        {"sqsup;", sizeof("sqsup;") - 1UL, {8848, -1}}, 
        {"sqsupe;", sizeof("sqsupe;") - 1UL, {8850, -1}}, 
        {"sqsupset;", sizeof("sqsupset;") - 1UL, {8848, -1}}, 
        {"sqsupseteq;", sizeof("sqsupseteq;") - 1UL, {8850, -1}}, 
        {"squ;", sizeof("squ;") - 1UL, {9633, -1}}, 
        {"square;", sizeof("square;") - 1UL, {9633, -1}}, 
        {"squarf;", sizeof("squarf;") - 1UL, {9642, -1}}, 
        {"squf;", sizeof("squf;") - 1UL, {9642, -1}}, 
        {"srarr;", sizeof("srarr;") - 1UL, {8594, -1}}, 
        {"sscr;", sizeof("sscr;") - 1UL, {120008, -1}}, 
        {"ssetmn;", sizeof("ssetmn;") - 1UL, {8726, -1}}, 
        {"ssmile;", sizeof("ssmile;") - 1UL, {8995, -1}}, 
        {"sstarf;", sizeof("sstarf;") - 1UL, {8902, -1}}, 
        {"star;", sizeof("star;") - 1UL, {9734, -1}}, 
        {"starf;", sizeof("starf;") - 1UL, {9733, -1}}, 
        {"straightepsilon;", sizeof("straightepsilon;") - 1UL, {1013, -1}}, 
        {"straightphi;", sizeof("straightphi;") - 1UL, {981, -1}}, 
        {"strns;", sizeof("strns;") - 1UL, {175, -1}}, 
        {"sub;", sizeof("sub;") - 1UL, {8834, -1}}, 
        {"subE;", sizeof("subE;") - 1UL, {10949, -1}}, 
        {"subdot;", sizeof("subdot;") - 1UL, {10941, -1}}, 
        {"sube;", sizeof("sube;") - 1UL, {8838, -1}}, 
        {"subedot;", sizeof("subedot;") - 1UL, {10947, -1}}, 
        {"submult;", sizeof("submult;") - 1UL, {10945, -1}}, 
        {"subnE;", sizeof("subnE;") - 1UL, {10955, -1}}, 
        {"subne;", sizeof("subne;") - 1UL, {8842, -1}}, 
        {"subplus;", sizeof("subplus;") - 1UL, {10943, -1}}, 
        {"subrarr;", sizeof("subrarr;") - 1UL, {10617, -1}}, 
        {"subset;", sizeof("subset;") - 1UL, {8834, -1}}, 
        {"subseteq;", sizeof("subseteq;") - 1UL, {8838, -1}}, 
        {"subseteqq;", sizeof("subseteqq;") - 1UL, {10949, -1}}, 
        {"subsetneq;", sizeof("subsetneq;") - 1UL, {8842, -1}}, 
        {"subsetneqq;", sizeof("subsetneqq;") - 1UL, {10955, -1}}, 
        {"subsim;", sizeof("subsim;") - 1UL, {10951, -1}}, 
        {"subsub;", sizeof("subsub;") - 1UL, {10965, -1}}, 
        {"subsup;", sizeof("subsup;") - 1UL, {10963, -1}}, 
        {"succ;", sizeof("succ;") - 1UL, {8827, -1}}, 
        {"succapprox;", sizeof("succapprox;") - 1UL, {10936, -1}}, 
        {"succcurlyeq;", sizeof("succcurlyeq;") - 1UL, {8829, -1}}, 
        {"succeq;", sizeof("succeq;") - 1UL, {10928, -1}}, 
        {"succnapprox;", sizeof("succnapprox;") - 1UL, {10938, -1}}, 
        {"succneqq;", sizeof("succneqq;") - 1UL, {10934, -1}}, 
        {"succnsim;", sizeof("succnsim;") - 1UL, {8937, -1}}, 
        {"succsim;", sizeof("succsim;") - 1UL, {8831, -1}}, 
        {"sum;", sizeof("sum;") - 1UL, {8721, -1}}, 
        {"sung;", sizeof("sung;") - 1UL, {9834, -1}}, 
        {"sup1;", sizeof("sup1;") - 1UL, {185, -1}}, 
        {"sup1", sizeof("sup1") - 1UL, {185, -1}}, 
        {"sup2;", sizeof("sup2;") - 1UL, {178, -1}}, 
        {"sup2", sizeof("sup2") - 1UL, {178, -1}}, 
        {"sup3;", sizeof("sup3;") - 1UL, {179, -1}}, 
        {"sup3", sizeof("sup3") - 1UL, {179, -1}}, 
        {"sup;", sizeof("sup;") - 1UL, {8835, -1}}, 
        {"supE;", sizeof("supE;") - 1UL, {10950, -1}}, 
        {"supdot;", sizeof("supdot;") - 1UL, {10942, -1}}, 
        {"supdsub;", sizeof("supdsub;") - 1UL, {10968, -1}}, 
        {"supe;", sizeof("supe;") - 1UL, {8839, -1}}, 
        {"supedot;", sizeof("supedot;") - 1UL, {10948, -1}}, 
        {"suphsol;", sizeof("suphsol;") - 1UL, {10185, -1}}, 
        {"suphsub;", sizeof("suphsub;") - 1UL, {10967, -1}}, 
        {"suplarr;", sizeof("suplarr;") - 1UL, {10619, -1}}, 
        {"supmult;", sizeof("supmult;") - 1UL, {10946, -1}}, 
        {"supnE;", sizeof("supnE;") - 1UL, {10956, -1}}, 
        {"supne;", sizeof("supne;") - 1UL, {8843, -1}}, 
        {"supplus;", sizeof("supplus;") - 1UL, {10944, -1}}, 
        {"supset;", sizeof("supset;") - 1UL, {8835, -1}}, 
        {"supseteq;", sizeof("supseteq;") - 1UL, {8839, -1}}, 
        {"supseteqq;", sizeof("supseteqq;") - 1UL, {10950, -1}}, 
        {"supsetneq;", sizeof("supsetneq;") - 1UL, {8843, -1}}, 
        {"supsetneqq;", sizeof("supsetneqq;") - 1UL, {10956, -1}}, 
        {"supsim;", sizeof("supsim;") - 1UL, {10952, -1}}, 
        {"supsub;", sizeof("supsub;") - 1UL, {10964, -1}}, 
        {"supsup;", sizeof("supsup;") - 1UL, {10966, -1}}, 
        {"swArr;", sizeof("swArr;") - 1UL, {8665, -1}}, 
        {"swarhk;", sizeof("swarhk;") - 1UL, {10534, -1}}, 
        {"swarr;", sizeof("swarr;") - 1UL, {8601, -1}}, 
        {"swarrow;", sizeof("swarrow;") - 1UL, {8601, -1}}, 
        {"swnwar;", sizeof("swnwar;") - 1UL, {10538, -1}}, 
        {"szlig;", sizeof("szlig;") - 1UL, {223, -1}}, 
        {"szlig", sizeof("szlig") - 1UL, {223, -1}}, 
        {"target;", sizeof("target;") - 1UL, {8982, -1}}, 
        {"tau;", sizeof("tau;") - 1UL, {964, -1}}, 
        {"tbrk;", sizeof("tbrk;") - 1UL, {9140, -1}}, 
        {"tcaron;", sizeof("tcaron;") - 1UL, {357, -1}}, 
        {"tcedil;", sizeof("tcedil;") - 1UL, {355, -1}}, 
        {"tcy;", sizeof("tcy;") - 1UL, {1090, -1}}, 
        {"tdot;", sizeof("tdot;") - 1UL, {8411, -1}}, 
        {"telrec;", sizeof("telrec;") - 1UL, {8981, -1}}, 
        {"tfr;", sizeof("tfr;") - 1UL, {120113, -1}}, 
        {"there4;", sizeof("there4;") - 1UL, {8756, -1}}, 
        {"therefore;", sizeof("therefore;") - 1UL, {8756, -1}}, 
        {"theta;", sizeof("theta;") - 1UL, {952, -1}}, 
        {"thetasym;", sizeof("thetasym;") - 1UL, {977, -1}}, 
        {"thetav;", sizeof("thetav;") - 1UL, {977, -1}}, 
        {"thickapprox;", sizeof("thickapprox;") - 1UL, {8776, -1}}, 
        {"thicksim;", sizeof("thicksim;") - 1UL, {8764, -1}}, 
        {"thinsp;", sizeof("thinsp;") - 1UL, {8201, -1}}, 
        {"thkap;", sizeof("thkap;") - 1UL, {8776, -1}}, 
        {"thksim;", sizeof("thksim;") - 1UL, {8764, -1}}, 
        {"thorn;", sizeof("thorn;") - 1UL, {254, -1}}, 
        {"thorn", sizeof("thorn") - 1UL, {254, -1}}, 
        {"tilde;", sizeof("tilde;") - 1UL, {732, -1}}, 
        {"times;", sizeof("times;") - 1UL, {215, -1}}, 
        {"times", sizeof("times") - 1UL, {215, -1}}, 
        {"timesb;", sizeof("timesb;") - 1UL, {8864, -1}}, 
        {"timesbar;", sizeof("timesbar;") - 1UL, {10801, -1}}, 
        {"timesd;", sizeof("timesd;") - 1UL, {10800, -1}}, 
        {"tint;", sizeof("tint;") - 1UL, {8749, -1}}, 
        {"toea;", sizeof("toea;") - 1UL, {10536, -1}}, 
        {"top;", sizeof("top;") - 1UL, {8868, -1}}, 
        {"topbot;", sizeof("topbot;") - 1UL, {9014, -1}}, 
        {"topcir;", sizeof("topcir;") - 1UL, {10993, -1}}, 
        {"topf;", sizeof("topf;") - 1UL, {120165, -1}}, 
        {"topfork;", sizeof("topfork;") - 1UL, {10970, -1}}, 
        {"tosa;", sizeof("tosa;") - 1UL, {10537, -1}}, 
        {"tprime;", sizeof("tprime;") - 1UL, {8244, -1}}, 
        {"trade;", sizeof("trade;") - 1UL, {8482, -1}}, 
        {"triangle;", sizeof("triangle;") - 1UL, {9653, -1}}, 
        {"triangledown;", sizeof("triangledown;") - 1UL, {9663, -1}}, 
        {"triangleleft;", sizeof("triangleleft;") - 1UL, {9667, -1}}, 
        {"trianglelefteq;", sizeof("trianglelefteq;") - 1UL, {8884, -1}}, 
        {"triangleq;", sizeof("triangleq;") - 1UL, {8796, -1}}, 
        {"triangleright;", sizeof("triangleright;") - 1UL, {9657, -1}}, 
        {"trianglerighteq;", sizeof("trianglerighteq;") - 1UL, {8885, -1}}, 
        {"tridot;", sizeof("tridot;") - 1UL, {9708, -1}}, 
        {"trie;", sizeof("trie;") - 1UL, {8796, -1}}, 
        {"triminus;", sizeof("triminus;") - 1UL, {10810, -1}}, 
        {"triplus;", sizeof("triplus;") - 1UL, {10809, -1}}, 
        {"trisb;", sizeof("trisb;") - 1UL, {10701, -1}}, 
        {"tritime;", sizeof("tritime;") - 1UL, {10811, -1}}, 
        {"trpezium;", sizeof("trpezium;") - 1UL, {9186, -1}}, 
        {"tscr;", sizeof("tscr;") - 1UL, {120009, -1}}, 
        {"tscy;", sizeof("tscy;") - 1UL, {1094, -1}}, 
        {"tshcy;", sizeof("tshcy;") - 1UL, {1115, -1}}, 
        {"tstrok;", sizeof("tstrok;") - 1UL, {359, -1}}, 
        {"twixt;", sizeof("twixt;") - 1UL, {8812, -1}}, 
        {"twoheadleftarrow;", sizeof("twoheadleftarrow;") - 1UL, {8606, -1}}, 
        {"twoheadrightarrow;", sizeof("twoheadrightarrow;") - 1UL, {8608, -1}}, 
        {"uArr;", sizeof("uArr;") - 1UL, {8657, -1}}, 
        {"uHar;", sizeof("uHar;") - 1UL, {10595, -1}}, 
        {"uacute;", sizeof("uacute;") - 1UL, {250, -1}}, 
        {"uacute", sizeof("uacute") - 1UL, {250, -1}}, 
        {"uarr;", sizeof("uarr;") - 1UL, {8593, -1}}, 
        {"ubrcy;", sizeof("ubrcy;") - 1UL, {1118, -1}}, 
        {"ubreve;", sizeof("ubreve;") - 1UL, {365, -1}}, 
        {"ucirc;", sizeof("ucirc;") - 1UL, {251, -1}}, 
        {"ucirc", sizeof("ucirc") - 1UL, {251, -1}}, 
        {"ucy;", sizeof("ucy;") - 1UL, {1091, -1}}, 
        {"udarr;", sizeof("udarr;") - 1UL, {8645, -1}}, 
        {"udblac;", sizeof("udblac;") - 1UL, {369, -1}}, 
        {"udhar;", sizeof("udhar;") - 1UL, {10606, -1}}, 
        {"ufisht;", sizeof("ufisht;") - 1UL, {10622, -1}}, 
        {"ufr;", sizeof("ufr;") - 1UL, {120114, -1}}, 
        {"ugrave;", sizeof("ugrave;") - 1UL, {249, -1}}, 
        {"ugrave", sizeof("ugrave") - 1UL, {249, -1}}, 
        {"uharl;", sizeof("uharl;") - 1UL, {8639, -1}}, 
        {"uharr;", sizeof("uharr;") - 1UL, {8638, -1}}, 
        {"uhblk;", sizeof("uhblk;") - 1UL, {9600, -1}}, 
        {"ulcorn;", sizeof("ulcorn;") - 1UL, {8988, -1}}, 
        {"ulcorner;", sizeof("ulcorner;") - 1UL, {8988, -1}}, 
        {"ulcrop;", sizeof("ulcrop;") - 1UL, {8975, -1}}, 
        {"ultri;", sizeof("ultri;") - 1UL, {9720, -1}}, 
        {"umacr;", sizeof("umacr;") - 1UL, {363, -1}}, 
        {"uml;", sizeof("uml;") - 1UL, {168, -1}}, 
        {"uml", sizeof("uml") - 1UL, {168, -1}}, 
        {"uogon;", sizeof("uogon;") - 1UL, {371, -1}}, 
        {"uopf;", sizeof("uopf;") - 1UL, {120166, -1}}, 
        {"uparrow;", sizeof("uparrow;") - 1UL, {8593, -1}}, 
        {"updownarrow;", sizeof("updownarrow;") - 1UL, {8597, -1}}, 
        {"upharpoonleft;", sizeof("upharpoonleft;") - 1UL, {8639, -1}}, 
        {"upharpoonright;", sizeof("upharpoonright;") - 1UL, {8638, -1}}, 
        {"uplus;", sizeof("uplus;") - 1UL, {8846, -1}}, 
        {"upsi;", sizeof("upsi;") - 1UL, {965, -1}}, 
        {"upsih;", sizeof("upsih;") - 1UL, {978, -1}}, 
        {"upsilon;", sizeof("upsilon;") - 1UL, {965, -1}}, 
        {"upuparrows;", sizeof("upuparrows;") - 1UL, {8648, -1}}, 
        {"urcorn;", sizeof("urcorn;") - 1UL, {8989, -1}}, 
        {"urcorner;", sizeof("urcorner;") - 1UL, {8989, -1}}, 
        {"urcrop;", sizeof("urcrop;") - 1UL, {8974, -1}}, 
        {"uring;", sizeof("uring;") - 1UL, {367, -1}}, 
        {"urtri;", sizeof("urtri;") - 1UL, {9721, -1}}, 
        {"uscr;", sizeof("uscr;") - 1UL, {120010, -1}}, 
        {"utdot;", sizeof("utdot;") - 1UL, {8944, -1}}, 
        {"utilde;", sizeof("utilde;") - 1UL, {361, -1}}, 
        {"utri;", sizeof("utri;") - 1UL, {9653, -1}}, 
        {"utrif;", sizeof("utrif;") - 1UL, {9652, -1}}, 
        {"uuarr;", sizeof("uuarr;") - 1UL, {8648, -1}}, 
        {"uuml;", sizeof("uuml;") - 1UL, {252, -1}}, 
        {"uuml", sizeof("uuml") - 1UL, {252, -1}}, 
        {"uwangle;", sizeof("uwangle;") - 1UL, {10663, -1}}, 
        {"vArr;", sizeof("vArr;") - 1UL, {8661, -1}}, 
        {"vBar;", sizeof("vBar;") - 1UL, {10984, -1}}, 
        {"vBarv;", sizeof("vBarv;") - 1UL, {10985, -1}}, 
        {"vDash;", sizeof("vDash;") - 1UL, {8872, -1}}, 
        {"vangrt;", sizeof("vangrt;") - 1UL, {10652, -1}}, 
        {"varepsilon;", sizeof("varepsilon;") - 1UL, {1013, -1}}, 
        {"varkappa;", sizeof("varkappa;") - 1UL, {1008, -1}}, 
        {"varnothing;", sizeof("varnothing;") - 1UL, {8709, -1}}, 
        {"varphi;", sizeof("varphi;") - 1UL, {981, -1}}, 
        {"varpi;", sizeof("varpi;") - 1UL, {982, -1}}, 
        {"varpropto;", sizeof("varpropto;") - 1UL, {8733, -1}}, 
        {"varr;", sizeof("varr;") - 1UL, {8597, -1}}, 
        {"varrho;", sizeof("varrho;") - 1UL, {1009, -1}}, 
        {"varsigma;", sizeof("varsigma;") - 1UL, {962, -1}}, 
        {"varsubsetneq;", sizeof("varsubsetneq;") - 1UL, {8842, 65024}}, 
        {"varsubsetneqq;", sizeof("varsubsetneqq;") - 1UL, {10955, 65024}}, 
        {"varsupsetneq;", sizeof("varsupsetneq;") - 1UL, {8843, 65024}}, 
        {"varsupsetneqq;", sizeof("varsupsetneqq;") - 1UL, {10956, 65024}}, 
        {"vartheta;", sizeof("vartheta;") - 1UL, {977, -1}}, 
        {"vartriangleleft;", sizeof("vartriangleleft;") - 1UL, {8882, -1}}, 
        {"vartriangleright;", sizeof("vartriangleright;") - 1UL, {8883, -1}}, 
        {"vcy;", sizeof("vcy;") - 1UL, {1074, -1}}, 
        {"vdash;", sizeof("vdash;") - 1UL, {8866, -1}}, 
        {"vee;", sizeof("vee;") - 1UL, {8744, -1}}, 
        {"veebar;", sizeof("veebar;") - 1UL, {8891, -1}}, 
        {"veeeq;", sizeof("veeeq;") - 1UL, {8794, -1}}, 
        {"vellip;", sizeof("vellip;") - 1UL, {8942, -1}}, 
        {"verbar;", sizeof("verbar;") - 1UL, {124, -1}}, 
        {"vert;", sizeof("vert;") - 1UL, {124, -1}}, 
        {"vfr;", sizeof("vfr;") - 1UL, {120115, -1}}, 
        {"vltri;", sizeof("vltri;") - 1UL, {8882, -1}}, 
        {"vnsub;", sizeof("vnsub;") - 1UL, {8834, 8402}}, 
        {"vnsup;", sizeof("vnsup;") - 1UL, {8835, 8402}}, 
        {"vopf;", sizeof("vopf;") - 1UL, {120167, -1}}, 
        {"vprop;", sizeof("vprop;") - 1UL, {8733, -1}}, 
        {"vrtri;", sizeof("vrtri;") - 1UL, {8883, -1}}, 
        {"vscr;", sizeof("vscr;") - 1UL, {120011, -1}}, 
        {"vsubnE;", sizeof("vsubnE;") - 1UL, {10955, 65024}}, 
        {"vsubne;", sizeof("vsubne;") - 1UL, {8842, 65024}}, 
        {"vsupnE;", sizeof("vsupnE;") - 1UL, {10956, 65024}}, 
        {"vsupne;", sizeof("vsupne;") - 1UL, {8843, 65024}}, 
        {"vzigzag;", sizeof("vzigzag;") - 1UL, {10650, -1}}, 
        {"wcirc;", sizeof("wcirc;") - 1UL, {373, -1}}, 
        {"wedbar;", sizeof("wedbar;") - 1UL, {10847, -1}}, 
        {"wedge;", sizeof("wedge;") - 1UL, {8743, -1}}, 
        {"wedgeq;", sizeof("wedgeq;") - 1UL, {8793, -1}}, 
        {"weierp;", sizeof("weierp;") - 1UL, {8472, -1}}, 
        {"wfr;", sizeof("wfr;") - 1UL, {120116, -1}}, 
        {"wopf;", sizeof("wopf;") - 1UL, {120168, -1}}, 
        {"wp;", sizeof("wp;") - 1UL, {8472, -1}}, 
        {"wr;", sizeof("wr;") - 1UL, {8768, -1}}, 
        {"wreath;", sizeof("wreath;") - 1UL, {8768, -1}}, 
        {"wscr;", sizeof("wscr;") - 1UL, {120012, -1}}, 
        {"xcap;", sizeof("xcap;") - 1UL, {8898, -1}}, 
        {"xcirc;", sizeof("xcirc;") - 1UL, {9711, -1}}, 
        {"xcup;", sizeof("xcup;") - 1UL, {8899, -1}}, 
        {"xdtri;", sizeof("xdtri;") - 1UL, {9661, -1}}, 
        {"xfr;", sizeof("xfr;") - 1UL, {120117, -1}}, 
        {"xhArr;", sizeof("xhArr;") - 1UL, {10234, -1}}, 
        {"xharr;", sizeof("xharr;") - 1UL, {10231, -1}}, 
        {"xi;", sizeof("xi;") - 1UL, {958, -1}}, 
        {"xlArr;", sizeof("xlArr;") - 1UL, {10232, -1}}, 
        {"xlarr;", sizeof("xlarr;") - 1UL, {10229, -1}}, 
        {"xmap;", sizeof("xmap;") - 1UL, {10236, -1}}, 
        {"xnis;", sizeof("xnis;") - 1UL, {8955, -1}}, 
        {"xodot;", sizeof("xodot;") - 1UL, {10752, -1}}, 
        {"xopf;", sizeof("xopf;") - 1UL, {120169, -1}}, 
        {"xoplus;", sizeof("xoplus;") - 1UL, {10753, -1}}, 
        {"xotime;", sizeof("xotime;") - 1UL, {10754, -1}}, 
        {"xrArr;", sizeof("xrArr;") - 1UL, {10233, -1}}, 
        {"xrarr;", sizeof("xrarr;") - 1UL, {10230, -1}}, 
        {"xscr;", sizeof("xscr;") - 1UL, {120013, -1}}, 
        {"xsqcup;", sizeof("xsqcup;") - 1UL, {10758, -1}}, 
        {"xuplus;", sizeof("xuplus;") - 1UL, {10756, -1}}, 
        {"xutri;", sizeof("xutri;") - 1UL, {9651, -1}}, 
        {"xvee;", sizeof("xvee;") - 1UL, {8897, -1}}, 
        {"xwedge;", sizeof("xwedge;") - 1UL, {8896, -1}}, 
        {"yacute;", sizeof("yacute;") - 1UL, {253, -1}}, 
        {"yacute", sizeof("yacute") - 1UL, {253, -1}}, 
        {"yacy;", sizeof("yacy;") - 1UL, {1103, -1}}, 
        {"ycirc;", sizeof("ycirc;") - 1UL, {375, -1}}, 
        {"ycy;", sizeof("ycy;") - 1UL, {1099, -1}}, 
        {"yen;", sizeof("yen;") - 1UL, {165, -1}}, 
        {"yen", sizeof("yen") - 1UL, {165, -1}}, 
        {"yfr;", sizeof("yfr;") - 1UL, {120118, -1}}, 
        {"yicy;", sizeof("yicy;") - 1UL, {1111, -1}}, 
        {"yopf;", sizeof("yopf;") - 1UL, {120170, -1}}, 
        {"yscr;", sizeof("yscr;") - 1UL, {120014, -1}}, 
        {"yucy;", sizeof("yucy;") - 1UL, {1102, -1}}, 
        {"yuml;", sizeof("yuml;") - 1UL, {255, -1}}, 
        {"yuml", sizeof("yuml") - 1UL, {255, -1}}, 
        {"zacute;", sizeof("zacute;") - 1UL, {378, -1}}, 
        {"zcaron;", sizeof("zcaron;") - 1UL, {382, -1}}, 
        {"zcy;", sizeof("zcy;") - 1UL, {1079, -1}}, 
        {"zdot;", sizeof("zdot;") - 1UL, {380, -1}}, 
        {"zeetrf;", sizeof("zeetrf;") - 1UL, {8488, -1}}, 
        {"zeta;", sizeof("zeta;") - 1UL, {950, -1}}, 
        {"zfr;", sizeof("zfr;") - 1UL, {120119, -1}}, 
        {"zhcy;", sizeof("zhcy;") - 1UL, {1078, -1}}, 
        {"zigrarr;", sizeof("zigrarr;") - 1UL, {8669, -1}}, 
        {"zopf;", sizeof("zopf;") - 1UL, {120171, -1}}, 
        {"zscr;", sizeof("zscr;") - 1UL, {120015, -1}}, 
        {"zwj;", sizeof("zwj;") - 1UL, {8205, -1}}, 
        {"zwnj;", sizeof("zwnj;") - 1UL, {8204, -1}}, 
        {"", sizeof("") - 1UL, {-1, -1}}};
static CharReplacement const   kCharReplacements[35]  = 
  {      {0, 65533}, 
        {13, 13}, 
        {128, 8364}, 
        {129, 129}, 
        {130, 8218}, 
        {131, 402}, 
        {132, 8222}, 
        {133, 8230}, 
        {134, 8224}, 
        {135, 8225}, 
        {136, 710}, 
        {137, 8240}, 
        {138, 352}, 
        {139, 8249}, 
        {140, 338}, 
        {141, 141}, 
        {142, 381}, 
        {143, 143}, 
        {144, 144}, 
        {145, 8216}, 
        {146, 8217}, 
        {147, 8220}, 
        {148, 8221}, 
        {149, 8226}, 
        {150, 8211}, 
        {151, 8212}, 
        {152, 732}, 
        {153, 8482}, 
        {154, 353}, 
        {155, 8250}, 
        {156, 339}, 
        {157, 157}, 
        {158, 382}, 
        {159, 376}, 
        {-1, -1}};
static int parse_digit(int c , _Bool allow_hex ) 
{ 


  {
  if (c >= 48) {
    if (c <= 57) {
      return (c - 48);
    }
  }
  if (allow_hex) {
    if (c >= 97) {
      if (c <= 102) {
        return ((c - 97) + 10);
      }
    }
  }
  if (allow_hex) {
    if (c >= 65) {
      if (c <= 70) {
        return ((c - 65) + 10);
      }
    }
  }
  return (-1);
}
}
static void add_no_digit_error(struct GumboInternalParser *parser , Utf8Iterator *input ) 
{ 
  GumboError *error___0 ;
  GumboError *tmp ;

  {
  tmp = gumbo_add_error(parser);
  error___0 = tmp;
  if (! error___0) {
    return;
  }
  utf8iterator_fill_error_at_mark(input, error___0);
  error___0->type = (GumboErrorType )3;
  return;
}
}
static void add_codepoint_error(struct GumboInternalParser *parser , Utf8Iterator *input ,
                                GumboErrorType type , int codepoint ) 
{ 
  GumboError *error___0 ;
  GumboError *tmp ;

  {
  tmp = gumbo_add_error(parser);
  error___0 = tmp;
  if (! error___0) {
    return;
  }
  utf8iterator_fill_error_at_mark(input, error___0);
  error___0->type = type;
  error___0->v.codepoint = (uint64_t )codepoint;
  return;
}
}
static void add_named_reference_error(struct GumboInternalParser *parser , Utf8Iterator *input ,
                                      GumboErrorType type , GumboStringPiece text ) 
{ 
  GumboError *error___0 ;
  GumboError *tmp ;

  {
  tmp = gumbo_add_error(parser);
  error___0 = tmp;
  if (! error___0) {
    return;
  }
  utf8iterator_fill_error_at_mark(input, error___0);
  error___0->type = type;
  error___0->v.text = text;
  return;
}
}
static int maybe_replace_codepoint(int codepoint ) 
{ 
  int i ;

  {
  i = 0;
  while (kCharReplacements[i].from_char != -1) {
    if (kCharReplacements[i].from_char == (int const   )codepoint) {
      return ((int )kCharReplacements[i].to_char);
    }
    i ++;
  }
  return (-1);
}
}
static _Bool consume_numeric_ref(struct GumboInternalParser *parser , Utf8Iterator *input ,
                                 int *output ) 
{ 
  _Bool is_hex ;
  int c ;
  int tmp ;
  int digit ;
  int tmp___0 ;
  int codepoint ;
  _Bool status ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int replacement ;
  int tmp___4 ;
  _Bool tmp___5 ;

  {
  utf8iterator_next(input);
  is_hex = (_Bool)0;
  tmp = utf8iterator_current((Utf8Iterator const   *)input);
  c = tmp;
  if (c == 120) {
    is_hex = (_Bool)1;
    utf8iterator_next(input);
    c = utf8iterator_current((Utf8Iterator const   *)input);
  } else
  if (c == 88) {
    is_hex = (_Bool)1;
    utf8iterator_next(input);
    c = utf8iterator_current((Utf8Iterator const   *)input);
  }
  tmp___0 = parse_digit(c, is_hex);
  digit = tmp___0;
  if (digit == -1) {
    add_no_digit_error(parser, input);
    utf8iterator_reset(input);
    *output = (int )kGumboNoChar;
    return ((_Bool)0);
  }
  codepoint = 0;
  status = (_Bool)1;
  while (1) {
    if (is_hex) {
      tmp___1 = 16;
    } else {
      tmp___1 = 10;
    }
    codepoint = codepoint * tmp___1 + digit;
    utf8iterator_next(input);
    tmp___2 = utf8iterator_current((Utf8Iterator const   *)input);
    digit = parse_digit(tmp___2, is_hex);
    if (! (digit != -1)) {
      break;
    }
  }
  tmp___3 = utf8iterator_current((Utf8Iterator const   *)input);
  if (tmp___3 != 59) {
    add_codepoint_error(parser, input, (GumboErrorType )4, codepoint);
    status = (_Bool)0;
  } else {
    utf8iterator_next(input);
  }
  tmp___4 = maybe_replace_codepoint(codepoint);
  replacement = tmp___4;
  if (replacement != -1) {
    add_codepoint_error(parser, input, (GumboErrorType )5, codepoint);
    *output = replacement;
    return ((_Bool)0);
  }
  if (codepoint >= 55296) {
    if (codepoint <= 57343) {
      add_codepoint_error(parser, input, (GumboErrorType )5, codepoint);
      *output = 65533;
      return ((_Bool)0);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (codepoint > 1114111) {
    add_codepoint_error(parser, input, (GumboErrorType )5, codepoint);
    *output = 65533;
    return ((_Bool)0);
  }
  tmp___5 = utf8_is_invalid_code_point(codepoint);
  if (tmp___5) {
    add_codepoint_error(parser, input, (GumboErrorType )5, codepoint);
    status = (_Bool)0;
  } else
  if (codepoint == 11) {
    add_codepoint_error(parser, input, (GumboErrorType )5, codepoint);
    status = (_Bool)0;
  }
  *output = codepoint;
  return (status);
}
}
static NamedCharRef const   *find_named_char_ref(Utf8Iterator *input ) 
{ 
  int i ;
  NamedCharRef const   *current ;
  size_t tmp___2 ;
  _Bool tmp___6 ;

  {
  i = 0;
  while (kNamedEntities[i].codepoints.first != -1) {
    current = & kNamedEntities[i];
    tmp___2 = strlen((char const   *)current->name);
    if (! (tmp___2 == (size_t )current->length)) {
      __assert_fail("strlen(current->name) == current->length", "deps/gumbo-parser/char_ref.c",
                    2460U, "find_named_char_ref");
    }
    tmp___6 = utf8iterator_maybe_consume_match(input, (char const   *)current->name,
                                               (size_t )current->length, (_Bool)1);
    if (tmp___6) {
      if (! ((unsigned long )current->name != (unsigned long )((void *)0))) {
        __assert_fail("current->name != NULL", "deps/gumbo-parser/char_ref.c", 2463U,
                      "find_named_char_ref");
      }
      if (! (current->length > 0UL)) {
        __assert_fail("current->length > 0", "deps/gumbo-parser/char_ref.c", 2464U,
                      "find_named_char_ref");
      }
      if (! (current->codepoints.first != kGumboNoChar)) {
        __assert_fail("current->codepoints.first != kGumboNoChar", "deps/gumbo-parser/char_ref.c",
                      2465U, "find_named_char_ref");
      }
      return (current);
    }
    i ++;
  }
  return ((NamedCharRef const   *)((void *)0));
}
}
static _Bool is_legal_attribute_char_next(Utf8Iterator *input ) 
{ 
  int c ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  tmp = utf8iterator_current((Utf8Iterator const   *)input);
  c = tmp;
  if (c == 61) {
    tmp___1 = 1;
  } else {
    tmp___0 = __ctype_b_loc();
    if ((int const   )*(*tmp___0 + c) & 8) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  return ((_Bool )tmp___1);
}
}
static _Bool maybe_add_invalid_named_reference(struct GumboInternalParser *parser ,
                                               Utf8Iterator *input ) 
{ 
  char const   *start ;
  char const   *tmp ;
  int c ;
  int tmp___0 ;
  GumboStringPiece bad_ref ;
  char const   *tmp___1 ;

  {
  tmp = utf8iterator_get_char_pointer((Utf8Iterator const   *)input);
  start = tmp;
  tmp___0 = utf8iterator_current((Utf8Iterator const   *)input);
  c = tmp___0;
  while (1) {
    if (c >= 97) {
      if (! (c <= 122)) {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (c >= 65) {
      if (! (c <= 90)) {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (c >= 48) {
      if (! (c <= 57)) {
        break;
      }
    } else {
      break;
    }
    utf8iterator_next(input);
    c = utf8iterator_current((Utf8Iterator const   *)input);
  }
  if (c == 59) {
    bad_ref.data = start;
    tmp___1 = utf8iterator_get_char_pointer((Utf8Iterator const   *)input);
    bad_ref.length = (size_t )(tmp___1 - start);
    add_named_reference_error(parser, input, (GumboErrorType )7, bad_ref);
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
static _Bool consume_named_ref(struct GumboInternalParser *parser , Utf8Iterator *input ,
                               _Bool is_in_attribute , OneOrTwoCodepoints *output ) 
{ 
  NamedCharRef const   *char_ref ;
  NamedCharRef const   *tmp___0 ;
  size_t tmp___4 ;
  char last_char ;
  GumboStringPiece bad_ref ;
  _Bool tmp___7 ;
  _Bool status ;
  _Bool tmp___8 ;

  {
  if (! (output->first == (int )kGumboNoChar)) {
    __assert_fail("output->first == kGumboNoChar", "deps/gumbo-parser/char_ref.c",
                  2503U, "consume_named_ref");
  }
  tmp___0 = find_named_char_ref(input);
  char_ref = tmp___0;
  if (char_ref) {
    tmp___4 = strlen((char const   *)char_ref->name);
    if (! (char_ref->length == (size_t const   )tmp___4)) {
      __assert_fail("char_ref->length == strlen(char_ref->name)", "deps/gumbo-parser/char_ref.c",
                    2506U, "consume_named_ref");
    }
    last_char = (char )*(char_ref->name + (char_ref->length - 1UL));
    if ((int )last_char == 59) {
      *output = (OneOrTwoCodepoints )char_ref->codepoints;
      if (! (output->first != (int )kGumboNoChar)) {
        __assert_fail("output->first != kGumboNoChar", "deps/gumbo-parser/char_ref.c",
                      2510U, "consume_named_ref");
      }
      return ((_Bool)1);
    } else
    if (is_in_attribute) {
      tmp___7 = is_legal_attribute_char_next(input);
      if (tmp___7) {
        utf8iterator_reset(input);
        return ((_Bool)1);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      bad_ref.data = (char const   *)char_ref->name;
      bad_ref.length = (size_t )char_ref->length;
      add_named_reference_error(parser, input, (GumboErrorType )6, bad_ref);
      *output = (OneOrTwoCodepoints )char_ref->codepoints;
      if (! (output->first != (int )kGumboNoChar)) {
        __assert_fail("output->first != kGumboNoChar", "deps/gumbo-parser/char_ref.c",
                      2522U, "consume_named_ref");
      }
      return ((_Bool)0);
    }
  } else {
    tmp___8 = maybe_add_invalid_named_reference(parser, input);
    status = tmp___8;
    utf8iterator_reset(input);
    return (status);
  }
}
}
_Bool consume_char_ref(struct GumboInternalParser *parser , struct GumboInternalUtf8Iterator *input ,
                       int additional_allowed_char , _Bool is_in_attribute , OneOrTwoCodepoints *output ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  utf8iterator_mark(input);
  utf8iterator_next(input);
  tmp = utf8iterator_current((Utf8Iterator const   *)input);
  c = tmp;
  output->first = (int )kGumboNoChar;
  output->second = (int )kGumboNoChar;
  if (c == additional_allowed_char) {
    utf8iterator_reset(input);
    output->first = (int )kGumboNoChar;
    return ((_Bool)1);
  }
  tmp___0 = utf8iterator_current((Utf8Iterator const   *)input);
  switch (tmp___0) {
  case -1: 
  case 38: 
  case 60: 
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  utf8iterator_reset(input);
  return ((_Bool)1);
  case 35: 
  tmp___1 = consume_numeric_ref(parser, input, & output->first);
  return (tmp___1);
  default: 
  tmp___2 = consume_named_ref(parser, input, is_in_attribute, output);
  return (tmp___2);
  }
}
}
#pragma merger("0","/tmp/cil-TV9VkcYF.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
struct __anonstruct_GumboStringPiece_673951369  const  kScriptTag  =    {"script", (size_t )6};
static void add_parse_error___0(GumboParser *parser , GumboErrorType type ) 
{ 
  GumboError *error___0 ;
  GumboError *tmp ;
  GumboTokenizerState *tokenizer ;

  {
  tmp = gumbo_add_error(parser);
  error___0 = tmp;
  if (! error___0) {
    return;
  }
  tokenizer = parser->_tokenizer_state;
  utf8iterator_get_position((Utf8Iterator const   *)(& tokenizer->_input), & error___0->position);
  error___0->original_text = utf8iterator_get_char_pointer((Utf8Iterator const   *)(& tokenizer->_input));
  error___0->type = type;
  error___0->v.tokenizer.codepoint = utf8iterator_current((Utf8Iterator const   *)(& tokenizer->_input));
  switch ((unsigned int )tokenizer->_state) {
  case 0U: 
  error___0->v.tokenizer.state = (GumboTokenizerErrorState )0;
  break;
  case 40U: 
  case 3U: 
  case 1U: 
  error___0->v.tokenizer.state = (GumboTokenizerErrorState )1;
  break;
  case 12U: 
  case 11U: 
  case 10U: 
  case 2U: 
  error___0->v.tokenizer.state = (GumboTokenizerErrorState )2;
  break;
  case 15U: 
  case 14U: 
  case 13U: 
  case 4U: 
  error___0->v.tokenizer.state = (GumboTokenizerErrorState )3;
  break;
  case 6U: 
  error___0->v.tokenizer.state = (GumboTokenizerErrorState )4;
  break;
  case 32U: 
  case 31U: 
  case 30U: 
  case 29U: 
  case 28U: 
  case 27U: 
  case 26U: 
  case 25U: 
  case 24U: 
  case 23U: 
  case 22U: 
  case 21U: 
  case 20U: 
  case 19U: 
  case 18U: 
  case 17U: 
  case 16U: 
  case 5U: 
  error___0->v.tokenizer.state = (GumboTokenizerErrorState )5;
  break;
  case 33U: 
  case 9U: 
  case 8U: 
  case 7U: 
  error___0->v.tokenizer.state = (GumboTokenizerErrorState )6;
  break;
  case 42U: 
  error___0->v.tokenizer.state = (GumboTokenizerErrorState )7;
  break;
  case 36U: 
  case 35U: 
  case 34U: 
  error___0->v.tokenizer.state = (GumboTokenizerErrorState )8;
  break;
  case 41U: 
  case 39U: 
  case 38U: 
  case 37U: 
  error___0->v.tokenizer.state = (GumboTokenizerErrorState )9;
  break;
  case 50U: 
  case 49U: 
  case 48U: 
  case 47U: 
  case 46U: 
  case 45U: 
  case 43U: 
  error___0->v.tokenizer.state = (GumboTokenizerErrorState )11;
  break;
  case 66U: 
  case 65U: 
  case 64U: 
  case 63U: 
  case 62U: 
  case 61U: 
  case 60U: 
  case 59U: 
  case 58U: 
  case 57U: 
  case 56U: 
  case 55U: 
  case 54U: 
  case 53U: 
  case 52U: 
  case 51U: 
  case 44U: 
  error___0->v.tokenizer.state = (GumboTokenizerErrorState )12;
  break;
  case 67U: 
  error___0->v.tokenizer.state = (GumboTokenizerErrorState )13;
  break;
  }
  return;
}
}
static _Bool is_alpha(int c ) 
{ 
  int tmp ;

  {
  if (c >= 65) {
    if (c <= 90) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (c >= 97) {
    if (c <= 122) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
static int ensure_lowercase(int c ) 
{ 
  int tmp ;

  {
  if (c >= 65) {
    if (c <= 90) {
      tmp = c + 32;
    } else {
      tmp = c;
    }
  } else {
    tmp = c;
  }
  return (tmp);
}
}
static GumboTokenType get_char_token_type(int c ) 
{ 


  {
  switch (c) {
  case 32: 
  case 12: 
  case 13: 
  case 10: 
  case 9: 
  return ((GumboTokenType )4);
  case 0: 
  gumbo_debug("Emitted null byte.\n");
  return ((GumboTokenType )6);
  case -1: 
  return ((GumboTokenType )7);
  default: 
  return ((GumboTokenType )5);
  }
}
}
static void clear_temporary_buffer(GumboParser *parser ) 
{ 
  GumboTokenizerState *tokenizer ;

  {
  tokenizer = parser->_tokenizer_state;
  if (! (! tokenizer->_temporary_buffer_emit)) {
    __assert_fail("!tokenizer->_temporary_buffer_emit", "deps/gumbo-parser/tokenizer.c",
                  349U, "clear_temporary_buffer");
  }
  utf8iterator_mark(& tokenizer->_input);
  gumbo_string_buffer_destroy(parser, & tokenizer->_temporary_buffer);
  gumbo_string_buffer_init(parser, & tokenizer->_temporary_buffer);
  gumbo_string_buffer_destroy(parser, & tokenizer->_script_data_buffer);
  gumbo_string_buffer_init(parser, & tokenizer->_script_data_buffer);
  return;
}
}
static void append_char_to_temporary_buffer(GumboParser *parser , int codepoint ) 
{ 


  {
  gumbo_string_buffer_append_codepoint(parser, codepoint, & (parser->_tokenizer_state)->_temporary_buffer);
  return;
}
}
static _Bool temporary_buffer_equals(GumboParser *parser , char const   *text ) 
{ 
  GumboStringBuffer *buffer ;
  int text_len ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  buffer = & (parser->_tokenizer_state)->_temporary_buffer;
  tmp = strlen(text);
  text_len = (int )tmp;
  if ((size_t )text_len == buffer->length) {
    tmp___0 = memcmp((void const   *)buffer->data, (void const   *)text, (size_t )text_len);
    if (tmp___0 == 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return ((_Bool )tmp___1);
}
}
static void doc_type_state_init(GumboParser *parser ) 
{ 
  GumboTokenDocType *doc_type_state ;

  {
  doc_type_state = & (parser->_tokenizer_state)->_doc_type_state;
  doc_type_state->name = (char const   *)((void *)0);
  doc_type_state->public_identifier = (char const   *)((void *)0);
  doc_type_state->system_identifier = (char const   *)((void *)0);
  doc_type_state->force_quirks = (_Bool)0;
  doc_type_state->has_public_identifier = (_Bool)0;
  doc_type_state->has_system_identifier = (_Bool)0;
  return;
}
}
static void reset_token_start_point(GumboTokenizerState *tokenizer ) 
{ 


  {
  tokenizer->_token_start = utf8iterator_get_char_pointer((Utf8Iterator const   *)(& tokenizer->_input));
  utf8iterator_get_position((Utf8Iterator const   *)(& tokenizer->_input), & tokenizer->_token_start_pos);
  return;
}
}
static void reset_tag_buffer_start_point(GumboParser *parser ) 
{ 
  GumboTokenizerState *tokenizer ;
  GumboTagState *tag_state ;

  {
  tokenizer = parser->_tokenizer_state;
  tag_state = & tokenizer->_tag_state;
  utf8iterator_get_position((Utf8Iterator const   *)(& tokenizer->_input), & tag_state->_start_pos);
  tag_state->_original_text = utf8iterator_get_char_pointer((Utf8Iterator const   *)(& tokenizer->_input));
  return;
}
}
static void finish_temporary_buffer(GumboParser *parser , char const   **output ) 
{ 
  GumboTokenizerState *tokenizer ;
  char *tmp ;

  {
  tokenizer = parser->_tokenizer_state;
  tmp = gumbo_string_buffer_to_string(parser, & tokenizer->_temporary_buffer);
  *output = (char const   *)tmp;
  clear_temporary_buffer(parser);
  return;
}
}
static void finish_token(GumboParser *parser , GumboToken *token ) 
{ 
  GumboTokenizerState *tokenizer ;

  {
  tokenizer = parser->_tokenizer_state;
  if (! tokenizer->_reconsume_current_input) {
    utf8iterator_next(& tokenizer->_input);
  }
  token->position = tokenizer->_token_start_pos;
  token->original_text.data = tokenizer->_token_start;
  reset_token_start_point(tokenizer);
  token->original_text.length = (size_t )(tokenizer->_token_start - token->original_text.data);
  if (token->original_text.length > 0UL) {
    if ((int const   )*(token->original_text.data + (token->original_text.length - 1UL)) == 13) {
      (token->original_text.length) --;
    }
  }
  return;
}
}
static void finish_doctype_public_id(GumboParser *parser ) 
{ 
  GumboTokenDocType *doc_type_state ;

  {
  doc_type_state = & (parser->_tokenizer_state)->_doc_type_state;
  gumbo_parser_deallocate(parser, (void *)doc_type_state->public_identifier);
  finish_temporary_buffer(parser, & doc_type_state->public_identifier);
  doc_type_state->has_public_identifier = (_Bool)1;
  return;
}
}
static void finish_doctype_system_id(GumboParser *parser ) 
{ 
  GumboTokenDocType *doc_type_state ;

  {
  doc_type_state = & (parser->_tokenizer_state)->_doc_type_state;
  gumbo_parser_deallocate(parser, (void *)doc_type_state->system_identifier);
  finish_temporary_buffer(parser, & doc_type_state->system_identifier);
  doc_type_state->has_system_identifier = (_Bool)1;
  return;
}
}
static void emit_char(GumboParser *parser , int c , GumboToken *output ) 
{ 


  {
  output->type = get_char_token_type(c);
  output->v.character = c;
  finish_token(parser, output);
  return;
}
}
static StateResult emit_replacement_char(GumboParser *parser , GumboToken *output ) 
{ 


  {
  add_parse_error___0(parser, (GumboErrorType )2);
  emit_char(parser, (int )kUtf8ReplacementChar, output);
  return ((StateResult )0);
}
}
static StateResult emit_eof(GumboParser *parser , GumboToken *output ) 
{ 


  {
  emit_char(parser, -1, output);
  return ((StateResult )1);
}
}
static _Bool emit_current_char(GumboParser *parser , GumboToken *output ) 
{ 
  int tmp ;

  {
  tmp = utf8iterator_current((Utf8Iterator const   *)(& (parser->_tokenizer_state)->_input));
  emit_char(parser, tmp, output);
  return ((_Bool)1);
}
}
static void emit_doctype(GumboParser *parser , GumboToken *output ) 
{ 


  {
  output->type = (GumboTokenType )0;
  output->v.doc_type = (parser->_tokenizer_state)->_doc_type_state;
  finish_token(parser, output);
  doc_type_state_init(parser);
  return;
}
}
static void mark_tag_state_as_empty(GumboTagState *tag_state ) 
{ 


  {
  tag_state->_attributes = (GumboVector )kGumboEmptyVector;
  return;
}
}
static StateResult emit_current_tag(GumboParser *parser , GumboToken *output ) 
{ 
  GumboTagState *tag_state ;
  char const   *tmp ;
  int i ;
  char const   *tmp___0 ;

  {
  tag_state = & (parser->_tokenizer_state)->_tag_state;
  if (tag_state->_is_start_tag) {
    output->type = (GumboTokenType )1;
    output->v.start_tag.tag = tag_state->_tag;
    output->v.start_tag.attributes = tag_state->_attributes;
    output->v.start_tag.is_self_closing = tag_state->_is_self_closing;
    tag_state->_last_start_tag = tag_state->_tag;
    mark_tag_state_as_empty(tag_state);
    tmp = gumbo_normalized_tagname(tag_state->_tag);
    gumbo_debug("Emitted start tag %s.\n", tmp);
  } else {
    output->type = (GumboTokenType )2;
    output->v.end_tag = tag_state->_tag;
    i = 0;
    while ((unsigned int )i < tag_state->_attributes.length) {
      gumbo_destroy_attribute(parser, (GumboAttribute *)*(tag_state->_attributes.data + i));
      i ++;
    }
    gumbo_parser_deallocate(parser, (void *)tag_state->_attributes.data);
    mark_tag_state_as_empty(tag_state);
    tmp___0 = gumbo_normalized_tagname(tag_state->_tag);
    gumbo_debug("Emitted end tag %s.\n", tmp___0);
  }
  gumbo_string_buffer_destroy(parser, & tag_state->_buffer);
  finish_token(parser, output);
  gumbo_debug("Original text = %.*s.\n", output->original_text.length, output->original_text.data);
  if (! (output->original_text.length >= 2UL)) {
    __assert_fail("output->original_text.length >= 2", "deps/gumbo-parser/tokenizer.c",
                  553U, "emit_current_tag");
  }
  if (! ((int const   )*(output->original_text.data + 0) == 60)) {
    __assert_fail("output->original_text.data[0] == \'<\'", "deps/gumbo-parser/tokenizer.c",
                  554U, "emit_current_tag");
  }
  if (! ((int const   )*(output->original_text.data + (output->original_text.length - 1UL)) == 62)) {
    __assert_fail("output->original_text.data[output->original_text.length - 1] == \'>\'",
                  "deps/gumbo-parser/tokenizer.c", 555U, "emit_current_tag");
  }
  return ((StateResult )1);
}
}
static void abandon_current_tag(GumboParser *parser ) 
{ 
  GumboTagState *tag_state ;
  int i ;

  {
  tag_state = & (parser->_tokenizer_state)->_tag_state;
  i = 0;
  while ((unsigned int )i < tag_state->_attributes.length) {
    gumbo_destroy_attribute(parser, (GumboAttribute *)*(tag_state->_attributes.data + i));
    i ++;
  }
  gumbo_parser_deallocate(parser, (void *)tag_state->_attributes.data);
  mark_tag_state_as_empty(tag_state);
  gumbo_string_buffer_destroy(parser, & tag_state->_buffer);
  gumbo_debug("Abandoning current tag.\n");
  return;
}
}
static StateResult emit_char_ref(GumboParser *parser , int additional_allowed_char ,
                                 _Bool is_in_attribute , GumboToken *output ) 
{ 
  GumboTokenizerState *tokenizer ;
  OneOrTwoCodepoints char_ref ;
  _Bool status ;
  _Bool tmp ;
  int tmp___0 ;

  {
  tokenizer = parser->_tokenizer_state;
  tmp = consume_char_ref(parser, & tokenizer->_input, additional_allowed_char, (_Bool)0,
                         & char_ref);
  status = tmp;
  if (char_ref.first != (int )kGumboNoChar) {
    tokenizer->_reconsume_current_input = (_Bool)1;
    emit_char(parser, char_ref.first, output);
    tokenizer->_buffered_emit_char = char_ref.second;
  } else {
    emit_char(parser, '&', output);
  }
  if (status) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return ((StateResult )tmp___0);
}
}
static StateResult emit_comment(GumboParser *parser , GumboToken *output ) 
{ 


  {
  output->type = (GumboTokenType )3;
  finish_temporary_buffer(parser, & output->v.text);
  finish_token(parser, output);
  return ((StateResult )1);
}
}
static _Bool maybe_emit_from_temporary_buffer(GumboParser *parser , GumboToken *output ) 
{ 
  GumboTokenizerState *tokenizer ;
  char const   *c ;
  GumboStringBuffer *buffer ;
  int tmp___2 ;
  _Bool saved_reconsume_state ;

  {
  tokenizer = parser->_tokenizer_state;
  c = tokenizer->_temporary_buffer_emit;
  buffer = & tokenizer->_temporary_buffer;
  if (! c) {
    tokenizer->_temporary_buffer_emit = (char const   *)((void *)0);
    return ((_Bool)0);
  } else
  if ((unsigned long )c >= (unsigned long )(buffer->data + buffer->length)) {
    tokenizer->_temporary_buffer_emit = (char const   *)((void *)0);
    return ((_Bool)0);
  }
  tmp___2 = utf8iterator_current((Utf8Iterator const   *)(& tokenizer->_input));
  if (! ((int const   )*c == (int const   )tmp___2)) {
    __assert_fail("*c == utf8iterator_current(&tokenizer->_input)", "deps/gumbo-parser/tokenizer.c",
                  622U, "maybe_emit_from_temporary_buffer");
  }
  saved_reconsume_state = tokenizer->_reconsume_current_input;
  tokenizer->_reconsume_current_input = (_Bool)0;
  emit_char(parser, (int )*c, output);
  (tokenizer->_temporary_buffer_emit) ++;
  tokenizer->_reconsume_current_input = saved_reconsume_state;
  return ((_Bool)1);
}
}
static _Bool emit_temporary_buffer(GumboParser *parser , GumboToken *output ) 
{ 
  GumboTokenizerState *tokenizer ;
  _Bool tmp___0 ;

  {
  tokenizer = parser->_tokenizer_state;
  if (! tokenizer->_temporary_buffer.data) {
    __assert_fail("tokenizer->_temporary_buffer.data", "deps/gumbo-parser/tokenizer.c",
                  646U, "emit_temporary_buffer");
  }
  utf8iterator_reset(& tokenizer->_input);
  tokenizer->_temporary_buffer_emit = (char const   *)tokenizer->_temporary_buffer.data;
  tmp___0 = maybe_emit_from_temporary_buffer(parser, output);
  return (tmp___0);
}
}
static void append_char_to_tag_buffer(GumboParser *parser , int codepoint , _Bool reinitilize_position_on_first ) 
{ 
  GumboStringBuffer *buffer ;

  {
  buffer = & (parser->_tokenizer_state)->_tag_state._buffer;
  if (buffer->length == 0UL) {
    if (reinitilize_position_on_first) {
      reset_tag_buffer_start_point(parser);
    }
  }
  gumbo_string_buffer_append_codepoint(parser, codepoint, buffer);
  return;
}
}
static void initialize_tag_buffer(GumboParser *parser ) 
{ 
  GumboTokenizerState *tokenizer ;
  GumboTagState *tag_state ;

  {
  tokenizer = parser->_tokenizer_state;
  tag_state = & tokenizer->_tag_state;
  gumbo_string_buffer_init(parser, & tag_state->_buffer);
  reset_tag_buffer_start_point(parser);
  return;
}
}
static void start_new_tag(GumboParser *parser , _Bool is_start_tag ) 
{ 
  GumboTokenizerState *tokenizer ;
  GumboTagState *tag_state ;
  int c ;
  int tmp ;
  _Bool tmp___3 ;
  _Bool tmp___7 ;

  {
  tokenizer = parser->_tokenizer_state;
  tag_state = & tokenizer->_tag_state;
  tmp = utf8iterator_current((Utf8Iterator const   *)(& tokenizer->_input));
  c = tmp;
  tmp___3 = is_alpha(c);
  if (! tmp___3) {
    __assert_fail("is_alpha(c)", "deps/gumbo-parser/tokenizer.c", 683U, "start_new_tag");
  }
  c = ensure_lowercase(c);
  tmp___7 = is_alpha(c);
  if (! tmp___7) {
    __assert_fail("is_alpha(c)", "deps/gumbo-parser/tokenizer.c", 685U, "start_new_tag");
  }
  initialize_tag_buffer(parser);
  gumbo_string_buffer_append_codepoint(parser, c, & tag_state->_buffer);
  if (! ((unsigned long )tag_state->_attributes.data == (unsigned long )((void *)0))) {
    __assert_fail("tag_state->_attributes.data == NULL", "deps/gumbo-parser/tokenizer.c",
                  690U, "start_new_tag");
  }
  gumbo_vector_init(parser, (size_t )4, & tag_state->_attributes);
  tag_state->_drop_next_attr_value = (_Bool)0;
  tag_state->_is_start_tag = is_start_tag;
  tag_state->_is_self_closing = (_Bool)0;
  gumbo_debug("Starting new tag.\n");
  return;
}
}
static void copy_over_tag_buffer(GumboParser *parser , char const   **output ) 
{ 
  GumboTokenizerState *tokenizer ;
  GumboTagState *tag_state ;
  char *tmp ;

  {
  tokenizer = parser->_tokenizer_state;
  tag_state = & tokenizer->_tag_state;
  tmp = gumbo_string_buffer_to_string(parser, & tag_state->_buffer);
  *output = (char const   *)tmp;
  return;
}
}
static void copy_over_original_tag_text(GumboParser *parser , GumboStringPiece *original_text ,
                                        GumboSourcePosition *start_pos , GumboSourcePosition *end_pos ) 
{ 
  GumboTokenizerState *tokenizer ;
  GumboTagState *tag_state ;
  char const   *tmp ;

  {
  tokenizer = parser->_tokenizer_state;
  tag_state = & tokenizer->_tag_state;
  original_text->data = tag_state->_original_text;
  tmp = utf8iterator_get_char_pointer((Utf8Iterator const   *)(& tokenizer->_input));
  original_text->length = (size_t )(tmp - tag_state->_original_text);
  if ((int const   )*(original_text->data + (original_text->length - 1UL)) == 13) {
    (original_text->length) --;
  }
  *start_pos = tag_state->_start_pos;
  utf8iterator_get_position((Utf8Iterator const   *)(& tokenizer->_input), end_pos);
  return;
}
}
static void reinitialize_tag_buffer(GumboParser *parser ) 
{ 


  {
  gumbo_parser_deallocate(parser, (void *)(parser->_tokenizer_state)->_tag_state._buffer.data);
  initialize_tag_buffer(parser);
  return;
}
}
static void finish_tag_name(GumboParser *parser ) 
{ 
  GumboTokenizerState *tokenizer ;
  GumboTagState *tag_state ;
  char const   *temp ;

  {
  tokenizer = parser->_tokenizer_state;
  tag_state = & tokenizer->_tag_state;
  copy_over_tag_buffer(parser, & temp);
  tag_state->_tag = gumbo_tag_enum(temp);
  reinitialize_tag_buffer(parser);
  gumbo_parser_deallocate(parser, (void *)temp);
  return;
}
}
static void add_duplicate_attr_error(GumboParser *parser , char const   *attr_name ,
                                     int original_index , int new_index ) 
{ 
  GumboError *error___0 ;
  GumboError *tmp ;
  GumboTagState *tag_state ;

  {
  tmp = gumbo_add_error(parser);
  error___0 = tmp;
  if (! error___0) {
    return;
  }
  tag_state = & (parser->_tokenizer_state)->_tag_state;
  error___0->type = (GumboErrorType )24;
  error___0->position = tag_state->_start_pos;
  error___0->original_text = tag_state->_original_text;
  error___0->v.duplicate_attr.original_index = (unsigned int )original_index;
  error___0->v.duplicate_attr.new_index = (unsigned int )new_index;
  copy_over_tag_buffer(parser, & error___0->v.duplicate_attr.name);
  reinitialize_tag_buffer(parser);
  return;
}
}
static _Bool finish_attribute_name(GumboParser *parser ) 
{ 
  GumboTokenizerState *tokenizer ;
  GumboTagState *tag_state ;
  GumboVector *attributes ;
  int i ;
  GumboAttribute *attr ;
  size_t tmp___1 ;
  int tmp___2 ;
  GumboAttribute *attr___0 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
  tokenizer = parser->_tokenizer_state;
  tag_state = & tokenizer->_tag_state;
  tag_state->_drop_next_attr_value = (_Bool)0;
  if (! tag_state->_attributes.data) {
    __assert_fail("tag_state->_attributes.data", "deps/gumbo-parser/tokenizer.c",
                  780U, "finish_attribute_name");
  }
  if (! tag_state->_attributes.capacity) {
    __assert_fail("tag_state->_attributes.capacity", "deps/gumbo-parser/tokenizer.c",
                  781U, "finish_attribute_name");
  }
  attributes = & tag_state->_attributes;
  i = 0;
  while ((unsigned int )i < attributes->length) {
    attr = (GumboAttribute *)*(attributes->data + i);
    tmp___1 = strlen(attr->name);
    if (tmp___1 == tag_state->_buffer.length) {
      tmp___2 = memcmp((void const   *)attr->name, (void const   *)tag_state->_buffer.data,
                       tag_state->_buffer.length);
      if (tmp___2 == 0) {
        add_duplicate_attr_error(parser, attr->name, i, (int )attributes->length);
        tag_state->_drop_next_attr_value = (_Bool)1;
        return ((_Bool)0);
      }
    }
    i ++;
  }
  tmp___3 = gumbo_parser_allocate(parser, sizeof(GumboAttribute ));
  attr___0 = (GumboAttribute *)tmp___3;
  attr___0->attr_namespace = (GumboAttributeNamespaceEnum )0;
  copy_over_tag_buffer(parser, & attr___0->name);
  copy_over_original_tag_text(parser, & attr___0->original_name, & attr___0->name_start,
                              & attr___0->name_end);
  tmp___4 = gumbo_copy_stringz(parser, "");
  attr___0->value = (char const   *)tmp___4;
  copy_over_original_tag_text(parser, & attr___0->original_value, & attr___0->name_start,
                              & attr___0->name_end);
  gumbo_vector_add(parser, (void *)attr___0, attributes);
  reinitialize_tag_buffer(parser);
  return ((_Bool)1);
}
}
static void finish_attribute_value(GumboParser *parser ) 
{ 
  GumboTagState *tag_state ;
  GumboAttribute *attr ;

  {
  tag_state = & (parser->_tokenizer_state)->_tag_state;
  if (tag_state->_drop_next_attr_value) {
    tag_state->_drop_next_attr_value = (_Bool)0;
    return;
  }
  attr = (GumboAttribute *)*(tag_state->_attributes.data + (tag_state->_attributes.length - 1U));
  gumbo_parser_deallocate(parser, (void *)attr->value);
  copy_over_tag_buffer(parser, & attr->value);
  copy_over_original_tag_text(parser, & attr->original_value, & attr->value_start,
                              & attr->value_end);
  reinitialize_tag_buffer(parser);
  return;
}
}
static _Bool is_appropriate_end_tag(GumboParser *parser ) 
{ 
  GumboTagState *tag_state ;
  GumboTag tmp___0 ;
  int tmp___1 ;

  {
  tag_state = & (parser->_tokenizer_state)->_tag_state;
  if (! (! tag_state->_is_start_tag)) {
    __assert_fail("!tag_state->_is_start_tag", "deps/gumbo-parser/tokenizer.c", 833U,
                  "is_appropriate_end_tag");
  }
  gumbo_string_buffer_append_codepoint(parser, '\000', & tag_state->_buffer);
  (tag_state->_buffer.length) --;
  if ((unsigned int )tag_state->_last_start_tag != 150U) {
    tmp___0 = gumbo_tag_enum((char const   *)tag_state->_buffer.data);
    if ((unsigned int )tag_state->_last_start_tag == (unsigned int )tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return ((_Bool )tmp___1);
}
}
void gumbo_tokenizer_state_init(struct GumboInternalParser *parser , char const   *text ,
                                size_t text_length ) 
{ 
  GumboTokenizerState *tokenizer ;
  void *tmp ;

  {
  tmp = gumbo_parser_allocate(parser, sizeof(GumboTokenizerState ));
  tokenizer = (GumboTokenizerState *)tmp;
  parser->_tokenizer_state = tokenizer;
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_reconsume_current_input = (_Bool)0;
  tokenizer->_is_current_node_foreign = (_Bool)0;
  tokenizer->_tag_state._last_start_tag = (GumboTag )150;
  tokenizer->_buffered_emit_char = (int )kGumboNoChar;
  gumbo_string_buffer_init(parser, & tokenizer->_temporary_buffer);
  tokenizer->_temporary_buffer_emit = (char const   *)((void *)0);
  mark_tag_state_as_empty(& tokenizer->_tag_state);
  gumbo_string_buffer_init(parser, & tokenizer->_script_data_buffer);
  tokenizer->_token_start = text;
  utf8iterator_init(parser, text, text_length, & tokenizer->_input);
  utf8iterator_get_position((Utf8Iterator const   *)(& tokenizer->_input), & tokenizer->_token_start_pos);
  doc_type_state_init(parser);
  return;
}
}
void gumbo_tokenizer_state_destroy(struct GumboInternalParser *parser ) 
{ 
  GumboTokenizerState *tokenizer ;

  {
  tokenizer = parser->_tokenizer_state;
  if (! ((unsigned long )tokenizer->_doc_type_state.name == (unsigned long )((void *)0))) {
    __assert_fail("tokenizer->_doc_type_state.name == NULL", "deps/gumbo-parser/tokenizer.c",
                  868U, "gumbo_tokenizer_state_destroy");
  }
  if (! ((unsigned long )tokenizer->_doc_type_state.public_identifier == (unsigned long )((void *)0))) {
    __assert_fail("tokenizer->_doc_type_state.public_identifier == NULL", "deps/gumbo-parser/tokenizer.c",
                  869U, "gumbo_tokenizer_state_destroy");
  }
  if (! ((unsigned long )tokenizer->_doc_type_state.system_identifier == (unsigned long )((void *)0))) {
    __assert_fail("tokenizer->_doc_type_state.system_identifier == NULL", "deps/gumbo-parser/tokenizer.c",
                  870U, "gumbo_tokenizer_state_destroy");
  }
  gumbo_string_buffer_destroy(parser, & tokenizer->_temporary_buffer);
  gumbo_string_buffer_destroy(parser, & tokenizer->_script_data_buffer);
  gumbo_parser_deallocate(parser, (void *)tokenizer);
  return;
}
}
void gumbo_tokenizer_set_state(struct GumboInternalParser *parser , GumboTokenizerEnum state ) 
{ 


  {
  (parser->_tokenizer_state)->_state = state;
  return;
}
}
void gumbo_tokenizer_set_is_current_node_foreign(struct GumboInternalParser *parser ,
                                                 _Bool is_foreign ) 
{ 
  char const   *tmp ;

  {
  if ((int )is_foreign != (int )(parser->_tokenizer_state)->_is_current_node_foreign) {
    if (is_foreign) {
      tmp = "true";
    } else {
      tmp = "false";
    }
    gumbo_debug("Toggling is_current_node_foreign to %s.\n", tmp);
  }
  (parser->_tokenizer_state)->_is_current_node_foreign = is_foreign;
  return;
}
}
static StateResult handle_data_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                     int c , GumboToken *output ) 
{ 
  _Bool tmp ;

  {
  switch (c) {
  case 38: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )1);
  tokenizer->_reconsume_current_input = (_Bool)1;
  return ((StateResult )2);
  case 60: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )7);
  clear_temporary_buffer(parser);
  append_char_to_temporary_buffer(parser, '<');
  return ((StateResult )2);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  emit_char(parser, c, output);
  return ((StateResult )0);
  default: 
  tmp = emit_current_char(parser, output);
  return ((StateResult )tmp);
  }
}
}
static StateResult handle_char_ref_in_data_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                 int c , GumboToken *output ) 
{ 
  StateResult tmp ;

  {
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tmp = emit_char_ref(parser, ' ', (_Bool)0, output);
  return (tmp);
}
}
static StateResult handle_rcdata_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                       int c , GumboToken *output ) 
{ 
  StateResult tmp ;
  StateResult tmp___0 ;
  _Bool tmp___1 ;

  {
  switch (c) {
  case 38: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )3);
  tokenizer->_reconsume_current_input = (_Bool)1;
  return ((StateResult )2);
  case 60: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )10);
  clear_temporary_buffer(parser);
  append_char_to_temporary_buffer(parser, '<');
  return ((StateResult )2);
  case 0: 
  tmp = emit_replacement_char(parser, output);
  return (tmp);
  case -1: 
  tmp___0 = emit_eof(parser, output);
  return (tmp___0);
  default: 
  tmp___1 = emit_current_char(parser, output);
  return ((StateResult )tmp___1);
  }
}
}
static StateResult handle_char_ref_in_rcdata_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                   int c , GumboToken *output ) 
{ 
  StateResult tmp ;

  {
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )2);
  tmp = emit_char_ref(parser, ' ', (_Bool)0, output);
  return (tmp);
}
}
static StateResult handle_rawtext_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                        int c , GumboToken *output ) 
{ 
  StateResult tmp ;
  StateResult tmp___0 ;
  _Bool tmp___1 ;

  {
  switch (c) {
  case 60: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )13);
  clear_temporary_buffer(parser);
  append_char_to_temporary_buffer(parser, '<');
  return ((StateResult )2);
  case 0: 
  tmp = emit_replacement_char(parser, output);
  return (tmp);
  case -1: 
  tmp___0 = emit_eof(parser, output);
  return (tmp___0);
  default: 
  tmp___1 = emit_current_char(parser, output);
  return ((StateResult )tmp___1);
  }
}
}
static StateResult handle_script_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                       int c , GumboToken *output ) 
{ 
  StateResult tmp ;
  StateResult tmp___0 ;
  _Bool tmp___1 ;

  {
  switch (c) {
  case 60: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )16);
  clear_temporary_buffer(parser);
  append_char_to_temporary_buffer(parser, '<');
  return ((StateResult )2);
  case 0: 
  tmp = emit_replacement_char(parser, output);
  return (tmp);
  case -1: 
  tmp___0 = emit_eof(parser, output);
  return (tmp___0);
  default: 
  tmp___1 = emit_current_char(parser, output);
  return ((StateResult )tmp___1);
  }
}
}
static StateResult handle_plaintext_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                          int c , GumboToken *output ) 
{ 
  StateResult tmp ;
  StateResult tmp___0 ;
  _Bool tmp___1 ;

  {
  switch (c) {
  case 0: 
  tmp = emit_replacement_char(parser, output);
  return (tmp);
  case -1: 
  tmp___0 = emit_eof(parser, output);
  return (tmp___0);
  default: 
  tmp___1 = emit_current_char(parser, output);
  return ((StateResult )tmp___1);
  }
}
}
static StateResult handle_tag_open_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                         int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  tmp___2 = temporary_buffer_equals(parser, "<");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"<\")", "deps/gumbo-parser/tokenizer.c",
                  1010U, "handle_tag_open_state");
  }
  switch (c) {
  case 33: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )44);
  clear_temporary_buffer(parser);
  return ((StateResult )2);
  case 47: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )8);
  append_char_to_temporary_buffer(parser, '/');
  return ((StateResult )2);
  case 63: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )43);
  clear_temporary_buffer(parser);
  append_char_to_temporary_buffer(parser, '?');
  add_parse_error___0(parser, (GumboErrorType )8);
  return ((StateResult )2);
  default: 
  tmp___3 = is_alpha(c);
  if (tmp___3) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )9);
    start_new_tag(parser, (_Bool)1);
    return ((StateResult )2);
  } else {
    add_parse_error___0(parser, (GumboErrorType )10);
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
    emit_temporary_buffer(parser, output);
    return ((StateResult )0);
  }
  }
}
}
static StateResult handle_end_tag_open_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                             int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  tmp___2 = temporary_buffer_equals(parser, "</");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"</\")", "deps/gumbo-parser/tokenizer.c",
                  1044U, "handle_end_tag_open_state");
  }
  switch (c) {
  case 62: 
  add_parse_error___0(parser, (GumboErrorType )11);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )12);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tmp___3 = emit_temporary_buffer(parser, output);
  return ((StateResult )tmp___3);
  default: 
  tmp___4 = is_alpha(c);
  if (tmp___4) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )9);
    start_new_tag(parser, (_Bool)0);
  } else {
    add_parse_error___0(parser, (GumboErrorType )13);
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )43);
    clear_temporary_buffer(parser);
    append_char_to_temporary_buffer(parser, c);
  }
  return ((StateResult )2);
  }
}
}
static StateResult handle_tag_name_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                         int c , GumboToken *output ) 
{ 
  StateResult tmp ;
  int tmp___0 ;

  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  finish_tag_name(parser);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )33);
  return ((StateResult )2);
  case 47: 
  finish_tag_name(parser);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )42);
  return ((StateResult )2);
  case 62: 
  finish_tag_name(parser);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tmp = emit_current_tag(parser, output);
  return (tmp);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  append_char_to_tag_buffer(parser, (int )kUtf8ReplacementChar, (_Bool)1);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )9);
  abandon_current_tag(parser);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  return ((StateResult )2);
  default: 
  tmp___0 = ensure_lowercase(c);
  append_char_to_tag_buffer(parser, tmp___0, (_Bool)1);
  return ((StateResult )2);
  }
}
}
static StateResult handle_rcdata_lt_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                          int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  tmp___2 = temporary_buffer_equals(parser, "<");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"<\")", "deps/gumbo-parser/tokenizer.c",
                  1107U, "handle_rcdata_lt_state");
  }
  if (c == 47) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )11);
    append_char_to_temporary_buffer(parser, '/');
    return ((StateResult )2);
  } else {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )2);
    tokenizer->_reconsume_current_input = (_Bool)1;
    tmp___3 = emit_temporary_buffer(parser, output);
    return ((StateResult )tmp___3);
  }
}
}
static StateResult handle_rcdata_end_tag_open_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                    int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  tmp___2 = temporary_buffer_equals(parser, "</");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"</\")", "deps/gumbo-parser/tokenizer.c",
                  1123U, "handle_rcdata_end_tag_open_state");
  }
  tmp___4 = is_alpha(c);
  if (tmp___4) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )12);
    start_new_tag(parser, (_Bool)0);
    append_char_to_temporary_buffer(parser, c);
    return ((StateResult )2);
  } else {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )2);
    tmp___3 = emit_temporary_buffer(parser, output);
    return ((StateResult )tmp___3);
  }
  return ((StateResult )1);
}
}
static StateResult handle_rcdata_end_tag_name_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                    int c , GumboToken *output ) 
{ 
  int tmp___0 ;
  StateResult tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  if (! (tokenizer->_temporary_buffer.length >= 2UL)) {
    __assert_fail("tokenizer->_temporary_buffer.length >= 2", "deps/gumbo-parser/tokenizer.c",
                  1140U, "handle_rcdata_end_tag_name_state");
  }
  tmp___3 = is_alpha(c);
  if (tmp___3) {
    tmp___0 = ensure_lowercase(c);
    append_char_to_tag_buffer(parser, tmp___0, (_Bool)1);
    append_char_to_temporary_buffer(parser, c);
    return ((StateResult )2);
  } else {
    tmp___2 = is_appropriate_end_tag(parser);
    if (tmp___2) {
      switch (c) {
      case 32: 
      case 12: 
      case 10: 
      case 9: 
      finish_tag_name(parser);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )33);
      return ((StateResult )2);
      case 47: 
      finish_tag_name(parser);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )42);
      return ((StateResult )2);
      case 62: 
      finish_tag_name(parser);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
      tmp___1 = emit_current_tag(parser, output);
      return (tmp___1);
      }
    }
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )2);
  abandon_current_tag(parser);
  tmp___4 = emit_temporary_buffer(parser, output);
  return ((StateResult )tmp___4);
}
}
static StateResult handle_rawtext_lt_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                           int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  tmp___2 = temporary_buffer_equals(parser, "<");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"<\")", "deps/gumbo-parser/tokenizer.c",
                  1173U, "handle_rawtext_lt_state");
  }
  if (c == 47) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )14);
    append_char_to_temporary_buffer(parser, '/');
    return ((StateResult )2);
  } else {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )4);
    tokenizer->_reconsume_current_input = (_Bool)1;
    tmp___3 = emit_temporary_buffer(parser, output);
    return ((StateResult )tmp___3);
  }
}
}
static StateResult handle_rawtext_end_tag_open_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                     int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  tmp___2 = temporary_buffer_equals(parser, "</");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"</\")", "deps/gumbo-parser/tokenizer.c",
                  1189U, "handle_rawtext_end_tag_open_state");
  }
  tmp___4 = is_alpha(c);
  if (tmp___4) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )15);
    start_new_tag(parser, (_Bool)0);
    append_char_to_temporary_buffer(parser, c);
    return ((StateResult )2);
  } else {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )4);
    tmp___3 = emit_temporary_buffer(parser, output);
    return ((StateResult )tmp___3);
  }
}
}
static StateResult handle_rawtext_end_tag_name_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                     int c , GumboToken *output ) 
{ 
  int tmp___0 ;
  StateResult tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  if (! (tokenizer->_temporary_buffer.length >= 2UL)) {
    __assert_fail("tokenizer->_temporary_buffer.length >= 2", "deps/gumbo-parser/tokenizer.c",
                  1205U, "handle_rawtext_end_tag_name_state");
  }
  gumbo_debug("Last end tag: %*s\n", (int )tokenizer->_tag_state._buffer.length, tokenizer->_tag_state._buffer.data);
  tmp___3 = is_alpha(c);
  if (tmp___3) {
    tmp___0 = ensure_lowercase(c);
    append_char_to_tag_buffer(parser, tmp___0, (_Bool)1);
    append_char_to_temporary_buffer(parser, c);
    return ((StateResult )2);
  } else {
    tmp___2 = is_appropriate_end_tag(parser);
    if (tmp___2) {
      gumbo_debug("Is an appropriate end tag.\n");
      switch (c) {
      case 32: 
      case 12: 
      case 10: 
      case 9: 
      finish_tag_name(parser);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )33);
      return ((StateResult )2);
      case 47: 
      finish_tag_name(parser);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )42);
      return ((StateResult )2);
      case 62: 
      finish_tag_name(parser);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
      tmp___1 = emit_current_tag(parser, output);
      return (tmp___1);
      }
    }
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )4);
  abandon_current_tag(parser);
  tmp___4 = emit_temporary_buffer(parser, output);
  return ((StateResult )tmp___4);
}
}
static StateResult handle_script_lt_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                          int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  tmp___2 = temporary_buffer_equals(parser, "<");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"<\")", "deps/gumbo-parser/tokenizer.c",
                  1241U, "handle_script_lt_state");
  }
  if (c == 47) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )17);
    append_char_to_temporary_buffer(parser, '/');
    return ((StateResult )2);
  } else
  if (c == 33) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )19);
    append_char_to_temporary_buffer(parser, '!');
    tmp___3 = emit_temporary_buffer(parser, output);
    return ((StateResult )tmp___3);
  } else {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )5);
    tokenizer->_reconsume_current_input = (_Bool)1;
    tmp___4 = emit_temporary_buffer(parser, output);
    return ((StateResult )tmp___4);
  }
}
}
static StateResult handle_script_end_tag_open_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                    int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  tmp___2 = temporary_buffer_equals(parser, "</");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"</\")", "deps/gumbo-parser/tokenizer.c",
                  1261U, "handle_script_end_tag_open_state");
  }
  tmp___4 = is_alpha(c);
  if (tmp___4) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )18);
    start_new_tag(parser, (_Bool)0);
    append_char_to_temporary_buffer(parser, c);
    return ((StateResult )2);
  } else {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )5);
    tmp___3 = emit_temporary_buffer(parser, output);
    return ((StateResult )tmp___3);
  }
}
}
static StateResult handle_script_end_tag_name_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                    int c , GumboToken *output ) 
{ 
  int tmp___0 ;
  StateResult tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  if (! (tokenizer->_temporary_buffer.length >= 2UL)) {
    __assert_fail("tokenizer->_temporary_buffer.length >= 2", "deps/gumbo-parser/tokenizer.c",
                  1277U, "handle_script_end_tag_name_state");
  }
  tmp___3 = is_alpha(c);
  if (tmp___3) {
    tmp___0 = ensure_lowercase(c);
    append_char_to_tag_buffer(parser, tmp___0, (_Bool)1);
    append_char_to_temporary_buffer(parser, c);
    return ((StateResult )2);
  } else {
    tmp___2 = is_appropriate_end_tag(parser);
    if (tmp___2) {
      switch (c) {
      case 32: 
      case 12: 
      case 10: 
      case 9: 
      finish_tag_name(parser);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )33);
      return ((StateResult )2);
      case 47: 
      finish_tag_name(parser);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )42);
      return ((StateResult )2);
      case 62: 
      finish_tag_name(parser);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
      tmp___1 = emit_current_tag(parser, output);
      return (tmp___1);
      }
    }
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )5);
  abandon_current_tag(parser);
  tmp___4 = emit_temporary_buffer(parser, output);
  return ((StateResult )tmp___4);
}
}
static StateResult handle_script_escaped_start_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                     int c , GumboToken *output ) 
{ 
  _Bool tmp ;

  {
  if (c == 45) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )20);
    tmp = emit_current_char(parser, output);
    return ((StateResult )tmp);
  } else {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )5);
    tokenizer->_reconsume_current_input = (_Bool)1;
    return ((StateResult )2);
  }
}
}
static StateResult handle_script_escaped_start_dash_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                          int c , GumboToken *output ) 
{ 
  _Bool tmp ;

  {
  if (c == 45) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )23);
    tmp = emit_current_char(parser, output);
    return ((StateResult )tmp);
  } else {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )5);
    tokenizer->_reconsume_current_input = (_Bool)1;
    return ((StateResult )2);
  }
}
}
static StateResult handle_script_escaped_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                               int c , GumboToken *output ) 
{ 
  _Bool tmp ;
  StateResult tmp___0 ;
  StateResult tmp___1 ;
  _Bool tmp___2 ;

  {
  switch (c) {
  case 45: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )22);
  tmp = emit_current_char(parser, output);
  return ((StateResult )tmp);
  case 60: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )24);
  clear_temporary_buffer(parser);
  append_char_to_temporary_buffer(parser, c);
  return ((StateResult )2);
  case 0: 
  tmp___0 = emit_replacement_char(parser, output);
  return (tmp___0);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )14);
  tmp___1 = emit_eof(parser, output);
  return (tmp___1);
  default: 
  tmp___2 = emit_current_char(parser, output);
  return ((StateResult )tmp___2);
  }
}
}
static StateResult handle_script_escaped_dash_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                    int c , GumboToken *output ) 
{ 
  _Bool tmp ;
  StateResult tmp___0 ;
  _Bool tmp___1 ;

  {
  switch (c) {
  case 45: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )23);
  tmp = emit_current_char(parser, output);
  return ((StateResult )tmp);
  case 60: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )24);
  clear_temporary_buffer(parser);
  append_char_to_temporary_buffer(parser, c);
  return ((StateResult )2);
  case 0: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )21);
  tmp___0 = emit_replacement_char(parser, output);
  return (tmp___0);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )14);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  return ((StateResult )2);
  default: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )21);
  tmp___1 = emit_current_char(parser, output);
  return ((StateResult )tmp___1);
  }
}
}
static StateResult handle_script_escaped_dash_dash_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                         int c , GumboToken *output ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  StateResult tmp___1 ;
  _Bool tmp___2 ;

  {
  switch (c) {
  case 45: 
  tmp = emit_current_char(parser, output);
  return ((StateResult )tmp);
  case 60: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )24);
  clear_temporary_buffer(parser);
  append_char_to_temporary_buffer(parser, c);
  return ((StateResult )2);
  case 62: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )5);
  tmp___0 = emit_current_char(parser, output);
  return ((StateResult )tmp___0);
  case 0: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )21);
  tmp___1 = emit_replacement_char(parser, output);
  return (tmp___1);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )14);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  return ((StateResult )2);
  default: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )21);
  tmp___2 = emit_current_char(parser, output);
  return ((StateResult )tmp___2);
  }
}
}
static StateResult handle_script_escaped_lt_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                  int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;

  {
  tmp___2 = temporary_buffer_equals(parser, "<");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"<\")", "deps/gumbo-parser/tokenizer.c",
                  1415U, "handle_script_escaped_lt_state");
  }
  if (! (! tokenizer->_script_data_buffer.length)) {
    __assert_fail("!tokenizer->_script_data_buffer.length", "deps/gumbo-parser/tokenizer.c",
                  1416U, "handle_script_escaped_lt_state");
  }
  if (c == 47) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )25);
    append_char_to_temporary_buffer(parser, c);
    return ((StateResult )2);
  } else {
    tmp___7 = is_alpha(c);
    if (tmp___7) {
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )27);
      append_char_to_temporary_buffer(parser, c);
      tmp___4 = ensure_lowercase(c);
      gumbo_string_buffer_append_codepoint(parser, tmp___4, & tokenizer->_script_data_buffer);
      tmp___5 = emit_temporary_buffer(parser, output);
      return ((StateResult )tmp___5);
    } else {
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )21);
      tmp___6 = emit_temporary_buffer(parser, output);
      return ((StateResult )tmp___6);
    }
  }
}
}
static StateResult handle_script_escaped_end_tag_open_state(GumboParser *parser ,
                                                            GumboTokenizerState *tokenizer ,
                                                            int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  tmp___2 = temporary_buffer_equals(parser, "</");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"</\")", "deps/gumbo-parser/tokenizer.c",
                  1437U, "handle_script_escaped_end_tag_open_state");
  }
  tmp___4 = is_alpha(c);
  if (tmp___4) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )26);
    start_new_tag(parser, (_Bool)0);
    append_char_to_temporary_buffer(parser, c);
    return ((StateResult )2);
  } else {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )21);
    tmp___3 = emit_temporary_buffer(parser, output);
    return ((StateResult )tmp___3);
  }
}
}
static StateResult handle_script_escaped_end_tag_name_state(GumboParser *parser ,
                                                            GumboTokenizerState *tokenizer ,
                                                            int c , GumboToken *output ) 
{ 
  int tmp___0 ;
  StateResult tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  if (! (tokenizer->_temporary_buffer.length >= 2UL)) {
    __assert_fail("tokenizer->_temporary_buffer.length >= 2", "deps/gumbo-parser/tokenizer.c",
                  1453U, "handle_script_escaped_end_tag_name_state");
  }
  tmp___3 = is_alpha(c);
  if (tmp___3) {
    tmp___0 = ensure_lowercase(c);
    append_char_to_tag_buffer(parser, tmp___0, (_Bool)1);
    append_char_to_temporary_buffer(parser, c);
    return ((StateResult )2);
  } else {
    tmp___2 = is_appropriate_end_tag(parser);
    if (tmp___2) {
      switch (c) {
      case 32: 
      case 12: 
      case 10: 
      case 9: 
      finish_tag_name(parser);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )33);
      return ((StateResult )2);
      case 47: 
      finish_tag_name(parser);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )42);
      return ((StateResult )2);
      case 62: 
      finish_tag_name(parser);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
      tmp___1 = emit_current_tag(parser, output);
      return (tmp___1);
      }
    }
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )21);
  abandon_current_tag(parser);
  tmp___4 = emit_temporary_buffer(parser, output);
  return ((StateResult )tmp___4);
}
}
static StateResult handle_script_double_escaped_start_state(GumboParser *parser ,
                                                            GumboTokenizerState *tokenizer ,
                                                            int c , GumboToken *output ) 
{ 
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
  switch (c) {
  case 62: 
  case 47: 
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  tmp___1 = gumbo_string_equals(& kScriptTag, (GumboStringPiece const   *)((GumboStringPiece *)(& tokenizer->_script_data_buffer)));
  if (tmp___1) {
    tmp___0 = 28;
  } else {
    tmp___0 = 21;
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )tmp___0);
  tmp___2 = emit_current_char(parser, output);
  return ((StateResult )tmp___2);
  default: 
  tmp___5 = is_alpha(c);
  if (tmp___5) {
    tmp___3 = ensure_lowercase(c);
    gumbo_string_buffer_append_codepoint(parser, tmp___3, & tokenizer->_script_data_buffer);
    tmp___4 = emit_current_char(parser, output);
    return ((StateResult )tmp___4);
  } else {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )21);
    tokenizer->_reconsume_current_input = (_Bool)1;
    return ((StateResult )2);
  }
  }
}
}
static StateResult handle_script_double_escaped_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                      int c , GumboToken *output ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  StateResult tmp___1 ;
  _Bool tmp___2 ;

  {
  switch (c) {
  case 45: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )29);
  tmp = emit_current_char(parser, output);
  return ((StateResult )tmp);
  case 60: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )31);
  tmp___0 = emit_current_char(parser, output);
  return ((StateResult )tmp___0);
  case 0: 
  tmp___1 = emit_replacement_char(parser, output);
  return (tmp___1);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )14);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  return ((StateResult )2);
  default: 
  tmp___2 = emit_current_char(parser, output);
  return ((StateResult )tmp___2);
  }
}
}
static StateResult handle_script_double_escaped_dash_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                           int c , GumboToken *output ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  StateResult tmp___1 ;
  _Bool tmp___2 ;

  {
  switch (c) {
  case 45: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )30);
  tmp = emit_current_char(parser, output);
  return ((StateResult )tmp);
  case 60: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )31);
  tmp___0 = emit_current_char(parser, output);
  return ((StateResult )tmp___0);
  case 0: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )28);
  tmp___1 = emit_replacement_char(parser, output);
  return (tmp___1);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )14);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  return ((StateResult )2);
  default: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )28);
  tmp___2 = emit_current_char(parser, output);
  return ((StateResult )tmp___2);
  }
}
}
static StateResult handle_script_double_escaped_dash_dash_state(GumboParser *parser ,
                                                                GumboTokenizerState *tokenizer ,
                                                                int c , GumboToken *output ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  StateResult tmp___2 ;
  _Bool tmp___3 ;

  {
  switch (c) {
  case 45: 
  tmp = emit_current_char(parser, output);
  return ((StateResult )tmp);
  case 60: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )31);
  tmp___0 = emit_current_char(parser, output);
  return ((StateResult )tmp___0);
  case 62: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )5);
  tmp___1 = emit_current_char(parser, output);
  return ((StateResult )tmp___1);
  case 0: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )28);
  tmp___2 = emit_replacement_char(parser, output);
  return (tmp___2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )14);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  return ((StateResult )2);
  default: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )28);
  tmp___3 = emit_current_char(parser, output);
  return ((StateResult )tmp___3);
  }
}
}
static StateResult handle_script_double_escaped_lt_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                         int c , GumboToken *output ) 
{ 
  _Bool tmp ;

  {
  if (c == 47) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )32);
    gumbo_string_buffer_destroy(parser, & tokenizer->_script_data_buffer);
    gumbo_string_buffer_init(parser, & tokenizer->_script_data_buffer);
    tmp = emit_current_char(parser, output);
    return ((StateResult )tmp);
  } else {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )28);
    tokenizer->_reconsume_current_input = (_Bool)1;
    return ((StateResult )2);
  }
}
}
static StateResult handle_script_double_escaped_end_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                          int c , GumboToken *output ) 
{ 
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
  switch (c) {
  case 62: 
  case 47: 
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  tmp___1 = gumbo_string_equals(& kScriptTag, (GumboStringPiece const   *)((GumboStringPiece *)(& tokenizer->_script_data_buffer)));
  if (tmp___1) {
    tmp___0 = 21;
  } else {
    tmp___0 = 28;
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )tmp___0);
  tmp___2 = emit_current_char(parser, output);
  return ((StateResult )tmp___2);
  default: 
  tmp___5 = is_alpha(c);
  if (tmp___5) {
    tmp___3 = ensure_lowercase(c);
    gumbo_string_buffer_append_codepoint(parser, tmp___3, & tokenizer->_script_data_buffer);
    tmp___4 = emit_current_char(parser, output);
    return ((StateResult )tmp___4);
  } else {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )28);
    tokenizer->_reconsume_current_input = (_Bool)1;
    return ((StateResult )2);
  }
  }
}
}
static StateResult handle_before_attr_name_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                 int c , GumboToken *output ) 
{ 
  StateResult tmp ;
  int tmp___0 ;

  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  return ((StateResult )2);
  case 47: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )42);
  return ((StateResult )2);
  case 62: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tmp = emit_current_tag(parser, output);
  return (tmp);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )34);
  append_char_to_temporary_buffer(parser, 65533);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )15);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  abandon_current_tag(parser);
  return ((StateResult )2);
  case 61: 
  case 60: 
  case 39: 
  case 34: 
  add_parse_error___0(parser, (GumboErrorType )16);
  default: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )34);
  tmp___0 = ensure_lowercase(c);
  append_char_to_tag_buffer(parser, tmp___0, (_Bool)1);
  return ((StateResult )2);
  }
}
}
static StateResult handle_attr_name_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                          int c , GumboToken *output ) 
{ 
  StateResult tmp ;
  int tmp___0 ;

  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  finish_attribute_name(parser);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )35);
  return ((StateResult )2);
  case 47: 
  finish_attribute_name(parser);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )42);
  return ((StateResult )2);
  case 61: 
  finish_attribute_name(parser);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )36);
  return ((StateResult )2);
  case 62: 
  finish_attribute_name(parser);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tmp = emit_current_tag(parser, output);
  return (tmp);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  append_char_to_tag_buffer(parser, (int )kUtf8ReplacementChar, (_Bool)1);
  return ((StateResult )2);
  case -1: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  abandon_current_tag(parser);
  add_parse_error___0(parser, (GumboErrorType )15);
  return ((StateResult )2);
  case 60: 
  case 39: 
  case 34: 
  add_parse_error___0(parser, (GumboErrorType )16);
  default: 
  tmp___0 = ensure_lowercase(c);
  append_char_to_tag_buffer(parser, tmp___0, (_Bool)1);
  return ((StateResult )2);
  }
}
}
static StateResult handle_after_attr_name_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                int c , GumboToken *output ) 
{ 
  StateResult tmp ;
  int tmp___0 ;

  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  return ((StateResult )2);
  case 47: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )42);
  return ((StateResult )2);
  case 61: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )36);
  return ((StateResult )2);
  case 62: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tmp = emit_current_tag(parser, output);
  return (tmp);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )34);
  append_char_to_temporary_buffer(parser, 65533);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )15);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  abandon_current_tag(parser);
  return ((StateResult )2);
  case 60: 
  case 39: 
  case 34: 
  add_parse_error___0(parser, (GumboErrorType )16);
  default: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )34);
  tmp___0 = ensure_lowercase(c);
  append_char_to_tag_buffer(parser, tmp___0, (_Bool)1);
  return ((StateResult )2);
  }
}
}
static StateResult handle_before_attr_value_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                  int c , GumboToken *output ) 
{ 


  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  return ((StateResult )2);
  case 34: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )37);
  reset_tag_buffer_start_point(parser);
  return ((StateResult )2);
  case 38: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )39);
  tokenizer->_reconsume_current_input = (_Bool)1;
  return ((StateResult )2);
  case 39: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )38);
  reset_tag_buffer_start_point(parser);
  return ((StateResult )2);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )39);
  append_char_to_tag_buffer(parser, (int )kUtf8ReplacementChar, (_Bool)1);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )19);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  abandon_current_tag(parser);
  tokenizer->_reconsume_current_input = (_Bool)1;
  return ((StateResult )2);
  case 62: 
  add_parse_error___0(parser, (GumboErrorType )20);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  emit_current_tag(parser, output);
  return ((StateResult )0);
  case 96: 
  case 61: 
  case 60: 
  add_parse_error___0(parser, (GumboErrorType )21);
  default: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )39);
  append_char_to_tag_buffer(parser, c, (_Bool)1);
  return ((StateResult )2);
  }
}
}
static StateResult handle_attr_value_double_quoted_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                         int c , GumboToken *output ) 
{ 


  {
  switch (c) {
  case 34: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )41);
  return ((StateResult )2);
  case 38: 
  tokenizer->_tag_state._attr_value_state = tokenizer->_state;
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )40);
  tokenizer->_reconsume_current_input = (_Bool)1;
  return ((StateResult )2);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  append_char_to_tag_buffer(parser, (int )kUtf8ReplacementChar, (_Bool)0);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )17);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  abandon_current_tag(parser);
  tokenizer->_reconsume_current_input = (_Bool)1;
  return ((StateResult )2);
  default: 
  append_char_to_tag_buffer(parser, c, (_Bool)0);
  return ((StateResult )2);
  }
}
}
static StateResult handle_attr_value_single_quoted_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                         int c , GumboToken *output ) 
{ 


  {
  switch (c) {
  case 39: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )41);
  return ((StateResult )2);
  case 38: 
  tokenizer->_tag_state._attr_value_state = tokenizer->_state;
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )40);
  tokenizer->_reconsume_current_input = (_Bool)1;
  return ((StateResult )2);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  append_char_to_tag_buffer(parser, (int )kUtf8ReplacementChar, (_Bool)0);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )18);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  abandon_current_tag(parser);
  tokenizer->_reconsume_current_input = (_Bool)1;
  return ((StateResult )2);
  default: 
  append_char_to_tag_buffer(parser, c, (_Bool)0);
  return ((StateResult )2);
  }
}
}
static StateResult handle_attr_value_unquoted_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                    int c , GumboToken *output ) 
{ 
  StateResult tmp ;

  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )33);
  finish_attribute_value(parser);
  return ((StateResult )2);
  case 38: 
  tokenizer->_tag_state._attr_value_state = tokenizer->_state;
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )40);
  tokenizer->_reconsume_current_input = (_Bool)1;
  return ((StateResult )2);
  case 62: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  finish_attribute_value(parser);
  tmp = emit_current_tag(parser, output);
  return (tmp);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  append_char_to_tag_buffer(parser, (int )kUtf8ReplacementChar, (_Bool)1);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )19);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_reconsume_current_input = (_Bool)1;
  abandon_current_tag(parser);
  return ((StateResult )2);
  case 96: 
  case 39: 
  case 34: 
  case 61: 
  case 60: 
  add_parse_error___0(parser, (GumboErrorType )21);
  default: 
  append_char_to_tag_buffer(parser, c, (_Bool)1);
  return ((StateResult )2);
  }
}
}
static StateResult handle_char_ref_in_attr_value_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                       int c , GumboToken *output ) 
{ 
  OneOrTwoCodepoints char_ref ;
  int allowed_char ;
  _Bool is_unquoted ;

  {
  is_unquoted = (_Bool)0;
  switch ((unsigned int )tokenizer->_tag_state._attr_value_state) {
  case 37U: 
  allowed_char = '\"';
  break;
  case 38U: 
  allowed_char = '\'';
  break;
  case 39U: 
  allowed_char = '>';
  is_unquoted = (_Bool)1;
  break;
  default: 
  allowed_char = ' ';
  __assert_fail("0", "deps/gumbo-parser/tokenizer.c", 1926U, "handle_char_ref_in_attr_value_state");
  }
  consume_char_ref(parser, & tokenizer->_input, allowed_char, (_Bool)1, & char_ref);
  if (char_ref.first != (int )kGumboNoChar) {
    tokenizer->_reconsume_current_input = (_Bool)1;
    append_char_to_tag_buffer(parser, char_ref.first, is_unquoted);
    if (char_ref.second != (int )kGumboNoChar) {
      append_char_to_tag_buffer(parser, char_ref.second, is_unquoted);
    }
  } else {
    append_char_to_tag_buffer(parser, '&', is_unquoted);
  }
  gumbo_tokenizer_set_state(parser, tokenizer->_tag_state._attr_value_state);
  return ((StateResult )2);
}
}
static StateResult handle_after_attr_value_quoted_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                        int c , GumboToken *output ) 
{ 
  StateResult tmp ;

  {
  finish_attribute_value(parser);
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )33);
  return ((StateResult )2);
  case 47: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )42);
  return ((StateResult )2);
  case 62: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tmp = emit_current_tag(parser, output);
  return (tmp);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )22);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  abandon_current_tag(parser);
  tokenizer->_reconsume_current_input = (_Bool)1;
  return ((StateResult )2);
  default: 
  add_parse_error___0(parser, (GumboErrorType )23);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )33);
  tokenizer->_reconsume_current_input = (_Bool)1;
  return ((StateResult )2);
  }
}
}
static StateResult handle_self_closing_start_tag_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                       int c , GumboToken *output ) 
{ 
  StateResult tmp ;

  {
  switch (c) {
  case 62: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_tag_state._is_self_closing = (_Bool)1;
  tmp = emit_current_tag(parser, output);
  return (tmp);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )25);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  abandon_current_tag(parser);
  return ((StateResult )2);
  default: 
  add_parse_error___0(parser, (GumboErrorType )26);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )33);
  tokenizer->_reconsume_current_input = (_Bool)1;
  return ((StateResult )2);
  }
}
}
static StateResult handle_bogus_comment_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                              int c , GumboToken *output ) 
{ 
  StateResult tmp ;

  {
  while (1) {
    if (c != 62) {
      if (! (c != -1)) {
        break;
      }
    } else {
      break;
    }
    if (c == 0) {
      c = 65533;
    }
    append_char_to_temporary_buffer(parser, c);
    utf8iterator_next(& tokenizer->_input);
    c = utf8iterator_current((Utf8Iterator const   *)(& tokenizer->_input));
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tmp = emit_comment(parser, output);
  return (tmp);
}
}
static StateResult handle_markup_declaration_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                   int c , GumboToken *output ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  tmp___4 = utf8iterator_maybe_consume_match(& tokenizer->_input, "--", sizeof("--") - 1UL,
                                             (_Bool)1);
  if (tmp___4) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )45);
    tokenizer->_reconsume_current_input = (_Bool)1;
  } else {
    tmp___3 = utf8iterator_maybe_consume_match(& tokenizer->_input, "DOCTYPE", sizeof("DOCTYPE") - 1UL,
                                               (_Bool)0);
    if (tmp___3) {
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )51);
      tokenizer->_reconsume_current_input = (_Bool)1;
      tmp = gumbo_copy_stringz(parser, "");
      tokenizer->_doc_type_state.name = (char const   *)tmp;
      tmp___0 = gumbo_copy_stringz(parser, "");
      tokenizer->_doc_type_state.public_identifier = (char const   *)tmp___0;
      tmp___1 = gumbo_copy_stringz(parser, "");
      tokenizer->_doc_type_state.system_identifier = (char const   *)tmp___1;
    } else
    if (tokenizer->_is_current_node_foreign) {
      tmp___2 = utf8iterator_maybe_consume_match(& tokenizer->_input, "[CDATA[", sizeof("[CDATA[") - 1UL,
                                                 (_Bool)1);
      if (tmp___2) {
        gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )67);
        tokenizer->_reconsume_current_input = (_Bool)1;
      } else {
        add_parse_error___0(parser, (GumboErrorType )27);
        gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )43);
        tokenizer->_reconsume_current_input = (_Bool)1;
        clear_temporary_buffer(parser);
      }
    } else {
      add_parse_error___0(parser, (GumboErrorType )27);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )43);
      tokenizer->_reconsume_current_input = (_Bool)1;
      clear_temporary_buffer(parser);
    }
  }
  return ((StateResult )2);
}
}
static StateResult handle_comment_start_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                              int c , GumboToken *output ) 
{ 


  {
  switch (c) {
  case 45: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )46);
  return ((StateResult )2);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )47);
  append_char_to_temporary_buffer(parser, (int )kUtf8ReplacementChar);
  return ((StateResult )2);
  case 62: 
  add_parse_error___0(parser, (GumboErrorType )29);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  emit_comment(parser, output);
  return ((StateResult )0);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )28);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  emit_comment(parser, output);
  return ((StateResult )0);
  default: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )47);
  append_char_to_temporary_buffer(parser, c);
  return ((StateResult )2);
  }
}
}
static StateResult handle_comment_start_dash_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                   int c , GumboToken *output ) 
{ 


  {
  switch (c) {
  case 45: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )49);
  return ((StateResult )2);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )47);
  append_char_to_temporary_buffer(parser, '-');
  append_char_to_temporary_buffer(parser, (int )kUtf8ReplacementChar);
  return ((StateResult )2);
  case 62: 
  add_parse_error___0(parser, (GumboErrorType )29);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  emit_comment(parser, output);
  return ((StateResult )0);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )28);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  emit_comment(parser, output);
  return ((StateResult )0);
  default: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )47);
  append_char_to_temporary_buffer(parser, '-');
  append_char_to_temporary_buffer(parser, c);
  return ((StateResult )2);
  }
}
}
static StateResult handle_comment_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                        int c , GumboToken *output ) 
{ 


  {
  switch (c) {
  case 45: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )48);
  return ((StateResult )2);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  append_char_to_temporary_buffer(parser, (int )kUtf8ReplacementChar);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )28);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  emit_comment(parser, output);
  return ((StateResult )0);
  default: 
  append_char_to_temporary_buffer(parser, c);
  return ((StateResult )2);
  }
}
}
static StateResult handle_comment_end_dash_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                 int c , GumboToken *output ) 
{ 


  {
  switch (c) {
  case 45: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )49);
  return ((StateResult )2);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )47);
  append_char_to_temporary_buffer(parser, '-');
  append_char_to_temporary_buffer(parser, (int )kUtf8ReplacementChar);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )28);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  emit_comment(parser, output);
  return ((StateResult )0);
  default: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )47);
  append_char_to_temporary_buffer(parser, '-');
  append_char_to_temporary_buffer(parser, c);
  return ((StateResult )2);
  }
}
}
static StateResult handle_comment_end_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                            int c , GumboToken *output ) 
{ 
  StateResult tmp ;

  {
  switch (c) {
  case 62: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tmp = emit_comment(parser, output);
  return (tmp);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )47);
  append_char_to_temporary_buffer(parser, '-');
  append_char_to_temporary_buffer(parser, '-');
  append_char_to_temporary_buffer(parser, (int )kUtf8ReplacementChar);
  return ((StateResult )2);
  case 33: 
  add_parse_error___0(parser, (GumboErrorType )30);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )50);
  return ((StateResult )2);
  case 45: 
  add_parse_error___0(parser, (GumboErrorType )31);
  append_char_to_temporary_buffer(parser, '-');
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )2);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  emit_comment(parser, output);
  return ((StateResult )0);
  default: 
  add_parse_error___0(parser, (GumboErrorType )29);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )47);
  append_char_to_temporary_buffer(parser, '-');
  append_char_to_temporary_buffer(parser, '-');
  append_char_to_temporary_buffer(parser, c);
  return ((StateResult )2);
  }
}
}
static StateResult handle_comment_end_bang_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                 int c , GumboToken *output ) 
{ 
  StateResult tmp ;

  {
  switch (c) {
  case 45: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )48);
  append_char_to_temporary_buffer(parser, '-');
  append_char_to_temporary_buffer(parser, '-');
  append_char_to_temporary_buffer(parser, '!');
  return ((StateResult )2);
  case 62: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tmp = emit_comment(parser, output);
  return (tmp);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )47);
  append_char_to_temporary_buffer(parser, '-');
  append_char_to_temporary_buffer(parser, '-');
  append_char_to_temporary_buffer(parser, '!');
  append_char_to_temporary_buffer(parser, (int )kUtf8ReplacementChar);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )33);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  emit_comment(parser, output);
  return ((StateResult )0);
  default: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )47);
  append_char_to_temporary_buffer(parser, '-');
  append_char_to_temporary_buffer(parser, '-');
  append_char_to_temporary_buffer(parser, '!');
  append_char_to_temporary_buffer(parser, c);
  return ((StateResult )2);
  }
}
}
static StateResult handle_doctype_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                        int c , GumboToken *output ) 
{ 


  {
  if (! (! tokenizer->_temporary_buffer.length)) {
    __assert_fail("!tokenizer->_temporary_buffer.length", "deps/gumbo-parser/tokenizer.c",
                  2243U, "handle_doctype_state");
  }
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )52);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )34);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  default: 
  add_parse_error___0(parser, (GumboErrorType )36);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )52);
  tokenizer->_reconsume_current_input = (_Bool)1;
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  return ((StateResult )2);
  }
}
}
static StateResult handle_before_doctype_name_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                    int c , GumboToken *output ) 
{ 
  int tmp ;

  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  return ((StateResult )2);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )53);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  append_char_to_temporary_buffer(parser, (int )kUtf8ReplacementChar);
  return ((StateResult )2);
  case 62: 
  add_parse_error___0(parser, (GumboErrorType )37);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )34);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  default: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )53);
  tokenizer->_doc_type_state.force_quirks = (_Bool)0;
  tmp = ensure_lowercase(c);
  append_char_to_temporary_buffer(parser, tmp);
  return ((StateResult )2);
  }
}
}
static StateResult handle_doctype_name_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                             int c , GumboToken *output ) 
{ 
  int tmp ;

  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )54);
  gumbo_parser_deallocate(parser, (void *)tokenizer->_doc_type_state.name);
  finish_temporary_buffer(parser, & tokenizer->_doc_type_state.name);
  return ((StateResult )2);
  case 62: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  gumbo_parser_deallocate(parser, (void *)tokenizer->_doc_type_state.name);
  finish_temporary_buffer(parser, & tokenizer->_doc_type_state.name);
  emit_doctype(parser, output);
  return ((StateResult )1);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  append_char_to_temporary_buffer(parser, (int )kUtf8ReplacementChar);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )34);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  gumbo_parser_deallocate(parser, (void *)tokenizer->_doc_type_state.name);
  finish_temporary_buffer(parser, & tokenizer->_doc_type_state.name);
  emit_doctype(parser, output);
  return ((StateResult )0);
  default: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )53);
  tokenizer->_doc_type_state.force_quirks = (_Bool)0;
  tmp = ensure_lowercase(c);
  append_char_to_temporary_buffer(parser, tmp);
  return ((StateResult )2);
  }
}
}
static StateResult handle_after_doctype_name_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                   int c , GumboToken *output ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  return ((StateResult )2);
  case 62: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  emit_doctype(parser, output);
  return ((StateResult )1);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )34);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  default: 
  tmp___0 = utf8iterator_maybe_consume_match(& tokenizer->_input, "PUBLIC", sizeof("PUBLIC") - 1UL,
                                             (_Bool)0);
  if (tmp___0) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )55);
    tokenizer->_reconsume_current_input = (_Bool)1;
  } else {
    tmp = utf8iterator_maybe_consume_match(& tokenizer->_input, "SYSTEM", sizeof("SYSTEM") - 1UL,
                                           (_Bool)0);
    if (tmp) {
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )61);
      tokenizer->_reconsume_current_input = (_Bool)1;
    } else {
      add_parse_error___0(parser, (GumboErrorType )38);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )66);
      tokenizer->_doc_type_state.force_quirks = (_Bool)1;
    }
  }
  return ((StateResult )2);
  }
}
}
static StateResult handle_after_doctype_public_keyword_state(GumboParser *parser ,
                                                             GumboTokenizerState *tokenizer ,
                                                             int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___6 ;

  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )56);
  return ((StateResult )2);
  case 34: 
  add_parse_error___0(parser, (GumboErrorType )35);
  tmp___2 = temporary_buffer_equals(parser, "");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"\")", "deps/gumbo-parser/tokenizer.c",
                  2398U, "handle_after_doctype_public_keyword_state");
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )57);
  return ((StateResult )2);
  case 39: 
  add_parse_error___0(parser, (GumboErrorType )35);
  tmp___6 = temporary_buffer_equals(parser, "");
  if (! tmp___6) {
    __assert_fail("temporary_buffer_equals(parser, \"\")", "deps/gumbo-parser/tokenizer.c",
                  2404U, "handle_after_doctype_public_keyword_state");
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )58);
  return ((StateResult )2);
  case 62: 
  add_parse_error___0(parser, (GumboErrorType )37);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )34);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  default: 
  add_parse_error___0(parser, (GumboErrorType )35);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )66);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  }
}
}
static StateResult handle_before_doctype_public_id_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                         int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___6 ;

  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  return ((StateResult )2);
  case 34: 
  tmp___2 = temporary_buffer_equals(parser, "");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"\")", "deps/gumbo-parser/tokenizer.c",
                  2440U, "handle_before_doctype_public_id_state");
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )57);
  return ((StateResult )2);
  case 39: 
  tmp___6 = temporary_buffer_equals(parser, "");
  if (! tmp___6) {
    __assert_fail("temporary_buffer_equals(parser, \"\")", "deps/gumbo-parser/tokenizer.c",
                  2445U, "handle_before_doctype_public_id_state");
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )58);
  return ((StateResult )2);
  case 62: 
  add_parse_error___0(parser, (GumboErrorType )39);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )34);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  default: 
  add_parse_error___0(parser, (GumboErrorType )35);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )66);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  }
}
}
static StateResult handle_doctype_public_id_double_quoted_state(GumboParser *parser ,
                                                                GumboTokenizerState *tokenizer ,
                                                                int c , GumboToken *output ) 
{ 


  {
  switch (c) {
  case 34: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )59);
  finish_doctype_public_id(parser);
  return ((StateResult )2);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  append_char_to_temporary_buffer(parser, (int )kUtf8ReplacementChar);
  return ((StateResult )2);
  case 62: 
  add_parse_error___0(parser, (GumboErrorType )39);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  finish_doctype_public_id(parser);
  emit_doctype(parser, output);
  return ((StateResult )0);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )34);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  finish_doctype_public_id(parser);
  emit_doctype(parser, output);
  return ((StateResult )0);
  default: 
  append_char_to_temporary_buffer(parser, c);
  return ((StateResult )2);
  }
}
}
static StateResult handle_doctype_public_id_single_quoted_state(GumboParser *parser ,
                                                                GumboTokenizerState *tokenizer ,
                                                                int c , GumboToken *output ) 
{ 


  {
  switch (c) {
  case 39: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )59);
  finish_doctype_public_id(parser);
  return ((StateResult )2);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  append_char_to_temporary_buffer(parser, (int )kUtf8ReplacementChar);
  return ((StateResult )2);
  case 62: 
  add_parse_error___0(parser, (GumboErrorType )39);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  finish_doctype_public_id(parser);
  emit_doctype(parser, output);
  return ((StateResult )0);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )34);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  finish_doctype_public_id(parser);
  emit_doctype(parser, output);
  return ((StateResult )0);
  default: 
  append_char_to_temporary_buffer(parser, c);
  return ((StateResult )2);
  }
}
}
static StateResult handle_after_doctype_public_id_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                        int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___6 ;

  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )60);
  return ((StateResult )2);
  case 62: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  emit_doctype(parser, output);
  return ((StateResult )1);
  case 34: 
  add_parse_error___0(parser, (GumboErrorType )35);
  tmp___2 = temporary_buffer_equals(parser, "");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"\")", "deps/gumbo-parser/tokenizer.c",
                  2554U, "handle_after_doctype_public_id_state");
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )63);
  return ((StateResult )2);
  case 39: 
  add_parse_error___0(parser, (GumboErrorType )35);
  tmp___6 = temporary_buffer_equals(parser, "");
  if (! tmp___6) {
    __assert_fail("temporary_buffer_equals(parser, \"\")", "deps/gumbo-parser/tokenizer.c",
                  2560U, "handle_after_doctype_public_id_state");
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )64);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )34);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_reconsume_current_input = (_Bool)1;
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  return ((StateResult )2);
  default: 
  add_parse_error___0(parser, (GumboErrorType )35);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )66);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  return ((StateResult )2);
  }
}
}
static StateResult handle_between_doctype_public_system_id_state(GumboParser *parser ,
                                                                 GumboTokenizerState *tokenizer ,
                                                                 int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___6 ;

  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  return ((StateResult )2);
  case 62: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  emit_doctype(parser, output);
  return ((StateResult )1);
  case 34: 
  tmp___2 = temporary_buffer_equals(parser, "");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"\")", "deps/gumbo-parser/tokenizer.c",
                  2593U, "handle_between_doctype_public_system_id_state");
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )63);
  return ((StateResult )2);
  case 39: 
  tmp___6 = temporary_buffer_equals(parser, "");
  if (! tmp___6) {
    __assert_fail("temporary_buffer_equals(parser, \"\")", "deps/gumbo-parser/tokenizer.c",
                  2598U, "handle_between_doctype_public_system_id_state");
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )64);
  return ((StateResult )2);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )34);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  default: 
  add_parse_error___0(parser, (GumboErrorType )35);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )66);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  }
}
}
static StateResult handle_after_doctype_system_keyword_state(GumboParser *parser ,
                                                             GumboTokenizerState *tokenizer ,
                                                             int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___6 ;

  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )62);
  return ((StateResult )2);
  case 34: 
  add_parse_error___0(parser, (GumboErrorType )35);
  tmp___2 = temporary_buffer_equals(parser, "");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"\")", "deps/gumbo-parser/tokenizer.c",
                  2630U, "handle_after_doctype_system_keyword_state");
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )63);
  return ((StateResult )2);
  case 39: 
  add_parse_error___0(parser, (GumboErrorType )35);
  tmp___6 = temporary_buffer_equals(parser, "");
  if (! tmp___6) {
    __assert_fail("temporary_buffer_equals(parser, \"\")", "deps/gumbo-parser/tokenizer.c",
                  2636U, "handle_after_doctype_system_keyword_state");
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )64);
  return ((StateResult )2);
  case 62: 
  add_parse_error___0(parser, (GumboErrorType )39);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )34);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  default: 
  add_parse_error___0(parser, (GumboErrorType )35);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )66);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  return ((StateResult )2);
  }
}
}
static StateResult handle_before_doctype_system_id_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                         int c , GumboToken *output ) 
{ 
  _Bool tmp___2 ;
  _Bool tmp___6 ;

  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  return ((StateResult )2);
  case 34: 
  tmp___2 = temporary_buffer_equals(parser, "");
  if (! tmp___2) {
    __assert_fail("temporary_buffer_equals(parser, \"\")", "deps/gumbo-parser/tokenizer.c",
                  2671U, "handle_before_doctype_system_id_state");
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )63);
  return ((StateResult )2);
  case 39: 
  tmp___6 = temporary_buffer_equals(parser, "");
  if (! tmp___6) {
    __assert_fail("temporary_buffer_equals(parser, \"\")", "deps/gumbo-parser/tokenizer.c",
                  2676U, "handle_before_doctype_system_id_state");
  }
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )64);
  return ((StateResult )2);
  case 62: 
  add_parse_error___0(parser, (GumboErrorType )39);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )34);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  default: 
  add_parse_error___0(parser, (GumboErrorType )35);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )66);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  return ((StateResult )2);
  }
}
}
static StateResult handle_doctype_system_id_double_quoted_state(GumboParser *parser ,
                                                                GumboTokenizerState *tokenizer ,
                                                                int c , GumboToken *output ) 
{ 


  {
  switch (c) {
  case 34: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )65);
  finish_doctype_system_id(parser);
  return ((StateResult )2);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  append_char_to_temporary_buffer(parser, (int )kUtf8ReplacementChar);
  return ((StateResult )2);
  case 62: 
  add_parse_error___0(parser, (GumboErrorType )39);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  finish_doctype_system_id(parser);
  emit_doctype(parser, output);
  return ((StateResult )0);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )34);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  finish_doctype_system_id(parser);
  emit_doctype(parser, output);
  return ((StateResult )0);
  default: 
  append_char_to_temporary_buffer(parser, c);
  return ((StateResult )2);
  }
}
}
static StateResult handle_doctype_system_id_single_quoted_state(GumboParser *parser ,
                                                                GumboTokenizerState *tokenizer ,
                                                                int c , GumboToken *output ) 
{ 


  {
  switch (c) {
  case 39: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )65);
  finish_doctype_system_id(parser);
  return ((StateResult )2);
  case 0: 
  add_parse_error___0(parser, (GumboErrorType )2);
  append_char_to_temporary_buffer(parser, (int )kUtf8ReplacementChar);
  return ((StateResult )2);
  case 62: 
  add_parse_error___0(parser, (GumboErrorType )39);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  finish_doctype_system_id(parser);
  emit_doctype(parser, output);
  return ((StateResult )0);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )35);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  finish_doctype_system_id(parser);
  emit_doctype(parser, output);
  return ((StateResult )0);
  default: 
  append_char_to_temporary_buffer(parser, c);
  return ((StateResult )2);
  }
}
}
static StateResult handle_after_doctype_system_id_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                                        int c , GumboToken *output ) 
{ 


  {
  switch (c) {
  case 32: 
  case 12: 
  case 10: 
  case 9: 
  return ((StateResult )2);
  case 62: 
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  emit_doctype(parser, output);
  return ((StateResult )1);
  case -1: 
  add_parse_error___0(parser, (GumboErrorType )34);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
  tokenizer->_doc_type_state.force_quirks = (_Bool)1;
  emit_doctype(parser, output);
  return ((StateResult )0);
  default: 
  add_parse_error___0(parser, (GumboErrorType )35);
  gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )66);
  return ((StateResult )2);
  }
}
}
static StateResult handle_bogus_doctype_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                              int c , GumboToken *output ) 
{ 


  {
  if (c == 62) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
    emit_doctype(parser, output);
    return ((StateResult )0);
  } else
  if (c == -1) {
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
    emit_doctype(parser, output);
    return ((StateResult )0);
  }
  return ((StateResult )2);
}
}
static StateResult handle_cdata_state(GumboParser *parser , GumboTokenizerState *tokenizer ,
                                      int c , GumboToken *output ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  if (c == -1) {
    tokenizer->_reconsume_current_input = (_Bool)1;
    reset_token_start_point(tokenizer);
    gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
    return ((StateResult )2);
  } else {
    tmp___0 = utf8iterator_maybe_consume_match(& tokenizer->_input, "]]>", sizeof("]]>") - 1UL,
                                               (_Bool)1);
    if (tmp___0) {
      tokenizer->_reconsume_current_input = (_Bool)1;
      reset_token_start_point(tokenizer);
      gumbo_tokenizer_set_state(parser, (GumboTokenizerEnum )0);
      return ((StateResult )2);
    } else {
      tmp = emit_current_char(parser, output);
      return ((StateResult )tmp);
    }
  }
}
}
static GumboLexerStateFunction dispatch_table[68]  = 
  {      & handle_data_state,      & handle_char_ref_in_data_state,      & handle_rcdata_state,      & handle_char_ref_in_rcdata_state, 
        & handle_rawtext_state,      & handle_script_state,      & handle_plaintext_state,      & handle_tag_open_state, 
        & handle_end_tag_open_state,      & handle_tag_name_state,      & handle_rcdata_lt_state,      & handle_rcdata_end_tag_open_state, 
        & handle_rcdata_end_tag_name_state,      & handle_rawtext_lt_state,      & handle_rawtext_end_tag_open_state,      & handle_rawtext_end_tag_name_state, 
        & handle_script_lt_state,      & handle_script_end_tag_open_state,      & handle_script_end_tag_name_state,      & handle_script_escaped_start_state, 
        & handle_script_escaped_start_dash_state,      & handle_script_escaped_state,      & handle_script_escaped_dash_state,      & handle_script_escaped_dash_dash_state, 
        & handle_script_escaped_lt_state,      & handle_script_escaped_end_tag_open_state,      & handle_script_escaped_end_tag_name_state,      & handle_script_double_escaped_start_state, 
        & handle_script_double_escaped_state,      & handle_script_double_escaped_dash_state,      & handle_script_double_escaped_dash_dash_state,      & handle_script_double_escaped_lt_state, 
        & handle_script_double_escaped_end_state,      & handle_before_attr_name_state,      & handle_attr_name_state,      & handle_after_attr_name_state, 
        & handle_before_attr_value_state,      & handle_attr_value_double_quoted_state,      & handle_attr_value_single_quoted_state,      & handle_attr_value_unquoted_state, 
        & handle_char_ref_in_attr_value_state,      & handle_after_attr_value_quoted_state,      & handle_self_closing_start_tag_state,      & handle_bogus_comment_state, 
        & handle_markup_declaration_state,      & handle_comment_start_state,      & handle_comment_start_dash_state,      & handle_comment_state, 
        & handle_comment_end_dash_state,      & handle_comment_end_state,      & handle_comment_end_bang_state,      & handle_doctype_state, 
        & handle_before_doctype_name_state,      & handle_doctype_name_state,      & handle_after_doctype_name_state,      & handle_after_doctype_public_keyword_state, 
        & handle_before_doctype_public_id_state,      & handle_doctype_public_id_double_quoted_state,      & handle_doctype_public_id_single_quoted_state,      & handle_after_doctype_public_id_state, 
        & handle_between_doctype_public_system_id_state,      & handle_after_doctype_system_keyword_state,      & handle_before_doctype_system_id_state,      & handle_doctype_system_id_double_quoted_state, 
        & handle_doctype_system_id_single_quoted_state,      & handle_after_doctype_system_id_state,      & handle_bogus_doctype_state,      & handle_cdata_state};
_Bool gumbo_lex(struct GumboInternalParser *parser , GumboToken *output ) 
{ 
  GumboTokenizerState *tokenizer ;
  _Bool tmp ;
  int c ;
  int tmp___2 ;
  StateResult result ;
  StateResult tmp___3 ;
  _Bool should_advance ;

  {
  tokenizer = parser->_tokenizer_state;
  if (tokenizer->_buffered_emit_char != (int )kGumboNoChar) {
    tokenizer->_reconsume_current_input = (_Bool)1;
    emit_char(parser, tokenizer->_buffered_emit_char, output);
    tokenizer->_reconsume_current_input = (_Bool)0;
    tokenizer->_buffered_emit_char = (int )kGumboNoChar;
    return ((_Bool)1);
  }
  tmp = maybe_emit_from_temporary_buffer(parser, output);
  if (tmp) {
    return ((_Bool)1);
  }
  while (1) {
    if (! (! tokenizer->_temporary_buffer_emit)) {
      __assert_fail("!tokenizer->_temporary_buffer_emit", "deps/gumbo-parser/tokenizer.c",
                    2927U, "gumbo_lex");
    }
    if (! (tokenizer->_buffered_emit_char == (int )kGumboNoChar)) {
      __assert_fail("tokenizer->_buffered_emit_char == kGumboNoChar", "deps/gumbo-parser/tokenizer.c",
                    2928U, "gumbo_lex");
    }
    tmp___2 = utf8iterator_current((Utf8Iterator const   *)(& tokenizer->_input));
    c = tmp___2;
    gumbo_debug("Lexing character \'%c\' in state %d.\n", c, (unsigned int )tokenizer->_state);
    tmp___3 = (*(dispatch_table[tokenizer->_state]))(parser, tokenizer, c, output);
    result = tmp___3;
    should_advance = (_Bool )(! tokenizer->_reconsume_current_input);
    tokenizer->_reconsume_current_input = (_Bool)0;
    if ((unsigned int )result == 1U) {
      return ((_Bool)1);
    } else
    if ((unsigned int )result == 0U) {
      return ((_Bool)0);
    }
    if (should_advance) {
      utf8iterator_next(& tokenizer->_input);
    }
  }
}
}
void gumbo_token_destroy(struct GumboInternalParser *parser , GumboToken *token ) 
{ 
  int i ;
  GumboAttribute *attr ;

  {
  if (! token) {
    return;
  }
  switch ((unsigned int )token->type) {
  case 0U: 
  gumbo_parser_deallocate(parser, (void *)token->v.doc_type.name);
  gumbo_parser_deallocate(parser, (void *)token->v.doc_type.public_identifier);
  gumbo_parser_deallocate(parser, (void *)token->v.doc_type.system_identifier);
  return;
  case 1U: 
  i = 0;
  while ((unsigned int )i < token->v.start_tag.attributes.length) {
    attr = (GumboAttribute *)*(token->v.start_tag.attributes.data + i);
    if (attr) {
      gumbo_destroy_attribute(parser, attr);
    }
    i ++;
  }
  gumbo_parser_deallocate(parser, (void *)token->v.start_tag.attributes.data);
  return;
  case 3U: 
  gumbo_parser_deallocate(parser, (void *)token->v.text);
  return;
  default: 
  return;
  }
}
}
#pragma merger("0","/tmp/cil-WJ1XT7GN.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
_Bool str_ends_with(char const   *str , char const   *end ) 
{ 
  int end_len ;
  int str_len ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((unsigned long )((void *)0) == (unsigned long )str) {
    return ((_Bool)0);
  } else
  if ((unsigned long )((void *)0) == (unsigned long )end) {
    return ((_Bool)0);
  }
  tmp = strlen(end);
  end_len = (int )tmp;
  tmp___0 = strlen(str);
  str_len = (int )tmp___0;
  if (str_len < end_len) {
    tmp___3 = 0;
  } else {
    tmp___1 = strcmp((str + str_len) - end_len, end);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    tmp___3 = tmp___2;
  }
  return ((_Bool )tmp___3);
}
}
#pragma merger("0","/tmp/cil-8dRJza3W.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
static int Write(FILE *stream , char const   *format , va_list___0 ap ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stream, (char const   * __restrict  )format,
                 ap);
  return (tmp);
}
}
__inline static unsigned int Shift(unsigned int val , unsigned int normal , unsigned int bright ) 
{ 


  {
  if (val == 0U) {
    return (9U + normal);
  }
  val --;
  if (val >= 8U) {
    return ((val - 8U) + bright);
  }
  return (val + normal);
}
}
static void UnixTerminalColorize(FILE *stream , unsigned int fg , unsigned int bg ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  tmp = Shift(bg, 40U, 100U);
  tmp___0 = Shift(fg, 30U, 90U);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\033[39;49;%u;%um",
          tmp___0, tmp);
  return;
}
}
static void UnixTerminalRestore(FILE *stream ) 
{ 


  {
  fputs((char const   * __restrict  )"\033[39;49m", (FILE * __restrict  )stream);
  return;
}
}
int cc_fprintf(cc_color_t color , FILE *stream , char const   *format  , ...) 
{ 
  va_list___0 ap ;
  int result ;
  unsigned int fg ;
  unsigned int bg ;

  {
  __builtin_va_start(ap, format);
  result = -22;
  if ((unsigned long )stream != (unsigned long )stdout) {
    if ((unsigned long )stream != (unsigned long )stderr) {
      result = Write(stream, format, ap);
      goto finish;
    }
  }
  fg = (unsigned int )color & (unsigned int )((1 << 5) - 1);
  bg = ((unsigned int )color >> 5) & (unsigned int )((1 << 5) - 1);
  UnixTerminalColorize(stream, fg, bg);
  Write(stream, format, ap);
  UnixTerminalRestore(stream);
  finish: 
  __builtin_va_end(ap);
  return (result);
}
}
#pragma merger("0","/tmp/cil-1h7LC1Sv.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
char *case_upper(char *str ) ;
char *case_camel(char *str ) ;
char *case_upper(char *str ) 
{ 
  int i ;
  int len ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  i = 0;
  tmp = strlen((char const   *)str);
  len = (int )tmp;
  while (i < len) {
    tmp___0 = __ctype_b_loc();
    if ((int const   )*(*tmp___0 + (int )*(str + i)) & 512) {
      *(str + i) = (char )((int )*(str + i) & -33);
    }
    i ++;
  }
  return (str);
}
}
char *case_lower(char *str ) 
{ 
  int i ;
  int len ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  i = 0;
  tmp = strlen((char const   *)str);
  len = (int )tmp;
  while (i < len) {
    tmp___0 = __ctype_b_loc();
    if ((int const   )*(*tmp___0 + (int )*(str + i)) & 256) {
      *(str + i) = (char )((int )*(str + i) | 32);
    }
    i ++;
  }
  return (str);
}
}
char *case_camel(char *str ) 
{ 
  int i ;
  int len ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  i = 0;
  tmp = strlen((char const   *)str);
  len = (int )tmp;
  while (i < len) {
    if ((int )*(str + i) == 45) {
      goto _L;
    } else
    if ((int )*(str + i) == 95) {
      goto _L;
    } else
    if ((int )*(str + i) == 32) {
      _L: /* CIL Label */ 
      memmove((void *)(str + i), (void const   *)(str + (i + 1)), (size_t )(len - i));
      if (i) {
        tmp___0 = __ctype_b_loc();
        if ((int const   )*(*tmp___0 + (int )*(str + i)) & 512) {
          *(str + i) = (char )((int )*(str + i) & -33);
        }
      }
      i --;
      len --;
    }
    i ++;
  }
  return (str);
}
}
#pragma merger("0","/tmp/cil-XAN_a09a.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
GumboNode *gumbo_get_element_by_id(char const   *id , GumboNode *document ) 
{ 
  GumboAttribute *node_id ;
  GumboAttribute *tmp ;
  int tmp___0 ;
  GumboVector *children ;
  unsigned int i ;
  GumboNode *node ;
  GumboNode *tmp___1 ;

  {
  if (0U != (unsigned int )document->type) {
    if (1U != (unsigned int )document->type) {
      return ((GumboNode *)((void *)0));
    }
  }
  tmp = gumbo_get_attribute((GumboVector const   *)(& document->v.element.attributes),
                            "id");
  node_id = tmp;
  if (node_id) {
    tmp___0 = strcmp(id, node_id->value);
    if (0 == tmp___0) {
      return (document);
    }
  }
  children = & document->v.element.children;
  i = 0U;
  while (i < children->length) {
    tmp___1 = gumbo_get_element_by_id(id, (GumboNode *)*(children->data + i));
    node = tmp___1;
    if (node) {
      return (node);
    }
    i ++;
  }
  return ((GumboNode *)((void *)0));
}
}
#pragma merger("0","/tmp/cil-KbLhqYEj.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
 __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *str )  __attribute__((__malloc__)) ;
char *( __attribute__((__nonnull__(1))) strdup)(char const   *str ) 
{ 
  int len ;
  size_t tmp ;
  char *buf ;
  void *tmp___0 ;

  {
  if ((unsigned long )((void *)0) == (unsigned long )((char *)str)) {
    return ((char *)((void *)0));
  }
  tmp = strlen(str);
  len = (int )(tmp + 1UL);
  tmp___0 = malloc((size_t )len);
  buf = (char *)tmp___0;
  if (buf) {
    memset((void *)buf, 0, (size_t )len);
    memcpy((void * __restrict  )buf, (void const   * __restrict  )str, (size_t )(len - 1));
  }
  return (buf);
}
}
#pragma merger("0","/tmp/cil-Ex4lt3jg.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
static char const   *env_vars[5]  = {      "TMPDIR",      "TEMP",      "TMP",      "Wimp$ScrapDir", 
        (char const   *)((void *)0)};
static char const   *platform_dirs[4]  = {      "/tmp",      "/var/tmp",      "/usr/tmp",      (char const   *)((void *)0)};
static int is_directory(char const   *path ) 
{ 
  struct stat s ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& s));
  if (-1 == tmp) {
    return (-1);
  }
  if (1 == ((s.st_mode & 61440U) == 16384U)) {
    tmp___0 = 0;
  } else {
    tmp___0 = -1;
  }
  return (tmp___0);
}
}
char *gettempdir(void) 
{ 
  int i ;
  char *dir ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int i___0 ;
  char *tmp___2 ;
  int tmp___3 ;
  char cwd[256] ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  i = 0;
  while (env_vars[i]) {
    tmp = getenv(env_vars[i]);
    dir = tmp;
    if (dir) {
      tmp___1 = is_directory((char const   *)dir);
      if (0 == tmp___1) {
        tmp___0 = strdup((char const   *)dir);
        return (tmp___0);
      }
    }
    i ++;
  }
  i___0 = 0;
  while (platform_dirs[i___0]) {
    tmp___3 = is_directory(platform_dirs[i___0]);
    if (0 == tmp___3) {
      tmp___2 = strdup(platform_dirs[i___0]);
      return (tmp___2);
    }
    i___0 ++;
  }
  tmp___5 = getcwd(cwd, sizeof(cwd));
  if ((unsigned long )((void *)0) != (unsigned long )tmp___5) {
    tmp___4 = strdup((char const   *)(cwd));
    return (tmp___4);
  }
  return ((char *)((void *)0));
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-eI6y2KSY.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
int asprintf(char **str , char const   *fmt  , ...) 
{ 
  int size ;
  va_list___0 args ;

  {
  size = 0;
  __builtin_va_start(args, fmt);
  size = vasprintf(str, fmt, args);
  __builtin_va_end(args);
  return (size);
}
}
int vasprintf(char **str , char const   *fmt , va_list___0 args ) 
{ 
  int size ;
  va_list___0 tmpa ;
  void *tmp ;

  {
  size = 0;
  __builtin_va_copy(tmpa, args);
  size = vsnprintf((char * __restrict  )((void *)0), (size_t )size, (char const   * __restrict  )fmt,
                   tmpa);
  __builtin_va_end(tmpa);
  if (size < 0) {
    return (-1);
  }
  tmp = malloc((size_t )(size + 1));
  *str = (char *)tmp;
  if ((unsigned long )((void *)0) == (unsigned long )*str) {
    return (-1);
  }
  size = vsprintf((char * __restrict  )*str, (char const   * __restrict  )fmt, args);
  return (size);
}
}
#pragma merger("0","/tmp/cil-1kFKN1Qr.i","-std=c99,-Wall,-Wno-unused-function,-pthread")
static text_nodes_t *get_text_nodes(GumboNode *root ) 
{ 
  text_nodes_t *nodes ;
  void *tmp ;
  GumboVector *children ;
  size_t i ;
  GumboNode *child ;
  size_t tmp___0 ;
  text_nodes_t *child_nodes ;
  text_nodes_t *tmp___1 ;
  size_t j ;
  size_t tmp___2 ;

  {
  tmp = malloc(sizeof(text_nodes_t ));
  nodes = (text_nodes_t *)tmp;
  if (! nodes) {
    return ((text_nodes_t *)((void *)0));
  }
  nodes->length = (size_t )0;
  children = & root->v.element.children;
  i = (size_t )0;
  while (i < (size_t )children->length) {
    child = (GumboNode *)*(children->data + i);
    if (2U == (unsigned int )child->type) {
      tmp___0 = nodes->length;
      (nodes->length) ++;
      nodes->nodes[tmp___0] = child->v.text.text;
    } else
    if (1U == (unsigned int )child->type) {
      tmp___1 = get_text_nodes(child);
      child_nodes = tmp___1;
      if (! child_nodes) {
        break;
      }
      if (child_nodes->length) {
        j = (size_t )0;
        while (j < child_nodes->length) {
          tmp___2 = nodes->length;
          (nodes->length) ++;
          nodes->nodes[tmp___2] = child_nodes->nodes[j];
          j ++;
        }
      }
      free((void *)child_nodes);
    }
    i ++;
  }
  return (nodes);
}
}
char *gumbo_text_content(GumboNode *node ) 
{ 
  text_nodes_t *text_nodes ;
  char *text_content ;
  size_t length ;
  int pos ;
  size_t i ;
  size_t tmp ;
  void *tmp___0 ;
  size_t i___0 ;
  size_t l ;
  size_t tmp___1 ;

  {
  text_nodes = (text_nodes_t *)((void *)0);
  text_content = (char *)((void *)0);
  length = (size_t )1;
  pos = 0;
  text_nodes = get_text_nodes(node);
  if (! text_nodes) {
    goto cleanup;
  }
  i = (size_t )0;
  while (i < text_nodes->length) {
    tmp = strlen(text_nodes->nodes[i]);
    length += tmp;
    i ++;
  }
  tmp___0 = malloc(length);
  text_content = (char *)tmp___0;
  if (! text_content) {
    goto cleanup;
  }
  *text_content = (char )'\000';
  i___0 = (size_t )0;
  while (i___0 < text_nodes->length) {
    tmp___1 = strlen(text_nodes->nodes[i___0]);
    l = tmp___1;
    strncat((char * __restrict  )(text_content + pos), (char const   * __restrict  )text_nodes->nodes[i___0],
            l);
    pos = (int )((size_t )pos + l);
    *(text_content + pos) = (char )'\000';
    i___0 ++;
  }
  cleanup: 
  free((void *)text_nodes);
  return (text_content);
}
}
