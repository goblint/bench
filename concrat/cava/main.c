/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __clock_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __syscall_slong_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
typedef int wchar_t;
typedef __builtin_va_list __gnuc_va_list;
union __anonunion___value_919941124 {
   unsigned int __wch ;
   char __wchb[4] ;
};
struct __anonstruct___mbstate_t_476269514 {
   int __count ;
   union __anonunion___value_919941124 __value ;
};
typedef struct __anonstruct___mbstate_t_476269514 __mbstate_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
struct __dirstream ;
typedef struct __dirstream DIR;
typedef double fftw_complex[2];
struct fftw_plan_s ;
typedef struct fftw_plan_s *fftw_plan;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval __sigval_t;
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
union __anonunion__bounds_401083816 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
struct __anonstruct__sigfault_1009314882 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_401083816 _bounds ;
};
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
struct __anonstruct__sigsys_44812255 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_289080392 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_1009314882 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_44812255 _sigsys ;
};
struct __anonstruct_siginfo_t_292364137 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_289080392 _sifields ;
};
typedef struct __anonstruct_siginfo_t_292364137 siginfo_t;
typedef void (*__sighandler_t)(int  );
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef unsigned int chtype;
struct _win_st ;
typedef struct _win_st WINDOW;
typedef chtype attr_t;
typedef unsigned int wint_t;
typedef __mbstate_t mbstate_t;
struct __anonstruct_cchar_t_667532103 {
   attr_t attr ;
   wchar_t chars[5] ;
   int ext_color ;
};
typedef struct __anonstruct_cchar_t_667532103 cchar_t;
struct ldat ;
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
   cchar_t _bkgrnd ;
   int _color ;
};
typedef int __gwchar_t;
struct audio_data {
   int FFTbassbufferSize ;
   int FFTmidbufferSize ;
   int FFTtreblebufferSize ;
   int bass_index ;
   int mid_index ;
   int treble_index ;
   double *bass_multiplier ;
   double *mid_multiplier ;
   double *treble_multiplier ;
   double *in_bass_r_raw ;
   double *in_bass_l_raw ;
   double *in_mid_r_raw ;
   double *in_mid_l_raw ;
   double *in_treble_r_raw ;
   double *in_treble_l_raw ;
   double *in_bass_r ;
   double *in_bass_l ;
   double *in_mid_r ;
   double *in_mid_l ;
   double *in_treble_r ;
   double *in_treble_l ;
   int format ;
   unsigned int rate ;
   char *source ;
   int im ;
   unsigned int channels ;
   _Bool left ;
   _Bool right ;
   _Bool average ;
   int terminate ;
   char error_message[1024] ;
};
enum input_method {
    INPUT_FIFO = 0,
    INPUT_PORTAUDIO = 1,
    INPUT_ALSA = 2,
    INPUT_PULSE = 3,
    INPUT_SNDIO = 4,
    INPUT_SHMEM = 5,
    INPUT_MAX = 6
} ;
enum output_method {
    OUTPUT_NCURSES = 0,
    OUTPUT_NONCURSES = 1,
    OUTPUT_RAW = 2,
    OUTPUT_NOT_SUPORTED = 3
} ;
enum xaxis_scale {
    NONE = 0,
    FREQUENCY = 1,
    NOTE = 2
} ;
struct config_params {
   char *color ;
   char *bcolor ;
   char *raw_target ;
   char *audio_source ;
   char **gradient_colors ;
   char *data_format ;
   char *mono_option ;
   char bar_delim ;
   char frame_delim ;
   double monstercat ;
   double integral ;
   double gravity ;
   double ignore ;
   double sens ;
   unsigned int lower_cut_off ;
   unsigned int upper_cut_off ;
   double *userEQ ;
   enum input_method input ;
   enum output_method output ;
   enum xaxis_scale xaxis ;
   int userEQ_keys ;
   int userEQ_enabled ;
   int col ;
   int bgcol ;
   int autobars ;
   int stereo ;
   int is_bin ;
   int ascii_range ;
   int bit_format ;
   int gradient ;
   int gradient_count ;
   int fixedbars ;
   int framerate ;
   int bar_width ;
   int bar_spacing ;
   int autosens ;
   int overshoot ;
   int waves ;
   int fifoSample ;
   int fifoSampleBits ;
   int sleep_timer ;
};
struct error_s {
   char message[1024] ;
   int length ;
};
typedef long __ssize_t;
typedef __gnuc_va_list va_list___0;
typedef __ssize_t ssize_t;
struct _dictionary_ {
   int n ;
   ssize_t size ;
   char **val ;
   char **key ;
   unsigned int *hash ;
};
typedef struct _dictionary_ dictionary;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef __int16_t int16_t;
typedef __uint16_t uint16_t;
typedef unsigned char __uint8_t;
typedef __uint8_t uint8_t;
typedef __mode_t mode_t;
typedef long intptr_t;
typedef __time_t time_t;
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
union __anonunion_pthread_rwlock_t_656928968 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
typedef union __anonunion_pthread_rwlock_t_656928968 pthread_rwlock_t;
typedef unsigned int u32_t;
typedef short s16_t;
struct __anonstruct_vis_t_409133603 {
   pthread_rwlock_t rwlock ;
   u32_t buf_size ;
   u32_t buf_index ;
   _Bool running ;
   u32_t rate ;
   time_t updated ;
   s16_t buffer[16384] ;
};
typedef struct __anonstruct_vis_t_409133603 vis_t;
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
typedef signed char __int8_t;
typedef __int8_t int8_t;
typedef __int32_t int32_t;
struct _snd_pcm_hw_params ;
typedef struct _snd_pcm_hw_params snd_pcm_hw_params_t;
enum _snd_pcm_stream {
    SND_PCM_STREAM_PLAYBACK = 0,
    SND_PCM_STREAM_CAPTURE = 1,
    SND_PCM_STREAM_LAST = 1
} ;
typedef enum _snd_pcm_stream snd_pcm_stream_t;
enum _snd_pcm_access {
    SND_PCM_ACCESS_MMAP_INTERLEAVED = 0,
    SND_PCM_ACCESS_MMAP_NONINTERLEAVED = 1,
    SND_PCM_ACCESS_MMAP_COMPLEX = 2,
    SND_PCM_ACCESS_RW_INTERLEAVED = 3,
    SND_PCM_ACCESS_RW_NONINTERLEAVED = 4,
    SND_PCM_ACCESS_LAST = 4
} ;
typedef enum _snd_pcm_access snd_pcm_access_t;
enum _snd_pcm_format {
    SND_PCM_FORMAT_UNKNOWN = -1,
    SND_PCM_FORMAT_S8 = 0,
    SND_PCM_FORMAT_U8 = 1,
    SND_PCM_FORMAT_S16_LE = 2,
    SND_PCM_FORMAT_S16_BE = 3,
    SND_PCM_FORMAT_U16_LE = 4,
    SND_PCM_FORMAT_U16_BE = 5,
    SND_PCM_FORMAT_S24_LE = 6,
    SND_PCM_FORMAT_S24_BE = 7,
    SND_PCM_FORMAT_U24_LE = 8,
    SND_PCM_FORMAT_U24_BE = 9,
    SND_PCM_FORMAT_S32_LE = 10,
    SND_PCM_FORMAT_S32_BE = 11,
    SND_PCM_FORMAT_U32_LE = 12,
    SND_PCM_FORMAT_U32_BE = 13,
    SND_PCM_FORMAT_FLOAT_LE = 14,
    SND_PCM_FORMAT_FLOAT_BE = 15,
    SND_PCM_FORMAT_FLOAT64_LE = 16,
    SND_PCM_FORMAT_FLOAT64_BE = 17,
    SND_PCM_FORMAT_IEC958_SUBFRAME_LE = 18,
    SND_PCM_FORMAT_IEC958_SUBFRAME_BE = 19,
    SND_PCM_FORMAT_MU_LAW = 20,
    SND_PCM_FORMAT_A_LAW = 21,
    SND_PCM_FORMAT_IMA_ADPCM = 22,
    SND_PCM_FORMAT_MPEG = 23,
    SND_PCM_FORMAT_GSM = 24,
    SND_PCM_FORMAT_S20_LE = 25,
    SND_PCM_FORMAT_S20_BE = 26,
    SND_PCM_FORMAT_U20_LE = 27,
    SND_PCM_FORMAT_U20_BE = 28,
    SND_PCM_FORMAT_SPECIAL = 31,
    SND_PCM_FORMAT_S24_3LE = 32,
    SND_PCM_FORMAT_S24_3BE = 33,
    SND_PCM_FORMAT_U24_3LE = 34,
    SND_PCM_FORMAT_U24_3BE = 35,
    SND_PCM_FORMAT_S20_3LE = 36,
    SND_PCM_FORMAT_S20_3BE = 37,
    SND_PCM_FORMAT_U20_3LE = 38,
    SND_PCM_FORMAT_U20_3BE = 39,
    SND_PCM_FORMAT_S18_3LE = 40,
    SND_PCM_FORMAT_S18_3BE = 41,
    SND_PCM_FORMAT_U18_3LE = 42,
    SND_PCM_FORMAT_U18_3BE = 43,
    SND_PCM_FORMAT_G723_24 = 44,
    SND_PCM_FORMAT_G723_24_1B = 45,
    SND_PCM_FORMAT_G723_40 = 46,
    SND_PCM_FORMAT_G723_40_1B = 47,
    SND_PCM_FORMAT_DSD_U8 = 48,
    SND_PCM_FORMAT_DSD_U16_LE = 49,
    SND_PCM_FORMAT_DSD_U32_LE = 50,
    SND_PCM_FORMAT_DSD_U16_BE = 51,
    SND_PCM_FORMAT_DSD_U32_BE = 52,
    SND_PCM_FORMAT_LAST = 52,
    SND_PCM_FORMAT_S16 = 2,
    SND_PCM_FORMAT_U16 = 4,
    SND_PCM_FORMAT_S24 = 6,
    SND_PCM_FORMAT_U24 = 8,
    SND_PCM_FORMAT_S32 = 10,
    SND_PCM_FORMAT_U32 = 12,
    SND_PCM_FORMAT_FLOAT = 14,
    SND_PCM_FORMAT_FLOAT64 = 16,
    SND_PCM_FORMAT_IEC958_SUBFRAME = 18,
    SND_PCM_FORMAT_S20 = 25,
    SND_PCM_FORMAT_U20 = 27
} ;
typedef enum _snd_pcm_format snd_pcm_format_t;
typedef unsigned long snd_pcm_uframes_t;
typedef long snd_pcm_sframes_t;
struct _snd_pcm ;
typedef struct _snd_pcm snd_pcm_t;
typedef long __suseconds_t;
typedef __uint32_t uint32_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
enum pa_sample_format {
    PA_SAMPLE_U8 = 0,
    PA_SAMPLE_ALAW = 1,
    PA_SAMPLE_ULAW = 2,
    PA_SAMPLE_S16LE = 3,
    PA_SAMPLE_S16BE = 4,
    PA_SAMPLE_FLOAT32LE = 5,
    PA_SAMPLE_FLOAT32BE = 6,
    PA_SAMPLE_S32LE = 7,
    PA_SAMPLE_S32BE = 8,
    PA_SAMPLE_S24LE = 9,
    PA_SAMPLE_S24BE = 10,
    PA_SAMPLE_S24_32LE = 11,
    PA_SAMPLE_S24_32BE = 12,
    PA_SAMPLE_MAX = 13,
    PA_SAMPLE_INVALID = -1
} ;
typedef enum pa_sample_format pa_sample_format_t;
struct pa_sample_spec {
   pa_sample_format_t format ;
   uint32_t rate ;
   uint8_t channels ;
};
typedef struct pa_sample_spec pa_sample_spec;
enum pa_context_state {
    PA_CONTEXT_UNCONNECTED = 0,
    PA_CONTEXT_CONNECTING = 1,
    PA_CONTEXT_AUTHORIZING = 2,
    PA_CONTEXT_SETTING_NAME = 3,
    PA_CONTEXT_READY = 4,
    PA_CONTEXT_FAILED = 5,
    PA_CONTEXT_TERMINATED = 6
} ;
typedef enum pa_context_state pa_context_state_t;
enum pa_context_flags {
    PA_CONTEXT_NOFLAGS = 0,
    PA_CONTEXT_NOAUTOSPAWN = 1,
    PA_CONTEXT_NOFAIL = 2
} ;
typedef enum pa_context_flags pa_context_flags_t;
enum pa_stream_direction {
    PA_STREAM_NODIRECTION = 0,
    PA_STREAM_PLAYBACK = 1,
    PA_STREAM_RECORD = 2,
    PA_STREAM_UPLOAD = 3
} ;
typedef enum pa_stream_direction pa_stream_direction_t;
struct pa_buffer_attr {
   uint32_t maxlength ;
   uint32_t tlength ;
   uint32_t prebuf ;
   uint32_t minreq ;
   uint32_t fragsize ;
};
typedef struct pa_buffer_attr pa_buffer_attr;
struct pa_spawn_api {
   void (*prefork)(void) ;
   void (*postfork)(void) ;
   void (*atfork)(void) ;
};
typedef struct pa_spawn_api pa_spawn_api;
struct pa_mainloop_api ;
typedef struct pa_mainloop_api pa_mainloop_api;
enum pa_io_event_flags {
    PA_IO_EVENT_NULL = 0,
    PA_IO_EVENT_INPUT = 1,
    PA_IO_EVENT_OUTPUT = 2,
    PA_IO_EVENT_HANGUP = 4,
    PA_IO_EVENT_ERROR = 8
} ;
typedef enum pa_io_event_flags pa_io_event_flags_t;
struct pa_io_event ;
typedef struct pa_io_event pa_io_event;
struct pa_time_event ;
typedef struct pa_time_event pa_time_event;
struct pa_defer_event ;
typedef struct pa_defer_event pa_defer_event;
struct pa_mainloop_api {
   void *userdata ;
   pa_io_event *(*io_new)(pa_mainloop_api *a , int fd , pa_io_event_flags_t events ,
                          void (*cb)(pa_mainloop_api *ea , pa_io_event *e , int fd ,
                                     pa_io_event_flags_t events , void *userdata ) ,
                          void *userdata ) ;
   void (*io_enable)(pa_io_event *e , pa_io_event_flags_t events ) ;
   void (*io_free)(pa_io_event *e ) ;
   void (*io_set_destroy)(pa_io_event *e , void (*cb)(pa_mainloop_api *a , pa_io_event *e ,
                                                      void *userdata ) ) ;
   pa_time_event *(*time_new)(pa_mainloop_api *a , struct timeval  const  *tv , void (*cb)(pa_mainloop_api *a ,
                                                                                           pa_time_event *e ,
                                                                                           struct timeval  const  *tv ,
                                                                                           void *userdata ) ,
                              void *userdata ) ;
   void (*time_restart)(pa_time_event *e , struct timeval  const  *tv ) ;
   void (*time_free)(pa_time_event *e ) ;
   void (*time_set_destroy)(pa_time_event *e , void (*cb)(pa_mainloop_api *a , pa_time_event *e ,
                                                          void *userdata ) ) ;
   pa_defer_event *(*defer_new)(pa_mainloop_api *a , void (*cb)(pa_mainloop_api *a ,
                                                                pa_defer_event *e ,
                                                                void *userdata ) ,
                                void *userdata ) ;
   void (*defer_enable)(pa_defer_event *e , int b ) ;
   void (*defer_free)(pa_defer_event *e ) ;
   void (*defer_set_destroy)(pa_defer_event *e , void (*cb)(pa_mainloop_api *a , pa_defer_event *e ,
                                                            void *userdata ) ) ;
   void (*quit)(pa_mainloop_api *a , int retval ) ;
};
enum pa_channel_position {
    PA_CHANNEL_POSITION_INVALID = -1,
    PA_CHANNEL_POSITION_MONO = 0,
    PA_CHANNEL_POSITION_FRONT_LEFT = 1,
    PA_CHANNEL_POSITION_FRONT_RIGHT = 2,
    PA_CHANNEL_POSITION_FRONT_CENTER = 3,
    PA_CHANNEL_POSITION_LEFT = 1,
    PA_CHANNEL_POSITION_RIGHT = 2,
    PA_CHANNEL_POSITION_CENTER = 3,
    PA_CHANNEL_POSITION_REAR_CENTER = 4,
    PA_CHANNEL_POSITION_REAR_LEFT = 5,
    PA_CHANNEL_POSITION_REAR_RIGHT = 6,
    PA_CHANNEL_POSITION_LFE = 7,
    PA_CHANNEL_POSITION_SUBWOOFER = 7,
    PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER = 8,
    PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER = 9,
    PA_CHANNEL_POSITION_SIDE_LEFT = 10,
    PA_CHANNEL_POSITION_SIDE_RIGHT = 11,
    PA_CHANNEL_POSITION_AUX0 = 12,
    PA_CHANNEL_POSITION_AUX1 = 13,
    PA_CHANNEL_POSITION_AUX2 = 14,
    PA_CHANNEL_POSITION_AUX3 = 15,
    PA_CHANNEL_POSITION_AUX4 = 16,
    PA_CHANNEL_POSITION_AUX5 = 17,
    PA_CHANNEL_POSITION_AUX6 = 18,
    PA_CHANNEL_POSITION_AUX7 = 19,
    PA_CHANNEL_POSITION_AUX8 = 20,
    PA_CHANNEL_POSITION_AUX9 = 21,
    PA_CHANNEL_POSITION_AUX10 = 22,
    PA_CHANNEL_POSITION_AUX11 = 23,
    PA_CHANNEL_POSITION_AUX12 = 24,
    PA_CHANNEL_POSITION_AUX13 = 25,
    PA_CHANNEL_POSITION_AUX14 = 26,
    PA_CHANNEL_POSITION_AUX15 = 27,
    PA_CHANNEL_POSITION_AUX16 = 28,
    PA_CHANNEL_POSITION_AUX17 = 29,
    PA_CHANNEL_POSITION_AUX18 = 30,
    PA_CHANNEL_POSITION_AUX19 = 31,
    PA_CHANNEL_POSITION_AUX20 = 32,
    PA_CHANNEL_POSITION_AUX21 = 33,
    PA_CHANNEL_POSITION_AUX22 = 34,
    PA_CHANNEL_POSITION_AUX23 = 35,
    PA_CHANNEL_POSITION_AUX24 = 36,
    PA_CHANNEL_POSITION_AUX25 = 37,
    PA_CHANNEL_POSITION_AUX26 = 38,
    PA_CHANNEL_POSITION_AUX27 = 39,
    PA_CHANNEL_POSITION_AUX28 = 40,
    PA_CHANNEL_POSITION_AUX29 = 41,
    PA_CHANNEL_POSITION_AUX30 = 42,
    PA_CHANNEL_POSITION_AUX31 = 43,
    PA_CHANNEL_POSITION_TOP_CENTER = 44,
    PA_CHANNEL_POSITION_TOP_FRONT_LEFT = 45,
    PA_CHANNEL_POSITION_TOP_FRONT_RIGHT = 46,
    PA_CHANNEL_POSITION_TOP_FRONT_CENTER = 47,
    PA_CHANNEL_POSITION_TOP_REAR_LEFT = 48,
    PA_CHANNEL_POSITION_TOP_REAR_RIGHT = 49,
    PA_CHANNEL_POSITION_TOP_REAR_CENTER = 50,
    PA_CHANNEL_POSITION_MAX = 51
} ;
typedef enum pa_channel_position pa_channel_position_t;
struct pa_channel_map {
   uint8_t channels ;
   pa_channel_position_t map[32U] ;
};
typedef struct pa_channel_map pa_channel_map;
struct pa_operation ;
typedef struct pa_operation pa_operation;
struct pa_context ;
typedef struct pa_context pa_context;
struct pa_server_info {
   char const   *user_name ;
   char const   *host_name ;
   char const   *server_version ;
   char const   *server_name ;
   pa_sample_spec sample_spec ;
   char const   *default_sink_name ;
   char const   *default_source_name ;
   uint32_t cookie ;
   pa_channel_map channel_map ;
};
typedef struct pa_server_info pa_server_info;
struct pa_mainloop ;
typedef struct pa_mainloop pa_mainloop;
struct pa_simple ;
typedef struct pa_simple pa_simple;
struct colors {
   short color ;
   short R ;
   short G ;
   short B ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-8JE5qSk3.i","-std=c99,-Wall,-Werror,-Wextra,-Wno-unused-result,-Wno-unknown-warning-option,-Wno-maybe-uninitialized,-Wno-vla-parameter,-g,-O2")
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
extern int system(char const   *__command ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
extern void fftw_execute(fftw_plan const   p ) ;
extern fftw_plan fftw_plan_dft_r2c_1d(int n , double *in , fftw_complex *out , unsigned int flags ) ;
extern void fftw_destroy_plan(fftw_plan p ) ;
extern double *fftw_alloc_real(size_t n ) ;
extern fftw_complex *fftw_alloc_complex(size_t n ) ;
extern void fftw_free(void *p ) ;
extern char *optarg ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt)(int ___argc ,
                                                                                     char * const  *___argv ,
                                                                                     char const   *__shortopts ) ;
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkfifo)(char const   *__path ,
                                                                                   __mode_t __mode ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
void init_terminal_ncurses(char * const  fg_color_string , char * const  bg_color_string ,
                           int predef_fg_color , int predef_bg_color , int gradient ,
                           int gradient_count , char **gradient_colors , int *width ,
                           int *lines ) ;
int draw_terminal_ncurses(int is_tty , int terminal_height , int terminal_width ,
                          int bars_count , int bar_width , int bar_spacing , int rest ,
                          int const   *bars , int *previous_frame , int gradient ,
                          int x_axis_info ) ;
void cleanup_terminal_ncurses(void) ;
__inline extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__gnu_inline__)) btowc)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctob)(wint_t __wc ) ;
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t * __restrict  __p ) ;
extern  __attribute__((__nothrow__)) size_t __mbrlen(char const   * __restrict  __s ,
                                                     size_t __n , mbstate_t * __restrict  __ps ) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbrlen)(char const   * __restrict  __s ,
                                                                                               size_t __n ,
                                                                                               mbstate_t * __restrict  __ps ) ;
extern wint_t __btowc_alias(int __c )  __asm__("btowc")  ;
__inline extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__gnu_inline__)) btowc)(int __c ) ;
__inline extern wint_t ( __attribute__((__gnu_inline__)) btowc)(int __c ) 
{ 
  wint_t tmp ;

  {
  tmp = __btowc_alias(__c);
  return (tmp);
}
}
extern int __wctob_alias(wint_t __c )  __asm__("wctob")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctob)(wint_t __wc ) ;
__inline extern int ( __attribute__((__gnu_inline__)) wctob)(wint_t __wc ) 
{ 
  int tmp ;

  {
  tmp = __wctob_alias(__wc);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbrlen)(char const   * __restrict  __s ,
                                                                                               size_t __n ,
                                                                                               mbstate_t * __restrict  __ps ) ;
__inline extern size_t ( __attribute__((__gnu_inline__)) mbrlen)(char const   * __restrict  __s ,
                                                                 size_t __n , mbstate_t * __restrict  __ps ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  if ((unsigned long )__ps != (unsigned long )((void *)0)) {
    tmp = mbrtowc((wchar_t * __restrict  )((void *)0), __s, __n, __ps);
    tmp___1 = tmp;
  } else {
    tmp___0 = __mbrlen(__s, __n, (mbstate_t * __restrict  )((void *)0));
    tmp___1 = tmp___0;
  }
  return (tmp___1);
}
}
extern int mvprintw(int  , int  , char const   *  , ...) ;
extern int wgetch(WINDOW * ) ;
extern WINDOW *stdscr ;
int print_raw_out(int bars_count , int fd , int is_binary , int bit_format , int ascii_range ,
                  char bar_delim , char frame_delim , int const   *f ) ;
int init_terminal_noncurses(int tty , int col , int bgcol , int width , int lines ,
                            int bar_width ) ;
void get_terminal_dim_noncurses(int *width , int *lines ) ;
int draw_terminal_noncurses(int tty , int lines , int width , int number_of_bars ,
                            int bar_width , int bar_spacing , int rest , int *bars ,
                            int *previous_frame , int x_axis_info ) ;
void cleanup_terminal_noncurses(void) ;
void *input_alsa(void *data ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __strtol_internal)(char const   * __restrict  __nptr ,
                                                                                               char ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                      char ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  tmp = __strtol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __strtoul_internal)(char const   * __restrict  __nptr ,
                                                                                                         char ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                       char ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __strtoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __wcstol_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                               __gwchar_t ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                      __gwchar_t ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  tmp = __wcstol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __wcstoul_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                                         __gwchar_t ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                       __gwchar_t ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __wcstoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
void reset_output_buffers(struct audio_data *data ) ;
pthread_mutex_t lock  ;
void *input_fifo(void *data ) ;
void *input_pulse(void *data ) ;
void getPulseDefaultSink(void *data ) ;
void *input_shmem(void *data ) ;
_Bool load_config(char *configPath , struct config_params *p___0 , _Bool colorsOnly ,
                  struct error_s *error ) ;
int output_mode  ;
int should_reload  =    0;
int reload_colors  =    0;
int should_quit  =    0;
struct config_params p  ;
fftw_complex *out_bass_l  ;
fftw_complex *out_bass_r  ;
fftw_plan p_bass_l  ;
fftw_plan p_bass_r  ;
fftw_complex *out_mid_l  ;
fftw_complex *out_mid_r  ;
fftw_plan p_mid_l  ;
fftw_plan p_mid_r  ;
fftw_complex *out_treble_l  ;
fftw_complex *out_treble_r  ;
fftw_plan p_treble_l  ;
fftw_plan p_treble_r  ;
void cleanup(void) 
{ 


  {
  if (output_mode == 0) {
    cleanup_terminal_ncurses();
  } else
  if (output_mode == 1) {
    cleanup_terminal_noncurses();
  }
  return;
}
}
void sig_handler(int sig_no ) 
{ 


  {
  if (sig_no == 10) {
    should_reload = 1;
    return;
  }
  if (sig_no == 12) {
    reload_colors = 1;
    return;
  }
  cleanup();
  if (sig_no == 2) {
    printf((char const   * __restrict  )"CTRL-C pressed -- goodbye\n");
  }
  signal(sig_no, (void (*)(int  ))0);
  raise(sig_no);
  return;
}
}
static _Bool is_loop_device_for_sure(char const   *text ) 
{ 
  char const   *LOOPBACK_DEVICE_PREFIX ;
  size_t tmp ;
  int tmp___0 ;

  {
  LOOPBACK_DEVICE_PREFIX = "hw:Loopback,";
  tmp = strlen(LOOPBACK_DEVICE_PREFIX);
  tmp___0 = strncmp(text, LOOPBACK_DEVICE_PREFIX, tmp);
  return ((_Bool )(tmp___0 == 0));
}
}
static _Bool directory_exists(char const   *path ) 
{ 
  DIR *dir ;
  DIR *tmp ;

  {
  tmp = opendir(path);
  dir = tmp;
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  closedir(dir);
  return ((_Bool)1);
}
}
int *monstercat_filter(int *bars , int number_of_bars , int waves , double monstercat ) 
{ 
  int z ;
  int m_y ;
  int de ;
  double _a ;
  double tmp___0 ;
  int _b ;
  double tmp___1 ;
  double _a___0 ;
  double tmp___3 ;
  int _b___0 ;
  double tmp___4 ;
  double _a___1 ;
  double tmp___6 ;
  int _b___1 ;
  double tmp___7 ;
  double _a___2 ;
  double tmp___9 ;
  int _b___2 ;
  double tmp___10 ;

  {
  if (waves > 0) {
    z = 0;
    while (z < number_of_bars) {
      *(bars + z) = (int )((double )*(bars + z) / 1.25);
      m_y = z - 1;
      while (m_y >= 0) {
        de = z - m_y;
        tmp___0 = pow((double )de, (double )2);
        _a = (double )*(bars + z) - tmp___0;
        _b = *(bars + m_y);
        if (_a > (double )_b) {
          tmp___1 = _a;
        } else {
          tmp___1 = (double )_b;
        }
        *(bars + m_y) = (int )tmp___1;
        m_y --;
      }
      m_y = z + 1;
      while (m_y < number_of_bars) {
        de = m_y - z;
        tmp___3 = pow((double )de, (double )2);
        _a___0 = (double )*(bars + z) - tmp___3;
        _b___0 = *(bars + m_y);
        if (_a___0 > (double )_b___0) {
          tmp___4 = _a___0;
        } else {
          tmp___4 = (double )_b___0;
        }
        *(bars + m_y) = (int )tmp___4;
        m_y ++;
      }
      z ++;
    }
  } else
  if (monstercat > (double )0) {
    z = 0;
    while (z < number_of_bars) {
      m_y = z - 1;
      while (m_y >= 0) {
        de = z - m_y;
        tmp___6 = pow(monstercat, (double )de);
        _a___1 = (double )*(bars + z) / tmp___6;
        _b___1 = *(bars + m_y);
        if (_a___1 > (double )_b___1) {
          tmp___7 = _a___1;
        } else {
          tmp___7 = (double )_b___1;
        }
        *(bars + m_y) = (int )tmp___7;
        m_y --;
      }
      m_y = z + 1;
      while (m_y < number_of_bars) {
        de = m_y - z;
        tmp___9 = pow(monstercat, (double )de);
        _a___2 = (double )*(bars + z) / tmp___9;
        _b___2 = *(bars + m_y);
        if (_a___2 > (double )_b___2) {
          tmp___10 = _a___2;
        } else {
          tmp___10 = (double )_b___2;
        }
        *(bars + m_y) = (int )tmp___10;
        m_y ++;
      }
      z ++;
    }
  }
  return (bars);
}
}
int main(int argc , char **argv ) 
{ 
  char configPath[4096] ;
  struct sigaction action ;
  char *usage ;
  int c ;
  struct error_s error ;
  _Bool tmp ;
  _Bool first ;
  int inAtty ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  FILE *font_file ;
  char *tmp___6 ;
  int *bars_left ;
  int *bars_right ;
  double *temp_l ;
  double *temp_r ;
  int bass_cut_off ;
  int treble_cut_off ;
  struct audio_data audio ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  int i ;
  double tmp___19 ;
  int i___0 ;
  double tmp___20 ;
  int i___1 ;
  double tmp___21 ;
  pthread_t p_thread ;
  int timeout_counter ;
  struct timespec timeout_timer ;
  int thr_id  __attribute__((__unused__)) ;
  _Bool tmp___22 ;
  _Bool tmp___23 ;
  _Bool tmp___24 ;
  int tmp___25 ;
  int bars[256] ;
  int bars_mem[256] ;
  int bars_last[256] ;
  int previous_frame[256] ;
  int fall[256] ;
  float bars_peak[256] ;
  int height ;
  int lines ;
  int width ;
  int remainder___0 ;
  int fp ;
  _Bool reloadConf ;
  int n ;
  int fptest ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  double tmp___29 ;
  int tmp___30 ;
  int number_of_bars ;
  float g ;
  double tmp___31 ;
  double integral ;
  double tmp___32 ;
  double tmp___33 ;
  double userEQ_keys_to_bars_ratio ;
  double frequency_constant ;
  double tmp___34 ;
  float cut_off_frequency[256] ;
  float upper_cut_off_frequency[256] ;
  float relative_cut_off[256] ;
  double center_frequencies[256] ;
  int FFTbuffer_lower_cut_off[256] ;
  int FFTbuffer_upper_cut_off[256] ;
  double eq[256] ;
  int bass_cut_off_bar ;
  int treble_cut_off_bar ;
  _Bool first_bar ;
  int first_treble_bar ;
  int n___0 ;
  double bar_distribution_coefficient ;
  double tmp___35 ;
  double tmp___36 ;
  double tmp___37 ;
  double tmp___38 ;
  double tmp___39 ;
  double tmp___40 ;
  double tmp___41 ;
  int x_axis_info ;
  double center_frequency ;
  int n___1 ;
  float freq_kilohz ;
  int freq_floor ;
  _Bool resizeTerminal ;
  struct timespec framerate_timer ;
  int sleep_counter ;
  _Bool silence ;
  char ch ;
  struct timespec sleep_mode_timer ;
  int tmp___42 ;
  struct error_s error___0 ;
  _Bool tmp___43 ;
  int n___2 ;
  int n___3 ;
  int i___2 ;
  double tmp___44 ;
  double tmp___45 ;
  double tmp___46 ;
  double tmp___47 ;
  double tmp___48 ;
  double tmp___49 ;
  _Bool senselow ;
  int n___4 ;
  int diff ;
  double div___0 ;
  int rc___0 ;

  {
  printf((char const   * __restrict  )"%c]0;%s%c", '\033', "cava", '\a');
  configPath[0] = (char )'\000';
  memset((void *)(& action), 0, sizeof(action));
  action.__sigaction_handler.sa_handler = & sig_handler;
  sigaction(2, (struct sigaction  const  * __restrict  )(& action), (struct sigaction * __restrict  )((void *)0));
  sigaction(15, (struct sigaction  const  * __restrict  )(& action), (struct sigaction * __restrict  )((void *)0));
  sigaction(10, (struct sigaction  const  * __restrict  )(& action), (struct sigaction * __restrict  )((void *)0));
  sigaction(12, (struct sigaction  const  * __restrict  )(& action), (struct sigaction * __restrict  )((void *)0));
  usage = (char *)"\nUsage : cava [options]\nVisualize audio input in terminal. \n\nOptions:\n\t-p          path to config file\n\t-v          print version\n\nKeys:\n        Up        Increase sensitivity\n        Down      Decrease sensitivity\n        Left      Decrease number of bars\n        Right     Increase number of bars\n        r         Reload config\n        c         Reload colors only\n        f         Cycle foreground color\n        b         Cycle background color\n        q         Quit\n\nas of 0.4.0 all options are specified in config file, see in \'/home/username/.config/cava/\' \n";
  while (1) {
    c = getopt(argc, (char * const  *)argv, "p:vh");
    if (! (c != -1)) {
      break;
    }
    switch (c) {
    case 112: 
    snprintf((char * __restrict  )(configPath), sizeof(configPath), (char const   * __restrict  )"%s",
             optarg);
    break;
    case 104: 
    printf((char const   * __restrict  )"%s", usage);
    return (1);
    case 63: 
    printf((char const   * __restrict  )"%s", usage);
    return (1);
    case 118: 
    printf((char const   * __restrict  )"cava 0.7.4-3-g4c0acb7\n");
    return (0);
    default: 
    abort();
    }
  }
  while (1) {
    while (1) {
      break;
    }
    error.length = 0;
    tmp = load_config((char *)(configPath), & p, (_Bool)0, & error);
    if (! tmp) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error loading config. %s",
              error.message);
      exit(1);
    }
    first = (_Bool)1;
    output_mode = (int )p.output;
    if (output_mode != 2) {
      inAtty = 0;
      tmp___0 = ttyname(0);
      tmp___1 = strncmp((char const   *)tmp___0, "/dev/tty", (size_t )8);
      if (tmp___1 == 0) {
        inAtty = 1;
      } else {
        tmp___2 = ttyname(0);
        tmp___3 = strcmp((char const   *)tmp___2, "/dev/console");
        if (tmp___3 == 0) {
          inAtty = 1;
        }
      }
      tmp___4 = ttyname(0);
      tmp___5 = strncmp((char const   *)tmp___4, "/dev/ttys", (size_t )9);
      if (tmp___5 == 0) {
        inAtty = 0;
      }
      if (inAtty) {
        font_file = fopen((char const   * __restrict  )"/usr/local/share/consolefonts/cava.psf",
                          (char const   * __restrict  )"r");
        if (font_file) {
          fclose(font_file);
          system("setfont /usr/local/share/consolefonts/cava.psf  >/dev/null 2>&1");
        } else {
          system("setfont cava.psf  >/dev/null 2>&1");
        }
        system("setterm -blank 0");
      }
      tmp___6 = getenv("LANG");
      if (tmp___6) {
        setlocale(6, "");
      } else {
        setlocale(6, "en_US.utf8");
      }
    }
    bass_cut_off = 150;
    treble_cut_off = 2500;
    memset((void *)(& audio), 0, sizeof(audio));
    tmp___7 = strlen((char const   *)p.audio_source);
    tmp___8 = malloc(1UL + tmp___7);
    audio.source = (char *)tmp___8;
    strcpy((char * __restrict  )audio.source, (char const   * __restrict  )p.audio_source);
    audio.format = -1;
    audio.rate = 0U;
    audio.FFTbassbufferSize = 4096;
    audio.FFTmidbufferSize = 2048;
    audio.FFTtreblebufferSize = 1024;
    audio.terminate = 0;
    if (p.stereo) {
      audio.channels = 2U;
    }
    if (! p.stereo) {
      audio.channels = 1U;
    }
    audio.average = (_Bool)0;
    audio.left = (_Bool)0;
    audio.right = (_Bool)0;
    tmp___9 = strcmp((char const   *)p.mono_option, "average");
    if (tmp___9 == 0) {
      audio.average = (_Bool)1;
    }
    tmp___10 = strcmp((char const   *)p.mono_option, "left");
    if (tmp___10 == 0) {
      audio.left = (_Bool)1;
    }
    tmp___11 = strcmp((char const   *)p.mono_option, "right");
    if (tmp___11 == 0) {
      audio.right = (_Bool)1;
    }
    audio.bass_index = 0;
    audio.mid_index = 0;
    audio.treble_index = 0;
    tmp___12 = malloc((unsigned long )audio.FFTbassbufferSize * sizeof(double ));
    audio.bass_multiplier = (double *)tmp___12;
    tmp___13 = malloc((unsigned long )audio.FFTmidbufferSize * sizeof(double ));
    audio.mid_multiplier = (double *)tmp___13;
    tmp___14 = malloc((unsigned long )audio.FFTtreblebufferSize * sizeof(double ));
    audio.treble_multiplier = (double *)tmp___14;
    tmp___15 = malloc((unsigned long )(audio.FFTbassbufferSize / 2 + 1) * sizeof(double ));
    temp_l = (double *)tmp___15;
    tmp___16 = malloc((unsigned long )(audio.FFTbassbufferSize / 2 + 1) * sizeof(double ));
    temp_r = (double *)tmp___16;
    tmp___17 = malloc(256UL * sizeof(int ));
    bars_left = (int *)tmp___17;
    tmp___18 = malloc(256UL * sizeof(int ));
    bars_right = (int *)tmp___18;
    i = 0;
    while (i < audio.FFTbassbufferSize) {
      tmp___19 = cos((((double )2 * 3.14159265358979323846) * (double )i) / (double )(audio.FFTbassbufferSize - 1));
      *(audio.bass_multiplier + i) = 0.5 * ((double )1 - tmp___19);
      i ++;
    }
    i___0 = 0;
    while (i___0 < audio.FFTmidbufferSize) {
      tmp___20 = cos((((double )2 * 3.14159265358979323846) * (double )i___0) / (double )(audio.FFTmidbufferSize - 1));
      *(audio.mid_multiplier + i___0) = 0.5 * ((double )1 - tmp___20);
      i___0 ++;
    }
    i___1 = 0;
    while (i___1 < audio.FFTtreblebufferSize) {
      tmp___21 = cos((((double )2 * 3.14159265358979323846) * (double )i___1) / (double )(audio.FFTtreblebufferSize - 1));
      *(audio.treble_multiplier + i___1) = 0.5 * ((double )1 - tmp___21);
      i___1 ++;
    }
    audio.in_bass_r = fftw_alloc_real((size_t )audio.FFTbassbufferSize);
    audio.in_bass_l = fftw_alloc_real((size_t )audio.FFTbassbufferSize);
    audio.in_bass_r_raw = fftw_alloc_real((size_t )audio.FFTbassbufferSize);
    audio.in_bass_l_raw = fftw_alloc_real((size_t )audio.FFTbassbufferSize);
    out_bass_l = fftw_alloc_complex((size_t )(audio.FFTbassbufferSize / 2 + 1));
    out_bass_r = fftw_alloc_complex((size_t )(audio.FFTbassbufferSize / 2 + 1));
    memset((void *)out_bass_l, 0, (unsigned long )(audio.FFTbassbufferSize / 2 + 1) * sizeof(fftw_complex ));
    memset((void *)out_bass_r, 0, (unsigned long )(audio.FFTbassbufferSize / 2 + 1) * sizeof(fftw_complex ));
    p_bass_l = fftw_plan_dft_r2c_1d(audio.FFTbassbufferSize, audio.in_bass_l, out_bass_l,
                                    0U);
    p_bass_r = fftw_plan_dft_r2c_1d(audio.FFTbassbufferSize, audio.in_bass_r, out_bass_r,
                                    0U);
    audio.in_mid_r = fftw_alloc_real((size_t )audio.FFTmidbufferSize);
    audio.in_mid_l = fftw_alloc_real((size_t )audio.FFTmidbufferSize);
    audio.in_mid_r_raw = fftw_alloc_real((size_t )audio.FFTmidbufferSize);
    audio.in_mid_l_raw = fftw_alloc_real((size_t )audio.FFTmidbufferSize);
    out_mid_l = fftw_alloc_complex((size_t )(audio.FFTmidbufferSize / 2 + 1));
    out_mid_r = fftw_alloc_complex((size_t )(audio.FFTmidbufferSize / 2 + 1));
    memset((void *)out_mid_l, 0, (unsigned long )(audio.FFTmidbufferSize / 2 + 1) * sizeof(fftw_complex ));
    memset((void *)out_mid_r, 0, (unsigned long )(audio.FFTmidbufferSize / 2 + 1) * sizeof(fftw_complex ));
    p_mid_l = fftw_plan_dft_r2c_1d(audio.FFTmidbufferSize, audio.in_mid_l, out_mid_l,
                                   0U);
    p_mid_r = fftw_plan_dft_r2c_1d(audio.FFTmidbufferSize, audio.in_mid_r, out_mid_r,
                                   0U);
    audio.in_treble_r = fftw_alloc_real((size_t )audio.FFTtreblebufferSize);
    audio.in_treble_l = fftw_alloc_real((size_t )audio.FFTtreblebufferSize);
    audio.in_treble_r_raw = fftw_alloc_real((size_t )audio.FFTtreblebufferSize);
    audio.in_treble_l_raw = fftw_alloc_real((size_t )audio.FFTtreblebufferSize);
    out_treble_l = fftw_alloc_complex((size_t )(audio.FFTtreblebufferSize / 2 + 1));
    out_treble_r = fftw_alloc_complex((size_t )(audio.FFTtreblebufferSize / 2 + 1));
    memset((void *)out_treble_l, 0, (unsigned long )(audio.FFTtreblebufferSize / 2 + 1) * sizeof(fftw_complex ));
    memset((void *)out_treble_r, 0, (unsigned long )(audio.FFTtreblebufferSize / 2 + 1) * sizeof(fftw_complex ));
    p_treble_l = fftw_plan_dft_r2c_1d(audio.FFTtreblebufferSize, audio.in_treble_l,
                                      out_treble_l, 0U);
    p_treble_r = fftw_plan_dft_r2c_1d(audio.FFTtreblebufferSize, audio.in_treble_r,
                                      out_treble_r, 0U);
    while (1) {
      break;
    }
    reset_output_buffers(& audio);
    while (1) {
      break;
    }
    timeout_counter = 0;
    timeout_timer.tv_sec = (__time_t )0;
    timeout_timer.tv_nsec = (__syscall_slong_t )1000000;
    switch ((unsigned int )p.input) {
    case 2U: 
    tmp___24 = is_loop_device_for_sure((char const   *)audio.source);
    if (tmp___24) {
      tmp___23 = directory_exists("/sys/");
      if (tmp___23) {
        tmp___22 = directory_exists("/sys/module/snd_aloop/");
        if (! tmp___22) {
          cleanup();
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Linux kernel module \"snd_aloop\" does not seem to  be loaded.\nMaybe run \"sudo modprobe snd_aloop\".\n");
          exit(1);
        }
      }
    }
    thr_id = pthread_create((pthread_t * __restrict  )(& p_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                            & input_alsa, (void * __restrict  )((void *)(& audio)));
    timeout_counter = 0;
    while (1) {
      if (! (audio.format == -1)) {
        if (! (audio.rate == 0U)) {
          break;
        }
      }
      nanosleep((struct timespec  const  *)(& timeout_timer), (struct timespec *)((void *)0));
      timeout_counter ++;
      if (timeout_counter > 2000) {
        cleanup();
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"could not get rate and/or format, problems with audio thread? quiting...\n");
        exit(1);
      }
    }
    while (1) {
      break;
    }
    break;
    case 0U: 
    thr_id = pthread_create((pthread_t * __restrict  )(& p_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                            & input_fifo, (void * __restrict  )((void *)(& audio)));
    audio.rate = (unsigned int )p.fifoSample;
    audio.format = p.fifoSampleBits;
    break;
    case 3U: 
    tmp___25 = strcmp((char const   *)audio.source, "auto");
    if (tmp___25 == 0) {
      getPulseDefaultSink((void *)(& audio));
    }
    thr_id = pthread_create((pthread_t * __restrict  )(& p_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                            & input_pulse, (void * __restrict  )((void *)(& audio)));
    audio.rate = 44100U;
    break;
    case 5U: 
    thr_id = pthread_create((pthread_t * __restrict  )(& p_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                            & input_shmem, (void * __restrict  )((void *)(& audio)));
    timeout_counter = 0;
    while (audio.rate == 0U) {
      nanosleep((struct timespec  const  *)(& timeout_timer), (struct timespec *)((void *)0));
      timeout_counter ++;
      if (timeout_counter > 2000) {
        cleanup();
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"could not get rate and/or format, problems with audio thread? quiting...\n");
        exit(1);
      }
    }
    while (1) {
      break;
    }
    break;
    default: 
    exit(1);
    }
    if (p.upper_cut_off > audio.rate / 2U) {
      cleanup();
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"higher cuttoff frequency can\'t be higher than sample rate / 2");
      exit(1);
    }
    reloadConf = (_Bool)0;
    while (! reloadConf) {
      n = 0;
      while (n < 256) {
        bars_last[n] = 0;
        previous_frame[n] = 0;
        fall[n] = 0;
        bars_peak[n] = (float )0;
        bars_mem[n] = 0;
        bars[n] = 0;
        n ++;
      }
      if ((unsigned int )p.xaxis == 1U) {
        if (p.bar_width < 4) {
          p.bar_width = 4;
        }
      }
      switch (output_mode) {
      case 0: 
      init_terminal_ncurses((char * const  )p.color, (char * const  )p.bcolor, p.col,
                            p.bgcol, p.gradient, p.gradient_count, p.gradient_colors,
                            & width, & lines);
      if ((unsigned int )p.xaxis != 0U) {
        lines --;
      }
      height = lines * 8;
      break;
      case 1: 
      get_terminal_dim_noncurses(& width, & lines);
      if ((unsigned int )p.xaxis != 0U) {
        lines --;
      }
      init_terminal_noncurses(inAtty, p.col, p.bgcol, width, lines, p.bar_width);
      height = lines * 8;
      break;
      case 2: 
      tmp___28 = strcmp((char const   *)p.raw_target, "/dev/stdout");
      if (tmp___28 != 0) {
        tmp___27 = access((char const   *)p.raw_target, 0);
        if (tmp___27 != -1) {
          fptest = open((char const   *)p.raw_target, 2048, 420);
          if (fptest == -1) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"could not open file %s for writing\n",
                    p.raw_target);
            exit(1);
          }
        } else {
          printf((char const   * __restrict  )"creating fifo %s\n", p.raw_target);
          tmp___26 = mkfifo((char const   *)p.raw_target, (__mode_t )436);
          if (tmp___26 == -1) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"could not create fifo %s\n",
                    p.raw_target);
            exit(1);
          }
          fptest = open((char const   *)p.raw_target, 2048, 420);
        }
        fp = open((char const   *)p.raw_target, 2113, 420);
      } else {
        fp = fileno(stdout);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Opening stdout\n");
      }
      if (fp == -1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"could not open file %s for writing\n",
                p.raw_target);
        exit(1);
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"open file %s for writing raw output\n",
              p.raw_target);
      width = 256;
      tmp___30 = strcmp((char const   *)p.data_format, "binary");
      if (tmp___30 == 0) {
        tmp___29 = pow((double )2, (double )p.bit_format);
        height = (int )(tmp___29 - (double )1);
      } else {
        height = p.ascii_range;
      }
      break;
      default: 
      exit(1);
      }
      if (p.fixedbars) {
        p.autobars = 0;
        if ((p.fixedbars * p.bar_width + p.fixedbars * p.bar_spacing) - p.bar_spacing > width) {
          p.autobars = 1;
        }
      }
      number_of_bars = p.fixedbars;
      if (p.autobars == 1) {
        number_of_bars = (width + p.bar_spacing) / (p.bar_width + p.bar_spacing);
      }
      if (number_of_bars < 1) {
        number_of_bars = 1;
      }
      if (number_of_bars > 256) {
        number_of_bars = 256;
      }
      if (p.stereo) {
        if (number_of_bars % 2 != 0) {
          number_of_bars --;
        }
      }
      remainder___0 = (((width - number_of_bars * p.bar_width) - number_of_bars * p.bar_spacing) + p.bar_spacing) / 2;
      if (remainder___0 < 0) {
        remainder___0 = 0;
      }
      tmp___31 = pow((double )((float )60 / (float )p.framerate), 2.5);
      g = (float )((p.gravity * (double )((float )height / (float )2160)) * tmp___31);
      integral = p.integral;
      if (height > 320) {
        tmp___32 = log10((double )((float )height / (float )10));
        tmp___33 = sqrt(tmp___32);
        integral = (p.integral * (double )1) / tmp___33;
      }
      if (p.stereo) {
        number_of_bars /= 2;
      }
      if (p.userEQ_enabled) {
        if (number_of_bars > 0) {
          userEQ_keys_to_bars_ratio = (double )p.userEQ_keys / (double )number_of_bars;
        }
      }
      tmp___34 = log10((double )((float )p.lower_cut_off / (float )p.upper_cut_off));
      frequency_constant = tmp___34 / (double )((float )1 / ((float )number_of_bars + (float )1) - (float )1);
      bass_cut_off_bar = -1;
      treble_cut_off_bar = -1;
      first_bar = (_Bool)1;
      first_treble_bar = 0;
      int bar_buffer[number_of_bars + 1] ;
      n___0 = 0;
      while (n___0 < number_of_bars + 1) {
        bar_distribution_coefficient = frequency_constant * (double )-1;
        bar_distribution_coefficient += (double )(((float )n___0 + (float )1) / ((float )number_of_bars + (float )1)) * frequency_constant;
        tmp___35 = pow((double )10, bar_distribution_coefficient);
        cut_off_frequency[n___0] = (float )((double )p.upper_cut_off * tmp___35);
        if (n___0 > 0) {
          if (cut_off_frequency[n___0 - 1] >= cut_off_frequency[n___0]) {
            if (cut_off_frequency[n___0 - 1] > (float )bass_cut_off) {
              cut_off_frequency[n___0] = cut_off_frequency[n___0 - 1] + (cut_off_frequency[n___0 - 1] - cut_off_frequency[n___0 - 2]);
            }
          }
        }
        relative_cut_off[n___0] = cut_off_frequency[n___0] / (float )(audio.rate / 2U);
        eq[n___0] = pow((double )cut_off_frequency[n___0], (double )1);
        tmp___36 = pow((double )2, (double )28);
        eq[n___0] *= (double )((float )height) / tmp___36;
        if (p.userEQ_enabled) {
          tmp___37 = floor((double )n___0 * userEQ_keys_to_bars_ratio);
          eq[n___0] *= *(p.userEQ + (int )tmp___37);
        }
        tmp___38 = log2((double )audio.FFTbassbufferSize);
        eq[n___0] /= tmp___38;
        if (cut_off_frequency[n___0] < (float )bass_cut_off) {
          bar_buffer[n___0] = 1;
          FFTbuffer_lower_cut_off[n___0] = (int )(relative_cut_off[n___0] * (float )(audio.FFTbassbufferSize / 2));
          bass_cut_off_bar ++;
          treble_cut_off_bar ++;
          if (bass_cut_off_bar > 0) {
            first_bar = (_Bool)0;
          }
          tmp___39 = log2((double )audio.FFTbassbufferSize);
          eq[n___0] *= tmp___39;
        } else
        if (cut_off_frequency[n___0] > (float )bass_cut_off) {
          if (cut_off_frequency[n___0] < (float )treble_cut_off) {
            bar_buffer[n___0] = 2;
            FFTbuffer_lower_cut_off[n___0] = (int )(relative_cut_off[n___0] * (float )(audio.FFTmidbufferSize / 2));
            treble_cut_off_bar ++;
            if (treble_cut_off_bar - bass_cut_off_bar == 1) {
              first_bar = (_Bool)1;
              FFTbuffer_upper_cut_off[n___0 - 1] = (int )(relative_cut_off[n___0] * (float )(audio.FFTbassbufferSize / 2));
            } else {
              first_bar = (_Bool)0;
            }
            tmp___40 = log2((double )audio.FFTmidbufferSize);
            eq[n___0] *= tmp___40;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          bar_buffer[n___0] = 3;
          FFTbuffer_lower_cut_off[n___0] = (int )(relative_cut_off[n___0] * (float )(audio.FFTtreblebufferSize / 2));
          first_treble_bar ++;
          if (first_treble_bar == 1) {
            first_bar = (_Bool)1;
            FFTbuffer_upper_cut_off[n___0 - 1] = (int )(relative_cut_off[n___0] * (float )(audio.FFTmidbufferSize / 2));
          } else {
            first_bar = (_Bool)0;
          }
          tmp___41 = log2((double )audio.FFTtreblebufferSize);
          eq[n___0] *= tmp___41;
        }
        if (n___0 > 0) {
          if (! first_bar) {
            FFTbuffer_upper_cut_off[n___0 - 1] = FFTbuffer_lower_cut_off[n___0] - 1;
            if (FFTbuffer_lower_cut_off[n___0] <= FFTbuffer_lower_cut_off[n___0 - 1]) {
              FFTbuffer_lower_cut_off[n___0] = FFTbuffer_lower_cut_off[n___0 - 1] + 1;
              FFTbuffer_upper_cut_off[n___0 - 1] = FFTbuffer_lower_cut_off[n___0] - 1;
              if (bar_buffer[n___0] == 1) {
                relative_cut_off[n___0] = (float )FFTbuffer_lower_cut_off[n___0] / ((float )audio.FFTbassbufferSize / (float )2);
              } else
              if (bar_buffer[n___0] == 2) {
                relative_cut_off[n___0] = (float )FFTbuffer_lower_cut_off[n___0] / ((float )audio.FFTmidbufferSize / (float )2);
              } else
              if (bar_buffer[n___0] == 3) {
                relative_cut_off[n___0] = (float )FFTbuffer_lower_cut_off[n___0] / ((float )audio.FFTtreblebufferSize / (float )2);
              }
              cut_off_frequency[n___0] = relative_cut_off[n___0] * ((float )audio.rate / (float )2);
            }
          } else
          if (FFTbuffer_upper_cut_off[n___0 - 1] <= FFTbuffer_lower_cut_off[n___0 - 1]) {
            FFTbuffer_upper_cut_off[n___0 - 1] = FFTbuffer_lower_cut_off[n___0 - 1] + 1;
          }
          upper_cut_off_frequency[n___0 - 1] = cut_off_frequency[n___0];
          center_frequencies[n___0 - 1] = pow((double )(cut_off_frequency[n___0 - 1] * upper_cut_off_frequency[n___0 - 1]),
                                              0.5);
        }
        n___0 ++;
      }
      if (p.stereo) {
        number_of_bars *= 2;
      }
      x_axis_info = 0;
      if ((unsigned int )p.xaxis != 0U) {
        x_axis_info = 1;
        if (output_mode == 1) {
          printf((char const   * __restrict  )"\r\033[%dB", lines + 1);
          if (remainder___0) {
            printf((char const   * __restrict  )"\033[%dC", remainder___0);
          }
        }
        n___1 = 0;
        while (n___1 < number_of_bars) {
          if (p.stereo) {
            if (n___1 < number_of_bars / 2) {
              center_frequency = center_frequencies[(number_of_bars / 2 - 1) - n___1];
            } else {
              center_frequency = center_frequencies[n___1 - number_of_bars / 2];
            }
          } else {
            center_frequency = center_frequencies[n___1];
          }
          freq_kilohz = (float )(center_frequency / (double )1000);
          freq_floor = (int )center_frequency;
          if (output_mode == 0) {
            if (center_frequency < (double )1000) {
              mvprintw(lines, n___1 * (p.bar_width + p.bar_spacing) + remainder___0,
                       "%-4d", freq_floor);
            } else
            if (center_frequency > (double )1000) {
              if (center_frequency < (double )10000) {
                mvprintw(lines, n___1 * (p.bar_width + p.bar_spacing) + remainder___0,
                         "%.2f", (double )freq_kilohz);
              } else {
                mvprintw(lines, n___1 * (p.bar_width + p.bar_spacing) + remainder___0,
                         "%.1f", (double )freq_kilohz);
              }
            } else {
              mvprintw(lines, n___1 * (p.bar_width + p.bar_spacing) + remainder___0,
                       "%.1f", (double )freq_kilohz);
            }
          } else
          if (output_mode == 1) {
            if (center_frequency < (double )1000) {
              printf((char const   * __restrict  )"%-4d", freq_floor);
            } else
            if (center_frequency > (double )1000) {
              if (center_frequency < (double )10000) {
                printf((char const   * __restrict  )"%.2f", (double )freq_kilohz);
              } else {
                printf((char const   * __restrict  )"%.1f", (double )freq_kilohz);
              }
            } else {
              printf((char const   * __restrict  )"%.1f", (double )freq_kilohz);
            }
            if (n___1 < number_of_bars - 1) {
              printf((char const   * __restrict  )"\033[%dC", (p.bar_width + p.bar_spacing) - 4);
            }
          }
          n___1 ++;
        }
        printf((char const   * __restrict  )"\r\033[%dA", lines + 1);
      }
      resizeTerminal = (_Bool)0;
      framerate_timer.tv_sec = (__time_t )0;
      framerate_timer.tv_nsec = (__syscall_slong_t )0;
      if (p.framerate <= 1) {
        framerate_timer.tv_sec = (__time_t )((float )1 / (float )p.framerate);
      } else {
        framerate_timer.tv_sec = (__time_t )0;
        framerate_timer.tv_nsec = (__syscall_slong_t )((double )((float )1 / (float )p.framerate) * 1e9);
      }
      sleep_counter = 0;
      silence = (_Bool)0;
      ch = (char )'\000';
      sleep_mode_timer.tv_sec = (__time_t )1;
      sleep_mode_timer.tv_nsec = (__syscall_slong_t )0;
      while (! resizeTerminal) {
        if (output_mode == 0) {
          tmp___42 = wgetch(stdscr);
          ch = (char )tmp___42;
        }
        switch ((int )ch) {
        case 65: 
        p.sens *= 1.05;
        break;
        case 66: 
        p.sens *= 0.95;
        break;
        case 68: 
        (p.bar_width) ++;
        resizeTerminal = (_Bool)1;
        break;
        case 67: 
        if (p.bar_width > 1) {
          (p.bar_width) --;
        }
        resizeTerminal = (_Bool)1;
        break;
        case 114: 
        should_reload = 1;
        break;
        case 99: 
        reload_colors = 1;
        break;
        case 102: 
        if (p.col < 7) {
          (p.col) ++;
        } else {
          p.col = 0;
        }
        resizeTerminal = (_Bool)1;
        break;
        case 98: 
        if (p.bgcol < 7) {
          (p.bgcol) ++;
        } else {
          p.bgcol = 0;
        }
        resizeTerminal = (_Bool)1;
        break;
        case 113: 
        should_reload = 1;
        should_quit = 1;
        }
        if (should_reload) {
          reloadConf = (_Bool)1;
          resizeTerminal = (_Bool)1;
          should_reload = 0;
        }
        if (reload_colors) {
          error___0.length = 0;
          tmp___43 = load_config((char *)(configPath), (struct config_params *)((void *)(& p)),
                                 (_Bool)1, & error___0);
          if (! tmp___43) {
            cleanup();
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error loading config. %s",
                    error___0.message);
            exit(1);
          }
          resizeTerminal = (_Bool)1;
          reload_colors = 0;
        }
        silence = (_Bool)1;
        n___2 = 0;
        while (n___2 < audio.FFTbassbufferSize) {
          if (*(audio.in_bass_l + n___2)) {
            silence = (_Bool)0;
            break;
          } else
          if (*(audio.in_bass_r + n___2)) {
            silence = (_Bool)0;
            break;
          }
          n___2 ++;
        }
        if (p.sleep_timer) {
          if (silence) {
            if (sleep_counter <= p.framerate * p.sleep_timer) {
              sleep_counter ++;
            } else {
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
          if (! silence) {
            sleep_counter = 0;
          }
          if (sleep_counter > p.framerate * p.sleep_timer) {
            nanosleep((struct timespec  const  *)(& sleep_mode_timer), (struct timespec *)((void *)0));
            continue;
          }
        }
        pthread_mutex_lock(& lock);
        fftw_execute((fftw_plan const   )p_bass_l);
        fftw_execute((fftw_plan const   )p_mid_l);
        fftw_execute((fftw_plan const   )p_treble_l);
        if (p.stereo) {
          fftw_execute((fftw_plan const   )p_bass_r);
          fftw_execute((fftw_plan const   )p_mid_r);
          fftw_execute((fftw_plan const   )p_treble_r);
          number_of_bars /= 2;
        }
        pthread_mutex_unlock(& lock);
        n___3 = 0;
        while (n___3 < number_of_bars) {
          *(temp_l + n___3) = (double )0;
          if (p.stereo) {
            *(temp_r + n___3) = (double )0;
          }
          i___2 = FFTbuffer_lower_cut_off[n___3];
          while (i___2 <= FFTbuffer_upper_cut_off[n___3]) {
            if (n___3 <= bass_cut_off_bar) {
              tmp___44 = hypot((*(out_bass_l + i___2))[0], (*(out_bass_l + i___2))[1]);
              *(temp_l + n___3) += tmp___44;
              if (p.stereo) {
                tmp___45 = hypot((*(out_bass_r + i___2))[0], (*(out_bass_r + i___2))[1]);
                *(temp_r + n___3) += tmp___45;
              }
            } else
            if (n___3 > bass_cut_off_bar) {
              if (n___3 <= treble_cut_off_bar) {
                tmp___46 = hypot((*(out_mid_l + i___2))[0], (*(out_mid_l + i___2))[1]);
                *(temp_l + n___3) += tmp___46;
                if (p.stereo) {
                  tmp___47 = hypot((*(out_mid_r + i___2))[0], (*(out_mid_r + i___2))[1]);
                  *(temp_r + n___3) += tmp___47;
                }
              } else {
                goto _L___1;
              }
            } else
            _L___1: /* CIL Label */ 
            if (n___3 > treble_cut_off_bar) {
              tmp___48 = hypot((*(out_treble_l + i___2))[0], (*(out_treble_l + i___2))[1]);
              *(temp_l + n___3) += tmp___48;
              if (p.stereo) {
                tmp___49 = hypot((*(out_treble_r + i___2))[0], (*(out_treble_r + i___2))[1]);
                *(temp_r + n___3) += tmp___49;
              }
            }
            i___2 ++;
          }
          *(temp_l + n___3) /= (double )((FFTbuffer_upper_cut_off[n___3] - FFTbuffer_lower_cut_off[n___3]) + 1);
          *(temp_l + n___3) *= p.sens * eq[n___3];
          if (*(temp_l + n___3) <= p.ignore) {
            *(temp_l + n___3) = (double )0;
          }
          *(bars_left + n___3) = (int )*(temp_l + n___3);
          if (p.stereo) {
            *(temp_r + n___3) /= (double )((FFTbuffer_upper_cut_off[n___3] - FFTbuffer_lower_cut_off[n___3]) + 1);
            *(temp_r + n___3) *= p.sens * eq[n___3];
            if (*(temp_r + n___3) <= p.ignore) {
              *(temp_r + n___3) = (double )0;
            }
            *(bars_right + n___3) = (int )*(temp_r + n___3);
          }
          n___3 ++;
        }
        if (p.stereo) {
          number_of_bars *= 2;
        }
        if (p.monstercat) {
          if (p.stereo) {
            bars_left = monstercat_filter(bars_left, number_of_bars / 2, p.waves,
                                          p.monstercat);
            bars_right = monstercat_filter(bars_right, number_of_bars / 2, p.waves,
                                           p.monstercat);
          } else {
            bars_left = monstercat_filter(bars_left, number_of_bars, p.waves, p.monstercat);
          }
        }
        senselow = (_Bool)1;
        n___4 = 0;
        while (n___4 < number_of_bars) {
          if (p.stereo) {
            if (n___4 < number_of_bars / 2) {
              bars[n___4] = *(bars_left + ((number_of_bars / 2 - n___4) - 1));
            } else {
              bars[n___4] = *(bars_right + (n___4 - number_of_bars / 2));
            }
          } else {
            bars[n___4] = *(bars_left + n___4);
          }
          if (g > (float )0) {
            if (bars[n___4] < bars_last[n___4]) {
              bars[n___4] = (int )(bars_peak[n___4] - (g * (float )fall[n___4]) * (float )fall[n___4]);
              if (bars[n___4] < 0) {
                bars[n___4] = 0;
              }
              (fall[n___4]) ++;
            } else {
              bars_peak[n___4] = (float )bars[n___4];
              fall[n___4] = 0;
            }
            bars_last[n___4] = bars[n___4];
          }
          if (p.integral > (double )0) {
            bars[n___4] = (int )((double )bars_mem[n___4] * integral + (double )bars[n___4]);
            bars_mem[n___4] = bars[n___4];
            diff = height - bars[n___4];
            if (diff < 0) {
              diff = 0;
            }
            div___0 = (double )(1 / (diff + 1));
            bars_mem[n___4] = (int )((double )bars_mem[n___4] * ((double )1 - div___0 / (double )20));
          }
          if (output_mode != 2) {
            if (bars[n___4] < 1) {
              bars[n___4] = 1;
            }
          }
          if (p.autosens) {
            if (! silence) {
              if (bars[n___4] > height) {
                if (senselow) {
                  p.sens *= 0.98;
                  senselow = (_Bool)0;
                  first = (_Bool)0;
                }
              }
            }
          }
          n___4 ++;
        }
        if (p.autosens) {
          if (! silence) {
            if (senselow) {
              p.sens *= 1.001;
              if (first) {
                p.sens *= 1.1;
              }
            }
          }
        }
        switch (output_mode) {
        case 0: 
        rc___0 = draw_terminal_ncurses(inAtty, lines, width, number_of_bars, p.bar_width,
                                       p.bar_spacing, remainder___0, (int const   *)(bars),
                                       (int *)(previous_frame), p.gradient, x_axis_info);
        break;
        case 1: 
        rc___0 = draw_terminal_noncurses(inAtty, lines, width, number_of_bars, p.bar_width,
                                         p.bar_spacing, remainder___0, (int *)(bars),
                                         (int *)(previous_frame), x_axis_info);
        break;
        case 2: 
        rc___0 = print_raw_out(number_of_bars, fp, p.is_bin, p.bit_format, p.ascii_range,
                               p.bar_delim, p.frame_delim, (int const   *)(bars));
        break;
        default: 
        exit(1);
        }
        if (rc___0 == -1) {
          resizeTerminal = (_Bool)1;
        }
        memcpy((void * __restrict  )(previous_frame), (void const   * __restrict  )(bars),
               256UL * sizeof(int ));
        if (audio.terminate == 1) {
          cleanup();
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Audio thread exited unexpectedly. %s\n",
                  audio.error_message);
          exit(1);
        }
        nanosleep((struct timespec  const  *)(& framerate_timer), (struct timespec *)((void *)0));
      }
    }
    audio.terminate = 1;
    pthread_join(p_thread, (void **)((void *)0));
    if (p.userEQ_enabled) {
      free((void *)p.userEQ);
    }
    free((void *)audio.source);
    fftw_free((void *)audio.in_bass_r);
    fftw_free((void *)audio.in_bass_l);
    fftw_free((void *)out_bass_r);
    fftw_free((void *)out_bass_l);
    fftw_destroy_plan(p_bass_l);
    fftw_destroy_plan(p_bass_r);
    fftw_free((void *)audio.in_mid_r);
    fftw_free((void *)audio.in_mid_l);
    fftw_free((void *)out_mid_r);
    fftw_free((void *)out_mid_l);
    fftw_destroy_plan(p_mid_l);
    fftw_destroy_plan(p_mid_r);
    fftw_free((void *)audio.in_treble_r);
    fftw_free((void *)audio.in_treble_l);
    fftw_free((void *)out_treble_r);
    fftw_free((void *)out_treble_l);
    fftw_destroy_plan(p_treble_l);
    fftw_destroy_plan(p_treble_r);
    cleanup();
    if (should_quit) {
      return (0);
    }
  }
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-QH0j8jKg.i","-std=c99,-Wall,-Werror,-Wextra,-Wno-unused-result,-Wno-unknown-warning-option,-Wno-maybe-uninitialized,-Wno-vla-parameter,-g,-O2")
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern int iniparser_getsecnkeys(dictionary const   *d , char const   *s ) ;
extern char const   **iniparser_getseckeys(dictionary const   *d , char const   *s ,
                                           char const   **keys ) ;
extern char const   *iniparser_getstring(dictionary const   *d , char const   *key ,
                                         char const   *def ) ;
extern int iniparser_getint(dictionary const   *d , char const   *key , int notfound ) ;
extern double iniparser_getdouble(dictionary const   *d , char const   *key , double notfound ) ;
extern dictionary *iniparser_load(char const   *ininame ) ;
extern void iniparser_freedict(dictionary *d ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
double smoothDef[5]  = {      (double )1,      (double )1,      (double )1,      (double )1, 
        (double )1};
enum input_method default_methods[4]  = {      (enum input_method )0,      (enum input_method )1,      (enum input_method )2,      (enum input_method )3};
char *outputMethod  ;
char *channels  ;
char *xaxisScale  ;
char const   *input_method_names[6]  = {      "fifo",      "portaudio",      "alsa",      "pulse", 
        "sndio",      "shmem"};
_Bool const   has_input_method[6]  = {      (_Bool const   )1,      (_Bool const   )0,      (_Bool const   )1,      (_Bool const   )1, 
        (_Bool const   )0,      (_Bool const   )1};
enum input_method input_method_by_name(char const   *str ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < 6) {
    tmp = strcmp(str, input_method_names[i]);
    if (! tmp) {
      return ((enum input_method )i);
    }
    i ++;
  }
  return ((enum input_method )6);
}
}
void write_errorf(void *err , char const   *fmt  , ...) 
{ 
  struct error_s *error ;
  va_list___0 args ;
  int tmp ;

  {
  error = (struct error_s *)err;
  __builtin_va_start(args, fmt);
  tmp = vsnprintf((char * __restrict  )(error->message + error->length), (size_t )(1024 - error->length),
                  (char const   * __restrict  )fmt, args);
  error->length += tmp;
  __builtin_va_end(args);
  return;
}
}
int validate_color(char *checkColor , void *params , void *err ) 
{ 
  struct config_params *p___0 ;
  struct error_s *error ;
  int validColor ;
  int i ;
  int __res ;
  __int32_t const   **tmp___0 ;
  int __res___0 ;
  __int32_t const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;

  {
  p___0 = (struct config_params *)params;
  error = (struct error_s *)err;
  validColor = 0;
  if ((int )*(checkColor + 0) == 35) {
    tmp___13 = strlen((char const   *)checkColor);
    if (tmp___13 == 7UL) {
      if ((unsigned int )p___0->output != 0U) {
        write_errorf((void *)error, "hex color configured, but ncurses not set. Forcing ncurses mode.\n");
        p___0->output = (enum output_method )0;
      }
      i = 1;
      while (*(checkColor + i)) {
        tmp___3 = __ctype_b_loc();
        if ((int const   )*(*tmp___3 + (int )*(checkColor + i)) & 2048) {
          validColor = 1;
        } else {
          if (sizeof(*(checkColor + i)) > 1UL) {
            __res = tolower((int )*(checkColor + i));
          } else {
            tmp___0 = __ctype_tolower_loc();
            __res = (int )*(*tmp___0 + (int )*(checkColor + i));
          }
          if (__res >= 97) {
            if (sizeof(*(checkColor + i)) > 1UL) {
              __res___0 = tolower((int )*(checkColor + i));
            } else {
              tmp___2 = __ctype_tolower_loc();
              __res___0 = (int )*(*tmp___2 + (int )*(checkColor + i));
            }
            if (__res___0 <= 102) {
              validColor = 1;
            } else {
              validColor = 0;
              break;
            }
          } else {
            validColor = 0;
            break;
          }
        }
        i ++;
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___4 = strcmp((char const   *)checkColor, "black");
    if (tmp___4 == 0) {
      validColor = 1;
    } else {
      tmp___5 = strcmp((char const   *)checkColor, "red");
      if (tmp___5 == 0) {
        validColor = 1;
      } else {
        tmp___6 = strcmp((char const   *)checkColor, "green");
        if (tmp___6 == 0) {
          validColor = 1;
        } else {
          tmp___7 = strcmp((char const   *)checkColor, "yellow");
          if (tmp___7 == 0) {
            validColor = 1;
          } else {
            tmp___8 = strcmp((char const   *)checkColor, "blue");
            if (tmp___8 == 0) {
              validColor = 1;
            } else {
              tmp___9 = strcmp((char const   *)checkColor, "magenta");
              if (tmp___9 == 0) {
                validColor = 1;
              } else {
                tmp___10 = strcmp((char const   *)checkColor, "cyan");
                if (tmp___10 == 0) {
                  validColor = 1;
                } else {
                  tmp___11 = strcmp((char const   *)checkColor, "white");
                  if (tmp___11 == 0) {
                    validColor = 1;
                  } else {
                    tmp___12 = strcmp((char const   *)checkColor, "default");
                    if (tmp___12 == 0) {
                      validColor = 1;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (validColor);
}
}
_Bool validate_colors(void *params , void *err ) 
{ 
  struct config_params *p___0 ;
  struct error_s *error ;
  int tmp ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  p___0 = (struct config_params *)params;
  error = (struct error_s *)err;
  tmp = validate_color(p___0->color, (void *)p___0, (void *)error);
  if (! tmp) {
    write_errorf((void *)error, "The value for \'foreground\' is invalid. It can be either one of the 7 named colors or a HTML color of the form \'#xxxxxx\'.\n");
    return ((_Bool)0);
  }
  tmp___0 = validate_color(p___0->bcolor, (void *)p___0, (void *)error);
  if (! tmp___0) {
    write_errorf((void *)error, "The value for \'background\' is invalid. It can be either one of the 7 named colors or a HTML color of the form \'#xxxxxx\'.\n");
    return ((_Bool)0);
  }
  if (p___0->gradient) {
    i = 0;
    while (i < p___0->gradient_count) {
      tmp___1 = validate_color(*(p___0->gradient_colors + i), (void *)p___0, (void *)error);
      if (! tmp___1) {
        write_errorf((void *)error, "Gradient color %d is invalid. It must be HTML color of the form \'#xxxxxx\'.\n",
                     i + 1);
        return ((_Bool)0);
      }
      i ++;
    }
  }
  p___0->col = -1;
  tmp___2 = strcmp((char const   *)p___0->color, "black");
  if (tmp___2 == 0) {
    p___0->col = 0;
  }
  tmp___3 = strcmp((char const   *)p___0->color, "red");
  if (tmp___3 == 0) {
    p___0->col = 1;
  }
  tmp___4 = strcmp((char const   *)p___0->color, "green");
  if (tmp___4 == 0) {
    p___0->col = 2;
  }
  tmp___5 = strcmp((char const   *)p___0->color, "yellow");
  if (tmp___5 == 0) {
    p___0->col = 3;
  }
  tmp___6 = strcmp((char const   *)p___0->color, "blue");
  if (tmp___6 == 0) {
    p___0->col = 4;
  }
  tmp___7 = strcmp((char const   *)p___0->color, "magenta");
  if (tmp___7 == 0) {
    p___0->col = 5;
  }
  tmp___8 = strcmp((char const   *)p___0->color, "cyan");
  if (tmp___8 == 0) {
    p___0->col = 6;
  }
  tmp___9 = strcmp((char const   *)p___0->color, "white");
  if (tmp___9 == 0) {
    p___0->col = 7;
  }
  tmp___10 = strcmp((char const   *)p___0->bcolor, "black");
  if (tmp___10 == 0) {
    p___0->bgcol = 0;
  }
  tmp___11 = strcmp((char const   *)p___0->bcolor, "red");
  if (tmp___11 == 0) {
    p___0->bgcol = 1;
  }
  tmp___12 = strcmp((char const   *)p___0->bcolor, "green");
  if (tmp___12 == 0) {
    p___0->bgcol = 2;
  }
  tmp___13 = strcmp((char const   *)p___0->bcolor, "yellow");
  if (tmp___13 == 0) {
    p___0->bgcol = 3;
  }
  tmp___14 = strcmp((char const   *)p___0->bcolor, "blue");
  if (tmp___14 == 0) {
    p___0->bgcol = 4;
  }
  tmp___15 = strcmp((char const   *)p___0->bcolor, "magenta");
  if (tmp___15 == 0) {
    p___0->bgcol = 5;
  }
  tmp___16 = strcmp((char const   *)p___0->bcolor, "cyan");
  if (tmp___16 == 0) {
    p___0->bgcol = 6;
  }
  tmp___17 = strcmp((char const   *)p___0->bcolor, "white");
  if (tmp___17 == 0) {
    p___0->bgcol = 7;
  }
  return ((_Bool)1);
}
}
_Bool validate_config(struct config_params *p___0 , struct error_s *error ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  _Bool tmp___12 ;

  {
  p___0->output = (enum output_method )3;
  tmp = strcmp((char const   *)outputMethod, "ncurses");
  if (tmp == 0) {
    p___0->output = (enum output_method )0;
    p___0->bgcol = -1;
  }
  tmp___0 = strcmp((char const   *)outputMethod, "noncurses");
  if (tmp___0 == 0) {
    p___0->output = (enum output_method )1;
    p___0->bgcol = 0;
  }
  tmp___3 = strcmp((char const   *)outputMethod, "raw");
  if (tmp___3 == 0) {
    p___0->output = (enum output_method )2;
    p___0->bar_spacing = 0;
    p___0->bar_width = 1;
    p___0->is_bin = -1;
    tmp___2 = strcmp((char const   *)p___0->data_format, "binary");
    if (tmp___2 == 0) {
      p___0->is_bin = 1;
      if (p___0->bit_format != 8) {
        if (p___0->bit_format != 16) {
          write_errorf((void *)error, "bit format  %d is not supported, supported data formats are: \'8\' and \'16\'\n",
                       p___0->bit_format);
          return ((_Bool)0);
        }
      }
    } else {
      tmp___1 = strcmp((char const   *)p___0->data_format, "ascii");
      if (tmp___1 == 0) {
        p___0->is_bin = 0;
        if (p___0->ascii_range < 1) {
          write_errorf((void *)error, "ascii max value must be a positive integer\n");
          return ((_Bool)0);
        }
      } else {
        write_errorf((void *)error, "data format %s is not supported, supported data formats are: \'binary\' and \'ascii\'\n",
                     p___0->data_format);
        return ((_Bool)0);
      }
    }
  }
  if ((unsigned int )p___0->output == 3U) {
    write_errorf((void *)error, "output method %s is not supported, supported methods are: \'ncurses\', \'noncurses\' and \'raw\'\n",
                 outputMethod);
    return ((_Bool)0);
  }
  p___0->xaxis = (enum xaxis_scale )0;
  tmp___4 = strcmp((char const   *)xaxisScale, "none");
  if (tmp___4 == 0) {
    p___0->xaxis = (enum xaxis_scale )0;
  }
  tmp___5 = strcmp((char const   *)xaxisScale, "frequency");
  if (tmp___5 == 0) {
    p___0->xaxis = (enum xaxis_scale )1;
  }
  tmp___6 = strcmp((char const   *)xaxisScale, "note");
  if (tmp___6 == 0) {
    p___0->xaxis = (enum xaxis_scale )2;
  }
  p___0->stereo = -1;
  tmp___10 = strcmp((char const   *)channels, "mono");
  if (tmp___10 == 0) {
    p___0->stereo = 0;
    tmp___7 = strcmp((char const   *)p___0->mono_option, "average");
    if (tmp___7 != 0) {
      tmp___8 = strcmp((char const   *)p___0->mono_option, "left");
      if (tmp___8 != 0) {
        tmp___9 = strcmp((char const   *)p___0->mono_option, "right");
        if (tmp___9 != 0) {
          write_errorf((void *)error, "mono option %s is not supported, supported options are: \'average\', \'left\' or \'right\'\n",
                       p___0->mono_option);
          return ((_Bool)0);
        }
      }
    }
  }
  tmp___11 = strcmp((char const   *)channels, "stereo");
  if (tmp___11 == 0) {
    p___0->stereo = 1;
  }
  if (p___0->stereo == -1) {
    write_errorf((void *)error, "output channels %s is not supported, supported channelss are: \'mono\' and \'stereo\'\n",
                 channels);
    return ((_Bool)0);
  }
  p___0->autobars = 1;
  if (p___0->fixedbars > 0) {
    p___0->autobars = 0;
  }
  if (p___0->fixedbars > 256) {
    p___0->fixedbars = 256;
  }
  if (p___0->bar_width > 256) {
    p___0->bar_width = 256;
  }
  if (p___0->bar_width < 1) {
    p___0->bar_width = 1;
  }
  if (p___0->framerate < 0) {
    write_errorf((void *)error, "framerate can\'t be negative!\n");
    return ((_Bool)0);
  }
  tmp___12 = validate_colors((void *)p___0, (void *)error);
  if (! tmp___12) {
    return ((_Bool)0);
  }
  p___0->gravity /= (double )100;
  if (p___0->gravity < (double )0) {
    p___0->gravity = (double )0;
  }
  p___0->integral /= (double )100;
  if (p___0->integral < (double )0) {
    p___0->integral = (double )0;
  } else
  if (p___0->integral > (double )1) {
    p___0->integral = (double )1;
  }
  if (p___0->lower_cut_off == 0U) {
    (p___0->lower_cut_off) ++;
  }
  if (p___0->lower_cut_off > p___0->upper_cut_off) {
    write_errorf((void *)error, "lower cutoff frequency can\'t be higher than higher cutoff frequency\n");
    return ((_Bool)0);
  }
  p___0->sens /= (double )100;
  return ((_Bool)1);
}
}
_Bool load_colors(struct config_params *p___0 , dictionary *ini , void *err ) 
{ 
  struct error_s *error ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int i ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  error = (struct error_s *)err;
  free((void *)p___0->color);
  free((void *)p___0->bcolor);
  tmp = iniparser_getstring((dictionary const   *)ini, "color:foreground", "default");
  p___0->color = strdup(tmp);
  tmp___0 = iniparser_getstring((dictionary const   *)ini, "color:background", "default");
  p___0->bcolor = strdup(tmp___0);
  p___0->gradient = iniparser_getint((dictionary const   *)ini, "color:gradient",
                                     0);
  if (p___0->gradient) {
    i = 0;
    while (i < p___0->gradient_count) {
      free((void *)*(p___0->gradient_colors + i));
      i ++;
    }
    p___0->gradient_count = iniparser_getint((dictionary const   *)ini, "color:gradient_count",
                                             8);
    if (p___0->gradient_count < 2) {
      write_errorf((void *)error, "\nAtleast two colors must be given as gradient!\n");
      return ((_Bool)0);
    }
    if (p___0->gradient_count > 8) {
      write_errorf((void *)error, "\nMaximum 8 colors can be specified as gradient!\n");
      return ((_Bool)0);
    }
    tmp___1 = malloc((sizeof(char *) * (unsigned long )p___0->gradient_count) * 9UL);
    p___0->gradient_colors = (char **)tmp___1;
    tmp___2 = iniparser_getstring((dictionary const   *)ini, "color:gradient_color_1",
                                  "#59cc33");
    *(p___0->gradient_colors + 0) = strdup(tmp___2);
    tmp___3 = iniparser_getstring((dictionary const   *)ini, "color:gradient_color_2",
                                  "#80cc33");
    *(p___0->gradient_colors + 1) = strdup(tmp___3);
    tmp___4 = iniparser_getstring((dictionary const   *)ini, "color:gradient_color_3",
                                  "#a6cc33");
    *(p___0->gradient_colors + 2) = strdup(tmp___4);
    tmp___5 = iniparser_getstring((dictionary const   *)ini, "color:gradient_color_4",
                                  "#cccc33");
    *(p___0->gradient_colors + 3) = strdup(tmp___5);
    tmp___6 = iniparser_getstring((dictionary const   *)ini, "color:gradient_color_5",
                                  "#cca633");
    *(p___0->gradient_colors + 4) = strdup(tmp___6);
    tmp___7 = iniparser_getstring((dictionary const   *)ini, "color:gradient_color_6",
                                  "#cc8033");
    *(p___0->gradient_colors + 5) = strdup(tmp___7);
    tmp___8 = iniparser_getstring((dictionary const   *)ini, "color:gradient_color_7",
                                  "#cc5933");
    *(p___0->gradient_colors + 6) = strdup(tmp___8);
    tmp___9 = iniparser_getstring((dictionary const   *)ini, "color:gradient_color_8",
                                  "#cc3333");
    *(p___0->gradient_colors + 7) = strdup(tmp___9);
  }
  return ((_Bool)1);
}
}
_Bool load_config(char *configPath , struct config_params *p___0 , _Bool colorsOnly ,
                  struct error_s *error ) 
{ 
  FILE *fp ;
  char *configFile ;
  char *configHome ;
  char *tmp ;
  dictionary *ini ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  double tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  int sk ;
  char *input_method_name ;
  size_t i ;
  enum input_method method ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char supported_methods[255] ;
  unsigned int tmp___21 ;
  int i___0 ;
  _Bool result ;
  _Bool tmp___22 ;

  {
  if ((int )*(configPath + 0) == 0) {
    configFile = (char *)"config";
    tmp = getenv("XDG_CONFIG_HOME");
    configHome = tmp;
    if ((unsigned long )configHome != (unsigned long )((void *)0)) {
      sprintf((char * __restrict  )configPath, (char const   * __restrict  )"%s/%s/",
              configHome, "cava");
    } else {
      configHome = getenv("HOME");
      if ((unsigned long )configHome != (unsigned long )((void *)0)) {
        sprintf((char * __restrict  )configPath, (char const   * __restrict  )"%s/%s/",
                configHome, ".config");
        mkdir((char const   *)configPath, (__mode_t )511);
        sprintf((char * __restrict  )configPath, (char const   * __restrict  )"%s/%s/%s/",
                configHome, ".config", "cava");
      } else {
        write_errorf((void *)error, "No HOME found (ERR_HOMELESS), exiting...");
        return ((_Bool)0);
      }
    }
    mkdir((char const   *)configPath, (__mode_t )511);
    strcat((char * __restrict  )configPath, (char const   * __restrict  )configFile);
    fp = fopen((char const   * __restrict  )configPath, (char const   * __restrict  )"ab+");
    if (fp) {
      fclose(fp);
    } else {
      fp = fopen((char const   * __restrict  )configPath, (char const   * __restrict  )"rb");
      if (fp) {
        fclose(fp);
      } else {
        write_errorf((void *)error, "Unable to open or create file \'%s\', exiting...\n",
                     configPath);
        return ((_Bool)0);
      }
    }
  } else {
    fp = fopen((char const   * __restrict  )configPath, (char const   * __restrict  )"rb");
    if (fp) {
      fclose(fp);
    } else {
      write_errorf((void *)error, "Unable to open file \'%s\', exiting...\n", configPath);
      return ((_Bool)0);
    }
  }
  ini = iniparser_load((char const   *)configPath);
  if (colorsOnly) {
    tmp___0 = load_colors(p___0, ini, (void *)error);
    if (! tmp___0) {
      return ((_Bool)0);
    }
    tmp___1 = validate_colors((void *)p___0, (void *)error);
    return (tmp___1);
  }
  tmp___2 = iniparser_getstring((dictionary const   *)ini, "output:method", "ncurses");
  outputMethod = (char *)tmp___2;
  tmp___3 = iniparser_getstring((dictionary const   *)ini, "output:xaxis", "none");
  xaxisScale = (char *)tmp___3;
  tmp___4 = iniparser_getdouble((dictionary const   *)ini, "smoothing:monstercat",
                                (double )0);
  p___0->monstercat = 1.5 * tmp___4;
  p___0->waves = iniparser_getint((dictionary const   *)ini, "smoothing:waves", 0);
  p___0->integral = iniparser_getdouble((dictionary const   *)ini, "smoothing:integral",
                                        (double )77);
  p___0->gravity = iniparser_getdouble((dictionary const   *)ini, "smoothing:gravity",
                                       (double )100);
  p___0->ignore = iniparser_getdouble((dictionary const   *)ini, "smoothing:ignore",
                                      (double )0);
  tmp___5 = load_colors(p___0, ini, (void *)error);
  if (! tmp___5) {
    return ((_Bool)0);
  }
  p___0->fixedbars = iniparser_getint((dictionary const   *)ini, "general:bars", 0);
  p___0->bar_width = iniparser_getint((dictionary const   *)ini, "general:bar_width",
                                      2);
  p___0->bar_spacing = iniparser_getint((dictionary const   *)ini, "general:bar_spacing",
                                        1);
  p___0->framerate = iniparser_getint((dictionary const   *)ini, "general:framerate",
                                      60);
  tmp___6 = iniparser_getint((dictionary const   *)ini, "general:sensitivity", 100);
  p___0->sens = (double )tmp___6;
  p___0->autosens = iniparser_getint((dictionary const   *)ini, "general:autosens",
                                     1);
  p___0->overshoot = iniparser_getint((dictionary const   *)ini, "general:overshoot",
                                      20);
  tmp___7 = iniparser_getint((dictionary const   *)ini, "general:lower_cutoff_freq",
                             50);
  p___0->lower_cut_off = (unsigned int )tmp___7;
  tmp___8 = iniparser_getint((dictionary const   *)ini, "general:higher_cutoff_freq",
                             10000);
  p___0->upper_cut_off = (unsigned int )tmp___8;
  p___0->sleep_timer = iniparser_getint((dictionary const   *)ini, "general:sleep_timer",
                                        0);
  free((void *)channels);
  free((void *)p___0->mono_option);
  free((void *)p___0->raw_target);
  free((void *)p___0->data_format);
  tmp___9 = iniparser_getstring((dictionary const   *)ini, "output:channels", "stereo");
  channels = strdup(tmp___9);
  tmp___10 = iniparser_getstring((dictionary const   *)ini, "output:mono_option",
                                 "average");
  p___0->mono_option = strdup(tmp___10);
  tmp___11 = iniparser_getstring((dictionary const   *)ini, "output:raw_target", "/dev/stdout");
  p___0->raw_target = strdup(tmp___11);
  tmp___12 = iniparser_getstring((dictionary const   *)ini, "output:data_format",
                                 "binary");
  p___0->data_format = strdup(tmp___12);
  tmp___13 = iniparser_getint((dictionary const   *)ini, "output:bar_delimiter", 59);
  p___0->bar_delim = (char )tmp___13;
  tmp___14 = iniparser_getint((dictionary const   *)ini, "output:frame_delimiter",
                              10);
  p___0->frame_delim = (char )tmp___14;
  p___0->ascii_range = iniparser_getint((dictionary const   *)ini, "output:ascii_max_range",
                                        1000);
  p___0->bit_format = iniparser_getint((dictionary const   *)ini, "output:bit_format",
                                       16);
  p___0->userEQ_keys = iniparser_getsecnkeys((dictionary const   *)ini, "eq");
  if (p___0->userEQ_keys > 0) {
    p___0->userEQ_enabled = 1;
    tmp___15 = calloc((size_t )(p___0->userEQ_keys + 1), sizeof(double ));
    p___0->userEQ = (double *)tmp___15;
    char const   *keys[p___0->userEQ_keys] ;
    iniparser_getseckeys((dictionary const   *)ini, "eq", keys);
    sk = 0;
    while (sk < p___0->userEQ_keys) {
      *(p___0->userEQ + sk) = iniparser_getdouble((dictionary const   *)ini, keys[sk],
                                                  (double )1);
      sk ++;
    }
  } else {
    p___0->userEQ_enabled = 0;
  }
  free((void *)p___0->audio_source);
  i = (size_t )0;
  while (i < (sizeof(default_methods) / sizeof(default_methods[0])) / (size_t )(! (sizeof(default_methods) % sizeof(default_methods[0])))) {
    method = default_methods[i];
    if (has_input_method[method]) {
      tmp___16 = iniparser_getstring((dictionary const   *)ini, "input:method", input_method_names[method]);
      input_method_name = (char *)tmp___16;
    }
    i ++;
  }
  p___0->input = input_method_by_name((char const   *)input_method_name);
  switch ((unsigned int )p___0->input) {
  case 2U: 
  tmp___17 = iniparser_getstring((dictionary const   *)ini, "input:source", "hw:Loopback,1");
  p___0->audio_source = strdup(tmp___17);
  break;
  case 0U: 
  tmp___18 = iniparser_getstring((dictionary const   *)ini, "input:source", "/tmp/mpd.fifo");
  p___0->audio_source = strdup(tmp___18);
  p___0->fifoSample = iniparser_getint((dictionary const   *)ini, "input:sample_rate",
                                       44100);
  p___0->fifoSampleBits = iniparser_getint((dictionary const   *)ini, "input:sample_bits",
                                           16);
  break;
  case 3U: 
  tmp___19 = iniparser_getstring((dictionary const   *)ini, "input:source", "auto");
  p___0->audio_source = strdup(tmp___19);
  break;
  case 5U: 
  tmp___20 = iniparser_getstring((dictionary const   *)ini, "input:source", "/squeezelite-00:00:00:00:00:00");
  p___0->audio_source = strdup(tmp___20);
  break;
  case 6U: 
  supported_methods[0] = (char )'\000';
  tmp___21 = 1U;
  while (! (tmp___21 >= 255U)) {
    supported_methods[tmp___21] = (char)0;
    tmp___21 ++;
  }
  i___0 = 0;
  while (i___0 < 6) {
    if (has_input_method[i___0]) {
      strcat((char * __restrict  )(supported_methods), (char const   * __restrict  )"\'");
      strcat((char * __restrict  )(supported_methods), (char const   * __restrict  )input_method_names[i___0]);
      strcat((char * __restrict  )(supported_methods), (char const   * __restrict  )"\' ");
    }
    i___0 ++;
  }
  write_errorf((void *)error, "input method \'%s\' is not supported, supported methods are: %s\n",
               input_method_name, supported_methods);
  return ((_Bool)0);
  default: 
  write_errorf((void *)error, "cava was built without \'%s\' input support\n", input_method_names[p___0->input]);
  return ((_Bool)0);
  }
  tmp___22 = validate_config(p___0, error);
  result = tmp___22;
  iniparser_freedict(ini);
  return (result);
}
}
#pragma merger("0","/tmp/cil-PFdx4XM1.i","-std=c99,-Wall,-Werror,-Wextra,-Wno-unused-result,-Wno-unknown-warning-option,-Wno-maybe-uninitialized,-Wno-vla-parameter,-g,-O2")
int write_to_fftw_input_buffers(int16_t frames , int16_t *buf , void *data ) ;
void reset_output_buffers(struct audio_data *data ) 
{ 


  {
  memset((void *)data->in_bass_r, 0, sizeof(double ) * (unsigned long )data->FFTbassbufferSize);
  memset((void *)data->in_bass_l, 0, sizeof(double ) * (unsigned long )data->FFTbassbufferSize);
  memset((void *)data->in_mid_r, 0, sizeof(double ) * (unsigned long )data->FFTmidbufferSize);
  memset((void *)data->in_mid_l, 0, sizeof(double ) * (unsigned long )data->FFTmidbufferSize);
  memset((void *)data->in_treble_r, 0, sizeof(double ) * (unsigned long )data->FFTtreblebufferSize);
  memset((void *)data->in_treble_l, 0, sizeof(double ) * (unsigned long )data->FFTtreblebufferSize);
  memset((void *)data->in_bass_r_raw, 0, sizeof(double ) * (unsigned long )data->FFTbassbufferSize);
  memset((void *)data->in_bass_l_raw, 0, sizeof(double ) * (unsigned long )data->FFTbassbufferSize);
  memset((void *)data->in_mid_r_raw, 0, sizeof(double ) * (unsigned long )data->FFTmidbufferSize);
  memset((void *)data->in_mid_l_raw, 0, sizeof(double ) * (unsigned long )data->FFTmidbufferSize);
  memset((void *)data->in_treble_r_raw, 0, sizeof(double ) * (unsigned long )data->FFTtreblebufferSize);
  memset((void *)data->in_treble_l_raw, 0, sizeof(double ) * (unsigned long )data->FFTtreblebufferSize);
  return;
}
}
int write_to_fftw_input_buffers(int16_t frames , int16_t *buf , void *data ) 
{ 
  struct audio_data *audio ;
  uint16_t n ;
  uint16_t i ;
  uint16_t n___0 ;
  uint16_t i___0 ;
  uint16_t n___1 ;
  uint16_t i___1 ;
  uint16_t n___2 ;
  uint16_t i___2 ;
  int i___3 ;
  int i___4 ;
  int i___5 ;

  {
  if ((int )frames == 0) {
    return (0);
  }
  audio = (struct audio_data *)data;
  n = (uint16_t )audio->FFTbassbufferSize;
  while ((int )n > (int )frames) {
    i = (uint16_t )1;
    while ((int )i <= (int )frames) {
      *(audio->in_bass_l_raw + ((int )n - (int )i)) = *(audio->in_bass_l_raw + (((int )n - (int )i) - (int )frames));
      if (audio->channels == 2U) {
        *(audio->in_bass_r_raw + ((int )n - (int )i)) = *(audio->in_bass_r_raw + (((int )n - (int )i) - (int )frames));
      }
      i = (uint16_t )((int )i + 1);
    }
    n = (uint16_t )((int )n - (int )frames);
  }
  n___0 = (uint16_t )audio->FFTmidbufferSize;
  while ((int )n___0 > (int )frames) {
    i___0 = (uint16_t )1;
    while ((int )i___0 <= (int )frames) {
      *(audio->in_mid_l_raw + ((int )n___0 - (int )i___0)) = *(audio->in_mid_l_raw + (((int )n___0 - (int )i___0) - (int )frames));
      if (audio->channels == 2U) {
        *(audio->in_mid_r_raw + ((int )n___0 - (int )i___0)) = *(audio->in_mid_r_raw + (((int )n___0 - (int )i___0) - (int )frames));
      }
      i___0 = (uint16_t )((int )i___0 + 1);
    }
    n___0 = (uint16_t )((int )n___0 - (int )frames);
  }
  n___1 = (uint16_t )audio->FFTtreblebufferSize;
  while ((int )n___1 > (int )frames) {
    i___1 = (uint16_t )1;
    while ((int )i___1 <= (int )frames) {
      *(audio->in_treble_l_raw + ((int )n___1 - (int )i___1)) = *(audio->in_treble_l_raw + (((int )n___1 - (int )i___1) - (int )frames));
      if (audio->channels == 2U) {
        *(audio->in_treble_r_raw + ((int )n___1 - (int )i___1)) = *(audio->in_treble_r_raw + (((int )n___1 - (int )i___1) - (int )frames));
      }
      i___1 = (uint16_t )((int )i___1 + 1);
    }
    n___1 = (uint16_t )((int )n___1 - (int )frames);
  }
  n___2 = (uint16_t )((int )frames - 1);
  i___2 = (uint16_t )0;
  while ((int )i___2 < (int )frames) {
    if (audio->channels == 1U) {
      if (audio->average) {
        *(audio->in_bass_l_raw + n___2) = (double )(((int )*(buf + (int )i___2 * 2) + (int )*(buf + ((int )i___2 * 2 + 1))) / 2);
      }
      if (audio->left) {
        *(audio->in_bass_l_raw + n___2) = (double )*(buf + (int )i___2 * 2);
      }
      if (audio->right) {
        *(audio->in_bass_l_raw + n___2) = (double )*(buf + ((int )i___2 * 2 + 1));
      }
    }
    if (audio->channels == 2U) {
      *(audio->in_bass_l_raw + n___2) = (double )*(buf + (int )i___2 * 2);
      *(audio->in_bass_r_raw + n___2) = (double )*(buf + ((int )i___2 * 2 + 1));
      *(audio->in_mid_r_raw + n___2) = *(audio->in_bass_r_raw + n___2);
      *(audio->in_treble_r_raw + n___2) = *(audio->in_bass_r_raw + n___2);
    }
    *(audio->in_mid_l_raw + n___2) = *(audio->in_bass_l_raw + n___2);
    *(audio->in_treble_l_raw + n___2) = *(audio->in_bass_l_raw + n___2);
    n___2 = (uint16_t )((int )n___2 - 1);
    i___2 = (uint16_t )((int )i___2 + 1);
  }
  i___3 = 0;
  while (i___3 < audio->FFTbassbufferSize) {
    *(audio->in_bass_l + i___3) = *(audio->bass_multiplier + i___3) * *(audio->in_bass_l_raw + i___3);
    if (audio->channels == 2U) {
      *(audio->in_bass_r + i___3) = *(audio->bass_multiplier + i___3) * *(audio->in_bass_r_raw + i___3);
    }
    i___3 ++;
  }
  i___4 = 0;
  while (i___4 < audio->FFTmidbufferSize) {
    *(audio->in_mid_l + i___4) = *(audio->mid_multiplier + i___4) * *(audio->in_mid_l_raw + i___4);
    if (audio->channels == 2U) {
      *(audio->in_mid_r + i___4) = *(audio->mid_multiplier + i___4) * *(audio->in_mid_r_raw + i___4);
    }
    i___4 ++;
  }
  i___5 = 0;
  while (i___5 < audio->FFTtreblebufferSize) {
    *(audio->in_treble_l + i___5) = *(audio->treble_multiplier + i___5) * *(audio->in_treble_l_raw + i___5);
    if (audio->channels == 2U) {
      *(audio->in_treble_r + i___5) = *(audio->treble_multiplier + i___5) * *(audio->in_treble_r_raw + i___5);
    }
    i___5 ++;
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-h_H70hpW.i","-std=c99,-Wall,-Werror,-Wextra,-Wno-unused-result,-Wno-unknown-warning-option,-Wno-maybe-uninitialized,-Wno-vla-parameter,-g,-O2")
extern int fcntl(int __fd , int __cmd  , ...) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
int open_fifo(char const   *path ) 
{ 
  int fd ;
  int tmp ;
  int flags ;
  int tmp___0 ;

  {
  tmp = open(path, 0);
  fd = tmp;
  tmp___0 = fcntl(fd, 3, 0);
  flags = tmp___0;
  fcntl(fd, 4, flags | 2048);
  return (fd);
}
}
void *input_fifo(void *data ) 
{ 
  struct audio_data *audio ;
  int SAMPLES_PER_BUFFER ;
  int bytes_per_sample ;
  uint16_t *samples ;
  void *tmp ;
  void *tmp___0 ;
  int fd ;
  int tmp___1 ;
  int time_since_last_input ;
  unsigned int offset ;
  int num_read ;
  ssize_t tmp___2 ;
  struct timespec __constr_expr_0 ;
  int i ;
  int i___0 ;

  {
  audio = (struct audio_data *)data;
  SAMPLES_PER_BUFFER = audio->FFTtreblebufferSize * 2;
  bytes_per_sample = audio->format / 8;
  uint8_t __attribute__((__aligned__(sizeof(uint16_t ))))  buf[SAMPLES_PER_BUFFER * bytes_per_sample] ;
  if (bytes_per_sample == 2) {
    tmp___0 = (void *)((uint16_t *)(& buf));
  } else {
    tmp = calloc((size_t )SAMPLES_PER_BUFFER, sizeof(uint16_t ));
    tmp___0 = tmp;
  }
  samples = (uint16_t *)tmp___0;
  tmp___1 = open_fifo((char const   *)audio->source);
  fd = tmp___1;
  while (! audio->terminate) {
    time_since_last_input = 0;
    offset = 0U;
    while (1) {
      tmp___2 = read(fd, (void *)(buf + offset), sizeof(buf) - (unsigned long )offset);
      num_read = (int )tmp___2;
      if (num_read < 1) {
        __constr_expr_0.tv_sec = (__time_t )0;
        __constr_expr_0.tv_nsec = (__syscall_slong_t )10000000;
        nanosleep((struct timespec  const  *)(& __constr_expr_0), (struct timespec *)((void *)0));
        time_since_last_input ++;
        if (time_since_last_input > 10) {
          reset_output_buffers(audio);
          close(fd);
          fd = open_fifo((char const   *)audio->source);
          time_since_last_input = 0;
          offset = 0U;
        }
      } else {
        offset += (unsigned int )num_read;
        time_since_last_input = 0;
      }
      if (! ((unsigned long )offset < sizeof(buf))) {
        break;
      }
    }
    switch (bytes_per_sample) {
    case 2: 
    break;
    case 3: 
    i = 0;
    while (i < SAMPLES_PER_BUFFER) {
      *(samples + i) = (uint16_t )(((int __attribute__((__aligned__(sizeof(uint16_t ))))  )buf[3 * i + 2] << 8) | (int __attribute__((__aligned__(sizeof(uint16_t ))))  )buf[3 * i + 1]);
      i ++;
    }
    break;
    case 4: 
    i___0 = 0;
    while (i___0 < SAMPLES_PER_BUFFER) {
      *(samples + i___0) = (uint16_t )(((int __attribute__((__aligned__(sizeof(uint16_t ))))  )buf[4 * i___0 + 3] << 8) | (int __attribute__((__aligned__(sizeof(uint16_t ))))  )buf[4 * i___0 + 2]);
      i___0 ++;
    }
    break;
    }
    pthread_mutex_lock(& lock);
    write_to_fftw_input_buffers((int16_t )(SAMPLES_PER_BUFFER / 2), (int16_t *)samples,
                                (void *)audio);
    pthread_mutex_unlock(& lock);
  }
  close(fd);
  if (bytes_per_sample != 2) {
    free((void *)samples);
  }
  return ((void *)0);
}
}
#pragma merger("0","/tmp/cil-qgYeYT34.i","-std=c99,-Wall,-Werror,-Wextra,-Wno-unused-result,-Wno-unknown-warning-option,-Wno-maybe-uninitialized,-Wno-vla-parameter,-g,-O2")
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
extern int shm_open(char const   *__name , int __oflag , mode_t __mode ) ;
int rc  ;
void *input_shmem(void *data ) 
{ 
  struct audio_data *audio ;
  vis_t *mmap_area ;
  int fd ;
  int mmap_count ;
  int buf_frames ;
  struct timespec req ;
  s16_t silence_buffer[16384] ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  audio = (struct audio_data *)data;
  mmap_count = (int )sizeof(vis_t );
  req.tv_sec = (__time_t )0;
  req.tv_nsec = (__syscall_slong_t )0;
  i = 0;
  while (i < 16384) {
    silence_buffer[i] = (s16_t )0;
    i ++;
  }
  printf((char const   * __restrict  )"input_shmem: source: %s", audio->source);
  fd = shm_open((char const   *)audio->source, 2, (mode_t )438);
  if (fd < 0) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    printf((char const   * __restrict  )"Could not open source \'%s\': %s\n", audio->source,
           tmp___0);
    exit(1);
  } else {
    tmp___1 = mmap((void *)0, sizeof(vis_t ), 3, 1, fd, (__off_t )0);
    mmap_area = (vis_t *)tmp___1;
    if ((intptr_t )mmap_area == -1L) {
      printf((char const   * __restrict  )"mmap failed - check if squeezelite is running with visualization enabled\n");
      exit(1);
    }
  }
  while (! audio->terminate) {
    audio->rate = mmap_area->rate;
    buf_frames = (int )(mmap_area->buf_size / 2U);
    req.tv_nsec = (__syscall_slong_t )((1000000U / mmap_area->rate) * (u32_t )buf_frames);
    if (mmap_area->running) {
      pthread_mutex_lock(& lock);
      write_to_fftw_input_buffers((int16_t )buf_frames, mmap_area->buffer, (void *)audio);
      pthread_mutex_unlock(& lock);
      nanosleep((struct timespec  const  *)(& req), (struct timespec *)((void *)0));
    } else {
      write_to_fftw_input_buffers((int16_t )buf_frames, silence_buffer, (void *)audio);
      nanosleep((struct timespec  const  *)(& req), (struct timespec *)((void *)0));
    }
  }
  if (fd > 0) {
    tmp___4 = close(fd);
    if (tmp___4 != 0) {
      tmp___2 = __errno_location();
      tmp___3 = strerror(*tmp___2);
      printf((char const   * __restrict  )"Could not close file descriptor %d: %s",
             fd, tmp___3);
    }
  } else {
    printf((char const   * __restrict  )"Wrong file descriptor %d", fd);
  }
  tmp___7 = munmap((void *)mmap_area, (size_t )mmap_count);
  if (tmp___7 != 0) {
    tmp___5 = __errno_location();
    tmp___6 = strerror(*tmp___5);
    printf((char const   * __restrict  )"Could not munmap() area %p+%d. %s", mmap_area,
           mmap_count, tmp___6);
  }
  return ((void *)0);
}
}
#pragma merger("0","/tmp/cil-BZrvZj6M.i","-std=c99,-Wall,-Werror,-Wextra,-Wno-unused-result,-Wno-unknown-warning-option,-Wno-maybe-uninitialized,-Wno-vla-parameter,-g,-O2")
extern int fflush(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
extern  __attribute__((__nothrow__)) wchar_t *( __attribute__((__nonnull__(1,2))) wcscat)(wchar_t * __restrict  __dest ,
                                                                                          wchar_t const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int swprintf(wchar_t * __restrict  __s , size_t __n ,
                                                  wchar_t const   * __restrict  __format 
                                                  , ...) ;
wchar_t *frame_buffer  ;
wchar_t *barstring[8]  ;
wchar_t *spacestring  ;
int buf_length  ;
char *ttyframe_buffer  ;
char *ttybarstring[8]  ;
char *ttyspacestring  ;
int ttybuf_length  ;
int setecho(int fd , int onoff ) 
{ 
  struct termios t ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = tcgetattr(fd, & t);
  if (tmp == -1) {
    return (-1);
  }
  if (onoff == 0) {
    t.c_lflag &= 4294967173U;
  } else {
    t.c_lflag |= 122U;
  }
  tmp___0 = tcsetattr(fd, 0, (struct termios  const  *)(& t));
  if (tmp___0 == -1) {
    return (-1);
  }
  return (0);
}
}
void free_terminal_noncurses(void) 
{ 
  int i ;

  {
  free((void *)frame_buffer);
  free((void *)ttyframe_buffer);
  free((void *)spacestring);
  free((void *)ttyspacestring);
  i = 0;
  while (i < 8) {
    free((void *)barstring[i]);
    free((void *)ttybarstring[i]);
    i ++;
  }
  return;
}
}
int init_terminal_noncurses(int tty , int col , int bgcol , int width , int lines ,
                            int bar_width ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  int n ;
  void *tmp___1 ;
  int n___0 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int n___1 ;
  void *tmp___4 ;
  int n___2 ;
  int n___3 ;
  int i ;

  {
  free_terminal_noncurses();
  if (tty) {
    ttybuf_length = (int )(((sizeof(char ) * (unsigned long )width) * (unsigned long )lines) * 10UL);
    tmp = malloc((size_t )ttybuf_length);
    ttyframe_buffer = (char *)tmp;
    tmp___0 = malloc(sizeof(char ) * (unsigned long )(bar_width + 1));
    ttyspacestring = (char *)tmp___0;
    n = 0;
    while (n < 8) {
      tmp___1 = malloc(sizeof(char ) * (unsigned long )(bar_width + 1));
      ttybarstring[n] = (char *)tmp___1;
      *(ttybarstring[n] + 0) = (char )'\000';
      n ++;
    }
    *(ttyspacestring + 0) = (char )'\000';
    *(ttyframe_buffer + 0) = (char )'\000';
    n___0 = 0;
    while (n___0 < bar_width) {
      strcat((char * __restrict  )ttybarstring[0], (char const   * __restrict  )"H");
      strcat((char * __restrict  )ttybarstring[1], (char const   * __restrict  )"A");
      strcat((char * __restrict  )ttybarstring[2], (char const   * __restrict  )"B");
      strcat((char * __restrict  )ttybarstring[3], (char const   * __restrict  )"C");
      strcat((char * __restrict  )ttybarstring[4], (char const   * __restrict  )"D");
      strcat((char * __restrict  )ttybarstring[5], (char const   * __restrict  )"E");
      strcat((char * __restrict  )ttybarstring[6], (char const   * __restrict  )"F");
      strcat((char * __restrict  )ttybarstring[7], (char const   * __restrict  )"G");
      strcat((char * __restrict  )ttyspacestring, (char const   * __restrict  )" ");
      n___0 ++;
    }
  } else
  if (! tty) {
    buf_length = (int )(((sizeof(wchar_t ) * (unsigned long )width) * (unsigned long )lines) * 10UL);
    tmp___2 = malloc((size_t )buf_length);
    frame_buffer = (wchar_t *)tmp___2;
    tmp___3 = malloc(sizeof(wchar_t ) * (unsigned long )(bar_width + 1));
    spacestring = (wchar_t *)tmp___3;
    n___1 = 0;
    while (n___1 < 8) {
      tmp___4 = malloc(sizeof(wchar_t ) * (unsigned long )(bar_width + 1));
      barstring[n___1] = (wchar_t *)tmp___4;
      *(barstring[n___1] + 0) = '\000';
      n___1 ++;
    }
    *(spacestring + 0) = '\000';
    *(frame_buffer + 0) = '\000';
    n___2 = 0;
    while (n___2 < bar_width) {
      wcscat((wchar_t * __restrict  )barstring[0], (wchar_t const   * __restrict  )L"2588");
      wcscat((wchar_t * __restrict  )barstring[1], (wchar_t const   * __restrict  )L"2581");
      wcscat((wchar_t * __restrict  )barstring[2], (wchar_t const   * __restrict  )L"2582");
      wcscat((wchar_t * __restrict  )barstring[3], (wchar_t const   * __restrict  )L"2583");
      wcscat((wchar_t * __restrict  )barstring[4], (wchar_t const   * __restrict  )L"2584");
      wcscat((wchar_t * __restrict  )barstring[5], (wchar_t const   * __restrict  )L"2585");
      wcscat((wchar_t * __restrict  )barstring[6], (wchar_t const   * __restrict  )L"2586");
      wcscat((wchar_t * __restrict  )barstring[7], (wchar_t const   * __restrict  )L"2587");
      wcscat((wchar_t * __restrict  )spacestring, (wchar_t const   * __restrict  )L" ");
      n___2 ++;
    }
  }
  col += 30;
  system("setterm -cursor off");
  system("setterm -blank 0");
  printf((char const   * __restrict  )"\033[0m\n");
  system("clear");
  if (col) {
    printf((char const   * __restrict  )"\033[%dm", col);
  }
  if (bgcol != 0) {
    bgcol += 40;
    printf((char const   * __restrict  )"\033[%dm", bgcol);
    n___3 = lines;
    while (n___3 >= 0) {
      i = 0;
      while (i < width) {
        printf((char const   * __restrict  )" ");
        i ++;
      }
      if (n___3 != 0) {
        printf((char const   * __restrict  )"\n");
      } else {
        printf((char const   * __restrict  )"\r");
      }
      n___3 --;
    }
    printf((char const   * __restrict  )"\033[%dA", lines);
  }
  setecho(0, 0);
  return (0);
}
}
void get_terminal_dim_noncurses(int *width , int *lines ) 
{ 
  struct winsize dim ;

  {
  ioctl(1, 21523UL, & dim);
  *lines = (int )dim.ws_row;
  *width = (int )dim.ws_col;
  system("clear");
  return;
}
}
int draw_terminal_noncurses(int tty , int lines , int width , int number_of_bars ,
                            int bar_width , int bar_spacing , int rest , int *bars ,
                            int *previous_frame , int x_axis_info ) 
{ 
  int current_cell ;
  int prev_cell ;
  int same_line ;
  int new_line ;
  int cx ;
  struct winsize dim ;
  int current_line ;
  int same_bar ;
  int center_adjusted ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  same_line = 0;
  new_line = 0;
  cx = 0;
  if (! tty) {
    ioctl(1, 21523UL, & dim);
    if (x_axis_info) {
      lines ++;
    }
    if ((int )dim.ws_row != lines) {
      return (-1);
    } else
    if ((int )dim.ws_col != width) {
      return (-1);
    }
    if (x_axis_info) {
      lines --;
    }
  }
  if (tty) {
    *(ttyframe_buffer + 0) = (char )'\000';
  } else
  if (! tty) {
    *(frame_buffer + 0) = '\000';
  }
  current_line = lines - 1;
  while (current_line >= 0) {
    same_bar = 0;
    center_adjusted = 0;
    i = 0;
    while (i < number_of_bars) {
      current_cell = *(bars + i) - current_line * 8;
      prev_cell = *(previous_frame + i) - current_line * 8;
      if (current_cell < 1) {
        if (prev_cell < 1) {
          same_bar ++;
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if (current_cell > 7) {
        if (prev_cell > 7) {
          same_bar ++;
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (current_cell == prev_cell) {
        same_bar ++;
      } else
      if (tty) {
        if (same_line > 0) {
          tmp = snprintf((char * __restrict  )(ttyframe_buffer + cx), (size_t )(ttybuf_length - cx),
                         (char const   * __restrict  )"\033[%dB", same_line);
          cx += tmp;
          new_line += same_line;
          same_line = 0;
        }
        if (same_bar > 0) {
          tmp___0 = snprintf((char * __restrict  )(ttyframe_buffer + cx), (size_t )(ttybuf_length - cx),
                             (char const   * __restrict  )"\033[%dC", (bar_width + bar_spacing) * same_bar);
          cx += tmp___0;
          same_bar = 0;
        }
        if (! center_adjusted) {
          if (rest) {
            tmp___1 = snprintf((char * __restrict  )(ttyframe_buffer + cx), (size_t )(ttybuf_length - cx),
                               (char const   * __restrict  )"\033[%dC", rest);
            cx += tmp___1;
            center_adjusted = 1;
          }
        }
        if (current_cell < 1) {
          tmp___2 = snprintf((char * __restrict  )(ttyframe_buffer + cx), (size_t )(ttybuf_length - cx),
                             (char const   * __restrict  )"%s", ttyspacestring);
          cx += tmp___2;
        } else
        if (current_cell > 7) {
          tmp___3 = snprintf((char * __restrict  )(ttyframe_buffer + cx), (size_t )(ttybuf_length - cx),
                             (char const   * __restrict  )"%s", ttybarstring[0]);
          cx += tmp___3;
        } else {
          tmp___4 = snprintf((char * __restrict  )(ttyframe_buffer + cx), (size_t )(ttybuf_length - cx),
                             (char const   * __restrict  )"%s", ttybarstring[current_cell]);
          cx += tmp___4;
        }
        if (bar_spacing) {
          tmp___5 = snprintf((char * __restrict  )(ttyframe_buffer + cx), (size_t )(ttybuf_length - cx),
                             (char const   * __restrict  )"\033[%dC", bar_spacing);
          cx += tmp___5;
        }
      } else
      if (! tty) {
        if (same_line > 0) {
          tmp___6 = swprintf((wchar_t * __restrict  )(frame_buffer + cx), (size_t )(buf_length - cx),
                             (wchar_t const   * __restrict  )L"\033[%dB", same_line);
          cx += tmp___6;
          new_line += same_line;
          same_line = 0;
        }
        if (same_bar > 0) {
          tmp___7 = swprintf((wchar_t * __restrict  )(frame_buffer + cx), (size_t )(buf_length - cx),
                             (wchar_t const   * __restrict  )L"\033[%dC", (bar_width + bar_spacing) * same_bar);
          cx += tmp___7;
          same_bar = 0;
        }
        if (! center_adjusted) {
          if (rest) {
            tmp___8 = swprintf((wchar_t * __restrict  )(frame_buffer + cx), (size_t )(buf_length - cx),
                               (wchar_t const   * __restrict  )L"\033[%dC", rest);
            cx += tmp___8;
            center_adjusted = 1;
          }
        }
        if (current_cell < 1) {
          tmp___9 = swprintf((wchar_t * __restrict  )(frame_buffer + cx), (size_t )(buf_length - cx),
                             (wchar_t const   * __restrict  )spacestring);
          cx += tmp___9;
        } else
        if (current_cell > 7) {
          tmp___10 = swprintf((wchar_t * __restrict  )(frame_buffer + cx), (size_t )(buf_length - cx),
                              (wchar_t const   * __restrict  )barstring[0]);
          cx += tmp___10;
        } else {
          tmp___11 = swprintf((wchar_t * __restrict  )(frame_buffer + cx), (size_t )(buf_length - cx),
                              (wchar_t const   * __restrict  )barstring[current_cell]);
          cx += tmp___11;
        }
        if (bar_spacing) {
          tmp___12 = swprintf((wchar_t * __restrict  )(frame_buffer + cx), (size_t )(buf_length - cx),
                              (wchar_t const   * __restrict  )L"\033[%dC", bar_spacing);
          cx += tmp___12;
        }
      }
      i ++;
    }
    if (same_bar != number_of_bars) {
      if (current_line != 0) {
        if (tty) {
          tmp___13 = snprintf((char * __restrict  )(ttyframe_buffer + cx), (size_t )(ttybuf_length - cx),
                              (char const   * __restrict  )"\n");
          cx += tmp___13;
        } else
        if (! tty) {
          tmp___14 = swprintf((wchar_t * __restrict  )(frame_buffer + cx), (size_t )(buf_length - cx),
                              (wchar_t const   * __restrict  )L"\n");
          cx += tmp___14;
        }
        new_line ++;
      }
    } else {
      same_line ++;
    }
    current_line --;
  }
  if (same_line != lines) {
    if (tty) {
      printf((char const   * __restrict  )"%s\r\033[%dA", ttyframe_buffer, new_line);
    } else
    if (! tty) {
      printf((char const   * __restrict  )"%ls\r\033[%dA", frame_buffer, new_line);
    }
    fflush(stdout);
  }
  return (0);
}
}
void cleanup_terminal_noncurses(void) 
{ 


  {
  setecho(0, 1);
  printf((char const   * __restrict  )"\033[0m\n");
  system("setfont  >/dev/null 2>&1");
  system("setfont /usr/share/consolefonts/Lat2-Fixed16.psf.gz  >/dev/null 2>&1");
  system("setterm -cursor on");
  system("setterm -blank 10");
  system("clear");
  return;
}
}
#pragma merger("0","/tmp/cil-BhEE3NEa.i","-std=c99,-Wall,-Werror,-Wextra,-Wno-unused-result,-Wno-unknown-warning-option,-Wno-maybe-uninitialized,-Wno-vla-parameter,-g,-O2")
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
int16_t buf_16  ;
int8_t buf_8  ;
int print_raw_out(int bars_count , int fd , int is_binary , int bit_format , int ascii_range ,
                  char bar_delim , char frame_delim , int const   *f ) 
{ 
  int i ;
  int f_limited ;
  double tmp ;
  double tmp___0 ;
  int i___0 ;
  int f_ranged ;
  int bar_height_size ;
  double tmp___1 ;
  double tmp___2 ;

  {
  if (is_binary) {
    i = 0;
    while (i < bars_count) {
      f_limited = (int )*(f + i);
      tmp___0 = pow((double )2, (double )bit_format);
      if ((double )f_limited > tmp___0 - (double )1) {
        tmp = pow((double )2, (double )bit_format);
        f_limited = (int )(tmp - (double )1);
      }
      switch (bit_format) {
      case 16: 
      buf_16 = (int16_t )f_limited;
      write(fd, (void const   *)(& buf_16), sizeof(int16_t ));
      break;
      case 8: 
      buf_8 = (int8_t )f_limited;
      write(fd, (void const   *)(& buf_8), sizeof(int8_t ));
      break;
      }
      i ++;
    }
  } else {
    i___0 = 0;
    while (i___0 < bars_count) {
      f_ranged = (int )*(f + i___0);
      if (f_ranged > ascii_range) {
        f_ranged = ascii_range;
      }
      bar_height_size = 2;
      if (f_ranged != 0) {
        tmp___1 = log10((double )f_ranged);
        tmp___2 = floor(tmp___1);
        bar_height_size = (int )((double )bar_height_size + tmp___2);
      }
      char bar_height[bar_height_size] ;
      snprintf((char * __restrict  )(bar_height), (size_t )bar_height_size, (char const   * __restrict  )"%d",
               f_ranged);
      write(fd, (void const   *)(bar_height), (size_t )(bar_height_size - 1));
      write(fd, (void const   *)(& bar_delim), sizeof(bar_delim));
      i___0 ++;
    }
    write(fd, (void const   *)(& frame_delim), sizeof(frame_delim));
  }
  return (0);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-LmVRTlxY.i","-std=c99,-Wall,-Werror,-Wextra,-Wno-unused-result,-Wno-unknown-warning-option,-Wno-maybe-uninitialized,-Wno-vla-parameter,-g,-O2")
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
extern char const   *snd_strerror(int errnum ) ;
extern int snd_pcm_open(snd_pcm_t **pcm , char const   *name , snd_pcm_stream_t stream ,
                        int mode ) ;
extern int snd_pcm_close(snd_pcm_t *pcm ) ;
extern int snd_pcm_hw_params(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ) ;
extern int snd_pcm_prepare(snd_pcm_t *pcm ) ;
extern snd_pcm_sframes_t snd_pcm_readi(snd_pcm_t *pcm , void *buffer , snd_pcm_uframes_t size ) ;
extern int snd_pcm_get_params(snd_pcm_t *pcm , snd_pcm_uframes_t *buffer_size , snd_pcm_uframes_t *period_size ) ;
extern int snd_pcm_hw_params_any(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ) ;
extern size_t snd_pcm_hw_params_sizeof(void) ;
extern int snd_pcm_hw_params_set_access(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        snd_pcm_access_t _access ) ;
extern int snd_pcm_hw_params_get_format(snd_pcm_hw_params_t const   *params , snd_pcm_format_t *val ) ;
extern int snd_pcm_hw_params_set_format(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        snd_pcm_format_t val ) ;
extern int snd_pcm_hw_params_set_channels(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                          unsigned int val ) ;
extern int snd_pcm_hw_params_get_rate(snd_pcm_hw_params_t const   *params , unsigned int *val ,
                                      int *dir ) ;
extern int snd_pcm_hw_params_set_rate_near(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                           unsigned int *val , int *dir ) ;
extern int snd_pcm_hw_params_get_period_size(snd_pcm_hw_params_t const   *params ,
                                             snd_pcm_uframes_t *frames , int *dir ) ;
extern int snd_pcm_hw_params_set_period_size_near(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                                  snd_pcm_uframes_t *val , int *dir ) ;
static void initialize_audio_parameters(snd_pcm_t **handle , struct audio_data *audio ,
                                        snd_pcm_uframes_t *frames ) 
{ 
  int err ;
  int tmp ;
  char const   *tmp___0 ;
  snd_pcm_hw_params_t *params ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  unsigned int sample_rate ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  tmp = snd_pcm_open(handle, (char const   *)audio->source, (snd_pcm_stream_t )1,
                     0);
  err = tmp;
  if (err < 0) {
    tmp___0 = snd_strerror(err);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"error opening stream: %s\n",
            tmp___0);
    exit(1);
  } else {
    while (1) {
      break;
    }
  }
  while (1) {
    tmp___1 = snd_pcm_hw_params_sizeof();
    tmp___2 = __builtin_alloca(tmp___1);
    params = (snd_pcm_hw_params_t *)tmp___2;
    tmp___3 = snd_pcm_hw_params_sizeof();
    memset((void *)params, 0, tmp___3);
    break;
  }
  snd_pcm_hw_params_any(*handle, params);
  snd_pcm_hw_params_set_access(*handle, params, (snd_pcm_access_t )3);
  snd_pcm_hw_params_set_format(*handle, params, (snd_pcm_format_t )2);
  snd_pcm_hw_params_set_channels(*handle, params, 2U);
  sample_rate = 44100U;
  snd_pcm_hw_params_set_rate_near(*handle, params, & sample_rate, (int *)((void *)0));
  snd_pcm_hw_params_set_period_size_near(*handle, params, frames, (int *)((void *)0));
  err = snd_pcm_hw_params(*handle, params);
  if (err < 0) {
    tmp___4 = snd_strerror(err);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unable to set hw parameters: %s\n",
            tmp___4);
    exit(1);
  }
  err = snd_pcm_prepare(*handle);
  if (err < 0) {
    tmp___5 = snd_strerror(err);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"cannot prepare audio interface for use (%s)\n",
            tmp___5);
    exit(1);
  }
  snd_pcm_hw_params_get_format((snd_pcm_hw_params_t const   *)params, (snd_pcm_format_t *)(& sample_rate));
  if (sample_rate <= 5U) {
    audio->format = 16;
  } else
  if (sample_rate <= 9U) {
    audio->format = 24;
  } else {
    audio->format = 32;
  }
  snd_pcm_hw_params_get_rate((snd_pcm_hw_params_t const   *)params, & audio->rate,
                             (int *)((void *)0));
  snd_pcm_hw_params_get_period_size((snd_pcm_hw_params_t const   *)params, frames,
                                    (int *)((void *)0));
  return;
}
}
static int get_certain_frame(signed char *buffer , int buffer_index , int adjustment ) 
{ 
  int temp ;
  int lo ;
  int tmp ;

  {
  temp = (int )*(buffer + ((buffer_index + adjustment) - 1)) << 2;
  lo = (int )*(buffer + ((buffer_index + adjustment) - 2)) >> 6;
  if (lo < 0) {
    tmp = abs(lo);
    lo = tmp + 1;
  }
  if (temp >= 0) {
    temp += lo;
  } else {
    temp -= lo;
  }
  return (temp);
}
}
void *input_alsa(void *data ) 
{ 
  int err ;
  struct audio_data *audio ;
  snd_pcm_t *handle ;
  snd_pcm_uframes_t buffer_size ;
  snd_pcm_uframes_t period_size ;
  snd_pcm_uframes_t frames ;
  int radj ;
  int ladj ;
  signed char *buffer ;
  void *tmp ;
  snd_pcm_sframes_t tmp___0 ;
  snd_pcm_sframes_t tmp___1 ;
  uint16_t i ;
  double tmp___2 ;
  snd_pcm_sframes_t tmp___3 ;
  uint16_t i___0 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  audio = (struct audio_data *)data;
  frames = (snd_pcm_uframes_t )audio->FFTtreblebufferSize;
  initialize_audio_parameters(& handle, audio, & frames);
  snd_pcm_get_params(handle, & buffer_size, & period_size);
  radj = audio->format / 4;
  ladj = audio->format / 8;
  int16_t buf[period_size] ;
  int32_t buffer32[period_size] ;
  frames = period_size / (snd_pcm_uframes_t )((audio->format / 8) * 2);
  tmp = malloc(period_size);
  buffer = (signed char *)tmp;
  while (! audio->terminate) {
    switch (audio->format) {
    case 16: 
    tmp___0 = snd_pcm_readi(handle, (void *)(buf), frames);
    err = (int )tmp___0;
    break;
    case 32: 
    tmp___1 = snd_pcm_readi(handle, (void *)(buffer32), frames);
    err = (int )tmp___1;
    i = (uint16_t )0;
    while ((snd_pcm_uframes_t )i < frames * 2UL) {
      tmp___2 = pow((double )2, (double )16);
      buf[i] = (int16_t )((double )buffer32[i] / tmp___2);
      i = (uint16_t )((int )i + 1);
    }
    break;
    default: 
    tmp___3 = snd_pcm_readi(handle, (void *)buffer, frames);
    err = (int )tmp___3;
    i___0 = (uint16_t )0;
    while ((snd_pcm_uframes_t )i___0 < period_size * 2UL) {
      tmp___4 = get_certain_frame(buffer, (int )i___0, ladj);
      buf[i___0] = (int16_t )tmp___4;
      tmp___5 = get_certain_frame(buffer, (int )i___0, radj);
      buf[(int )i___0 + 1] = (int16_t )tmp___5;
      i___0 = (uint16_t )((int )i___0 + ladj * 2);
    }
    break;
    }
    if (err == -32) {
      while (1) {
        break;
      }
      snd_pcm_prepare(handle);
    } else
    if (err < 0) {
      while (1) {
        break;
      }
    } else
    if (err != (int )frames) {
      while (1) {
        break;
      }
    }
    pthread_mutex_lock(& lock);
    write_to_fftw_input_buffers((int16_t )frames, buf, data);
    pthread_mutex_unlock(& lock);
  }
  free((void *)buffer);
  snd_pcm_close(handle);
  return ((void *)0);
}
}
#pragma merger("0","/tmp/cil-h_Vt0Bo2.i","-std=c99,-Wall,-Werror,-Wextra,-Wno-unused-result,-Wno-unknown-warning-option,-Wno-maybe-uninitialized,-Wno-vla-parameter,-g,-O2")
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
extern char const   *pa_strerror(int error ) ;
extern void pa_operation_unref(pa_operation *o ) ;
extern pa_context *pa_context_new(pa_mainloop_api *mainloop , char const   *name ) ;
extern void pa_context_unref(pa_context *c ) ;
extern void pa_context_set_state_callback(pa_context *c , void (*cb)(pa_context *c ,
                                                                     void *userdata ) ,
                                          void *userdata ) ;
extern pa_context_state_t pa_context_get_state(pa_context const   *c ) ;
extern int pa_context_connect(pa_context *c , char const   *server , pa_context_flags_t flags ,
                              pa_spawn_api const   *api ) ;
extern void pa_context_disconnect(pa_context *c ) ;
extern pa_operation *pa_context_get_server_info(pa_context *c , void (*cb)(pa_context *c ,
                                                                           pa_server_info const   *i ,
                                                                           void *userdata ) ,
                                                void *userdata ) ;
extern pa_mainloop *pa_mainloop_new(void) ;
extern void pa_mainloop_free(pa_mainloop *m ) ;
extern int pa_mainloop_iterate(pa_mainloop *m , int block , int *retval ) ;
extern int pa_mainloop_run(pa_mainloop *m , int *retval ) ;
extern pa_mainloop_api *pa_mainloop_get_api(pa_mainloop *m ) ;
extern void pa_mainloop_quit(pa_mainloop *m , int retval ) ;
extern pa_simple *pa_simple_new(char const   *server , char const   *name , pa_stream_direction_t dir ,
                                char const   *dev , char const   *stream_name , pa_sample_spec const   *ss ,
                                pa_channel_map const   *map , pa_buffer_attr const   *attr ,
                                int *error ) ;
extern void pa_simple_free(pa_simple *s ) ;
extern int pa_simple_read(pa_simple *s , void *data , size_t bytes , int *error ) ;
pa_mainloop *m_pulseaudio_mainloop  ;
void cb(pa_context *pulseaudio_context  __attribute__((__unused__)) , pa_server_info const   *i ,
        void *userdata ) 
{ 
  struct audio_data *audio ;
  void *tmp ;

  {
  audio = (struct audio_data *)userdata;
  free((void *)audio->source);
  tmp = malloc(sizeof(char ) * 1024UL);
  audio->source = (char *)tmp;
  strcpy((char * __restrict  )audio->source, (char const   * __restrict  )i->default_sink_name);
  audio->source = strcat((char * __restrict  )audio->source, (char const   * __restrict  )".monitor");
  pa_context_disconnect(pulseaudio_context);
  pa_context_unref(pulseaudio_context);
  pa_mainloop_quit(m_pulseaudio_mainloop, 0);
  pa_mainloop_free(m_pulseaudio_mainloop);
  return;
}
}
void pulseaudio_context_state_callback(pa_context *pulseaudio_context , void *userdata ) 
{ 
  pa_context_state_t tmp ;
  pa_operation *tmp___0 ;

  {
  tmp = pa_context_get_state((pa_context const   *)pulseaudio_context);
  switch ((unsigned int )tmp) {
  case 0U: 
  break;
  case 1U: 
  break;
  case 2U: 
  break;
  case 3U: 
  break;
  case 4U: 
  tmp___0 = pa_context_get_server_info(pulseaudio_context, & cb, userdata);
  pa_operation_unref(tmp___0);
  break;
  case 5U: 
  printf((char const   * __restrict  )"failed to connect to pulseaudio server\n");
  exit(1);
  break;
  case 6U: 
  pa_mainloop_quit(m_pulseaudio_mainloop, 0);
  break;
  }
  return;
}
}
void getPulseDefaultSink(void *data ) 
{ 
  struct audio_data *audio ;
  pa_mainloop_api *mainloop_api ;
  pa_context *pulseaudio_context ;
  int ret ;

  {
  audio = (struct audio_data *)data;
  m_pulseaudio_mainloop = pa_mainloop_new();
  mainloop_api = pa_mainloop_get_api(m_pulseaudio_mainloop);
  pulseaudio_context = pa_context_new(mainloop_api, "cava device list");
  pa_context_connect(pulseaudio_context, (char const   *)((void *)0), (pa_context_flags_t )0,
                     (pa_spawn_api const   *)((void *)0));
  pa_context_set_state_callback(pulseaudio_context, & pulseaudio_context_state_callback,
                                (void *)audio);
  ret = pa_mainloop_iterate(m_pulseaudio_mainloop, 0, & ret);
  if (! ret) {
    printf((char const   * __restrict  )"Could not open pulseaudio mainloop to find default device name: %d\ncheck if pulseaudio is running\n",
           ret);
    exit(1);
  }
  pa_mainloop_run(m_pulseaudio_mainloop, & ret);
  return;
}
}
static struct pa_sample_spec  const  ss  =    {(pa_sample_format_t )3, (uint32_t )44100, (uint8_t )2};
void *input_pulse(void *data ) 
{ 
  struct audio_data *audio ;
  uint16_t frames ;
  int channels___0 ;
  int frag_size ;
  pa_buffer_attr pb ;
  pa_simple *s ;
  int error ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  audio = (struct audio_data *)data;
  frames = (uint16_t )audio->FFTtreblebufferSize;
  channels___0 = 2;
  int16_t buf[(int )frames * channels___0] ;
  audio->format = 16;
  frag_size = ((((int )frames * channels___0) * audio->format) / 8) * 2;
  pb.maxlength = (uint32_t )-1;
  pb.tlength = 0U;
  pb.prebuf = 0U;
  pb.minreq = 0U;
  pb.fragsize = (uint32_t )frag_size;
  s = (pa_simple *)((void *)0);
  s = pa_simple_new((char const   *)((void *)0), "cava", (pa_stream_direction_t )2,
                    (char const   *)audio->source, "audio for cava", & ss, (pa_channel_map const   *)((void *)0),
                    (pa_buffer_attr const   *)(& pb), & error);
  if (! s) {
    tmp = pa_strerror(error);
    sprintf((char * __restrict  )(audio->error_message), (char const   * __restrict  )"input/pulse.c: Could not open pulseaudio source: %s, %s. \t\tTo find a list of your pulseaudio sources run \'pacmd list-sources\'\n",
            audio->source, tmp);
    audio->terminate = 1;
  }
  while (! audio->terminate) {
    tmp___1 = pa_simple_read(s, (void *)(buf), sizeof(buf), & error);
    if (tmp___1 < 0) {
      tmp___0 = pa_strerror(error);
      sprintf((char * __restrict  )(audio->error_message), (char const   * __restrict  )"input/pulse.c: pa_simple_read() failed: %s\n",
              tmp___0);
      audio->terminate = 1;
    }
    pthread_mutex_lock(& lock);
    write_to_fftw_input_buffers((int16_t )frames, buf, data);
    pthread_mutex_unlock(& lock);
  }
  pa_simple_free(s);
  pthread_exit((void *)0);
  return ((void *)0);
}
}
#pragma merger("0","/tmp/cil-i9hw1kLJ.i","-std=c99,-Wall,-Werror,-Wextra,-Wno-unused-result,-Wno-unknown-warning-option,-Wno-maybe-uninitialized,-Wno-vla-parameter,-g,-O2")
void get_terminal_dim_ncurses(int *width , int *height ) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern _Bool can_change_color(void) ;
extern int curs_set(int  ) ;
extern int echo(void) ;
extern int endwin(void) ;
extern WINDOW *initscr(void) ;
extern int init_color(short  , short  , short  , short  ) ;
extern int init_pair(short  , short  , short  ) ;
extern int noecho(void) ;
extern int start_color(void) ;
extern int waddch(WINDOW * , chtype const    ) ;
extern int wattrset(WINDOW * , int  ) ;
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
extern int wbkgd(WINDOW * , chtype  ) ;
extern int wclear(WINDOW * ) ;
extern int wmove(WINDOW * , int  , int  ) ;
extern int wrefresh(WINDOW * ) ;
extern void wtimeout(WINDOW * , int  ) ;
extern int use_default_colors(void) ;
extern int COLORS ;
extern int COLOR_PAIRS ;
extern int COLS ;
extern int LINES ;
extern int waddnwstr(WINDOW * , wchar_t const   * , int  ) ;
int gradient_size  =    64;
wchar_t const   *bar_heights[8]  = 
  {      (wchar_t const   *)L"2581",      (wchar_t const   *)L"2582",      (wchar_t const   *)L"2583",      (wchar_t const   *)L"2584", 
        (wchar_t const   *)L"2585",      (wchar_t const   *)L"2586",      (wchar_t const   *)L"2587",      (wchar_t const   *)L"2588"};
int num_bar_heights  =    (int )(sizeof(bar_heights) / sizeof(bar_heights[0]));
static void parse_color(char *color_string , struct colors *color ) 
{ 
  _Bool tmp ;

  {
  if ((int )*(color_string + 0) == 35) {
    tmp = can_change_color();
    if (! tmp) {
      cleanup_terminal_ncurses();
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Your terminal can not change color definitions, please use one of the predefined colors.\n");
      exit(1);
    }
    color->color = (short)-2;
    color_string ++;
    sscanf((char const   * __restrict  )color_string, (char const   * __restrict  )"%02hx%02hx%02hx",
           & color->R, & color->G, & color->B);
  }
  return;
}
}
static short change_color_definition(short color_number , char * const  color_string ,
                                     short predef_color ) 
{ 
  struct colors color ;
  short return_color_number ;

  {
  color.color = (short)0;
  color.R = (short)0;
  color.G = (short)0;
  color.B = (short)0;
  parse_color((char *)color_string, & color);
  return_color_number = predef_color;
  if ((int )color.color == -2) {
    init_color(color_number, (short )(((double )color.R * 1000.0) / (double )255 + 0.5),
               (short )(((double )color.G * 1000.0) / (double )255 + 0.5), (short )(((double )color.B * 1000.0) / (double )255 + 0.5));
    return_color_number = color_number;
  }
  return (return_color_number);
}
}
void init_terminal_ncurses(char * const  fg_color_string , char * const  bg_color_string ,
                           int predef_fg_color , int predef_bg_color , int gradient ,
                           int gradient_count , char **gradient_colors , int *width ,
                           int *lines ) 
{ 
  short color_pair_number ;
  short bg_color_number ;
  short fg_color_number ;
  char next_color[14] ;
  int i ;
  int col ;
  int individual_size ;
  int i___0 ;
  int col___0 ;
  int j ;
  int k ;
  int left ;
  int col___1 ;
  int y ;
  int x ;
  int tmp ;

  {
  initscr();
  curs_set(0);
  wtimeout(stdscr, 0);
  noecho();
  start_color();
  use_default_colors();
  if ((unsigned long )((void const   *)0) != (unsigned long )((void const   *)stdscr)) {
    *lines = (int )stdscr->_maxy + 1;
  } else {
    *lines = -1;
  }
  if ((unsigned long )((void const   *)0) != (unsigned long )((void const   *)stdscr)) {
    *width = (int )stdscr->_maxx + 1;
  } else {
    *width = -1;
  }
  wclear(stdscr);
  color_pair_number = (short)16;
  bg_color_number = change_color_definition((short)0, bg_color_string, (short )predef_bg_color);
  if (! gradient) {
    fg_color_number = change_color_definition((short)1, fg_color_string, (short )predef_fg_color);
    init_pair(color_pair_number, fg_color_number, bg_color_number);
  } else
  if (gradient) {
    unsigned short rgb[2 * gradient_count - 1][3] ;
    gradient_size = *lines;
    if (gradient_size > COLORS) {
      gradient_size = COLORS - 1;
    }
    if (gradient_size > COLOR_PAIRS) {
      gradient_size = COLOR_PAIRS - 1;
    }
    if (gradient_size > 256) {
      gradient_size = 255;
    }
    i = 0;
    while (i < gradient_count) {
      col = (i + 1) * 2 - 2;
      sscanf((char const   * __restrict  )(*(gradient_colors + i) + 1), (char const   * __restrict  )"%02hx%02hx%02hx",
             & rgb[col][0], & rgb[col][1], & rgb[col][2]);
      i ++;
    }
    individual_size = gradient_size / (gradient_count - 1);
    i___0 = 0;
    while (i___0 < gradient_count - 1) {
      col___0 = (i___0 + 1) * 2 - 2;
      if (i___0 == gradient_count - 1) {
        col___0 = 2 * (gradient_count - 1) - 2;
      }
      j = 0;
      while (j < individual_size) {
        k = 0;
        while (k < 3) {
          rgb[col___0 + 1][k] = (unsigned short )((double )rgb[col___0][k] + (double )((int )rgb[col___0 + 2][k] - (int )rgb[col___0][k]) * ((double )j / ((double )individual_size * 0.85)));
          if ((int )rgb[col___0 + 1][k] > 255) {
            rgb[col___0][k] = (unsigned short)0;
          }
          if ((double )j > (double )individual_size * 0.85) {
            rgb[col___0 + 1][k] = rgb[col___0 + 2][k];
          }
          k ++;
        }
        sprintf((char * __restrict  )(next_color), (char const   * __restrict  )"#%02x%02x%02x",
                (int )rgb[col___0 + 1][0], (int )rgb[col___0 + 1][1], (int )rgb[col___0 + 1][2]);
        change_color_definition(color_pair_number, (char * const  )(next_color), color_pair_number);
        init_pair(color_pair_number, color_pair_number, bg_color_number);
        color_pair_number = (short )((int )color_pair_number + 1);
        j ++;
      }
      i___0 ++;
    }
    left = individual_size * (gradient_count - 1);
    col___1 = 2 * gradient_count - 2;
    while (left < gradient_size) {
      sprintf((char * __restrict  )(next_color), (char const   * __restrict  )"#%02x%02x%02x",
              (int )rgb[col___1][0], (int )rgb[col___1][1], (int )rgb[col___1][2]);
      change_color_definition(color_pair_number, (char * const  )(next_color), color_pair_number);
      init_pair(color_pair_number, color_pair_number, bg_color_number);
      color_pair_number = (short )((int )color_pair_number + 1);
      left ++;
    }
    color_pair_number = (short )((int )color_pair_number - 1);
  }
  wattr_on(stdscr, ((chtype )color_pair_number << 8) & (((1U << 8) - 1U) << 8), (void *)0);
  if ((int )bg_color_number != -1) {
    wbkgd(stdscr, ((chtype )color_pair_number << 8) & (((1U << 8) - 1U) << 8));
  }
  y = 0;
  while (y < *lines) {
    x = 0;
    while (x < *width) {
      tmp = wmove(stdscr, y, x);
      if (! (tmp == -1)) {
        waddch(stdscr, (chtype const   )' ');
      }
      x ++;
    }
    y ++;
  }
  wrefresh(stdscr);
  return;
}
}
void change_colors(int cur_height , int tot_height ) 
{ 


  {
  tot_height /= gradient_size;
  if (tot_height < 1) {
    tot_height = 1;
  }
  cur_height /= tot_height;
  if (cur_height > gradient_size - 1) {
    cur_height = gradient_size - 1;
  }
  wattr_on(stdscr, ((chtype )(cur_height + 16) << 8) & (((1U << 8) - 1U) << 8), (void *)0);
  return;
}
}
void get_terminal_dim_ncurses(int *width , int *height ) 
{ 


  {
  if ((unsigned long )((void const   *)0) != (unsigned long )((void const   *)stdscr)) {
    *height = (int )stdscr->_maxy + 1;
  } else {
    *height = -1;
  }
  if ((unsigned long )((void const   *)0) != (unsigned long )((void const   *)stdscr)) {
    *width = (int )stdscr->_maxx + 1;
  } else {
    *width = -1;
  }
  gradient_size = *height;
  wclear(stdscr);
  return;
}
}
int draw_terminal_ncurses(int is_tty , int terminal_height , int terminal_width ,
                          int bars_count , int bar_width , int bar_spacing , int rest ,
                          int const   *bars , int *previous_frame , int gradient ,
                          int x_axis_info ) 
{ 
  int height ;
  int max_update_y ;
  int bar ;
  int _a ;
  int _b___0 ;
  int _a___1 ;
  int _b___1 ;
  int tmp___0 ;
  int tmp___1 ;
  int y ;
  int bar___0 ;
  int cur_col ;
  int f_cell ;
  int f_last_cell ;
  int bar_step ;
  int col ;
  int i ;
  int tmp___2 ;
  int tmp___3 ;
  int col___0 ;
  int i___0 ;
  int tmp___4 ;

  {
  height = terminal_height - 1;
  if (! is_tty) {
    if (x_axis_info) {
      terminal_height ++;
    }
    if (LINES != terminal_height) {
      goto _L;
    } else
    if (COLS != terminal_width) {
      _L: /* CIL Label */ 
      return (-1);
      if (x_axis_info) {
        terminal_height --;
      }
    }
  }
  max_update_y = 0;
  bar = 0;
  while (bar < bars_count) {
    _a = max_update_y;
    _a___1 = (int )*(bars + bar);
    _b___1 = *(previous_frame + bar);
    if (_a___1 > _b___1) {
      tmp___0 = _a___1;
    } else {
      tmp___0 = _b___1;
    }
    _b___0 = tmp___0;
    if (_a > _b___0) {
      tmp___1 = _a;
    } else {
      tmp___1 = _b___0;
    }
    max_update_y = tmp___1;
    bar ++;
  }
  max_update_y = (max_update_y + num_bar_heights) / num_bar_heights;
  y = 0;
  while (y < max_update_y) {
    if (gradient) {
      change_colors(y, height);
    }
    bar___0 = 0;
    while (bar___0 < bars_count) {
      if (*(bars + bar___0) == (int const   )*(previous_frame + bar___0)) {
        goto __Cont;
      }
      cur_col = (bar___0 * bar_width + bar___0 * bar_spacing) + rest;
      f_cell = (int )((*(bars + bar___0) - 1) / (int const   )num_bar_heights);
      f_last_cell = (*(previous_frame + bar___0) - 1) / num_bar_heights;
      if (f_cell >= y) {
        if (f_cell == y) {
          bar_step = (int )((*(bars + bar___0) - 1) % (int const   )num_bar_heights);
        } else
        if (f_last_cell <= y) {
          bar_step = num_bar_heights - 1;
        } else {
          goto __Cont;
        }
        col = cur_col;
        i = 0;
        while (i < bar_width) {
          if (is_tty) {
            tmp___2 = wmove(stdscr, height - y, col);
            if (! (tmp___2 == -1)) {
              waddch(stdscr, (chtype const   )(65 + bar_step));
            }
          } else {
            tmp___3 = wmove(stdscr, height - y, col);
            if (! (tmp___3 == -1)) {
              waddnwstr(stdscr, bar_heights[bar_step], -1);
            }
          }
          i ++;
          col ++;
        }
      } else
      if (f_last_cell >= y) {
        col___0 = cur_col;
        i___0 = 0;
        while (i___0 < bar_width) {
          tmp___4 = wmove(stdscr, height - y, col___0);
          if (! (tmp___4 == -1)) {
            waddch(stdscr, (chtype const   )' ');
          }
          i___0 ++;
          col___0 ++;
        }
      }
      __Cont: /* CIL Label */ 
      bar___0 ++;
    }
    y ++;
  }
  wrefresh(stdscr);
  return (0);
}
}
void cleanup_terminal_ncurses(void) 
{ 


  {
  echo();
  system("setfont  >/dev/null 2>&1");
  system("setfont /usr/share/consolefonts/Lat2-Fixed16.psf.gz  >/dev/null 2>&1");
  system("setterm -blank 10  >/dev/null 2>&1");
  wattrset(stdscr, 0);
  endwin();
  system("clear");
  return;
}
}
