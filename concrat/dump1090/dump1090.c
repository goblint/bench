/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __suseconds_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __ssize_t ssize_t;
typedef __time_t time_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_506248102 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_112954847 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_100370678 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_112954847 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_506248102 __annonCompField1 ;
   union __anonunion____missing_field_name_100370678 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef void (*__sighandler_t)(int  );
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct rtlsdr_dev ;
typedef struct rtlsdr_dev rtlsdr_dev_t;
struct client {
   int fd ;
   int service ;
   char buf[1025] ;
   int buflen ;
};
struct aircraft {
   uint32_t addr ;
   char hexaddr[7] ;
   char flight[9] ;
   int altitude ;
   int speed ;
   int track ;
   time_t seen ;
   long messages ;
   int odd_cprlat ;
   int odd_cprlon ;
   int even_cprlat ;
   int even_cprlon ;
   double lat ;
   double lon ;
   long long odd_cprtime ;
   long long even_cprtime ;
   struct aircraft *next ;
};
struct __anonstruct_Modes_120292704 {
   pthread_t reader_thread ;
   pthread_mutex_t data_mutex ;
   pthread_cond_t data_cond ;
   unsigned char *data ;
   uint16_t *magnitude ;
   uint32_t data_len ;
   int fd ;
   int data_ready ;
   uint32_t *icao_cache ;
   uint16_t *maglut ;
   int exit ;
   int dev_index ;
   int gain ;
   int enable_agc ;
   rtlsdr_dev_t *dev ;
   int freq ;
   char aneterr[256] ;
   struct client *clients[1024] ;
   int maxfd ;
   int sbsos ;
   int ros ;
   int ris ;
   int https ;
   char *filename ;
   int loop ;
   int fix_errors ;
   int check_crc ;
   int raw ;
   int debug ;
   int net ;
   int net_only ;
   int interactive ;
   int interactive_rows ;
   int interactive_ttl ;
   int stats ;
   int onlyaddr ;
   int metric ;
   int aggressive ;
   struct aircraft *aircrafts ;
   long long interactive_last_update ;
   long long stat_valid_preamble ;
   long long stat_demodulated ;
   long long stat_goodcrc ;
   long long stat_badcrc ;
   long long stat_fixed ;
   long long stat_single_bit_fix ;
   long long stat_two_bits_fix ;
   long long stat_http_requests ;
   long long stat_sbs_connections ;
   long long stat_out_of_phase ;
};
struct modesMessage {
   unsigned char msg[14] ;
   int msgbits ;
   int msgtype ;
   int crcok ;
   uint32_t crc ;
   int errorbit ;
   int aa1 ;
   int aa2 ;
   int aa3 ;
   int phase_corrected ;
   int ca ;
   int metype ;
   int mesub ;
   int heading_is_valid ;
   int heading ;
   int aircraft_type ;
   int fflag ;
   int tflag ;
   int raw_latitude ;
   int raw_longitude ;
   char flight[9] ;
   int ew_dir ;
   int ew_velocity ;
   int ns_dir ;
   int ns_velocity ;
   int vert_rate_source ;
   int vert_rate_sign ;
   int vert_rate ;
   int velocity ;
   int fs ;
   int dr ;
   int um ;
   int identity ;
   int altitude ;
   int unit ;
};
struct __anonstruct_modesNetServices_483049182 {
   char *descr ;
   int *socket ;
   int port ;
};
typedef unsigned int __socklen_t;
typedef __mode_t mode_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
typedef __gnuc_va_list va_list___0;
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-4Nih5QUE.i","-O2,-g,-Wall,-W")
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern int fclose(FILE *__stream ) ;
extern int fflush(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern void perror(char const   *__s ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern int usleep(__useconds_t __useconds ) ;
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double round(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
extern uint32_t __attribute__((__visibility__("default")))  rtlsdr_get_device_count(void) ;
extern int __attribute__((__visibility__("default")))  rtlsdr_get_device_usb_strings(uint32_t index ,
                                                                                     char *manufact ,
                                                                                     char *product ,
                                                                                     char *serial ) ;
extern int __attribute__((__visibility__("default")))  rtlsdr_open(rtlsdr_dev_t **dev ,
                                                                   uint32_t index ) ;
extern int __attribute__((__visibility__("default")))  rtlsdr_close(rtlsdr_dev_t *dev ) ;
extern int __attribute__((__visibility__("default")))  rtlsdr_set_center_freq(rtlsdr_dev_t *dev ,
                                                                              uint32_t freq ) ;
extern int __attribute__((__visibility__("default")))  rtlsdr_set_freq_correction(rtlsdr_dev_t *dev ,
                                                                                  int ppm ) ;
extern int __attribute__((__visibility__("default")))  rtlsdr_get_tuner_gains(rtlsdr_dev_t *dev ,
                                                                              int *gains ) ;
extern int __attribute__((__visibility__("default")))  rtlsdr_set_tuner_gain(rtlsdr_dev_t *dev ,
                                                                             int gain ) ;
extern int __attribute__((__visibility__("default")))  rtlsdr_get_tuner_gain(rtlsdr_dev_t *dev ) ;
extern int __attribute__((__visibility__("default")))  rtlsdr_set_tuner_gain_mode(rtlsdr_dev_t *dev ,
                                                                                  int manual ) ;
extern int __attribute__((__visibility__("default")))  rtlsdr_set_sample_rate(rtlsdr_dev_t *dev ,
                                                                              uint32_t rate ) ;
extern int __attribute__((__visibility__("default")))  rtlsdr_set_agc_mode(rtlsdr_dev_t *dev ,
                                                                           int on ) ;
extern int __attribute__((__visibility__("default")))  rtlsdr_reset_buffer(rtlsdr_dev_t *dev ) ;
extern int __attribute__((__visibility__("default")))  rtlsdr_read_async(rtlsdr_dev_t *dev ,
                                                                         void (*cb)(unsigned char *buf ,
                                                                                    uint32_t len ,
                                                                                    void *ctx ) ,
                                                                         void *ctx ,
                                                                         uint32_t buf_num ,
                                                                         uint32_t buf_len ) ;
int anetTcpServer(char *err , int port , char *bindaddr ) ;
int anetTcpAccept(char *err , int s , char *ip , int *port ) ;
int anetNonBlock(char *err , int fd ) ;
int anetSetSendBuffer(char *err , int fd , int buffsize ) ;
struct __anonstruct_Modes_120292704 Modes  ;
void interactiveShowData(void) ;
struct aircraft *interactiveReceiveData(struct modesMessage *mm ) ;
void modesSendRawOutput(struct modesMessage *mm ) ;
void modesSendSBSOutput(struct modesMessage *mm , struct aircraft *a ) ;
void useModesMessage(struct modesMessage *mm ) ;
int fixSingleBitErrors(unsigned char *msg , int bits ) ;
int fixTwoBitsErrors(unsigned char *msg , int bits ) ;
int modesMessageLenByType(int type ) ;
void sigWinchCallback(void) ;
int getTermRows(void) ;
static long long mstime(void) 
{ 
  struct timeval tv ;
  long long mst ;

  {
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  mst = (long long )tv.tv_sec * 1000LL;
  mst += (long long )(tv.tv_usec / 1000L);
  return (mst);
}
}
void modesInitConfig(void) 
{ 


  {
  Modes.gain = 999999;
  Modes.dev_index = 0;
  Modes.enable_agc = 0;
  Modes.freq = 1090000000;
  Modes.filename = (char *)((void *)0);
  Modes.fix_errors = 1;
  Modes.check_crc = 1;
  Modes.raw = 0;
  Modes.net = 0;
  Modes.net_only = 0;
  Modes.onlyaddr = 0;
  Modes.debug = 0;
  Modes.interactive = 0;
  Modes.interactive_rows = 15;
  Modes.interactive_ttl = 60;
  Modes.aggressive = 0;
  Modes.interactive_rows = getTermRows();
  Modes.loop = 0;
  return;
}
}
void modesInit(void) 
{ 
  int i ;
  int q ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
  pthread_mutex_init(& Modes.data_mutex, (pthread_mutexattr_t const   *)((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& Modes.data_cond), (pthread_condattr_t const   * __restrict  )((void *)0));
  Modes.data_len = (uint32_t )262620;
  Modes.data_ready = 0;
  tmp = malloc((sizeof(uint32_t ) * 1024UL) * 2UL);
  Modes.icao_cache = (uint32_t *)tmp;
  memset((void *)Modes.icao_cache, 0, (sizeof(uint32_t ) * 1024UL) * 2UL);
  Modes.aircrafts = (struct aircraft *)((void *)0);
  Modes.interactive_last_update = 0LL;
  tmp___0 = malloc((size_t )Modes.data_len);
  Modes.data = (unsigned char *)tmp___0;
  if ((unsigned long )Modes.data == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Out of memory allocating data buffer.\n");
    exit(1);
  } else {
    tmp___1 = malloc((size_t )(Modes.data_len * 2U));
    Modes.magnitude = (uint16_t *)tmp___1;
    if ((unsigned long )Modes.magnitude == (unsigned long )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Out of memory allocating data buffer.\n");
      exit(1);
    }
  }
  memset((void *)Modes.data, 127, (size_t )Modes.data_len);
  tmp___2 = malloc((size_t )33282);
  Modes.maglut = (uint16_t *)tmp___2;
  i = 0;
  while (i <= 128) {
    q = 0;
    while (q <= 128) {
      tmp___3 = sqrt((double )(i * i + q * q));
      tmp___4 = round(tmp___3 * (double )360);
      *(Modes.maglut + (i * 129 + q)) = (uint16_t )tmp___4;
      q ++;
    }
    i ++;
  }
  Modes.stat_valid_preamble = 0LL;
  Modes.stat_demodulated = 0LL;
  Modes.stat_goodcrc = 0LL;
  Modes.stat_badcrc = 0LL;
  Modes.stat_fixed = 0LL;
  Modes.stat_single_bit_fix = 0LL;
  Modes.stat_two_bits_fix = 0LL;
  Modes.stat_http_requests = 0LL;
  Modes.stat_sbs_connections = 0LL;
  Modes.stat_out_of_phase = 0LL;
  Modes.exit = 0;
  return;
}
}
void modesInitRTLSDR(void) 
{ 
  int j ;
  int device_count ;
  int ppm_error ;
  char vendor[256] ;
  char product[256] ;
  char serial[256] ;
  uint32_t __attribute__((__visibility__("default")))  tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  int tmp___4 ;
  int numgains ;
  int gains[100] ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  int __attribute__((__visibility__("default")))  tmp___6 ;

  {
  ppm_error = 0;
  tmp = rtlsdr_get_device_count();
  device_count = (int )tmp;
  if (! device_count) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No supported RTLSDR devices found.\n");
    exit(1);
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Found %d device(s):\n",
          device_count);
  j = 0;
  while (j < device_count) {
    rtlsdr_get_device_usb_strings((uint32_t )j, vendor, product, serial);
    if (j == Modes.dev_index) {
      tmp___0 = "(currently selected)";
    } else {
      tmp___0 = "";
    }
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%d: %s, %s, SN: %s %s\n",
            j, vendor, product, serial, tmp___0);
    j ++;
  }
  tmp___3 = rtlsdr_open(& Modes.dev, (uint32_t )Modes.dev_index);
  if (tmp___3 < (int __attribute__((__visibility__("default")))  )0) {
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error opening the RTLSDR device: %s\n",
            tmp___2);
    exit(1);
  }
  if (Modes.gain == -100) {
    tmp___4 = 0;
  } else {
    tmp___4 = 1;
  }
  rtlsdr_set_tuner_gain_mode(Modes.dev, tmp___4);
  if (Modes.gain != -100) {
    if (Modes.gain == 999999) {
      tmp___5 = rtlsdr_get_tuner_gains(Modes.dev, gains);
      numgains = (int )tmp___5;
      Modes.gain = gains[numgains - 1];
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Max available gain is: %.2f\n",
              (double )Modes.gain / 10.0);
    }
    rtlsdr_set_tuner_gain(Modes.dev, Modes.gain);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Setting gain to: %.2f\n",
            (double )Modes.gain / 10.0);
  } else {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Using automatic gain control.\n");
  }
  rtlsdr_set_freq_correction(Modes.dev, ppm_error);
  if (Modes.enable_agc) {
    rtlsdr_set_agc_mode(Modes.dev, 1);
  }
  rtlsdr_set_center_freq(Modes.dev, (uint32_t )Modes.freq);
  rtlsdr_set_sample_rate(Modes.dev, (uint32_t )2000000);
  rtlsdr_reset_buffer(Modes.dev);
  tmp___6 = rtlsdr_get_tuner_gain(Modes.dev);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Gain reported by device: %.2f\n",
          (double )tmp___6 / 10.0);
  return;
}
}
void rtlsdrCallback(unsigned char *buf , uint32_t len , void *ctx ) 
{ 


  {
  pthread_mutex_lock(& Modes.data_mutex);
  if (len > 262144U) {
    len = (uint32_t )262144;
  }
  memcpy((void * __restrict  )Modes.data, (void const   * __restrict  )(Modes.data + 262144),
         (size_t )476);
  memcpy((void * __restrict  )(Modes.data + 476), (void const   * __restrict  )buf,
         (size_t )len);
  Modes.data_ready = 1;
  pthread_cond_signal(& Modes.data_cond);
  pthread_mutex_unlock(& Modes.data_mutex);
  return;
}
}
void readDataFromFile(void) 
{ 
  ssize_t nread ;
  ssize_t toread ;
  unsigned char *p ;
  __off_t tmp ;

  {
  pthread_mutex_lock(& Modes.data_mutex);
  while (1) {
    if (Modes.data_ready) {
      pthread_cond_wait((pthread_cond_t * __restrict  )(& Modes.data_cond), (pthread_mutex_t * __restrict  )(& Modes.data_mutex));
      continue;
    }
    if (Modes.interactive) {
      pthread_mutex_unlock(& Modes.data_mutex);
      usleep((__useconds_t )5000);
      pthread_mutex_lock(& Modes.data_mutex);
    }
    memcpy((void * __restrict  )Modes.data, (void const   * __restrict  )(Modes.data + 262144),
           (size_t )476);
    toread = (ssize_t )262144;
    p = Modes.data + 476;
    while (toread) {
      nread = read(Modes.fd, (void *)p, (size_t )toread);
      if (nread == 0L) {
        if ((unsigned long )Modes.filename != (unsigned long )((void *)0)) {
          if (Modes.fd != 0) {
            if (Modes.loop) {
              tmp = lseek(Modes.fd, (__off_t )0, 0);
              if (tmp != -1L) {
                continue;
              }
            }
          }
        }
      }
      if (nread <= 0L) {
        Modes.exit = 1;
        break;
      }
      p += nread;
      toread -= nread;
    }
    if (toread) {
      memset((void *)p, 127, (size_t )toread);
    }
    Modes.data_ready = 1;
    pthread_cond_signal(& Modes.data_cond);
  }
}
}
void *readerThreadEntryPoint(void *arg ) 
{ 


  {
  if ((unsigned long )Modes.filename == (unsigned long )((void *)0)) {
    rtlsdr_read_async(Modes.dev, & rtlsdrCallback, (void *)0, (uint32_t )12, (uint32_t )262144);
  } else {
    readDataFromFile();
  }
  return ((void *)0);
}
}
void dumpMagnitudeBar(int index___0 , int magnitude ) 
{ 
  char *set ;
  char buf[256] ;
  int div___0 ;
  int rem ;
  int markchar ;

  {
  set = (char *)" .-o";
  div___0 = (magnitude / 256) / 4;
  rem = (magnitude / 256) % 4;
  memset((void *)(buf), 'O', (size_t )div___0);
  buf[div___0] = *(set + rem);
  buf[div___0 + 1] = (char )'\000';
  if (index___0 >= 0) {
    markchar = ']';
    if (index___0 == 0) {
      markchar = '>';
    } else
    if (index___0 == 2) {
      markchar = '>';
    } else
    if (index___0 == 7) {
      markchar = '>';
    } else
    if (index___0 == 9) {
      markchar = '>';
    }
    if (index___0 >= 16) {
      if ((index___0 - 16) / 2 & 1) {
        markchar = '|';
      } else {
        markchar = ')';
      }
    }
    printf((char const   * __restrict  )"[%.3d%c |%-66s %d\n", index___0, markchar,
           buf, magnitude);
  } else {
    printf((char const   * __restrict  )"[%.2d] |%-66s %d\n", index___0, buf, magnitude);
  }
  return;
}
}
void dumpMagnitudeVector(uint16_t *m , uint32_t offset ) 
{ 
  uint32_t padding ;
  uint32_t start ;
  uint32_t tmp ;
  uint32_t end ;
  uint32_t j ;

  {
  padding = (uint32_t )5;
  if (offset < padding) {
    tmp = (uint32_t )0;
  } else {
    tmp = offset - padding;
  }
  start = tmp;
  end = ((offset + 16U) + 112U) - 1U;
  j = start;
  while (j <= end) {
    dumpMagnitudeBar((int )(j - offset), (int )*(m + j));
    j ++;
  }
  return;
}
}
void dumpRawMessageJS(char *descr , unsigned char *msg , uint16_t *m , uint32_t offset ,
                      int fixable ) 
{ 
  int padding ;
  int start ;
  int end ;
  FILE *fp ;
  int j ;
  int fix1 ;
  int fix2 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  padding = 5;
  start = (int )(offset - (uint32_t )padding);
  end = (int )(((offset + 16U) + 224U) - 1U);
  fix1 = -1;
  fix2 = -1;
  if (fixable != -1) {
    fix1 = fixable & 255;
    if (fixable > 255) {
      fix2 = fixable >> 8;
    }
  }
  fp = fopen((char const   * __restrict  )"frames.js", (char const   * __restrict  )"a");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error opening frames.js: %s\n",
            tmp___0);
    exit(1);
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"frames.push({\"descr\": \"%s\", \"mag\": [",
          descr);
  j = start;
  while (j <= end) {
    if (j < 0) {
      tmp___1 = 0;
    } else {
      tmp___1 = (int )*(m + j);
    }
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d", tmp___1);
    if (j != end) {
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )",");
    }
    j ++;
  }
  tmp___2 = modesMessageLenByType((int )*(msg + 0) >> 3);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"], \"fix1\": %d, \"fix2\": %d, \"bits\": %d, \"hex\": \"",
          fix1, fix2, tmp___2);
  j = 0;
  while (j < 14) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\\x%02x", (int )*(msg + j));
    j ++;
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\"});\n");
  fclose(fp);
  return;
}
}
void dumpRawMessage(char *descr , unsigned char *msg , uint16_t *m , uint32_t offset ) 
{ 
  int j ;
  int msgtype ;
  int fixable ;
  int msgbits ;
  int tmp ;

  {
  msgtype = (int )*(msg + 0) >> 3;
  fixable = -1;
  if (msgtype == 11) {
    goto _L;
  } else
  if (msgtype == 17) {
    _L: /* CIL Label */ 
    if (msgtype == 11) {
      tmp = 56;
    } else {
      tmp = 112;
    }
    msgbits = tmp;
    fixable = fixSingleBitErrors(msg, msgbits);
    if (fixable == -1) {
      fixable = fixTwoBitsErrors(msg, msgbits);
    }
  }
  if (Modes.debug & (1 << 6)) {
    dumpRawMessageJS(descr, msg, m, offset, fixable);
    return;
  }
  printf((char const   * __restrict  )"\n--- %s\n    ", descr);
  j = 0;
  while (j < 14) {
    printf((char const   * __restrict  )"%02x", (int )*(msg + j));
    if (j == 6) {
      printf((char const   * __restrict  )" ... ");
    }
    j ++;
  }
  printf((char const   * __restrict  )" (DF %d, Fixable: %d)\n", msgtype, fixable);
  dumpMagnitudeVector(m, offset);
  printf((char const   * __restrict  )"---\n\n");
  return;
}
}
uint32_t modes_checksum_table[112]  = 
  {      (uint32_t )3749354,      (uint32_t )1874677,      (uint32_t )15841150,      (uint32_t )7920575, 
        (uint32_t )12818395,      (uint32_t )10367465,      (uint32_t )11592432,      (uint32_t )5796216, 
        (uint32_t )2898108,      (uint32_t )1449054,      (uint32_t )724527,      (uint32_t )16416019, 
        (uint32_t )8569997,      (uint32_t )12490818,      (uint32_t )6245409,      (uint32_t )13655060, 
        (uint32_t )6827530,      (uint32_t )3413765,      (uint32_t )15069574,      (uint32_t )7534787, 
        (uint32_t )13010533,      (uint32_t )10271030,      (uint32_t )5135515,      (uint32_t )14210121, 
        (uint32_t )9670688,      (uint32_t )4835344,      (uint32_t )2417672,      (uint32_t )1208836, 
        (uint32_t )604418,      (uint32_t )302209,      (uint32_t )16626756,      (uint32_t )8313378, 
        (uint32_t )4156689,      (uint32_t )14699660,      (uint32_t )7349830,      (uint32_t )3674915, 
        (uint32_t )14939029,      (uint32_t )9307086,      (uint32_t )4653543,      (uint32_t )14449399, 
        (uint32_t )9553791,      (uint32_t )11999675,      (uint32_t )10778329,      (uint32_t )11387240, 
        (uint32_t )5693620,      (uint32_t )2846810,      (uint32_t )1423405,      (uint32_t )16066066, 
        (uint32_t )8033033,      (uint32_t )12759936,      (uint32_t )6379968,      (uint32_t )3189984, 
        (uint32_t )1594992,      (uint32_t )797496,      (uint32_t )398748,      (uint32_t )199374, 
        (uint32_t )99687,      (uint32_t )16726199,      (uint32_t )8414815,      (uint32_t )12568875, 
        (uint32_t )10493585,      (uint32_t )11531596,      (uint32_t )5765798,      (uint32_t )2882899, 
        (uint32_t )15336621,      (uint32_t )9107538,      (uint32_t )4553769,      (uint32_t )14500880, 
        (uint32_t )7250440,      (uint32_t )3625220,      (uint32_t )1812610,      (uint32_t )906305, 
        (uint32_t )16322596,      (uint32_t )8161298,      (uint32_t )4080649,      (uint32_t )14735360, 
        (uint32_t )7367680,      (uint32_t )3683840,      (uint32_t )1841920,      (uint32_t )920960, 
        (uint32_t )460480,      (uint32_t )230240,      (uint32_t )115120,      (uint32_t )57560, 
        (uint32_t )28780,      (uint32_t )14390,      (uint32_t )7195,      (uint32_t )16774153, 
        (uint32_t )0,      (uint32_t )0,      (uint32_t )0,      (uint32_t )0, 
        (uint32_t )0,      (uint32_t )0,      (uint32_t )0,      (uint32_t )0, 
        (uint32_t )0,      (uint32_t )0,      (uint32_t )0,      (uint32_t )0, 
        (uint32_t )0,      (uint32_t )0,      (uint32_t )0,      (uint32_t )0, 
        (uint32_t )0,      (uint32_t )0,      (uint32_t )0,      (uint32_t )0, 
        (uint32_t )0,      (uint32_t )0,      (uint32_t )0,      (uint32_t )0};
uint32_t modesChecksum(unsigned char *msg , int bits ) 
{ 
  uint32_t crc ;
  int offset ;
  int tmp ;
  int j ;
  int byte ;
  int bit ;
  int bitmask ;

  {
  crc = (uint32_t )0;
  if (bits == 112) {
    tmp = 0;
  } else {
    tmp = 56;
  }
  offset = tmp;
  j = 0;
  while (j < bits) {
    byte = j / 8;
    bit = j % 8;
    bitmask = 1 << (7 - bit);
    if ((int )*(msg + byte) & bitmask) {
      crc ^= modes_checksum_table[j + offset];
    }
    j ++;
  }
  return (crc);
}
}
int modesMessageLenByType(int type ) 
{ 


  {
  if (type == 16) {
    return (112);
  } else
  if (type == 17) {
    return (112);
  } else
  if (type == 19) {
    return (112);
  } else
  if (type == 20) {
    return (112);
  } else
  if (type == 21) {
    return (112);
  } else {
    return (56);
  }
}
}
int fixSingleBitErrors(unsigned char *msg , int bits ) 
{ 
  int j ;
  unsigned char aux[14] ;
  int byte ;
  int bitmask ;
  uint32_t crc1 ;
  uint32_t crc2 ;

  {
  j = 0;
  while (j < bits) {
    byte = j / 8;
    bitmask = 1 << (7 - j % 8);
    memcpy((void * __restrict  )(aux), (void const   * __restrict  )msg, (size_t )(bits / 8));
    aux[byte] = (unsigned char )((int )aux[byte] ^ bitmask);
    crc1 = (((uint32_t )aux[bits / 8 - 3] << 16) | ((uint32_t )aux[bits / 8 - 2] << 8)) | (uint32_t )aux[bits / 8 - 1];
    crc2 = modesChecksum(aux, bits);
    if (crc1 == crc2) {
      memcpy((void * __restrict  )msg, (void const   * __restrict  )(aux), (size_t )(bits / 8));
      return (j);
    }
    j ++;
  }
  return (-1);
}
}
int fixTwoBitsErrors(unsigned char *msg , int bits ) 
{ 
  int j ;
  int i ;
  unsigned char aux[14] ;
  int byte1 ;
  int bitmask1 ;
  int byte2 ;
  int bitmask2 ;
  uint32_t crc1 ;
  uint32_t crc2 ;

  {
  j = 0;
  while (j < bits) {
    byte1 = j / 8;
    bitmask1 = 1 << (7 - j % 8);
    i = j + 1;
    while (i < bits) {
      byte2 = i / 8;
      bitmask2 = 1 << (7 - i % 8);
      memcpy((void * __restrict  )(aux), (void const   * __restrict  )msg, (size_t )(bits / 8));
      aux[byte1] = (unsigned char )((int )aux[byte1] ^ bitmask1);
      aux[byte2] = (unsigned char )((int )aux[byte2] ^ bitmask2);
      crc1 = (((uint32_t )aux[bits / 8 - 3] << 16) | ((uint32_t )aux[bits / 8 - 2] << 8)) | (uint32_t )aux[bits / 8 - 1];
      crc2 = modesChecksum(aux, bits);
      if (crc1 == crc2) {
        memcpy((void * __restrict  )msg, (void const   * __restrict  )(aux), (size_t )(bits / 8));
        return (j | (i << 8));
      }
      i ++;
    }
    j ++;
  }
  return (-1);
}
}
uint32_t ICAOCacheHashAddress(uint32_t a ) 
{ 


  {
  a = ((a >> 16) ^ a) * 73244475U;
  a = ((a >> 16) ^ a) * 73244475U;
  a = (a >> 16) ^ a;
  return (a & 1023U);
}
}
void addRecentlySeenICAOAddr(uint32_t addr ) 
{ 
  uint32_t h ;
  uint32_t tmp ;
  time_t tmp___0 ;

  {
  tmp = ICAOCacheHashAddress(addr);
  h = tmp;
  *(Modes.icao_cache + h * 2U) = addr;
  tmp___0 = time((time_t *)((void *)0));
  *(Modes.icao_cache + (h * 2U + 1U)) = (uint32_t )tmp___0;
  return;
}
}
int ICAOAddressWasRecentlySeen(uint32_t addr ) 
{ 
  uint32_t h ;
  uint32_t tmp ;
  uint32_t a ;
  uint32_t t ;
  time_t tmp___0 ;
  int tmp___1 ;

  {
  tmp = ICAOCacheHashAddress(addr);
  h = tmp;
  a = *(Modes.icao_cache + h * 2U);
  t = *(Modes.icao_cache + (h * 2U + 1U));
  if (a) {
    if (a == addr) {
      tmp___0 = time((time_t *)((void *)0));
      if (tmp___0 - (time_t )t <= 60L) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
int bruteForceAP(unsigned char *msg , struct modesMessage *mm ) 
{ 
  unsigned char aux[14] ;
  int msgtype ;
  int msgbits ;
  uint32_t addr ;
  uint32_t crc ;
  int lastbyte ;
  int tmp ;

  {
  msgtype = mm->msgtype;
  msgbits = mm->msgbits;
  if (msgtype == 0) {
    goto _L;
  } else
  if (msgtype == 4) {
    goto _L;
  } else
  if (msgtype == 5) {
    goto _L;
  } else
  if (msgtype == 16) {
    goto _L;
  } else
  if (msgtype == 20) {
    goto _L;
  } else
  if (msgtype == 21) {
    goto _L;
  } else
  if (msgtype == 24) {
    _L: /* CIL Label */ 
    lastbyte = msgbits / 8 - 1;
    memcpy((void * __restrict  )(aux), (void const   * __restrict  )msg, (size_t )(msgbits / 8));
    crc = modesChecksum(aux, msgbits);
    aux[lastbyte] = (unsigned char )((unsigned int )aux[lastbyte] ^ (crc & 255U));
    aux[lastbyte - 1] = (unsigned char )((unsigned int )aux[lastbyte - 1] ^ ((crc >> 8) & 255U));
    aux[lastbyte - 2] = (unsigned char )((unsigned int )aux[lastbyte - 2] ^ ((crc >> 16) & 255U));
    addr = (uint32_t )(((int )aux[lastbyte] | ((int )aux[lastbyte - 1] << 8)) | ((int )aux[lastbyte - 2] << 16));
    tmp = ICAOAddressWasRecentlySeen(addr);
    if (tmp) {
      mm->aa1 = (int )aux[lastbyte - 2];
      mm->aa2 = (int )aux[lastbyte - 1];
      mm->aa3 = (int )aux[lastbyte];
      return (1);
    }
  }
  return (0);
}
}
int decodeAC13Field(unsigned char *msg , int *unit ) 
{ 
  int m_bit ;
  int q_bit ;
  int n ;

  {
  m_bit = (int )*(msg + 3) & (1 << 6);
  q_bit = (int )*(msg + 3) & (1 << 4);
  if (! m_bit) {
    *unit = 0;
    if (q_bit) {
      n = (((((int )*(msg + 2) & 31) << 6) | (((int )*(msg + 3) & 128) >> 2)) | (((int )*(msg + 3) & 32) >> 1)) | ((int )*(msg + 3) & 15);
      return (n * 25 - 1000);
    }
  } else {
    *unit = 1;
  }
  return (0);
}
}
int decodeAC12Field(unsigned char *msg , int *unit ) 
{ 
  int q_bit ;
  int n ;

  {
  q_bit = (int )*(msg + 5) & 1;
  if (q_bit) {
    *unit = 0;
    n = (((int )*(msg + 5) >> 1) << 4) | (((int )*(msg + 6) & 240) >> 4);
    return (n * 25 - 1000);
  } else {
    return (0);
  }
}
}
char *ca_str[8]  = 
  {      (char *)"Level 1 (Survillance Only)",      (char *)"Level 2 (DF0,4,5,11)",      (char *)"Level 3 (DF0,4,5,11,20,21)",      (char *)"Level 4 (DF0,4,5,11,20,21,24)", 
        (char *)"Level 2+3+4 (DF0,4,5,11,20,21,24,code7 - is on ground)",      (char *)"Level 2+3+4 (DF0,4,5,11,20,21,24,code7 - is on airborne)",      (char *)"Level 2+3+4 (DF0,4,5,11,20,21,24,code7)",      (char *)"Level 7 ???"};
char *fs_str[8]  = 
  {      (char *)"Normal, Airborne",      (char *)"Normal, On the ground",      (char *)"ALERT,  Airborne",      (char *)"ALERT,  On the ground", 
        (char *)"ALERT & Special Position Identification. Airborne or Ground",      (char *)"Special Position Identification. Airborne or Ground",      (char *)"Value 6 is not assigned",      (char *)"Value 7 is not assigned"};
char *me_str[0]  = { };
char *getMEDescription(int metype , int mesub ) 
{ 
  char *mename ;

  {
  mename = (char *)"Unknown";
  if (metype >= 1) {
    if (metype <= 4) {
      mename = (char *)"Aircraft Identification and Category";
    } else {
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
  if (metype >= 5) {
    if (metype <= 8) {
      mename = (char *)"Surface Position";
    } else {
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
  if (metype >= 9) {
    if (metype <= 18) {
      mename = (char *)"Airborne Position (Baro Altitude)";
    } else {
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
  if (metype == 19) {
    if (mesub >= 1) {
      if (mesub <= 4) {
        mename = (char *)"Airborne Velocity";
      } else {
        goto _L___6;
      }
    } else {
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
  if (metype >= 20) {
    if (metype <= 22) {
      mename = (char *)"Airborne Position (GNSS Height)";
    } else {
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
  if (metype == 23) {
    if (mesub == 0) {
      mename = (char *)"Test Message";
    } else {
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
  if (metype == 24) {
    if (mesub == 1) {
      mename = (char *)"Surface System Status";
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (metype == 28) {
    if (mesub == 1) {
      mename = (char *)"Extended Squitter Aircraft Status (Emergency)";
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (metype == 28) {
    if (mesub == 2) {
      mename = (char *)"Extended Squitter Aircraft Status (1090ES TCAS RA)";
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (metype == 29) {
    if (mesub == 0) {
      mename = (char *)"Target State and Status Message";
    } else
    if (mesub == 1) {
      mename = (char *)"Target State and Status Message";
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (metype == 31) {
    if (mesub == 0) {
      mename = (char *)"Aircraft Operational Status Message";
    } else
    if (mesub == 1) {
      mename = (char *)"Aircraft Operational Status Message";
    }
  }
  return (mename);
}
}
void decodeModesMessage(struct modesMessage *mm , unsigned char *msg ) 
{ 
  uint32_t crc2 ;
  char *ais_charset ;
  int tmp ;
  int tmp___0 ;
  int a ;
  int b ;
  int c ;
  int d ;
  int tmp___1 ;
  uint32_t addr ;
  double tmp___2 ;
  int ewv ;
  int nsv ;
  double heading ;

  {
  ais_charset = (char *)"?ABCDEFGHIJKLMNOPQRSTUVWXYZ????? ???????????????0123456789??????";
  memcpy((void * __restrict  )(mm->msg), (void const   * __restrict  )msg, (size_t )14);
  msg = mm->msg;
  mm->msgtype = (int )*(msg + 0) >> 3;
  mm->msgbits = modesMessageLenByType(mm->msgtype);
  mm->crc = (((uint32_t )*(msg + (mm->msgbits / 8 - 3)) << 16) | ((uint32_t )*(msg + (mm->msgbits / 8 - 2)) << 8)) | (uint32_t )*(msg + (mm->msgbits / 8 - 1));
  crc2 = modesChecksum(msg, mm->msgbits);
  mm->errorbit = -1;
  mm->crcok = mm->crc == crc2;
  if (! mm->crcok) {
    if (Modes.fix_errors) {
      if (mm->msgtype == 11) {
        goto _L;
      } else
      if (mm->msgtype == 17) {
        _L: /* CIL Label */ 
        tmp___0 = fixSingleBitErrors(msg, mm->msgbits);
        mm->errorbit = tmp___0;
        if (tmp___0 != -1) {
          mm->crc = modesChecksum(msg, mm->msgbits);
          mm->crcok = 1;
        } else
        if (Modes.aggressive) {
          if (mm->msgtype == 17) {
            tmp = fixTwoBitsErrors(msg, mm->msgbits);
            mm->errorbit = tmp;
            if (tmp != -1) {
              mm->crc = modesChecksum(msg, mm->msgbits);
              mm->crcok = 1;
            }
          }
        }
      }
    }
  }
  mm->ca = (int )*(msg + 0) & 7;
  mm->aa1 = (int )*(msg + 1);
  mm->aa2 = (int )*(msg + 2);
  mm->aa3 = (int )*(msg + 3);
  mm->metype = (int )*(msg + 4) >> 3;
  mm->mesub = (int )*(msg + 4) & 7;
  mm->fs = (int )*(msg + 0) & 7;
  mm->dr = ((int )*(msg + 1) >> 3) & 31;
  mm->um = (((int )*(msg + 1) & 7) << 3) | ((int )*(msg + 2) >> 5);
  a = ((((int )*(msg + 3) & 128) >> 5) | ((int )*(msg + 2) & 2)) | (((int )*(msg + 2) & 8) >> 3);
  b = ((((int )*(msg + 3) & 2) << 1) | (((int )*(msg + 3) & 8) >> 2)) | (((int )*(msg + 3) & 32) >> 5);
  c = ((((int )*(msg + 2) & 1) << 2) | (((int )*(msg + 2) & 4) >> 1)) | (((int )*(msg + 2) & 16) >> 4);
  d = ((((int )*(msg + 3) & 1) << 2) | (((int )*(msg + 3) & 4) >> 1)) | (((int )*(msg + 3) & 16) >> 4);
  mm->identity = ((a * 1000 + b * 100) + c * 10) + d;
  if (mm->msgtype != 11) {
    if (mm->msgtype != 17) {
      tmp___1 = bruteForceAP(msg, mm);
      if (tmp___1) {
        mm->crcok = 1;
      } else {
        mm->crcok = 0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (mm->crcok) {
    if (mm->errorbit == -1) {
      addr = (uint32_t )(((mm->aa1 << 16) | (mm->aa2 << 8)) | mm->aa3);
      addRecentlySeenICAOAddr(addr);
    }
  }
  if (mm->msgtype == 0) {
    mm->altitude = decodeAC13Field(msg, & mm->unit);
  } else
  if (mm->msgtype == 4) {
    mm->altitude = decodeAC13Field(msg, & mm->unit);
  } else
  if (mm->msgtype == 16) {
    mm->altitude = decodeAC13Field(msg, & mm->unit);
  } else
  if (mm->msgtype == 20) {
    mm->altitude = decodeAC13Field(msg, & mm->unit);
  }
  if (mm->msgtype == 17) {
    if (mm->metype >= 1) {
      if (mm->metype <= 4) {
        mm->aircraft_type = mm->metype - 1;
        mm->flight[0] = *(ais_charset + ((int )*(msg + 5) >> 2));
        mm->flight[1] = *(ais_charset + ((((int )*(msg + 5) & 3) << 4) | ((int )*(msg + 6) >> 4)));
        mm->flight[2] = *(ais_charset + ((((int )*(msg + 6) & 15) << 2) | ((int )*(msg + 7) >> 6)));
        mm->flight[3] = *(ais_charset + ((int )*(msg + 7) & 63));
        mm->flight[4] = *(ais_charset + ((int )*(msg + 8) >> 2));
        mm->flight[5] = *(ais_charset + ((((int )*(msg + 8) & 3) << 4) | ((int )*(msg + 9) >> 4)));
        mm->flight[6] = *(ais_charset + ((((int )*(msg + 9) & 15) << 2) | ((int )*(msg + 10) >> 6)));
        mm->flight[7] = *(ais_charset + ((int )*(msg + 10) & 63));
        mm->flight[8] = (char )'\000';
      } else {
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
    if (mm->metype >= 9) {
      if (mm->metype <= 18) {
        mm->fflag = (int )*(msg + 6) & (1 << 2);
        mm->tflag = (int )*(msg + 6) & (1 << 3);
        mm->altitude = decodeAC12Field(msg, & mm->unit);
        mm->raw_latitude = ((((int )*(msg + 6) & 3) << 15) | ((int )*(msg + 7) << 7)) | ((int )*(msg + 8) >> 1);
        mm->raw_longitude = ((((int )*(msg + 8) & 1) << 16) | ((int )*(msg + 9) << 8)) | (int )*(msg + 10);
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    if (mm->metype == 19) {
      if (mm->mesub >= 1) {
        if (mm->mesub <= 4) {
          if (mm->mesub == 1) {
            goto _L___1;
          } else
          if (mm->mesub == 2) {
            _L___1: /* CIL Label */ 
            mm->ew_dir = ((int )*(msg + 5) & 4) >> 2;
            mm->ew_velocity = (((int )*(msg + 5) & 3) << 8) | (int )*(msg + 6);
            mm->ns_dir = ((int )*(msg + 7) & 128) >> 7;
            mm->ns_velocity = (((int )*(msg + 7) & 127) << 3) | (((int )*(msg + 8) & 224) >> 5);
            mm->vert_rate_source = ((int )*(msg + 8) & 16) >> 4;
            mm->vert_rate_sign = ((int )*(msg + 8) & 8) >> 3;
            mm->vert_rate = (((int )*(msg + 8) & 7) << 6) | (((int )*(msg + 9) & 252) >> 2);
            tmp___2 = sqrt((double )(mm->ns_velocity * mm->ns_velocity + mm->ew_velocity * mm->ew_velocity));
            mm->velocity = (int )tmp___2;
            if (mm->velocity) {
              ewv = mm->ew_velocity;
              nsv = mm->ns_velocity;
              if (mm->ew_dir) {
                ewv *= -1;
              }
              if (mm->ns_dir) {
                nsv *= -1;
              }
              heading = atan2((double )ewv, (double )nsv);
              mm->heading = (int )((heading * (double )360) / (3.14159265358979323846 * (double )2));
              if (mm->heading < 0) {
                mm->heading += 360;
              }
            } else {
              mm->heading = 0;
            }
          } else
          if (mm->mesub == 3) {
            mm->heading_is_valid = (int )*(msg + 5) & (1 << 2);
            mm->heading = (int )((360.0 / (double )128) * (double )((((int )*(msg + 5) & 3) << 5) | ((int )*(msg + 6) >> 3)));
          } else
          if (mm->mesub == 4) {
            mm->heading_is_valid = (int )*(msg + 5) & (1 << 2);
            mm->heading = (int )((360.0 / (double )128) * (double )((((int )*(msg + 5) & 3) << 5) | ((int )*(msg + 6) >> 3)));
          }
        }
      }
    }
  }
  mm->phase_corrected = 0;
  return;
}
}
void displayModesMessage(struct modesMessage *mm ) 
{ 
  int j ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *ac_type_str[4] ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
  if (Modes.onlyaddr) {
    printf((char const   * __restrict  )"%02x%02x%02x\n", mm->aa1, mm->aa2, mm->aa3);
    return;
  }
  printf((char const   * __restrict  )"*");
  j = 0;
  while (j < mm->msgbits / 8) {
    printf((char const   * __restrict  )"%02x", (int )mm->msg[j]);
    j ++;
  }
  printf((char const   * __restrict  )";\n");
  if (Modes.raw) {
    fflush(stdout);
    return;
  }
  if (mm->crcok) {
    tmp = "ok";
  } else {
    tmp = "wrong";
  }
  printf((char const   * __restrict  )"CRC: %06x (%s)\n", (int )mm->crc, tmp);
  if (mm->errorbit != -1) {
    printf((char const   * __restrict  )"Single bit error fixed, bit %d\n", mm->errorbit);
  }
  if (mm->msgtype == 0) {
    printf((char const   * __restrict  )"DF 0: Short Air-Air Surveillance.\n");
    if (mm->unit == 1) {
      tmp___0 = "meters";
    } else {
      tmp___0 = "feet";
    }
    printf((char const   * __restrict  )"  Altitude       : %d %s\n", mm->altitude,
           tmp___0);
    printf((char const   * __restrict  )"  ICAO Address   : %02x%02x%02x\n", mm->aa1,
           mm->aa2, mm->aa3);
  } else
  if (mm->msgtype == 4) {
    goto _L___3;
  } else
  if (mm->msgtype == 20) {
    _L___3: /* CIL Label */ 
    if (mm->msgtype == 4) {
      tmp___1 = "Surveillance";
    } else {
      tmp___1 = "Comm-B";
    }
    printf((char const   * __restrict  )"DF %d: %s, Altitude Reply.\n", mm->msgtype,
           tmp___1);
    printf((char const   * __restrict  )"  Flight Status  : %s\n", fs_str[mm->fs]);
    printf((char const   * __restrict  )"  DR             : %d\n", mm->dr);
    printf((char const   * __restrict  )"  UM             : %d\n", mm->um);
    if (mm->unit == 1) {
      tmp___2 = "meters";
    } else {
      tmp___2 = "feet";
    }
    printf((char const   * __restrict  )"  Altitude       : %d %s\n", mm->altitude,
           tmp___2);
    printf((char const   * __restrict  )"  ICAO Address   : %02x%02x%02x\n", mm->aa1,
           mm->aa2, mm->aa3);
  } else
  if (mm->msgtype == 5) {
    goto _L___2;
  } else
  if (mm->msgtype == 21) {
    _L___2: /* CIL Label */ 
    if (mm->msgtype == 5) {
      tmp___3 = "Surveillance";
    } else {
      tmp___3 = "Comm-B";
    }
    printf((char const   * __restrict  )"DF %d: %s, Identity Reply.\n", mm->msgtype,
           tmp___3);
    printf((char const   * __restrict  )"  Flight Status  : %s\n", fs_str[mm->fs]);
    printf((char const   * __restrict  )"  DR             : %d\n", mm->dr);
    printf((char const   * __restrict  )"  UM             : %d\n", mm->um);
    printf((char const   * __restrict  )"  Squawk         : %d\n", mm->identity);
    printf((char const   * __restrict  )"  ICAO Address   : %02x%02x%02x\n", mm->aa1,
           mm->aa2, mm->aa3);
  } else
  if (mm->msgtype == 11) {
    printf((char const   * __restrict  )"DF 11: All Call Reply.\n");
    printf((char const   * __restrict  )"  Capability  : %s\n", ca_str[mm->ca]);
    printf((char const   * __restrict  )"  ICAO Address: %02x%02x%02x\n", mm->aa1,
           mm->aa2, mm->aa3);
  } else
  if (mm->msgtype == 17) {
    printf((char const   * __restrict  )"DF 17: ADS-B message.\n");
    printf((char const   * __restrict  )"  Capability     : %d (%s)\n", mm->ca, ca_str[mm->ca]);
    printf((char const   * __restrict  )"  ICAO Address   : %02x%02x%02x\n", mm->aa1,
           mm->aa2, mm->aa3);
    printf((char const   * __restrict  )"  Extended Squitter  Type: %d\n", mm->metype);
    printf((char const   * __restrict  )"  Extended Squitter  Sub : %d\n", mm->mesub);
    tmp___4 = getMEDescription(mm->metype, mm->mesub);
    printf((char const   * __restrict  )"  Extended Squitter  Name: %s\n", tmp___4);
    if (mm->metype >= 1) {
      if (mm->metype <= 4) {
        ac_type_str[0] = (char *)"Aircraft Type D";
        ac_type_str[1] = (char *)"Aircraft Type C";
        ac_type_str[2] = (char *)"Aircraft Type B";
        ac_type_str[3] = (char *)"Aircraft Type A";
        printf((char const   * __restrict  )"    Aircraft Type  : %s\n", ac_type_str[mm->aircraft_type]);
        printf((char const   * __restrict  )"    Identification : %s\n", mm->flight);
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if (mm->metype >= 9) {
      if (mm->metype <= 18) {
        if (mm->fflag) {
          tmp___5 = "odd";
        } else {
          tmp___5 = "even";
        }
        printf((char const   * __restrict  )"    F flag   : %s\n", tmp___5);
        if (mm->tflag) {
          tmp___6 = "UTC";
        } else {
          tmp___6 = "non-UTC";
        }
        printf((char const   * __restrict  )"    T flag   : %s\n", tmp___6);
        printf((char const   * __restrict  )"    Altitude : %d feet\n", mm->altitude);
        printf((char const   * __restrict  )"    Latitude : %d (not decoded)\n", mm->raw_latitude);
        printf((char const   * __restrict  )"    Longitude: %d (not decoded)\n", mm->raw_longitude);
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (mm->metype == 19) {
      if (mm->mesub >= 1) {
        if (mm->mesub <= 4) {
          if (mm->mesub == 1) {
            goto _L;
          } else
          if (mm->mesub == 2) {
            _L: /* CIL Label */ 
            printf((char const   * __restrict  )"    EW direction      : %d\n", mm->ew_dir);
            printf((char const   * __restrict  )"    EW velocity       : %d\n", mm->ew_velocity);
            printf((char const   * __restrict  )"    NS direction      : %d\n", mm->ns_dir);
            printf((char const   * __restrict  )"    NS velocity       : %d\n", mm->ns_velocity);
            printf((char const   * __restrict  )"    Vertical rate src : %d\n", mm->vert_rate_source);
            printf((char const   * __restrict  )"    Vertical rate sign: %d\n", mm->vert_rate_sign);
            printf((char const   * __restrict  )"    Vertical rate     : %d\n", mm->vert_rate);
          } else
          if (mm->mesub == 3) {
            printf((char const   * __restrict  )"    Heading status: %d", mm->heading_is_valid);
            printf((char const   * __restrict  )"    Heading: %d", mm->heading);
          } else
          if (mm->mesub == 4) {
            printf((char const   * __restrict  )"    Heading status: %d", mm->heading_is_valid);
            printf((char const   * __restrict  )"    Heading: %d", mm->heading);
          }
        } else {
          printf((char const   * __restrict  )"    Unrecognized ME type: %d subtype: %d\n",
                 mm->metype, mm->mesub);
        }
      } else {
        printf((char const   * __restrict  )"    Unrecognized ME type: %d subtype: %d\n",
               mm->metype, mm->mesub);
      }
    } else {
      printf((char const   * __restrict  )"    Unrecognized ME type: %d subtype: %d\n",
             mm->metype, mm->mesub);
    }
  } else
  if (Modes.check_crc) {
    printf((char const   * __restrict  )"DF %d with good CRC received (decoding still not implemented).\n",
           mm->msgtype);
  }
  return;
}
}
void computeMagnitudeVector(void) 
{ 
  uint16_t *m ;
  unsigned char *p ;
  uint32_t j ;
  int i ;
  int q ;

  {
  m = Modes.magnitude;
  p = Modes.data;
  j = (uint32_t )0;
  while (j < Modes.data_len) {
    i = (int )*(p + j) - 127;
    q = (int )*(p + (j + 1U)) - 127;
    if (i < 0) {
      i = - i;
    }
    if (q < 0) {
      q = - q;
    }
    *(m + j / 2U) = *(Modes.maglut + (i * 129 + q));
    j += 2U;
  }
  return;
}
}
int detectOutOfPhase(uint16_t *m ) 
{ 


  {
  if ((int )*(m + 3) > (int )*(m + 2) / 3) {
    return (1);
  }
  if ((int )*(m + 10) > (int )*(m + 9) / 3) {
    return (1);
  }
  if ((int )*(m + 6) > (int )*(m + 7) / 3) {
    return (-1);
  }
  if ((int )*(m + -1) > (int )*(m + 1) / 3) {
    return (-1);
  }
  return (0);
}
}
void applyPhaseCorrection(uint16_t *m ) 
{ 
  int j ;

  {
  m += 16;
  j = 0;
  while (j < 222) {
    if ((int )*(m + j) > (int )*(m + (j + 1))) {
      *(m + (j + 2)) = (uint16_t )(((int )*(m + (j + 2)) * 5) / 4);
    } else {
      *(m + (j + 2)) = (uint16_t )(((int )*(m + (j + 2)) * 4) / 5);
    }
    j += 2;
  }
  return;
}
}
void detectModeS(uint16_t *m , uint32_t mlen ) 
{ 
  unsigned char bits[112] ;
  unsigned char msg[56] ;
  uint16_t aux[224] ;
  uint32_t j ;
  int use_correction ;
  int low ;
  int high ;
  int delta ;
  int i ;
  int errors ;
  int good_message ;
  int tmp ;
  int msgtype ;
  int msglen ;
  int tmp___0 ;
  int tmp___1 ;
  struct modesMessage mm ;

  {
  use_correction = 0;
  j = (uint32_t )0;
  while (j < mlen - 240U) {
    good_message = 0;
    if (use_correction) {
      goto good_preamble;
    }
    if ((int )*(m + j) > (int )*(m + (j + 1U))) {
      if ((int )*(m + (j + 1U)) < (int )*(m + (j + 2U))) {
        if ((int )*(m + (j + 2U)) > (int )*(m + (j + 3U))) {
          if ((int )*(m + (j + 3U)) < (int )*(m + j)) {
            if ((int )*(m + (j + 4U)) < (int )*(m + j)) {
              if ((int )*(m + (j + 5U)) < (int )*(m + j)) {
                if ((int )*(m + (j + 6U)) < (int )*(m + j)) {
                  if ((int )*(m + (j + 7U)) > (int )*(m + (j + 8U))) {
                    if ((int )*(m + (j + 8U)) < (int )*(m + (j + 9U))) {
                      if (! ((int )*(m + (j + 9U)) > (int )*(m + (j + 6U)))) {
                        goto _L___7;
                      }
                    } else {
                      goto _L___7;
                    }
                  } else {
                    goto _L___7;
                  }
                } else {
                  goto _L___7;
                }
              } else {
                goto _L___7;
              }
            } else {
              goto _L___7;
            }
          } else {
            goto _L___7;
          }
        } else {
          goto _L___7;
        }
      } else {
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ 
      if (Modes.debug & (1 << 4)) {
        if ((int )*(m + j) > 25) {
          dumpRawMessage((char *)"Unexpected ratio among first 10 samples", msg, m,
                         j);
        }
      }
      goto __Cont;
    }
    high = ((((int )*(m + j) + (int )*(m + (j + 2U))) + (int )*(m + (j + 7U))) + (int )*(m + (j + 9U))) / 6;
    if ((int )*(m + (j + 4U)) >= high) {
      goto _L___8;
    } else
    if ((int )*(m + (j + 5U)) >= high) {
      _L___8: /* CIL Label */ 
      if (Modes.debug & (1 << 4)) {
        if ((int )*(m + j) > 25) {
          dumpRawMessage((char *)"Too high level in samples between 3 and 6", msg,
                         m, j);
        }
      }
      goto __Cont;
    }
    if ((int )*(m + (j + 11U)) >= high) {
      goto _L___9;
    } else
    if ((int )*(m + (j + 12U)) >= high) {
      goto _L___9;
    } else
    if ((int )*(m + (j + 13U)) >= high) {
      goto _L___9;
    } else
    if ((int )*(m + (j + 14U)) >= high) {
      _L___9: /* CIL Label */ 
      if (Modes.debug & (1 << 4)) {
        if ((int )*(m + j) > 25) {
          dumpRawMessage((char *)"Too high level in samples between 10 and 15", msg,
                         m, j);
        }
      }
      goto __Cont;
    }
    (Modes.stat_valid_preamble) ++;
    good_preamble: 
    if (use_correction) {
      memcpy((void * __restrict  )(aux), (void const   * __restrict  )((m + j) + 16),
             sizeof(aux));
      if (j) {
        tmp = detectOutOfPhase(m + j);
        if (tmp) {
          applyPhaseCorrection(m + j);
          (Modes.stat_out_of_phase) ++;
        }
      }
    }
    errors = 0;
    i = 0;
    while (i < 224) {
      low = (int )*(m + ((j + (uint32_t )i) + 16U));
      high = (int )*(m + (((j + (uint32_t )i) + 16U) + 1U));
      delta = low - high;
      if (delta < 0) {
        delta = - delta;
      }
      if (i > 0) {
        if (delta < 256) {
          bits[i / 2] = bits[i / 2 - 1];
        } else {
          goto _L___10;
        }
      } else
      _L___10: /* CIL Label */ 
      if (low == high) {
        bits[i / 2] = (unsigned char)2;
        if (i < 112) {
          errors ++;
        }
      } else
      if (low > high) {
        bits[i / 2] = (unsigned char)1;
      } else {
        bits[i / 2] = (unsigned char)0;
      }
      i += 2;
    }
    if (use_correction) {
      memcpy((void * __restrict  )((m + j) + 16), (void const   * __restrict  )(aux),
             sizeof(aux));
    }
    i = 0;
    while (i < 112) {
      msg[i / 8] = (unsigned char )(((((((((int )bits[i] << 7) | ((int )bits[i + 1] << 6)) | ((int )bits[i + 2] << 5)) | ((int )bits[i + 3] << 4)) | ((int )bits[i + 4] << 3)) | ((int )bits[i + 5] << 2)) | ((int )bits[i + 6] << 1)) | (int )bits[i + 7]);
      i += 8;
    }
    msgtype = (int )msg[0] >> 3;
    tmp___0 = modesMessageLenByType(msgtype);
    msglen = tmp___0 / 8;
    delta = 0;
    i = 0;
    while (i < (msglen * 8) * 2) {
      tmp___1 = abs((int )*(m + ((j + (uint32_t )i) + 16U)) - (int )*(m + (((j + (uint32_t )i) + 16U) + 1U)));
      delta += tmp___1;
      i += 2;
    }
    delta /= msglen * 4;
    if (delta < 2550) {
      use_correction = 0;
      goto __Cont;
    }
    if (errors == 0) {
      goto _L___14;
    } else
    if (Modes.aggressive) {
      if (errors < 3) {
        _L___14: /* CIL Label */ 
        decodeModesMessage(& mm, msg);
        if (mm.crcok) {
          goto _L___11;
        } else
        if (use_correction) {
          _L___11: /* CIL Label */ 
          if (errors == 0) {
            (Modes.stat_demodulated) ++;
          }
          if (mm.errorbit == -1) {
            if (mm.crcok) {
              (Modes.stat_goodcrc) ++;
            } else {
              (Modes.stat_badcrc) ++;
            }
          } else {
            (Modes.stat_badcrc) ++;
            (Modes.stat_fixed) ++;
            if (mm.errorbit < 112) {
              (Modes.stat_single_bit_fix) ++;
            } else {
              (Modes.stat_two_bits_fix) ++;
            }
          }
        }
        if (use_correction == 0) {
          if (Modes.debug & 1) {
            dumpRawMessage((char *)"Demodulated with 0 errors", msg, m, j);
          } else
          if (Modes.debug & (1 << 2)) {
            if (mm.msgtype == 17) {
              if (! mm.crcok) {
                dumpRawMessage((char *)"Decoded with bad CRC", msg, m, j);
              } else
              if (mm.errorbit != -1) {
                dumpRawMessage((char *)"Decoded with bad CRC", msg, m, j);
              } else {
                goto _L___13;
              }
            } else {
              goto _L___13;
            }
          } else
          _L___13: /* CIL Label */ 
          if (Modes.debug & (1 << 3)) {
            if (mm.crcok) {
              if (mm.errorbit == -1) {
                dumpRawMessage((char *)"Decoded with good CRC", msg, m, j);
              }
            }
          }
        }
        if (mm.crcok) {
          j += (uint32_t )((8 + msglen * 8) * 2);
          good_message = 1;
          if (use_correction) {
            mm.phase_corrected = 1;
          }
        }
        useModesMessage(& mm);
      } else {
        goto _L___15;
      }
    } else
    _L___15: /* CIL Label */ 
    if (Modes.debug & (1 << 1)) {
      if (use_correction) {
        printf((char const   * __restrict  )"The following message has %d demod errors\n",
               errors);
        dumpRawMessage((char *)"Demodulated with errors", msg, m, j);
      }
    }
    if (! good_message) {
      if (! use_correction) {
        j --;
        use_correction = 1;
      } else {
        use_correction = 0;
      }
    } else {
      use_correction = 0;
    }
    __Cont: /* CIL Label */ 
    j ++;
  }
  return;
}
}
void useModesMessage(struct modesMessage *mm ) 
{ 
  struct aircraft *a ;
  struct aircraft *tmp ;

  {
  if (! Modes.stats) {
    if (Modes.check_crc == 0) {
      goto _L___0;
    } else
    if (mm->crcok) {
      _L___0: /* CIL Label */ 
      if (Modes.interactive) {
        goto _L;
      } else
      if (Modes.stat_http_requests > 0LL) {
        goto _L;
      } else
      if (Modes.stat_sbs_connections > 0LL) {
        _L: /* CIL Label */ 
        tmp = interactiveReceiveData(mm);
        a = tmp;
        if (a) {
          if (Modes.stat_sbs_connections > 0LL) {
            modesSendSBSOutput(mm, a);
          }
        }
      }
      if (! Modes.interactive) {
        displayModesMessage(mm);
        if (! Modes.raw) {
          if (! Modes.onlyaddr) {
            printf((char const   * __restrict  )"\n");
          }
        }
      }
      if (Modes.net) {
        modesSendRawOutput(mm);
      }
    }
  }
  return;
}
}
struct aircraft *interactiveCreateAircraft(uint32_t addr ) 
{ 
  struct aircraft *a ;
  void *tmp ;

  {
  tmp = malloc(sizeof(*a));
  a = (struct aircraft *)tmp;
  a->addr = addr;
  snprintf((char * __restrict  )(a->hexaddr), sizeof(a->hexaddr), (char const   * __restrict  )"%06x",
           (int )addr);
  a->flight[0] = (char )'\000';
  a->altitude = 0;
  a->speed = 0;
  a->track = 0;
  a->odd_cprlat = 0;
  a->odd_cprlon = 0;
  a->odd_cprtime = 0LL;
  a->even_cprlat = 0;
  a->even_cprlon = 0;
  a->even_cprtime = 0LL;
  a->lat = (double )0;
  a->lon = (double )0;
  a->seen = time((time_t *)((void *)0));
  a->messages = 0L;
  a->next = (struct aircraft *)((void *)0);
  return (a);
}
}
struct aircraft *interactiveFindAircraft(uint32_t addr ) 
{ 
  struct aircraft *a ;

  {
  a = Modes.aircrafts;
  while (a) {
    if (a->addr == addr) {
      return (a);
    }
    a = a->next;
  }
  return ((struct aircraft *)((void *)0));
}
}
int cprModFunction(int a , int b ) 
{ 
  int res ;

  {
  res = a % b;
  if (res < 0) {
    res += b;
  }
  return (res);
}
}
int cprNLFunction(double lat ) 
{ 


  {
  if (lat < (double )0) {
    lat = - lat;
  }
  if (lat < 10.47047130) {
    return (59);
  }
  if (lat < 14.82817437) {
    return (58);
  }
  if (lat < 18.18626357) {
    return (57);
  }
  if (lat < 21.02939493) {
    return (56);
  }
  if (lat < 23.54504487) {
    return (55);
  }
  if (lat < 25.82924707) {
    return (54);
  }
  if (lat < 27.93898710) {
    return (53);
  }
  if (lat < 29.91135686) {
    return (52);
  }
  if (lat < 31.77209708) {
    return (51);
  }
  if (lat < 33.53993436) {
    return (50);
  }
  if (lat < 35.22899598) {
    return (49);
  }
  if (lat < 36.85025108) {
    return (48);
  }
  if (lat < 38.41241892) {
    return (47);
  }
  if (lat < 39.92256684) {
    return (46);
  }
  if (lat < 41.38651832) {
    return (45);
  }
  if (lat < 42.80914012) {
    return (44);
  }
  if (lat < 44.19454951) {
    return (43);
  }
  if (lat < 45.54626723) {
    return (42);
  }
  if (lat < 46.86733252) {
    return (41);
  }
  if (lat < 48.16039128) {
    return (40);
  }
  if (lat < 49.42776439) {
    return (39);
  }
  if (lat < 50.67150166) {
    return (38);
  }
  if (lat < 51.89342469) {
    return (37);
  }
  if (lat < 53.09516153) {
    return (36);
  }
  if (lat < 54.27817472) {
    return (35);
  }
  if (lat < 55.44378444) {
    return (34);
  }
  if (lat < 56.59318756) {
    return (33);
  }
  if (lat < 57.72747354) {
    return (32);
  }
  if (lat < 58.84763776) {
    return (31);
  }
  if (lat < 59.95459277) {
    return (30);
  }
  if (lat < 61.04917774) {
    return (29);
  }
  if (lat < 62.13216659) {
    return (28);
  }
  if (lat < 63.20427479) {
    return (27);
  }
  if (lat < 64.26616523) {
    return (26);
  }
  if (lat < 65.31845310) {
    return (25);
  }
  if (lat < 66.36171008) {
    return (24);
  }
  if (lat < 67.39646774) {
    return (23);
  }
  if (lat < 68.42322022) {
    return (22);
  }
  if (lat < 69.44242631) {
    return (21);
  }
  if (lat < 70.45451075) {
    return (20);
  }
  if (lat < 71.45986473) {
    return (19);
  }
  if (lat < 72.45884545) {
    return (18);
  }
  if (lat < 73.45177442) {
    return (17);
  }
  if (lat < 74.43893416) {
    return (16);
  }
  if (lat < 75.42056257) {
    return (15);
  }
  if (lat < 76.39684391) {
    return (14);
  }
  if (lat < 77.36789461) {
    return (13);
  }
  if (lat < 78.33374083) {
    return (12);
  }
  if (lat < 79.29428225) {
    return (11);
  }
  if (lat < 80.24923213) {
    return (10);
  }
  if (lat < 81.19801349) {
    return (9);
  }
  if (lat < 82.13956981) {
    return (8);
  }
  if (lat < 83.07199445) {
    return (7);
  }
  if (lat < 83.99173563) {
    return (6);
  }
  if (lat < 84.89166191) {
    return (5);
  }
  if (lat < 85.75541621) {
    return (4);
  }
  if (lat < 86.53536998) {
    return (3);
  }
  if (lat < 87.00000000) {
    return (2);
  } else {
    return (1);
  }
}
}
int cprNFunction(double lat , int isodd ) 
{ 
  int nl ;
  int tmp ;

  {
  tmp = cprNLFunction(lat);
  nl = tmp - isodd;
  if (nl < 1) {
    nl = 1;
  }
  return (nl);
}
}
double cprDlonFunction(double lat , int isodd ) 
{ 
  int tmp ;

  {
  tmp = cprNFunction(lat, isodd);
  return (360.0 / (double )tmp);
}
}
void decodeCPR(struct aircraft *a ) 
{ 
  double AirDlat0 ;
  double AirDlat1 ;
  double lat0 ;
  double lat1 ;
  double lon0 ;
  double lon1 ;
  int j ;
  double tmp ;
  double rlat0 ;
  int tmp___0 ;
  double rlat1 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int ni ;
  int tmp___4 ;
  int m ;
  int tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  int tmp___9 ;
  int ni___0 ;
  int tmp___10 ;
  int m___0 ;
  int tmp___11 ;
  int tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  int tmp___15 ;

  {
  AirDlat0 = 360.0 / (double )60;
  AirDlat1 = 360.0 / (double )59;
  lat0 = (double )a->even_cprlat;
  lat1 = (double )a->odd_cprlat;
  lon0 = (double )a->even_cprlon;
  lon1 = (double )a->odd_cprlon;
  tmp = floor(((double )59 * lat0 - (double )60 * lat1) / (double )131072 + 0.5);
  j = (int )tmp;
  tmp___0 = cprModFunction(j, 60);
  rlat0 = AirDlat0 * ((double )tmp___0 + lat0 / (double )131072);
  tmp___1 = cprModFunction(j, 59);
  rlat1 = AirDlat1 * ((double )tmp___1 + lat1 / (double )131072);
  if (rlat0 >= (double )270) {
    rlat0 -= (double )360;
  }
  if (rlat1 >= (double )270) {
    rlat1 -= (double )360;
  }
  tmp___2 = cprNLFunction(rlat0);
  tmp___3 = cprNLFunction(rlat1);
  if (tmp___2 != tmp___3) {
    return;
  }
  if (a->even_cprtime > a->odd_cprtime) {
    tmp___4 = cprNFunction(rlat0, 0);
    ni = tmp___4;
    tmp___5 = cprNLFunction(rlat0);
    tmp___6 = cprNLFunction(rlat0);
    tmp___7 = floor((lon0 * (double )(tmp___5 - 1) - lon1 * (double )tmp___6) / (double )131072 + 0.5);
    m = (int )tmp___7;
    tmp___8 = cprDlonFunction(rlat0, 0);
    tmp___9 = cprModFunction(m, ni);
    a->lon = tmp___8 * ((double )tmp___9 + lon0 / (double )131072);
    a->lat = rlat0;
  } else {
    tmp___10 = cprNFunction(rlat1, 1);
    ni___0 = tmp___10;
    tmp___11 = cprNLFunction(rlat1);
    tmp___12 = cprNLFunction(rlat1);
    tmp___13 = floor((lon0 * (double )(tmp___11 - 1) - lon1 * (double )tmp___12) / 131072.0 + 0.5);
    m___0 = (int )tmp___13;
    tmp___14 = cprDlonFunction(rlat1, 1);
    tmp___15 = cprModFunction(m___0, ni___0);
    a->lon = tmp___14 * ((double )tmp___15 + lon1 / (double )131072);
    a->lat = rlat1;
  }
  if (a->lon > (double )180) {
    a->lon -= (double )360;
  }
  return;
}
}
struct aircraft *interactiveReceiveData(struct modesMessage *mm ) 
{ 
  uint32_t addr ;
  struct aircraft *a ;
  int tmp___0 ;

  {
  if (Modes.check_crc) {
    if (mm->crcok == 0) {
      return ((struct aircraft *)((void *)0));
    }
  }
  addr = (uint32_t )(((mm->aa1 << 16) | (mm->aa2 << 8)) | mm->aa3);
  a = interactiveFindAircraft(addr);
  if (! a) {
    a = interactiveCreateAircraft(addr);
    a->next = Modes.aircrafts;
    Modes.aircrafts = a;
  }
  a->seen = time((time_t *)((void *)0));
  (a->messages) ++;
  if (mm->msgtype == 0) {
    a->altitude = mm->altitude;
  } else
  if (mm->msgtype == 4) {
    a->altitude = mm->altitude;
  } else
  if (mm->msgtype == 20) {
    a->altitude = mm->altitude;
  } else
  if (mm->msgtype == 17) {
    if (mm->metype >= 1) {
      if (mm->metype <= 4) {
        memcpy((void * __restrict  )(a->flight), (void const   * __restrict  )(mm->flight),
               sizeof(a->flight));
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (mm->metype >= 9) {
      if (mm->metype <= 18) {
        a->altitude = mm->altitude;
        if (mm->fflag) {
          a->odd_cprlat = mm->raw_latitude;
          a->odd_cprlon = mm->raw_longitude;
          a->odd_cprtime = mstime();
        } else {
          a->even_cprlat = mm->raw_latitude;
          a->even_cprlon = mm->raw_longitude;
          a->even_cprtime = mstime();
        }
        tmp___0 = abs((int )(a->even_cprtime - a->odd_cprtime));
        if (tmp___0 <= 10000) {
          decodeCPR(a);
        }
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (mm->metype == 19) {
      if (mm->mesub == 1) {
        a->speed = mm->velocity;
        a->track = mm->heading;
      } else
      if (mm->mesub == 2) {
        a->speed = mm->velocity;
        a->track = mm->heading;
      }
    }
  }
  return (a);
}
}
void interactiveShowData(void) 
{ 
  struct aircraft *a ;
  time_t now ;
  time_t tmp ;
  char progress[4] ;
  int count ;
  time_t tmp___0 ;
  int altitude ;
  int speed ;

  {
  a = Modes.aircrafts;
  tmp = time((time_t *)((void *)0));
  now = tmp;
  count = 0;
  memset((void *)(progress), ' ', (size_t )3);
  tmp___0 = time((time_t *)((void *)0));
  progress[tmp___0 % 3L] = (char )'.';
  progress[3] = (char )'\000';
  printf((char const   * __restrict  )"\033[H\033[2J");
  printf((char const   * __restrict  )"Hex    Flight   Altitude  Speed   Lat       Lon       Track  Messages Seen %s\n--------------------------------------------------------------------------------\n",
         progress);
  while (1) {
    if (a) {
      if (! (count < Modes.interactive_rows)) {
        break;
      }
    } else {
      break;
    }
    altitude = a->altitude;
    speed = a->speed;
    if (Modes.metric) {
      altitude = (int )((double )altitude / 3.2828);
      speed = (int )((double )speed * 1.852);
    }
    printf((char const   * __restrict  )"%-6s %-8s %-9d %-7d %-7.03f   %-7.03f   %-3d   %-9ld %d sec\n",
           a->hexaddr, a->flight, altitude, speed, a->lat, a->lon, a->track, a->messages,
           (int )(now - a->seen));
    a = a->next;
    count ++;
  }
  return;
}
}
void interactiveRemoveStaleAircrafts(void) 
{ 
  struct aircraft *a ;
  struct aircraft *prev ;
  time_t now ;
  time_t tmp ;
  struct aircraft *next ;

  {
  a = Modes.aircrafts;
  prev = (struct aircraft *)((void *)0);
  tmp = time((time_t *)((void *)0));
  now = tmp;
  while (a) {
    if (now - a->seen > (time_t )Modes.interactive_ttl) {
      next = a->next;
      free((void *)a);
      if (! prev) {
        Modes.aircrafts = next;
      } else {
        prev->next = next;
      }
      a = next;
    } else {
      prev = a;
      a = a->next;
    }
  }
  return;
}
}
void snipMode(int level ) 
{ 
  int i ;
  int q ;
  long long c ;
  int tmp ;
  int tmp___0 ;

  {
  c = 0LL;
  while (1) {
    i = getchar();
    if (i != -1) {
      q = getchar();
      if (! (q != -1)) {
        break;
      }
    } else {
      break;
    }
    tmp = abs(i - 127);
    if (tmp < level) {
      tmp___0 = abs(q - 127);
      if (tmp___0 < level) {
        c ++;
        if (c > 32LL) {
          continue;
        }
      } else {
        c = 0LL;
      }
    } else {
      c = 0LL;
    }
    putchar(i);
    putchar(q);
  }
  return;
}
}
struct __anonstruct_modesNetServices_483049182 modesNetServices[4]  = {      {(char *)"Raw TCP output", & Modes.ros, 30002}, 
        {(char *)"Raw TCP input", & Modes.ris, 30001}, 
        {(char *)"HTTP server", & Modes.https, 8080}, 
        {(char *)"Basestation TCP output", & Modes.sbsos, 30003}};
void modesInitNet(void) 
{ 
  int j ;
  int s ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  memset((void *)(Modes.clients), 0, sizeof(Modes.clients));
  Modes.maxfd = -1;
  j = 0;
  while (j < 4) {
    tmp = anetTcpServer(Modes.aneterr, modesNetServices[j].port, (char *)((void *)0));
    s = tmp;
    if (s == -1) {
      tmp___0 = __errno_location();
      tmp___1 = strerror(*tmp___0);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error opening the listening port %d (%s): %s\n",
              modesNetServices[j].port, modesNetServices[j].descr, tmp___1);
      exit(1);
    }
    anetNonBlock(Modes.aneterr, s);
    *(modesNetServices[j].socket) = s;
    j ++;
  }
  signal(13, (void (*)(int  ))1);
  return;
}
}
void modesAcceptClients(void) 
{ 
  int fd ;
  int port ;
  unsigned int j ;
  struct client *c ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;

  {
  j = 0U;
  while (j < 4U) {
    fd = anetTcpAccept(Modes.aneterr, *(modesNetServices[j].socket), (char *)((void *)0),
                       & port);
    if (fd == -1) {
      if (Modes.debug & (1 << 5)) {
        tmp___1 = __errno_location();
        if (*tmp___1 != 11) {
          tmp = __errno_location();
          tmp___0 = strerror(*tmp);
          printf((char const   * __restrict  )"Accept %d: %s\n", *(modesNetServices[j].socket),
                 tmp___0);
        }
      }
      goto __Cont;
    }
    if (fd >= 1024) {
      close(fd);
      return;
    }
    anetNonBlock(Modes.aneterr, fd);
    tmp___2 = malloc(sizeof(*c));
    c = (struct client *)tmp___2;
    c->service = *(modesNetServices[j].socket);
    c->fd = fd;
    c->buflen = 0;
    Modes.clients[fd] = c;
    anetSetSendBuffer(Modes.aneterr, fd, 65536);
    if (Modes.maxfd < fd) {
      Modes.maxfd = fd;
    }
    if (*(modesNetServices[j].socket) == Modes.sbsos) {
      (Modes.stat_sbs_connections) ++;
    }
    j --;
    if (Modes.debug & (1 << 5)) {
      printf((char const   * __restrict  )"Created new client %d\n", fd);
    }
    __Cont: /* CIL Label */ 
    j ++;
  }
  return;
}
}
void modesFreeClient(int fd ) 
{ 
  int j ;

  {
  close(fd);
  free((void *)Modes.clients[fd]);
  Modes.clients[fd] = (struct client *)((void *)0);
  if (Modes.debug & (1 << 5)) {
    printf((char const   * __restrict  )"Closing client %d\n", fd);
  }
  if (Modes.maxfd == fd) {
    Modes.maxfd = -1;
    j = fd - 1;
    while (j >= 0) {
      if (Modes.clients[j]) {
        Modes.maxfd = j;
        break;
      }
      j --;
    }
  }
  return;
}
}
void modesSendAllClients(int service , void *msg , int len ) 
{ 
  int j ;
  struct client *c ;
  int nwritten ;
  ssize_t tmp ;

  {
  j = 0;
  while (j <= Modes.maxfd) {
    c = Modes.clients[j];
    if (c) {
      if (c->service == service) {
        tmp = write(j, (void const   *)msg, (size_t )len);
        nwritten = (int )tmp;
        if (nwritten != len) {
          modesFreeClient(j);
        }
      }
    }
    j ++;
  }
  return;
}
}
void modesSendRawOutput(struct modesMessage *mm ) 
{ 
  char msg[128] ;
  char *p ;
  int j ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  p = msg;
  tmp = p;
  p ++;
  *tmp = (char )'*';
  j = 0;
  while (j < mm->msgbits / 8) {
    sprintf((char * __restrict  )p, (char const   * __restrict  )"%02X", (int )mm->msg[j]);
    p += 2;
    j ++;
  }
  tmp___0 = p;
  p ++;
  *tmp___0 = (char )';';
  tmp___1 = p;
  p ++;
  *tmp___1 = (char )'\n';
  modesSendAllClients(Modes.ros, (void *)(msg), (int )(p - msg));
  return;
}
}
void modesSendSBSOutput(struct modesMessage *mm , struct aircraft *a ) 
{ 
  char msg[256] ;
  char *p ;
  int emergency ;
  int ground ;
  int alert ;
  int spi ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int vr ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
  p = msg;
  emergency = 0;
  ground = 0;
  alert = 0;
  spi = 0;
  if (mm->msgtype == 4) {
    goto _L;
  } else
  if (mm->msgtype == 5) {
    goto _L;
  } else
  if (mm->msgtype == 21) {
    _L: /* CIL Label */ 
    if (mm->identity == 7500) {
      emergency = -1;
    } else
    if (mm->identity == 7600) {
      emergency = -1;
    } else
    if (mm->identity == 7700) {
      emergency = -1;
    }
    if (mm->fs == 1) {
      ground = -1;
    } else
    if (mm->fs == 3) {
      ground = -1;
    }
    if (mm->fs == 2) {
      alert = -1;
    } else
    if (mm->fs == 3) {
      alert = -1;
    } else
    if (mm->fs == 4) {
      alert = -1;
    }
    if (mm->fs == 4) {
      spi = -1;
    } else
    if (mm->fs == 5) {
      spi = -1;
    }
  }
  if (mm->msgtype == 0) {
    tmp = sprintf((char * __restrict  )p, (char const   * __restrict  )"MSG,5,,,%02X%02X%02X,,,,,,,%d,,,,,,,,,,",
                  mm->aa1, mm->aa2, mm->aa3, mm->altitude);
    p += tmp;
  } else
  if (mm->msgtype == 4) {
    tmp___0 = sprintf((char * __restrict  )p, (char const   * __restrict  )"MSG,5,,,%02X%02X%02X,,,,,,,%d,,,,,,,%d,%d,%d,%d",
                      mm->aa1, mm->aa2, mm->aa3, mm->altitude, alert, emergency, spi,
                      ground);
    p += tmp___0;
  } else
  if (mm->msgtype == 5) {
    tmp___1 = sprintf((char * __restrict  )p, (char const   * __restrict  )"MSG,6,,,%02X%02X%02X,,,,,,,,,,,,,%d,%d,%d,%d,%d",
                      mm->aa1, mm->aa2, mm->aa3, mm->identity, alert, emergency, spi,
                      ground);
    p += tmp___1;
  } else
  if (mm->msgtype == 11) {
    tmp___2 = sprintf((char * __restrict  )p, (char const   * __restrict  )"MSG,8,,,%02X%02X%02X,,,,,,,,,,,,,,,,,",
                      mm->aa1, mm->aa2, mm->aa3);
    p += tmp___2;
  } else
  if (mm->msgtype == 17) {
    if (mm->metype == 4) {
      tmp___3 = sprintf((char * __restrict  )p, (char const   * __restrict  )"MSG,1,,,%02X%02X%02X,,,,,,%s,,,,,,,,0,0,0,0",
                        mm->aa1, mm->aa2, mm->aa3, mm->flight);
      p += tmp___3;
    } else {
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
  if (mm->msgtype == 17) {
    if (mm->metype >= 9) {
      if (mm->metype <= 18) {
        if (a->lat == (double )0) {
          if (a->lon == (double )0) {
            tmp___4 = sprintf((char * __restrict  )p, (char const   * __restrict  )"MSG,3,,,%02X%02X%02X,,,,,,,%d,,,,,,,0,0,0,0",
                              mm->aa1, mm->aa2, mm->aa3, mm->altitude);
            p += tmp___4;
          } else {
            tmp___5 = sprintf((char * __restrict  )p, (char const   * __restrict  )"MSG,3,,,%02X%02X%02X,,,,,,,%d,,,%1.5f,%1.5f,,,0,0,0,0",
                              mm->aa1, mm->aa2, mm->aa3, mm->altitude, a->lat, a->lon);
            p += tmp___5;
          }
        } else {
          tmp___5 = sprintf((char * __restrict  )p, (char const   * __restrict  )"MSG,3,,,%02X%02X%02X,,,,,,,%d,,,%1.5f,%1.5f,,,0,0,0,0",
                            mm->aa1, mm->aa2, mm->aa3, mm->altitude, a->lat, a->lon);
          p += tmp___5;
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
  if (mm->msgtype == 17) {
    if (mm->metype == 19) {
      if (mm->mesub == 1) {
        if (mm->vert_rate_sign == 0) {
          tmp___6 = 1;
        } else {
          tmp___6 = -1;
        }
        vr = (tmp___6 * (mm->vert_rate - 1)) * 64;
        tmp___7 = sprintf((char * __restrict  )p, (char const   * __restrict  )"MSG,4,,,%02X%02X%02X,,,,,,,,%d,%d,,,%i,,0,0,0,0",
                          mm->aa1, mm->aa2, mm->aa3, a->speed, a->track, vr);
        p += tmp___7;
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (mm->msgtype == 21) {
    tmp___8 = sprintf((char * __restrict  )p, (char const   * __restrict  )"MSG,6,,,%02X%02X%02X,,,,,,,,,,,,,%d,%d,%d,%d,%d",
                      mm->aa1, mm->aa2, mm->aa3, mm->identity, alert, emergency, spi,
                      ground);
    p += tmp___8;
  } else {
    return;
  }
  tmp___9 = p;
  p ++;
  *tmp___9 = (char )'\n';
  modesSendAllClients(Modes.sbsos, (void *)(msg), (int )(p - msg));
  return;
}
}
int hexDigitVal(int c ) 
{ 
  int __res ;
  __int32_t const   **tmp___0 ;

  {
  if (sizeof(c) > 1UL) {
    __res = tolower(c);
  } else {
    tmp___0 = __ctype_tolower_loc();
    __res = (int )*(*tmp___0 + c);
  }
  c = __res;
  if (c >= 48) {
    if (c <= 57) {
      return (c - 48);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (c >= 97) {
    if (c <= 102) {
      return ((c - 97) + 10);
    } else {
      return (-1);
    }
  } else {
    return (-1);
  }
}
}
int decodeHexMessage(struct client *c ) 
{ 
  char *hex ;
  int l ;
  size_t tmp ;
  int j ;
  unsigned char msg[14] ;
  struct modesMessage mm ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int high ;
  int tmp___2 ;
  int low ;
  int tmp___3 ;

  {
  hex = c->buf;
  tmp = strlen((char const   *)hex);
  l = (int )tmp;
  while (1) {
    if (l) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___0 + (int )*(hex + (l - 1))) & 8192)) {
        break;
      }
    } else {
      break;
    }
    *(hex + (l - 1)) = (char )'\000';
    l --;
  }
  while (1) {
    tmp___1 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___1 + (int )*hex) & 8192)) {
      break;
    }
    hex ++;
    l --;
  }
  if (l < 2) {
    return (0);
  } else
  if ((int )*(hex + 0) != 42) {
    return (0);
  } else
  if ((int )*(hex + (l - 1)) != 59) {
    return (0);
  }
  hex ++;
  l -= 2;
  if (l > 28) {
    return (0);
  }
  j = 0;
  while (j < l) {
    tmp___2 = hexDigitVal((int )*(hex + j));
    high = tmp___2;
    tmp___3 = hexDigitVal((int )*(hex + (j + 1)));
    low = tmp___3;
    if (high == -1) {
      return (0);
    } else
    if (low == -1) {
      return (0);
    }
    msg[j / 2] = (unsigned char )((high << 4) | low);
    j += 2;
  }
  decodeModesMessage(& mm, msg);
  useModesMessage(& mm);
  return (0);
}
}
char *aircraftsToJson(int *len ) 
{ 
  struct aircraft *a ;
  int buflen ;
  char *buf ;
  void *tmp ;
  char *p ;
  int l ;
  int altitude ;
  int speed ;
  int used ;
  void *tmp___0 ;

  {
  a = Modes.aircrafts;
  buflen = 1024;
  tmp = malloc((size_t )buflen);
  buf = (char *)tmp;
  p = buf;
  l = snprintf((char * __restrict  )p, (size_t )buflen, (char const   * __restrict  )"[\n");
  p += l;
  buflen -= l;
  while (a) {
    altitude = a->altitude;
    speed = a->speed;
    if (Modes.metric) {
      altitude = (int )((double )altitude / 3.2828);
      speed = (int )((double )speed * 1.852);
    }
    if (a->lat != (double )0) {
      if (a->lon != (double )0) {
        l = snprintf((char * __restrict  )p, (size_t )buflen, (char const   * __restrict  )"{\"hex\":\"%s\", \"flight\":\"%s\", \"lat\":%f, \"lon\":%f, \"altitude\":%d, \"track\":%d, \"speed\":%d},\n",
                     a->hexaddr, a->flight, a->lat, a->lon, a->altitude, a->track,
                     a->speed);
        p += l;
        buflen -= l;
        if (buflen < 256) {
          used = (int )(p - buf);
          buflen += 1024;
          tmp___0 = realloc((void *)buf, (size_t )(used + buflen));
          buf = (char *)tmp___0;
          p = buf + used;
        }
      }
    }
    a = a->next;
  }
  if ((int )*(p - 2) == 44) {
    *(p - 2) = (char )'\n';
    p --;
    buflen ++;
  }
  l = snprintf((char * __restrict  )p, (size_t )buflen, (char const   * __restrict  )"]\n");
  p += l;
  buflen -= l;
  *len = (int )(p - buf);
  return (buf);
}
}
int handleHTTPRequest(struct client *c ) 
{ 
  char hdr[512] ;
  int clen ;
  int hdrlen ;
  int httpver ;
  int keepalive ;
  char *p ;
  char *url ;
  char *content ;
  char *ctype ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct stat sbuf ;
  int fd ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  ssize_t tmp___6 ;
  char buf[128] ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  ssize_t tmp___12 ;
  ssize_t tmp___13 ;

  {
  if (Modes.debug & (1 << 5)) {
    printf((char const   * __restrict  )"\nHTTP request: %s\n", c->buf);
  }
  tmp___0 = strstr((char const   *)(c->buf), "HTTP/1.1");
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    httpver = 11;
  } else {
    httpver = 10;
  }
  if (httpver == 10) {
    tmp___1 = strstr((char const   *)(c->buf), "Connection: keep-alive");
    keepalive = (unsigned long )tmp___1 != (unsigned long )((void *)0);
  } else
  if (httpver == 11) {
    tmp___2 = strstr((char const   *)(c->buf), "Connection: close");
    keepalive = (unsigned long )tmp___2 == (unsigned long )((void *)0);
  }
  p = strchr((char const   *)(c->buf), ' ');
  if (! p) {
    return (1);
  }
  p ++;
  url = p;
  p = strchr((char const   *)p, ' ');
  if (! p) {
    return (1);
  }
  *p = (char )'\000';
  if (Modes.debug & (1 << 5)) {
    printf((char const   * __restrict  )"\nHTTP keep alive: %d\n", keepalive);
    printf((char const   * __restrict  )"HTTP requested URL: %s\n\n", url);
  }
  tmp___10 = strstr((char const   *)url, "/data.json");
  if (tmp___10) {
    content = aircraftsToJson(& clen);
    ctype = (char *)"application/json;charset=utf-8";
  } else {
    fd = -1;
    tmp___9 = stat((char const   * __restrict  )"gmap.html", (struct stat * __restrict  )(& sbuf));
    if (tmp___9 != -1) {
      fd = open("gmap.html", 0);
      if (fd != -1) {
        tmp___3 = malloc((size_t )sbuf.st_size);
        content = (char *)tmp___3;
        tmp___6 = read(fd, (void *)content, (size_t )sbuf.st_size);
        if (tmp___6 == -1L) {
          tmp___4 = __errno_location();
          tmp___5 = strerror(*tmp___4);
          snprintf((char * __restrict  )content, (size_t )sbuf.st_size, (char const   * __restrict  )"Error reading from file: %s",
                   tmp___5);
        }
        clen = (int )sbuf.st_size;
      } else {
        tmp___7 = __errno_location();
        tmp___8 = strerror(*tmp___7);
        clen = snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"Error opening HTML file: %s",
                        tmp___8);
        content = strdup((char const   *)(buf));
      }
    } else {
      tmp___7 = __errno_location();
      tmp___8 = strerror(*tmp___7);
      clen = snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"Error opening HTML file: %s",
                      tmp___8);
      content = strdup((char const   *)(buf));
    }
    if (fd != -1) {
      close(fd);
    }
    ctype = (char *)"text/html;charset=utf-8";
  }
  if (keepalive) {
    tmp___11 = "keep-alive";
  } else {
    tmp___11 = "close";
  }
  hdrlen = snprintf((char * __restrict  )(hdr), sizeof(hdr), (char const   * __restrict  )"HTTP/1.1 200 OK\r\nServer: Dump1090\r\nContent-Type: %s\r\nConnection: %s\r\nContent-Length: %d\r\nAccess-Control-Allow-Origin: *\r\n\r\n",
                    ctype, tmp___11, clen);
  if (Modes.debug & (1 << 5)) {
    printf((char const   * __restrict  )"HTTP Reply header:\n%s", hdr);
  }
  tmp___12 = write(c->fd, (void const   *)(hdr), (size_t )hdrlen);
  if (tmp___12 != (ssize_t )hdrlen) {
    free((void *)content);
    return (1);
  } else {
    tmp___13 = write(c->fd, (void const   *)content, (size_t )clen);
    if (tmp___13 != (ssize_t )clen) {
      free((void *)content);
      return (1);
    }
  }
  free((void *)content);
  (Modes.stat_http_requests) ++;
  return (! keepalive);
}
}
void modesReadFromClient(struct client *c , char *sep , int (*handler)(struct client * ) ) 
{ 
  int left ;
  int nread ;
  ssize_t tmp ;
  int fullmsg ;
  int i ;
  char *p ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  while (1) {
    left = 1024 - c->buflen;
    tmp = read(c->fd, (void *)(c->buf + c->buflen), (size_t )left);
    nread = (int )tmp;
    fullmsg = 0;
    if (nread <= 0) {
      if (nread == 0) {
        modesFreeClient(c->fd);
      } else {
        tmp___0 = __errno_location();
        if (*tmp___0 != 11) {
          modesFreeClient(c->fd);
        }
      }
      break;
    }
    c->buflen += nread;
    c->buf[c->buflen] = (char )'\000';
    while (1) {
      p = strstr((char const   *)(c->buf), (char const   *)sep);
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
        break;
      }
      i = (int )(p - c->buf);
      c->buf[i] = (char )'\000';
      tmp___1 = (*handler)(c);
      if (tmp___1) {
        modesFreeClient(c->fd);
        return;
      }
      tmp___2 = strlen((char const   *)sep);
      i = (int )((size_t )i + tmp___2);
      memmove((void *)(c->buf), (void const   *)(c->buf + i), (size_t )(c->buflen - i));
      c->buflen -= i;
      c->buf[c->buflen] = (char )'\000';
      fullmsg = 1;
    }
    if (c->buflen == 1024) {
      c->buflen = 0;
      continue;
    }
    if (! fullmsg) {
      break;
    }
  }
  return;
}
}
void modesReadFromClients(void) 
{ 
  int j ;
  struct client *c ;

  {
  j = 0;
  while (j <= Modes.maxfd) {
    c = Modes.clients[j];
    if ((unsigned long )c == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    if (c->service == Modes.ris) {
      modesReadFromClient(c, (char *)"\n", & decodeHexMessage);
    } else
    if (c->service == Modes.https) {
      modesReadFromClient(c, (char *)"\r\n\r\n", & handleHTTPRequest);
    }
    __Cont: /* CIL Label */ 
    j ++;
  }
  return;
}
}
void modesWaitReadableClients(int timeout_ms ) 
{ 
  struct timeval tv ;
  fd_set fds ;
  int j ;
  int maxfd ;
  int __d0 ;
  int __d1 ;
  int s ;

  {
  maxfd = Modes.maxfd;
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.__fds_bits[0]): "memory");
    break;
  }
  j = 0;
  while (j <= Modes.maxfd) {
    if (Modes.clients[j]) {
      fds.__fds_bits[j / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << j % (8 * (int )sizeof(__fd_mask )));
    }
    j ++;
  }
  j = 0;
  while (j < 4) {
    s = *(modesNetServices[j].socket);
    fds.__fds_bits[s / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << s % (8 * (int )sizeof(__fd_mask )));
    if (s > maxfd) {
      maxfd = s;
    }
    j ++;
  }
  tv.tv_sec = (__time_t )(timeout_ms / 1000);
  tv.tv_usec = (__suseconds_t )((timeout_ms % 1000) * 1000);
  select(maxfd + 1, (fd_set * __restrict  )(& fds), (fd_set * __restrict  )((void *)0),
         (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& tv));
  return;
}
}
void sigWinchCallback(void) 
{ 


  {
  signal(28, (void (*)(int  ))1);
  Modes.interactive_rows = getTermRows();
  interactiveShowData();
  signal(28, (void (*)(int  ))(& sigWinchCallback));
  return;
}
}
int getTermRows(void) 
{ 
  struct winsize w ;

  {
  ioctl(1, 21523UL, & w);
  return ((int )w.ws_row);
}
}
void showHelp(void) 
{ 


  {
  printf((char const   * __restrict  )"--device-index <index>   Select RTL device (default: 0).\n--gain <db>              Set gain (default: max gain. Use -100 for auto-gain).\n--enable-agc             Enable the Automatic Gain Control (default: off).\n--freq <hz>              Set frequency (default: 1090 Mhz).\n--ifile <filename>       Read data from file (use \'-\' for stdin).\n--loop                   With --ifile, read the same file in a loop.\n--interactive            Interactive mode refreshing data on screen.\n--interactive-rows <num> Max number of rows in interactive mode (default: 15).\n--interactive-ttl <sec>  Remove from list if idle for <sec> (default: 60).\n--raw                    Show only messages hex values.\n--net                    Enable networking.\n--net-only               Enable just networking, no RTL device or file used.\n--net-ro-port <port>     TCP listening port for raw output (default: 30002).\n--net-ri-port <port>     TCP listening port for raw input (default: 30001).\n--net-http-port <port>   HTTP server port (default: 8080).\n--net-sbs-port <port>    TCP listening port for BaseStation format output (default: 30003).\n--no-fix                 Disable single-bits error correction using CRC.\n--no-crc-check           Disable messages with broken CRC (discouraged).\n--aggressive             More CPU for more messages (two bits fixes, ...).\n--stats                  With --ifile print stats at exit. No other output.\n--onlyaddr               Show only ICAO addresses (testing purposes).\n--metric                 Use metric units (meters, km/h, ...).\n--snip <level>           Strip IQ file removing samples < level.\n--debug <flags>          Debug mode (verbose), see README for details.\n--help                   Show this help.\n\nDebug mode flags: d = Log frames decoded with errors\n                  D = Log frames decoded with zero errors\n                  c = Log frames with bad CRC\n                  C = Log frames with good CRC\n                  p = Log frames with bad preamble\n                  n = Log network debugging info\n                  j = Log frames to frames.js, loadable by debug.html.\n");
  return;
}
}
void backgroundTasks(void) 
{ 
  long long tmp ;

  {
  if (Modes.net) {
    modesAcceptClients();
    modesReadFromClients();
    interactiveRemoveStaleAircrafts();
  }
  if (Modes.interactive) {
    tmp = mstime();
    if (tmp - Modes.interactive_last_update > 250LL) {
      interactiveRemoveStaleAircrafts();
      interactiveShowData();
      Modes.interactive_last_update = mstime();
    }
  }
  return;
}
}
int main(int argc , char **argv ) 
{ 
  int j ;
  int more ;
  double tmp ;
  long long tmp___0 ;
  char *f ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
  modesInitConfig();
  j = 1;
  while (j < argc) {
    more = j + 1 < argc;
    tmp___26 = strcmp((char const   *)*(argv + j), "--device-index");
    if (tmp___26) {
      _L___8: /* CIL Label */ 
      tmp___25 = strcmp((char const   *)*(argv + j), "--gain");
      if (tmp___25) {
        _L___7: /* CIL Label */ 
        tmp___24 = strcmp((char const   *)*(argv + j), "--enable-agc");
        if (tmp___24) {
          tmp___23 = strcmp((char const   *)*(argv + j), "--freq");
          if (tmp___23) {
            _L___6: /* CIL Label */ 
            tmp___22 = strcmp((char const   *)*(argv + j), "--ifile");
            if (tmp___22) {
              _L___5: /* CIL Label */ 
              tmp___21 = strcmp((char const   *)*(argv + j), "--loop");
              if (tmp___21) {
                tmp___20 = strcmp((char const   *)*(argv + j), "--no-fix");
                if (tmp___20) {
                  tmp___19 = strcmp((char const   *)*(argv + j), "--no-crc-check");
                  if (tmp___19) {
                    tmp___18 = strcmp((char const   *)*(argv + j), "--raw");
                    if (tmp___18) {
                      tmp___17 = strcmp((char const   *)*(argv + j), "--net");
                      if (tmp___17) {
                        tmp___16 = strcmp((char const   *)*(argv + j), "--net-only");
                        if (tmp___16) {
                          tmp___15 = strcmp((char const   *)*(argv + j), "--net-ro-port");
                          if (tmp___15) {
                            _L___4: /* CIL Label */ 
                            tmp___14 = strcmp((char const   *)*(argv + j), "--net-ri-port");
                            if (tmp___14) {
                              _L___3: /* CIL Label */ 
                              tmp___13 = strcmp((char const   *)*(argv + j), "--net-http-port");
                              if (tmp___13) {
                                _L___2: /* CIL Label */ 
                                tmp___12 = strcmp((char const   *)*(argv + j), "--net-sbs-port");
                                if (tmp___12) {
                                  _L___1: /* CIL Label */ 
                                  tmp___11 = strcmp((char const   *)*(argv + j), "--onlyaddr");
                                  if (tmp___11) {
                                    tmp___10 = strcmp((char const   *)*(argv + j),
                                                      "--metric");
                                    if (tmp___10) {
                                      tmp___9 = strcmp((char const   *)*(argv + j),
                                                       "--aggressive");
                                      if (tmp___9) {
                                        tmp___8 = strcmp((char const   *)*(argv + j),
                                                         "--interactive");
                                        if (tmp___8) {
                                          tmp___7 = strcmp((char const   *)*(argv + j),
                                                           "--interactive-rows");
                                          if (tmp___7) {
                                            tmp___6 = strcmp((char const   *)*(argv + j),
                                                             "--interactive-ttl");
                                            if (tmp___6) {
                                              tmp___5 = strcmp((char const   *)*(argv + j),
                                                               "--debug");
                                              if (tmp___5) {
                                                _L___0: /* CIL Label */ 
                                                tmp___4 = strcmp((char const   *)*(argv + j),
                                                                 "--stats");
                                                if (tmp___4) {
                                                  tmp___3 = strcmp((char const   *)*(argv + j),
                                                                   "--snip");
                                                  if (tmp___3) {
                                                    _L: /* CIL Label */ 
                                                    tmp___2 = strcmp((char const   *)*(argv + j),
                                                                     "--help");
                                                    if (tmp___2) {
                                                      fprintf((FILE * __restrict  )stderr,
                                                              (char const   * __restrict  )"Unknown or not enough arguments for option \'%s\'.\n\n",
                                                              *(argv + j));
                                                      showHelp();
                                                      exit(1);
                                                    } else {
                                                      showHelp();
                                                      exit(0);
                                                    }
                                                  } else
                                                  if (more) {
                                                    j ++;
                                                    tmp___1 = atoi((char const   *)*(argv + j));
                                                    snipMode(tmp___1);
                                                    exit(0);
                                                  } else {
                                                    goto _L;
                                                  }
                                                } else {
                                                  Modes.stats = 1;
                                                }
                                              } else
                                              if (more) {
                                                j ++;
                                                f = *(argv + j);
                                                while (*f) {
                                                  switch ((int )*f) {
                                                  case 68: 
                                                  Modes.debug |= 1;
                                                  break;
                                                  case 100: 
                                                  Modes.debug |= 1 << 1;
                                                  break;
                                                  case 67: 
                                                  Modes.debug |= 1 << 3;
                                                  break;
                                                  case 99: 
                                                  Modes.debug |= 1 << 2;
                                                  break;
                                                  case 112: 
                                                  Modes.debug |= 1 << 4;
                                                  break;
                                                  case 110: 
                                                  Modes.debug |= 1 << 5;
                                                  break;
                                                  case 106: 
                                                  Modes.debug |= 1 << 6;
                                                  break;
                                                  default: 
                                                  fprintf((FILE * __restrict  )stderr,
                                                          (char const   * __restrict  )"Unknown debugging flag: %c\n",
                                                          (int )*f);
                                                  exit(1);
                                                  break;
                                                  }
                                                  f ++;
                                                }
                                              } else {
                                                goto _L___0;
                                              }
                                            } else {
                                              j ++;
                                              Modes.interactive_ttl = atoi((char const   *)*(argv + j));
                                            }
                                          } else {
                                            j ++;
                                            Modes.interactive_rows = atoi((char const   *)*(argv + j));
                                          }
                                        } else {
                                          Modes.interactive = 1;
                                        }
                                      } else {
                                        (Modes.aggressive) ++;
                                      }
                                    } else {
                                      Modes.metric = 1;
                                    }
                                  } else {
                                    Modes.onlyaddr = 1;
                                  }
                                } else
                                if (more) {
                                  j ++;
                                  modesNetServices[3].port = atoi((char const   *)*(argv + j));
                                } else {
                                  goto _L___1;
                                }
                              } else
                              if (more) {
                                j ++;
                                modesNetServices[2].port = atoi((char const   *)*(argv + j));
                              } else {
                                goto _L___2;
                              }
                            } else
                            if (more) {
                              j ++;
                              modesNetServices[1].port = atoi((char const   *)*(argv + j));
                            } else {
                              goto _L___3;
                            }
                          } else
                          if (more) {
                            j ++;
                            modesNetServices[0].port = atoi((char const   *)*(argv + j));
                          } else {
                            goto _L___4;
                          }
                        } else {
                          Modes.net = 1;
                          Modes.net_only = 1;
                        }
                      } else {
                        Modes.net = 1;
                      }
                    } else {
                      Modes.raw = 1;
                    }
                  } else {
                    Modes.check_crc = 0;
                  }
                } else {
                  Modes.fix_errors = 0;
                }
              } else {
                Modes.loop = 1;
              }
            } else
            if (more) {
              j ++;
              Modes.filename = strdup((char const   *)*(argv + j));
            } else {
              goto _L___5;
            }
          } else
          if (more) {
            j ++;
            tmp___0 = strtoll((char const   * __restrict  )*(argv + j), (char ** __restrict  )((void *)0),
                              10);
            Modes.freq = (int )tmp___0;
          } else {
            goto _L___6;
          }
        } else {
          (Modes.enable_agc) ++;
        }
      } else
      if (more) {
        j ++;
        tmp = atof((char const   *)*(argv + j));
        Modes.gain = (int )(tmp * (double )10);
      } else {
        goto _L___7;
      }
    } else
    if (more) {
      j ++;
      Modes.dev_index = atoi((char const   *)*(argv + j));
    } else {
      goto _L___8;
    }
    j ++;
  }
  if (Modes.interactive == 1) {
    signal(28, (void (*)(int  ))(& sigWinchCallback));
  }
  modesInit();
  if (Modes.net_only) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Net-only mode, no RTL device or file open.\n");
  } else
  if ((unsigned long )Modes.filename == (unsigned long )((void *)0)) {
    modesInitRTLSDR();
  } else
  if ((int )*(Modes.filename + 0) == 45) {
    if ((int )*(Modes.filename + 1) == 0) {
      Modes.fd = 0;
    } else {
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ 
    Modes.fd = open((char const   *)Modes.filename, 0);
    if (Modes.fd == -1) {
      perror("Opening data file");
      exit(1);
    }
  }
  if (Modes.net) {
    modesInitNet();
  }
  while (Modes.net_only) {
    backgroundTasks();
    modesWaitReadableClients(100);
  }
  pthread_create((pthread_t * __restrict  )(& Modes.reader_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                 & readerThreadEntryPoint, (void * __restrict  )((void *)0));
  pthread_mutex_lock(& Modes.data_mutex);
  while (1) {
    if (! Modes.data_ready) {
      pthread_cond_wait((pthread_cond_t * __restrict  )(& Modes.data_cond), (pthread_mutex_t * __restrict  )(& Modes.data_mutex));
      continue;
    }
    computeMagnitudeVector();
    Modes.data_ready = 0;
    pthread_cond_signal(& Modes.data_cond);
    pthread_mutex_unlock(& Modes.data_mutex);
    detectModeS(Modes.magnitude, Modes.data_len / 2U);
    backgroundTasks();
    pthread_mutex_lock(& Modes.data_mutex);
    if (Modes.exit) {
      break;
    }
  }
  if (Modes.stats) {
    if (Modes.filename) {
      printf((char const   * __restrict  )"%lld valid preambles\n", Modes.stat_valid_preamble);
      printf((char const   * __restrict  )"%lld demodulated again after phase correction\n",
             Modes.stat_out_of_phase);
      printf((char const   * __restrict  )"%lld demodulated with zero errors\n", Modes.stat_demodulated);
      printf((char const   * __restrict  )"%lld with good crc\n", Modes.stat_goodcrc);
      printf((char const   * __restrict  )"%lld with bad crc\n", Modes.stat_badcrc);
      printf((char const   * __restrict  )"%lld errors corrected\n", Modes.stat_fixed);
      printf((char const   * __restrict  )"%lld single bit errors\n", Modes.stat_single_bit_fix);
      printf((char const   * __restrict  )"%lld two bits errors\n", Modes.stat_two_bits_fix);
      printf((char const   * __restrict  )"%lld total usable messages\n", Modes.stat_goodcrc + Modes.stat_fixed);
    }
  }
  rtlsdr_close(Modes.dev);
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-XVU19bKA.i","-O2,-g,-Wall,-W")
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 


  {
  return ((__uint16_t )((((int )__bsx >> 8) & 255) | (((int )__bsx & 255) << 8)));
}
}
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 


  {
  return (((((__bsx & 4278190080U) >> 24) | ((__bsx & 16711680U) >> 8)) | ((__bsx & 65280U) << 8)) | ((__bsx & 255U) << 24));
}
}
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg ) 
{ 


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
extern  __attribute__((__nothrow__)) int inet_aton(char const   *__cp , struct in_addr *__inp ) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
extern struct hostent *gethostbyname(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
int anetTcpConnect(char *err , char *addr , int port ) ;
int anetTcpNonBlockConnect(char *err , char *addr , int port ) ;
int anetUnixConnect(char *err , char *path ) ;
int anetUnixNonBlockConnect(char *err , char *path ) ;
int anetRead(int fd , char *buf , int count ) ;
int anetResolve(char *err , char *host , char *ipbuf ) ;
int anetUnixServer(char *err , char *path , mode_t perm ) ;
int anetUnixAccept(char *err , int s ) ;
int anetWrite(int fd , char *buf , int count ) ;
int anetTcpNoDelay(char *err , int fd ) ;
int anetTcpKeepAlive(char *err , int fd ) ;
int anetPeerToString(int fd , char *ip , int *port ) ;
static void anetSetError(char *err , char const   *fmt  , ...) 
{ 
  va_list___0 ap ;

  {
  if (! err) {
    return;
  }
  __builtin_va_start(ap, fmt);
  vsnprintf((char * __restrict  )err, (size_t )256, (char const   * __restrict  )fmt,
            ap);
  __builtin_va_end(ap);
  return;
}
}
int anetNonBlock(char *err , int fd ) 
{ 
  int flags ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  flags = fcntl(fd, 3);
  if (flags == -1) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    anetSetError(err, "fcntl(F_GETFL): %s", tmp___0);
    return (-1);
  }
  tmp___3 = fcntl(fd, 4, flags | 2048);
  if (tmp___3 == -1) {
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    anetSetError(err, "fcntl(F_SETFL,O_NONBLOCK): %s", tmp___2);
    return (-1);
  }
  return (0);
}
}
int anetTcpNoDelay(char *err , int fd ) 
{ 
  int yes ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  yes = 1;
  tmp___1 = setsockopt(fd, 6, 1, (void const   *)(& yes), (socklen_t )sizeof(yes));
  if (tmp___1 == -1) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    anetSetError(err, "setsockopt TCP_NODELAY: %s", tmp___0);
    return (-1);
  }
  return (0);
}
}
int anetSetSendBuffer(char *err , int fd , int buffsize ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  tmp___1 = setsockopt(fd, 1, 7, (void const   *)(& buffsize), (socklen_t )sizeof(buffsize));
  if (tmp___1 == -1) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    anetSetError(err, "setsockopt SO_SNDBUF: %s", tmp___0);
    return (-1);
  }
  return (0);
}
}
int anetTcpKeepAlive(char *err , int fd ) 
{ 
  int yes ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  yes = 1;
  tmp___1 = setsockopt(fd, 1, 9, (void const   *)(& yes), (socklen_t )sizeof(yes));
  if (tmp___1 == -1) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    anetSetError(err, "setsockopt SO_KEEPALIVE: %s", tmp___0);
    return (-1);
  }
  return (0);
}
}
int anetResolve(char *err , char *host , char *ipbuf ) 
{ 
  struct sockaddr_in sa ;
  struct hostent *he ;
  int tmp ;
  char *tmp___0 ;

  {
  sa.sin_family = (sa_family_t )2;
  tmp = inet_aton((char const   *)host, & sa.sin_addr);
  if (tmp == 0) {
    he = gethostbyname((char const   *)host);
    if ((unsigned long )he == (unsigned long )((void *)0)) {
      anetSetError(err, "can\'t resolve: %s", host);
      return (-1);
    }
    memcpy((void * __restrict  )(& sa.sin_addr), (void const   * __restrict  )*(he->h_addr_list + 0),
           sizeof(struct in_addr ));
  }
  tmp___0 = inet_ntoa(sa.sin_addr);
  strcpy((char * __restrict  )ipbuf, (char const   * __restrict  )tmp___0);
  return (0);
}
}
static int anetCreateSocket(char *err , int domain ) 
{ 
  int s ;
  int on ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  on = 1;
  s = socket(domain, 1, 0);
  if (s == -1) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    anetSetError(err, "creating socket: %s", tmp___0);
    return (-1);
  }
  tmp___3 = setsockopt(s, 1, 2, (void const   *)(& on), (socklen_t )sizeof(on));
  if (tmp___3 == -1) {
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    anetSetError(err, "setsockopt SO_REUSEADDR: %s", tmp___2);
    return (-1);
  }
  return (s);
}
}
static int anetTcpGenericConnect(char *err , char *addr , int port , int flags ) 
{ 
  int s ;
  struct sockaddr_in sa ;
  struct hostent *he ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  s = anetCreateSocket(err, 2);
  if (s == -1) {
    return (-1);
  }
  sa.sin_family = (sa_family_t )2;
  sa.sin_port = __bswap_16((__uint16_t )port);
  tmp = inet_aton((char const   *)addr, & sa.sin_addr);
  if (tmp == 0) {
    he = gethostbyname((char const   *)addr);
    if ((unsigned long )he == (unsigned long )((void *)0)) {
      anetSetError(err, "can\'t resolve: %s", addr);
      close(s);
      return (-1);
    }
    memcpy((void * __restrict  )(& sa.sin_addr), (void const   * __restrict  )*(he->h_addr_list + 0),
           sizeof(struct in_addr ));
  }
  if (flags & 1) {
    tmp___0 = anetNonBlock(err, s);
    if (tmp___0 != 0) {
      return (-1);
    }
  }
  tmp___4 = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& sa)), (socklen_t )sizeof(sa));
  if (tmp___4 == -1) {
    tmp___1 = __errno_location();
    if (*tmp___1 == 115) {
      if (flags & 1) {
        return (s);
      }
    }
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    anetSetError(err, "connect: %s", tmp___3);
    close(s);
    return (-1);
  }
  return (s);
}
}
int anetTcpConnect(char *err , char *addr , int port ) 
{ 
  int tmp ;

  {
  tmp = anetTcpGenericConnect(err, addr, port, 0);
  return (tmp);
}
}
int anetTcpNonBlockConnect(char *err , char *addr , int port ) 
{ 
  int tmp ;

  {
  tmp = anetTcpGenericConnect(err, addr, port, 1);
  return (tmp);
}
}
int anetUnixGenericConnect(char *err , char *path , int flags ) 
{ 
  int s ;
  struct sockaddr_un sa ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  s = anetCreateSocket(err, 1);
  if (s == -1) {
    return (-1);
  }
  sa.sun_family = (sa_family_t )1;
  strncpy((char * __restrict  )(sa.sun_path), (char const   * __restrict  )path, sizeof(sa.sun_path) - 1UL);
  if (flags & 1) {
    tmp = anetNonBlock(err, s);
    if (tmp != 0) {
      return (-1);
    }
  }
  tmp___3 = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& sa)), (socklen_t )sizeof(sa));
  if (tmp___3 == -1) {
    tmp___0 = __errno_location();
    if (*tmp___0 == 115) {
      if (flags & 1) {
        return (s);
      }
    }
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    anetSetError(err, "connect: %s", tmp___2);
    close(s);
    return (-1);
  }
  return (s);
}
}
int anetUnixConnect(char *err , char *path ) 
{ 
  int tmp ;

  {
  tmp = anetUnixGenericConnect(err, path, 0);
  return (tmp);
}
}
int anetUnixNonBlockConnect(char *err , char *path ) 
{ 
  int tmp ;

  {
  tmp = anetUnixGenericConnect(err, path, 1);
  return (tmp);
}
}
int anetRead(int fd , char *buf , int count ) 
{ 
  int nread ;
  int totlen ;
  ssize_t tmp ;

  {
  totlen = 0;
  while (totlen != count) {
    tmp = read(fd, (void *)buf, (size_t )(count - totlen));
    nread = (int )tmp;
    if (nread == 0) {
      return (totlen);
    }
    if (nread == -1) {
      return (-1);
    }
    totlen += nread;
    buf += nread;
  }
  return (totlen);
}
}
int anetWrite(int fd , char *buf , int count ) 
{ 
  int nwritten ;
  int totlen ;
  ssize_t tmp ;

  {
  totlen = 0;
  while (totlen != count) {
    tmp = write(fd, (void const   *)buf, (size_t )(count - totlen));
    nwritten = (int )tmp;
    if (nwritten == 0) {
      return (totlen);
    }
    if (nwritten == -1) {
      return (-1);
    }
    totlen += nwritten;
    buf += nwritten;
  }
  return (totlen);
}
}
static int anetListen(char *err , int s , struct sockaddr *sa , socklen_t len ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  tmp___1 = bind(s, (struct sockaddr  const  *)sa, len);
  if (tmp___1 == -1) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    anetSetError(err, "bind: %s", tmp___0);
    close(s);
    return (-1);
  }
  tmp___4 = listen(s, 511);
  if (tmp___4 == -1) {
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    anetSetError(err, "listen: %s", tmp___3);
    close(s);
    return (-1);
  }
  return (0);
}
}
int anetTcpServer(char *err , int port , char *bindaddr ) 
{ 
  int s ;
  struct sockaddr_in sa ;
  int tmp ;
  int tmp___0 ;

  {
  s = anetCreateSocket(err, 2);
  if (s == -1) {
    return (-1);
  }
  memset((void *)(& sa), 0, sizeof(sa));
  sa.sin_family = (sa_family_t )2;
  sa.sin_port = __bswap_16((__uint16_t )port);
  sa.sin_addr.s_addr = __bswap_32((in_addr_t )0);
  if (bindaddr) {
    tmp = inet_aton((char const   *)bindaddr, & sa.sin_addr);
    if (tmp == 0) {
      anetSetError(err, "invalid bind address");
      close(s);
      return (-1);
    }
  }
  tmp___0 = anetListen(err, s, (struct sockaddr *)(& sa), (socklen_t )sizeof(sa));
  if (tmp___0 == -1) {
    return (-1);
  }
  return (s);
}
}
int anetUnixServer(char *err , char *path , mode_t perm ) 
{ 
  int s ;
  struct sockaddr_un sa ;
  int tmp ;

  {
  s = anetCreateSocket(err, 1);
  if (s == -1) {
    return (-1);
  }
  memset((void *)(& sa), 0, sizeof(sa));
  sa.sun_family = (sa_family_t )1;
  strncpy((char * __restrict  )(sa.sun_path), (char const   * __restrict  )path, sizeof(sa.sun_path) - 1UL);
  tmp = anetListen(err, s, (struct sockaddr *)(& sa), (socklen_t )sizeof(sa));
  if (tmp == -1) {
    return (-1);
  }
  if (perm) {
    chmod((char const   *)(sa.sun_path), perm);
  }
  return (s);
}
}
static int anetGenericAccept(char *err , int s , struct sockaddr *sa , socklen_t *len ) 
{ 
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  while (1) {
    fd = accept(s, (struct sockaddr * __restrict  )sa, (socklen_t * __restrict  )len);
    if (fd == -1) {
      tmp___1 = __errno_location();
      if (*tmp___1 == 4) {
        continue;
      } else {
        tmp = __errno_location();
        tmp___0 = strerror(*tmp);
        anetSetError(err, "accept: %s", tmp___0);
        return (-1);
      }
    }
    break;
  }
  return (fd);
}
}
int anetTcpAccept(char *err , int s , char *ip , int *port ) 
{ 
  int fd ;
  struct sockaddr_in sa ;
  socklen_t salen ;
  char *tmp ;
  __uint16_t tmp___0 ;

  {
  salen = (socklen_t )sizeof(sa);
  fd = anetGenericAccept(err, s, (struct sockaddr *)(& sa), & salen);
  if (fd == -1) {
    return (-1);
  }
  if (ip) {
    tmp = inet_ntoa(sa.sin_addr);
    strcpy((char * __restrict  )ip, (char const   * __restrict  )tmp);
  }
  if (port) {
    tmp___0 = __bswap_16(sa.sin_port);
    *port = (int )tmp___0;
  }
  return (fd);
}
}
int anetUnixAccept(char *err , int s ) 
{ 
  int fd ;
  struct sockaddr_un sa ;
  socklen_t salen ;

  {
  salen = (socklen_t )sizeof(sa);
  fd = anetGenericAccept(err, s, (struct sockaddr *)(& sa), & salen);
  if (fd == -1) {
    return (-1);
  }
  return (fd);
}
}
int anetPeerToString(int fd , char *ip , int *port ) 
{ 
  struct sockaddr_in sa ;
  socklen_t salen ;
  int tmp ;
  char *tmp___0 ;
  __uint16_t tmp___1 ;

  {
  salen = (socklen_t )sizeof(sa);
  tmp = getpeername(fd, (struct sockaddr * __restrict  )((struct sockaddr *)(& sa)),
                    (socklen_t * __restrict  )(& salen));
  if (tmp == -1) {
    *port = 0;
    *(ip + 0) = (char )'?';
    *(ip + 1) = (char )'\000';
    return (-1);
  }
  if (ip) {
    tmp___0 = inet_ntoa(sa.sin_addr);
    strcpy((char * __restrict  )ip, (char const   * __restrict  )tmp___0);
  }
  if (port) {
    tmp___1 = __bswap_16(sa.sin_port);
    *port = (int )tmp___1;
  }
  return (0);
}
}
int anetSockName(int fd , char *ip , int *port ) 
{ 
  struct sockaddr_in sa ;
  socklen_t salen ;
  int tmp ;
  char *tmp___0 ;
  __uint16_t tmp___1 ;

  {
  salen = (socklen_t )sizeof(sa);
  tmp = getsockname(fd, (struct sockaddr * __restrict  )((struct sockaddr *)(& sa)),
                    (socklen_t * __restrict  )(& salen));
  if (tmp == -1) {
    *port = 0;
    *(ip + 0) = (char )'?';
    *(ip + 1) = (char )'\000';
    return (-1);
  }
  if (ip) {
    tmp___0 = inet_ntoa(sa.sin_addr);
    strcpy((char * __restrict  )ip, (char const   * __restrict  )tmp___0);
  }
  if (port) {
    tmp___1 = __bswap_16(sa.sin_port);
    *port = (int )tmp___1;
  }
  return (0);
}
}
