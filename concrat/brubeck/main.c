/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned char __uint8_t;
typedef unsigned short __uint16_t;
typedef unsigned int __uint32_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __syscall_slong_t;
typedef unsigned int __socklen_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef unsigned long size_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef int volatile   pthread_spinlock_t;
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
typedef __builtin_va_list __gnuc_va_list;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
typedef double value_t;
struct brubeck_server ;
struct brubeck_metric ;
enum brubeck_backend_t {
    BRUBECK_BACKEND_CARBON = 0,
    BRUBECK_BACKEND_KAFKA = 1
} ;
struct brubeck_backend {
   enum brubeck_backend_t type ;
   struct brubeck_server *server ;
   int sample_freq ;
   int shard_n ;
   int (*connect)(void * ) ;
   _Bool (*is_connected)(void * ) ;
   void (*sample)(struct brubeck_metric  const  * , char const   * , value_t  , void * ) ;
   void (*flush)(void * ) ;
   uint32_t tick_time ;
   pthread_t thread ;
   struct brubeck_metric *queue ;
};
enum __anonenum_json_type_587412934 {
    JSON_OBJECT = 0,
    JSON_ARRAY = 1,
    JSON_STRING = 2,
    JSON_INTEGER = 3,
    JSON_REAL = 4,
    JSON_TRUE = 5,
    JSON_FALSE = 6,
    JSON_NULL = 7
} ;
typedef enum __anonenum_json_type_587412934 json_type;
struct json_t {
   json_type type ;
   size_t volatile   refcount ;
};
typedef struct json_t json_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef int __gwchar_t;
struct brubeck_histo {
   value_t *values ;
   uint32_t count ;
   uint16_t alloc ;
   uint16_t size ;
};
struct brubeck_hashtable_t ;
typedef struct brubeck_hashtable_t brubeck_hashtable_t;
struct brubeck_tag_set ;
struct __anonstruct_gauge_908274918 {
   value_t value ;
};
struct __anonstruct_counter_908274919 {
   value_t value ;
   value_t previous ;
};
union __anonunion_as_920192508 {
   struct __anonstruct_gauge_908274918 gauge ;
   struct __anonstruct_gauge_908274918 meter ;
   struct __anonstruct_counter_908274919 counter ;
   struct brubeck_histo histogram ;
   void *other ;
};
struct brubeck_metric {
   struct brubeck_metric *next ;
   struct brubeck_tag_set  const  *tags ;
   pthread_spinlock_t lock ;
   uint16_t key_len ;
   uint8_t type ;
   uint8_t private_state ;
   union __anonunion_as_920192508 as ;
   char key[] ;
};
enum brubeck_sampler_t {
    BRUBECK_SAMPLER_STATSD = 0
} ;
struct brubeck_sampler {
   enum brubeck_sampler_t type ;
   struct brubeck_server *server ;
   int in_sock ;
   struct sockaddr_in addr ;
   size_t inflow ;
   size_t current_flow ;
   void (*shutdown)(struct brubeck_sampler * ) ;
};
struct brubeck_slab_node {
   struct brubeck_slab_node *next ;
   size_t alloc ;
   char heap[] ;
};
struct brubeck_slab {
   struct brubeck_slab_node *current ;
   size_t total_alloc ;
   pthread_mutex_t lock ;
};
struct brubeck_tag {
   char const   *key ;
   char const   *value ;
};
struct brubeck_tag_set {
   uint32_t index ;
   uint16_t tag_len ;
   uint16_t num_tags ;
   struct brubeck_tag tags[] ;
};
struct brubeck_tags_t ;
typedef struct brubeck_tags_t brubeck_tags_t;
struct __anonstruct_live_669259541 {
   uint32_t metrics ;
   uint32_t errors ;
   uint32_t unique_keys ;
};
struct brubeck_internal_stats {
   int sample_freq ;
   struct __anonstruct_live_669259541 live ;
   struct __anonstruct_live_669259541 sample ;
};
struct brubeck_server {
   char const   *name ;
   char const   *dump_path ;
   char const   *config_name ;
   int running ;
   int active_backends ;
   int active_samplers ;
   _Bool set_proctitle ;
   int fd_signal ;
   int fd_expire ;
   int fd_update ;
   struct brubeck_slab slab ;
   brubeck_hashtable_t *metrics ;
   brubeck_tags_t *tags ;
   int at_capacity ;
   struct brubeck_sampler *samplers[8] ;
   struct brubeck_backend *backends[8] ;
   json_t *config ;
   struct brubeck_internal_stats internal_stats ;
};
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
typedef int __clockid_t;
typedef __clockid_t clockid_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
typedef unsigned long __uint64_t;
typedef long __ssize_t;
typedef __uint64_t uint64_t;
typedef __ssize_t ssize_t;
struct json_error_t {
   int line ;
   int column ;
   int position ;
   char source[80] ;
   char text[160] ;
};
typedef struct json_error_t json_error_t;
struct pickler {
   char *ptr ;
   uint16_t pos ;
   uint16_t pt ;
};
struct brubeck_carbon {
   struct brubeck_backend backend ;
   int out_sock ;
   struct sockaddr_in out_sockaddr ;
   struct pickler pickler ;
   size_t bytes_sent ;
};
struct multibloom {
   int bits ;
   int bytes ;
   int hashes ;
   unsigned char *filters[] ;
};
struct brubeck_histo_sample {
   value_t sum ;
   value_t min ;
   value_t max ;
   value_t mean ;
   value_t median ;
   value_t count ;
   value_t percentile[5] ;
};
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
typedef unsigned long uintptr_t;
struct ck_malloc {
   void *(*malloc)(size_t  ) ;
   void *(*realloc)(void * , size_t  , size_t  , _Bool  ) ;
   void (*free)(void * , size_t  , _Bool  ) ;
};
struct ck_ht_hash {
   uint64_t value ;
};
typedef struct ck_ht_hash ck_ht_hash_t;
struct ck_ht_entry {
   uintptr_t key ;
   uintptr_t value ;
   uint64_t key_length ;
   uint64_t hash ;
};
typedef struct ck_ht_entry ck_ht_entry_t;
typedef void ck_ht_hash_cb_t(ck_ht_hash_t * , void const   * , size_t  , uint64_t  );
struct ck_ht_map ;
struct ck_ht {
   struct ck_malloc *m ;
   struct ck_ht_map *map ;
   unsigned int mode ;
   uint64_t seed ;
   ck_ht_hash_cb_t *h ;
};
typedef struct ck_ht ck_ht_t;
struct ck_ht_iterator {
   struct ck_ht_entry *current ;
   uint64_t offset ;
};
typedef struct ck_ht_iterator ck_ht_iterator_t;
struct brubeck_hashtable_t {
   ck_ht_t table ;
   pthread_mutex_t write_mutex ;
};
typedef int __pid_t;
typedef long long json_int_t;
struct rd_kafka_s ;
typedef struct rd_kafka_s rd_kafka_t;
struct brubeck_kafka_document {
   json_t *json ;
   _Bool is_dirty ;
};
struct brubeck_kafka {
   struct brubeck_backend backend ;
   rd_kafka_t *rk ;
   _Bool connected ;
   char const   *topic ;
   char const   *tag_subdocument ;
   size_t bytes_sent ;
   struct brubeck_kafka_document **documents ;
};
struct MHD_Daemon ;
struct MHD_Connection ;
struct MHD_Response ;
enum MHD_ResponseMemoryMode {
    MHD_RESPMEM_PERSISTENT = 0,
    MHD_RESPMEM_MUST_FREE = 1,
    MHD_RESPMEM_MUST_COPY = 2
} ;
typedef __gnuc_va_list va_list___0;
struct brubeck_metric__proto {
   void (*record)(struct brubeck_metric * , value_t  , value_t  , uint8_t  ) ;
   void (*sample)(struct brubeck_metric * , void (*)(struct brubeck_metric  const  *metric ,
                                                     char const   *key , value_t value ,
                                                     void *backend ) , void * ) ;
};
typedef unsigned long __ino64_t;
typedef long __blkcnt64_t;
struct mmsghdr {
   struct msghdr msg_hdr ;
   unsigned int msg_len ;
};
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct brubeck_statsd_msg {
   char *key ;
   uint16_t key_len ;
   uint16_t type ;
   value_t value ;
   value_t sample_freq ;
   uint8_t modifiers ;
};
struct brubeck_statsd {
   struct brubeck_sampler sampler ;
   pthread_t *workers ;
   unsigned int worker_count ;
   unsigned int mmsg_count ;
   double scale_timers_by ;
};
typedef unsigned long nfds_t;
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
typedef int __int32_t;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
typedef void (*__sighandler_t)(int  );
typedef __int32_t int32_t;
struct signalfd_siginfo {
   uint32_t ssi_signo ;
   int32_t ssi_errno ;
   int32_t ssi_code ;
   uint32_t ssi_pid ;
   uint32_t ssi_uid ;
   int32_t ssi_fd ;
   uint32_t ssi_tid ;
   uint32_t ssi_band ;
   uint32_t ssi_overrun ;
   uint32_t ssi_trapno ;
   int32_t ssi_status ;
   int32_t ssi_int ;
   uint64_t ssi_ptr ;
   uint64_t ssi_utime ;
   uint64_t ssi_stime ;
   uint64_t ssi_addr ;
   uint16_t ssi_addr_lsb ;
   uint16_t __pad2 ;
   int32_t ssi_syscall ;
   uint64_t ssi_call_addr ;
   uint32_t ssi_arch ;
   uint8_t __pad[28] ;
};
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
struct brubeck_tags_t {
   uint32_t num_tag_sets ;
   ck_ht_t table ;
   pthread_mutex_t write_mutex ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
union __anonunion_x_375160861 {
   int L ;
   float F ;
};
typedef long __int64_t;
typedef __int64_t int64_t;
enum rd_kafka_type_t {
    RD_KAFKA_PRODUCER = 0,
    RD_KAFKA_CONSUMER = 1
} ;
typedef enum rd_kafka_type_t rd_kafka_type_t;
struct rd_kafka_topic_s ;
typedef struct rd_kafka_topic_s rd_kafka_topic_t;
struct rd_kafka_conf_s ;
typedef struct rd_kafka_conf_s rd_kafka_conf_t;
enum __anonenum_rd_kafka_resp_err_t_686298611 {
    RD_KAFKA_RESP_ERR__BEGIN = -200,
    RD_KAFKA_RESP_ERR__BAD_MSG = -199,
    RD_KAFKA_RESP_ERR__BAD_COMPRESSION = -198,
    RD_KAFKA_RESP_ERR__DESTROY = -197,
    RD_KAFKA_RESP_ERR__FAIL = -196,
    RD_KAFKA_RESP_ERR__TRANSPORT = -195,
    RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = -194,
    RD_KAFKA_RESP_ERR__RESOLVE = -193,
    RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = -192,
    RD_KAFKA_RESP_ERR__PARTITION_EOF = -191,
    RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = -190,
    RD_KAFKA_RESP_ERR__FS = -189,
    RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = -188,
    RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = -187,
    RD_KAFKA_RESP_ERR__INVALID_ARG = -186,
    RD_KAFKA_RESP_ERR__TIMED_OUT = -185,
    RD_KAFKA_RESP_ERR__QUEUE_FULL = -184,
    RD_KAFKA_RESP_ERR__ISR_INSUFF = -183,
    RD_KAFKA_RESP_ERR__NODE_UPDATE = -182,
    RD_KAFKA_RESP_ERR__SSL = -181,
    RD_KAFKA_RESP_ERR__WAIT_COORD = -180,
    RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = -179,
    RD_KAFKA_RESP_ERR__IN_PROGRESS = -178,
    RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = -177,
    RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = -176,
    RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = -175,
    RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = -174,
    RD_KAFKA_RESP_ERR__CONFLICT = -173,
    RD_KAFKA_RESP_ERR__STATE = -172,
    RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = -171,
    RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = -170,
    RD_KAFKA_RESP_ERR__AUTHENTICATION = -169,
    RD_KAFKA_RESP_ERR__NO_OFFSET = -168,
    RD_KAFKA_RESP_ERR__OUTDATED = -167,
    RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = -166,
    RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = -165,
    RD_KAFKA_RESP_ERR__WAIT_CACHE = -164,
    RD_KAFKA_RESP_ERR__INTR = -163,
    RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = -162,
    RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = -161,
    RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = -160,
    RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = -159,
    RD_KAFKA_RESP_ERR__PARTIAL = -158,
    RD_KAFKA_RESP_ERR__READ_ONLY = -157,
    RD_KAFKA_RESP_ERR__NOENT = -156,
    RD_KAFKA_RESP_ERR__UNDERFLOW = -155,
    RD_KAFKA_RESP_ERR__INVALID_TYPE = -154,
    RD_KAFKA_RESP_ERR__RETRY = -153,
    RD_KAFKA_RESP_ERR__PURGE_QUEUE = -152,
    RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = -151,
    RD_KAFKA_RESP_ERR__FATAL = -150,
    RD_KAFKA_RESP_ERR__INCONSISTENT = -149,
    RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = -148,
    RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = -147,
    RD_KAFKA_RESP_ERR__END = -100,
    RD_KAFKA_RESP_ERR_UNKNOWN = -1,
    RD_KAFKA_RESP_ERR_NO_ERROR = 0,
    RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,
    RD_KAFKA_RESP_ERR_INVALID_MSG = 2,
    RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,
    RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,
    RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,
    RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,
    RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,
    RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,
    RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,
    RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,
    RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,
    RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,
    RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,
    RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,
    RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,
    RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,
    RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,
    RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,
    RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,
    RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,
    RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,
    RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,
    RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,
    RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,
    RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,
    RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,
    RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,
    RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,
    RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,
    RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,
    RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,
    RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,
    RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,
    RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,
    RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,
    RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,
    RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,
    RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,
    RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,
    RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,
    RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,
    RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,
    RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,
    RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,
    RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,
    RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,
    RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,
    RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,
    RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,
    RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,
    RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,
    RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,
    RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,
    RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,
    RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,
    RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,
    RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,
    RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,
    RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,
    RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,
    RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,
    RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,
    RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,
    RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,
    RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,
    RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,
    RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,
    RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,
    RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,
    RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,
    RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,
    RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,
    RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,
    RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,
    RD_KAFKA_RESP_ERR_END_ALL = 82
} ;
typedef enum __anonenum_rd_kafka_resp_err_t_686298611 rd_kafka_resp_err_t;
struct rd_kafka_message_s {
   rd_kafka_resp_err_t err ;
   rd_kafka_topic_t *rkt ;
   int32_t partition ;
   void *payload ;
   size_t len ;
   void *key ;
   size_t key_len ;
   int64_t offset ;
   void *_private ;
};
typedef struct rd_kafka_message_s rd_kafka_message_t;
enum __anonenum_rd_kafka_conf_res_t_437023812 {
    RD_KAFKA_CONF_UNKNOWN = -2,
    RD_KAFKA_CONF_INVALID = -1,
    RD_KAFKA_CONF_OK = 0
} ;
typedef enum __anonenum_rd_kafka_conf_res_t_437023812 rd_kafka_conf_res_t;
/* compiler builtin:
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-8TwwMzIi.i","-g,-Wall,-O3,-Wno-strict-aliasing")
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg )
{


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 )
{


  {
  return (__thread1 == __thread2);
}
}
extern FILE *stdin ;
extern FILE *stdout ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
extern int puts(char const   *__s ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg )
{
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void)
{
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp )
{
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void)
{
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c )
{
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream )
{
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c )
{
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream )
{


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream )
{


  {
  return ((__stream->_flags & 32) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr )
{
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr )
{
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr )
{
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) )
{
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr )
{
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf )
{
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf )
{
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf )
{
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag )
{
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev )
{
  int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev )
{
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
extern char *optarg ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __strtol_internal)(char const   * __restrict  __nptr ,
                                                                                               char ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                      char ** __restrict  endptr ,
                                                                      int base )
{
  long tmp ;

  {
  tmp = __strtol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __strtoul_internal)(char const   * __restrict  __nptr ,
                                                                                                         char ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                       char ** __restrict  endptr ,
                                                                       int base )
{
  unsigned long tmp ;

  {
  tmp = __strtoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __wcstol_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                               __gwchar_t ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                      __gwchar_t ** __restrict  endptr ,
                                                                      int base )
{
  long tmp ;

  {
  tmp = __wcstol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __wcstoul_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                                         __gwchar_t ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                       __gwchar_t ** __restrict  endptr ,
                                                                       int base )
{
  unsigned long tmp ;

  {
  tmp = __wcstoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
void gh_log_open(char const   *path ) ;
int brubeck_server_run(struct brubeck_server *server ) ;
void brubeck_server_init(struct brubeck_server *server , char const   *config ) ;
void initproctitle(int argc , char **argv ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc ,
                                                                                          char * const  *___argv ,
                                                                                          char const   *__shortopts ,
                                                                                          struct option  const  *__longopts ,
                                                                                          int *__longind ) ;
int main(int argc , char **argv ) ;
static struct option longopts[5]  = {      {"log", 1, (int *)((void *)0), 'l'},
        {"config", 1, (int *)((void *)0), 'c'},
        {"version", 0, (int *)((void *)0), 'v'},
        {"no-setproctitle", 0, (int *)((void *)0), 'n'},
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
int main(int argc , char **argv )
{
  struct brubeck_server server ;
  char const   *config_file ;
  char const   *log_file ;
  int opt ;
  int tmp ;

  {
  memset((void *)(& server), 0, sizeof(struct brubeck_server ));
  server.set_proctitle = (_Bool)1;
  config_file = "config.default.json";
  log_file = (char const   *)((void *)0);
  while (1) {
    opt = getopt_long(argc, (char * const  *)argv, ":l:c:vn", (struct option  const  *)(longopts),
                      (int *)((void *)0));
    if (! (opt != -1)) {
      break;
    }
    switch (opt) {
    case 108:
    log_file = (char const   *)optarg;
    break;
    case 99:
    config_file = (char const   *)optarg;
    break;
    case 118:
    puts("brubeck f306c25");
    return (0);
    case 110:
    server.set_proctitle = (_Bool)0;
    break;
    default:
    printf((char const   * __restrict  )"Usage: %s [--log LOG_FILE] [--config CONFIG_FILE] [--version] [--no-setproctitle] \n",
           *(argv + 0));
    return (1);
    }
  }
  if (server.set_proctitle) {
    initproctitle(argc, argv);
  }
  gh_log_open(log_file);
  brubeck_server_init(& server, config_file);
  tmp = brubeck_server_run(& server);
  return (tmp);
}
}
/* compiler builtin:
   _Bool __atomic_compare_exchange_n(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_load_n(...) ;  */
/* compiler builtin:
   _Bool __sync_bool_compare_and_swap(...) ;  */
#pragma merger("0","/tmp/cil-T8jZ3Ufp.i","-g,-Wall,-O3,-Wno-strict-aliasing")
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec  const  *__req ,
                           struct timespec *__rem ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format
                   , ...) ;
void brubeck_backend_run_threaded(struct brubeck_backend *self ) ;
void brubeck_backend_register_metric(struct brubeck_backend *self , struct brubeck_metric *metric ) ;
 __attribute__((__noreturn__)) void gh_log_die(void) ;
void brubeck_metric_sample(struct brubeck_metric *metric , void (*cb)(struct brubeck_metric  const  *metric ,
                                                                      char const   *key ,
                                                                      value_t value ,
                                                                      void *backend ) ,
                           void *backend ) ;
__inline static uint8_t const   brubeck_metric_get_state(struct brubeck_metric  const  *metric )
{
  uint8_t tmp ;

  {
  tmp = (uint8_t )__atomic_load_n(& metric->private_state, 5);
  return (tmp);
}
}
__inline static _Bool brubeck_metric_set_state_if_equal(struct brubeck_metric *metric ,
                                                        uint8_t expected , uint8_t const   state )
{
  _Bool tmp ;

  {
  tmp = __atomic_compare_exchange_n(& metric->private_state, & expected, (int const   )state,
                                    0, 5, 5);
  return (tmp);
}
}
void brubeck_backend_register_metric(struct brubeck_backend *self , struct brubeck_metric *metric )
{
  struct brubeck_metric *next ;
  _Bool tmp ;

  {
  while (1) {
    next = self->queue;
    metric->next = next;
    tmp = __sync_bool_compare_and_swap(& self->queue, next, metric);
    if (tmp) {
      break;
    }
  }
  return;
}
}
static void *backend__thread(void *_ptr )
{
  struct brubeck_backend *self ;
  struct timespec now ;
  struct timespec then ;
  struct brubeck_metric *mt ;
  uint8_t state ;
  uint8_t tmp ;
  int tmp___0 ;

  {
  self = (struct brubeck_backend *)_ptr;
  while (1) {
    clock_gettime(1, & then);
    then.tv_sec += (__time_t )self->sample_freq;
    tmp___0 = (*(self->connect))((void *)self);
    if (! tmp___0) {
      clock_gettime(0, & now);
      self->tick_time = (uint32_t )now.tv_sec;
      mt = self->queue;
      while (mt) {
        tmp = (uint8_t )brubeck_metric_get_state((struct brubeck_metric  const  *)mt);
        state = (uint8_t )tmp;
        if ((int )state == 2) {
          brubeck_metric_sample(mt, self->sample, (void *)self);
          brubeck_metric_set_state_if_equal(mt, state, (uint8_t const   )1);
        } else
        if ((int )state == 1) {
          brubeck_metric_sample(mt, self->sample, (void *)self);
          brubeck_metric_set_state_if_equal(mt, state, (uint8_t const   )0);
        }
        mt = mt->next;
      }
      if (self->flush) {
        (*(self->flush))((void *)self);
      }
    }
    clock_nanosleep(1, 1, (struct timespec  const  *)(& then), (struct timespec *)((void *)0));
  }
  return ((void *)0);
}
}
void brubeck_backend_run_threaded(struct brubeck_backend *self )
{
  int tmp ;

  {
  tmp = pthread_create((pthread_t * __restrict  )(& self->thread), (pthread_attr_t const   * __restrict  )((void *)0),
                       & backend__thread, (void * __restrict  )self);
  if (tmp != 0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: failed to start backend thread\n");
      gh_log_die();
      break;
    }
  }
  return;
}
}
#pragma merger("0","/tmp/cil-zlMayhUp.i","-g,-Wall,-O3,-Wno-strict-aliasing")
__inline static __uint32_t __bswap_32(__uint32_t __bsx )
{


  {
  return (((((__bsx & 4278190080U) >> 24) | ((__bsx & 16711680U) >> 8)) | ((__bsx & 65280U) << 8)) | ((__bsx & 255U) << 24));
}
}
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern int close(int __fd ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern int json_unpack_ex(json_t *root , json_error_t *error , size_t flags , char const   *fmt
                          , ...) ;
struct brubeck_backend *brubeck_carbon_new(struct brubeck_server *server , json_t *settings ,
                                           int shard_n ) ;
char const   *gh_log_instance(void) ;
void ( /* format attribute */  gh_log_write)(char const   *message  , ...) ;
void url_to_inaddr2(struct sockaddr_in *addr , char const   *url , int port ) ;
void sock_enlarge_out(int fd ) ;
int brubeck_itoa(char *ptr , uint64_t number ) ;
int brubeck_ftoa(char *outbuf , float f ) ;
__inline static void *xcalloc(size_t n , size_t size )
{
  void *ptr ;
  void *tmp ;
  long tmp___0 ;

  {
  tmp = calloc(n, size);
  ptr = tmp;
  tmp___0 = __builtin_expect((long )((unsigned long )ptr == (unsigned long )((void *)0)),
                             0L);
  if (tmp___0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: oom\n");
      gh_log_die();
      break;
    }
  }
  return (ptr);
}
}
__inline static ssize_t xwrite(int fd , void const   *buf , size_t len )
{
  ssize_t nr ;
  int *tmp ;
  int *tmp___0 ;

  {
  while (1) {
    nr = write(fd, buf, len);
    if (nr < 0L) {
      tmp = __errno_location();
      if (*tmp == 11) {
        continue;
      } else {
        tmp___0 = __errno_location();
        if (*tmp___0 == 4) {
          continue;
        }
      }
    }
    return (nr);
  }
}
}
__inline static ssize_t write_in_full(int fd , void const   *buf , size_t count )
{
  char const   *p ;
  ssize_t total ;
  ssize_t written ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  p = (char const   *)buf;
  total = (ssize_t )0;
  while (count > 0UL) {
    tmp = xwrite(fd, (void const   *)p, count);
    written = tmp;
    if (written < 0L) {
      return ((ssize_t )-1);
    }
    if (! written) {
      tmp___0 = __errno_location();
      *tmp___0 = 28;
      return ((ssize_t )-1);
    }
    count -= (size_t )written;
    p += written;
    total += written;
  }
  return (total);
}
}
static _Bool carbon_is_connected(void *backend )
{
  struct brubeck_carbon *self ;

  {
  self = (struct brubeck_carbon *)backend;
  return ((_Bool )(self->out_sock >= 0));
}
}
static int carbon_connect(void *backend )
{
  struct brubeck_carbon *self ;
  _Bool tmp ;
  int rc ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char const   *tmp___5 ;

  {
  self = (struct brubeck_carbon *)backend;
  tmp = carbon_is_connected((void *)self);
  if (tmp) {
    return (0);
  }
  self->out_sock = socket(2, 1, 6);
  if (self->out_sock >= 0) {
    tmp___0 = connect(self->out_sock, (struct sockaddr  const  *)((struct sockaddr *)(& self->out_sockaddr)),
                      (socklen_t )sizeof(self->out_sockaddr));
    rc = tmp___0;
    if (rc == 0) {
      tmp___1 = gh_log_instance();
      gh_log_write("instance=%s backend=carbon event=connected\n", tmp___1);
      sock_enlarge_out(self->out_sock);
      return (0);
    }
    close(self->out_sock);
    self->out_sock = -1;
  }
  tmp___2 = __errno_location();
  tmp___3 = strerror(*tmp___2);
  tmp___4 = __errno_location();
  tmp___5 = gh_log_instance();
  gh_log_write("instance=%s backend=carbon event=failed_to_connect errno=%d msg=\"%s\"\n",
               tmp___5, *tmp___4, tmp___3);
  return (-1);
}
}
static void carbon_disconnect(struct brubeck_carbon *self )
{
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;

  {
  tmp = __errno_location();
  tmp___0 = strerror(*tmp);
  tmp___1 = __errno_location();
  tmp___2 = gh_log_instance();
  gh_log_write("instance=%s backend=carbon event=disconnected errno=%d msg=\"%s\"\n",
               tmp___2, *tmp___1, tmp___0);
  close(self->out_sock);
  self->out_sock = -1;
  return;
}
}
static void plaintext_each(struct brubeck_metric  const  *metric , char const   *key ,
                           value_t value , void *backend )
{
  struct brubeck_carbon *carbon ;
  char buffer[1024] ;
  char *ptr ;
  size_t key_len ;
  size_t tmp ;
  ssize_t wr ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  carbon = (struct brubeck_carbon *)backend;
  ptr = buffer;
  tmp = strlen(key);
  key_len = tmp;
  tmp___0 = carbon_is_connected((void *)carbon);
  if (! tmp___0) {
    return;
  }
  tmp___1 = strchr(key, ' ');
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
    return;
  }
  memcpy((void * __restrict  )ptr, (void const   * __restrict  )key, key_len);
  ptr += key_len;
  tmp___2 = ptr;
  ptr ++;
  *tmp___2 = (char )' ';
  tmp___3 = brubeck_ftoa(ptr, (float )value);
  ptr += tmp___3;
  tmp___4 = ptr;
  ptr ++;
  *tmp___4 = (char )' ';
  tmp___5 = brubeck_itoa(ptr, (uint64_t )carbon->backend.tick_time);
  ptr += tmp___5;
  tmp___6 = ptr;
  ptr ++;
  *tmp___6 = (char )'\n';
  wr = write_in_full(carbon->out_sock, (void const   *)(buffer), (size_t )(ptr - buffer));
  if (wr < 0L) {
    carbon_disconnect(carbon);
    return;
  }
  carbon->bytes_sent += (size_t )wr;
  return;
}
}
__inline static size_t pickle1_int32(char *ptr , void *_src )
{


  {
  *ptr = (char )'J';
  memcpy((void * __restrict  )(ptr + 1), (void const   * __restrict  )_src, (size_t )4);
  return ((size_t )5);
}
}
__inline static size_t pickle1_double(char *ptr , void *_src )
{
  uint8_t *source ;
  char *tmp ;

  {
  source = (uint8_t *)_src;
  tmp = ptr;
  ptr ++;
  *tmp = (char )'G';
  *(ptr + 0) = (char )*(source + 7);
  *(ptr + 1) = (char )*(source + 6);
  *(ptr + 2) = (char )*(source + 5);
  *(ptr + 3) = (char )*(source + 4);
  *(ptr + 4) = (char )*(source + 3);
  *(ptr + 5) = (char )*(source + 2);
  *(ptr + 6) = (char )*(source + 1);
  *(ptr + 7) = (char )*(source + 0);
  return ((size_t )9);
}
}
static void pickle1_push(struct pickler *buf , char const   *key , uint8_t key_len ,
                         uint32_t timestamp , value_t value )
{
  char *ptr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  uint16_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  uint16_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  uint16_t tmp___15 ;

  {
  ptr = buf->ptr + (int )buf->pos;
  tmp = ptr;
  ptr ++;
  *tmp = (char )'(';
  tmp___0 = ptr;
  ptr ++;
  *tmp___0 = (char )'U';
  tmp___1 = ptr;
  ptr ++;
  *tmp___1 = (char )key_len;
  memcpy((void * __restrict  )ptr, (void const   * __restrict  )key, (size_t )key_len);
  ptr += (int )key_len;
  tmp___2 = ptr;
  ptr ++;
  *tmp___2 = (char )'q';
  tmp___3 = ptr;
  ptr ++;
  tmp___4 = buf->pt;
  buf->pt = (uint16_t )((int )buf->pt + 1);
  *tmp___3 = (char )tmp___4;
  tmp___5 = ptr;
  ptr ++;
  *tmp___5 = (char )'(';
  tmp___6 = pickle1_int32(ptr, (void *)(& timestamp));
  ptr += tmp___6;
  tmp___7 = pickle1_double(ptr, (void *)(& value));
  ptr += tmp___7;
  tmp___8 = ptr;
  ptr ++;
  *tmp___8 = (char )'t';
  tmp___9 = ptr;
  ptr ++;
  *tmp___9 = (char )'q';
  tmp___10 = ptr;
  ptr ++;
  tmp___11 = buf->pt;
  buf->pt = (uint16_t )((int )buf->pt + 1);
  *tmp___10 = (char )tmp___11;
  tmp___12 = ptr;
  ptr ++;
  *tmp___12 = (char )'t';
  tmp___13 = ptr;
  ptr ++;
  *tmp___13 = (char )'q';
  tmp___14 = ptr;
  ptr ++;
  tmp___15 = buf->pt;
  buf->pt = (uint16_t )((int )buf->pt + 1);
  *tmp___14 = (char )tmp___15;
  buf->pos = (uint16_t )(ptr - buf->ptr);
  return;
}
}
__inline static void pickle1_init(struct pickler *buf ) ;
static uint8_t const   lead[4]  = {      (uint8_t const   )']',      (uint8_t const   )'q',      (uint8_t const   )0,      (uint8_t const   )'('};
__inline static void pickle1_init(struct pickler *buf )
{


  {
  memcpy((void * __restrict  )(buf->ptr + 4), (void const   * __restrict  )(lead),
         sizeof(lead));
  buf->pos = (uint16_t )(4UL + sizeof(lead));
  buf->pt = (uint16_t )1;
  return;
}
}
static void pickle1_flush(void *backend ) ;
static uint8_t const   trail[2]  = {      (uint8_t const   )'e',      (uint8_t const   )'.'};
static void pickle1_flush(void *backend )
{
  struct brubeck_carbon *carbon ;
  struct pickler *buf ;
  uint32_t *buf_lead ;
  ssize_t wr ;
  _Bool tmp ;

  {
  carbon = (struct brubeck_carbon *)backend;
  buf = & carbon->pickler;
  if ((int )buf->pt == 1) {
    return;
  } else {
    tmp = carbon_is_connected((void *)carbon);
    if (! tmp) {
      return;
    }
  }
  memcpy((void * __restrict  )(buf->ptr + (int )buf->pos), (void const   * __restrict  )(trail),
         sizeof(trail));
  buf->pos = (uint16_t )((unsigned long )buf->pos + sizeof(trail));
  buf_lead = (uint32_t *)buf->ptr;
  *buf_lead = __bswap_32((uint32_t )buf->pos - 4U);
  wr = write_in_full(carbon->out_sock, (void const   *)buf->ptr, (size_t )buf->pos);
  pickle1_init(& carbon->pickler);
  if (wr < 0L) {
    carbon_disconnect(carbon);
    return;
  }
  carbon->bytes_sent += (size_t )wr;
  return;
}
}
static void pickle1_each(struct brubeck_metric  const  *metric , char const   *key ,
                         value_t value , void *backend )
{
  struct brubeck_carbon *carbon ;
  char *tmp ;
  uint8_t key_len ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  carbon = (struct brubeck_carbon *)backend;
  tmp = strchr(key, ' ');
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    return;
  }
  tmp___0 = strlen(key);
  key_len = (uint8_t )tmp___0;
  if ((int )carbon->pickler.pos + (32 + (int )key_len) >= 4096) {
    pickle1_flush((void *)carbon);
  }
  tmp___1 = carbon_is_connected((void *)carbon);
  if (! tmp___1) {
    return;
  }
  pickle1_push(& carbon->pickler, key, key_len, carbon->backend.tick_time, value);
  return;
}
}
struct brubeck_backend *brubeck_carbon_new(struct brubeck_server *server , json_t *settings ,
                                           int shard_n )
{
  struct brubeck_carbon *carbon ;
  void *tmp ;
  char *address ;
  int port ;
  int frequency ;
  int pickle ;
  json_error_t _error_j ;
  int tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;

  {
  tmp = xcalloc((size_t )1, sizeof(struct brubeck_carbon ));
  carbon = (struct brubeck_carbon *)tmp;
  pickle = 0;
  tmp___0 = json_unpack_ex(settings, & _error_j, (size_t )0, "{s:s, s:i, s?:b, s:i}",
                           "address", & address, "port", & port, "pickle", & pickle,
                           "frequency", & frequency);
  if (tmp___0 < 0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: config error: %s\n",
              _error_j.text);
      gh_log_die();
      break;
    }
  }
  carbon->backend.type = (enum brubeck_backend_t )0;
  carbon->backend.shard_n = shard_n;
  carbon->backend.connect = & carbon_connect;
  carbon->backend.is_connected = & carbon_is_connected;
  if (pickle) {
    carbon->backend.sample = & pickle1_each;
    carbon->backend.flush = & pickle1_flush;
    tmp___1 = malloc((size_t )4096);
    carbon->pickler.ptr = (char *)tmp___1;
    pickle1_init(& carbon->pickler);
  } else {
    carbon->backend.sample = & plaintext_each;
    carbon->backend.flush = (void (*)(void * ))((void *)0);
  }
  carbon->backend.sample_freq = frequency;
  carbon->backend.server = server;
  carbon->out_sock = -1;
  url_to_inaddr2(& carbon->out_sockaddr, (char const   *)address, port);
  brubeck_backend_run_threaded((struct brubeck_backend *)carbon);
  tmp___2 = gh_log_instance();
  gh_log_write("instance=%s backend=carbon event=started\n", tmp___2);
  return ((struct brubeck_backend *)carbon);
}
}
#pragma merger("0","/tmp/cil-y2Ag7fam.i","-g,-Wall,-O3,-Wno-strict-aliasing")
extern  __attribute__((__nothrow__)) double log(double __x ) ;
extern  __attribute__((__nothrow__)) double ceil(double __x )  __attribute__((__const__)) ;
int multibloom_check(struct multibloom *bloom , int f , uint32_t a , uint32_t b ) ;
void multibloom_reset(struct multibloom *bloom , int f ) ;
struct multibloom *multibloom_new(int filters , int entries , double error ) ;
__inline static void *xmalloc(size_t size )
{
  void *ptr ;
  void *tmp ;
  long tmp___0 ;

  {
  tmp = malloc(size);
  ptr = tmp;
  tmp___0 = __builtin_expect((long )((unsigned long )ptr == (unsigned long )((void *)0)),
                             0L);
  if (tmp___0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: oom\n");
      gh_log_die();
      break;
    }
  }
  return (ptr);
}
}
int multibloom_check(struct multibloom *bloom , int f , uint32_t a , uint32_t b )
{
  unsigned char *filter ;
  int hits ;
  uint32_t x ;
  uint32_t i ;
  uint32_t byte ;
  uint32_t mask ;
  unsigned char c ;

  {
  filter = bloom->filters[f];
  hits = 0;
  i = (uint32_t )0;
  while (i < (uint32_t )bloom->hashes) {
    x = (a + i * b) % (unsigned int )bloom->bits;
    byte = x >> 3;
    c = *(filter + byte);
    mask = (uint32_t )(1 << x % 8U);
    if ((unsigned int )c & mask) {
      hits ++;
    } else {
      *(filter + byte) = (unsigned char )((unsigned int )c | mask);
    }
    i ++;
  }
  return (hits == bloom->hashes);
}
}
void multibloom_reset(struct multibloom *bloom , int f )
{


  {
  memset((void *)bloom->filters[f], 0, (size_t )bloom->bytes);
  return;
}
}
struct multibloom *multibloom_new(int filters , int entries , double error )
{
  double bpe ;
  double tmp ;
  int i ;
  struct multibloom *bloom ;
  void *tmp___0 ;
  double tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;

  {
  tmp = log(error);
  bpe = - (tmp / 0.480453013918201);
  tmp___0 = xmalloc(sizeof(struct multibloom ) + (unsigned long )filters * sizeof(void *));
  bloom = (struct multibloom *)tmp___0;
  bloom->bits = (int )((double )entries * bpe);
  bloom->bytes = bloom->bits / 8;
  if (bloom->bits % 8) {
    (bloom->bytes) ++;
  }
  tmp___1 = ceil(0.693147180559945 * bpe);
  bloom->hashes = (int )tmp___1;
  i = 0;
  while (i < filters) {
    tmp___2 = xcalloc((size_t )1, (size_t )bloom->bytes);
    bloom->filters[i] = (unsigned char *)tmp___2;
    i ++;
  }
  tmp___3 = gh_log_instance();
  gh_log_write("instance=%s event=bloom_init entries=%d error=%f bits=%d bpe=%f bytes=%d hash_funcs=%d\n",
               tmp___3, entries, error, bloom->bits, bpe, bloom->bytes, bloom->hashes);
  return (bloom);
}
}
#pragma merger("0","/tmp/cil-k2IZGjBH.i","-g,-Wall,-O3,-Wno-strict-aliasing")
static uint32_t read32(char const   *p )
{
  uint32_t result ;

  {
  memcpy((void * __restrict  )(& result), (void const   * __restrict  )p, sizeof(result));
  return (result);
}
}
static unsigned int const   c1  =    (uint32_t const   )3432918353U;
static unsigned int const   c2  =    (uint32_t const   )461845907;
static uint32_t fmix(uint32_t h )
{


  {
  h ^= h >> 16;
  h *= 2246822507U;
  h ^= h >> 13;
  h *= 3266489909U;
  h ^= h >> 16;
  return (h);
}
}
static uint32_t ror32(uint32_t val , int shift )
{
  uint32_t tmp ;

  {
  if (shift == 0) {
    tmp = val;
  } else {
    tmp = (val >> shift) | (val << (32 - shift));
  }
  return (tmp);
}
}
static uint32_t mur(uint32_t a , uint32_t h )
{


  {
  a *= (uint32_t )c1;
  a = ror32(a, 17);
  a *= (uint32_t )c2;
  h ^= a;
  h = ror32(h, 19);
  return (h * 5U + 3864292196U);
}
}
static uint32_t Hash32Len13to24(char const   *s , size_t len )
{
  uint32_t a ;
  uint32_t tmp ;
  uint32_t b ;
  uint32_t tmp___0 ;
  uint32_t c ;
  uint32_t tmp___1 ;
  uint32_t d ;
  uint32_t tmp___2 ;
  uint32_t e ;
  uint32_t tmp___3 ;
  uint32_t f ;
  uint32_t tmp___4 ;
  uint32_t h ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;

  {
  tmp = read32((s - 4) + (len >> 1));
  a = tmp;
  tmp___0 = read32(s + 4);
  b = tmp___0;
  tmp___1 = read32((s + len) - 8);
  c = tmp___1;
  tmp___2 = read32(s + (len >> 1));
  d = tmp___2;
  tmp___3 = read32(s);
  e = tmp___3;
  tmp___4 = read32((s + len) - 4);
  f = tmp___4;
  h = (uint32_t )len;
  tmp___5 = mur(a, h);
  tmp___6 = mur(b, tmp___5);
  tmp___7 = mur(c, tmp___6);
  tmp___8 = mur(d, tmp___7);
  tmp___9 = mur(e, tmp___8);
  tmp___10 = mur(f, tmp___9);
  tmp___11 = fmix(tmp___10);
  return (tmp___11);
}
}
static uint32_t Hash32Len0to4(char const   *s , size_t len )
{
  uint32_t b ;
  uint32_t c ;
  int i ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
  b = (uint32_t )0;
  c = (uint32_t )9;
  i = 0;
  while ((size_t )i < len) {
    b = b * (uint32_t )c1 + (uint32_t )*(s + i);
    c ^= b;
    i ++;
  }
  tmp = mur((uint32_t )len, c);
  tmp___0 = mur(b, tmp);
  tmp___1 = fmix(tmp___0);
  return (tmp___1);
}
}
static uint32_t Hash32Len5to12(char const   *s , size_t len )
{
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;

  {
  a = (uint32_t )len;
  b = (uint32_t )(len * 5UL);
  c = (uint32_t )9;
  d = b;
  tmp = read32(s);
  a += tmp;
  tmp___0 = read32((s + len) - 4);
  b += tmp___0;
  tmp___1 = read32(s + ((len >> 1) & 4UL));
  c += tmp___1;
  tmp___2 = mur(a, d);
  tmp___3 = mur(b, tmp___2);
  tmp___4 = mur(c, tmp___3);
  tmp___5 = fmix(tmp___4);
  return (tmp___5);
}
}
uint32_t CityHash32(char const   *s , size_t len )
{
  size_t iters ;
  uint32_t a0 ;
  uint32_t a1 ;
  uint32_t a2 ;
  uint32_t a3 ;
  uint32_t a4 ;
  uint32_t h ;
  uint32_t g ;
  uint32_t f ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t a0___0 ;
  uint32_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t a1___0 ;
  uint32_t tmp___16 ;
  uint32_t a2___0 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t a3___0 ;
  uint32_t tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t a4___0 ;
  uint32_t tmp___21 ;
  __uint32_t tmp___22 ;
  uint32_t aux ;
  uint32_t aux___0 ;
  uint32_t tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t tmp___27 ;
  uint32_t tmp___28 ;

  {
  if (len <= 24UL) {
    if (len <= 12UL) {
      if (len <= 4UL) {
        tmp = Hash32Len0to4(s, len);
        tmp___1 = tmp;
      } else {
        tmp___0 = Hash32Len5to12(s, len);
        tmp___1 = tmp___0;
      }
      tmp___3 = tmp___1;
    } else {
      tmp___2 = Hash32Len13to24(s, len);
      tmp___3 = tmp___2;
    }
    return (tmp___3);
  }
  h = (uint32_t )len;
  g = (uint32_t )((size_t )c1 * len);
  f = g;
  tmp___4 = read32((s + len) - 4);
  tmp___5 = ror32(tmp___4 * (uint32_t )c1, 17);
  a0 = tmp___5 * (uint32_t )c2;
  tmp___6 = read32((s + len) - 8);
  tmp___7 = ror32(tmp___6 * (uint32_t )c1, 17);
  a1 = tmp___7 * (uint32_t )c2;
  tmp___8 = read32((s + len) - 16);
  tmp___9 = ror32(tmp___8 * (uint32_t )c1, 17);
  a2 = tmp___9 * (uint32_t )c2;
  tmp___10 = read32((s + len) - 12);
  tmp___11 = ror32(tmp___10 * (uint32_t )c1, 17);
  a3 = tmp___11 * (uint32_t )c2;
  tmp___12 = read32((s + len) - 20);
  tmp___13 = ror32(tmp___12 * (uint32_t )c1, 17);
  a4 = tmp___13 * (uint32_t )c2;
  h ^= a0;
  h = ror32(h, 19);
  h = h * 5U + 3864292196U;
  h ^= a2;
  h = ror32(h, 19);
  h = h * 5U + 3864292196U;
  g ^= a1;
  g = ror32(g, 19);
  g = g * 5U + 3864292196U;
  g ^= a3;
  g = ror32(g, 19);
  g = g * 5U + 3864292196U;
  f += a4;
  f = ror32(f, 19);
  f = f * 5U + 3864292196U;
  iters = (len - 1UL) / 20UL;
  while (1) {
    tmp___14 = read32(s);
    tmp___15 = ror32(tmp___14 * (uint32_t )c1, 17);
    a0___0 = tmp___15 * (uint32_t )c2;
    tmp___16 = read32(s + 4);
    a1___0 = tmp___16;
    tmp___17 = read32(s + 8);
    tmp___18 = ror32(tmp___17 * (uint32_t )c1, 17);
    a2___0 = tmp___18 * (uint32_t )c2;
    tmp___19 = read32(s + 12);
    tmp___20 = ror32(tmp___19 * (uint32_t )c1, 17);
    a3___0 = tmp___20 * (uint32_t )c2;
    tmp___21 = read32(s + 16);
    a4___0 = tmp___21;
    h ^= a0___0;
    h = ror32(h, 18);
    h = h * 5U + 3864292196U;
    f += a1___0;
    f = ror32(f, 19);
    f *= (uint32_t )c1;
    g += a2___0;
    g = ror32(g, 18);
    g = g * 5U + 3864292196U;
    h ^= a3___0 + a1___0;
    h = ror32(h, 19);
    h = h * 5U + 3864292196U;
    g ^= a4___0;
    tmp___22 = __bswap_32(g);
    g = tmp___22 * 5U;
    h += a4___0 * 5U;
    h = __bswap_32(h);
    f += a0___0;
    while (1) {
      while (1) {
        aux = f;
        f = h;
        h = aux;
        break;
      }
      while (1) {
        aux___0 = f;
        f = g;
        g = aux___0;
        break;
      }
      break;
    }
    s += 20;
    iters --;
    if (! (iters != 0UL)) {
      break;
    }
  }
  tmp___23 = ror32(g, 11);
  g = tmp___23 * (uint32_t )c1;
  tmp___24 = ror32(g, 17);
  g = tmp___24 * (uint32_t )c1;
  tmp___25 = ror32(f, 11);
  f = tmp___25 * (uint32_t )c1;
  tmp___26 = ror32(f, 17);
  f = tmp___26 * (uint32_t )c1;
  h = ror32(h + g, 19);
  h = h * 5U + 3864292196U;
  tmp___27 = ror32(h, 17);
  h = tmp___27 * (uint32_t )c1;
  h = ror32(h + f, 19);
  h = h * 5U + 3864292196U;
  tmp___28 = ror32(h, 17);
  h = tmp___28 * (uint32_t )c1;
  return (h);
}
}
#pragma merger("0","/tmp/cil-m_WRfhSa.i","-g,-Wall,-O3,-Wno-strict-aliasing")
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
void brubeck_histo_push(struct brubeck_histo *histo , value_t value , value_t sample_freq ) ;
void brubeck_histo_sample(struct brubeck_histo_sample *sample , struct brubeck_histo *histo ) ;
__inline static void *xrealloc(void *ptr , size_t size )
{
  void *new_ptr ;
  void *tmp ;
  long tmp___0 ;

  {
  tmp = realloc(ptr, size);
  new_ptr = tmp;
  tmp___0 = __builtin_expect((long )((unsigned long )new_ptr == (unsigned long )((void *)0)),
                             0L);
  if (tmp___0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: oom\n");
      gh_log_die();
      break;
    }
  }
  return (new_ptr);
}
}
void brubeck_histo_push(struct brubeck_histo *histo , value_t value , value_t sample_freq )
{
  size_t new_size ;
  void *tmp ;
  uint16_t tmp___0 ;

  {
  histo->count = (uint32_t )((value_t )histo->count + sample_freq);
  if ((int )histo->size == (int )histo->alloc) {
    if ((int )histo->size == 65535) {
      return;
    }
    new_size = (size_t )((int )histo->alloc * 2);
    if (new_size > 65535UL) {
      new_size = (size_t )65535;
    }
    if (new_size < 16UL) {
      new_size = (size_t )16;
    }
    if (new_size != (size_t )histo->alloc) {
      histo->alloc = (uint16_t )new_size;
      tmp = xrealloc((void *)histo->values, (unsigned long )histo->alloc * sizeof(value_t ));
      histo->values = (value_t *)tmp;
    }
  }
  tmp___0 = histo->size;
  histo->size = (uint16_t )((int )histo->size + 1);
  *(histo->values + tmp___0) = value;
  return;
}
}
__inline static value_t histo_percentile(struct brubeck_histo *histo , float rank )
{
  size_t irank ;
  double tmp ;

  {
  tmp = floor((double )(rank * (float )histo->size + 0.5f));
  irank = (size_t )tmp;
  return (*(histo->values + (irank - 1UL)));
}
}
__inline static value_t histo_sum(struct brubeck_histo *histo )
{
  size_t i ;
  value_t sum ;

  {
  sum = 0.0;
  i = (size_t )0;
  while (i < (size_t )histo->size) {
    sum += *(histo->values + i);
    i ++;
  }
  return (sum);
}
}
static int value_cmp(void const   *a , void const   *b )
{
  value_t va ;
  value_t vb ;

  {
  va = (value_t )*((value_t const   *)a);
  vb = (value_t )*((value_t const   *)b);
  if (va < vb) {
    return (-1);
  }
  if (va > vb) {
    return (1);
  }
  return (0);
}
}
__inline static void histo_sort(struct brubeck_histo *histo )
{


  {
  qsort((void *)histo->values, (size_t )histo->size, sizeof(value_t ), & value_cmp);
  return;
}
}
void brubeck_histo_sample(struct brubeck_histo_sample *sample , struct brubeck_histo *histo )
{


  {
  if ((int )histo->size == 0) {
    memset((void *)sample, 0, sizeof(struct brubeck_histo_sample ));
    return;
  }
  histo_sort(histo);
  sample->sum = histo_sum(histo);
  sample->min = *(histo->values + 0);
  sample->max = *(histo->values + ((int )histo->size - 1));
  sample->mean = sample->sum / (value_t )histo->size;
  sample->median = histo_percentile(histo, 0.5f);
  sample->count = (value_t )histo->count;
  sample->percentile[0] = histo_percentile(histo, 0.75f);
  sample->percentile[1] = histo_percentile(histo, 0.95f);
  sample->percentile[2] = histo_percentile(histo, 0.98f);
  sample->percentile[3] = histo_percentile(histo, 0.99f);
  sample->percentile[4] = histo_percentile(histo, 0.999f);
  histo->size = (uint16_t )0;
  histo->count = (uint32_t )0;
  return;
}
}
#pragma merger("0","/tmp/cil-Pbz9Qb__.i","-g,-Wall,-O3,-Wno-strict-aliasing")
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
brubeck_hashtable_t *brubeck_hashtable_new(uint64_t const   size ) ;
void brubeck_hashtable_free(brubeck_hashtable_t *ht ) ;
struct brubeck_metric *brubeck_hashtable_find(brubeck_hashtable_t *ht , char const   *key ,
                                              uint16_t key_len ) ;
_Bool brubeck_hashtable_insert(brubeck_hashtable_t *ht , char const   *key , uint16_t key_len ,
                               struct brubeck_metric *val ) ;
size_t brubeck_hashtable_size(brubeck_hashtable_t *ht ) ;
void brubeck_hashtable_foreach(brubeck_hashtable_t *ht , void (*callback)(struct brubeck_metric * ,
                                                                          void * ) ,
                               void *payload ) ;
struct brubeck_metric **brubeck_hashtable_to_a(brubeck_hashtable_t *ht , size_t *length ) ;
__inline static void ck_ht_entry_key_set(ck_ht_entry_t *entry , void const   *key ,
                                         uint16_t key_length )  __attribute__((__unused__)) ;
__inline static void ck_ht_entry_key_set(ck_ht_entry_t *entry , void const   *key ,
                                         uint16_t key_length )
{


  {
  entry->key = (uintptr_t )key;
  entry->key_length = (uint64_t )key_length;
  return;
}
}
__inline static void *ck_ht_entry_value(ck_ht_entry_t *entry )  __attribute__((__unused__)) ;
__inline static void *ck_ht_entry_value(ck_ht_entry_t *entry )
{


  {
  return ((void *)entry->value);
}
}
__inline static void ck_ht_entry_set(struct ck_ht_entry *entry , ck_ht_hash_t h ,
                                     void const   *key , uint16_t key_length , void const   *value )  __attribute__((__unused__)) ;
__inline static void ck_ht_entry_set(struct ck_ht_entry *entry , ck_ht_hash_t h ,
                                     void const   *key , uint16_t key_length , void const   *value )
{


  {
  entry->key = (uintptr_t )key;
  entry->value = (uintptr_t )value;
  entry->key_length = (uint64_t )key_length;
  entry->hash = h.value;
  return;
}
}
extern _Bool ck_ht_next(ck_ht_t * , ck_ht_iterator_t * , ck_ht_entry_t **entry ) ;
extern void ck_ht_hash(ck_ht_hash_t * , ck_ht_t * , void const   * , uint16_t  ) ;
extern _Bool ck_ht_init(ck_ht_t * , unsigned int  , ck_ht_hash_cb_t * , struct ck_malloc * ,
                        uint64_t  , uint64_t  ) ;
extern _Bool ck_ht_put_spmc(ck_ht_t * , ck_ht_hash_t  , ck_ht_entry_t * ) ;
extern _Bool ck_ht_get_spmc(ck_ht_t * , ck_ht_hash_t  , ck_ht_entry_t * ) ;
extern uint64_t ck_ht_count(ck_ht_t * ) ;
static void *ht_malloc(size_t r )
{
  void *tmp ;

  {
  tmp = xmalloc(r);
  return (tmp);
}
}
static void ht_free(void *p , size_t b , _Bool r )
{


  {
  free(p);
  return;
}
}
static struct ck_malloc ALLOCATOR  =    {& ht_malloc, (void *(*)(void * , size_t  , size_t  , _Bool  ))0, & ht_free};
brubeck_hashtable_t *brubeck_hashtable_new(uint64_t const   size )
{
  brubeck_hashtable_t *ht ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  tmp = xmalloc(sizeof(brubeck_hashtable_t ));
  ht = (brubeck_hashtable_t *)tmp;
  pthread_mutex_init(& ht->write_mutex, (pthread_mutexattr_t const   *)((void *)0));
  tmp___0 = ck_ht_init(& ht->table, 2U, (ck_ht_hash_cb_t *)((void *)0), & ALLOCATOR,
                       (uint64_t )size, (uint64_t )3735928559U);
  if (! tmp___0) {
    free((void *)ht);
    return ((brubeck_hashtable_t *)((void *)0));
  }
  return (ht);
}
}
void brubeck_hashtable_free(brubeck_hashtable_t *ht )
{


  {
  return;
}
}
struct brubeck_metric *brubeck_hashtable_find(brubeck_hashtable_t *ht , char const   *key ,
                                              uint16_t key_len )
{
  ck_ht_hash_t h ;
  ck_ht_entry_t entry ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  ck_ht_hash(& h, & ht->table, (void const   *)key, key_len);
  ck_ht_entry_key_set(& entry, (void const   *)key, key_len);
  tmp___0 = ck_ht_get_spmc(& ht->table, h, & entry);
  if (tmp___0) {
    tmp = ck_ht_entry_value(& entry);
    return ((struct brubeck_metric *)tmp);
  }
  return ((struct brubeck_metric *)((void *)0));
}
}
_Bool brubeck_hashtable_insert(brubeck_hashtable_t *ht , char const   *key , uint16_t key_len ,
                               struct brubeck_metric *val )
{
  ck_ht_hash_t h ;
  ck_ht_entry_t entry ;
  _Bool result ;

  {
  ck_ht_hash(& h, & ht->table, (void const   *)key, key_len);
  ck_ht_entry_set(& entry, h, (void const   *)key, key_len, (void const   *)val);
  pthread_mutex_lock(& ht->write_mutex);
  result = ck_ht_put_spmc(& ht->table, h, & entry);
  pthread_mutex_unlock(& ht->write_mutex);
  return (result);
}
}
size_t brubeck_hashtable_size(brubeck_hashtable_t *ht )
{
  size_t len ;

  {
  pthread_mutex_lock(& ht->write_mutex);
  len = ck_ht_count(& ht->table);
  pthread_mutex_unlock(& ht->write_mutex);
  return (len);
}
}
void brubeck_hashtable_foreach(brubeck_hashtable_t *ht , void (*callback)(struct brubeck_metric * ,
                                                                          void * ) ,
                               void *payload )
{
  ck_ht_iterator_t iterator ;
  ck_ht_entry_t *entry ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  iterator.current = (struct ck_ht_entry *)((void *)0);
  iterator.offset = (uint64_t )0;
  pthread_mutex_lock(& ht->write_mutex);
  while (1) {
    tmp___0 = ck_ht_next(& ht->table, & iterator, & entry);
    if (! tmp___0) {
      break;
    }
    tmp = ck_ht_entry_value(entry);
    (*callback)((struct brubeck_metric *)tmp, payload);
  }
  pthread_mutex_unlock(& ht->write_mutex);
  return;
}
}
struct brubeck_metric **brubeck_hashtable_to_a(brubeck_hashtable_t *ht , size_t *length )
{
  ck_ht_iterator_t iterator ;
  ck_ht_entry_t *entry ;
  struct brubeck_metric **array ;
  size_t i ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  _Bool tmp___2 ;

  {
  iterator.current = (struct ck_ht_entry *)((void *)0);
  iterator.offset = (uint64_t )0;
  i = (size_t )0;
  pthread_mutex_lock(& ht->write_mutex);
  *length = ck_ht_count(& ht->table);
  tmp = xmalloc(*length * sizeof(void *));
  array = (struct brubeck_metric **)tmp;
  while (1) {
    tmp___2 = ck_ht_next(& ht->table, & iterator, & entry);
    if (! tmp___2) {
      break;
    }
    tmp___0 = i;
    i ++;
    tmp___1 = ck_ht_entry_value(entry);
    *(array + tmp___0) = (struct brubeck_metric *)tmp___1;
  }
  pthread_mutex_unlock(& ht->write_mutex);
  return (array);
}
}
/* compiler builtin:
   void __atomic_store_n(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_sub_fetch(...) ;  */
#pragma merger("0","/tmp/cil-2VCEpSWX.i","-g,-Wall,-O3,-Wno-strict-aliasing")
__inline static __uint16_t __bswap_16(__uint16_t __bsx )
{


  {
  return ((__uint16_t )((((int )__bsx >> 8) & 255) | (((int )__bsx & 255) << 8)));
}
}
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   * __restrict  __cp ,
                                                             char * __restrict  __buf ,
                                                             socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern json_t *json_array(void) ;
extern void json_delete(json_t *json ) ;
__inline static void json_decref(json_t *json )
{
  size_t volatile   tmp ;

  {
  if (json) {
    if (json->refcount != (size_t volatile   )0xffffffffffffffffUL) {
      tmp = (size_t volatile   )__atomic_sub_fetch(& json->refcount, 1, 3);
      if (tmp == (size_t volatile   )0) {
        json_delete(json);
      }
    }
  }
  return;
}
}
extern int json_array_append_new(json_t *array , json_t *value ) ;
extern json_t *( __attribute__((__warn_unused_result__)) json_pack)(char const   *fmt
                                                                    , ...) ;
extern char *( __attribute__((__warn_unused_result__)) json_dumps)(json_t const   *json ,
                                                                   size_t flags ) ;
__inline static void brubeck_metric_set_state(struct brubeck_metric *metric , uint8_t const   state )
{


  {
  __atomic_store_n(& metric->private_state, (int const   )state, 5);
  return;
}
}
void brubeck_http_endpoint_init(struct brubeck_server *server , char const   *listen___0 ) ;
__inline static int starts_with(char const   *str , char const   *prefix )
{


  {
  while (1) {
    if (! *prefix) {
      return (1);
    } else
    if ((int const   )*str != (int const   )*prefix) {
      return (0);
    }
    str ++;
    prefix ++;
  }
}
}
extern struct MHD_Daemon *MHD_start_daemon(unsigned int flags , uint16_t port , int (*apc)(void *cls ,
                                                                                           struct sockaddr  const  *addr ,
                                                                                           socklen_t addrlen ) ,
                                           void *apc_cls , int (*dh)(void *cls , struct MHD_Connection *connection ,
                                                                     char const   *url ,
                                                                     char const   *method ,
                                                                     char const   *version ,
                                                                     char const   *upload_data ,
                                                                     size_t *upload_data_size ,
                                                                     void **con_cls ) ,
                                           void *dh_cls  , ...) ;
extern int MHD_queue_response(struct MHD_Connection *connection , unsigned int status_code ,
                              struct MHD_Response *response ) ;
extern struct MHD_Response *MHD_create_response_from_buffer(size_t size , void *buffer ,
                                                            enum MHD_ResponseMemoryMode mode ) ;
extern void MHD_destroy_response(struct MHD_Response *response ) ;
extern int MHD_add_response_header(struct MHD_Response *response , char const   *header ,
                                   char const   *content ) ;
static struct MHD_Response *flow_stats(struct brubeck_server *server )
{


  {
  return ((struct MHD_Response *)((void *)0));
}
}
static struct brubeck_metric *safe_lookup_metric(struct brubeck_server *server , char const   *key )
{
  size_t tmp ;
  struct brubeck_metric *tmp___0 ;

  {
  tmp = strlen(key);
  tmp___0 = brubeck_hashtable_find(server->metrics, key, (uint16_t )tmp);
  return (tmp___0);
}
}
static struct MHD_Response *expire_metric(struct brubeck_server *server , char const   *url )
{
  struct brubeck_metric *metric ;
  size_t tmp ;
  struct brubeck_metric *tmp___0 ;
  struct MHD_Response *tmp___1 ;

  {
  tmp = strlen("/expire/");
  tmp___0 = safe_lookup_metric(server, url + tmp);
  metric = tmp___0;
  if (metric) {
    brubeck_metric_set_state(metric, (uint8_t const   )0);
    tmp___1 = MHD_create_response_from_buffer((size_t )0, (void *)"", (enum MHD_ResponseMemoryMode )0);
    return (tmp___1);
  }
  return ((struct MHD_Response *)((void *)0));
}
}
static struct MHD_Response *send_metric(struct brubeck_server *server , char const   *url ) ;
static char const   *metric_types[6]  = {      "gauge",      "meter",      "counter",      "histogram",
        "timer",      "internal"};
static char const   *expire_status[3]  = {      "disabled",      "inactive",      "active"};
static struct MHD_Response *send_metric(struct brubeck_server *server , char const   *url )
{
  struct brubeck_metric *metric ;
  size_t tmp ;
  struct brubeck_metric *tmp___0 ;
  json_t *mj ;
  uint8_t tmp___1 ;
  json_t *tmp___2 ;
  char *jsonr ;
  char *tmp___3 ;
  size_t tmp___4 ;
  struct MHD_Response *tmp___5 ;

  {
  tmp = strlen("/metric/");
  tmp___0 = safe_lookup_metric(server, url + tmp);
  metric = tmp___0;
  if (metric) {
    tmp___1 = (uint8_t )brubeck_metric_get_state((struct brubeck_metric  const  *)metric);
    tmp___2 = json_pack("{s:s, s:s, s:i, s:s}", "key", metric->key, "type", metric_types[metric->type],
                        "shard", 0, "expire", expire_status[tmp___1]);
    mj = tmp___2;
    tmp___3 = json_dumps((json_t const   *)mj, (size_t )260);
    jsonr = tmp___3;
    json_decref(mj);
    tmp___4 = strlen((char const   *)jsonr);
    tmp___5 = MHD_create_response_from_buffer(tmp___4, (void *)jsonr, (enum MHD_ResponseMemoryMode )1);
    return (tmp___5);
  }
  return ((struct MHD_Response *)((void *)0));
}
}
static struct MHD_Response *send_stats(struct brubeck_server *brubeck )
{
  char *jsonr ;
  json_t *stats ;
  json_t *backends ;
  json_t *samplers ;
  int i ;
  struct brubeck_backend *backend ;
  struct brubeck_carbon *carbon ;
  struct sockaddr_in *address ;
  char addr[16] ;
  __uint16_t tmp ;
  char const   *tmp___0 ;
  json_t *tmp___1 ;
  struct brubeck_kafka *kafka ;
  json_t *tmp___2 ;
  struct brubeck_sampler *sampler ;
  struct sockaddr_in *address___0 ;
  char addr___0[16] ;
  char const   *sampler_name ;
  __uint16_t tmp___3 ;
  char const   *tmp___4 ;
  json_t *tmp___5 ;
  size_t tmp___6 ;
  struct MHD_Response *tmp___7 ;

  {
  backends = json_array();
  i = 0;
  while (i < brubeck->active_backends) {
    backend = brubeck->backends[i];
    if ((unsigned int )backend->type == 0U) {
      carbon = (struct brubeck_carbon *)backend;
      address = & carbon->out_sockaddr;
      tmp = __bswap_16(address->sin_port);
      tmp___0 = inet_ntop(2, (void const   * __restrict  )(& address->sin_addr.s_addr),
                          (char * __restrict  )(addr), (socklen_t )16);
      tmp___1 = json_pack("{s:s, s:i, s:b, s:s, s:i, s:I}", "type", "carbon", "sample_freq",
                          carbon->backend.sample_freq, "connected", carbon->out_sock >= 0,
                          "address", tmp___0, "port", (int )tmp, "bytes_sent", (json_int_t )carbon->bytes_sent);
      json_array_append_new(backends, tmp___1);
    } else
    if ((unsigned int )backend->type == 1U) {
      kafka = (struct brubeck_kafka *)backend;
      tmp___2 = json_pack("{s:s, s:i, s:b, s:I}", "type", "kafka", "sample_freq",
                          kafka->backend.sample_freq, "connected", (int )kafka->connected,
                          "bytes_sent", (json_int_t )kafka->bytes_sent);
      json_array_append_new(backends, tmp___2);
    }
    i ++;
  }
  samplers = json_array();
  i = 0;
  while (i < brubeck->active_samplers) {
    sampler = brubeck->samplers[i];
    address___0 = & sampler->addr;
    sampler_name = (char const   *)((void *)0);
    switch ((unsigned int )sampler->type) {
    case 0U:
    sampler_name = "statsd";
    break;
    default: ;
    }
    tmp___3 = __bswap_16(address___0->sin_port);
    tmp___4 = inet_ntop(2, (void const   * __restrict  )(& address___0->sin_addr.s_addr),
                        (char * __restrict  )(addr___0), (socklen_t )16);
    tmp___5 = json_pack("{s:s, s:f, s:s, s:i}", "type", sampler_name, "sample_freq",
                        (double )sampler->current_flow, "address", tmp___4, "port",
                        (int )tmp___3);
    json_array_append_new(samplers, tmp___5);
    i ++;
  }
  stats = json_pack("{s:s, s:i, s:i, s:i, s:o, s:o}", "version", "brubeck f306c25",
                    "metrics", brubeck->internal_stats.sample.metrics, "errors", brubeck->internal_stats.sample.errors,
                    "unique_keys", brubeck->internal_stats.sample.unique_keys, "backends",
                    backends, "samplers", samplers);
  jsonr = json_dumps((json_t const   *)stats, (size_t )260);
  json_decref(stats);
  tmp___6 = strlen((char const   *)jsonr);
  tmp___7 = MHD_create_response_from_buffer(tmp___6, (void *)jsonr, (enum MHD_ResponseMemoryMode )1);
  return (tmp___7);
}
}
static struct MHD_Response *send_ping(struct brubeck_server *brubeck )
{
  value_t frequency ;
  char const   *status ;
  char *jsonr ;
  json_t *stats ;
  int i ;
  struct brubeck_backend *backend ;
  _Bool tmp ;
  __pid_t tmp___0 ;
  size_t tmp___1 ;
  struct MHD_Response *tmp___2 ;

  {
  frequency = (double )brubeck->internal_stats.sample_freq;
  status = "OK";
  i = 0;
  while (i < brubeck->active_backends) {
    backend = brubeck->backends[i];
    tmp = (*(backend->is_connected))((void *)backend);
    if (! tmp) {
      status = "ERROR (backend disconnected)";
      break;
    }
    i ++;
  }
  tmp___0 = getpid();
  stats = json_pack("{s:s, s:i, s:s, s:f, s:f, s:i}", "version", "brubeck f306c25",
                    "pid", tmp___0, "status", status, "metrics_per_second", (value_t )brubeck->internal_stats.sample.metrics / frequency,
                    "errors_per_second", (value_t )brubeck->internal_stats.sample.errors / frequency,
                    "unique_keys", brubeck->internal_stats.sample.unique_keys);
  jsonr = json_dumps((json_t const   *)stats, (size_t )260);
  json_decref(stats);
  tmp___1 = strlen((char const   *)jsonr);
  tmp___2 = MHD_create_response_from_buffer(tmp___1, (void *)jsonr, (enum MHD_ResponseMemoryMode )1);
  return (tmp___2);
}
}
static int handle_request(void *cls , struct MHD_Connection *connection , char const   *url ,
                          char const   *method , char const   *version , char const   *upload_data ,
                          size_t *upload_data_size , void **con_cls ) ;
static char const   *NOT_FOUND  =    "404 not found";
static int handle_request(void *cls , struct MHD_Connection *connection , char const   *url ,
                          char const   *method , char const   *version , char const   *upload_data ,
                          size_t *upload_data_size , void **con_cls )
{
  int ret ;
  struct MHD_Response *response ;
  struct brubeck_server *brubeck ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
  response = (struct MHD_Response *)((void *)0);
  brubeck = (struct brubeck_server *)cls;
  tmp___6 = strcmp(method, "GET");
  if (tmp___6) {
    tmp___5 = strcmp(method, "POST");
    if (! tmp___5) {
      tmp___4 = starts_with(url, "/expire/");
      if (tmp___4) {
        response = expire_metric(brubeck, url);
      }
    }
  } else {
    tmp___2 = strcmp(url, "/_ping");
    if (tmp___2) {
      tmp___3 = strcmp(url, "/ping");
      if (tmp___3) {
        tmp___1 = strcmp(url, "/stats");
        if (tmp___1) {
          tmp___0 = strcmp(url, "/flow_stats");
          if (tmp___0) {
            tmp = starts_with(url, "/metric/");
            if (tmp) {
              response = send_metric(brubeck, url);
            }
          } else {
            response = flow_stats(brubeck);
          }
        } else {
          response = send_stats(brubeck);
        }
      } else {
        response = send_ping(brubeck);
      }
    } else {
      response = send_ping(brubeck);
    }
  }
  if (! response) {
    tmp___7 = strlen(NOT_FOUND);
    response = MHD_create_response_from_buffer(tmp___7, (void *)NOT_FOUND, (enum MHD_ResponseMemoryMode )0);
    MHD_add_response_header(response, "Connection", "close");
    ret = MHD_queue_response(connection, 404U, response);
  } else {
    MHD_add_response_header(response, "Connection", "close");
    MHD_add_response_header(response, "Content-Type", "application/json");
    ret = MHD_queue_response(connection, 200U, response);
  }
  MHD_destroy_response(response);
  return (ret);
}
}
void brubeck_http_endpoint_init(struct brubeck_server *server , char const   *listen___0 )
{
  struct MHD_Daemon *daemon___0 ;
  char const   *port ;
  char *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  tmp = strrchr(listen___0, ':');
  port = (char const   *)tmp;
  if (port) {
    port ++;
  } else {
    port = listen___0;
  }
  tmp___0 = atoi(port);
  daemon___0 = MHD_start_daemon(8U, (uint16_t )tmp___0, (int (*)(void *cls , struct sockaddr  const  *addr ,
                                                                 socklen_t addrlen ))((void *)0),
                                (void *)0, & handle_request, (void *)server, 3, 10U,
                                0);
  if (! daemon___0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: failed to start HTTP endpoint\n");
      gh_log_die();
      break;
    }
  }
  tmp___1 = gh_log_instance();
  gh_log_write("instance=%s event=http_server listen=%s\n", tmp___1, port);
  return;
}
}
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_add_and_fetch(...) ;  */
/* compiler builtin:
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_lock_test_and_set(...) ;  */
#pragma merger("0","/tmp/cil-ai3zzkyO.i","-g,-Wall,-O3,-Wno-strict-aliasing")
struct brubeck_metric *brubeck_metric_new(struct brubeck_server *server , char const   *key ,
                                          size_t key_len , uint8_t type ) ;
struct brubeck_backend *brubeck_metric_shard(struct brubeck_server *server , struct brubeck_metric *metric ) ;
void brubeck_internal__init(struct brubeck_server *server ) ;
void brubeck_internal__sample(struct brubeck_metric *metric , void (*sample)(struct brubeck_metric  const  *metric ,
                                                                             char const   *key ,
                                                                             value_t value ,
                                                                             void *backend ) ,
                              void *opaque ) ;
void brubeck_internal__sample(struct brubeck_metric *metric , void (*sample)(struct brubeck_metric  const  *metric ,
                                                                             char const   *key ,
                                                                             value_t value ,
                                                                             void *backend ) ,
                              void *opaque )
{
  struct brubeck_internal_stats *stats ;
  uint32_t value ;
  char *key ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  stats = (struct brubeck_internal_stats *)metric->as.other;
  tmp = strlen(".unique_keys");
  tmp___0 = __builtin_alloca(((size_t )metric->key_len + tmp) + 1UL);
  key = (char *)tmp___0;
  memcpy((void * __restrict  )key, (void const   * __restrict  )(metric->key), (size_t )metric->key_len);
  tmp___1 = strlen(".metrics");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".metrics",
         tmp___1 + 1UL);
  value = (uint32_t )__sync_lock_test_and_set(& stats->live.metrics, 0);
  stats->sample.metrics = value;
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, (value_t )value,
            opaque);
  tmp___2 = strlen(".errors");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".errors",
         tmp___2 + 1UL);
  value = (uint32_t )__sync_lock_test_and_set(& stats->live.errors, 0);
  stats->sample.errors = value;
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, (value_t )value,
            opaque);
  tmp___3 = strlen(".unique_keys");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".unique_keys",
         tmp___3 + 1UL);
  value = (uint32_t )__sync_add_and_fetch(& stats->live.unique_keys, 0);
  stats->sample.unique_keys = value;
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, (value_t )value,
            opaque);
  brubeck_metric_set_state(metric, (uint8_t const   )2);
  return;
}
}
void brubeck_internal__init(struct brubeck_server *server )
{
  struct brubeck_metric *internal ;
  struct brubeck_backend *backend ;
  size_t tmp ;

  {
  tmp = strlen(server->name);
  internal = brubeck_metric_new(server, server->name, tmp, (uint8_t )5);
  if ((unsigned long )internal == (unsigned long )((void *)0)) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: Failed to initialize internal stats sampler\n");
      gh_log_die();
      break;
    }
  }
  internal->as.other = (void *)(& server->internal_stats);
  backend = brubeck_metric_shard(server, internal);
  server->internal_stats.sample_freq = backend->sample_freq;
  return;
}
}
/* compiler builtin:
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-ivWLyzxx.i","-g,-Wall,-O3,-Wno-strict-aliasing")
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern void closelog(void) ;
extern void openlog(char const   *__ident , int __option , int __facility ) ;
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
extern int fclose(FILE *__stream ) ;
extern int fflush(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
void gh_log_set_instance(char const   *instance ) ;
void gh_log_reopen(void) ;
static char const   *gh_log_path  =    (char const   *)((void *)0);
static FILE *gh_log_file  ;
static int gh_syslog_enabled  ;
void gh_log_open(char const   *path )
{
  FILE *new_log ;
  int tmp ;

  {
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    gh_syslog_enabled = 0;
    gh_log_file = (FILE *)((void *)0);
    return;
  }
  tmp = strcmp(path, "syslog");
  if (! tmp) {
    openlog((char const   *)((void *)0), 1, 23 << 3);
    gh_syslog_enabled = 1;
    return;
  }
  new_log = fopen((char const   * __restrict  )path, (char const   * __restrict  )"a");
  if ((unsigned long )new_log == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to open log file at \'%s\'\n",
            path);
    return;
  }
  if (gh_log_file) {
    fclose(gh_log_file);
  }
  if (gh_syslog_enabled) {
    closelog();
    gh_syslog_enabled = 0;
  }
  gh_log_file = new_log;
  gh_log_path = path;
  return;
}
}
void gh_log_reopen(void)
{


  {
  if ((unsigned long )gh_log_path != (unsigned long )((void *)0)) {
    gh_log_open(gh_log_path);
  }
  return;
}
}
void ( /* format attribute */  gh_log_write)(char const   *message  , ...)
{
  va_list___0 vl ;

  {
  __builtin_va_start(vl, message);
  if (gh_syslog_enabled) {
    vsyslog(6, message, vl);
  } else
  if (gh_log_file) {
    vfprintf((FILE * __restrict  )gh_log_file, (char const   * __restrict  )message,
             vl);
    fflush(gh_log_file);
  } else {
    vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )message, vl);
    fflush(stderr);
  }
  __builtin_va_end(vl);
  return;
}
}
 __attribute__((__noreturn__)) void gh_log_die(void) ;
void gh_log_die(void)
{


  {
  exit(1);
}
}
static char const   *_app_instance  =    (char const   *)((void *)0);
char const   *gh_log_instance(void)
{


  {
  return (_app_instance);
}
}
void gh_log_set_instance(char const   *instance )
{


  {
  _app_instance = instance;
  return;
}
}
#pragma merger("0","/tmp/cil-3XtDiIYt.i","-g,-Wall,-O3,-Wno-strict-aliasing")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_spin_init)(pthread_spinlock_t *__lock ,
                                                                                              int __pshared ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_spin_lock)(pthread_spinlock_t *__lock ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_spin_unlock)(pthread_spinlock_t *__lock ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strndup)(char const   *__string ,
                                                                                      size_t __n )  __attribute__((__malloc__)) ;
void brubeck_metric_record(struct brubeck_metric *metric , value_t value , value_t sample_freq ,
                           uint8_t modifiers ) ;
struct brubeck_metric *brubeck_metric_find(struct brubeck_server *server , char const   *key ,
                                           size_t key_len , uint8_t type ) ;
void *brubeck_slab_alloc(struct brubeck_slab *slab , size_t need ) ;
struct brubeck_tag_set  const  *brubeck_get_tag_set(struct brubeck_tags_t *tags ,
                                                    char const   *key_str , uint16_t key_len ) ;
__inline static struct brubeck_metric *new_metric(struct brubeck_server *server ,
                                                  char const   *key , size_t key_len ,
                                                  uint8_t type )
{
  struct brubeck_metric *metric ;
  struct brubeck_tag_set  const  *tags ;
  void *tmp ;

  {
  tags = (struct brubeck_tag_set  const  *)((void *)0);
  if (server->tags) {
    tags = brubeck_get_tag_set(server->tags, key, (uint16_t )key_len);
    if (tags) {
      key_len -= (size_t )tags->tag_len;
    }
  }
  tmp = brubeck_slab_alloc(& server->slab, (sizeof(struct brubeck_metric ) + key_len) + 1UL);
  metric = (struct brubeck_metric *)tmp;
  memset((void *)metric, 0, sizeof(struct brubeck_metric ));
  metric->tags = tags;
  memcpy((void * __restrict  )(metric->key), (void const   * __restrict  )key, key_len);
  metric->key[key_len] = (char )'\000';
  metric->key_len = (uint16_t )key_len;
  brubeck_metric_set_state(metric, (uint8_t const   )2);
  metric->type = type;
  pthread_spin_init(& metric->lock, 0);
  return (metric);
}
}
static void gauge__record(struct brubeck_metric *metric , value_t value , value_t sample_freq ,
                          uint8_t modifiers )
{


  {
  pthread_spin_lock(& metric->lock);
  if ((int )modifiers & 1) {
    metric->as.gauge.value += value;
  } else {
    metric->as.gauge.value = value;
  }
  pthread_spin_unlock(& metric->lock);
  return;
}
}
static void gauge__sample(struct brubeck_metric *metric , void (*sample)(struct brubeck_metric  const  *metric ,
                                                                         char const   *key ,
                                                                         value_t value ,
                                                                         void *backend ) ,
                          void *opaque )
{
  value_t value ;

  {
  pthread_spin_lock(& metric->lock);
  value = metric->as.gauge.value;
  pthread_spin_unlock(& metric->lock);
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)(metric->key),
            value, opaque);
  return;
}
}
static void meter__record(struct brubeck_metric *metric , value_t value , value_t sample_freq ,
                          uint8_t modifiers )
{


  {
  value *= sample_freq;
  pthread_spin_lock(& metric->lock);
  metric->as.meter.value += value;
  pthread_spin_unlock(& metric->lock);
  return;
}
}
static void meter__sample(struct brubeck_metric *metric , void (*sample)(struct brubeck_metric  const  *metric ,
                                                                         char const   *key ,
                                                                         value_t value ,
                                                                         void *backend ) ,
                          void *opaque )
{
  value_t value ;

  {
  pthread_spin_lock(& metric->lock);
  value = metric->as.meter.value;
  metric->as.meter.value = 0.0;
  pthread_spin_unlock(& metric->lock);
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)(metric->key),
            value, opaque);
  return;
}
}
static void counter__record(struct brubeck_metric *metric , value_t value , value_t sample_freq ,
                            uint8_t modifiers )
{
  value_t diff ;
  value_t tmp ;

  {
  value *= sample_freq;
  pthread_spin_lock(& metric->lock);
  if (metric->as.counter.previous > 0.0) {
    if (value >= metric->as.counter.previous) {
      tmp = value - metric->as.counter.previous;
    } else {
      tmp = value;
    }
    diff = tmp;
    metric->as.counter.value += diff;
  }
  metric->as.counter.previous = value;
  pthread_spin_unlock(& metric->lock);
  return;
}
}
static void counter__sample(struct brubeck_metric *metric , void (*sample)(struct brubeck_metric  const  *metric ,
                                                                           char const   *key ,
                                                                           value_t value ,
                                                                           void *backend ) ,
                            void *opaque )
{
  value_t value ;

  {
  pthread_spin_lock(& metric->lock);
  value = metric->as.counter.value;
  metric->as.counter.value = 0.0;
  pthread_spin_unlock(& metric->lock);
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)(metric->key),
            value, opaque);
  return;
}
}
static void histogram__record(struct brubeck_metric *metric , value_t value , value_t sample_freq ,
                              uint8_t modifiers )
{


  {
  pthread_spin_lock(& metric->lock);
  brubeck_histo_push(& metric->as.histogram, value, sample_freq);
  pthread_spin_unlock(& metric->lock);
  return;
}
}
static void histogram__sample(struct brubeck_metric *metric , void (*sample)(struct brubeck_metric  const  *metric ,
                                                                             char const   *key ,
                                                                             value_t value ,
                                                                             void *backend ) ,
                              void *opaque )
{
  struct brubeck_histo_sample hsample ;
  char *key ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  struct brubeck_backend *backend ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;

  {
  pthread_spin_lock(& metric->lock);
  brubeck_histo_sample(& hsample, & metric->as.histogram);
  pthread_spin_unlock(& metric->lock);
  tmp = strlen(".percentile.999");
  tmp___0 = __builtin_alloca(((size_t )metric->key_len + tmp) + 1UL);
  key = (char *)tmp___0;
  memcpy((void * __restrict  )key, (void const   * __restrict  )(metric->key), (size_t )metric->key_len);
  tmp___1 = strlen(".count");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".count",
         tmp___1 + 1UL);
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, hsample.count,
            opaque);
  tmp___2 = strlen(".count_ps");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".count_ps",
         tmp___2 + 1UL);
  backend = (struct brubeck_backend *)opaque;
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, hsample.count / (double )backend->sample_freq,
            opaque);
  if (hsample.count == 0.0) {
    return;
  }
  tmp___3 = strlen(".min");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".min",
         tmp___3 + 1UL);
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, hsample.min,
            opaque);
  tmp___4 = strlen(".max");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".max",
         tmp___4 + 1UL);
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, hsample.max,
            opaque);
  tmp___5 = strlen(".sum");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".sum",
         tmp___5 + 1UL);
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, hsample.sum,
            opaque);
  tmp___6 = strlen(".mean");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".mean",
         tmp___6 + 1UL);
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, hsample.mean,
            opaque);
  tmp___7 = strlen(".median");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".median",
         tmp___7 + 1UL);
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, hsample.median,
            opaque);
  tmp___8 = strlen(".percentile.75");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".percentile.75",
         tmp___8 + 1UL);
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, hsample.percentile[0],
            opaque);
  tmp___9 = strlen(".percentile.95");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".percentile.95",
         tmp___9 + 1UL);
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, hsample.percentile[1],
            opaque);
  tmp___10 = strlen(".percentile.98");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".percentile.98",
         tmp___10 + 1UL);
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, hsample.percentile[2],
            opaque);
  tmp___11 = strlen(".percentile.99");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".percentile.99",
         tmp___11 + 1UL);
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, hsample.percentile[3],
            opaque);
  tmp___12 = strlen(".percentile.999");
  memcpy((void * __restrict  )(key + (int )metric->key_len), (void const   * __restrict  )".percentile.999",
         tmp___12 + 1UL);
  (*sample)((struct brubeck_metric  const  *)metric, (char const   *)key, hsample.percentile[4],
            opaque);
  return;
}
}
static struct brubeck_metric__proto _prototypes[6]  = {      {& gauge__record, & gauge__sample},
        {& meter__record, & meter__sample},
        {& counter__record, & counter__sample},
        {& histogram__record, & histogram__sample},
        {& histogram__record, & histogram__sample},
        {(void (*)(struct brubeck_metric * , value_t  , value_t  , uint8_t  ))((void *)0),
      & brubeck_internal__sample}};
void brubeck_metric_sample(struct brubeck_metric *metric , void (*cb)(struct brubeck_metric  const  *metric ,
                                                                      char const   *key ,
                                                                      value_t value ,
                                                                      void *backend ) ,
                           void *backend )
{


  {
  (*(_prototypes[metric->type].sample))(metric, cb, backend);
  return;
}
}
void brubeck_metric_record(struct brubeck_metric *metric , value_t value , value_t sample_freq ,
                           uint8_t modifiers )
{


  {
  brubeck_metric_set_state(metric, (uint8_t const   )2);
  (*(_prototypes[metric->type].record))(metric, value, sample_freq, modifiers);
  return;
}
}
struct brubeck_backend *brubeck_metric_shard(struct brubeck_server *server , struct brubeck_metric *metric )
{
  int shard ;
  uint32_t tmp ;

  {
  shard = 0;
  if (server->active_backends > 1) {
    tmp = CityHash32((char const   *)(metric->key), (size_t )metric->key_len);
    shard = (int )(tmp % (unsigned int )server->active_backends);
  }
  return (server->backends[shard]);
}
}
struct brubeck_metric *brubeck_metric_new(struct brubeck_server *server , char const   *key ,
                                          size_t key_len , uint8_t type )
{
  struct brubeck_metric *metric ;
  char *key_for_ht ;
  char *tmp ;
  struct brubeck_metric *tmp___0 ;
  _Bool tmp___1 ;
  struct brubeck_backend *tmp___2 ;

  {
  tmp = strndup(key, key_len);
  key_for_ht = tmp;
  metric = new_metric(server, key, key_len, type);
  if (! metric) {
    return ((struct brubeck_metric *)((void *)0));
  }
  tmp___1 = brubeck_hashtable_insert(server->metrics, (char const   *)key_for_ht,
                                     (uint16_t )key_len, metric);
  if (! tmp___1) {
    free((void *)key_for_ht);
    tmp___0 = brubeck_hashtable_find(server->metrics, key, (uint16_t )key_len);
    return (tmp___0);
  }
  tmp___2 = brubeck_metric_shard(server, metric);
  brubeck_backend_register_metric(tmp___2, metric);
  __sync_add_and_fetch(& server->internal_stats.live.unique_keys, 1);
  return (metric);
}
}
struct brubeck_metric *brubeck_metric_find(struct brubeck_server *server , char const   *key ,
                                           size_t key_len , uint8_t type )
{
  struct brubeck_metric *metric ;
  struct brubeck_metric *tmp ;
  long tmp___0 ;

  {
  metric = brubeck_hashtable_find(server->metrics, key, (uint16_t )key_len);
  tmp___0 = __builtin_expect((long )((unsigned long )metric == (unsigned long )((void *)0)),
                             0L);
  if (tmp___0) {
    if (server->at_capacity) {
      return ((struct brubeck_metric *)((void *)0));
    }
    tmp = brubeck_metric_new(server, key, key_len, type);
    return (tmp);
  }
  return (metric);
}
}
#pragma merger("0","/tmp/cil-m2wYtNkD.i","-g,-Wall,-O3,-Wno-strict-aliasing")
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
int brubeck_sampler_socket(struct brubeck_sampler *sampler , int multisock ) ;
void brubeck_sampler_init_inet(struct brubeck_sampler *sampler , struct brubeck_server *server ,
                               char const   *url , int port ) ;
__inline static char const   *brubeck_sampler_name(struct brubeck_sampler *sampler )
{


  {
  switch ((unsigned int )sampler->type) {
  case 0U:
  return ("statsd");
  default:
  return ((char const   *)((void *)0));
  }
}
}
void sock_setreuse(int fd , int reuse ) ;
void sock_setreuse_port(int fd , int reuse ) ;
void sock_enlarge_in(int fd ) ;
void brubeck_sampler_init_inet(struct brubeck_sampler *sampler , struct brubeck_server *server ,
                               char const   *url , int port )
{
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  sampler->server = server;
  url_to_inaddr2(& sampler->addr, url, port);
  tmp = brubeck_sampler_name(sampler);
  tmp___0 = gh_log_instance();
  gh_log_write("instance=%s sampler=%s event=load_udp addr=0.0.0.0:%d\n", tmp___0,
               tmp, port);
  return;
}
}
int brubeck_sampler_socket(struct brubeck_sampler *sampler , int multisock )
{
  int sock ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = socket(2, 2, 17);
  sock = tmp;
  sock_enlarge_in(sock);
  sock_setreuse(sock, 1);
  if (multisock) {
    sock_setreuse_port(sock, 1);
  }
  tmp___0 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sampler->addr)),
                 (socklen_t )sizeof(sampler->addr));
  if (tmp___0 < 0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: failed to bind socket\n");
      gh_log_die();
      break;
    }
  }
  return (sock);
}
}
#pragma merger("0","/tmp/cil-XNJZU4x4.i","-g,-Wall,-O3,-Wno-strict-aliasing")
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern int recvmmsg(int __fd , struct mmsghdr *__vmessages , unsigned int __vlen ,
                    int __flags , struct timespec *__tmo ) ;
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
extern int pthread_cancel(pthread_t __th ) ;
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream )
{
  __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat64)(int __ver ,
                                                                                       int __fildes ,
                                                                                       struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat64)(int __ver ,
                                                                                        char const   *__filename ,
                                                                                        struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat64)(int __ver ,
                                                                                         char const   *__filename ,
                                                                                         struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat64)(int __ver ,
                                                                                           int __fildes ,
                                                                                           char const   *__filename ,
                                                                                           struct stat64 *__stat_buf ,
                                                                                           int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat64)(char const   * __restrict  __path ,
                                                                                struct stat64 * __restrict  __statbuf )
{
  int tmp ;

  {
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat64)(char const   * __restrict  __path ,
                                                                                 struct stat64 * __restrict  __statbuf )
{
  int tmp ;

  {
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat64)(int __fd ,
                                                                               struct stat64 *__statbuf )
{
  int tmp ;

  {
  tmp = __fxstat64(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat64)(int __fd ,
                                                                                   char const   * __restrict  __filename ,
                                                                                   struct stat64 * __restrict  __statbuf ,
                                                                                   int __flag )
{
  int tmp ;

  {
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
void brubeck_statsd_packet_parse(struct brubeck_server *server , char *buffer , char *end ,
                                 double const   scale_timers_by ) ;
int brubeck_statsd_msg_parse(struct brubeck_statsd_msg *msg , char *buffer , char *end ,
                             double const   scale_timers_by ) ;
struct brubeck_sampler *brubeck_statsd_new(struct brubeck_server *server , json_t *settings ) ;
static void statsd_run_recvmmsg(struct brubeck_statsd *statsd , int sock )
{
  unsigned int SIM_PACKETS ;
  struct brubeck_server *server ;
  unsigned int i ;
  char const   *tmp ;
  int res ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char const   *tmp___6 ;
  char *buf ;
  char *end ;

  {
  SIM_PACKETS = statsd->mmsg_count;
  server = statsd->sampler.server;
  struct iovec iovecs[SIM_PACKETS] ;
  struct mmsghdr msgs[SIM_PACKETS] ;
  memset((void *)(msgs), 0, sizeof(msgs));
  i = 0U;
  while (i < SIM_PACKETS) {
    iovecs[i].iov_base = xmalloc((size_t )8192);
    iovecs[i].iov_len = (size_t )8191;
    msgs[i].msg_hdr.msg_iov = & iovecs[i];
    msgs[i].msg_hdr.msg_iovlen = (size_t )1;
    i ++;
  }
  tmp = gh_log_instance();
  gh_log_write("instance=%s sampler=statsd event=worker_online syscall=recvmmsg socket=%d\n",
               tmp, sock);
  while (1) {
    tmp___0 = recvmmsg(sock, msgs, SIM_PACKETS, 65536, (struct timespec *)((void *)0));
    res = tmp___0;
    if (res < 0) {
      tmp___1 = __errno_location();
      if (*tmp___1 == 11) {
        goto __Cont;
      } else {
        tmp___2 = __errno_location();
        if (*tmp___2 == 4) {
          goto __Cont;
        }
      }
      tmp___3 = __errno_location();
      tmp___4 = strerror(*tmp___3);
      tmp___5 = __errno_location();
      tmp___6 = gh_log_instance();
      gh_log_write("instance=%s sampler=statsd event=failed_read errno=%d msg=\"%s\"\n",
                   tmp___6, *tmp___5, tmp___4);
      __sync_add_and_fetch(& server->internal_stats.live.errors, 1);
      goto __Cont;
    }
    __sync_add_and_fetch(& statsd->sampler.inflow, res);
    i = 0U;
    while (i < (unsigned int )res) {
      buf = (char *)(msgs[i].msg_hdr.msg_iov)->iov_base;
      end = buf + msgs[i].msg_len;
      brubeck_statsd_packet_parse(server, buf, end, (double const   )statsd->scale_timers_by);
      i ++;
    }
    __Cont: /* CIL Label */ ;
  }
}
}
static void statsd_run_recvmsg(struct brubeck_statsd *statsd , int sock )
{
  struct brubeck_server *server ;
  char *buffer ;
  void *tmp ;
  struct sockaddr_in reporter ;
  socklen_t reporter_len ;
  char const   *tmp___0 ;
  int res ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;

  {
  server = statsd->sampler.server;
  tmp = xmalloc((size_t )8192);
  buffer = (char *)tmp;
  reporter_len = (socklen_t )sizeof(reporter);
  memset((void *)(& reporter), 0, (size_t )reporter_len);
  tmp___0 = gh_log_instance();
  gh_log_write("instance=%s sampler=statsd event=worker_online syscall=recvmsg socket=%d\n",
               tmp___0, sock);
  while (1) {
    tmp___1 = recvfrom(sock, (void * __restrict  )buffer, (size_t )8191, 0, (struct sockaddr * __restrict  )((struct sockaddr *)(& reporter)),
                       (socklen_t * __restrict  )(& reporter_len));
    res = (int )tmp___1;
    if (res < 0) {
      tmp___2 = __errno_location();
      if (*tmp___2 == 11) {
        goto __Cont;
      } else {
        tmp___3 = __errno_location();
        if (*tmp___3 == 4) {
          goto __Cont;
        }
      }
      tmp___4 = __errno_location();
      tmp___5 = strerror(*tmp___4);
      tmp___6 = __errno_location();
      tmp___7 = inet_ntoa(reporter.sin_addr);
      tmp___8 = gh_log_instance();
      gh_log_write("instance=%s sampler=statsd event=failed_read from=%s errno=%d msg=\"%s\"\n",
                   tmp___8, tmp___7, *tmp___6, tmp___5);
      __sync_add_and_fetch(& server->internal_stats.live.errors, 1);
      goto __Cont;
    }
    __sync_add_and_fetch(& statsd->sampler.inflow, 1);
    brubeck_statsd_packet_parse(server, buffer, buffer + res, (double const   )statsd->scale_timers_by);
    __Cont: /* CIL Label */ ;
  }
}
}
__inline static char *parse_float(char *buffer , value_t *result , uint8_t *mods )
{
  int negative ;
  char *start ;
  value_t value ;
  double f ;
  int n ;
  double tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  negative = 0;
  start = buffer;
  value = 0.0;
  if ((int )*buffer == 45) {
    buffer ++;
    negative = 1;
    *mods = (uint8_t )((int )*mods | 1);
  } else
  if ((int )*buffer == 43) {
    buffer ++;
    *mods = (uint8_t )((int )*mods | 1);
  }
  while (1) {
    if ((int )*buffer >= 48) {
      if (! ((int )*buffer <= 57)) {
        break;
      }
    } else {
      break;
    }
    value = value * 10.0 + (value_t )((int )*buffer - 48);
    buffer ++;
  }
  if ((int )*buffer == 46) {
    f = 0.0;
    n = 0;
    buffer ++;
    while (1) {
      if ((int )*buffer >= 48) {
        if (! ((int )*buffer <= 57)) {
          break;
        }
      } else {
        break;
      }
      f = f * 10.0 + (double )((int )*buffer - 48);
      buffer ++;
      n ++;
    }
    tmp = pow(10.0, (double )n);
    value += f / tmp;
  }
  if (negative) {
    value = - value;
  }
  if ((int )*buffer == 101) {
    tmp___0 = 1;
  } else
  if ((int )*buffer == 69) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  if (tmp___1) {
    value = strtod((char const   * __restrict  )start, (char ** __restrict  )(& buffer));
  }
  *result = value;
  return (buffer);
}
}
int brubeck_statsd_msg_parse(struct brubeck_statsd_msg *msg , char *buffer , char *end ,
                             double const   scale_timers_by )
{
  char *tmp ;
  double sample_rate ;
  uint8_t dummy ;

  {
  *end = (char )'\000';
  msg->key = buffer;
  msg->key_len = (uint16_t )0;
  while (1) {
    if ((int )*buffer != 58) {
      if (! ((int )*buffer != 0)) {
        break;
      }
    } else {
      break;
    }
    buffer ++;
  }
  if ((int )*buffer == 0) {
    return (-1);
  }
  msg->key_len = (uint16_t )(buffer - msg->key);
  tmp = buffer;
  buffer ++;
  *tmp = (char )'\000';
  if ((int )*(msg->key + ((int )msg->key_len - 1)) == 46) {
    return (-1);
  }
  msg->modifiers = (uint8_t )0;
  buffer = parse_float(buffer, & msg->value, & msg->modifiers);
  if ((int )*buffer != 124) {
    return (-1);
  }
  buffer ++;
  switch ((int )*buffer) {
  case 103:
  msg->type = (uint16_t )0;
  break;
  case 99:
  msg->type = (uint16_t )1;
  break;
  case 67:
  msg->type = (uint16_t )2;
  break;
  case 104:
  msg->type = (uint16_t )3;
  break;
  case 109:
  buffer ++;
  if ((int )*buffer == 115) {
    msg->type = (uint16_t )4;
    msg->value *= (value_t )scale_timers_by;
    break;
  }
  default:
  return (-1);
  }
  buffer ++;
  if ((int )*(buffer + 0) == 124) {
    if ((int )*(buffer + 1) == 64) {
      buffer = parse_float(buffer + 2, & sample_rate, & dummy);
      if (sample_rate <= 0.0) {
        return (-1);
      } else
      if (sample_rate > 1.0) {
        return (-1);
      }
      msg->sample_freq = 1.0 / sample_rate;
    } else {
      msg->sample_freq = 1.0;
    }
  } else {
    msg->sample_freq = 1.0;
  }
  if ((int )*(buffer + 0) == 0) {
    return (0);
  } else
  if ((int )*(buffer + 0) == 10) {
    if ((int )*(buffer + 1) == 0) {
      return (0);
    }
  }
  return (-1);
}
}
void brubeck_statsd_packet_parse(struct brubeck_server *server , char *buffer , char *end ,
                                 double const   scale_timers_by )
{
  struct brubeck_statsd_msg msg ;
  struct brubeck_metric *metric ;
  char *stat_end ;
  void *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  while ((unsigned long )buffer < (unsigned long )end) {
    tmp = memchr((void const   *)buffer, '\n', (size_t )(end - buffer));
    stat_end = (char *)tmp;
    if (! stat_end) {
      stat_end = end;
    }
    tmp___1 = brubeck_statsd_msg_parse(& msg, buffer, stat_end, scale_timers_by);
    if (tmp___1 < 0) {
      __sync_add_and_fetch(& server->internal_stats.live.errors, 1);
      tmp___0 = gh_log_instance();
      gh_log_write("instance=%s sampler=statsd event=packet_drop\n", tmp___0);
    } else {
      __sync_add_and_fetch(& server->internal_stats.live.metrics, 1);
      metric = brubeck_metric_find(server, (char const   *)msg.key, (size_t )msg.key_len,
                                   (uint8_t )msg.type);
      if ((unsigned long )metric != (unsigned long )((void *)0)) {
        brubeck_metric_record(metric, msg.value, msg.sample_freq, msg.modifiers);
      }
    }
    buffer = stat_end + 1;
  }
  return;
}
}
static void *statsd__thread(void *_in )
{
  struct brubeck_statsd *statsd ;
  int sock ;

  {
  statsd = (struct brubeck_statsd *)_in;
  sock = statsd->sampler.in_sock;
  if (sock < 0) {
    sock = brubeck_sampler_socket(& statsd->sampler, 1);
  }
  if (statsd->mmsg_count > 1U) {
    statsd_run_recvmmsg(statsd, sock);
    return ((void *)0);
  }
  statsd_run_recvmsg(statsd, sock);
  return ((void *)0);
}
}
static void run_worker_threads(struct brubeck_statsd *statsd )
{
  unsigned int i ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = xmalloc((unsigned long )statsd->worker_count * sizeof(pthread_t ));
  statsd->workers = (pthread_t *)tmp;
  i = 0U;
  while (i < statsd->worker_count) {
    tmp___0 = pthread_create((pthread_t * __restrict  )(statsd->workers + i), (pthread_attr_t const   * __restrict  )((void *)0),
                             & statsd__thread, (void * __restrict  )statsd);
    if (tmp___0 != 0) {
      while (1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: failed to start sampler thread\n");
        gh_log_die();
        break;
      }
    }
    i ++;
  }
  return;
}
}
static void shutdown_sampler(struct brubeck_sampler *sampler )
{
  struct brubeck_statsd *statsd ;
  size_t i ;

  {
  statsd = (struct brubeck_statsd *)sampler;
  i = (size_t )0;
  while (i < (size_t )statsd->worker_count) {
    pthread_cancel(*(statsd->workers + i));
    i ++;
  }
  return;
}
}
struct brubeck_sampler *brubeck_statsd_new(struct brubeck_server *server , json_t *settings )
{
  struct brubeck_statsd *std ;
  void *tmp ;
  char *address ;
  int port ;
  int multisock ;
  json_error_t _error_j ;
  int tmp___0 ;

  {
  tmp = xmalloc(sizeof(struct brubeck_statsd ));
  std = (struct brubeck_statsd *)tmp;
  multisock = 0;
  std->sampler.type = (enum brubeck_sampler_t )0;
  std->sampler.shutdown = & shutdown_sampler;
  std->sampler.in_sock = -1;
  std->worker_count = 4U;
  std->mmsg_count = 1U;
  std->scale_timers_by = 1.;
  tmp___0 = json_unpack_ex(settings, & _error_j, (size_t )0, "{s:s, s:i, s?:i, s?:i, s?:b, s?:F}",
                           "address", & address, "port", & port, "workers", & std->worker_count,
                           "multimsg", & std->mmsg_count, "multisock", & multisock,
                           "scale_timers_by", & std->scale_timers_by);
  if (tmp___0 < 0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: config error: %s\n",
              _error_j.text);
      gh_log_die();
      break;
    }
  }
  brubeck_sampler_init_inet(& std->sampler, server, (char const   *)address, port);
  if (! multisock) {
    std->sampler.in_sock = brubeck_sampler_socket(& std->sampler, 0);
  }
  run_worker_threads(std);
  return (& std->sampler);
}
}
#pragma merger("0","/tmp/cil-FqR0Ez2x.i","-g,-Wall,-O3,-Wno-strict-aliasing")
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) signalfd)(int __fd ,
                                                                                     sigset_t const   *__mask ,
                                                                                     int __flags ) ;
extern  __attribute__((__nothrow__)) int timerfd_create(__clockid_t __clock_id , int __flags ) ;
extern  __attribute__((__nothrow__)) int timerfd_settime(int __ufd , int __flags ,
                                                         struct itimerspec  const  *__utmr ,
                                                         struct itimerspec *__otmr ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern json_t *( __attribute__((__warn_unused_result__)) json_object_get)(json_t const   *object ,
                                                                          char const   *key ) ;
extern size_t json_array_size(json_t const   *array ) ;
extern json_t *( __attribute__((__warn_unused_result__)) json_array_get)(json_t const   *array ,
                                                                         size_t index ) ;
extern char const   *json_string_value(json_t const   *string ) ;
extern json_t *( __attribute__((__warn_unused_result__)) json_load_file)(char const   *path ,
                                                                         size_t flags ,
                                                                         json_error_t *error ) ;
struct brubeck_backend *brubeck_kafka_new(struct brubeck_server *server , json_t *settings ,
                                          int shard_n ) ;
void brubeck_slab_init(struct brubeck_slab *slab ) ;
brubeck_tags_t *brubeck_tags_create(uint64_t const   size ) ;
void setproctitle(char const   *prog , char const   *txt ) ;
static void update_flows(struct brubeck_server *server )
{
  int i ;
  struct brubeck_sampler *sampler ;

  {
  i = 0;
  while (i < server->active_samplers) {
    sampler = server->samplers[i];
    sampler->current_flow = sampler->inflow;
    sampler->inflow = (size_t )0;
    i ++;
  }
  return;
}
}
static void update_proctitle(struct brubeck_server *server ) ;
static char const   *size_suffix[7]  = {      "b",      "kb",      "mb",      "gb",
        "tb",      "pb",      "eb"};
static void update_proctitle(struct brubeck_server *server )
{
  char buf[2048] ;
  int i ;
  int j ;
  int pos ;
  int tmp ;
  double bytes_sent ;
  _Bool connected ;
  struct brubeck_backend *backend ;
  struct brubeck_carbon *carbon ;
  int tmp___0 ;
  struct brubeck_kafka *kafka ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct brubeck_sampler *sampler ;
  __uint16_t tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  if (server->set_proctitle) {
    pos = 0;
    tmp = snprintf((char * __restrict  )(buf + pos), sizeof(buf) - (unsigned long )pos,
                   (char const   * __restrict  )"[%s] [ \342\206\221", server->config_name);
    pos += tmp;
    bytes_sent = 0.;
    connected = (_Bool)0;
    i = 0;
    while (i < server->active_backends) {
      backend = server->backends[i];
      if ((unsigned int )backend->type == 0U) {
        carbon = (struct brubeck_carbon *)backend;
        bytes_sent += (double )carbon->bytes_sent;
        if (connected) {
          tmp___0 = 1;
        } else
        if (carbon->out_sock >= 0) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
        connected = (_Bool )tmp___0;
      } else
      if ((unsigned int )backend->type == 1U) {
        kafka = (struct brubeck_kafka *)backend;
        bytes_sent += (double )kafka->bytes_sent;
        if (connected) {
          tmp___1 = 1;
        } else
        if (kafka->connected) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
        connected = (_Bool )tmp___1;
      }
      i ++;
    }
    j = 0;
    while (1) {
      if (j < 7) {
        if (! (bytes_sent >= 1024.0)) {
          break;
        }
      } else {
        break;
      }
      bytes_sent /= 1024.0;
      j ++;
    }
    if (connected) {
      tmp___2 = "";
    } else {
      tmp___2 = " (dc)";
    }
    if (i > 0) {
      tmp___3 = ",";
    } else {
      tmp___3 = "";
    }
    tmp___4 = snprintf((char * __restrict  )(buf + pos), sizeof(buf) - (unsigned long )pos,
                       (char const   * __restrict  )"%s #%d %.1f%s%s", tmp___3, i + 1,
                       bytes_sent, size_suffix[j], tmp___2);
    pos += tmp___4;
    tmp___5 = snprintf((char * __restrict  )(buf + pos), sizeof(buf) - (unsigned long )pos,
                       (char const   * __restrict  )" ] [ \342\206\223");
    pos += tmp___5;
    i = 0;
    while (i < server->active_samplers) {
      sampler = server->samplers[i];
      tmp___6 = __bswap_16(sampler->addr.sin_port);
      if (i > 0) {
        tmp___7 = ",";
      } else {
        tmp___7 = "";
      }
      tmp___8 = snprintf((char * __restrict  )(buf + pos), sizeof(buf) - (unsigned long )pos,
                         (char const   * __restrict  )"%s :%d %d/s", tmp___7, (int )tmp___6,
                         (int )sampler->current_flow);
      pos += tmp___8;
      i ++;
    }
    tmp___9 = snprintf((char * __restrict  )(buf + pos), sizeof(buf) - (unsigned long )pos,
                       (char const   * __restrict  )" ]");
    pos += tmp___9;
    setproctitle("brubeck", (char const   *)(buf));
  }
  return;
}
}
static void dump_metric(struct brubeck_metric *mt , void *out_file ) ;
static char const   *METRIC_NAMES[6]  = {      "g",      "c",      "C",      "h",
        "ms",      "internal"};
static void dump_metric(struct brubeck_metric *mt , void *out_file )
{


  {
  fprintf((FILE * __restrict  )((FILE *)out_file), (char const   * __restrict  )"%s|%s\n",
          mt->key, METRIC_NAMES[mt->type]);
  return;
}
}
static void dump_all_metrics(struct brubeck_server *server )
{
  FILE *dump ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;

  {
  dump = (FILE *)((void *)0);
  tmp = gh_log_instance();
  gh_log_write("instance=%s event=dump_metrics\n", tmp);
  if (server->dump_path) {
    dump = fopen((char const   * __restrict  )server->dump_path, (char const   * __restrict  )"w+");
  }
  if (! dump) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    tmp___2 = __errno_location();
    tmp___3 = gh_log_instance();
    gh_log_write("instance=%s event=dump_failed errno=%d msg=\"%s\"\n", tmp___3, *tmp___2,
                 tmp___1);
    return;
  }
  brubeck_hashtable_foreach(server->metrics, & dump_metric, (void *)dump);
  fclose(dump);
  return;
}
}
static void load_backends(struct brubeck_server *server , json_t *backends )
{
  size_t idx ;
  json_t *b ;
  char const   *type ;
  json_t *tmp ;
  char const   *tmp___0 ;
  struct brubeck_backend *backend ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;

  {
  idx = (size_t )0;
  while (1) {
    tmp___6 = json_array_size((json_t const   *)backends);
    if (idx < tmp___6) {
      b = json_array_get((json_t const   *)backends, idx);
      if (! b) {
        break;
      }
    } else {
      break;
    }
    tmp = json_object_get((json_t const   *)b, "type");
    tmp___0 = json_string_value((json_t const   *)tmp);
    type = tmp___0;
    backend = (struct brubeck_backend *)((void *)0);
    if (type) {
      tmp___5 = strcmp(type, "carbon");
      if (tmp___5) {
        goto _L;
      } else {
        backend = brubeck_carbon_new(server, b, server->active_backends);
        tmp___1 = server->active_backends;
        (server->active_backends) ++;
        server->backends[tmp___1] = backend;
      }
    } else
    _L: /* CIL Label */
    if (type) {
      tmp___4 = strcmp(type, "kafka");
      if (tmp___4) {
        tmp___3 = gh_log_instance();
        gh_log_write("instance=%s backend=%s event=invalid_backend\n", tmp___3, type);
      } else {
        backend = brubeck_kafka_new(server, b, server->active_backends);
        tmp___2 = server->active_backends;
        (server->active_backends) ++;
        server->backends[tmp___2] = backend;
      }
    } else {
      tmp___3 = gh_log_instance();
      gh_log_write("instance=%s backend=%s event=invalid_backend\n", tmp___3, type);
    }
    idx ++;
  }
  if (server->active_backends == 0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: no backends were loaded\n");
      gh_log_die();
      break;
    }
  }
  return;
}
}
static void load_samplers(struct brubeck_server *server , json_t *samplers )
{
  size_t idx ;
  json_t *s ;
  char const   *type ;
  json_t *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
  idx = (size_t )0;
  while (1) {
    tmp___4 = json_array_size((json_t const   *)samplers);
    if (idx < tmp___4) {
      s = json_array_get((json_t const   *)samplers, idx);
      if (! s) {
        break;
      }
    } else {
      break;
    }
    tmp = json_object_get((json_t const   *)s, "type");
    tmp___0 = json_string_value((json_t const   *)tmp);
    type = tmp___0;
    if (type) {
      tmp___3 = strcmp(type, "statsd");
      if (tmp___3) {
        tmp___2 = gh_log_instance();
        gh_log_write("instance=%s sampler=%s event=invalid_sampler\n", tmp___2, type);
      } else {
        tmp___1 = server->active_samplers;
        (server->active_samplers) ++;
        server->samplers[tmp___1] = brubeck_statsd_new(server, s);
      }
    } else {
      tmp___2 = gh_log_instance();
      gh_log_write("instance=%s sampler=%s event=invalid_sampler\n", tmp___2, type);
    }
    idx ++;
  }
  return;
}
}
static int load_timerfd(int interval )
{
  struct itimerspec timer ;
  int timerfd ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = timerfd_create(1, 0);
  timerfd = tmp;
  if (timerfd < 0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: failed to create timer\n");
      gh_log_die();
      break;
    }
  }
  memset((void *)(& timer), 0, sizeof(timer));
  timer.it_value.tv_sec = (__time_t )interval;
  timer.it_value.tv_nsec = (__syscall_slong_t )0;
  timer.it_interval.tv_sec = (__time_t )interval;
  timer.it_interval.tv_nsec = (__syscall_slong_t )0;
  tmp___0 = timerfd_settime(timerfd, 0, (struct itimerspec  const  *)(& timer), (struct itimerspec *)((void *)0));
  if (tmp___0 < 0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: failed to set system timer\n");
      gh_log_die();
      break;
    }
  }
  return (timerfd);
}
}
static int load_signalfd(void)
{
  sigset_t mask ;
  int tmp ;
  int tmp___0 ;

  {
  sigemptyset(& mask);
  sigaddset(& mask, 2);
  sigaddset(& mask, 15);
  sigaddset(& mask, 1);
  sigaddset(& mask, 12);
  tmp = sigprocmask(0, (sigset_t const   * __restrict  )(& mask), (sigset_t * __restrict  )((void *)0));
  if (tmp == -1) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: failed to sigprocmask the needed signals\n");
      gh_log_die();
      break;
    }
  }
  tmp___0 = signalfd(-1, (sigset_t const   *)(& mask), 0);
  return (tmp___0);
}
}
static char *get_config_name(char const   *full_path )
{
  char const   *filename ;
  char *tmp ;
  char *config_name ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *ext ;
  char *tmp___2 ;

  {
  tmp = strrchr(full_path, '/');
  filename = (char const   *)tmp;
  if (filename) {
    tmp___0 = filename + 1;
  } else {
    tmp___0 = full_path;
  }
  tmp___1 = strdup(tmp___0);
  config_name = tmp___1;
  tmp___2 = strrchr((char const   *)config_name, '.');
  ext = tmp___2;
  if (ext) {
    *ext = (char )'\000';
  }
  return (config_name);
}
}
static void load_config(struct brubeck_server *server , char const   *path )
{
  json_error_t error ;
  int capacity ;
  json_t *backends ;
  json_t *samplers ;
  char *http ;
  int tag_capacity ;
  char *tmp ;
  json_error_t _error_j ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  http = (char *)((void *)0);
  tag_capacity = 0;
  server->name = "brubeck";
  tmp = get_config_name(path);
  server->config_name = (char const   *)tmp;
  server->dump_path = (char const   *)((void *)0);
  server->config = json_load_file(path, (size_t )0, & error);
  if (! server->config) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: failed to load config file, %s (%s:%d:%d)\n",
              error.text, error.source, error.line, error.column);
      gh_log_die();
      break;
    }
  }
  tmp___0 = json_unpack_ex(server->config, & _error_j, (size_t )0, "{s?:s, s:s, s:i, s?:i, s:o, s:o, s?:s}",
                           "server_name", & server->name, "dumpfile", & server->dump_path,
                           "capacity", & capacity, "tag_capacity", & tag_capacity,
                           "backends", & backends, "samplers", & samplers, "http",
                           & http);
  if (tmp___0 < 0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: config error: %s\n",
              _error_j.text);
      gh_log_die();
      break;
    }
  }
  gh_log_set_instance(server->name);
  server->metrics = brubeck_hashtable_new((uint64_t const   )(1 << capacity));
  if (! server->metrics) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: failed to initialize hash table (size: %lu)\n",
              1UL << capacity);
      gh_log_die();
      break;
    }
  }
  if (tag_capacity) {
    server->tags = brubeck_tags_create((uint64_t const   )(1 << tag_capacity));
    if (! server->tags) {
      while (1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: failed to initialize tags (size: %lu)\n",
                1UL << tag_capacity);
        gh_log_die();
        break;
      }
    }
    tmp___1 = gh_log_instance();
    gh_log_write("instance=%s event=tagging_initialized\n", tmp___1);
  }
  load_backends(server, backends);
  load_samplers(server, samplers);
  if (http) {
    brubeck_http_endpoint_init(server, (char const   *)http);
  }
  return;
}
}
void brubeck_server_init(struct brubeck_server *server , char const   *config )
{


  {
  signal(13, (void (*)(int  ))1);
  server->fd_signal = load_signalfd();
  server->fd_update = load_timerfd(1);
  brubeck_slab_init(& server->slab);
  load_config(server, config);
  brubeck_internal__init(server);
  return;
}
}
static int timer_elapsed(struct pollfd *fd )
{
  uint64_t timer ;
  int s ;
  ssize_t tmp ;

  {
  if ((int )fd->revents & 1) {
    tmp = read(fd->fd, (void *)(& timer), sizeof(timer));
    s = (int )tmp;
    return ((unsigned long )s == sizeof(timer));
  }
  return (0);
}
}
static int signal_triggered(struct pollfd *fd )
{
  struct signalfd_siginfo fdsi ;
  int s ;
  ssize_t tmp ;

  {
  if ((int )fd->revents & 1) {
    tmp = read(fd->fd, (void *)(& fdsi), sizeof(fdsi));
    s = (int )tmp;
    if ((unsigned long )s == sizeof(fdsi)) {
      return ((int )fdsi.ssi_signo);
    }
  }
  return (-1);
}
}
int brubeck_server_run(struct brubeck_server *server )
{
  struct pollfd fds[2] ;
  int nfd ;
  size_t i ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  struct brubeck_sampler *sampler ;
  char const   *tmp___4 ;

  {
  nfd = 2;
  memset((void *)(fds), 0, sizeof(fds));
  fds[0].fd = server->fd_signal;
  fds[0].events = (short)1;
  fds[1].fd = server->fd_update;
  fds[1].events = (short)1;
  server->running = 1;
  tmp = gh_log_instance();
  gh_log_write("instance=%s event=listening\n", tmp);
  while (server->running) {
    tmp___0 = poll(fds, (nfds_t )nfd, -1);
    if (tmp___0 < 0) {
      continue;
    }
    tmp___1 = signal_triggered(& fds[0]);
    switch (tmp___1) {
    case 1:
    gh_log_reopen();
    tmp___2 = gh_log_instance();
    gh_log_write("instance=%s event=reload_log\n", tmp___2);
    break;
    case 12:
    dump_all_metrics(server);
    break;
    case 15:
    case 2:
    server->running = 0;
    break;
    }
    tmp___3 = timer_elapsed(& fds[1]);
    if (tmp___3) {
      update_flows(server);
      update_proctitle(server);
    }
  }
  i = (size_t )0;
  while (i < (size_t )server->active_backends) {
    pthread_cancel((server->backends[i])->thread);
    i ++;
  }
  i = (size_t )0;
  while (i < (size_t )server->active_samplers) {
    sampler = server->samplers[i];
    if (sampler->shutdown) {
      (*(sampler->shutdown))(sampler);
    }
    i ++;
  }
  tmp___4 = gh_log_instance();
  gh_log_write("instance=%s event=shutdown\n", tmp___4);
  return (0);
}
}
#pragma merger("0","/tmp/cil-c4bGaRDY.i","-g,-Wall,-O3,-Wno-strict-aliasing")
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format
                                                 , ...) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern char **environ ;
static char **argv0  ;
static int argv_lth  ;
void initproctitle(int argc , char **argv )
{
  int i ;
  char **envp ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  envp = environ;
  i = 0;
  while ((unsigned long )*(envp + i) != (unsigned long )((void *)0)) {
    goto __Cont;
    __Cont: /* CIL Label */
    i ++;
  }
  tmp = malloc(sizeof(char *) * (unsigned long )(i + 1));
  environ = (char **)tmp;
  if ((unsigned long )environ == (unsigned long )((void *)0)) {
    return;
  }
  i = 0;
  while ((unsigned long )*(envp + i) != (unsigned long )((void *)0)) {
    tmp___0 = strdup((char const   *)*(envp + i));
    *(environ + i) = tmp___0;
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      return;
    }
    i ++;
  }
  *(environ + i) = (char *)((void *)0);
  argv0 = argv;
  if (i > 0) {
    tmp___1 = strlen((char const   *)*(envp + (i - 1)));
    argv_lth = (int )((*(envp + (i - 1)) + tmp___1) - *(argv0 + 0));
  } else {
    tmp___2 = strlen((char const   *)*(argv0 + (argc - 1)));
    argv_lth = (int )((*(argv0 + (argc - 1)) + tmp___2) - *(argv0 + 0));
  }
  return;
}
}
int getproctitle(char **procbuffer )
{


  {
  if (! argv0) {
    return (-1);
  }
  memset((void *)*(argv0 + 0), '\000', (size_t )argv_lth);
  *(argv0 + 1) = (char *)((void *)0);
  *procbuffer = *(argv0 + 0);
  return (argv_lth);
}
}
void setproctitle(char const   *prog , char const   *txt )
{
  int i ;
  char buf[2048] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  if (! argv0) {
    return;
  }
  tmp = strlen(prog);
  tmp___0 = strlen(txt);
  if ((tmp + tmp___0) + 5UL > 2048UL) {
    return;
  }
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%s -- %s", prog,
          txt);
  tmp___1 = strlen((char const   *)(buf));
  i = (int )tmp___1;
  if (i > argv_lth - 2) {
    i = argv_lth - 2;
    buf[i] = (char )'\000';
  }
  memset((void *)*(argv0 + 0), '\000', (size_t )argv_lth);
  strcpy((char * __restrict  )*(argv0 + 0), (char const   * __restrict  )(buf));
  *(argv0 + 1) = (char *)((void *)0);
  return;
}
}
#pragma merger("0","/tmp/cil-eLFLuOmk.i","-g,-Wall,-O3,-Wno-strict-aliasing")
static struct brubeck_slab_node *push_node(struct brubeck_slab *slab )
{
  struct brubeck_slab_node *node ;
  void *tmp ;

  {
  tmp = xmalloc((size_t )4096);
  node = (struct brubeck_slab_node *)tmp;
  node->alloc = (size_t )0;
  node->next = slab->current;
  slab->current = node;
  return (node);
}
}
void *brubeck_slab_alloc(struct brubeck_slab *slab , size_t need )
{
  struct brubeck_slab_node *node ;
  void *ptr ;

  {
  need = ((need + 32UL) - 1UL) & 0xffffffffffffffe0UL;
  pthread_mutex_lock(& slab->lock);
  node = slab->current;
  if (node->alloc + need > 4064UL) {
    node = push_node(slab);
  }
  slab->total_alloc += need;
  ptr = (void *)(node->heap + node->alloc);
  node->alloc += need;
  pthread_mutex_unlock(& slab->lock);
  return (ptr);
}
}
void brubeck_slab_init(struct brubeck_slab *slab )
{


  {
  push_node(slab);
  pthread_mutex_init(& slab->lock, (pthread_mutexattr_t const   *)((void *)0));
  return;
}
}
#pragma merger("0","/tmp/cil-9Z2sdDnE.i","-g,-Wall,-O3,-Wno-strict-aliasing")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3))) strtok_r)(char * __restrict  __s ,
                                                                                         char const   * __restrict  __delim ,
                                                                                         char ** __restrict  __save_ptr ) ;
uint16_t const   brubeck_tag_offset(char const   *str ) ;
struct brubeck_tag_set *brubeck_parse_tags(char *tag_str , uint16_t tag_str_len ) ;
static char const   char_assoc  =    (char const   )'=';
static char const   *str_assoc  =    "=";
static char const   *str_delim  =    ",";
static void *tags_malloc(size_t r )
{
  void *tmp ;

  {
  tmp = xmalloc(r);
  return (tmp);
}
}
static void tags_free(void *p , size_t b , _Bool r )
{


  {
  free(p);
  return;
}
}
static struct ck_malloc ALLOCATOR___0  =    {& tags_malloc, (void *(*)(void * , size_t  , size_t  , _Bool  ))0, & tags_free};
brubeck_tags_t *brubeck_tags_create(uint64_t const   size )
{
  brubeck_tags_t *tags ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  tmp = xmalloc(sizeof(brubeck_tags_t ));
  tags = (brubeck_tags_t *)tmp;
  memset((void *)tags, 0, sizeof(brubeck_tags_t ));
  pthread_mutex_init(& tags->write_mutex, (pthread_mutexattr_t const   *)((void *)0));
  tmp___0 = ck_ht_init(& tags->table, 2U, (ck_ht_hash_cb_t *)((void *)0), & ALLOCATOR___0,
                       (uint64_t )size, (uint64_t )195948557);
  if (! tmp___0) {
    free((void *)tags);
    return ((brubeck_tags_t *)((void *)0));
  }
  return (tags);
}
}
_Bool brubeck_tags_insert(brubeck_tags_t *tags , char const   *key , uint16_t key_len ,
                          struct brubeck_tag_set *val )
{
  ck_ht_hash_t h ;
  ck_ht_entry_t entry ;
  _Bool result ;

  {
  ck_ht_hash(& h, & tags->table, (void const   *)key, key_len);
  ck_ht_entry_set(& entry, h, (void const   *)key, key_len, (void const   *)val);
  pthread_mutex_lock(& tags->write_mutex);
  result = ck_ht_put_spmc(& tags->table, h, & entry);
  if (result) {
    (tags->num_tag_sets) ++;
    val->index = tags->num_tag_sets;
  }
  pthread_mutex_unlock(& tags->write_mutex);
  return (result);
}
}
struct brubeck_tag_set *brubeck_tags_find(brubeck_tags_t *tags , char const   *key ,
                                          uint16_t key_len )
{
  ck_ht_hash_t h ;
  ck_ht_entry_t entry ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  ck_ht_hash(& h, & tags->table, (void const   *)key, key_len);
  ck_ht_entry_key_set(& entry, (void const   *)key, key_len);
  tmp___0 = ck_ht_get_spmc(& tags->table, h, & entry);
  if (tmp___0) {
    tmp = ck_ht_entry_value(& entry);
    return ((struct brubeck_tag_set *)tmp);
  }
  return ((struct brubeck_tag_set *)((void *)0));
}
}
uint16_t const   brubeck_tag_offset(char const   *str )
{
  uint16_t offset ;

  {
  offset = (uint16_t )0;
  offset = (uint16_t )0;
  while (1) {
    if (*str) {
      if ((int const   )*str != 44) {
        if (! ((int const   )*str != 35)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    str ++;
    offset = (uint16_t )((int )offset + 1);
  }
  return ((uint16_t const   )offset);
}
}
uint16_t const   count_char_in_str(char const   *str , char c )
{
  uint16_t count ;

  {
  count = (uint16_t )0;
  while (*(str + count)) {
    if ((int const   )*(str + count) == (int const   )c) {
      count = (uint16_t )((int )count + 1);
    } else {
      c = (char )((int )c + 1);
    }
  }
  return ((uint16_t const   )count);
}
}
_Bool parse_tag(char *kv_str , struct brubeck_tag *tag )
{
  char *state ;
  char *key ;
  char *value ;

  {
  key = strtok_r((char * __restrict  )kv_str, (char const   * __restrict  )str_assoc,
                 (char ** __restrict  )(& state));
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  value = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )str_assoc,
                   (char ** __restrict  )(& state));
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  tag->key = (char const   *)key;
  tag->value = (char const   *)value;
  return ((_Bool)1);
}
}
struct brubeck_tag_set *brubeck_parse_tags(char *tag_str , uint16_t tag_str_len )
{
  char *state ;
  uint16_t num_possible_tags ;
  uint16_t tmp ;
  int tmp___0 ;
  size_t alloc_size ;
  struct brubeck_tag_set *tag_set ;
  void *tmp___1 ;
  _Bool tmp___2 ;

  {
  if (tag_str) {
    tmp = (uint16_t )count_char_in_str((char const   *)tag_str, (char )char_assoc);
    tmp___0 = (int const   )tmp;
  } else {
    tmp___0 = (int const   )0;
  }
  num_possible_tags = (uint16_t )tmp___0;
  alloc_size = sizeof(struct brubeck_tag_set ) + (unsigned long )num_possible_tags * sizeof(struct brubeck_tag *);
  tmp___1 = malloc(alloc_size);
  tag_set = (struct brubeck_tag_set *)tmp___1;
  memset((void *)tag_set, 0, alloc_size);
  if (tag_str) {
    tag_set->tag_len = tag_str_len;
    tag_str = strtok_r((char * __restrict  )tag_str, (char const   * __restrict  )str_delim,
                       (char ** __restrict  )(& state));
    while (tag_str) {
      tmp___2 = parse_tag(tag_str, & tag_set->tags[tag_set->num_tags]);
      if (tmp___2) {
        tag_set->num_tags = (uint16_t )((int )tag_set->num_tags + 1);
      }
      tag_str = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )str_delim,
                         (char ** __restrict  )(& state));
    }
  }
  return (tag_set);
}
}
struct brubeck_tag_set  const  *brubeck_get_tag_set_of_tag_str(struct brubeck_tags_t *tags ,
                                                               char const   *tag_str ,
                                                               uint16_t tag_str_len )
{
  struct brubeck_tag_set *tag_set ;
  char *tag_str_for_parse ;
  char *tmp ;
  char *tag_str_for_key ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
  tag_set = brubeck_tags_find(tags, tag_str, tag_str_len);
  if ((unsigned long )tag_set == (unsigned long )((void *)0)) {
    tmp = strdup(tag_str);
    tag_str_for_parse = tmp;
    tmp___0 = strdup(tag_str);
    tag_str_for_key = tmp___0;
    tag_set = brubeck_parse_tags(tag_str_for_parse, tag_str_len);
    tmp___1 = brubeck_tags_insert(tags, (char const   *)tag_str_for_key, tag_str_len,
                                  tag_set);
    if (! tmp___1) {
      free((void *)tag_set);
      free((void *)tag_str_for_parse);
      free((void *)tag_str_for_key);
      tag_set = brubeck_tags_find(tags, tag_str, tag_str_len);
    }
  }
  return ((struct brubeck_tag_set  const  *)tag_set);
}
}
struct brubeck_tag_set  const  *brubeck_get_tag_set(struct brubeck_tags_t *tags ,
                                                    char const   *key_str , uint16_t key_len )
{
  uint16_t tag_offset ;
  uint16_t tmp ;
  struct brubeck_tag_set  const  *tmp___0 ;

  {
  tmp = (uint16_t )brubeck_tag_offset(key_str);
  tag_offset = (uint16_t )tmp;
  tmp___0 = brubeck_get_tag_set_of_tag_str(tags, key_str + (int )tag_offset, (uint16_t )((int )key_len - (int )tag_offset));
  return (tmp___0);
}
}
#pragma merger("0","/tmp/cil-nvaHmtJZ.i","-g,-Wall,-O3,-Wno-strict-aliasing")
extern int fcntl(int __fd , int __cmd  , ...) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
void sock_setnonblock(int fd ) ;
char *find_substr(char const   *s , char const   *find , size_t slen ) ;
char *find_substr(char const   *s , char const   *find , size_t slen )
{
  char c ;
  char sc ;
  size_t len ;
  char const   *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
  tmp___2 = find;
  find ++;
  c = (char )*tmp___2;
  if ((int )c != 0) {
    len = strlen(find);
    while (1) {
      while (1) {
        tmp = s;
        s ++;
        sc = (char )*tmp;
        if ((int )sc == 0) {
          return ((char *)((void *)0));
        } else {
          tmp___0 = slen;
          slen --;
          if (tmp___0 < 1UL) {
            return ((char *)((void *)0));
          }
        }
        if (! ((int )sc != (int )c)) {
          break;
        }
      }
      if (len > slen) {
        return ((char *)((void *)0));
      }
      tmp___1 = strncmp(s, find, len);
      if (! (tmp___1 != 0)) {
        break;
      }
    }
    s --;
  }
  return ((char *)s);
}
}
void sock_setnonblock(int fd )
{
  int flags ;
  int tmp ;

  {
  flags = fcntl(fd, 3);
  flags |= 2048;
  tmp = fcntl(fd, 4, flags);
  if (tmp < 0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: Failed to set O_NONBLOCK\n");
      gh_log_die();
      break;
    }
  }
  return;
}
}
void sock_setreuse(int fd , int reuse )
{
  int tmp ;

  {
  tmp = setsockopt(fd, 1, 2, (void const   *)(& reuse), (socklen_t )sizeof(reuse));
  if (tmp == -1) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: Failed to set SO_REUSEADDR\n");
      gh_log_die();
      break;
    }
  }
  return;
}
}
void sock_enlarge_in(int fd )
{
  int bs ;
  int tmp ;

  {
  bs = 33554431;
  tmp = setsockopt(fd, 1, 8, (void const   *)(& bs), (socklen_t )sizeof(bs));
  if (tmp == -1) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: Failed to set SO_RCVBUF\n");
      gh_log_die();
      break;
    }
  }
  return;
}
}
void sock_enlarge_out(int fd )
{
  int bs ;
  int tmp ;

  {
  bs = 33554431;
  tmp = setsockopt(fd, 1, 7, (void const   *)(& bs), (socklen_t )sizeof(bs));
  if (tmp == -1) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: Failed to set SO_SNDBUF\n");
      gh_log_die();
      break;
    }
  }
  return;
}
}
void sock_setreuse_port(int fd , int reuse )
{
  int tmp ;

  {
  tmp = setsockopt(fd, 1, 15, (void const   *)(& reuse), (socklen_t )sizeof(reuse));
  if (tmp == -1) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: failed to set SO_REUSEPORT\n");
      gh_log_die();
      break;
    }
  }
  return;
}
}
void url_to_inaddr2(struct sockaddr_in *addr , char const   *url , int port )
{
  struct addrinfo hints ;
  struct addrinfo *result ;
  struct addrinfo *rp ;
  int tmp ;

  {
  memset((void *)addr, 0, sizeof(struct sockaddr_in ));
  if (url) {
    memset((void *)(& hints), 0, sizeof(struct addrinfo ));
    hints.ai_family = 2;
    tmp = getaddrinfo((char const   * __restrict  )url, (char const   * __restrict  )((void *)0),
                      (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& result));
    if (tmp != 0) {
      while (1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: failed to resolve address \'%s\'\n",
                url);
        gh_log_die();
        break;
      }
    }
    rp = result;
    while (rp) {
      if (result->ai_family == 2) {
        if ((unsigned long )result->ai_addrlen == sizeof(struct sockaddr_in )) {
          break;
        }
      }
      rp = rp->ai_next;
    }
    if (! rp) {
      while (1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: address format not supported\n");
        gh_log_die();
        break;
      }
    }
    memcpy((void * __restrict  )addr, (void const   * __restrict  )rp->ai_addr, (size_t )rp->ai_addrlen);
    addr->sin_port = __bswap_16((__uint16_t )port);
    freeaddrinfo(result);
  } else {
    addr->sin_family = (sa_family_t )2;
    addr->sin_port = __bswap_16((__uint16_t )port);
    addr->sin_addr.s_addr = __bswap_32((in_addr_t )0);
  }
  return;
}
}
int brubeck_itoa(char *ptr , uint64_t number )
{
  char *origin ;
  int size ;
  char *tmp ;
  char t ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  origin = ptr;
  while (1) {
    tmp = ptr;
    ptr ++;
    *tmp = (char )(48UL + number % 10UL);
    number /= 10UL;
    if (! number) {
      break;
    }
  }
  size = (int )(ptr - origin);
  ptr --;
  while ((unsigned long )origin < (unsigned long )ptr) {
    t = *ptr;
    tmp___0 = ptr;
    ptr --;
    *tmp___0 = *origin;
    tmp___1 = origin;
    origin ++;
    *tmp___1 = t;
  }
  return (size);
}
}
int brubeck_ftoa(char *outbuf , float f )
{
  uint64_t mantissa ;
  uint64_t int_part ;
  uint64_t frac_part ;
  int safe_shift ;
  uint64_t safe_mask ;
  short exp2___0 ;
  char *p ;
  union __anonunion_x_375160861 x ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int m ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  x.F = f;
  p = outbuf;
  exp2___0 = (short )((int )((unsigned char )(x.L >> 23)) - 127);
  mantissa = (uint64_t )((x.L & 16777215) | 8388608);
  frac_part = (uint64_t )0;
  int_part = (uint64_t )0;
  if (x.L < 0) {
    tmp = p;
    p ++;
    *tmp = (char )'-';
  }
  if ((int )exp2___0 < -36) {
    tmp___0 = p;
    p ++;
    *tmp___0 = (char )'0';
    goto END;
  }
  safe_shift = - ((int )exp2___0 + 1);
  safe_mask = (uint64_t )(18446744073709551615 >> (40 - safe_shift));
  if ((int )exp2___0 >= 64) {
    int_part = 18446744073709551615;
  } else
  if ((int )exp2___0 >= 23) {
    int_part = mantissa << ((int )exp2___0 - 23);
  } else
  if ((int )exp2___0 >= 0) {
    int_part = mantissa >> (23 - (int )exp2___0);
    frac_part = mantissa & safe_mask;
  } else {
    frac_part = mantissa & 16777215UL;
  }
  if (int_part == 0UL) {
    tmp___1 = p;
    p ++;
    *tmp___1 = (char )'0';
  } else {
    tmp___2 = brubeck_itoa(p, int_part);
    p += tmp___2;
  }
  if (frac_part != 0UL) {
    tmp___3 = p;
    p ++;
    *tmp___3 = (char )'.';
    m = 0;
    while (m < 4) {
      frac_part = (frac_part << 3) + (frac_part << 1);
      tmp___4 = p;
      p ++;
      *tmp___4 = (char )((frac_part >> (24 + safe_shift)) + 48UL);
      frac_part &= safe_mask;
      m ++;
    }
    while ((int )*(p + -1) == 48) {
      p --;
    }
    if ((int )*(p + -1) == 46) {
      p --;
    }
  }
  END:
  *p = (char)0;
  return ((int )(p - outbuf));
}
}
/* compiler builtin:
   void __attribute__((__overloaded__))  __atomic_add_fetch(...) ;  */
#pragma merger("0","/tmp/cil-oJETZjSf.i","-g,-Wall,-O3,-Wno-strict-aliasing")
extern json_t *json_object(void) ;
extern json_t *json_string(char const   *value ) ;
extern json_t *json_integer(json_int_t value ) ;
extern json_t *json_real(double value ) ;
__inline static json_t *json_incref(json_t *json )
{


  {
  if (json) {
    if (json->refcount != (size_t volatile   )0xffffffffffffffffUL) {
      __atomic_add_fetch(& json->refcount, 1, 2);
    }
  }
  return (json);
}
}
extern int json_object_set_new_nocheck(json_t *object , char const   *key , json_t *value ) ;
extern int json_object_clear(json_t *object ) ;
extern void *json_object_iter(json_t *object ) ;
extern void *json_object_key_to_iter(char const   *key ) ;
extern void *json_object_iter_next(json_t *object , void *iter ) ;
extern char const   *json_object_iter_key(void *iter ) ;
extern json_t *json_object_iter_value(void *iter ) ;
__inline static int json_object_set_nocheck(json_t *object , char const   *key , json_t *value )
{
  json_t *tmp ;
  int tmp___0 ;

  {
  tmp = json_incref(value);
  tmp___0 = json_object_set_new_nocheck(object, key, tmp);
  return (tmp___0);
}
}
extern char const   *rd_kafka_err2str(rd_kafka_resp_err_t err ) ;
extern char const   *rd_kafka_err2name(rd_kafka_resp_err_t err ) ;
extern rd_kafka_resp_err_t rd_kafka_fatal_error(rd_kafka_t *rk , char *errstr , size_t errstr_size ) ;
extern rd_kafka_conf_t *rd_kafka_conf_new(void) ;
extern void rd_kafka_conf_destroy(rd_kafka_conf_t *conf ) ;
extern rd_kafka_conf_res_t rd_kafka_conf_set(rd_kafka_conf_t *conf , char const   *name ,
                                             char const   *value , char *errstr ,
                                             size_t errstr_size ) ;
extern void rd_kafka_conf_set_dr_msg_cb(rd_kafka_conf_t *conf , void (*dr_msg_cb)(rd_kafka_t *rk ,
                                                                                  rd_kafka_message_t const   *rkmessage ,
                                                                                  void *opaque ) ) ;
extern void rd_kafka_conf_set_error_cb(rd_kafka_conf_t *conf , void (*error_cb)(rd_kafka_t *rk ,
                                                                                int err ,
                                                                                char const   *reason ,
                                                                                void *opaque ) ) ;
extern void rd_kafka_conf_set_opaque(rd_kafka_conf_t *conf , void *opaque ) ;
extern rd_kafka_t *rd_kafka_new(rd_kafka_type_t type , rd_kafka_conf_t *conf , char *errstr ,
                                size_t errstr_size ) ;
extern void rd_kafka_destroy(rd_kafka_t *rk ) ;
extern int rd_kafka_poll(rd_kafka_t *rk , int timeout_ms ) ;
extern rd_kafka_resp_err_t rd_kafka_producev(rd_kafka_t *rk  , ...) ;
extern rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk , int timeout_ms ) ;
static char errstr[512]  ;
static int kafka_shutdown(void *backend )
{
  struct brubeck_kafka *self ;
  rd_kafka_resp_err_t err ;
  int i ;
  size_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  self = (struct brubeck_kafka *)backend;
  self->connected = (_Bool)0;
  i = 0;
  while (1) {
    if (self->documents) {
      tmp = *((size_t *)self->documents + -2);
    } else {
      tmp = (size_t )0;
    }
    if (! ((size_t )i < tmp)) {
      break;
    }
    if ((unsigned long )*(self->documents + i) != (unsigned long )((void *)0)) {
      json_decref((*(self->documents + i))->json);
    }
    i ++;
  }
  err = rd_kafka_fatal_error(self->rk, errstr, sizeof(errstr));
  if (err) {
    tmp___0 = rd_kafka_err2name(err);
    tmp___1 = gh_log_instance();
    gh_log_write("instance=%s backend=kafka event=fatal_error reason=%s msg=\"%s\"\n",
                 tmp___1, tmp___0, errstr);
  }
  tmp___2 = gh_log_instance();
  gh_log_write("instance=%s backend=kafka event=flushing-outstanding-messages\n",
               tmp___2);
  rd_kafka_flush(self->rk, 10000);
  rd_kafka_destroy(self->rk);
  return ((int )err);
}
}
static void dr_msg_cb(rd_kafka_t *rk , rd_kafka_message_t const   *rkmessage , void *opaque )
{
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  if (rkmessage->err) {
    tmp = rd_kafka_err2name((rd_kafka_resp_err_t )rkmessage->err);
    tmp___0 = gh_log_instance();
    gh_log_write("instance=%s backend=kafka event=delivery_error msg=\"%s\"\n", tmp___0,
                 tmp);
  }
  return;
}
}
static void error_cb(rd_kafka_t *rk , int err , char const   *reason , void *opaque )
{
  struct brubeck_kafka *self ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  self = (struct brubeck_kafka *)opaque;
  tmp = rd_kafka_err2name((rd_kafka_resp_err_t )err);
  tmp___0 = gh_log_instance();
  gh_log_write("instance=%s backend=kafka event=producer_error reason=%s msg=\"%s\"\n",
               tmp___0, tmp, reason);
  if (err != -150) {
    return;
  }
  tmp___1 = kafka_shutdown((void *)self);
  if (tmp___1) {
    exit(1);
  }
  return;
}
}
static _Bool kafka_is_connected(void *backend )
{
  struct brubeck_kafka *self ;

  {
  self = (struct brubeck_kafka *)backend;
  return (self->connected);
}
}
static int kafka_connect(void *backend )
{
  struct brubeck_kafka *self ;

  {
  self = (struct brubeck_kafka *)backend;
  if (self->connected) {
    return (0);
  } else {
    return (-1);
  }
}
}
static void each_metric(struct brubeck_metric  const  *metric , char const   *key ,
                        value_t value , void *backend )
{
  struct brubeck_kafka *self ;
  uint32_t tag_index ;
  struct brubeck_kafka_document *doc ;
  struct brubeck_kafka_document *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t __cap ;
  size_t tmp___3 ;
  size_t __size ;
  size_t *__p ;
  void *tmp___4 ;
  size_t __prev_size ;
  size_t tmp___5 ;
  size_t *__p1 ;
  size_t *__p2 ;
  void *tmp___6 ;
  json_t *tag_destination ;
  uint16_t i ;
  json_t *tmp___7 ;
  json_t *tmp___8 ;

  {
  self = (struct brubeck_kafka *)backend;
  tag_index = (uint32_t )0;
  if ((unsigned long )metric->tags != (unsigned long )((void *)0)) {
    tag_index = (uint32_t )(metric->tags)->index;
  }
  if (self->documents) {
    tmp___1 = *((size_t *)self->documents + -2);
  } else {
    tmp___1 = (size_t )0;
  }
  if ((size_t )tag_index >= tmp___1) {
    tmp___0 = (struct brubeck_kafka_document *)((void *)0);
  } else {
    tmp___0 = *(self->documents + tag_index);
  }
  doc = tmp___0;
  if ((unsigned long )doc == (unsigned long )((void *)0)) {
    tmp___2 = malloc(sizeof(struct brubeck_kafka_document ));
    doc = (struct brubeck_kafka_document *)tmp___2;
    doc->is_dirty = (_Bool)0;
    doc->json = json_object();
    while (1) {
      if (self->documents) {
        tmp___3 = *((size_t *)self->documents + -1);
      } else {
        tmp___3 = (size_t )0;
      }
      __cap = tmp___3;
      if (__cap <= (size_t )tag_index) {
        if (! __cap) {
          __cap = (size_t )1;
        }
        while (__cap <= (size_t )tag_index) {
          __cap <<= 1;
        }
        while (1) {
          __size = __cap * sizeof(*(self->documents)) + sizeof(size_t ) * 2UL;
          if (! self->documents) {
            tmp___4 = malloc(__size);
            __p = (size_t *)tmp___4;
            memset((void *)__p, 0, __size);
            self->documents = (struct brubeck_kafka_document **)((void *)(__p + 2));
            while (1) {
              if (self->documents) {
                *((size_t *)self->documents + -1) = __cap;
              }
              break;
            }
            while (1) {
              if (self->documents) {
                *((size_t *)self->documents + -2) = (size_t )0;
              }
              break;
            }
          } else {
            if (self->documents) {
              tmp___5 = *((size_t *)self->documents + -1);
            } else {
              tmp___5 = (size_t )0;
            }
            __prev_size = tmp___5 * sizeof(*(self->documents)) + sizeof(size_t ) * 2UL;
            __p1 = (size_t *)self->documents + -2;
            tmp___6 = realloc((void *)__p1, __size);
            __p2 = (size_t *)tmp___6;
            memset((void *)((char *)__p2 + __prev_size), 0, __size - __prev_size);
            self->documents = (struct brubeck_kafka_document **)((void *)(__p2 + 2));
            while (1) {
              if (self->documents) {
                *((size_t *)self->documents + -1) = __cap;
              }
              break;
            }
          }
          break;
        }
      }
      break;
    }
    *(self->documents + tag_index) = doc;
    while (1) {
      if (self->documents) {
        *((size_t *)self->documents + -2) = (size_t )(tag_index + 1U);
      }
      break;
    }
  }
  if ((int )doc->is_dirty == 0) {
    if ((unsigned long )metric->tags != (unsigned long )((void *)0)) {
      if ((int const   )(metric->tags)->num_tags > 0) {
        tag_destination = doc->json;
        if ((unsigned long )self->tag_subdocument != (unsigned long )((void *)0)) {
          tag_destination = json_object();
          json_object_set_new_nocheck(doc->json, self->tag_subdocument, tag_destination);
        }
        i = (uint16_t )0;
        while ((int )i < (int )(metric->tags)->num_tags) {
          tmp___7 = json_string((char const   *)(metric->tags)->tags[i].value);
          json_object_set_new_nocheck(tag_destination, (char const   *)(metric->tags)->tags[i].key,
                                      tmp___7);
          i = (uint16_t )((int )i + 1);
        }
      }
    }
  }
  tmp___8 = json_real(value);
  json_object_set_new_nocheck(doc->json, key, tmp___8);
  doc->is_dirty = (_Bool)1;
  return;
}
}
static void kafka_flush(void *backend )
{
  struct brubeck_kafka *self ;
  rd_kafka_resp_err_t err ;
  char *buf ;
  size_t len ;
  int64_t epoch_ms ;
  json_t *json_epoch_ms ;
  int i ;
  struct brubeck_kafka_document *doc ;
  char const   *tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
  self = (struct brubeck_kafka *)backend;
  epoch_ms = (int64_t )self->backend.tick_time;
  epoch_ms *= 1000L;
  json_epoch_ms = json_integer((json_int_t )epoch_ms);
  i = 0;
  while (1) {
    if (self->documents) {
      tmp___1 = *((size_t *)self->documents + -2);
    } else {
      tmp___1 = (size_t )0;
    }
    if (! ((size_t )i < tmp___1)) {
      break;
    }
    doc = *(self->documents + i);
    if ((unsigned long )doc != (unsigned long )((void *)0)) {
      if (doc->is_dirty) {
        json_object_set_nocheck(doc->json, "@timestamp", json_epoch_ms);
        buf = json_dumps((json_t const   *)doc->json, (size_t )32);
        len = strlen((char const   *)buf);
        err = rd_kafka_producev(self->rk, 1, self->topic, 7, 1, 4, (void *)buf, len,
                                6, (void *)0, 0);
        if (err) {
          tmp = rd_kafka_err2str(err);
          tmp___0 = gh_log_instance();
          gh_log_write("instance=%s backend=kafka event=failed_to_enqueue msg=\"%s\"\n",
                       tmp___0, tmp);
          free((void *)buf);
        } else {
          self->bytes_sent += len;
        }
        json_object_clear(doc->json);
        doc->is_dirty = (_Bool)0;
        rd_kafka_poll(self->rk, 0);
      }
    }
    i ++;
  }
  json_decref(json_epoch_ms);
  return;
}
}
static rd_kafka_conf_t *build_rdkafka_config(json_t *json )
{
  rd_kafka_conf_t *conf ;
  int retval ;
  char const   *key ;
  json_t *value ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  rd_kafka_conf_res_t tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  void *tmp___6 ;

  {
  conf = rd_kafka_conf_new();
  tmp = json_object_iter(json);
  key = json_object_iter_key(tmp);
  while (1) {
    if (key) {
      tmp___6 = json_object_key_to_iter(key);
      value = json_object_iter_value(tmp___6);
      if (! value) {
        break;
      }
    } else {
      break;
    }
    tmp___2 = json_string_value((json_t const   *)value);
    tmp___3 = rd_kafka_conf_set(conf, key, tmp___2, errstr, sizeof(errstr));
    retval = (int )tmp___3;
    if (retval != 0) {
      tmp___4 = rd_kafka_err2name((rd_kafka_resp_err_t )retval);
      tmp___5 = gh_log_instance();
      gh_log_write("instance=%s backend=kafka event=conf_error key=%s code=%s msg=\"%s\"\n",
                   tmp___5, key, tmp___4, errstr);
      rd_kafka_conf_destroy(conf);
      exit(1);
    }
    tmp___0 = json_object_key_to_iter(key);
    tmp___1 = json_object_iter_next(json, tmp___0);
    key = json_object_iter_key(tmp___1);
  }
  return (conf);
}
}
struct brubeck_backend *brubeck_kafka_new(struct brubeck_server *server , json_t *settings ,
                                          int shard_n )
{
  struct brubeck_kafka *self ;
  void *tmp ;
  int frequency ;
  json_t *rdkafka_config ;
  rd_kafka_conf_t *conf ;
  json_error_t _error_j ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  tmp = xmalloc(sizeof(struct brubeck_kafka ));
  self = (struct brubeck_kafka *)tmp;
  memset((void *)self, 0, sizeof(struct brubeck_kafka ));
  frequency = 0;
  tmp___0 = json_unpack_ex(settings, & _error_j, (size_t )0, "{s:s, s:i, s:o, s?:s}",
                           "topic", & self->topic, "frequency", & frequency, "rdkafka_config",
                           & rdkafka_config, "tag_subdocument", & self->tag_subdocument);
  if (tmp___0 < 0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[FATAL]: config error: %s\n",
              _error_j.text);
      gh_log_die();
      break;
    }
  }
  conf = build_rdkafka_config(rdkafka_config);
  self->connected = (_Bool)1;
  self->backend.type = (enum brubeck_backend_t )1;
  self->backend.connect = & kafka_connect;
  self->backend.is_connected = & kafka_is_connected;
  self->backend.sample = & each_metric;
  self->backend.flush = & kafka_flush;
  self->backend.sample_freq = frequency;
  self->backend.server = server;
  rd_kafka_conf_set_dr_msg_cb(conf, & dr_msg_cb);
  rd_kafka_conf_set_error_cb(conf, & error_cb);
  rd_kafka_conf_set_opaque(conf, (void *)self);
  self->rk = rd_kafka_new((rd_kafka_type_t )0, conf, errstr, sizeof(errstr));
  if (! self->rk) {
    tmp___1 = gh_log_instance();
    gh_log_write("instance=%s backend=kafka event=producer_creation_failed error=\"%s\"\n",
                 tmp___1, errstr);
    rd_kafka_conf_destroy(conf);
    exit(1);
  }
  tmp___2 = gh_log_instance();
  gh_log_write("instance=%s backend=kafka event=ready\n", tmp___2);
  brubeck_backend_run_threaded((struct brubeck_backend *)self);
  tmp___3 = gh_log_instance();
  gh_log_write("instance=%s backend=kafka event=started\n", tmp___3);
  return ((struct brubeck_backend *)self);
}
}
