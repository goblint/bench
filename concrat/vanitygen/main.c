/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned int __socklen_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __ssize_t ssize_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_622077928 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_119281978 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_119281977 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_119281978 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_622077928 __annonCompField1 ;
   union __anonunion____missing_field_name_119281977 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
typedef int wchar_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct bignum_st ;
typedef struct bignum_st BIGNUM;
struct bignum_ctx ;
typedef struct bignum_ctx BN_CTX;
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
enum __anonenum_point_conversion_form_t_134566212 {
    POINT_CONVERSION_COMPRESSED = 2,
    POINT_CONVERSION_UNCOMPRESSED = 4,
    POINT_CONVERSION_HYBRID = 6
} ;
typedef enum __anonenum_point_conversion_form_t_134566212 point_conversion_form_t;
struct ec_group_st ;
typedef struct ec_group_st EC_GROUP;
struct ec_point_st ;
typedef struct ec_point_st EC_POINT;
struct ec_key_st ;
typedef struct ec_key_st EC_KEY;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
typedef void CURL;
enum __anonenum_CURLcode_1040171027 {
    CURLE_OK = 0,
    CURLE_UNSUPPORTED_PROTOCOL = 1,
    CURLE_FAILED_INIT = 2,
    CURLE_URL_MALFORMAT = 3,
    CURLE_NOT_BUILT_IN = 4,
    CURLE_COULDNT_RESOLVE_PROXY = 5,
    CURLE_COULDNT_RESOLVE_HOST = 6,
    CURLE_COULDNT_CONNECT = 7,
    CURLE_WEIRD_SERVER_REPLY = 8,
    CURLE_REMOTE_ACCESS_DENIED = 9,
    CURLE_FTP_ACCEPT_FAILED = 10,
    CURLE_FTP_WEIRD_PASS_REPLY = 11,
    CURLE_FTP_ACCEPT_TIMEOUT = 12,
    CURLE_FTP_WEIRD_PASV_REPLY = 13,
    CURLE_FTP_WEIRD_227_FORMAT = 14,
    CURLE_FTP_CANT_GET_HOST = 15,
    CURLE_HTTP2 = 16,
    CURLE_FTP_COULDNT_SET_TYPE = 17,
    CURLE_PARTIAL_FILE = 18,
    CURLE_FTP_COULDNT_RETR_FILE = 19,
    CURLE_OBSOLETE20 = 20,
    CURLE_QUOTE_ERROR = 21,
    CURLE_HTTP_RETURNED_ERROR = 22,
    CURLE_WRITE_ERROR = 23,
    CURLE_OBSOLETE24 = 24,
    CURLE_UPLOAD_FAILED = 25,
    CURLE_READ_ERROR = 26,
    CURLE_OUT_OF_MEMORY = 27,
    CURLE_OPERATION_TIMEDOUT = 28,
    CURLE_OBSOLETE29 = 29,
    CURLE_FTP_PORT_FAILED = 30,
    CURLE_FTP_COULDNT_USE_REST = 31,
    CURLE_OBSOLETE32 = 32,
    CURLE_RANGE_ERROR = 33,
    CURLE_HTTP_POST_ERROR = 34,
    CURLE_SSL_CONNECT_ERROR = 35,
    CURLE_BAD_DOWNLOAD_RESUME = 36,
    CURLE_FILE_COULDNT_READ_FILE = 37,
    CURLE_LDAP_CANNOT_BIND = 38,
    CURLE_LDAP_SEARCH_FAILED = 39,
    CURLE_OBSOLETE40 = 40,
    CURLE_FUNCTION_NOT_FOUND = 41,
    CURLE_ABORTED_BY_CALLBACK = 42,
    CURLE_BAD_FUNCTION_ARGUMENT = 43,
    CURLE_OBSOLETE44 = 44,
    CURLE_INTERFACE_FAILED = 45,
    CURLE_OBSOLETE46 = 46,
    CURLE_TOO_MANY_REDIRECTS = 47,
    CURLE_UNKNOWN_OPTION = 48,
    CURLE_TELNET_OPTION_SYNTAX = 49,
    CURLE_OBSOLETE50 = 50,
    CURLE_OBSOLETE51 = 51,
    CURLE_GOT_NOTHING = 52,
    CURLE_SSL_ENGINE_NOTFOUND = 53,
    CURLE_SSL_ENGINE_SETFAILED = 54,
    CURLE_SEND_ERROR = 55,
    CURLE_RECV_ERROR = 56,
    CURLE_OBSOLETE57 = 57,
    CURLE_SSL_CERTPROBLEM = 58,
    CURLE_SSL_CIPHER = 59,
    CURLE_PEER_FAILED_VERIFICATION = 60,
    CURLE_BAD_CONTENT_ENCODING = 61,
    CURLE_LDAP_INVALID_URL = 62,
    CURLE_FILESIZE_EXCEEDED = 63,
    CURLE_USE_SSL_FAILED = 64,
    CURLE_SEND_FAIL_REWIND = 65,
    CURLE_SSL_ENGINE_INITFAILED = 66,
    CURLE_LOGIN_DENIED = 67,
    CURLE_TFTP_NOTFOUND = 68,
    CURLE_TFTP_PERM = 69,
    CURLE_REMOTE_DISK_FULL = 70,
    CURLE_TFTP_ILLEGAL = 71,
    CURLE_TFTP_UNKNOWNID = 72,
    CURLE_REMOTE_FILE_EXISTS = 73,
    CURLE_TFTP_NOSUCHUSER = 74,
    CURLE_CONV_FAILED = 75,
    CURLE_CONV_REQD = 76,
    CURLE_SSL_CACERT_BADFILE = 77,
    CURLE_REMOTE_FILE_NOT_FOUND = 78,
    CURLE_SSH = 79,
    CURLE_SSL_SHUTDOWN_FAILED = 80,
    CURLE_AGAIN = 81,
    CURLE_SSL_CRL_BADFILE = 82,
    CURLE_SSL_ISSUER_ERROR = 83,
    CURLE_FTP_PRET_FAILED = 84,
    CURLE_RTSP_CSEQ_ERROR = 85,
    CURLE_RTSP_SESSION_ERROR = 86,
    CURLE_FTP_BAD_FILE_LIST = 87,
    CURLE_CHUNK_FAILED = 88,
    CURLE_NO_CONNECTION_AVAILABLE = 89,
    CURLE_SSL_PINNEDPUBKEYNOTMATCH = 90,
    CURLE_SSL_INVALIDCERTSTATUS = 91,
    CURLE_HTTP2_STREAM = 92,
    CURLE_RECURSIVE_API_CALL = 93,
    CURLE_AUTH_ERROR = 94,
    CURLE_HTTP3 = 95,
    CURL_LAST = 96
} ;
typedef enum __anonenum_CURLcode_1040171027 CURLcode;
enum __anonenum_CURLoption_714703655 {
    CURLOPT_WRITEDATA = 10001,
    CURLOPT_URL = 10002,
    CURLOPT_PORT = 3,
    CURLOPT_PROXY = 10004,
    CURLOPT_USERPWD = 10005,
    CURLOPT_PROXYUSERPWD = 10006,
    CURLOPT_RANGE = 10007,
    CURLOPT_READDATA = 10009,
    CURLOPT_ERRORBUFFER = 10010,
    CURLOPT_WRITEFUNCTION = 20011,
    CURLOPT_READFUNCTION = 20012,
    CURLOPT_TIMEOUT = 13,
    CURLOPT_INFILESIZE = 14,
    CURLOPT_POSTFIELDS = 10015,
    CURLOPT_REFERER = 10016,
    CURLOPT_FTPPORT = 10017,
    CURLOPT_USERAGENT = 10018,
    CURLOPT_LOW_SPEED_LIMIT = 19,
    CURLOPT_LOW_SPEED_TIME = 20,
    CURLOPT_RESUME_FROM = 21,
    CURLOPT_COOKIE = 10022,
    CURLOPT_HTTPHEADER = 10023,
    CURLOPT_HTTPPOST = 10024,
    CURLOPT_SSLCERT = 10025,
    CURLOPT_KEYPASSWD = 10026,
    CURLOPT_CRLF = 27,
    CURLOPT_QUOTE = 10028,
    CURLOPT_HEADERDATA = 10029,
    CURLOPT_COOKIEFILE = 10031,
    CURLOPT_SSLVERSION = 32,
    CURLOPT_TIMECONDITION = 33,
    CURLOPT_TIMEVALUE = 34,
    CURLOPT_CUSTOMREQUEST = 10036,
    CURLOPT_STDERR = 10037,
    CURLOPT_POSTQUOTE = 10039,
    CURLOPT_OBSOLETE40 = 10040,
    CURLOPT_VERBOSE = 41,
    CURLOPT_HEADER = 42,
    CURLOPT_NOPROGRESS = 43,
    CURLOPT_NOBODY = 44,
    CURLOPT_FAILONERROR = 45,
    CURLOPT_UPLOAD = 46,
    CURLOPT_POST = 47,
    CURLOPT_DIRLISTONLY = 48,
    CURLOPT_APPEND = 50,
    CURLOPT_NETRC = 51,
    CURLOPT_FOLLOWLOCATION = 52,
    CURLOPT_TRANSFERTEXT = 53,
    CURLOPT_PUT = 54,
    CURLOPT_PROGRESSFUNCTION = 20056,
    CURLOPT_PROGRESSDATA = 10057,
    CURLOPT_AUTOREFERER = 58,
    CURLOPT_PROXYPORT = 59,
    CURLOPT_POSTFIELDSIZE = 60,
    CURLOPT_HTTPPROXYTUNNEL = 61,
    CURLOPT_INTERFACE = 10062,
    CURLOPT_KRBLEVEL = 10063,
    CURLOPT_SSL_VERIFYPEER = 64,
    CURLOPT_CAINFO = 10065,
    CURLOPT_MAXREDIRS = 68,
    CURLOPT_FILETIME = 69,
    CURLOPT_TELNETOPTIONS = 10070,
    CURLOPT_MAXCONNECTS = 71,
    CURLOPT_OBSOLETE72 = 72,
    CURLOPT_FRESH_CONNECT = 74,
    CURLOPT_FORBID_REUSE = 75,
    CURLOPT_RANDOM_FILE = 10076,
    CURLOPT_EGDSOCKET = 10077,
    CURLOPT_CONNECTTIMEOUT = 78,
    CURLOPT_HEADERFUNCTION = 20079,
    CURLOPT_HTTPGET = 80,
    CURLOPT_SSL_VERIFYHOST = 81,
    CURLOPT_COOKIEJAR = 10082,
    CURLOPT_SSL_CIPHER_LIST = 10083,
    CURLOPT_HTTP_VERSION = 84,
    CURLOPT_FTP_USE_EPSV = 85,
    CURLOPT_SSLCERTTYPE = 10086,
    CURLOPT_SSLKEY = 10087,
    CURLOPT_SSLKEYTYPE = 10088,
    CURLOPT_SSLENGINE = 10089,
    CURLOPT_SSLENGINE_DEFAULT = 90,
    CURLOPT_DNS_USE_GLOBAL_CACHE = 91,
    CURLOPT_DNS_CACHE_TIMEOUT = 92,
    CURLOPT_PREQUOTE = 10093,
    CURLOPT_DEBUGFUNCTION = 20094,
    CURLOPT_DEBUGDATA = 10095,
    CURLOPT_COOKIESESSION = 96,
    CURLOPT_CAPATH = 10097,
    CURLOPT_BUFFERSIZE = 98,
    CURLOPT_NOSIGNAL = 99,
    CURLOPT_SHARE = 10100,
    CURLOPT_PROXYTYPE = 101,
    CURLOPT_ACCEPT_ENCODING = 10102,
    CURLOPT_PRIVATE = 10103,
    CURLOPT_HTTP200ALIASES = 10104,
    CURLOPT_UNRESTRICTED_AUTH = 105,
    CURLOPT_FTP_USE_EPRT = 106,
    CURLOPT_HTTPAUTH = 107,
    CURLOPT_SSL_CTX_FUNCTION = 20108,
    CURLOPT_SSL_CTX_DATA = 10109,
    CURLOPT_FTP_CREATE_MISSING_DIRS = 110,
    CURLOPT_PROXYAUTH = 111,
    CURLOPT_FTP_RESPONSE_TIMEOUT = 112,
    CURLOPT_IPRESOLVE = 113,
    CURLOPT_MAXFILESIZE = 114,
    CURLOPT_INFILESIZE_LARGE = 30115,
    CURLOPT_RESUME_FROM_LARGE = 30116,
    CURLOPT_MAXFILESIZE_LARGE = 30117,
    CURLOPT_NETRC_FILE = 10118,
    CURLOPT_USE_SSL = 119,
    CURLOPT_POSTFIELDSIZE_LARGE = 30120,
    CURLOPT_TCP_NODELAY = 121,
    CURLOPT_FTPSSLAUTH = 129,
    CURLOPT_IOCTLFUNCTION = 20130,
    CURLOPT_IOCTLDATA = 10131,
    CURLOPT_FTP_ACCOUNT = 10134,
    CURLOPT_COOKIELIST = 10135,
    CURLOPT_IGNORE_CONTENT_LENGTH = 136,
    CURLOPT_FTP_SKIP_PASV_IP = 137,
    CURLOPT_FTP_FILEMETHOD = 138,
    CURLOPT_LOCALPORT = 139,
    CURLOPT_LOCALPORTRANGE = 140,
    CURLOPT_CONNECT_ONLY = 141,
    CURLOPT_CONV_FROM_NETWORK_FUNCTION = 20142,
    CURLOPT_CONV_TO_NETWORK_FUNCTION = 20143,
    CURLOPT_CONV_FROM_UTF8_FUNCTION = 20144,
    CURLOPT_MAX_SEND_SPEED_LARGE = 30145,
    CURLOPT_MAX_RECV_SPEED_LARGE = 30146,
    CURLOPT_FTP_ALTERNATIVE_TO_USER = 10147,
    CURLOPT_SOCKOPTFUNCTION = 20148,
    CURLOPT_SOCKOPTDATA = 10149,
    CURLOPT_SSL_SESSIONID_CACHE = 150,
    CURLOPT_SSH_AUTH_TYPES = 151,
    CURLOPT_SSH_PUBLIC_KEYFILE = 10152,
    CURLOPT_SSH_PRIVATE_KEYFILE = 10153,
    CURLOPT_FTP_SSL_CCC = 154,
    CURLOPT_TIMEOUT_MS = 155,
    CURLOPT_CONNECTTIMEOUT_MS = 156,
    CURLOPT_HTTP_TRANSFER_DECODING = 157,
    CURLOPT_HTTP_CONTENT_DECODING = 158,
    CURLOPT_NEW_FILE_PERMS = 159,
    CURLOPT_NEW_DIRECTORY_PERMS = 160,
    CURLOPT_POSTREDIR = 161,
    CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 = 10162,
    CURLOPT_OPENSOCKETFUNCTION = 20163,
    CURLOPT_OPENSOCKETDATA = 10164,
    CURLOPT_COPYPOSTFIELDS = 10165,
    CURLOPT_PROXY_TRANSFER_MODE = 166,
    CURLOPT_SEEKFUNCTION = 20167,
    CURLOPT_SEEKDATA = 10168,
    CURLOPT_CRLFILE = 10169,
    CURLOPT_ISSUERCERT = 10170,
    CURLOPT_ADDRESS_SCOPE = 171,
    CURLOPT_CERTINFO = 172,
    CURLOPT_USERNAME = 10173,
    CURLOPT_PASSWORD = 10174,
    CURLOPT_PROXYUSERNAME = 10175,
    CURLOPT_PROXYPASSWORD = 10176,
    CURLOPT_NOPROXY = 10177,
    CURLOPT_TFTP_BLKSIZE = 178,
    CURLOPT_SOCKS5_GSSAPI_SERVICE = 10179,
    CURLOPT_SOCKS5_GSSAPI_NEC = 180,
    CURLOPT_PROTOCOLS = 181,
    CURLOPT_REDIR_PROTOCOLS = 182,
    CURLOPT_SSH_KNOWNHOSTS = 10183,
    CURLOPT_SSH_KEYFUNCTION = 20184,
    CURLOPT_SSH_KEYDATA = 10185,
    CURLOPT_MAIL_FROM = 10186,
    CURLOPT_MAIL_RCPT = 10187,
    CURLOPT_FTP_USE_PRET = 188,
    CURLOPT_RTSP_REQUEST = 189,
    CURLOPT_RTSP_SESSION_ID = 10190,
    CURLOPT_RTSP_STREAM_URI = 10191,
    CURLOPT_RTSP_TRANSPORT = 10192,
    CURLOPT_RTSP_CLIENT_CSEQ = 193,
    CURLOPT_RTSP_SERVER_CSEQ = 194,
    CURLOPT_INTERLEAVEDATA = 10195,
    CURLOPT_INTERLEAVEFUNCTION = 20196,
    CURLOPT_WILDCARDMATCH = 197,
    CURLOPT_CHUNK_BGN_FUNCTION = 20198,
    CURLOPT_CHUNK_END_FUNCTION = 20199,
    CURLOPT_FNMATCH_FUNCTION = 20200,
    CURLOPT_CHUNK_DATA = 10201,
    CURLOPT_FNMATCH_DATA = 10202,
    CURLOPT_RESOLVE = 10203,
    CURLOPT_TLSAUTH_USERNAME = 10204,
    CURLOPT_TLSAUTH_PASSWORD = 10205,
    CURLOPT_TLSAUTH_TYPE = 10206,
    CURLOPT_TRANSFER_ENCODING = 207,
    CURLOPT_CLOSESOCKETFUNCTION = 20208,
    CURLOPT_CLOSESOCKETDATA = 10209,
    CURLOPT_GSSAPI_DELEGATION = 210,
    CURLOPT_DNS_SERVERS = 10211,
    CURLOPT_ACCEPTTIMEOUT_MS = 212,
    CURLOPT_TCP_KEEPALIVE = 213,
    CURLOPT_TCP_KEEPIDLE = 214,
    CURLOPT_TCP_KEEPINTVL = 215,
    CURLOPT_SSL_OPTIONS = 216,
    CURLOPT_MAIL_AUTH = 10217,
    CURLOPT_SASL_IR = 218,
    CURLOPT_XFERINFOFUNCTION = 20219,
    CURLOPT_XOAUTH2_BEARER = 10220,
    CURLOPT_DNS_INTERFACE = 10221,
    CURLOPT_DNS_LOCAL_IP4 = 10222,
    CURLOPT_DNS_LOCAL_IP6 = 10223,
    CURLOPT_LOGIN_OPTIONS = 10224,
    CURLOPT_SSL_ENABLE_NPN = 225,
    CURLOPT_SSL_ENABLE_ALPN = 226,
    CURLOPT_EXPECT_100_TIMEOUT_MS = 227,
    CURLOPT_PROXYHEADER = 10228,
    CURLOPT_HEADEROPT = 229,
    CURLOPT_PINNEDPUBLICKEY = 10230,
    CURLOPT_UNIX_SOCKET_PATH = 10231,
    CURLOPT_SSL_VERIFYSTATUS = 232,
    CURLOPT_SSL_FALSESTART = 233,
    CURLOPT_PATH_AS_IS = 234,
    CURLOPT_PROXY_SERVICE_NAME = 10235,
    CURLOPT_SERVICE_NAME = 10236,
    CURLOPT_PIPEWAIT = 237,
    CURLOPT_DEFAULT_PROTOCOL = 10238,
    CURLOPT_STREAM_WEIGHT = 239,
    CURLOPT_STREAM_DEPENDS = 10240,
    CURLOPT_STREAM_DEPENDS_E = 10241,
    CURLOPT_TFTP_NO_OPTIONS = 242,
    CURLOPT_CONNECT_TO = 10243,
    CURLOPT_TCP_FASTOPEN = 244,
    CURLOPT_KEEP_SENDING_ON_ERROR = 245,
    CURLOPT_PROXY_CAINFO = 10246,
    CURLOPT_PROXY_CAPATH = 10247,
    CURLOPT_PROXY_SSL_VERIFYPEER = 248,
    CURLOPT_PROXY_SSL_VERIFYHOST = 249,
    CURLOPT_PROXY_SSLVERSION = 250,
    CURLOPT_PROXY_TLSAUTH_USERNAME = 10251,
    CURLOPT_PROXY_TLSAUTH_PASSWORD = 10252,
    CURLOPT_PROXY_TLSAUTH_TYPE = 10253,
    CURLOPT_PROXY_SSLCERT = 10254,
    CURLOPT_PROXY_SSLCERTTYPE = 10255,
    CURLOPT_PROXY_SSLKEY = 10256,
    CURLOPT_PROXY_SSLKEYTYPE = 10257,
    CURLOPT_PROXY_KEYPASSWD = 10258,
    CURLOPT_PROXY_SSL_CIPHER_LIST = 10259,
    CURLOPT_PROXY_CRLFILE = 10260,
    CURLOPT_PROXY_SSL_OPTIONS = 261,
    CURLOPT_PRE_PROXY = 10262,
    CURLOPT_PROXY_PINNEDPUBLICKEY = 10263,
    CURLOPT_ABSTRACT_UNIX_SOCKET = 10264,
    CURLOPT_SUPPRESS_CONNECT_HEADERS = 265,
    CURLOPT_REQUEST_TARGET = 10266,
    CURLOPT_SOCKS5_AUTH = 267,
    CURLOPT_SSH_COMPRESSION = 268,
    CURLOPT_MIMEPOST = 10269,
    CURLOPT_TIMEVALUE_LARGE = 30270,
    CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS = 271,
    CURLOPT_RESOLVER_START_FUNCTION = 20272,
    CURLOPT_RESOLVER_START_DATA = 10273,
    CURLOPT_HAPROXYPROTOCOL = 274,
    CURLOPT_DNS_SHUFFLE_ADDRESSES = 275,
    CURLOPT_TLS13_CIPHERS = 10276,
    CURLOPT_PROXY_TLS13_CIPHERS = 10277,
    CURLOPT_DISALLOW_USERNAME_IN_URL = 278,
    CURLOPT_DOH_URL = 10279,
    CURLOPT_UPLOAD_BUFFERSIZE = 280,
    CURLOPT_UPKEEP_INTERVAL_MS = 281,
    CURLOPT_CURLU = 10282,
    CURLOPT_TRAILERFUNCTION = 20283,
    CURLOPT_TRAILERDATA = 10284,
    CURLOPT_HTTP09_ALLOWED = 285,
    CURLOPT_ALTSVC_CTRL = 286,
    CURLOPT_ALTSVC = 10287,
    CURLOPT_MAXAGE_CONN = 288,
    CURLOPT_SASL_AUTHZID = 10289,
    CURLOPT_LASTENTRY = 10290
} ;
typedef enum __anonenum_CURLoption_714703655 CURLoption;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct _vg_context_s ;
typedef struct _vg_context_s vg_context_t;
struct _vg_exec_context_s ;
typedef struct _vg_exec_context_s vg_exec_context_t;
struct _vg_exec_context_s {
   vg_context_t *vxc_vc ;
   BN_CTX *vxc_bnctx ;
   EC_KEY *vxc_key ;
   int vxc_delta ;
   unsigned char vxc_binres[28] ;
   BIGNUM vxc_bntarg ;
   BIGNUM vxc_bnbase ;
   BIGNUM vxc_bntmp ;
   BIGNUM vxc_bntmp2 ;
   void *(*vxc_threadfunc)(vg_exec_context_t * ) ;
   pthread_t vxc_pthread ;
   int vxc_thread_active ;
   struct _vg_exec_context_s *vxc_next ;
   int vxc_lockmode ;
   int vxc_stop ;
};
enum vg_format {
    VCF_PUBKEY = 0,
    VCF_SCRIPT = 1
} ;
struct _timing_info_s ;
struct _vg_context_s {
   int vc_addrtype ;
   int vc_privtype ;
   unsigned long vc_npatterns ;
   unsigned long vc_npatterns_start ;
   unsigned long long vc_found ;
   int vc_pattern_generation ;
   double vc_chance ;
   char const   *vc_result_file ;
   char const   *vc_key_protect_pass ;
   int vc_remove_on_match ;
   int vc_only_one ;
   int vc_verbose ;
   enum vg_format vc_format ;
   int vc_pubkeytype ;
   EC_POINT *vc_pubkey_base ;
   int vc_halt ;
   vg_exec_context_t *vc_threads ;
   int vc_thread_excl ;
   void (*vc_free)(vg_context_t * ) ;
   int (*vc_add_patterns)(vg_context_t * , char const   ** const  patterns , int npatterns ) ;
   void (*vc_clear_all_patterns)(vg_context_t * ) ;
   int (*vc_test)(vg_exec_context_t * ) ;
   int (*vc_hash160_sort)(vg_context_t *vcp , void *buf ) ;
   unsigned long long vc_timing_total ;
   unsigned long long vc_timing_prevfound ;
   unsigned long long vc_timing_sincelast ;
   struct _timing_info_s *vc_timing_head ;
   void (*vc_output_error)(vg_context_t *vcp , char const   *info ) ;
   void (*vc_output_match)(vg_context_t *vcp , EC_KEY *pkey , char const   *pattern ) ;
   void (*vc_output_timing)(vg_context_t *vcp , double count , unsigned long long rate ,
                            unsigned long long total ) ;
};
struct _vg_ocl_context_s ;
typedef struct _vg_ocl_context_s vg_ocl_context_t;
enum __anonenum_avl_balance_t_281414157 {
    CENT = 1,
    LEFT = 0,
    RIGHT = 2
} ;
typedef enum __anonenum_avl_balance_t_281414157 avl_balance_t;
struct _avl_item_s {
   struct _avl_item_s *ai_left ;
   struct _avl_item_s *ai_right ;
   struct _avl_item_s *ai_up ;
   avl_balance_t ai_balance ;
   int ai_indexed ;
};
typedef struct _avl_item_s avl_item_t;
struct _avl_root_s {
   avl_item_t *ar_root ;
};
typedef struct _avl_root_s avl_root_t;
struct workitem_s {
   avl_item_t avlent ;
   char const   *pattern ;
   char const   *comment ;
   EC_POINT *pubkey ;
   int addrtype ;
   double difficulty ;
   double reward ;
   double value ;
};
typedef struct workitem_s workitem_t;
struct pubkeybatch_s {
   avl_item_t avlent ;
   EC_POINT *pubkey ;
   char const   *pubkey_hex ;
   avl_root_t items ;
   int nitems ;
   double total_value ;
};
typedef struct pubkeybatch_s pubkeybatch_t;
struct server_request_s {
   int request_status ;
   EC_GROUP const   *group ;
   char *part_buf ;
   size_t part_off ;
   size_t part_end ;
   size_t part_size ;
   avl_root_t items ;
   int nitems ;
};
typedef struct server_request_s server_request_t;
struct server_context_s {
   EC_KEY *dummy_key ;
   char const   *url ;
   char const   *credit_addr ;
   char *getwork ;
   char *submit ;
   int verbose ;
   avl_root_t items ;
   int nitems ;
};
typedef struct server_context_s server_context_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
struct real_pcre ;
typedef struct real_pcre pcre;
struct pcre_extra {
   unsigned long flags ;
   void *study_data ;
   unsigned long match_limit ;
   void *callout_data ;
   unsigned char const   *tables ;
   unsigned long match_limit_recursion ;
   unsigned char **mark ;
   void *executable_jit ;
};
typedef struct pcre_extra pcre_extra;
struct _timing_info_s {
   struct _timing_info_s *ti_next ;
   pthread_t ti_thread ;
   unsigned long ti_last_rate ;
   unsigned long long ti_hist_time[5] ;
   unsigned long ti_hist_work[5] ;
   int ti_hist_last ;
};
typedef struct _timing_info_s timing_info_t;
struct _vg_prefix_s {
   avl_item_t vp_item ;
   struct _vg_prefix_s *vp_sibling ;
   char const   *vp_pattern ;
   BIGNUM *vp_low ;
   BIGNUM *vp_high ;
};
typedef struct _vg_prefix_s vg_prefix_t;
struct _prefix_case_iter_s {
   char ci_prefix[32] ;
   char ci_case_map[32] ;
   char ci_nbits ;
   int ci_value ;
};
typedef struct _prefix_case_iter_s prefix_case_iter_t;
struct _vg_prefix_context_s {
   vg_context_t base ;
   avl_root_t vcp_avlroot ;
   BIGNUM vcp_difficulty ;
   int vcp_caseinsensitive ;
};
typedef struct _vg_prefix_context_s vg_prefix_context_t;
struct _vg_regex_context_s {
   vg_context_t base ;
   pcre **vcr_regex ;
   pcre_extra **vcr_regex_extra ;
   char const   **vcr_regex_pat ;
   unsigned long vcr_nalloc ;
};
typedef struct _vg_regex_context_s vg_regex_context_t;
struct asn1_string_st ;
typedef struct asn1_string_st ASN1_INTEGER;
typedef struct asn1_string_st ASN1_ENUMERATED;
typedef struct asn1_string_st ASN1_BIT_STRING;
typedef struct asn1_string_st ASN1_OCTET_STRING;
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
typedef struct asn1_string_st ASN1_T61STRING;
typedef struct asn1_string_st ASN1_IA5STRING;
typedef struct asn1_string_st ASN1_GENERALSTRING;
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
typedef struct asn1_string_st ASN1_BMPSTRING;
typedef struct asn1_string_st ASN1_UTCTIME;
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
typedef struct asn1_string_st ASN1_VISIBLESTRING;
typedef struct asn1_string_st ASN1_UTF8STRING;
typedef struct asn1_string_st ASN1_STRING;
typedef int ASN1_BOOLEAN;
struct bn_blinding_st ;
typedef struct bn_blinding_st BN_BLINDING;
struct bn_mont_ctx_st ;
typedef struct bn_mont_ctx_st BN_MONT_CTX;
struct bn_gencb_st ;
typedef struct bn_gencb_st BN_GENCB;
struct buf_mem_st ;
typedef struct buf_mem_st BUF_MEM;
struct evp_cipher_st ;
typedef struct evp_cipher_st EVP_CIPHER;
struct evp_cipher_ctx_st ;
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
struct env_md_st ;
typedef struct env_md_st EVP_MD;
struct env_md_ctx_st ;
typedef struct env_md_ctx_st EVP_MD_CTX;
struct evp_pkey_st ;
typedef struct evp_pkey_st EVP_PKEY;
struct evp_pkey_asn1_method_st ;
typedef struct evp_pkey_asn1_method_st EVP_PKEY_ASN1_METHOD;
struct evp_pkey_ctx_st ;
typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;
struct dh_st ;
typedef struct dh_st DH;
struct dh_method ;
typedef struct dh_method DH_METHOD;
struct dsa_st ;
typedef struct dsa_st DSA;
struct dsa_method ;
typedef struct dsa_method DSA_METHOD;
struct rsa_st ;
typedef struct rsa_st RSA;
struct rsa_meth_st ;
typedef struct rsa_meth_st RSA_METHOD;
struct X509_algor_st ;
typedef struct X509_algor_st X509_ALGOR;
struct pkcs8_priv_key_info_st ;
typedef struct pkcs8_priv_key_info_st PKCS8_PRIV_KEY_INFO;
struct engine_st ;
typedef struct engine_st ENGINE;
struct crypto_ex_data_st ;
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(void const   * , void const   * ) ;
};
typedef struct stack_st _STACK;
struct bio_st ;
struct stack_st_void ;
struct crypto_ex_data_st {
   struct stack_st_void *sk ;
   int dummy ;
};
struct stack_st_void {
   _STACK stack ;
};
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0[2] ;
   int flags ;
};
union __anonunion_cb_888073939 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_888073939 cb ;
};
typedef struct bio_st BIO;
typedef void bio_info_cb(struct bio_st * , int  , char const   * , int  , long  ,
                         long  );
struct bio_method_st {
   int type ;
   char const   *name ;
   int (*bwrite)(BIO * , char const   * , int  ) ;
   int (*bread)(BIO * , char * , int  ) ;
   int (*bputs)(BIO * , char const   * ) ;
   int (*bgets)(BIO * , char * , int  ) ;
   long (*ctrl)(BIO * , int  , long  , void * ) ;
   int (*create)(BIO * ) ;
   int (*destroy)(BIO * ) ;
   long (*callback_ctrl)(BIO * , int  , bio_info_cb * ) ;
};
typedef struct bio_method_st BIO_METHOD;
struct bio_st {
   BIO_METHOD *method ;
   long (*callback)(struct bio_st * , int  , char const   * , int  , long  , long  ) ;
   char *cb_arg ;
   int init ;
   int shutdown ;
   int flags ;
   int retry_reason ;
   int num ;
   void *ptr ;
   struct bio_st *next_bio ;
   struct bio_st *prev_bio ;
   int references ;
   unsigned long num_read ;
   unsigned long num_write ;
   CRYPTO_EX_DATA ex_data ;
};
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char const   *data ;
   int flags ;
};
typedef struct asn1_object_st ASN1_OBJECT;
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
struct ASN1_VALUE_st ;
typedef struct ASN1_VALUE_st ASN1_VALUE;
union __anonunion_value_401497255 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
   ASN1_VALUE *asn1_value ;
};
struct asn1_type_st {
   int type ;
   union __anonunion_value_401497255 value ;
};
typedef struct asn1_type_st ASN1_TYPE;
union __anonunion_pkey_1024245030 {
   char *ptr ;
   struct rsa_st *rsa ;
   struct dsa_st *dsa ;
   struct dh_st *dh ;
   struct ec_key_st *ec ;
};
struct stack_st_X509_ATTRIBUTE ;
struct evp_pkey_st {
   int type ;
   int save_type ;
   int references ;
   EVP_PKEY_ASN1_METHOD const   *ameth ;
   ENGINE *engine ;
   union __anonunion_pkey_1024245030 pkey ;
   int save_parameters ;
   struct stack_st_X509_ATTRIBUTE *attributes ;
};
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
   int (*md_ctrl)(EVP_MD_CTX *ctx , int cmd , int p1 , void *p2 ) ;
};
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
   EVP_PKEY_CTX *pctx ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
};
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    size_t inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
struct buf_mem_st {
   size_t length ;
   char *data ;
   size_t max ;
};
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char const   *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
typedef struct DSA_SIG_st DSA_SIG;
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char const   *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
struct X509_algor_st {
   ASN1_OBJECT *algorithm ;
   ASN1_TYPE *parameter ;
};
struct X509_sig_st {
   X509_ALGOR *algor ;
   ASN1_OCTET_STRING *digest ;
};
typedef struct X509_sig_st X509_SIG;
struct stack_st_X509_ATTRIBUTE {
   _STACK stack ;
};
struct pkcs8_priv_key_info_st {
   int broken ;
   ASN1_INTEGER *version ;
   X509_ALGOR *pkeyalg ;
   ASN1_TYPE *pkey ;
   struct stack_st_X509_ATTRIBUTE *attributes ;
};
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
struct __anonstruct_vg_protkey_parameters_t_1070732568 {
   int mode ;
   int iterations ;
   EVP_MD const   *(*pbkdf_hash_getter)(void) ;
   EVP_CIPHER const   *(*cipher_getter)(void) ;
};
typedef struct __anonstruct_vg_protkey_parameters_t_1070732568 vg_protkey_parameters_t;
/* compiler builtin:
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin:
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin:
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin:
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin:
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin:
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin:
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin:
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin:
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-YNFZ1O0H.i","-ggdb,-O3,-Wall")
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                             pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                                        pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                             pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                               pthread_t __thread2 )
{


  {
  return (__thread1 == __thread2);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atoi)(char const   *__nptr )
{
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atol)(char const   *__nptr )
{
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__, __gnu_inline__)) atoll)(char const   *__nptr )
{
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__, __alloc_size__(1))) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size )  __attribute__((__alloc_size__(2))) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                        char * __restrict  __resolved ) ;
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) )
{
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) wctomb)(char *__s ,
                                                                      wchar_t __wchar ) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                                              size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                                              size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__)) atof)(char const   *__nptr )
{
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_chk)(char const   * __restrict  __name , char * __restrict  __resolved ,
                           size_t __resolvedlen ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_alias)(char const   * __restrict  __name , char * __restrict  __resolved )  __asm__("realpath")  ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                        char * __restrict  __resolved ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                              char * __restrict  __resolved )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__resolved, 1);
    tmp___0 = __realpath_chk(__name, __resolved, tmp);
    return (tmp___0);
  }
  tmp___2 = __realpath_alias(__name, __resolved);
  return (tmp___2);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ptsname_r")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"))) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) ;
__inline extern int ( __attribute__((__leaf__, __gnu_inline__, __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                                              char *__buf ,
                                                                                                              size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_chk)(char *__s , wchar_t __wchar , size_t __buflen ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_alias)(char *__s , wchar_t __wchar )  __asm__("wctomb")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) wctomb)(char *__s ,
                                                                      wchar_t __wchar ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = __builtin_object_size((void *)__s, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp___2 = __builtin_object_size((void *)__s, 1);
    if (16UL > tmp___2) {
      tmp = __builtin_object_size((void *)__s, 1);
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
      return (tmp___0);
    }
  }
  tmp___3 = __wctomb_alias(__s, __wchar);
  return (tmp___3);
}
}
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk)(wchar_t * __restrict  __dst ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_alias)(wchar_t * __restrict  __dst ,
                                                                                          char const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("mbstowcs")  ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk_warn)(wchar_t * __restrict  __dst ,
                                                                                             char const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                                              size_t __len ) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __mbstowcs_chk(__dst, __src, __len, tmp / sizeof(wchar_t ));
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    if (__len > tmp___3 / sizeof(wchar_t )) {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __mbstowcs_chk_warn(__dst, __src, __len, tmp___1 / sizeof(wchar_t ));
      return (tmp___2);
    }
  }
  tmp___5 = __mbstowcs_alias(__dst, __src, __len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk)(char * __restrict  __dst ,
                                                                                        wchar_t const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_alias)(char * __restrict  __dst ,
                                                                                          wchar_t const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("wcstombs")  ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk_warn)(char * __restrict  __dst ,
                                                                                             wchar_t const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"))) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                                              size_t __len ) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __wcstombs_chk(__dst, __src, __len, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    if (__len > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __wcstombs_chk_warn(__dst, __src, __len, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __wcstombs_alias(__dst, __src, __len);
  return (tmp___5);
}
}
extern void CRYPTO_free(void *ptr ) ;
extern char *BN_bn2hex(BIGNUM const   *a ) ;
extern void EC_POINT_free(EC_POINT *point ) ;
extern char *EC_POINT_point2hex(EC_GROUP const   * , EC_POINT const   * , point_conversion_form_t form ,
                                BN_CTX * ) ;
extern EC_POINT *EC_POINT_hex2point(EC_GROUP const   * , char const   * , EC_POINT * ,
                                    BN_CTX * ) ;
extern int EC_POINT_cmp(EC_GROUP const   *group , EC_POINT const   *a , EC_POINT const   *b ,
                        BN_CTX *ctx ) ;
extern void EC_KEY_free(EC_KEY *key ) ;
extern EC_GROUP const   *EC_KEY_get0_group(EC_KEY const   *key ) ;
extern BIGNUM const   *EC_KEY_get0_private_key(EC_KEY const   *key ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__,
__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__,
__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__leaf__, __gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                           struct cmsghdr *__cmsg )
{


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
__inline extern ssize_t ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) recv)(int __fd ,
                                                                                                   void *__buf ,
                                                                                                   size_t __n ,
                                                                                                   int __flags ) ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) recvfrom)(int __fd ,
                                                                                                       void * __restrict  __buf ,
                                                                                                       size_t __n ,
                                                                                                       int __flags ,
                                                                                                       struct sockaddr * __restrict  __addr ,
                                                                                                       socklen_t * __restrict  __addr_len ) ;
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags )  __asm__("recv")  ;
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags )  __asm__("__recv_chk") __attribute__((__warning__("recv called with bigger length than size of destination buffer"))) ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) recv)(int __fd ,
                                                                                                   void *__buf ,
                                                                                                   size_t __n ,
                                                                                                   int __flags )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size(__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __recv_chk(__fd, __buf, __n, tmp, __flags);
    return (tmp___0);
    tmp___3 = __builtin_object_size(__buf, 0);
    if (__n > tmp___3) {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __recv_chk_warn(__fd, __buf, __n, tmp___1, __flags);
      return (tmp___2);
    }
  }
  tmp___5 = __recv_alias(__fd, __buf, __n, __flags);
  return (tmp___5);
}
}
extern ssize_t __recvfrom_chk(int __fd , void * __restrict  __buf , size_t __n , size_t __buflen ,
                              int __flags , struct sockaddr * __restrict  __addr ,
                              socklen_t * __restrict  __addr_len ) ;
extern ssize_t __recvfrom_alias(int __fd , void * __restrict  __buf , size_t __n ,
                                int __flags , struct sockaddr * __restrict  __addr ,
                                socklen_t * __restrict  __addr_len )  __asm__("recvfrom")  ;
extern ssize_t __recvfrom_chk_warn(int __fd , void * __restrict  __buf , size_t __n ,
                                   size_t __buflen , int __flags , struct sockaddr * __restrict  __addr ,
                                   socklen_t * __restrict  __addr_len )  __asm__("__recvfrom_chk") __attribute__((__warning__("recvfrom called with bigger length than size of destination buffer"))) ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __artificial__, __always_inline__)) recvfrom)(int __fd ,
                                                                                                       void * __restrict  __buf ,
                                                                                                       size_t __n ,
                                                                                                       int __flags ,
                                                                                                       struct sockaddr * __restrict  __addr ,
                                                                                                       socklen_t * __restrict  __addr_len )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 0);
    tmp___0 = __recvfrom_chk(__fd, __buf, __n, tmp, __flags, __addr, __addr_len);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 0);
    if (__n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 0);
      tmp___2 = __recvfrom_chk_warn(__fd, __buf, __n, tmp___1, __flags, __addr, __addr_len);
      return (tmp___2);
    }
  }
  tmp___5 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr, __addr_len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   void * __restrict  __tz ) ;
extern char const   *curl_easy_strerror(CURLcode  ) ;
extern CURL *curl_easy_init(void) ;
extern CURLcode curl_easy_setopt(CURL *curl , CURLoption option  , ...) ;
extern CURLcode curl_easy_perform(CURL *curl ) ;
extern void curl_easy_cleanup(CURL *curl ) ;
static void __attribute__((__warning__("curl_easy_setopt expects a long argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_long)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a long argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_long)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_off_t argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_off_t)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_off_t argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_off_t)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a string (\'char *\' or char[]) argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_string)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a string (\'char *\' or char[]) argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_string)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_write_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_write_callback)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_write_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_write_callback)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_resolver_start_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_resolver_start_callback)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_resolver_start_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_resolver_start_callback)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_read_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_read_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_read_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_read_cb)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_ioctl_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_ioctl_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_ioctl_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_ioctl_cb)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_sockopt_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_sockopt_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_sockopt_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_sockopt_cb)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_opensocket_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_opensocket_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_opensocket_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_opensocket_cb)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_progress_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_progress_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_progress_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_progress_cb)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_debug_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_debug_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_debug_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_debug_cb)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_ssl_ctx_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_ssl_ctx_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_ssl_ctx_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_ssl_ctx_cb)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_conv_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_conv_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_conv_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_conv_cb)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a curl_seek_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_seek_cb)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a curl_seek_callback argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_seek_cb)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a private data pointer as argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_cb_data)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a private data pointer as argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_cb_data)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a char buffer of CURL_ERROR_SIZE as argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_error_buffer)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a char buffer of CURL_ERROR_SIZE as argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_error_buffer)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a \'FILE *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_FILE)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a \'FILE *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_FILE)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a \'void *\' or \'char *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_postfields)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a \'void *\' or \'char *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_postfields)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a \'struct curl_httppost *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_httpost)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a \'struct curl_httppost *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_httpost)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a \'curl_mime *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_mimepost)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a \'curl_mime *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_mimepost)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a \'struct curl_slist *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_slist)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a \'struct curl_slist *\' argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_curl_slist)(void)
{


  {
  __asm__  ("":);
  return;
}
}
static void __attribute__((__warning__("curl_easy_setopt expects a CURLSH* argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_CURLSH)(void)  __attribute__((__unused__)) ;
static void __attribute__((__warning__("curl_easy_setopt expects a CURLSH* argument for this option")))  ( __attribute__((__noinline__)) _curl_easy_setopt_err_CURLSH)(void)
{


  {
  __asm__  ("":);
  return;
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__, __gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__leaf__, __gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename ,
                                    struct stat * __restrict  __statbuf , int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__, __gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode ,
                                    __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3), __leaf__)) __fxstat)(int __ver ,
                                                                                               int __fildes ,
                                                                                               struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int __ver ,
                                                                                                char const   *__filename ,
                                                                                                struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int __ver ,
                                                                                                 char const   *__filename ,
                                                                                                 struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4), __leaf__)) __fxstatat)(int __ver ,
                                                                                                   int __fildes ,
                                                                                                   char const   *__filename ,
                                                                                                   struct stat *__stat_buf ,
                                                                                                   int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4), __leaf__)) __xmknod)(int __ver ,
                                                                                                 char const   *__path ,
                                                                                                 __mode_t __mode ,
                                                                                                 __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5), __leaf__)) __xmknodat)(int __ver ,
                                                                                                   int __fd ,
                                                                                                   char const   *__path ,
                                                                                                   __mode_t __mode ,
                                                                                                   __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                                        struct stat * __restrict  __statbuf )
{
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__, __gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __leaf__, __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                                         struct stat * __restrict  __statbuf )
{
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__, __gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__)) fstat)(int __fd ,
                                                                                       struct stat *__statbuf )
{
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__leaf__, __gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename ,
                                    struct stat * __restrict  __statbuf , int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __leaf__, __gnu_inline__)) fstatat)(int __fd ,
                                                                                           char const   * __restrict  __filename ,
                                                                                           struct stat * __restrict  __statbuf ,
                                                                                           int __flag )
{
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__)) mknod)(char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t __dev )
{
  int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__, __gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode ,
                                    __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __leaf__, __gnu_inline__)) mknodat)(int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t __dev )
{
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes ) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) getcwd)(char *__buf ,
                                                                      size_t __size ) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) getgroups)(int __size ,
                                                                         __gid_t *__list ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd ,
                                                                                         char *__buf ,
                                                                                         size_t __buflen ) ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                                          char * __restrict  __buf ,
                                                                                          size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                                            char const   * __restrict  __path ,
                                                                                            char * __restrict  __buf ,
                                                                                            size_t __len ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) getlogin_r)(char *__buf , size_t __buflen ) ;
extern char *optarg ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) getopt)(int ___argc ,
                                                                                               char * const  *___argv ,
                                                                                               char const   *__shortopts ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) gethostname)(char *__buf ,
                                                                           size_t __buflen ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf ,
                                                                                             size_t __buflen ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk)(int __fd , void *__buf ,
                                                                     size_t __nbytes ,
                                                                     size_t __buflen ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_alias)(int __fd ,
                                                                       void *__buf ,
                                                                       size_t __nbytes )  __asm__("read")  ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk_warn)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          size_t __buflen )  __asm__("__read_chk") __attribute__((__warning__("read called with bigger length than size of the destination buffer"))) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __artificial__,
__always_inline__)) read)(int __fd , void *__buf , size_t __nbytes )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size(__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __read_chk(__fd, __buf, __nbytes, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size(__buf, 0);
    if (__nbytes > tmp___3) {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __read_chk_warn(__fd, __buf, __nbytes, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __read_alias(__fd, __buf, __nbytes);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_chk)(char const   * __restrict  __path , char * __restrict  __buf ,
                                             size_t __len , size_t __buflen ) ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_alias)(char const   * __restrict  __path ,
                                               char * __restrict  __buf , size_t __len )  __asm__("readlink")  ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_chk_warn)(char const   * __restrict  __path ,
                                                  char * __restrict  __buf , size_t __len ,
                                                  size_t __buflen )  __asm__("__readlink_chk") __attribute__((__warning__("readlink called with bigger length than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                                          char * __restrict  __buf ,
                                                                                          size_t __len ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                        char * __restrict  __buf ,
                                                                        size_t __len )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __readlink_chk(__path, __buf, __len, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__len > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __readlink_chk_warn(__path, __buf, __len, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __readlink_alias(__path, __buf, __len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_chk)(int __fd , char const   * __restrict  __path ,
                                               char * __restrict  __buf , size_t __len ,
                                               size_t __buflen ) ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_alias)(int __fd , char const   * __restrict  __path ,
                                                 char * __restrict  __buf , size_t __len )  __asm__("readlinkat")  ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_chk_warn)(int __fd , char const   * __restrict  __path ,
                                                    char * __restrict  __buf , size_t __len ,
                                                    size_t __buflen )  __asm__("__readlinkat_chk") __attribute__((__warning__("readlinkat called with bigger length than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                                            char const   * __restrict  __path ,
                                                                                            char * __restrict  __buf ,
                                                                                            size_t __len ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                          char const   * __restrict  __path ,
                                                                          char * __restrict  __buf ,
                                                                          size_t __len )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __readlinkat_chk(__fd, __path, __buf, __len, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__len > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __readlinkat_chk_warn(__fd, __path, __buf, __len, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __readlinkat_alias(__fd, __path, __buf, __len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_chk)(char *__buf , size_t __size , size_t __buflen ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_alias)(char *__buf , size_t __size )  __asm__("getcwd")  ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_chk_warn)(char *__buf , size_t __size , size_t __buflen )  __asm__("__getcwd_chk") __attribute__((__warning__("getcwd caller with bigger length than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) getcwd)(char *__buf ,
                                                                      size_t __size ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getcwd_chk(__buf, __size, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__size > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getcwd_chk_warn(__buf, __size, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __getcwd_alias(__buf, __size);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getwd_chk)(char *__buf , size_t buflen ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getwd_warn)(char *__buf )  __asm__("getwd") __attribute__((__warning__("please use getcwd instead, as getwd doesn\'t specify buffer size"))) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getwd)(char *__buf )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__buf, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getwd_chk(__buf, tmp);
    return ((char __attribute__((__deprecated__))  *)tmp___0);
  }
  tmp___2 = __getwd_warn(__buf);
  return ((char __attribute__((__deprecated__))  *)tmp___2);
}
}
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_chk)(int __name ,
                                                                                       char *__buf ,
                                                                                       size_t __len ,
                                                                                       size_t __buflen ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_alias)(int __name ,
                                                                                         char *__buf ,
                                                                                         size_t __len )  __asm__("confstr")  ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_chk_warn)(int __name ,
                                                                                            char *__buf ,
                                                                                            size_t __len ,
                                                                                            size_t __buflen )  __asm__("__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __gnu_inline__,
__artificial__, __always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
__inline extern size_t ( __attribute__((__leaf__, __gnu_inline__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __confstr_chk(__name, __buf, __len, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (tmp___3 < __len) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __confstr_chk_warn(__name, __buf, __len, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __confstr_alias(__name, __buf, __len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_chk)(int __size , __gid_t *__list , size_t __listlen ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_alias)(int __size , __gid_t *__list )  __asm__("getgroups")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_chk_warn)(int __size , __gid_t *__list , size_t __listlen )  __asm__("__getgroups_chk") __attribute__((__warning__("getgroups called with bigger group count than what can fit into destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) getgroups)(int __size ,
                                                                         __gid_t *__list ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__list, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__list, 1);
    tmp___0 = __getgroups_chk(__size, __list, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__list, 1);
    if ((unsigned long )__size * sizeof(__gid_t ) > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__list, 1);
      tmp___2 = __getgroups_chk_warn(__size, __list, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __getgroups_alias(__size, __list);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ttyname_r")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ttyname_r_chk") __attribute__((__warning__("ttyname_r called with bigger buflen than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd ,
                                                                                         char *__buf ,
                                                                                         size_t __buflen ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __ttyname_r_chk(__fd, __buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __ttyname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __ttyname_r_alias(__fd, __buf, __buflen);
  return (tmp___5);
}
}
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk)(char *__buf , size_t __buflen ,
                                                               size_t __nreal ) ;
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_alias)(char *__buf , size_t __buflen )  __asm__("getlogin_r")  ;
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk_warn)(char *__buf ,
                                                                    size_t __buflen ,
                                                                    size_t __nreal )  __asm__("__getlogin_r_chk") __attribute__((__warning__("getlogin_r called with bigger buflen than size of destination buffer"))) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __artificial__,
__always_inline__)) getlogin_r)(char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getlogin_r_chk(__buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getlogin_r_chk_warn(__buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __getlogin_r_alias(__buf, __buflen);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk)(char *__buf ,
                                                                                                        size_t __buflen ,
                                                                                                        size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_alias)(char *__buf ,
                                                                                                          size_t __buflen )  __asm__("gethostname")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk_warn)(char *__buf ,
                                                                                                             size_t __buflen ,
                                                                                                             size_t __nreal )  __asm__("__gethostname_chk") __attribute__((__warning__("gethostname called with bigger buflen than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) gethostname)(char *__buf ,
                                                                           size_t __buflen ) ;
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __gnu_inline__, __artificial__,
__always_inline__)) gethostname)(char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __gethostname_chk(__buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __gethostname_chk_warn(__buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __gethostname_alias(__buf, __buflen);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_chk)(char *__buf , size_t __buflen , size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_alias)(char *__buf , size_t __buflen )  __asm__("getdomainname")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_chk_warn)(char *__buf , size_t __buflen ,
                                                     size_t __nreal )  __asm__("__getdomainname_chk") __attribute__((__warning__("getdomainname called with bigger buflen than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf ,
                                                                                             size_t __buflen ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__gnu_inline__, __artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getdomainname_chk(__buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getdomainname_chk_warn(__buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __getdomainname_alias(__buf, __buflen);
  return (tmp___5);
}
}
int vg_context_add_patterns(vg_context_t *vcp , char const   ** const  patterns ,
                            int npatterns ) ;
void vg_context_clear_all_patterns(vg_context_t *vcp ) ;
int vg_context_start_threads(vg_context_t *vcp ) ;
void vg_context_stop_threads(vg_context_t *vcp ) ;
vg_context_t *vg_prefix_context_new(int addrtype , int privtype , int caseinsensitive ) ;
double vg_prefix_get_difficulty(int addrtype , char const   *pattern ) ;
void vg_output_match_console(vg_context_t *vcp , EC_KEY *pkey , char const   *pattern ) ;
void vg_output_timing_console(vg_context_t *vcp , double count , unsigned long long rate ,
                              unsigned long long total ) ;
EC_KEY *vg_exec_context_new_key(void) ;
extern vg_ocl_context_t *vg_ocl_context_new(vg_context_t *vcp , int platformidx ,
                                            int deviceidx , int safe_mode , int verify ,
                                            int worksize , int nthreads , int nrows ,
                                            int ncols , int invsize ) ;
extern vg_ocl_context_t *vg_ocl_context_new_from_devstr(vg_context_t *vcp , char const   *devstr ,
                                                        int safemode , int verify ) ;
extern void vg_ocl_enumerate_devices(void) ;
int vg_b58_decode_check(char const   *input , void *buf , size_t len ) ;
__inline static void avl_root_init(avl_root_t *rootp )
{


  {
  rootp->ar_root = (avl_item_t *)((void *)0);
  return;
}
}
__inline static int avl_root_empty(avl_root_t *rootp )
{
  int tmp ;

  {
  if ((unsigned long )rootp->ar_root == (unsigned long )((void *)0)) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
__inline static void avl_item_init(avl_item_t *itemp )
{


  {
  itemp->ai_left = (struct _avl_item_s *)((void *)0);
  itemp->ai_right = (struct _avl_item_s *)((void *)0);
  itemp->ai_up = (struct _avl_item_s *)((void *)0);
  itemp->ai_balance = (avl_balance_t )1;
  itemp->ai_indexed = 0;
  return;
}
}
__inline static void _avl_rotate_ll(avl_root_t *rootp , avl_item_t *itemp )
{
  avl_item_t *tmp ;

  {
  tmp = itemp->ai_left;
  itemp->ai_left = tmp->ai_right;
  if (itemp->ai_left) {
    (itemp->ai_left)->ai_up = itemp;
  }
  tmp->ai_right = itemp;
  if (itemp->ai_up) {
    if ((unsigned long )(itemp->ai_up)->ai_left == (unsigned long )itemp) {
      (itemp->ai_up)->ai_left = tmp;
    } else {
      if (! ((unsigned long )(itemp->ai_up)->ai_right == (unsigned long )itemp)) {
        __assert_fail("itemp->ai_up->ai_right == itemp", "avl.h", 89U, "_avl_rotate_ll");
      }
      (itemp->ai_up)->ai_right = tmp;
    }
  } else {
    rootp->ar_root = tmp;
  }
  tmp->ai_up = itemp->ai_up;
  itemp->ai_up = tmp;
  return;
}
}
__inline static void _avl_rotate_lr(avl_root_t *rootp , avl_item_t *itemp )
{
  avl_item_t *rcp ;
  avl_item_t *rlcp ;

  {
  rcp = itemp->ai_left;
  rlcp = rcp->ai_right;
  if (itemp->ai_up) {
    if ((unsigned long )itemp == (unsigned long )(itemp->ai_up)->ai_left) {
      (itemp->ai_up)->ai_left = rlcp;
    } else {
      if (! ((unsigned long )itemp == (unsigned long )(itemp->ai_up)->ai_right)) {
        __assert_fail("itemp == itemp->ai_up->ai_right", "avl.h", 109U, "_avl_rotate_lr");
      }
      (itemp->ai_up)->ai_right = rlcp;
    }
  } else {
    rootp->ar_root = rlcp;
  }
  rlcp->ai_up = itemp->ai_up;
  rcp->ai_right = rlcp->ai_left;
  if (rcp->ai_right) {
    (rcp->ai_right)->ai_up = rcp;
  }
  itemp->ai_left = rlcp->ai_right;
  if (itemp->ai_left) {
    (itemp->ai_left)->ai_up = itemp;
  }
  rlcp->ai_left = rcp;
  rlcp->ai_right = itemp;
  rcp->ai_up = rlcp;
  itemp->ai_up = rlcp;
  return;
}
}
__inline static void _avl_rotate_rr(avl_root_t *rootp , avl_item_t *itemp )
{
  avl_item_t *tmp ;

  {
  tmp = itemp->ai_right;
  itemp->ai_right = tmp->ai_left;
  if (itemp->ai_right) {
    (itemp->ai_right)->ai_up = itemp;
  }
  tmp->ai_left = itemp;
  if (itemp->ai_up) {
    if ((unsigned long )(itemp->ai_up)->ai_right == (unsigned long )itemp) {
      (itemp->ai_up)->ai_right = tmp;
    } else {
      if (! ((unsigned long )(itemp->ai_up)->ai_left == (unsigned long )itemp)) {
        __assert_fail("itemp->ai_up->ai_left == itemp", "avl.h", 142U, "_avl_rotate_rr");
      }
      (itemp->ai_up)->ai_left = tmp;
    }
  } else {
    rootp->ar_root = tmp;
  }
  tmp->ai_up = itemp->ai_up;
  itemp->ai_up = tmp;
  return;
}
}
__inline static void _avl_rotate_rl(avl_root_t *rootp , avl_item_t *itemp )
{
  avl_item_t *rcp ;
  avl_item_t *rlcp ;

  {
  rcp = itemp->ai_right;
  rlcp = rcp->ai_left;
  if (itemp->ai_up) {
    if ((unsigned long )itemp == (unsigned long )(itemp->ai_up)->ai_right) {
      (itemp->ai_up)->ai_right = rlcp;
    } else {
      if (! ((unsigned long )itemp == (unsigned long )(itemp->ai_up)->ai_left)) {
        __assert_fail("itemp == itemp->ai_up->ai_left", "avl.h", 162U, "_avl_rotate_rl");
      }
      (itemp->ai_up)->ai_left = rlcp;
    }
  } else {
    rootp->ar_root = rlcp;
  }
  rlcp->ai_up = itemp->ai_up;
  rcp->ai_left = rlcp->ai_right;
  if (rcp->ai_left) {
    (rcp->ai_left)->ai_up = rcp;
  }
  itemp->ai_right = rlcp->ai_left;
  if (itemp->ai_right) {
    (itemp->ai_right)->ai_up = itemp;
  }
  rlcp->ai_right = rcp;
  rlcp->ai_left = itemp;
  rcp->ai_up = rlcp;
  itemp->ai_up = rlcp;
  return;
}
}
static void avl_delete_fix(avl_root_t *rootp , avl_item_t *itemp , avl_item_t *parentp )
{
  avl_item_t *childp ;

  {
  if ((unsigned long )parentp->ai_left == (unsigned long )((void *)0)) {
    if ((unsigned long )parentp->ai_right == (unsigned long )((void *)0)) {
      if (! ((unsigned long )itemp == (unsigned long )((void *)0))) {
        __assert_fail("itemp == NULL", "avl.h", 188U, "avl_delete_fix");
      }
      parentp->ai_balance = (avl_balance_t )1;
      itemp = parentp;
      parentp = itemp->ai_up;
    }
  }
  while (parentp) {
    if ((unsigned long )itemp == (unsigned long )parentp->ai_right) {
      itemp = parentp->ai_left;
      if ((unsigned int )parentp->ai_balance == 0U) {
        if ((unsigned int )itemp->ai_balance == 0U) {
          _avl_rotate_ll(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          parentp = itemp;
        } else
        if ((unsigned int )itemp->ai_balance == 1U) {
          _avl_rotate_ll(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )2;
          parentp->ai_balance = (avl_balance_t )0;
          break;
        } else {
          childp = itemp->ai_right;
          _avl_rotate_lr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          if ((unsigned int )childp->ai_balance == 2U) {
            itemp->ai_balance = (avl_balance_t )0;
          }
          if ((unsigned int )childp->ai_balance == 0U) {
            parentp->ai_balance = (avl_balance_t )2;
          }
          childp->ai_balance = (avl_balance_t )1;
          parentp = childp;
        }
      } else
      if ((unsigned int )parentp->ai_balance == 1U) {
        parentp->ai_balance = (avl_balance_t )0;
        break;
      } else {
        parentp->ai_balance = (avl_balance_t )1;
      }
    } else {
      itemp = parentp->ai_right;
      if ((unsigned int )parentp->ai_balance == 2U) {
        if ((unsigned int )itemp->ai_balance == 2U) {
          _avl_rotate_rr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          parentp = itemp;
        } else
        if ((unsigned int )itemp->ai_balance == 1U) {
          _avl_rotate_rr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )0;
          parentp->ai_balance = (avl_balance_t )2;
          break;
        } else {
          childp = itemp->ai_left;
          _avl_rotate_rl(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          if ((unsigned int )childp->ai_balance == 2U) {
            parentp->ai_balance = (avl_balance_t )0;
          }
          if ((unsigned int )childp->ai_balance == 0U) {
            itemp->ai_balance = (avl_balance_t )2;
          }
          childp->ai_balance = (avl_balance_t )1;
          parentp = childp;
        }
      } else
      if ((unsigned int )parentp->ai_balance == 1U) {
        parentp->ai_balance = (avl_balance_t )2;
        break;
      } else {
        parentp->ai_balance = (avl_balance_t )1;
      }
    }
    itemp = parentp;
    parentp = itemp->ai_up;
  }
  return;
}
}
static void avl_insert_fix(avl_root_t *rootp , avl_item_t *itemp )
{
  avl_item_t *childp ;
  avl_item_t *parentp ;
  struct _avl_item_s *tmp ;

  {
  parentp = itemp->ai_up;
  tmp = (struct _avl_item_s *)((void *)0);
  itemp->ai_right = tmp;
  itemp->ai_left = tmp;
  if (! (! itemp->ai_indexed)) {
    __assert_fail("!itemp->ai_indexed", "avl.h", 275U, "avl_insert_fix");
  }
  itemp->ai_indexed = 1;
  while (parentp) {
    if ((unsigned long )itemp == (unsigned long )parentp->ai_left) {
      if ((unsigned int )parentp->ai_balance == 0U) {
        if ((unsigned int )itemp->ai_balance == 0U) {
          _avl_rotate_ll(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          break;
        } else {
          if (! ((unsigned int )itemp->ai_balance != 1U)) {
            __assert_fail("itemp->ai_balance != CENT", "avl.h", 290U, "avl_insert_fix");
          }
          childp = itemp->ai_right;
          _avl_rotate_lr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          if ((unsigned int )childp->ai_balance == 2U) {
            itemp->ai_balance = (avl_balance_t )0;
          }
          if ((unsigned int )childp->ai_balance == 0U) {
            parentp->ai_balance = (avl_balance_t )2;
          }
          childp->ai_balance = (avl_balance_t )1;
          break;
        }
      } else
      if ((unsigned int )parentp->ai_balance == 1U) {
        parentp->ai_balance = (avl_balance_t )0;
      } else {
        parentp->ai_balance = (avl_balance_t )1;
        return;
      }
    } else
    if ((unsigned int )parentp->ai_balance == 2U) {
      if ((unsigned int )itemp->ai_balance == 2U) {
        _avl_rotate_rr(rootp, parentp);
        itemp->ai_balance = (avl_balance_t )1;
        parentp->ai_balance = (avl_balance_t )1;
        break;
      } else {
        if (! ((unsigned int )itemp->ai_balance != 1U)) {
          __assert_fail("itemp->ai_balance != CENT", "avl.h", 316U, "avl_insert_fix");
        }
        childp = itemp->ai_left;
        _avl_rotate_rl(rootp, parentp);
        itemp->ai_balance = (avl_balance_t )1;
        parentp->ai_balance = (avl_balance_t )1;
        if ((unsigned int )childp->ai_balance == 2U) {
          parentp->ai_balance = (avl_balance_t )0;
        }
        if ((unsigned int )childp->ai_balance == 0U) {
          itemp->ai_balance = (avl_balance_t )2;
        }
        childp->ai_balance = (avl_balance_t )1;
        break;
      }
    } else
    if ((unsigned int )parentp->ai_balance == 1U) {
      parentp->ai_balance = (avl_balance_t )2;
    } else {
      parentp->ai_balance = (avl_balance_t )1;
      break;
    }
    itemp = parentp;
    parentp = itemp->ai_up;
  }
  return;
}
}
__inline static avl_item_t *avl_first(avl_root_t *rootp )
{
  avl_item_t *itemp ;

  {
  itemp = rootp->ar_root;
  if (itemp) {
    while (itemp->ai_left) {
      itemp = itemp->ai_left;
    }
  }
  return (itemp);
}
}
__inline static avl_item_t *avl_next(avl_item_t *itemp )
{


  {
  if (itemp->ai_right) {
    itemp = itemp->ai_right;
    while (itemp->ai_left) {
      itemp = itemp->ai_left;
    }
    return (itemp);
  }
  while (1) {
    if (itemp->ai_up) {
      if (! ((unsigned long )itemp == (unsigned long )(itemp->ai_up)->ai_right)) {
        break;
      }
    } else {
      break;
    }
    itemp = itemp->ai_up;
  }
  if (! itemp->ai_up) {
    return ((avl_item_t *)((void *)0));
  }
  return (itemp->ai_up);
}
}
static void avl_remove(avl_root_t *rootp , avl_item_t *itemp )
{
  avl_item_t *relocp ;
  avl_item_t *replacep ;
  avl_item_t *parentp ;

  {
  parentp = (avl_item_t *)((void *)0);
  if (! itemp->ai_indexed) {
    __assert_fail("itemp->ai_indexed", "avl.h", 376U, "avl_remove");
  }
  itemp->ai_indexed = 0;
  if ((unsigned long )itemp->ai_left == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if ((unsigned long )itemp->ai_right == (unsigned long )((void *)0)) {
    _L: /* CIL Label */
    parentp = itemp->ai_up;
    replacep = itemp->ai_left;
    if ((unsigned long )replacep == (unsigned long )((void *)0)) {
      replacep = itemp->ai_right;
    }
    if ((unsigned long )replacep != (unsigned long )((void *)0)) {
      replacep->ai_up = parentp;
    }
    if ((unsigned long )parentp == (unsigned long )((void *)0)) {
      rootp->ar_root = replacep;
    } else {
      if ((unsigned long )itemp == (unsigned long )parentp->ai_left) {
        parentp->ai_left = replacep;
      } else {
        parentp->ai_right = replacep;
      }
      avl_delete_fix(rootp, replacep, parentp);
    }
    return;
  }
  relocp = avl_next(itemp);
  if (! relocp) {
    __assert_fail("relocp", "avl.h", 405U, "avl_remove");
  }
  if (! ((unsigned long )relocp->ai_up != (unsigned long )((void *)0))) {
    __assert_fail("relocp->ai_up != NULL", "avl.h", 406U, "avl_remove");
  }
  if (! ((unsigned long )relocp->ai_left == (unsigned long )((void *)0))) {
    __assert_fail("relocp->ai_left == NULL", "avl.h", 407U, "avl_remove");
  }
  replacep = relocp->ai_right;
  relocp->ai_left = itemp->ai_left;
  if ((unsigned long )relocp->ai_left != (unsigned long )((void *)0)) {
    (relocp->ai_left)->ai_up = relocp;
  }
  if ((unsigned long )itemp->ai_up == (unsigned long )((void *)0)) {
    rootp->ar_root = relocp;
  } else
  if ((unsigned long )itemp == (unsigned long )(itemp->ai_up)->ai_left) {
    (itemp->ai_up)->ai_left = relocp;
  } else {
    (itemp->ai_up)->ai_right = relocp;
  }
  if ((unsigned long )relocp == (unsigned long )(relocp->ai_up)->ai_left) {
    if (! ((unsigned long )relocp->ai_up != (unsigned long )itemp)) {
      __assert_fail("relocp->ai_up != itemp", "avl.h", 421U, "avl_remove");
    }
    (relocp->ai_up)->ai_left = replacep;
    parentp = relocp->ai_up;
    if ((unsigned long )replacep != (unsigned long )((void *)0)) {
      replacep->ai_up = relocp->ai_up;
    }
    relocp->ai_right = itemp->ai_right;
  } else {
    if (! ((unsigned long )relocp->ai_up == (unsigned long )itemp)) {
      __assert_fail("relocp->ai_up == itemp", "avl.h", 428U, "avl_remove");
    }
    relocp->ai_right = replacep;
    parentp = relocp;
  }
  if ((unsigned long )relocp->ai_right != (unsigned long )((void *)0)) {
    (relocp->ai_right)->ai_up = relocp;
  }
  relocp->ai_up = itemp->ai_up;
  relocp->ai_balance = itemp->ai_balance;
  avl_delete_fix(rootp, replacep, parentp);
  return;
}
}
char const   *version  =    "0.22";
int const   debug  =    (int const   )0;
static int workitem_cmp(workitem_t *a , workitem_t *b )
{
  int cmpres ;
  int tmp ;

  {
  cmpres = strcmp(a->pattern, b->pattern);
  if (! cmpres) {
    if (a->reward < b->reward) {
      cmpres = -1;
    } else {
      if (a->reward > b->reward) {
        tmp = 1;
      } else {
        tmp = 0;
      }
      cmpres = tmp;
    }
  }
  return (cmpres);
}
}
static workitem_t *workitem_avl_search(avl_root_t *rootp , char const   *pattern )
{
  workitem_t *vp ;
  avl_item_t *itemp ;
  int cmpres ;

  {
  itemp = rootp->ar_root;
  while (itemp) {
    vp = (workitem_t *)((unsigned char *)itemp - (size_t )(& ((workitem_t *)((unsigned char *)0))->avlent));
    cmpres = strcmp(vp->pattern, pattern);
    if (cmpres > 0) {
      itemp = itemp->ai_left;
    } else
    if (cmpres < 0) {
      itemp = itemp->ai_right;
    } else {
      return (vp);
    }
  }
  return ((workitem_t *)((void *)0));
}
}
static workitem_t *workitem_avl_insert(avl_root_t *rootp , workitem_t *vpnew )
{
  workitem_t *vp ;
  avl_item_t *itemp ;
  avl_item_t **ptrp ;
  int cmpres ;

  {
  itemp = (avl_item_t *)((void *)0);
  ptrp = & rootp->ar_root;
  while (*ptrp) {
    itemp = *ptrp;
    vp = (workitem_t *)((unsigned char *)itemp - (size_t )(& ((workitem_t *)((unsigned char *)0))->avlent));
    cmpres = workitem_cmp(vp, vpnew);
    if (cmpres > 0) {
      ptrp = & itemp->ai_left;
    } else
    if (cmpres < 0) {
      ptrp = & itemp->ai_right;
    } else {
      return (vp);
    }
  }
  vpnew->avlent.ai_up = itemp;
  itemp = & vpnew->avlent;
  *ptrp = itemp;
  avl_insert_fix(rootp, itemp);
  return ((workitem_t *)((void *)0));
}
}
static workitem_t *workitem_avl_first(avl_root_t *rootp )
{
  avl_item_t *itemp ;

  {
  itemp = avl_first(rootp);
  if (itemp) {
    return ((workitem_t *)((unsigned char *)itemp - (size_t )(& ((workitem_t *)((unsigned char *)0))->avlent)));
  }
  return ((workitem_t *)((void *)0));
}
}
static workitem_t *workitem_avl_next(workitem_t *vp )
{
  avl_item_t *itemp ;

  {
  itemp = & vp->avlent;
  itemp = avl_next(itemp);
  if (itemp) {
    return ((workitem_t *)((unsigned char *)itemp - (size_t )(& ((workitem_t *)((unsigned char *)0))->avlent)));
  }
  return ((workitem_t *)((void *)0));
}
}
void server_workitem_free(workitem_t *wip )
{


  {
  if (wip->pubkey) {
    EC_POINT_free(wip->pubkey);
  }
  free((void *)wip);
  return;
}
}
void server_batch_free(pubkeybatch_t *pbatch )
{
  workitem_t *wip ;

  {
  while (1) {
    wip = workitem_avl_first(& pbatch->items);
    if (! ((unsigned long )wip != (unsigned long )((void *)0))) {
      break;
    }
    if ((unsigned long )wip->pubkey == (unsigned long )pbatch->pubkey) {
      wip->pubkey = (EC_POINT *)((void *)0);
    }
    avl_remove(& pbatch->items, & wip->avlent);
    server_workitem_free(wip);
  }
  if (pbatch->pubkey) {
    EC_POINT_free(pbatch->pubkey);
  }
  if (pbatch->pubkey_hex) {
    CRYPTO_free((void *)((char *)pbatch->pubkey_hex));
  }
  free((void *)pbatch);
  return;
}
}
static int pubkeybatch_cmp(pubkeybatch_t *a , pubkeybatch_t *b )
{
  int tmp ;

  {
  tmp = strcmp(a->pubkey_hex, b->pubkey_hex);
  return (tmp);
}
}
static pubkeybatch_t *pubkeybatch_avl_search(avl_root_t *rootp , EC_POINT const   *pubkey ,
                                             EC_GROUP const   *pgroup )
{
  char *pubkey_hex ;
  pubkeybatch_t *vp ;
  avl_item_t *itemp ;
  int cmpres ;

  {
  itemp = rootp->ar_root;
  pubkey_hex = EC_POINT_point2hex(pgroup, pubkey, (point_conversion_form_t )4, (BN_CTX *)((void *)0));
  while (itemp) {
    vp = (pubkeybatch_t *)((unsigned char *)itemp - (size_t )(& ((pubkeybatch_t *)((unsigned char *)0))->avlent));
    cmpres = strcmp((char const   *)pubkey_hex, vp->pubkey_hex);
    if (cmpres > 0) {
      itemp = itemp->ai_left;
    } else
    if (cmpres < 0) {
      itemp = itemp->ai_right;
    } else {
      CRYPTO_free((void *)pubkey_hex);
      return (vp);
    }
  }
  CRYPTO_free((void *)pubkey_hex);
  return ((pubkeybatch_t *)((void *)0));
}
}
static pubkeybatch_t *pubkeybatch_avl_insert(avl_root_t *rootp , pubkeybatch_t *vpnew )
{
  pubkeybatch_t *vp ;
  avl_item_t *itemp ;
  avl_item_t **ptrp ;
  int cmpres ;

  {
  itemp = (avl_item_t *)((void *)0);
  ptrp = & rootp->ar_root;
  while (*ptrp) {
    itemp = *ptrp;
    vp = (pubkeybatch_t *)((unsigned char *)itemp - (size_t )(& ((pubkeybatch_t *)((unsigned char *)0))->avlent));
    cmpres = pubkeybatch_cmp(vpnew, vp);
    if (cmpres > 0) {
      ptrp = & itemp->ai_left;
    } else
    if (cmpres < 0) {
      ptrp = & itemp->ai_right;
    } else {
      return (vp);
    }
  }
  vpnew->avlent.ai_up = itemp;
  itemp = & vpnew->avlent;
  *ptrp = itemp;
  avl_insert_fix(rootp, itemp);
  return ((pubkeybatch_t *)((void *)0));
}
}
static pubkeybatch_t *pubkeybatch_avl_first(avl_root_t *rootp )
{
  avl_item_t *itemp ;

  {
  itemp = avl_first(rootp);
  if (itemp) {
    return ((pubkeybatch_t *)((unsigned char *)itemp - (size_t )(& ((pubkeybatch_t *)((unsigned char *)0))->avlent)));
  }
  return ((pubkeybatch_t *)((void *)0));
}
}
static pubkeybatch_t *pubkeybatch_avl_next(pubkeybatch_t *vp )
{
  avl_item_t *itemp ;

  {
  itemp = & vp->avlent;
  itemp = avl_next(itemp);
  if (itemp) {
    return ((pubkeybatch_t *)((unsigned char *)itemp - (size_t )(& ((pubkeybatch_t *)((unsigned char *)0))->avlent)));
  }
  return ((pubkeybatch_t *)((void *)0));
}
}
static workitem_t *server_workitem_new(server_request_t *reqp , char const   *pfx ,
                                       char const   *pubkey_s , char const   *addrtype_s ,
                                       char const   *reward_s , char const   *comment )
{
  workitem_t *wip ;
  EC_POINT *pubkey ;
  int addrtype ;
  double reward ;
  double difficulty ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  addrtype = atoi(addrtype_s);
  if (addrtype < 0) {
    return ((workitem_t *)((void *)0));
  } else
  if (addrtype > 255) {
    return ((workitem_t *)((void *)0));
  }
  reward = strtod((char const   * __restrict  )reward_s, (char ** __restrict  )((void *)0));
  if (reward < 0.0) {
    return ((workitem_t *)((void *)0));
  }
  difficulty = vg_prefix_get_difficulty(addrtype, pfx);
  if (difficulty == 0.0) {
    return ((workitem_t *)((void *)0));
  }
  pubkey = EC_POINT_hex2point(reqp->group, pubkey_s, (EC_POINT *)((void *)0), (BN_CTX *)((void *)0));
  if ((unsigned long )pubkey == (unsigned long )((void *)0)) {
    return ((workitem_t *)((void *)0));
  }
  tmp = strlen(pfx);
  tmp___0 = strlen(comment);
  tmp___1 = malloc(((sizeof(*wip) + tmp) + tmp___0) + 2UL);
  wip = (workitem_t *)tmp___1;
  memset((void *)wip, 0, sizeof(*wip));
  avl_item_init(& wip->avlent);
  wip->pattern = (char const   *)((char *)(wip + 1));
  strcpy((char * __restrict  )((char *)wip->pattern), (char const   * __restrict  )pfx);
  tmp___2 = strlen(wip->pattern);
  wip->comment = wip->pattern + (tmp___2 + 1UL);
  strcpy((char * __restrict  )((char *)wip->comment), (char const   * __restrict  )comment);
  wip->pubkey = pubkey;
  wip->addrtype = addrtype;
  wip->difficulty = difficulty;
  wip->reward = reward;
  wip->value = (reward * 1000000000.0) / difficulty;
  return (wip);
}
}
static int server_workitem_equal(workitem_t *a , workitem_t *b )
{
  int tmp ;
  int tmp___0 ;

  {
  if (a->reward == b->reward) {
    tmp = strcmp(a->pattern, b->pattern);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int server_pubkeybatch_equal(server_context_t *ctxp , pubkeybatch_t *a , pubkeybatch_t *b )
{
  workitem_t *wipa ;
  workitem_t *wipb ;
  EC_GROUP const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (a->nitems != b->nitems) {
    return (0);
  }
  tmp = EC_KEY_get0_group((EC_KEY const   *)ctxp->dummy_key);
  tmp___0 = EC_POINT_cmp(tmp, (EC_POINT const   *)a->pubkey, (EC_POINT const   *)b->pubkey,
                         (BN_CTX *)((void *)0));
  if (tmp___0) {
    return (0);
  }
  wipa = workitem_avl_first(& a->items);
  wipb = workitem_avl_first(& b->items);
  while (1) {
    if (wipa) {
      if (! wipb) {
        break;
      }
    } else {
      break;
    }
    tmp___1 = server_workitem_equal(wipa, wipb);
    if (! tmp___1) {
      return (0);
    }
    wipa = workitem_avl_next(wipa);
    wipb = workitem_avl_next(wipb);
  }
  return (1);
}
}
void server_context_free(server_context_t *ctxp )
{


  {
  if (ctxp->dummy_key) {
    EC_KEY_free(ctxp->dummy_key);
  }
  if (ctxp->getwork) {
    free((void *)ctxp->getwork);
  }
  if (ctxp->submit) {
    free((void *)ctxp->submit);
  }
  free((void *)ctxp);
  return;
}
}
server_context_t *server_context_new(char const   *url , char const   *credit_addr )
{
  server_context_t *ctxp ;
  int urllen ;
  size_t tmp ;
  int addrlen ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  tmp = strlen(url);
  urllen = (int )tmp;
  tmp___0 = strlen(credit_addr);
  addrlen = (int )tmp___0;
  tmp___1 = malloc(((sizeof(*ctxp) + (unsigned long )urllen) + (unsigned long )addrlen) + 2UL);
  ctxp = (server_context_t *)tmp___1;
  memset((void *)ctxp, 0, sizeof(*ctxp));
  avl_root_init(& ctxp->items);
  ctxp->url = (char const   *)(ctxp + 1);
  ctxp->credit_addr = (ctxp->url + urllen) + 1;
  strcpy((char * __restrict  )((char *)ctxp->url), (char const   * __restrict  )url);
  strcpy((char * __restrict  )((char *)ctxp->credit_addr), (char const   * __restrict  )credit_addr);
  ctxp->dummy_key = vg_exec_context_new_key();
  tmp___2 = malloc((size_t )(urllen + 9));
  ctxp->getwork = (char *)tmp___2;
  tmp___3 = malloc((size_t )(urllen + 7));
  ctxp->submit = (char *)tmp___3;
  if ((int const   )*(url + (urllen - 1)) == 47) {
    snprintf((char * __restrict  )ctxp->getwork, (size_t )(urllen + 9), (char const   * __restrict  )"%sgetWork",
             url);
    snprintf((char * __restrict  )ctxp->submit, (size_t )(urllen + 7), (char const   * __restrict  )"%ssolve",
             url);
  } else {
    snprintf((char * __restrict  )ctxp->getwork, (size_t )(urllen + 9), (char const   * __restrict  )"%s/getWork",
             url);
    snprintf((char * __restrict  )ctxp->submit, (size_t )(urllen + 7), (char const   * __restrict  )"%s/solve",
             url);
  }
  return (ctxp);
}
}
int server_workitem_add(server_request_t *reqp , workitem_t *wip )
{
  workitem_t *xwip ;
  pubkeybatch_t *pbatch ;
  void *tmp ;
  char *tmp___0 ;

  {
  pbatch = (pubkeybatch_t *)((void *)0);
  pbatch = pubkeybatch_avl_search(& reqp->items, (EC_POINT const   *)wip->pubkey,
                                  reqp->group);
  if ((unsigned long )pbatch == (unsigned long )((void *)0)) {
    tmp = malloc(sizeof(*pbatch));
    pbatch = (pubkeybatch_t *)tmp;
    if ((unsigned long )pbatch == (unsigned long )((void *)0)) {
      return (-1);
    }
    memset((void *)pbatch, 0, sizeof(*pbatch));
    avl_item_init(& pbatch->avlent);
    avl_root_init(& pbatch->items);
    pbatch->total_value = (double )0;
    pbatch->pubkey = wip->pubkey;
    tmp___0 = EC_POINT_point2hex(reqp->group, (EC_POINT const   *)wip->pubkey, (point_conversion_form_t )4,
                                 (BN_CTX *)((void *)0));
    pbatch->pubkey_hex = (char const   *)tmp___0;
    pubkeybatch_avl_insert(& reqp->items, pbatch);
    (reqp->nitems) ++;
  }
  xwip = workitem_avl_insert(& pbatch->items, wip);
  if (xwip) {
    return (-1);
  }
  if (wip->pubkey) {
    if ((unsigned long )wip->pubkey != (unsigned long )pbatch->pubkey) {
      EC_POINT_free(wip->pubkey);
    }
  }
  wip->pubkey = pbatch->pubkey;
  (pbatch->nitems) ++;
  pbatch->total_value += wip->value;
  return (0);
}
}
static size_t server_body_reader(char const   *buf , size_t elemsize , size_t len ,
                                 void *param )
{
  server_request_t *reqp ;
  char *line ;
  char *sep ;
  char *pfx ;
  char *pubkey_s ;
  char *addrtype_s ;
  char *reward_s ;
  char *comment ;
  workitem_t *wip ;
  void *tmp ;
  int tmp___0 ;

  {
  reqp = (server_request_t *)param;
  if (! len) {
    return ((size_t )0);
  }
  if (reqp->part_size < (reqp->part_end + len) + 1UL) {
    if (reqp->part_off > 0UL) {
      memmove((void *)reqp->part_buf, (void const   *)(reqp->part_buf + reqp->part_off),
              reqp->part_end - reqp->part_off);
      reqp->part_end -= reqp->part_off;
      reqp->part_off = (size_t )0;
    }
  }
  if (reqp->part_size < (reqp->part_end + len) + 1UL) {
    if (reqp->part_size == 0UL) {
      reqp->part_size = (size_t )4096;
    }
    while (reqp->part_size < (reqp->part_end + len) + 1UL) {
      reqp->part_size *= 2UL;
      if (reqp->part_size > 1048576UL) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Line too long from server");
        reqp->request_status = 0;
        return ((size_t )0);
      }
    }
    tmp = realloc((void *)reqp->part_buf, reqp->part_size);
    reqp->part_buf = (char *)tmp;
    if (! reqp->part_buf) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Out of memory");
      return ((size_t )0);
    }
  }
  memcpy((void * __restrict  )(reqp->part_buf + reqp->part_end), (void const   * __restrict  )buf,
         len);
  reqp->part_end += len;
  *(reqp->part_buf + reqp->part_end) = (char )'\000';
  line = reqp->part_buf + reqp->part_off;
  while (1) {
    sep = strchr((char const   *)line, '\n');
    if (! sep) {
      break;
    }
    pfx = line;
    *sep = (char )'\000';
    line = sep + 1;
    sep = strchr((char const   *)pfx, ':');
    if (! sep) {
      goto bad_line;
    }
    *sep = (char )'\000';
    sep ++;
    pubkey_s = sep;
    sep = strchr((char const   *)sep, ':');
    if (! sep) {
      goto bad_line;
    }
    *sep = (char )'\000';
    sep ++;
    addrtype_s = sep;
    sep = strchr((char const   *)sep, ':');
    if (! sep) {
      goto bad_line;
    }
    *sep = (char )'\000';
    sep ++;
    reward_s = sep;
    sep = strchr((char const   *)sep, ';');
    if (! sep) {
      goto bad_line;
    }
    *sep = (char )'\000';
    sep ++;
    comment = sep;
    wip = server_workitem_new(reqp, (char const   *)pfx, (char const   *)pubkey_s,
                              (char const   *)addrtype_s, (char const   *)reward_s,
                              (char const   *)comment);
    if (! wip) {
      goto bad_line;
    }
    tmp___0 = server_workitem_add(reqp, wip);
    if (tmp___0) {
      server_workitem_free(wip);
      goto bad_line;
    }
    continue;
    bad_line: ;
  }
  reqp->part_off = (size_t )(line - reqp->part_buf);
  if (reqp->part_off == reqp->part_end) {
    reqp->part_off = (size_t )0;
    reqp->part_end = (size_t )0;
  }
  return (len);
}
}
void dump_work(avl_root_t *work )
{
  pubkeybatch_t *pbatch ;
  workitem_t *wip ;

  {
  printf((char const   * __restrict  )"Available bounties:\n");
  pbatch = pubkeybatch_avl_first(work);
  while ((unsigned long )pbatch != (unsigned long )((void *)0)) {
    wip = workitem_avl_first(& pbatch->items);
    while ((unsigned long )wip != (unsigned long )((void *)0)) {
      printf((char const   * __restrict  )"Pattern: \"%s\" Reward: %f Value: %f BTC/Gkey\n",
             wip->pattern, wip->reward, wip->value);
      wip = workitem_avl_next(wip);
    }
    if (pbatch->nitems > 1) {
      printf((char const   * __restrict  )"Batch of %d, total value: %f BTC/Gkey\n",
             pbatch->nitems, pbatch->total_value);
    }
    pbatch = pubkeybatch_avl_next(pbatch);
  }
  return;
}
}
void free_pkb_tree(avl_root_t *rootp , pubkeybatch_t *save_pkb )
{
  pubkeybatch_t *pkb ;

  {
  while (1) {
    pkb = pubkeybatch_avl_first(rootp);
    if (! ((unsigned long )pkb != (unsigned long )((void *)0))) {
      break;
    }
    avl_remove(rootp, & pkb->avlent);
    if ((unsigned long )pkb != (unsigned long )save_pkb) {
      server_batch_free(pkb);
    }
  }
  return;
}
}
void server_request_free(server_request_t *reqp )
{
  int tmp ;

  {
  if ((unsigned long )reqp->part_buf != (unsigned long )((void *)0)) {
    free((void *)reqp->part_buf);
  }
  tmp = avl_root_empty(& reqp->items);
  if (! tmp) {
    free_pkb_tree(& reqp->items, (pubkeybatch_t *)((void *)0));
  }
  free((void *)reqp);
  return;
}
}
int server_context_getwork(server_context_t *ctxp )
{
  CURLcode res ;
  server_request_t *reqp ;
  CURL *creq ;
  void *tmp ;
  int _curl_opt ;
  int tmp___0 ;
  int tmp___1 ;
  CURLcode tmp___2 ;
  int _curl_opt___0 ;
  int tmp___3 ;
  CURLcode tmp___4 ;
  int _curl_opt___1 ;
  int tmp___5 ;
  CURLcode tmp___6 ;
  int _curl_opt___2 ;
  int tmp___7 ;
  CURLcode tmp___8 ;
  int _curl_opt___3 ;
  CURLcode tmp___9 ;
  char const   *tmp___10 ;

  {
  tmp = malloc(sizeof(*reqp));
  reqp = (server_request_t *)tmp;
  memset((void *)reqp, 0, sizeof(*reqp));
  reqp->group = EC_KEY_get0_group((EC_KEY const   *)ctxp->dummy_key);
  creq = curl_easy_init();
  _curl_opt = 10002;
  if (0) {
    if (0 < _curl_opt) {
      if (_curl_opt < 10000) {
        _curl_easy_setopt_err_long();
      }
    }
    if (_curl_opt > 30000) {
      _curl_easy_setopt_err_curl_off_t();
    }
    if (_curl_opt == 10264) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10102) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10287) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10065) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10097) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10022) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10031) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10082) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10135) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10169) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10036) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10238) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10221) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10222) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10223) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10211) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10279) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10077) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10017) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10134) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10147) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10062) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10170) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10026) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10063) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10224) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10217) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10186) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10118) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10177) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10174) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10230) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10262) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10004) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10176) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10175) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10006) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10246) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10247) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10260) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10258) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10263) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10235) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10254) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10255) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10256) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10257) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10259) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10277) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10252) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10253) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10251) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10076) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10007) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10016) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10266) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10190) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10191) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10192) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10289) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10236) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10179) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10162) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10183) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10153) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10152) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10025) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10086) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10089) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10087) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10088) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10083) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10276) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10205) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10206) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10204) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10231) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10002) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10018) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10173) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10005) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10220) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    if (_curl_opt == 20079) {
      _curl_easy_setopt_err_write_callback();
    } else
    if (_curl_opt == 20011) {
      _curl_easy_setopt_err_write_callback();
    }
    if (_curl_opt == 20272) {
      _curl_easy_setopt_err_resolver_start_callback();
    }
    if (_curl_opt == 20012) {
      _curl_easy_setopt_err_read_cb();
    }
    if (_curl_opt == 20130) {
      _curl_easy_setopt_err_ioctl_cb();
    }
    if (_curl_opt == 20148) {
      _curl_easy_setopt_err_sockopt_cb();
    }
    if (_curl_opt == 20163) {
      _curl_easy_setopt_err_opensocket_cb();
    }
    if (_curl_opt == 20056) {
      _curl_easy_setopt_err_progress_cb();
    }
    if (_curl_opt == 20094) {
      _curl_easy_setopt_err_debug_cb();
    }
    if (_curl_opt == 20108) {
      _curl_easy_setopt_err_ssl_ctx_cb();
    }
    if (_curl_opt == 20143) {
      _curl_easy_setopt_err_conv_cb();
    } else
    if (_curl_opt == 20142) {
      _curl_easy_setopt_err_conv_cb();
    } else
    if (_curl_opt == 20144) {
      _curl_easy_setopt_err_conv_cb();
    }
    if (_curl_opt == 20167) {
      _curl_easy_setopt_err_seek_cb();
    }
    if (_curl_opt == 10201) {
      goto _L;
    } else
    if (_curl_opt == 10209) {
      goto _L;
    } else
    if (_curl_opt == 10095) {
      goto _L;
    } else
    if (_curl_opt == 10202) {
      goto _L;
    } else
    if (_curl_opt == 10029) {
      goto _L;
    } else
    if (_curl_opt == 10195) {
      goto _L;
    } else
    if (_curl_opt == 10131) {
      goto _L;
    } else
    if (_curl_opt == 10164) {
      goto _L;
    } else
    if (_curl_opt == 10103) {
      goto _L;
    } else
    if (_curl_opt == 10057) {
      goto _L;
    } else
    if (_curl_opt == 10009) {
      goto _L;
    } else
    if (_curl_opt == 10168) {
      goto _L;
    } else
    if (_curl_opt == 10149) {
      goto _L;
    } else
    if (_curl_opt == 10185) {
      goto _L;
    } else
    if (_curl_opt == 10109) {
      goto _L;
    } else
    if (_curl_opt == 10001) {
      goto _L;
    } else
    if (_curl_opt == 10273) {
      goto _L;
    } else
    if (_curl_opt == 10284) {
      goto _L;
    } else
    if (0) {
      _L: /* CIL Label */
      if (! (sizeof(ctxp->getwork) == sizeof(void *))) {
        _curl_easy_setopt_err_cb_data();
      }
    }
    if (_curl_opt == 10037) {
      _curl_easy_setopt_err_FILE();
    }
    if (_curl_opt == 10015) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10165) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    if (_curl_opt == 10024) {
      _curl_easy_setopt_err_curl_httpost();
    }
    if (_curl_opt == 10269) {
      _curl_easy_setopt_err_curl_mimepost();
    }
    if (_curl_opt == 10104) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10023) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10187) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10039) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10093) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10228) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10028) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10203) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10070) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10243) {
      _curl_easy_setopt_err_curl_slist();
    }
    if (_curl_opt == 10100) {
      _curl_easy_setopt_err_CURLSH();
    }
  }
  tmp___2 = curl_easy_setopt(creq, (CURLoption )_curl_opt, ctxp->getwork);
  if (tmp___2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
    exit(1);
  } else {
    _curl_opt___0 = 41;
    if (0) {
      if (0 < _curl_opt___0) {
        if (_curl_opt___0 < 10000) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
      if (_curl_opt___0 > 30000) {
        _curl_easy_setopt_err_curl_off_t();
      }
      if (_curl_opt___0 == 10264) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10102) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10287) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10065) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10097) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10022) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10031) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10082) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10135) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10169) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10036) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10238) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10221) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10222) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10223) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10211) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10279) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10077) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10017) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10134) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10147) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10062) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10170) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10026) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10063) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10224) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10217) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10186) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10118) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10177) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10174) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10230) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10262) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10004) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10176) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10175) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10006) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10246) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10247) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10260) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10258) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10263) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10235) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10254) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10255) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10256) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10257) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10259) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10277) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10252) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10253) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10251) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10076) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10007) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10016) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10266) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10190) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10191) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10192) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10289) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10236) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10179) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10162) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10183) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10153) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10152) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10025) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10086) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10089) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10087) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10088) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10083) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10276) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10205) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10206) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10204) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10231) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10002) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10018) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10173) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10005) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10220) {
        _curl_easy_setopt_err_string();
      }
      if (_curl_opt___0 == 20079) {
        _curl_easy_setopt_err_write_callback();
      } else
      if (_curl_opt___0 == 20011) {
        _curl_easy_setopt_err_write_callback();
      }
      if (_curl_opt___0 == 20272) {
        _curl_easy_setopt_err_resolver_start_callback();
      }
      if (_curl_opt___0 == 20012) {
        _curl_easy_setopt_err_read_cb();
      }
      if (_curl_opt___0 == 20130) {
        _curl_easy_setopt_err_ioctl_cb();
      }
      if (_curl_opt___0 == 20148) {
        _curl_easy_setopt_err_sockopt_cb();
      }
      if (_curl_opt___0 == 20163) {
        _curl_easy_setopt_err_opensocket_cb();
      }
      if (_curl_opt___0 == 20056) {
        _curl_easy_setopt_err_progress_cb();
      }
      if (_curl_opt___0 == 20094) {
        _curl_easy_setopt_err_debug_cb();
      }
      if (_curl_opt___0 == 20108) {
        _curl_easy_setopt_err_ssl_ctx_cb();
      }
      if (_curl_opt___0 == 20143) {
        _curl_easy_setopt_err_conv_cb();
      } else
      if (_curl_opt___0 == 20142) {
        _curl_easy_setopt_err_conv_cb();
      } else
      if (_curl_opt___0 == 20144) {
        _curl_easy_setopt_err_conv_cb();
      }
      if (_curl_opt___0 == 20167) {
        _curl_easy_setopt_err_seek_cb();
      }
      if (_curl_opt___0 == 10201) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10209) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10095) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10202) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10029) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10195) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10131) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10164) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10103) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10057) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10009) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10168) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10149) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10185) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10109) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10001) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10273) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10284) {
        goto _L___0;
      } else
      if (0) {
        _L___0: /* CIL Label */
        if (! (sizeof(ctxp->verbose > 1) == sizeof(void *))) {
          _curl_easy_setopt_err_cb_data();
        }
      }
      if (_curl_opt___0 == 10010) {
        _curl_easy_setopt_err_error_buffer();
      }
      if (_curl_opt___0 == 10037) {
        _curl_easy_setopt_err_FILE();
      }
      if (_curl_opt___0 == 10015) {
        _curl_easy_setopt_err_postfields();
      } else
      if (_curl_opt___0 == 10165) {
        _curl_easy_setopt_err_postfields();
      }
      if (_curl_opt___0 == 10024) {
        _curl_easy_setopt_err_curl_httpost();
      }
      if (_curl_opt___0 == 10269) {
        _curl_easy_setopt_err_curl_mimepost();
      }
      if (_curl_opt___0 == 10104) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10023) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10187) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10039) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10093) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10228) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10028) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10203) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10070) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10243) {
        _curl_easy_setopt_err_curl_slist();
      }
      if (_curl_opt___0 == 10100) {
        _curl_easy_setopt_err_CURLSH();
      }
    }
    tmp___4 = curl_easy_setopt(creq, (CURLoption )_curl_opt___0, ctxp->verbose > 1);
    if (tmp___4) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
      exit(1);
    } else {
      _curl_opt___1 = 20011;
      if (0) {
        if (0 < _curl_opt___1) {
          if (_curl_opt___1 < 10000) {
            _curl_easy_setopt_err_long();
          }
        }
        if (_curl_opt___1 > 30000) {
          _curl_easy_setopt_err_curl_off_t();
        }
        if (_curl_opt___1 == 10264) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10102) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10287) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10065) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10097) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10022) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10031) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10082) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10135) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10169) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10036) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10238) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10221) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10222) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10223) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10211) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10279) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10077) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10017) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10134) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10147) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10062) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10170) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10026) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10063) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10224) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10217) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10186) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10118) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10177) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10174) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10230) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10262) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10004) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10176) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10175) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10006) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10246) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10247) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10260) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10258) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10263) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10235) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10254) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10255) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10256) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10257) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10259) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10277) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10252) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10253) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10251) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10076) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10007) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10016) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10266) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10190) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10191) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10192) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10289) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10236) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10179) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10162) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10183) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10153) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10152) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10025) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10086) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10089) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10087) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10088) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10083) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10276) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10205) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10206) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10204) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10231) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10002) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10018) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10173) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10005) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10220) {
          _curl_easy_setopt_err_string();
        }
        if (_curl_opt___1 == 20079) {
          tmp___5 = 1;
        } else
        if (_curl_opt___1 == 20011) {
          tmp___5 = 1;
        } else {
          tmp___5 = 0;
        }
        if (_curl_opt___1 == 20272) {
          _curl_easy_setopt_err_resolver_start_callback();
        }
        if (_curl_opt___1 == 20130) {
          _curl_easy_setopt_err_ioctl_cb();
        }
        if (_curl_opt___1 == 20148) {
          _curl_easy_setopt_err_sockopt_cb();
        }
        if (_curl_opt___1 == 20163) {
          _curl_easy_setopt_err_opensocket_cb();
        }
        if (_curl_opt___1 == 20056) {
          _curl_easy_setopt_err_progress_cb();
        }
        if (_curl_opt___1 == 20094) {
          _curl_easy_setopt_err_debug_cb();
        }
        if (_curl_opt___1 == 20108) {
          _curl_easy_setopt_err_ssl_ctx_cb();
        }
        if (_curl_opt___1 == 20143) {
          _curl_easy_setopt_err_conv_cb();
        } else
        if (_curl_opt___1 == 20142) {
          _curl_easy_setopt_err_conv_cb();
        } else
        if (_curl_opt___1 == 20144) {
          _curl_easy_setopt_err_conv_cb();
        }
        if (_curl_opt___1 == 20167) {
          _curl_easy_setopt_err_seek_cb();
        }
        if (_curl_opt___1 == 10201) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10209) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10095) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10202) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10029) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10195) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10131) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10164) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10103) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10057) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10009) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10168) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10149) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10185) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10109) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10001) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10273) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10284) {
          goto _L___1;
        } else
        if (0) {
          _L___1: /* CIL Label */
          if (! (sizeof(server_body_reader) == sizeof(void *))) {
            _curl_easy_setopt_err_cb_data();
          }
        }
        if (_curl_opt___1 == 10010) {
          _curl_easy_setopt_err_error_buffer();
        }
        if (_curl_opt___1 == 10037) {
          _curl_easy_setopt_err_FILE();
        }
        if (_curl_opt___1 == 10015) {
          _curl_easy_setopt_err_postfields();
        } else
        if (_curl_opt___1 == 10165) {
          _curl_easy_setopt_err_postfields();
        }
        if (_curl_opt___1 == 10024) {
          _curl_easy_setopt_err_curl_httpost();
        }
        if (_curl_opt___1 == 10269) {
          _curl_easy_setopt_err_curl_mimepost();
        }
        if (_curl_opt___1 == 10104) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10023) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10187) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10039) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10093) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10228) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10028) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10203) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10070) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10243) {
          _curl_easy_setopt_err_curl_slist();
        }
        if (_curl_opt___1 == 10100) {
          _curl_easy_setopt_err_CURLSH();
        }
      }
      tmp___6 = curl_easy_setopt(creq, (CURLoption )_curl_opt___1, & server_body_reader);
      if (tmp___6) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
        exit(1);
      } else {
        _curl_opt___2 = 52;
        if (0) {
          if (0 < _curl_opt___2) {
            if (_curl_opt___2 < 10000) {
              tmp___7 = 1;
            } else {
              tmp___7 = 0;
            }
          } else {
            tmp___7 = 0;
          }
          if (_curl_opt___2 > 30000) {
            _curl_easy_setopt_err_curl_off_t();
          }
          if (_curl_opt___2 == 10264) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10102) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10287) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10065) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10097) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10022) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10031) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10082) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10135) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10169) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10036) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10238) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10221) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10222) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10223) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10211) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10279) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10077) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10017) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10134) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10147) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10062) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10170) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10026) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10063) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10224) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10217) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10186) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10118) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10177) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10174) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10230) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10262) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10004) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10176) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10175) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10006) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10246) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10247) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10260) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10258) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10263) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10235) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10254) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10255) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10256) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10257) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10259) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10277) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10252) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10253) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10251) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10076) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10007) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10016) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10266) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10190) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10191) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10192) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10289) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10236) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10179) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10162) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10183) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10153) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10152) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10025) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10086) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10089) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10087) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10088) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10083) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10276) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10205) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10206) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10204) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10231) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10002) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10018) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10173) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10005) {
            _curl_easy_setopt_err_string();
          } else
          if (_curl_opt___2 == 10220) {
            _curl_easy_setopt_err_string();
          }
          if (_curl_opt___2 == 20079) {
            _curl_easy_setopt_err_write_callback();
          } else
          if (_curl_opt___2 == 20011) {
            _curl_easy_setopt_err_write_callback();
          }
          if (_curl_opt___2 == 20272) {
            _curl_easy_setopt_err_resolver_start_callback();
          }
          if (_curl_opt___2 == 20012) {
            _curl_easy_setopt_err_read_cb();
          }
          if (_curl_opt___2 == 20130) {
            _curl_easy_setopt_err_ioctl_cb();
          }
          if (_curl_opt___2 == 20148) {
            _curl_easy_setopt_err_sockopt_cb();
          }
          if (_curl_opt___2 == 20163) {
            _curl_easy_setopt_err_opensocket_cb();
          }
          if (_curl_opt___2 == 20056) {
            _curl_easy_setopt_err_progress_cb();
          }
          if (_curl_opt___2 == 20094) {
            _curl_easy_setopt_err_debug_cb();
          }
          if (_curl_opt___2 == 20108) {
            _curl_easy_setopt_err_ssl_ctx_cb();
          }
          if (_curl_opt___2 == 20143) {
            _curl_easy_setopt_err_conv_cb();
          } else
          if (_curl_opt___2 == 20142) {
            _curl_easy_setopt_err_conv_cb();
          } else
          if (_curl_opt___2 == 20144) {
            _curl_easy_setopt_err_conv_cb();
          }
          if (_curl_opt___2 == 20167) {
            _curl_easy_setopt_err_seek_cb();
          }
          if (_curl_opt___2 == 10201) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10209) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10095) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10202) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10029) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10195) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10131) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10164) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10103) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10057) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10009) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10168) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10149) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10185) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10109) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10001) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10273) {
            goto _L___2;
          } else
          if (_curl_opt___2 == 10284) {
            goto _L___2;
          } else
          if (0) {
            _L___2: /* CIL Label */
            if (! (sizeof(1) == sizeof(void *))) {
              _curl_easy_setopt_err_cb_data();
            }
          }
          if (_curl_opt___2 == 10010) {
            _curl_easy_setopt_err_error_buffer();
          }
          if (_curl_opt___2 == 10037) {
            _curl_easy_setopt_err_FILE();
          }
          if (_curl_opt___2 == 10015) {
            _curl_easy_setopt_err_postfields();
          } else
          if (_curl_opt___2 == 10165) {
            _curl_easy_setopt_err_postfields();
          }
          if (_curl_opt___2 == 10024) {
            _curl_easy_setopt_err_curl_httpost();
          }
          if (_curl_opt___2 == 10269) {
            _curl_easy_setopt_err_curl_mimepost();
          }
          if (_curl_opt___2 == 10104) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10023) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10187) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10039) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10093) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10228) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10028) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10203) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10070) {
            _curl_easy_setopt_err_curl_slist();
          } else
          if (_curl_opt___2 == 10243) {
            _curl_easy_setopt_err_curl_slist();
          }
          if (_curl_opt___2 == 10100) {
            _curl_easy_setopt_err_CURLSH();
          }
        }
        tmp___8 = curl_easy_setopt(creq, (CURLoption )_curl_opt___2, 1);
        if (tmp___8) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
          exit(1);
        } else {
          _curl_opt___3 = 10001;
          if (0) {
            if (0 < _curl_opt___3) {
              if (_curl_opt___3 < 10000) {
                _curl_easy_setopt_err_long();
              }
            }
            if (_curl_opt___3 > 30000) {
              _curl_easy_setopt_err_curl_off_t();
            }
            if (_curl_opt___3 == 10264) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10102) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10287) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10065) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10097) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10022) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10031) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10082) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10135) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10169) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10036) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10238) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10221) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10222) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10223) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10211) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10279) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10077) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10017) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10134) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10147) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10062) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10170) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10026) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10063) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10224) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10217) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10186) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10118) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10177) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10174) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10230) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10262) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10004) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10176) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10175) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10006) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10246) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10247) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10260) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10258) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10263) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10235) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10254) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10255) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10256) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10257) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10259) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10277) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10252) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10253) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10251) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10076) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10007) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10016) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10266) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10190) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10191) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10192) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10289) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10236) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10179) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10162) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10183) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10153) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10152) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10025) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10086) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10089) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10087) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10088) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10083) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10276) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10205) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10206) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10204) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10231) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10002) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10018) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10173) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10005) {
              _curl_easy_setopt_err_string();
            } else
            if (_curl_opt___3 == 10220) {
              _curl_easy_setopt_err_string();
            }
            if (_curl_opt___3 == 20079) {
              _curl_easy_setopt_err_write_callback();
            } else
            if (_curl_opt___3 == 20011) {
              _curl_easy_setopt_err_write_callback();
            }
            if (_curl_opt___3 == 20272) {
              _curl_easy_setopt_err_resolver_start_callback();
            }
            if (_curl_opt___3 == 20012) {
              _curl_easy_setopt_err_read_cb();
            }
            if (_curl_opt___3 == 20130) {
              _curl_easy_setopt_err_ioctl_cb();
            }
            if (_curl_opt___3 == 20148) {
              _curl_easy_setopt_err_sockopt_cb();
            }
            if (_curl_opt___3 == 20163) {
              _curl_easy_setopt_err_opensocket_cb();
            }
            if (_curl_opt___3 == 20056) {
              _curl_easy_setopt_err_progress_cb();
            }
            if (_curl_opt___3 == 20094) {
              _curl_easy_setopt_err_debug_cb();
            }
            if (_curl_opt___3 == 20108) {
              _curl_easy_setopt_err_ssl_ctx_cb();
            }
            if (_curl_opt___3 == 20143) {
              _curl_easy_setopt_err_conv_cb();
            } else
            if (_curl_opt___3 == 20142) {
              _curl_easy_setopt_err_conv_cb();
            } else
            if (_curl_opt___3 == 20144) {
              _curl_easy_setopt_err_conv_cb();
            }
            if (_curl_opt___3 == 20167) {
              _curl_easy_setopt_err_seek_cb();
            }
            if (_curl_opt___3 == 10201) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10209) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10095) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10202) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10029) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10195) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10131) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10164) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10103) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10057) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10009) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10168) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10149) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10185) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10109) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10001) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10273) {
              goto _L___3;
            } else
            if (_curl_opt___3 == 10284) {
              goto _L___3;
            } else
            if (0) {
              _L___3: /* CIL Label */
              if (! (sizeof(reqp) == sizeof(void *))) {
                _curl_easy_setopt_err_cb_data();
              }
            }
            if (_curl_opt___3 == 10010) {
              _curl_easy_setopt_err_error_buffer();
            }
            if (_curl_opt___3 == 10037) {
              _curl_easy_setopt_err_FILE();
            }
            if (_curl_opt___3 == 10015) {
              _curl_easy_setopt_err_postfields();
            } else
            if (_curl_opt___3 == 10165) {
              _curl_easy_setopt_err_postfields();
            }
            if (_curl_opt___3 == 10024) {
              _curl_easy_setopt_err_curl_httpost();
            }
            if (_curl_opt___3 == 10104) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10023) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10187) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10039) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10093) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10228) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10028) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10203) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10070) {
              _curl_easy_setopt_err_curl_slist();
            } else
            if (_curl_opt___3 == 10243) {
              _curl_easy_setopt_err_curl_slist();
            }
            if (_curl_opt___3 == 10100) {
              _curl_easy_setopt_err_CURLSH();
            }
          }
          tmp___9 = curl_easy_setopt(creq, (CURLoption )_curl_opt___3, reqp);
          if (tmp___9) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
            exit(1);
          }
        }
      }
    }
  }
  res = curl_easy_perform(creq);
  curl_easy_cleanup(creq);
  if ((unsigned int )res != 0U) {
    tmp___10 = curl_easy_strerror(res);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Get work request failed: %s\n",
            tmp___10);
    server_request_free(reqp);
    return (-1);
  }
  ctxp->items.ar_root = reqp->items.ar_root;
  return (0);
}
}
int server_context_submit_solution(server_context_t *ctxp , workitem_t *work , char const   *privkey )
{
  char urlbuf[8192] ;
  char *pubhex ;
  CURL *creq ;
  CURLcode res ;
  EC_GROUP const   *tmp ;
  int _curl_opt ;
  int tmp___0 ;
  int tmp___1 ;
  CURLcode tmp___2 ;
  int _curl_opt___0 ;
  int tmp___3 ;
  CURLcode tmp___4 ;
  int _curl_opt___1 ;
  int tmp___5 ;
  CURLcode tmp___6 ;
  char const   *tmp___7 ;

  {
  tmp = EC_KEY_get0_group((EC_KEY const   *)ctxp->dummy_key);
  pubhex = EC_POINT_point2hex(tmp, (EC_POINT const   *)work->pubkey, (point_conversion_form_t )4,
                              (BN_CTX *)((void *)0));
  snprintf((char * __restrict  )(urlbuf), sizeof(urlbuf), (char const   * __restrict  )"%s?key=%s%%3A%s&privateKey=%s&bitcoinAddress=%s",
           ctxp->submit, work->pattern, pubhex, privkey, ctxp->credit_addr);
  CRYPTO_free((void *)pubhex);
  creq = curl_easy_init();
  _curl_opt = 10002;
  if (0) {
    if (0 < _curl_opt) {
      if (_curl_opt < 10000) {
        _curl_easy_setopt_err_long();
      }
    }
    if (_curl_opt > 30000) {
      _curl_easy_setopt_err_curl_off_t();
    }
    if (_curl_opt == 10264) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10102) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10287) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10065) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10097) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10022) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10031) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10082) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10135) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10169) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10036) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10238) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10221) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10222) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10223) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10211) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10279) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10077) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10017) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10134) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10147) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10062) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10170) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10026) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10063) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10224) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10217) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10186) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10118) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10177) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10174) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10230) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10262) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10004) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10176) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10175) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10006) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10246) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10247) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10260) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10258) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10263) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10235) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10254) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10255) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10256) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10257) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10259) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10277) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10252) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10253) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10251) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10076) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10007) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10016) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10266) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10190) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10191) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10192) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10289) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10236) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10179) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10162) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10183) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10153) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10152) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10025) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10086) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10089) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10087) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10088) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10083) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10276) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10205) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10206) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10204) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10231) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10002) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10018) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10173) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10005) {
      tmp___0 = 1;
    } else
    if (_curl_opt == 10220) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    if (_curl_opt == 20079) {
      _curl_easy_setopt_err_write_callback();
    } else
    if (_curl_opt == 20011) {
      _curl_easy_setopt_err_write_callback();
    }
    if (_curl_opt == 20272) {
      _curl_easy_setopt_err_resolver_start_callback();
    }
    if (_curl_opt == 20012) {
      _curl_easy_setopt_err_read_cb();
    }
    if (_curl_opt == 20130) {
      _curl_easy_setopt_err_ioctl_cb();
    }
    if (_curl_opt == 20148) {
      _curl_easy_setopt_err_sockopt_cb();
    }
    if (_curl_opt == 20163) {
      _curl_easy_setopt_err_opensocket_cb();
    }
    if (_curl_opt == 20056) {
      _curl_easy_setopt_err_progress_cb();
    }
    if (_curl_opt == 20094) {
      _curl_easy_setopt_err_debug_cb();
    }
    if (_curl_opt == 20108) {
      _curl_easy_setopt_err_ssl_ctx_cb();
    }
    if (_curl_opt == 20143) {
      _curl_easy_setopt_err_conv_cb();
    } else
    if (_curl_opt == 20142) {
      _curl_easy_setopt_err_conv_cb();
    } else
    if (_curl_opt == 20144) {
      _curl_easy_setopt_err_conv_cb();
    }
    if (_curl_opt == 20167) {
      _curl_easy_setopt_err_seek_cb();
    }
    if (_curl_opt == 10201) {
      goto _L;
    } else
    if (_curl_opt == 10209) {
      goto _L;
    } else
    if (_curl_opt == 10095) {
      goto _L;
    } else
    if (_curl_opt == 10202) {
      goto _L;
    } else
    if (_curl_opt == 10029) {
      goto _L;
    } else
    if (_curl_opt == 10195) {
      goto _L;
    } else
    if (_curl_opt == 10131) {
      goto _L;
    } else
    if (_curl_opt == 10164) {
      goto _L;
    } else
    if (_curl_opt == 10103) {
      goto _L;
    } else
    if (_curl_opt == 10057) {
      goto _L;
    } else
    if (_curl_opt == 10009) {
      goto _L;
    } else
    if (_curl_opt == 10168) {
      goto _L;
    } else
    if (_curl_opt == 10149) {
      goto _L;
    } else
    if (_curl_opt == 10185) {
      goto _L;
    } else
    if (_curl_opt == 10109) {
      goto _L;
    } else
    if (_curl_opt == 10001) {
      goto _L;
    } else
    if (_curl_opt == 10273) {
      goto _L;
    } else
    if (_curl_opt == 10284) {
      goto _L;
    } else
    if (0) {
      _L: /* CIL Label */
      if (! (sizeof(urlbuf) == sizeof(void *))) {
        _curl_easy_setopt_err_cb_data();
      }
    }
    if (_curl_opt == 10037) {
      _curl_easy_setopt_err_FILE();
    }
    if (_curl_opt == 10015) {
      tmp___1 = 1;
    } else
    if (_curl_opt == 10165) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    if (_curl_opt == 10024) {
      _curl_easy_setopt_err_curl_httpost();
    }
    if (_curl_opt == 10269) {
      _curl_easy_setopt_err_curl_mimepost();
    }
    if (_curl_opt == 10104) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10023) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10187) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10039) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10093) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10228) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10028) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10203) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10070) {
      _curl_easy_setopt_err_curl_slist();
    } else
    if (_curl_opt == 10243) {
      _curl_easy_setopt_err_curl_slist();
    }
    if (_curl_opt == 10100) {
      _curl_easy_setopt_err_CURLSH();
    }
  }
  tmp___2 = curl_easy_setopt(creq, (CURLoption )_curl_opt, urlbuf);
  if (tmp___2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
    exit(1);
  } else {
    _curl_opt___0 = 41;
    if (0) {
      if (0 < _curl_opt___0) {
        if (_curl_opt___0 < 10000) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
      if (_curl_opt___0 > 30000) {
        _curl_easy_setopt_err_curl_off_t();
      }
      if (_curl_opt___0 == 10264) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10102) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10287) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10065) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10097) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10022) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10031) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10082) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10135) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10169) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10036) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10238) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10221) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10222) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10223) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10211) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10279) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10077) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10017) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10134) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10147) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10062) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10170) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10026) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10063) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10224) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10217) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10186) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10118) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10177) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10174) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10230) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10262) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10004) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10176) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10175) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10006) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10246) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10247) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10260) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10258) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10263) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10235) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10254) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10255) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10256) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10257) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10259) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10277) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10252) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10253) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10251) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10076) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10007) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10016) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10266) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10190) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10191) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10192) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10289) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10236) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10179) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10162) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10183) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10153) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10152) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10025) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10086) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10089) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10087) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10088) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10083) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10276) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10205) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10206) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10204) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10231) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10002) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10018) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10173) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10005) {
        _curl_easy_setopt_err_string();
      } else
      if (_curl_opt___0 == 10220) {
        _curl_easy_setopt_err_string();
      }
      if (_curl_opt___0 == 20079) {
        _curl_easy_setopt_err_write_callback();
      } else
      if (_curl_opt___0 == 20011) {
        _curl_easy_setopt_err_write_callback();
      }
      if (_curl_opt___0 == 20272) {
        _curl_easy_setopt_err_resolver_start_callback();
      }
      if (_curl_opt___0 == 20012) {
        _curl_easy_setopt_err_read_cb();
      }
      if (_curl_opt___0 == 20130) {
        _curl_easy_setopt_err_ioctl_cb();
      }
      if (_curl_opt___0 == 20148) {
        _curl_easy_setopt_err_sockopt_cb();
      }
      if (_curl_opt___0 == 20163) {
        _curl_easy_setopt_err_opensocket_cb();
      }
      if (_curl_opt___0 == 20056) {
        _curl_easy_setopt_err_progress_cb();
      }
      if (_curl_opt___0 == 20094) {
        _curl_easy_setopt_err_debug_cb();
      }
      if (_curl_opt___0 == 20108) {
        _curl_easy_setopt_err_ssl_ctx_cb();
      }
      if (_curl_opt___0 == 20143) {
        _curl_easy_setopt_err_conv_cb();
      } else
      if (_curl_opt___0 == 20142) {
        _curl_easy_setopt_err_conv_cb();
      } else
      if (_curl_opt___0 == 20144) {
        _curl_easy_setopt_err_conv_cb();
      }
      if (_curl_opt___0 == 20167) {
        _curl_easy_setopt_err_seek_cb();
      }
      if (_curl_opt___0 == 10201) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10209) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10095) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10202) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10029) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10195) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10131) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10164) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10103) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10057) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10009) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10168) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10149) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10185) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10109) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10001) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10273) {
        goto _L___0;
      } else
      if (_curl_opt___0 == 10284) {
        goto _L___0;
      } else
      if (0) {
        _L___0: /* CIL Label */
        if (! (sizeof(ctxp->verbose > 1) == sizeof(void *))) {
          _curl_easy_setopt_err_cb_data();
        }
      }
      if (_curl_opt___0 == 10010) {
        _curl_easy_setopt_err_error_buffer();
      }
      if (_curl_opt___0 == 10037) {
        _curl_easy_setopt_err_FILE();
      }
      if (_curl_opt___0 == 10015) {
        _curl_easy_setopt_err_postfields();
      } else
      if (_curl_opt___0 == 10165) {
        _curl_easy_setopt_err_postfields();
      }
      if (_curl_opt___0 == 10024) {
        _curl_easy_setopt_err_curl_httpost();
      }
      if (_curl_opt___0 == 10269) {
        _curl_easy_setopt_err_curl_mimepost();
      }
      if (_curl_opt___0 == 10104) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10023) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10187) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10039) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10093) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10228) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10028) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10203) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10070) {
        _curl_easy_setopt_err_curl_slist();
      } else
      if (_curl_opt___0 == 10243) {
        _curl_easy_setopt_err_curl_slist();
      }
      if (_curl_opt___0 == 10100) {
        _curl_easy_setopt_err_CURLSH();
      }
    }
    tmp___4 = curl_easy_setopt(creq, (CURLoption )_curl_opt___0, ctxp->verbose > 1);
    if (tmp___4) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
      exit(1);
    } else {
      _curl_opt___1 = 52;
      if (0) {
        if (0 < _curl_opt___1) {
          if (_curl_opt___1 < 10000) {
            tmp___5 = 1;
          } else {
            tmp___5 = 0;
          }
        } else {
          tmp___5 = 0;
        }
        if (_curl_opt___1 > 30000) {
          _curl_easy_setopt_err_curl_off_t();
        }
        if (_curl_opt___1 == 10264) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10102) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10287) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10065) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10097) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10022) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10031) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10082) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10135) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10169) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10036) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10238) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10221) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10222) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10223) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10211) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10279) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10077) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10017) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10134) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10147) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10062) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10170) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10026) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10063) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10224) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10217) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10186) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10118) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10177) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10174) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10230) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10262) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10004) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10176) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10175) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10006) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10246) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10247) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10260) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10258) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10263) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10235) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10254) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10255) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10256) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10257) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10259) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10277) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10252) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10253) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10251) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10076) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10007) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10016) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10266) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10190) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10191) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10192) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10289) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10236) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10179) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10162) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10183) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10153) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10152) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10025) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10086) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10089) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10087) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10088) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10083) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10276) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10205) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10206) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10204) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10231) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10002) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10018) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10173) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10005) {
          _curl_easy_setopt_err_string();
        } else
        if (_curl_opt___1 == 10220) {
          _curl_easy_setopt_err_string();
        }
        if (_curl_opt___1 == 20079) {
          _curl_easy_setopt_err_write_callback();
        } else
        if (_curl_opt___1 == 20011) {
          _curl_easy_setopt_err_write_callback();
        }
        if (_curl_opt___1 == 20272) {
          _curl_easy_setopt_err_resolver_start_callback();
        }
        if (_curl_opt___1 == 20012) {
          _curl_easy_setopt_err_read_cb();
        }
        if (_curl_opt___1 == 20130) {
          _curl_easy_setopt_err_ioctl_cb();
        }
        if (_curl_opt___1 == 20148) {
          _curl_easy_setopt_err_sockopt_cb();
        }
        if (_curl_opt___1 == 20163) {
          _curl_easy_setopt_err_opensocket_cb();
        }
        if (_curl_opt___1 == 20056) {
          _curl_easy_setopt_err_progress_cb();
        }
        if (_curl_opt___1 == 20094) {
          _curl_easy_setopt_err_debug_cb();
        }
        if (_curl_opt___1 == 20108) {
          _curl_easy_setopt_err_ssl_ctx_cb();
        }
        if (_curl_opt___1 == 20143) {
          _curl_easy_setopt_err_conv_cb();
        } else
        if (_curl_opt___1 == 20142) {
          _curl_easy_setopt_err_conv_cb();
        } else
        if (_curl_opt___1 == 20144) {
          _curl_easy_setopt_err_conv_cb();
        }
        if (_curl_opt___1 == 20167) {
          _curl_easy_setopt_err_seek_cb();
        }
        if (_curl_opt___1 == 10201) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10209) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10095) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10202) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10029) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10195) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10131) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10164) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10103) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10057) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10009) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10168) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10149) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10185) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10109) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10001) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10273) {
          goto _L___1;
        } else
        if (_curl_opt___1 == 10284) {
          goto _L___1;
        } else
        if (0) {
          _L___1: /* CIL Label */
          if (! (sizeof(1) == sizeof(void *))) {
            _curl_easy_setopt_err_cb_data();
          }
        }
        if (_curl_opt___1 == 10010) {
          _curl_easy_setopt_err_error_buffer();
        }
        if (_curl_opt___1 == 10037) {
          _curl_easy_setopt_err_FILE();
        }
        if (_curl_opt___1 == 10015) {
          _curl_easy_setopt_err_postfields();
        } else
        if (_curl_opt___1 == 10165) {
          _curl_easy_setopt_err_postfields();
        }
        if (_curl_opt___1 == 10024) {
          _curl_easy_setopt_err_curl_httpost();
        }
        if (_curl_opt___1 == 10269) {
          _curl_easy_setopt_err_curl_mimepost();
        }
        if (_curl_opt___1 == 10104) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10023) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10187) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10039) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10093) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10228) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10028) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10203) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10070) {
          _curl_easy_setopt_err_curl_slist();
        } else
        if (_curl_opt___1 == 10243) {
          _curl_easy_setopt_err_curl_slist();
        }
        if (_curl_opt___1 == 10100) {
          _curl_easy_setopt_err_CURLSH();
        }
      }
      tmp___6 = curl_easy_setopt(creq, (CURLoption )_curl_opt___1, 1);
      if (tmp___6) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to set up libcurl\n");
        exit(1);
      }
    }
  }
  res = curl_easy_perform(creq);
  if ((unsigned int )res != 0U) {
    tmp___7 = curl_easy_strerror(res);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Submission failed: %s\n",
            tmp___7);
    curl_easy_cleanup(creq);
    return (-1);
  }
  curl_easy_cleanup(creq);
  return (0);
}
}
static pthread_mutex_t soln_lock  ;
static pthread_cond_t soln_cond  ;
static char *soln_pattern  =    (char *)((void *)0);
static char *soln_private_key  =    (char *)((void *)0);
void free_soln(void)
{


  {
  if (soln_pattern) {
    free((void *)soln_pattern);
    soln_pattern = (char *)((void *)0);
  }
  if (soln_private_key) {
    CRYPTO_free((void *)soln_private_key);
    soln_private_key = (char *)((void *)0);
  }
  return;
}
}
void output_match_work_complete(vg_context_t *vcp , EC_KEY *pkey , char const   *pattern )
{
  BIGNUM const   *tmp ;

  {
  vg_output_match_console(vcp, pkey, pattern);
  pthread_mutex_lock(& soln_lock);
  free_soln();
  soln_pattern = strdup(pattern);
  tmp = EC_KEY_get0_private_key((EC_KEY const   *)pkey);
  soln_private_key = BN_bn2hex(tmp);
  vcp->vc_halt = 1;
  pthread_cond_broadcast(& soln_cond);
  pthread_mutex_unlock(& soln_lock);
  return;
}
}
int check_solution(server_context_t *scp , pubkeybatch_t *pbatch )
{
  int res ;
  workitem_t *wip ;
  workitem_t *tmp ;

  {
  res = 0;
  pthread_mutex_lock(& soln_lock);
  if ((unsigned long )soln_private_key != (unsigned long )((void *)0)) {
    tmp = workitem_avl_search(& pbatch->items, (char const   *)soln_pattern);
    wip = tmp;
    if (! ((unsigned long )wip != (unsigned long )((void *)0))) {
      __assert_fail("wip != NULL", "oclvanityminer.c", 712U, "check_solution");
    }
    avl_remove(& pbatch->items, & wip->avlent);
    (pbatch->nitems) --;
    pbatch->total_value -= wip->value;
    server_context_submit_solution(scp, wip, (char const   *)soln_private_key);
    if ((unsigned long )wip->pubkey == (unsigned long )pbatch->pubkey) {
      wip->pubkey = (EC_POINT *)((void *)0);
    }
    server_workitem_free(wip);
    free_soln();
    res = 1;
  }
  pthread_mutex_unlock(& soln_lock);
  return (res);
}
}
pubkeybatch_t *most_valuable_pkb(server_context_t *scp )
{
  pubkeybatch_t *pbatch ;
  pubkeybatch_t *res ;

  {
  res = (pubkeybatch_t *)((void *)0);
  pbatch = pubkeybatch_avl_first(& scp->items);
  while ((unsigned long )pbatch != (unsigned long )((void *)0)) {
    if (! res) {
      res = pbatch;
    } else
    if (res->total_value < pbatch->total_value) {
      res = pbatch;
    }
    pbatch = pubkeybatch_avl_next(pbatch);
  }
  return (res);
}
}
void usage(char const   *name )
{


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"oclVanityMiner %s (OpenSSL 1.0.1u  22 Sep 2016)\nUsage: %s -u <URL> -a <credit address>\nOrganized vanity address mining client using OpenCL.  Contacts the specified\nbounty pool server, downloads a list of active bounties, and attempts to\ngenerate the address with the best difficulty to reward ratio.  Maintains\ncontact with the bounty pool server and periodically refreshes the bounty\nlist.\nBy default, if no device is specified, and the system has exactly one OpenCL\ndevice, it will be selected automatically, otherwise if the system has\nmultiple OpenCL devices and no device is specified, an error will be\nreported.  To use multiple devices simultaneously, specify the -D option for\neach device.\n\nOptions:\n-u <URL>      Bounty pool URL\n-a <address>  Credit address for completed work\n-i <interval> Set server polling interval in seconds (default 90)\n-v            Verbose output\n-q            Quiet output\n-p <platform> Select OpenCL platform\n-d <device>   Select OpenCL device\n-D <devstr>   Use OpenCL device, identified by device string\n              Form: <platform>:<devicenumber>[,<options>]\n              Example: 0:0,grid=1024x1024\n-S            Safe mode, disable OpenCL loop unrolling optimizations\n-w <worksize> Set work items per thread in a work unit\n-t <threads>  Set target thread count per multiprocessor\n-g <x>x<y>    Set grid size\n-b <invsize>  Set modular inverse ops per thread\n-V            Enable kernel/OpenCL/hardware verification (SLOW)\n",
          version, name);
  return;
}
}
int main(int argc , char **argv )
{
  char const   *url ;
  char const   *credit_addr ;
  int opt ;
  int platformidx ;
  int deviceidx ;
  char *pend ;
  int verbose ;
  int interval ;
  int nthreads ;
  int worksize ;
  int nrows ;
  int ncols ;
  int invsize ;
  int verify_mode ;
  int safe_mode ;
  char *devstrs[32] ;
  int ndevstrs ;
  vg_context_t *vcp ;
  vg_ocl_context_t *vocp ;
  int res ;
  int thread_started ;
  pubkeybatch_t *active_pkb ;
  float active_pkb_value ;
  server_context_t *scp ;
  pubkeybatch_t *pkb ;
  int was_sleeping ;
  struct timeval tv ;
  struct timespec sleepy ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  workitem_t *wip ;
  int tmp___6 ;
  int tmp___8 ;

  {
  url = (char const   *)((void *)0);
  credit_addr = (char const   *)((void *)0);
  platformidx = -1;
  deviceidx = -1;
  verbose = 1;
  interval = 90;
  nthreads = 0;
  worksize = 0;
  nrows = 0;
  ncols = 0;
  invsize = 0;
  verify_mode = 0;
  safe_mode = 0;
  ndevstrs = 0;
  vcp = (vg_context_t *)((void *)0);
  vocp = (vg_ocl_context_t *)((void *)0);
  thread_started = 0;
  active_pkb = (pubkeybatch_t *)((void *)0);
  active_pkb_value = (float )0;
  scp = (server_context_t *)((void *)0);
  was_sleeping = 0;
  pthread_mutex_init(& soln_lock, (pthread_mutexattr_t const   *)((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& soln_cond), (pthread_condattr_t const   * __restrict  )((void *)0));
  if (argc == 1) {
    usage((char const   *)*(argv + 0));
    return (1);
  }
  while (1) {
    opt = getopt(argc, (char * const  *)argv, "u:a:vqp:d:w:t:g:b:VD:Sh?i:");
    if (! (opt != -1)) {
      break;
    }
    switch (opt) {
    case 117:
    url = (char const   *)optarg;
    break;
    case 97:
    credit_addr = (char const   *)optarg;
    break;
    case 118:
    verbose = 2;
    break;
    case 113:
    verbose = 0;
    break;
    case 105:
    interval = atoi((char const   *)optarg);
    if (interval < 10) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid interval \'%s\'\n",
              optarg);
      return (1);
    }
    break;
    case 112:
    platformidx = atoi((char const   *)optarg);
    break;
    case 100:
    deviceidx = atoi((char const   *)optarg);
    break;
    case 119:
    worksize = atoi((char const   *)optarg);
    if (worksize == 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid work size \'%s\'\n",
              optarg);
      return (1);
    }
    break;
    case 116:
    nthreads = atoi((char const   *)optarg);
    if (nthreads == 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid thread count \'%s\'\n",
              optarg);
      return (1);
    }
    break;
    case 103:
    nrows = 0;
    tmp = strtol((char const   * __restrict  )optarg, (char ** __restrict  )(& pend),
                 0);
    ncols = (int )tmp;
    if (pend) {
      if ((int )*pend == 120) {
        tmp___0 = strtol((char const   * __restrict  )(pend + 1), (char ** __restrict  )((void *)0),
                         0);
        nrows = (int )tmp___0;
      }
    }
    if (! nrows) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid grid size \'%s\'\n",
              optarg);
      return (1);
    } else
    if (! ncols) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid grid size \'%s\'\n",
              optarg);
      return (1);
    }
    break;
    case 98:
    invsize = atoi((char const   *)optarg);
    if (! invsize) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid modular inverse size \'%s\'\n",
              optarg);
      return (1);
    }
    if (invsize & (invsize - 1)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Modular inverse size must be a power of 2\n");
      return (1);
    }
    break;
    case 86:
    verify_mode = 1;
    break;
    case 83:
    safe_mode = 1;
    break;
    case 68:
    if (ndevstrs >= 32) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Too many OpenCL devices (limit %d)\n",
              32);
      return (1);
    }
    tmp___1 = ndevstrs;
    ndevstrs ++;
    devstrs[tmp___1] = optarg;
    break;
    default:
    usage((char const   *)*(argv + 0));
    return (1);
    }
  }
  curl_easy_init();
  vcp = vg_prefix_context_new(0, 128, 0);
  vcp->vc_verbose = verbose;
  vcp->vc_output_match = & output_match_work_complete;
  vcp->vc_output_timing = & vg_output_timing_console;
  if (! url) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: No server URL specified\n");
    return (1);
  }
  if (! credit_addr) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: No reward address specified\n");
    return (1);
  }
  tmp___2 = vg_b58_decode_check(credit_addr, (void *)0, (size_t )0);
  if (! tmp___2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Invalid reward address specified\n");
    return (1);
  }
  scp = server_context_new(url, credit_addr);
  scp->verbose = verbose;
  tmp___3 = server_context_getwork(scp);
  if (tmp___3) {
    return (1);
  }
  res = 0;
  if (ndevstrs) {
    opt = 0;
    while (opt < ndevstrs) {
      vocp = vg_ocl_context_new_from_devstr(vcp, (char const   *)devstrs[opt], safe_mode,
                                            verify_mode);
      if (! vocp) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not open device \'%s\', ignoring\n",
                devstrs[opt]);
      } else {
        res ++;
      }
      opt ++;
    }
  } else {
    vocp = vg_ocl_context_new(vcp, platformidx, deviceidx, safe_mode, verify_mode,
                              worksize, nthreads, nrows, ncols, invsize);
    if (vocp) {
      res ++;
    }
  }
  if (! res) {
    vg_ocl_enumerate_devices();
    return (1);
  }
  if (verbose > 1) {
    dump_work(& scp->items);
  }
  while (1) {
    tmp___4 = avl_root_empty(& scp->items);
    if (tmp___4) {
      server_context_getwork(scp);
    }
    pkb = most_valuable_pkb(scp);
    if (pkb) {
      if (active_pkb) {
        tmp___5 = server_pubkeybatch_equal(scp, active_pkb, pkb);
        if (tmp___5) {
          pkb = active_pkb;
        }
      }
    }
    if (thread_started) {
      if (! active_pkb) {
        goto _L;
      } else
      if ((unsigned long )pkb != (unsigned long )active_pkb) {
        _L: /* CIL Label */
        vg_context_stop_threads(vcp);
        thread_started = 0;
        if (active_pkb) {
          check_solution(scp, active_pkb);
          active_pkb = (pubkeybatch_t *)((void *)0);
        }
        vg_context_clear_all_patterns(vcp);
        if (verbose > 1) {
          dump_work(& scp->items);
        }
      }
    }
    if (! pkb) {
      if (! was_sleeping) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No work available, sleeping\n");
        was_sleeping = 1;
      }
    } else
    if (! active_pkb) {
      was_sleeping = 0;
      active_pkb_value = (float )0;
      vcp->vc_pubkey_base = pkb->pubkey;
      wip = workitem_avl_first(& pkb->items);
      while ((unsigned long )wip != (unsigned long )((void *)0)) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Searching for pattern: \"%s\" Reward: %f Value: %f BTC/Gkey\n",
                wip->pattern, wip->reward, wip->value);
        vcp->vc_addrtype = wip->addrtype;
        tmp___6 = vg_context_add_patterns(vcp, (char const   ** const  )(& wip->pattern),
                                          1);
        if (tmp___6) {
          active_pkb_value = (float )((double )active_pkb_value + wip->value);
        } else {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: could not add pattern\n");
        }
        if (! vcp->vc_npatterns) {
          __assert_fail("vcp->vc_npatterns", "oclvanityminer.c", 1042U, "main");
        }
        wip = workitem_avl_next(wip);
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nTotal value for current work: %f BTC/Gkey\n",
              (double )active_pkb_value);
      res = vg_context_start_threads(vcp);
      if (res) {
        return (1);
      }
      thread_started = 1;
      active_pkb = pkb;
    }
    gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
    sleepy.tv_sec = tv.tv_sec;
    sleepy.tv_nsec = tv.tv_usec * 1000L;
    sleepy.tv_sec += (__time_t )interval;
    pthread_mutex_lock(& soln_lock);
    res = 0;
    if (! soln_private_key) {
      res = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& soln_cond), (pthread_mutex_t * __restrict  )(& soln_lock),
                                   (struct timespec  const  * __restrict  )(& sleepy));
    }
    pthread_mutex_unlock(& soln_lock);
    if (res == 0) {
      tmp___8 = check_solution(scp, active_pkb);
      if (tmp___8) {
        active_pkb = (pubkeybatch_t *)((void *)0);
      }
    } else
    if (res == 110) {
      free_pkb_tree(& scp->items, active_pkb);
    }
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-bTF4NPpC.i","-ggdb,-O3,-Wall")
extern int fclose(FILE *__stream ) ;
extern int fflush(FILE *__stream ) ;
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const   * __restrict  __filename ,
                                                              char const   * __restrict  __modes ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
extern unsigned char *SHA256(unsigned char const   *d , size_t n , unsigned char *md ) ;
extern unsigned char *RIPEMD160(unsigned char const   *d , size_t n , unsigned char *md ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_chk_warn)(char const   * __restrict  __name , char * __restrict  __resolved ,
                                size_t __resolvedlen )  __asm__("__realpath_chk") __attribute__((__warning__("second argument of realpath must be either NULL or at least PATH_MAX bytes long buffer"))) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __gnu_inline__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                        char * __restrict  __resolved ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __gnu_inline__,
__artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                              char * __restrict  __resolved )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__resolved, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)__resolved, 1);
    if (tmp___1 < 4096UL) {
      tmp = __builtin_object_size((void *)__resolved, 1);
      tmp___0 = __realpath_chk_warn(__name, __resolved, tmp);
      return (tmp___0);
    }
    tmp___2 = __builtin_object_size((void *)__resolved, 1);
    tmp___3 = __realpath_chk(__name, __resolved, tmp___2);
    return (tmp___3);
  }
  tmp___5 = __realpath_alias(__name, __resolved);
  return (tmp___5);
}
}
extern BIGNUM const   *BN_value_one(void) ;
extern BN_CTX *BN_CTX_new(void) ;
extern void BN_CTX_free(BN_CTX *c ) ;
extern BIGNUM *BN_new(void) ;
extern void BN_init(BIGNUM * ) ;
extern void BN_clear_free(BIGNUM *a ) ;
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
extern int BN_add(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
extern int BN_mul(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b , BN_CTX *ctx ) ;
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
extern int BN_set_word(BIGNUM *a , unsigned long w ) ;
extern unsigned long BN_get_word(BIGNUM const   *a ) ;
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
extern void BN_free(BIGNUM *a ) ;
extern int BN_lshift(BIGNUM *r , BIGNUM const   *a , int n ) ;
extern int BN_exp(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BN_CTX *ctx ) ;
extern void BN_clear(BIGNUM *a ) ;
extern int BN_set_bit(BIGNUM *a , int n ) ;
extern char *BN_bn2dec(BIGNUM const   *a ) ;
extern EC_POINT *EC_POINT_new(EC_GROUP const   *group ) ;
extern int EC_POINT_copy(EC_POINT *dst , EC_POINT const   *src ) ;
extern size_t EC_POINT_point2oct(EC_GROUP const   *group , EC_POINT const   *p , point_conversion_form_t form ,
                                 unsigned char *buf , size_t len , BN_CTX *ctx ) ;
extern int EC_POINT_add(EC_GROUP const   *group , EC_POINT *r , EC_POINT const   *a ,
                        EC_POINT const   *b , BN_CTX *ctx ) ;
extern EC_KEY *EC_KEY_new_by_curve_name(int nid ) ;
extern EC_POINT const   *EC_KEY_get0_public_key(EC_KEY const   *key ) ;
extern int EC_KEY_precompute_mult(EC_KEY *key , BN_CTX *ctx ) ;
extern int EC_KEY_check_key(EC_KEY const   *key ) ;
extern int i2d_ECPrivateKey(EC_KEY *key , unsigned char **out ) ;
extern int i2o_ECPublicKey(EC_KEY *key , unsigned char **out ) ;
extern void (*pcre_free)(void * ) ;
extern pcre *pcre_compile(char const   * , int  , char const   ** , int * , unsigned char const   * ) ;
extern int pcre_exec(pcre const   * , pcre_extra const   * , char const   * , int  ,
                     int  , int  , int * , int  ) ;
extern pcre_extra *pcre_study(pcre const   * , int  , char const   ** ) ;
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
void vg_context_free(vg_context_t *vcp ) ;
void vg_context_wait_for_completion(vg_context_t *vcp ) ;
void vg_prefix_context_set_case_insensitive(vg_context_t *vcp , int caseinsensitive ) ;
vg_context_t *vg_regex_context_new(int addrtype , int privtype ) ;
int vg_output_timing(vg_context_t *vcp , int cycle , struct timeval *last ) ;
int vg_context_hash160_sort(vg_context_t *vcp , void *buf ) ;
void vg_context_thread_exit(vg_context_t *vcp ) ;
int vg_exec_context_init(vg_context_t *vcp , vg_exec_context_t *vxcp ) ;
void vg_exec_context_del(vg_exec_context_t *vxcp ) ;
void vg_exec_context_consolidate_key(vg_exec_context_t *vxcp ) ;
void vg_exec_context_calc_address(vg_exec_context_t *vxcp ) ;
void vg_exec_context_downgrade_lock(vg_exec_context_t *vxcp ) ;
int vg_exec_context_upgrade_lock(vg_exec_context_t *vxcp ) ;
void vg_exec_context_yield(vg_exec_context_t *vxcp ) ;
char const   *vg_b58_alphabet ;
signed char const   vg_b58_reverse_map[256] ;
void dumphex(unsigned char const   *src , size_t len ) ;
void dumpbn(BIGNUM const   *bn ) ;
void vg_encode_address(EC_POINT const   *ppoint , EC_GROUP const   *pgroup , int addrtype ,
                       char *result ) ;
void vg_encode_script_address(EC_POINT const   *ppoint , EC_GROUP const   *pgroup ,
                              int addrtype , char *result ) ;
void vg_encode_privkey(EC_KEY const   *pkey , int addrtype , char *result ) ;
int vg_set_privkey(BIGNUM const   *bnpriv , EC_KEY *pkey ) ;
int vg_protect_encode_privkey(char *out , EC_KEY const   *pkey , int keytype , int parameter_group ,
                              char const   *pass ) ;
static void avl_delete_fix___0(avl_root_t *rootp , avl_item_t *itemp , avl_item_t *parentp )
{
  avl_item_t *childp ;

  {
  if ((unsigned long )parentp->ai_left == (unsigned long )((void *)0)) {
    if ((unsigned long )parentp->ai_right == (unsigned long )((void *)0)) {
      if (! ((unsigned long )itemp == (unsigned long )((void *)0))) {
        __assert_fail("itemp == NULL", "avl.h", 188U, "avl_delete_fix");
      }
      parentp->ai_balance = (avl_balance_t )1;
      itemp = parentp;
      parentp = itemp->ai_up;
    }
  }
  while (parentp) {
    if ((unsigned long )itemp == (unsigned long )parentp->ai_right) {
      itemp = parentp->ai_left;
      if ((unsigned int )parentp->ai_balance == 0U) {
        if ((unsigned int )itemp->ai_balance == 0U) {
          _avl_rotate_ll(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          parentp = itemp;
        } else
        if ((unsigned int )itemp->ai_balance == 1U) {
          _avl_rotate_ll(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )2;
          parentp->ai_balance = (avl_balance_t )0;
          break;
        } else {
          childp = itemp->ai_right;
          _avl_rotate_lr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          if ((unsigned int )childp->ai_balance == 2U) {
            itemp->ai_balance = (avl_balance_t )0;
          }
          if ((unsigned int )childp->ai_balance == 0U) {
            parentp->ai_balance = (avl_balance_t )2;
          }
          childp->ai_balance = (avl_balance_t )1;
          parentp = childp;
        }
      } else
      if ((unsigned int )parentp->ai_balance == 1U) {
        parentp->ai_balance = (avl_balance_t )0;
        break;
      } else {
        parentp->ai_balance = (avl_balance_t )1;
      }
    } else {
      itemp = parentp->ai_right;
      if ((unsigned int )parentp->ai_balance == 2U) {
        if ((unsigned int )itemp->ai_balance == 2U) {
          _avl_rotate_rr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          parentp = itemp;
        } else
        if ((unsigned int )itemp->ai_balance == 1U) {
          _avl_rotate_rr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )0;
          parentp->ai_balance = (avl_balance_t )2;
          break;
        } else {
          childp = itemp->ai_left;
          _avl_rotate_rl(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          if ((unsigned int )childp->ai_balance == 2U) {
            parentp->ai_balance = (avl_balance_t )0;
          }
          if ((unsigned int )childp->ai_balance == 0U) {
            itemp->ai_balance = (avl_balance_t )2;
          }
          childp->ai_balance = (avl_balance_t )1;
          parentp = childp;
        }
      } else
      if ((unsigned int )parentp->ai_balance == 1U) {
        parentp->ai_balance = (avl_balance_t )2;
        break;
      } else {
        parentp->ai_balance = (avl_balance_t )1;
      }
    }
    itemp = parentp;
    parentp = itemp->ai_up;
  }
  return;
}
}
static void avl_insert_fix___0(avl_root_t *rootp , avl_item_t *itemp )
{
  avl_item_t *childp ;
  avl_item_t *parentp ;
  struct _avl_item_s *tmp ;

  {
  parentp = itemp->ai_up;
  tmp = (struct _avl_item_s *)((void *)0);
  itemp->ai_right = tmp;
  itemp->ai_left = tmp;
  if (! (! itemp->ai_indexed)) {
    __assert_fail("!itemp->ai_indexed", "avl.h", 275U, "avl_insert_fix");
  }
  itemp->ai_indexed = 1;
  while (parentp) {
    if ((unsigned long )itemp == (unsigned long )parentp->ai_left) {
      if ((unsigned int )parentp->ai_balance == 0U) {
        if ((unsigned int )itemp->ai_balance == 0U) {
          _avl_rotate_ll(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          break;
        } else {
          if (! ((unsigned int )itemp->ai_balance != 1U)) {
            __assert_fail("itemp->ai_balance != CENT", "avl.h", 290U, "avl_insert_fix");
          }
          childp = itemp->ai_right;
          _avl_rotate_lr(rootp, parentp);
          itemp->ai_balance = (avl_balance_t )1;
          parentp->ai_balance = (avl_balance_t )1;
          if ((unsigned int )childp->ai_balance == 2U) {
            itemp->ai_balance = (avl_balance_t )0;
          }
          if ((unsigned int )childp->ai_balance == 0U) {
            parentp->ai_balance = (avl_balance_t )2;
          }
          childp->ai_balance = (avl_balance_t )1;
          break;
        }
      } else
      if ((unsigned int )parentp->ai_balance == 1U) {
        parentp->ai_balance = (avl_balance_t )0;
      } else {
        parentp->ai_balance = (avl_balance_t )1;
        return;
      }
    } else
    if ((unsigned int )parentp->ai_balance == 2U) {
      if ((unsigned int )itemp->ai_balance == 2U) {
        _avl_rotate_rr(rootp, parentp);
        itemp->ai_balance = (avl_balance_t )1;
        parentp->ai_balance = (avl_balance_t )1;
        break;
      } else {
        if (! ((unsigned int )itemp->ai_balance != 1U)) {
          __assert_fail("itemp->ai_balance != CENT", "avl.h", 316U, "avl_insert_fix");
        }
        childp = itemp->ai_left;
        _avl_rotate_rl(rootp, parentp);
        itemp->ai_balance = (avl_balance_t )1;
        parentp->ai_balance = (avl_balance_t )1;
        if ((unsigned int )childp->ai_balance == 2U) {
          parentp->ai_balance = (avl_balance_t )0;
        }
        if ((unsigned int )childp->ai_balance == 0U) {
          itemp->ai_balance = (avl_balance_t )2;
        }
        childp->ai_balance = (avl_balance_t )1;
        break;
      }
    } else
    if ((unsigned int )parentp->ai_balance == 1U) {
      parentp->ai_balance = (avl_balance_t )2;
    } else {
      parentp->ai_balance = (avl_balance_t )1;
      break;
    }
    itemp = parentp;
    parentp = itemp->ai_up;
  }
  return;
}
}
static void avl_remove___0(avl_root_t *rootp , avl_item_t *itemp )
{
  avl_item_t *relocp ;
  avl_item_t *replacep ;
  avl_item_t *parentp ;

  {
  parentp = (avl_item_t *)((void *)0);
  if (! itemp->ai_indexed) {
    __assert_fail("itemp->ai_indexed", "avl.h", 376U, "avl_remove");
  }
  itemp->ai_indexed = 0;
  if ((unsigned long )itemp->ai_left == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if ((unsigned long )itemp->ai_right == (unsigned long )((void *)0)) {
    _L: /* CIL Label */
    parentp = itemp->ai_up;
    replacep = itemp->ai_left;
    if ((unsigned long )replacep == (unsigned long )((void *)0)) {
      replacep = itemp->ai_right;
    }
    if ((unsigned long )replacep != (unsigned long )((void *)0)) {
      replacep->ai_up = parentp;
    }
    if ((unsigned long )parentp == (unsigned long )((void *)0)) {
      rootp->ar_root = replacep;
    } else {
      if ((unsigned long )itemp == (unsigned long )parentp->ai_left) {
        parentp->ai_left = replacep;
      } else {
        parentp->ai_right = replacep;
      }
      avl_delete_fix___0(rootp, replacep, parentp);
    }
    return;
  }
  relocp = avl_next(itemp);
  if (! relocp) {
    __assert_fail("relocp", "avl.h", 405U, "avl_remove");
  }
  if (! ((unsigned long )relocp->ai_up != (unsigned long )((void *)0))) {
    __assert_fail("relocp->ai_up != NULL", "avl.h", 406U, "avl_remove");
  }
  if (! ((unsigned long )relocp->ai_left == (unsigned long )((void *)0))) {
    __assert_fail("relocp->ai_left == NULL", "avl.h", 407U, "avl_remove");
  }
  replacep = relocp->ai_right;
  relocp->ai_left = itemp->ai_left;
  if ((unsigned long )relocp->ai_left != (unsigned long )((void *)0)) {
    (relocp->ai_left)->ai_up = relocp;
  }
  if ((unsigned long )itemp->ai_up == (unsigned long )((void *)0)) {
    rootp->ar_root = relocp;
  } else
  if ((unsigned long )itemp == (unsigned long )(itemp->ai_up)->ai_left) {
    (itemp->ai_up)->ai_left = relocp;
  } else {
    (itemp->ai_up)->ai_right = relocp;
  }
  if ((unsigned long )relocp == (unsigned long )(relocp->ai_up)->ai_left) {
    if (! ((unsigned long )relocp->ai_up != (unsigned long )itemp)) {
      __assert_fail("relocp->ai_up != itemp", "avl.h", 421U, "avl_remove");
    }
    (relocp->ai_up)->ai_left = replacep;
    parentp = relocp->ai_up;
    if ((unsigned long )replacep != (unsigned long )((void *)0)) {
      replacep->ai_up = relocp->ai_up;
    }
    relocp->ai_right = itemp->ai_right;
  } else {
    if (! ((unsigned long )relocp->ai_up == (unsigned long )itemp)) {
      __assert_fail("relocp->ai_up == itemp", "avl.h", 428U, "avl_remove");
    }
    relocp->ai_right = replacep;
    parentp = relocp;
  }
  if ((unsigned long )relocp->ai_right != (unsigned long )((void *)0)) {
    (relocp->ai_right)->ai_up = relocp;
  }
  relocp->ai_up = itemp->ai_up;
  relocp->ai_balance = itemp->ai_balance;
  avl_delete_fix___0(rootp, replacep, parentp);
  return;
}
}
EC_KEY *vg_exec_context_new_key(void)
{
  EC_KEY *tmp ;

  {
  tmp = EC_KEY_new_by_curve_name(714);
  return (tmp);
}
}
static pthread_mutex_t vg_thread_lock  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static pthread_cond_t vg_thread_rdcond  =    {{{0ULL},
     {0ULL}, {0U, 0U}, {0U, 0U}, 0U, 0U, {0U, 0U}}};
static pthread_cond_t vg_thread_wrcond  =    {{{0ULL}, {0ULL}, {0U, 0U}, {0U, 0U}, 0U, 0U, {0U, 0U}}};
static pthread_cond_t vg_thread_upcond  =    {{{0ULL}, {0ULL}, {0U, 0U}, {0U, 0U}, 0U, 0U, {0U, 0U}}};
static void __vg_exec_context_yield(vg_exec_context_t *vxcp )
{


  {
  vxcp->vxc_lockmode = 0;
  while ((vxcp->vxc_vc)->vc_thread_excl) {
    if (vxcp->vxc_stop) {
      if (! (vxcp->vxc_vc)->vc_thread_excl) {
        __assert_fail("vxcp->vxc_vc->vc_thread_excl", "pattern.c", 64U, "__vg_exec_context_yield");
      }
      vxcp->vxc_stop = 0;
      pthread_cond_signal(& vg_thread_upcond);
    }
    pthread_cond_wait((pthread_cond_t * __restrict  )(& vg_thread_rdcond), (pthread_mutex_t * __restrict  )(& vg_thread_lock));
  }
  if (! (! vxcp->vxc_stop)) {
    __assert_fail("!vxcp->vxc_stop", "pattern.c", 70U, "__vg_exec_context_yield");
  }
  if (! (! vxcp->vxc_lockmode)) {
    __assert_fail("!vxcp->vxc_lockmode", "pattern.c", 71U, "__vg_exec_context_yield");
  }
  vxcp->vxc_lockmode = 1;
  return;
}
}
int vg_exec_context_upgrade_lock(vg_exec_context_t *vxcp )
{
  vg_exec_context_t *tp ;
  vg_context_t *vcp ;
  int tmp___5 ;

  {
  if (vxcp->vxc_lockmode == 2) {
    return (0);
  }
  pthread_mutex_lock(& vg_thread_lock);
  if (! (vxcp->vxc_lockmode == 1)) {
    __assert_fail("vxcp->vxc_lockmode == 1", "pattern.c", 86U, "vg_exec_context_upgrade_lock");
  }
  vxcp->vxc_lockmode = 0;
  vcp = vxcp->vxc_vc;
  tmp___5 = vcp->vc_thread_excl;
  (vcp->vc_thread_excl) ++;
  if (tmp___5) {
    if (! vxcp->vxc_stop) {
      __assert_fail("vxcp->vxc_stop", "pattern.c", 91U, "vg_exec_context_upgrade_lock");
    }
    vxcp->vxc_stop = 0;
    pthread_cond_signal(& vg_thread_upcond);
    pthread_cond_wait((pthread_cond_t * __restrict  )(& vg_thread_wrcond), (pthread_mutex_t * __restrict  )(& vg_thread_lock));
    tp = vcp->vc_threads;
    while ((unsigned long )tp != (unsigned long )((void *)0)) {
      if (! (! tp->vxc_lockmode)) {
        __assert_fail("!tp->vxc_lockmode", "pattern.c", 97U, "vg_exec_context_upgrade_lock");
      }
      if (! (! tp->vxc_stop)) {
        __assert_fail("!tp->vxc_stop", "pattern.c", 98U, "vg_exec_context_upgrade_lock");
      }
      tp = tp->vxc_next;
    }
  } else {
    tp = vcp->vc_threads;
    while ((unsigned long )tp != (unsigned long )((void *)0)) {
      if (tp->vxc_lockmode) {
        if (! (tp->vxc_lockmode != 2)) {
          __assert_fail("tp->vxc_lockmode != 2", "pattern.c", 104U, "vg_exec_context_upgrade_lock");
        }
        tp->vxc_stop = 1;
      }
      tp = tp->vxc_next;
    }
    while (1) {
      tp = vcp->vc_threads;
      while ((unsigned long )tp != (unsigned long )((void *)0)) {
        if (tp->vxc_lockmode) {
          if (! (tp->vxc_lockmode != 2)) {
            __assert_fail("tp->vxc_lockmode != 2", "pattern.c", 114U, "vg_exec_context_upgrade_lock");
          }
          pthread_cond_wait((pthread_cond_t * __restrict  )(& vg_thread_upcond), (pthread_mutex_t * __restrict  )(& vg_thread_lock));
          break;
        }
        tp = tp->vxc_next;
      }
      if (! tp) {
        break;
      }
    }
  }
  vxcp->vxc_lockmode = 2;
  pthread_mutex_unlock(& vg_thread_lock);
  return (1);
}
}
void vg_exec_context_downgrade_lock(vg_exec_context_t *vxcp )
{


  {
  pthread_mutex_lock(& vg_thread_lock);
  if (! (vxcp->vxc_lockmode == 2)) {
    __assert_fail("vxcp->vxc_lockmode == 2", "pattern.c", 132U, "vg_exec_context_downgrade_lock");
  }
  if (! (! vxcp->vxc_stop)) {
    __assert_fail("!vxcp->vxc_stop", "pattern.c", 133U, "vg_exec_context_downgrade_lock");
  }
  ((vxcp->vxc_vc)->vc_thread_excl) --;
  if (! (vxcp->vxc_vc)->vc_thread_excl) {
    vxcp->vxc_lockmode = 1;
    pthread_cond_broadcast(& vg_thread_rdcond);
    pthread_mutex_unlock(& vg_thread_lock);
    return;
  }
  pthread_cond_signal(& vg_thread_wrcond);
  __vg_exec_context_yield(vxcp);
  pthread_mutex_unlock(& vg_thread_lock);
  return;
}
}
int vg_exec_context_init(vg_context_t *vcp , vg_exec_context_t *vxcp )
{


  {
  pthread_mutex_lock(& vg_thread_lock);
  memset((void *)vxcp, 0, sizeof(*vxcp));
  vxcp->vxc_vc = vcp;
  BN_init(& vxcp->vxc_bntarg);
  BN_init(& vxcp->vxc_bnbase);
  BN_init(& vxcp->vxc_bntmp);
  BN_init(& vxcp->vxc_bntmp2);
  BN_set_word(& vxcp->vxc_bnbase, 58UL);
  vxcp->vxc_bnctx = BN_CTX_new();
  if (! vxcp->vxc_bnctx) {
    __assert_fail("vxcp->vxc_bnctx", "pattern.c", 162U, "vg_exec_context_init");
  }
  vxcp->vxc_key = vg_exec_context_new_key();
  if (! vxcp->vxc_key) {
    __assert_fail("vxcp->vxc_key", "pattern.c", 164U, "vg_exec_context_init");
  }
  EC_KEY_precompute_mult(vxcp->vxc_key, vxcp->vxc_bnctx);
  vxcp->vxc_lockmode = 0;
  vxcp->vxc_stop = 0;
  vxcp->vxc_next = vcp->vc_threads;
  vcp->vc_threads = vxcp;
  __vg_exec_context_yield(vxcp);
  pthread_mutex_unlock(& vg_thread_lock);
  return (1);
}
}
void vg_exec_context_del(vg_exec_context_t *vxcp )
{
  vg_exec_context_t *tp ;
  vg_exec_context_t **pprev ;

  {
  if (vxcp->vxc_lockmode == 2) {
    vg_exec_context_downgrade_lock(vxcp);
  }
  pthread_mutex_lock(& vg_thread_lock);
  if (! (vxcp->vxc_lockmode == 1)) {
    __assert_fail("vxcp->vxc_lockmode == 1", "pattern.c", 186U, "vg_exec_context_del");
  }
  vxcp->vxc_lockmode = 0;
  pprev = & (vxcp->vxc_vc)->vc_threads;
  tp = *pprev;
  while (1) {
    if ((unsigned long )tp != (unsigned long )vxcp) {
      if (! ((unsigned long )tp != (unsigned long )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    pprev = & tp->vxc_next;
    tp = *pprev;
  }
  if (! ((unsigned long )tp == (unsigned long )vxcp)) {
    __assert_fail("tp == vxcp", "pattern.c", 193U, "vg_exec_context_del");
  }
  *pprev = tp->vxc_next;
  if (tp->vxc_stop) {
    pthread_cond_signal(& vg_thread_upcond);
  }
  BN_clear_free(& vxcp->vxc_bntarg);
  BN_clear_free(& vxcp->vxc_bnbase);
  BN_clear_free(& vxcp->vxc_bntmp);
  BN_clear_free(& vxcp->vxc_bntmp2);
  BN_CTX_free(vxcp->vxc_bnctx);
  vxcp->vxc_bnctx = (BN_CTX *)((void *)0);
  pthread_mutex_unlock(& vg_thread_lock);
  return;
}
}
void vg_exec_context_yield(vg_exec_context_t *vxcp )
{


  {
  if (vxcp->vxc_lockmode == 2) {
    vg_exec_context_downgrade_lock(vxcp);
  } else
  if (vxcp->vxc_stop) {
    if (! (vxcp->vxc_lockmode == 1)) {
      __assert_fail("vxcp->vxc_lockmode == 1", "pattern.c", 215U, "vg_exec_context_yield");
    }
    pthread_mutex_lock(& vg_thread_lock);
    __vg_exec_context_yield(vxcp);
    pthread_mutex_unlock(& vg_thread_lock);
  }
  if (! (vxcp->vxc_lockmode == 1)) {
    __assert_fail("vxcp->vxc_lockmode == 1", "pattern.c", 221U, "vg_exec_context_yield");
  }
  return;
}
}
void vg_exec_context_consolidate_key(vg_exec_context_t *vxcp )
{
  BIGNUM const   *tmp ;

  {
  if (vxcp->vxc_delta) {
    BN_clear(& vxcp->vxc_bntmp);
    BN_set_word(& vxcp->vxc_bntmp, (unsigned long )vxcp->vxc_delta);
    tmp = EC_KEY_get0_private_key((EC_KEY const   *)vxcp->vxc_key);
    BN_add(& vxcp->vxc_bntmp2, tmp, (BIGNUM const   *)(& vxcp->vxc_bntmp));
    vg_set_privkey((BIGNUM const   *)(& vxcp->vxc_bntmp2), vxcp->vxc_key);
    vxcp->vxc_delta = 0;
  }
  return;
}
}
void vg_exec_context_calc_address(vg_exec_context_t *vxcp )
{
  EC_POINT *pubkey ;
  EC_GROUP const   *pgroup ;
  unsigned char eckey_buf[96] ;
  unsigned char hash1[32] ;
  unsigned char hash2[20] ;
  int len ;
  EC_POINT const   *tmp ;
  size_t tmp___0 ;

  {
  vg_exec_context_consolidate_key(vxcp);
  pgroup = EC_KEY_get0_group((EC_KEY const   *)vxcp->vxc_key);
  pubkey = EC_POINT_new(pgroup);
  tmp = EC_KEY_get0_public_key((EC_KEY const   *)vxcp->vxc_key);
  EC_POINT_copy(pubkey, tmp);
  if ((vxcp->vxc_vc)->vc_pubkey_base) {
    EC_POINT_add(pgroup, pubkey, (EC_POINT const   *)pubkey, (EC_POINT const   *)(vxcp->vxc_vc)->vc_pubkey_base,
                 vxcp->vxc_bnctx);
  }
  tmp___0 = EC_POINT_point2oct(pgroup, (EC_POINT const   *)pubkey, (point_conversion_form_t )4,
                               eckey_buf, sizeof(eckey_buf), vxcp->vxc_bnctx);
  len = (int )tmp___0;
  SHA256((unsigned char const   *)(eckey_buf), (size_t )len, hash1);
  RIPEMD160((unsigned char const   *)(hash1), sizeof(hash1), hash2);
  memcpy((void * __restrict  )(& vxcp->vxc_binres[1]), (void const   * __restrict  )(hash2),
         (size_t )20);
  EC_POINT_free(pubkey);
  return;
}
}
static pthread_mutex_t timing_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
int vg_output_timing(vg_context_t *vcp ,
                     int cycle , struct timeval *last )
{
  pthread_t me ;
  struct timeval tvnow ;
  struct timeval tv ;
  timing_info_t *tip ;
  timing_info_t *mytip ;
  unsigned long long rate ;
  unsigned long long myrate ;
  unsigned long long mytime ;
  unsigned long long total ;
  unsigned long long sincelast ;
  int p ;
  int i ;
  int tmp ;
  void *tmp___0 ;

  {
  myrate = 0ULL;
  gettimeofday((struct timeval * __restrict  )(& tvnow), (void * __restrict  )((void *)0));
  while (1) {
    tv.tv_sec = tvnow.tv_sec - last->tv_sec;
    tv.tv_usec = tvnow.tv_usec - last->tv_usec;
    if (tv.tv_usec < 0L) {
      (tv.tv_sec) --;
      tv.tv_usec += 1000000L;
    }
    break;
  }
  memcpy((void * __restrict  )last, (void const   * __restrict  )(& tvnow), sizeof(*last));
  mytime = (unsigned long long )tv.tv_usec + 1000000ULL * (unsigned long long )tv.tv_sec;
  if (! mytime) {
    mytime = 1ULL;
  }
  rate = 0ULL;
  pthread_mutex_lock(& timing_mutex);
  me = pthread_self();
  tip = vcp->vc_timing_head;
  mytip = (timing_info_t *)((void *)0);
  while ((unsigned long )tip != (unsigned long )((void *)0)) {
    tmp = pthread_equal(tip->ti_thread, me);
    if (tmp) {
      mytip = tip;
      p = (tip->ti_hist_last + 1) % 5;
      tip->ti_hist_time[p] = mytime;
      tip->ti_hist_work[p] = (unsigned long )cycle;
      tip->ti_hist_last = p;
      mytime = 0ULL;
      myrate = 0ULL;
      i = 0;
      while (i < 5) {
        mytime += tip->ti_hist_time[i];
        myrate += (unsigned long long )tip->ti_hist_work[i];
        i ++;
      }
      myrate = (myrate * 1000000ULL) / mytime;
      tip->ti_last_rate = (unsigned long )myrate;
      rate += myrate;
    } else {
      rate += (unsigned long long )tip->ti_last_rate;
    }
    tip = tip->ti_next;
  }
  if (! mytip) {
    tmp___0 = malloc(sizeof(*tip));
    mytip = (timing_info_t *)tmp___0;
    mytip->ti_next = vcp->vc_timing_head;
    mytip->ti_thread = me;
    vcp->vc_timing_head = mytip;
    mytip->ti_hist_last = 0;
    mytip->ti_hist_time[0] = mytime;
    mytip->ti_hist_work[0] = (unsigned long )cycle;
    i = 1;
    while (i < 5) {
      mytip->ti_hist_time[i] = 1ULL;
      mytip->ti_hist_work[i] = 0UL;
      i ++;
    }
    myrate = ((unsigned long long )cycle * 1000000ULL) / mytime;
    mytip->ti_last_rate = (unsigned long )myrate;
    rate += myrate;
  }
  vcp->vc_timing_total += (unsigned long long )cycle;
  if (vcp->vc_timing_prevfound != vcp->vc_found) {
    vcp->vc_timing_prevfound = vcp->vc_found;
    vcp->vc_timing_sincelast = 0ULL;
  }
  vcp->vc_timing_sincelast += (unsigned long long )cycle;
  if ((unsigned long )mytip != (unsigned long )vcp->vc_timing_head) {
    pthread_mutex_unlock(& timing_mutex);
    return ((int )myrate);
  }
  total = vcp->vc_timing_total;
  sincelast = vcp->vc_timing_sincelast;
  pthread_mutex_unlock(& timing_mutex);
  (*(vcp->vc_output_timing))(vcp, (double )sincelast, rate, total);
  return ((int )myrate);
}
}
void vg_context_thread_exit(vg_context_t *vcp )
{
  timing_info_t *tip ;
  timing_info_t **ptip ;
  pthread_t me ;
  int tmp ;

  {
  pthread_mutex_lock(& timing_mutex);
  me = pthread_self();
  ptip = & vcp->vc_timing_head;
  tip = *ptip;
  while ((unsigned long )tip != (unsigned long )((void *)0)) {
    tmp = pthread_equal(tip->ti_thread, me);
    if (! tmp) {
      goto __Cont;
    }
    *ptip = tip->ti_next;
    free((void *)tip);
    break;
    __Cont: /* CIL Label */
    ptip = & tip->ti_next;
    tip = *ptip;
  }
  pthread_mutex_unlock(& timing_mutex);
  return;
}
}
static void vg_timing_info_free(vg_context_t *vcp )
{
  timing_info_t *tp ;

  {
  while ((unsigned long )vcp->vc_timing_head != (unsigned long )((void *)0)) {
    tp = vcp->vc_timing_head;
    vcp->vc_timing_head = tp->ti_next;
    free((void *)tp);
  }
  return;
}
}
void vg_output_timing_console(vg_context_t *vcp , double count , unsigned long long rate ,
                              unsigned long long total )
{
  double prob ;
  double time___0 ;
  double targ ;
  char *unit ;
  char linebuf[80] ;
  int rem ;
  int p ;
  int i ;
  double targs[6] ;
  double tmp___0 ;
  double tmp___2 ;

  {
  targs[0] = 0.5;
  targs[1] = 0.75;
  targs[2] = 0.8;
  targs[3] = 0.9;
  targs[4] = 0.95;
  targs[5] = 1.0;
  targ = (double )rate;
  unit = (char *)"key/s";
  if (targ > (double )1000) {
    unit = (char *)"Kkey/s";
    targ /= 1000.0;
    if (targ > (double )1000) {
      unit = (char *)"Mkey/s";
      targ /= 1000.0;
    }
  }
  rem = (int )sizeof(linebuf);
  p = snprintf((char * __restrict  )(linebuf), (size_t )rem, (char const   * __restrict  )"[%.2f %s][total %lld]",
               targ, unit, total);
  if (! (p > 0)) {
    __assert_fail("p > 0", "pattern.c", 421U, "vg_output_timing_console");
  }
  rem -= p;
  if (rem < 0) {
    rem = 0;
  }
  if (vcp->vc_chance >= 1.0) {
    tmp___0 = exp(- count / vcp->vc_chance);
    prob = (double )1.0f - tmp___0;
    if (prob <= 0.999) {
      p = snprintf((char * __restrict  )(& linebuf[p]), (size_t )rem, (char const   * __restrict  )"[Prob %.1f%%]",
                   prob * (double )100);
      if (! (p > 0)) {
        __assert_fail("p > 0", "pattern.c", 432U, "vg_output_timing_console");
      }
      rem -= p;
      if (rem < 0) {
        rem = 0;
      }
      p = (int )(sizeof(linebuf) - (unsigned long )rem);
    }
    i = 0;
    while ((unsigned long )i < sizeof(targs) / sizeof(targs[0])) {
      targ = targs[i];
      if (targ < 1.0) {
        if (prob <= targ) {
          break;
        }
      }
      i ++;
    }
    if (targ < 1.0) {
      tmp___2 = log(1.0 - targ);
      time___0 = (- vcp->vc_chance * tmp___2 - count) / (double )rate;
      unit = (char *)"s";
      if (time___0 > (double )60) {
        time___0 /= (double )60;
        unit = (char *)"min";
        if (time___0 > (double )60) {
          time___0 /= (double )60;
          unit = (char *)"h";
          if (time___0 > (double )24) {
            time___0 /= (double )24;
            unit = (char *)"d";
            if (time___0 > (double )365) {
              time___0 /= (double )365;
              unit = (char *)"y";
            }
          }
        }
      }
      if (time___0 > (double )1000000) {
        p = snprintf((char * __restrict  )(& linebuf[p]), (size_t )rem, (char const   * __restrict  )"[%d%% in %e%s]",
                     (int )((double )100 * targ), time___0, unit);
      } else {
        p = snprintf((char * __restrict  )(& linebuf[p]), (size_t )rem, (char const   * __restrict  )"[%d%% in %.1f%s]",
                     (int )((double )100 * targ), time___0, unit);
      }
      if (! (p > 0)) {
        __assert_fail("p > 0", "pattern.c", 475U, "vg_output_timing_console");
      }
      rem -= p;
      if (rem < 0) {
        rem = 0;
      }
      p = (int )(sizeof(linebuf) - (unsigned long )rem);
    }
  }
  if (vcp->vc_found) {
    if (vcp->vc_remove_on_match) {
      p = snprintf((char * __restrict  )(& linebuf[p]), (size_t )rem, (char const   * __restrict  )"[Found %lld/%ld]",
                   vcp->vc_found, vcp->vc_npatterns_start);
    } else {
      p = snprintf((char * __restrict  )(& linebuf[p]), (size_t )rem, (char const   * __restrict  )"[Found %lld]",
                   vcp->vc_found);
    }
    if (! (p > 0)) {
      __assert_fail("p > 0", "pattern.c", 490U, "vg_output_timing_console");
    }
    rem -= p;
    if (rem < 0) {
      rem = 0;
    }
  }
  if (rem) {
    memset((void *)(& linebuf[sizeof(linebuf) - (unsigned long )rem]), 32, (size_t )rem);
    linebuf[sizeof(linebuf) - 1UL] = (char )'\000';
  }
  printf((char const   * __restrict  )"\r%s", linebuf);
  fflush(stdout);
  return;
}
}
void vg_output_match_console(vg_context_t *vcp , EC_KEY *pkey , char const   *pattern )
{
  unsigned char key_buf[512] ;
  unsigned char *pend ;
  char addr_buf[64] ;
  char addr2_buf[64] ;
  char privkey_buf[128] ;
  char const   *keytype ;
  int len ;
  int isscript ;
  EC_POINT *ppnt ;
  int free_ppnt ;
  EC_GROUP const   *tmp ;
  EC_POINT const   *tmp___0 ;
  EC_GROUP const   *tmp___1 ;
  EC_POINT const   *tmp___2 ;
  int tmp___6 ;
  EC_GROUP const   *tmp___7 ;
  EC_GROUP const   *tmp___8 ;
  BIGNUM const   *tmp___9 ;
  FILE *fp ;
  FILE *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;

  {
  keytype = "Privkey";
  isscript = (unsigned int )vcp->vc_format == 1U;
  free_ppnt = 0;
  if (vcp->vc_pubkey_base) {
    tmp = EC_KEY_get0_group((EC_KEY const   *)pkey);
    ppnt = EC_POINT_new(tmp);
    tmp___0 = EC_KEY_get0_public_key((EC_KEY const   *)pkey);
    EC_POINT_copy(ppnt, tmp___0);
    tmp___1 = EC_KEY_get0_group((EC_KEY const   *)pkey);
    EC_POINT_add(tmp___1, ppnt, (EC_POINT const   *)ppnt, (EC_POINT const   *)vcp->vc_pubkey_base,
                 (BN_CTX *)((void *)0));
    free_ppnt = 1;
    keytype = "PrivkeyPart";
  } else {
    tmp___2 = EC_KEY_get0_public_key((EC_KEY const   *)pkey);
    ppnt = (EC_POINT *)tmp___2;
  }
  tmp___6 = EC_KEY_check_key((EC_KEY const   *)pkey);
  if (! tmp___6) {
    __assert_fail("EC_KEY_check_key(pkey)", "pattern.c", 530U, "vg_output_match_console");
  }
  tmp___7 = EC_KEY_get0_group((EC_KEY const   *)pkey);
  vg_encode_address((EC_POINT const   *)ppnt, tmp___7, vcp->vc_pubkeytype, addr_buf);
  if (isscript) {
    tmp___8 = EC_KEY_get0_group((EC_KEY const   *)pkey);
    vg_encode_script_address((EC_POINT const   *)ppnt, tmp___8, vcp->vc_addrtype,
                             addr2_buf);
  }
  if (vcp->vc_key_protect_pass) {
    len = vg_protect_encode_privkey(privkey_buf, (EC_KEY const   *)pkey, vcp->vc_privtype,
                                    -1, vcp->vc_key_protect_pass);
    if (len) {
      keytype = "Protkey";
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: could not password-protect key\n");
      vcp->vc_key_protect_pass = (char const   *)((void *)0);
    }
  }
  if (! vcp->vc_key_protect_pass) {
    vg_encode_privkey((EC_KEY const   *)pkey, vcp->vc_privtype, privkey_buf);
  }
  if (! vcp->vc_result_file) {
    printf((char const   * __restrict  )"\r%79s\rPattern: %s\n", "", pattern);
  } else
  if (vcp->vc_verbose > 0) {
    printf((char const   * __restrict  )"\r%79s\rPattern: %s\n", "", pattern);
  }
  if (vcp->vc_verbose > 0) {
    if (vcp->vc_verbose > 1) {
      pend = key_buf;
      len = i2o_ECPublicKey(pkey, & pend);
      printf((char const   * __restrict  )"Pubkey (hex): ");
      dumphex((unsigned char const   *)(key_buf), (size_t )len);
      printf((char const   * __restrict  )"Privkey (hex): ");
      tmp___9 = EC_KEY_get0_private_key((EC_KEY const   *)pkey);
      dumpbn(tmp___9);
      pend = key_buf;
      len = i2d_ECPrivateKey(pkey, & pend);
      printf((char const   * __restrict  )"Privkey (ASN1): ");
      dumphex((unsigned char const   *)(key_buf), (size_t )len);
    }
  }
  if (! vcp->vc_result_file) {
    goto _L;
  } else
  if (vcp->vc_verbose > 0) {
    _L: /* CIL Label */
    if (isscript) {
      printf((char const   * __restrict  )"P2SHAddress: %s\n", addr2_buf);
    }
    printf((char const   * __restrict  )"Address: %s\n%s: %s\n", addr_buf, keytype,
           privkey_buf);
  }
  if (vcp->vc_result_file) {
    tmp___10 = fopen((char const   * __restrict  )vcp->vc_result_file, (char const   * __restrict  )"a");
    fp = tmp___10;
    if (! fp) {
      tmp___11 = __errno_location();
      tmp___12 = strerror(*tmp___11);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: could not open result file: %s\n",
              tmp___12);
    } else {
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Pattern: %s\n",
              pattern);
      if (isscript) {
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"P2SHAddress: %s\n",
                addr2_buf);
      }
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Address: %s\n%s: %s\n",
              addr_buf, keytype, privkey_buf);
      fclose(fp);
    }
  }
  if (free_ppnt) {
    EC_POINT_free(ppnt);
  }
  return;
}
}
void vg_context_free(vg_context_t *vcp )
{


  {
  vg_timing_info_free(vcp);
  (*(vcp->vc_free))(vcp);
  return;
}
}
int vg_context_add_patterns(vg_context_t *vcp , char const   ** const  patterns ,
                            int npatterns )
{
  int tmp ;

  {
  (vcp->vc_pattern_generation) ++;
  tmp = (*(vcp->vc_add_patterns))(vcp, patterns, npatterns);
  return (tmp);
}
}
void vg_context_clear_all_patterns(vg_context_t *vcp )
{


  {
  (*(vcp->vc_clear_all_patterns))(vcp);
  (vcp->vc_pattern_generation) ++;
  return;
}
}
int vg_context_hash160_sort(vg_context_t *vcp , void *buf )
{
  int tmp ;

  {
  if (! vcp->vc_hash160_sort) {
    return (0);
  }
  tmp = (*(vcp->vc_hash160_sort))(vcp, buf);
  return (tmp);
}
}
int vg_context_start_threads(vg_context_t *vcp )
{
  vg_exec_context_t *vxcp ;
  int res ;

  {
  vxcp = vcp->vc_threads;
  while ((unsigned long )vxcp != (unsigned long )((void *)0)) {
    res = pthread_create((pthread_t * __restrict  )(& vxcp->vxc_pthread), (pthread_attr_t const   * __restrict  )((void *)0),
                         (void *(*)(void * ))vxcp->vxc_threadfunc, (void * __restrict  )vxcp);
    if (res) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: could not create thread: %d\n",
              res);
      vg_context_stop_threads(vcp);
      return (-1);
    }
    vxcp->vxc_thread_active = 1;
    vxcp = vxcp->vxc_next;
  }
  return (0);
}
}
void vg_context_stop_threads(vg_context_t *vcp )
{


  {
  vcp->vc_halt = 1;
  vg_context_wait_for_completion(vcp);
  vcp->vc_halt = 0;
  return;
}
}
void vg_context_wait_for_completion(vg_context_t *vcp )
{
  vg_exec_context_t *vxcp ;

  {
  vxcp = vcp->vc_threads;
  while ((unsigned long )vxcp != (unsigned long )((void *)0)) {
    if (! vxcp->vxc_thread_active) {
      goto __Cont;
    }
    pthread_join(vxcp->vxc_pthread, (void **)((void *)0));
    vxcp->vxc_thread_active = 0;
    __Cont: /* CIL Label */
    vxcp = vxcp->vxc_next;
  }
  return;
}
}
static int get_prefix_ranges(int addrtype , char const   *pfx , BIGNUM **result ,
                             BN_CTX *bnctx )
{
  int i ;
  int p ;
  int c ;
  int zero_prefix ;
  int check_upper ;
  int b58pow ;
  int b58ceil ;
  int b58top ;
  int ret ;
  BIGNUM bntarg ;
  BIGNUM bnceil ;
  BIGNUM bnfloor ;
  BIGNUM bnbase ;
  BIGNUM *bnap ;
  BIGNUM *bnbp ;
  BIGNUM *bntp ;
  BIGNUM *bnhigh ;
  BIGNUM *bnlow ;
  BIGNUM *bnhigh2 ;
  BIGNUM *bnlow2 ;
  BIGNUM bntmp ;
  BIGNUM bntmp2 ;
  size_t tmp ;
  BIGNUM const   *tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  BIGNUM const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  zero_prefix = 0;
  check_upper = 0;
  b58top = 0;
  ret = -1;
  bnhigh = (BIGNUM *)((void *)0);
  bnlow = (BIGNUM *)((void *)0);
  bnhigh2 = (BIGNUM *)((void *)0);
  bnlow2 = (BIGNUM *)((void *)0);
  BN_init(& bntarg);
  BN_init(& bnceil);
  BN_init(& bnfloor);
  BN_init(& bnbase);
  BN_init(& bntmp);
  BN_init(& bntmp2);
  BN_set_word(& bnbase, 58UL);
  tmp = strlen(pfx);
  p = (int )tmp;
  i = 0;
  while (i < p) {
    c = (int )vg_b58_reverse_map[(int )*(pfx + i)];
    if (c == -1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid character \'%c\' in prefix \'%s\'\n",
              (int const   )*(pfx + i), pfx);
      goto out;
    }
    if (i == zero_prefix) {
      if (c == 0) {
        zero_prefix ++;
        if (zero_prefix > 19) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Prefix \'%s\' is too long\n",
                  pfx);
          goto out;
        }
        goto __Cont;
      }
      b58top = c;
      BN_set_word(& bntarg, (unsigned long )c);
    } else {
      BN_set_word(& bntmp2, (unsigned long )c);
      BN_mul(& bntmp, (BIGNUM const   *)(& bntarg), (BIGNUM const   *)(& bnbase),
             bnctx);
      BN_add(& bntarg, (BIGNUM const   *)(& bntmp), (BIGNUM const   *)(& bntmp2));
    }
    __Cont: /* CIL Label */
    i ++;
  }
  BN_clear(& bntmp);
  BN_set_bit(& bntmp, 200 - zero_prefix * 8);
  tmp___0 = BN_value_one();
  BN_sub(& bnceil, (BIGNUM const   *)(& bntmp), tmp___0);
  BN_set_bit(& bnfloor, 192 - zero_prefix * 8);
  bnlow = BN_new();
  bnhigh = BN_new();
  if (b58top) {
    BN_copy(& bntmp, (BIGNUM const   *)(& bnceil));
    bnap = & bntmp;
    bnbp = & bntmp2;
    b58pow = 0;
    while (1) {
      tmp___1 = BN_cmp((BIGNUM const   *)bnap, (BIGNUM const   *)(& bnbase));
      if (! (tmp___1 > 0)) {
        break;
      }
      b58pow ++;
      BN_div(bnbp, (BIGNUM *)((void *)0), (BIGNUM const   *)bnap, (BIGNUM const   *)(& bnbase),
             bnctx);
      bntp = bnap;
      bnap = bnbp;
      bnbp = bntp;
    }
    tmp___2 = BN_get_word((BIGNUM const   *)bnap);
    b58ceil = (int )tmp___2;
    if (b58pow - (p - zero_prefix) < 6) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Prefix \'%s\' is too long\n",
              pfx);
      goto out;
    }
    BN_set_word(& bntmp2, (unsigned long )(b58pow - (p - zero_prefix)));
    BN_exp(& bntmp, (BIGNUM const   *)(& bnbase), (BIGNUM const   *)(& bntmp2), bnctx);
    BN_mul(bnlow, (BIGNUM const   *)(& bntmp), (BIGNUM const   *)(& bntarg), bnctx);
    tmp___3 = BN_value_one();
    BN_sub(& bntmp2, (BIGNUM const   *)(& bntmp), tmp___3);
    BN_add(bnhigh, (BIGNUM const   *)bnlow, (BIGNUM const   *)(& bntmp2));
    if (b58top <= b58ceil) {
      check_upper = 1;
      bnlow2 = BN_new();
      bnhigh2 = BN_new();
      BN_mul(bnlow2, (BIGNUM const   *)bnlow, (BIGNUM const   *)(& bnbase), bnctx);
      BN_mul(& bntmp2, (BIGNUM const   *)bnhigh, (BIGNUM const   *)(& bnbase), bnctx);
      BN_set_word(& bntmp, 57UL);
      BN_add(bnhigh2, (BIGNUM const   *)(& bntmp2), (BIGNUM const   *)(& bntmp));
      tmp___5 = BN_cmp((BIGNUM const   *)(& bnceil), (BIGNUM const   *)bnlow2);
      if (tmp___5 < 0) {
        check_upper = 0;
        BN_free(bnhigh2);
        bnhigh2 = (BIGNUM *)((void *)0);
        BN_free(bnlow2);
        bnlow2 = (BIGNUM *)((void *)0);
      } else {
        tmp___4 = BN_cmp((BIGNUM const   *)(& bnceil), (BIGNUM const   *)bnhigh2);
        if (tmp___4 < 0) {
          BN_copy(bnhigh2, (BIGNUM const   *)(& bnceil));
        }
      }
      tmp___8 = BN_cmp((BIGNUM const   *)(& bnfloor), (BIGNUM const   *)bnhigh);
      if (tmp___8 >= 0) {
        if (! check_upper) {
          __assert_fail("check_upper", "pattern.c", 820U, "get_prefix_ranges");
        }
        check_upper = 0;
        BN_free(bnhigh);
        bnhigh = bnhigh2;
        bnhigh2 = (BIGNUM *)((void *)0);
        BN_free(bnlow);
        bnlow = bnlow2;
        bnlow2 = (BIGNUM *)((void *)0);
      } else {
        tmp___7 = BN_cmp((BIGNUM const   *)(& bnfloor), (BIGNUM const   *)bnlow);
        if (tmp___7 > 0) {
          BN_copy(bnlow, (BIGNUM const   *)(& bnfloor));
        }
      }
    }
  } else {
    BN_copy(bnhigh, (BIGNUM const   *)(& bnceil));
    BN_clear(bnlow);
  }
  BN_clear(& bntmp);
  BN_set_word(& bntmp, (unsigned long )addrtype);
  BN_lshift(& bntmp2, (BIGNUM const   *)(& bntmp), 192);
  if (check_upper) {
    tmp___10 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnhigh2);
    if (tmp___10 > 0) {
      check_upper = 0;
      BN_free(bnhigh2);
      bnhigh2 = (BIGNUM *)((void *)0);
      BN_free(bnlow2);
      bnlow2 = (BIGNUM *)((void *)0);
    } else {
      tmp___9 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnlow2);
      if (tmp___9 > 0) {
        BN_copy(bnlow2, (BIGNUM const   *)(& bntmp2));
      }
    }
  }
  tmp___12 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnhigh);
  if (tmp___12 > 0) {
    if (! check_upper) {
      goto not_possible;
    }
    check_upper = 0;
    BN_free(bnhigh);
    bnhigh = bnhigh2;
    bnhigh2 = (BIGNUM *)((void *)0);
    BN_free(bnlow);
    bnlow = bnlow2;
    bnlow2 = (BIGNUM *)((void *)0);
  } else {
    tmp___11 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnlow);
    if (tmp___11 > 0) {
      BN_copy(bnlow, (BIGNUM const   *)(& bntmp2));
    }
  }
  BN_set_word(& bntmp, (unsigned long )(addrtype + 1));
  BN_lshift(& bntmp2, (BIGNUM const   *)(& bntmp), 192);
  if (check_upper) {
    tmp___14 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnlow2);
    if (tmp___14 < 0) {
      check_upper = 0;
      BN_free(bnhigh2);
      bnhigh2 = (BIGNUM *)((void *)0);
      BN_free(bnlow2);
      bnlow2 = (BIGNUM *)((void *)0);
    } else {
      tmp___13 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnhigh2);
      if (tmp___13 < 0) {
        BN_copy(bnlow2, (BIGNUM const   *)(& bntmp2));
      }
    }
  }
  tmp___16 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnlow);
  if (tmp___16 < 0) {
    if (! check_upper) {
      goto not_possible;
    }
    check_upper = 0;
    BN_free(bnhigh);
    bnhigh = bnhigh2;
    bnhigh2 = (BIGNUM *)((void *)0);
    BN_free(bnlow);
    bnlow = bnlow2;
    bnlow2 = (BIGNUM *)((void *)0);
  } else {
    tmp___15 = BN_cmp((BIGNUM const   *)(& bntmp2), (BIGNUM const   *)bnhigh);
    if (tmp___15 < 0) {
      BN_copy(bnhigh, (BIGNUM const   *)(& bntmp2));
    }
  }
  if (! check_upper) {
    if ((unsigned long )bnlow2 == (unsigned long )((void *)0)) {
      if (! ((unsigned long )bnhigh2 == (unsigned long )((void *)0))) {
        __assert_fail("check_upper || ((bnlow2 == NULL) && (bnhigh2 == NULL))", "pattern.c",
                      903U, "get_prefix_ranges");
      }
    } else {
      __assert_fail("check_upper || ((bnlow2 == NULL) && (bnhigh2 == NULL))", "pattern.c",
                    903U, "get_prefix_ranges");
    }
  }
  *(result + 0) = bnlow;
  *(result + 1) = bnhigh;
  *(result + 2) = bnlow2;
  *(result + 3) = bnhigh2;
  bnlow = (BIGNUM *)((void *)0);
  bnhigh = (BIGNUM *)((void *)0);
  bnlow2 = (BIGNUM *)((void *)0);
  bnhigh2 = (BIGNUM *)((void *)0);
  ret = 0;
  if (0) {
    not_possible:
    ret = -2;
  }
  out:
  BN_clear_free(& bntarg);
  BN_clear_free(& bnceil);
  BN_clear_free(& bnfloor);
  BN_clear_free(& bnbase);
  BN_clear_free(& bntmp);
  BN_clear_free(& bntmp2);
  if (bnhigh) {
    BN_free(bnhigh);
  }
  if (bnlow) {
    BN_free(bnlow);
  }
  if (bnhigh2) {
    BN_free(bnhigh2);
  }
  if (bnlow2) {
    BN_free(bnlow2);
  }
  return (ret);
}
}
static void free_ranges(BIGNUM **ranges )
{


  {
  BN_free(*(ranges + 0));
  BN_free(*(ranges + 1));
  *(ranges + 0) = (BIGNUM *)((void *)0);
  *(ranges + 1) = (BIGNUM *)((void *)0);
  if (*(ranges + 2)) {
    BN_free(*(ranges + 2));
    BN_free(*(ranges + 3));
    *(ranges + 2) = (BIGNUM *)((void *)0);
    *(ranges + 3) = (BIGNUM *)((void *)0);
  }
  return;
}
}
int const   vpk_nwords  =    (int const   )(((25UL + sizeof(unsigned long )) - 1UL) / sizeof(unsigned long ));
static void vg_prefix_free(vg_prefix_t *vp )
{


  {
  if (vp->vp_low) {
    BN_free(vp->vp_low);
  }
  if (vp->vp_high) {
    BN_free(vp->vp_high);
  }
  free((void *)vp);
  return;
}
}
static vg_prefix_t *vg_prefix_avl_search(avl_root_t *rootp , BIGNUM *targ )
{
  vg_prefix_t *vp ;
  avl_item_t *itemp ;
  int tmp ;
  int tmp___0 ;

  {
  itemp = rootp->ar_root;
  while (itemp) {
    vp = (vg_prefix_t *)((unsigned char *)itemp - (size_t )(& ((vg_prefix_t *)((unsigned char *)0))->vp_item));
    tmp___0 = BN_cmp((BIGNUM const   *)vp->vp_low, (BIGNUM const   *)targ);
    if (tmp___0 > 0) {
      itemp = itemp->ai_left;
    } else {
      tmp = BN_cmp((BIGNUM const   *)vp->vp_high, (BIGNUM const   *)targ);
      if (tmp < 0) {
        itemp = itemp->ai_right;
      } else {
        return (vp);
      }
    }
  }
  return ((vg_prefix_t *)((void *)0));
}
}
static vg_prefix_t *vg_prefix_avl_insert(avl_root_t *rootp , vg_prefix_t *vpnew )
{
  vg_prefix_t *vp ;
  avl_item_t *itemp ;
  avl_item_t **ptrp ;
  int tmp ;
  int tmp___0 ;

  {
  itemp = (avl_item_t *)((void *)0);
  ptrp = & rootp->ar_root;
  while (*ptrp) {
    itemp = *ptrp;
    vp = (vg_prefix_t *)((unsigned char *)itemp - (size_t )(& ((vg_prefix_t *)((unsigned char *)0))->vp_item));
    tmp___0 = BN_cmp((BIGNUM const   *)vp->vp_low, (BIGNUM const   *)vpnew->vp_high);
    if (tmp___0 > 0) {
      ptrp = & itemp->ai_left;
    } else {
      tmp = BN_cmp((BIGNUM const   *)vp->vp_high, (BIGNUM const   *)vpnew->vp_low);
      if (tmp < 0) {
        ptrp = & itemp->ai_right;
      } else {
        return (vp);
      }
    }
  }
  vpnew->vp_item.ai_up = itemp;
  itemp = & vpnew->vp_item;
  *ptrp = itemp;
  avl_insert_fix___0(rootp, itemp);
  return ((vg_prefix_t *)((void *)0));
}
}
static vg_prefix_t *vg_prefix_first(avl_root_t *rootp )
{
  avl_item_t *itemp ;

  {
  itemp = avl_first(rootp);
  if (itemp) {
    return ((vg_prefix_t *)((unsigned char *)itemp - (size_t )(& ((vg_prefix_t *)((unsigned char *)0))->vp_item)));
  }
  return ((vg_prefix_t *)((void *)0));
}
}
static vg_prefix_t *vg_prefix_next(vg_prefix_t *vp )
{
  avl_item_t *itemp ;

  {
  itemp = & vp->vp_item;
  itemp = avl_next(itemp);
  if (itemp) {
    return ((vg_prefix_t *)((unsigned char *)itemp - (size_t )(& ((vg_prefix_t *)((unsigned char *)0))->vp_item)));
  }
  return ((vg_prefix_t *)((void *)0));
}
}
static vg_prefix_t *vg_prefix_add(avl_root_t *rootp , char const   *pattern , BIGNUM *low ,
                                  BIGNUM *high )
{
  vg_prefix_t *vp ;
  vg_prefix_t *vp2 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  tmp___2 = BN_cmp((BIGNUM const   *)low, (BIGNUM const   *)high);
  if (! (tmp___2 < 0)) {
    __assert_fail("BN_cmp(low, high) < 0", "pattern.c", 1047U, "vg_prefix_add");
  }
  tmp___3 = malloc(sizeof(*vp));
  vp = (vg_prefix_t *)tmp___3;
  if (vp) {
    avl_item_init(& vp->vp_item);
    vp->vp_sibling = (struct _vg_prefix_s *)((void *)0);
    vp->vp_pattern = pattern;
    vp->vp_low = low;
    vp->vp_high = high;
    vp2 = vg_prefix_avl_insert(rootp, vp);
    if ((unsigned long )vp2 != (unsigned long )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Prefix \'%s\' ignored, overlaps \'%s\'\n",
              pattern, vp2->vp_pattern);
      vg_prefix_free(vp);
      vp = (vg_prefix_t *)((void *)0);
    }
  }
  return (vp);
}
}
static void vg_prefix_delete(avl_root_t *rootp , vg_prefix_t *vp )
{
  vg_prefix_t *sibp ;
  vg_prefix_t *delp ;

  {
  avl_remove___0(rootp, & vp->vp_item);
  sibp = vp->vp_sibling;
  while (1) {
    if (sibp) {
      if (! ((unsigned long )sibp != (unsigned long )vp)) {
        break;
      }
    } else {
      break;
    }
    avl_remove___0(rootp, & sibp->vp_item);
    delp = sibp;
    sibp = sibp->vp_sibling;
    vg_prefix_free(delp);
  }
  vg_prefix_free(vp);
  return;
}
}
static vg_prefix_t *vg_prefix_add_ranges(avl_root_t *rootp , char const   *pattern ,
                                         BIGNUM **ranges , vg_prefix_t *master )
{
  vg_prefix_t *vp ;
  vg_prefix_t *vp2 ;

  {
  vp2 = (vg_prefix_t *)((void *)0);
  if (! *(ranges + 0)) {
    __assert_fail("ranges[0]", "pattern.c", 1089U, "vg_prefix_add_ranges");
  }
  vp = vg_prefix_add(rootp, pattern, *(ranges + 0), *(ranges + 1));
  if (! vp) {
    return ((vg_prefix_t *)((void *)0));
  }
  if (*(ranges + 2)) {
    vp2 = vg_prefix_add(rootp, pattern, *(ranges + 2), *(ranges + 3));
    if (! vp2) {
      vg_prefix_delete(rootp, vp);
      return ((vg_prefix_t *)((void *)0));
    }
  }
  if (! master) {
    vp->vp_sibling = vp2;
    if (vp2) {
      vp2->vp_sibling = vp;
    }
  } else
  if (vp2) {
    vp->vp_sibling = vp2;
    if (master->vp_sibling) {
      vp2->vp_sibling = master->vp_sibling;
    } else {
      vp2->vp_sibling = master;
    }
    master->vp_sibling = vp;
  } else {
    if (master->vp_sibling) {
      vp->vp_sibling = master->vp_sibling;
    } else {
      vp->vp_sibling = master;
    }
    master->vp_sibling = vp;
  }
  return (vp);
}
}
static void vg_prefix_range_sum(vg_prefix_t *vp , BIGNUM *result , BIGNUM *tmp1 )
{
  vg_prefix_t *startp ;

  {
  startp = vp;
  BN_clear(result);
  while (1) {
    BN_sub(tmp1, (BIGNUM const   *)vp->vp_high, (BIGNUM const   *)vp->vp_low);
    BN_add(result, (BIGNUM const   *)result, (BIGNUM const   *)tmp1);
    vp = vp->vp_sibling;
    if (vp) {
      if (! ((unsigned long )vp != (unsigned long )startp)) {
        break;
      }
    } else {
      break;
    }
  }
  return;
}
}
static unsigned char const   b58_case_map[256]  =
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )1,
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2,
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )0,
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )0,
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
static int prefix_case_iter_init(prefix_case_iter_t *cip , char const   *pfx )
{
  int i ;

  {
  cip->ci_nbits = (char)0;
  cip->ci_value = 0;
  i = 0;
  while (*(pfx + i)) {
    if ((unsigned long )i > sizeof(cip->ci_prefix)) {
      return (0);
    }
    if (! b58_case_map[(int )*(pfx + i)]) {
      cip->ci_prefix[i] = (char )*(pfx + i);
      goto __Cont;
    }
    if ((int const   )b58_case_map[(int )*(pfx + i)] == 2) {
      cip->ci_prefix[i] = (char )((int const   )*(pfx + i) ^ 32);
      goto __Cont;
    }
    cip->ci_prefix[i] = (char )((int const   )*(pfx + i) | 32);
    cip->ci_case_map[(int )cip->ci_nbits] = (char )i;
    cip->ci_nbits = (char )((int )cip->ci_nbits + 1);
    __Cont: /* CIL Label */
    i ++;
  }
  cip->ci_prefix[i] = (char )'\000';
  return (1);
}
}
static int prefix_case_iter_next(prefix_case_iter_t *cip )
{
  unsigned long val ;
  unsigned long max ;
  unsigned long mask ;
  int i ;
  int nbits ;

  {
  nbits = (int )cip->ci_nbits;
  max = (1UL << nbits) - 1UL;
  val = (unsigned long )(cip->ci_value + 1);
  if (val > max) {
    return (0);
  }
  i = 0;
  mask = 1UL;
  while (i < nbits) {
    if (val & mask) {
      cip->ci_prefix[(int )cip->ci_case_map[i]] = (char )((int )cip->ci_prefix[(int )cip->ci_case_map[i]] & 223);
    } else {
      cip->ci_prefix[(int )cip->ci_case_map[i]] = (char )((int )cip->ci_prefix[(int )cip->ci_case_map[i]] | 32);
    }
    i ++;
    mask <<= 1;
  }
  cip->ci_value = (int )val;
  return (1);
}
}
void vg_prefix_context_set_case_insensitive(vg_context_t *vcp , int caseinsensitive )
{


  {
  ((vg_prefix_context_t *)vcp)->vcp_caseinsensitive = caseinsensitive;
  return;
}
}
static void vg_prefix_context_clear_all_patterns(vg_context_t *vcp )
{
  vg_prefix_context_t *vcpp ;
  vg_prefix_t *vp ;
  unsigned long npfx_left ;
  int tmp ;

  {
  vcpp = (vg_prefix_context_t *)vcp;
  npfx_left = 0UL;
  while (1) {
    tmp = avl_root_empty(& vcpp->vcp_avlroot);
    if (tmp) {
      break;
    }
    vp = (vg_prefix_t *)((unsigned char *)vcpp->vcp_avlroot.ar_root - (size_t )(& ((vg_prefix_t *)((unsigned char *)0))->vp_item));
    vg_prefix_delete(& vcpp->vcp_avlroot, vp);
    npfx_left ++;
  }
  if (! (npfx_left == vcpp->base.vc_npatterns)) {
    __assert_fail("npfx_left == vcpp->base.vc_npatterns", "pattern.c", 1233U, "vg_prefix_context_clear_all_patterns");
  }
  vcpp->base.vc_npatterns = 0UL;
  vcpp->base.vc_npatterns_start = 0UL;
  vcpp->base.vc_found = 0ULL;
  BN_clear(& vcpp->vcp_difficulty);
  return;
}
}
static void vg_prefix_context_free(vg_context_t *vcp )
{
  vg_prefix_context_t *vcpp ;

  {
  vcpp = (vg_prefix_context_t *)vcp;
  vg_prefix_context_clear_all_patterns(vcp);
  BN_clear_free(& vcpp->vcp_difficulty);
  free((void *)vcpp);
  return;
}
}
static void vg_prefix_context_next_difficulty(vg_prefix_context_t *vcpp , BIGNUM *bntmp ,
                                              BIGNUM *bntmp2 , BN_CTX *bnctx )
{
  char *dbuf ;

  {
  BN_clear(bntmp);
  BN_set_bit(bntmp, 192);
  BN_div(bntmp2, (BIGNUM *)((void *)0), (BIGNUM const   *)bntmp, (BIGNUM const   *)(& vcpp->vcp_difficulty),
         bnctx);
  dbuf = BN_bn2dec((BIGNUM const   *)bntmp2);
  if (vcpp->base.vc_verbose > 0) {
    if (vcpp->base.vc_npatterns > 1UL) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Next match difficulty: %s (%ld prefixes)\n",
              dbuf, vcpp->base.vc_npatterns);
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Difficulty: %s\n",
              dbuf);
    }
  }
  vcpp->base.vc_chance = atof((char const   *)dbuf);
  CRYPTO_free((void *)dbuf);
  return;
}
}
static int vg_prefix_context_add_patterns(vg_context_t *vcp , char const   ** const  patterns ,
                                          int npatterns )
{
  vg_prefix_context_t *vcpp ;
  prefix_case_iter_t caseiter ;
  vg_prefix_t *vp ;
  vg_prefix_t *vp2 ;
  BN_CTX *bnctx ;
  BIGNUM bntmp ;
  BIGNUM bntmp2 ;
  BIGNUM bntmp3 ;
  BIGNUM *ranges[4] ;
  int ret ;
  int i ;
  int impossible ;
  int case_impossible ;
  unsigned long npfx ;
  char *dbuf ;
  int tmp ;
  int tmp___0 ;
  char const   *ats ;
  char const   *bw ;

  {
  vcpp = (vg_prefix_context_t *)vcp;
  ret = 0;
  impossible = 0;
  bnctx = BN_CTX_new();
  BN_init(& bntmp);
  BN_init(& bntmp2);
  BN_init(& bntmp3);
  npfx = 0UL;
  i = 0;
  while (i < npatterns) {
    if (! vcpp->vcp_caseinsensitive) {
      vp = (vg_prefix_t *)((void *)0);
      ret = get_prefix_ranges(vcpp->base.vc_addrtype, *(patterns + i), ranges, bnctx);
      if (! ret) {
        vp = vg_prefix_add_ranges(& vcpp->vcp_avlroot, *(patterns + i), ranges, (vg_prefix_t *)((void *)0));
      }
    } else {
      tmp = prefix_case_iter_init(& caseiter, *(patterns + i));
      if (! tmp) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Prefix \'%s\' is too long\n",
                *(patterns + i));
        goto __Cont;
      }
      if ((int )caseiter.ci_nbits > 16) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Prefix \'%s\' has 2^%d case-varied derivatives\n",
                *(patterns + i), (int )caseiter.ci_nbits);
      }
      case_impossible = 0;
      vp = (vg_prefix_t *)((void *)0);
      while (1) {
        ret = get_prefix_ranges(vcpp->base.vc_addrtype, (char const   *)(caseiter.ci_prefix),
                                ranges, bnctx);
        if (ret == -2) {
          case_impossible ++;
          ret = 0;
          goto __Cont___0;
        }
        if (ret) {
          break;
        }
        vp2 = vg_prefix_add_ranges(& vcpp->vcp_avlroot, *(patterns + i), ranges, vp);
        if (! vp2) {
          ret = -1;
          break;
        }
        if (! vp) {
          vp = vp2;
        }
        __Cont___0: /* CIL Label */
        tmp___0 = prefix_case_iter_next(& caseiter);
        if (! tmp___0) {
          break;
        }
      }
      if (! vp) {
        if (case_impossible) {
          ret = -2;
        }
      }
      if (ret) {
        if (vp) {
          vg_prefix_delete(& vcpp->vcp_avlroot, vp);
          vp = (vg_prefix_t *)((void *)0);
        }
      }
    }
    if (ret == -2) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Prefix \'%s\' not possible\n",
              *(patterns + i));
      impossible ++;
    }
    if (! vp) {
      goto __Cont;
    }
    npfx ++;
    vg_prefix_range_sum(vp, & bntmp, & bntmp2);
    BN_add(& bntmp2, (BIGNUM const   *)(& vcpp->vcp_difficulty), (BIGNUM const   *)(& bntmp));
    BN_copy(& vcpp->vcp_difficulty, (BIGNUM const   *)(& bntmp2));
    if (vcp->vc_verbose > 1) {
      BN_clear(& bntmp2);
      BN_set_bit(& bntmp2, 192);
      BN_div(& bntmp3, (BIGNUM *)((void *)0), (BIGNUM const   *)(& bntmp2), (BIGNUM const   *)(& bntmp),
             bnctx);
      dbuf = BN_bn2dec((BIGNUM const   *)(& bntmp3));
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Prefix difficulty: %20s %s\n",
              dbuf, *(patterns + i));
      CRYPTO_free((void *)dbuf);
    }
    __Cont: /* CIL Label */
    i ++;
  }
  vcpp->base.vc_npatterns += npfx;
  vcpp->base.vc_npatterns_start += npfx;
  if (! npfx) {
    if (impossible) {
      ats = "bitcoin";
      bw = "\"1\"";
      switch (vcpp->base.vc_addrtype) {
      case 5:
      ats = "bitcoin script";
      bw = "\"3\"";
      break;
      case 111:
      ats = "testnet";
      bw = "\"m\" or \"n\"";
      break;
      case 52:
      ats = "namecoin";
      bw = "\"M\" or \"N\"";
      break;
      default:
      break;
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Hint: valid %s addresses begin with %s\n",
              ats, bw);
    }
  }
  if (npfx) {
    vg_prefix_context_next_difficulty(vcpp, & bntmp, & bntmp2, bnctx);
  }
  ret = npfx != 0UL;
  BN_clear_free(& bntmp);
  BN_clear_free(& bntmp2);
  BN_clear_free(& bntmp3);
  BN_CTX_free(bnctx);
  return (ret);
}
}
double vg_prefix_get_difficulty(int addrtype , char const   *pattern )
{
  BN_CTX *bnctx ;
  BIGNUM result ;
  BIGNUM bntmp ;
  BIGNUM *ranges[4] ;
  char *dbuf ;
  int ret ;
  double diffret ;

  {
  diffret = 0.0;
  bnctx = BN_CTX_new();
  BN_init(& result);
  BN_init(& bntmp);
  ret = get_prefix_ranges(addrtype, pattern, ranges, bnctx);
  if (ret == 0) {
    BN_sub(& bntmp, (BIGNUM const   *)ranges[1], (BIGNUM const   *)ranges[0]);
    BN_add(& result, (BIGNUM const   *)(& result), (BIGNUM const   *)(& bntmp));
    if (ranges[2]) {
      BN_sub(& bntmp, (BIGNUM const   *)ranges[3], (BIGNUM const   *)ranges[2]);
      BN_add(& result, (BIGNUM const   *)(& result), (BIGNUM const   *)(& bntmp));
    }
    free_ranges(ranges);
    BN_clear(& bntmp);
    BN_set_bit(& bntmp, 192);
    BN_div(& result, (BIGNUM *)((void *)0), (BIGNUM const   *)(& bntmp), (BIGNUM const   *)(& result),
           bnctx);
    dbuf = BN_bn2dec((BIGNUM const   *)(& result));
    diffret = strtod((char const   * __restrict  )dbuf, (char ** __restrict  )((void *)0));
    CRYPTO_free((void *)dbuf);
  }
  BN_clear_free(& result);
  BN_clear_free(& bntmp);
  BN_CTX_free(bnctx);
  return (diffret);
}
}
static int vg_prefix_test(vg_exec_context_t *vxcp )
{
  vg_prefix_context_t *vcpp ;
  vg_prefix_t *vp ;
  int res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  vcpp = (vg_prefix_context_t *)vxcp->vxc_vc;
  res = 0;
  BN_bin2bn((unsigned char const   *)(vxcp->vxc_binres), 25, & vxcp->vxc_bntarg);
  research:
  vp = vg_prefix_avl_search(& vcpp->vcp_avlroot, & vxcp->vxc_bntarg);
  if (vp) {
    tmp = vg_exec_context_upgrade_lock(vxcp);
    if (tmp) {
      goto research;
    }
    vg_exec_context_consolidate_key(vxcp);
    (*(vcpp->base.vc_output_match))(& vcpp->base, vxcp->vxc_key, vp->vp_pattern);
    (vcpp->base.vc_found) ++;
    if (vcpp->base.vc_only_one) {
      return (2);
    }
    if (vcpp->base.vc_remove_on_match) {
      vg_prefix_range_sum(vp, & vxcp->vxc_bntarg, & vxcp->vxc_bntmp);
      BN_sub(& vxcp->vxc_bntmp, (BIGNUM const   *)(& vcpp->vcp_difficulty), (BIGNUM const   *)(& vxcp->vxc_bntarg));
      BN_copy(& vcpp->vcp_difficulty, (BIGNUM const   *)(& vxcp->vxc_bntmp));
      vg_prefix_delete(& vcpp->vcp_avlroot, vp);
      (vcpp->base.vc_npatterns) --;
      tmp___0 = avl_root_empty(& vcpp->vcp_avlroot);
      if (! tmp___0) {
        vg_prefix_context_next_difficulty(vcpp, & vxcp->vxc_bntmp, & vxcp->vxc_bntmp2,
                                          vxcp->vxc_bnctx);
      }
      (vcpp->base.vc_pattern_generation) ++;
    }
    res = 1;
  }
  tmp___1 = avl_root_empty(& vcpp->vcp_avlroot);
  if (tmp___1) {
    return (2);
  }
  return (res);
}
}
static int vg_prefix_hash160_sort(vg_context_t *vcp , void *buf )
{
  vg_prefix_context_t *vcpp ;
  vg_prefix_t *vp ;
  unsigned char *cbuf ;
  unsigned char bnbuf[25] ;
  int nbytes ;
  int ncopy ;
  int nskip ;
  int npfx ;
  int tmp ;
  int tmp___0 ;

  {
  vcpp = (vg_prefix_context_t *)vcp;
  cbuf = (unsigned char *)buf;
  npfx = 0;
  vp = vg_prefix_first(& vcpp->vcp_avlroot);
  while ((unsigned long )vp != (unsigned long )((void *)0)) {
    npfx ++;
    if (! buf) {
      goto __Cont;
    }
    nbytes = BN_bn2bin((BIGNUM const   *)vp->vp_low, bnbuf);
    if (nbytes >= 24) {
      ncopy = 20;
    } else {
      if (nbytes > 4) {
        tmp = nbytes - 4;
      } else {
        tmp = 0;
      }
      ncopy = tmp;
    }
    if (nbytes >= 24) {
      nskip = nbytes - 24;
    } else {
      nskip = 0;
    }
    if (ncopy < 20) {
      memset((void *)cbuf, 0, (size_t )(20 - ncopy));
    }
    memcpy((void * __restrict  )(cbuf + (20 - ncopy)), (void const   * __restrict  )(bnbuf + nskip),
           (size_t )ncopy);
    cbuf += 20;
    nbytes = BN_bn2bin((BIGNUM const   *)vp->vp_high, bnbuf);
    if (nbytes >= 24) {
      ncopy = 20;
    } else {
      if (nbytes > 4) {
        tmp___0 = nbytes - 4;
      } else {
        tmp___0 = 0;
      }
      ncopy = tmp___0;
    }
    if (nbytes >= 24) {
      nskip = nbytes - 24;
    } else {
      nskip = 0;
    }
    if (ncopy < 20) {
      memset((void *)cbuf, 0, (size_t )(20 - ncopy));
    }
    memcpy((void * __restrict  )(cbuf + (20 - ncopy)), (void const   * __restrict  )(bnbuf + nskip),
           (size_t )ncopy);
    cbuf += 20;
    __Cont: /* CIL Label */
    vp = vg_prefix_next(vp);
  }
  return (npfx);
}
}
vg_context_t *vg_prefix_context_new(int addrtype , int privtype , int caseinsensitive )
{
  vg_prefix_context_t *vcpp ;
  void *tmp ;

  {
  tmp = malloc(sizeof(*vcpp));
  vcpp = (vg_prefix_context_t *)tmp;
  if (vcpp) {
    memset((void *)vcpp, 0, sizeof(*vcpp));
    vcpp->base.vc_addrtype = addrtype;
    vcpp->base.vc_privtype = privtype;
    vcpp->base.vc_npatterns = 0UL;
    vcpp->base.vc_npatterns_start = 0UL;
    vcpp->base.vc_found = 0ULL;
    vcpp->base.vc_chance = 0.0;
    vcpp->base.vc_free = & vg_prefix_context_free;
    vcpp->base.vc_add_patterns = & vg_prefix_context_add_patterns;
    vcpp->base.vc_clear_all_patterns = & vg_prefix_context_clear_all_patterns;
    vcpp->base.vc_test = & vg_prefix_test;
    vcpp->base.vc_hash160_sort = & vg_prefix_hash160_sort;
    avl_root_init(& vcpp->vcp_avlroot);
    BN_init(& vcpp->vcp_difficulty);
    vcpp->vcp_caseinsensitive = caseinsensitive;
  }
  return (& vcpp->base);
}
}
static int vg_regex_context_add_patterns(vg_context_t *vcp , char const   ** const  patterns ,
                                         int npatterns )
{
  vg_regex_context_t *vcrp ;
  char const   *pcre_errptr ;
  int pcre_erroffset ;
  unsigned long i ;
  unsigned long nres ;
  unsigned long count ;
  void **mem ;
  void *tmp ;
  char const   *spaces ;

  {
  vcrp = (vg_regex_context_t *)vcp;
  if (! npatterns) {
    return (1);
  }
  if ((unsigned long )npatterns > vcrp->vcr_nalloc - vcrp->base.vc_npatterns) {
    count = (unsigned long )npatterns + vcrp->base.vc_npatterns;
    if (count < 2UL * vcrp->vcr_nalloc) {
      count = 2UL * vcrp->vcr_nalloc;
    }
    if (count < 16UL) {
      count = 16UL;
    }
    tmp = malloc((3UL * count) * sizeof(void *));
    mem = (void **)tmp;
    if (! mem) {
      return (0);
    }
    i = 0UL;
    while (i < vcrp->base.vc_npatterns) {
      *(mem + i) = (void *)*(vcrp->vcr_regex + i);
      *(mem + (count + i)) = (void *)*(vcrp->vcr_regex_extra + i);
      *(mem + (2UL * count + i)) = (void *)*(vcrp->vcr_regex_pat + i);
      i ++;
    }
    if (vcrp->vcr_nalloc) {
      free((void *)vcrp->vcr_regex);
    }
    vcrp->vcr_regex = (pcre **)mem;
    vcrp->vcr_regex_extra = (pcre_extra **)(mem + count);
    vcrp->vcr_regex_pat = (char const   **)(mem + 2UL * count);
    vcrp->vcr_nalloc = count;
  }
  nres = vcrp->base.vc_npatterns;
  i = 0UL;
  while (i < (unsigned long )npatterns) {
    *(vcrp->vcr_regex + nres) = pcre_compile(*(patterns + i), 0, & pcre_errptr, & pcre_erroffset,
                                             (unsigned char const   *)((void *)0));
    if (! *(vcrp->vcr_regex + nres)) {
      spaces = "                ";
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", *(patterns + i));
      while (pcre_erroffset > 16) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", spaces);
        pcre_erroffset -= 16;
      }
      if (pcre_erroffset > 0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", spaces + (16 - pcre_erroffset));
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"^\nRegex error: %s\n",
              pcre_errptr);
      goto __Cont;
    }
    *(vcrp->vcr_regex_extra + nres) = pcre_study((pcre const   *)*(vcrp->vcr_regex + nres),
                                                 0, & pcre_errptr);
    if (pcre_errptr) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Regex error: %s\n",
              pcre_errptr);
      (*pcre_free)((void *)*(vcrp->vcr_regex + nres));
      goto __Cont;
    }
    *(vcrp->vcr_regex_pat + nres) = *(patterns + i);
    nres ++;
    __Cont: /* CIL Label */
    i ++;
  }
  if (nres == vcrp->base.vc_npatterns) {
    return (0);
  }
  vcrp->base.vc_npatterns_start += nres - vcrp->base.vc_npatterns;
  vcrp->base.vc_npatterns = nres;
  return (1);
}
}
static void vg_regex_context_clear_all_patterns(vg_context_t *vcp )
{
  vg_regex_context_t *vcrp ;
  int i ;

  {
  vcrp = (vg_regex_context_t *)vcp;
  i = 0;
  while ((unsigned long )i < vcrp->base.vc_npatterns) {
    if (*(vcrp->vcr_regex_extra + i)) {
      (*pcre_free)((void *)*(vcrp->vcr_regex_extra + i));
    }
    (*pcre_free)((void *)*(vcrp->vcr_regex + i));
    i ++;
  }
  vcrp->base.vc_npatterns = 0UL;
  vcrp->base.vc_npatterns_start = 0UL;
  vcrp->base.vc_found = 0ULL;
  return;
}
}
static void vg_regex_context_free(vg_context_t *vcp )
{
  vg_regex_context_t *vcrp ;

  {
  vcrp = (vg_regex_context_t *)vcp;
  vg_regex_context_clear_all_patterns(vcp);
  if (vcrp->vcr_nalloc) {
    free((void *)vcrp->vcr_regex);
  }
  free((void *)vcrp);
  return;
}
}
static int vg_regex_test(vg_exec_context_t *vxcp )
{
  vg_regex_context_t *vcrp ;
  unsigned char hash1[32] ;
  unsigned char hash2[32] ;
  int i ;
  int zpfx ;
  int p ;
  int d ;
  int nres ;
  int re_vec[9] ;
  char b58[40] ;
  BIGNUM bnrem ;
  BIGNUM *bn ;
  BIGNUM *bndiv ;
  BIGNUM *bnptmp ;
  int res ;
  pcre *re ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  vcrp = (vg_regex_context_t *)vxcp->vxc_vc;
  res = 0;
  BN_init(& bnrem);
  SHA256((unsigned char const   *)(vxcp->vxc_binres), (size_t )21, hash1);
  SHA256((unsigned char const   *)(hash1), sizeof(hash1), hash2);
  memcpy((void * __restrict  )(& vxcp->vxc_binres[21]), (void const   * __restrict  )(hash2),
         (size_t )4);
  bn = & vxcp->vxc_bntmp;
  bndiv = & vxcp->vxc_bntmp2;
  BN_bin2bn((unsigned char const   *)(vxcp->vxc_binres), 25, bn);
  zpfx = 0;
  while (1) {
    if (zpfx < 25) {
      if (! ((int )vxcp->vxc_binres[zpfx] == 0)) {
        break;
      }
    } else {
      break;
    }
    zpfx ++;
  }
  p = (int )(sizeof(b58) - 1UL);
  b58[p] = (char )'\000';
  while (! (bn->top == 0)) {
    BN_div(bndiv, & bnrem, (BIGNUM const   *)bn, (BIGNUM const   *)(& vxcp->vxc_bnbase),
           vxcp->vxc_bnctx);
    bnptmp = bn;
    bn = bndiv;
    bndiv = bnptmp;
    tmp = BN_get_word((BIGNUM const   *)(& bnrem));
    d = (int )tmp;
    p --;
    b58[p] = (char )*(vg_b58_alphabet + d);
  }
  while (1) {
    tmp___0 = zpfx;
    zpfx --;
    if (! tmp___0) {
      break;
    }
    p --;
    b58[p] = (char )*(vg_b58_alphabet + 0);
  }
  restart_loop:
  nres = (int )vcrp->base.vc_npatterns;
  if (! nres) {
    res = 2;
    goto out;
  }
  i = 0;
  while (i < nres) {
    d = pcre_exec((pcre const   *)*(vcrp->vcr_regex + i), (pcre_extra const   *)*(vcrp->vcr_regex_extra + i),
                  (char const   *)(& b58[p]), (int )((sizeof(b58) - 1UL) - (unsigned long )p),
                  0, 0, re_vec, (int )(sizeof(re_vec) / sizeof(re_vec[0])));
    if (d <= 0) {
      if (d != -1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"PCRE error: %d\n",
                d);
        res = 2;
        goto out;
      }
      goto __Cont;
    }
    re = *(vcrp->vcr_regex + i);
    tmp___1 = vg_exec_context_upgrade_lock(vxcp);
    if (tmp___1) {
      if ((unsigned long )i >= vcrp->base.vc_npatterns) {
        goto restart_loop;
      } else
      if ((unsigned long )*(vcrp->vcr_regex + i) != (unsigned long )re) {
        goto restart_loop;
      }
    }
    vg_exec_context_consolidate_key(vxcp);
    (*(vcrp->base.vc_output_match))(& vcrp->base, vxcp->vxc_key, *(vcrp->vcr_regex_pat + i));
    (vcrp->base.vc_found) ++;
    if (vcrp->base.vc_only_one) {
      res = 2;
      goto out;
    }
    if (vcrp->base.vc_remove_on_match) {
      (*pcre_free)((void *)*(vcrp->vcr_regex + i));
      if (*(vcrp->vcr_regex_extra + i)) {
        (*pcre_free)((void *)*(vcrp->vcr_regex_extra + i));
      }
      nres --;
      vcrp->base.vc_npatterns = (unsigned long )nres;
      if (! nres) {
        res = 2;
        goto out;
      }
      *(vcrp->vcr_regex + i) = *(vcrp->vcr_regex + nres);
      *(vcrp->vcr_regex_extra + i) = *(vcrp->vcr_regex_extra + nres);
      *(vcrp->vcr_regex_pat + i) = *(vcrp->vcr_regex_pat + nres);
      vcrp->base.vc_npatterns = (unsigned long )nres;
      (vcrp->base.vc_pattern_generation) ++;
    }
    res = 1;
    __Cont: /* CIL Label */
    i ++;
  }
  out:
  BN_clear_free(& bnrem);
  return (res);
}
}
vg_context_t *vg_regex_context_new(int addrtype , int privtype )
{
  vg_regex_context_t *vcrp ;
  void *tmp ;

  {
  tmp = malloc(sizeof(*vcrp));
  vcrp = (vg_regex_context_t *)tmp;
  if (vcrp) {
    memset((void *)vcrp, 0, sizeof(*vcrp));
    vcrp->base.vc_addrtype = addrtype;
    vcrp->base.vc_privtype = privtype;
    vcrp->base.vc_npatterns = 0UL;
    vcrp->base.vc_npatterns_start = 0UL;
    vcrp->base.vc_found = 0ULL;
    vcrp->base.vc_chance = 0.0;
    vcrp->base.vc_free = & vg_regex_context_free;
    vcrp->base.vc_add_patterns = & vg_regex_context_add_patterns;
    vcrp->base.vc_clear_all_patterns = & vg_regex_context_clear_all_patterns;
    vcrp->base.vc_test = & vg_regex_test;
    vcrp->base.vc_hash160_sort = (int (*)(vg_context_t *vcp , void *buf ))((void *)0);
    vcrp->vcr_regex = (pcre **)((void *)0);
    vcrp->vcr_nalloc = 0UL;
  }
  return (& vcrp->base);
}
}
#pragma merger("0","/tmp/cil-XmRKgc3M.i","-ggdb,-O3,-Wall")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
extern void OPENSSL_cleanse(void *ptr , size_t len ) ;
extern int BN_num_bits(BIGNUM const   *a ) ;
extern BIO *BIO_new(BIO_METHOD *type ) ;
extern int BIO_free(BIO *a ) ;
extern long BIO_ctrl(BIO *bp , int cmd , long larg , void *parg ) ;
extern BIO_METHOD *BIO_s_mem(void) ;
extern BIO *BIO_new_mem_buf(void *buf , int len ) ;
extern int EVP_read_pw_string(char *buf , int length , char const   *prompt , int verify ) ;
extern int EVP_CipherInit(EVP_CIPHER_CTX *ctx , EVP_CIPHER const   *cipher , unsigned char const   *key ,
                          unsigned char const   *iv , int enc ) ;
extern int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx , unsigned char *out , int *outl ,
                            unsigned char const   *in , int inl ) ;
extern int EVP_CipherFinal(EVP_CIPHER_CTX *ctx , unsigned char *outm , int *outl ) ;
extern EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void) ;
extern void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *a ) ;
extern int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c , int pad ) ;
extern EVP_MD const   *EVP_sha256(void) ;
extern EVP_CIPHER const   *EVP_aes_256_cbc(void) ;
extern int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey , struct ec_key_st *key ) ;
extern struct ec_key_st *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey ) ;
extern EVP_PKEY *EVP_PKEY_new(void) ;
extern void EVP_PKEY_free(EVP_PKEY *pkey ) ;
extern int PKCS5_PBKDF2_HMAC(char const   *pass , int passlen , unsigned char const   *salt ,
                             int saltlen , int iter , EVP_MD const   *digest , int keylen ,
                             unsigned char *out ) ;
extern unsigned char *HMAC(EVP_MD const   *evp_md , void const   *key , int key_len ,
                           unsigned char const   *d , size_t n , unsigned char *md ,
                           unsigned int *md_len ) ;
extern int RAND_bytes(unsigned char *buf , int num ) ;
extern int EC_GROUP_cmp(EC_GROUP const   *a , EC_GROUP const   *b , BN_CTX *ctx ) ;
extern int EC_POINT_mul(EC_GROUP const   *group , EC_POINT *r , BIGNUM const   *n ,
                        EC_POINT const   *q , BIGNUM const   *m , BN_CTX *ctx ) ;
extern EC_KEY *EC_KEY_copy(EC_KEY *dst , EC_KEY const   *src ) ;
extern EC_KEY *EC_KEY_dup(EC_KEY const   *src ) ;
extern int EC_KEY_set_private_key(EC_KEY *key , BIGNUM const   *prv ) ;
extern int EC_KEY_set_public_key(EC_KEY *key , EC_POINT const   *pub ) ;
extern void X509_SIG_free(X509_SIG *a ) ;
extern void PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO *a ) ;
extern EVP_PKEY *EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8 ) ;
extern PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(EVP_PKEY *pkey ) ;
extern X509_SIG *PEM_read_bio_PKCS8(BIO *bp , X509_SIG **x , pem_password_cb *cb ,
                                    void *u ) ;
extern int PEM_write_bio_PKCS8(BIO *bp , X509_SIG *x ) ;
extern PKCS8_PRIV_KEY_INFO *PEM_read_bio_PKCS8_PRIV_KEY_INFO(BIO *bp , PKCS8_PRIV_KEY_INFO **x ,
                                                             pem_password_cb *cb ,
                                                             void *u ) ;
extern int PEM_write_bio_PKCS8_PRIV_KEY_INFO(BIO *bp , PKCS8_PRIV_KEY_INFO *x ) ;
extern PKCS8_PRIV_KEY_INFO *PKCS8_decrypt(X509_SIG *p8 , char const   *pass , int passlen ) ;
extern X509_SIG *PKCS8_encrypt(int pbe_nid , EVP_CIPHER const   *cipher , char const   *pass ,
                               int passlen , unsigned char *salt , int saltlen , int iter ,
                               PKCS8_PRIV_KEY_INFO *p8 ) ;
void fdumphex(FILE *fp , unsigned char const   *src , size_t len ) ;
void fdumpbn(FILE *fp , BIGNUM const   *bn ) ;
void vg_b58_encode_check(void *buf , size_t len , char *result ) ;
int vg_decode_privkey(char const   *b58encoded , EC_KEY *pkey , int *addrtype ) ;
int vg_protect_decode_privkey(EC_KEY *pkey , int *keytype , char const   *encoded ,
                              char const   *pass ) ;
int vg_pkcs8_encode_privkey(char *out , int outlen , EC_KEY const   *pkey , char const   *pass ) ;
int vg_pkcs8_decode_privkey(EC_KEY *pkey , char const   *pem_in , char const   *pass ) ;
int vg_decode_privkey_any(EC_KEY *pkey , int *addrtype , char const   *input , char const   *pass ) ;
int vg_read_password(char *buf , size_t size ) ;
int vg_check_password_complexity(char const   *pass , int verbose ) ;
int vg_read_file(FILE *fp , char ***result , int *rescount ) ;
char const   *vg_b58_alphabet  =    "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
signed char const   vg_b58_reverse_map[256]  =
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,
        (signed char const   )3,      (signed char const   )4,      (signed char const   )5,      (signed char const   )6,
        (signed char const   )7,      (signed char const   )8,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )9,      (signed char const   )10,      (signed char const   )11,
        (signed char const   )12,      (signed char const   )13,      (signed char const   )14,      (signed char const   )15,
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )17,      (signed char const   )18,
        (signed char const   )19,      (signed char const   )20,      (signed char const   )21,      (signed char const   )-1,
        (signed char const   )22,      (signed char const   )23,      (signed char const   )24,      (signed char const   )25,
        (signed char const   )26,      (signed char const   )27,      (signed char const   )28,      (signed char const   )29,
        (signed char const   )30,      (signed char const   )31,      (signed char const   )32,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )33,      (signed char const   )34,      (signed char const   )35,
        (signed char const   )36,      (signed char const   )37,      (signed char const   )38,      (signed char const   )39,
        (signed char const   )40,      (signed char const   )41,      (signed char const   )42,      (signed char const   )43,
        (signed char const   )-1,      (signed char const   )44,      (signed char const   )45,      (signed char const   )46,
        (signed char const   )47,      (signed char const   )48,      (signed char const   )49,      (signed char const   )50,
        (signed char const   )51,      (signed char const   )52,      (signed char const   )53,      (signed char const   )54,
        (signed char const   )55,      (signed char const   )56,      (signed char const   )57,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
void fdumphex(FILE *fp , unsigned char const   *src , size_t len )
{
  size_t i ;

  {
  i = (size_t )0;
  while (i < len) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%02x", (int const   )*(src + i));
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  return;
}
}
void fdumpbn(FILE *fp , BIGNUM const   *bn )
{
  char *buf ;
  char const   *tmp ;

  {
  buf = BN_bn2hex(bn);
  if (buf) {
    tmp = (char const   *)buf;
  } else {
    tmp = "0";
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\n", tmp);
  if (buf) {
    CRYPTO_free((void *)buf);
  }
  return;
}
}
void dumphex(unsigned char const   *src , size_t len )
{


  {
  fdumphex(stdout, src, len);
  return;
}
}
void dumpbn(BIGNUM const   *bn )
{


  {
  fdumpbn(stdout, bn);
  return;
}
}
void vg_b58_encode_check(void *buf , size_t len , char *result )
{
  unsigned char hash1[32] ;
  unsigned char hash2[32] ;
  int d ;
  int p ;
  BN_CTX *bnctx ;
  BIGNUM *bn ;
  BIGNUM *bndiv ;
  BIGNUM *bntmp ;
  BIGNUM bna ;
  BIGNUM bnb ;
  BIGNUM bnbase ;
  BIGNUM bnrem ;
  unsigned char *binres ;
  int brlen ;
  int zpfx ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  bnctx = BN_CTX_new();
  BN_init(& bna);
  BN_init(& bnb);
  BN_init(& bnbase);
  BN_init(& bnrem);
  BN_set_word(& bnbase, 58UL);
  bn = & bna;
  bndiv = & bnb;
  brlen = (int )(2UL * len + 4UL);
  tmp = malloc((size_t )brlen);
  binres = (unsigned char *)tmp;
  memcpy((void * __restrict  )binres, (void const   * __restrict  )buf, len);
  SHA256((unsigned char const   *)binres, len, hash1);
  SHA256((unsigned char const   *)(hash1), sizeof(hash1), hash2);
  memcpy((void * __restrict  )(binres + len), (void const   * __restrict  )(hash2),
         (size_t )4);
  BN_bin2bn((unsigned char const   *)binres, (int )(len + 4UL), bn);
  zpfx = 0;
  while (1) {
    if ((size_t )zpfx < len + 4UL) {
      if (! ((int )*(binres + zpfx) == 0)) {
        break;
      }
    } else {
      break;
    }
    zpfx ++;
  }
  p = brlen;
  while (! (bn->top == 0)) {
    BN_div(bndiv, & bnrem, (BIGNUM const   *)bn, (BIGNUM const   *)(& bnbase), bnctx);
    bntmp = bn;
    bn = bndiv;
    bndiv = bntmp;
    tmp___0 = BN_get_word((BIGNUM const   *)(& bnrem));
    d = (int )tmp___0;
    p --;
    *(binres + p) = (unsigned char )*(vg_b58_alphabet + d);
  }
  while (1) {
    tmp___1 = zpfx;
    zpfx --;
    if (! tmp___1) {
      break;
    }
    p --;
    *(binres + p) = (unsigned char )*(vg_b58_alphabet + 0);
  }
  memcpy((void * __restrict  )result, (void const   * __restrict  )(binres + p), (size_t )(brlen - p));
  *(result + (brlen - p)) = (char )'\000';
  free((void *)binres);
  BN_clear_free(& bna);
  BN_clear_free(& bnb);
  BN_clear_free(& bnbase);
  BN_clear_free(& bnrem);
  BN_CTX_free(bnctx);
  return;
}
}
int vg_b58_decode_check(char const   *input , void *buf , size_t len )
{
  int i ;
  int l ;
  int c ;
  unsigned char *xbuf ;
  BIGNUM bn ;
  BIGNUM bnw ;
  BIGNUM bnbase ;
  BN_CTX *bnctx ;
  unsigned char hash1[32] ;
  unsigned char hash2[32] ;
  int zpfx ;
  int res ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  xbuf = (unsigned char *)((void *)0);
  res = 0;
  BN_init(& bn);
  BN_init(& bnw);
  BN_init(& bnbase);
  BN_set_word(& bnbase, 58UL);
  bnctx = BN_CTX_new();
  tmp = strlen(input);
  l = (int )tmp;
  i = 0;
  while (i < l) {
    if ((int const   )*(input + i) == 13) {
      goto __Cont;
    } else
    if ((int const   )*(input + i) == 10) {
      goto __Cont;
    } else
    if ((int const   )*(input + i) == 32) {
      goto __Cont;
    } else
    if ((int const   )*(input + i) == 9) {
      goto __Cont;
    }
    c = (int )vg_b58_reverse_map[(int )*(input + i)];
    if (c < 0) {
      goto out;
    }
    BN_clear(& bnw);
    BN_set_word(& bnw, (unsigned long )c);
    BN_mul(& bn, (BIGNUM const   *)(& bn), (BIGNUM const   *)(& bnbase), bnctx);
    BN_add(& bn, (BIGNUM const   *)(& bn), (BIGNUM const   *)(& bnw));
    __Cont: /* CIL Label */
    i ++;
  }
  i = 0;
  zpfx = 0;
  while (*(input + i)) {
    if ((int const   )*(input + i) == 13) {
      goto __Cont___0;
    } else
    if ((int const   )*(input + i) == 10) {
      goto __Cont___0;
    } else
    if ((int const   )*(input + i) == 32) {
      goto __Cont___0;
    } else
    if ((int const   )*(input + i) == 9) {
      goto __Cont___0;
    }
    if ((int const   )*(input + i) != (int const   )*(vg_b58_alphabet + 0)) {
      break;
    }
    zpfx ++;
    __Cont___0: /* CIL Label */
    i ++;
  }
  tmp___0 = BN_num_bits((BIGNUM const   *)(& bn));
  c = (tmp___0 + 7) / 8;
  l = zpfx + c;
  if (l < 5) {
    goto out;
  }
  tmp___1 = malloc((size_t )l);
  xbuf = (unsigned char *)tmp___1;
  if (! xbuf) {
    goto out;
  }
  if (zpfx) {
    memset((void *)xbuf, 0, (size_t )zpfx);
  }
  if (c) {
    BN_bn2bin((BIGNUM const   *)(& bn), xbuf + zpfx);
  }
  l -= 4;
  SHA256((unsigned char const   *)xbuf, (size_t )l, hash1);
  SHA256((unsigned char const   *)(hash1), sizeof(hash1), hash2);
  tmp___2 = memcmp((void const   *)(hash2), (void const   *)(xbuf + l), (size_t )4);
  if (tmp___2) {
    goto out;
  }
  if (len) {
    if (len > (size_t )l) {
      len = (size_t )l;
    }
    memcpy((void * __restrict  )buf, (void const   * __restrict  )xbuf, len);
  }
  res = l;
  out:
  if (xbuf) {
    free((void *)xbuf);
  }
  BN_clear_free(& bn);
  BN_clear_free(& bnw);
  BN_clear_free(& bnbase);
  BN_CTX_free(bnctx);
  return (res);
}
}
void vg_encode_address(EC_POINT const   *ppoint , EC_GROUP const   *pgroup , int addrtype ,
                       char *result )
{
  unsigned char eckey_buf[128] ;
  unsigned char *pend ;
  unsigned char binres[21] ;
  unsigned int tmp ;
  unsigned char hash1[32] ;

  {
  binres[0] = (unsigned char)0;
  tmp = 1U;
  while (! (tmp >= 21U)) {
    binres[tmp] = (unsigned char)0;
    tmp ++;
  }
  pend = eckey_buf;
  EC_POINT_point2oct(pgroup, ppoint, (point_conversion_form_t )4, eckey_buf, sizeof(eckey_buf),
                     (BN_CTX *)((void *)0));
  pend = eckey_buf + 65;
  binres[0] = (unsigned char )addrtype;
  SHA256((unsigned char const   *)(eckey_buf), (size_t )(pend - eckey_buf), hash1);
  RIPEMD160((unsigned char const   *)(hash1), sizeof(hash1), & binres[1]);
  vg_b58_encode_check((void *)(binres), sizeof(binres), result);
  return;
}
}
void vg_encode_script_address(EC_POINT const   *ppoint , EC_GROUP const   *pgroup ,
                              int addrtype , char *result )
{
  unsigned char script_buf[69] ;
  unsigned char *eckey_buf ;
  unsigned char binres[21] ;
  unsigned int tmp ;
  unsigned char hash1[32] ;

  {
  eckey_buf = script_buf + 2;
  binres[0] = (unsigned char)0;
  tmp = 1U;
  while (! (tmp >= 21U)) {
    binres[tmp] = (unsigned char)0;
    tmp ++;
  }
  script_buf[0] = (unsigned char)81;
  script_buf[1] = (unsigned char)65;
  script_buf[67] = (unsigned char)81;
  script_buf[68] = (unsigned char)174;
  EC_POINT_point2oct(pgroup, ppoint, (point_conversion_form_t )4, eckey_buf, (size_t )65,
                     (BN_CTX *)((void *)0));
  binres[0] = (unsigned char )addrtype;
  SHA256((unsigned char const   *)(script_buf), (size_t )69, hash1);
  RIPEMD160((unsigned char const   *)(hash1), sizeof(hash1), & binres[1]);
  vg_b58_encode_check((void *)(binres), sizeof(binres), result);
  return;
}
}
void vg_encode_privkey(EC_KEY const   *pkey , int addrtype , char *result )
{
  unsigned char eckey_buf[128] ;
  BIGNUM const   *bn ;
  int nbytes ;
  int tmp ;

  {
  bn = EC_KEY_get0_private_key(pkey);
  eckey_buf[0] = (unsigned char )addrtype;
  tmp = BN_num_bits(bn);
  nbytes = (tmp + 7) / 8;
  if (! (nbytes <= 32)) {
    __assert_fail("nbytes <= 32", "util.c", 301U, "vg_encode_privkey");
  }
  if (nbytes < 32) {
    memset((void *)(eckey_buf + 1), 0, (size_t )(32 - nbytes));
  }
  BN_bn2bin(bn, & eckey_buf[33 - nbytes]);
  vg_b58_encode_check((void *)(eckey_buf), (size_t )33, result);
  return;
}
}
int vg_set_privkey(BIGNUM const   *bnpriv , EC_KEY *pkey )
{
  EC_GROUP const   *pgroup ;
  EC_POINT *ppnt ;
  int res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___6 ;

  {
  pgroup = EC_KEY_get0_group((EC_KEY const   *)pkey);
  ppnt = EC_POINT_new(pgroup);
  if (ppnt) {
    tmp = EC_KEY_set_private_key(pkey, bnpriv);
    if (tmp) {
      tmp___0 = EC_POINT_mul(pgroup, ppnt, bnpriv, (EC_POINT const   *)((void *)0),
                             (BIGNUM const   *)((void *)0), (BN_CTX *)((void *)0));
      if (tmp___0) {
        tmp___1 = EC_KEY_set_public_key(pkey, (EC_POINT const   *)ppnt);
        if (tmp___1) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  res = tmp___2;
  if (ppnt) {
    EC_POINT_free(ppnt);
  }
  if (! res) {
    return (0);
  }
  tmp___6 = EC_KEY_check_key((EC_KEY const   *)pkey);
  if (! tmp___6) {
    __assert_fail("EC_KEY_check_key(pkey)", "util.c", 330U, "vg_set_privkey");
  }
  return (1);
}
}
int vg_decode_privkey(char const   *b58encoded , EC_KEY *pkey , int *addrtype )
{
  BIGNUM bnpriv ;
  unsigned char ecpriv[48] ;
  int res ;

  {
  res = vg_b58_decode_check(b58encoded, (void *)(ecpriv), sizeof(ecpriv));
  if (res != 33) {
    return (0);
  }
  BN_init(& bnpriv);
  BN_bin2bn((unsigned char const   *)(ecpriv + 1), res - 1, & bnpriv);
  res = vg_set_privkey((BIGNUM const   *)(& bnpriv), pkey);
  BN_clear_free(& bnpriv);
  *addrtype = (int )ecpriv[0];
  return (1);
}
}
static vg_protkey_parameters_t const   protkey_parameters[17]  =
  {      {0, 4096, & EVP_sha256, & EVP_aes_256_cbc},
        {0, 0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {0,
      0, (EVP_MD const   *(*)(void))((void *)0), (EVP_CIPHER const   *(*)(void))((void *)0)},
        {1,
      4096, & EVP_sha256, & EVP_aes_256_cbc}};
static int vg_protect_crypt(int parameter_group , unsigned char *data_in , int data_in_len ,
                            unsigned char *data_out , char const   *pass , int enc )
{
  EVP_CIPHER_CTX *ctx ;
  unsigned char *salt ;
  unsigned char keymaterial[144] ;
  unsigned char hmac[64] ;
  int hmac_len ;
  int hmac_keylen ;
  int salt_len ;
  int plaintext_len ;
  int ciphertext_len ;
  int pkcs7_padding ;
  vg_protkey_parameters_t const   *params ;
  EVP_CIPHER const   *cipher ;
  EVP_MD const   *pbkdf_digest ;
  EVP_MD const   *hmac_digest ;
  unsigned int hlen ;
  int opos ;
  int olen ;
  int oincr ;
  int nbytes ;
  int ipos ;
  int ret ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;

  {
  ctx = (EVP_CIPHER_CTX *)((void *)0);
  hmac_len = 0;
  hmac_keylen = 0;
  plaintext_len = 32;
  pkcs7_padding = 1;
  ret = 0;
  ctx = EVP_CIPHER_CTX_new();
  if (! ctx) {
    goto out;
  }
  if (parameter_group < 0) {
    if (enc) {
      parameter_group = 0;
    } else {
      parameter_group = (int )*(data_in + 0);
    }
  } else
  if (! enc) {
    if (parameter_group != (int )*(data_in + 0)) {
      goto out;
    }
  }
  if ((unsigned long )parameter_group > sizeof(protkey_parameters) / sizeof(protkey_parameters[0])) {
    goto out;
  }
  params = & protkey_parameters[parameter_group];
  if (! params->iterations) {
    goto out;
  } else
  if (! params->pbkdf_hash_getter) {
    goto out;
  }
  pbkdf_digest = (*(params->pbkdf_hash_getter))();
  cipher = (*(params->cipher_getter))();
  if (params->mode == 0) {
    salt_len = 4;
    hmac_len = 8;
    hmac_keylen = 16;
    ciphertext_len = (((plaintext_len + (int )cipher->block_size) - 1) / (int )cipher->block_size) * (int )cipher->block_size;
    pkcs7_padding = 0;
    hmac_digest = EVP_sha256();
  } else {
    salt_len = 8;
    ciphertext_len = ((plaintext_len + (int )cipher->block_size) / (int )cipher->block_size) * (int )cipher->block_size;
    hmac_digest = (EVP_MD const   *)((void *)0);
  }
  if (! enc) {
    if (data_in_len != ((1 + ciphertext_len) + hmac_len) + salt_len) {
      goto out;
    }
  }
  if (! pass) {
    ret = plaintext_len;
    goto out;
  } else
  if (! data_out) {
    ret = plaintext_len;
    goto out;
  }
  if (! enc) {
    salt = ((data_in + 1) + ciphertext_len) + hmac_len;
  } else
  if (salt_len) {
    salt = ((data_out + 1) + ciphertext_len) + hmac_len;
    RAND_bytes(salt, salt_len);
  } else {
    salt = (unsigned char *)((void *)0);
  }
  tmp = strlen(pass);
  PKCS5_PBKDF2_HMAC(pass, (int )(tmp + 1UL), (unsigned char const   *)salt, salt_len,
                    (int )params->iterations, pbkdf_digest, (int )((cipher->key_len + cipher->iv_len) + (int const   )hmac_keylen),
                    keymaterial);
  tmp___0 = EVP_CipherInit(ctx, cipher, (unsigned char const   *)(keymaterial), (unsigned char const   *)(keymaterial + cipher->key_len),
                           enc);
  if (! tmp___0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: could not configure cipher\n");
    goto out;
  }
  if (! pkcs7_padding) {
    EVP_CIPHER_CTX_set_padding(ctx, 0);
  }
  if (! enc) {
    opos = 0;
    olen = plaintext_len;
    nbytes = ciphertext_len;
    ipos = 1;
  } else {
    *(data_out + 0) = (unsigned char )parameter_group;
    opos = 1;
    olen = (((1 + ciphertext_len) + hmac_len) + salt_len) - opos;
    nbytes = plaintext_len;
    ipos = 0;
  }
  oincr = olen;
  tmp___1 = EVP_CipherUpdate(ctx, data_out + opos, & oincr, (unsigned char const   *)(data_in + ipos),
                             nbytes);
  if (! tmp___1) {
    goto invalid_pass;
  }
  opos += oincr;
  olen -= oincr;
  oincr = olen;
  tmp___2 = EVP_CipherFinal(ctx, data_out + opos, & oincr);
  if (! tmp___2) {
    goto invalid_pass;
  }
  opos += oincr;
  if (hmac_len) {
    hlen = (unsigned int )sizeof(hmac);
    if (enc) {
      tmp___3 = data_in;
    } else {
      tmp___3 = data_out;
    }
    HMAC(hmac_digest, (void const   *)((keymaterial + cipher->key_len) + cipher->iv_len),
         hmac_keylen, (unsigned char const   *)tmp___3, (size_t )plaintext_len, hmac,
         & hlen);
    if (enc) {
      memcpy((void * __restrict  )((data_out + 1) + ciphertext_len), (void const   * __restrict  )(hmac),
             (size_t )hmac_len);
    } else {
      tmp___4 = memcmp((void const   *)(hmac), (void const   *)((data_in + 1) + ciphertext_len),
                       (size_t )hmac_len);
      if (tmp___4) {
        goto invalid_pass;
      }
    }
  }
  if (enc) {
    if (opos != 1 + ciphertext_len) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: plaintext size mismatch\n");
      goto out;
    }
    opos += hmac_len + salt_len;
  } else
  if (opos != plaintext_len) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: plaintext size mismatch\n");
    goto out;
  }
  ret = opos;
  if (0) {
    invalid_pass:
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Invalid password\n");
  }
  out:
  OPENSSL_cleanse((void *)(hmac), sizeof(hmac));
  OPENSSL_cleanse((void *)(keymaterial), sizeof(keymaterial));
  if (ctx) {
    EVP_CIPHER_CTX_free(ctx);
  }
  return (ret);
}
}
int vg_protect_encode_privkey(char *out , EC_KEY const   *pkey , int keytype , int parameter_group ,
                              char const   *pass )
{
  unsigned char ecpriv[64] ;
  unsigned char ecenc[128] ;
  BIGNUM const   *privkey ;
  int nbytes ;
  int restype ;
  int tmp ;
  size_t tmp___0 ;

  {
  if (keytype & 1) {
    restype = 79;
  } else {
    restype = 32;
  }
  privkey = EC_KEY_get0_private_key(pkey);
  tmp = BN_num_bits(privkey);
  nbytes = (tmp + 7) / 8;
  if (nbytes < 32) {
    memset((void *)(ecpriv), 0, (size_t )(32 - nbytes));
  }
  BN_bn2bin(privkey, (ecpriv + 32) - nbytes);
  nbytes = vg_protect_crypt(parameter_group, ecpriv, 32, & ecenc[1], pass, 1);
  if (nbytes <= 0) {
    return (0);
  }
  OPENSSL_cleanse((void *)(ecpriv), sizeof(ecpriv));
  ecenc[0] = (unsigned char )restype;
  vg_b58_encode_check((void *)(ecenc), (size_t )(nbytes + 1), out);
  tmp___0 = strlen((char const   *)out);
  nbytes = (int )tmp___0;
  return (nbytes);
}
}
int vg_protect_decode_privkey(EC_KEY *pkey , int *keytype , char const   *encoded ,
                              char const   *pass )
{
  unsigned char ecpriv[64] ;
  unsigned char ecenc[128] ;
  BIGNUM bn ;
  int restype ;
  int res ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
  res = vg_b58_decode_check(encoded, (void *)(ecenc), sizeof(ecenc));
  if (res < 2) {
    return (0);
  } else
  if ((unsigned long )res > sizeof(ecenc)) {
    return (0);
  }
  switch ((int )ecenc[0]) {
  case 32:
  restype = 128;
  break;
  case 79:
  restype = 239;
  break;
  default:
  return (0);
  }
  if (pkey) {
    tmp = ecpriv;
  } else {
    tmp = (unsigned char *)((void *)0);
  }
  tmp___0 = vg_protect_crypt(-1, ecenc + 1, res - 1, tmp, pass, 0);
  if (! tmp___0) {
    return (0);
  }
  res = 1;
  if (pkey) {
    BN_init(& bn);
    BN_bin2bn((unsigned char const   *)(ecpriv), 32, & bn);
    res = vg_set_privkey((BIGNUM const   *)(& bn), pkey);
    BN_clear_free(& bn);
    OPENSSL_cleanse((void *)(ecpriv), sizeof(ecpriv));
  }
  *keytype = restype;
  return (res);
}
}
int vg_pkcs8_encode_privkey(char *out , int outlen , EC_KEY const   *pkey , char const   *pass )
{
  EC_KEY *pkey_copy ;
  EVP_PKEY *evp_key ;
  PKCS8_PRIV_KEY_INFO *pkcs8 ;
  X509_SIG *pkcs8_enc ;
  BUF_MEM *memptr ;
  BIO *bio ;
  int res ;
  int tmp ;
  BIO_METHOD *tmp___0 ;
  size_t tmp___1 ;
  EVP_CIPHER const   *tmp___2 ;

  {
  pkey_copy = (EC_KEY *)((void *)0);
  evp_key = (EVP_PKEY *)((void *)0);
  pkcs8 = (PKCS8_PRIV_KEY_INFO *)((void *)0);
  pkcs8_enc = (X509_SIG *)((void *)0);
  bio = (BIO *)((void *)0);
  res = 0;
  pkey_copy = EC_KEY_dup(pkey);
  if (! pkey_copy) {
    goto out;
  }
  evp_key = EVP_PKEY_new();
  if (! evp_key) {
    goto out;
  } else {
    tmp = EVP_PKEY_set1_EC_KEY(evp_key, pkey_copy);
    if (! tmp) {
      goto out;
    }
  }
  pkcs8 = EVP_PKEY2PKCS8(evp_key);
  if (! pkcs8) {
    goto out;
  }
  tmp___0 = BIO_s_mem();
  bio = BIO_new(tmp___0);
  if (! bio) {
    goto out;
  }
  if (! pass) {
    res = PEM_write_bio_PKCS8_PRIV_KEY_INFO(bio, pkcs8);
  } else {
    tmp___1 = strlen(pass);
    tmp___2 = EVP_aes_256_cbc();
    pkcs8_enc = PKCS8_encrypt(-1, tmp___2, pass, (int )tmp___1, (unsigned char *)((void *)0),
                              0, 4096, pkcs8);
    if (! pkcs8_enc) {
      goto out;
    }
    res = PEM_write_bio_PKCS8(bio, pkcs8_enc);
  }
  BIO_ctrl(bio, 115, 0L, (void *)((char *)(& memptr)));
  res = (int )memptr->length;
  if (res < outlen) {
    memcpy((void * __restrict  )out, (void const   * __restrict  )memptr->data, (size_t )res);
    *(out + res) = (char )'\000';
  } else {
    memcpy((void * __restrict  )out, (void const   * __restrict  )memptr->data, (size_t )(outlen - 1));
    *(out + (outlen - 1)) = (char )'\000';
  }
  out:
  if (bio) {
    BIO_free(bio);
  }
  if (pkey_copy) {
    EC_KEY_free(pkey_copy);
  }
  if (evp_key) {
    EVP_PKEY_free(evp_key);
  }
  if (pkcs8) {
    PKCS8_PRIV_KEY_INFO_free(pkcs8);
  }
  if (pkcs8_enc) {
    X509_SIG_free(pkcs8_enc);
  }
  return (res);
}
}
int vg_pkcs8_decode_privkey(EC_KEY *pkey , char const   *pem_in , char const   *pass )
{
  EC_KEY *pkey_in ;
  EC_KEY *test_key ;
  EVP_PKEY *evp_key ;
  PKCS8_PRIV_KEY_INFO *pkcs8 ;
  X509_SIG *pkcs8_enc ;
  BIO *bio ;
  int res ;
  size_t tmp ;
  size_t tmp___0 ;
  EC_GROUP const   *tmp___1 ;
  EC_GROUP const   *tmp___2 ;
  int tmp___3 ;
  EC_KEY *tmp___4 ;

  {
  pkey_in = (EC_KEY *)((void *)0);
  test_key = (EC_KEY *)((void *)0);
  evp_key = (EVP_PKEY *)((void *)0);
  pkcs8 = (PKCS8_PRIV_KEY_INFO *)((void *)0);
  pkcs8_enc = (X509_SIG *)((void *)0);
  bio = (BIO *)((void *)0);
  res = 0;
  tmp = strlen(pem_in);
  bio = BIO_new_mem_buf((void *)((char *)pem_in), (int )tmp);
  if (! bio) {
    goto out;
  }
  pkcs8_enc = PEM_read_bio_PKCS8(bio, (X509_SIG **)((void *)0), (pem_password_cb *)((void *)0),
                                 (void *)0);
  if (pkcs8_enc) {
    if (! pass) {
      return (-1);
    }
    tmp___0 = strlen(pass);
    pkcs8 = PKCS8_decrypt(pkcs8_enc, pass, (int )tmp___0);
  } else {
    BIO_ctrl(bio, 1, 0L, (void *)0);
    pkcs8 = PEM_read_bio_PKCS8_PRIV_KEY_INFO(bio, (PKCS8_PRIV_KEY_INFO **)((void *)0),
                                             (pem_password_cb *)((void *)0), (void *)0);
  }
  if (! pkcs8) {
    goto out;
  }
  evp_key = EVP_PKCS82PKEY(pkcs8);
  if (! evp_key) {
    goto out;
  }
  pkey_in = EVP_PKEY_get1_EC_KEY(evp_key);
  if (! pkey_in) {
    goto out;
  }
  test_key = EC_KEY_new_by_curve_name(714);
  if (! test_key) {
    goto out;
  } else {
    tmp___1 = EC_KEY_get0_group((EC_KEY const   *)test_key);
    tmp___2 = EC_KEY_get0_group((EC_KEY const   *)pkey_in);
    tmp___3 = EC_GROUP_cmp(tmp___2, tmp___1, (BN_CTX *)((void *)0));
    if (tmp___3) {
      goto out;
    }
  }
  tmp___4 = EC_KEY_copy(pkey, (EC_KEY const   *)pkey_in);
  if (! tmp___4) {
    goto out;
  }
  res = 1;
  out:
  if (bio) {
    BIO_free(bio);
  }
  if (test_key) {
    EC_KEY_free(pkey_in);
  }
  if (evp_key) {
    EVP_PKEY_free(evp_key);
  }
  if (pkcs8) {
    PKCS8_PRIV_KEY_INFO_free(pkcs8);
  }
  if (pkcs8_enc) {
    X509_SIG_free(pkcs8_enc);
  }
  return (res);
}
}
int vg_decode_privkey_any(EC_KEY *pkey , int *addrtype , char const   *input , char const   *pass )
{
  int res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = vg_decode_privkey(input, pkey, addrtype);
  if (tmp) {
    return (1);
  }
  tmp___1 = vg_protect_decode_privkey(pkey, addrtype, input, (char const   *)((void *)0));
  if (tmp___1) {
    if (! pass) {
      return (-1);
    }
    tmp___0 = vg_protect_decode_privkey(pkey, addrtype, input, pass);
    return (tmp___0);
  }
  res = vg_pkcs8_decode_privkey(pkey, input, pass);
  if (res > 0) {
    *addrtype = 128;
  }
  return (res);
}
}
int vg_read_password(char *buf , size_t size )
{
  int tmp ;
  int tmp___0 ;

  {
  tmp = EVP_read_pw_string(buf, (int )size, "Enter new password:", 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return (tmp___0);
}
}
static unsigned char ascii_class[128]  =
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)5,      (unsigned char)4,      (unsigned char)5,      (unsigned char)4,
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)5,
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4,
        (unsigned char)5,      (unsigned char)4,      (unsigned char)5,      (unsigned char)5,
        (unsigned char)3,      (unsigned char)3,      (unsigned char)3,      (unsigned char)3,
        (unsigned char)3,      (unsigned char)3,      (unsigned char)3,      (unsigned char)3,
        (unsigned char)3,      (unsigned char)3,      (unsigned char)5,      (unsigned char)5,
        (unsigned char)5,      (unsigned char)4,      (unsigned char)5,      (unsigned char)5,
        (unsigned char)4,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2,
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2,
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2,
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2,
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2,
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2,
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)5,
        (unsigned char)5,      (unsigned char)5,      (unsigned char)4,      (unsigned char)4,
        (unsigned char)5,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)5,
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)0};
int vg_check_password_complexity(char const   *pass , int verbose )
{
  int i ;
  int len ;
  int classes[6] ;
  unsigned int tmp ;
  char const   *crackunit ;
  int char_complexity ;
  double crackops ;
  double cracktime ;
  int weak ;
  int rate ;
  int weak_threshold ;
  size_t tmp___0 ;
  char const   *tmp___1 ;

  {
  classes[0] = 0;
  tmp = 1U;
  while (! (tmp >= 6U)) {
    classes[tmp] = 0;
    tmp ++;
  }
  crackunit = "seconds";
  char_complexity = 0;
  rate = 250000000;
  weak_threshold = 31536000;
  tmp___0 = strlen(pass);
  len = (int )tmp___0;
  i = 0;
  while (i < len) {
    if ((unsigned long )*(pass + i) > sizeof(ascii_class)) {
      (classes[5]) ++;
    } else
    if (! (! ascii_class[(int )*(pass + i)])) {
      (classes[(int )ascii_class[(int )*(pass + i)] - 1]) ++;
    }
    i ++;
  }
  if (classes[0]) {
    char_complexity += 26;
  }
  if (classes[1]) {
    char_complexity += 26;
  }
  if (classes[2]) {
    char_complexity += 10;
  }
  if (classes[3]) {
    char_complexity += 14;
  }
  if (classes[4]) {
    char_complexity += 19;
  }
  if (classes[5]) {
    char_complexity += 32;
  }
  crackops = pow((double )char_complexity, (double )len);
  cracktime = (crackops * ((double )1 - (double )1 / 2.7182818284590452354)) / (double )rate;
  weak = cracktime < (double )weak_threshold;
  if (cracktime > 60.0) {
    cracktime /= 60.0;
    crackunit = "minutes";
    if (cracktime > 60.0) {
      cracktime /= 60.0;
      crackunit = "hours";
      if (cracktime > 24.0) {
        cracktime /= (double )24;
        crackunit = "days";
        if (cracktime > 365.0) {
          cracktime /= 365.0;
          crackunit = "years";
        }
      }
    }
  }
  if (weak) {
    if (verbose > 0) {
      goto _L___5;
    } else {
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */
  if (verbose > 1) {
    _L___5: /* CIL Label */
    if (cracktime < 1.0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Estimated password crack time: >1 %s\n",
              crackunit);
    } else
    if (cracktime < (double )1000000) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Estimated password crack time: %.1f %s\n",
              cracktime, crackunit);
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Estimated password crack time: %e %s\n",
              cracktime, crackunit);
    }
    if (! classes[0]) {
      if (! classes[1]) {
        if (classes[2]) {
          if (! classes[3]) {
            if (! classes[4]) {
              if (! classes[5]) {
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Password contains only numbers\n");
              } else {
                goto _L___4;
              }
            } else {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else {
          goto _L___4;
        }
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */
    if (! classes[2]) {
      if (! classes[3]) {
        if (! classes[4]) {
          if (! classes[5]) {
            if (! classes[0]) {
              goto _L;
            } else
            if (! classes[1]) {
              _L: /* CIL Label */
              if (classes[0]) {
                tmp___1 = "lower";
              } else {
                tmp___1 = "upper";
              }
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Password contains only %scase letters\n",
                      tmp___1);
            } else {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Password contains only letters\n");
            }
          }
        }
      }
    }
  }
  return (! weak);
}
}
int vg_read_file(FILE *fp , char ***result , int *rescount )
{
  int ret ;
  char **patterns ;
  char *buf ;
  char *obuf ;
  char *pat ;
  int blksize ;
  int nalloc ;
  int npatterns ;
  int count ;
  int pos ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;

  {
  ret = 1;
  buf = (char *)((void *)0);
  blksize = 16384;
  nalloc = 16;
  npatterns = 0;
  tmp = malloc(sizeof(char *) * (unsigned long )nalloc);
  patterns = (char **)tmp;
  count = 0;
  pos = 0;
  while (1) {
    obuf = buf;
    tmp___0 = malloc((size_t )blksize);
    buf = (char *)tmp___0;
    if (! buf) {
      ret = 0;
      break;
    }
    if (pos < count) {
      memcpy((void * __restrict  )buf, (void const   * __restrict  )(obuf + pos),
             (size_t )(count - pos));
    }
    pos = count - pos;
    tmp___1 = fread((void * __restrict  )(buf + pos), (size_t )1, (size_t )(blksize - pos),
                    (FILE * __restrict  )fp);
    count = (int )tmp___1;
    if (count < 0) {
      tmp___2 = __errno_location();
      tmp___3 = strerror(*tmp___2);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error reading file: %s\n",
              tmp___3);
      ret = 0;
    }
    if (count <= 0) {
      break;
    }
    count += pos;
    pat = buf;
    while (pos < count) {
      if ((int )*(buf + pos) == 13) {
        goto _L;
      } else
      if ((int )*(buf + pos) == 10) {
        _L: /* CIL Label */
        *(buf + pos) = (char )'\000';
        if (pat) {
          if (npatterns == nalloc) {
            nalloc *= 2;
            tmp___4 = realloc((void *)patterns, sizeof(char *) * (unsigned long )nalloc);
            patterns = (char **)tmp___4;
          }
          *(patterns + npatterns) = pat;
          npatterns ++;
          pat = (char *)((void *)0);
        }
      } else
      if (! pat) {
        pat = buf + pos;
      }
      pos ++;
    }
    if (pat) {
      pos = (int )(pat - buf);
    } else {
      pos = count;
    }
  }
  *result = patterns;
  *rescount = npatterns;
  return (ret);
}
}
