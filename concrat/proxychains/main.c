/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned short __uint16_t;
typedef unsigned int __uint32_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef long __ssize_t;
typedef unsigned int __socklen_t;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
typedef unsigned long size_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef __builtin_va_list __gnuc_va_list;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __gnuc_va_list va_list___0;
typedef __socklen_t socklen_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
struct sockaddr_in ;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
typedef unsigned long nfds_t;
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
typedef unsigned long uint_fast32_t;
union __anonunion_ip_type_826858479 {
   unsigned char octet[4] ;
   uint32_t as_int ;
};
typedef union __anonunion_ip_type_826858479 ip_type;
struct __anonstruct_string_hash_tuple_67209659 {
   uint32_t hash ;
   char *string ;
};
typedef struct __anonstruct_string_hash_tuple_67209659 string_hash_tuple;
struct __anonstruct_internal_ip_lookup_table_78056353 {
   uint32_t counter ;
   uint32_t capa ;
   string_hash_tuple **list ;
};
typedef struct __anonstruct_internal_ip_lookup_table_78056353 internal_ip_lookup_table;
enum __anonenum_proxy_type_303997851 {
    HTTP_TYPE = 0,
    RAW_TYPE = 1,
    SOCKS4_TYPE = 2,
    SOCKS5_TYPE = 3
} ;
typedef enum __anonenum_proxy_type_303997851 proxy_type;
enum __anonenum_chain_type_847959665 {
    DYNAMIC_TYPE = 0,
    STRICT_TYPE = 1,
    RANDOM_TYPE = 2
} ;
typedef enum __anonenum_chain_type_847959665 chain_type;
enum __anonenum_proxy_state_523521024 {
    PLAY_STATE = 0,
    DOWN_STATE = 1,
    BLOCKED_STATE = 2,
    BUSY_STATE = 3
} ;
typedef enum __anonenum_proxy_state_523521024 proxy_state;
enum __anonenum_select_type_1061206784 {
    RANDOMLY = 0,
    FIFOLY = 1
} ;
typedef enum __anonenum_select_type_1061206784 select_type;
struct __anonstruct_proxy_data_655008577 {
   ip_type ip ;
   unsigned short port ;
   proxy_type pt ;
   proxy_state ps ;
   char user[256] ;
   char pass[256] ;
};
typedef struct __anonstruct_proxy_data_655008577 proxy_data;
struct gethostbyname_data {
   struct hostent hostent_space ;
   in_addr_t resolved_addr ;
   char *resolved_addr_p[2] ;
   char addr_name[8192] ;
};
struct addrinfo_data {
   struct addrinfo addrinfo_space ;
   struct sockaddr sockaddr_space ;
   char addr_name[256] ;
};
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
typedef int pthread_once_t;
struct __anonstruct_localaddr_arg_1073158885 {
   struct in_addr in_addr ;
   struct in_addr netmask ;
   unsigned short port ;
};
typedef struct __anonstruct_localaddr_arg_1073158885 localaddr_arg;
struct __anonstruct_dnat_arg_1073158886 {
   struct in_addr orig_dst ;
   struct in_addr new_dst ;
   unsigned short orig_port ;
   unsigned short new_port ;
};
typedef struct __anonstruct_dnat_arg_1073158886 dnat_arg;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-XMadcckr.i","-Wall,-O2,-g,-std=c99,-pipe,-Werror,-fPIC")
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 


  {
  return ((__uint16_t )((((int )__bsx >> 8) & 255) | (((int )__bsx & 255) << 8)));
}
}
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern int fflush(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) int rand(void) ;
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg ) 
{ 


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
extern struct hostent *gethostent(void) ;
extern int getservbyname_r(char const   * __restrict  __name , char const   * __restrict  __proto ,
                           struct servent * __restrict  __result_buf , char * __restrict  __buf ,
                           size_t __buflen , struct servent ** __restrict  __result ) ;
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   * __restrict  __cp ,
                                                             char * __restrict  __buf ,
                                                             socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int inet_aton(char const   *__cp , struct in_addr *__inp ) ;
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
pthread_mutex_t internal_ips_lock  ;
internal_ip_lookup_table internal_ips ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
int connect_proxy_chain(int sock , ip_type target_ip , unsigned short target_port ,
                        proxy_data *pd , unsigned int proxy_count , chain_type ct ,
                        unsigned int max_chain ) ;
void proxychains_write_log(char *str  , ...) ;
int (*true_connect)(int  , struct sockaddr  const  * , socklen_t  ) ;
struct hostent *proxy_gethostbyname(char const   *name , struct gethostbyname_data *data ) ;
void proxy_getservbyname(char const   *service , struct servent *se_buf , char *buf___0 ,
                         size_t buf_len , struct servent **se_result ) ;
int proxy_getaddrinfo(char const   *node , char const   *service , struct addrinfo  const  *hints ,
                      struct addrinfo **res ) ;
void proxy_freeaddrinfo(struct addrinfo *res ) ;
int tcp_read_time_out ;
int tcp_connect_time_out ;
int proxychains_quiet_mode ;
unsigned int remote_dns_subnet ;
internal_ip_lookup_table internal_ips  =    {(uint32_t )0, (uint32_t )0, (string_hash_tuple **)((void *)0)};
uint32_t dalias_hash(char *s0 ) 
{ 
  unsigned char *s ;
  uint_fast32_t h ;
  unsigned char *tmp ;

  {
  s = (unsigned char *)((void *)s0);
  h = (uint_fast32_t )0;
  while (*s) {
    tmp = s;
    s ++;
    h = 16UL * h + (uint_fast32_t )*tmp;
    h ^= (h >> 24) & 240UL;
  }
  return ((uint32_t )(h & 268435455UL));
}
}
uint32_t index_from_internal_ip(ip_type internalip ) 
{ 
  ip_type tmp ;
  uint32_t ret ;

  {
  tmp = internalip;
  ret = (uint32_t )(((int )tmp.octet[3] + ((int )tmp.octet[2] << 8)) + ((int )tmp.octet[1] << 16));
  ret --;
  return (ret);
}
}
char *string_from_internal_ip(ip_type internalip ) 
{ 
  char *res ;
  uint32_t index___0 ;
  uint32_t tmp ;

  {
  res = (char *)((void *)0);
  tmp = index_from_internal_ip(internalip);
  index___0 = tmp;
  pthread_mutex_lock(& internal_ips_lock);
  if (index___0 < internal_ips.counter) {
    res = (*(internal_ips.list + index___0))->string;
  }
  pthread_mutex_unlock(& internal_ips_lock);
  return (res);
}
}
in_addr_t make_internal_ip(uint32_t index___0 ) 
{ 
  ip_type ret ;

  {
  index___0 ++;
  if (index___0 > 16777215U) {
    return ((in_addr_t )-1);
  }
  ret.octet[0] = (unsigned char )(remote_dns_subnet & 255U);
  ret.octet[1] = (unsigned char )((index___0 & 16711680U) >> 16);
  ret.octet[2] = (unsigned char )((index___0 & 65280U) >> 8);
  ret.octet[3] = (unsigned char )(index___0 & 255U);
  return (ret.as_int);
}
}
static char const   base64[65]  = 
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
static int poll_retry(struct pollfd *fds , nfds_t nfsd , int timeout ) 
{ 
  int ret ;
  int time_remain ;
  int time_elapsed ;
  struct timeval start_time ;
  struct timeval tv ;
  int *tmp ;

  {
  time_remain = timeout;
  time_elapsed = 0;
  gettimeofday((struct timeval * __restrict  )(& start_time), (void * __restrict  )((void *)0));
  while (1) {
    ret = poll(fds, nfsd, time_remain);
    gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
    time_elapsed = (int )(tv.tv_sec - start_time.tv_sec) * 1000 + (int )(tv.tv_usec - start_time.tv_usec) / 1000;
    time_remain = timeout - time_elapsed;
    if (ret == -1) {
      tmp = __errno_location();
      if (*tmp == 4) {
        if (! (time_remain > 0)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
  }
  return (ret);
}
}
static void encode_base_64(char *src , char *dest , int max_len ) 
{ 
  int n ;
  int i ;
  size_t l ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  l = strlen((char const   *)src);
  max_len = (max_len - 1) / 4;
  i = 0;
  while (i < max_len) {
    switch (l) {
    case 0UL: 
    break;
    case 1UL: 
    n = (int )*(src + 0) << 16;
    tmp = dest;
    dest ++;
    *tmp = (char )base64[(n >> 18) & 63];
    tmp___0 = dest;
    dest ++;
    *tmp___0 = (char )base64[(n >> 12) & 63];
    tmp___1 = dest;
    dest ++;
    *tmp___1 = (char )'=';
    tmp___2 = dest;
    dest ++;
    *tmp___2 = (char )'=';
    break;
    case 2UL: 
    n = ((int )*(src + 0) << 16) | ((int )*(src + 1) << 8);
    tmp___3 = dest;
    dest ++;
    *tmp___3 = (char )base64[(n >> 18) & 63];
    tmp___4 = dest;
    dest ++;
    *tmp___4 = (char )base64[(n >> 12) & 63];
    tmp___5 = dest;
    dest ++;
    *tmp___5 = (char )base64[(n >> 6) & 63];
    tmp___6 = dest;
    dest ++;
    *tmp___6 = (char )'=';
    break;
    default: 
    n = (((int )*(src + 0) << 16) | ((int )*(src + 1) << 8)) | (int )*(src + 2);
    tmp___7 = dest;
    dest ++;
    *tmp___7 = (char )base64[(n >> 18) & 63];
    tmp___8 = dest;
    dest ++;
    *tmp___8 = (char )base64[(n >> 12) & 63];
    tmp___9 = dest;
    dest ++;
    *tmp___9 = (char )base64[(n >> 6) & 63];
    tmp___10 = dest;
    dest ++;
    *tmp___10 = (char )base64[n & 63];
    }
    if (l < 3UL) {
      break;
    }
    i ++;
    src += 3;
    l -= 3UL;
  }
  tmp___11 = dest;
  dest ++;
  *tmp___11 = (char)0;
  return;
}
}
void proxychains_write_log(char *str  , ...) 
{ 
  char buff[20480] ;
  va_list___0 arglist ;

  {
  if (! proxychains_quiet_mode) {
    __builtin_va_start(arglist, str);
    vsnprintf((char * __restrict  )(buff), sizeof(buff), (char const   * __restrict  )str,
              arglist);
    __builtin_va_end(arglist);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", buff);
    fflush(stderr);
  }
  return;
}
}
static size_t write_n_bytes(int fd , char *buff , size_t size ) 
{ 
  size_t i ;
  size_t wrote ;
  ssize_t tmp ;

  {
  i = (size_t )0;
  wrote = (size_t )0;
  while (1) {
    tmp = write(fd, (void const   *)(buff + wrote), size - wrote);
    i = (size_t )tmp;
    if (i <= 0UL) {
      return (i);
    }
    wrote += i;
    if (wrote == size) {
      return (wrote);
    }
  }
}
}
static size_t read_n_bytes(int fd , char *buff , size_t size ) 
{ 
  int ready ;
  size_t i ;
  struct pollfd pfd[1] ;
  ssize_t tmp ;

  {
  pfd[0].fd = fd;
  pfd[0].events = (short)1;
  i = (size_t )0;
  while (i < size) {
    pfd[0].revents = (short)0;
    ready = poll_retry(pfd, (nfds_t )1, tcp_read_time_out);
    if (ready != 1) {
      return ((size_t )0);
    } else
    if (! ((int )pfd[0].revents & 1)) {
      return ((size_t )0);
    } else {
      tmp = read(fd, (void *)(buff + i), (size_t )1);
      if (1L != tmp) {
        return ((size_t )0);
      }
    }
    i ++;
  }
  return (size);
}
}
static int timed_connect(int sock , struct sockaddr  const  *addr , socklen_t len ) 
{ 
  int ret ;
  int value ;
  socklen_t value_len ;
  struct pollfd pfd[1] ;
  int *tmp ;

  {
  pfd[0].fd = sock;
  pfd[0].events = (short)4;
  fcntl(sock, 4, 2048);
  ret = (*true_connect)(sock, addr, len);
  while (1) {
    break;
  }
  if (ret == -1) {
    tmp = __errno_location();
    if (*tmp == 115) {
      ret = poll_retry(pfd, (nfds_t )1, tcp_connect_time_out);
      while (1) {
        break;
      }
      if (ret == 1) {
        value_len = (socklen_t )sizeof(socklen_t );
        getsockopt(sock, 1, 4, (void * __restrict  )(& value), (socklen_t * __restrict  )(& value_len));
        while (1) {
          break;
        }
        if (! value) {
          ret = 0;
        } else {
          ret = -1;
        }
      } else {
        ret = -1;
      }
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (ret != 0) {
    ret = -1;
  }
  fcntl(sock, 4, 0);
  return (ret);
}
}
static int tunnel_to(int sock , ip_type ip , unsigned short port , proxy_type pt ,
                     char *user , char *pass ) 
{ 
  char *dns_name ;
  size_t dns_len ;
  size_t ulen ;
  size_t tmp ;
  size_t passlen ;
  size_t tmp___0 ;
  size_t len ;
  unsigned char buff[8192] ;
  char ip_buf[16] ;
  __uint16_t tmp___1 ;
  char src[512] ;
  char dst[2048] ;
  ssize_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char in[2] ;
  char out[515] ;
  char *cur ;
  int c ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t buff_iter ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;

  {
  dns_name = (char *)((void *)0);
  dns_len = (size_t )0;
  while (1) {
    break;
  }
  if ((unsigned int )ip.octet[0] == remote_dns_subnet) {
    dns_name = string_from_internal_ip(ip);
    if (! dns_name) {
      goto err;
    }
    dns_len = strlen((char const   *)dns_name);
    if (! dns_len) {
      goto err;
    }
  }
  while (1) {
    break;
  }
  tmp = strlen((char const   *)user);
  ulen = tmp;
  tmp___0 = strlen((char const   *)pass);
  passlen = tmp___0;
  if (ulen > 255UL) {
    proxychains_write_log((char *)"[proxychains] error: maximum size of 255 for user/pass or domain name!\n");
    goto err;
  } else
  if (passlen > 255UL) {
    proxychains_write_log((char *)"[proxychains] error: maximum size of 255 for user/pass or domain name!\n");
    goto err;
  } else
  if (dns_len > 255UL) {
    proxychains_write_log((char *)"[proxychains] error: maximum size of 255 for user/pass or domain name!\n");
    goto err;
  }
  switch ((unsigned int )pt) {
  case 1U: 
  return (0);
  break;
  case 0U: 
  if (! dns_len) {
    inet_ntop(2, (void const   * __restrict  )(& ip.octet[0]), (char * __restrict  )(ip_buf),
              (socklen_t )sizeof(ip_buf));
    dns_name = ip_buf;
  }
  tmp___1 = __bswap_16(port);
  snprintf((char * __restrict  )((char *)(buff)), sizeof(buff), (char const   * __restrict  )"CONNECT %s:%d HTTP/1.0\r\n",
           dns_name, (int )tmp___1);
  if (*(user + 0)) {
    memcpy((void * __restrict  )(src), (void const   * __restrict  )user, ulen);
    memcpy((void * __restrict  )(src + ulen), (void const   * __restrict  )":", (size_t )1);
    memcpy((void * __restrict  )((src + ulen) + 1), (void const   * __restrict  )pass,
           passlen);
    src[(ulen + 1UL) + passlen] = (char)0;
    encode_base_64(src, dst, (int )sizeof(dst));
    strcat((char * __restrict  )((char *)(buff)), (char const   * __restrict  )"Proxy-Authorization: Basic ");
    strcat((char * __restrict  )((char *)(buff)), (char const   * __restrict  )(dst));
    strcat((char * __restrict  )((char *)(buff)), (char const   * __restrict  )"\r\n\r\n");
  } else {
    strcat((char * __restrict  )((char *)(buff)), (char const   * __restrict  )"\r\n");
  }
  len = strlen((char const   *)((char *)(buff)));
  tmp___2 = send(sock, (void const   *)(buff), len, 0);
  if (len != (size_t )tmp___2) {
    goto err;
  }
  len = (size_t )0;
  while (len < 8192UL) {
    tmp___3 = read_n_bytes(sock, (char *)(buff + len), (size_t )1);
    if (1UL == tmp___3) {
      len ++;
    } else {
      goto err;
    }
    if (len > 4UL) {
      if ((int )buff[len - 1UL] == 10) {
        if ((int )buff[len - 2UL] == 13) {
          if ((int )buff[len - 3UL] == 10) {
            if ((int )buff[len - 4UL] == 13) {
              break;
            }
          }
        }
      }
    }
  }
  if (len == 8192UL) {
    return (5);
  } else
  if ((int )buff[9] == 50) {
    if ((int )buff[10] == 48) {
      if (! ((int )buff[11] == 48)) {
        return (5);
      }
    } else {
      return (5);
    }
  } else {
    return (5);
  }
  return (0);
  break;
  case 2U: 
  buff[0] = (unsigned char)4;
  buff[1] = (unsigned char)1;
  memcpy((void * __restrict  )(& buff[2]), (void const   * __restrict  )(& port),
         (size_t )2);
  if (dns_len) {
    ip.octet[0] = (unsigned char)0;
    ip.octet[1] = (unsigned char)0;
    ip.octet[2] = (unsigned char)0;
    ip.octet[3] = (unsigned char)1;
  }
  memcpy((void * __restrict  )(& buff[4]), (void const   * __restrict  )(& ip), (size_t )4);
  len = ulen + 1UL;
  if (len > 1UL) {
    memcpy((void * __restrict  )(& buff[8]), (void const   * __restrict  )user, len);
  } else {
    buff[8] = (unsigned char)0;
  }
  if (dns_len) {
    memcpy((void * __restrict  )(& buff[8UL + len]), (void const   * __restrict  )dns_name,
           dns_len + 1UL);
    len += dns_len + 1UL;
  }
  tmp___4 = write_n_bytes(sock, (char *)(buff), 8UL + len);
  if (len + 8UL != tmp___4) {
    goto err;
  }
  tmp___5 = read_n_bytes(sock, (char *)(buff), (size_t )8);
  if (8UL != tmp___5) {
    goto err;
  }
  if ((int )buff[0] != 0) {
    return (5);
  } else
  if ((int )buff[1] != 90) {
    return (5);
  }
  return (0);
  break;
  case 3U: 
  if (user) {
    buff[0] = (unsigned char)5;
    buff[1] = (unsigned char)2;
    buff[2] = (unsigned char)0;
    buff[3] = (unsigned char)2;
    tmp___6 = write_n_bytes(sock, (char *)(buff), (size_t )4);
    if (4UL != tmp___6) {
      goto err;
    }
  } else {
    buff[0] = (unsigned char)5;
    buff[1] = (unsigned char)1;
    buff[2] = (unsigned char)0;
    tmp___7 = write_n_bytes(sock, (char *)(buff), (size_t )3);
    if (3UL != tmp___7) {
      goto err;
    }
  }
  tmp___8 = read_n_bytes(sock, (char *)(buff), (size_t )2);
  if (2UL != tmp___8) {
    goto err;
  }
  if ((int )buff[0] != 5) {
    goto _L;
  } else
  if ((int )buff[1] != 0) {
    if ((int )buff[1] != 2) {
      _L: /* CIL Label */ 
      if ((int )buff[0] == 5) {
        if ((int )buff[1] == 255) {
          return (5);
        } else {
          goto err;
        }
      } else {
        goto err;
      }
    }
  }
  if ((int )buff[1] == 2) {
    cur = out;
    tmp___9 = cur;
    cur ++;
    *tmp___9 = (char)1;
    c = (int )(ulen & 255UL);
    tmp___10 = cur;
    cur ++;
    *tmp___10 = (char )c;
    memcpy((void * __restrict  )cur, (void const   * __restrict  )user, (size_t )c);
    cur += c;
    c = (int )(passlen & 255UL);
    tmp___11 = cur;
    cur ++;
    *tmp___11 = (char )c;
    memcpy((void * __restrict  )cur, (void const   * __restrict  )pass, (size_t )c);
    cur += c;
    tmp___12 = write_n_bytes(sock, out, (size_t )(cur - out));
    if ((size_t )(cur - out) != tmp___12) {
      goto err;
    }
    tmp___13 = read_n_bytes(sock, in, (size_t )2);
    if (2UL != tmp___13) {
      goto err;
    }
    if ((int )in[0] != 1) {
      goto _L___0;
    } else
    if ((int )in[1] != 0) {
      _L___0: /* CIL Label */ 
      if ((int )in[0] != 1) {
        goto err;
      } else {
        return (5);
      }
    }
  }
  buff_iter = (size_t )0;
  tmp___14 = buff_iter;
  buff_iter ++;
  buff[tmp___14] = (unsigned char)5;
  tmp___15 = buff_iter;
  buff_iter ++;
  buff[tmp___15] = (unsigned char)1;
  tmp___16 = buff_iter;
  buff_iter ++;
  buff[tmp___16] = (unsigned char)0;
  if (! dns_len) {
    tmp___17 = buff_iter;
    buff_iter ++;
    buff[tmp___17] = (unsigned char)1;
    memcpy((void * __restrict  )(buff + buff_iter), (void const   * __restrict  )(& ip),
           (size_t )4);
    buff_iter += 4UL;
  } else {
    tmp___18 = buff_iter;
    buff_iter ++;
    buff[tmp___18] = (unsigned char)3;
    tmp___19 = buff_iter;
    buff_iter ++;
    buff[tmp___19] = (unsigned char )(dns_len & 255UL);
    memcpy((void * __restrict  )(buff + buff_iter), (void const   * __restrict  )dns_name,
           dns_len);
    buff_iter += dns_len;
  }
  memcpy((void * __restrict  )(buff + buff_iter), (void const   * __restrict  )(& port),
         (size_t )2);
  buff_iter += 2UL;
  tmp___20 = write_n_bytes(sock, (char *)(buff), buff_iter);
  if (buff_iter != tmp___20) {
    goto err;
  }
  tmp___21 = read_n_bytes(sock, (char *)(buff), (size_t )4);
  if (4UL != tmp___21) {
    goto err;
  }
  if ((int )buff[0] != 5) {
    goto err;
  } else
  if ((int )buff[1] != 0) {
    goto err;
  }
  switch ((int )buff[3]) {
  case 1: 
  len = (size_t )4;
  break;
  case 4: 
  len = (size_t )16;
  break;
  case 3: 
  len = (size_t )0;
  tmp___22 = read_n_bytes(sock, (char *)(& len), (size_t )1);
  if (1UL != tmp___22) {
    goto err;
  }
  break;
  default: 
  goto err;
  }
  tmp___23 = read_n_bytes(sock, (char *)(buff), len + 2UL);
  if (len + 2UL != tmp___23) {
    goto err;
  }
  return (0);
  break;
  }
  err: 
  return (2);
}
}
static int start_chain(int *fd , proxy_data *pd , char *begin_mark ) 
{ 
  struct sockaddr_in addr ;
  char ip_buf[16] ;
  __uint16_t tmp ;
  int tmp___0 ;

  {
  *fd = socket(2, 1, 0);
  if (*fd == -1) {
    goto error;
  }
  inet_ntop(2, (void const   * __restrict  )(& pd->ip.octet[0]), (char * __restrict  )(ip_buf),
            (socklen_t )sizeof(ip_buf));
  tmp = __bswap_16(pd->port);
  proxychains_write_log((char *)"[proxychains] %s  ...  %s:%d ", begin_mark, ip_buf,
                        (int )tmp);
  pd->ps = (proxy_state )0;
  memset((void *)(& addr), 0, sizeof(addr));
  addr.sin_family = (sa_family_t )2;
  addr.sin_addr.s_addr = pd->ip.as_int;
  addr.sin_port = pd->port;
  tmp___0 = timed_connect(*fd, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                          (socklen_t )sizeof(addr));
  if (tmp___0) {
    pd->ps = (proxy_state )1;
    goto error1;
  }
  pd->ps = (proxy_state )3;
  return (0);
  error1: 
  proxychains_write_log((char *)" ...  timeout\n");
  error: 
  if (*fd != -1) {
    close(*fd);
  }
  return (2);
}
}
static FILE *fp  ;
unsigned int get_rand_int(unsigned int range ) 
{ 
  unsigned int randval ;
  time_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  if (! fp) {
    fp = fopen((char const   * __restrict  )"/dev/urandom", (char const   * __restrict  )"r");
  }
  tmp___1 = fread((void * __restrict  )(& randval), sizeof(randval), (size_t )1, (FILE * __restrict  )fp);
  if (tmp___1) {
    return (randval % range);
  } else {
    tmp = time((time_t *)((void *)0));
    srand((unsigned int )tmp);
    tmp___0 = rand();
    return ((unsigned int )tmp___0 % range);
  }
}
}
static proxy_data *select_proxy(select_type how , proxy_data *pd , unsigned int proxy_count ,
                                unsigned int *offset ) 
{ 
  unsigned int i ;
  unsigned int k ;
  unsigned int tmp ;
  proxy_data *tmp___0 ;

  {
  i = 0U;
  k = 0U;
  if (*offset >= proxy_count) {
    return ((proxy_data *)((void *)0));
  }
  switch ((unsigned int )how) {
  case 0U: 
  while (1) {
    k ++;
    tmp = get_rand_int(proxy_count);
    i = tmp;
    if ((unsigned int )(pd + i)->ps != 0U) {
      if (! (k < proxy_count * 100U)) {
        break;
      }
    } else {
      break;
    }
  }
  break;
  case 1U: 
  i = *offset;
  while (i < proxy_count) {
    if ((unsigned int )(pd + i)->ps == 0U) {
      *offset = i;
      break;
    }
    i ++;
  }
  default: 
  break;
  }
  if (i >= proxy_count) {
    i = 0U;
  }
  if ((unsigned int )(pd + i)->ps == 0U) {
    tmp___0 = pd + i;
  } else {
    tmp___0 = (proxy_data *)((void *)0);
  }
  return (tmp___0);
}
}
static void release_all(proxy_data *pd , unsigned int proxy_count ) 
{ 
  unsigned int i ;

  {
  i = 0U;
  while (i < proxy_count) {
    (pd + i)->ps = (proxy_state )0;
    i ++;
  }
  return;
}
}
static void release_busy(proxy_data *pd , unsigned int proxy_count ) 
{ 
  unsigned int i ;

  {
  i = 0U;
  while (i < proxy_count) {
    if ((unsigned int )(pd + i)->ps == 3U) {
      (pd + i)->ps = (proxy_state )0;
    }
    i ++;
  }
  return;
}
}
static unsigned int calc_alive(proxy_data *pd , unsigned int proxy_count ) 
{ 
  unsigned int i ;
  unsigned int alive_count ;

  {
  alive_count = 0U;
  release_busy(pd, proxy_count);
  i = 0U;
  while (i < proxy_count) {
    if ((unsigned int )(pd + i)->ps == 0U) {
      alive_count ++;
    }
    i ++;
  }
  return (alive_count);
}
}
static int chain_step(int ns , proxy_data *pfrom , proxy_data *pto ) 
{ 
  int retcode ;
  char *hostname___0 ;
  char ip_buf[16] ;
  __uint16_t tmp ;

  {
  retcode = -1;
  while (1) {
    break;
  }
  if ((unsigned int )pto->ip.octet[0] == remote_dns_subnet) {
    hostname___0 = string_from_internal_ip(pto->ip);
    if (! hostname___0) {
      goto usenumericip;
    }
  } else {
    usenumericip: 
    inet_ntop(2, (void const   * __restrict  )(& pto->ip.octet[0]), (char * __restrict  )(ip_buf),
              (socklen_t )sizeof(ip_buf));
    hostname___0 = ip_buf;
  }
  tmp = __bswap_16(pto->port);
  proxychains_write_log((char *)" ...  %s:%d ", hostname___0, (int )tmp);
  retcode = tunnel_to(ns, pto->ip, pto->port, pfrom->pt, pfrom->user, pfrom->pass);
  switch (retcode) {
  case 0: 
  pto->ps = (proxy_state )3;
  break;
  case 5: 
  pto->ps = (proxy_state )2;
  proxychains_write_log((char *)"<--denied\n");
  close(ns);
  break;
  case 2: 
  pto->ps = (proxy_state )1;
  proxychains_write_log((char *)"<--socket error or timeout!\n");
  close(ns);
  break;
  }
  return (retcode);
}
}
int connect_proxy_chain(int sock , ip_type target_ip , unsigned short target_port ,
                        proxy_data *pd , unsigned int proxy_count , chain_type ct ,
                        unsigned int max_chain ) 
{ 
  proxy_data p4 ;
  proxy_data *p1 ;
  proxy_data *p2 ;
  proxy_data *p3 ;
  int ns ;
  unsigned int offset ;
  unsigned int alive_count ;
  unsigned int curr_len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
  ns = -1;
  offset = 0U;
  alive_count = 0U;
  curr_len = 0U;
  p3 = & p4;
  while (1) {
    break;
  }
  again: 
  switch ((unsigned int )ct) {
  case 0U: 
  calc_alive(pd, proxy_count);
  offset = 0U;
  while (1) {
    p1 = select_proxy((select_type )1, pd, proxy_count, & offset);
    if (! p1) {
      goto error_more;
    }
    tmp = start_chain(& ns, p1, (char *)"Dynamic chain");
    if (0 != tmp) {
      if (! (offset < proxy_count)) {
        break;
      }
    } else {
      break;
    }
  }
  while (1) {
    p2 = select_proxy((select_type )1, pd, proxy_count, & offset);
    if (! p2) {
      break;
    }
    tmp___0 = chain_step(ns, p1, p2);
    if (0 != tmp___0) {
      while (1) {
        break;
      }
      goto again;
    }
    p1 = p2;
  }
  p3->ip = target_ip;
  p3->port = target_port;
  tmp___1 = chain_step(ns, p1, p3);
  if (0 != tmp___1) {
    goto error;
  }
  break;
  case 1U: 
  calc_alive(pd, proxy_count);
  offset = 0U;
  p1 = select_proxy((select_type )1, pd, proxy_count, & offset);
  if (! p1) {
    while (1) {
      break;
    }
    goto error_strict;
  }
  tmp___2 = start_chain(& ns, p1, (char *)"Strict chain");
  if (0 != tmp___2) {
    while (1) {
      break;
    }
    goto error_strict;
  }
  while (offset < proxy_count) {
    p2 = select_proxy((select_type )1, pd, proxy_count, & offset);
    if (! p2) {
      break;
    }
    tmp___3 = chain_step(ns, p1, p2);
    if (0 != tmp___3) {
      while (1) {
        break;
      }
      goto error_strict;
    }
    p1 = p2;
  }
  p3->ip = target_ip;
  p3->port = target_port;
  tmp___4 = chain_step(ns, p1, p3);
  if (0 != tmp___4) {
    goto error;
  }
  break;
  case 2U: 
  alive_count = calc_alive(pd, proxy_count);
  if (alive_count < max_chain) {
    goto error_more;
  }
  offset = 0U;
  curr_len = offset;
  while (1) {
    p1 = select_proxy((select_type )0, pd, proxy_count, & offset);
    if (! p1) {
      goto error_more;
    }
    tmp___5 = start_chain(& ns, p1, (char *)"Random chain");
    if (0 != tmp___5) {
      if (! (offset < max_chain)) {
        break;
      }
    } else {
      break;
    }
  }
  while (1) {
    curr_len ++;
    if (! (curr_len < max_chain)) {
      break;
    }
    p2 = select_proxy((select_type )0, pd, proxy_count, & offset);
    if (! p2) {
      goto error_more;
    }
    tmp___6 = chain_step(ns, p1, p2);
    if (0 != tmp___6) {
      while (1) {
        break;
      }
      goto again;
    }
    p1 = p2;
  }
  p3->ip = target_ip;
  p3->port = target_port;
  tmp___7 = chain_step(ns, p1, p3);
  if (0 != tmp___7) {
    goto error;
  }
  }
  proxychains_write_log((char *)" ...  OK\n");
  dup2(ns, sock);
  close(ns);
  return (0);
  error: 
  if (ns != -1) {
    close(ns);
  }
  tmp___8 = __errno_location();
  *tmp___8 = 111;
  return (-1);
  error_more: 
  proxychains_write_log((char *)"\n!!!need more proxies!!!\n");
  error_strict: 
  while (1) {
    break;
  }
  release_all(pd, proxy_count);
  if (ns != -1) {
    close(ns);
  }
  tmp___9 = __errno_location();
  *tmp___9 = 110;
  return (-1);
}
}
static union __anonunion_ip_type_826858479  const  local_host  =    {{(unsigned char)127, (unsigned char)0, (unsigned char)0, (unsigned char)1}};
char hostname[256]  ;
struct hostent *proxy_gethostbyname(char const   *name , struct gethostbyname_data *data ) 
{ 
  char buff[256] ;
  uint32_t i ;
  uint32_t hash ;
  void *new_mem ;
  size_t l ;
  struct hostent *hp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  data->resolved_addr_p[0] = (char *)(& data->resolved_addr);
  data->resolved_addr_p[1] = (char *)((void *)0);
  data->hostent_space.h_addr_list = data->resolved_addr_p;
  data->resolved_addr = (in_addr_t )0;
  gethostname(buff, sizeof(buff));
  tmp = strcmp((char const   *)(buff), name);
  if (! tmp) {
    data->resolved_addr = inet_addr((char const   *)(buff));
    if (data->resolved_addr == 4294967295U) {
      data->resolved_addr = (in_addr_t )local_host.as_int;
    }
    snprintf((char * __restrict  )(hostname), sizeof(hostname), (char const   * __restrict  )"%s",
             name);
    data->hostent_space.h_name = hostname;
    data->hostent_space.h_length = (int )sizeof(in_addr_t );
    data->hostent_space.h_addrtype = 2;
    return (& data->hostent_space);
  }
  memset((void *)(buff), 0, sizeof(buff));
  while (1) {
    hp = gethostent();
    if (! hp) {
      break;
    }
    tmp___0 = strcmp((char const   *)hp->h_name, name);
    if (! tmp___0) {
      return (hp);
    }
  }
  hash = dalias_hash((char *)name);
  pthread_mutex_lock(& internal_ips_lock);
  if (internal_ips.counter) {
    i = (uint32_t )0;
    while (i < internal_ips.counter) {
      if ((*(internal_ips.list + i))->hash == hash) {
        tmp___1 = strcmp(name, (char const   *)(*(internal_ips.list + i))->string);
        if (! tmp___1) {
          data->resolved_addr = make_internal_ip(i);
          while (1) {
            break;
          }
          goto have_ip;
        }
      }
      i ++;
    }
  }
  if (internal_ips.capa < internal_ips.counter + 1U) {
    while (1) {
      break;
    }
    new_mem = realloc((void *)internal_ips.list, (unsigned long )(internal_ips.capa + 16U) * sizeof(void *));
    if (new_mem) {
      internal_ips.capa += 16U;
      internal_ips.list = (string_hash_tuple **)new_mem;
    } else {
      oom: 
      proxychains_write_log((char *)"out of mem\n");
      goto err_plus_unlock;
    }
  }
  data->resolved_addr = make_internal_ip(internal_ips.counter);
  if (data->resolved_addr == 4294967295U) {
    goto err_plus_unlock;
  }
  l = strlen(name);
  new_mem = malloc((sizeof(string_hash_tuple ) + l) + 1UL);
  if (! new_mem) {
    goto oom;
  }
  while (1) {
    break;
  }
  *(internal_ips.list + internal_ips.counter) = (string_hash_tuple *)new_mem;
  (*(internal_ips.list + internal_ips.counter))->hash = hash;
  (*(internal_ips.list + internal_ips.counter))->string = (char *)new_mem + sizeof(string_hash_tuple );
  memcpy((void * __restrict  )(*(internal_ips.list + internal_ips.counter))->string,
         (void const   * __restrict  )name, l + 1UL);
  (internal_ips.counter) ++;
  have_ip: 
  pthread_mutex_unlock(& internal_ips_lock);
  strncpy((char * __restrict  )(data->addr_name), (char const   * __restrict  )name,
          sizeof(data->addr_name) - 1UL);
  data->hostent_space.h_name = data->addr_name;
  data->hostent_space.h_length = (int )sizeof(in_addr_t );
  data->hostent_space.h_addrtype = 2;
  return (& data->hostent_space);
  err_plus_unlock: 
  pthread_mutex_unlock(& internal_ips_lock);
  return ((struct hostent *)((void *)0));
}
}
void proxy_freeaddrinfo(struct addrinfo *res ) 
{ 


  {
  free((void *)res);
  return;
}
}
void proxy_getservbyname(char const   *service , struct servent *se_buf , char *buf___0 ,
                         size_t buf_len , struct servent **se_result ) 
{ 


  {
  getservbyname_r((char const   * __restrict  )service, (char const   * __restrict  )((void *)0),
                  (struct servent * __restrict  )se_buf, (char * __restrict  )buf___0,
                  buf_len, (struct servent ** __restrict  )se_result);
  return;
}
}
int proxy_getaddrinfo(char const   *node , char const   *service , struct addrinfo  const  *hints ,
                      struct addrinfo **res ) 
{ 
  struct gethostbyname_data ghdata ;
  struct addrinfo_data *space ;
  struct servent *se ;
  struct hostent *hp ;
  struct servent se_buf ;
  struct addrinfo *p ;
  char buf___0[1024] ;
  int port ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  __uint16_t tmp___3 ;
  sa_family_t tmp___4 ;

  {
  se = (struct servent *)((void *)0);
  hp = (struct hostent *)((void *)0);
  tmp = calloc((size_t )1, sizeof(struct addrinfo_data ));
  space = (struct addrinfo_data *)tmp;
  if (! space) {
    return (1);
  }
  if (node) {
    tmp___0 = inet_aton(node, & ((struct sockaddr_in *)(& space->sockaddr_space))->sin_addr);
    if (! tmp___0) {
      hp = proxy_gethostbyname(node, & ghdata);
      if (hp) {
        memcpy((void * __restrict  )(& ((struct sockaddr_in *)(& space->sockaddr_space))->sin_addr),
               (void const   * __restrict  )*(hp->h_addr_list), sizeof(in_addr_t ));
      } else {
        free((void *)space);
        return (1);
      }
    }
  }
  if (service) {
    proxy_getservbyname(service, & se_buf, buf___0, sizeof(buf___0), & se);
  }
  if (se) {
    port = se->s_port;
  } else {
    if (service) {
      tmp___1 = service;
    } else {
      tmp___1 = "0";
    }
    tmp___2 = atoi(tmp___1);
    tmp___3 = __bswap_16((uint16_t )tmp___2);
    port = (int )tmp___3;
  }
  ((struct sockaddr_in *)(& space->sockaddr_space))->sin_port = (in_port_t )port;
  p = & space->addrinfo_space;
  *res = p;
  if (! ((size_t )p == (size_t )space)) {
    __assert_fail("(size_t)p == (size_t) space", "src/core.c", 913U, "proxy_getaddrinfo");
  }
  p->ai_addr = & space->sockaddr_space;
  if (node) {
    strncpy((char * __restrict  )(space->addr_name), (char const   * __restrict  )node,
            sizeof(space->addr_name) - 1UL);
  }
  p->ai_canonname = space->addr_name;
  p->ai_next = (struct addrinfo *)((void *)0);
  tmp___4 = (sa_family_t )2;
  space->sockaddr_space.sa_family = tmp___4;
  p->ai_family = (int )tmp___4;
  p->ai_addrlen = (socklen_t )sizeof(space->sockaddr_space);
  if (hints) {
    p->ai_socktype = (int )hints->ai_socktype;
    p->ai_flags = (int )hints->ai_flags;
    p->ai_protocol = (int )hints->ai_protocol;
  } else {
    p->ai_flags = 32;
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-ycbYswGu.i","-Wall,-O2,-g,-std=c99,-pipe,-Werror,-fPIC")
char *get_config_path(char *default_path , char *pbuf , size_t bufsize ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
extern void perror(char const   *__s ) ;
static int check_path(char *path ) 
{ 
  int tmp ;

  {
  if (! path) {
    return (0);
  }
  tmp = access((char const   *)path, 4);
  return (tmp != -1);
}
}
char *get_config_path(char *default_path , char *pbuf , size_t bufsize ) 
{ 
  char buf___0[512] ;
  char *path ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  path = default_path;
  tmp = check_path(path);
  if (tmp) {
    return (path);
  }
  if (! pbuf) {
    goto err;
  }
  path = getenv("PROXYCHAINS_CONF_FILE");
  tmp___0 = check_path(path);
  if (tmp___0) {
    return (path);
  }
  path = getcwd(buf___0, sizeof(buf___0));
  snprintf((char * __restrict  )pbuf, bufsize, (char const   * __restrict  )"%s/%s",
           path, "proxychains.conf");
  path = pbuf;
  tmp___1 = check_path(path);
  if (tmp___1) {
    return (path);
  }
  path = getenv("HOME");
  snprintf((char * __restrict  )pbuf, bufsize, (char const   * __restrict  )"%s/.proxychains/%s",
           path, "proxychains.conf");
  path = pbuf;
  tmp___2 = check_path(path);
  if (tmp___2) {
    return (path);
  }
  path = (char *)"/usr/local/etc/proxychains.conf";
  tmp___3 = check_path(path);
  if (tmp___3) {
    return (path);
  }
  path = (char *)"/etc/proxychains.conf";
  tmp___4 = check_path(path);
  if (tmp___4) {
    return (path);
  }
  err: 
  perror("couldnt find configuration file");
  exit(1);
}
}
#pragma merger("0","/tmp/cil-gjyc2UWi.i","-Wall,-O2,-g,-std=c99,-pipe,-Werror,-fPIC")
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 


  {
  return (((((__bsx & 4278190080U) >> 24) | ((__bsx & 16711680U) >> 8)) | ((__bsx & 65280U) << 8)) | ((__bsx & 255U) << 24));
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2))) dlsym)(void * __restrict  __handle ,
                                                                                    char const   * __restrict  __name ) ;
extern  __attribute__((__nothrow__)) char *dlerror(void) ;
int connect(int sock , struct sockaddr  const  * __restrict  addr , socklen_t len ) ;
struct hostent *gethostbyaddr(void const   *addr , __socklen_t len , int type ) ;
struct hostent *gethostbyname(char const   *name ) ;
int getaddrinfo(char const   * __restrict  node , char const   * __restrict  service ,
                struct addrinfo  const  * __restrict  hints , struct addrinfo ** __restrict  res ) ;
 __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *res ) ;
int getnameinfo(struct sockaddr  const  * __restrict  sa , socklen_t salen , char * __restrict  host ,
                socklen_t hostlen , char * __restrict  serv , socklen_t servlen ,
                int flags ) ;
extern int fclose(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int inet_pton(int __af , char const   * __restrict  __cp ,
                                                   void * __restrict  __buf ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *__once_control ,
                                                             void (*__init_routine)(void) ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
int (*true_connect)(int  , struct sockaddr  const  * , socklen_t  )  ;
struct hostent *(*true_gethostbyname)(char const   * )  ;
int (*true_getaddrinfo)(char const   * , char const   * , struct addrinfo  const  * ,
                        struct addrinfo ** )  ;
int (*true_freeaddrinfo)(struct addrinfo * )  ;
int (*true_getnameinfo)(struct sockaddr  const  * , socklen_t  , char * , socklen_t  ,
                        char * , socklen_t  , int  )  ;
struct hostent *(*true_gethostbyaddr)(void const   * , socklen_t  , int  )  ;
int tcp_read_time_out  ;
int tcp_connect_time_out  ;
int proxychains_got_chain_data  =    0;
int proxychains_quiet_mode  =    0;
int proxychains_resolver  =    0;
unsigned int proxychains_proxy_count  =    0U;
unsigned int proxychains_max_chain  =    1U;
unsigned int remote_dns_subnet  =    224U;
localaddr_arg localnet_addr[64]  ;
chain_type proxychains_ct  ;
proxy_data proxychains_pd[512]  ;
size_t num_localnet_addr  =    (size_t )0;
dnat_arg dnats[64]  ;
size_t num_dnats  =    (size_t )0;
pthread_once_t init_once  =    0;
static int init_l  =    0;
static void load_default_settings(chain_type *ct ) ;
static void get_chain_data(proxy_data *pd , unsigned int *proxy_count , chain_type *ct ) ;
static void simple_socks5_env(proxy_data *pd , unsigned int *proxy_count , chain_type *ct ) ;
static void *load_sym(char *symname , void *proxyfunc ) 
{ 
  void *funcptr ;
  void *tmp ;
  char *tmp___0 ;

  {
  tmp = dlsym((void * __restrict  )((void *)-1L), (char const   * __restrict  )symname);
  funcptr = tmp;
  if (! funcptr) {
    tmp___0 = dlerror();
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Cannot load symbol \'%s\' %s\n",
            symname, tmp___0);
    exit(1);
  } else {
    while (1) {
      break;
    }
  }
  if ((unsigned long )funcptr == (unsigned long )proxyfunc) {
    while (1) {
      break;
    }
    abort();
  }
  return (funcptr);
}
}
static void do_init(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  pthread_mutex_init(& internal_ips_lock, (pthread_mutexattr_t const   *)((void *)0));
  simple_socks5_env(proxychains_pd, & proxychains_proxy_count, & proxychains_ct);
  get_chain_data(proxychains_pd, & proxychains_proxy_count, & proxychains_ct);
  proxychains_write_log((char *)"[proxychains] DLL init\n");
  while (1) {
    tmp = load_sym((char *)"connect", (void *)(& connect));
    true_connect = (int (*)(int  , struct sockaddr  const  * , socklen_t  ))tmp;
    break;
  }
  while (1) {
    tmp___0 = load_sym((char *)"gethostbyname", (void *)(& gethostbyname));
    true_gethostbyname = (struct hostent *(*)(char const   * ))tmp___0;
    break;
  }
  while (1) {
    tmp___1 = load_sym((char *)"getaddrinfo", (void *)(& getaddrinfo));
    true_getaddrinfo = (int (*)(char const   * , char const   * , struct addrinfo  const  * ,
                                struct addrinfo ** ))tmp___1;
    break;
  }
  while (1) {
    tmp___2 = load_sym((char *)"freeaddrinfo", (void *)(& freeaddrinfo));
    true_freeaddrinfo = (int (*)(struct addrinfo * ))tmp___2;
    break;
  }
  while (1) {
    tmp___3 = load_sym((char *)"gethostbyaddr", (void *)(& gethostbyaddr));
    true_gethostbyaddr = (struct hostent *(*)(void const   * , socklen_t  , int  ))tmp___3;
    break;
  }
  while (1) {
    tmp___4 = load_sym((char *)"getnameinfo", (void *)(& getnameinfo));
    true_getnameinfo = (int (*)(struct sockaddr  const  * , socklen_t  , char * ,
                                socklen_t  , char * , socklen_t  , int  ))tmp___4;
    break;
  }
  init_l = 1;
  return;
}
}
static void init_lib_wrapper(char const   *caller ) 
{ 


  {
  if (! init_l) {
    while (1) {
      break;
    }
  }
  pthread_once(& init_once, & do_init);
  return;
}
}
static void gcc_init(void)  __attribute__((__constructor__)) ;
static void gcc_init(void) 
{ 


  {
  init_lib_wrapper("gcc_init");
  return;
}
}
FILE *open_config_file(void) 
{ 
  char home_conf[4096] ;
  char prefix_conf[4096] ;
  FILE *file ;
  char *tmp ;

  {
  tmp = getenv("HOME");
  snprintf((char * __restrict  )(home_conf), (size_t )256, (char const   * __restrict  )"%s/.proxychains/proxychains.conf",
           tmp);
  snprintf((char * __restrict  )(prefix_conf), (size_t )256, (char const   * __restrict  )"%s/etc/proxychains.conf",
           "/usr/local");
  file = fopen((char const   * __restrict  )"./proxychains.conf", (char const   * __restrict  )"r");
  if (! file) {
    file = fopen((char const   * __restrict  )(home_conf), (char const   * __restrict  )"r");
    if (! file) {
      file = fopen((char const   * __restrict  )(prefix_conf), (char const   * __restrict  )"r");
      if (! file) {
        file = fopen((char const   * __restrict  )"/etc/proxychains.conf", (char const   * __restrict  )"r");
        if (! file) {
          perror("Can\'t locate proxychains.conf");
          exit(1);
        }
      }
    }
  }
  return (file);
}
}
static void load_default_settings(chain_type *ct ) 
{ 
  char *env ;

  {
  tcp_read_time_out = 4000;
  tcp_connect_time_out = 10000;
  *ct = (chain_type )0;
  env = getenv("PROXYCHAINS_QUIET_MODE");
  if (env) {
    if ((int )*env == 49) {
      proxychains_quiet_mode = 1;
    }
  }
  return;
}
}
static void get_chain_data(proxy_data *pd , unsigned int *proxy_count , chain_type *ct ) 
{ 
  unsigned int count ;
  int port_n ;
  int list___0 ;
  char buff[1024] ;
  char type[1024] ;
  char host[1024] ;
  char user[1024] ;
  char *env ;
  char local_in_addr_port[32] ;
  char local_in_addr[32] ;
  char local_in_port[32] ;
  char local_netmask[32] ;
  char dnat_orig_addr_port[32] ;
  char dnat_new_addr_port[32] ;
  char dnat_orig_addr[32] ;
  char dnat_orig_port[32] ;
  char dnat_new_addr[32] ;
  char dnat_new_port[32] ;
  FILE *file ;
  char *tmp ;
  in_addr_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int error ;
  int tmp___7 ;
  char *pc ;
  int len ;
  int tmp___8 ;
  int tmp___9 ;
  int error___0 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  size_t tmp___24 ;
  char *tmp___25 ;

  {
  count = 0U;
  port_n = 0;
  list___0 = 0;
  file = (FILE *)((void *)0);
  if (proxychains_got_chain_data) {
    return;
  }
  load_default_settings(ct);
  tmp = getenv("PROXYCHAINS_CONF_FILE");
  env = get_config_path(tmp, buff, sizeof(buff));
  file = fopen((char const   * __restrict  )env, (char const   * __restrict  )"r");
  while (1) {
    tmp___25 = fgets((char * __restrict  )(buff), (int )sizeof(buff), (FILE * __restrict  )file);
    if (! tmp___25) {
      break;
    }
    if ((int )buff[0] != 10) {
      tmp___24 = strspn((char const   *)(buff), " ");
      if ((int )buff[tmp___24] != 35) {
        if (list___0) {
          if (count >= 512U) {
            break;
          }
          memset((void *)(pd + count), 0, sizeof(proxy_data ));
          (pd + count)->ps = (proxy_state )0;
          port_n = 0;
          sscanf((char const   * __restrict  )(buff), (char const   * __restrict  )"%s %s %d %s %s",
                 type, host, & port_n, (pd + count)->user, (pd + count)->pass);
          tmp___0 = inet_addr((char const   *)(host));
          (pd + count)->ip.as_int = tmp___0;
          (pd + count)->port = __bswap_16((unsigned short )port_n);
          tmp___4 = strcmp((char const   *)(type), "http");
          if (tmp___4) {
            tmp___3 = strcmp((char const   *)(type), "raw");
            if (tmp___3) {
              tmp___2 = strcmp((char const   *)(type), "socks4");
              if (tmp___2) {
                tmp___1 = strcmp((char const   *)(type), "socks5");
                if (tmp___1) {
                  continue;
                } else {
                  (pd + count)->pt = (proxy_type )3;
                }
              } else {
                (pd + count)->pt = (proxy_type )2;
              }
            } else {
              (pd + count)->pt = (proxy_type )1;
            }
          } else {
            (pd + count)->pt = (proxy_type )0;
          }
          if ((pd + count)->ip.as_int) {
            if (port_n) {
              if ((pd + count)->ip.as_int != 4294967295U) {
                count ++;
              }
            }
          }
        } else {
          tmp___23 = strstr((char const   *)(buff), "[ProxyList]");
          if (tmp___23) {
            list___0 = 1;
          } else {
            tmp___22 = strstr((char const   *)(buff), "random_chain");
            if (tmp___22) {
              *ct = (chain_type )2;
            } else {
              tmp___21 = strstr((char const   *)(buff), "strict_chain");
              if (tmp___21) {
                *ct = (chain_type )1;
              } else {
                tmp___20 = strstr((char const   *)(buff), "dynamic_chain");
                if (tmp___20) {
                  *ct = (chain_type )0;
                } else {
                  tmp___19 = strstr((char const   *)(buff), "tcp_read_time_out");
                  if (tmp___19) {
                    sscanf((char const   * __restrict  )(buff), (char const   * __restrict  )"%s %d",
                           user, & tcp_read_time_out);
                  } else {
                    tmp___18 = strstr((char const   *)(buff), "tcp_connect_time_out");
                    if (tmp___18) {
                      sscanf((char const   * __restrict  )(buff), (char const   * __restrict  )"%s %d",
                             user, & tcp_connect_time_out);
                    } else {
                      tmp___17 = strstr((char const   *)(buff), "remote_dns_subnet");
                      if (tmp___17) {
                        sscanf((char const   * __restrict  )(buff), (char const   * __restrict  )"%s %d",
                               user, & remote_dns_subnet);
                        if (remote_dns_subnet >= 256U) {
                          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"remote_dns_subnet: invalid value. requires a number between 0 and 255.\n");
                          exit(1);
                        }
                      } else {
                        tmp___16 = strstr((char const   *)(buff), "localnet");
                        if (tmp___16) {
                          tmp___5 = sscanf((char const   * __restrict  )(buff), (char const   * __restrict  )"%s %21[^/]/%15s",
                                           user, local_in_addr_port, local_netmask);
                          if (tmp___5 < 3) {
                            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"localnet format error");
                            exit(1);
                          }
                          memset((void *)(local_in_port), 0, sizeof(local_in_port) / sizeof(local_in_port[0]));
                          tmp___6 = sscanf((char const   * __restrict  )(local_in_addr_port),
                                           (char const   * __restrict  )"%15[^:]:%5s",
                                           local_in_addr, local_in_port);
                          if (tmp___6 < 2) {
                            while (1) {
                              break;
                            }
                          } else {
                            while (1) {
                              break;
                            }
                          }
                          if (num_localnet_addr < 64UL) {
                            error = inet_pton(2, (char const   * __restrict  )(local_in_addr),
                                              (void * __restrict  )(& localnet_addr[num_localnet_addr].in_addr));
                            if (error <= 0) {
                              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"localnet address error\n");
                              exit(1);
                            }
                            error = inet_pton(2, (char const   * __restrict  )(local_netmask),
                                              (void * __restrict  )(& localnet_addr[num_localnet_addr].netmask));
                            if (error <= 0) {
                              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"localnet netmask error\n");
                              exit(1);
                            }
                            if (local_in_port[0]) {
                              tmp___7 = atoi((char const   *)(local_in_port));
                              localnet_addr[num_localnet_addr].port = (unsigned short )tmp___7;
                            } else {
                              localnet_addr[num_localnet_addr].port = (unsigned short)0;
                            }
                            num_localnet_addr ++;
                          } else {
                            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"# of localnet exceed %d.\n",
                                    64);
                          }
                        } else {
                          tmp___15 = strstr((char const   *)(buff), "chain_len");
                          if (tmp___15) {
                            pc = strchr((char const   *)(buff), '=');
                            pc ++;
                            len = atoi((char const   *)pc);
                            if (len) {
                              tmp___8 = len;
                            } else {
                              tmp___8 = 1;
                            }
                            proxychains_max_chain = (unsigned int )tmp___8;
                          } else {
                            tmp___14 = strstr((char const   *)(buff), "quiet_mode");
                            if (tmp___14) {
                              proxychains_quiet_mode = 1;
                            } else {
                              tmp___13 = strstr((char const   *)(buff), "proxy_dns");
                              if (tmp___13) {
                                proxychains_resolver = 1;
                              } else {
                                tmp___12 = strstr((char const   *)(buff), "dnat");
                                if (tmp___12) {
                                  tmp___9 = sscanf((char const   * __restrict  )(buff),
                                                   (char const   * __restrict  )"%s %21[^ ] %21s\n",
                                                   user, dnat_orig_addr_port, dnat_new_addr_port);
                                  if (tmp___9 < 3) {
                                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"dnat format error");
                                    exit(1);
                                  }
                                  memset((void *)(dnat_orig_port), 0, sizeof(dnat_orig_port) / sizeof(dnat_orig_port[0]));
                                  memset((void *)(dnat_new_port), 0, sizeof(dnat_new_port) / sizeof(dnat_new_port[0]));
                                  sscanf((char const   * __restrict  )(dnat_orig_addr_port),
                                         (char const   * __restrict  )"%15[^:]:%5s",
                                         dnat_orig_addr, dnat_orig_port);
                                  sscanf((char const   * __restrict  )(dnat_new_addr_port),
                                         (char const   * __restrict  )"%15[^:]:%5s",
                                         dnat_new_addr, dnat_new_port);
                                  if (num_dnats < 64UL) {
                                    error___0 = inet_pton(2, (char const   * __restrict  )(dnat_orig_addr),
                                                          (void * __restrict  )(& dnats[num_dnats].orig_dst));
                                    if (error___0 <= 0) {
                                      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"dnat original destination address error\n");
                                      exit(1);
                                    }
                                    error___0 = inet_pton(2, (char const   * __restrict  )(dnat_new_addr),
                                                          (void * __restrict  )(& dnats[num_dnats].new_dst));
                                    if (error___0 <= 0) {
                                      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"dnat effective destination address error\n");
                                      exit(1);
                                    }
                                    if (dnat_orig_port[0]) {
                                      tmp___10 = atoi((char const   *)(dnat_orig_port));
                                      dnats[num_dnats].orig_port = (unsigned short )tmp___10;
                                    } else {
                                      dnats[num_dnats].orig_port = (unsigned short)0;
                                    }
                                    if (dnat_new_port[0]) {
                                      tmp___11 = atoi((char const   *)(dnat_new_port));
                                      dnats[num_dnats].new_port = (unsigned short )tmp___11;
                                    } else {
                                      dnats[num_dnats].new_port = (unsigned short)0;
                                    }
                                    while (1) {
                                      break;
                                    }
                                    num_dnats ++;
                                  } else {
                                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"# of dnat exceed %d.\n",
                                            64);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  fclose(file);
  *proxy_count = count;
  proxychains_got_chain_data = 1;
  return;
}
}
static void simple_socks5_env(proxy_data *pd , unsigned int *proxy_count , chain_type *ct ) 
{ 
  char *port_string ;
  char *host_string ;
  in_addr_t tmp ;
  long tmp___0 ;
  char *tmp___1 ;

  {
  if (proxychains_got_chain_data) {
    return;
  }
  load_default_settings(ct);
  port_string = getenv("PROXYCHAINS_SOCKS5_PORT");
  if (! port_string) {
    return;
  }
  host_string = getenv("PROXYCHAINS_SOCKS5_HOST");
  if (! host_string) {
    host_string = (char *)"127.0.0.1";
  }
  memset((void *)pd, 0, sizeof(proxy_data ));
  (pd + 0)->ps = (proxy_state )0;
  tmp = inet_addr((char const   *)host_string);
  (pd + 0)->ip.as_int = tmp;
  tmp___0 = strtol((char const   * __restrict  )port_string, (char ** __restrict  )((void *)0),
                   0);
  (pd + 0)->port = __bswap_16((unsigned short )tmp___0);
  (pd + 0)->pt = (proxy_type )3;
  proxychains_max_chain = 1U;
  tmp___1 = getenv("PROXYCHAINS_DNS");
  if (tmp___1) {
    proxychains_resolver = 1;
  }
  *proxy_count = 1U;
  proxychains_got_chain_data = 1;
  return;
}
}
int connect(int sock , struct sockaddr  const  * __restrict  addr , socklen_t len ) 
{ 
  int socktype ;
  int flags ;
  int ret ;
  socklen_t optlen ;
  ip_type dest_ip ;
  struct in_addr *p_addr_in ;
  struct sockaddr_in new_addr ;
  dnat_arg *dnat ;
  unsigned short port ;
  size_t i ;
  int remote_dns_connect ;
  int tmp ;
  __uint32_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  socktype = 0;
  flags = 0;
  ret = 0;
  optlen = (socklen_t )0;
  dnat = (dnat_arg *)((void *)0);
  remote_dns_connect = 0;
  init_lib_wrapper("connect");
  optlen = (socklen_t )sizeof(socktype);
  getsockopt(sock, 1, 3, (void * __restrict  )(& socktype), (socklen_t * __restrict  )(& optlen));
  if ((int )((struct sockaddr_in *)addr)->sin_family == 2) {
    if (! (socktype == 1)) {
      tmp = (*true_connect)(sock, (struct sockaddr  const  *)addr, len);
      return (tmp);
    }
  } else {
    tmp = (*true_connect)(sock, (struct sockaddr  const  *)addr, len);
    return (tmp);
  }
  p_addr_in = & ((struct sockaddr_in *)addr)->sin_addr;
  port = __bswap_16(((struct sockaddr_in *)addr)->sin_port);
  tmp___0 = __bswap_32(p_addr_in->s_addr);
  remote_dns_connect = tmp___0 >> 24 == remote_dns_subnet;
  i = (size_t )0;
  while (1) {
    if (i < num_dnats) {
      if (! remote_dns_connect) {
        if (! (! dnat)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    if (dnats[i].orig_dst.s_addr == p_addr_in->s_addr) {
      if (dnats[i].orig_port) {
        if ((int )dnats[i].orig_port == (int )port) {
          dnat = & dnats[i];
        }
      }
    }
    i ++;
  }
  i = (size_t )0;
  while (1) {
    if (i < num_dnats) {
      if (! remote_dns_connect) {
        if (! (! dnat)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    if (dnats[i].orig_dst.s_addr == p_addr_in->s_addr) {
      if (! dnats[i].orig_port) {
        dnat = & dnats[i];
      }
    }
    i ++;
  }
  if (dnat) {
    if (dnat->new_port) {
      new_addr.sin_port = __bswap_16(dnat->new_port);
    } else {
      new_addr.sin_port = __bswap_16(port);
    }
    new_addr.sin_addr = dnat->new_dst;
    addr = (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& new_addr));
    p_addr_in = & ((struct sockaddr_in *)addr)->sin_addr;
    port = __bswap_16(((struct sockaddr_in *)addr)->sin_port);
  }
  i = (size_t )0;
  while (1) {
    if (i < num_localnet_addr) {
      if (! (! remote_dns_connect)) {
        break;
      }
    } else {
      break;
    }
    if ((localnet_addr[i].in_addr.s_addr & localnet_addr[i].netmask.s_addr) == (p_addr_in->s_addr & localnet_addr[i].netmask.s_addr)) {
      if (! localnet_addr[i].port) {
        goto _L;
      } else
      if ((int )localnet_addr[i].port == (int )port) {
        _L: /* CIL Label */ 
        while (1) {
          break;
        }
        tmp___1 = (*true_connect)(sock, (struct sockaddr  const  *)addr, len);
        return (tmp___1);
      }
    }
    i ++;
  }
  flags = fcntl(sock, 3, 0);
  if (flags & 2048) {
    fcntl(sock, 4, 0);
  }
  dest_ip.as_int = ((struct sockaddr_in *)addr)->sin_addr.s_addr;
  ret = connect_proxy_chain(sock, dest_ip, ((struct sockaddr_in *)addr)->sin_port,
                            proxychains_pd, proxychains_proxy_count, proxychains_ct,
                            proxychains_max_chain);
  fcntl(sock, 4, flags);
  if (ret != 0) {
    tmp___2 = __errno_location();
    *tmp___2 = 111;
  }
  return (ret);
}
}
static struct gethostbyname_data ghbndata  ;
struct hostent *gethostbyname(char const   *name ) 
{ 
  struct hostent *tmp ;
  struct hostent *tmp___0 ;

  {
  init_lib_wrapper("gethostbyname");
  while (1) {
    break;
  }
  if (proxychains_resolver) {
    tmp = proxy_gethostbyname(name, & ghbndata);
    return (tmp);
  } else {
    tmp___0 = (*true_gethostbyname)(name);
    return (tmp___0);
  }
  return ((struct hostent *)((void *)0));
}
}
int getaddrinfo(char const   * __restrict  node , char const   * __restrict  service ,
                struct addrinfo  const  * __restrict  hints , struct addrinfo ** __restrict  res ) 
{ 
  int ret ;

  {
  ret = 0;
  init_lib_wrapper("getaddrinfo");
  while (1) {
    break;
  }
  if (proxychains_resolver) {
    ret = proxy_getaddrinfo((char const   *)node, (char const   *)service, (struct addrinfo  const  *)hints,
                            (struct addrinfo **)res);
  } else {
    ret = (*true_getaddrinfo)((char const   *)node, (char const   *)service, (struct addrinfo  const  *)hints,
                              (struct addrinfo **)res);
  }
  return (ret);
}
}
 __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *res ) ;
void freeaddrinfo(struct addrinfo *res ) 
{ 


  {
  init_lib_wrapper("freeaddrinfo");
  while (1) {
    break;
  }
  if (! proxychains_resolver) {
    (*true_freeaddrinfo)(res);
  } else {
    proxy_freeaddrinfo(res);
  }
  return;
}
}
int getnameinfo(struct sockaddr  const  * __restrict  sa , socklen_t salen , char * __restrict  host ,
                socklen_t hostlen , char * __restrict  serv , socklen_t servlen ,
                int flags ) 
{ 
  char ip_buf[16] ;
  int ret ;
  __uint16_t tmp ;

  {
  ret = 0;
  init_lib_wrapper("getnameinfo");
  while (1) {
    break;
  }
  if (! proxychains_resolver) {
    ret = (*true_getnameinfo)((struct sockaddr  const  *)sa, salen, (char *)host,
                              hostlen, (char *)serv, servlen, flags);
  } else {
    if (hostlen) {
      inet_ntop(2, (void const   * __restrict  )((unsigned char *)(& ((struct sockaddr_in *)sa)->sin_addr)),
                (char * __restrict  )(ip_buf), (socklen_t )sizeof(ip_buf));
      strncpy(host, (char const   * __restrict  )(ip_buf), (size_t )hostlen);
    }
    if (servlen) {
      tmp = __bswap_16(((struct sockaddr_in *)sa)->sin_port);
      snprintf(serv, (size_t )servlen, (char const   * __restrict  )"%d", (int )tmp);
    }
  }
  return (ret);
}
}
static char buf[16]  ;
static char ipv4[4]  ;
static char *list[2]  ;
static struct hostent he  ;
struct hostent *gethostbyaddr(void const   *addr , __socklen_t len , int type ) 
{ 
  struct hostent *tmp ;

  {
  init_lib_wrapper("gethostbyaddr");
  while (1) {
    break;
  }
  if (! proxychains_resolver) {
    tmp = (*true_gethostbyaddr)(addr, len, type);
    return (tmp);
  } else {
    while (1) {
      break;
    }
    if (len != 4U) {
      return ((struct hostent *)((void *)0));
    }
    he.h_name = buf;
    memcpy((void * __restrict  )(ipv4), (void const   * __restrict  )addr, (size_t )4);
    list[0] = ipv4;
    list[1] = (char *)((void *)0);
    he.h_addr_list = list;
    he.h_addrtype = 2;
    he.h_aliases = (char **)((void *)0);
    he.h_length = 4;
    inet_ntop(2, (void const   * __restrict  )addr, (char * __restrict  )(buf), (socklen_t )sizeof(buf));
    return (& he);
  }
  return ((struct hostent *)((void *)0));
}
}
